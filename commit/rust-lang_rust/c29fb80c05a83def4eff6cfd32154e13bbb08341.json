{"sha": "c29fb80c05a83def4eff6cfd32154e13bbb08341", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyOWZiODBjMDVhODNkZWY0ZWZmNmNmZDMyMTU0ZTEzYmJiMDgzNDE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-09-26T10:11:34Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-10-05T07:40:52Z"}, "message": "Reapply the derive helper changes from master", "tree": {"sha": "c10bad46506b4add06e7d21a33827b64f0770561", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c10bad46506b4add06e7d21a33827b64f0770561"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c29fb80c05a83def4eff6cfd32154e13bbb08341", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c29fb80c05a83def4eff6cfd32154e13bbb08341", "html_url": "https://github.com/rust-lang/rust/commit/c29fb80c05a83def4eff6cfd32154e13bbb08341", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c29fb80c05a83def4eff6cfd32154e13bbb08341/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8994c6d417e25eba3cd077c0dce5760cfd05d576", "url": "https://api.github.com/repos/rust-lang/rust/commits/8994c6d417e25eba3cd077c0dce5760cfd05d576", "html_url": "https://github.com/rust-lang/rust/commit/8994c6d417e25eba3cd077c0dce5760cfd05d576"}], "stats": {"total": 75, "additions": 38, "deletions": 37}, "files": [{"sha": "54eb27d4f39f52fc13030b14ca66900808975471", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/c29fb80c05a83def4eff6cfd32154e13bbb08341/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c29fb80c05a83def4eff6cfd32154e13bbb08341/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=c29fb80c05a83def4eff6cfd32154e13bbb08341", "patch": "@@ -554,35 +554,35 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         //    (open, not controlled).\n         // 3. Standard library prelude (de-facto closed, controlled).\n         // (Macro NS)\n-        // 1-2. `macro_rules` (open, not controlled), loop through legacy scopes. Have higher\n+        // 1-3. Derive helpers (open, not controlled). All ambiguities with other names\n+        //    are currently reported as errors. They should be higher in priority than preludes\n+        //    and probably even names in modules according to the \"general principles\" above. They\n+        //    also should be subject to restricted shadowing because are effectively produced by\n+        //    derives (you need to resolve the derive first to add helpers into scope), but they\n+        //    should be available before the derive is expanded for compatibility.\n+        //    It's mess in general, so we are being conservative for now.\n+        // 1-3. `macro_rules` (open, not controlled), loop through legacy scopes. Have higher\n         //    priority than prelude macros, but create ambiguities with macros in modules.\n-        // 1-2. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n+        // 1-3. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n         //    (open, not controlled). Have higher priority than prelude macros, but create\n         //    ambiguities with `macro_rules`.\n-        // 3. `macro_use` prelude (open, the open part is from macro expansions, not controlled).\n-        // 3a. User-defined prelude from macro-use\n+        // 4. `macro_use` prelude (open, the open part is from macro expansions, not controlled).\n+        // 4a. User-defined prelude from macro-use\n         //    (open, the open part is from macro expansions, not controlled).\n-        // 3b. Standard library prelude is currently implemented as `macro-use` (closed, controlled)\n+        // 4b. Standard library prelude is currently implemented as `macro-use` (closed, controlled)\n         // 5. Language prelude: builtin macros (closed, controlled, except for legacy plugins).\n         // 6. Language prelude: builtin attributes (closed, controlled).\n-        // 3-6. Legacy plugin helpers (open, not controlled). Similar to derive helpers,\n+        // 4-6. Legacy plugin helpers (open, not controlled). Similar to derive helpers,\n         //    but introduced by legacy plugins using `register_attribute`. Priority is somewhere\n         //    in prelude, not sure where exactly (creates ambiguities with any other prelude names).\n-        // N (unordered). Derive helpers (open, not controlled). All ambiguities with other names\n-        //    are currently reported as errors. They should be higher in priority than preludes\n-        //    and maybe even names in modules according to the \"general principles\" above. They\n-        //    also should be subject to restricted shadowing because are effectively produced by\n-        //    derives (you need to resolve the derive first to add helpers into scope), but they\n-        //    should be available before the derive is expanded for compatibility.\n-        //    It's mess in general, so we are being conservative for now.\n \n         enum WhereToResolve<'a> {\n+            DeriveHelpers,\n             MacroRules(LegacyScope<'a>),\n             Module(Module<'a>),\n             MacroUsePrelude,\n             BuiltinMacros,\n             BuiltinAttrs,\n-            DeriveHelpers,\n             LegacyPluginHelpers,\n             ExternPrelude,\n             ToolPrelude,\n@@ -616,10 +616,30 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         let mut innermost_result: Option<(&NameBinding, Flags, /* conflicts with */ Flags)> = None;\n \n         // Go through all the scopes and try to resolve the name.\n-        let mut where_to_resolve = WhereToResolve::MacroRules(parent_scope.legacy);\n+        let mut where_to_resolve = WhereToResolve::DeriveHelpers;\n         let mut use_prelude = !parent_scope.module.no_implicit_prelude;\n         loop {\n             let result = match where_to_resolve {\n+                WhereToResolve::DeriveHelpers => {\n+                    let mut result = Err(Determinacy::Determined);\n+                    for derive in &parent_scope.derives {\n+                        let parent_scope = ParentScope { derives: Vec::new(), ..*parent_scope };\n+                        if let Ok((_, ext)) = self.resolve_macro_to_def(derive, MacroKind::Derive,\n+                                                                        &parent_scope, force) {\n+                            if let SyntaxExtension::ProcMacroDerive(_, helper_attrs, _) = &*ext {\n+                                if helper_attrs.contains(&ident.name) {\n+                                    let binding =\n+                                        (Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n+                                        ty::Visibility::Public, derive.span, Mark::root())\n+                                        .to_name_binding(self.arenas);\n+                                    result = Ok((binding, Flags::DERIVE_HELPERS, Flags::all()));\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    }\n+                    result\n+                }\n                 WhereToResolve::MacroRules(legacy_scope) => match legacy_scope {\n                     LegacyScope::Binding(legacy_binding) if ident == legacy_binding.ident =>\n                         Ok((legacy_binding.binding, Flags::MACRO_RULES, Flags::MODULE)),\n@@ -660,26 +680,6 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         Err(Determinacy::Determined)\n                     }\n                 }\n-                WhereToResolve::DeriveHelpers => {\n-                    let mut result = Err(Determinacy::Determined);\n-                    for derive in &parent_scope.derives {\n-                        let parent_scope = ParentScope { derives: Vec::new(), ..*parent_scope };\n-                        if let Ok((_, ext)) = self.resolve_macro_to_def(derive, MacroKind::Derive,\n-                                                                        &parent_scope, force) {\n-                            if let SyntaxExtension::ProcMacroDerive(_, helper_attrs, _) = &*ext {\n-                                if helper_attrs.contains(&ident.name) {\n-                                    let binding =\n-                                        (Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n-                                        ty::Visibility::Public, derive.span, Mark::root())\n-                                        .to_name_binding(self.arenas);\n-                                    result = Ok((binding, Flags::DERIVE_HELPERS, Flags::all()));\n-                                    break;\n-                                }\n-                            }\n-                        }\n-                    }\n-                    result\n-                }\n                 WhereToResolve::LegacyPluginHelpers => {\n                     if self.session.plugin_attributes.borrow().iter()\n                                                      .any(|(name, _)| ident.name == &**name) {\n@@ -747,6 +747,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n             macro_rules! continue_search { () => {\n                 where_to_resolve = match where_to_resolve {\n+                    WhereToResolve::DeriveHelpers =>\n+                        WhereToResolve::MacroRules(parent_scope.legacy),\n                     WhereToResolve::MacroRules(legacy_scope) => match legacy_scope {\n                         LegacyScope::Binding(binding) =>\n                             WhereToResolve::MacroRules(binding.parent_legacy_scope),\n@@ -770,8 +772,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     }\n                     WhereToResolve::MacroUsePrelude => WhereToResolve::BuiltinMacros,\n                     WhereToResolve::BuiltinMacros => WhereToResolve::BuiltinAttrs,\n-                    WhereToResolve::BuiltinAttrs => WhereToResolve::DeriveHelpers,\n-                    WhereToResolve::DeriveHelpers => WhereToResolve::LegacyPluginHelpers,\n+                    WhereToResolve::BuiltinAttrs => WhereToResolve::LegacyPluginHelpers,\n                     WhereToResolve::LegacyPluginHelpers => break, // nowhere else to search\n                     WhereToResolve::ExternPrelude => WhereToResolve::ToolPrelude,\n                     WhereToResolve::ToolPrelude => WhereToResolve::StdLibPrelude,"}]}