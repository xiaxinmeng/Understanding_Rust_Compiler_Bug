{"sha": "6603299f3f9f7fccde7dacbfd93e3cedd7e30e75", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MDMyOTlmM2Y5ZjdmY2NkZTdkYWNiZmQ5M2UzY2VkZDdlMzBlNzU=", "commit": {"author": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-12T18:13:14Z"}, "committer": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-13T04:35:40Z"}, "message": "lifetimes lint: straighten some code, add a few comments", "tree": {"sha": "463914b67a588c95252b1f194a366797e7a5250f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/463914b67a588c95252b1f194a366797e7a5250f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6603299f3f9f7fccde7dacbfd93e3cedd7e30e75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6603299f3f9f7fccde7dacbfd93e3cedd7e30e75", "html_url": "https://github.com/rust-lang/rust/commit/6603299f3f9f7fccde7dacbfd93e3cedd7e30e75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6603299f3f9f7fccde7dacbfd93e3cedd7e30e75/comments", "author": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b349f9e88dfd5269af69ef3096dabb71742a9737", "url": "https://api.github.com/repos/rust-lang/rust/commits/b349f9e88dfd5269af69ef3096dabb71742a9737", "html_url": "https://github.com/rust-lang/rust/commit/b349f9e88dfd5269af69ef3096dabb71742a9737"}], "stats": {"total": 48, "additions": 28, "deletions": 20}, "files": [{"sha": "83f6d0eecdbfe1a0af76a44d28ed619bb080c2d0", "filename": "src/lifetimes.rs", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6603299f3f9f7fccde7dacbfd93e3cedd7e30e75/src%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6603299f3f9f7fccde7dacbfd93e3cedd7e30e75/src%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flifetimes.rs?ref=6603299f3f9f7fccde7dacbfd93e3cedd7e30e75", "patch": "@@ -2,7 +2,7 @@ use syntax::ast::*;\n use rustc::lint::{Context, LintPass, LintArray, Lint};\n use syntax::codemap::Span;\n use syntax::visit::{Visitor, FnKind, walk_ty};\n-use utils::{in_macro, span_lint};\n+use utils::{in_external_macro, span_lint};\n use std::collections::HashSet;\n use std::iter::FromIterator;\n \n@@ -19,16 +19,17 @@ impl LintPass for LifetimePass {\n \n     fn check_fn(&mut self, cx: &Context, kind: FnKind, decl: &FnDecl,\n                 _: &Block, span: Span, _: NodeId) {\n-        if cx.sess().codemap().with_expn_info(span.expn_id, |info| in_macro(cx, info)) {\n+        if in_external_macro(cx, span) {\n             return;\n         }\n         if could_use_elision(kind, decl) {\n             span_lint(cx, NEEDLESS_LIFETIMES, span,\n-                      \"explicit lifetimes given where they could be inferred\");\n+                      \"explicit lifetimes given in parameter types where they could be elided\");\n         }\n     }\n }\n \n+/// The lifetime of a &-reference.\n #[derive(PartialEq, Eq, Hash, Debug)]\n enum RefLt {\n     Unnamed,\n@@ -42,24 +43,24 @@ fn could_use_elision(kind: FnKind, func: &FnDecl) -> bool {\n     // * no output references, all input references have different LT\n     // * output references, exactly one input reference with same LT\n \n+    // these will collect all the lifetimes for references in arg/return types\n     let mut input_visitor = RefVisitor(Vec::new());\n     let mut output_visitor = RefVisitor(Vec::new());\n \n-    // extract lifetimes of input argument types\n-    for arg in &func.inputs {\n-        walk_ty(&mut input_visitor, &*arg.ty);\n-    }\n-    // extract lifetime of \"self\" argument for methods\n+    // extract lifetime in \"self\" argument for methods (there is a \"self\" argument\n+    // in func.inputs, but its type is TyInfer)\n     if let FnKind::FkMethod(_, sig, _) = kind {\n         match sig.explicit_self.node {\n-            SelfRegion(ref lt_opt, _, _) =>\n-                input_visitor.visit_opt_lifetime_ref(sig.explicit_self.span, lt_opt),\n-            SelfExplicit(ref ty, _) =>\n-                walk_ty(&mut input_visitor, ty),\n+            SelfRegion(ref opt_lt, _, _) => input_visitor.record(opt_lt),\n+            SelfExplicit(ref ty, _) => walk_ty(&mut input_visitor, ty),\n             _ => { }\n         }\n     }\n-    // extract lifetimes of output type\n+    // extract lifetimes in input argument types\n+    for arg in &func.inputs {\n+        walk_ty(&mut input_visitor, &*arg.ty);\n+    }\n+    // extract lifetimes in output type\n     if let Return(ref ty) = func.output {\n         walk_ty(&mut output_visitor, ty);\n     }\n@@ -100,19 +101,16 @@ fn could_use_elision(kind: FnKind, func: &FnDecl) -> bool {\n     false\n }\n \n+/// Number of unique lifetimes in the given vector.\n fn unique_lifetimes(lts: &Vec<RefLt>) -> usize {\n-    let set: HashSet<&RefLt> = HashSet::from_iter(lts.iter());\n-    set.len()\n+    lts.iter().collect::<HashSet<_>>().len()\n }\n \n+/// A visitor usable for syntax::visit::walk_ty().\n struct RefVisitor(Vec<RefLt>);\n \n impl RefVisitor {\n-    fn into_vec(self) -> Vec<RefLt> { self.0 }\n-}\n-\n-impl<'v> Visitor<'v> for RefVisitor {\n-    fn visit_opt_lifetime_ref(&mut self, _: Span, lifetime: &'v Option<Lifetime>) {\n+    fn record(&mut self, lifetime: &Option<Lifetime>) {\n         if let &Some(ref lt) = lifetime {\n             if lt.name.as_str() == \"'static\" {\n                 self.0.push(Static);\n@@ -123,4 +121,14 @@ impl<'v> Visitor<'v> for RefVisitor {\n             self.0.push(Unnamed);\n         }\n     }\n+\n+    fn into_vec(self) -> Vec<RefLt> {\n+        self.0\n+    }\n+}\n+\n+impl<'v> Visitor<'v> for RefVisitor {\n+    fn visit_opt_lifetime_ref(&mut self, _: Span, lifetime: &'v Option<Lifetime>) {\n+        self.record(lifetime);\n+    }\n }"}]}