{"sha": "977ce57d915914139c4aa643e63f368913e5f437", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3N2NlNTdkOTE1OTE0MTM5YzRhYTY0M2U2M2YzNjg5MTNlNWY0Mzc=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-06-23T06:31:41Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-06-23T06:50:30Z"}, "message": "Updated query for num_counters to compute from max index\n\nAlso added FIXME comments to note the possible need to accommodate\ncounter increment calls in source-based functions that differ from the\nfunction context of the caller instance (e.g., inline functions).", "tree": {"sha": "2a66c67004ce3486958d045ebd0b9f7edf038c26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a66c67004ce3486958d045ebd0b9f7edf038c26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/977ce57d915914139c4aa643e63f368913e5f437", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/977ce57d915914139c4aa643e63f368913e5f437", "html_url": "https://github.com/rust-lang/rust/commit/977ce57d915914139c4aa643e63f368913e5f437", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/977ce57d915914139c4aa643e63f368913e5f437/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a04514026824f9342ab93d9b608e3ec5dab53dad", "url": "https://api.github.com/repos/rust-lang/rust/commits/a04514026824f9342ab93d9b608e3ec5dab53dad", "html_url": "https://github.com/rust-lang/rust/commit/a04514026824f9342ab93d9b608e3ec5dab53dad"}], "stats": {"total": 31, "additions": 27, "deletions": 4}, "files": [{"sha": "dfe97b1ee2e9de80184c51a559dd5ba5ac7bc180", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/977ce57d915914139c4aa643e63f368913e5f437/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/977ce57d915914139c4aa643e63f368913e5f437/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=977ce57d915914139c4aa643e63f368913e5f437", "patch": "@@ -140,6 +140,9 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 self.call(llfn, &[], None)\n             }\n             \"count_code_region\" => {\n+                // FIXME(richkadel): The current implementation assumes the MIR for the given\n+                // caller_instance represents a single function. Validate and/or correct if inlining\n+                // and/or monomorphization invalidates these assumptions.\n                 let coverage_data = tcx.coverage_data(caller_instance.def_id());\n                 let mangled_fn = tcx.symbol_name(caller_instance);\n                 let (mangled_fn_name, _len_val) = self.const_str(mangled_fn.name);"}, {"sha": "06b648ab5a908dd3710b02d5cbdde751cfdf4c11", "filename": "src/librustc_mir/transform/instrument_coverage.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/977ce57d915914139c4aa643e63f368913e5f437/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/977ce57d915914139c4aa643e63f368913e5f437/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs?ref=977ce57d915914139c4aa643e63f368913e5f437", "patch": "@@ -5,15 +5,15 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::lang_items;\n use rustc_middle::hir;\n use rustc_middle::ich::StableHashingContext;\n-use rustc_middle::mir::interpret::Scalar;\n+use rustc_middle::mir::interpret::{ConstValue, Scalar};\n use rustc_middle::mir::{\n     self, traversal, BasicBlock, BasicBlockData, CoverageData, Operand, Place, SourceInfo,\n     StatementKind, Terminator, TerminatorKind, START_BLOCK,\n };\n use rustc_middle::ty;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::FnDef;\n use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{ConstKind, FnDef};\n use rustc_span::def_id::DefId;\n use rustc_span::Span;\n \n@@ -26,16 +26,36 @@ pub struct InstrumentCoverage;\n pub(crate) fn provide(providers: &mut Providers<'_>) {\n     providers.coverage_data = |tcx, def_id| {\n         let mir_body = tcx.optimized_mir(def_id);\n+        // FIXME(richkadel): The current implementation assumes the MIR for the given DefId\n+        // represents a single function. Validate and/or correct if inlining and/or monomorphization\n+        // invalidates these assumptions.\n         let count_code_region_fn =\n             tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None);\n         let mut num_counters: u32 = 0;\n+        // The `num_counters` argument to `llvm.instrprof.increment` is the number of injected\n+        // counters, with each counter having an index from `0..num_counters-1`. MIR optimization\n+        // may split and duplicate some BasicBlock sequences. Simply counting the calls may not\n+        // not work; but computing the num_counters by adding `1` to the highest index (for a given\n+        // instrumented function) is valid.\n         for (_, data) in traversal::preorder(mir_body) {\n             if let Some(terminator) = &data.terminator {\n-                if let TerminatorKind::Call { func: Operand::Constant(func), .. } = &terminator.kind\n+                if let TerminatorKind::Call { func: Operand::Constant(func), args, .. } =\n+                    &terminator.kind\n                 {\n                     if let FnDef(called_fn_def_id, _) = func.literal.ty.kind {\n                         if called_fn_def_id == count_code_region_fn {\n-                            num_counters += 1;\n+                            if let Operand::Constant(constant) =\n+                                args.get(0).expect(\"count_code_region has at least one arg\")\n+                            {\n+                                if let ConstKind::Value(ConstValue::Scalar(value)) =\n+                                    constant.literal.val\n+                                {\n+                                    let index = value\n+                                        .to_u32()\n+                                        .expect(\"count_code_region index at arg0 is u32\");\n+                                    num_counters = std::cmp::max(num_counters, index + 1);\n+                                }\n+                            }\n                         }\n                     }\n                 }"}]}