{"sha": "847c5e4e9892ef56873ac52a552997267c4d385a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0N2M1ZTRlOTg5MmVmNTY4NzNhYzUyYTU1Mjk5NzI2N2M0ZDM4NWE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-06-08T03:12:05Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-06-08T03:12:05Z"}, "message": "syntax: Remove a bunch of implicit copies", "tree": {"sha": "7b374454400211b9ac1fda8cb4cc1630d9cbba1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b374454400211b9ac1fda8cb4cc1630d9cbba1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/847c5e4e9892ef56873ac52a552997267c4d385a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/847c5e4e9892ef56873ac52a552997267c4d385a", "html_url": "https://github.com/rust-lang/rust/commit/847c5e4e9892ef56873ac52a552997267c4d385a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/847c5e4e9892ef56873ac52a552997267c4d385a/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b", "html_url": "https://github.com/rust-lang/rust/commit/7ef825bb607c4e934c92bd0b73ecbc4c24f3286b"}], "stats": {"total": 140, "additions": 80, "deletions": 60}, "files": [{"sha": "b0cb1d22cf745c86132f5905a23b43fcccb58755", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/847c5e4e9892ef56873ac52a552997267c4d385a/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847c5e4e9892ef56873ac52a552997267c4d385a/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=847c5e4e9892ef56873ac52a552997267c4d385a", "patch": "@@ -12,16 +12,16 @@ type path = [path_elt];\n fn path_to_str_with_sep(p: path, sep: str) -> str {\n     let strs = vec::map(p) {|e|\n         alt e {\n-          path_mod(s) { s }\n-          path_name(s) { s }\n+          path_mod(s) { /* FIXME: bad */ copy s }\n+          path_name(s) { /* FIXME: bad */ copy s }\n         }\n     };\n     str::connect(strs, sep)\n }\n \n fn path_ident_to_str(p: path, i: ident) -> str {\n     if vec::is_empty(p) {\n-        i\n+        /* FIXME: bad */ copy i\n     } else {\n         #fmt[\"%s::%s\", path_to_str(p), i]\n     }\n@@ -59,7 +59,7 @@ type ctx = {map: map, mut path: path,\n             mut local_id: uint, diag: span_handler};\n type vt = visit::vt<ctx>;\n \n-fn extend(cx: ctx, elt: str) -> @path {\n+fn extend(cx: ctx, +elt: str) -> @path {\n     @(cx.path + [path_name(elt)])\n }\n \n@@ -89,15 +89,15 @@ fn map_crate(diag: span_handler, c: crate) -> map {\n // crate.  The `path` should be the path to the item but should not include\n // the item itself.\n fn map_decoded_item(diag: span_handler,\n-                    map: map, path: path, ii: inlined_item) {\n+                    map: map, +path: path, ii: inlined_item) {\n     // I believe it is ok for the local IDs of inlined items from other crates\n     // to overlap with the local ids from this crate, so just generate the ids\n     // starting from 0.  (In particular, I think these ids are only used in\n     // alias analysis, which we will not be running on the inlined items, and\n     // even if we did I think it only needs an ordering between local\n     // variables that are simultaneously in scope).\n     let cx = {map: map,\n-              mut path: path,\n+              mut path: /* FIXME: bad */ copy path,\n               mut local_id: 0u,\n               diag: diag};\n     let v = mk_ast_map_visitor();\n@@ -128,11 +128,13 @@ fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     }\n     alt fk {\n       visit::fk_ctor(nm, tps, self_id, parent_id) {\n-          let ct = @{node: {id: id, self_id: self_id,\n-                           dec: decl, body: body},\n+          let ct = @{node: {id: id,\n+                            self_id: self_id,\n+                            dec: /* FIXME: bad */ copy decl,\n+                            body: /* FIXME: bad */ copy body},\n                     span: sp};\n-          cx.map.insert(id, node_ctor(nm, tps, class_ctor(ct, parent_id),\n-                                      @cx.path));\n+          cx.map.insert(id, node_ctor(/* FIXME: bad */ copy nm, tps,\n+                                      class_ctor(ct, parent_id), @cx.path));\n        }\n       visit::fk_dtor(tps, self_id, parent_id) {\n           let dt = @{node: {id: id, self_id: self_id, body: body},"}, {"sha": "c81f6d9590fcbb1ee4999609f5cc685a5609f4c5", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/847c5e4e9892ef56873ac52a552997267c4d385a/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847c5e4e9892ef56873ac52a552997267c4d385a/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=847c5e4e9892ef56873ac52a552997267c4d385a", "patch": "@@ -156,7 +156,7 @@ fn is_exported(i: ident, m: _mod) -> bool {\n             for variants.each {|v|\n                 if v.node.name == i {\n                    local = true;\n-                   parent_enum = some(it.ident);\n+                   parent_enum = some(/* FIXME: bad */ copy it.ident);\n                 }\n             }\n           }\n@@ -247,12 +247,12 @@ fn block_from_expr(e: @expr) -> blk {\n     ret {node: blk_, span: e.span};\n }\n \n-fn default_block(stmts1: [@stmt], expr1: option<@expr>, id1: node_id) ->\n+fn default_block(+stmts1: [@stmt], expr1: option<@expr>, id1: node_id) ->\n    blk_ {\n     {view_items: [], stmts: stmts1, expr: expr1, id: id1, rules: default_blk}\n }\n \n-fn ident_to_path(s: span, i: ident) -> @path {\n+fn ident_to_path(s: span, +i: ident) -> @path {\n     @{span: s, global: false, idents: [i],\n       rp: none, types: []}\n }\n@@ -265,7 +265,7 @@ pure fn is_unguarded(&&a: arm) -> bool {\n }\n \n pure fn unguarded_pat(a: arm) -> option<[@pat]> {\n-    if is_unguarded(a) { some(a.pats) } else { none }\n+    if is_unguarded(a) { some(/* FIXME: bad */ copy a.pats) } else { none }\n }\n \n // Provides an extra node_id to hang callee information on, in case the\n@@ -275,8 +275,8 @@ fn op_expr_callee_id(e: @expr) -> node_id { e.id - 1 }\n \n pure fn class_item_ident(ci: @class_member) -> ident {\n     alt ci.node {\n-      instance_var(i,_,_,_,_) { i }\n-      class_method(it) { it.ident }\n+      instance_var(i,_,_,_,_) { /* FIXME: bad */ copy i }\n+      class_method(it) { /* FIXME: bad */ copy it.ident }\n     }\n }\n \n@@ -294,7 +294,11 @@ fn split_class_items(cs: [@class_member]) -> ([ivar], [@method]) {\n     for cs.each {|c|\n       alt c.node {\n         instance_var(i, t, cm, id, vis) {\n-          vs += [{ident: i, ty: t, cm: cm, id: id, vis: vis}];\n+          vs += [{ident: /* FIXME: bad */ copy i,\n+                  ty: t,\n+                  cm: cm,\n+                  id: id,\n+                  vis: vis}];\n         }\n         class_method(m) { ms += [m]; }\n       }\n@@ -312,10 +316,10 @@ pure fn class_member_visibility(ci: @class_member) -> visibility {\n impl inlined_item_methods for inlined_item {\n     fn ident() -> ident {\n         alt self {\n-          ii_item(i) { i.ident }\n-          ii_native(i) { i.ident }\n-          ii_method(_, m) { m.ident }\n-          ii_ctor(_, nm, _, _) { nm }\n+          ii_item(i) { /* FIXME: bad */ copy i.ident }\n+          ii_native(i) { /* FIXME: bad */ copy i.ident }\n+          ii_method(_, m) { /* FIXME: bad */ copy m.ident }\n+          ii_ctor(_, nm, _, _) { /* FIXME: bad */ copy nm }\n         }\n     }\n "}, {"sha": "204973ade02d9ebc38997d0a2bac4bfbc744e25f", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 40, "deletions": 30, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/847c5e4e9892ef56873ac52a552997267c4d385a/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847c5e4e9892ef56873ac52a552997267c4d385a/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=847c5e4e9892ef56873ac52a552997267c4d385a", "patch": "@@ -46,21 +46,21 @@ export require_unique_names;\n \n /* Constructors */\n \n-fn mk_name_value_item_str(name: ast::ident, value: str) -> @ast::meta_item {\n+fn mk_name_value_item_str(+name: ast::ident, +value: str) -> @ast::meta_item {\n     let value_lit = dummy_spanned(ast::lit_str(value));\n     ret mk_name_value_item(name, value_lit);\n }\n \n-fn mk_name_value_item(name: ast::ident, value: ast::lit) -> @ast::meta_item {\n+fn mk_name_value_item(+name: ast::ident, +value: ast::lit) -> @ast::meta_item {\n     ret @dummy_spanned(ast::meta_name_value(name, value));\n }\n \n-fn mk_list_item(name: ast::ident, items: [@ast::meta_item]) ->\n+fn mk_list_item(+name: ast::ident, +items: [@ast::meta_item]) ->\n    @ast::meta_item {\n     ret @dummy_spanned(ast::meta_list(name, items));\n }\n \n-fn mk_word_item(name: ast::ident) -> @ast::meta_item {\n+fn mk_word_item(+name: ast::ident) -> @ast::meta_item {\n     ret @dummy_spanned(ast::meta_word(name));\n }\n \n@@ -89,9 +89,9 @@ fn get_attr_name(attr: ast::attribute) -> ast::ident {\n \n fn get_meta_item_name(meta: @ast::meta_item) -> ast::ident {\n     alt meta.node {\n-      ast::meta_word(n) { n }\n-      ast::meta_name_value(n, _) { n }\n-      ast::meta_list(n, _) { n }\n+      ast::meta_word(n) { /* FIXME bad */ copy n }\n+      ast::meta_name_value(n, _) { /* FIXME bad */ copy n }\n+      ast::meta_list(n, _) { /* FIXME bad */ copy n }\n     }\n }\n \n@@ -102,7 +102,14 @@ containing a string, otherwise none\n fn get_meta_item_value_str(meta: @ast::meta_item) -> option<str> {\n     alt meta.node {\n       ast::meta_name_value(_, v) {\n-        alt v.node { ast::lit_str(s) { option::some(s) } _ { option::none } }\n+        alt v.node {\n+            ast::lit_str(s) {\n+                option::some(/* FIXME bad */ copy s)\n+            }\n+            _ {\n+                option::none\n+            }\n+        }\n       }\n       _ { option::none }\n     }\n@@ -111,7 +118,7 @@ fn get_meta_item_value_str(meta: @ast::meta_item) -> option<str> {\n #[doc = \"Gets a list of inner meta items from a list meta_item type\"]\n fn get_meta_item_list(meta: @ast::meta_item) -> option<[@ast::meta_item]> {\n     alt meta.node {\n-      ast::meta_list(_, l) { option::some(l) }\n+      ast::meta_list(_, l) { option::some(/* FIXME bad */ copy l) }\n       _ { option::none }\n     }\n }\n@@ -126,7 +133,7 @@ fn get_name_value_str_pair(\n     alt attr::get_meta_item_value_str(item) {\n       some(value) {\n         let name = attr::get_meta_item_name(item);\n-        some((name, value))\n+        some((name, /* FIXME bad */ copy value))\n       }\n       none { none }\n     }\n@@ -138,7 +145,7 @@ fn get_name_value_str_pair(\n #[doc = \"\n Search a list of attributes and return only those with a specific name\n \"]\n-fn find_attrs_by_name(attrs: [ast::attribute], name: ast::ident) ->\n+fn find_attrs_by_name(attrs: [ast::attribute], +name: ast::ident) ->\n    [ast::attribute] {\n     let filter = (\n         fn@(a: ast::attribute) -> option<ast::attribute> {\n@@ -153,7 +160,7 @@ fn find_attrs_by_name(attrs: [ast::attribute], name: ast::ident) ->\n #[doc = \"\n Searcha list of meta items and return only those with a specific name\n \"]\n-fn find_meta_items_by_name(metas: [@ast::meta_item], name: ast::ident) ->\n+fn find_meta_items_by_name(metas: [@ast::meta_item], +name: ast::ident) ->\n    [@ast::meta_item] {\n     let filter = fn@(&&m: @ast::meta_item) -> option<@ast::meta_item> {\n         if get_meta_item_name(m) == name {\n@@ -201,16 +208,16 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n         }\n }\n \n-fn contains_name(metas: [@ast::meta_item], name: ast::ident) -> bool {\n+fn contains_name(metas: [@ast::meta_item], +name: ast::ident) -> bool {\n     let matches = find_meta_items_by_name(metas, name);\n     ret vec::len(matches) > 0u;\n }\n \n-fn attrs_contains_name(attrs: [ast::attribute], name: ast::ident) -> bool {\n+fn attrs_contains_name(attrs: [ast::attribute], +name: ast::ident) -> bool {\n     vec::is_not_empty(find_attrs_by_name(attrs, name))\n }\n \n-fn first_attr_value_str_by_name(attrs: [ast::attribute], name: ast::ident)\n+fn first_attr_value_str_by_name(attrs: [ast::attribute], +name: ast::ident)\n     -> option<str> {\n     let mattrs = find_attrs_by_name(attrs, name);\n     if vec::len(mattrs) > 0u {\n@@ -221,20 +228,20 @@ fn first_attr_value_str_by_name(attrs: [ast::attribute], name: ast::ident)\n \n fn last_meta_item_by_name(\n     items: [@ast::meta_item],\n-    name: str\n+    +name: str\n ) -> option<@ast::meta_item> {\n     let items = attr::find_meta_items_by_name(items, name);\n     vec::last_opt(items)\n }\n \n fn last_meta_item_value_str_by_name(\n     items: [@ast::meta_item],\n-    name: str\n+    +name: str\n ) -> option<str> {\n     alt last_meta_item_by_name(items, name) {\n       some(item) {\n         alt attr::get_meta_item_value_str(item) {\n-          some(value) { some(value) }\n+          some(value) { some(/* FIXME bad */ copy value) }\n           none { none }\n         }\n       }\n@@ -244,7 +251,7 @@ fn last_meta_item_value_str_by_name(\n \n fn last_meta_item_list_by_name(\n     items: [@ast::meta_item],\n-    name: str\n+    +name: str\n ) -> option<[@ast::meta_item]> {\n     alt last_meta_item_by_name(items, name) {\n       some(item) {\n@@ -259,13 +266,13 @@ fn last_meta_item_list_by_name(\n \n // FIXME: This needs to sort by meta_item variant in addition to the item name\n // (See [Fixme-sorting])\n-fn sort_meta_items(items: [@ast::meta_item]) -> [@ast::meta_item] {\n+fn sort_meta_items(+items: [@ast::meta_item]) -> [@ast::meta_item] {\n     fn lteq(&&ma: @ast::meta_item, &&mb: @ast::meta_item) -> bool {\n         fn key(m: @ast::meta_item) -> ast::ident {\n             alt m.node {\n-              ast::meta_word(name) { name }\n-              ast::meta_name_value(name, _) { name }\n-              ast::meta_list(name, _) { name }\n+              ast::meta_word(name) { /* FIXME bad */ copy name }\n+              ast::meta_name_value(name, _) { /* FIXME bad */ copy name }\n+              ast::meta_list(name, _) { /* FIXME bad */ copy name }\n             }\n         }\n         ret key(ma) <= key(mb);\n@@ -280,13 +287,14 @@ fn sort_meta_items(items: [@ast::meta_item]) -> [@ast::meta_item] {\n fn remove_meta_items_by_name(items: [@ast::meta_item], name: str) ->\n    [@ast::meta_item] {\n \n-    let filter = fn@(&&item: @ast::meta_item) -> option<@ast::meta_item> {\n+    ret vec::filter_map(items, {\n+        |item|\n         if get_meta_item_name(item) != name {\n-            option::some(item)\n-        } else { option::none }\n-    };\n-\n-    ret vec::filter_map(items, filter);\n+            option::some(/* FIXME bad */ copy item)\n+        } else {\n+            option::none\n+        }\n+    });\n }\n \n fn find_linkage_attrs(attrs: [ast::attribute]) -> [ast::attribute] {\n@@ -307,7 +315,7 @@ linkage\n fn find_linkage_metas(attrs: [ast::attribute]) -> [@ast::meta_item] {\n     find_linkage_attrs(attrs).flat_map {|attr|\n         alt check attr.node.value.node {\n-          ast::meta_list(_, items) { items }\n+          ast::meta_list(_, items) { /* FIXME bad */ copy items }\n         }\n     }\n }\n@@ -362,6 +370,8 @@ fn require_unique_names(diagnostic: span_handler,\n     let map = map::str_hash();\n     for metas.each {|meta|\n         let name = get_meta_item_name(meta);\n+\n+        // FIXME: How do I silence the warnings? --pcw\n         if map.contains_key(name) {\n             diagnostic.span_fatal(meta.span,\n                                   #fmt[\"duplicate meta item `%s`\", name]);"}, {"sha": "97911f9d8b88105b525f13054cebca96322a06eb", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/847c5e4e9892ef56873ac52a552997267c4d385a/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847c5e4e9892ef56873ac52a552997267c4d385a/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=847c5e4e9892ef56873ac52a552997267c4d385a", "patch": "@@ -51,7 +51,7 @@ type loc = {file: filemap, line: uint, col: uint};\n \n fn new_codemap() -> codemap { @{files: dvec()} }\n \n-fn new_filemap_w_substr(filename: filename, substr: file_substr,\n+fn new_filemap_w_substr(+filename: filename, +substr: file_substr,\n                         src: @str,\n                         start_pos_ch: uint, start_pos_byte: uint)\n    -> filemap {\n@@ -60,7 +60,7 @@ fn new_filemap_w_substr(filename: filename, substr: file_substr,\n           mut lines: [{ch: start_pos_ch, byte: start_pos_byte}]};\n }\n \n-fn new_filemap(filename: filename, src: @str,\n+fn new_filemap(+filename: filename, src: @str,\n                start_pos_ch: uint, start_pos_byte: uint)\n     -> filemap {\n     ret new_filemap_w_substr(filename, fss_none, src,\n@@ -123,14 +123,16 @@ fn lookup_char_pos_adj(map: codemap, pos: uint)\n     let loc = lookup_char_pos(map, pos);\n     alt (loc.file.substr) {\n       fss_none {\n-        {filename: loc.file.name, line: loc.line, col: loc.col,\n+        {filename: /* FIXME bad */ copy loc.file.name,\n+         line: loc.line,\n+         col: loc.col,\n          file: some(loc.file)}\n       }\n       fss_internal(sp) {\n         lookup_char_pos_adj(map, sp.lo + (pos - loc.file.start_pos.ch))\n       }\n       fss_external(eloc) {\n-        {filename: eloc.filename,\n+        {filename: /* FIXME bad */ copy eloc.filename,\n          line: eloc.line + loc.line - 1u,\n          col: if loc.line == 1u {eloc.col + loc.col} else {loc.col},\n          file: none}\n@@ -176,7 +178,7 @@ type file_lines = {file: filemap, lines: [uint]};\n \n fn span_to_filename(sp: span, cm: codemap::codemap) -> filename {\n     let lo = lookup_char_pos(cm, sp.lo);\n-    ret lo.file.name;\n+    ret /* FIXME bad */ copy lo.file.name;\n }\n \n fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {"}, {"sha": "b65c6524d120627f258085f5ee8f8e9df653bdde", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/847c5e4e9892ef56873ac52a552997267c4d385a/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847c5e4e9892ef56873ac52a552997267c4d385a/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=847c5e4e9892ef56873ac52a552997267c4d385a", "patch": "@@ -201,7 +201,7 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n     // arbitrarily only print up to six lines of the error\n     let max_lines = 6u;\n     let mut elided = false;\n-    let mut display_lines = lines.lines;\n+    let mut display_lines = /* FIXME bad */ copy lines.lines;\n     if vec::len(display_lines) > max_lines {\n         display_lines = vec::slice(display_lines, 0u, max_lines);\n         elided = true;\n@@ -250,9 +250,11 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n \n fn print_macro_backtrace(cm: codemap::codemap, sp: span) {\n     option::iter (sp.expn_info) {|ei|\n-        let ss = option::map_default(ei.callie.span, \"\",\n-                               bind codemap::span_to_str(_, cm));\n-        print_diagnostic(ss, note,\n+        let ss = option::map_default(ei.callie.span, @\"\", {\n+            |span|\n+            @codemap::span_to_str(span, cm)\n+        });\n+        print_diagnostic(*ss, note,\n                          #fmt(\"in expansion of #%s\", ei.callie.name));\n         let ss = codemap::span_to_str(ei.call_site, cm);\n         print_diagnostic(ss, note, \"expansion site\");"}]}