{"sha": "b57611d10c31a7bfdc3703fa938277caaa87f3a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1NzYxMWQxMGMzMWE3YmZkYzM3MDNmYTkzODI3N2NhYWE4N2YzYTc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-19T06:54:55Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-19T19:05:19Z"}, "message": "core::rt: Simplify some scheduler operations", "tree": {"sha": "90c2a77a775890c728f83c5d3b4847506a522449", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90c2a77a775890c728f83c5d3b4847506a522449"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b57611d10c31a7bfdc3703fa938277caaa87f3a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b57611d10c31a7bfdc3703fa938277caaa87f3a7", "html_url": "https://github.com/rust-lang/rust/commit/b57611d10c31a7bfdc3703fa938277caaa87f3a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b57611d10c31a7bfdc3703fa938277caaa87f3a7/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eddd817bf05723c02722a7b4ab16b7c74baa9533", "url": "https://api.github.com/repos/rust-lang/rust/commits/eddd817bf05723c02722a7b4ab16b7c74baa9533", "html_url": "https://github.com/rust-lang/rust/commit/eddd817bf05723c02722a7b4ab16b7c74baa9533"}], "stats": {"total": 113, "additions": 14, "deletions": 99}, "files": [{"sha": "28946281628b199044dfbd9c010298560fc949a7", "filename": "src/libcore/rt/sched/mod.rs", "status": "modified", "additions": 13, "deletions": 97, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/b57611d10c31a7bfdc3703fa938277caaa87f3a7/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b57611d10c31a7bfdc3703fa938277caaa87f3a7/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched%2Fmod.rs?ref=b57611d10c31a7bfdc3703fa938277caaa87f3a7", "patch": "@@ -16,11 +16,11 @@ use super::work_queue::WorkQueue;\n use super::stack::{StackPool, StackSegment};\n use super::rtio::{EventLoop, EventLoopObject};\n use super::context::Context;\n+use cell::Cell;\n \n #[cfg(test)] use super::uvio::UvEventLoop;\n #[cfg(test)] use unstable::run_in_bare_thread;\n #[cfg(test)] use int;\n-#[cfg(test)] use cell::Cell;\n \n // A more convenient name for external callers, e.g. `local_sched::take()`\n pub mod local_sched;\n@@ -58,8 +58,6 @@ impl ClosureConverter for UnsafeTaskReceiver {\n \n enum CleanupJob {\n     DoNothing,\n-    RescheduleTask(~Task),\n-    RecycleTask(~Task),\n     GiveTask(~Task, UnsafeTaskReceiver)\n }\n \n@@ -143,44 +141,25 @@ pub impl Scheduler {\n \n         rtdebug!(\"ending running task\");\n \n-        let dead_task = self.current_task.swap_unwrap();\n-        self.enqueue_cleanup_job(RecycleTask(dead_task));\n-\n-        local_sched::put(self);\n-\n-        let sched = unsafe { local_sched::unsafe_borrow() };\n-        let (sched_context, last_task_context, _) = sched.get_contexts();\n-        let last_task_context = last_task_context.unwrap();\n-        Context::swap(last_task_context, sched_context);\n+        do self.deschedule_running_task_and_then |dead_task| {\n+            let dead_task = Cell(dead_task);\n+            do local_sched::borrow |sched| {\n+                dead_task.take().recycle(&mut sched.stack_pool);\n+            }\n+        }\n \n         // Control never reaches here\n     }\n \n-    /// Switch directly to another task, without going through the scheduler.\n-    /// You would want to think hard about doing this, e.g. if there are\n-    /// pending I/O events it would be a bad idea.\n-    fn resume_task_from_running_task_direct(~self, next_task: ~Task) {\n+    fn schedule_new_task(~self, task: ~Task) {\n         let mut self = self;\n         assert!(self.in_task_context());\n \n-        rtdebug!(\"switching tasks\");\n-\n-        let old_running_task = self.current_task.swap_unwrap();\n-        self.enqueue_cleanup_job(RescheduleTask(old_running_task));\n-        self.current_task = Some(next_task);\n-\n-        local_sched::put(self);\n-\n-        unsafe {\n-            let sched = local_sched::unsafe_borrow();\n-            let (_, last_task_context, next_task_context) = sched.get_contexts();\n-            let last_task_context = last_task_context.unwrap();\n-            let next_task_context = next_task_context.unwrap();\n-            Context::swap(last_task_context, next_task_context);\n-\n-            // We could be executing in a different thread now\n-            let sched = local_sched::unsafe_borrow();\n-            sched.run_cleanup_job();\n+        do self.switch_running_tasks_and_then(task) |last_task| {\n+            let last_task = Cell(last_task);\n+            do local_sched::borrow |sched| {\n+                sched.task_queue.push_front(last_task.take());\n+            }\n         }\n     }\n \n@@ -294,11 +273,6 @@ pub impl Scheduler {\n         let cleanup_job = self.cleanup_job.swap_unwrap();\n         match cleanup_job {\n             DoNothing => { }\n-            RescheduleTask(task) => {\n-                // NB: Pushing to the *front* of the queue\n-                self.task_queue.push_front(task);\n-            }\n-            RecycleTask(task) => task.recycle(&mut self.stack_pool),\n             GiveTask(task, f) => (f.to_fn())(task)\n         }\n     }\n@@ -316,8 +290,6 @@ pub impl Scheduler {\n                                           Option<&'a mut Context>,\n                                           Option<&'a mut Context>) {\n         let last_task = match self.cleanup_job {\n-            Some(RescheduleTask(~ref task)) |\n-            Some(RecycleTask(~ref task)) |\n             Some(GiveTask(~ref task, _)) => {\n                 Some(task)\n             }\n@@ -432,29 +404,6 @@ fn test_several_tasks() {\n     }\n }\n \n-#[test]\n-fn test_swap_tasks() {\n-    do run_in_bare_thread {\n-        let mut count = 0;\n-        let count_ptr: *mut int = &mut count;\n-\n-        let mut sched = ~UvEventLoop::new_scheduler();\n-        let task1 = ~do Task::new(&mut sched.stack_pool) {\n-            unsafe { *count_ptr = *count_ptr + 1; }\n-            let mut sched = local_sched::take();\n-            let task2 = ~do Task::new(&mut sched.stack_pool) {\n-                unsafe { *count_ptr = *count_ptr + 1; }\n-            };\n-            // Context switch directly to the new task\n-            sched.resume_task_from_running_task_direct(task2);\n-            unsafe { *count_ptr = *count_ptr + 1; }\n-        };\n-        sched.task_queue.push_back(task1);\n-        sched.run();\n-        assert!(count == 3);\n-    }\n-}\n-\n #[test]\n fn test_swap_tasks_then() {\n     do run_in_bare_thread {\n@@ -516,39 +465,6 @@ fn test_run_a_lot_of_tasks_queued() {\n     }\n }\n \n-#[bench] #[test] #[ignore(reason = \"too much stack allocation\")]\n-fn test_run_a_lot_of_tasks_direct() {\n-    do run_in_bare_thread {\n-        static MAX: int = 100000;\n-        let mut count = 0;\n-        let count_ptr: *mut int = &mut count;\n-\n-        let mut sched = ~UvEventLoop::new_scheduler();\n-\n-        let start_task = ~do Task::new(&mut sched.stack_pool) {\n-            run_task(count_ptr);\n-        };\n-        sched.task_queue.push_back(start_task);\n-        sched.run();\n-\n-        assert!(count == MAX);\n-\n-        fn run_task(count_ptr: *mut int) {\n-            let mut sched = local_sched::take();\n-            let task = ~do Task::new(&mut sched.stack_pool) {\n-                unsafe {\n-                    *count_ptr = *count_ptr + 1;\n-                    if *count_ptr != MAX {\n-                        run_task(count_ptr);\n-                    }\n-                }\n-            };\n-            // Context switch directly to the new task\n-            sched.resume_task_from_running_task_direct(task);\n-        };\n-    }\n-}\n-\n #[test]\n fn test_block_task() {\n     do run_in_bare_thread {"}, {"sha": "118c4cc23125b35654ae2f017109bad3d5f03644", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b57611d10c31a7bfdc3703fa938277caaa87f3a7/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b57611d10c31a7bfdc3703fa938277caaa87f3a7/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=b57611d10c31a7bfdc3703fa938277caaa87f3a7", "patch": "@@ -552,10 +552,9 @@ pub fn spawn_raw(opts: TaskOpts, f: ~fn()) {\n fn spawn_raw_newsched(opts: TaskOpts, f: ~fn()) {\n     use rt::sched::*;\n \n-    // XXX: How to schedule a new task is a policy decision that shouldn't be made here\n     let mut sched = local_sched::take();\n     let task = ~Task::new(&mut sched.stack_pool, f);\n-    sched.resume_task_from_running_task_direct(task);\n+    sched.schedule_new_task(task);\n }\n \n fn spawn_raw_oldsched(opts: TaskOpts, f: ~fn()) {"}]}