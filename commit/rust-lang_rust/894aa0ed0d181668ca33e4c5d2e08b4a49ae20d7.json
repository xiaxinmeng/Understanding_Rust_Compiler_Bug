{"sha": "894aa0ed0d181668ca33e4c5d2e08b4a49ae20d7", "node_id": "C_kwDOAAsO6NoAKDg5NGFhMGVkMGQxODE2NjhjYTMzZTRjNWQyZTA4YjRhNDlhZTIwZDc", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-09-02T15:43:20Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-09-02T15:43:20Z"}, "message": "Clarify the state of (extern) preludes for block def maps", "tree": {"sha": "ff0717071073a1c6aa74a78f5812de7b66e85a74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff0717071073a1c6aa74a78f5812de7b66e85a74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/894aa0ed0d181668ca33e4c5d2e08b4a49ae20d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/894aa0ed0d181668ca33e4c5d2e08b4a49ae20d7", "html_url": "https://github.com/rust-lang/rust/commit/894aa0ed0d181668ca33e4c5d2e08b4a49ae20d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/894aa0ed0d181668ca33e4c5d2e08b4a49ae20d7/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8828049b2398b0df3bfc76d06bcf5154cdbe536a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8828049b2398b0df3bfc76d06bcf5154cdbe536a", "html_url": "https://github.com/rust-lang/rust/commit/8828049b2398b0df3bfc76d06bcf5154cdbe536a"}], "stats": {"total": 120, "additions": 60, "deletions": 60}, "files": [{"sha": "2e392f741bf29767884b56fa25b6097b9795e35a", "filename": "crates/hir-def/src/nameres.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/894aa0ed0d181668ca33e4c5d2e08b4a49ae20d7/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/894aa0ed0d181668ca33e4c5d2e08b4a49ae20d7/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres.rs?ref=894aa0ed0d181668ca33e4c5d2e08b4a49ae20d7", "patch": "@@ -98,7 +98,11 @@ pub struct DefMap {\n     /// The prelude module for this crate. This either comes from an import\n     /// marked with the `prelude_import` attribute, or (in the normal case) from\n     /// a dependency (`std` or `core`).\n+    /// The prelude is empty for non-block DefMaps (unless `#[prelude_import]` was used,\n+    /// but that attribute is nightly and when used in a block, it affects resolution globally\n+    /// so we aren't handling this correctly anyways).\n     prelude: Option<ModuleId>,\n+    /// The extern prelude is only populated for non-block DefMaps\n     extern_prelude: FxHashMap<Name, ModuleId>,\n \n     /// Side table for resolving derive helpers."}, {"sha": "495bbe4579f00780774fc970110130f7fdd0ddb3", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/894aa0ed0d181668ca33e4c5d2e08b4a49ae20d7/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/894aa0ed0d181668ca33e4c5d2e08b4a49ae20d7/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=894aa0ed0d181668ca33e4c5d2e08b4a49ae20d7", "patch": "@@ -512,10 +512,9 @@ impl DefCollector<'_> {\n             Edition::Edition2021 => name![rust_2021],\n         };\n \n-        let path_kind = if self.def_map.edition == Edition::Edition2015 {\n-            PathKind::Plain\n-        } else {\n-            PathKind::Abs\n+        let path_kind = match self.def_map.edition {\n+            Edition::Edition2015 => PathKind::Plain,\n+            _ => PathKind::Abs,\n         };\n         let path =\n             ModPath::from_segments(path_kind, [krate.clone(), name![prelude], edition].into_iter());\n@@ -535,7 +534,6 @@ impl DefCollector<'_> {\n             match per_ns.types {\n                 Some((ModuleDefId::ModuleId(m), _)) => {\n                     self.def_map.prelude = Some(m);\n-                    return;\n                 }\n                 types => {\n                     tracing::debug!(\n@@ -850,7 +848,10 @@ impl DefCollector<'_> {\n                 tracing::debug!(\"resolved import {:?} ({:?}) to {:?}\", name, import, def);\n \n                 // extern crates in the crate root are special-cased to insert entries into the extern prelude: rust-lang/rust#54658\n-                if import.is_extern_crate && module_id == self.def_map.root {\n+                if import.is_extern_crate\n+                    && self.def_map.block.is_none()\n+                    && module_id == self.def_map.root\n+                {\n                     if let (Some(ModuleDefId::ModuleId(def)), Some(name)) = (def.take_types(), name)\n                     {\n                         self.def_map.extern_prelude.insert(name.clone(), def);"}, {"sha": "8aa5973cac57baae18937f13d92a45f2d83242f2", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 49, "deletions": 54, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/894aa0ed0d181668ca33e4c5d2e08b4a49ae20d7/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/894aa0ed0d181668ca33e4c5d2e08b4a49ae20d7/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=894aa0ed0d181668ca33e4c5d2e08b4a49ae20d7", "patch": "@@ -368,34 +368,43 @@ impl Resolver {\n         for scope in self.scopes() {\n             scope.process_names(&mut res, db);\n         }\n-        process_module_scope_names(&mut res, db, &self.module_scope);\n+        let ModuleItemMap { ref def_map, module_id } = self.module_scope;\n+        // FIXME: should we provide `self` here?\n+        // f(\n+        //     Name::self_param(),\n+        //     PerNs::types(Resolution::Def {\n+        //         def: m.module.into(),\n+        //     }),\n+        // );\n+        def_map[module_id].scope.entries().for_each(|(name, def)| {\n+            res.add_per_ns(name, def);\n+        });\n+        def_map[module_id].scope.legacy_macros().for_each(|(name, macs)| {\n+            macs.iter().for_each(|&mac| {\n+                res.add(name, ScopeDef::ModuleDef(ModuleDefId::MacroId(MacroId::from(mac))));\n+            })\n+        });\n+        def_map.extern_prelude().for_each(|(name, &def)| {\n+            res.add(name, ScopeDef::ModuleDef(ModuleDefId::ModuleId(def)));\n+        });\n+        BUILTIN_SCOPE.iter().for_each(|(name, &def)| {\n+            res.add_per_ns(name, def);\n+        });\n+        if let Some(prelude) = def_map.prelude() {\n+            let prelude_def_map = prelude.def_map(db);\n+            for (name, def) in prelude_def_map[prelude.local_id].scope.entries() {\n+                res.add_per_ns(name, def)\n+            }\n+        }\n         res.map\n     }\n \n     pub fn traits_in_scope(&self, db: &dyn DefDatabase) -> FxHashSet<TraitId> {\n         let mut traits = FxHashSet::default();\n \n-        let collect_module_traits = |traits: &mut FxHashSet<_>, m: &ModuleItemMap| {\n-            if let Some(prelude) = m.def_map.prelude() {\n-                let prelude_def_map = prelude.def_map(db);\n-                traits.extend(prelude_def_map[prelude.local_id].scope.traits());\n-            }\n-            traits.extend(m.def_map[m.module_id].scope.traits());\n-\n-            // Add all traits that are in scope because of the containing DefMaps\n-            m.def_map.with_ancestor_maps(db, m.module_id, &mut |def_map, module| {\n-                if let Some(prelude) = def_map.prelude() {\n-                    let prelude_def_map = prelude.def_map(db);\n-                    traits.extend(prelude_def_map[prelude.local_id].scope.traits());\n-                }\n-                traits.extend(def_map[module].scope.traits());\n-                None::<()>\n-            });\n-        };\n-\n         for scope in self.scopes() {\n             match scope {\n-                Scope::BlockScope(m) => collect_module_traits(&mut traits, m),\n+                Scope::BlockScope(m) => traits.extend(m.def_map[m.module_id].scope.traits()),\n                 &Scope::ImplDefScope(impl_) => {\n                     if let Some(target_trait) = &db.impl_data(impl_).target_trait {\n                         if let Some(TypeNs::TraitId(trait_)) =\n@@ -409,7 +418,13 @@ impl Resolver {\n             }\n         }\n \n-        collect_module_traits(&mut traits, &self.module_scope);\n+        // Fill in the prelude traits\n+        if let Some(prelude) = self.module_scope.def_map.prelude() {\n+            let prelude_def_map = prelude.def_map(db);\n+            traits.extend(prelude_def_map[prelude.local_id].scope.traits());\n+        }\n+        // Fill in module visible traits\n+        traits.extend(self.module_scope.def_map[self.module_scope.module_id].scope.traits());\n         traits\n     }\n \n@@ -493,42 +508,22 @@ pub enum ScopeDef {\n     Label(LabelId),\n }\n \n-fn process_module_scope_names(acc: &mut ScopeNames, db: &dyn DefDatabase, m: &ModuleItemMap) {\n-    // FIXME: should we provide `self` here?\n-    // f(\n-    //     Name::self_param(),\n-    //     PerNs::types(Resolution::Def {\n-    //         def: m.module.into(),\n-    //     }),\n-    // );\n-    m.def_map[m.module_id].scope.entries().for_each(|(name, def)| {\n-        acc.add_per_ns(name, def);\n-    });\n-    m.def_map[m.module_id].scope.legacy_macros().for_each(|(name, macs)| {\n-        macs.iter().for_each(|&mac| {\n-            acc.add(name, ScopeDef::ModuleDef(ModuleDefId::MacroId(MacroId::from(mac))));\n-        })\n-    });\n-    m.def_map.extern_prelude().for_each(|(name, &def)| {\n-        acc.add(name, ScopeDef::ModuleDef(ModuleDefId::ModuleId(def)));\n-    });\n-    if m.def_map.block_id().is_none() {\n-        BUILTIN_SCOPE.iter().for_each(|(name, &def)| {\n-            acc.add_per_ns(name, def);\n-        });\n-    }\n-    if let Some(prelude) = m.def_map.prelude() {\n-        let prelude_def_map = prelude.def_map(db);\n-        for (name, def) in prelude_def_map[prelude.local_id].scope.entries() {\n-            acc.add_per_ns(name, def)\n-        }\n-    }\n-}\n-\n impl Scope {\n     fn process_names(&self, acc: &mut ScopeNames, db: &dyn DefDatabase) {\n         match self {\n-            Scope::BlockScope(m) => process_module_scope_names(acc, db, m),\n+            Scope::BlockScope(m) => {\n+                m.def_map[m.module_id].scope.entries().for_each(|(name, def)| {\n+                    acc.add_per_ns(name, def);\n+                });\n+                m.def_map[m.module_id].scope.legacy_macros().for_each(|(name, macs)| {\n+                    macs.iter().for_each(|&mac| {\n+                        acc.add(\n+                            name,\n+                            ScopeDef::ModuleDef(ModuleDefId::MacroId(MacroId::from(mac))),\n+                        );\n+                    })\n+                });\n+            }\n             Scope::GenericParams { params, def: parent } => {\n                 let parent = *parent;\n                 for (local_id, param) in params.type_or_consts.iter() {"}]}