{"sha": "3b651330e0ff4090f18fc834486a8f0a9aa62748", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiNjUxMzMwZTBmZjQwOTBmMThmYzgzNDQ4NmE4ZjBhOWFhNjI3NDg=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-12T05:45:55Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-12T10:50:44Z"}, "message": "extract recover_pat_ident_mut_first", "tree": {"sha": "8aeeca81030523644b37bcefe568f0d1f46096d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8aeeca81030523644b37bcefe568f0d1f46096d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b651330e0ff4090f18fc834486a8f0a9aa62748", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b651330e0ff4090f18fc834486a8f0a9aa62748", "html_url": "https://github.com/rust-lang/rust/commit/3b651330e0ff4090f18fc834486a8f0a9aa62748", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b651330e0ff4090f18fc834486a8f0a9aa62748/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c69b3ede8a98b45633736f7a84757fe7f3b5a392", "url": "https://api.github.com/repos/rust-lang/rust/commits/c69b3ede8a98b45633736f7a84757fe7f3b5a392", "html_url": "https://github.com/rust-lang/rust/commit/c69b3ede8a98b45633736f7a84757fe7f3b5a392"}], "stats": {"total": 36, "additions": 20, "deletions": 16}, "files": [{"sha": "1b6baf09d816b4c2bec33967bfff787a9840b031", "filename": "src/libsyntax/parse/parser/pat.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3b651330e0ff4090f18fc834486a8f0a9aa62748/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b651330e0ff4090f18fc834486a8f0a9aa62748/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs?ref=3b651330e0ff4090f18fc834486a8f0a9aa62748", "patch": "@@ -140,22 +140,7 @@ impl<'a> Parser<'a> {\n                 // Parse _\n                 PatKind::Wild\n             } else if self.eat_keyword(kw::Mut) {\n-                // Parse mut ident @ pat / mut ref ident @ pat\n-                let mutref_span = self.prev_span.to(self.token.span);\n-                let binding_mode = if self.eat_keyword(kw::Ref) {\n-                    self.diagnostic()\n-                        .struct_span_err(mutref_span, \"the order of `mut` and `ref` is incorrect\")\n-                        .span_suggestion(\n-                            mutref_span,\n-                            \"try switching the order\",\n-                            \"ref mut\".into(),\n-                            Applicability::MachineApplicable\n-                        ).emit();\n-                    BindingMode::ByRef(Mutability::Mutable)\n-                } else {\n-                    BindingMode::ByValue(Mutability::Mutable)\n-                };\n-                self.parse_pat_ident(binding_mode)?\n+                self.recover_pat_ident_mut_first()?\n             } else if self.eat_keyword(kw::Ref) {\n                 // Parse ref ident @ pat / ref mut ident @ pat\n                 let mutbl = self.parse_mutability();\n@@ -338,6 +323,25 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n+    // Recover on `mut ref? ident @ pat` and suggest that the order of `mut` and `ref` is incorrect.\n+    fn recover_pat_ident_mut_first(&mut self) -> PResult<'a, PatKind> {\n+        let mutref_span = self.prev_span.to(self.token.span);\n+        let binding_mode = if self.eat_keyword(kw::Ref) {\n+            self.struct_span_err(mutref_span, \"the order of `mut` and `ref` is incorrect\")\n+                .span_suggestion(\n+                    mutref_span,\n+                    \"try switching the order\",\n+                    \"ref mut\".into(),\n+                    Applicability::MachineApplicable\n+                )\n+                .emit();\n+            BindingMode::ByRef(Mutability::Mutable)\n+        } else {\n+            BindingMode::ByValue(Mutability::Mutable)\n+        };\n+        self.parse_pat_ident(binding_mode)\n+    }\n+\n     // Helper function to decide whether to parse as ident binding\n     // or to try to do something more complex like range patterns.\n     fn parse_as_ident(&mut self) -> bool {"}]}