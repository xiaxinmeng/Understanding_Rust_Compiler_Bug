{"sha": "7c720ce6121dd878b25f8e6a645a07563e5a4b01", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNzIwY2U2MTIxZGQ4NzhiMjVmOGU2YTY0NWEwNzU2M2U1YTRiMDE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-07-16T07:39:35Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-07-16T08:09:56Z"}, "message": "get rid of incorrect erase_for_fmt", "tree": {"sha": "1aa40698e47dde0b95b0d78522fb8839f8e0c54c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1aa40698e47dde0b95b0d78522fb8839f8e0c54c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c720ce6121dd878b25f8e6a645a07563e5a4b01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c720ce6121dd878b25f8e6a645a07563e5a4b01", "html_url": "https://github.com/rust-lang/rust/commit/7c720ce6121dd878b25f8e6a645a07563e5a4b01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c720ce6121dd878b25f8e6a645a07563e5a4b01/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e280656189588a3cc30b86599a0ff4f211030b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e280656189588a3cc30b86599a0ff4f211030b8", "html_url": "https://github.com/rust-lang/rust/commit/4e280656189588a3cc30b86599a0ff4f211030b8"}], "stats": {"total": 200, "additions": 81, "deletions": 119}, "files": [{"sha": "56b8f9b928f9d35c45fc0d0aead57615c17ded66", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c720ce6121dd878b25f8e6a645a07563e5a4b01/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c720ce6121dd878b25f8e6a645a07563e5a4b01/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=7c720ce6121dd878b25f8e6a645a07563e5a4b01", "patch": "@@ -377,7 +377,9 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n             }\n         };\n \n-        let (bytes, provenance) = match val.to_bits_or_ptr(range.size) {\n+        // `to_bits_or_ptr_internal` is the right method because we just want to store this data\n+        // as-is into memory.\n+        let (bytes, provenance) = match val.to_bits_or_ptr_internal(range.size) {\n             Err(val) => {\n                 let (provenance, offset) = val.into_parts();\n                 (u128::from(offset.bytes()), Some(provenance))"}, {"sha": "c7daaec8d5d54a5ead9783dc329462c4077f86c0", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7c720ce6121dd878b25f8e6a645a07563e5a4b01/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c720ce6121dd878b25f8e6a645a07563e5a4b01/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=7c720ce6121dd878b25f8e6a645a07563e5a4b01", "patch": "@@ -89,16 +89,17 @@ impl<T: HasDataLayout> PointerArithmetic for T {}\n pub trait Provenance: Copy {\n     /// Says whether the `offset` field of `Pointer`s with this provenance is the actual physical address.\n     /// If `true, ptr-to-int casts work by simply discarding the provenance.\n-    /// If `false`, ptr-to-int casts are not supported.\n+    /// If `false`, ptr-to-int casts are not supported. The offset *must* be relative in that case.\n     const OFFSET_IS_ADDR: bool;\n \n     /// Determines how a pointer should be printed.\n     fn fmt(ptr: &Pointer<Self>, f: &mut fmt::Formatter<'_>) -> fmt::Result\n     where\n         Self: Sized;\n \n-    /// \"Erasing\" a tag converts it to the default tag type if possible. Used only for formatting purposes!\n-    fn erase_for_fmt(self) -> AllocId;\n+    /// Provenance must always be able to identify the allocation this ptr points to.\n+    /// (Identifying the offset in that allocation, however, is harder -- use `Memory::ptr_get_alloc` for that.)\n+    fn get_alloc_id(self) -> AllocId;\n }\n \n impl Provenance for AllocId {\n@@ -120,7 +121,7 @@ impl Provenance for AllocId {\n         Ok(())\n     }\n \n-    fn erase_for_fmt(self) -> AllocId {\n+    fn get_alloc_id(self) -> AllocId {\n         self\n     }\n }\n@@ -177,14 +178,6 @@ impl<Tag> Pointer<Option<Tag>> {\n             None => Err(self.offset),\n         }\n     }\n-\n-    #[inline(always)]\n-    pub fn map_erase_for_fmt(self) -> Pointer<Option<AllocId>>\n-    where\n-        Tag: Provenance,\n-    {\n-        Pointer { offset: self.offset, provenance: self.provenance.map(Provenance::erase_for_fmt) }\n-    }\n }\n \n impl<Tag> Pointer<Option<Tag>> {\n@@ -208,15 +201,6 @@ impl<'tcx, Tag> Pointer<Tag> {\n         (self.provenance, self.offset)\n     }\n \n-    #[inline(always)]\n-    pub fn erase_for_fmt(self) -> Pointer\n-    where\n-        Tag: Provenance,\n-    {\n-        // FIXME: This is wrong! `self.offset` might be an absolute address.\n-        Pointer { offset: self.offset, provenance: self.provenance.erase_for_fmt() }\n-    }\n-\n     pub fn map_provenance(self, f: impl FnOnce(Tag) -> Tag) -> Self {\n         Pointer { provenance: f(self.provenance), ..self }\n     }"}, {"sha": "62b71b10d5a1b98c7a0b94b100d46829dfac1fc7", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 17, "deletions": 35, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7c720ce6121dd878b25f8e6a645a07563e5a4b01/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c720ce6121dd878b25f8e6a645a07563e5a4b01/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=7c720ce6121dd878b25f8e6a645a07563e5a4b01", "patch": "@@ -289,9 +289,10 @@ impl<Tag> Scalar<Tag> {\n     /// This is almost certainly not the method you want!  You should dispatch on the type\n     /// and use `to_{u8,u16,...}`/`scalar_to_ptr` to perform ptr-to-int / int-to-ptr casts as needed.\n     ///\n-    /// This method only exists for the benefit of low-level memory operations.\n+    /// This method only exists for the benefit of low-level operations that truly need to treat the\n+    /// scalar in whatever form it is.\n     #[inline]\n-    pub fn to_bits_or_ptr(self, target_size: Size) -> Result<u128, Pointer<Tag>> {\n+    pub fn to_bits_or_ptr_internal(self, target_size: Size) -> Result<u128, Pointer<Tag>> {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n         match self {\n             Scalar::Int(int) => Ok(int.assert_bits(target_size)),\n@@ -304,32 +305,23 @@ impl<Tag> Scalar<Tag> {\n }\n \n impl<'tcx, Tag: Provenance> Scalar<Tag> {\n-    /// Erase the tag from the scalar, if any.\n-    ///\n-    /// Used by error reporting code to avoid having the error type depend on `Tag`.\n-    #[inline]\n-    pub fn erase_for_fmt(self) -> Scalar {\n-        match self {\n-            Scalar::Ptr(ptr, sz) => Scalar::Ptr(ptr.erase_for_fmt(), sz),\n-            Scalar::Int(int) => Scalar::Int(int),\n-        }\n-    }\n-\n     /// Fundamental scalar-to-int (cast) operation. Many convenience wrappers exist below, that you\n     /// likely want to use instead.\n     ///\n     /// Will perform ptr-to-int casts if needed and possible.\n+    /// If that fails, we know the offset is relative, so we return an \"erased\" Scalar\n+    /// (which is useful for error messages but not much else).\n     #[inline]\n-    pub fn try_to_int(self) -> Option<ScalarInt> {\n+    pub fn try_to_int(self) -> Result<ScalarInt, Scalar<AllocId>> {\n         match self {\n-            Scalar::Int(int) => Some(int),\n+            Scalar::Int(int) => Ok(int),\n             Scalar::Ptr(ptr, sz) => {\n                 if Tag::OFFSET_IS_ADDR {\n-                    Some(\n-                        ScalarInt::try_from_uint(ptr.offset.bytes(), Size::from_bytes(sz)).unwrap(),\n-                    )\n+                    Ok(ScalarInt::try_from_uint(ptr.offset.bytes(), Size::from_bytes(sz)).unwrap())\n                 } else {\n-                    None\n+                    // We know `offset` is relative, since `OFFSET_IS_ADDR == false`.\n+                    let (tag, offset) = ptr.into_parts();\n+                    Err(Scalar::Ptr(Pointer::new(tag.get_alloc_id(), offset), sz))\n                 }\n             }\n         }\n@@ -340,19 +332,20 @@ impl<'tcx, Tag: Provenance> Scalar<Tag> {\n         self.try_to_int().unwrap()\n     }\n \n+    /// This throws UB (instead of ICEing) on a size mismatch since size mismatches can arise in\n+    /// Miri when someone declares a function that we shim (such as `malloc`) with a wrong type.\n     #[inline]\n     pub fn to_bits(self, target_size: Size) -> InterpResult<'tcx, u128> {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n-        self.try_to_int()\n-            .ok_or_else(|| err_unsup!(ReadPointerAsBytes))?\n-            .to_bits(target_size)\n-            .map_err(|size| {\n+        self.try_to_int().map_err(|_| err_unsup!(ReadPointerAsBytes))?.to_bits(target_size).map_err(\n+            |size| {\n                 err_ub!(ScalarSizeMismatch {\n                     target_size: target_size.bytes(),\n                     data_size: size.bytes(),\n                 })\n                 .into()\n-            })\n+            },\n+        )\n     }\n \n     #[inline(always)]\n@@ -522,17 +515,6 @@ impl<Tag> ScalarMaybeUninit<Tag> {\n }\n \n impl<'tcx, Tag: Provenance> ScalarMaybeUninit<Tag> {\n-    /// Erase the tag from the scalar, if any.\n-    ///\n-    /// Used by error reporting code to avoid having the error type depend on `Tag`.\n-    #[inline]\n-    pub fn erase_for_fmt(self) -> ScalarMaybeUninit {\n-        match self {\n-            ScalarMaybeUninit::Scalar(s) => ScalarMaybeUninit::Scalar(s.erase_for_fmt()),\n-            ScalarMaybeUninit::Uninit => ScalarMaybeUninit::Uninit,\n-        }\n-    }\n-\n     #[inline(always)]\n     pub fn to_bool(self) -> InterpResult<'tcx, bool> {\n         self.check_init()?.to_bool()"}, {"sha": "6dfbd28f7763b7db91a00610dc21d5ef151eb3b3", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c720ce6121dd878b25f8e6a645a07563e5a4b01/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c720ce6121dd878b25f8e6a645a07563e5a4b01/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=7c720ce6121dd878b25f8e6a645a07563e5a4b01", "patch": "@@ -1,5 +1,5 @@\n use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n-use crate::mir::interpret::{AllocRange, ConstValue, GlobalAlloc, Pointer, Scalar};\n+use crate::mir::interpret::{AllocRange, ConstValue, GlobalAlloc, Pointer, Provenance, Scalar};\n use crate::ty::subst::{GenericArg, GenericArgKind, Subst};\n use crate::ty::{self, ConstInt, DefIdTree, ParamConst, ScalarInt, Ty, TyCtxt, TypeFoldable};\n use rustc_apfloat::ieee::{Double, Single};\n@@ -1107,9 +1107,9 @@ pub trait PrettyPrinter<'tcx>:\n \n     /// This is overridden for MIR printing because we only want to hide alloc ids from users, not\n     /// from MIR where it is actually useful.\n-    fn pretty_print_const_pointer(\n+    fn pretty_print_const_pointer<Tag: Provenance>(\n         mut self,\n-        _: Pointer,\n+        _: Pointer<Tag>,\n         ty: Ty<'tcx>,\n         print_ty: bool,\n     ) -> Result<Self::Const, Self::Error> {\n@@ -1680,9 +1680,9 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n         }\n     }\n \n-    fn pretty_print_const_pointer(\n+    fn pretty_print_const_pointer<Tag: Provenance>(\n         self,\n-        p: Pointer,\n+        p: Pointer<Tag>,\n         ty: Ty<'tcx>,\n         print_ty: bool,\n     ) -> Result<Self::Const, Self::Error> {"}, {"sha": "b130eb3ca0c39173378f1af9d915a749e0db4ec4", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7c720ce6121dd878b25f8e6a645a07563e5a4b01/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c720ce6121dd878b25f8e6a645a07563e5a4b01/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=7c720ce6121dd878b25f8e6a645a07563e5a4b01", "patch": "@@ -897,11 +897,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn deallocate_local(&mut self, local: LocalValue<M::PointerTag>) -> InterpResult<'tcx> {\n         if let LocalValue::Live(Operand::Indirect(MemPlace { ptr, .. })) = local {\n             // All locals have a backing allocation, even if the allocation is empty\n-            // due to the local having ZST type.\n+            // due to the local having ZST type. Hence we can `unwrap`.\n             trace!(\n                 \"deallocating local {:?}: {:?}\",\n                 local,\n-                self.memory.dump_alloc(ptr.provenance.unwrap().erase_for_fmt())\n+                self.memory.dump_alloc(ptr.provenance.unwrap().get_alloc_id())\n             );\n             self.memory.deallocate(ptr, None, MemoryKind::Stack)?;\n         };\n@@ -989,28 +989,28 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> std::fmt::Debug\n                             },\n                             mplace.ptr,\n                         )?;\n-                        allocs.extend(mplace.ptr.map_erase_for_fmt().provenance);\n+                        allocs.extend(mplace.ptr.provenance.map(Provenance::get_alloc_id));\n                     }\n                     LocalValue::Live(Operand::Immediate(Immediate::Scalar(val))) => {\n                         write!(fmt, \" {:?}\", val)?;\n                         if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr, _size)) = val {\n-                            allocs.push(ptr.provenance.erase_for_fmt());\n+                            allocs.push(ptr.provenance.get_alloc_id());\n                         }\n                     }\n                     LocalValue::Live(Operand::Immediate(Immediate::ScalarPair(val1, val2))) => {\n                         write!(fmt, \" ({:?}, {:?})\", val1, val2)?;\n                         if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr, _size)) = val1 {\n-                            allocs.push(ptr.provenance.erase_for_fmt());\n+                            allocs.push(ptr.provenance.get_alloc_id());\n                         }\n                         if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr, _size)) = val2 {\n-                            allocs.push(ptr.provenance.erase_for_fmt());\n+                            allocs.push(ptr.provenance.get_alloc_id());\n                         }\n                     }\n                 }\n \n                 write!(fmt, \": {:?}\", self.ecx.memory.dump_allocs(allocs))\n             }\n-            Place::Ptr(mplace) => match mplace.ptr.map_erase_for_fmt().provenance {\n+            Place::Ptr(mplace) => match mplace.ptr.provenance.map(Provenance::get_alloc_id) {\n                 Some(alloc_id) => write!(\n                     fmt,\n                     \"by align({}) ref {:?}: {:?}\","}, {"sha": "dc1f9053b61f028fe968a3c1b31928e657a61481", "filename": "compiler/rustc_mir/src/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c720ce6121dd878b25f8e6a645a07563e5a4b01/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c720ce6121dd878b25f8e6a645a07563e5a4b01/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=7c720ce6121dd878b25f8e6a645a07563e5a4b01", "patch": "@@ -362,7 +362,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 //\n                 // Control flow is weird because we cannot early-return (to reach the\n                 // `go_to_block` at the end).\n-                let done = if let (Some(a), Some(b)) = (a.try_to_int(), b.try_to_int()) {\n+                let done = if let (Ok(a), Ok(b)) = (a.try_to_int(), b.try_to_int()) {\n                     let a = a.try_to_machine_usize(*self.tcx).unwrap();\n                     let b = b.try_to_machine_usize(*self.tcx).unwrap();\n                     if a == b && a != 0 {"}, {"sha": "b82dbf3e94b604c948eb61ccb32167e40e6e834c", "filename": "compiler/rustc_mir/src/interpret/memory.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7c720ce6121dd878b25f8e6a645a07563e5a4b01/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c720ce6121dd878b25f8e6a645a07563e5a4b01/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs?ref=7c720ce6121dd878b25f8e6a645a07563e5a4b01", "patch": "@@ -757,12 +757,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         ptr: Pointer<Option<M::PointerTag>>,\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n         trace!(\"get_fn({:?})\", ptr);\n-        let (alloc_id, offset, ptr) = self.ptr_get_alloc(ptr)?;\n+        let (alloc_id, offset, _ptr) = self.ptr_get_alloc(ptr)?;\n         if offset.bytes() != 0 {\n-            throw_ub!(InvalidFunctionPointer(ptr.erase_for_fmt()))\n+            throw_ub!(InvalidFunctionPointer(Pointer::new(alloc_id, offset)))\n         }\n         self.get_fn_alloc(alloc_id)\n-            .ok_or_else(|| err_ub!(InvalidFunctionPointer(ptr.erase_for_fmt())).into())\n+            .ok_or_else(|| err_ub!(InvalidFunctionPointer(Pointer::new(alloc_id, offset))).into())\n     }\n \n     pub fn mark_immutable(&mut self, id: AllocId) -> InterpResult<'tcx> {\n@@ -801,7 +801,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 if reachable.insert(id) {\n                     // This is a new allocation, add its relocations to `todo`.\n                     if let Some((_, alloc)) = self.alloc_map.get(id) {\n-                        todo.extend(alloc.relocations().values().map(|tag| tag.erase_for_fmt()));\n+                        todo.extend(alloc.relocations().values().map(|tag| tag.get_alloc_id()));\n                     }\n                 }\n             }\n@@ -841,7 +841,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n             allocs_to_print: &mut VecDeque<AllocId>,\n             alloc: &Allocation<Tag, Extra>,\n         ) -> std::fmt::Result {\n-            for alloc_id in alloc.relocations().values().map(|tag| tag.erase_for_fmt()) {\n+            for alloc_id in alloc.relocations().values().map(|tag| tag.get_alloc_id()) {\n                 allocs_to_print.push_back(alloc_id);\n             }\n             write!(fmt, \"{}\", pretty::display_allocation(tcx, alloc))\n@@ -1129,7 +1129,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n /// Machine pointer introspection.\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn scalar_to_ptr(&self, scalar: Scalar<M::PointerTag>) -> Pointer<Option<M::PointerTag>> {\n-        match scalar.to_bits_or_ptr(self.pointer_size()) {\n+        // We use `to_bits_or_ptr_internal` since we are just implementing the method people need to\n+        // call to force getting out a pointer.\n+        match scalar.to_bits_or_ptr_internal(self.pointer_size()) {\n             Err(ptr) => ptr.into(),\n             Ok(bits) => {\n                 let addr = u64::try_from(bits).unwrap();"}, {"sha": "04d4e3993e4f5005545e33985b858c66c038c796", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7c720ce6121dd878b25f8e6a645a07563e5a4b01/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c720ce6121dd878b25f8e6a645a07563e5a4b01/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=7c720ce6121dd878b25f8e6a645a07563e5a4b01", "patch": "@@ -118,8 +118,14 @@ impl<Tag: Provenance> std::fmt::Display for ImmTy<'tcx, Tag> {\n             ty: Ty<'tcx>,\n         ) -> Result<FmtPrinter<'a, 'tcx, F>, std::fmt::Error> {\n             match s {\n-                ScalarMaybeUninit::Scalar(s) => {\n-                    cx.pretty_print_const_scalar(s.erase_for_fmt(), ty, true)\n+                ScalarMaybeUninit::Scalar(Scalar::Int(int)) => {\n+                    cx.pretty_print_const_scalar_int(int, ty, true)\n+                }\n+                ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr, _sz)) => {\n+                    // Just print the ptr value. `pretty_print_const_scalar_ptr` would also try to\n+                    // print what is points to, which would fail since it has no access to the local\n+                    // memory.\n+                    cx.pretty_print_const_pointer(ptr, ty, true)\n                 }\n                 ScalarMaybeUninit::Uninit => cx.typed_value(\n                     |mut this| {\n@@ -139,11 +145,11 @@ impl<Tag: Provenance> std::fmt::Display for ImmTy<'tcx, Tag> {\n                         p(cx, s, ty)?;\n                         return Ok(());\n                     }\n-                    write!(f, \"{}: {}\", s.erase_for_fmt(), self.layout.ty)\n+                    write!(f, \"{}: {}\", s, self.layout.ty)\n                 }\n                 Immediate::ScalarPair(a, b) => {\n                     // FIXME(oli-obk): at least print tuples and slices nicely\n-                    write!(f, \"({}, {}): {}\", a.erase_for_fmt(), b.erase_for_fmt(), self.layout.ty,)\n+                    write!(f, \"({}, {}): {}\", a, b, self.layout.ty,)\n                 }\n             }\n         })\n@@ -693,8 +699,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(match *tag_encoding {\n             TagEncoding::Direct => {\n                 let tag_bits = tag_val\n-                    .to_bits(tag_layout.size)\n-                    .map_err(|_| err_ub!(InvalidTag(tag_val.erase_for_fmt())))?;\n+                    .try_to_int()\n+                    .map_err(|dbg_val| err_ub!(InvalidTag(dbg_val)))?\n+                    .assert_bits(tag_layout.size);\n                 // Cast bits from tag layout to discriminant layout.\n                 let discr_val = self.cast_from_scalar(tag_bits, tag_layout, discr_layout.ty);\n                 let discr_bits = discr_val.assert_bits(discr_layout.size);\n@@ -711,7 +718,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                     _ => span_bug!(self.cur_span(), \"tagged layout for non-adt non-generator\"),\n                 }\n-                .ok_or_else(|| err_ub!(InvalidTag(tag_val.erase_for_fmt())))?;\n+                .ok_or_else(|| err_ub!(InvalidTag(Scalar::from_uint(tag_bits, tag_layout.size))))?;\n                 // Return the cast value, and the index.\n                 (discr_val, index.0)\n             }\n@@ -720,18 +727,23 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // discriminant (encoded in niche/tag) and variant index are the same.\n                 let variants_start = niche_variants.start().as_u32();\n                 let variants_end = niche_variants.end().as_u32();\n-                let variant = match tag_val.to_bits_or_ptr(tag_layout.size) {\n-                    Err(ptr) => {\n-                        // The niche must be just 0 (which an inbounds pointer value never is)\n+                let variant = match tag_val.try_to_int() {\n+                    Err(dbg_val) => {\n+                        // So this is a pointer then, and casting to an int failed.\n+                        // Can only happen during CTFE.\n+                        let ptr = self.scalar_to_ptr(tag_val);\n+                        // The niche must be just 0, and the ptr not null, then we know this is\n+                        // okay. Everything else, we conservatively reject.\n                         let ptr_valid = niche_start == 0\n                             && variants_start == variants_end\n-                            && !self.memory.ptr_may_be_null(ptr.into());\n+                            && !self.memory.ptr_may_be_null(ptr);\n                         if !ptr_valid {\n-                            throw_ub!(InvalidTag(tag_val.erase_for_fmt()))\n+                            throw_ub!(InvalidTag(dbg_val))\n                         }\n                         dataful_variant\n                     }\n                     Ok(tag_bits) => {\n+                        let tag_bits = tag_bits.assert_bits(tag_layout.size);\n                         // We need to use machine arithmetic to get the relative variant idx:\n                         // variant_index_relative = tag_val - niche_start_val\n                         let tag_val = ImmTy::from_uint(tag_bits, tag_layout);"}, {"sha": "419c17595a1b7e7734d06c78e22e081c15d388ed", "filename": "compiler/rustc_mir/src/interpret/place.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7c720ce6121dd878b25f8e6a645a07563e5a4b01/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c720ce6121dd878b25f8e6a645a07563e5a4b01/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs?ref=7c720ce6121dd878b25f8e6a645a07563e5a4b01", "patch": "@@ -62,17 +62,6 @@ impl<Tag> MemPlaceMeta<Tag> {\n             Self::None | Self::Poison => false,\n         }\n     }\n-\n-    pub fn erase_for_fmt(self) -> MemPlaceMeta\n-    where\n-        Tag: Provenance,\n-    {\n-        match self {\n-            Self::Meta(s) => MemPlaceMeta::Meta(s.erase_for_fmt()),\n-            Self::None => MemPlaceMeta::None,\n-            Self::Poison => MemPlaceMeta::Poison,\n-        }\n-    }\n }\n \n #[derive(Copy, Clone, Hash, PartialEq, Eq, HashStable)]\n@@ -182,18 +171,6 @@ impl<'tcx, Tag> From<MPlaceTy<'tcx, Tag>> for PlaceTy<'tcx, Tag> {\n }\n \n impl<Tag> MemPlace<Tag> {\n-    #[inline]\n-    pub fn erase_for_fmt(self) -> MemPlace\n-    where\n-        Tag: Provenance,\n-    {\n-        MemPlace {\n-            ptr: self.ptr.map_erase_for_fmt(),\n-            align: self.align,\n-            meta: self.meta.erase_for_fmt(),\n-        }\n-    }\n-\n     #[inline(always)]\n     pub fn from_ptr(ptr: Pointer<Option<Tag>>, align: Align) -> Self {\n         MemPlace { ptr, align, meta: MemPlaceMeta::None }"}, {"sha": "0c7f89c1a36ba10ab46dac0240255cdf8d9501bd", "filename": "compiler/rustc_mir/src/interpret/validity.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7c720ce6121dd878b25f8e6a645a07563e5a4b01/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c720ce6121dd878b25f8e6a645a07563e5a4b01/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs?ref=7c720ce6121dd878b25f8e6a645a07563e5a4b01", "patch": "@@ -535,7 +535,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // types below!\n                 if self.ctfe_mode.is_some() {\n                     // Integers/floats in CTFE: Must be scalar bits, pointers are dangerous\n-                    let is_bits = value.check_init().map_or(false, |v| v.try_to_int().is_some());\n+                    let is_bits = value.check_init().map_or(false, |v| v.try_to_int().is_ok());\n                     if !is_bits {\n                         throw_validation_failure!(self.path,\n                             { \"{}\", value } expected { \"initialized plain (non-pointer) bytes\" }\n@@ -652,11 +652,14 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             err_ub!(InvalidUninitBytes(None)) => { \"{}\", value }\n                 expected { \"something {}\", wrapping_range_format(valid_range, max_hi) },\n         );\n-        let bits = match value.to_bits_or_ptr(op.layout.size) {\n-            Err(ptr) => {\n+        let bits = match value.try_to_int() {\n+            Err(_) => {\n+                // So this is a pointer then, and casting to an int failed.\n+                // Can only happen during CTFE.\n+                let ptr = self.ecx.scalar_to_ptr(value);\n                 if lo == 1 && hi == max_hi {\n                     // Only null is the niche.  So make sure the ptr is NOT null.\n-                    if self.ecx.memory.ptr_may_be_null(ptr.into()) {\n+                    if self.ecx.memory.ptr_may_be_null(ptr) {\n                         throw_validation_failure!(self.path,\n                             { \"a potentially null pointer\" }\n                             expected {\n@@ -678,7 +681,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     )\n                 }\n             }\n-            Ok(data) => data,\n+            Ok(int) => int.assert_bits(op.layout.size),\n         };\n         // Now compare. This is slightly subtle because this is a special \"wrap-around\" range.\n         if wrapping_range_contains(&valid_range, bits) {"}, {"sha": "e02e41d62061a380dd70045ac07b57043f2753d2", "filename": "compiler/rustc_mir/src/transform/const_prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c720ce6121dd878b25f8e6a645a07563e5a4b01/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c720ce6121dd878b25f8e6a645a07563e5a4b01/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs?ref=7c720ce6121dd878b25f8e6a645a07563e5a4b01", "patch": "@@ -921,12 +921,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n         match **op {\n             interpret::Operand::Immediate(Immediate::Scalar(ScalarMaybeUninit::Scalar(s))) => {\n-                s.try_to_int().is_some()\n+                s.try_to_int().is_ok()\n             }\n             interpret::Operand::Immediate(Immediate::ScalarPair(\n                 ScalarMaybeUninit::Scalar(l),\n                 ScalarMaybeUninit::Scalar(r),\n-            )) => l.try_to_int().is_some() && r.try_to_int().is_some(),\n+            )) => l.try_to_int().is_ok() && r.try_to_int().is_ok(),\n             _ => false,\n         }\n     }"}, {"sha": "ace13ea44624d627b8959b0328e7e8310d15ba68", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c720ce6121dd878b25f8e6a645a07563e5a4b01/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c720ce6121dd878b25f8e6a645a07563e5a4b01/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=7c720ce6121dd878b25f8e6a645a07563e5a4b01", "patch": "@@ -123,7 +123,7 @@ impl IntRange {\n                     // straight to the result, after doing a bit of checking. (We\n                     // could remove this branch and just fall through, which\n                     // is more general but much slower.)\n-                    if let Ok(bits) = scalar.to_bits_or_ptr(target_size) {\n+                    if let Ok(bits) = scalar.to_bits_or_ptr_internal(target_size) {\n                         return Some(bits);\n                     }\n                 }"}]}