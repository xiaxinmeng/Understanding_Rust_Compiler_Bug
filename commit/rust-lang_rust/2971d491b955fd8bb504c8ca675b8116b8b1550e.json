{"sha": "2971d491b955fd8bb504c8ca675b8116b8b1550e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5NzFkNDkxYjk1NWZkOGJiNTA0YzhjYTY3NWI4MTE2YjhiMTU1MGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-28T12:09:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-28T12:09:37Z"}, "message": "Auto merge of #41508 - michaelwoerister:generic-path-remapping, r=alexcrichton\n\nImplement a file-path remapping feature in support of debuginfo and reproducible builds\n\nThis PR adds the `-Zremap-path-prefix-from`/`-Zremap-path-prefix-to` commandline option pair and is a more general implementation of #41419. As opposed to the previous attempt, this implementation should enable reproducible builds regardless of the working directory of the compiler.\n\nThis implementation of the feature is more general in the sense that the re-mapping will affect *all* paths the compiler emits, including the ones in error messages.\n\nr? @alexcrichton", "tree": {"sha": "ba93ea8ebe8cf30501b47093968f19936111e063", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba93ea8ebe8cf30501b47093968f19936111e063"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2971d491b955fd8bb504c8ca675b8116b8b1550e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2971d491b955fd8bb504c8ca675b8116b8b1550e", "html_url": "https://github.com/rust-lang/rust/commit/2971d491b955fd8bb504c8ca675b8116b8b1550e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2971d491b955fd8bb504c8ca675b8116b8b1550e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ace517da0d1e356aa5b42f4cdee6854538591ef2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ace517da0d1e356aa5b42f4cdee6854538591ef2", "html_url": "https://github.com/rust-lang/rust/commit/ace517da0d1e356aa5b42f4cdee6854538591ef2"}, {"sha": "8ea050d89dbdb133ee6f17314a1b1acfbc42363f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ea050d89dbdb133ee6f17314a1b1acfbc42363f", "html_url": "https://github.com/rust-lang/rust/commit/8ea050d89dbdb133ee6f17314a1b1acfbc42363f"}], "stats": {"total": 860, "additions": 547, "deletions": 313}, "files": [{"sha": "0d0485dc872d7bd379744132b380a175b7d6bac1", "filename": "src/doc/unstable-book/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -2,6 +2,7 @@\n \n - [Compiler flags](compiler-flags.md)\n     - [linker_flavor](compiler-flags/linker-flavor.md)\n+    - [remap_path_prefix](compiler-flags/remap-path-prefix.md)\n - [Language features](language-features.md)\n     - [abi_msp430_interrupt](language-features/abi-msp430-interrupt.md)\n     - [abi_ptx](language-features/abi-ptx.md)"}, {"sha": "8ca04d253259258af86b8e2546cc28f943d8734d", "filename": "src/doc/unstable-book/src/compiler-flags/remap-path-prefix.md", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fremap-path-prefix.md", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fremap-path-prefix.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fremap-path-prefix.md?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -0,0 +1,37 @@\n+# `remap-path-prefix`\n+\n+The tracking issue for this feature is: [#41555](https://github.com/rust-lang/rust/issues/41555)\n+\n+------------------------\n+\n+The `-Z remap-path-prefix-from`, `-Z remap-path-prefix-to` commandline option\n+pair allows to replace prefixes of any file paths the compiler emits in various\n+places. This is useful for bringing debuginfo paths into a well-known form and\n+for achieving reproducible builds independent of the directory the compiler was\n+executed in. All paths emitted by the compiler are affected, including those in\n+error messages.\n+\n+In order to map all paths starting with `/home/foo/my-project/src` to\n+`/sources/my-project`, one would invoke the compiler as follows:\n+\n+```text\n+rustc -Zremap-path-prefix-from=\"/home/foo/my-project/src\" -Zremap-path-prefix-to=\"/sources/my-project\"\n+```\n+\n+Debuginfo for code from the file `/home/foo/my-project/src/foo/mod.rs`,\n+for example, would then point debuggers to `/sources/my-project/foo/mod.rs`\n+instead of the original file.\n+\n+The options can be specified multiple times when multiple prefixes should be\n+mapped:\n+\n+```text\n+rustc -Zremap-path-prefix-from=\"/home/foo/my-project/src\" \\\n+      -Zremap-path-prefix-to=\"/sources/my-project\" \\\n+      -Zremap-path-prefix-from=\"/home/foo/my-project/build-dir\" \\\n+      -Zremap-path-prefix-to=\"/stable-build-dir\"\n+```\n+\n+When the options are given multiple times, the nth `-from` will be matched up\n+with the nth `-to` and they can appear anywhere on the commandline. Mappings\n+specified later on the line will take precedence over earlier ones."}, {"sha": "3ac043f7aa9bc13568c73c482ce5484a3a09f745", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -296,7 +296,7 @@ fn main() {\n                                          syntax::errors::registry::Registry::new(&[]),\n                                          Rc::new(DummyCrateStore));\n     let filemap = session.parse_sess.codemap()\n-                         .new_filemap(\"<n/a>\".to_string(), None, code);\n+                         .new_filemap(\"<n/a>\".to_string(), code);\n     let mut lexer = lexer::StringReader::new(session.diagnostic(), filemap);\n     let cm = session.codemap();\n "}, {"sha": "0bb4cd69e0cd18e5cd1e8a50fb0f22534fe69b0c", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -25,6 +25,7 @@ use lint;\n use middle::cstore;\n \n use syntax::ast::{self, IntTy, UintTy};\n+use syntax::codemap::FilePathMapping;\n use syntax::parse::token;\n use syntax::parse;\n use syntax::symbol::Symbol;\n@@ -492,6 +493,14 @@ impl Options {\n         self.incremental.is_none() ||\n         self.cg.codegen_units == 1\n     }\n+\n+    pub fn file_path_mapping(&self) -> FilePathMapping {\n+        FilePathMapping::new(\n+            self.debugging_opts.remap_path_prefix_from.iter().zip(\n+                self.debugging_opts.remap_path_prefix_to.iter()\n+            ).map(|(src, dst)| (src.clone(), dst.clone())).collect()\n+        )\n+    }\n }\n \n // The type of entry function, so\n@@ -1012,6 +1021,10 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"Set the optimization fuel quota for a crate.\"),\n     print_fuel: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"Make Rustc print the total optimization fuel used by a crate.\"),\n+    remap_path_prefix_from: Vec<String> = (vec![], parse_string_push, [TRACKED],\n+        \"add a source pattern to the file path remapping config\"),\n+    remap_path_prefix_to: Vec<String> = (vec![], parse_string_push, [TRACKED],\n+        \"add a mapping target to the file path remapping config\"),\n }\n \n pub fn default_lib_output() -> CrateType {\n@@ -1319,7 +1332,7 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n pub fn parse_cfgspecs(cfgspecs: Vec<String> ) -> ast::CrateConfig {\n     cfgspecs.into_iter().map(|s| {\n-        let sess = parse::ParseSess::new();\n+        let sess = parse::ParseSess::new(FilePathMapping::empty());\n         let mut parser =\n             parse::new_parser_from_source_str(&sess, \"cfgspec\".to_string(), s.to_string());\n \n@@ -1430,6 +1443,23 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n         output_types.insert(OutputType::Exe, None);\n     }\n \n+    let remap_path_prefix_sources = debugging_opts.remap_path_prefix_from.len();\n+    let remap_path_prefix_targets = debugging_opts.remap_path_prefix_from.len();\n+\n+    if remap_path_prefix_targets < remap_path_prefix_sources {\n+        for source in &debugging_opts.remap_path_prefix_from[remap_path_prefix_targets..] {\n+            early_error(error_format,\n+                &format!(\"option `-Zremap-path-prefix-from='{}'` does not have \\\n+                         a corresponding `-Zremap-path-prefix-to`\", source))\n+        }\n+    } else if remap_path_prefix_targets > remap_path_prefix_sources {\n+        for target in &debugging_opts.remap_path_prefix_to[remap_path_prefix_sources..] {\n+            early_error(error_format,\n+                &format!(\"option `-Zremap-path-prefix-to='{}'` does not have \\\n+                          a corresponding `-Zremap-path-prefix-from`\", target))\n+        }\n+    }\n+\n     let mut cg = build_codegen_options(matches, error_format);\n \n     // Issue #30063: if user requests llvm-related output to one"}, {"sha": "c8732c31663ebc54f33f5e0b5fde892666e73350", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -74,8 +74,10 @@ pub struct Session {\n     // The name of the root source file of the crate, in the local file system.\n     // The path is always expected to be absolute. `None` means that there is no\n     // source file.\n-    pub local_crate_source_file: Option<PathBuf>,\n-    pub working_dir: PathBuf,\n+    pub local_crate_source_file: Option<String>,\n+    // The directory the compiler has been executed in plus a flag indicating\n+    // if the value stored here has been affected by path remapping.\n+    pub working_dir: (String, bool),\n     pub lint_store: RefCell<lint::LintStore>,\n     pub lints: RefCell<lint::LintTable>,\n     /// Set of (LintId, span, message) tuples tracking lint (sub)diagnostics\n@@ -553,12 +555,14 @@ pub fn build_session(sopts: config::Options,\n                      registry: errors::registry::Registry,\n                      cstore: Rc<CrateStore>)\n                      -> Session {\n+    let file_path_mapping = sopts.file_path_mapping();\n+\n     build_session_with_codemap(sopts,\n                                dep_graph,\n                                local_crate_source_file,\n                                registry,\n                                cstore,\n-                               Rc::new(codemap::CodeMap::new()),\n+                               Rc::new(codemap::CodeMap::new(file_path_mapping)),\n                                None)\n }\n \n@@ -622,7 +626,7 @@ pub fn build_session_(sopts: config::Options,\n         Ok(t) => t,\n         Err(e) => {\n             panic!(span_diagnostic.fatal(&format!(\"Error loading host specification: {}\", e)));\n-    }\n+        }\n     };\n     let target_cfg = config::build_target_config(&sopts, &span_diagnostic);\n     let p_s = parse::ParseSess::with_span_handler(span_diagnostic, codemap);\n@@ -631,21 +635,22 @@ pub fn build_session_(sopts: config::Options,\n         None => Some(filesearch::get_or_default_sysroot())\n     };\n \n+    let file_path_mapping = sopts.file_path_mapping();\n+\n     // Make the path absolute, if necessary\n-    let local_crate_source_file = local_crate_source_file.map(|path|\n-        if path.is_absolute() {\n-            path.clone()\n-        } else {\n-            env::current_dir().unwrap().join(&path)\n-        }\n-    );\n+    let local_crate_source_file = local_crate_source_file.map(|path| {\n+        file_path_mapping.map_prefix(path.to_string_lossy().into_owned()).0\n+    });\n \n     let optimization_fuel_crate = sopts.debugging_opts.fuel.as_ref().map(|i| i.0.clone());\n     let optimization_fuel_limit = Cell::new(sopts.debugging_opts.fuel.as_ref()\n         .map(|i| i.1).unwrap_or(0));\n     let print_fuel_crate = sopts.debugging_opts.print_fuel.clone();\n     let print_fuel = Cell::new(0);\n \n+    let working_dir = env::current_dir().unwrap().to_string_lossy().into_owned();\n+    let working_dir = file_path_mapping.map_prefix(working_dir);\n+\n     let sess = Session {\n         dep_graph: dep_graph.clone(),\n         target: target_cfg,\n@@ -660,7 +665,7 @@ pub fn build_session_(sopts: config::Options,\n         derive_registrar_fn: Cell::new(None),\n         default_sysroot: default_sysroot,\n         local_crate_source_file: local_crate_source_file,\n-        working_dir: env::current_dir().unwrap(),\n+        working_dir: working_dir,\n         lint_store: RefCell::new(lint::LintStore::new()),\n         lints: RefCell::new(lint::LintTable::new()),\n         one_time_diagnostics: RefCell::new(FxHashSet()),"}, {"sha": "e4ed2b8eb8fabda1fad638c30772383eb05721db", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -206,7 +206,7 @@ pub fn run_compiler<'a>(args: &[String],\n     let cstore = Rc::new(CStore::new(&dep_graph));\n \n     let loader = file_loader.unwrap_or(box RealFileLoader);\n-    let codemap = Rc::new(CodeMap::with_file_loader(loader));\n+    let codemap = Rc::new(CodeMap::with_file_loader(loader, sopts.file_path_mapping()));\n     let mut sess = session::build_session_with_codemap(\n         sopts, &dep_graph, input_file_path, descriptions, cstore.clone(), codemap, emitter_dest,\n     );"}, {"sha": "a19bc4aea2c9dba97aeac93ea82bf4b7cb0452b4", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -31,7 +31,7 @@ use rustc::session::{self, config};\n use std::rc::Rc;\n use syntax::ast;\n use syntax::abi::Abi;\n-use syntax::codemap::CodeMap;\n+use syntax::codemap::{CodeMap, FilePathMapping};\n use errors;\n use errors::emitter::Emitter;\n use errors::{Level, DiagnosticBuilder};\n@@ -108,7 +108,7 @@ fn test_env<F>(source_string: &str,\n                                        &dep_graph,\n                                        None,\n                                        diagnostic_handler,\n-                                       Rc::new(CodeMap::new()),\n+                                       Rc::new(CodeMap::new(FilePathMapping::empty())),\n                                        cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let input = config::Input::Str {"}, {"sha": "8bfe3ec1bd5d0d6f160518fdfbba714869481c12", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -397,7 +397,7 @@ impl CrateStore for cstore::CStore {\n         let (name, def) = data.get_macro(id.index);\n         let source_name = format!(\"<{} macros>\", name);\n \n-        let filemap = sess.parse_sess.codemap().new_filemap(source_name, None, def.body);\n+        let filemap = sess.parse_sess.codemap().new_filemap(source_name, def.body);\n         let local_span = Span { lo: filemap.start_pos, hi: filemap.end_pos, ctxt: NO_EXPANSION };\n         let body = filemap_to_stream(&sess.parse_sess, filemap);\n "}, {"sha": "502149c59b7e850cea692765d2ecf017424cbeab", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -1138,7 +1138,7 @@ impl<'a, 'tcx> CrateMetadata {\n                         // We can't reuse an existing FileMap, so allocate a new one\n                         // containing the information we need.\n                         let syntax_pos::FileMap { name,\n-                                                  abs_path,\n+                                                  name_was_remapped,\n                                                   start_pos,\n                                                   end_pos,\n                                                   lines,\n@@ -1162,7 +1162,7 @@ impl<'a, 'tcx> CrateMetadata {\n                         }\n \n                         let local_version = local_codemap.new_imported_filemap(name,\n-                                                                               abs_path,\n+                                                                               name_was_remapped,\n                                                                                source_length,\n                                                                                lines,\n                                                                                multibyte_chars);"}, {"sha": "904a8132f293c5997d4b9981e6dec8e3773496e7", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -30,6 +30,7 @@ use std::hash::Hash;\n use std::intrinsics;\n use std::io::prelude::*;\n use std::io::Cursor;\n+use std::path::Path;\n use std::rc::Rc;\n use std::u32;\n use syntax::ast::{self, CRATE_NODE_ID};\n@@ -1270,13 +1271,40 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_codemap(&mut self) -> LazySeq<syntax_pos::FileMap> {\n         let codemap = self.tcx.sess.codemap();\n         let all_filemaps = codemap.files.borrow();\n-        self.lazy_seq_ref(all_filemaps.iter()\n+        let adapted = all_filemaps.iter()\n             .filter(|filemap| {\n                 // No need to re-export imported filemaps, as any downstream\n                 // crate will import them from their original source.\n                 !filemap.is_imported()\n             })\n-            .map(|filemap| &**filemap))\n+            .map(|filemap| {\n+                // When exporting FileMaps, we expand all paths to absolute\n+                // paths because any relative paths are potentially relative to\n+                // a wrong directory.\n+                // However, if a path has been modified via\n+                // `-Zremap-path-prefix` we assume the user has already set\n+                // things up the way they want and don't touch the path values\n+                // anymore.\n+                let name = Path::new(&filemap.name);\n+                let (ref working_dir, working_dir_was_remapped) = self.tcx.sess.working_dir;\n+                if filemap.name_was_remapped ||\n+                   (name.is_relative() && working_dir_was_remapped) {\n+                    // This path of this FileMap has been modified by\n+                    // path-remapping, so we use it verbatim (and avoid cloning\n+                    // the whole map in the process).\n+                    filemap.clone()\n+                } else {\n+                    let mut adapted = (**filemap).clone();\n+                    let abs_path = Path::new(working_dir).join(name)\n+                                                         .to_string_lossy()\n+                                                         .into_owned();\n+                    adapted.name = abs_path;\n+                    Rc::new(adapted)\n+                }\n+            })\n+            .collect::<Vec<_>>();\n+\n+        self.lazy_seq_ref(adapted.iter().map(|fm| &**fm))\n     }\n \n     fn encode_def_path_table(&mut self) -> Lazy<DefPathTable> {"}, {"sha": "5efb2e1eebad4e3c00139262641b8a502fc9217c", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -37,6 +37,7 @@ use rustc::ty::{self, TyCtxt, AssociatedItemContainer};\n use std::collections::HashSet;\n use std::collections::hash_map::DefaultHasher;\n use std::hash::*;\n+use std::path::Path;\n \n use syntax::ast::{self, NodeId, PatKind, Attribute, CRATE_NODE_ID};\n use syntax::parse::token;\n@@ -128,6 +129,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n     pub fn dump_crate_info(&mut self, name: &str, krate: &ast::Crate) {\n         let source_file = self.tcx.sess.local_crate_source_file.as_ref();\n         let crate_root = source_file.map(|source_file| {\n+            let source_file = Path::new(source_file);\n             match source_file.file_name() {\n                 Some(_) => source_file.parent().unwrap().display().to_string(),\n                 None => source_file.display().to_string(),"}, {"sha": "ae618c7e170df4b4a07d4e93194070b12701023f", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::FunctionDebugContext;\n+use super::{FunctionDebugContext, FunctionDebugContextData};\n use super::metadata::file_metadata;\n use super::utils::{DIB, span_start};\n \n use llvm;\n-use llvm::debuginfo::{DIScope, DISubprogram};\n+use llvm::debuginfo::DIScope;\n use common::CrateContext;\n use rustc::mir::{Mir, VisibilityScope};\n \n@@ -53,8 +53,8 @@ pub fn create_mir_scopes(ccx: &CrateContext, mir: &Mir, debug_context: &Function\n     };\n     let mut scopes = IndexVec::from_elem(null_scope, &mir.visibility_scopes);\n \n-    let fn_metadata = match *debug_context {\n-        FunctionDebugContext::RegularContext(ref data) => data.fn_metadata,\n+    let debug_context = match *debug_context {\n+        FunctionDebugContext::RegularContext(ref data) => data,\n         FunctionDebugContext::DebugInfoDisabled |\n         FunctionDebugContext::FunctionWithoutDebugInfo => {\n             return scopes;\n@@ -71,7 +71,7 @@ pub fn create_mir_scopes(ccx: &CrateContext, mir: &Mir, debug_context: &Function\n     // Instantiate all scopes.\n     for idx in 0..mir.visibility_scopes.len() {\n         let scope = VisibilityScope::new(idx);\n-        make_mir_scope(ccx, &mir, &has_variables, fn_metadata, scope, &mut scopes);\n+        make_mir_scope(ccx, &mir, &has_variables, debug_context, scope, &mut scopes);\n     }\n \n     scopes\n@@ -80,7 +80,7 @@ pub fn create_mir_scopes(ccx: &CrateContext, mir: &Mir, debug_context: &Function\n fn make_mir_scope(ccx: &CrateContext,\n                   mir: &Mir,\n                   has_variables: &BitVector,\n-                  fn_metadata: DISubprogram,\n+                  debug_context: &FunctionDebugContextData,\n                   scope: VisibilityScope,\n                   scopes: &mut IndexVec<VisibilityScope, MirDebugScope>) {\n     if scopes[scope].is_valid() {\n@@ -89,13 +89,13 @@ fn make_mir_scope(ccx: &CrateContext,\n \n     let scope_data = &mir.visibility_scopes[scope];\n     let parent_scope = if let Some(parent) = scope_data.parent_scope {\n-        make_mir_scope(ccx, mir, has_variables, fn_metadata, parent, scopes);\n+        make_mir_scope(ccx, mir, has_variables, debug_context, parent, scopes);\n         scopes[parent]\n     } else {\n         // The root is the function itself.\n         let loc = span_start(ccx, mir.span);\n         scopes[scope] = MirDebugScope {\n-            scope_metadata: fn_metadata,\n+            scope_metadata: debug_context.fn_metadata,\n             file_start_pos: loc.file.start_pos,\n             file_end_pos: loc.file.end_pos,\n         };\n@@ -109,14 +109,17 @@ fn make_mir_scope(ccx: &CrateContext,\n         // However, we don't skip creating a nested scope if\n         // our parent is the root, because we might want to\n         // put arguments in the root and not have shadowing.\n-        if parent_scope.scope_metadata != fn_metadata {\n+        if parent_scope.scope_metadata != debug_context.fn_metadata {\n             scopes[scope] = parent_scope;\n             return;\n         }\n     }\n \n     let loc = span_start(ccx, scope_data.span);\n-    let file_metadata = file_metadata(ccx, &loc.file.name, &loc.file.abs_path);\n+    let file_metadata = file_metadata(ccx,\n+                                      &loc.file.name,\n+                                      debug_context.defining_crate);\n+\n     let scope_metadata = unsafe {\n         llvm::LLVMRustDIBuilderCreateLexicalBlock(\n             DIB(ccx),"}, {"sha": "188f8ee3366370ccb30fdb1309630a9f0056d627", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 41, "deletions": 50, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -26,7 +26,7 @@ use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor,\n                       DICompositeType, DILexicalBlock, DIFlags};\n \n use rustc::hir::def::CtorKind;\n-use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use rustc::ty::fold::TypeVisitor;\n use rustc::ty::subst::Substs;\n use rustc::ty::util::TypeIdHasher;\n@@ -39,14 +39,12 @@ use rustc::ty::{self, AdtKind, Ty};\n use rustc::ty::layout::{self, LayoutTyper};\n use session::config;\n use util::nodemap::FxHashMap;\n-use util::common::path2cstr;\n \n use libc::{c_uint, c_longlong};\n use std::ffi::CString;\n-use std::path::Path;\n use std::ptr;\n use syntax::ast;\n-use syntax::symbol::{Interner, InternedString};\n+use syntax::symbol::{Interner, InternedString, Symbol};\n use syntax_pos::{self, Span};\n \n \n@@ -349,8 +347,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     assert!(member_descriptions.len() == member_llvm_types.len());\n \n-    let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, &loc.file.name, &loc.file.abs_path);\n+    let file_metadata = unknown_file_metadata(cx);\n \n     let metadata = composite_type_metadata(cx,\n                                            slice_llvm_type,\n@@ -659,44 +656,51 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     metadata\n }\n \n-pub fn file_metadata(cx: &CrateContext, path: &str, full_path: &Option<String>) -> DIFile {\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let work_dir = cx.sess().working_dir.to_str().unwrap();\n-    let file_name =\n-        full_path.as_ref().map(|p| p.as_str()).unwrap_or_else(|| {\n-            if path.starts_with(work_dir) {\n-                &path[work_dir.len() + 1..path.len()]\n-            } else {\n-                path\n-            }\n-        });\n+pub fn file_metadata(cx: &CrateContext,\n+                     file_name: &str,\n+                     defining_crate: CrateNum) -> DIFile {\n+    debug!(\"file_metadata: file_name: {}, defining_crate: {}\",\n+           file_name,\n+           defining_crate);\n \n-    file_metadata_(cx, path, file_name, &work_dir)\n+    let directory = if defining_crate == LOCAL_CRATE {\n+        &cx.sess().working_dir.0[..]\n+    } else {\n+        // If the path comes from an upstream crate we assume it has been made\n+        // independent of the compiler's working directory one way or another.\n+        \"\"\n+    };\n+\n+    file_metadata_raw(cx, file_name, directory)\n }\n \n pub fn unknown_file_metadata(cx: &CrateContext) -> DIFile {\n-    // Regular filenames should not be empty, so we abuse an empty name as the\n-    // key for the special unknown file metadata\n-    file_metadata_(cx, \"\", \"<unknown>\", \"\")\n-\n+    file_metadata_raw(cx, \"<unknown>\", \"\")\n }\n \n-fn file_metadata_(cx: &CrateContext, key: &str, file_name: &str, work_dir: &str) -> DIFile {\n-    if let Some(file_metadata) = debug_context(cx).created_files.borrow().get(key) {\n+fn file_metadata_raw(cx: &CrateContext,\n+                     file_name: &str,\n+                     directory: &str)\n+                     -> DIFile {\n+    let key = (Symbol::intern(file_name), Symbol::intern(directory));\n+\n+    if let Some(file_metadata) = debug_context(cx).created_files.borrow().get(&key) {\n         return *file_metadata;\n     }\n \n-    debug!(\"file_metadata: file_name: {}, work_dir: {}\", file_name, work_dir);\n+    debug!(\"file_metadata: file_name: {}, directory: {}\", file_name, directory);\n \n     let file_name = CString::new(file_name).unwrap();\n-    let work_dir = CString::new(work_dir).unwrap();\n+    let directory = CString::new(directory).unwrap();\n+\n     let file_metadata = unsafe {\n-        llvm::LLVMRustDIBuilderCreateFile(DIB(cx), file_name.as_ptr(),\n-                                          work_dir.as_ptr())\n+        llvm::LLVMRustDIBuilderCreateFile(DIB(cx),\n+                                          file_name.as_ptr(),\n+                                          directory.as_ptr())\n     };\n \n     let mut created_files = debug_context(cx).created_files.borrow_mut();\n-    created_files.insert(key.to_string(), file_metadata);\n+    created_files.insert(key, file_metadata);\n     file_metadata\n }\n \n@@ -761,25 +765,10 @@ pub fn compile_unit_metadata(scc: &SharedCrateContext,\n                              debug_context: &CrateDebugContext,\n                              sess: &Session)\n                              -> DIDescriptor {\n-    let work_dir = &sess.working_dir;\n     let compile_unit_name = match sess.local_crate_source_file {\n         None => fallback_path(scc),\n-        Some(ref abs_path) => {\n-            if abs_path.is_relative() {\n-                sess.warn(\"debuginfo: Invalid path to crate's local root source file!\");\n-                fallback_path(scc)\n-            } else {\n-                match abs_path.strip_prefix(work_dir) {\n-                    Ok(ref p) if p.is_relative() => {\n-                        if p.starts_with(Path::new(\"./\")) {\n-                            path2cstr(p)\n-                        } else {\n-                            path2cstr(&Path::new(\".\").join(p))\n-                        }\n-                    }\n-                    _ => fallback_path(scc)\n-                }\n-            }\n+        Some(ref path) => {\n+            CString::new(&path[..]).unwrap()\n         }\n     };\n \n@@ -789,7 +778,8 @@ pub fn compile_unit_metadata(scc: &SharedCrateContext,\n                            (option_env!(\"CFG_VERSION\")).expect(\"CFG_VERSION\"));\n \n     let compile_unit_name = compile_unit_name.as_ptr();\n-    let work_dir = path2cstr(&work_dir);\n+\n+    let work_dir = CString::new(&sess.working_dir.0[..]).unwrap();\n     let producer = CString::new(producer).unwrap();\n     let flags = \"\\0\";\n     let split_name = \"\\0\";\n@@ -1760,7 +1750,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n \n     let (file_metadata, line_number) = if span != syntax_pos::DUMMY_SP {\n         let loc = span_start(cx, span);\n-        (file_metadata(cx, &loc.file.name, &loc.file.abs_path), loc.line as c_uint)\n+        (file_metadata(cx, &loc.file.name, LOCAL_CRATE), loc.line as c_uint)\n     } else {\n         (unknown_file_metadata(cx), UNKNOWN_LINE_NUMBER)\n     };\n@@ -1795,9 +1785,10 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n // Creates an \"extension\" of an existing DIScope into another file.\n pub fn extend_scope_to_file(ccx: &CrateContext,\n                             scope_metadata: DIScope,\n-                            file: &syntax_pos::FileMap)\n+                            file: &syntax_pos::FileMap,\n+                            defining_crate: CrateNum)\n                             -> DILexicalBlock {\n-    let file_metadata = file_metadata(ccx, &file.name, &file.abs_path);\n+    let file_metadata = file_metadata(ccx, &file.name, defining_crate);\n     unsafe {\n         llvm::LLVMRustDIBuilderCreateLexicalBlockFile(\n             DIB(ccx),"}, {"sha": "ebe42a2b9082d2214acbfdd89a7a817efebe992b", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -23,7 +23,7 @@ use self::source_loc::InternalDebugLocation::{self, UnknownLocation};\n use llvm;\n use llvm::{ModuleRef, ContextRef, ValueRef};\n use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilderRef, DISubprogram, DIArray, DIFlags};\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, CrateNum};\n use rustc::ty::subst::Substs;\n \n use abi::Abi;\n@@ -42,6 +42,7 @@ use std::ptr;\n \n use syntax_pos::{self, Span, Pos};\n use syntax::ast;\n+use syntax::symbol::Symbol;\n use rustc::ty::layout;\n \n pub mod gdb;\n@@ -67,7 +68,7 @@ const DW_TAG_arg_variable: c_uint = 0x101;\n pub struct CrateDebugContext<'tcx> {\n     llcontext: ContextRef,\n     builder: DIBuilderRef,\n-    created_files: RefCell<FxHashMap<String, DIFile>>,\n+    created_files: RefCell<FxHashMap<(Symbol, Symbol), DIFile>>,\n     created_enum_disr_types: RefCell<FxHashMap<(DefId, layout::Integer), DIType>>,\n \n     type_map: RefCell<TypeMap<'tcx>>,\n@@ -103,7 +104,7 @@ pub enum FunctionDebugContext {\n }\n \n impl FunctionDebugContext {\n-    fn get_ref<'a>(&'a self, span: Span) -> &'a FunctionDebugContextData {\n+    pub fn get_ref<'a>(&'a self, span: Span) -> &'a FunctionDebugContextData {\n         match *self {\n             FunctionDebugContext::RegularContext(ref data) => data,\n             FunctionDebugContext::DebugInfoDisabled => {\n@@ -128,6 +129,7 @@ impl FunctionDebugContext {\n pub struct FunctionDebugContextData {\n     fn_metadata: DISubprogram,\n     source_locations_enabled: Cell<bool>,\n+    pub defining_crate: CrateNum,\n }\n \n pub enum VariableAccess<'a> {\n@@ -220,24 +222,25 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         return FunctionDebugContext::FunctionWithoutDebugInfo;\n     }\n \n+    let def_id = instance.def_id();\n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, &loc.file.name, &loc.file.abs_path);\n+    let file_metadata = file_metadata(cx, &loc.file.name, def_id.krate);\n \n     let function_type_metadata = unsafe {\n         let fn_signature = get_function_signature(cx, sig);\n         llvm::LLVMRustDIBuilderCreateSubroutineType(DIB(cx), file_metadata, fn_signature)\n     };\n \n     // Find the enclosing function, in case this is a closure.\n-    let def_key = cx.tcx().def_key(instance.def_id());\n+    let def_key = cx.tcx().def_key(def_id);\n     let mut name = def_key.disambiguated_data.data.to_string();\n     let name_len = name.len();\n \n-    let fn_def_id = cx.tcx().closure_base_def_id(instance.def_id());\n+    let enclosing_fn_def_id = cx.tcx().closure_base_def_id(def_id);\n \n     // Get_template_parameters() will append a `<...>` clause to the function\n     // name if necessary.\n-    let generics = cx.tcx().generics_of(fn_def_id);\n+    let generics = cx.tcx().generics_of(enclosing_fn_def_id);\n     let substs = instance.substs.truncate_to(cx.tcx(), generics);\n     let template_parameters = get_template_parameters(cx,\n                                                       &generics,\n@@ -289,6 +292,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let fn_debug_context = FunctionDebugContextData {\n         fn_metadata: fn_metadata,\n         source_locations_enabled: Cell::new(false),\n+        defining_crate: def_id.krate,\n     };\n \n     return FunctionDebugContext::RegularContext(fn_debug_context);\n@@ -438,8 +442,9 @@ pub fn declare_local<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     let cx = bcx.ccx;\n \n     let file = span_start(cx, span).file;\n-    let filename = file.name.clone();\n-    let file_metadata = file_metadata(cx, &filename[..], &file.abs_path);\n+    let file_metadata = file_metadata(cx,\n+                                      &file.name[..],\n+                                      dbg_context.get_ref(span).defining_crate);\n \n     let loc = span_start(cx, span);\n     let type_metadata = type_metadata(cx, variable_type, span);"}, {"sha": "54a129536d03dfad5f33bfb3b00477d2cf60e799", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -72,7 +72,7 @@ pub fn item_namespace(ccx: &CrateContext, def_id: DefId) -> DIScope {\n     let span = ccx.tcx().def_span(def_id);\n     let (file, line) = if span != DUMMY_SP {\n         let loc = span_start(ccx, span);\n-        (file_metadata(ccx, &loc.file.name, &loc.file.abs_path), loc.line as c_uint)\n+        (file_metadata(ccx, &loc.file.name, def_id.krate), loc.line as c_uint)\n     } else {\n         (unknown_file_metadata(ccx), UNKNOWN_LINE_NUMBER)\n     };"}, {"sha": "19a556bf3f0f9b27af268a234b5a73a1ee343bcd", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -157,7 +157,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         if pos < self.scopes[scope_id].file_start_pos ||\n            pos >= self.scopes[scope_id].file_end_pos {\n             let cm = self.ccx.sess().codemap();\n-            debuginfo::extend_scope_to_file(self.ccx, scope_metadata, &cm.lookup_char_pos(pos).file)\n+            let defining_crate = self.debug_context.get_ref(DUMMY_SP).defining_crate;\n+            debuginfo::extend_scope_to_file(self.ccx,\n+                                            scope_metadata,\n+                                            &cm.lookup_char_pos(pos).file,\n+                                            defining_crate)\n         } else {\n             scope_metadata\n         }"}, {"sha": "6417270b9c73bc8a1ce8c0a137a8f950ff4bfaba", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -129,7 +129,7 @@ pub fn run_core(search_paths: SearchPaths,\n         ..config::basic_options().clone()\n     };\n \n-    let codemap = Rc::new(codemap::CodeMap::new());\n+    let codemap = Rc::new(codemap::CodeMap::new(sessopts.file_path_mapping()));\n     let diagnostic_handler = errors::Handler::with_tty_emitter(ColorConfig::Auto,\n                                                                true,\n                                                                false,"}, {"sha": "15dada10c0dc11d7758761762c7ad1924cbeb924", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -26,7 +26,7 @@ use std::fmt::Display;\n use std::io;\n use std::io::prelude::*;\n \n-use syntax::codemap::CodeMap;\n+use syntax::codemap::{CodeMap, FilePathMapping};\n use syntax::parse::lexer::{self, TokenAndSpan};\n use syntax::parse::token;\n use syntax::parse;\n@@ -36,8 +36,8 @@ use syntax_pos::Span;\n pub fn render_with_highlighting(src: &str, class: Option<&str>, id: Option<&str>,\n                                 extension: Option<&str>) -> String {\n     debug!(\"highlighting: ================\\n{}\\n==============\", src);\n-    let sess = parse::ParseSess::new();\n-    let fm = sess.codemap().new_filemap(\"<stdin>\".to_string(), None, src.to_string());\n+    let sess = parse::ParseSess::new(FilePathMapping::empty());\n+    let fm = sess.codemap().new_filemap(\"<stdin>\".to_string(), src.to_string());\n \n     let mut out = Vec::new();\n     write_header(class, id, &mut out).unwrap();\n@@ -58,8 +58,8 @@ pub fn render_with_highlighting(src: &str, class: Option<&str>, id: Option<&str>\n /// be inserted into an element. C.f., `render_with_highlighting` which includes\n /// an enclosing `<pre>` block.\n pub fn render_inner_with_highlighting(src: &str) -> io::Result<String> {\n-    let sess = parse::ParseSess::new();\n-    let fm = sess.codemap().new_filemap(\"<stdin>\".to_string(), None, src.to_string());\n+    let sess = parse::ParseSess::new(FilePathMapping::empty());\n+    let fm = sess.codemap().new_filemap(\"<stdin>\".to_string(), src.to_string());\n \n     let mut out = Vec::new();\n     let mut classifier = Classifier::new(lexer::StringReader::new(&sess, fm), sess.codemap());"}, {"sha": "5428b0663f36808f6f87a66bcff5c6e8d8c151b4", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -74,7 +74,7 @@ pub fn run(input: &str,\n         ..config::basic_options().clone()\n     };\n \n-    let codemap = Rc::new(CodeMap::new());\n+    let codemap = Rc::new(CodeMap::new(sessopts.file_path_mapping()));\n     let handler =\n         errors::Handler::with_tty_emitter(ColorConfig::Auto, true, false, Some(codemap.clone()));\n \n@@ -217,7 +217,7 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n         }\n     }\n     let data = Arc::new(Mutex::new(Vec::new()));\n-    let codemap = Rc::new(CodeMap::new());\n+    let codemap = Rc::new(CodeMap::new(sessopts.file_path_mapping()));\n     let emitter = errors::emitter::EmitterWriter::new(box Sink(data.clone()),\n                                                       Some(codemap.clone()));\n     let old = io::set_panic(Some(box Sink(data.clone())));"}, {"sha": "8a88ec3a6724fc0df57382592d07b0c5f1c17553", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 69, "deletions": 32, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -104,32 +104,42 @@ impl FileLoader for RealFileLoader {\n \n pub struct CodeMap {\n     pub files: RefCell<Vec<Rc<FileMap>>>,\n-    file_loader: Box<FileLoader>\n+    file_loader: Box<FileLoader>,\n+    // This is used to apply the file path remapping as specified via\n+    // -Zremap-path-prefix to all FileMaps allocated within this CodeMap.\n+    path_mapping: FilePathMapping,\n }\n \n impl CodeMap {\n-    pub fn new() -> CodeMap {\n+    pub fn new(path_mapping: FilePathMapping) -> CodeMap {\n         CodeMap {\n             files: RefCell::new(Vec::new()),\n-            file_loader: Box::new(RealFileLoader)\n+            file_loader: Box::new(RealFileLoader),\n+            path_mapping: path_mapping,\n         }\n     }\n \n-    pub fn with_file_loader(file_loader: Box<FileLoader>) -> CodeMap {\n+    pub fn with_file_loader(file_loader: Box<FileLoader>,\n+                            path_mapping: FilePathMapping)\n+                            -> CodeMap {\n         CodeMap {\n             files: RefCell::new(Vec::new()),\n-            file_loader: file_loader\n+            file_loader: file_loader,\n+            path_mapping: path_mapping,\n         }\n     }\n \n+    pub fn path_mapping(&self) -> &FilePathMapping {\n+        &self.path_mapping\n+    }\n+\n     pub fn file_exists(&self, path: &Path) -> bool {\n         self.file_loader.file_exists(path)\n     }\n \n     pub fn load_file(&self, path: &Path) -> io::Result<Rc<FileMap>> {\n         let src = self.file_loader.read_file(path)?;\n-        let abs_path = self.file_loader.abs_path(path).map(|p| p.to_str().unwrap().to_string());\n-        Ok(self.new_filemap(path.to_str().unwrap().to_string(), abs_path, src))\n+        Ok(self.new_filemap(path.to_str().unwrap().to_string(), src))\n     }\n \n     fn next_start_pos(&self) -> usize {\n@@ -144,8 +154,7 @@ impl CodeMap {\n \n     /// Creates a new filemap without setting its line information. If you don't\n     /// intend to set the line information yourself, you should use new_filemap_and_lines.\n-    pub fn new_filemap(&self, filename: FileName, abs_path: Option<FileName>,\n-                       mut src: String) -> Rc<FileMap> {\n+    pub fn new_filemap(&self, filename: FileName, mut src: String) -> Rc<FileMap> {\n         let start_pos = self.next_start_pos();\n         let mut files = self.files.borrow_mut();\n \n@@ -156,9 +165,11 @@ impl CodeMap {\n \n         let end_pos = start_pos + src.len();\n \n+        let (filename, was_remapped) = self.path_mapping.map_prefix(filename);\n+\n         let filemap = Rc::new(FileMap {\n             name: filename,\n-            abs_path: abs_path,\n+            name_was_remapped: was_remapped,\n             src: Some(Rc::new(src)),\n             start_pos: Pos::from_usize(start_pos),\n             end_pos: Pos::from_usize(end_pos),\n@@ -172,11 +183,8 @@ impl CodeMap {\n     }\n \n     /// Creates a new filemap and sets its line information.\n-    pub fn new_filemap_and_lines(&self, filename: &str, abs_path: Option<&str>,\n-                                 src: &str) -> Rc<FileMap> {\n-        let fm = self.new_filemap(filename.to_string(),\n-                                  abs_path.map(|s| s.to_owned()),\n-                                  src.to_owned());\n+    pub fn new_filemap_and_lines(&self, filename: &str, src: &str) -> Rc<FileMap> {\n+        let fm = self.new_filemap(filename.to_string(), src.to_owned());\n         let mut byte_pos: u32 = fm.start_pos.0;\n         for line in src.lines() {\n             // register the start of this line\n@@ -195,7 +203,7 @@ impl CodeMap {\n     /// information for things inlined from other crates.\n     pub fn new_imported_filemap(&self,\n                                 filename: FileName,\n-                                abs_path: Option<FileName>,\n+                                name_was_remapped: bool,\n                                 source_len: usize,\n                                 mut file_local_lines: Vec<BytePos>,\n                                 mut file_local_multibyte_chars: Vec<MultiByteChar>)\n@@ -216,7 +224,7 @@ impl CodeMap {\n \n         let filemap = Rc::new(FileMap {\n             name: filename,\n-            abs_path: abs_path,\n+            name_was_remapped: name_was_remapped,\n             src: None,\n             start_pos: start_pos,\n             end_pos: end_pos,\n@@ -550,6 +558,42 @@ impl CodeMapper for CodeMap {\n     }\n }\n \n+#[derive(Clone)]\n+pub struct FilePathMapping {\n+    mapping: Vec<(String, String)>,\n+}\n+\n+impl FilePathMapping {\n+    pub fn empty() -> FilePathMapping {\n+        FilePathMapping {\n+            mapping: vec![]\n+        }\n+    }\n+\n+    pub fn new(mapping: Vec<(String, String)>) -> FilePathMapping {\n+        FilePathMapping {\n+            mapping: mapping\n+        }\n+    }\n+\n+    /// Applies any path prefix substitution as defined by the mapping.\n+    /// The return value is the remapped path and a boolean indicating whether\n+    /// the path was affected by the mapping.\n+    pub fn map_prefix(&self, path: String) -> (String, bool) {\n+        // NOTE: We are iterating over the mapping entries from last to first\n+        //       because entries specified later on the command line should\n+        //       take precedence.\n+        for &(ref from, ref to) in self.mapping.iter().rev() {\n+            if path.starts_with(from) {\n+                let mapped = path.replacen(from, to, 1);\n+                return (mapped, true);\n+            }\n+        }\n+\n+        (path, false)\n+    }\n+}\n+\n // _____________________________________________________________________________\n // Tests\n //\n@@ -561,9 +605,8 @@ mod tests {\n \n     #[test]\n     fn t1 () {\n-        let cm = CodeMap::new();\n+        let cm = CodeMap::new(FilePathMapping::empty());\n         let fm = cm.new_filemap(\"blork.rs\".to_string(),\n-                                None,\n                                 \"first line.\\nsecond line\".to_string());\n         fm.next_line(BytePos(0));\n         // Test we can get lines with partial line info.\n@@ -578,9 +621,8 @@ mod tests {\n     #[test]\n     #[should_panic]\n     fn t2 () {\n-        let cm = CodeMap::new();\n+        let cm = CodeMap::new(FilePathMapping::empty());\n         let fm = cm.new_filemap(\"blork.rs\".to_string(),\n-                                None,\n                                 \"first line.\\nsecond line\".to_string());\n         // TESTING *REALLY* BROKEN BEHAVIOR:\n         fm.next_line(BytePos(0));\n@@ -589,15 +631,12 @@ mod tests {\n     }\n \n     fn init_code_map() -> CodeMap {\n-        let cm = CodeMap::new();\n+        let cm = CodeMap::new(FilePathMapping::empty());\n         let fm1 = cm.new_filemap(\"blork.rs\".to_string(),\n-                                 None,\n                                  \"first line.\\nsecond line\".to_string());\n         let fm2 = cm.new_filemap(\"empty.rs\".to_string(),\n-                                 None,\n                                  \"\".to_string());\n         let fm3 = cm.new_filemap(\"blork2.rs\".to_string(),\n-                                 None,\n                                  \"first line.\\nsecond line\".to_string());\n \n         fm1.next_line(BytePos(0));\n@@ -656,14 +695,12 @@ mod tests {\n     }\n \n     fn init_code_map_mbc() -> CodeMap {\n-        let cm = CodeMap::new();\n+        let cm = CodeMap::new(FilePathMapping::empty());\n         // \u20ac is a three byte utf8 char.\n         let fm1 =\n             cm.new_filemap(\"blork.rs\".to_string(),\n-                           None,\n                            \"fir\u20acst \u20ac\u20ac\u20ac\u20ac line.\\nsecond line\".to_string());\n         let fm2 = cm.new_filemap(\"blork2.rs\".to_string(),\n-                                 None,\n                                  \"first line\u20ac\u20ac.\\n\u20ac second line\".to_string());\n \n         fm1.next_line(BytePos(0));\n@@ -728,10 +765,10 @@ mod tests {\n     /// lines in the middle of a file.\n     #[test]\n     fn span_to_snippet_and_lines_spanning_multiple_lines() {\n-        let cm = CodeMap::new();\n+        let cm = CodeMap::new(FilePathMapping::empty());\n         let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n         let selection = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n-        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n+        cm.new_filemap_and_lines(\"blork.rs\", inputtext);\n         let span = span_from_selection(inputtext, selection);\n \n         // check that we are extracting the text we thought we were extracting\n@@ -770,11 +807,11 @@ mod tests {\n     /// Test failing to merge two spans on different lines\n     #[test]\n     fn span_merging_fail() {\n-        let cm = CodeMap::new();\n+        let cm = CodeMap::new(FilePathMapping::empty());\n         let inputtext  = \"bbbb BB\\ncc CCC\\n\";\n         let selection1 = \"     ~~\\n      \\n\";\n         let selection2 = \"       \\n   ~~~\\n\";\n-        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n+        cm.new_filemap_and_lines(\"blork.rs\", inputtext);\n         let span1 = span_from_selection(inputtext, selection1);\n         let span2 = span_from_selection(inputtext, selection2);\n "}, {"sha": "2db295d013639e8bcd36463381b5a01328b8eb1a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -783,7 +783,7 @@ fn stream_for_item(item: &Annotatable, parse_sess: &ParseSess) -> TokenStream {\n \n fn string_to_stream(text: String, parse_sess: &ParseSess) -> TokenStream {\n     let filename = String::from(\"<macro expansion>\");\n-    filemap_to_stream(parse_sess, parse_sess.codemap().new_filemap(filename, None, text))\n+    filemap_to_stream(parse_sess, parse_sess.codemap().new_filemap(filename, text))\n }\n \n impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {"}, {"sha": "22a5776315a0cfe6cdf3c1e72e7de81ab0ef4b92", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -142,7 +142,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenT\n             // Add this input file to the code map to make it available as\n             // dependency information\n             let filename = format!(\"{}\", file.display());\n-            cx.codemap().new_filemap_and_lines(&filename, None, &src);\n+            cx.codemap().new_filemap_and_lines(&filename, &src);\n \n             base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&src)))\n         }\n@@ -173,7 +173,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::Toke\n             // Add this input file to the code map to make it available as\n             // dependency information, but don't enter it's contents\n             let filename = format!(\"{}\", file.display());\n-            cx.codemap().new_filemap_and_lines(&filename, None, \"\");\n+            cx.codemap().new_filemap_and_lines(&filename, \"\");\n \n             base::MacEager::expr(cx.expr_lit(sp, ast::LitKind::ByteStr(Rc::new(bytes))))\n         }"}, {"sha": "47b60f0e080d0760518ead367eab8efe8c385dad", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -19,7 +19,7 @@\n \n // FIXME spec the JSON output properly.\n \n-use codemap::CodeMap;\n+use codemap::{CodeMap, FilePathMapping};\n use syntax_pos::{self, MacroBacktrace, Span, SpanLabel, MultiSpan};\n use errors::registry::Registry;\n use errors::{DiagnosticBuilder, SubDiagnostic, RenderSpan, CodeSuggestion, CodeMapper};\n@@ -48,7 +48,8 @@ impl JsonEmitter {\n     }\n \n     pub fn basic() -> JsonEmitter {\n-        JsonEmitter::stderr(None, Rc::new(CodeMap::new()))\n+        let file_path_mapping = FilePathMapping::empty();\n+        JsonEmitter::stderr(None, Rc::new(CodeMap::new(file_path_mapping)))\n     }\n \n     pub fn new(dst: Box<Write + Send>,"}, {"sha": "7ac322b144c7ea46c9641fbb719f87909e0f6998", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -348,8 +348,8 @@ pub fn gather_comments_and_literals(sess: &ParseSess, path: String, srdr: &mut R\n     let mut src = Vec::new();\n     srdr.read_to_end(&mut src).unwrap();\n     let src = String::from_utf8(src).unwrap();\n-    let cm = CodeMap::new();\n-    let filemap = cm.new_filemap(path, None, src);\n+    let cm = CodeMap::new(sess.codemap().path_mapping().clone());\n+    let filemap = cm.new_filemap(path, src);\n     let mut rdr = lexer::StringReader::new_raw(sess, filemap);\n \n     let mut comments: Vec<Comment> = Vec::new();"}, {"sha": "c2e5763237d3c89e0b4f36876365ee073cc40ad4", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -10,7 +10,7 @@\n \n use ast::{self, Ident};\n use syntax_pos::{self, BytePos, CharPos, Pos, Span, NO_EXPANSION};\n-use codemap::CodeMap;\n+use codemap::{CodeMap, FilePathMapping};\n use errors::{FatalError, DiagnosticBuilder};\n use parse::{token, ParseSess};\n use str::char_at;\n@@ -563,7 +563,7 @@ impl<'a> StringReader<'a> {\n \n                 // I guess this is the only way to figure out if\n                 // we're at the beginning of the file...\n-                let cmap = CodeMap::new();\n+                let cmap = CodeMap::new(FilePathMapping::empty());\n                 cmap.files.borrow_mut().push(self.filemap.clone());\n                 let loc = cmap.lookup_char_pos_adj(self.pos);\n                 debug!(\"Skipping a shebang\");\n@@ -1718,13 +1718,13 @@ mod tests {\n                  sess: &'a ParseSess,\n                  teststr: String)\n                  -> StringReader<'a> {\n-        let fm = cm.new_filemap(\"zebra.rs\".to_string(), None, teststr);\n+        let fm = cm.new_filemap(\"zebra.rs\".to_string(), teststr);\n         StringReader::new(sess, fm)\n     }\n \n     #[test]\n     fn t1() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         let mut string_reader = setup(&cm,\n                                       &sh,\n@@ -1776,71 +1776,71 @@ mod tests {\n \n     #[test]\n     fn doublecolonparsing() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         check_tokenization(setup(&cm, &sh, \"a b\".to_string()),\n                            vec![mk_ident(\"a\"), token::Whitespace, mk_ident(\"b\")]);\n     }\n \n     #[test]\n     fn dcparsing_2() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         check_tokenization(setup(&cm, &sh, \"a::b\".to_string()),\n                            vec![mk_ident(\"a\"), token::ModSep, mk_ident(\"b\")]);\n     }\n \n     #[test]\n     fn dcparsing_3() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         check_tokenization(setup(&cm, &sh, \"a ::b\".to_string()),\n                            vec![mk_ident(\"a\"), token::Whitespace, token::ModSep, mk_ident(\"b\")]);\n     }\n \n     #[test]\n     fn dcparsing_4() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         check_tokenization(setup(&cm, &sh, \"a:: b\".to_string()),\n                            vec![mk_ident(\"a\"), token::ModSep, token::Whitespace, mk_ident(\"b\")]);\n     }\n \n     #[test]\n     fn character_a() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"'a'\".to_string()).next_token().tok,\n                    token::Literal(token::Char(Symbol::intern(\"a\")), None));\n     }\n \n     #[test]\n     fn character_space() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"' '\".to_string()).next_token().tok,\n                    token::Literal(token::Char(Symbol::intern(\" \")), None));\n     }\n \n     #[test]\n     fn character_escaped() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"'\\\\n'\".to_string()).next_token().tok,\n                    token::Literal(token::Char(Symbol::intern(\"\\\\n\")), None));\n     }\n \n     #[test]\n     fn lifetime_name() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"'abc\".to_string()).next_token().tok,\n                    token::Lifetime(Ident::from_str(\"'abc\")));\n     }\n \n     #[test]\n     fn raw_string() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\".to_string())\n                        .next_token()\n@@ -1850,7 +1850,7 @@ mod tests {\n \n     #[test]\n     fn literal_suffixes() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         macro_rules! test {\n             ($input: expr, $tok_type: ident, $tok_contents: expr) => {{\n@@ -1894,7 +1894,7 @@ mod tests {\n \n     #[test]\n     fn nested_block_comments() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         let mut lexer = setup(&cm, &sh, \"/* /* */ */'a'\".to_string());\n         match lexer.next_token().tok {\n@@ -1907,7 +1907,7 @@ mod tests {\n \n     #[test]\n     fn crlf_comments() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         let mut lexer = setup(&cm, &sh, \"// test\\r\\n/// test\\r\\n\".to_string());\n         let comment = lexer.next_token();"}, {"sha": "9d8f3b3d039d2ef60768d0a46f00116f40a07878", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -11,7 +11,7 @@\n //! The main parser interface\n \n use ast::{self, CrateConfig};\n-use codemap::CodeMap;\n+use codemap::{CodeMap, FilePathMapping};\n use syntax_pos::{self, Span, FileMap, NO_EXPANSION};\n use errors::{Handler, ColorConfig, DiagnosticBuilder};\n use feature_gate::UnstableFeatures;\n@@ -53,8 +53,8 @@ pub struct ParseSess {\n }\n \n impl ParseSess {\n-    pub fn new() -> Self {\n-        let cm = Rc::new(CodeMap::new());\n+    pub fn new(file_path_mapping: FilePathMapping) -> Self {\n+        let cm = Rc::new(CodeMap::new(file_path_mapping));\n         let handler = Handler::with_tty_emitter(ColorConfig::Auto,\n                                                 true,\n                                                 false,\n@@ -143,13 +143,13 @@ pub fn parse_stmt_from_source_str<'a>(name: String, source: String, sess: &'a Pa\n \n pub fn parse_stream_from_source_str<'a>(name: String, source: String, sess: &'a ParseSess)\n                                         -> TokenStream {\n-    filemap_to_stream(sess, sess.codemap().new_filemap(name, None, source))\n+    filemap_to_stream(sess, sess.codemap().new_filemap(name, source))\n }\n \n // Create a new parser from a source string\n pub fn new_parser_from_source_str<'a>(sess: &'a ParseSess, name: String, source: String)\n                                       -> Parser<'a> {\n-    filemap_to_parser(sess, sess.codemap().new_filemap(name, None, source))\n+    filemap_to_parser(sess, sess.codemap().new_filemap(name, source))\n }\n \n /// Create a new parser, handling errors as appropriate\n@@ -828,7 +828,7 @@ mod tests {\n     }\n \n     #[test] fn parse_ident_pat () {\n-        let sess = ParseSess::new();\n+        let sess = ParseSess::new(FilePathMapping::empty());\n         let mut parser = string_to_parser(&sess, \"b\".to_string());\n         assert!(panictry!(parser.parse_pat())\n                 == P(ast::Pat{\n@@ -998,7 +998,7 @@ mod tests {\n     }\n \n     #[test] fn crlf_doc_comments() {\n-        let sess = ParseSess::new();\n+        let sess = ParseSess::new(FilePathMapping::empty());\n \n         let name = \"<source>\".to_string();\n         let source = \"/// doc comment\\r\\nfn foo() {}\".to_string();\n@@ -1023,7 +1023,7 @@ mod tests {\n \n     #[test]\n     fn ttdelim_span() {\n-        let sess = ParseSess::new();\n+        let sess = ParseSess::new(FilePathMapping::empty());\n         let expr = parse::parse_expr_from_source_str(\"foo\".to_string(),\n             \"foo!( fn main() { body } )\".to_string(), &sess).unwrap();\n "}, {"sha": "b3fa1e97376d016faaed2d4d09a31df547be9bf1", "filename": "src/libsyntax/test_snippet.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibsyntax%2Ftest_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibsyntax%2Ftest_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest_snippet.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use codemap::CodeMap;\n+use codemap::{CodeMap, FilePathMapping};\n use errors::Handler;\n use errors::emitter::EmitterWriter;\n use std::io;\n@@ -47,8 +47,8 @@ impl<T: Write> Write for Shared<T> {\n fn test_harness(file_text: &str, span_labels: Vec<SpanLabel>, expected_output: &str) {\n     let output = Arc::new(Mutex::new(Vec::new()));\n \n-    let code_map = Rc::new(CodeMap::new());\n-    code_map.new_filemap_and_lines(\"test.rs\", None, &file_text);\n+    let code_map = Rc::new(CodeMap::new(FilePathMapping::empty()));\n+    code_map.new_filemap_and_lines(\"test.rs\", &file_text);\n \n     let primary_span = make_span(&file_text, &span_labels[0].start, &span_labels[0].end);\n     let mut msp = MultiSpan::from_span(primary_span);"}, {"sha": "2727ab79ebf76b80763a9420132598355b6aba6e", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use ast::{self, Ident};\n+use codemap::FilePathMapping;\n use parse::{ParseSess, PResult, filemap_to_stream};\n use parse::{lexer, new_parser_from_source_str};\n use parse::parser::Parser;\n@@ -18,8 +19,8 @@ use std::iter::Peekable;\n \n /// Map a string to tts, using a made-up filename:\n pub fn string_to_stream(source_str: String) -> TokenStream {\n-    let ps = ParseSess::new();\n-    filemap_to_stream(&ps, ps.codemap().new_filemap(\"bogofile\".to_string(), None, source_str))\n+    let ps = ParseSess::new(FilePathMapping::empty());\n+    filemap_to_stream(&ps, ps.codemap().new_filemap(\"bogofile\".to_string(), source_str))\n }\n \n /// Map string to parser (via tts)\n@@ -38,31 +39,31 @@ fn with_error_checking_parse<'a, T, F>(s: String, ps: &'a ParseSess, f: F) -> T\n \n /// Parse a string, return a crate.\n pub fn string_to_crate (source_str : String) -> ast::Crate {\n-    let ps = ParseSess::new();\n+    let ps = ParseSess::new(FilePathMapping::empty());\n     with_error_checking_parse(source_str, &ps, |p| {\n         p.parse_crate_mod()\n     })\n }\n \n /// Parse a string, return an expr\n pub fn string_to_expr (source_str : String) -> P<ast::Expr> {\n-    let ps = ParseSess::new();\n+    let ps = ParseSess::new(FilePathMapping::empty());\n     with_error_checking_parse(source_str, &ps, |p| {\n         p.parse_expr()\n     })\n }\n \n /// Parse a string, return an item\n pub fn string_to_item (source_str : String) -> Option<P<ast::Item>> {\n-    let ps = ParseSess::new();\n+    let ps = ParseSess::new(FilePathMapping::empty());\n     with_error_checking_parse(source_str, &ps, |p| {\n         p.parse_item()\n     })\n }\n \n /// Parse a string, return a stmt\n pub fn string_to_stmt(source_str : String) -> Option<ast::Stmt> {\n-    let ps = ParseSess::new();\n+    let ps = ParseSess::new(FilePathMapping::empty());\n     with_error_checking_parse(source_str, &ps, |p| {\n         p.parse_stmt()\n     })\n@@ -71,7 +72,7 @@ pub fn string_to_stmt(source_str : String) -> Option<ast::Stmt> {\n /// Parse a string, return a pat. Uses \"irrefutable\"... which doesn't\n /// (currently) affect parsing.\n pub fn string_to_pat(source_str: String) -> P<ast::Pat> {\n-    let ps = ParseSess::new();\n+    let ps = ParseSess::new(FilePathMapping::empty());\n     with_error_checking_parse(source_str, &ps, |p| {\n         p.parse_pat()\n     })"}, {"sha": "f46b4fcb715b088da96a2c7bf2aa277deb9dc192", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -369,13 +369,14 @@ pub struct MultiByteChar {\n }\n \n /// A single source in the CodeMap.\n+#[derive(Clone)]\n pub struct FileMap {\n     /// The name of the file that the source came from, source that doesn't\n     /// originate from files has names between angle brackets by convention,\n     /// e.g. `<anon>`\n     pub name: FileName,\n-    /// The absolute path of the file that the source came from.\n-    pub abs_path: Option<FileName>,\n+    /// True if the `name` field above has been modified by -Zremap-path-prefix\n+    pub name_was_remapped: bool,\n     /// The complete source code\n     pub src: Option<Rc<String>>,\n     /// The start position of this source in the CodeMap\n@@ -392,7 +393,7 @@ impl Encodable for FileMap {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_struct(\"FileMap\", 6, |s| {\n             s.emit_struct_field(\"name\", 0, |s| self.name.encode(s))?;\n-            s.emit_struct_field(\"abs_path\", 1, |s| self.abs_path.encode(s))?;\n+            s.emit_struct_field(\"name_was_remapped\", 1, |s| self.name_was_remapped.encode(s))?;\n             s.emit_struct_field(\"start_pos\", 2, |s| self.start_pos.encode(s))?;\n             s.emit_struct_field(\"end_pos\", 3, |s| self.end_pos.encode(s))?;\n             s.emit_struct_field(\"lines\", 4, |s| {\n@@ -453,8 +454,8 @@ impl Decodable for FileMap {\n \n         d.read_struct(\"FileMap\", 6, |d| {\n             let name: String = d.read_struct_field(\"name\", 0, |d| Decodable::decode(d))?;\n-            let abs_path: Option<String> =\n-                d.read_struct_field(\"abs_path\", 1, |d| Decodable::decode(d))?;\n+            let name_was_remapped: bool =\n+                d.read_struct_field(\"name_was_remapped\", 1, |d| Decodable::decode(d))?;\n             let start_pos: BytePos = d.read_struct_field(\"start_pos\", 2, |d| Decodable::decode(d))?;\n             let end_pos: BytePos = d.read_struct_field(\"end_pos\", 3, |d| Decodable::decode(d))?;\n             let lines: Vec<BytePos> = d.read_struct_field(\"lines\", 4, |d| {\n@@ -489,7 +490,7 @@ impl Decodable for FileMap {\n                 d.read_struct_field(\"multibyte_chars\", 5, |d| Decodable::decode(d))?;\n             Ok(FileMap {\n                 name: name,\n-                abs_path: abs_path,\n+                name_was_remapped: name_was_remapped,\n                 start_pos: start_pos,\n                 end_pos: end_pos,\n                 src: None,"}, {"sha": "5543a091680f17fd52cf6396c2fd7937d7a13e5b", "filename": "src/test/codegen/remap_path_prefix/auxiliary/remap_path_prefix_aux.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fauxiliary%2Fremap_path_prefix_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fauxiliary%2Fremap_path_prefix_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fauxiliary%2Fremap_path_prefix_aux.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+// compile-flags: -g  -Zremap-path-prefix-from={{cwd}} -Zremap-path-prefix-to=/the/aux-cwd -Zremap-path-prefix-from={{src-base}}/remap_path_prefix/auxiliary -Zremap-path-prefix-to=/the/aux-src\n+\n+#[inline]\n+pub fn some_aux_function() -> i32 {\n+    1234\n+}"}, {"sha": "eb00c91ba5f39f29feebb269845343725af119eb", "filename": "src/test/codegen/remap_path_prefix/main.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-windows\n+// ignore-tidy-linelength\n+\n+// compile-flags: -g  -C no-prepopulate-passes -Zremap-path-prefix-from={{cwd}} -Zremap-path-prefix-to=/the/cwd -Zremap-path-prefix-from={{src-base}} -Zremap-path-prefix-to=/the/src\n+// aux-build:remap_path_prefix_aux.rs\n+\n+extern crate remap_path_prefix_aux;\n+\n+// Here we check that the expansion of the file!() macro is mapped.\n+// CHECK: internal constant [34 x i8] c\"/the/src/remap_path_prefix/main.rs\"\n+pub static FILE_PATH: &'static str = file!();\n+\n+fn main() {\n+    remap_path_prefix_aux::some_aux_function();\n+}\n+\n+// Here we check that local debuginfo is mapped correctly.\n+// CHECK: !DIFile(filename: \"/the/src/remap_path_prefix/main.rs\", directory: \"/the/cwd\")\n+\n+// And here that debuginfo from other crates are expanded to absolute paths.\n+// CHECK: !DIFile(filename: \"/the/aux-src/remap_path_prefix_aux.rs\", directory: \"\")"}, {"sha": "3e2829adeb52e6e9a874a0bc011dacf7a8a46de0", "filename": "src/test/compile-fail-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -16,12 +16,13 @@ extern crate syntax;\n extern crate syntax_pos;\n \n use syntax::ast;\n+use syntax::codemap::FilePathMapping;\n use syntax::print::pprust;\n use syntax::symbol::Symbol;\n use syntax_pos::DUMMY_SP;\n \n fn main() {\n-    let ps = syntax::parse::ParseSess::new();\n+    let ps = syntax::parse::ParseSess::new(FilePathMapping::empty());\n     let mut resolver = syntax::ext::base::DummyResolver;\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n         &ps,"}, {"sha": "27b9e27be43853c01a339e6bc817732966df3627", "filename": "src/test/run-fail-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -24,7 +24,7 @@ use syntax::symbol::Symbol;\n use syntax_pos::DUMMY_SP;\n \n fn main() {\n-    let ps = syntax::parse::ParseSess::new();\n+    let ps = syntax::parse::ParseSess::new(codemap::FilePathMapping::empty());\n     let mut resolver = syntax::ext::base::DummyResolver;\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n         &ps,"}, {"sha": "fc031f4a310c2585718a269caad5c17c9c1a6755", "filename": "src/test/run-pass-fulldeps/ast_stmt_expr_attr.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -17,6 +17,7 @@ extern crate syntax;\n use syntax::ast::*;\n use syntax::attr::*;\n use syntax::ast;\n+use syntax::codemap::FilePathMapping;\n use syntax::parse;\n use syntax::parse::{ParseSess, PResult};\n use syntax::parse::new_parser_from_source_str;\n@@ -78,7 +79,7 @@ fn str_compare<T, F: Fn(&T) -> String>(e: &str, expected: &[T], actual: &[T], f:\n }\n \n fn check_expr_attrs(es: &str, expected: &[&str]) {\n-    let ps = ParseSess::new();\n+    let ps = ParseSess::new(FilePathMapping::empty());\n     let e = expr(es, &ps).expect(\"parse error\");\n     let actual = &e.attrs;\n     str_compare(es,\n@@ -88,7 +89,7 @@ fn check_expr_attrs(es: &str, expected: &[&str]) {\n }\n \n fn check_stmt_attrs(es: &str, expected: &[&str]) {\n-    let ps = ParseSess::new();\n+    let ps = ParseSess::new(FilePathMapping::empty());\n     let e = stmt(es, &ps).expect(\"parse error\");\n     let actual = e.node.attrs();\n     str_compare(es,\n@@ -98,15 +99,15 @@ fn check_stmt_attrs(es: &str, expected: &[&str]) {\n }\n \n fn reject_expr_parse(es: &str) {\n-    let ps = ParseSess::new();\n+    let ps = ParseSess::new(FilePathMapping::empty());\n     match expr(es, &ps) {\n         Ok(_) => panic!(\"parser did not reject `{}`\", es),\n         Err(mut e) => e.cancel(),\n     };\n }\n \n fn reject_stmt_parse(es: &str) {\n-    let ps = ParseSess::new();\n+    let ps = ParseSess::new(FilePathMapping::empty());\n     match stmt(es, &ps) {\n         Ok(_) => panic!(\"parser did not reject `{}`\", es),\n         Err(mut e) => e.cancel(),"}, {"sha": "949aa8a9518c0f803fdba39bf70bffb7770d693c", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -15,12 +15,13 @@\n extern crate syntax;\n extern crate syntax_pos;\n \n+use syntax::codemap::FilePathMapping;\n use syntax::print::pprust::*;\n use syntax::symbol::Symbol;\n use syntax_pos::DUMMY_SP;\n \n fn main() {\n-    let ps = syntax::parse::ParseSess::new();\n+    let ps = syntax::parse::ParseSess::new(FilePathMapping::empty());\n     let mut resolver = syntax::ext::base::DummyResolver;\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n         &ps,"}, {"sha": "0f653dfbcf07c9293b1302b44ecbc5433d5e5743", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 152, "deletions": 119, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -40,23 +40,24 @@ impl EarlyProps {\n                     None,\n                     &mut |ln| {\n             props.ignore =\n-                props.ignore || parse_name_directive(ln, \"ignore-test\") ||\n-                parse_name_directive(ln, &ignore_target(config)) ||\n-                parse_name_directive(ln, &ignore_architecture(config)) ||\n-                parse_name_directive(ln, &ignore_stage(config)) ||\n-                parse_name_directive(ln, &ignore_env(config)) ||\n-                (config.mode == common::Pretty && parse_name_directive(ln, \"ignore-pretty\")) ||\n+                props.ignore || config.parse_name_directive(ln, \"ignore-test\") ||\n+                config.parse_name_directive(ln, &ignore_target(config)) ||\n+                config.parse_name_directive(ln, &ignore_architecture(config)) ||\n+                config.parse_name_directive(ln, &ignore_stage(config)) ||\n+                config.parse_name_directive(ln, &ignore_env(config)) ||\n+                (config.mode == common::Pretty &&\n+                 config.parse_name_directive(ln, \"ignore-pretty\")) ||\n                 (config.target != config.host &&\n-                 parse_name_directive(ln, \"ignore-cross-compile\")) ||\n+                 config.parse_name_directive(ln, \"ignore-cross-compile\")) ||\n                 ignore_gdb(config, ln) ||\n                 ignore_lldb(config, ln) ||\n                 ignore_llvm(config, ln);\n \n-            if let Some(s) = parse_aux_build(ln) {\n+            if let Some(s) = config.parse_aux_build(ln) {\n                 props.aux.push(s);\n             }\n \n-            props.should_fail = props.should_fail || parse_name_directive(ln, \"should-fail\");\n+            props.should_fail = props.should_fail || config.parse_name_directive(ln, \"should-fail\");\n         });\n \n         return props;\n@@ -80,7 +81,7 @@ impl EarlyProps {\n             }\n \n             if !line.contains(\"ignore-gdb-version\") &&\n-               parse_name_directive(line, \"ignore-gdb\") {\n+               config.parse_name_directive(line, \"ignore-gdb\") {\n                 return true;\n             }\n \n@@ -143,7 +144,7 @@ impl EarlyProps {\n                 return false;\n             }\n \n-            if parse_name_directive(line, \"ignore-lldb\") {\n+            if config.parse_name_directive(line, \"ignore-lldb\") {\n                 return true;\n             }\n \n@@ -260,105 +261,112 @@ impl TestProps {\n         }\n     }\n \n-    pub fn from_aux_file(&self, testfile: &Path, cfg: Option<&str>) -> Self {\n+    pub fn from_aux_file(&self,\n+                         testfile: &Path,\n+                         cfg: Option<&str>,\n+                         config: &Config)\n+                         -> Self {\n         let mut props = TestProps::new();\n \n         // copy over select properties to the aux build:\n         props.incremental_dir = self.incremental_dir.clone();\n-        props.load_from(testfile, cfg);\n+        props.load_from(testfile, cfg, config);\n \n         props\n     }\n \n-    pub fn from_file(testfile: &Path) -> Self {\n+    pub fn from_file(testfile: &Path, config: &Config) -> Self {\n         let mut props = TestProps::new();\n-        props.load_from(testfile, None);\n+        props.load_from(testfile, None, config);\n         props\n     }\n \n     /// Load properties from `testfile` into `props`. If a property is\n     /// tied to a particular revision `foo` (indicated by writing\n     /// `//[foo]`), then the property is ignored unless `cfg` is\n     /// `Some(\"foo\")`.\n-    pub fn load_from(&mut self, testfile: &Path, cfg: Option<&str>) {\n+    pub fn load_from(&mut self,\n+                     testfile: &Path,\n+                     cfg: Option<&str>,\n+                     config: &Config) {\n         iter_header(testfile,\n                     cfg,\n                     &mut |ln| {\n-            if let Some(ep) = parse_error_pattern(ln) {\n+            if let Some(ep) = config.parse_error_pattern(ln) {\n                 self.error_patterns.push(ep);\n             }\n \n-            if let Some(flags) = parse_compile_flags(ln) {\n+            if let Some(flags) = config.parse_compile_flags(ln) {\n                 self.compile_flags.extend(flags.split_whitespace()\n                     .map(|s| s.to_owned()));\n             }\n \n-            if let Some(r) = parse_revisions(ln) {\n+            if let Some(r) = config.parse_revisions(ln) {\n                 self.revisions.extend(r);\n             }\n \n             if self.run_flags.is_none() {\n-                self.run_flags = parse_run_flags(ln);\n+                self.run_flags = config.parse_run_flags(ln);\n             }\n \n             if self.pp_exact.is_none() {\n-                self.pp_exact = parse_pp_exact(ln, testfile);\n+                self.pp_exact = config.parse_pp_exact(ln, testfile);\n             }\n \n             if !self.build_aux_docs {\n-                self.build_aux_docs = parse_build_aux_docs(ln);\n+                self.build_aux_docs = config.parse_build_aux_docs(ln);\n             }\n \n             if !self.force_host {\n-                self.force_host = parse_force_host(ln);\n+                self.force_host = config.parse_force_host(ln);\n             }\n \n             if !self.check_stdout {\n-                self.check_stdout = parse_check_stdout(ln);\n+                self.check_stdout = config.parse_check_stdout(ln);\n             }\n \n             if !self.no_prefer_dynamic {\n-                self.no_prefer_dynamic = parse_no_prefer_dynamic(ln);\n+                self.no_prefer_dynamic = config.parse_no_prefer_dynamic(ln);\n             }\n \n             if !self.pretty_expanded {\n-                self.pretty_expanded = parse_pretty_expanded(ln);\n+                self.pretty_expanded = config.parse_pretty_expanded(ln);\n             }\n \n-            if let Some(m) = parse_pretty_mode(ln) {\n+            if let Some(m) = config.parse_pretty_mode(ln) {\n                 self.pretty_mode = m;\n             }\n \n             if !self.pretty_compare_only {\n-                self.pretty_compare_only = parse_pretty_compare_only(ln);\n+                self.pretty_compare_only = config.parse_pretty_compare_only(ln);\n             }\n \n-            if let Some(ab) = parse_aux_build(ln) {\n+            if let Some(ab) = config.parse_aux_build(ln) {\n                 self.aux_builds.push(ab);\n             }\n \n-            if let Some(ee) = parse_env(ln, \"exec-env\") {\n+            if let Some(ee) = config.parse_env(ln, \"exec-env\") {\n                 self.exec_env.push(ee);\n             }\n \n-            if let Some(ee) = parse_env(ln, \"rustc-env\") {\n+            if let Some(ee) = config.parse_env(ln, \"rustc-env\") {\n                 self.rustc_env.push(ee);\n             }\n \n-            if let Some(cl) = parse_check_line(ln) {\n+            if let Some(cl) = config.parse_check_line(ln) {\n                 self.check_lines.push(cl);\n             }\n \n-            if let Some(of) = parse_forbid_output(ln) {\n+            if let Some(of) = config.parse_forbid_output(ln) {\n                 self.forbid_output.push(of);\n             }\n \n             if !self.must_compile_successfully {\n-                self.must_compile_successfully = parse_must_compile_successfully(ln);\n+                self.must_compile_successfully = config.parse_must_compile_successfully(ln);\n             }\n \n             if !self.check_test_line_numbers_match {\n-                self.check_test_line_numbers_match = parse_check_test_line_numbers_match(ln);\n+                self.check_test_line_numbers_match = config.parse_check_test_line_numbers_match(ln);\n             }\n         });\n \n@@ -410,114 +418,118 @@ fn iter_header(testfile: &Path, cfg: Option<&str>, it: &mut FnMut(&str)) {\n     return;\n }\n \n-fn parse_error_pattern(line: &str) -> Option<String> {\n-    parse_name_value_directive(line, \"error-pattern\")\n-}\n+impl Config {\n \n-fn parse_forbid_output(line: &str) -> Option<String> {\n-    parse_name_value_directive(line, \"forbid-output\")\n-}\n+    fn parse_error_pattern(&self, line: &str) -> Option<String> {\n+        self.parse_name_value_directive(line, \"error-pattern\")\n+    }\n \n-fn parse_aux_build(line: &str) -> Option<String> {\n-    parse_name_value_directive(line, \"aux-build\")\n-}\n+    fn parse_forbid_output(&self, line: &str) -> Option<String> {\n+        self.parse_name_value_directive(line, \"forbid-output\")\n+    }\n \n-fn parse_compile_flags(line: &str) -> Option<String> {\n-    parse_name_value_directive(line, \"compile-flags\")\n-}\n+    fn parse_aux_build(&self, line: &str) -> Option<String> {\n+        self.parse_name_value_directive(line, \"aux-build\")\n+    }\n \n-fn parse_revisions(line: &str) -> Option<Vec<String>> {\n-    parse_name_value_directive(line, \"revisions\")\n-        .map(|r| r.split_whitespace().map(|t| t.to_string()).collect())\n-}\n+    fn parse_compile_flags(&self, line: &str) -> Option<String> {\n+        self.parse_name_value_directive(line, \"compile-flags\")\n+    }\n \n-fn parse_run_flags(line: &str) -> Option<String> {\n-    parse_name_value_directive(line, \"run-flags\")\n-}\n+    fn parse_revisions(&self, line: &str) -> Option<Vec<String>> {\n+        self.parse_name_value_directive(line, \"revisions\")\n+            .map(|r| r.split_whitespace().map(|t| t.to_string()).collect())\n+    }\n \n-fn parse_check_line(line: &str) -> Option<String> {\n-    parse_name_value_directive(line, \"check\")\n-}\n+    fn parse_run_flags(&self, line: &str) -> Option<String> {\n+        self.parse_name_value_directive(line, \"run-flags\")\n+    }\n \n-fn parse_force_host(line: &str) -> bool {\n-    parse_name_directive(line, \"force-host\")\n-}\n+    fn parse_check_line(&self, line: &str) -> Option<String> {\n+        self.parse_name_value_directive(line, \"check\")\n+    }\n \n-fn parse_build_aux_docs(line: &str) -> bool {\n-    parse_name_directive(line, \"build-aux-docs\")\n-}\n+    fn parse_force_host(&self, line: &str) -> bool {\n+        self.parse_name_directive(line, \"force-host\")\n+    }\n \n-fn parse_check_stdout(line: &str) -> bool {\n-    parse_name_directive(line, \"check-stdout\")\n-}\n+    fn parse_build_aux_docs(&self, line: &str) -> bool {\n+        self.parse_name_directive(line, \"build-aux-docs\")\n+    }\n \n-fn parse_no_prefer_dynamic(line: &str) -> bool {\n-    parse_name_directive(line, \"no-prefer-dynamic\")\n-}\n+    fn parse_check_stdout(&self, line: &str) -> bool {\n+        self.parse_name_directive(line, \"check-stdout\")\n+    }\n \n-fn parse_pretty_expanded(line: &str) -> bool {\n-    parse_name_directive(line, \"pretty-expanded\")\n-}\n+    fn parse_no_prefer_dynamic(&self, line: &str) -> bool {\n+        self.parse_name_directive(line, \"no-prefer-dynamic\")\n+    }\n \n-fn parse_pretty_mode(line: &str) -> Option<String> {\n-    parse_name_value_directive(line, \"pretty-mode\")\n-}\n+    fn parse_pretty_expanded(&self, line: &str) -> bool {\n+        self.parse_name_directive(line, \"pretty-expanded\")\n+    }\n \n-fn parse_pretty_compare_only(line: &str) -> bool {\n-    parse_name_directive(line, \"pretty-compare-only\")\n-}\n+    fn parse_pretty_mode(&self, line: &str) -> Option<String> {\n+        self.parse_name_value_directive(line, \"pretty-mode\")\n+    }\n \n-fn parse_must_compile_successfully(line: &str) -> bool {\n-    parse_name_directive(line, \"must-compile-successfully\")\n-}\n+    fn parse_pretty_compare_only(&self, line: &str) -> bool {\n+        self.parse_name_directive(line, \"pretty-compare-only\")\n+    }\n \n-fn parse_check_test_line_numbers_match(line: &str) -> bool {\n-    parse_name_directive(line, \"check-test-line-numbers-match\")\n-}\n+    fn parse_must_compile_successfully(&self, line: &str) -> bool {\n+        self.parse_name_directive(line, \"must-compile-successfully\")\n+    }\n \n-fn parse_env(line: &str, name: &str) -> Option<(String, String)> {\n-    parse_name_value_directive(line, name).map(|nv| {\n-        // nv is either FOO or FOO=BAR\n-        let mut strs: Vec<String> = nv.splitn(2, '=')\n-            .map(str::to_owned)\n-            .collect();\n+    fn parse_check_test_line_numbers_match(&self, line: &str) -> bool {\n+        self.parse_name_directive(line, \"check-test-line-numbers-match\")\n+    }\n \n-        match strs.len() {\n-            1 => (strs.pop().unwrap(), \"\".to_owned()),\n-            2 => {\n-                let end = strs.pop().unwrap();\n-                (strs.pop().unwrap(), end)\n+    fn parse_env(&self, line: &str, name: &str) -> Option<(String, String)> {\n+        self.parse_name_value_directive(line, name).map(|nv| {\n+            // nv is either FOO or FOO=BAR\n+            let mut strs: Vec<String> = nv.splitn(2, '=')\n+                .map(str::to_owned)\n+                .collect();\n+\n+            match strs.len() {\n+                1 => (strs.pop().unwrap(), \"\".to_owned()),\n+                2 => {\n+                    let end = strs.pop().unwrap();\n+                    (strs.pop().unwrap(), end)\n+                }\n+                n => panic!(\"Expected 1 or 2 strings, not {}\", n),\n             }\n-            n => panic!(\"Expected 1 or 2 strings, not {}\", n),\n-        }\n-    })\n-}\n+        })\n+    }\n \n-fn parse_pp_exact(line: &str, testfile: &Path) -> Option<PathBuf> {\n-    if let Some(s) = parse_name_value_directive(line, \"pp-exact\") {\n-        Some(PathBuf::from(&s))\n-    } else {\n-        if parse_name_directive(line, \"pp-exact\") {\n-            testfile.file_name().map(PathBuf::from)\n+    fn parse_pp_exact(&self, line: &str, testfile: &Path) -> Option<PathBuf> {\n+        if let Some(s) = self.parse_name_value_directive(line, \"pp-exact\") {\n+            Some(PathBuf::from(&s))\n         } else {\n-            None\n+            if self.parse_name_directive(line, \"pp-exact\") {\n+                testfile.file_name().map(PathBuf::from)\n+            } else {\n+                None\n+            }\n         }\n     }\n-}\n \n-fn parse_name_directive(line: &str, directive: &str) -> bool {\n-    // This 'no-' rule is a quick hack to allow pretty-expanded and no-pretty-expanded to coexist\n-    line.contains(directive) && !line.contains(&(\"no-\".to_owned() + directive))\n-}\n+    fn parse_name_directive(&self, line: &str, directive: &str) -> bool {\n+        // This 'no-' rule is a quick hack to allow pretty-expanded and\n+        // no-pretty-expanded to coexist\n+        line.contains(directive) && !line.contains(&(\"no-\".to_owned() + directive))\n+    }\n \n-pub fn parse_name_value_directive(line: &str, directive: &str) -> Option<String> {\n-    let keycolon = format!(\"{}:\", directive);\n-    if let Some(colon) = line.find(&keycolon) {\n-        let value = line[(colon + keycolon.len())..line.len()].to_owned();\n-        debug!(\"{}: {}\", directive, value);\n-        Some(value)\n-    } else {\n-        None\n+    pub fn parse_name_value_directive(&self, line: &str, directive: &str) -> Option<String> {\n+        let keycolon = format!(\"{}:\", directive);\n+        if let Some(colon) = line.find(&keycolon) {\n+            let value = line[(colon + keycolon.len())..line.len()].to_owned();\n+            debug!(\"{}: {}\", directive, value);\n+            Some(expand_variables(value, self))\n+        } else {\n+            None\n+        }\n     }\n }\n \n@@ -528,3 +540,24 @@ pub fn lldb_version_to_int(version_string: &str) -> isize {\n     let major: isize = version_string.parse().ok().expect(&error_string);\n     return major;\n }\n+\n+fn expand_variables(mut value: String, config: &Config) -> String {\n+    const CWD: &'static str = \"{{cwd}}\";\n+    const SRC_BASE: &'static str = \"{{src-base}}\";\n+    const BUILD_BASE: &'static str = \"{{build-base}}\";\n+\n+    if value.contains(CWD) {\n+        let cwd = env::current_dir().unwrap();\n+        value = value.replace(CWD, &cwd.to_string_lossy());\n+    }\n+\n+    if value.contains(SRC_BASE) {\n+        value = value.replace(SRC_BASE, &config.src_base.to_string_lossy());\n+    }\n+\n+    if value.contains(BUILD_BASE) {\n+        value = value.replace(BUILD_BASE, &config.build_base.to_string_lossy());\n+    }\n+\n+    value\n+}"}, {"sha": "1348c8552496ba3b6c7a48d51b9ba1a230a16b75", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2971d491b955fd8bb504c8ca675b8116b8b1550e/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=2971d491b955fd8bb504c8ca675b8116b8b1550e", "patch": "@@ -16,7 +16,6 @@ use errors::{self, ErrorKind, Error};\n use filetime::FileTime;\n use json;\n use header::TestProps;\n-use header;\n use procsrv;\n use test::TestPaths;\n use uidiff;\n@@ -57,7 +56,7 @@ pub fn run(config: Config, testpaths: &TestPaths) {\n         print!(\"\\n\\n\");\n     }\n     debug!(\"running {:?}\", testpaths.file.display());\n-    let base_props = TestProps::from_file(&testpaths.file);\n+    let base_props = TestProps::from_file(&testpaths.file, &config);\n \n     let base_cx = TestCx { config: &config,\n                            props: &base_props,\n@@ -70,7 +69,7 @@ pub fn run(config: Config, testpaths: &TestPaths) {\n     } else {\n         for revision in &base_props.revisions {\n             let mut revision_props = base_props.clone();\n-            revision_props.load_from(&testpaths.file, Some(&revision));\n+            revision_props.load_from(&testpaths.file, Some(&revision), &config);\n             let rev_cx = TestCx {\n                 config: &config,\n                 props: &revision_props,\n@@ -867,13 +866,13 @@ actual:\\n\\\n                     }\n \n                     for &(ref command_directive, ref check_directive) in &directives {\n-                        header::parse_name_value_directive(\n+                        self.config.parse_name_value_directive(\n                             &line,\n                             &command_directive).map(|cmd| {\n                                 commands.push(cmd)\n                             });\n \n-                        header::parse_name_value_directive(\n+                        self.config.parse_name_value_directive(\n                             &line,\n                             &check_directive).map(|cmd| {\n                                 check_lines.push(cmd)\n@@ -1158,7 +1157,9 @@ actual:\\n\\\n         if self.props.build_aux_docs {\n             for rel_ab in &self.props.aux_builds {\n                 let aux_testpaths = self.compute_aux_test_paths(rel_ab);\n-                let aux_props = self.props.from_aux_file(&aux_testpaths.file, self.revision);\n+                let aux_props = self.props.from_aux_file(&aux_testpaths.file,\n+                                                         self.revision,\n+                                                         self.config);\n                 let aux_cx = TestCx {\n                     config: self.config,\n                     props: &aux_props,\n@@ -1279,7 +1280,9 @@ actual:\\n\\\n \n         for rel_ab in &self.props.aux_builds {\n             let aux_testpaths = self.compute_aux_test_paths(rel_ab);\n-            let aux_props = self.props.from_aux_file(&aux_testpaths.file, self.revision);\n+            let aux_props = self.props.from_aux_file(&aux_testpaths.file,\n+                                                     self.revision,\n+                                                     self.config);\n             let mut crate_type = if aux_props.no_prefer_dynamic {\n                 Vec::new()\n             } else {"}]}