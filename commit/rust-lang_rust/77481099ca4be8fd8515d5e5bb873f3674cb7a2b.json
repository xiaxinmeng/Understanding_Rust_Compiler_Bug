{"sha": "77481099ca4be8fd8515d5e5bb873f3674cb7a2b", "node_id": "C_kwDOAAsO6NoAKDc3NDgxMDk5Y2E0YmU4ZmQ4NTE1ZDVlNWJiODczZjM2NzRjYjdhMmI", "commit": {"author": {"name": "LegionMammal978", "email": "mattlloydhouse@gmail.com", "date": "2023-05-15T18:31:00Z"}, "committer": {"name": "LegionMammal978", "email": "mattlloydhouse@gmail.com", "date": "2023-05-15T18:31:00Z"}, "message": "Mark internal functions and traits unsafe", "tree": {"sha": "313403bf007a0956918d7315dd8c5fbbe3749eb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/313403bf007a0956918d7315dd8c5fbbe3749eb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77481099ca4be8fd8515d5e5bb873f3674cb7a2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77481099ca4be8fd8515d5e5bb873f3674cb7a2b", "html_url": "https://github.com/rust-lang/rust/commit/77481099ca4be8fd8515d5e5bb873f3674cb7a2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77481099ca4be8fd8515d5e5bb873f3674cb7a2b/comments", "author": {"login": "LegionMammal978", "id": 7880963, "node_id": "MDQ6VXNlcjc4ODA5NjM=", "avatar_url": "https://avatars.githubusercontent.com/u/7880963?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LegionMammal978", "html_url": "https://github.com/LegionMammal978", "followers_url": "https://api.github.com/users/LegionMammal978/followers", "following_url": "https://api.github.com/users/LegionMammal978/following{/other_user}", "gists_url": "https://api.github.com/users/LegionMammal978/gists{/gist_id}", "starred_url": "https://api.github.com/users/LegionMammal978/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LegionMammal978/subscriptions", "organizations_url": "https://api.github.com/users/LegionMammal978/orgs", "repos_url": "https://api.github.com/users/LegionMammal978/repos", "events_url": "https://api.github.com/users/LegionMammal978/events{/privacy}", "received_events_url": "https://api.github.com/users/LegionMammal978/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LegionMammal978", "id": 7880963, "node_id": "MDQ6VXNlcjc4ODA5NjM=", "avatar_url": "https://avatars.githubusercontent.com/u/7880963?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LegionMammal978", "html_url": "https://github.com/LegionMammal978", "followers_url": "https://api.github.com/users/LegionMammal978/followers", "following_url": "https://api.github.com/users/LegionMammal978/following{/other_user}", "gists_url": "https://api.github.com/users/LegionMammal978/gists{/gist_id}", "starred_url": "https://api.github.com/users/LegionMammal978/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LegionMammal978/subscriptions", "organizations_url": "https://api.github.com/users/LegionMammal978/orgs", "repos_url": "https://api.github.com/users/LegionMammal978/repos", "events_url": "https://api.github.com/users/LegionMammal978/events{/privacy}", "received_events_url": "https://api.github.com/users/LegionMammal978/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63b2ee0fafdb0043cb302a6d2e138122fb2c52bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/63b2ee0fafdb0043cb302a6d2e138122fb2c52bd", "html_url": "https://github.com/rust-lang/rust/commit/63b2ee0fafdb0043cb302a6d2e138122fb2c52bd"}], "stats": {"total": 89, "additions": 57, "deletions": 32}, "files": [{"sha": "5ecd0479971ea804b345f8a9585a35d5de974b73", "filename": "library/alloc/src/vec/in_place_collect.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/77481099ca4be8fd8515d5e5bb873f3674cb7a2b/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77481099ca4be8fd8515d5e5bb873f3674cb7a2b/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs?ref=77481099ca4be8fd8515d5e5bb873f3674cb7a2b", "patch": "@@ -178,7 +178,8 @@ where\n             )\n         };\n \n-        let len = SpecInPlaceCollect::collect_in_place(&mut iterator, dst_buf, dst_end);\n+        // SAFETY: `dst_buf` and `dst_end` are the start and end of the buffer.\n+        let len = unsafe { SpecInPlaceCollect::collect_in_place(&mut iterator, dst_buf, dst_end) };\n \n         let src = unsafe { iterator.as_inner().as_into_iter() };\n         // check if SourceIter contract was upheld\n@@ -239,15 +240,15 @@ trait SpecInPlaceCollect<T, I>: Iterator<Item = T> {\n     /// `Iterator::__iterator_get_unchecked` calls with a `TrustedRandomAccessNoCoerce` bound\n     /// on `I` which means the caller of this method must take the safety conditions\n     /// of that trait into consideration.\n-    fn collect_in_place(&mut self, dst: *mut T, end: *const T) -> usize;\n+    unsafe fn collect_in_place(&mut self, dst: *mut T, end: *const T) -> usize;\n }\n \n impl<T, I> SpecInPlaceCollect<T, I> for I\n where\n     I: Iterator<Item = T>,\n {\n     #[inline]\n-    default fn collect_in_place(&mut self, dst_buf: *mut T, end: *const T) -> usize {\n+    default unsafe fn collect_in_place(&mut self, dst_buf: *mut T, end: *const T) -> usize {\n         // use try-fold since\n         // - it vectorizes better for some iterator adapters\n         // - unlike most internal iteration methods, it only takes a &mut self\n@@ -265,7 +266,7 @@ where\n     I: Iterator<Item = T> + TrustedRandomAccessNoCoerce,\n {\n     #[inline]\n-    fn collect_in_place(&mut self, dst_buf: *mut T, end: *const T) -> usize {\n+    unsafe fn collect_in_place(&mut self, dst_buf: *mut T, end: *const T) -> usize {\n         let len = self.size();\n         let mut drop_guard = InPlaceDrop { inner: dst_buf, dst: dst_buf };\n         for i in 0..len {"}, {"sha": "3bbf5d8770bd2ba14bf1957e047c1e13c54098fe", "filename": "library/core/src/fmt/float.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/77481099ca4be8fd8515d5e5bb873f3674cb7a2b/library%2Fcore%2Fsrc%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77481099ca4be8fd8515d5e5bb873f3674cb7a2b/library%2Fcore%2Fsrc%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Ffloat.rs?ref=77481099ca4be8fd8515d5e5bb873f3674cb7a2b", "patch": "@@ -45,7 +45,8 @@ where\n         &mut buf,\n         &mut parts,\n     );\n-    fmt.pad_formatted_parts(&formatted)\n+    // SAFETY: `to_exact_fixed_str` and `format_exact` produce only ASCII characters.\n+    unsafe { fmt.pad_formatted_parts(&formatted) }\n }\n \n // Don't inline this so callers that call both this and the above won't wind\n@@ -71,7 +72,8 @@ where\n         &mut buf,\n         &mut parts,\n     );\n-    fmt.pad_formatted_parts(&formatted)\n+    // SAFETY: `to_shortest_str` and `format_shortest` produce only ASCII characters.\n+    unsafe { fmt.pad_formatted_parts(&formatted) }\n }\n \n fn float_to_decimal_display<T>(fmt: &mut Formatter<'_>, num: &T) -> Result\n@@ -116,7 +118,8 @@ where\n         &mut buf,\n         &mut parts,\n     );\n-    fmt.pad_formatted_parts(&formatted)\n+    // SAFETY: `to_exact_exp_str` and `format_exact` produce only ASCII characters.\n+    unsafe { fmt.pad_formatted_parts(&formatted) }\n }\n \n // Don't inline this so callers that call both this and the above won't wind\n@@ -143,7 +146,8 @@ where\n         &mut buf,\n         &mut parts,\n     );\n-    fmt.pad_formatted_parts(&formatted)\n+    // SAFETY: `to_shortest_exp_str` and `format_shortest` produce only ASCII characters.\n+    unsafe { fmt.pad_formatted_parts(&formatted) }\n }\n \n // Common code of floating point LowerExp and UpperExp."}, {"sha": "1786b309c5bd3ea77e1f5684b8b17eb334a10e83", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/77481099ca4be8fd8515d5e5bb873f3674cb7a2b/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77481099ca4be8fd8515d5e5bb873f3674cb7a2b/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=77481099ca4be8fd8515d5e5bb873f3674cb7a2b", "patch": "@@ -1415,7 +1415,11 @@ impl<'a> Formatter<'a> {\n     /// Takes the formatted parts and applies the padding.\n     /// Assumes that the caller already has rendered the parts with required precision,\n     /// so that `self.precision` can be ignored.\n-    fn pad_formatted_parts(&mut self, formatted: &numfmt::Formatted<'_>) -> Result {\n+    ///\n+    /// # Safety\n+    ///\n+    /// Any `numfmt::Part::Copy` parts in `formatted` must contain valid UTF-8.\n+    unsafe fn pad_formatted_parts(&mut self, formatted: &numfmt::Formatted<'_>) -> Result {\n         if let Some(mut width) = self.width {\n             // for the sign-aware zero padding, we render the sign first and\n             // behave as if we had no sign from the beginning.\n@@ -1438,31 +1442,35 @@ impl<'a> Formatter<'a> {\n             let len = formatted.len();\n             let ret = if width <= len {\n                 // no padding\n-                self.write_formatted_parts(&formatted)\n+                // SAFETY: Per the precondition.\n+                unsafe { self.write_formatted_parts(&formatted) }\n             } else {\n                 let post_padding = self.padding(width - len, Alignment::Right)?;\n-                self.write_formatted_parts(&formatted)?;\n+                // SAFETY: Per the precondition.\n+                unsafe {\n+                    self.write_formatted_parts(&formatted)?;\n+                }\n                 post_padding.write(self)\n             };\n             self.fill = old_fill;\n             self.align = old_align;\n             ret\n         } else {\n             // this is the common case and we take a shortcut\n-            self.write_formatted_parts(formatted)\n+            // SAFETY: Per the precondition.\n+            unsafe { self.write_formatted_parts(formatted) }\n         }\n     }\n \n-    fn write_formatted_parts(&mut self, formatted: &numfmt::Formatted<'_>) -> Result {\n-        fn write_bytes(buf: &mut dyn Write, s: &[u8]) -> Result {\n+    /// # Safety\n+    ///\n+    /// Any `numfmt::Part::Copy` parts in `formatted` must contain valid UTF-8.\n+    unsafe fn write_formatted_parts(&mut self, formatted: &numfmt::Formatted<'_>) -> Result {\n+        unsafe fn write_bytes(buf: &mut dyn Write, s: &[u8]) -> Result {\n             // SAFETY: This is used for `numfmt::Part::Num` and `numfmt::Part::Copy`.\n             // It's safe to use for `numfmt::Part::Num` since every char `c` is between\n-            // `b'0'` and `b'9'`, which means `s` is valid UTF-8.\n-            // It's also probably safe in practice to use for `numfmt::Part::Copy(buf)`\n-            // since `buf` should be plain ASCII, but it's possible for someone to pass\n-            // in a bad value for `buf` into `numfmt::to_shortest_str` since it is a\n-            // public function.\n-            // FIXME: Determine whether this could result in UB.\n+            // `b'0'` and `b'9'`, which means `s` is valid UTF-8. It's safe to use for\n+            // `numfmt::Part::Copy` due to this function's precondition.\n             buf.write_str(unsafe { str::from_utf8_unchecked(s) })\n         }\n \n@@ -1489,11 +1497,15 @@ impl<'a> Formatter<'a> {\n                         *c = b'0' + (v % 10) as u8;\n                         v /= 10;\n                     }\n-                    write_bytes(self.buf, &s[..len])?;\n+                    // SAFETY: Per the precondition.\n+                    unsafe {\n+                        write_bytes(self.buf, &s[..len])?;\n+                    }\n                 }\n-                numfmt::Part::Copy(buf) => {\n+                // SAFETY: Per the precondition.\n+                numfmt::Part::Copy(buf) => unsafe {\n                     write_bytes(self.buf, buf)?;\n-                }\n+                },\n             }\n         }\n         Ok(())"}, {"sha": "4f42f73ebbaffd73cbf5f7f3c9f16bc98f1fea19", "filename": "library/core/src/fmt/num.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/77481099ca4be8fd8515d5e5bb873f3674cb7a2b/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77481099ca4be8fd8515d5e5bb873f3674cb7a2b/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs?ref=77481099ca4be8fd8515d5e5bb873f3674cb7a2b", "patch": "@@ -52,8 +52,12 @@ impl_int! { i8 i16 i32 i64 i128 isize }\n impl_uint! { u8 u16 u32 u64 u128 usize }\n \n /// A type that represents a specific radix\n+///\n+/// # Safety\n+///\n+/// `digit` must return an ASCII character.\n #[doc(hidden)]\n-trait GenericRadix: Sized {\n+unsafe trait GenericRadix: Sized {\n     /// The number of digits.\n     const BASE: u8;\n \n@@ -129,7 +133,7 @@ struct UpperHex;\n \n macro_rules! radix {\n     ($T:ident, $base:expr, $prefix:expr, $($x:pat => $conv:expr),+) => {\n-        impl GenericRadix for $T {\n+        unsafe impl GenericRadix for $T {\n             const BASE: u8 = $base;\n             const PREFIX: &'static str = $prefix;\n             fn digit(x: u8) -> u8 {\n@@ -407,7 +411,7 @@ macro_rules! impl_Exp {\n             let parts = &[\n                 numfmt::Part::Copy(buf_slice),\n                 numfmt::Part::Zero(added_precision),\n-                numfmt::Part::Copy(exp_slice)\n+                numfmt::Part::Copy(exp_slice),\n             ];\n             let sign = if !is_nonnegative {\n                 \"-\"\n@@ -416,8 +420,9 @@ macro_rules! impl_Exp {\n             } else {\n                 \"\"\n             };\n-            let formatted = numfmt::Formatted{sign, parts};\n-            f.pad_formatted_parts(&formatted)\n+            let formatted = numfmt::Formatted { sign, parts };\n+            // SAFETY: `buf_slice` and `exp_slice` contain only ASCII characters.\n+            unsafe { f.pad_formatted_parts(&formatted) }\n         }\n \n         $("}, {"sha": "febdeb514634cd5c5edc12554f30606705b6d35c", "filename": "library/std/src/path.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/77481099ca4be8fd8515d5e5bb873f3674cb7a2b/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77481099ca4be8fd8515d5e5bb873f3674cb7a2b/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=77481099ca4be8fd8515d5e5bb873f3674cb7a2b", "patch": "@@ -733,8 +733,9 @@ impl<'a> Components<'a> {\n         }\n     }\n \n-    // parse a given byte sequence into the corresponding path component\n-    fn parse_single_component<'b>(&self, comp: &'b [u8]) -> Option<Component<'b>> {\n+    // parse a given byte sequence following the OsStr encoding into the\n+    // corresponding path component\n+    unsafe fn parse_single_component<'b>(&self, comp: &'b [u8]) -> Option<Component<'b>> {\n         match comp {\n             b\".\" if self.prefix_verbatim() => Some(Component::CurDir),\n             b\".\" => None, // . components are normalized away, except at\n@@ -754,7 +755,8 @@ impl<'a> Components<'a> {\n             None => (0, self.path),\n             Some(i) => (1, &self.path[..i]),\n         };\n-        (comp.len() + extra, self.parse_single_component(comp))\n+        // SAFETY: `comp` is a valid substring, since it is split on a separator.\n+        (comp.len() + extra, unsafe { self.parse_single_component(comp) })\n     }\n \n     // parse a component from the right, saying how many bytes to consume to\n@@ -766,7 +768,8 @@ impl<'a> Components<'a> {\n             None => (0, &self.path[start..]),\n             Some(i) => (1, &self.path[start + i + 1..]),\n         };\n-        (comp.len() + extra, self.parse_single_component(comp))\n+        // SAFETY: `comp` is a valid substring, since it is split on a separator.\n+        (comp.len() + extra, unsafe { self.parse_single_component(comp) })\n     }\n \n     // trim away repeated separators (i.e., empty components) on the left"}]}