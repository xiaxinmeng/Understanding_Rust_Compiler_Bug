{"sha": "63942c969df0adc88aeec86437e78f69145cd693", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzOTQyYzk2OWRmMGFkYzg4YWVlYzg2NDM3ZTc4ZjY5MTQ1Y2Q2OTM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-05T04:17:50Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-07T00:44:26Z"}, "message": "core: Add priv::chan_from_global_ptr\n\nThis allows singleton, globally accessible tasks to be created", "tree": {"sha": "afc2414ce9cb7196bcff6b6fadcdce5d4178f060", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afc2414ce9cb7196bcff6b6fadcdce5d4178f060"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63942c969df0adc88aeec86437e78f69145cd693", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63942c969df0adc88aeec86437e78f69145cd693", "html_url": "https://github.com/rust-lang/rust/commit/63942c969df0adc88aeec86437e78f69145cd693", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63942c969df0adc88aeec86437e78f69145cd693/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52e084b92afd95630900f2067cca679e75aab36a", "url": "https://api.github.com/repos/rust-lang/rust/commits/52e084b92afd95630900f2067cca679e75aab36a", "html_url": "https://github.com/rust-lang/rust/commit/52e084b92afd95630900f2067cca679e75aab36a"}], "stats": {"total": 160, "additions": 159, "deletions": 1}, "files": [{"sha": "c0d46a9fad506ae12fbc6e856e5f6c46beea2353", "filename": "src/libcore/core.rc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63942c969df0adc88aeec86437e78f69145cd693/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/63942c969df0adc88aeec86437e78f69145cd693/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=63942c969df0adc88aeec86437e78f69145cd693", "patch": "@@ -37,6 +37,11 @@ export extfmt;\n export tuple;\n export to_str;\n \n+// FIXME: This creates some APIs that I do not want to commit to. It is\n+// currently exported for the uv code in std, but when that code moves into\n+// core this should become unexported\n+export priv;\n+\n // Built-in-type support modules\n \n mod box;\n@@ -61,7 +66,8 @@ mod bool;\n \n // For internal use by char, not exported\n mod unicode;\n-\n+// Do not export\n+mod priv;\n \n // Ubiquitous-utility-type modules\n "}, {"sha": "ec432a69ef20de703e71318ad959211b3171f466", "filename": "src/libcore/priv.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/63942c969df0adc88aeec86437e78f69145cd693/src%2Flibcore%2Fpriv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63942c969df0adc88aeec86437e78f69145cd693/src%2Flibcore%2Fpriv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpriv.rs?ref=63942c969df0adc88aeec86437e78f69145cd693", "patch": "@@ -0,0 +1,145 @@\n+#[doc(hidden)];\n+\n+export chan_from_global_ptr;\n+\n+import compare_and_swap = rustrt::rust_compare_and_swap_ptr;\n+\n+native mod rustrt {\n+    fn rust_compare_and_swap_ptr(address: *libc::uintptr_t,\n+                                 oldval: libc::uintptr_t,\n+                                 newval: libc::uintptr_t) -> bool;\n+}\n+\n+type global_ptr<T: send> = *libc::uintptr_t;\n+\n+#[doc = \"\n+Atomically gets a channel from a pointer to a pointer-sized memory location\n+or, if no channel exists creates and installs a new channel and sets up a new\n+task to receive from it.\n+\"]\n+unsafe fn chan_from_global_ptr<T: send>(\n+    global: global_ptr<T>,\n+    builder: fn() -> task::builder,\n+    f: fn~(comm::port<T>)\n+) -> comm::chan<T> {\n+\n+    enum msg {\n+        proceed,\n+        abort\n+    }\n+\n+    let is_probably_zero = *global == 0u;\n+    if is_probably_zero {\n+        // There's no global channel. We must make it\n+\n+        let setup_po = comm::port();\n+        let setup_ch = comm::chan(setup_po);\n+        let setup_ch = task::run_listener(builder()) {|setup_po|\n+            let po = comm::port::<T>();\n+            let ch = comm::chan(po);\n+            comm::send(setup_ch, ch);\n+\n+            // Wait to hear if we are the official instance of\n+            // this global task\n+            alt comm::recv::<msg>(setup_po) {\n+              proceed { f(po); }\n+              abort { }\n+            }\n+        };\n+\n+        // This is the proposed global channel\n+        let ch = comm::recv(setup_po);\n+        // 0 is our sentinal value. It is not a valid channel\n+        assert unsafe::reinterpret_cast(ch) != 0u;\n+\n+        // Install the channel\n+        let swapped = compare_and_swap(\n+            global, 0u, unsafe::reinterpret_cast(ch));\n+\n+        if swapped {\n+            // Success!\n+            comm::send(setup_ch, proceed);\n+            ch\n+        } else {\n+            // Somebody else got in before we did\n+            comm::send(setup_ch, abort);\n+            unsafe::reinterpret_cast(*global)\n+        }\n+    } else {\n+        unsafe::reinterpret_cast(*global)\n+    }\n+}\n+\n+#[test]\n+fn test_from_global_chan1() unsafe {\n+\n+    // This is unreadable, right?\n+\n+    // The global channel\n+    let globchan = 0u;\n+    let globchanp = ptr::addr_of(globchan);\n+\n+    // Create the global channel, attached to a new task\n+    let ch = chan_from_global_ptr(globchanp, task::builder) {|po|\n+        let ch = comm::recv(po);\n+        comm::send(ch, true);\n+        let ch = comm::recv(po);\n+        comm::send(ch, true);\n+    };\n+    // Talk to it\n+    let po = comm::port();\n+    comm::send(ch, comm::chan(po));\n+    assert comm::recv(po) == true;\n+\n+    // This one just reuses the previous channel\n+    let ch = chan_from_global_ptr(globchanp, task::builder) {|po|\n+        let ch = comm::recv(po);\n+        comm::send(ch, false);\n+    };\n+\n+    // Talk to the original global task\n+    let po = comm::port();\n+    comm::send(ch, comm::chan(po));\n+    assert comm::recv(po) == true;\n+}\n+\n+#[test]\n+fn test_from_global_chan2() unsafe {\n+\n+    iter::repeat(100u) {||\n+        // The global channel\n+        let globchan = 0u;\n+        let globchanp = ptr::addr_of(globchan);\n+\n+        let resultpo = comm::port();\n+        let resultch = comm::chan(resultpo);\n+\n+        // Spawn a bunch of tasks that all want to compete to\n+        // create the global channel\n+        uint::range(0u, 10u) {|i|\n+            task::spawn() {||\n+                let ch = chan_from_global_ptr(\n+                    globchanp, task::builder) {|po|\n+\n+                    uint::range(0u, 10u) {|_j|\n+                        let ch = comm::recv(po);\n+                        comm::send(ch, {i});\n+                    }\n+                };\n+                let po = comm::port();\n+                comm::send(ch, comm::chan(po));\n+                // We are the winner if our version of the\n+                // task was installed\n+                let winner = comm::recv(po);\n+                comm::send(resultch, winner == i);\n+            }\n+        }\n+        // There should be only one winner\n+        let mut winners = 0u;\n+        uint::range(0u, 10u) {|_i|\n+            let res = comm::recv(resultpo);\n+            if res { winners += 1u };\n+        }\n+        assert winners == 1u;\n+    }\n+}"}, {"sha": "910331fa7c08408f76df3030cdd772dacfe93e4e", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63942c969df0adc88aeec86437e78f69145cd693/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/63942c969df0adc88aeec86437e78f69145cd693/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=63942c969df0adc88aeec86437e78f69145cd693", "patch": "@@ -776,6 +776,12 @@ rust_osmain_sched_id() {\n     return task->kernel->osmain_sched_id();\n }\n \n+extern \"C\" CDECL bool\n+rust_compare_and_swap_ptr(intptr_t *address,\n+                          intptr_t oldval, intptr_t newval) {\n+    return sync::compare_and_swap(address, oldval, newval);\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "ec4f5bedb24f29c7c5bf3d123e76f2ff93939d80", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63942c969df0adc88aeec86437e78f69145cd693/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/63942c969df0adc88aeec86437e78f69145cd693/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=63942c969df0adc88aeec86437e78f69145cd693", "patch": "@@ -136,3 +136,4 @@ rust_dbg_lock_wait\n rust_dbg_lock_signal\n rust_dbg_call\n rust_osmain_sched_id\n+rust_compare_and_swap_ptr\n\\ No newline at end of file"}]}