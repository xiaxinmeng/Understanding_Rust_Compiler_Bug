{"sha": "e76bd7e75d3ab7e7091817dc84d03e29c86f32eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3NmJkN2U3NWQzYWI3ZTcwOTE4MTdkYzg0ZDAzZTI5Yzg2ZjMyZWI=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-12-23T18:31:43Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-29T16:58:21Z"}, "message": "Properly deal with Ordering in the guide\n\nNow that it's been removed from the prelude, we need to treat things differently.\n\nFixes #17967", "tree": {"sha": "50aa17ea10067cffee55b7f642e1479dff0a4c64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50aa17ea10067cffee55b7f642e1479dff0a4c64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e76bd7e75d3ab7e7091817dc84d03e29c86f32eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e76bd7e75d3ab7e7091817dc84d03e29c86f32eb", "html_url": "https://github.com/rust-lang/rust/commit/e76bd7e75d3ab7e7091817dc84d03e29c86f32eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e76bd7e75d3ab7e7091817dc84d03e29c86f32eb/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c32d03f4172580e3f33e4844ed3c01234dca2d53", "url": "https://api.github.com/repos/rust-lang/rust/commits/c32d03f4172580e3f33e4844ed3c01234dca2d53", "html_url": "https://github.com/rust-lang/rust/commit/c32d03f4172580e3f33e4844ed3c01234dca2d53"}], "stats": {"total": 82, "additions": 48, "deletions": 34}, "files": [{"sha": "26a39b5140550fca55262b1631f2be595e3db9f3", "filename": "src/doc/guide.md", "status": "modified", "additions": 48, "deletions": 34, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e76bd7e75d3ab7e7091817dc84d03e29c86f32eb/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/e76bd7e75d3ab7e7091817dc84d03e29c86f32eb/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=e76bd7e75d3ab7e7091817dc84d03e29c86f32eb", "patch": "@@ -1100,10 +1100,17 @@ enum Ordering {\n ```\n \n An `Ordering` can only be _one_ of `Less`, `Equal`, or `Greater` at any given\n-time. Here's an example:\n+time.\n+\n+Because `Ordering` is provided by the standard library, we can use the `use`\n+keyword to use it in our code. We'll learn more about `use` later, but it's\n+used to bring names into scope.\n+\n+Here's an example of how to use `Ordering`:\n \n ```{rust}\n-# use std::cmp::Ordering;\n+use std::cmp::Ordering;\n+\n fn cmp(a: int, b: int) -> Ordering {\n     if a < b { Ordering::Less }\n     else if a > b { Ordering::Greater }\n@@ -1126,18 +1133,25 @@ fn main() {\n }\n ```\n \n-`cmp` is a function that compares two things, and returns an `Ordering`. We\n-return either `Less`, `Greater`, or `Equal`, depending on if the two values\n-are greater, less, or equal.\n+There's a symbol here we haven't seen before: the double colon (`::`).\n+This is used to indicate a namesapce. In this case, `Ordering` lives in\n+the `cmp` submodule of the `std` module. We'll talk more about modules\n+later in the guide. For now, all you need to know is that you can `use`\n+things from the standard library if you need them.\n \n-The `ordering` variable has the type `Ordering`, and so contains one of the\n-three values. We can then do a bunch of `if`/`else` comparisons to check\n-which one it is.\n+Okay, let's talk about the actual code in the example. `cmp` is a function that\n+compares two things, and returns an `Ordering`. We return either\n+`Ordering::Less`, `Ordering::Greater`, or `Ordering::Equal`, depending on if\n+the two values are greater, less, or equal. Note that each variant of the\n+`enum` is namespaced under the `enum` itself: it's `Ordering::Greater` not\n+`Greater`.\n \n-However, repeated `if`/`else` comparisons get quite tedious. Rust has a feature\n-that not only makes them nicer to read, but also makes sure that you never\n-miss a case. Before we get to that, though, let's talk about another kind of\n-enum: one with values.\n+The `ordering` variable has the type `Ordering`, and so contains one of the\n+three values. We can then do a bunch of `if`/`else` comparisons to check which\n+one it is. However, repeated `if`/`else` comparisons get quite tedious. Rust\n+has a feature that not only makes them nicer to read, but also makes sure that\n+you never miss a case. Before we get to that, though, let's talk about another\n+kind of enum: one with values.\n \n This enum has two variants, one of which has a value:\n \n@@ -1170,18 +1184,19 @@ enum StringResult {\n     ErrorReason(String),\n }\n ```\n-Where a `StringResult` is either a `StringOK`, with the result of a computation, or an\n-`ErrorReason` with a `String` explaining what caused the computation to fail. These kinds of\n-`enum`s are actually very useful and are even part of the standard library.\n+Where a `StringResult` is either a `StringResult::StringOK`, with the result of\n+a computation, or an `StringResult::ErrorReason` with a `String` explaining\n+what caused the computation to fail. These kinds of `enum`s are actually very\n+useful and are even part of the standard library.\n \n-Enum variants are namespaced under the enum names. For example, here is an example of using\n-our `StringResult`:\n+Here is an example of using our `StringResult`:\n \n ```rust\n-# enum StringResult {\n-#     StringOK(String),\n-#     ErrorReason(String),\n-# }\n+enum StringResult {\n+    StringOK(String),\n+    ErrorReason(String),\n+}\n+\n fn respond(greeting: &str) -> StringResult {\n     if greeting == \"Hello\" {\n         StringResult::StringOK(\"Good morning!\".to_string())\n@@ -1191,10 +1206,7 @@ fn respond(greeting: &str) -> StringResult {\n }\n ```\n \n-Notice that we need both the enum name and the variant name: `StringResult::StringOK`, but\n-we didn't need to with `Ordering` \u2013 we just said `Greater` rather than `Ordering::Greater`.\n-There's a reason: the Rust prelude imports the variants of `Ordering` as well as the enum\n-itself. We can use the `use` keyword to do something similar with `StringResult`:\n+That's a lot of typing! We can use the `use` keyword to make it shorter:\n \n ```rust\n use StringResult::StringOK;\n@@ -1216,12 +1228,11 @@ fn respond(greeting: &str) -> StringResult {\n }\n ```\n \n-We'll learn more about `use` later, but it's used to bring names into scope. `use` declarations\n-must come before anything else, which looks a little strange in this example, since we `use`\n-the variants before we define them. Anyway, in the body of `respond`, we can just say `StringOK`\n-now, rather than the full `StringResult::StringOK`. Importing variants can be convenient, but can\n-also cause name conflicts, so do this with caution. It's considered good style to rarely import\n-variants for this reason.\n+`use` declarations must come before anything else, which looks a little strange in this example,\n+since we `use` the variants before we define them. Anyway, in the body of `respond`, we can just\n+say `StringOK` now, rather than the full `StringResult::StringOK`. Importing variants can be\n+convenient, but can also cause name conflicts, so do this with caution. It's considered good style\n+to rarely import variants for this reason.\n \n As you can see, `enum`s with values are quite a powerful tool for data representation,\n and can be even more useful when they're generic across types. Before we get to generics,\n@@ -1275,7 +1286,8 @@ for every possible value of `x`, and so our program will compile successfully.\n section on enums?\n \n ```{rust}\n-# use std::cmp::Ordering;\n+use std::cmp::Ordering;\n+\n fn cmp(a: int, b: int) -> Ordering {\n     if a < b { Ordering::Less }\n     else if a > b { Ordering::Greater }\n@@ -1301,7 +1313,8 @@ fn main() {\n We can re-write this as a `match`:\n \n ```{rust}\n-# use std::cmp::Ordering;\n+use std::cmp::Ordering;\n+\n fn cmp(a: int, b: int) -> Ordering {\n     if a < b { Ordering::Less }\n     else if a > b { Ordering::Greater }\n@@ -1362,7 +1375,8 @@ side of a `let` binding or directly where an expression is used. We could\n also implement the previous line like this:\n \n ```{rust}\n-# use std::cmp::Ordering;\n+use std::cmp::Ordering;\n+\n fn cmp(a: int, b: int) -> Ordering {\n     if a < b { Ordering::Less }\n     else if a > b { Ordering::Greater }"}]}