{"sha": "d616f47cd03a65fed13be2ee5527f24f6a4f7f92", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2MTZmNDdjZDAzYTY1ZmVkMTNiZTJlZTU1MjdmMjRmNmE0ZjdmOTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-09T17:51:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-09T17:51:32Z"}, "message": "Auto merge of #41084 - QuietMisdreavus:rustdoc-format-redux, r=frewsxcxv,GuillaumeGomez\n\nrustdoc: update formatting of fn signatures and where clauses to match style rfcs\n\nRecent updates to style RFCs ([where clauses](https://github.com/rust-lang-nursery/fmt-rfcs/issues/38), [function definitions](https://github.com/rust-lang-nursery/fmt-rfcs/issues/39)) changed the \"canonical\" style for these items, so this is a rustdoc update to make it emit that style where necessary. This is mainly a conversion from visual indent to block indent, which helps out in situations where there was excessive indent causing lines to wrap regardless.\n\nSamples:\n\n![std::iter::IntoIterator](https://cloud.githubusercontent.com/assets/5217170/24712947/e586604c-19e9-11e7-87ae-4fe64d689dc3.png)\n\n![excerpt from std::iter::Iterator](https://cloud.githubusercontent.com/assets/5217170/24713209/91e65112-19ea-11e7-9ff8-d4cf6b31aae1.png)\n\n![std::iter::FromIterator](https://cloud.githubusercontent.com/assets/5217170/24713138/59f36114-19ea-11e7-9dbb-5f5ba7126e2e.png)\n\n![std::cmp::min](https://cloud.githubusercontent.com/assets/5217170/24713038/1bab88b4-19ea-11e7-935d-defed5648de4.png)\n\n![some trait impls on std::collections::HashMap](https://cloud.githubusercontent.com/assets/5217170/24713251/b7ef69e8-19ea-11e7-94a7-e01fbf89fa31.png)\n\n![`fn extract_code_blocks`, an example given in #40687](https://cloud.githubusercontent.com/assets/5217170/24713159/672717cc-19ea-11e7-9acb-6ac278b90339.png)\n\n![excerpt from itertools::Itertools](https://cloud.githubusercontent.com/assets/5217170/24713323/f06716ea-19ea-11e7-94cc-6ef68d9980ec.png)\n\nfixes #41025 and #40687\n\nr? @rust-lang/docs", "tree": {"sha": "a3af2cda894abde784d405b75e4f8f0db4996a71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3af2cda894abde784d405b75e4f8f0db4996a71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d616f47cd03a65fed13be2ee5527f24f6a4f7f92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d616f47cd03a65fed13be2ee5527f24f6a4f7f92", "html_url": "https://github.com/rust-lang/rust/commit/d616f47cd03a65fed13be2ee5527f24f6a4f7f92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d616f47cd03a65fed13be2ee5527f24f6a4f7f92/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa332c901575da70ac7a612609a26b752b1adc65", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa332c901575da70ac7a612609a26b752b1adc65", "html_url": "https://github.com/rust-lang/rust/commit/fa332c901575da70ac7a612609a26b752b1adc65"}, {"sha": "8dd4c44ef6c851afcc9651c9b32df005e35d0d1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8dd4c44ef6c851afcc9651c9b32df005e35d0d1d", "html_url": "https://github.com/rust-lang/rust/commit/8dd4c44ef6c851afcc9651c9b32df005e35d0d1d"}], "stats": {"total": 270, "additions": 137, "deletions": 133}, "files": [{"sha": "ffef42bc3d27ce1fe398c0d5dee6386c427a79d5", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 76, "deletions": 58, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/d616f47cd03a65fed13be2ee5527f24f6a4f7f92/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d616f47cd03a65fed13be2ee5527f24f6a4f7f92/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=d616f47cd03a65fed13be2ee5527f24f6a4f7f92", "patch": "@@ -41,22 +41,38 @@ pub struct UnsafetySpace(pub hir::Unsafety);\n /// with a space after it.\n #[derive(Copy, Clone)]\n pub struct ConstnessSpace(pub hir::Constness);\n-/// Wrapper struct for properly emitting a method declaration.\n-pub struct Method<'a>(pub &'a clean::FnDecl, pub usize);\n /// Similar to VisSpace, but used for mutability\n #[derive(Copy, Clone)]\n pub struct MutableSpace(pub clean::Mutability);\n /// Similar to VisSpace, but used for mutability\n #[derive(Copy, Clone)]\n pub struct RawMutableSpace(pub clean::Mutability);\n-/// Wrapper struct for emitting a where clause from Generics.\n-pub struct WhereClause<'a>(pub &'a clean::Generics, pub usize);\n /// Wrapper struct for emitting type parameter bounds.\n pub struct TyParamBounds<'a>(pub &'a [clean::TyParamBound]);\n /// Wrapper struct for emitting a comma-separated list of items\n pub struct CommaSep<'a, T: 'a>(pub &'a [T]);\n pub struct AbiSpace(pub Abi);\n \n+/// Wrapper struct for properly emitting a method declaration.\n+pub struct Method<'a> {\n+    /// The declaration to emit.\n+    pub decl: &'a clean::FnDecl,\n+    /// The length of the function's \"name\", used to determine line-wrapping.\n+    pub name_len: usize,\n+    /// The number of spaces to indent each successive line with, if line-wrapping is necessary.\n+    pub indent: usize,\n+}\n+\n+/// Wrapper struct for emitting a where clause from Generics.\n+pub struct WhereClause<'a>{\n+    /// The Generics from which to emit a where clause.\n+    pub gens: &'a clean::Generics,\n+    /// The number of spaces to indent each line with.\n+    pub indent: usize,\n+    /// Whether the where clause needs to add a comma and newline after the last bound.\n+    pub end_newline: bool,\n+}\n+\n pub struct HRef<'a> {\n     pub did: DefId,\n     pub text: &'a str,\n@@ -167,24 +183,27 @@ impl fmt::Display for clean::Generics {\n \n impl<'a> fmt::Display for WhereClause<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let &WhereClause(gens, pad) = self;\n+        let &WhereClause { gens, indent, end_newline } = self;\n         if gens.where_predicates.is_empty() {\n             return Ok(());\n         }\n         let mut clause = String::new();\n         if f.alternate() {\n-            clause.push_str(\" where \");\n+            clause.push_str(\" where\");\n         } else {\n-            clause.push_str(\" <span class=\\\"where fmt-newline\\\">where \");\n+            if end_newline {\n+                clause.push_str(\" <span class=\\\"where fmt-newline\\\">where\");\n+            } else {\n+                clause.push_str(\" <span class=\\\"where\\\">where\");\n+            }\n         }\n         for (i, pred) in gens.where_predicates.iter().enumerate() {\n-            if i > 0 {\n-                if f.alternate() {\n-                    clause.push_str(\", \");\n-                } else {\n-                    clause.push_str(\",<br>\");\n-                }\n+            if f.alternate() {\n+                clause.push(' ');\n+            } else {\n+                clause.push_str(\"<br>\");\n             }\n+\n             match pred {\n                 &clean::WherePredicate::BoundPredicate { ref ty, ref bounds } => {\n                     let bounds = bounds;\n@@ -213,21 +232,29 @@ impl<'a> fmt::Display for WhereClause<'a> {\n                     }\n                 }\n             }\n+\n+            if i < gens.where_predicates.len() - 1 || end_newline {\n+                clause.push(',');\n+            }\n         }\n+\n+        if end_newline {\n+            //add a space so stripping <br> tags and breaking spaces still renders properly\n+            if f.alternate() {\n+                clause.push(' ');\n+            } else {\n+                clause.push_str(\"&nbsp;\");\n+            }\n+        }\n+\n         if !f.alternate() {\n             clause.push_str(\"</span>\");\n-            let plain = format!(\"{:#}\", self);\n-            if plain.len() + pad > 80 {\n-                // break it onto its own line regardless, but make sure method impls and trait\n-                // blocks keep their fixed padding (2 and 9, respectively)\n-                let padding = if pad > 10 {\n-                    repeat(\"&nbsp;\").take(8).collect::<String>()\n-                } else {\n-                    repeat(\"&nbsp;\").take(pad + 6).collect::<String>()\n-                };\n-                clause = clause.replace(\"<br>\", &format!(\"<br>{}\", padding));\n-            } else {\n-                clause = clause.replace(\"<br>\", \" \");\n+            let padding = repeat(\"&nbsp;\").take(indent + 4).collect::<String>();\n+            clause = clause.replace(\"<br>\", &format!(\"<br>{}\", padding));\n+            clause.insert_str(0, &repeat(\"&nbsp;\").take(indent.saturating_sub(1))\n+                                                  .collect::<String>());\n+            if !end_newline {\n+                clause.insert_str(0, \"<br>\");\n             }\n         }\n         write!(f, \"{}\", clause)\n@@ -838,43 +865,35 @@ fn fmt_impl(i: &clean::Impl,\n             f: &mut fmt::Formatter,\n             link_trait: bool,\n             use_absolute: bool) -> fmt::Result {\n-    let mut plain = String::new();\n-\n     if f.alternate() {\n         write!(f, \"impl{:#} \", i.generics)?;\n     } else {\n         write!(f, \"impl{} \", i.generics)?;\n     }\n-    plain.push_str(&format!(\"impl{:#} \", i.generics));\n \n     if let Some(ref ty) = i.trait_ {\n         if i.polarity == Some(clean::ImplPolarity::Negative) {\n             write!(f, \"!\")?;\n-            plain.push_str(\"!\");\n         }\n \n         if link_trait {\n             fmt::Display::fmt(ty, f)?;\n-            plain.push_str(&format!(\"{:#}\", ty));\n         } else {\n             match *ty {\n                 clean::ResolvedPath { typarams: None, ref path, is_generic: false, .. } => {\n                     let last = path.segments.last().unwrap();\n                     fmt::Display::fmt(&last.name, f)?;\n                     fmt::Display::fmt(&last.params, f)?;\n-                    plain.push_str(&format!(\"{:#}{:#}\", last.name, last.params));\n                 }\n                 _ => unreachable!(),\n             }\n         }\n         write!(f, \" for \")?;\n-        plain.push_str(\" for \");\n     }\n \n     fmt_type(&i.for_, f, use_absolute, true)?;\n-    plain.push_str(&format!(\"{:#}\", i.for_));\n \n-    fmt::Display::fmt(&WhereClause(&i.generics, plain.len() + 1), f)?;\n+    fmt::Display::fmt(&WhereClause { gens: &i.generics, indent: 0, end_newline: true }, f)?;\n     Ok(())\n }\n \n@@ -939,12 +958,15 @@ impl fmt::Display for clean::FnDecl {\n \n impl<'a> fmt::Display for Method<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let decl = self.0;\n-        let indent = self.1;\n+        let &Method { decl, name_len, indent } = self;\n         let amp = if f.alternate() { \"&\" } else { \"&amp;\" };\n         let mut args = String::new();\n         let mut args_plain = String::new();\n         for (i, input) in decl.inputs.values.iter().enumerate() {\n+            if i == 0 {\n+                args.push_str(\"<br>\");\n+            }\n+\n             if let Some(selfty) = input.to_self() {\n                 match selfty {\n                     clean::SelfValue => {\n@@ -970,7 +992,7 @@ impl<'a> fmt::Display for Method<'a> {\n                 }\n             } else {\n                 if i > 0 {\n-                    args.push_str(\"<br> \");\n+                    args.push_str(\" <br>\");\n                     args_plain.push_str(\" \");\n                 }\n                 if !input.name.is_empty() {\n@@ -986,8 +1008,8 @@ impl<'a> fmt::Display for Method<'a> {\n                 args_plain.push_str(&format!(\"{:#}\", input.type_));\n             }\n             if i + 1 < decl.inputs.values.len() {\n-                args.push_str(\",\");\n-                args_plain.push_str(\",\");\n+                args.push(',');\n+                args_plain.push(',');\n             }\n         }\n \n@@ -1003,27 +1025,23 @@ impl<'a> fmt::Display for Method<'a> {\n             format!(\"{}\", decl.output)\n         };\n \n-        let mut output: String;\n-        let plain: String;\n-        let pad = repeat(\" \").take(indent).collect::<String>();\n-        if arrow.is_empty() {\n-            output = format!(\"({})\", args);\n-            plain = format!(\"{}({})\", pad, args_plain);\n+        let pad = repeat(\" \").take(name_len).collect::<String>();\n+        let plain = format!(\"{pad}({args}){arrow}\",\n+                        pad = pad,\n+                        args = args_plain,\n+                        arrow = arrow_plain);\n+\n+        let output = if plain.len() > 80 {\n+            let full_pad = format!(\"<br>{}\", repeat(\"&nbsp;\").take(indent + 4).collect::<String>());\n+            let close_pad = format!(\"<br>{}\", repeat(\"&nbsp;\").take(indent).collect::<String>());\n+            format!(\"({args}{close}){arrow}\",\n+                    args = args.replace(\"<br>\", &full_pad),\n+                    close = close_pad,\n+                    arrow = arrow)\n         } else {\n-            output = format!(\"({args})<br>{arrow}\", args = args, arrow = arrow);\n-            plain = format!(\"{pad}({args}){arrow}\",\n-                            pad = pad,\n-                            args = args_plain,\n-                            arrow = arrow_plain);\n-        }\n+            format!(\"({args}){arrow}\", args = args.replace(\"<br>\", \"\"), arrow = arrow)\n+        };\n \n-        if plain.len() > 80 {\n-            let pad = repeat(\"&nbsp;\").take(indent).collect::<String>();\n-            let pad = format!(\"<br>{}\", pad);\n-            output = output.replace(\"<br>\", &pad);\n-        } else {\n-            output = output.replace(\"<br>\", \"\");\n-        }\n         if f.alternate() {\n             write!(f, \"{}\", output.replace(\"<br>\", \"\\n\"))\n         } else {"}, {"sha": "42a18345681f69eec08283610d5a21f0340db37e", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 55, "deletions": 58, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/d616f47cd03a65fed13be2ee5527f24f6a4f7f92/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d616f47cd03a65fed13be2ee5527f24f6a4f7f92/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=d616f47cd03a65fed13be2ee5527f24f6a4f7f92", "patch": "@@ -2016,13 +2016,13 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         UnstableFeatures::Allow => f.constness,\n         _ => hir::Constness::NotConst\n     };\n-    let indent = format!(\"{}{}{}{:#}fn {}{:#}\",\n-                         VisSpace(&it.visibility),\n-                         ConstnessSpace(vis_constness),\n-                         UnsafetySpace(f.unsafety),\n-                         AbiSpace(f.abi),\n-                         it.name.as_ref().unwrap(),\n-                         f.generics).len();\n+    let name_len = format!(\"{}{}{}{:#}fn {}{:#}\",\n+                           VisSpace(&it.visibility),\n+                           ConstnessSpace(vis_constness),\n+                           UnsafetySpace(f.unsafety),\n+                           AbiSpace(f.abi),\n+                           it.name.as_ref().unwrap(),\n+                           f.generics).len();\n     write!(w, \"<pre class='rust fn'>\")?;\n     render_attributes(w, it)?;\n     write!(w, \"{vis}{constness}{unsafety}{abi}fn \\\n@@ -2033,8 +2033,12 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n            abi = AbiSpace(f.abi),\n            name = it.name.as_ref().unwrap(),\n            generics = f.generics,\n-           where_clause = WhereClause(&f.generics, 2),\n-           decl = Method(&f.decl, indent))?;\n+           where_clause = WhereClause { gens: &f.generics, indent: 0, end_newline: true },\n+           decl = Method {\n+               decl: &f.decl,\n+               name_len: name_len,\n+               indent: 0,\n+           })?;\n     document(w, cx, it)\n }\n \n@@ -2062,14 +2066,18 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     // Output the trait definition\n     write!(w, \"<pre class='rust trait'>\")?;\n     render_attributes(w, it)?;\n-    write!(w, \"{}{}trait {}{}{}{} \",\n+    write!(w, \"{}{}trait {}{}{}\",\n            VisSpace(&it.visibility),\n            UnsafetySpace(t.unsafety),\n            it.name.as_ref().unwrap(),\n            t.generics,\n-           bounds,\n-           // Where clauses in traits are indented nine spaces, per rustdoc.css\n-           WhereClause(&t.generics, 9))?;\n+           bounds)?;\n+\n+    if !t.generics.where_predicates.is_empty() {\n+        write!(w, \"{}\", WhereClause { gens: &t.generics, indent: 0, end_newline: true })?;\n+    } else {\n+        write!(w, \" \")?;\n+    }\n \n     let types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n     let consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n@@ -2108,7 +2116,14 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         for m in &provided {\n             write!(w, \"    \")?;\n             render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait)?;\n-            write!(w, \" {{ ... }}\\n\")?;\n+            match m.inner {\n+                clean::MethodItem(ref inner) if !inner.generics.where_predicates.is_empty() => {\n+                    write!(w, \",\\n    {{ ... }}\\n\")?;\n+                },\n+                _ => {\n+                    write!(w, \" {{ ... }}\\n\")?;\n+                },\n+            }\n         }\n         write!(w, \"}}\")?;\n     }\n@@ -2342,21 +2357,17 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n         } else {\n             hir::Constness::NotConst\n         };\n-        let prefix = format!(\"{}{}{:#}fn {}{:#}\",\n-                             ConstnessSpace(vis_constness),\n-                             UnsafetySpace(unsafety),\n-                             AbiSpace(abi),\n-                             name,\n-                             *g);\n-        let mut indent = prefix.len();\n-        let where_indent = if parent == ItemType::Trait {\n-            indent += 4;\n-            8\n-        } else if parent == ItemType::Impl {\n-            2\n+        let mut head_len = format!(\"{}{}{:#}fn {}{:#}\",\n+                                   ConstnessSpace(vis_constness),\n+                                   UnsafetySpace(unsafety),\n+                                   AbiSpace(abi),\n+                                   name,\n+                                   *g).len();\n+        let (indent, end_newline) = if parent == ItemType::Trait {\n+            head_len += 4;\n+            (4, false)\n         } else {\n-            let prefix = prefix + &format!(\"{:#}\", Method(d, indent));\n-            prefix.lines().last().unwrap().len() + 1\n+            (0, true)\n         };\n         write!(w, \"{}{}{}fn <a href='{href}' class='fnname'>{name}</a>\\\n                    {generics}{decl}{where_clause}\",\n@@ -2366,8 +2377,16 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n                href = href,\n                name = name,\n                generics = *g,\n-               decl = Method(d, indent),\n-               where_clause = WhereClause(g, where_indent))\n+               decl = Method {\n+                   decl: d,\n+                   name_len: head_len,\n+                   indent: indent,\n+               },\n+               where_clause = WhereClause {\n+                   gens: g,\n+                   indent: indent,\n+                   end_newline: end_newline,\n+               })\n     }\n     match item.inner {\n         clean::StrippedItem(..) => Ok(()),\n@@ -2480,15 +2499,11 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n              e: &clean::Enum) -> fmt::Result {\n     write!(w, \"<pre class='rust enum'>\")?;\n     render_attributes(w, it)?;\n-    let padding = format!(\"{}enum {}{:#} \",\n-                          VisSpace(&it.visibility),\n-                          it.name.as_ref().unwrap(),\n-                          e.generics).len();\n     write!(w, \"{}enum {}{}{}\",\n            VisSpace(&it.visibility),\n            it.name.as_ref().unwrap(),\n            e.generics,\n-           WhereClause(&e.generics, padding))?;\n+           WhereClause { gens: &e.generics, indent: 0, end_newline: true })?;\n     if e.variants.is_empty() && !e.variants_stripped {\n         write!(w, \" {{}}\")?;\n     } else {\n@@ -2662,23 +2677,17 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                  fields: &[clean::Item],\n                  tab: &str,\n                  structhead: bool) -> fmt::Result {\n-    let mut plain = String::new();\n     write!(w, \"{}{}{}\",\n            VisSpace(&it.visibility),\n            if structhead {\"struct \"} else {\"\"},\n            it.name.as_ref().unwrap())?;\n-    plain.push_str(&format!(\"{}{}{}\",\n-                            VisSpace(&it.visibility),\n-                            if structhead {\"struct \"} else {\"\"},\n-                            it.name.as_ref().unwrap()));\n     if let Some(g) = g {\n-        plain.push_str(&format!(\"{:#}\", g));\n         write!(w, \"{}\", g)?\n     }\n     match ty {\n         doctree::Plain => {\n             if let Some(g) = g {\n-                write!(w, \"{}\", WhereClause(g, plain.len() + 1))?\n+                write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: true })?\n             }\n             let mut has_visible_fields = false;\n             write!(w, \" {{\")?;\n@@ -2707,35 +2716,30 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n         }\n         doctree::Tuple => {\n             write!(w, \"(\")?;\n-            plain.push_str(\"(\");\n             for (i, field) in fields.iter().enumerate() {\n                 if i > 0 {\n                     write!(w, \", \")?;\n-                    plain.push_str(\", \");\n                 }\n                 match field.inner {\n                     clean::StrippedItem(box clean::StructFieldItem(..)) => {\n-                        plain.push_str(\"_\");\n                         write!(w, \"_\")?\n                     }\n                     clean::StructFieldItem(ref ty) => {\n-                        plain.push_str(&format!(\"{}{:#}\", VisSpace(&field.visibility), *ty));\n                         write!(w, \"{}{}\", VisSpace(&field.visibility), *ty)?\n                     }\n                     _ => unreachable!()\n                 }\n             }\n             write!(w, \")\")?;\n-            plain.push_str(\")\");\n             if let Some(g) = g {\n-                write!(w, \"{}\", WhereClause(g, plain.len() + 1))?\n+                write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: false })?\n             }\n             write!(w, \";\")?;\n         }\n         doctree::Unit => {\n             // Needed for PhantomData.\n             if let Some(g) = g {\n-                write!(w, \"{}\", WhereClause(g, plain.len() + 1))?\n+                write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: false })?\n             }\n             write!(w, \";\")?;\n         }\n@@ -2748,19 +2752,13 @@ fn render_union(w: &mut fmt::Formatter, it: &clean::Item,\n                 fields: &[clean::Item],\n                 tab: &str,\n                 structhead: bool) -> fmt::Result {\n-    let mut plain = String::new();\n     write!(w, \"{}{}{}\",\n            VisSpace(&it.visibility),\n            if structhead {\"union \"} else {\"\"},\n            it.name.as_ref().unwrap())?;\n-    plain.push_str(&format!(\"{}{}{}\",\n-                            VisSpace(&it.visibility),\n-                            if structhead {\"union \"} else {\"\"},\n-                            it.name.as_ref().unwrap()));\n     if let Some(g) = g {\n         write!(w, \"{}\", g)?;\n-        plain.push_str(&format!(\"{:#}\", g));\n-        write!(w, \"{}\", WhereClause(g, plain.len() + 1))?;\n+        write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: true })?;\n     }\n \n     write!(w, \" {{\\n{}\", tab)?;\n@@ -3059,13 +3057,12 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n \n fn item_typedef(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 t: &clean::Typedef) -> fmt::Result {\n-    let indent = format!(\"type {}{:#} \", it.name.as_ref().unwrap(), t.generics).len();\n     write!(w, \"<pre class='rust typedef'>\")?;\n     render_attributes(w, it)?;\n     write!(w, \"type {}{}{where_clause} = {type_};</pre>\",\n            it.name.as_ref().unwrap(),\n            t.generics,\n-           where_clause = WhereClause(&t.generics, indent),\n+           where_clause = WhereClause { gens: &t.generics, indent: 0, end_newline: true },\n            type_ = t.type_)?;\n \n     document(w, cx, it)"}, {"sha": "ddaa00aa4fb1446c5da00c571e6b2a6e7635359c", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d616f47cd03a65fed13be2ee5527f24f6a4f7f92/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/d616f47cd03a65fed13be2ee5527f24f6a4f7f92/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=d616f47cd03a65fed13be2ee5527f24f6a4f7f92", "patch": "@@ -379,12 +379,6 @@ h4 > code, h3 > code, .invisible > code {\n .content .where.fmt-newline {\n \tdisplay: block;\n }\n-/* Bit of whitespace to indent it */\n-.content .method .where::before,\n-.content .fn .where::before,\n-.content .where.fmt-newline::before {\n-\tcontent: '  ';\n-}\n \n .content .methods > div { margin-left: 40px; }\n \n@@ -399,11 +393,6 @@ h4 > code, h3 > code, .invisible > code {\n \tfont-size: 90%;\n }\n \n-/* Shift where in trait listing down a line */\n-pre.trait .where::before {\n-\tcontent: '\\a         ';\n-}\n-\n nav {\n \tborder-bottom: 1px solid;\n \tpadding-bottom: 10px;\n@@ -772,4 +761,4 @@ span.since {\n \tnav.sub, .content .out-of-band, .collapse-toggle {\n \t\tdisplay: none;\n \t}\n-}\n\\ No newline at end of file\n+}"}, {"sha": "48ef4b6be66dea34e4d204f8ce7eba6bce392b74", "filename": "src/test/rustdoc/impl-parts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d616f47cd03a65fed13be2ee5527f24f6a4f7f92/src%2Ftest%2Frustdoc%2Fimpl-parts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d616f47cd03a65fed13be2ee5527f24f6a4f7f92/src%2Ftest%2Frustdoc%2Fimpl-parts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fimpl-parts.rs?ref=d616f47cd03a65fed13be2ee5527f24f6a4f7f92", "patch": "@@ -17,7 +17,7 @@ impl AnOibit for .. {}\n pub struct Foo<T> { field: T }\n \n // @has impl_parts/struct.Foo.html '//*[@class=\"impl\"]//code' \\\n-//     \"impl<T: Clone> !AnOibit for Foo<T> where T: Sync\"\n+//     \"impl<T: Clone> !AnOibit for Foo<T> where T: Sync,\"\n // @has impl_parts/trait.AnOibit.html '//*[@class=\"item-list\"]//code' \\\n-//     \"impl<T: Clone> !AnOibit for Foo<T> where T: Sync\"\n+//     \"impl<T: Clone> !AnOibit for Foo<T> where T: Sync,\"\n impl<T: Clone> !AnOibit for Foo<T> where T: Sync {}"}, {"sha": "960e40b07098567491d48b8936a0fe4a7b757b09", "filename": "src/test/rustdoc/issue-20727-4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d616f47cd03a65fed13be2ee5527f24f6a4f7f92/src%2Ftest%2Frustdoc%2Fissue-20727-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d616f47cd03a65fed13be2ee5527f24f6a4f7f92/src%2Ftest%2Frustdoc%2Fissue-20727-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-20727-4.rs?ref=d616f47cd03a65fed13be2ee5527f24f6a4f7f92", "patch": "@@ -35,15 +35,15 @@ pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n \n pub mod reexport {\n     // @has issue_20727_4/reexport/trait.Index.html\n-    // @has - '//*[@class=\"rust trait\"]' 'trait Index<Idx> where Idx: ?Sized {'\n+    // @has - '//*[@class=\"rust trait\"]' 'trait Index<Idx> where Idx: ?Sized, {'\n     // @has - '//*[@class=\"rust trait\"]' 'type Output: ?Sized'\n     // @has - '//*[@class=\"rust trait\"]' \\\n     //        'fn index(&self, index: Idx) -> &Self::Output'\n     pub use issue_20727::Index;\n \n     // @has issue_20727_4/reexport/trait.IndexMut.html\n     // @has - '//*[@class=\"rust trait\"]' \\\n-    //        'trait IndexMut<Idx>: Index<Idx> where Idx: ?Sized {'\n+    //        'trait IndexMut<Idx>: Index<Idx> where Idx: ?Sized, {'\n     // @has - '//*[@class=\"rust trait\"]' \\\n     //        'fn index_mut(&mut self, index: Idx) -> &mut Self::Output;'\n     pub use issue_20727::IndexMut;"}, {"sha": "e691f7c5bea01ef8e054f78e1cc71c7c9bcb7492", "filename": "src/test/rustdoc/where.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d616f47cd03a65fed13be2ee5527f24f6a4f7f92/src%2Ftest%2Frustdoc%2Fwhere.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d616f47cd03a65fed13be2ee5527f24f6a4f7f92/src%2Ftest%2Frustdoc%2Fwhere.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fwhere.rs?ref=d616f47cd03a65fed13be2ee5527f24f6a4f7f92", "patch": "@@ -44,5 +44,5 @@ pub enum Foxtrot<F> { Foxtrot1(F) }\n impl<F> MyTrait for Foxtrot<F> where F: MyTrait {}\n \n // @has foo/type.Golf.html '//pre[@class=\"rust typedef\"]' \\\n-//          \"type Golf<T> where T: Clone = (T, T)\"\n+//          \"type Golf<T> where T: Clone, = (T, T)\"\n pub type Golf<T> where T: Clone = (T, T);"}]}