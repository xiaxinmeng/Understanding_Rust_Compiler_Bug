{"sha": "3d4d0cf8be8d833c26c95fb61f34a6eab93e916c", "node_id": "C_kwDOAAsO6NoAKDNkNGQwY2Y4YmU4ZDgzM2MyNmM5NWZiNjFmMzRhNmVhYjkzZTkxNmM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-11T16:42:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-11T16:42:57Z"}, "message": "Auto merge of #7643 - xFrednet:7569-splits-for-slices, r=camsteffen\n\nNew lint `index_refutable_slice` to avoid slice indexing\n\nA new lint to check for slices that could be deconstructed to avoid indexing. This lint should hopefully prevent some panics in other projects and ICEs for us. See #7569 for an example\n\nThe implementation specifically checks for immutable bindings in `if let` statements to slices and arrays. Then it checks if these bindings are only used for value access using indices and that these indices are lower than the configured limit. I did my best to keep the implementation small, however the check was sadly quite complex. Now it's around 300 lines for the implementation and the rest are test.\n\n---\n\nOptional future improvements:\n* Check for these instances also in `match` statements\n* Check for mutable slice bindings that could also be destructed\n\n---\n\nchangelog: New lint [`index_refutable_slice`]\n\nI've already fixed a bunch of lint triggers in #7638 to make this PR smaller\n\nCloses: #7569", "tree": {"sha": "23b92a942c84d302c5006f3500e22a10fe0d96f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23b92a942c84d302c5006f3500e22a10fe0d96f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c", "html_url": "https://github.com/rust-lang/rust/commit/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bfe98d372fc4dacd12a7f0c06d44d72e2e96cd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bfe98d372fc4dacd12a7f0c06d44d72e2e96cd2", "html_url": "https://github.com/rust-lang/rust/commit/3bfe98d372fc4dacd12a7f0c06d44d72e2e96cd2"}, {"sha": "e444cbe5d67b92e1c0989ec4d36758c2b036014b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e444cbe5d67b92e1c0989ec4d36758c2b036014b", "html_url": "https://github.com/rust-lang/rust/commit/e444cbe5d67b92e1c0989ec4d36758c2b036014b"}], "stats": {"total": 734, "additions": 729, "deletions": 5}, "files": [{"sha": "1059f0ac7cd6597059dea21216bdc3788393d295", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=3d4d0cf8be8d833c26c95fb61f34a6eab93e916c", "patch": "@@ -2904,6 +2904,7 @@ Released 2018-09-13\n [`imprecise_flops`]: https://rust-lang.github.io/rust-clippy/master/index.html#imprecise_flops\n [`inconsistent_digit_grouping`]: https://rust-lang.github.io/rust-clippy/master/index.html#inconsistent_digit_grouping\n [`inconsistent_struct_constructor`]: https://rust-lang.github.io/rust-clippy/master/index.html#inconsistent_struct_constructor\n+[`index_refutable_slice`]: https://rust-lang.github.io/rust-clippy/master/index.html#index_refutable_slice\n [`indexing_slicing`]: https://rust-lang.github.io/rust-clippy/master/index.html#indexing_slicing\n [`ineffective_bit_mask`]: https://rust-lang.github.io/rust-clippy/master/index.html#ineffective_bit_mask\n [`inefficient_to_string`]: https://rust-lang.github.io/rust-clippy/master/index.html#inefficient_to_string"}, {"sha": "69f1c90beec5d31cc049262194ee7a0526874d02", "filename": "clippy_lints/src/index_refutable_slice.rs", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/clippy_lints%2Fsrc%2Findex_refutable_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/clippy_lints%2Fsrc%2Findex_refutable_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findex_refutable_slice.rs?ref=3d4d0cf8be8d833c26c95fb61f34a6eab93e916c", "patch": "@@ -0,0 +1,276 @@\n+use clippy_utils::consts::{constant, Constant};\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::higher::IfLet;\n+use clippy_utils::ty::is_copy;\n+use clippy_utils::{is_expn_of, is_lint_allowed, meets_msrv, msrvs, path_to_local};\n+use if_chain::if_chain;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::ty;\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{symbol::Ident, Span};\n+use std::convert::TryInto;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// The lint checks for slice bindings in patterns that are only used to\n+    /// access individual slice values.\n+    ///\n+    /// ### Why is this bad?\n+    /// Accessing slice values using indices can lead to panics. Using refutable\n+    /// patterns can avoid these. Binding to individual values also improves the\n+    /// readability as they can be named.\n+    ///\n+    /// ### Limitations\n+    /// This lint currently only checks for immutable access inside `if let`\n+    /// patterns.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let slice: Option<&[u32]> = Some(&[1, 2, 3]);\n+    ///\n+    /// if let Some(slice) = slice {\n+    ///     println!(\"{}\", slice[0]);\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let slice: Option<&[u32]> = Some(&[1, 2, 3]);\n+    ///\n+    /// if let Some(&[first, ..]) = slice {\n+    ///     println!(\"{}\", first);\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.58.0\"]\n+    pub INDEX_REFUTABLE_SLICE,\n+    nursery,\n+    \"avoid indexing on slices which could be destructed\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct IndexRefutableSlice {\n+    max_suggested_slice: u64,\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl IndexRefutableSlice {\n+    pub fn new(max_suggested_slice_pattern_length: u64, msrv: Option<RustcVersion>) -> Self {\n+        Self {\n+            max_suggested_slice: max_suggested_slice_pattern_length,\n+            msrv,\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(IndexRefutableSlice => [INDEX_REFUTABLE_SLICE]);\n+\n+impl LateLintPass<'_> for IndexRefutableSlice {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if_chain! {\n+            if !expr.span.from_expansion() || is_expn_of(expr.span, \"if_chain\").is_some();\n+            if let Some(IfLet {let_pat, if_then, ..}) = IfLet::hir(cx, expr);\n+            if !is_lint_allowed(cx, INDEX_REFUTABLE_SLICE, expr.hir_id);\n+            if meets_msrv(self.msrv.as_ref(), &msrvs::SLICE_PATTERNS);\n+\n+            let found_slices = find_slice_values(cx, let_pat);\n+            if !found_slices.is_empty();\n+            let filtered_slices = filter_lintable_slices(cx, found_slices, self.max_suggested_slice, if_then);\n+            if !filtered_slices.is_empty();\n+            then {\n+                for slice in filtered_slices.values() {\n+                    lint_slice(cx, slice);\n+                }\n+            }\n+        }\n+    }\n+\n+    extract_msrv_attr!(LateContext);\n+}\n+\n+fn find_slice_values(cx: &LateContext<'_>, pat: &hir::Pat<'_>) -> FxHashMap<hir::HirId, SliceLintInformation> {\n+    let mut removed_pat: FxHashSet<hir::HirId> = FxHashSet::default();\n+    let mut slices: FxHashMap<hir::HirId, SliceLintInformation> = FxHashMap::default();\n+    pat.walk_always(|pat| {\n+        if let hir::PatKind::Binding(binding, value_hir_id, ident, sub_pat) = pat.kind {\n+            // We'll just ignore mut and ref mut for simplicity sake right now\n+            if let hir::BindingAnnotation::Mutable | hir::BindingAnnotation::RefMut = binding {\n+                return;\n+            }\n+\n+            // This block catches bindings with sub patterns. It would be hard to build a correct suggestion\n+            // for them and it's likely that the user knows what they are doing in such a case.\n+            if removed_pat.contains(&value_hir_id) {\n+                return;\n+            }\n+            if sub_pat.is_some() {\n+                removed_pat.insert(value_hir_id);\n+                slices.remove(&value_hir_id);\n+                return;\n+            }\n+\n+            let bound_ty = cx.typeck_results().node_type(pat.hir_id);\n+            if let ty::Slice(inner_ty) | ty::Array(inner_ty, _) = bound_ty.peel_refs().kind() {\n+                // The values need to use the `ref` keyword if they can't be copied.\n+                // This will need to be adjusted if the lint want to support multable access in the future\n+                let src_is_ref = bound_ty.is_ref() && binding != hir::BindingAnnotation::Ref;\n+                let needs_ref = !(src_is_ref || is_copy(cx, inner_ty));\n+\n+                let slice_info = slices\n+                    .entry(value_hir_id)\n+                    .or_insert_with(|| SliceLintInformation::new(ident, needs_ref));\n+                slice_info.pattern_spans.push(pat.span);\n+            }\n+        }\n+    });\n+\n+    slices\n+}\n+\n+fn lint_slice(cx: &LateContext<'_>, slice: &SliceLintInformation) {\n+    let used_indices = slice\n+        .index_use\n+        .iter()\n+        .map(|(index, _)| *index)\n+        .collect::<FxHashSet<_>>();\n+\n+    let value_name = |index| format!(\"{}_{}\", slice.ident.name, index);\n+\n+    if let Some(max_index) = used_indices.iter().max() {\n+        let opt_ref = if slice.needs_ref { \"ref \" } else { \"\" };\n+        let pat_sugg_idents = (0..=*max_index)\n+            .map(|index| {\n+                if used_indices.contains(&index) {\n+                    format!(\"{}{}\", opt_ref, value_name(index))\n+                } else {\n+                    \"_\".to_string()\n+                }\n+            })\n+            .collect::<Vec<_>>();\n+        let pat_sugg = format!(\"[{}, ..]\", pat_sugg_idents.join(\", \"));\n+\n+        span_lint_and_then(\n+            cx,\n+            INDEX_REFUTABLE_SLICE,\n+            slice.ident.span,\n+            \"this binding can be a slice pattern to avoid indexing\",\n+            |diag| {\n+                diag.multipart_suggestion(\n+                    \"try using a slice pattern here\",\n+                    slice\n+                        .pattern_spans\n+                        .iter()\n+                        .map(|span| (*span, pat_sugg.clone()))\n+                        .collect(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+\n+                diag.multipart_suggestion(\n+                    \"and replace the index expressions here\",\n+                    slice\n+                        .index_use\n+                        .iter()\n+                        .map(|(index, span)| (*span, value_name(*index)))\n+                        .collect(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+\n+                // The lint message doesn't contain a warning about the removed index expression,\n+                // since `filter_lintable_slices` will only return slices where all access indices\n+                // are known at compile time. Therefore, they can be removed without side effects.\n+            },\n+        );\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct SliceLintInformation {\n+    ident: Ident,\n+    needs_ref: bool,\n+    pattern_spans: Vec<Span>,\n+    index_use: Vec<(u64, Span)>,\n+}\n+\n+impl SliceLintInformation {\n+    fn new(ident: Ident, needs_ref: bool) -> Self {\n+        Self {\n+            ident,\n+            needs_ref,\n+            pattern_spans: Vec::new(),\n+            index_use: Vec::new(),\n+        }\n+    }\n+}\n+\n+fn filter_lintable_slices<'a, 'tcx>(\n+    cx: &'a LateContext<'tcx>,\n+    slice_lint_info: FxHashMap<hir::HirId, SliceLintInformation>,\n+    max_suggested_slice: u64,\n+    scope: &'tcx hir::Expr<'tcx>,\n+) -> FxHashMap<hir::HirId, SliceLintInformation> {\n+    let mut visitor = SliceIndexLintingVisitor {\n+        cx,\n+        slice_lint_info,\n+        max_suggested_slice,\n+    };\n+\n+    intravisit::walk_expr(&mut visitor, scope);\n+\n+    visitor.slice_lint_info\n+}\n+\n+struct SliceIndexLintingVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    slice_lint_info: FxHashMap<hir::HirId, SliceLintInformation>,\n+    max_suggested_slice: u64,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for SliceIndexLintingVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n+        if let Some(local_id) = path_to_local(expr) {\n+            let Self {\n+                cx,\n+                ref mut slice_lint_info,\n+                max_suggested_slice,\n+            } = *self;\n+\n+            if_chain! {\n+                // Check if this is even a local we're interested in\n+                if let Some(use_info) = slice_lint_info.get_mut(&local_id);\n+\n+                let map = cx.tcx.hir();\n+\n+                // Checking for slice indexing\n+                let parent_id = map.get_parent_node(expr.hir_id);\n+                if let Some(hir::Node::Expr(parent_expr)) = map.find(parent_id);\n+                if let hir::ExprKind::Index(_, index_expr) = parent_expr.kind;\n+                if let Some((Constant::Int(index_value), _)) = constant(cx, cx.typeck_results(), index_expr);\n+                if let Ok(index_value) = index_value.try_into();\n+                if index_value < max_suggested_slice;\n+\n+                // Make sure that this slice index is read only\n+                let maybe_addrof_id = map.get_parent_node(parent_id);\n+                if let Some(hir::Node::Expr(maybe_addrof_expr)) = map.find(maybe_addrof_id);\n+                if let hir::ExprKind::AddrOf(_kind, hir::Mutability::Not, _inner_expr) = maybe_addrof_expr.kind;\n+                then {\n+                    use_info.index_use.push((index_value, map.span(parent_expr.hir_id)));\n+                    return;\n+                }\n+            }\n+\n+            // The slice was used for something other than indexing\n+            self.slice_lint_info.remove(&local_id);\n+        }\n+        intravisit::walk_expr(self, expr);\n+    }\n+}"}, {"sha": "6d1d45f890006992311aa5004a56f0175a99699f", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=3d4d0cf8be8d833c26c95fb61f34a6eab93e916c", "patch": "@@ -168,6 +168,7 @@ store.register_lints(&[\n     implicit_return::IMPLICIT_RETURN,\n     implicit_saturating_sub::IMPLICIT_SATURATING_SUB,\n     inconsistent_struct_constructor::INCONSISTENT_STRUCT_CONSTRUCTOR,\n+    index_refutable_slice::INDEX_REFUTABLE_SLICE,\n     indexing_slicing::INDEXING_SLICING,\n     indexing_slicing::OUT_OF_BOUNDS_INDEXING,\n     infinite_iter::INFINITE_ITER,"}, {"sha": "cc0eb71be695f48f538a78534c3614be8bc76c50", "filename": "clippy_lints/src/lib.register_nursery.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/clippy_lints%2Fsrc%2Flib.register_nursery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/clippy_lints%2Fsrc%2Flib.register_nursery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_nursery.rs?ref=3d4d0cf8be8d833c26c95fb61f34a6eab93e916c", "patch": "@@ -13,6 +13,7 @@ store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n     LintId::of(floating_point_arithmetic::IMPRECISE_FLOPS),\n     LintId::of(floating_point_arithmetic::SUBOPTIMAL_FLOPS),\n     LintId::of(future_not_send::FUTURE_NOT_SEND),\n+    LintId::of(index_refutable_slice::INDEX_REFUTABLE_SLICE),\n     LintId::of(let_if_seq::USELESS_LET_IF_SEQ),\n     LintId::of(missing_const_for_fn::MISSING_CONST_FOR_FN),\n     LintId::of(mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL),"}, {"sha": "2445a0aeed08a054a3d58494ea294ae7eabfb1f6", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=3d4d0cf8be8d833c26c95fb61f34a6eab93e916c", "patch": "@@ -238,6 +238,7 @@ mod implicit_hasher;\n mod implicit_return;\n mod implicit_saturating_sub;\n mod inconsistent_struct_constructor;\n+mod index_refutable_slice;\n mod indexing_slicing;\n mod infinite_iter;\n mod inherent_impl;\n@@ -580,6 +581,13 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n \n     store.register_late_pass(|| Box::new(size_of_in_element_count::SizeOfInElementCount));\n     store.register_late_pass(|| Box::new(same_name_method::SameNameMethod));\n+    let max_suggested_slice_pattern_length = conf.max_suggested_slice_pattern_length;\n+    store.register_late_pass(move || {\n+        Box::new(index_refutable_slice::IndexRefutableSlice::new(\n+            max_suggested_slice_pattern_length,\n+            msrv,\n+        ))\n+    });\n     store.register_late_pass(|| Box::new(map_clone::MapClone));\n     store.register_late_pass(|| Box::new(map_err_ignore::MapErrIgnore));\n     store.register_late_pass(|| Box::new(shadow::Shadow::default()));"}, {"sha": "71771aae44b2172c8dc0175474c2f8279d5ef77e", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=3d4d0cf8be8d833c26c95fb61f34a6eab93e916c", "patch": "@@ -231,8 +231,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n         } else {\n             // find `unwrap[_err]()` calls:\n             if_chain! {\n-                if let ExprKind::MethodCall(method_name, _, args, _) = expr.kind;\n-                if let Some(id) = path_to_local(&args[0]);\n+                if let ExprKind::MethodCall(method_name, _, [self_arg, ..], _) = expr.kind;\n+                if let Some(id) = path_to_local(self_arg);\n                 if [sym::unwrap, sym::expect, sym!(unwrap_err)].contains(&method_name.ident.name);\n                 let call_to_unwrap = [sym::unwrap, sym::expect].contains(&method_name.ident.name);\n                 if let Some(unwrappable) = self.unwrappables.iter()"}, {"sha": "1a170807980592fe1b04f3ab55f6de9d2b821d00", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=3d4d0cf8be8d833c26c95fb61f34a6eab93e916c", "patch": "@@ -148,7 +148,7 @@ define_Conf! {\n     ///\n     /// Suppress lints whenever the suggested change would cause breakage for other crates.\n     (avoid_breaking_exported_api: bool = true),\n-    /// Lint: MANUAL_SPLIT_ONCE, MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE, APPROX_CONSTANT, DEPRECATED_CFG_ATTR.\n+    /// Lint: MANUAL_SPLIT_ONCE, MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE, APPROX_CONSTANT, DEPRECATED_CFG_ATTR, INDEX_REFUTABLE_SLICE.\n     ///\n     /// The minimum rust version that the project supports\n     (msrv: Option<String> = None),\n@@ -296,6 +296,12 @@ define_Conf! {\n     ///\n     /// Whether to apply the raw pointer heuristic to determine if a type is `Send`.\n     (enable_raw_pointer_heuristic_for_send: bool = true),\n+    /// Lint: INDEX_REFUTABLE_SLICE.\n+    ///\n+    /// When Clippy suggests using a slice pattern, this is the maximum number of elements allowed in\n+    /// the slice pattern that is suggested. If more elements would be necessary, the lint is suppressed.\n+    /// For example, `[_, _, _, e, ..]` is a slice pattern with 4 elements.\n+    (max_suggested_slice_pattern_length: u64 = 3),\n }\n \n /// Search for the configuration file."}, {"sha": "66d07c9d0e8597c12e0c3350fca59a610ce7fb72", "filename": "clippy_utils/src/msrvs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/clippy_utils%2Fsrc%2Fmsrvs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/clippy_utils%2Fsrc%2Fmsrvs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmsrvs.rs?ref=3d4d0cf8be8d833c26c95fb61f34a6eab93e916c", "patch": "@@ -19,7 +19,7 @@ msrv_aliases! {\n     1,46,0 { CONST_IF_MATCH }\n     1,45,0 { STR_STRIP_PREFIX }\n     1,43,0 { LOG2_10, LOG10_2 }\n-    1,42,0 { MATCHES_MACRO }\n+    1,42,0 { MATCHES_MACRO, SLICE_PATTERNS }\n     1,41,0 { RE_REBALANCING_COHERENCE, RESULT_MAP_OR_ELSE }\n     1,40,0 { MEM_TAKE, NON_EXHAUSTIVE, OPTION_AS_DEREF }\n     1,38,0 { POINTER_CAST }"}, {"sha": "babab07ea9f6a1d4601404ddb6aaa0bb6f14ff88", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=3d4d0cf8be8d833c26c95fb61f34a6eab93e916c", "patch": "@@ -19,6 +19,7 @@ use rustc_trait_selection::traits::query::normalize::AtExt;\n \n use crate::{match_def_path, must_use_attr};\n \n+// Checks if the given type implements copy.\n pub fn is_copy<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     ty.is_copy_modulo_regions(cx.tcx.at(DUMMY_SP), cx.param_env)\n }"}, {"sha": "78c7e63b4107fa057231c924eef97f41627006e8", "filename": "tests/ui-toml/max_suggested_slice_pattern_length/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/tests%2Fui-toml%2Fmax_suggested_slice_pattern_length%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/tests%2Fui-toml%2Fmax_suggested_slice_pattern_length%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fmax_suggested_slice_pattern_length%2Fclippy.toml?ref=3d4d0cf8be8d833c26c95fb61f34a6eab93e916c", "patch": "@@ -0,0 +1 @@\n+max-suggested-slice-pattern-length = 8"}, {"sha": "21849a14fa95e3fde5a25bf83e744c4575ade43d", "filename": "tests/ui-toml/max_suggested_slice_pattern_length/index_refutable_slice.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/tests%2Fui-toml%2Fmax_suggested_slice_pattern_length%2Findex_refutable_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/tests%2Fui-toml%2Fmax_suggested_slice_pattern_length%2Findex_refutable_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fmax_suggested_slice_pattern_length%2Findex_refutable_slice.rs?ref=3d4d0cf8be8d833c26c95fb61f34a6eab93e916c", "patch": "@@ -0,0 +1,23 @@\n+#![deny(clippy::index_refutable_slice)]\n+\n+fn below_limit() {\n+    let slice: Option<&[u32]> = Some(&[1, 2, 3]);\n+    if let Some(slice) = slice {\n+        // This would usually not be linted but is included now due to the\n+        // index limit in the config file\n+        println!(\"{}\", slice[7]);\n+    }\n+}\n+\n+fn above_limit() {\n+    let slice: Option<&[u32]> = Some(&[1, 2, 3]);\n+    if let Some(slice) = slice {\n+        // This will not be linted as 8 is above the limit\n+        println!(\"{}\", slice[8]);\n+    }\n+}\n+\n+fn main() {\n+    below_limit();\n+    above_limit();\n+}"}, {"sha": "d319e65d06ce8ade969aebbd57d3e1232d85f537", "filename": "tests/ui-toml/max_suggested_slice_pattern_length/index_refutable_slice.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/tests%2Fui-toml%2Fmax_suggested_slice_pattern_length%2Findex_refutable_slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/tests%2Fui-toml%2Fmax_suggested_slice_pattern_length%2Findex_refutable_slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fmax_suggested_slice_pattern_length%2Findex_refutable_slice.stderr?ref=3d4d0cf8be8d833c26c95fb61f34a6eab93e916c", "patch": "@@ -0,0 +1,22 @@\n+error: this binding can be a slice pattern to avoid indexing\n+  --> $DIR/index_refutable_slice.rs:5:17\n+   |\n+LL |     if let Some(slice) = slice {\n+   |                 ^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/index_refutable_slice.rs:1:9\n+   |\n+LL | #![deny(clippy::index_refutable_slice)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using a slice pattern here\n+   |\n+LL |     if let Some([_, _, _, _, _, _, _, slice_7, ..]) = slice {\n+   |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+help: and replace the index expressions here\n+   |\n+LL |         println!(\"{}\", slice_7);\n+   |                        ~~~~~~~\n+\n+error: aborting due to previous error\n+"}, {"sha": "8e104926524e16fab2789cd6c7f0826f31aacc70", "filename": "tests/ui-toml/min_rust_version/min_rust_version.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/tests%2Fui-toml%2Fmin_rust_version%2Fmin_rust_version.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/tests%2Fui-toml%2Fmin_rust_version%2Fmin_rust_version.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fmin_rust_version%2Fmin_rust_version.rs?ref=3d4d0cf8be8d833c26c95fb61f34a6eab93e916c", "patch": "@@ -59,10 +59,20 @@ fn manual_strip_msrv() {\n     }\n }\n \n+fn check_index_refutable_slice() {\n+    // This shouldn't trigger `clippy::index_refutable_slice` as the suggestion\n+    // would only be valid from 1.42.0 onward\n+    let slice: Option<&[u32]> = Some(&[1]);\n+    if let Some(slice) = slice {\n+        println!(\"{}\", slice[0]);\n+    }\n+}\n+\n fn main() {\n     option_as_ref_deref();\n     match_like_matches();\n     match_same_arms();\n     match_same_arms2();\n     manual_strip_msrv();\n+    check_index_refutable_slice();\n }"}, {"sha": "00ddbd608a7c725dbee190ad54a3cc3c2c6dd88e", "filename": "tests/ui-toml/toml_unknown_key/conf_unknown_key.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr?ref=3d4d0cf8be8d833c26c95fb61f34a6eab93e916c", "patch": "@@ -1,4 +1,4 @@\n-error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `avoid-breaking-exported-api`, `msrv`, `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `pass-by-value-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-trait-bounds`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `disallowed-methods`, `disallowed-types`, `unreadable-literal-lint-fractions`, `upper-case-acronyms-aggressive`, `cargo-ignore-publish`, `standard-macro-braces`, `enforced-import-renames`, `allowed-scripts`, `enable-raw-pointer-heuristic-for-send`, `third-party` at line 5 column 1\n+error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `avoid-breaking-exported-api`, `msrv`, `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `pass-by-value-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-trait-bounds`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `disallowed-methods`, `disallowed-types`, `unreadable-literal-lint-fractions`, `upper-case-acronyms-aggressive`, `cargo-ignore-publish`, `standard-macro-braces`, `enforced-import-renames`, `allowed-scripts`, `enable-raw-pointer-heuristic-for-send`, `max-suggested-slice-pattern-length`, `third-party` at line 5 column 1\n \n error: aborting due to previous error\n "}, {"sha": "c2c0c520dc62d433ca2f8b70499d53e3e6246590", "filename": "tests/ui/index_refutable_slice/if_let_slice_binding.rs", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/tests%2Fui%2Findex_refutable_slice%2Fif_let_slice_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/tests%2Fui%2Findex_refutable_slice%2Fif_let_slice_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Findex_refutable_slice%2Fif_let_slice_binding.rs?ref=3d4d0cf8be8d833c26c95fb61f34a6eab93e916c", "patch": "@@ -0,0 +1,166 @@\n+#![deny(clippy::index_refutable_slice)]\n+\n+enum SomeEnum<T> {\n+    One(T),\n+    Two(T),\n+    Three(T),\n+    Four(T),\n+}\n+\n+fn lintable_examples() {\n+    // Try with reference\n+    let slice: Option<&[u32]> = Some(&[1, 2, 3]);\n+    if let Some(slice) = slice {\n+        println!(\"{}\", slice[0]);\n+    }\n+\n+    // Try with copy\n+    let slice: Option<[u32; 3]> = Some([1, 2, 3]);\n+    if let Some(slice) = slice {\n+        println!(\"{}\", slice[0]);\n+    }\n+\n+    // Try with long slice and small indices\n+    let slice: Option<[u32; 9]> = Some([1, 2, 3, 4, 5, 6, 7, 8, 9]);\n+    if let Some(slice) = slice {\n+        println!(\"{}\", slice[2]);\n+        println!(\"{}\", slice[0]);\n+    }\n+\n+    // Multiple bindings\n+    let slice_wrapped: SomeEnum<[u32; 3]> = SomeEnum::One([5, 6, 7]);\n+    if let SomeEnum::One(slice) | SomeEnum::Three(slice) = slice_wrapped {\n+        println!(\"{}\", slice[0]);\n+    }\n+\n+    // Two lintable slices in one if let\n+    let a_wrapped: SomeEnum<[u32; 3]> = SomeEnum::One([9, 5, 1]);\n+    let b_wrapped: Option<[u32; 2]> = Some([4, 6]);\n+    if let (SomeEnum::Three(a), Some(b)) = (a_wrapped, b_wrapped) {\n+        println!(\"{} -> {}\", a[2], b[1]);\n+    }\n+\n+    // This requires the slice values to be borrowed as the slice values can only be\n+    // borrowed and `String` doesn't implement copy\n+    let slice: Option<[String; 2]> = Some([String::from(\"1\"), String::from(\"2\")]);\n+    if let Some(ref slice) = slice {\n+        println!(\"{:?}\", slice[1]);\n+    }\n+    println!(\"{:?}\", slice);\n+\n+    // This should not suggest using the `ref` keyword as the scrutinee is already\n+    // a reference\n+    let slice: Option<[String; 2]> = Some([String::from(\"1\"), String::from(\"2\")]);\n+    if let Some(slice) = &slice {\n+        println!(\"{:?}\", slice[0]);\n+    }\n+    println!(\"{:?}\", slice);\n+}\n+\n+fn slice_index_above_limit() {\n+    let slice: Option<&[u32]> = Some(&[1, 2, 3]);\n+\n+    if let Some(slice) = slice {\n+        // Would cause a panic, IDK\n+        println!(\"{}\", slice[7]);\n+    }\n+}\n+\n+fn slice_is_used() {\n+    let slice: Option<&[u32]> = Some(&[1, 2, 3]);\n+    if let Some(slice) = slice {\n+        println!(\"{:?}\", slice.len());\n+    }\n+\n+    let slice: Option<&[u32]> = Some(&[1, 2, 3]);\n+    if let Some(slice) = slice {\n+        println!(\"{:?}\", slice.to_vec());\n+    }\n+\n+    let opt: Option<[String; 2]> = Some([String::from(\"Hello\"), String::from(\"world\")]);\n+    if let Some(slice) = opt {\n+        if !slice.is_empty() {\n+            println!(\"first: {}\", slice[0]);\n+        }\n+    }\n+}\n+\n+/// The slice is used by an external function and should therefore not be linted\n+fn check_slice_as_arg() {\n+    fn is_interesting<T>(slice: &[T; 2]) -> bool {\n+        !slice.is_empty()\n+    }\n+\n+    let slice_wrapped: Option<[String; 2]> = Some([String::from(\"Hello\"), String::from(\"world\")]);\n+    if let Some(slice) = &slice_wrapped {\n+        if is_interesting(slice) {\n+            println!(\"This is interesting {}\", slice[0]);\n+        }\n+    }\n+    println!(\"{:?}\", slice_wrapped);\n+}\n+\n+fn check_slice_in_struct() {\n+    #[derive(Debug)]\n+    struct Wrapper<'a> {\n+        inner: Option<&'a [String]>,\n+        is_awesome: bool,\n+    }\n+\n+    impl<'a> Wrapper<'a> {\n+        fn is_super_awesome(&self) -> bool {\n+            self.is_awesome\n+        }\n+    }\n+\n+    let inner = &[String::from(\"New\"), String::from(\"World\")];\n+    let wrap = Wrapper {\n+        inner: Some(inner),\n+        is_awesome: true,\n+    };\n+\n+    // Test 1: Field access\n+    if let Some(slice) = wrap.inner {\n+        if wrap.is_awesome {\n+            println!(\"This is awesome! {}\", slice[0]);\n+        }\n+    }\n+\n+    // Test 2: function access\n+    if let Some(slice) = wrap.inner {\n+        if wrap.is_super_awesome() {\n+            println!(\"This is super awesome! {}\", slice[0]);\n+        }\n+    }\n+    println!(\"Complete wrap: {:?}\", wrap);\n+}\n+\n+/// This would be a nice additional feature to have in the future, but adding it\n+/// now would make the PR too large. This is therefore only a test that we don't\n+/// lint cases we can't make a reasonable suggestion for\n+fn mutable_slice_index() {\n+    // Mut access\n+    let mut slice: Option<[String; 1]> = Some([String::from(\"Penguin\")]);\n+    if let Some(ref mut slice) = slice {\n+        slice[0] = String::from(\"Mr. Penguin\");\n+    }\n+    println!(\"Use after modification: {:?}\", slice);\n+\n+    // Mut access on reference\n+    let mut slice: Option<[String; 1]> = Some([String::from(\"Cat\")]);\n+    if let Some(slice) = &mut slice {\n+        slice[0] = String::from(\"Lord Meow Meow\");\n+    }\n+    println!(\"Use after modification: {:?}\", slice);\n+}\n+\n+/// The lint will ignore bindings with sub patterns as it would be hard\n+/// to build correct suggestions for these instances :)\n+fn binding_with_sub_pattern() {\n+    let slice: Option<&[u32]> = Some(&[1, 2, 3]);\n+    if let Some(slice @ [_, _, _]) = slice {\n+        println!(\"{:?}\", slice[2]);\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "a607df9b87660f71665f35f3d206df1f3e0b8841", "filename": "tests/ui/index_refutable_slice/if_let_slice_binding.stderr", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/tests%2Fui%2Findex_refutable_slice%2Fif_let_slice_binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/tests%2Fui%2Findex_refutable_slice%2Fif_let_slice_binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Findex_refutable_slice%2Fif_let_slice_binding.stderr?ref=3d4d0cf8be8d833c26c95fb61f34a6eab93e916c", "patch": "@@ -0,0 +1,158 @@\n+error: this binding can be a slice pattern to avoid indexing\n+  --> $DIR/if_let_slice_binding.rs:13:17\n+   |\n+LL |     if let Some(slice) = slice {\n+   |                 ^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/if_let_slice_binding.rs:1:9\n+   |\n+LL | #![deny(clippy::index_refutable_slice)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using a slice pattern here\n+   |\n+LL |     if let Some([slice_0, ..]) = slice {\n+   |                 ~~~~~~~~~~~~~\n+help: and replace the index expressions here\n+   |\n+LL |         println!(\"{}\", slice_0);\n+   |                        ~~~~~~~\n+\n+error: this binding can be a slice pattern to avoid indexing\n+  --> $DIR/if_let_slice_binding.rs:19:17\n+   |\n+LL |     if let Some(slice) = slice {\n+   |                 ^^^^^\n+   |\n+help: try using a slice pattern here\n+   |\n+LL |     if let Some([slice_0, ..]) = slice {\n+   |                 ~~~~~~~~~~~~~\n+help: and replace the index expressions here\n+   |\n+LL |         println!(\"{}\", slice_0);\n+   |                        ~~~~~~~\n+\n+error: this binding can be a slice pattern to avoid indexing\n+  --> $DIR/if_let_slice_binding.rs:25:17\n+   |\n+LL |     if let Some(slice) = slice {\n+   |                 ^^^^^\n+   |\n+help: try using a slice pattern here\n+   |\n+LL |     if let Some([slice_0, _, slice_2, ..]) = slice {\n+   |                 ~~~~~~~~~~~~~~~~~~~~~~~~~\n+help: and replace the index expressions here\n+   |\n+LL ~         println!(\"{}\", slice_2);\n+LL ~         println!(\"{}\", slice_0);\n+   |\n+\n+error: this binding can be a slice pattern to avoid indexing\n+  --> $DIR/if_let_slice_binding.rs:32:26\n+   |\n+LL |     if let SomeEnum::One(slice) | SomeEnum::Three(slice) = slice_wrapped {\n+   |                          ^^^^^\n+   |\n+help: try using a slice pattern here\n+   |\n+LL |     if let SomeEnum::One([slice_0, ..]) | SomeEnum::Three([slice_0, ..]) = slice_wrapped {\n+   |                          ~~~~~~~~~~~~~                    ~~~~~~~~~~~~~\n+help: and replace the index expressions here\n+   |\n+LL |         println!(\"{}\", slice_0);\n+   |                        ~~~~~~~\n+\n+error: this binding can be a slice pattern to avoid indexing\n+  --> $DIR/if_let_slice_binding.rs:39:29\n+   |\n+LL |     if let (SomeEnum::Three(a), Some(b)) = (a_wrapped, b_wrapped) {\n+   |                             ^\n+   |\n+help: try using a slice pattern here\n+   |\n+LL |     if let (SomeEnum::Three([_, _, a_2, ..]), Some(b)) = (a_wrapped, b_wrapped) {\n+   |                             ~~~~~~~~~~~~~~~\n+help: and replace the index expressions here\n+   |\n+LL |         println!(\"{} -> {}\", a_2, b[1]);\n+   |                              ~~~\n+\n+error: this binding can be a slice pattern to avoid indexing\n+  --> $DIR/if_let_slice_binding.rs:39:38\n+   |\n+LL |     if let (SomeEnum::Three(a), Some(b)) = (a_wrapped, b_wrapped) {\n+   |                                      ^\n+   |\n+help: try using a slice pattern here\n+   |\n+LL |     if let (SomeEnum::Three(a), Some([_, b_1, ..])) = (a_wrapped, b_wrapped) {\n+   |                                      ~~~~~~~~~~~~\n+help: and replace the index expressions here\n+   |\n+LL |         println!(\"{} -> {}\", a[2], b_1);\n+   |                                    ~~~\n+\n+error: this binding can be a slice pattern to avoid indexing\n+  --> $DIR/if_let_slice_binding.rs:46:21\n+   |\n+LL |     if let Some(ref slice) = slice {\n+   |                     ^^^^^\n+   |\n+help: try using a slice pattern here\n+   |\n+LL |     if let Some([_, ref slice_1, ..]) = slice {\n+   |                 ~~~~~~~~~~~~~~~~~~~~\n+help: and replace the index expressions here\n+   |\n+LL |         println!(\"{:?}\", slice_1);\n+   |                          ~~~~~~~\n+\n+error: this binding can be a slice pattern to avoid indexing\n+  --> $DIR/if_let_slice_binding.rs:54:17\n+   |\n+LL |     if let Some(slice) = &slice {\n+   |                 ^^^^^\n+   |\n+help: try using a slice pattern here\n+   |\n+LL |     if let Some([slice_0, ..]) = &slice {\n+   |                 ~~~~~~~~~~~~~\n+help: and replace the index expressions here\n+   |\n+LL |         println!(\"{:?}\", slice_0);\n+   |                          ~~~~~~~\n+\n+error: this binding can be a slice pattern to avoid indexing\n+  --> $DIR/if_let_slice_binding.rs:123:17\n+   |\n+LL |     if let Some(slice) = wrap.inner {\n+   |                 ^^^^^\n+   |\n+help: try using a slice pattern here\n+   |\n+LL |     if let Some([slice_0, ..]) = wrap.inner {\n+   |                 ~~~~~~~~~~~~~\n+help: and replace the index expressions here\n+   |\n+LL |             println!(\"This is awesome! {}\", slice_0);\n+   |                                             ~~~~~~~\n+\n+error: this binding can be a slice pattern to avoid indexing\n+  --> $DIR/if_let_slice_binding.rs:130:17\n+   |\n+LL |     if let Some(slice) = wrap.inner {\n+   |                 ^^^^^\n+   |\n+help: try using a slice pattern here\n+   |\n+LL |     if let Some([slice_0, ..]) = wrap.inner {\n+   |                 ~~~~~~~~~~~~~\n+help: and replace the index expressions here\n+   |\n+LL |             println!(\"This is super awesome! {}\", slice_0);\n+   |                                                   ~~~~~~~\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "406e82083f88f2e4058ab23e6c66eb233b9614a1", "filename": "tests/ui/index_refutable_slice/slice_indexing_in_macro.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/tests%2Fui%2Findex_refutable_slice%2Fslice_indexing_in_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/tests%2Fui%2Findex_refutable_slice%2Fslice_indexing_in_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Findex_refutable_slice%2Fslice_indexing_in_macro.rs?ref=3d4d0cf8be8d833c26c95fb61f34a6eab93e916c", "patch": "@@ -0,0 +1,28 @@\n+#![deny(clippy::index_refutable_slice)]\n+\n+extern crate if_chain;\n+use if_chain::if_chain;\n+\n+macro_rules! if_let_slice_macro {\n+    () => {\n+        // This would normally be linted\n+        let slice: Option<&[u32]> = Some(&[1, 2, 3]);\n+        if let Some(slice) = slice {\n+            println!(\"{}\", slice[0]);\n+        }\n+    };\n+}\n+\n+fn main() {\n+    // Don't lint this\n+    if_let_slice_macro!();\n+\n+    // Do lint this\n+    if_chain! {\n+        let slice: Option<&[u32]> = Some(&[1, 2, 3]);\n+        if let Some(slice) = slice;\n+        then {\n+            println!(\"{}\", slice[0]);\n+        }\n+    }\n+}"}, {"sha": "11b19428b4fdc3552e809264c6a3f0d2b83ca9db", "filename": "tests/ui/index_refutable_slice/slice_indexing_in_macro.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/tests%2Fui%2Findex_refutable_slice%2Fslice_indexing_in_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d4d0cf8be8d833c26c95fb61f34a6eab93e916c/tests%2Fui%2Findex_refutable_slice%2Fslice_indexing_in_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Findex_refutable_slice%2Fslice_indexing_in_macro.stderr?ref=3d4d0cf8be8d833c26c95fb61f34a6eab93e916c", "patch": "@@ -0,0 +1,22 @@\n+error: this binding can be a slice pattern to avoid indexing\n+  --> $DIR/slice_indexing_in_macro.rs:23:21\n+   |\n+LL |         if let Some(slice) = slice;\n+   |                     ^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/slice_indexing_in_macro.rs:1:9\n+   |\n+LL | #![deny(clippy::index_refutable_slice)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using a slice pattern here\n+   |\n+LL |         if let Some([slice_0, ..]) = slice;\n+   |                     ~~~~~~~~~~~~~\n+help: and replace the index expressions here\n+   |\n+LL |             println!(\"{}\", slice_0);\n+   |                            ~~~~~~~\n+\n+error: aborting due to previous error\n+"}]}