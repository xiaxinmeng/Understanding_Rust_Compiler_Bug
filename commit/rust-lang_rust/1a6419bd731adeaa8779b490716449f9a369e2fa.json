{"sha": "1a6419bd731adeaa8779b490716449f9a369e2fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhNjQxOWJkNzMxYWRlYWE4Nzc5YjQ5MDcxNjQ0OWY5YTM2OWUyZmE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-14T21:25:43Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-14T22:39:35Z"}, "message": "rustc: Move metadata::encoder over to interior vectors", "tree": {"sha": "edd1d08a6fa79e0a1a492efee4e93c0f2d46c701", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/edd1d08a6fa79e0a1a492efee4e93c0f2d46c701"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a6419bd731adeaa8779b490716449f9a369e2fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a6419bd731adeaa8779b490716449f9a369e2fa", "html_url": "https://github.com/rust-lang/rust/commit/1a6419bd731adeaa8779b490716449f9a369e2fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a6419bd731adeaa8779b490716449f9a369e2fa/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3dee955144a722da50e17dde62cb36cbcccf73f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3dee955144a722da50e17dde62cb36cbcccf73f", "html_url": "https://github.com/rust-lang/rust/commit/b3dee955144a722da50e17dde62cb36cbcccf73f"}], "stats": {"total": 108, "additions": 56, "deletions": 52}, "files": [{"sha": "e0c9d544742d708314cba95909fdd06b99cb7315", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 56, "deletions": 52, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/1a6419bd731adeaa8779b490716449f9a369e2fa/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a6419bd731adeaa8779b490716449f9a369e2fa/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=1a6419bd731adeaa8779b490716449f9a369e2fa", "patch": "@@ -2,7 +2,6 @@\n \n import std::ivec;\n import std::str;\n-import std::vec;\n import std::uint;\n import std::ioivec;\n import std::option;\n@@ -39,8 +38,8 @@ fn encode_def_id(&ebmlivec::writer ebml_w, &def_id id) {\n }\n \n fn encode_tag_variant_paths(&ebmlivec::writer ebml_w, &variant[] variants,\n-                            &vec[str] path,\n-                            &mutable vec[tup(str, uint)] index) {\n+                            &str[] path,\n+                            &mutable (tup(str, uint))[] index) {\n     for (variant variant in variants) {\n         add_to_index(ebml_w, path, index, variant.node.name);\n         ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n@@ -50,15 +49,15 @@ fn encode_tag_variant_paths(&ebmlivec::writer ebml_w, &variant[] variants,\n     }\n }\n \n-fn add_to_index(&ebmlivec::writer ebml_w, &vec[str] path,\n-                &mutable vec[tup(str, uint)] index, &str name) {\n-    auto full_path = path + [name];\n-    index += [tup(str::connect(full_path, \"::\"), ebml_w.writer.tell())];\n+fn add_to_index(&ebmlivec::writer ebml_w, &str[] path,\n+                &mutable (tup(str, uint))[] index, &str name) {\n+    auto full_path = path + ~[name];\n+    index += ~[tup(str::connect_ivec(full_path, \"::\"), ebml_w.writer.tell())];\n }\n \n fn encode_native_module_item_paths(&ebmlivec::writer ebml_w,\n-                                   &native_mod nmod, &vec[str] path,\n-                                   &mutable vec[tup(str, uint)] index) {\n+                                   &native_mod nmod, &str[] path,\n+                                   &mutable (tup(str, uint))[] index) {\n     for (@native_item nitem in nmod.items) {\n         add_to_index(ebml_w, path, index, nitem.ident);\n         ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n@@ -69,8 +68,8 @@ fn encode_native_module_item_paths(&ebmlivec::writer ebml_w,\n }\n \n fn encode_module_item_paths(&ebmlivec::writer ebml_w, &_mod module,\n-                            &vec[str] path,\n-                            &mutable vec[tup(str, uint)] index) {\n+                            &str[] path,\n+                            &mutable (tup(str, uint))[] index) {\n     for (@item it in module.items) {\n         if (!is_exported(it.ident, module)) { cont; }\n         alt (it.node) {\n@@ -93,7 +92,7 @@ fn encode_module_item_paths(&ebmlivec::writer ebml_w, &_mod module,\n                 ebmlivec::start_tag(ebml_w, tag_paths_data_mod);\n                 encode_name(ebml_w, it.ident);\n                 encode_def_id(ebml_w, local_def(it.id));\n-                encode_module_item_paths(ebml_w, _mod, path + [it.ident],\n+                encode_module_item_paths(ebml_w, _mod, path + ~[it.ident],\n                                          index);\n                 ebmlivec::end_tag(ebml_w);\n             }\n@@ -103,7 +102,7 @@ fn encode_module_item_paths(&ebmlivec::writer ebml_w, &_mod module,\n                 encode_name(ebml_w, it.ident);\n                 encode_def_id(ebml_w, local_def(it.id));\n                 encode_native_module_item_paths(ebml_w, nmod,\n-                                                path + [it.ident], index);\n+                                                path + ~[it.ident], index);\n                 ebmlivec::end_tag(ebml_w);\n             }\n             case (item_ty(_, ?tps)) {\n@@ -149,10 +148,10 @@ fn encode_module_item_paths(&ebmlivec::writer ebml_w, &_mod module,\n     }\n }\n \n-fn encode_item_paths(&ebmlivec::writer ebml_w, &@crate crate) ->\n-   vec[tup(str, uint)] {\n-    let vec[tup(str, uint)] index = [];\n-    let vec[str] path = [];\n+fn encode_item_paths(&ebmlivec::writer ebml_w, &@crate crate)\n+        -> (tup(str, uint))[] {\n+    let (tup(str, uint))[] index = ~[];\n+    let str[] path = ~[];\n     ebmlivec::start_tag(ebml_w, tag_paths);\n     encode_module_item_paths(ebml_w, crate.node.module, path, index);\n     ebmlivec::end_tag(ebml_w);\n@@ -213,10 +212,10 @@ fn encode_tag_id(&ebmlivec::writer ebml_w, &def_id id) {\n \n fn encode_tag_variant_info(&@encode_ctxt ecx, &ebmlivec::writer ebml_w,\n                            node_id id, &variant[] variants,\n-                           &mutable vec[tup(int, uint)] index,\n+                           &mutable (tup(int, uint))[] index,\n                            &ty_param[] ty_params) {\n     for (variant variant in variants) {\n-        index += [tup(variant.node.id, ebml_w.writer.tell())];\n+        index += ~[tup(variant.node.id, ebml_w.writer.tell())];\n         ebmlivec::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(variant.node.id));\n         encode_kind(ebml_w, 'v' as u8);\n@@ -233,7 +232,7 @@ fn encode_tag_variant_info(&@encode_ctxt ecx, &ebmlivec::writer ebml_w,\n }\n \n fn encode_info_for_item(@encode_ctxt ecx, &ebmlivec::writer ebml_w,\n-                        @item item, &mutable vec[tup(int, uint)] index) {\n+                        @item item, &mutable (tup(int, uint))[] index) {\n     alt (item.node) {\n         case (item_const(_, _)) {\n             ebmlivec::start_tag(ebml_w, tag_items_data_item);\n@@ -302,7 +301,7 @@ fn encode_info_for_item(@encode_ctxt ecx, &ebmlivec::writer ebml_w,\n             encode_symbol(ecx, ebml_w, item.id);\n             ebmlivec::end_tag(ebml_w);\n \n-            index += [tup(ctor_id, ebml_w.writer.tell())];\n+            index += ~[tup(ctor_id, ebml_w.writer.tell())];\n             ebmlivec::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(ctor_id));\n             encode_kind(ebml_w, 'f' as u8);\n@@ -321,7 +320,7 @@ fn encode_info_for_item(@encode_ctxt ecx, &ebmlivec::writer ebml_w,\n             encode_type(ecx, ebml_w, ty::ty_fn_ret(ecx.ccx.tcx, fn_ty));\n             ebmlivec::end_tag(ebml_w);\n \n-            index += [tup(ctor_id, ebml_w.writer.tell())];\n+            index += ~[tup(ctor_id, ebml_w.writer.tell())];\n             ebmlivec::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(ctor_id));\n             encode_kind(ebml_w, 'f' as u8);\n@@ -355,19 +354,19 @@ fn encode_info_for_native_item(&@encode_ctxt ecx, &ebmlivec::writer ebml_w,\n     ebmlivec::end_tag(ebml_w);\n }\n \n-fn encode_info_for_items(&@encode_ctxt ecx, &ebmlivec::writer ebml_w) ->\n-   vec[tup(int, uint)] {\n-    let vec[tup(int, uint)] index = [];\n+fn encode_info_for_items(&@encode_ctxt ecx, &ebmlivec::writer ebml_w)\n+        -> (tup(int, uint))[] {\n+    let (tup(int, uint))[] index = ~[];\n     ebmlivec::start_tag(ebml_w, tag_items_data);\n     for each (@tup(node_id, middle::ast_map::ast_node) kvp in\n               ecx.ccx.ast_map.items()) {\n         alt (kvp._1) {\n             case (middle::ast_map::node_item(?i)) {\n-                index += [tup(kvp._0, ebml_w.writer.tell())];\n+                index += ~[tup(kvp._0, ebml_w.writer.tell())];\n                 encode_info_for_item(ecx, ebml_w, i, index);\n             }\n             case (middle::ast_map::node_native_item(?i)) {\n-                index += [tup(kvp._0, ebml_w.writer.tell())];\n+                index += ~[tup(kvp._0, ebml_w.writer.tell())];\n                 encode_info_for_native_item(ecx, ebml_w, i);\n             }\n             case (_) {}\n@@ -380,27 +379,32 @@ fn encode_info_for_items(&@encode_ctxt ecx, &ebmlivec::writer ebml_w) ->\n \n // Path and definition ID indexing\n \n-fn create_index[T](&vec[tup(T, uint)] index, fn(&T) -> uint  hash_fn) ->\n-   vec[vec[tup(T, uint)]] {\n-    let vec[mutable vec[tup(T, uint)]] buckets = vec::empty_mut();\n-    for each (uint i in uint::range(0u, 256u)) { buckets += [mutable []]; }\n+fn create_index[T](&(tup(T, uint))[] index, fn(&T) -> uint  hash_fn)\n+        -> (@(tup(T, uint))[])[] {\n+    let (@mutable (tup(T,uint))[])[] buckets = ~[];\n+    for each (uint i in uint::range(0u, 256u)) { buckets += ~[@mutable ~[]]; }\n     for (tup(T, uint) elt in index) {\n         auto h = hash_fn(elt._0);\n-        buckets.(h % 256u) += [elt];\n+        *(buckets.(h % 256u)) += ~[elt];\n     }\n-    ret vec::freeze(buckets);\n+\n+    auto buckets_frozen = ~[];\n+    for (@mutable (tup(T, uint))[] bucket in buckets) {\n+        buckets_frozen += ~[@*bucket];\n+    }\n+    ret buckets_frozen;\n }\n \n-fn encode_index[T](&ebmlivec::writer ebml_w, &vec[vec[tup(T, uint)]] buckets,\n+fn encode_index[T](&ebmlivec::writer ebml_w, &(@(tup(T, uint))[])[] buckets,\n                    fn(&ioivec::writer, &T)  write_fn) {\n     auto writer = ioivec::new_writer_(ebml_w.writer);\n     ebmlivec::start_tag(ebml_w, tag_index);\n-    let vec[uint] bucket_locs = [];\n+    let uint[] bucket_locs = ~[];\n     ebmlivec::start_tag(ebml_w, tag_index_buckets);\n-    for (vec[tup(T, uint)] bucket in buckets) {\n-        bucket_locs += [ebml_w.writer.tell()];\n+    for (@(tup(T, uint))[] bucket in buckets) {\n+        bucket_locs += ~[ebml_w.writer.tell()];\n         ebmlivec::start_tag(ebml_w, tag_index_buckets_bucket);\n-        for (tup(T, uint) elt in bucket) {\n+        for (tup(T, uint) elt in *bucket) {\n             ebmlivec::start_tag(ebml_w, tag_index_buckets_bucket_elt);\n             writer.write_be_uint(elt._1, 4u);\n             write_fn(writer, elt._0);\n@@ -458,7 +462,7 @@ fn encode_meta_item(&ebmlivec::writer ebml_w, &meta_item mi) {\n     }\n }\n \n-fn encode_attributes(&ebmlivec::writer ebml_w, &vec[attribute] attrs) {\n+fn encode_attributes(&ebmlivec::writer ebml_w, &attribute[] attrs) {\n     ebmlivec::start_tag(ebml_w, tag_attributes);\n     for (attribute attr in attrs) {\n         ebmlivec::start_tag(ebml_w, tag_attribute);\n@@ -473,7 +477,7 @@ fn encode_attributes(&ebmlivec::writer ebml_w, &vec[attribute] attrs) {\n // 'name' and 'vers' items, so if the user didn't provide them we will throw\n // them in anyway with default values.\n fn synthesize_crate_attrs(&@encode_ctxt ecx,\n-                          &@crate crate) -> vec[attribute] {\n+                          &@crate crate) -> attribute[] {\n \n     fn synthesize_link_attr(&@encode_ctxt ecx, &(@meta_item)[] items)\n             -> attribute {\n@@ -497,44 +501,44 @@ fn synthesize_crate_attrs(&@encode_ctxt ecx,\n         ret attr::mk_attr(link_item);\n     }\n \n-    let vec[attribute] attrs = [];\n+    let attribute[] attrs = ~[];\n     auto found_link_attr = false;\n     for (attribute attr in crate.node.attrs) {\n         attrs += if (attr::get_attr_name(attr) != \"link\") {\n-            [attr]\n+            ~[attr]\n         } else {\n             alt (attr.node.value.node) {\n                 case (meta_list(?n, ?l)) {\n                     found_link_attr = true;\n-                    [synthesize_link_attr(ecx, l)]\n+                    ~[synthesize_link_attr(ecx, l)]\n                 }\n-                case (_) { [attr] }\n+                case (_) { ~[attr] }\n             }\n         }\n     }\n \n     if (!found_link_attr) {\n-        attrs += [synthesize_link_attr(ecx, ~[])];\n+        attrs += ~[synthesize_link_attr(ecx, ~[])];\n     }\n \n     ret attrs;\n }\n \n fn encode_crate_deps(&ebmlivec::writer ebml_w, &cstore::cstore cstore) {\n \n-    fn get_ordered_names(&cstore::cstore cstore) -> vec[str] {\n+    fn get_ordered_names(&cstore::cstore cstore) -> str[] {\n         type hashkv = @tup(crate_num, cstore::crate_metadata);\n         type numname = tup(crate_num, str);\n \n         // Pull the cnums and names out of cstore\n-        let vec[mutable numname] pairs = [mutable];\n+        let numname[mutable] pairs = ~[mutable];\n         for each (hashkv hashkv in cstore::iter_crate_data(cstore)) {\n-            pairs += [mutable tup(hashkv._0, hashkv._1.name)];\n+            pairs += ~[mutable tup(hashkv._0, hashkv._1.name)];\n         }\n \n         // Sort by cnum\n         fn lteq(&numname kv1, &numname kv2) -> bool { kv1._0 <= kv2._0 }\n-        std::sort::quick_sort(lteq, pairs);\n+        std::sort::ivector::quick_sort(lteq, pairs);\n \n         // Sanity-check the crate numbers\n         auto expected_cnum = 1;\n@@ -545,9 +549,9 @@ fn encode_crate_deps(&ebmlivec::writer ebml_w, &cstore::cstore cstore) {\n \n         // Return just the names\n         fn name(&numname kv) -> str { kv._1 }\n-        // mutable -> immutable hack for vec::map\n-        auto immpairs = vec::slice(pairs, 0u, vec::len(pairs));\n-        ret vec::map(name, immpairs);\n+        // mutable -> immutable hack for ivec::map\n+        auto immpairs = ivec::slice(pairs, 0u, ivec::len(pairs));\n+        ret ivec::map(name, immpairs);\n     }\n \n     // We're just going to write a list of crate names, with the assumption"}]}