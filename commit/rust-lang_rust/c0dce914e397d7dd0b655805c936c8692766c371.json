{"sha": "c0dce914e397d7dd0b655805c936c8692766c371", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwZGNlOTE0ZTM5N2Q3ZGQwYjY1NTgwNWM5MzZjODY5Mjc2NmMzNzE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-06-22T17:08:59Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-06-22T17:08:59Z"}, "message": "Mostly fix it", "tree": {"sha": "24fe58013ae26854d279a059398c41d4e577f9ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24fe58013ae26854d279a059398c41d4e577f9ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0dce914e397d7dd0b655805c936c8692766c371", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0dce914e397d7dd0b655805c936c8692766c371", "html_url": "https://github.com/rust-lang/rust/commit/c0dce914e397d7dd0b655805c936c8692766c371", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0dce914e397d7dd0b655805c936c8692766c371/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08d17c9ece01a9a6bd7915869dbd27f7bcef73fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/08d17c9ece01a9a6bd7915869dbd27f7bcef73fc", "html_url": "https://github.com/rust-lang/rust/commit/08d17c9ece01a9a6bd7915869dbd27f7bcef73fc"}], "stats": {"total": 219, "additions": 130, "deletions": 89}, "files": [{"sha": "7d18ad985724e30ca9b47c4b0371f757aeec87eb", "filename": "src/base.rs", "status": "modified", "additions": 130, "deletions": 89, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/c0dce914e397d7dd0b655805c936c8692766c371/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0dce914e397d7dd0b655805c936c8692766c371/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=c0dce914e397d7dd0b655805c936c8692766c371", "patch": "@@ -2,7 +2,7 @@ use syntax::ast::{IntTy, UintTy};\n use rustc_mir::monomorphize::MonoItem;\n \n use cretonne::prelude::*;\n-//use cretonne::codegen::Context;\n+use cretonne::codegen::Context;\n use cretonne::codegen::ir::{\n     ExternalName,\n     FuncRef,\n@@ -33,6 +33,28 @@ impl EntityRef for Variable {\n     }\n }\n \n+// FIXME(cretonne) fix load.i8\n+fn load_workaround(fx: &mut FunctionCx, ty: Type, addr: Value, offset: i32) -> Value {\n+    use cretonne::codegen::ir::types::*;\n+    match ty {\n+        I8 => fx.bcx.ins().uload8(I32, MemFlags::new(), addr, offset),\n+        I16 => fx.bcx.ins().uload16(I32, MemFlags::new(), addr, offset),\n+        // I32 and I64 work\n+        _ => fx.bcx.ins().load(ty, MemFlags::new(), addr, offset),\n+    }\n+}\n+\n+// FIXME(cretonne) fix store.i8\n+fn store_workaround(fx: &mut FunctionCx, ty: Type, addr: Value, val: Value, offset: i32) {\n+    use cretonne::codegen::ir::types::*;\n+    match ty {\n+        I8 => fx.bcx.ins().istore8(MemFlags::new(), val, addr, offset),\n+        I16 => fx.bcx.ins().istore16(MemFlags::new(), val, addr, offset),\n+        // I32 and I64 work\n+        _ => fx.bcx.ins().store(MemFlags::new(), val, addr, offset),\n+    };\n+}\n+\n #[derive(Copy, Clone)]\n enum CValue {\n     ByRef(Value),\n@@ -65,7 +87,7 @@ impl CValue {\n         match self {\n             CValue::ByRef(value) => {\n                 let cton_ty = cton_type_from_ty(ty).unwrap();\n-                fx.bcx.ins().load(cton_ty, MemFlags::new(), value, 0)\n+                load_workaround(fx, cton_ty, value, 0)\n             }\n             CValue::ByVal(value) => value,\n             CValue::Func(func) => {\n@@ -77,8 +99,8 @@ impl CValue {\n     fn expect_byref(self) -> Value {\n         match self {\n             CValue::ByRef(value) => value,\n-            CValue::ByVal(_) => unimplemented!(\"Expected CValue::ByRef, found CValue::ByVal\"),\n-            CValue::Func(_) => unimplemented!(\"Expected CValue::ByRef, found CValue::Func\"),\n+            CValue::ByVal(_) => bug!(\"Expected CValue::ByRef, found CValue::ByVal\"),\n+            CValue::Func(_) => bug!(\"Expected CValue::ByRef, found CValue::Func\"),\n         }\n     }\n }\n@@ -89,8 +111,12 @@ enum CPlace {\n     Addr(Value),\n }\n \n-impl CPlace {\n-    fn to_cvalue<'a, 'tcx: 'a>(self, fx: &mut FunctionCx<'a, 'tcx>) -> CValue {\n+impl<'a, 'tcx: 'a> CPlace {\n+    fn from_stack_slot(fx: &mut FunctionCx<'a, 'tcx>, stack_slot: StackSlot) -> CPlace {\n+        CPlace::Addr(fx.bcx.ins().stack_addr(types::I64, stack_slot, 0))\n+    }\n+\n+    fn to_cvalue(self, fx: &mut FunctionCx<'a, 'tcx>) -> CValue {\n         match self {\n             CPlace::Var(var) => CValue::ByVal(fx.bcx.use_var(var)),\n             CPlace::Addr(addr) => CValue::ByRef(addr),\n@@ -100,7 +126,30 @@ impl CPlace {\n     fn expect_addr(self) -> Value {\n         match self {\n             CPlace::Addr(addr) => addr,\n-            CPlace::Var(_) => unreachable!(\"Expected CPlace::Addr, found CPlace::Var\"),\n+            CPlace::Var(_) => bug!(\"Expected CPlace::Addr, found CPlace::Var\"),\n+        }\n+    }\n+\n+    fn write_cvalue(self, fx: &mut FunctionCx<'a, 'tcx>, from: CValue, ty: Ty<'tcx>) {\n+        let layout = fx.tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n+        let size = layout.size.bytes() as i32;\n+        match self {\n+            CPlace::Var(var) => {\n+                let data = from.load_value(fx, ty);\n+                fx.bcx.def_var(var, data)\n+            },\n+            CPlace::Addr(addr) => {\n+                if let Some(cton_ty) = cton_type_from_ty(ty) {\n+                    let data = from.load_value(fx, ty);\n+                    store_workaround(fx, cton_ty, addr, data, 0);\n+                } else {\n+                    for i in 0..size {\n+                        let from = from.expect_byref();\n+                        let byte = load_workaround(fx, types::I8, from, i);\n+                        store_workaround(fx, types::I8, addr, byte, i);\n+                    }\n+                }\n+            }\n         }\n     }\n }\n@@ -109,66 +158,81 @@ pub fn trans_crate<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Box<Any> {\n     let link_meta = ::build_link_meta(tcx.crate_hash(LOCAL_CRATE));\n     let metadata = tcx.encode_metadata(&link_meta);\n \n-    let module: Module<SimpleJITBackend> = Module::new(SimpleJITBuilder::new());\n-    //let mut context = Context::new();\n-\n-    let mut cx = CodegenCx {\n-        tcx,\n-        module,\n-        def_id_fn_id_map: HashMap::new(),\n-    };\n-    let cx = &mut cx;\n+    let mut module: Module<SimpleJITBackend> = Module::new(SimpleJITBuilder::new());\n+    let mut context = Context::new();\n+    let mut def_id_fn_id_map = HashMap::new();\n \n-    for mono_item in\n-        collector::collect_crate_mono_items(\n+    {\n+        let mut cx = CodegenCx {\n             tcx,\n-            collector::MonoItemCollectionMode::Eager\n-        ).0 {\n-        match mono_item {\n-            MonoItem::Fn(inst) => match inst {\n-                Instance {\n-                    def: InstanceDef::Item(def_id),\n-                    substs,\n-                } => {\n-                    let sig = tcx.fn_sig(def_id);\n-                    let sig = cton_sig_from_fn_sig(tcx, sig, substs);\n-                    let func_id = {\n-                        let module = &mut cx.module;\n-                        *cx.def_id_fn_id_map.entry(inst).or_insert_with(|| {\n-                            module.declare_function(&tcx.absolute_item_path_str(def_id), Linkage::Local, &sig).unwrap()\n-                        })\n-                    };\n+            module: &mut module,\n+            def_id_fn_id_map: &mut def_id_fn_id_map,\n+        };\n+        let cx = &mut cx;\n+\n+        for mono_item in\n+            collector::collect_crate_mono_items(\n+                tcx,\n+                collector::MonoItemCollectionMode::Eager\n+            ).0 {\n+            match mono_item {\n+                MonoItem::Fn(inst) => match inst {\n+                    Instance {\n+                        def: InstanceDef::Item(def_id),\n+                        substs,\n+                    } => {\n+                        let sig = tcx.fn_sig(def_id);\n+                        let sig = cton_sig_from_fn_sig(tcx, sig, substs);\n+                        let func_id = {\n+                            let module = &mut cx.module;\n+                            *cx.def_id_fn_id_map.entry(inst).or_insert_with(|| {\n+                                module.declare_function(&tcx.absolute_item_path_str(def_id), Linkage::Local, &sig).unwrap()\n+                            })\n+                        };\n \n-                    let mut f = Function::with_name_signature(ext_name_from_did(def_id), sig);\n+                        let mut f = Function::with_name_signature(ext_name_from_did(def_id), sig);\n \n-                    trans_fn(cx, &mut f, def_id, substs);\n+                        trans_fn(cx, &mut f, def_id, substs);\n \n-                    let mut mir = ::std::io::Cursor::new(Vec::new());\n-                    ::rustc_mir::util::write_mir_pretty(cx.tcx, Some(def_id), &mut mir).unwrap();\n-                    let mut cton = String::new();\n-                    ::cretonne::codegen::write_function(&mut cton, &f, None).unwrap();\n-                    tcx.sess.warn(&format!(\"{:?}:\\n\\n{}\\n\\n{}\", def_id, String::from_utf8_lossy(&mir.into_inner()), cton));\n+                        let mut mir = ::std::io::Cursor::new(Vec::new());\n+                        ::rustc_mir::util::write_mir_pretty(cx.tcx, Some(def_id), &mut mir).unwrap();\n+                        let mut cton = String::new();\n+                        ::cretonne::codegen::write_function(&mut cton, &f, None).unwrap();\n+                        tcx.sess.warn(&format!(\"{:?}:\\n\\n{}\\n\\n{}\", def_id, String::from_utf8_lossy(&mir.into_inner()), cton));\n \n-                    let flags = settings::Flags::new(settings::builder());\n-                    match ::cretonne::codegen::verify_function(&f, &flags) {\n-                        Ok(_) => {}\n-                        Err(err) => {\n-                            tcx.sess.fatal(&format!(\"cretonne verify error: {}\", err));\n+                        let flags = settings::Flags::new(settings::builder());\n+                        match ::cretonne::codegen::verify_function(&f, &flags) {\n+                            Ok(_) => {}\n+                            Err(err) => {\n+                                tcx.sess.fatal(&format!(\"cretonne verify error: {}\", err));\n+                            }\n                         }\n-                    }\n \n-                    //context.func = f;\n-                    //cx.module.define_function(func_id, &mut context).unwrap();\n-                    //context.clear();\n+                        context.func = f;\n+                        cx.module.define_function(func_id, &mut context).unwrap();\n+                        context.clear();\n+                    }\n+                    _ => {}\n                 }\n                 _ => {}\n             }\n-            _ => {}\n         }\n     }\n \n-    //cx.module.finalize_all();\n-    //cx.module.finish();\n+    module.finalize_all();\n+\n+    for (inst, func_id) in def_id_fn_id_map.iter() {\n+        if tcx.absolute_item_path_str(inst.def_id()) != \"example::ret_42\" {\n+            continue;\n+        }\n+        let finalized_function: *const u8 = module.finalize_function(*func_id);\n+        let f: extern \"C\" fn(&mut u32) = unsafe { ::std::mem::transmute(finalized_function) };\n+        let mut res = 0u32;\n+        f(&mut res);\n+        tcx.sess.warn(&format!(\"ret_42 returned {}\", res));\n+    }\n+\n+    module.finish();\n \n     tcx.sess.fatal(\"unimplemented\");\n \n@@ -179,10 +243,10 @@ pub fn trans_crate<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Box<Any> {\n     })\n }\n \n-struct CodegenCx<'a, 'tcx: 'a> {\n+struct CodegenCx<'a, 'tcx: 'a, B: Backend + 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    module: Module<CurrentBackend>,\n-    def_id_fn_id_map: HashMap<Instance<'tcx>, FuncId>,\n+    module: &'a mut Module<B>,\n+    def_id_fn_id_map: &'a mut HashMap<Instance<'tcx>, FuncId>,\n }\n \n struct FunctionCx<'a, 'tcx: 'a> {\n@@ -215,7 +279,7 @@ impl<'f, 'tcx> FunctionCx<'f, 'tcx> {\n     }\n }\n \n-fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx>, f: &mut Function, def_id: DefId, substs: &Substs<'tcx>) {\n+fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &mut Function, def_id: DefId, substs: &Substs<'tcx>) {\n     let mir = cx.tcx.optimized_mir(def_id);\n     let mut func_ctx = FunctionBuilderContext::new();\n     let mut bcx: FunctionBuilder<Variable> = FunctionBuilder::new(f, &mut func_ctx);\n@@ -259,13 +323,13 @@ fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx>, f: &mut Function, def_id\n     fx.local_map.insert(RETURN_PLACE, CPlace::Addr(ret_param));\n \n     for (local, ebb_param, ty, stack_slot) in func_params {\n-        let addr = fx.bcx.ins().stack_addr(types::I64, stack_slot, 0);\n+        let place = CPlace::from_stack_slot(fx, stack_slot);\n         if ty.is_some() {\n             fx.bcx.ins().stack_store(ebb_param, stack_slot, 0);\n         } else {\n-            do_memcpy(fx, CPlace::Addr(addr), CValue::ByRef(ebb_param), mir.local_decls[local].ty);\n+            place.write_cvalue(fx, CValue::ByRef(ebb_param), mir.local_decls[local].ty);\n         }\n-        fx.local_map.insert(local, CPlace::Addr(addr));\n+        fx.local_map.insert(local, place);\n     }\n \n     for local in mir.vars_and_temps_iter() {\n@@ -275,8 +339,8 @@ fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx>, f: &mut Function, def_id\n             size: layout.size.bytes() as u32,\n             offset: None,\n         });\n-        let addr = fx.bcx.ins().stack_addr(types::I64, stack_slot, 0);\n-        fx.local_map.insert(local, CPlace::Addr(addr));\n+        let place = CPlace::from_stack_slot(fx, stack_slot);\n+        fx.local_map.insert(local, place);\n     }\n \n     fx.bcx.ins().jump(*fx.ebb_map.get(&START_BLOCK).unwrap(), &[]);\n@@ -393,7 +457,7 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n             match rval {\n                 Rvalue::Use(operand) => {\n                     let val = trans_operand(fx, operand);\n-                    do_memcpy(fx, lval, val, ty);\n+                    lval.write_cvalue(fx, val, ty);\n                 },\n                 Rvalue::CheckedBinaryOp(bin_op, lhs, rhs) => {\n                     let ty = lhs.ty(&fx.mir.local_decls, fx.tcx);\n@@ -414,15 +478,15 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n                         }\n                         _ => unimplemented!(),\n                     };\n-                    do_memcpy(fx, lval, CValue::ByVal(res), ty);\n+                    lval.write_cvalue(fx, CValue::ByVal(res), ty);\n                 }\n                 Rvalue::Cast(CastKind::ReifyFnPointer, operand, ty) => {\n                     let operand = trans_operand(fx, operand);\n-                    do_memcpy(fx, lval, operand, ty);\n+                    lval.write_cvalue(fx, operand, ty);\n                 }\n                 Rvalue::Cast(CastKind::UnsafeFnPointer, operand, ty) => {\n                     let operand = trans_operand(fx, operand);\n-                    do_memcpy(fx, lval, operand, ty);\n+                    lval.write_cvalue(fx, operand, ty);\n                 }\n                 rval => unimplemented!(\"rval {:?}\", rval),\n             }\n@@ -490,29 +554,6 @@ fn trans_operand<'a, 'tcx>(fx: &mut FunctionCx<'a, 'tcx>, operand: &Operand<'tcx\n     }\n }\n \n-fn do_memcpy<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, to: CPlace, from: CValue, ty: Ty<'tcx>) {\n-    let layout = fx.tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n-    let size = layout.size.bytes() as i32;\n-    match to {\n-        CPlace::Var(var) => {\n-            let data = from.load_value(fx, ty);\n-            fx.bcx.def_var(var, data)\n-        },\n-        CPlace::Addr(addr) => {\n-            if cton_type_from_ty(ty).is_some() {\n-                let data = from.load_value(fx, ty);\n-                fx.bcx.ins().store(MemFlags::new(), data, addr, 0);\n-            } else {\n-                for i in 0..size {\n-                    let from = from.expect_byref();\n-                    let byte = fx.bcx.ins().load(types::I8, MemFlags::new(), from, i);\n-                    fx.bcx.ins().store(MemFlags::new(), byte, addr, i);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n fn ext_name_from_did(def_id: DefId) -> ExternalName {\n     ExternalName::user(def_id.krate.as_u32(), def_id.index.as_raw_u32())\n }"}]}