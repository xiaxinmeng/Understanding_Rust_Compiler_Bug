{"sha": "516570f2d6b2246cf2ae0269a201bd6a62c91881", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxNjU3MGYyZDZiMjI0NmNmMmFlMDI2OWEyMDFiZDZhNjJjOTE4ODE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-04-15T20:58:50Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-04-15T20:58:50Z"}, "message": "rustc_typeck: move some obligation methods to Inherited.", "tree": {"sha": "c246cb3dc58b9b433446a765e2020d1dd3abb0e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c246cb3dc58b9b433446a765e2020d1dd3abb0e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/516570f2d6b2246cf2ae0269a201bd6a62c91881", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/516570f2d6b2246cf2ae0269a201bd6a62c91881", "html_url": "https://github.com/rust-lang/rust/commit/516570f2d6b2246cf2ae0269a201bd6a62c91881", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/516570f2d6b2246cf2ae0269a201bd6a62c91881/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ad196444b41830b59a724d644052e692ebcad47", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ad196444b41830b59a724d644052e692ebcad47", "html_url": "https://github.com/rust-lang/rust/commit/2ad196444b41830b59a724d644052e692ebcad47"}], "stats": {"total": 181, "additions": 68, "deletions": 113}, "files": [{"sha": "9610477d8fd919f26e49a37c1130a4e4375eaef5", "filename": "src/librustc_typeck/check/assoc.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2ad196444b41830b59a724d644052e692ebcad47/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad196444b41830b59a724d644052e692ebcad47/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=2ad196444b41830b59a724d644052e692ebcad47", "patch": "@@ -1,39 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::infer::InferCtxt;\n-use rustc::traits::{self, FulfillmentContext, Normalized, MiscObligation, SelectionContext,\n-                    ObligationCause};\n-use rustc::ty::fold::TypeFoldable;\n-use syntax::ast;\n-use syntax_pos::Span;\n-\n-// FIXME(@jroesch): Ideally we should be able to drop the fulfillment_cx argument.\n-pub fn normalize_associated_types_in<'a, 'gcx, 'tcx, T>(\n-    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-    fulfillment_cx: &mut FulfillmentContext<'tcx>,\n-    span: Span,\n-    body_id: ast::NodeId,\n-    value: &T) -> T\n-\n-    where T : TypeFoldable<'tcx>\n-{\n-    debug!(\"normalize_associated_types_in(value={:?})\", value);\n-    let mut selcx = SelectionContext::new(infcx);\n-    let cause = ObligationCause::new(span, body_id, MiscObligation);\n-    let Normalized { value: result, obligations } = traits::normalize(&mut selcx, cause, value);\n-    debug!(\"normalize_associated_types_in: result={:?} predicates={:?}\",\n-           result,\n-           obligations);\n-    for obligation in obligations {\n-        fulfillment_cx.register_predicate_obligation(infcx, obligation);\n-    }\n-    result\n-}"}, {"sha": "8a6853461a5e847d15c465fe14f494a6edead243", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 25, "deletions": 39, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/516570f2d6b2246cf2ae0269a201bd6a62c91881/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/516570f2d6b2246cf2ae0269a201bd6a62c91881/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=516570f2d6b2246cf2ae0269a201bd6a62c91881", "patch": "@@ -20,7 +20,6 @@ use rustc::util::common::ErrorReported;\n use syntax::ast;\n use syntax_pos::Span;\n \n-use super::assoc;\n use super::{Inherited, FnCtxt};\n use astconv::ExplicitSelf;\n \n@@ -227,7 +226,6 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tcx.infer_ctxt(trait_param_env, Reveal::UserFacing).enter(|infcx| {\n         let inh = Inherited::new(infcx);\n         let infcx = &inh.infcx;\n-        let fulfillment_cx = &inh.fulfillment_cx;\n \n         debug!(\"compare_impl_method: caller_bounds={:?}\",\n                infcx.parameter_environment.caller_bounds);\n@@ -239,12 +237,11 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                        infer::HigherRankedType,\n                                                        &ty::Binder(impl_m_own_bounds.predicates));\n         for predicate in impl_m_own_bounds {\n-            let traits::Normalized { value: predicate, .. } =\n+            let traits::Normalized { value: predicate, obligations } =\n                 traits::normalize(&mut selcx, normalize_cause.clone(), &predicate);\n \n-            fulfillment_cx.borrow_mut().register_predicate_obligation(\n-                &infcx,\n-                traits::Obligation::new(cause.clone(), predicate));\n+            inh.register_predicates(obligations);\n+            inh.register_predicate(traits::Obligation::new(cause.clone(), predicate));\n         }\n \n         // We now need to check that the signature of the impl method is\n@@ -277,11 +274,9 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let impl_sig =\n             impl_sig.subst(tcx, impl_to_skol_substs);\n         let impl_sig =\n-            assoc::normalize_associated_types_in(&infcx,\n-                                                 &mut fulfillment_cx.borrow_mut(),\n-                                                 impl_m_span,\n-                                                 impl_m_body_id,\n-                                                 &impl_sig);\n+            inh.normalize_associated_types_in(impl_m_span,\n+                                              impl_m_body_id,\n+                                              &impl_sig);\n         let impl_fty = tcx.mk_fn_ptr(ty::Binder(impl_sig));\n         debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n \n@@ -291,11 +286,9 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let trait_sig =\n             trait_sig.subst(tcx, trait_to_skol_substs);\n         let trait_sig =\n-            assoc::normalize_associated_types_in(&infcx,\n-                                                 &mut fulfillment_cx.borrow_mut(),\n-                                                 impl_m_span,\n-                                                 impl_m_body_id,\n-                                                 &trait_sig);\n+            inh.normalize_associated_types_in(impl_m_span,\n+                                              impl_m_body_id,\n+                                              &trait_sig);\n         let trait_fty = tcx.mk_fn_ptr(ty::Binder(trait_sig));\n \n         debug!(\"compare_impl_method: trait_fty={:?}\", trait_fty);\n@@ -344,7 +337,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         // Check that all obligations are satisfied by the implementation's\n         // version.\n-        if let Err(ref errors) = fulfillment_cx.borrow_mut().select_all_or_error(&infcx) {\n+        if let Err(ref errors) = inh.fulfillment_cx.borrow_mut().select_all_or_error(&infcx) {\n             infcx.report_fulfillment_errors(errors);\n             return Err(ErrorReported);\n         }\n@@ -731,7 +724,8 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\", impl_trait_ref);\n \n     tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n-        let mut fulfillment_cx = traits::FulfillmentContext::new();\n+        let inh = Inherited::new(infcx);\n+        let infcx = &inh.infcx;\n \n         // The below is for the most part highly similar to the procedure\n         // for methods above. It is simpler in many respects, especially\n@@ -761,31 +755,21 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let trait_ty = tcx.item_type(trait_c.def_id).subst(tcx, trait_to_skol_substs);\n         let mut cause = ObligationCause::misc(impl_c_span, impl_c_node_id);\n \n-        let err = infcx.commit_if_ok(|_| {\n-            // There is no \"body\" here, so just pass dummy id.\n-            let impl_ty = assoc::normalize_associated_types_in(&infcx,\n-                                                               &mut fulfillment_cx,\n-                                                               impl_c_span,\n-                                                               ast::CRATE_NODE_ID,\n-                                                               &impl_ty);\n+        // There is no \"body\" here, so just pass dummy id.\n+        let impl_ty = inh.normalize_associated_types_in(impl_c_span,\n+                                                        impl_c_node_id,\n+                                                        &impl_ty);\n \n-            debug!(\"compare_const_impl: impl_ty={:?}\", impl_ty);\n+        debug!(\"compare_const_impl: impl_ty={:?}\", impl_ty);\n \n-            let trait_ty = assoc::normalize_associated_types_in(&infcx,\n-                                                                &mut fulfillment_cx,\n-                                                                impl_c_span,\n-                                                                ast::CRATE_NODE_ID,\n-                                                                &trait_ty);\n+        let trait_ty = inh.normalize_associated_types_in(impl_c_span,\n+                                                         impl_c_node_id,\n+                                                         &trait_ty);\n \n-            debug!(\"compare_const_impl: trait_ty={:?}\", trait_ty);\n+        debug!(\"compare_const_impl: trait_ty={:?}\", trait_ty);\n \n-            infcx.sub_types(false, &cause, impl_ty, trait_ty)\n-                 .map(|InferOk { obligations, value: () }| {\n-                     for obligation in obligations {\n-                         fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n-                     }\n-                 })\n-        });\n+        let err = infcx.sub_types(false, &cause, impl_ty, trait_ty)\n+            .map(|ok| inh.register_infer_ok_obligations(ok));\n \n         if let Err(terr) = err {\n             debug!(\"checking associated const for compatibility: impl ty {:?}, trait ty {:?}\",\n@@ -822,5 +806,7 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 &terr);\n             diag.emit();\n         }\n+\n+        // FIXME(#41323) Check the obligations in the fulfillment context.\n     });\n }"}, {"sha": "2e69ad4cc618c69b70fd9f44609e60282c36c0c2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/516570f2d6b2246cf2ae0269a201bd6a62c91881/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/516570f2d6b2246cf2ae0269a201bd6a62c91881/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=516570f2d6b2246cf2ae0269a201bd6a62c91881", "patch": "@@ -129,7 +129,6 @@ use rustc_back::slice;\n use rustc_const_eval::eval_length;\n use rustc_const_math::ConstInt;\n \n-mod assoc;\n mod autoderef;\n pub mod dropck;\n pub mod _match;\n@@ -537,7 +536,7 @@ impl<'a, 'gcx, 'tcx> InheritedBuilder<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n-    pub fn new(infcx: InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n+    fn new(infcx: InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n         Inherited {\n             infcx: infcx,\n             fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n@@ -548,20 +547,55 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn register_predicate(&self, obligation: traits::PredicateObligation<'tcx>) {\n+        debug!(\"register_predicate({:?})\", obligation);\n+        if obligation.has_escaping_regions() {\n+            span_bug!(obligation.cause.span, \"escaping regions in predicate {:?}\",\n+                      obligation);\n+        }\n+        self.fulfillment_cx\n+            .borrow_mut()\n+            .register_predicate_obligation(self, obligation);\n+    }\n+\n+    fn register_predicates(&self, obligations: Vec<traits::PredicateObligation<'tcx>>) {\n+        for obligation in obligations {\n+            self.register_predicate(obligation);\n+        }\n+    }\n+\n+    fn register_infer_ok_obligations<T>(&self, infer_ok: InferOk<'tcx, T>) -> T {\n+        self.register_predicates(infer_ok.obligations);\n+        infer_ok.value\n+    }\n+\n     fn normalize_associated_types_in<T>(&self,\n                                         span: Span,\n                                         body_id: ast::NodeId,\n-                                        value: &T)\n-                                        -> T\n+                                        value: &T) -> T\n         where T : TypeFoldable<'tcx>\n     {\n-        assoc::normalize_associated_types_in(self,\n-                                             &mut self.fulfillment_cx.borrow_mut(),\n-                                             span,\n-                                             body_id,\n-                                             value)\n+        let ok = self.normalize_associated_types_in_as_infer_ok(span, body_id, value);\n+        self.register_infer_ok_obligations(ok)\n     }\n \n+    fn normalize_associated_types_in_as_infer_ok<T>(&self,\n+                                                    span: Span,\n+                                                    body_id: ast::NodeId,\n+                                                    value: &T)\n+                                                    -> InferOk<'tcx, T>\n+        where T : TypeFoldable<'tcx>\n+    {\n+        debug!(\"normalize_associated_types_in(value={:?})\", value);\n+        let mut selcx = traits::SelectionContext::new(self);\n+        let cause = ObligationCause::misc(span, body_id);\n+        let traits::Normalized { value, obligations } =\n+            traits::normalize(&mut selcx, cause, value);\n+        debug!(\"normalize_associated_types_in: result={:?} predicates={:?}\",\n+            value,\n+            obligations);\n+        InferOk { value, obligations }\n+    }\n }\n \n struct CheckItemTypesVisitor<'a, 'tcx: 'a> { tcx: TyCtxt<'a, 'tcx, 'tcx> }\n@@ -1806,32 +1840,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             .register_bound(self, ty, def_id, cause);\n     }\n \n-    pub fn register_predicate(&self,\n-                              obligation: traits::PredicateObligation<'tcx>)\n-    {\n-        debug!(\"register_predicate({:?})\", obligation);\n-        if obligation.has_escaping_regions() {\n-            span_bug!(obligation.cause.span, \"escaping regions in predicate {:?}\",\n-                      obligation);\n-        }\n-        self.fulfillment_cx\n-            .borrow_mut()\n-            .register_predicate_obligation(self, obligation);\n-    }\n-\n-    pub fn register_predicates(&self,\n-                               obligations: Vec<traits::PredicateObligation<'tcx>>)\n-    {\n-        for obligation in obligations {\n-            self.register_predicate(obligation);\n-        }\n-    }\n-\n-    pub fn register_infer_ok_obligations<T>(&self, infer_ok: InferOk<'tcx, T>) -> T {\n-        self.register_predicates(infer_ok.obligations);\n-        infer_ok.value\n-    }\n-\n     pub fn to_ty(&self, ast_t: &hir::Ty) -> Ty<'tcx> {\n         let t = AstConv::ast_ty_to_ty(self, ast_t);\n         self.register_wf_obligation(t, ast_t.span, traits::MiscObligation);"}]}