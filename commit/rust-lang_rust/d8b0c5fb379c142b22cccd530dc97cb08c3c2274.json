{"sha": "d8b0c5fb379c142b22cccd530dc97cb08c3c2274", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4YjBjNWZiMzc5YzE0MmIyMmNjY2Q1MzBkYzk3Y2IwOGMzYzIyNzQ=", "commit": {"author": {"name": "Tim Diekmann", "email": "tim.diekmann@3dvision.de", "date": "2020-04-03T05:28:23Z"}, "committer": {"name": "Tim Diekmann", "email": "tim.diekmann@3dvision.de", "date": "2020-04-03T05:28:23Z"}, "message": "Minor doc improvements on `AllocRef`", "tree": {"sha": "742f829609fc016344522b9e146ccf37029451b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/742f829609fc016344522b9e146ccf37029451b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8b0c5fb379c142b22cccd530dc97cb08c3c2274", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8b0c5fb379c142b22cccd530dc97cb08c3c2274", "html_url": "https://github.com/rust-lang/rust/commit/d8b0c5fb379c142b22cccd530dc97cb08c3c2274", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8b0c5fb379c142b22cccd530dc97cb08c3c2274/comments", "author": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b612399366e28b5314b5fd289f46c636d596a7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b612399366e28b5314b5fd289f46c636d596a7b", "html_url": "https://github.com/rust-lang/rust/commit/0b612399366e28b5314b5fd289f46c636d596a7b"}], "stats": {"total": 41, "additions": 22, "deletions": 19}, "files": [{"sha": "b1e502d8548d923a3469fa52360f8f85274881f1", "filename": "src/libcore/alloc/mod.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d8b0c5fb379c142b22cccd530dc97cb08c3c2274/src%2Flibcore%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8b0c5fb379c142b22cccd530dc97cb08c3c2274/src%2Flibcore%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Fmod.rs?ref=d8b0c5fb379c142b22cccd530dc97cb08c3c2274", "patch": "@@ -119,7 +119,7 @@ pub enum ReallocPlacement {\n ///\n /// Unlike [`GlobalAlloc`][], zero-sized allocations are allowed in `AllocRef`. If an underlying\n /// allocator does not support this (like jemalloc) or return a null pointer (such as\n-/// `libc::malloc`), this case must be caught.\n+/// `libc::malloc`), this is caught by the implementation.\n ///\n /// ### Currently allocated memory\n ///\n@@ -157,18 +157,20 @@ pub enum ReallocPlacement {\n /// # Safety\n ///\n /// * Memory blocks returned from an allocator must point to valid memory and retain their validity\n-///   until the instance and all of its clones are dropped, and\n+///   until the instance and all of its clones are dropped,\n ///\n /// * cloning or moving the allocator must not invalidate memory blocks returned from this\n-///   allocator. A cloned allocator must behave like the same allocator.\n+///   allocator. A cloned allocator must behave like the same allocator, and\n ///\n /// * any pointer to a memory block which is [*currently allocated*] may be passed to any other\n ///   method of the allocator.\n ///\n /// [*currently allocated*]: #currently-allocated-memory\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n pub unsafe trait AllocRef {\n-    /// On success, returns a memory block meeting the size and alignment guarantees of `layout`.\n+    /// Attempts to allocate a block of memory.\n+    ///\n+    /// On success, returns a [`MemoryBlock`][] meeting the size and alignment guarantees of `layout`.\n     ///\n     /// The returned block may have a larger size than specified by `layout.size()` and is\n     /// initialized as specified by [`init`], all the way up to the returned size of the block.\n@@ -190,26 +192,26 @@ pub unsafe trait AllocRef {\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr>;\n \n-    /// Deallocates the memory denoted by `memory`.\n+    /// Deallocates the memory referenced by `ptr`.\n     ///\n     /// # Safety\n     ///\n-    /// * `ptr` must be [*currently allocated*] via this allocator, and\n-    /// * `layout` must [*fit*] the `ptr`.\n+    /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator, and\n+    /// * `layout` must [*fit*] that block of memory.\n     ///\n     /// [*currently allocated*]: #currently-allocated-memory\n     /// [*fit*]: #memory-fitting\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout);\n \n     /// Attempts to extend the memory block.\n     ///\n-    /// Returns a new memory block containing a pointer and the actual size of the allocated\n-    /// block. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n+    /// Returns a new [`MemoryBlock`][] containing a pointer and the actual size of the allocated\n+    /// memory. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n     /// alignment and a size given by `new_size`. To accomplish this, the allocator may extend the\n     /// allocation referenced by `ptr` to fit the new layout. If the [`placement`] is\n     /// [`InPlace`], the returned pointer is guaranteed to be the same as the passed `ptr`.\n     ///\n-    /// If `ReallocPlacement::MayMove` is used then ownership of the memory block referenced by `ptr`\n+    /// If [`MayMove`] is used then ownership of the memory block referenced by `ptr`\n     /// is transferred to this allocator. The memory may or may not be freed, and should be\n     /// considered unusable (unless of course it is transferred back to the caller again via the\n     /// return value of this method).\n@@ -227,17 +229,18 @@ pub unsafe trait AllocRef {\n     ///     the size of the `MemoryBlock` returned by the `grow` call.\n     ///\n     /// [`InPlace`]: ReallocPlacement::InPlace\n+    /// [`MayMove`]: ReallocPlacement::MayMove\n     /// [`placement`]: ReallocPlacement\n     /// [`init`]: AllocInit\n     ///\n     /// # Safety\n     ///\n-    /// * `ptr` must be [*currently allocated*] via this allocator,\n-    /// * `layout` must [*fit*] the `ptr`. (The `new_size` argument need not fit it.)\n+    /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator,\n+    /// * `layout` must [*fit*] that block of memory (The `new_size` argument need not fit it.),\n     // We can't require that `new_size` is strictly greater than `memory.size` because of ZSTs.\n     // An alternative would be\n     // * `new_size must be strictly greater than `memory.size` or both are zero\n-    /// * `new_size` must be greater than or equal to `layout.size()`\n+    /// * `new_size` must be greater than or equal to `layout.size()`, and\n     /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`, must not overflow\n     ///   (i.e., the rounded value must be less than or equal to `usize::MAX`).\n     ///\n@@ -289,8 +292,8 @@ pub unsafe trait AllocRef {\n \n     /// Attempts to shrink the memory block.\n     ///\n-    /// Returns a new memory block containing a pointer and the actual size of the allocated\n-    /// block. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n+    /// Returns a new [`MemoryBlock`][] containing a pointer and the actual size of the allocated\n+    /// memory. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n     /// alignment and a size given by `new_size`. To accomplish this, the allocator may shrink the\n     /// allocation referenced by `ptr` to fit the new layout. If the [`placement`] is\n     /// [`InPlace`], the returned pointer is guaranteed to be the same as the passed `ptr`.\n@@ -310,20 +313,20 @@ pub unsafe trait AllocRef {\n     ///\n     /// # Safety\n     ///\n-    /// * `ptr` must be [*currently allocated*] via this allocator,\n-    /// * `layout` must [*fit*] the `ptr`. (The `new_size` argument need not fit it.)\n+    /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator,\n+    /// * `layout` must [*fit*] that block of memory (The `new_size` argument need not fit it.), and\n     // We can't require that `new_size` is strictly smaller than `memory.size` because of ZSTs.\n     // An alternative would be\n     // * `new_size must be strictly smaller than `memory.size` or both are zero\n-    /// * `new_size` must be smaller than or equal to `layout.size()`\n+    /// * `new_size` must be smaller than or equal to `layout.size()`.\n     ///\n     /// [*currently allocated*]: #currently-allocated-memory\n     /// [*fit*]: #memory-fitting\n     ///\n     /// # Errors\n     ///\n     /// Returns `Err` if the new layout does not meet the allocator's size and alignment\n-    /// constraints of the allocator, or if growing otherwise fails.\n+    /// constraints of the allocator, or if shrinking otherwise fails.\n     ///\n     /// Implementations are encouraged to return `Err` on memory exhaustion rather than panicking or\n     /// aborting, but this is not a strict requirement. (Specifically: it is *legal* to implement"}]}