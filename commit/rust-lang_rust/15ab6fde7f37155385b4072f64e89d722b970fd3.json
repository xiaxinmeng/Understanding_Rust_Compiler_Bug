{"sha": "15ab6fde7f37155385b4072f64e89d722b970fd3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1YWI2ZmRlN2YzNzE1NTM4NWI0MDcyZjY0ZTg5ZDcyMmI5NzBmZDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-26T15:02:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-26T15:02:06Z"}, "message": "auto merge of #8039 : Xazax-hun/rust/master, r=brson\n\nAdded some more atomic operations. https://github.com/mozilla/rust/issues/7421", "tree": {"sha": "c197c9c5b9eaec9841b048fa382e2908a64c7f63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c197c9c5b9eaec9841b048fa382e2908a64c7f63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15ab6fde7f37155385b4072f64e89d722b970fd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15ab6fde7f37155385b4072f64e89d722b970fd3", "html_url": "https://github.com/rust-lang/rust/commit/15ab6fde7f37155385b4072f64e89d722b970fd3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15ab6fde7f37155385b4072f64e89d722b970fd3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "382b037252c213150f2a298524db2c7674804126", "url": "https://api.github.com/repos/rust-lang/rust/commits/382b037252c213150f2a298524db2c7674804126", "html_url": "https://github.com/rust-lang/rust/commit/382b037252c213150f2a298524db2c7674804126"}, {"sha": "7cc8f4bae0ed20aad04e03e5f3812fb7b8288f78", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cc8f4bae0ed20aad04e03e5f3812fb7b8288f78", "html_url": "https://github.com/rust-lang/rust/commit/7cc8f4bae0ed20aad04e03e5f3812fb7b8288f78"}], "stats": {"total": 186, "additions": 184, "deletions": 2}, "files": [{"sha": "712c32d2436623f4049934f83108c429beb4b9d6", "filename": "src/libstd/unstable/atomics.rs", "status": "modified", "additions": 184, "deletions": 2, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/15ab6fde7f37155385b4072f64e89d722b970fd3/src%2Flibstd%2Funstable%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ab6fde7f37155385b4072f64e89d722b970fd3/src%2Flibstd%2Funstable%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fatomics.rs?ref=15ab6fde7f37155385b4072f64e89d722b970fd3", "patch": "@@ -96,7 +96,7 @@ impl AtomicFlag {\n      */\n     #[inline]\n     pub fn test_and_set(&mut self, order: Ordering) -> bool {\n-        unsafe {atomic_compare_and_swap(&mut self.v, 0, 1, order) > 0}\n+        unsafe { atomic_compare_and_swap(&mut self.v, 0, 1, order) > 0 }\n     }\n }\n \n@@ -121,7 +121,7 @@ impl AtomicBool {\n     pub fn swap(&mut self, val: bool, order: Ordering) -> bool {\n         let val = if val { 1 } else { 0 };\n \n-        unsafe { atomic_swap(&mut self.v, val, order) > 0}\n+        unsafe { atomic_swap(&mut self.v, val, order) > 0 }\n     }\n \n     #[inline]\n@@ -131,6 +131,38 @@ impl AtomicBool {\n \n         unsafe { atomic_compare_and_swap(&mut self.v, old, new, order) > 0 }\n     }\n+\n+    /// Returns the old value\n+    #[inline]\n+    pub fn fetch_and(&mut self, val: bool, order: Ordering) -> bool {\n+        let val = if val { 1 } else { 0 };\n+\n+        unsafe { atomic_and(&mut self.v, val, order) > 0 }\n+    }\n+\n+    /// Returns the old value\n+    #[inline]\n+    pub fn fetch_nand(&mut self, val: bool, order: Ordering) -> bool {\n+        let val = if val { 1 } else { 0 };\n+\n+        unsafe { atomic_nand(&mut self.v, val, order) > 0 }\n+    }\n+\n+    /// Returns the old value\n+    #[inline]\n+    pub fn fetch_or(&mut self, val: bool, order: Ordering) -> bool {\n+        let val = if val { 1 } else { 0 };\n+\n+        unsafe { atomic_or(&mut self.v, val, order) > 0 }\n+    }\n+\n+    /// Returns the old value\n+    #[inline]\n+    pub fn fetch_xor(&mut self, val: bool, order: Ordering) -> bool {\n+        let val = if val { 1 } else { 0 };\n+\n+        unsafe { atomic_xor(&mut self.v, val, order) > 0 }\n+    }\n }\n \n impl AtomicInt {\n@@ -169,6 +201,18 @@ impl AtomicInt {\n     pub fn fetch_sub(&mut self, val: int, order: Ordering) -> int {\n         unsafe { atomic_sub(&mut self.v, val, order) }\n     }\n+\n+    /// Returns the old value\n+    #[inline]\n+    pub fn fetch_min(&mut self, val: int, order: Ordering) -> int {\n+        unsafe { atomic_min(&mut self.v, val, order) }\n+    }\n+\n+    /// Returns the old value\n+    #[inline]\n+    pub fn fetch_max(&mut self, val: int, order: Ordering) -> int {\n+        unsafe { atomic_max(&mut self.v, val, order) }\n+    }\n }\n \n impl AtomicUint {\n@@ -207,6 +251,18 @@ impl AtomicUint {\n     pub fn fetch_sub(&mut self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_sub(&mut self.v, val, order) }\n     }\n+\n+    /// Returns the old value\n+    #[inline]\n+    pub fn fetch_min(&mut self, val: uint, order: Ordering) -> uint {\n+        unsafe { atomic_umin(&mut self.v, val, order) }\n+    }\n+\n+    /// Returns the old value\n+    #[inline]\n+    pub fn fetch_max(&mut self, val: uint, order: Ordering) -> uint {\n+        unsafe { atomic_umax(&mut self.v, val, order) }\n+    }\n }\n \n impl<T> AtomicPtr<T> {\n@@ -395,6 +451,125 @@ pub unsafe fn atomic_compare_and_swap<T>(dst:&mut T, old:T, new:T, order: Orderi\n     })\n }\n \n+#[inline]\n+pub unsafe fn atomic_and<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    let dst = cast::transmute(dst);\n+    let val = cast::transmute(val);\n+\n+    cast::transmute(match order {\n+        Acquire => intrinsics::atomic_and_acq(dst, val),\n+        Release => intrinsics::atomic_and_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_and_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_and_relaxed(dst, val),\n+        _       => intrinsics::atomic_and(dst, val)\n+    })\n+}\n+\n+\n+#[inline]\n+pub unsafe fn atomic_nand<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    let dst = cast::transmute(dst);\n+    let val = cast::transmute(val);\n+\n+    cast::transmute(match order {\n+        Acquire => intrinsics::atomic_nand_acq(dst, val),\n+        Release => intrinsics::atomic_nand_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_nand_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_nand_relaxed(dst, val),\n+        _       => intrinsics::atomic_nand(dst, val)\n+    })\n+}\n+\n+\n+#[inline]\n+pub unsafe fn atomic_or<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    let dst = cast::transmute(dst);\n+    let val = cast::transmute(val);\n+\n+    cast::transmute(match order {\n+        Acquire => intrinsics::atomic_or_acq(dst, val),\n+        Release => intrinsics::atomic_or_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_or_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_or_relaxed(dst, val),\n+        _       => intrinsics::atomic_or(dst, val)\n+    })\n+}\n+\n+\n+#[inline]\n+pub unsafe fn atomic_xor<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    let dst = cast::transmute(dst);\n+    let val = cast::transmute(val);\n+\n+    cast::transmute(match order {\n+        Acquire => intrinsics::atomic_xor_acq(dst, val),\n+        Release => intrinsics::atomic_xor_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_xor_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_xor_relaxed(dst, val),\n+        _       => intrinsics::atomic_xor(dst, val)\n+    })\n+}\n+\n+\n+#[inline]\n+pub unsafe fn atomic_max<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    let dst = cast::transmute(dst);\n+    let val = cast::transmute(val);\n+\n+    cast::transmute(match order {\n+        Acquire => intrinsics::atomic_max_acq(dst, val),\n+        Release => intrinsics::atomic_max_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_max_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_max_relaxed(dst, val),\n+        _       => intrinsics::atomic_max(dst, val)\n+    })\n+}\n+\n+\n+#[inline]\n+pub unsafe fn atomic_min<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    let dst = cast::transmute(dst);\n+    let val = cast::transmute(val);\n+\n+    cast::transmute(match order {\n+        Acquire => intrinsics::atomic_min_acq(dst, val),\n+        Release => intrinsics::atomic_min_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_min_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_min_relaxed(dst, val),\n+        _       => intrinsics::atomic_min(dst, val)\n+    })\n+}\n+\n+#[inline]\n+pub unsafe fn atomic_umax<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    let dst = cast::transmute(dst);\n+    let val = cast::transmute(val);\n+\n+    cast::transmute(match order {\n+        Acquire => intrinsics::atomic_umax_acq(dst, val),\n+        Release => intrinsics::atomic_umax_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_umax_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_umax_relaxed(dst, val),\n+        _       => intrinsics::atomic_umax(dst, val)\n+    })\n+}\n+\n+\n+#[inline]\n+pub unsafe fn atomic_umin<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    let dst = cast::transmute(dst);\n+    let val = cast::transmute(val);\n+\n+    cast::transmute(match order {\n+        Acquire => intrinsics::atomic_umin_acq(dst, val),\n+        Release => intrinsics::atomic_umin_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_umin_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_umin_relaxed(dst, val),\n+        _       => intrinsics::atomic_umin(dst, val)\n+    })\n+}\n+\n+\n #[cfg(test)]\n mod test {\n     use option::*;\n@@ -448,4 +623,11 @@ mod test {\n         assert!(p.fill(~2, SeqCst).is_none()); // shouldn't fail\n         assert_eq!(p.take(SeqCst), Some(~2));\n     }\n+\n+    #[test]\n+    fn bool_and() {\n+        let mut a = AtomicBool::new(true);\n+        assert_eq!(a.fetch_and(false, SeqCst),true);\n+        assert_eq!(a.load(SeqCst),false);\n+    }\n }"}]}