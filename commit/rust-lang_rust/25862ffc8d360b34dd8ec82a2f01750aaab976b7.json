{"sha": "25862ffc8d360b34dd8ec82a2f01750aaab976b7", "node_id": "C_kwDOAAsO6NoAKDI1ODYyZmZjOGQzNjBiMzRkZDhlYzgyYTJmMDE3NTBhYWFiOTc2Yjc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-01T03:58:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-01T03:58:32Z"}, "message": "Auto merge of #93259 - eddyb:diagbld-scalar-pair, r=jackh726\n\nrustc_errors: only box the `diagnostic` field in `DiagnosticBuilder`.\n\nI happened to need to do the first change (replacing `allow_suggestions` with equivalent functionality on `Diagnostic` itself) as part of a larger change, and noticed that there's only two fields left in `DiagnosticBuilderInner`.\n\nSo with this PR, instead of a single pointer, `DiagnosticBuilder` is two pointers, which should work just as well for passing *it* by value (and may even work better wrt some operations, though probably not by much).\n\nBut anything that was already taking advantage of `DiagnosticBuilder` being a single pointer, and wrapping it further (e.g. `Result<T, DiagnosticBuilder>` w/ non-ZST `T`), ~~will probably see a slowdown~~, so I want to do a perf run before even trying to propose this.", "tree": {"sha": "d9ef0def054f8bc2a497a7d3b5b3d17ed8c15f0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9ef0def054f8bc2a497a7d3b5b3d17ed8c15f0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25862ffc8d360b34dd8ec82a2f01750aaab976b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25862ffc8d360b34dd8ec82a2f01750aaab976b7", "html_url": "https://github.com/rust-lang/rust/commit/25862ffc8d360b34dd8ec82a2f01750aaab976b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25862ffc8d360b34dd8ec82a2f01750aaab976b7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6cd4aa9a784e3d2e54bca2a1b41082fda67310d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6cd4aa9a784e3d2e54bca2a1b41082fda67310d", "html_url": "https://github.com/rust-lang/rust/commit/a6cd4aa9a784e3d2e54bca2a1b41082fda67310d"}, {"sha": "f5a32711dc14ea66510bd5c8a21763183ee5fc99", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5a32711dc14ea66510bd5c8a21763183ee5fc99", "html_url": "https://github.com/rust-lang/rust/commit/f5a32711dc14ea66510bd5c8a21763183ee5fc99"}], "stats": {"total": 244, "additions": 88, "deletions": 156}, "files": [{"sha": "8cfecafd20c86f7bf8f5df29132d33b78699c150", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/25862ffc8d360b34dd8ec82a2f01750aaab976b7/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25862ffc8d360b34dd8ec82a2f01750aaab976b7/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=25862ffc8d360b34dd8ec82a2f01750aaab976b7", "patch": "@@ -11,6 +11,11 @@ use rustc_span::{MultiSpan, Span, DUMMY_SP};\n use std::fmt;\n use std::hash::{Hash, Hasher};\n \n+/// Error type for `Diagnostic`'s `suggestions` field, indicating that\n+/// `.disable_suggestions()` was called on the `Diagnostic`.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Encodable, Decodable)]\n+pub struct SuggestionsDisabled;\n+\n #[must_use]\n #[derive(Clone, Debug, Encodable, Decodable)]\n pub struct Diagnostic {\n@@ -19,7 +24,7 @@ pub struct Diagnostic {\n     pub code: Option<DiagnosticId>,\n     pub span: MultiSpan,\n     pub children: Vec<SubDiagnostic>,\n-    pub suggestions: Vec<CodeSuggestion>,\n+    pub suggestions: Result<Vec<CodeSuggestion>, SuggestionsDisabled>,\n \n     /// This is not used for highlighting or rendering any error message.  Rather, it can be used\n     /// as a sort key to sort a buffer of diagnostics.  By default, it is the primary span of\n@@ -106,7 +111,7 @@ impl Diagnostic {\n             code,\n             span: MultiSpan::new(),\n             children: vec![],\n-            suggestions: vec![],\n+            suggestions: Ok(vec![]),\n             sort_span: DUMMY_SP,\n             is_lint: false,\n         }\n@@ -300,6 +305,21 @@ impl Diagnostic {\n         self\n     }\n \n+    /// Disallow attaching suggestions this diagnostic.\n+    /// Any suggestions attached e.g. with the `span_suggestion_*` methods\n+    /// (before and after the call to `disable_suggestions`) will be ignored.\n+    pub fn disable_suggestions(&mut self) -> &mut Self {\n+        self.suggestions = Err(SuggestionsDisabled);\n+        self\n+    }\n+\n+    /// Helper for pushing to `self.suggestions`, if available (not disable).\n+    fn push_suggestion(&mut self, suggestion: CodeSuggestion) {\n+        if let Ok(suggestions) = &mut self.suggestions {\n+            suggestions.push(suggestion);\n+        }\n+    }\n+\n     /// Show a suggestion that has multiple parts to it.\n     /// In other words, multiple changes need to be applied as part of this suggestion.\n     pub fn multipart_suggestion(\n@@ -340,7 +360,7 @@ impl Diagnostic {\n         style: SuggestionStyle,\n     ) -> &mut Self {\n         assert!(!suggestion.is_empty());\n-        self.suggestions.push(CodeSuggestion {\n+        self.push_suggestion(CodeSuggestion {\n             substitutions: vec![Substitution {\n                 parts: suggestion\n                     .into_iter()\n@@ -368,7 +388,7 @@ impl Diagnostic {\n         applicability: Applicability,\n     ) -> &mut Self {\n         assert!(!suggestion.is_empty());\n-        self.suggestions.push(CodeSuggestion {\n+        self.push_suggestion(CodeSuggestion {\n             substitutions: vec![Substitution {\n                 parts: suggestion\n                     .into_iter()\n@@ -426,7 +446,7 @@ impl Diagnostic {\n         applicability: Applicability,\n         style: SuggestionStyle,\n     ) -> &mut Self {\n-        self.suggestions.push(CodeSuggestion {\n+        self.push_suggestion(CodeSuggestion {\n             substitutions: vec![Substitution {\n                 parts: vec![SubstitutionPart { snippet: suggestion, span: sp }],\n             }],\n@@ -471,7 +491,7 @@ impl Diagnostic {\n             .into_iter()\n             .map(|snippet| Substitution { parts: vec![SubstitutionPart { snippet, span: sp }] })\n             .collect();\n-        self.suggestions.push(CodeSuggestion {\n+        self.push_suggestion(CodeSuggestion {\n             substitutions,\n             msg: msg.to_owned(),\n             style: SuggestionStyle::ShowCode,\n@@ -489,7 +509,7 @@ impl Diagnostic {\n         suggestions: impl Iterator<Item = Vec<(Span, String)>>,\n         applicability: Applicability,\n     ) -> &mut Self {\n-        self.suggestions.push(CodeSuggestion {\n+        self.push_suggestion(CodeSuggestion {\n             substitutions: suggestions\n                 .map(|sugg| Substitution {\n                     parts: sugg\n@@ -578,7 +598,7 @@ impl Diagnostic {\n         applicability: Applicability,\n         tool_metadata: Json,\n     ) {\n-        self.suggestions.push(CodeSuggestion {\n+        self.push_suggestion(CodeSuggestion {\n             substitutions: vec![],\n             msg: msg.to_owned(),\n             style: SuggestionStyle::CompletelyHidden,\n@@ -668,7 +688,7 @@ impl Diagnostic {\n         &Vec<(String, Style)>,\n         &Option<DiagnosticId>,\n         &MultiSpan,\n-        &Vec<CodeSuggestion>,\n+        &Result<Vec<CodeSuggestion>, SuggestionsDisabled>,\n         Option<&Vec<SubDiagnostic>>,\n     ) {\n         ("}, {"sha": "3c8751a7a3586850ee9839d08aa94126adc53730", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 44, "deletions": 138, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/25862ffc8d360b34dd8ec82a2f01750aaab976b7/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25862ffc8d360b34dd8ec82a2f01750aaab976b7/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=25862ffc8d360b34dd8ec82a2f01750aaab976b7", "patch": "@@ -15,19 +15,14 @@ use tracing::debug;\n /// extending `HandlerFlags`, accessed via `self.handler.flags`.\n #[must_use]\n #[derive(Clone)]\n-pub struct DiagnosticBuilder<'a>(Box<DiagnosticBuilderInner<'a>>);\n-\n-/// This is a large type, and often used as a return value, especially within\n-/// the frequently-used `PResult` type. In theory, return value optimization\n-/// (RVO) should avoid unnecessary copying. In practice, it does not (at the\n-/// time of writing). The split between `DiagnosticBuilder` and\n-/// `DiagnosticBuilderInner` exists to avoid many `memcpy` calls.\n-#[must_use]\n-#[derive(Clone)]\n-struct DiagnosticBuilderInner<'a> {\n+pub struct DiagnosticBuilder<'a> {\n     handler: &'a Handler,\n-    diagnostic: Diagnostic,\n-    allow_suggestions: bool,\n+\n+    /// `Diagnostic` is a large type, and `DiagnosticBuilder` is often used as a\n+    /// return value, especially within the frequently-used `PResult` type.\n+    /// In theory, return value optimization (RVO) should avoid unnecessary\n+    /// copying. In practice, it does not (at the time of writing).\n+    diagnostic: Box<Diagnostic>,\n }\n \n /// In general, the `DiagnosticBuilder` uses deref to allow access to\n@@ -60,7 +55,7 @@ macro_rules! forward {\n         $(#[$attrs])*\n         #[doc = concat!(\"See [`Diagnostic::\", stringify!($n), \"()`].\")]\n         pub fn $n(&mut self, $($name: $ty),*) -> &mut Self {\n-            self.0.diagnostic.$n($($name),*);\n+            self.diagnostic.$n($($name),*);\n             self\n         }\n     };\n@@ -77,7 +72,7 @@ macro_rules! forward {\n         $(#[$attrs])*\n         #[doc = concat!(\"See [`Diagnostic::\", stringify!($n), \"()`].\")]\n         pub fn $n<$($generic: $bound),*>(&mut self, $($name: $ty),*) -> &mut Self {\n-            self.0.diagnostic.$n($($name),*);\n+            self.diagnostic.$n($($name),*);\n             self\n         }\n     };\n@@ -87,20 +82,20 @@ impl<'a> Deref for DiagnosticBuilder<'a> {\n     type Target = Diagnostic;\n \n     fn deref(&self) -> &Diagnostic {\n-        &self.0.diagnostic\n+        &self.diagnostic\n     }\n }\n \n impl<'a> DerefMut for DiagnosticBuilder<'a> {\n     fn deref_mut(&mut self) -> &mut Diagnostic {\n-        &mut self.0.diagnostic\n+        &mut self.diagnostic\n     }\n }\n \n impl<'a> DiagnosticBuilder<'a> {\n     /// Emit the diagnostic.\n     pub fn emit(&mut self) {\n-        self.0.handler.emit_diagnostic(&self);\n+        self.handler.emit_diagnostic(&self);\n         self.cancel();\n     }\n \n@@ -130,19 +125,19 @@ impl<'a> DiagnosticBuilder<'a> {\n     /// Converts the builder to a `Diagnostic` for later emission,\n     /// unless handler has disabled such buffering.\n     pub fn into_diagnostic(mut self) -> Option<(Diagnostic, &'a Handler)> {\n-        if self.0.handler.flags.dont_buffer_diagnostics\n-            || self.0.handler.flags.treat_err_as_bug.is_some()\n+        if self.handler.flags.dont_buffer_diagnostics\n+            || self.handler.flags.treat_err_as_bug.is_some()\n         {\n             self.emit();\n             return None;\n         }\n \n-        let handler = self.0.handler;\n+        let handler = self.handler;\n \n         // We must use `Level::Cancelled` for `dummy` to avoid an ICE about an\n         // unused diagnostic.\n         let dummy = Diagnostic::new(Level::Cancelled, \"\");\n-        let diagnostic = std::mem::replace(&mut self.0.diagnostic, dummy);\n+        let diagnostic = std::mem::replace(&mut *self.diagnostic, dummy);\n \n         // Logging here is useful to help track down where in logs an error was\n         // actually emitted.\n@@ -169,7 +164,7 @@ impl<'a> DiagnosticBuilder<'a> {\n     /// locally in whichever way makes the most sense.\n     pub fn delay_as_bug(&mut self) {\n         self.level = Level::Bug;\n-        self.0.handler.delay_as_bug(self.0.diagnostic.clone());\n+        self.handler.delay_as_bug((*self.diagnostic).clone());\n         self.cancel();\n     }\n \n@@ -186,7 +181,7 @@ impl<'a> DiagnosticBuilder<'a> {\n     /// [\"primary span\"][`MultiSpan`]; only the `Span` supplied when creating the diagnostic is\n     /// primary.\n     pub fn span_label(&mut self, span: Span, label: impl Into<String>) -> &mut Self {\n-        self.0.diagnostic.span_label(span, label);\n+        self.diagnostic.span_label(span, label);\n         self\n     }\n \n@@ -199,7 +194,7 @@ impl<'a> DiagnosticBuilder<'a> {\n     ) -> &mut Self {\n         let label = label.as_ref();\n         for span in spans {\n-            self.0.diagnostic.span_label(span, label);\n+            self.diagnostic.span_label(span, label);\n         }\n         self\n     }\n@@ -244,164 +239,79 @@ impl<'a> DiagnosticBuilder<'a> {\n     ) -> &mut Self);\n     forward!(pub fn set_is_lint(&mut self,) -> &mut Self);\n \n-    /// See [`Diagnostic::multipart_suggestion()`].\n-    pub fn multipart_suggestion(\n+    forward!(pub fn disable_suggestions(&mut self,) -> &mut Self);\n+\n+    forward!(pub fn multipart_suggestion(\n         &mut self,\n         msg: &str,\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n-    ) -> &mut Self {\n-        if !self.0.allow_suggestions {\n-            return self;\n-        }\n-        self.0.diagnostic.multipart_suggestion(msg, suggestion, applicability);\n-        self\n-    }\n-\n-    /// See [`Diagnostic::multipart_suggestion()`].\n-    pub fn multipart_suggestion_verbose(\n+    ) -> &mut Self);\n+    forward!(pub fn multipart_suggestion_verbose(\n         &mut self,\n         msg: &str,\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n-    ) -> &mut Self {\n-        if !self.0.allow_suggestions {\n-            return self;\n-        }\n-        self.0.diagnostic.multipart_suggestion_verbose(msg, suggestion, applicability);\n-        self\n-    }\n-\n-    /// See [`Diagnostic::tool_only_multipart_suggestion()`].\n-    pub fn tool_only_multipart_suggestion(\n+    ) -> &mut Self);\n+    forward!(pub fn tool_only_multipart_suggestion(\n         &mut self,\n         msg: &str,\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n-    ) -> &mut Self {\n-        if !self.0.allow_suggestions {\n-            return self;\n-        }\n-        self.0.diagnostic.tool_only_multipart_suggestion(msg, suggestion, applicability);\n-        self\n-    }\n-\n-    /// See [`Diagnostic::span_suggestion()`].\n-    pub fn span_suggestion(\n+    ) -> &mut Self);\n+    forward!(pub fn span_suggestion(\n         &mut self,\n         sp: Span,\n         msg: &str,\n         suggestion: String,\n         applicability: Applicability,\n-    ) -> &mut Self {\n-        if !self.0.allow_suggestions {\n-            return self;\n-        }\n-        self.0.diagnostic.span_suggestion(sp, msg, suggestion, applicability);\n-        self\n-    }\n-\n-    /// See [`Diagnostic::span_suggestions()`].\n-    pub fn span_suggestions(\n+    ) -> &mut Self);\n+    forward!(pub fn span_suggestions(\n         &mut self,\n         sp: Span,\n         msg: &str,\n         suggestions: impl Iterator<Item = String>,\n         applicability: Applicability,\n-    ) -> &mut Self {\n-        if !self.0.allow_suggestions {\n-            return self;\n-        }\n-        self.0.diagnostic.span_suggestions(sp, msg, suggestions, applicability);\n-        self\n-    }\n-\n-    /// See [`Diagnostic::multipart_suggestions()`].\n-    pub fn multipart_suggestions(\n+    ) -> &mut Self);\n+    forward!(pub fn multipart_suggestions(\n         &mut self,\n         msg: &str,\n         suggestions: impl Iterator<Item = Vec<(Span, String)>>,\n         applicability: Applicability,\n-    ) -> &mut Self {\n-        if !self.0.allow_suggestions {\n-            return self;\n-        }\n-        self.0.diagnostic.multipart_suggestions(msg, suggestions, applicability);\n-        self\n-    }\n-\n-    /// See [`Diagnostic::span_suggestion_short()`].\n-    pub fn span_suggestion_short(\n+    ) -> &mut Self);\n+    forward!(pub fn span_suggestion_short(\n         &mut self,\n         sp: Span,\n         msg: &str,\n         suggestion: String,\n         applicability: Applicability,\n-    ) -> &mut Self {\n-        if !self.0.allow_suggestions {\n-            return self;\n-        }\n-        self.0.diagnostic.span_suggestion_short(sp, msg, suggestion, applicability);\n-        self\n-    }\n-\n-    /// See [`Diagnostic::span_suggestion_verbose()`].\n-    pub fn span_suggestion_verbose(\n+    ) -> &mut Self);\n+    forward!(pub fn span_suggestion_verbose(\n         &mut self,\n         sp: Span,\n         msg: &str,\n         suggestion: String,\n         applicability: Applicability,\n-    ) -> &mut Self {\n-        if !self.0.allow_suggestions {\n-            return self;\n-        }\n-        self.0.diagnostic.span_suggestion_verbose(sp, msg, suggestion, applicability);\n-        self\n-    }\n-\n-    /// See [`Diagnostic::span_suggestion_hidden()`].\n-    pub fn span_suggestion_hidden(\n+    ) -> &mut Self);\n+    forward!(pub fn span_suggestion_hidden(\n         &mut self,\n         sp: Span,\n         msg: &str,\n         suggestion: String,\n         applicability: Applicability,\n-    ) -> &mut Self {\n-        if !self.0.allow_suggestions {\n-            return self;\n-        }\n-        self.0.diagnostic.span_suggestion_hidden(sp, msg, suggestion, applicability);\n-        self\n-    }\n-\n-    /// See [`Diagnostic::tool_only_span_suggestion()`] for more information.\n-    pub fn tool_only_span_suggestion(\n+    ) -> &mut Self);\n+    forward!(pub fn tool_only_span_suggestion(\n         &mut self,\n         sp: Span,\n         msg: &str,\n         suggestion: String,\n         applicability: Applicability,\n-    ) -> &mut Self {\n-        if !self.0.allow_suggestions {\n-            return self;\n-        }\n-        self.0.diagnostic.tool_only_span_suggestion(sp, msg, suggestion, applicability);\n-        self\n-    }\n+    ) -> &mut Self);\n \n     forward!(pub fn set_primary_message<M: Into<String>>(&mut self, msg: M) -> &mut Self);\n     forward!(pub fn set_span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self);\n     forward!(pub fn code(&mut self, s: DiagnosticId) -> &mut Self);\n \n-    /// Allow attaching suggestions this diagnostic.\n-    /// If this is set to `false`, then any suggestions attached with the `span_suggestion_*`\n-    /// methods after this is set to `false` will be ignored.\n-    pub fn allow_suggestions(&mut self, allow: bool) -> &mut Self {\n-        self.0.allow_suggestions = allow;\n-        self\n-    }\n-\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`].\n     crate fn new(handler: &'a Handler, level: Level, message: &str) -> DiagnosticBuilder<'a> {\n@@ -424,17 +334,13 @@ impl<'a> DiagnosticBuilder<'a> {\n     /// diagnostic.\n     crate fn new_diagnostic(handler: &'a Handler, diagnostic: Diagnostic) -> DiagnosticBuilder<'a> {\n         debug!(\"Created new diagnostic\");\n-        DiagnosticBuilder(Box::new(DiagnosticBuilderInner {\n-            handler,\n-            diagnostic,\n-            allow_suggestions: true,\n-        }))\n+        DiagnosticBuilder { handler, diagnostic: Box::new(diagnostic) }\n     }\n }\n \n impl<'a> Debug for DiagnosticBuilder<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.0.diagnostic.fmt(f)\n+        self.diagnostic.fmt(f)\n     }\n }\n \n@@ -444,7 +350,7 @@ impl<'a> Drop for DiagnosticBuilder<'a> {\n     fn drop(&mut self) {\n         if !panicking() && !self.cancelled() {\n             let mut db = DiagnosticBuilder::new(\n-                self.0.handler,\n+                self.handler,\n                 Level::Bug,\n                 \"the following error was constructed but not emitted\",\n             );"}, {"sha": "f90f4d46a9a0b1cfe70796dc3a8881c88841f90d", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/25862ffc8d360b34dd8ec82a2f01750aaab976b7/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25862ffc8d360b34dd8ec82a2f01750aaab976b7/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=25862ffc8d360b34dd8ec82a2f01750aaab976b7", "patch": "@@ -227,7 +227,8 @@ pub trait Emitter {\n         diag: &'a Diagnostic,\n     ) -> (MultiSpan, &'a [CodeSuggestion]) {\n         let mut primary_span = diag.span.clone();\n-        if let Some((sugg, rest)) = diag.suggestions.split_first() {\n+        let suggestions = diag.suggestions.as_ref().map_or(&[][..], |suggestions| &suggestions[..]);\n+        if let Some((sugg, rest)) = suggestions.split_first() {\n             if rest.is_empty() &&\n                // ^ if there is only one suggestion\n                // don't display multi-suggestions as labels\n@@ -282,10 +283,10 @@ pub trait Emitter {\n                 // to be consistent. We could try to figure out if we can\n                 // make one (or the first one) inline, but that would give\n                 // undue importance to a semi-random suggestion\n-                (primary_span, &diag.suggestions)\n+                (primary_span, suggestions)\n             }\n         } else {\n-            (primary_span, &diag.suggestions)\n+            (primary_span, suggestions)\n         }\n     }\n "}, {"sha": "ff3478073d92baba96ccabd77598c820fb629fd5", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25862ffc8d360b34dd8ec82a2f01750aaab976b7/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25862ffc8d360b34dd8ec82a2f01750aaab976b7/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=25862ffc8d360b34dd8ec82a2f01750aaab976b7", "patch": "@@ -345,7 +345,7 @@ struct UnusedExterns<'a, 'b, 'c> {\n \n impl Diagnostic {\n     fn from_errors_diagnostic(diag: &crate::Diagnostic, je: &JsonEmitter) -> Diagnostic {\n-        let sugg = diag.suggestions.iter().map(|sugg| Diagnostic {\n+        let sugg = diag.suggestions.iter().flatten().map(|sugg| Diagnostic {\n             message: sugg.msg.clone(),\n             code: None,\n             level: \"help\","}, {"sha": "7582f317b85cfb0fb29b77c0a6c814a49bd4d3b8", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25862ffc8d360b34dd8ec82a2f01750aaab976b7/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25862ffc8d360b34dd8ec82a2f01750aaab976b7/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=25862ffc8d360b34dd8ec82a2f01750aaab976b7", "patch": "@@ -54,9 +54,11 @@ pub use snippet::Style;\n pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a>>;\n \n // `PResult` is used a lot. Make sure it doesn't unintentionally get bigger.\n-// (See also the comment on `DiagnosticBuilderInner`.)\n+// (See also the comment on `DiagnosticBuilder`'s `diagnostic` field.)\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(PResult<'_, bool>, 16);\n+rustc_data_structures::static_assert_size!(PResult<'_, ()>, 16);\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+rustc_data_structures::static_assert_size!(PResult<'_, bool>, 24);\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, Encodable, Decodable)]\n pub enum SuggestionStyle {"}, {"sha": "c6226c69f302020ec2cc11742041bfeada4925c4", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25862ffc8d360b34dd8ec82a2f01750aaab976b7/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25862ffc8d360b34dd8ec82a2f01750aaab976b7/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=25862ffc8d360b34dd8ec82a2f01750aaab976b7", "patch": "@@ -262,7 +262,7 @@ pub fn struct_lint_level<'s, 'd>(\n         if err.span.primary_spans().iter().any(|s| in_external_macro(sess, *s)) {\n             // Any suggestions made here are likely to be incorrect, so anything we\n             // emit shouldn't be automatically fixed by rustfix.\n-            err.allow_suggestions(false);\n+            err.disable_suggestions();\n \n             // If this is a future incompatible that is not an edition fixing lint\n             // it'll become a hard error, so we have to emit *something*. Also,"}, {"sha": "b99e44f2105caff9d1cbb60c14f33709394cfd62", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25862ffc8d360b34dd8ec82a2f01750aaab976b7/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25862ffc8d360b34dd8ec82a2f01750aaab976b7/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=25862ffc8d360b34dd8ec82a2f01750aaab976b7", "patch": "@@ -726,7 +726,10 @@ fn infer_placeholder_type<'a>(\n             if !ty.references_error() {\n                 // The parser provided a sub-optimal `HasPlaceholders` suggestion for the type.\n                 // We are typeck and have the real type, so remove that and suggest the actual type.\n-                err.suggestions.clear();\n+                // FIXME(eddyb) this looks like it should be functionality on `Diagnostic`.\n+                if let Ok(suggestions) = &mut err.suggestions {\n+                    suggestions.clear();\n+                }\n \n                 // Suggesting unnameable types won't help.\n                 let mut mk_nameable = MakeNameable::new(tcx);"}, {"sha": "7fc3778376cd0901336236bd614f945b514facdd", "filename": "src/tools/rustfmt/src/parse/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25862ffc8d360b34dd8ec82a2f01750aaab976b7/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25862ffc8d360b34dd8ec82a2f01750aaab976b7/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fsession.rs?ref=25862ffc8d360b34dd8ec82a2f01750aaab976b7", "patch": "@@ -315,7 +315,7 @@ mod tests {\n                 code: None,\n                 message: vec![],\n                 children: vec![],\n-                suggestions: vec![],\n+                suggestions: Ok(vec![]),\n                 span: span.unwrap_or_else(MultiSpan::new),\n                 sort_span: DUMMY_SP,\n                 is_lint: false,"}]}