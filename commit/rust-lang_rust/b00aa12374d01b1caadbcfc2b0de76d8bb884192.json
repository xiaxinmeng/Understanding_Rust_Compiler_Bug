{"sha": "b00aa12374d01b1caadbcfc2b0de76d8bb884192", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwMGFhMTIzNzRkMDFiMWNhYWRiY2ZjMmIwZGU3NmQ4YmI4ODQxOTI=", "commit": {"author": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-08-14T00:26:04Z"}, "committer": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-08-17T04:22:27Z"}, "message": "Crypto: Add tests for add_bytes_to_bits functions.", "tree": {"sha": "5cb750a6287e7d9a4d17a0a34cc645c56ee36b6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cb750a6287e7d9a4d17a0a34cc645c56ee36b6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b00aa12374d01b1caadbcfc2b0de76d8bb884192", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b00aa12374d01b1caadbcfc2b0de76d8bb884192", "html_url": "https://github.com/rust-lang/rust/commit/b00aa12374d01b1caadbcfc2b0de76d8bb884192", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b00aa12374d01b1caadbcfc2b0de76d8bb884192/comments", "author": null, "committer": null, "parents": [{"sha": "6386f887a7e7ac1581075ba296edf1a66f375f08", "url": "https://api.github.com/repos/rust-lang/rust/commits/6386f887a7e7ac1581075ba296edf1a66f375f08", "html_url": "https://github.com/rust-lang/rust/commit/6386f887a7e7ac1581075ba296edf1a66f375f08"}], "stats": {"total": 47, "additions": 47, "deletions": 0}, "files": [{"sha": "2bca346061a13b796a373682ac9f57f13a8aa282", "filename": "src/libextra/crypto/cryptoutil.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b00aa12374d01b1caadbcfc2b0de76d8bb884192/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00aa12374d01b1caadbcfc2b0de76d8bb884192/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs?ref=b00aa12374d01b1caadbcfc2b0de76d8bb884192", "patch": "@@ -351,6 +351,7 @@ mod test {\n     use std::rand::RngUtil;\n     use std::vec;\n \n+    use cryptoutil::{add_bytes_to_bits, add_bytes_to_bits_tuple};\n     use digest::Digest;\n \n     /// Feed 1,000,000 'a's into the digest with varying input sizes and check that the result is\n@@ -375,4 +376,50 @@ mod test {\n \n         assert!(expected == result_str);\n     }\n+\n+    // A normal addition - no overflow occurs\n+    #[test]\n+    fn test_add_bytes_to_bits_ok() {\n+        assert!(add_bytes_to_bits::<u64>(100, 10) == 180);\n+    }\n+\n+    // A simple failure case - adding 1 to the max value\n+    #[test]\n+    #[should_fail]\n+    fn test_add_bytes_to_bits_overflow() {\n+        add_bytes_to_bits::<u64>(Bounded::max_value(), 1);\n+    }\n+\n+    // A normal addition - no overflow occurs (fast path)\n+    #[test]\n+    fn test_add_bytes_to_bits_tuple_ok() {\n+        assert!(add_bytes_to_bits_tuple::<u64>((5, 100), 10) == (5, 180));\n+    }\n+\n+    // The low order value overflows into the high order value\n+    #[test]\n+    fn test_add_bytes_to_bits_tuple_ok2() {\n+        assert!(add_bytes_to_bits_tuple::<u64>((5, Bounded::max_value()), 1) == (6, 7));\n+    }\n+\n+    // The value to add is too large to be converted into bits without overflowing its type\n+    #[test]\n+    fn test_add_bytes_to_bits_tuple_ok3() {\n+        assert!(add_bytes_to_bits_tuple::<u64>((5, 0), 0x4000000000000001) == (7, 8));\n+    }\n+\n+    // A simple failure case - adding 1 to the max value\n+    #[test]\n+    #[should_fail]\n+    fn test_add_bytes_to_bits_tuple_overflow() {\n+        add_bytes_to_bits_tuple::<u64>((Bounded::max_value(), Bounded::max_value()), 1);\n+    }\n+\n+    // The value to add is too large to convert to bytes without overflowing its type, but the high\n+    // order value from this conversion overflows when added to the existing high order value\n+    #[test]\n+    #[should_fail]\n+    fn test_add_bytes_to_bits_tuple_overflow2() {\n+        add_bytes_to_bits_tuple::<u64>((Bounded::max_value::<u64>() - 1, 0), 0x8000000000000000);\n+    }\n }"}]}