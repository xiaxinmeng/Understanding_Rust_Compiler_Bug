{"sha": "66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ZWE0NzFmOWQ0YTE0ZTVhZjcyZTg2ZWU3YjEyZWQ5ZDlmYTNjYTU=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-12-13T05:15:19Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-12-25T06:10:15Z"}, "message": "Handle more specific case E0222", "tree": {"sha": "79a5b8c8da979a43daffd60cd0bcd68e625e8280", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79a5b8c8da979a43daffd60cd0bcd68e625e8280"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5", "html_url": "https://github.com/rust-lang/rust/commit/66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e74f630546676e0a40e8f5debac531a8e44912a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e74f630546676e0a40e8f5debac531a8e44912a", "html_url": "https://github.com/rust-lang/rust/commit/8e74f630546676e0a40e8f5debac531a8e44912a"}], "stats": {"total": 227, "additions": 167, "deletions": 60}, "files": [{"sha": "18d58d9d19e2c0ba9e512e8d8dc7594b6d1a3a93", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5", "patch": "@@ -116,6 +116,7 @@ E0211: include_str!(\"./error_codes/E0211.md\"),\n E0214: include_str!(\"./error_codes/E0214.md\"),\n E0220: include_str!(\"./error_codes/E0220.md\"),\n E0221: include_str!(\"./error_codes/E0221.md\"),\n+E0222: include_str!(\"./error_codes/E0222.md\"),\n E0223: include_str!(\"./error_codes/E0223.md\"),\n E0225: include_str!(\"./error_codes/E0225.md\"),\n E0229: include_str!(\"./error_codes/E0229.md\"),\n@@ -457,8 +458,6 @@ E0745: include_str!(\"./error_codes/E0745.md\"),\n //  E0217, // ambiguous associated type, defined in multiple supertraits\n //  E0218, // no associated type defined\n //  E0219, // associated type defined in higher-ranked supertrait\n-//  E0222, // Error code E0045 (variadic function must have C or cdecl calling\n-           // convention) duplicate\n     E0224, // at least one non-builtin train is required for an object type\n     E0226, // only a single explicit lifetime bound is permitted\n     E0227, // ambiguous lifetime bound, explicit lifetime bound required"}, {"sha": "66b6c4d712b70df473e1bfe6b425fdca3e77f070", "filename": "src/librustc_error_codes/error_codes/E0222.md", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5/src%2Flibrustc_error_codes%2Ferror_codes%2FE0222.md", "raw_url": "https://github.com/rust-lang/rust/raw/66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5/src%2Flibrustc_error_codes%2Ferror_codes%2FE0222.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0222.md?ref=66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5", "patch": "@@ -0,0 +1,51 @@\n+An attempt was made to constrain an associated type.\n+For example:\n+\n+```compile_fail,E0222\n+pub trait Vehicle {\n+    type Color;\n+}\n+\n+pub trait Box {\n+    type Color;\n+}\n+\n+pub trait BoxCar : Box + Vehicle {}\n+\n+fn dent_object<COLOR>(c: dyn BoxCar<Color=COLOR>) {} // Invalid constraint\n+```\n+\n+In this example, `BoxCar` has two super-traits: `Vehicle` and `Box`. Both of\n+these traits define an associated type `Color`. `BoxCar` inherits two types\n+with that name from both super-traits. Because of this, we need to use the\n+fully qualified path syntax to refer to the appropriate `Color` associated\n+type, either `<BoxCar as Vehicle>::Color` or `<BoxCar as Box>::Color`, but this\n+syntax is not allowed to be used in a function signature.\n+\n+In order to encode this kind of constraint, a `where` clause and a new type\n+parameter are needed:\n+\n+```\n+pub trait Vehicle {\n+    type Color;\n+}\n+\n+pub trait Box {\n+    type Color;\n+}\n+\n+pub trait BoxCar : Box + Vehicle {}\n+\n+// Introduce a new `CAR` type parameter\n+fn foo<CAR, COLOR>(\n+    c: CAR,\n+) where\n+    // Bind the type parameter `CAR` to the trait `BoxCar`\n+    CAR: BoxCar,\n+    // Further restrict `<BoxCar as Vehicle>::Color` to be the same as the\n+    // type parameter `COLOR`\n+    CAR: Vehicle<Color = COLOR>,\n+    // We can also simultaneously restrict the other trait's associated type\n+    CAR: Box<Color = COLOR>\n+{}\n+```"}, {"sha": "d89db403b15f75d7b3ab8a2e3b2f5098773f1832", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5", "patch": "@@ -804,6 +804,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         predicate.span,\n                         \"equality constraints are not yet supported in `where` clauses\",\n                     )\n+                    .span_label(predicate.span, \"not supported\")\n                     .note(\n                         \"for more information, see https://github.com/rust-lang/rust/issues/20041\",\n                     )"}, {"sha": "f9854aee9790dd5ead0ec5b6efd8d31813b4866b", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 85, "deletions": 33, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5", "patch": "@@ -1267,7 +1267,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let candidate =\n             if self.trait_defines_associated_type_named(trait_ref.def_id(), binding.item_name) {\n                 // Simple case: X is defined in the current trait.\n-                Ok(trait_ref)\n+                trait_ref\n             } else {\n                 // Otherwise, we have to walk through the supertraits to find\n                 // those that do.\n@@ -1276,8 +1276,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     &trait_ref.print_only_trait_path().to_string(),\n                     binding.item_name,\n                     path_span,\n-                )\n-            }?;\n+                    match binding.kind {\n+                        ConvertedBindingKind::Equality(ty) => Some(ty.to_string()),\n+                        _ => None,\n+                    },\n+                )?\n+            };\n \n         let (assoc_ident, def_scope) =\n             tcx.adjust_ident_and_get_scope(binding.item_name, candidate.def_id(), hir_ref_id);\n@@ -1626,20 +1630,31 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n         let mut suggestions_len = suggestions.len();\n         if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(sugg_span) {\n-            if potential_assoc_types.is_empty() && trait_bounds.len() == 1 &&\n+            let assoc_types: Vec<String> = associated_types\n+                .iter()\n+                .map(|item_def_id| {\n+                    let assoc_item = tcx.associated_item(*item_def_id);\n+                    format!(\"{} = Type\", assoc_item.ident)\n+                })\n+                .collect();\n+            let dedup = assoc_types.clone().drain(..).collect::<FxHashSet<_>>();\n+\n+            if dedup.len() != assoc_types.len() && trait_bounds.len() == 1 {\n+                // If there are duplicates associated type names and a single trait bound do not\n+                // use structured suggestion, it means that there are multiple super-traits with\n+                // the same associated type name.\n+                err.help(\n+                    \"consider introducing a new type parameter, adding `where` constraints \\\n+                          using the fully-qualified path to the associated type\",\n+                );\n+            } else if dedup.len() == assoc_types.len() &&\n+                potential_assoc_types.is_empty() &&\n+                trait_bounds.len() == 1 &&\n                 // Do not attempt to suggest when we don't know which path segment needs the\n                 // type parameter set.\n                 trait_bounds[0].trait_ref.path.segments.len() == 1\n             {\n-                debug!(\"path segments {:?}\", trait_bounds[0].trait_ref.path.segments);\n                 applicability = Applicability::HasPlaceholders;\n-                let assoc_types: Vec<String> = associated_types\n-                    .iter()\n-                    .map(|item_def_id| {\n-                        let assoc_item = tcx.associated_item(*item_def_id);\n-                        format!(\"{} = Type\", assoc_item.ident)\n-                    })\n-                    .collect();\n                 let sugg = assoc_types.join(\", \");\n                 if snippet.ends_with('>') {\n                     // The user wrote `Trait<'a>` or similar and we don't have a type we can\n@@ -1666,7 +1681,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 .collect::<Vec<_>>()\n                 .join(\", \");\n             err.span_label(\n-                span,\n+                sugg_span,\n                 format!(\n                     \"associated type{} {} must be specified\",\n                     pluralize!(associated_types.len()),\n@@ -1743,15 +1758,19 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             &param_name.as_str(),\n             assoc_name,\n             span,\n+            None,\n         )\n     }\n \n+    // Checks that `bounds` contains exactly one element and reports appropriate\n+    // errors otherwise.\n     fn one_bound_for_assoc_type<I>(\n         &self,\n         all_candidates: impl Fn() -> I,\n         ty_param_name: &str,\n         assoc_name: ast::Ident,\n         span: Span,\n+        is_equality: Option<String>,\n     ) -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n     where\n         I: Iterator<Item = ty::PolyTraitRef<'tcx>>,\n@@ -1778,16 +1797,29 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             debug!(\"one_bound_for_assoc_type: bound2 = {:?}\", bound2);\n \n             let bounds = iter::once(bound).chain(iter::once(bound2)).chain(matching_candidates);\n-            let mut err = struct_span_err!(\n-                self.tcx().sess,\n-                span,\n-                E0221,\n-                \"ambiguous associated type `{}` in bounds of `{}`\",\n-                assoc_name,\n-                ty_param_name\n-            );\n+            let mut err = if is_equality.is_some() {\n+                // More specific Error Index entry.\n+                struct_span_err!(\n+                    self.tcx().sess,\n+                    span,\n+                    E0222,\n+                    \"ambiguous associated type `{}` in bounds of `{}`\",\n+                    assoc_name,\n+                    ty_param_name\n+                )\n+            } else {\n+                struct_span_err!(\n+                    self.tcx().sess,\n+                    span,\n+                    E0221,\n+                    \"ambiguous associated type `{}` in bounds of `{}`\",\n+                    assoc_name,\n+                    ty_param_name\n+                )\n+            };\n             err.span_label(span, format!(\"ambiguous associated type `{}`\", assoc_name));\n \n+            let mut where_bounds = vec![];\n             for bound in bounds {\n                 let bound_span = self\n                     .tcx()\n@@ -1807,17 +1839,26 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             bound.print_only_trait_path(),\n                         ),\n                     );\n-                    err.span_suggestion(\n-                        span,\n-                        \"use fully qualified syntax to disambiguate\",\n-                        format!(\n-                            \"<{} as {}>::{}\",\n-                            ty_param_name,\n-                            bound.print_only_trait_path(),\n-                            assoc_name,\n-                        ),\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                    if let Some(constraint) = &is_equality {\n+                        where_bounds.push(format!(\n+                            \"        T: {trait}::{assoc} = {constraint}\",\n+                            trait=bound.print_only_trait_path(),\n+                            assoc=assoc_name,\n+                            constraint=constraint,\n+                        ));\n+                    } else {\n+                        err.span_suggestion(\n+                            span,\n+                            \"use fully qualified syntax to disambiguate\",\n+                            format!(\n+                                \"<{} as {}>::{}\",\n+                                ty_param_name,\n+                                bound.print_only_trait_path(),\n+                                assoc_name,\n+                            ),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n                 } else {\n                     err.note(&format!(\n                         \"associated type `{}` could derive from `{}`\",\n@@ -1826,9 +1867,19 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     ));\n                 }\n             }\n+            if !where_bounds.is_empty() {\n+                err.help(&format!(\n+                    \"consider introducing a new type parameter `T` and adding `where` constraints:\\\n+                     \\n    where\\n        T: {},\\n{}\",\n+                    ty_param_name,\n+                    where_bounds.join(\",\\n\"),\n+                ));\n+            }\n             err.emit();\n+            if !where_bounds.is_empty() {\n+                return Err(ErrorReported);\n+            }\n         }\n-\n         return Ok(bound);\n     }\n \n@@ -1933,6 +1984,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     \"Self\",\n                     assoc_ident,\n                     span,\n+                    None,\n                 )?\n             }\n             (&ty::Param(_), Res::SelfTy(Some(param_did), None))"}, {"sha": "77ed784f1fa74be810b10b7cd32132e889576ba3", "filename": "src/test/ui/associated-type/associated-type-projection-from-multiple-supertraits.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-multiple-supertraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-multiple-supertraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-multiple-supertraits.rs?ref=66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5", "patch": "@@ -20,11 +20,9 @@ fn dent<C:BoxCar>(c: C, color: C::Color) {\n     //~^ ERROR ambiguous associated type `Color` in bounds of `C`\n }\n \n-// FIXME: add error code to detect this case and explain that you'll want the approach in\n-// `dent_object_3` of using a new type param and relying on the `where` clauses.\n fn dent_object<COLOR>(c: dyn BoxCar<Color=COLOR>) {\n     //~^ ERROR ambiguous associated type\n-    //~| ERROR the value of the associated type `Color` (from trait `Vehicle`) must be specified\n+    //~| ERROR the value of the associated types `Color` (from trait `Vehicle`), `Color` (from\n }\n \n fn paint<C:BoxCar>(c: C, d: C::Color) {"}, {"sha": "aa46e5d077f3e047e7c801cf442c60119b996027", "filename": "src/test/ui/associated-type/associated-type-projection-from-multiple-supertraits.stderr", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-multiple-supertraits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-multiple-supertraits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-multiple-supertraits.stderr?ref=66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5", "patch": "@@ -1,8 +1,10 @@\n-error: equality constraints are not yet supported in where clauses (see #20041)\n-  --> $DIR/associated-type-projection-from-multiple-supertraits.rs:34:46\n+error: equality constraints are not yet supported in where clauses\n+  --> $DIR/associated-type-projection-from-multiple-supertraits.rs:32:46\n    |\n LL | fn dent_object_2<COLOR>(c: dyn BoxCar) where <dyn BoxCar as Vehicle>::Color = COLOR {\n-   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not supported\n+   |\n+   = note: for more information, see #20041\n \n error[E0221]: ambiguous associated type `Color` in bounds of `C`\n   --> $DIR/associated-type-projection-from-multiple-supertraits.rs:19:32\n@@ -25,8 +27,8 @@ help: use fully qualified syntax to disambiguate\n LL | fn dent<C:BoxCar>(c: C, color: <C as Vehicle>::Color) {\n    |                                ^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0221]: ambiguous associated type `Color` in bounds of `BoxCar`\n-  --> $DIR/associated-type-projection-from-multiple-supertraits.rs:25:30\n+error[E0222]: ambiguous associated type `Color` in bounds of `BoxCar`\n+  --> $DIR/associated-type-projection-from-multiple-supertraits.rs:23:30\n    |\n LL |     type Color;\n    |     ----------- ambiguous `Color` from `Vehicle`\n@@ -37,26 +39,28 @@ LL |     type Color;\n LL | fn dent_object<COLOR>(c: dyn BoxCar<Color=COLOR>) {\n    |                              ^^^^^^^^^^^^^^^^^^^ ambiguous associated type `Color`\n    |\n-help: use fully qualified syntax to disambiguate\n-   |\n-LL | fn dent_object<COLOR>(c: dyn <BoxCar as Box>::Color) {\n-   |                              ^^^^^^^^^^^^^^^^^^^^^^\n-help: use fully qualified syntax to disambiguate\n-   |\n-LL | fn dent_object<COLOR>(c: dyn <BoxCar as Vehicle>::Color) {\n-   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: consider introducing a new type parameter `T` and adding `where` constraints:\n+               where\n+                   T: BoxCar,\n+                   T: Box::Color = COLOR,\n+                   T: Vehicle::Color = COLOR\n \n-error[E0191]: the value of the associated type `Color` (from trait `Vehicle`) must be specified\n-  --> $DIR/associated-type-projection-from-multiple-supertraits.rs:25:30\n+error[E0191]: the value of the associated types `Color` (from trait `Vehicle`), `Color` (from trait `Box`) must be specified\n+  --> $DIR/associated-type-projection-from-multiple-supertraits.rs:23:30\n    |\n LL |     type Color;\n    |     ----------- `Color` defined here\n ...\n+LL |     type Color;\n+   |     ----------- `Color` defined here\n+...\n LL | fn dent_object<COLOR>(c: dyn BoxCar<Color=COLOR>) {\n-   |                              ^^^^^^^^^^^^^^^^^^^ help: specify the associated type: `BoxCar<Color=COLOR, Color = Type>`\n+   |                              ^^^^^^^^^^^^^^^^^^^ associated types `Color`, `Color` must be specified\n+   |\n+   = help: consider introducing a new type parameter, adding `where` constraints using the fully-qualified path to the associated type\n \n error[E0221]: ambiguous associated type `Color` in bounds of `C`\n-  --> $DIR/associated-type-projection-from-multiple-supertraits.rs:30:29\n+  --> $DIR/associated-type-projection-from-multiple-supertraits.rs:28:29\n    |\n LL |     type Color;\n    |     ----------- ambiguous `Color` from `Vehicle`\n@@ -77,7 +81,7 @@ LL | fn paint<C:BoxCar>(c: C, d: <C as Vehicle>::Color) {\n    |                             ^^^^^^^^^^^^^^^^^^^^^\n \n error[E0191]: the value of the associated types `Color` (from trait `Vehicle`), `Color` (from trait `Box`) must be specified\n-  --> $DIR/associated-type-projection-from-multiple-supertraits.rs:34:32\n+  --> $DIR/associated-type-projection-from-multiple-supertraits.rs:32:32\n    |\n LL |     type Color;\n    |     ----------- `Color` defined here\n@@ -86,9 +90,11 @@ LL |     type Color;\n    |     ----------- `Color` defined here\n ...\n LL | fn dent_object_2<COLOR>(c: dyn BoxCar) where <dyn BoxCar as Vehicle>::Color = COLOR {\n-   |                                ^^^^^^ help: specify the associated types: `BoxCar<Color = Type, Color = Type>`\n+   |                                ^^^^^^ associated types `Color`, `Color` must be specified\n+   |\n+   = help: consider introducing a new type parameter, adding `where` constraints using the fully-qualified path to the associated type\n \n error: aborting due to 6 previous errors\n \n-Some errors have detailed explanations: E0191, E0221.\n+Some errors have detailed explanations: E0191, E0221, E0222.\n For more information about an error, try `rustc --explain E0191`."}, {"sha": "54d6ad6a13696829eb917f7640a2cac104f1dea3", "filename": "src/test/ui/where-clauses/where-equality-constraints.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-equality-constraints.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-equality-constraints.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-equality-constraints.stderr?ref=66ea471f9d4a14e5af72e86ee7b12ed9d9fa3ca5", "patch": "@@ -2,15 +2,15 @@ error: equality constraints are not yet supported in `where` clauses\n   --> $DIR/where-equality-constraints.rs:1:14\n    |\n LL | fn f() where u8 = u16 {}\n-   |              ^^^^^^^^\n+   |              ^^^^^^^^ not supported\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/20041\n \n error: equality constraints are not yet supported in `where` clauses\n   --> $DIR/where-equality-constraints.rs:3:14\n    |\n LL | fn g() where for<'a> &'static (u8,) == u16, {}\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not supported\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/20041\n "}]}