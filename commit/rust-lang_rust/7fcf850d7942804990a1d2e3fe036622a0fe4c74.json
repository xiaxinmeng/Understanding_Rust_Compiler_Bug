{"sha": "7fcf850d7942804990a1d2e3fe036622a0fe4c74", "node_id": "C_kwDOAAsO6NoAKDdmY2Y4NTBkNzk0MjgwNDk5MGExZDJlM2ZlMDM2NjIyYTBmZTRjNzQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-23T18:55:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-23T18:55:40Z"}, "message": "Auto merge of #103137 - dtolnay:readdir, r=Mark-Simulacrum\n\nEliminate 280-byte memset from ReadDir iterator\n\nThis guy:\n\nhttps://github.com/rust-lang/rust/blob/1536ab1b383f21b38f8d49230a2aecc51daffa3d/library/std/src/sys/unix/fs.rs#L589\n\nIt turns out `libc::dirent64` is quite big&mdash;https://docs.rs/libc/0.2.135/libc/struct.dirent64.html. In #103135 this memset accounted for 0.9% of the runtime of iterating a big directory.\n\nAlmost none of the big zeroed value is ever used. We memcpy a tiny prefix (19 bytes) into it, and then read just 9 bytes (`d_ino` and `d_type`) back out. We can read exactly those 9 bytes we need directly from the original entry_ptr instead.\n\n## History\n\nThis code got added in #93459 and tweaked in #94272 and #94750.\n\nPrior to #93459, there was no memset but a full 280 bytes were being copied from the entry_ptr.\n\n<table><tr><td>copy 280 bytes</td></tr></table>\n\nThis was not legal because not all of those bytes might be initialized, or even allocated, depending on the length of the directory entry's name, leading to a segfault. That PR fixed the segfault by creating a new zeroed dirent64 and copying just the guaranteed initialized prefix into it.\n\n<table><tr><td>memset 280 bytes</td><td>copy 19 bytes</td></tr></table>\n\nHowever this was still buggy because it used `addr_of!((*entry_ptr).d_name)`, which is considered UB by Miri in the case that the full extent of entry_ptr is not in bounds of the same allocation. (Arguably this shouldn't be a requirement, but here we are.)\n\nThe UB got fixed by #94272 by replacing `addr_of` with some pointer manipulation based on `offset_from`, but still fundamentally the same operation.\n\n<table><tr><td>memset 280 bytes</td><td>copy 19 bytes</td></tr></table>\n\nThen #94750 noticed that only 9 of those 19 bytes were even being used, so we could pick out only those 9 to put in the ReadDir value.\n\n<table><tr><td>memset 280 bytes</td><td>copy 19 bytes</td><td>copy 9 bytes</td></tr></table>\n\nAfter my PR we just grab the 9 needed bytes directly from entry_ptr.\n\n<table><tr><td>copy 9 bytes</td></tr></table>\n\nThe resulting code is more complex but I believe still worthwhile to land for the following reason. This is an extremely straightforward thing to accomplish in C and clearly libc assumes that; literally just `entry_ptr->d_name`. The extra work in comparison to accomplish it in Rust is not an example of any actual safety being provided by Rust. I believe it's useful to have uncovered that and think about what could be done in the standard library or language to support this obvious operation better.\n\n## References\n\n- https://man7.org/linux/man-pages/man3/readdir.3.html", "tree": {"sha": "40dad5a3c248179f86456d39052dcbb448f86681", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40dad5a3c248179f86456d39052dcbb448f86681"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7fcf850d7942804990a1d2e3fe036622a0fe4c74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7fcf850d7942804990a1d2e3fe036622a0fe4c74", "html_url": "https://github.com/rust-lang/rust/commit/7fcf850d7942804990a1d2e3fe036622a0fe4c74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7fcf850d7942804990a1d2e3fe036622a0fe4c74/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ca6777c014813e3bdb98d155562fc3d111d86dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ca6777c014813e3bdb98d155562fc3d111d86dd", "html_url": "https://github.com/rust-lang/rust/commit/1ca6777c014813e3bdb98d155562fc3d111d86dd"}, {"sha": "0bb6eb15266b8476138860352d049da786f890f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bb6eb15266b8476138860352d049da786f890f5", "html_url": "https://github.com/rust-lang/rust/commit/0bb6eb15266b8476138860352d049da786f890f5"}], "stats": {"total": 85, "additions": 65, "deletions": 20}, "files": [{"sha": "e22b2f3340af08109d0c63086f8b37fadf9210bf", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 65, "deletions": 20, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/7fcf850d7942804990a1d2e3fe036622a0fe4c74/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fcf850d7942804990a1d2e3fe036622a0fe4c74/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=7fcf850d7942804990a1d2e3fe036622a0fe4c74", "patch": "@@ -4,6 +4,15 @@ use crate::ffi::{CStr, OsStr, OsString};\n use crate::fmt;\n use crate::io::{self, BorrowedCursor, Error, IoSlice, IoSliceMut, SeekFrom};\n use crate::mem;\n+#[cfg(any(\n+    target_os = \"android\",\n+    target_os = \"linux\",\n+    target_os = \"solaris\",\n+    target_os = \"fuchsia\",\n+    target_os = \"redox\",\n+    target_os = \"illumos\"\n+))]\n+use crate::mem::MaybeUninit;\n use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd};\n use crate::path::{Path, PathBuf};\n use crate::ptr;\n@@ -584,33 +593,69 @@ impl Iterator for ReadDir {\n                     };\n                 }\n \n-                // Only d_reclen bytes of *entry_ptr are valid, so we can't just copy the\n-                // whole thing (#93384).  Instead, copy everything except the name.\n-                let mut copy: dirent64 = mem::zeroed();\n-                // Can't dereference entry_ptr, so use the local entry to get\n-                // offsetof(struct dirent, d_name)\n-                let copy_bytes = &mut copy as *mut _ as *mut u8;\n-                let copy_name = &mut copy.d_name as *mut _ as *mut u8;\n-                let name_offset = copy_name.offset_from(copy_bytes) as usize;\n-                let entry_bytes = entry_ptr as *const u8;\n-                let entry_name = entry_bytes.add(name_offset);\n-                ptr::copy_nonoverlapping(entry_bytes, copy_bytes, name_offset);\n+                // The dirent64 struct is a weird imaginary thing that isn't ever supposed\n+                // to be worked with by value. Its trailing d_name field is declared\n+                // variously as [c_char; 256] or [c_char; 1] on different systems but\n+                // either way that size is meaningless; only the offset of d_name is\n+                // meaningful. The dirent64 pointers that libc returns from readdir64 are\n+                // allowed to point to allocations smaller _or_ LARGER than implied by the\n+                // definition of the struct.\n+                //\n+                // As such, we need to be even more careful with dirent64 than if its\n+                // contents were \"simply\" partially initialized data.\n+                //\n+                // Like for uninitialized contents, converting entry_ptr to `&dirent64`\n+                // would not be legal. However, unique to dirent64 is that we don't even\n+                // get to use `addr_of!((*entry_ptr).d_name)` because that operation\n+                // requires the full extent of *entry_ptr to be in bounds of the same\n+                // allocation, which is not necessarily the case here.\n+                //\n+                // Absent any other way to obtain a pointer to `(*entry_ptr).d_name`\n+                // legally in Rust analogously to how it would be done in C, we instead\n+                // need to make our own non-libc allocation that conforms to the weird\n+                // imaginary definition of dirent64, and use that for a field offset\n+                // computation.\n+                macro_rules! offset_ptr {\n+                    ($entry_ptr:expr, $field:ident) => {{\n+                        const OFFSET: isize = {\n+                            let delusion = MaybeUninit::<dirent64>::uninit();\n+                            let entry_ptr = delusion.as_ptr();\n+                            unsafe {\n+                                ptr::addr_of!((*entry_ptr).$field)\n+                                    .cast::<u8>()\n+                                    .offset_from(entry_ptr.cast::<u8>())\n+                            }\n+                        };\n+                        if true {\n+                            // Cast to the same type determined by the else branch.\n+                            $entry_ptr.byte_offset(OFFSET).cast::<_>()\n+                        } else {\n+                            #[allow(deref_nullptr)]\n+                            {\n+                                ptr::addr_of!((*ptr::null::<dirent64>()).$field)\n+                            }\n+                        }\n+                    }};\n+                }\n+\n+                // d_name is guaranteed to be null-terminated.\n+                let name = CStr::from_ptr(offset_ptr!(entry_ptr, d_name).cast());\n+                let name_bytes = name.to_bytes();\n+                if name_bytes == b\".\" || name_bytes == b\"..\" {\n+                    continue;\n+                }\n \n                 let entry = dirent64_min {\n-                    d_ino: copy.d_ino as u64,\n+                    d_ino: *offset_ptr!(entry_ptr, d_ino) as u64,\n                     #[cfg(not(any(target_os = \"solaris\", target_os = \"illumos\")))]\n-                    d_type: copy.d_type as u8,\n+                    d_type: *offset_ptr!(entry_ptr, d_type) as u8,\n                 };\n \n-                let ret = DirEntry {\n+                return Some(Ok(DirEntry {\n                     entry,\n-                    // d_name is guaranteed to be null-terminated.\n-                    name: CStr::from_ptr(entry_name as *const _).to_owned(),\n+                    name: name.to_owned(),\n                     dir: Arc::clone(&self.inner),\n-                };\n-                if ret.name_bytes() != b\".\" && ret.name_bytes() != b\"..\" {\n-                    return Some(Ok(ret));\n-                }\n+                }));\n             }\n         }\n     }"}]}