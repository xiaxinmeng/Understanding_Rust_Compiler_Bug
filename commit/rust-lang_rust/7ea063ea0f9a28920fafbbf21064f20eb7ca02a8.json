{"sha": "7ea063ea0f9a28920fafbbf21064f20eb7ca02a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlYTA2M2VhMGY5YTI4OTIwZmFmYmJmMjEwNjRmMjBlYjdjYTAyYTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-23T04:41:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-23T04:41:29Z"}, "message": "auto merge of #11294 : alexcrichton/rust/native-timer, r=brson\n\nCommit messages have the fun details\r\n\r\nCloses #10925", "tree": {"sha": "429ddb0b6f5287ee3dbe962261f68c09d910db42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/429ddb0b6f5287ee3dbe962261f68c09d910db42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8", "html_url": "https://github.com/rust-lang/rust/commit/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fce792249e72a181f2ad52413b25b1db643c371f", "url": "https://api.github.com/repos/rust-lang/rust/commits/fce792249e72a181f2ad52413b25b1db643c371f", "html_url": "https://github.com/rust-lang/rust/commit/fce792249e72a181f2ad52413b25b1db643c371f"}, {"sha": "b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5", "html_url": "https://github.com/rust-lang/rust/commit/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5"}], "stats": {"total": 1266, "additions": 1236, "deletions": 30}, "files": [{"sha": "b07e4271ee448f69a70c110e2a95641e134b2254", "filename": "src/libnative/bookkeeping.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8/src%2Flibnative%2Fbookkeeping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8/src%2Flibnative%2Fbookkeeping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fbookkeeping.rs?ref=7ea063ea0f9a28920fafbbf21064f20eb7ca02a8", "patch": "@@ -45,5 +45,6 @@ pub fn wait_for_other_tasks() {\n             TASK_LOCK.wait();\n         }\n         TASK_LOCK.unlock();\n+        TASK_LOCK.destroy();\n     }\n }"}, {"sha": "f3aca7820a50582124436b685acd3836853f62ae", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=7ea063ea0f9a28920fafbbf21064f20eb7ca02a8", "patch": "@@ -46,6 +46,22 @@ pub mod file;\n pub mod process;\n pub mod net;\n \n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+#[path = \"timer_other.rs\"]\n+pub mod timer;\n+\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"android\")]\n+#[path = \"timer_timerfd.rs\"]\n+pub mod timer;\n+\n+#[cfg(target_os = \"win32\")]\n+#[path = \"timer_win32.rs\"]\n+pub mod timer;\n+\n+mod timer_helper;\n+\n type IoResult<T> = Result<T, IoError>;\n \n fn unimpl() -> IoError {\n@@ -249,7 +265,7 @@ impl rtio::IoFactory for IoFactory {\n \n     // misc\n     fn timer_init(&mut self) -> IoResult<~RtioTimer> {\n-        Err(unimpl())\n+        timer::Timer::new().map(|t| ~t as ~RtioTimer)\n     }\n     fn spawn(&mut self, config: ProcessConfig)\n             -> IoResult<(~RtioProcess, ~[Option<~RtioPipe>])> {"}, {"sha": "3c20d073f2913306532ebbb5ecea2ac393dfa015", "filename": "src/libnative/io/timer_helper.rs", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8/src%2Flibnative%2Fio%2Ftimer_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8/src%2Flibnative%2Fio%2Ftimer_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_helper.rs?ref=7ea063ea0f9a28920fafbbf21064f20eb7ca02a8", "patch": "@@ -0,0 +1,143 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of the helper thread for the timer module\n+//!\n+//! This module contains the management necessary for the timer worker thread.\n+//! This thread is responsible for performing the send()s on channels for timers\n+//! that are using channels instead of a blocking call.\n+//!\n+//! The timer thread is lazily initialized, and it's shut down via the\n+//! `shutdown` function provided. It must be maintained as an invariant that\n+//! `shutdown` is only called when the entire program is finished. No new timers\n+//! can be created in the future and there must be no active timers at that\n+//! time.\n+\n+use std::cast;\n+use std::rt;\n+use std::unstable::mutex::{Once, ONCE_INIT};\n+\n+use bookkeeping;\n+use io::timer::{Req, Shutdown};\n+use task;\n+\n+// You'll note that these variables are *not* protected by a lock. These\n+// variables are initialized with a Once before any Timer is created and are\n+// only torn down after everything else has exited. This means that these\n+// variables are read-only during use (after initialization) and both of which\n+// are safe to use concurrently.\n+static mut HELPER_CHAN: *mut SharedChan<Req> = 0 as *mut SharedChan<Req>;\n+static mut HELPER_SIGNAL: imp::signal = 0 as imp::signal;\n+\n+pub fn boot(helper: fn(imp::signal, Port<Req>)) {\n+    static mut INIT: Once = ONCE_INIT;\n+\n+    unsafe {\n+        INIT.doit(|| {\n+            let (msgp, msgc) = SharedChan::new();\n+            HELPER_CHAN = cast::transmute(~msgc);\n+            let (receive, send) = imp::new();\n+            HELPER_SIGNAL = send;\n+\n+            do task::spawn {\n+                bookkeeping::decrement();\n+                helper(receive, msgp);\n+            }\n+\n+            rt::at_exit(proc() { shutdown() });\n+        })\n+    }\n+}\n+\n+pub fn send(req: Req) {\n+    unsafe {\n+        assert!(!HELPER_CHAN.is_null());\n+        (*HELPER_CHAN).send(req);\n+        imp::signal(HELPER_SIGNAL);\n+    }\n+}\n+\n+fn shutdown() {\n+    // We want to wait for the entire helper task to exit, and in doing so it\n+    // will attempt to decrement the global task count. When the helper was\n+    // created, it decremented the count so it wouldn't count towards preventing\n+    // the program to exit, so here we pair that manual decrement with a manual\n+    // increment. We will then wait for the helper thread to exit by calling\n+    // wait_for_other_tasks.\n+    bookkeeping::increment();\n+\n+    // Request a shutdown, and then wait for the task to exit\n+    send(Shutdown);\n+    bookkeeping::wait_for_other_tasks();\n+\n+    // Clean up after ther helper thread\n+    unsafe {\n+        imp::close(HELPER_SIGNAL);\n+        let _chan: ~SharedChan<Req> = cast::transmute(HELPER_CHAN);\n+        HELPER_CHAN = 0 as *mut SharedChan<Req>;\n+        HELPER_SIGNAL = 0 as imp::signal;\n+    }\n+}\n+\n+#[cfg(unix)]\n+mod imp {\n+    use std::libc;\n+    use std::os;\n+\n+    use io::file::FileDesc;\n+\n+    pub type signal = libc::c_int;\n+\n+    pub fn new() -> (signal, signal) {\n+        let pipe = os::pipe();\n+        (pipe.input, pipe.out)\n+    }\n+\n+    pub fn signal(fd: libc::c_int) {\n+        FileDesc::new(fd, false).inner_write([0]);\n+    }\n+\n+    pub fn close(fd: libc::c_int) {\n+        let _fd = FileDesc::new(fd, true);\n+    }\n+}\n+\n+#[cfg(windows)]\n+mod imp {\n+    use std::libc::{BOOL, LPCSTR, HANDLE, LPSECURITY_ATTRIBUTES, CloseHandle};\n+    use std::ptr;\n+    use std::libc;\n+\n+    pub type signal = HANDLE;\n+\n+    pub fn new() -> (HANDLE, HANDLE) {\n+        unsafe {\n+            let handle = CreateEventA(ptr::mut_null(), libc::FALSE, libc::FALSE,\n+                                      ptr::null());\n+            (handle, handle)\n+        }\n+    }\n+\n+    pub fn signal(handle: HANDLE) {\n+        unsafe { SetEvent(handle); }\n+    }\n+\n+    pub fn close(handle: HANDLE) {\n+        unsafe { CloseHandle(handle); }\n+    }\n+\n+    extern \"system\" {\n+        fn CreateEventA(lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n+                        bManualReset: BOOL,\n+                        bInitialState: BOOL,\n+                        lpName: LPCSTR) -> HANDLE;\n+        fn SetEvent(hEvent: HANDLE) -> BOOL;\n+    }\n+}"}, {"sha": "24ffd7a4147782a42e8265b31fde2d6bcc68c6d0", "filename": "src/libnative/io/timer_other.rs", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8/src%2Flibnative%2Fio%2Ftimer_other.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8/src%2Flibnative%2Fio%2Ftimer_other.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_other.rs?ref=7ea063ea0f9a28920fafbbf21064f20eb7ca02a8", "patch": "@@ -0,0 +1,328 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Timers for non-linux/non-windows OSes\n+//!\n+//! This module implements timers with a worker thread, select(), and a lot of\n+//! witchcraft that turns out to be horribly inaccurate timers. The unfortunate\n+//! part is that I'm at a loss of what else to do one these OSes. This is also\n+//! why linux has a specialized timerfd implementation and windows has its own\n+//! implementation (they're more accurate than this one).\n+//!\n+//! The basic idea is that there is a worker thread that's communicated to via a\n+//! channel and a pipe, the pipe is used by the worker thread in a select()\n+//! syscall with a timeout. The timeout is the \"next timer timeout\" while the\n+//! channel is used to send data over to the worker thread.\n+//!\n+//! Whenever the call to select() times out, then a channel receives a message.\n+//! Whenever the call returns that the file descriptor has information, then the\n+//! channel from timers is drained, enqueueing all incoming requests.\n+//!\n+//! The actual implementation of the helper thread is a sorted array of\n+//! timers in terms of target firing date. The target is the absolute time at\n+//! which the timer should fire. Timers are then re-enqueued after a firing if\n+//! the repeat boolean is set.\n+//!\n+//! Naturally, all this logic of adding times and keeping track of\n+//! relative/absolute time is a little lossy and not quite exact. I've done the\n+//! best I could to reduce the amount of calls to 'now()', but there's likely\n+//! still inaccuracies trickling in here and there.\n+//!\n+//! One of the tricky parts of this implementation is that whenever a timer is\n+//! acted upon, it must cancel whatever the previous action was (if one is\n+//! active) in order to act like the other implementations of this timer. In\n+//! order to do this, the timer's inner pointer is transferred to the worker\n+//! thread. Whenever the timer is modified, it first takes ownership back from\n+//! the worker thread in order to modify the same data structure. This has the\n+//! side effect of \"cancelling\" the previous requests while allowing a\n+//! re-enqueueing later on.\n+//!\n+//! Note that all time units in this file are in *milliseconds*.\n+\n+use std::comm::Data;\n+use std::hashmap::HashMap;\n+use std::libc;\n+use std::os;\n+use std::ptr;\n+use std::rt::rtio;\n+use std::sync::atomics;\n+use std::unstable::intrinsics;\n+\n+use io::file::FileDesc;\n+use io::IoResult;\n+use io::timer_helper;\n+\n+pub struct Timer {\n+    priv id: uint,\n+    priv inner: Option<~Inner>,\n+}\n+\n+struct Inner {\n+    chan: Option<Chan<()>>,\n+    interval: u64,\n+    repeat: bool,\n+    target: u64,\n+    id: uint,\n+}\n+\n+pub enum Req {\n+    // Add a new timer to the helper thread.\n+    NewTimer(~Inner),\n+\n+    // Remove a timer based on its id and then send it back on the channel\n+    // provided\n+    RemoveTimer(uint, Chan<~Inner>),\n+\n+    // Shut down the loop and then ACK this channel once it's shut down\n+    Shutdown,\n+}\n+\n+// returns the current time (in milliseconds)\n+fn now() -> u64 {\n+    unsafe {\n+        let mut now: libc::timeval = intrinsics::init();\n+        assert_eq!(imp::gettimeofday(&mut now, ptr::null()), 0);\n+        return (now.tv_sec as u64) * 1000 + (now.tv_usec as u64) / 1000;\n+    }\n+}\n+\n+fn helper(input: libc::c_int, messages: Port<Req>) {\n+    let mut set: imp::fd_set = unsafe { intrinsics::init() };\n+\n+    let mut fd = FileDesc::new(input, true);\n+    let mut timeout: libc::timeval = unsafe { intrinsics::init() };\n+\n+    // active timers are those which are able to be selected upon (and it's a\n+    // sorted list, and dead timers are those which have expired, but ownership\n+    // hasn't yet been transferred back to the timer itself.\n+    let mut active: ~[~Inner] = ~[];\n+    let mut dead = HashMap::new();\n+\n+    // inserts a timer into an array of timers (sorted by firing time)\n+    fn insert(t: ~Inner, active: &mut ~[~Inner]) {\n+        match active.iter().position(|tm| tm.target > t.target) {\n+            Some(pos) => { active.insert(pos, t); }\n+            None => { active.push(t); }\n+        }\n+    }\n+\n+    // signals the first requests in the queue, possible re-enqueueing it.\n+    fn signal(active: &mut ~[~Inner], dead: &mut HashMap<uint, ~Inner>) {\n+        let mut timer = match active.shift() {\n+            Some(timer) => timer, None => return\n+        };\n+        let chan = timer.chan.take_unwrap();\n+        if chan.try_send(()) && timer.repeat {\n+            timer.chan = Some(chan);\n+            timer.target += timer.interval;\n+            insert(timer, active);\n+        } else {\n+            drop(chan);\n+            dead.insert(timer.id, timer);\n+        }\n+    }\n+\n+    'outer: loop {\n+        let timeout = match active {\n+            // Empty array? no timeout (wait forever for the next request)\n+            [] => ptr::null(),\n+\n+            [~Inner { target, .. }, ..] => {\n+                let now = now();\n+                // If this request has already expired, then signal it and go\n+                // through another iteration\n+                if target <= now {\n+                    signal(&mut active, &mut dead);\n+                    continue;\n+                }\n+\n+                // The actual timeout listed in the requests array is an\n+                // absolute date, so here we translate the absolute time to a\n+                // relative time.\n+                let tm = target - now;\n+                timeout.tv_sec = (tm / 1000) as libc::time_t;\n+                timeout.tv_usec = ((tm % 1000) * 1000) as libc::suseconds_t;\n+                &timeout as *libc::timeval\n+            }\n+        };\n+\n+        imp::fd_set(&mut set, input);\n+        match unsafe {\n+            imp::select(input + 1, &set, ptr::null(), ptr::null(), timeout)\n+        } {\n+            // timed out\n+            0 => signal(&mut active, &mut dead),\n+\n+            // file descriptor write woke us up, we've got some new requests\n+            1 => {\n+                loop {\n+                    match messages.try_recv() {\n+                        Data(Shutdown) => {\n+                            assert!(active.len() == 0);\n+                            break 'outer;\n+                        }\n+\n+                        Data(NewTimer(timer)) => insert(timer, &mut active),\n+\n+                        Data(RemoveTimer(id, ack)) => {\n+                            match dead.pop(&id) {\n+                                Some(i) => { ack.send(i); continue }\n+                                None => {}\n+                            }\n+                            let i = active.iter().position(|i| i.id == id);\n+                            let i = i.expect(\"no timer found\");\n+                            let t = active.remove(i).unwrap();\n+                            ack.send(t);\n+                        }\n+                        _ => break\n+                    }\n+                }\n+\n+                // drain the file descriptor\n+                let mut buf = [0];\n+                fd.inner_read(buf);\n+            }\n+\n+            -1 if os::errno() == libc::EINTR as int => {}\n+            n => fail!(\"helper thread failed in select() with error: {} ({})\",\n+                       n, os::last_os_error())\n+        }\n+    }\n+}\n+\n+impl Timer {\n+    pub fn new() -> IoResult<Timer> {\n+        timer_helper::boot(helper);\n+\n+        static mut ID: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n+        let id = unsafe { ID.fetch_add(1, atomics::Relaxed) };\n+        Ok(Timer {\n+            id: id,\n+            inner: Some(~Inner {\n+                chan: None,\n+                interval: 0,\n+                target: 0,\n+                repeat: false,\n+                id: id,\n+            })\n+        })\n+    }\n+\n+    pub fn sleep(ms: u64) {\n+        unsafe { libc::usleep((ms * 1000) as libc::c_uint); }\n+    }\n+\n+    fn inner(&mut self) -> ~Inner {\n+        match self.inner.take() {\n+            Some(i) => i,\n+            None => {\n+                let (p, c) = Chan::new();\n+                timer_helper::send(RemoveTimer(self.id, c));\n+                p.recv()\n+            }\n+        }\n+    }\n+}\n+\n+impl rtio::RtioTimer for Timer {\n+    fn sleep(&mut self, msecs: u64) {\n+        let mut inner = self.inner();\n+        inner.chan = None; // cancel any previous request\n+        self.inner = Some(inner);\n+\n+        Timer::sleep(msecs);\n+    }\n+\n+    fn oneshot(&mut self, msecs: u64) -> Port<()> {\n+        let now = now();\n+        let mut inner = self.inner();\n+\n+        let (p, c) = Chan::new();\n+        inner.repeat = false;\n+        inner.chan = Some(c);\n+        inner.interval = msecs;\n+        inner.target = now + msecs;\n+\n+        timer_helper::send(NewTimer(inner));\n+        return p;\n+    }\n+\n+    fn period(&mut self, msecs: u64) -> Port<()> {\n+        let now = now();\n+        let mut inner = self.inner();\n+\n+        let (p, c) = Chan::new();\n+        inner.repeat = true;\n+        inner.chan = Some(c);\n+        inner.interval = msecs;\n+        inner.target = now + msecs;\n+\n+        timer_helper::send(NewTimer(inner));\n+        return p;\n+    }\n+}\n+\n+impl Drop for Timer {\n+    fn drop(&mut self) {\n+        self.inner = Some(self.inner());\n+    }\n+}\n+\n+#[cfg(target_os = \"macos\")]\n+mod imp {\n+    use std::libc;\n+\n+    pub static FD_SETSIZE: uint = 1024;\n+\n+    pub struct fd_set {\n+        fds_bits: [i32, ..(FD_SETSIZE / 32)]\n+    }\n+\n+    pub fn fd_set(set: &mut fd_set, fd: i32) {\n+        set.fds_bits[fd / 32] |= 1 << (fd % 32);\n+    }\n+\n+    extern {\n+        pub fn select(nfds: libc::c_int,\n+                      readfds: *fd_set,\n+                      writefds: *fd_set,\n+                      errorfds: *fd_set,\n+                      timeout: *libc::timeval) -> libc::c_int;\n+\n+        pub fn gettimeofday(timeval: *mut libc::timeval,\n+                            tzp: *libc::c_void) -> libc::c_int;\n+    }\n+}\n+\n+#[cfg(target_os = \"freebsd\")]\n+mod imp {\n+    use std::libc;\n+\n+    pub static FD_SETSIZE: uint = 1024;\n+\n+    pub struct fd_set {\n+        fds_bits: [u64, ..(FD_SETSIZE / 64)]\n+    }\n+\n+    pub fn fd_set(set: &mut fd_set, fd: i32) {\n+        set.fds_bits[fd / 64] |= (1 << (fd % 64)) as u64;\n+    }\n+\n+    extern {\n+        pub fn select(nfds: libc::c_int,\n+                      readfds: *fd_set,\n+                      writefds: *fd_set,\n+                      errorfds: *fd_set,\n+                      timeout: *libc::timeval) -> libc::c_int;\n+\n+        pub fn gettimeofday(timeval: *mut libc::timeval,\n+                            tzp: *libc::c_void) -> libc::c_int;\n+    }\n+}"}, {"sha": "4912f4f431f1f430f750628a70e83df6810b46cc", "filename": "src/libnative/io/timer_timerfd.rs", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_timerfd.rs?ref=7ea063ea0f9a28920fafbbf21064f20eb7ca02a8", "patch": "@@ -0,0 +1,303 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Timers based on timerfd_create(2)\n+//!\n+//! On OSes which support timerfd_create, we can use these much more accurate\n+//! timers over select() + a timeout (see timer_other.rs). This strategy still\n+//! employs a worker thread which does the waiting on the timer fds (to send\n+//! messages away).\n+//!\n+//! The worker thread in this implementation uses epoll(7) to block. It\n+//! maintains a working set of *all* native timers in the process, along with a\n+//! pipe file descriptor used to communicate that there is data available on the\n+//! incoming channel to the worker thread. Timers send requests to update their\n+//! timerfd settings to the worker thread (see the comment above 'oneshot' for\n+//! why).\n+//!\n+//! As with timer_other, timers just using sleep() do not use the timerfd at\n+//! all. They remove the timerfd from the worker thread and then invoke usleep()\n+//! to block the calling thread.\n+//!\n+//! As with timer_other, all units in this file are in units of millseconds.\n+\n+use std::comm::Data;\n+use std::libc;\n+use std::ptr;\n+use std::os;\n+use std::rt::rtio;\n+use std::hashmap::HashMap;\n+use std::unstable::intrinsics;\n+\n+use io::file::FileDesc;\n+use io::IoResult;\n+use io::timer_helper;\n+\n+pub struct Timer {\n+    priv fd: FileDesc,\n+    priv on_worker: bool,\n+}\n+\n+pub enum Req {\n+    NewTimer(libc::c_int, Chan<()>, bool, imp::itimerspec),\n+    RemoveTimer(libc::c_int, Chan<()>),\n+    Shutdown,\n+}\n+\n+fn helper(input: libc::c_int, messages: Port<Req>) {\n+    let efd = unsafe { imp::epoll_create(10) };\n+    let _fd1 = FileDesc::new(input, true);\n+    let _fd2 = FileDesc::new(efd, true);\n+\n+    fn add(efd: libc::c_int, fd: libc::c_int) {\n+        let event = imp::epoll_event {\n+            events: imp::EPOLLIN as u32,\n+            data: imp::epoll_data_t { fd: fd, pad: 0, }\n+        };\n+        let ret = unsafe {\n+            imp::epoll_ctl(efd, imp::EPOLL_CTL_ADD, fd, &event)\n+        };\n+        assert_eq!(ret, 0);\n+    }\n+    fn del(efd: libc::c_int, fd: libc::c_int) {\n+        let event = imp::epoll_event {\n+            events: 0, data: imp::epoll_data_t { fd: 0, pad: 0, }\n+        };\n+        let ret = unsafe {\n+            imp::epoll_ctl(efd, imp::EPOLL_CTL_DEL, fd, &event)\n+        };\n+        assert_eq!(ret, 0);\n+    }\n+\n+    add(efd, input);\n+    let events: [imp::epoll_event, ..16] = unsafe { intrinsics::init() };\n+    let mut map: HashMap<libc::c_int, (Chan<()>, bool)> = HashMap::new();\n+    'outer: loop {\n+        let n = match unsafe {\n+            imp::epoll_wait(efd, events.as_ptr(),\n+                            events.len() as libc::c_int, -1)\n+        } {\n+            0 => fail!(\"epoll_wait returned immediately!\"),\n+            -1 => fail!(\"epoll wait failed: {}\", os::last_os_error()),\n+            n => n\n+        };\n+\n+        let mut incoming = false;\n+        debug!(\"{} events to process\", n);\n+        for event in events.slice_to(n as uint).iter() {\n+            let fd = event.data.fd;\n+            debug!(\"data on fd {} (input = {})\", fd, input);\n+            if fd == input {\n+                let mut buf = [0, ..1];\n+                // drain the input file descriptor of its input\n+                FileDesc::new(fd, false).inner_read(buf);\n+                incoming = true;\n+            } else {\n+                let mut bits = [0, ..8];\n+                // drain the timerfd of how many times its fired\n+                //\n+                // XXX: should this perform a send() this number of\n+                //      times?\n+                FileDesc::new(fd, false).inner_read(bits);\n+                let remove = {\n+                    match map.find(&fd).expect(\"fd unregistered\") {\n+                        &(ref c, oneshot) => !c.try_send(()) || oneshot\n+                    }\n+                };\n+                if remove {\n+                    map.remove(&fd);\n+                    del(efd, fd);\n+                }\n+            }\n+        }\n+\n+        while incoming {\n+            match messages.try_recv() {\n+                Data(NewTimer(fd, chan, one, timeval)) => {\n+                    // acknowledge we have the new channel, we will never send\n+                    // another message to the old channel\n+                    chan.send(());\n+\n+                    // If we haven't previously seen the file descriptor, then\n+                    // we need to add it to the epoll set.\n+                    if map.insert(fd, (chan, one)) {\n+                        add(efd, fd);\n+                    }\n+\n+                    // Update the timerfd's time value now that we have control\n+                    // of the timerfd\n+                    let ret = unsafe {\n+                        imp::timerfd_settime(fd, 0, &timeval, ptr::null())\n+                    };\n+                    assert_eq!(ret, 0);\n+                }\n+\n+                Data(RemoveTimer(fd, chan)) => {\n+                    if map.remove(&fd) {\n+                        del(efd, fd);\n+                    }\n+                    chan.send(());\n+                }\n+\n+                Data(Shutdown) => {\n+                    assert!(map.len() == 0);\n+                    break 'outer;\n+                }\n+\n+                _ => break,\n+            }\n+        }\n+    }\n+}\n+\n+impl Timer {\n+    pub fn new() -> IoResult<Timer> {\n+        timer_helper::boot(helper);\n+        match unsafe { imp::timerfd_create(imp::CLOCK_MONOTONIC, 0) } {\n+            -1 => Err(super::last_error()),\n+            n => Ok(Timer { fd: FileDesc::new(n, true), on_worker: false, }),\n+        }\n+    }\n+\n+    pub fn sleep(ms: u64) {\n+        unsafe { libc::usleep((ms * 1000) as libc::c_uint); }\n+    }\n+\n+    fn remove(&mut self) {\n+        if !self.on_worker { return }\n+\n+        let (p, c) = Chan::new();\n+        timer_helper::send(RemoveTimer(self.fd.fd(), c));\n+        p.recv();\n+        self.on_worker = false;\n+    }\n+}\n+\n+impl rtio::RtioTimer for Timer {\n+    fn sleep(&mut self, msecs: u64) {\n+        self.remove();\n+        Timer::sleep(msecs);\n+    }\n+\n+    // Periodic and oneshot channels are updated by updating the settings on the\n+    // corresopnding timerfd. The update is not performed on the thread calling\n+    // oneshot or period, but rather the helper epoll thread. The reason for\n+    // this is to avoid losing messages and avoid leaking messages across ports.\n+    //\n+    // By updating the timerfd on the helper thread, we're guaranteed that all\n+    // messages for a particular setting of the timer will be received by the\n+    // new channel/port pair rather than leaking old messages onto the new port\n+    // or leaking new messages onto the old port.\n+    //\n+    // We also wait for the remote thread to actually receive the new settings\n+    // before returning to guarantee the invariant that when oneshot() and\n+    // period() return that the old port will never receive any more messages.\n+\n+    fn oneshot(&mut self, msecs: u64) -> Port<()> {\n+        let (p, c) = Chan::new();\n+\n+        let new_value = imp::itimerspec {\n+            it_interval: imp::timespec { tv_sec: 0, tv_nsec: 0 },\n+            it_value: imp::timespec {\n+                tv_sec: (msecs / 1000) as libc::time_t,\n+                tv_nsec: ((msecs % 1000) * 1000000) as libc::c_long,\n+            }\n+        };\n+        timer_helper::send(NewTimer(self.fd.fd(), c, true, new_value));\n+        p.recv();\n+        self.on_worker = true;\n+\n+        return p;\n+    }\n+\n+    fn period(&mut self, msecs: u64) -> Port<()> {\n+        let (p, c) = Chan::new();\n+\n+        let spec = imp::timespec {\n+            tv_sec: (msecs / 1000) as libc::time_t,\n+            tv_nsec: ((msecs % 1000) * 1000000) as libc::c_long,\n+        };\n+        let new_value = imp::itimerspec { it_interval: spec, it_value: spec, };\n+        timer_helper::send(NewTimer(self.fd.fd(), c, false, new_value));\n+        p.recv();\n+        self.on_worker = true;\n+\n+        return p;\n+    }\n+}\n+\n+impl Drop for Timer {\n+    fn drop(&mut self) {\n+        // When the timerfd file descriptor is closed, it will be automatically\n+        // removed from the epoll set of the worker thread, but we want to make\n+        // sure that the associated channel is also removed from the worker's\n+        // hash map.\n+        self.remove();\n+    }\n+}\n+\n+#[allow(dead_code)]\n+mod imp {\n+    use std::libc;\n+\n+    pub static CLOCK_MONOTONIC: libc::c_int = 1;\n+    pub static EPOLL_CTL_ADD: libc::c_int = 1;\n+    pub static EPOLL_CTL_DEL: libc::c_int = 2;\n+    pub static EPOLL_CTL_MOD: libc::c_int = 3;\n+    pub static EPOLLIN: libc::c_int = 0x001;\n+    pub static EPOLLOUT: libc::c_int = 0x004;\n+    pub static EPOLLPRI: libc::c_int = 0x002;\n+    pub static EPOLLERR: libc::c_int = 0x008;\n+    pub static EPOLLRDHUP: libc::c_int = 0x2000;\n+    pub static EPOLLET: libc::c_int = 1 << 31;\n+    pub static EPOLLHUP: libc::c_int = 0x010;\n+    pub static EPOLLONESHOT: libc::c_int = 1 << 30;\n+\n+    pub struct epoll_event {\n+        events: u32,\n+        data: epoll_data_t,\n+    }\n+\n+    pub struct epoll_data_t {\n+        fd: i32,\n+        pad: u32,\n+    }\n+\n+    pub struct timespec {\n+        tv_sec: libc::time_t,\n+        tv_nsec: libc::c_long,\n+    }\n+\n+    pub struct itimerspec {\n+        it_interval: timespec,\n+        it_value: timespec,\n+    }\n+\n+    extern {\n+        pub fn timerfd_create(clockid: libc::c_int,\n+                              flags: libc::c_int) -> libc::c_int;\n+        pub fn timerfd_settime(fd: libc::c_int,\n+                               flags: libc::c_int,\n+                               new_value: *itimerspec,\n+                               old_value: *itimerspec) -> libc::c_int;\n+        pub fn timerfd_gettime(fd: libc::c_int,\n+                               curr_value: *itimerspec) -> libc::c_int;\n+\n+        pub fn epoll_create(size: libc::c_int) -> libc::c_int;\n+        pub fn epoll_ctl(epfd: libc::c_int,\n+                         op: libc::c_int,\n+                         fd: libc::c_int,\n+                         event: *epoll_event) -> libc::c_int;\n+        pub fn epoll_wait(epfd: libc::c_int,\n+                          events: *epoll_event,\n+                          maxevents: libc::c_int,\n+                          timeout: libc::c_int) -> libc::c_int;\n+    }\n+}"}, {"sha": "e359d99eedf659361cd02b816f6a11a7beb20d55", "filename": "src/libnative/io/timer_win32.rs", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8/src%2Flibnative%2Fio%2Ftimer_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8/src%2Flibnative%2Fio%2Ftimer_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_win32.rs?ref=7ea063ea0f9a28920fafbbf21064f20eb7ca02a8", "patch": "@@ -0,0 +1,203 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Timers based on win32 WaitableTimers\n+//!\n+//! This implementation is meant to be used solely on windows. As with other\n+//! implementations, there is a worker thread which is doing all the waiting on\n+//! a large number of timers for all active timers in the system. This worker\n+//! thread uses the select() equivalent, WaitForMultipleObjects. One of the\n+//! objects being waited on is a signal into the worker thread to notify that\n+//! the incoming channel should be looked at.\n+//!\n+//! Other than that, the implementation is pretty straightforward in terms of\n+//! the other two implementations of timers with nothing *that* new showing up.\n+\n+use std::comm::Data;\n+use std::libc;\n+use std::ptr;\n+use std::rt::rtio;\n+\n+use io::timer_helper;\n+use io::IoResult;\n+\n+pub struct Timer {\n+    priv obj: libc::HANDLE,\n+    priv on_worker: bool,\n+}\n+\n+pub enum Req {\n+    NewTimer(libc::HANDLE, Chan<()>, bool),\n+    RemoveTimer(libc::HANDLE, Chan<()>),\n+    Shutdown,\n+}\n+\n+fn helper(input: libc::HANDLE, messages: Port<Req>) {\n+    let mut objs = ~[input];\n+    let mut chans = ~[];\n+\n+    'outer: loop {\n+        let idx = unsafe {\n+            imp::WaitForMultipleObjects(objs.len() as libc::DWORD,\n+                                        objs.as_ptr(),\n+                                        0 as libc::BOOL,\n+                                        libc::INFINITE)\n+        };\n+\n+        if idx == 0 {\n+            loop {\n+                match messages.try_recv() {\n+                    Data(NewTimer(obj, c, one)) => {\n+                        objs.push(obj);\n+                        chans.push((c, one));\n+                    }\n+                    Data(RemoveTimer(obj, c)) => {\n+                        c.send(());\n+                        match objs.iter().position(|&o| o == obj) {\n+                            Some(i) => {\n+                                objs.remove(i);\n+                                chans.remove(i - 1);\n+                            }\n+                            None => {}\n+                        }\n+                    }\n+                    Data(Shutdown) => {\n+                        assert_eq!(objs.len(), 1);\n+                        assert_eq!(chans.len(), 0);\n+                        break 'outer;\n+                    }\n+                    _ => break\n+                }\n+            }\n+        } else {\n+            let remove = {\n+                match &chans[idx - 1] {\n+                    &(ref c, oneshot) => !c.try_send(()) || oneshot\n+                }\n+            };\n+            if remove {\n+                objs.remove(idx as uint);\n+                chans.remove(idx as uint - 1);\n+            }\n+        }\n+    }\n+}\n+\n+impl Timer {\n+    pub fn new() -> IoResult<Timer> {\n+        timer_helper::boot(helper);\n+\n+        let obj = unsafe {\n+            imp::CreateWaitableTimerA(ptr::mut_null(), 0, ptr::null())\n+        };\n+        if obj.is_null() {\n+            Err(super::last_error())\n+        } else {\n+            Ok(Timer { obj: obj, on_worker: false, })\n+        }\n+    }\n+\n+    pub fn sleep(ms: u64) {\n+        use std::rt::rtio::RtioTimer;\n+        let mut t = Timer::new().ok().expect(\"must allocate a timer!\");\n+        t.sleep(ms);\n+    }\n+\n+    fn remove(&mut self) {\n+        if !self.on_worker { return }\n+\n+        let (p, c) = Chan::new();\n+        timer_helper::send(RemoveTimer(self.obj, c));\n+        p.recv();\n+\n+        self.on_worker = false;\n+    }\n+}\n+\n+impl rtio::RtioTimer for Timer {\n+    fn sleep(&mut self, msecs: u64) {\n+        self.remove();\n+\n+        // there are 10^6 nanoseconds in a millisecond, and the parameter is in\n+        // 100ns intervals, so we multiply by 10^4.\n+        let due = -(msecs * 10000) as libc::LARGE_INTEGER;\n+        assert_eq!(unsafe {\n+            imp::SetWaitableTimer(self.obj, &due, 0, ptr::null(),\n+                                  ptr::mut_null(), 0)\n+        }, 1);\n+\n+        unsafe { imp::WaitForSingleObject(self.obj, libc::INFINITE); }\n+    }\n+\n+    fn oneshot(&mut self, msecs: u64) -> Port<()> {\n+        self.remove();\n+        let (p, c) = Chan::new();\n+\n+        // see above for the calculation\n+        let due = -(msecs * 10000) as libc::LARGE_INTEGER;\n+        assert_eq!(unsafe {\n+            imp::SetWaitableTimer(self.obj, &due, 0, ptr::null(),\n+                                  ptr::mut_null(), 0)\n+        }, 1);\n+\n+        timer_helper::send(NewTimer(self.obj, c, true));\n+        self.on_worker = true;\n+        return p;\n+    }\n+\n+    fn period(&mut self, msecs: u64) -> Port<()> {\n+        self.remove();\n+        let (p, c) = Chan::new();\n+\n+        // see above for the calculation\n+        let due = -(msecs * 10000) as libc::LARGE_INTEGER;\n+        assert_eq!(unsafe {\n+            imp::SetWaitableTimer(self.obj, &due, msecs as libc::LONG,\n+                                  ptr::null(), ptr::mut_null(), 0)\n+        }, 1);\n+\n+        timer_helper::send(NewTimer(self.obj, c, false));\n+        self.on_worker = true;\n+\n+        return p;\n+    }\n+}\n+\n+impl Drop for Timer {\n+    fn drop(&mut self) {\n+        self.remove();\n+        unsafe { libc::CloseHandle(self.obj); }\n+    }\n+}\n+\n+mod imp {\n+    use std::libc::{LPSECURITY_ATTRIBUTES, BOOL, LPCSTR, HANDLE, LARGE_INTEGER,\n+                    LONG, LPVOID, DWORD, c_void};\n+\n+    pub type PTIMERAPCROUTINE = *c_void;\n+\n+    extern \"system\" {\n+        pub fn CreateWaitableTimerA(lpTimerAttributes: LPSECURITY_ATTRIBUTES,\n+                                    bManualReset: BOOL,\n+                                    lpTimerName: LPCSTR) -> HANDLE;\n+        pub fn SetWaitableTimer(hTimer: HANDLE,\n+                                pDueTime: *LARGE_INTEGER,\n+                                lPeriod: LONG,\n+                                pfnCompletionRoutine: PTIMERAPCROUTINE,\n+                                lpArgToCompletionRoutine: LPVOID,\n+                                fResume: BOOL) -> BOOL;\n+        pub fn WaitForMultipleObjects(nCount: DWORD,\n+                                      lpHandles: *HANDLE,\n+                                      bWaitAll: BOOL,\n+                                      dwMilliseconds: DWORD) -> DWORD;\n+        pub fn WaitForSingleObject(hHandle: HANDLE,\n+                                   dwMilliseconds: DWORD) -> DWORD;\n+    }\n+}"}, {"sha": "d81de989df7d849cad657b7225a0480e03ec20d3", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=7ea063ea0f9a28920fafbbf21064f20eb7ca02a8", "patch": "@@ -34,6 +34,7 @@ macro_rules! iotest (\n             use io::net::udp::*;\n             #[cfg(unix)]\n             use io::net::unix::*;\n+            use io::timer::*;\n             use io::process::*;\n             use str;\n             use util;"}, {"sha": "4bf89a1d5596cb641df9048ac6a3f374e538e1fc", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 145, "deletions": 29, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=7ea063ea0f9a28920fafbbf21064f20eb7ca02a8", "patch": "@@ -96,61 +96,177 @@ impl Timer {\n \n #[cfg(test)]\n mod test {\n-    use prelude::*;\n-    use super::*;\n-\n-    #[test]\n-    fn test_io_timer_sleep_simple() {\n+    iotest!(fn test_io_timer_sleep_simple() {\n         let mut timer = Timer::new().unwrap();\n         timer.sleep(1);\n-    }\n+    })\n \n-    #[test]\n-    fn test_io_timer_sleep_oneshot() {\n+    iotest!(fn test_io_timer_sleep_oneshot() {\n         let mut timer = Timer::new().unwrap();\n         timer.oneshot(1).recv();\n-    }\n+    })\n \n-    #[test]\n-    fn test_io_timer_sleep_oneshot_forget() {\n+    iotest!(fn test_io_timer_sleep_oneshot_forget() {\n         let mut timer = Timer::new().unwrap();\n         timer.oneshot(100000000000);\n-    }\n+    })\n \n-    #[test]\n-    fn oneshot_twice() {\n+    iotest!(fn oneshot_twice() {\n         let mut timer = Timer::new().unwrap();\n         let port1 = timer.oneshot(10000);\n         let port = timer.oneshot(1);\n         port.recv();\n-        assert!(port1.recv_opt().is_none());\n-    }\n+        assert_eq!(port1.recv_opt(), None);\n+    })\n \n-    #[test]\n-    fn test_io_timer_oneshot_then_sleep() {\n+    iotest!(fn test_io_timer_oneshot_then_sleep() {\n         let mut timer = Timer::new().unwrap();\n         let port = timer.oneshot(100000000000);\n         timer.sleep(1); // this should invalidate the port\n-        assert!(port.recv_opt().is_none());\n-    }\n \n-    #[test]\n-    fn test_io_timer_sleep_periodic() {\n+        assert_eq!(port.recv_opt(), None);\n+    })\n+\n+    iotest!(fn test_io_timer_sleep_periodic() {\n         let mut timer = Timer::new().unwrap();\n         let port = timer.periodic(1);\n         port.recv();\n         port.recv();\n         port.recv();\n-    }\n+    })\n \n-    #[test]\n-    fn test_io_timer_sleep_periodic_forget() {\n+    iotest!(fn test_io_timer_sleep_periodic_forget() {\n         let mut timer = Timer::new().unwrap();\n         timer.periodic(100000000000);\n-    }\n+    })\n \n-    #[test]\n-    fn test_io_timer_sleep_standalone() {\n+    iotest!(fn test_io_timer_sleep_standalone() {\n         sleep(1)\n-    }\n+    })\n+\n+    iotest!(fn oneshot() {\n+        let mut timer = Timer::new().unwrap();\n+\n+        let port = timer.oneshot(1);\n+        port.recv();\n+        assert!(port.recv_opt().is_none());\n+\n+        let port = timer.oneshot(1);\n+        port.recv();\n+        assert!(port.recv_opt().is_none());\n+    })\n+\n+    iotest!(fn override() {\n+        let mut timer = Timer::new().unwrap();\n+        let oport = timer.oneshot(100);\n+        let pport = timer.periodic(100);\n+        timer.sleep(1);\n+        assert_eq!(oport.recv_opt(), None);\n+        assert_eq!(pport.recv_opt(), None);\n+        timer.oneshot(1).recv();\n+    })\n+\n+    iotest!(fn period() {\n+        let mut timer = Timer::new().unwrap();\n+        let port = timer.periodic(1);\n+        port.recv();\n+        port.recv();\n+        let port2 = timer.periodic(1);\n+        port2.recv();\n+        port2.recv();\n+    })\n+\n+    iotest!(fn sleep() {\n+        let mut timer = Timer::new().unwrap();\n+        timer.sleep(1);\n+        timer.sleep(1);\n+    })\n+\n+    iotest!(fn oneshot_fail() {\n+        let mut timer = Timer::new().unwrap();\n+        let _port = timer.oneshot(1);\n+        fail!();\n+    } #[should_fail])\n+\n+    iotest!(fn period_fail() {\n+        let mut timer = Timer::new().unwrap();\n+        let _port = timer.periodic(1);\n+        fail!();\n+    } #[should_fail])\n+\n+    iotest!(fn normal_fail() {\n+        let _timer = Timer::new().unwrap();\n+        fail!();\n+    } #[should_fail])\n+\n+    iotest!(fn closing_channel_during_drop_doesnt_kill_everything() {\n+        // see issue #10375\n+        let mut timer = Timer::new().unwrap();\n+        let timer_port = timer.periodic(1000);\n+\n+        do spawn {\n+            timer_port.recv_opt();\n+        }\n+\n+        // when we drop the TimerWatcher we're going to destroy the channel,\n+        // which must wake up the task on the other end\n+    })\n+\n+    iotest!(fn reset_doesnt_switch_tasks() {\n+        // similar test to the one above.\n+        let mut timer = Timer::new().unwrap();\n+        let timer_port = timer.periodic(1000);\n+\n+        do spawn {\n+            timer_port.recv_opt();\n+        }\n+\n+        timer.oneshot(1);\n+    })\n+\n+    iotest!(fn reset_doesnt_switch_tasks2() {\n+        // similar test to the one above.\n+        let mut timer = Timer::new().unwrap();\n+        let timer_port = timer.periodic(1000);\n+\n+        do spawn {\n+            timer_port.recv_opt();\n+        }\n+\n+        timer.sleep(1);\n+    })\n+\n+    iotest!(fn sender_goes_away_oneshot() {\n+        let port = {\n+            let mut timer = Timer::new().unwrap();\n+            timer.oneshot(1000)\n+        };\n+        assert_eq!(port.recv_opt(), None);\n+    })\n+\n+    iotest!(fn sender_goes_away_period() {\n+        let port = {\n+            let mut timer = Timer::new().unwrap();\n+            timer.periodic(1000)\n+        };\n+        assert_eq!(port.recv_opt(), None);\n+    })\n+\n+    iotest!(fn receiver_goes_away_oneshot() {\n+        let mut timer1 = Timer::new().unwrap();\n+        timer1.oneshot(1);\n+        let mut timer2 = Timer::new().unwrap();\n+        // while sleeping, the prevous timer should fire and not have its\n+        // callback do something terrible.\n+        timer2.sleep(2);\n+    })\n+\n+    iotest!(fn receiver_goes_away_period() {\n+        let mut timer1 = Timer::new().unwrap();\n+        timer1.periodic(1);\n+        let mut timer2 = Timer::new().unwrap();\n+        // while sleeping, the prevous timer should fire and not have its\n+        // callback do something terrible.\n+        timer2.sleep(2);\n+    })\n }"}, {"sha": "8975c2a7955bd9b271dc687783473b378ceb5c08", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=7ea063ea0f9a28920fafbbf21064f20eb7ca02a8", "patch": "@@ -3548,6 +3548,7 @@ pub mod funcs {\n                 pub fn setsid() -> pid_t;\n                 pub fn setuid(uid: uid_t) -> c_int;\n                 pub fn sleep(secs: c_uint) -> c_uint;\n+                pub fn usleep(secs: c_uint) -> c_int;\n                 pub fn sysconf(name: c_int) -> c_long;\n                 pub fn tcgetpgrp(fd: c_int) -> pid_t;\n                 pub fn ttyname(fd: c_int) -> *c_char;"}, {"sha": "6f9be64a73d04b0004ba7d4d0e468076b00e689d", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=7ea063ea0f9a28920fafbbf21064f20eb7ca02a8", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of running at_exit routines\n+//!\n+//! Documentation can be found on the `rt::at_exit` function.\n+\n+use cast;\n+use iter::Iterator;\n+use option::{Some, None};\n+use ptr::RawPtr;\n+use unstable::sync::Exclusive;\n+use util;\n+use vec::OwnedVector;\n+\n+type Queue = Exclusive<~[proc()]>;\n+\n+// You'll note that these variables are *not* atomic, and this is done on\n+// purpose. This module is designed to have init() called *once* in a\n+// single-task context, and then run() is called only once in another\n+// single-task context. As a result of this, only the `push` function is\n+// thread-safe, and it assumes that the `init` function has run previously.\n+static mut QUEUE: *mut Queue = 0 as *mut Queue;\n+static mut RUNNING: bool = false;\n+\n+pub fn init() {\n+    unsafe {\n+        rtassert!(!RUNNING);\n+        rtassert!(QUEUE.is_null());\n+        let state: ~Queue = ~Exclusive::new(~[]);\n+        QUEUE = cast::transmute(state);\n+    }\n+}\n+\n+pub fn push(f: proc()) {\n+    unsafe {\n+        rtassert!(!RUNNING);\n+        rtassert!(!QUEUE.is_null());\n+        let state: &mut Queue = cast::transmute(QUEUE);\n+        let mut f = Some(f);\n+        state.with(|arr|  {\n+            arr.push(f.take_unwrap());\n+        });\n+    }\n+}\n+\n+pub fn run() {\n+    let vec = unsafe {\n+        rtassert!(!RUNNING);\n+        rtassert!(!QUEUE.is_null());\n+        RUNNING = true;\n+        let state: ~Queue = cast::transmute(QUEUE);\n+        QUEUE = 0 as *mut Queue;\n+        let mut vec = None;\n+        state.with(|arr| {\n+            vec = Some(util::replace(arr, ~[]));\n+        });\n+        vec.take_unwrap()\n+    };\n+\n+\n+    for f in vec.move_iter() {\n+        f();\n+    }\n+}"}, {"sha": "7aa966802f2f5ec8fa5a2202853f72e100951754", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ea063ea0f9a28920fafbbf21064f20eb7ca02a8/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=7ea063ea0f9a28920fafbbf21064f20eb7ca02a8", "patch": "@@ -127,6 +127,9 @@ mod util;\n // Global command line argument storage\n pub mod args;\n \n+// Support for running procedures when a program has exited.\n+mod at_exit_imp;\n+\n /// The default error code of the rust runtime if the main task fails instead\n /// of exiting cleanly.\n pub static DEFAULT_ERROR_CODE: int = 101;\n@@ -171,9 +174,27 @@ pub fn init(argc: int, argv: **u8) {\n         env::init();\n         logging::init();\n         local_ptr::init();\n+        at_exit_imp::init();\n     }\n }\n \n+/// Enqueues a procedure to run when the runtime is cleaned up\n+///\n+/// The procedure passed to this function will be executed as part of the\n+/// runtime cleanup phase. For normal rust programs, this means that it will run\n+/// after all other tasks have exited.\n+///\n+/// The procedure is *not* executed with a local `Task` available to it, so\n+/// primitives like logging, I/O, channels, spawning, etc, are *not* available.\n+/// This is meant for \"bare bones\" usage to clean up runtime details, this is\n+/// not meant as a general-purpose \"let's clean everything up\" function.\n+///\n+/// It is forbidden for procedures to register more `at_exit` handlers when they\n+/// are running, and doing so will lead to a process abort.\n+pub fn at_exit(f: proc()) {\n+    at_exit_imp::push(f);\n+}\n+\n /// One-time runtime cleanup.\n ///\n /// This function is unsafe because it performs no checks to ensure that the\n@@ -184,6 +205,7 @@ pub fn init(argc: int, argv: **u8) {\n /// Invoking cleanup while portions of the runtime are still in use may cause\n /// undefined behavior.\n pub unsafe fn cleanup() {\n+    at_exit_imp::run();\n     args::cleanup();\n     local_ptr::cleanup();\n }"}]}