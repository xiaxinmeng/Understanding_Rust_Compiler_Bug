{"sha": "418eea115454f1a617440e9e35f9c63520962bc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxOGVlYTExNTQ1NGYxYTYxNzQ0MGU5ZTM1ZjljNjM1MjA5NjJiYzM=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-02-19T01:24:07Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-02-19T01:24:07Z"}, "message": "Fix bug with zero-length filemaps and rename bytepos_to_local_charpos to bytepos_to_charpos.", "tree": {"sha": "1c23d144e6d6df9a87861348169a0fb4c6eba734", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c23d144e6d6df9a87861348169a0fb4c6eba734"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/418eea115454f1a617440e9e35f9c63520962bc3", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/418eea115454f1a617440e9e35f9c63520962bc3", "html_url": "https://github.com/rust-lang/rust/commit/418eea115454f1a617440e9e35f9c63520962bc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/418eea115454f1a617440e9e35f9c63520962bc3/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93a2ee807abafa25555b17b6432d02db53f9e756", "url": "https://api.github.com/repos/rust-lang/rust/commits/93a2ee807abafa25555b17b6432d02db53f9e756", "html_url": "https://github.com/rust-lang/rust/commit/93a2ee807abafa25555b17b6432d02db53f9e756"}], "stats": {"total": 86, "additions": 78, "deletions": 8}, "files": [{"sha": "486a25fa775c9ee40ff5971c17ee11c3fa29562e", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 78, "deletions": 8, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/418eea115454f1a617440e9e35f9c63520962bc3/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418eea115454f1a617440e9e35f9c63520962bc3/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=418eea115454f1a617440e9e35f9c63520962bc3", "patch": "@@ -380,6 +380,20 @@ impl CodeMap {\n                 a = m;\n             }\n         }\n+        // There can be filemaps with length 0. These have the same start_pos as the previous\n+        // filemap, but are not the filemaps we want (because they are length 0, they cannot\n+        // contain what we are looking for). So, rewind until we find a useful filemap.\n+        loop {\n+            let lines = files[a].lines.borrow();\n+            let lines = lines.get();\n+            if lines.len() > 0 {\n+                break;\n+            }\n+            if a == 0 {\n+                fail!(\"position {} does not resolve to a source location\", pos.to_uint());\n+            }\n+            a -= 1;\n+        }\n         if a >= len {\n             fail!(\"position {} does not resolve to a source location\", pos.to_uint())\n         }\n@@ -406,10 +420,10 @@ impl CodeMap {\n     fn lookup_pos(&self, pos: BytePos) -> Loc {\n         let FileMapAndLine {fm: f, line: a} = self.lookup_line(pos);\n         let line = a + 1u; // Line numbers start at 1\n-        let chpos = self.bytepos_to_local_charpos(pos);\n-        let mut lines = f.lines.borrow_mut();\n+        let chpos = self.bytepos_to_charpos(pos);\n+        let lines = f.lines.borrow();\n         let linebpos = lines.get()[a];\n-        let linechpos = self.bytepos_to_local_charpos(linebpos);\n+        let linechpos = self.bytepos_to_charpos(linebpos);\n         debug!(\"codemap: byte pos {:?} is on the line at byte pos {:?}\",\n                pos, linebpos);\n         debug!(\"codemap: char pos {:?} is on the line at char pos {:?}\",\n@@ -432,9 +446,8 @@ impl CodeMap {\n         return FileMapAndBytePos {fm: fm, pos: offset};\n     }\n \n-    // Converts an absolute BytePos to a CharPos relative to the file it is\n-    // located in\n-    fn bytepos_to_local_charpos(&self, bpos: BytePos) -> CharPos {\n+    // Converts an absolute BytePos to a CharPos relative to the codemap.\n+    fn bytepos_to_charpos(&self, bpos: BytePos) -> CharPos {\n         debug!(\"codemap: converting {:?} to char pos\", bpos);\n         let idx = self.lookup_filemap_idx(bpos);\n         let files = self.files.borrow();\n@@ -450,8 +463,8 @@ impl CodeMap {\n                 total_extra_bytes += mbc.bytes;\n                 // We should never see a byte position in the middle of a\n                 // character\n-                assert!(bpos == mbc.pos\n-                    || bpos.to_uint() >= mbc.pos.to_uint() + mbc.bytes);\n+                assert!(bpos == mbc.pos ||\n+                        bpos.to_uint() >= mbc.pos.to_uint() + mbc.bytes);\n             } else {\n                 break;\n             }\n@@ -486,4 +499,61 @@ mod test {\n         fm.next_line(BytePos(10));\n         fm.next_line(BytePos(2));\n     }\n+\n+    fn init_code_map() ->CodeMap {\n+        let cm = CodeMap::new();\n+        let fm1 = cm.new_filemap(~\"blork.rs\",~\"first line.\\nsecond line\");\n+        let fm2 = cm.new_filemap(~\"empty.rs\",~\"\");\n+        let fm3 = cm.new_filemap(~\"blork2.rs\",~\"first line.\\nsecond line\");\n+\n+        fm1.next_line(BytePos(0));\n+        fm1.next_line(BytePos(12));\n+        fm2.next_line(BytePos(23));\n+        fm3.next_line(BytePos(23));\n+        fm3.next_line(BytePos(33));\n+\n+        cm\n+    }\n+\n+    #[test]\n+    fn t3() {\n+        // Test lookup_byte_offset\n+        let cm = init_code_map();\n+\n+        let fmabp1 = cm.lookup_byte_offset(BytePos(22));\n+        assert_eq!(fmabp1.fm.name, ~\"blork.rs\");\n+        assert_eq!(fmabp1.pos, BytePos(22));\n+\n+        let fmabp2 = cm.lookup_byte_offset(BytePos(23));\n+        assert_eq!(fmabp2.fm.name, ~\"blork2.rs\");\n+        assert_eq!(fmabp2.pos, BytePos(0));\n+    }\n+\n+    #[test]\n+    fn t4() {\n+        // Test bytepos_to_charpos\n+        let cm = init_code_map();\n+\n+        let cp1 = cm.bytepos_to_charpos(BytePos(22));\n+        assert_eq!(cp1, CharPos(22));\n+\n+        let cp2 = cm.bytepos_to_charpos(BytePos(23));\n+        assert_eq!(cp2, CharPos(23));\n+    }\n+\n+    #[test]\n+    fn t5() {\n+        // Test zero-length filemaps.\n+        let cm = init_code_map();\n+\n+        let loc1 = cm.lookup_char_pos(BytePos(22));\n+        assert_eq!(loc1.file.name, ~\"blork.rs\");\n+        assert_eq!(loc1.line, 2);\n+        assert_eq!(loc1.col, CharPos(10));\n+\n+        let loc2 = cm.lookup_char_pos(BytePos(23));\n+        assert_eq!(loc2.file.name, ~\"blork2.rs\");\n+        assert_eq!(loc2.line, 1);\n+        assert_eq!(loc2.col, CharPos(0));\n+    }\n }"}]}