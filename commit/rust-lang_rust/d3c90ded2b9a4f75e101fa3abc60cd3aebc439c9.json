{"sha": "d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzYzkwZGVkMmI5YTRmNzVlMTAxZmEzYWJjNjBjZDNhZWJjNDM5Yzk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-17T19:00:13Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-17T19:00:13Z"}, "message": "Borrowed AST", "tree": {"sha": "6d2388eb68605331a0dd090269372bc98dd038cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d2388eb68605331a0dd090269372bc98dd038cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9", "html_url": "https://github.com/rust-lang/rust/commit/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70097504f78c4c41368a0b864a94df95fb9c27f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/70097504f78c4c41368a0b864a94df95fb9c27f7", "html_url": "https://github.com/rust-lang/rust/commit/70097504f78c4c41368a0b864a94df95fb9c27f7"}], "stats": {"total": 697, "additions": 352, "deletions": 345}, "files": [{"sha": "e8e2ce7eed6effb1440e6bbc362a6da38ae85c37", "filename": "crates/cli/src/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Fcli%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Fcli%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcli%2Fsrc%2Fmain.rs?ref=d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9", "patch": "@@ -10,7 +10,7 @@ use std::{\n };\n use clap::{App, Arg, SubCommand};\n use tools::collect_tests;\n-use libeditor::{File, syntax_tree, file_structure};\n+use libeditor::{ParsedFile, syntax_tree, file_structure};\n \n type Result<T> = ::std::result::Result<T, failure::Error>;\n \n@@ -68,7 +68,7 @@ fn main() -> Result<()> {\n     Ok(())\n }\n \n-fn file() -> Result<File> {\n+fn file() -> Result<ParsedFile> {\n     let text = read_stdin()?;\n     Ok(libeditor::parse(&text))\n }"}, {"sha": "15a433afc9dbd403989026d03575c77e126b31eb", "filename": "crates/libanalysis/src/lib.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibanalysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibanalysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Flib.rs?ref=d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9", "patch": "@@ -26,8 +26,8 @@ use std::{\n };\n \n use libsyntax2::{\n-    TextUnit, TextRange, RefRoot,\n-    ast::{self, AstNode, NameOwner},\n+    TextUnit, TextRange,\n+    ast::{self, AstNode, NameOwner, ParsedFile},\n     SyntaxKind::*,\n };\n use libeditor::{LineIndex, FileSymbol, find_node};\n@@ -109,7 +109,7 @@ impl WorldState {\n \n \n impl World {\n-    pub fn file_syntax(&self, file_id: FileId) -> Result<ast::File> {\n+    pub fn file_syntax(&self, file_id: FileId) -> Result<ParsedFile> {\n         let data = self.file_data(file_id)?;\n         Ok(data.syntax().clone())\n     }\n@@ -137,11 +137,11 @@ impl World {\n         offset: TextUnit,\n     ) -> Result<Vec<(FileId, FileSymbol)>> {\n         let file = self.file_syntax(id)?;\n-        let syntax = file.syntax_ref();\n-        if let Some(name_ref) = find_node::<ast::NameRef<_>>(syntax, offset) {\n+        let syntax = file.syntax();\n+        if let Some(name_ref) = find_node::<ast::NameRef>(syntax, offset) {\n             return Ok(self.index_resolve(name_ref));\n         }\n-        if let Some(name) = find_node::<ast::Name<_>>(syntax, offset) {\n+        if let Some(name) = find_node::<ast::Name>(syntax, offset) {\n             if let Some(module) = name.syntax().parent().and_then(ast::Module::cast) {\n                 if module.has_semi() {\n                     return Ok(self.resolve_module(id, module));\n@@ -151,15 +151,15 @@ impl World {\n         Ok(vec![])\n     }\n \n-    fn index_resolve(&self, name_ref: ast::NameRef<RefRoot>) -> Vec<(FileId, FileSymbol)> {\n+    fn index_resolve(&self, name_ref: ast::NameRef) -> Vec<(FileId, FileSymbol)> {\n         let name = name_ref.text();\n         let mut query = Query::new(name.to_string());\n         query.exact();\n         query.limit(4);\n         self.world_symbols(query)\n     }\n \n-    fn resolve_module(&self, id: FileId, module: ast::Module<RefRoot>) -> Vec<(FileId, FileSymbol)> {\n+    fn resolve_module(&self, id: FileId, module: ast::Module) -> Vec<(FileId, FileSymbol)> {\n         let name = match module.name() {\n             Some(name) => name.text(),\n             None => return Vec::new(),\n@@ -220,7 +220,7 @@ struct WorldData {\n struct FileData {\n     text: String,\n     symbols: OnceCell<FileSymbols>,\n-    syntax: OnceCell<ast::File>,\n+    syntax: OnceCell<ParsedFile>,\n     lines: OnceCell<LineIndex>,\n }\n \n@@ -234,14 +234,14 @@ impl FileData {\n         }\n     }\n \n-    fn syntax(&self) -> &ast::File {\n+    fn syntax(&self) -> &ParsedFile {\n         self.syntax\n-            .get_or_init(|| ast::File::parse(&self.text))\n+            .get_or_init(|| ParsedFile::parse(&self.text))\n     }\n \n-    fn syntax_transient(&self) -> ast::File {\n+    fn syntax_transient(&self) -> ParsedFile {\n         self.syntax.get().map(|s| s.clone())\n-            .unwrap_or_else(|| ast::File::parse(&self.text))\n+            .unwrap_or_else(|| ParsedFile::parse(&self.text))\n     }\n \n     fn symbols(&self) -> &FileSymbols {"}, {"sha": "426de4c760db4d8cc0a05a02ff22b347cf9808d0", "filename": "crates/libanalysis/src/symbol_index.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibanalysis%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibanalysis%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fsymbol_index.rs?ref=d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9", "patch": "@@ -1,6 +1,6 @@\n use libeditor::{FileSymbol, file_symbols};\n use libsyntax2::{\n-    ast,\n+    ParsedFile,\n     SyntaxKind::{self, *},\n };\n use fst::{self, IntoStreamer, Streamer};\n@@ -12,7 +12,7 @@ pub(crate) struct FileSymbols {\n }\n \n impl FileSymbols {\n-    pub(crate) fn new(file: &ast::File) -> FileSymbols {\n+    pub(crate) fn new(file: &ParsedFile) -> FileSymbols {\n         let mut symbols = file_symbols(file)\n             .into_iter()\n             .map(|s| (s.name.as_str().to_lowercase(), s))"}, {"sha": "80c3963378169c9e55054f3beac15858c525dfe0", "filename": "crates/libeditor/src/code_actions.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibeditor%2Fsrc%2Fcode_actions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibeditor%2Fsrc%2Fcode_actions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Fcode_actions.rs?ref=d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9", "patch": "@@ -1,8 +1,8 @@\n-use {TextUnit, File, EditBuilder, Edit};\n+use {TextUnit, EditBuilder, Edit};\n use libsyntax2::{\n-    ast::{self, AstNode, AttrsOwner},\n+    ast::{self, AstNode, AttrsOwner, ParsedFile},\n     SyntaxKind::COMMA,\n-    SyntaxNodeRef, RefRoot,\n+    SyntaxNodeRef,\n     algo::{\n         Direction, siblings,\n         find_leaf_at_offset, ancestors,\n@@ -19,9 +19,8 @@ pub enum CursorPosition {\n     Offset(TextUnit),\n }\n \n-pub fn flip_comma<'a>(file: &'a File, offset: TextUnit) -> Option<impl FnOnce() -> ActionResult + 'a> {\n+pub fn flip_comma<'a>(file: &'a ParsedFile, offset: TextUnit) -> Option<impl FnOnce() -> ActionResult + 'a> {\n     let syntax = file.syntax();\n-    let syntax = syntax.as_ref();\n \n     let comma = find_leaf_at_offset(syntax, offset).find(|leaf| leaf.kind() == COMMA)?;\n     let left = non_trivia_sibling(comma, Direction::Backward)?;\n@@ -37,8 +36,8 @@ pub fn flip_comma<'a>(file: &'a File, offset: TextUnit) -> Option<impl FnOnce()\n     })\n }\n \n-pub fn add_derive<'a>(file: &'a File, offset: TextUnit) -> Option<impl FnOnce() -> ActionResult + 'a> {\n-    let nominal = find_node::<ast::NominalDef<_>>(file.syntax_ref(), offset)?;\n+pub fn add_derive<'a>(file: &'a ParsedFile, offset: TextUnit) -> Option<impl FnOnce() -> ActionResult + 'a> {\n+    let nominal = find_node::<ast::NominalDef>(file.syntax(), offset)?;\n     Some(move || {\n         let derive_attr = nominal\n             .attrs()\n@@ -70,7 +69,7 @@ fn non_trivia_sibling(node: SyntaxNodeRef, direction: Direction) -> Option<Synta\n         .find(|node| !node.kind().is_trivia())\n }\n \n-pub fn find_node<'a, N: AstNode<RefRoot<'a>>>(syntax: SyntaxNodeRef<'a>, offset: TextUnit) -> Option<N> {\n+pub fn find_node<'a, N: AstNode<'a>>(syntax: SyntaxNodeRef<'a>, offset: TextUnit) -> Option<N> {\n     let leaves = find_leaf_at_offset(syntax, offset);\n     let leaf = leaves.clone()\n         .find(|leaf| !leaf.kind().is_trivia())"}, {"sha": "cb6edb57692c68988fa2953388757278f755b34a", "filename": "crates/libeditor/src/extend_selection.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibeditor%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibeditor%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Fextend_selection.rs?ref=d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9", "patch": "@@ -1,11 +1,10 @@\n use libsyntax2::{\n-    ast, AstNode,\n-    TextRange, SyntaxNodeRef,\n+    ParsedFile, TextRange, SyntaxNodeRef,\n     SyntaxKind::WHITESPACE,\n     algo::{find_leaf_at_offset, find_covering_node, ancestors},\n };\n \n-pub fn extend_selection(file: &ast::File, range: TextRange) -> Option<TextRange> {\n+pub fn extend_selection(file: &ParsedFile, range: TextRange) -> Option<TextRange> {\n     let syntax = file.syntax();\n     extend(syntax.as_ref(), range)\n }"}, {"sha": "d9d0369f6ef025794e71e0d365083caa896ff384", "filename": "crates/libeditor/src/lib.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibeditor%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibeditor%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Flib.rs?ref=d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9", "patch": "@@ -15,7 +15,7 @@ use libsyntax2::{\n     algo::{walk, find_leaf_at_offset},\n     SyntaxKind::{self, *},\n };\n-pub use libsyntax2::{File, TextRange, TextUnit};\n+pub use libsyntax2::{ParsedFile, TextRange, TextUnit};\n pub use self::{\n     line_index::{LineIndex, LineCol},\n     extend_selection::extend_selection,\n@@ -51,18 +51,18 @@ pub enum RunnableKind {\n     Bin,\n }\n \n-pub fn parse(text: &str) -> ast::File {\n-    ast::File::parse(text)\n+pub fn parse(text: &str) -> ast::ParsedFile {\n+    ast::ParsedFile::parse(text)\n }\n \n-pub fn matching_brace(file: &ast::File, offset: TextUnit) -> Option<TextUnit> {\n+pub fn matching_brace(file: &ast::ParsedFile, offset: TextUnit) -> Option<TextUnit> {\n     const BRACES: &[SyntaxKind] = &[\n         L_CURLY, R_CURLY,\n         L_BRACK, R_BRACK,\n         L_PAREN, R_PAREN,\n         L_ANGLE, R_ANGLE,\n     ];\n-    let (brace_node, brace_idx) = find_leaf_at_offset(file.syntax_ref(), offset)\n+    let (brace_node, brace_idx) = find_leaf_at_offset(file.syntax(), offset)\n         .filter_map(|node| {\n             let idx = BRACES.iter().position(|&brace| brace == node.kind())?;\n             Some((node, idx))\n@@ -75,9 +75,9 @@ pub fn matching_brace(file: &ast::File, offset: TextUnit) -> Option<TextUnit> {\n     Some(matching_node.range().start())\n }\n \n-pub fn highlight(file: &ast::File) -> Vec<HighlightedRange> {\n+pub fn highlight(file: &ast::ParsedFile) -> Vec<HighlightedRange> {\n     let mut res = Vec::new();\n-    for node in walk::preorder(file.syntax_ref()) {\n+    for node in walk::preorder(file.syntax()) {\n         let tag = match node.kind() {\n             ERROR => \"error\",\n             COMMENT | DOC_COMMENT => \"comment\",\n@@ -98,10 +98,10 @@ pub fn highlight(file: &ast::File) -> Vec<HighlightedRange> {\n     res\n }\n \n-pub fn diagnostics(file: &ast::File) -> Vec<Diagnostic> {\n+pub fn diagnostics(file: &ast::ParsedFile) -> Vec<Diagnostic> {\n     let mut res = Vec::new();\n \n-    for node in walk::preorder(file.syntax_ref()) {\n+    for node in walk::preorder(file.syntax()) {\n         if node.kind() == ERROR {\n             res.push(Diagnostic {\n                 range: node.range(),\n@@ -116,12 +116,12 @@ pub fn diagnostics(file: &ast::File) -> Vec<Diagnostic> {\n     res\n }\n \n-pub fn syntax_tree(file: &ast::File) -> String {\n-    ::libsyntax2::utils::dump_tree(&file.syntax())\n+pub fn syntax_tree(file: &ast::ParsedFile) -> String {\n+    ::libsyntax2::utils::dump_tree(file.syntax())\n }\n \n-pub fn runnables(file: &ast::File) -> Vec<Runnable> {\n-    file\n+pub fn runnables(file: &ast::ParsedFile) -> Vec<Runnable> {\n+    file.ast()\n         .functions()\n         .filter_map(|f| {\n             let name = f.name()?.text();"}, {"sha": "d7bd111e6ef86b877a1660d427d9d5dc7796d5b6", "filename": "crates/libeditor/src/symbols.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibeditor%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibeditor%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Fsymbols.rs?ref=d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9", "patch": "@@ -1,6 +1,6 @@\n use smol_str::SmolStr;\n use libsyntax2::{\n-    SyntaxKind, SyntaxNodeRef, AstNode, RefRoot,\n+    SyntaxKind, SyntaxNodeRef, AstNode, ParsedFile,\n     ast::{self, NameOwner},\n     algo::{\n         visit::{visitor, Visitor},\n@@ -25,14 +25,14 @@ pub struct FileSymbol {\n     pub kind: SyntaxKind,\n }\n \n-pub fn file_symbols(file: &ast::File) -> Vec<FileSymbol> {\n-    preorder(file.syntax_ref())\n+pub fn file_symbols(file: &ParsedFile) -> Vec<FileSymbol> {\n+    preorder(file.syntax())\n         .filter_map(to_symbol)\n         .collect()\n }\n \n fn to_symbol(node: SyntaxNodeRef) -> Option<FileSymbol> {\n-    fn decl<'a, N: NameOwner<RefRoot<'a>>>(node: N) -> Option<FileSymbol> {\n+    fn decl<'a, N: NameOwner<'a>>(node: N) -> Option<FileSymbol> {\n         let name = node.name()?;\n         Some(FileSymbol {\n             name: name.text(),\n@@ -41,23 +41,23 @@ fn to_symbol(node: SyntaxNodeRef) -> Option<FileSymbol> {\n         })\n     }\n     visitor()\n-        .visit(decl::<ast::FnDef<_>>)\n-        .visit(decl::<ast::StructDef<_>>)\n-        .visit(decl::<ast::EnumDef<_>>)\n-        .visit(decl::<ast::TraitDef<_>>)\n-        .visit(decl::<ast::Module<_>>)\n-        .visit(decl::<ast::TypeDef<_>>)\n-        .visit(decl::<ast::ConstDef<_>>)\n-        .visit(decl::<ast::StaticDef<_>>)\n+        .visit(decl::<ast::FnDef>)\n+        .visit(decl::<ast::StructDef>)\n+        .visit(decl::<ast::EnumDef>)\n+        .visit(decl::<ast::TraitDef>)\n+        .visit(decl::<ast::Module>)\n+        .visit(decl::<ast::TypeDef>)\n+        .visit(decl::<ast::ConstDef>)\n+        .visit(decl::<ast::StaticDef>)\n         .accept(node)?\n }\n \n \n-pub fn file_structure(file: &ast::File) -> Vec<StructureNode> {\n+pub fn file_structure(file: &ParsedFile) -> Vec<StructureNode> {\n     let mut res = Vec::new();\n     let mut stack = Vec::new();\n \n-    for event in walk(file.syntax_ref()) {\n+    for event in walk(file.syntax()) {\n         match event {\n             WalkEvent::Enter(node) => {\n                 match structure_node(node) {\n@@ -80,7 +80,7 @@ pub fn file_structure(file: &ast::File) -> Vec<StructureNode> {\n }\n \n fn structure_node(node: SyntaxNodeRef) -> Option<StructureNode> {\n-    fn decl<'a, N: NameOwner<RefRoot<'a>>>(node: N) -> Option<StructureNode> {\n+    fn decl<'a, N: NameOwner<'a>>(node: N) -> Option<StructureNode> {\n         let name = node.name()?;\n         Some(StructureNode {\n             parent: None,\n@@ -92,16 +92,16 @@ fn structure_node(node: SyntaxNodeRef) -> Option<StructureNode> {\n     }\n \n     visitor()\n-        .visit(decl::<ast::FnDef<_>>)\n-        .visit(decl::<ast::StructDef<_>>)\n-        .visit(decl::<ast::NamedField<_>>)\n-        .visit(decl::<ast::EnumDef<_>>)\n-        .visit(decl::<ast::TraitDef<_>>)\n-        .visit(decl::<ast::Module<_>>)\n-        .visit(decl::<ast::TypeDef<_>>)\n-        .visit(decl::<ast::ConstDef<_>>)\n-        .visit(decl::<ast::StaticDef<_>>)\n-        .visit(|im: ast::ImplItem<_>| {\n+        .visit(decl::<ast::FnDef>)\n+        .visit(decl::<ast::StructDef>)\n+        .visit(decl::<ast::NamedField>)\n+        .visit(decl::<ast::EnumDef>)\n+        .visit(decl::<ast::TraitDef>)\n+        .visit(decl::<ast::Module>)\n+        .visit(decl::<ast::TypeDef>)\n+        .visit(decl::<ast::ConstDef>)\n+        .visit(decl::<ast::StaticDef>)\n+        .visit(|im: ast::ImplItem| {\n             let target_type = im.target_type()?;\n             let target_trait = im.target_trait();\n             let label = match target_trait {"}, {"sha": "a2e26003ac8f69b4b4a80dca5e28556f03b76fd2", "filename": "crates/libeditor/tests/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibeditor%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibeditor%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Ftests%2Ftest.rs?ref=d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9", "patch": "@@ -5,7 +5,7 @@ extern crate assert_eq_text;\n \n use assert_eq_text::{assert_eq_dbg};\n use libeditor::{\n-    File, TextUnit, TextRange, ActionResult, CursorPosition,\n+    ParsedFile, TextUnit, TextRange, ActionResult, CursorPosition,\n     highlight, runnables, extend_selection, file_structure,\n     flip_comma, add_derive, matching_brace,\n };\n@@ -146,11 +146,11 @@ fn test_matching_brace() {\n     );\n }\n \n-fn file(text: &str) -> File {\n-    File::parse(text)\n+fn file(text: &str) -> ParsedFile {\n+    ParsedFile::parse(text)\n }\n \n-fn check_action<F: Fn(&File, TextUnit) -> Option<ActionResult>>(\n+fn check_action<F: Fn(&ParsedFile, TextUnit) -> Option<ActionResult>>(\n     before: &str,\n     after: &str,\n     f: F,"}, {"sha": "a36c8f45e1ba5db89092fa0e5337e842ccd5f218", "filename": "crates/libsyntax2/src/algo/visit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibsyntax2%2Fsrc%2Falgo%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibsyntax2%2Fsrc%2Falgo%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Falgo%2Fvisit.rs?ref=d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9", "patch": "@@ -1,5 +1,5 @@\n use std::marker::PhantomData;\n-use {SyntaxNodeRef, AstNode, RefRoot};\n+use {SyntaxNodeRef, AstNode};\n \n \n pub fn visitor<'a, T>() -> impl Visitor<'a, Output=T> {\n@@ -10,7 +10,7 @@ pub trait Visitor<'a>: Sized {\n     type Output;\n     fn accept(self, node: SyntaxNodeRef<'a>) -> Option<Self::Output>;\n     fn visit<N, F>(self, f: F) -> Vis<Self, N, F>\n-        where N: AstNode<RefRoot<'a>>,\n+        where N: AstNode<'a>,\n               F: FnOnce(N) -> Self::Output,\n     {\n         Vis { inner: self, f, ph: PhantomData }\n@@ -40,7 +40,7 @@ pub struct Vis<V, N, F> {\n impl<'a, V, N, F> Visitor<'a> for Vis<V, N, F>\n     where\n         V: Visitor<'a>,\n-        N: AstNode<RefRoot<'a>>,\n+        N: AstNode<'a>,\n         F: FnOnce(N) -> <V as Visitor<'a>>::Output,\n {\n     type Output = <V as Visitor<'a>>::Output;"}, {"sha": "e8a87eba583fda625a0033876a48e857106a7ce3", "filename": "crates/libsyntax2/src/ast/generated.rs", "status": "modified", "additions": 218, "deletions": 218, "changes": 436, "blob_url": "https://github.com/rust-lang/rust/blob/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibsyntax2%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibsyntax2%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fast%2Fgenerated.rs?ref=d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9", "patch": "@@ -1,45 +1,45 @@\n use {\n     ast,\n-    SyntaxNode, OwnedRoot, TreeRoot, AstNode,\n+    SyntaxNodeRef, AstNode,\n     SyntaxKind::*,\n };\n \n // ArrayType\n #[derive(Debug, Clone, Copy)]\n-pub struct ArrayType<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct ArrayType<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for ArrayType<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for ArrayType<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             ARRAY_TYPE => Some(ArrayType { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> ArrayType<R> {}\n+impl<'a> ArrayType<'a> {}\n \n // Attr\n #[derive(Debug, Clone, Copy)]\n-pub struct Attr<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct Attr<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for Attr<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for Attr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             ATTR => Some(Attr { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> Attr<R> {\n-    pub fn value(&self) -> Option<TokenTree<R>> {\n+impl<'a> Attr<'a> {\n+    pub fn value(self) -> Option<TokenTree<'a>> {\n         self.syntax()\n             .children()\n             .filter_map(TokenTree::cast)\n@@ -49,80 +49,80 @@ impl<R: TreeRoot> Attr<R> {\n \n // ConstDef\n #[derive(Debug, Clone, Copy)]\n-pub struct ConstDef<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct ConstDef<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for ConstDef<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for ConstDef<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             CONST_DEF => Some(ConstDef { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> ast::NameOwner<R> for ConstDef<R> {}\n-impl<R: TreeRoot> ast::AttrsOwner<R> for ConstDef<R> {}\n-impl<R: TreeRoot> ConstDef<R> {}\n+impl<'a> ast::NameOwner<'a> for ConstDef<'a> {}\n+impl<'a> ast::AttrsOwner<'a> for ConstDef<'a> {}\n+impl<'a> ConstDef<'a> {}\n \n // DynTraitType\n #[derive(Debug, Clone, Copy)]\n-pub struct DynTraitType<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct DynTraitType<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for DynTraitType<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for DynTraitType<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             DYN_TRAIT_TYPE => Some(DynTraitType { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> DynTraitType<R> {}\n+impl<'a> DynTraitType<'a> {}\n \n // EnumDef\n #[derive(Debug, Clone, Copy)]\n-pub struct EnumDef<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct EnumDef<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for EnumDef<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for EnumDef<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             ENUM_DEF => Some(EnumDef { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> ast::NameOwner<R> for EnumDef<R> {}\n-impl<R: TreeRoot> ast::AttrsOwner<R> for EnumDef<R> {}\n-impl<R: TreeRoot> EnumDef<R> {}\n+impl<'a> ast::NameOwner<'a> for EnumDef<'a> {}\n+impl<'a> ast::AttrsOwner<'a> for EnumDef<'a> {}\n+impl<'a> EnumDef<'a> {}\n \n // File\n #[derive(Debug, Clone, Copy)]\n-pub struct File<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct File<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for File<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for File<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             FILE => Some(File { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> File<R> {\n-    pub fn functions<'a>(&'a self) -> impl Iterator<Item = FnDef<R>> + 'a {\n+impl<'a> File<'a> {\n+    pub fn functions(self) -> impl Iterator<Item = FnDef<'a>> + 'a {\n         self.syntax()\n             .children()\n             .filter_map(FnDef::cast)\n@@ -131,364 +131,364 @@ impl<R: TreeRoot> File<R> {\n \n // FnDef\n #[derive(Debug, Clone, Copy)]\n-pub struct FnDef<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct FnDef<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for FnDef<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for FnDef<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             FN_DEF => Some(FnDef { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> ast::NameOwner<R> for FnDef<R> {}\n-impl<R: TreeRoot> ast::AttrsOwner<R> for FnDef<R> {}\n-impl<R: TreeRoot> FnDef<R> {}\n+impl<'a> ast::NameOwner<'a> for FnDef<'a> {}\n+impl<'a> ast::AttrsOwner<'a> for FnDef<'a> {}\n+impl<'a> FnDef<'a> {}\n \n // FnPointerType\n #[derive(Debug, Clone, Copy)]\n-pub struct FnPointerType<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct FnPointerType<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for FnPointerType<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for FnPointerType<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             FN_POINTER_TYPE => Some(FnPointerType { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> FnPointerType<R> {}\n+impl<'a> FnPointerType<'a> {}\n \n // ForType\n #[derive(Debug, Clone, Copy)]\n-pub struct ForType<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct ForType<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for ForType<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for ForType<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             FOR_TYPE => Some(ForType { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> ForType<R> {}\n+impl<'a> ForType<'a> {}\n \n // ImplItem\n #[derive(Debug, Clone, Copy)]\n-pub struct ImplItem<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct ImplItem<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for ImplItem<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for ImplItem<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             IMPL_ITEM => Some(ImplItem { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> ImplItem<R> {}\n+impl<'a> ImplItem<'a> {}\n \n // ImplTraitType\n #[derive(Debug, Clone, Copy)]\n-pub struct ImplTraitType<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct ImplTraitType<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for ImplTraitType<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for ImplTraitType<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             IMPL_TRAIT_TYPE => Some(ImplTraitType { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> ImplTraitType<R> {}\n+impl<'a> ImplTraitType<'a> {}\n \n // Module\n #[derive(Debug, Clone, Copy)]\n-pub struct Module<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct Module<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for Module<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for Module<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             MODULE => Some(Module { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> ast::NameOwner<R> for Module<R> {}\n-impl<R: TreeRoot> ast::AttrsOwner<R> for Module<R> {}\n-impl<R: TreeRoot> Module<R> {}\n+impl<'a> ast::NameOwner<'a> for Module<'a> {}\n+impl<'a> ast::AttrsOwner<'a> for Module<'a> {}\n+impl<'a> Module<'a> {}\n \n // Name\n #[derive(Debug, Clone, Copy)]\n-pub struct Name<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct Name<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for Name<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for Name<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             NAME => Some(Name { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> Name<R> {}\n+impl<'a> Name<'a> {}\n \n // NameRef\n #[derive(Debug, Clone, Copy)]\n-pub struct NameRef<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct NameRef<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for NameRef<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for NameRef<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             NAME_REF => Some(NameRef { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> NameRef<R> {}\n+impl<'a> NameRef<'a> {}\n \n // NamedField\n #[derive(Debug, Clone, Copy)]\n-pub struct NamedField<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct NamedField<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for NamedField<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for NamedField<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             NAMED_FIELD => Some(NamedField { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> ast::NameOwner<R> for NamedField<R> {}\n-impl<R: TreeRoot> ast::AttrsOwner<R> for NamedField<R> {}\n-impl<R: TreeRoot> NamedField<R> {}\n+impl<'a> ast::NameOwner<'a> for NamedField<'a> {}\n+impl<'a> ast::AttrsOwner<'a> for NamedField<'a> {}\n+impl<'a> NamedField<'a> {}\n \n // NeverType\n #[derive(Debug, Clone, Copy)]\n-pub struct NeverType<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct NeverType<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for NeverType<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for NeverType<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             NEVER_TYPE => Some(NeverType { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> NeverType<R> {}\n+impl<'a> NeverType<'a> {}\n \n // NominalDef\n #[derive(Debug, Clone, Copy)]\n-pub enum NominalDef<R: TreeRoot = OwnedRoot> {\n-    StructDef(StructDef<R>),\n-    EnumDef(EnumDef<R>),\n+pub enum NominalDef<'a> {\n+    StructDef(StructDef<'a>),\n+    EnumDef(EnumDef<'a>),\n }\n \n-impl<R: TreeRoot> AstNode<R> for NominalDef<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for NominalDef<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             STRUCT_DEF => Some(NominalDef::StructDef(StructDef { syntax })),\n             ENUM_DEF => Some(NominalDef::EnumDef(EnumDef { syntax })),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> {\n+    fn syntax(self) -> SyntaxNodeRef<'a> {\n         match self {\n             NominalDef::StructDef(inner) => inner.syntax(),\n             NominalDef::EnumDef(inner) => inner.syntax(),\n         }\n     }\n }\n \n-impl<R: TreeRoot> ast::AttrsOwner<R> for NominalDef<R> {}\n-impl<R: TreeRoot> NominalDef<R> {}\n+impl<'a> ast::AttrsOwner<'a> for NominalDef<'a> {}\n+impl<'a> NominalDef<'a> {}\n \n // ParenType\n #[derive(Debug, Clone, Copy)]\n-pub struct ParenType<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct ParenType<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for ParenType<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for ParenType<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             PAREN_TYPE => Some(ParenType { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> ParenType<R> {}\n+impl<'a> ParenType<'a> {}\n \n // PathType\n #[derive(Debug, Clone, Copy)]\n-pub struct PathType<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct PathType<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for PathType<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for PathType<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             PATH_TYPE => Some(PathType { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> PathType<R> {}\n+impl<'a> PathType<'a> {}\n \n // PlaceholderType\n #[derive(Debug, Clone, Copy)]\n-pub struct PlaceholderType<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct PlaceholderType<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for PlaceholderType<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for PlaceholderType<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             PLACEHOLDER_TYPE => Some(PlaceholderType { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> PlaceholderType<R> {}\n+impl<'a> PlaceholderType<'a> {}\n \n // PointerType\n #[derive(Debug, Clone, Copy)]\n-pub struct PointerType<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct PointerType<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for PointerType<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for PointerType<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             POINTER_TYPE => Some(PointerType { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> PointerType<R> {}\n+impl<'a> PointerType<'a> {}\n \n // ReferenceType\n #[derive(Debug, Clone, Copy)]\n-pub struct ReferenceType<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct ReferenceType<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for ReferenceType<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for ReferenceType<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             REFERENCE_TYPE => Some(ReferenceType { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> ReferenceType<R> {}\n+impl<'a> ReferenceType<'a> {}\n \n // SliceType\n #[derive(Debug, Clone, Copy)]\n-pub struct SliceType<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct SliceType<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for SliceType<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for SliceType<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             SLICE_TYPE => Some(SliceType { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> SliceType<R> {}\n+impl<'a> SliceType<'a> {}\n \n // StaticDef\n #[derive(Debug, Clone, Copy)]\n-pub struct StaticDef<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct StaticDef<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for StaticDef<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for StaticDef<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             STATIC_DEF => Some(StaticDef { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> ast::NameOwner<R> for StaticDef<R> {}\n-impl<R: TreeRoot> ast::AttrsOwner<R> for StaticDef<R> {}\n-impl<R: TreeRoot> StaticDef<R> {}\n+impl<'a> ast::NameOwner<'a> for StaticDef<'a> {}\n+impl<'a> ast::AttrsOwner<'a> for StaticDef<'a> {}\n+impl<'a> StaticDef<'a> {}\n \n // StructDef\n #[derive(Debug, Clone, Copy)]\n-pub struct StructDef<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct StructDef<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for StructDef<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for StructDef<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             STRUCT_DEF => Some(StructDef { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> ast::NameOwner<R> for StructDef<R> {}\n-impl<R: TreeRoot> ast::AttrsOwner<R> for StructDef<R> {}\n-impl<R: TreeRoot> StructDef<R> {\n-    pub fn fields<'a>(&'a self) -> impl Iterator<Item = NamedField<R>> + 'a {\n+impl<'a> ast::NameOwner<'a> for StructDef<'a> {}\n+impl<'a> ast::AttrsOwner<'a> for StructDef<'a> {}\n+impl<'a> StructDef<'a> {\n+    pub fn fields(self) -> impl Iterator<Item = NamedField<'a>> + 'a {\n         self.syntax()\n             .children()\n             .filter_map(NamedField::cast)\n@@ -497,100 +497,100 @@ impl<R: TreeRoot> StructDef<R> {\n \n // TokenTree\n #[derive(Debug, Clone, Copy)]\n-pub struct TokenTree<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct TokenTree<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for TokenTree<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for TokenTree<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             TOKEN_TREE => Some(TokenTree { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> TokenTree<R> {}\n+impl<'a> TokenTree<'a> {}\n \n // TraitDef\n #[derive(Debug, Clone, Copy)]\n-pub struct TraitDef<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct TraitDef<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for TraitDef<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for TraitDef<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             TRAIT_DEF => Some(TraitDef { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> ast::NameOwner<R> for TraitDef<R> {}\n-impl<R: TreeRoot> ast::AttrsOwner<R> for TraitDef<R> {}\n-impl<R: TreeRoot> TraitDef<R> {}\n+impl<'a> ast::NameOwner<'a> for TraitDef<'a> {}\n+impl<'a> ast::AttrsOwner<'a> for TraitDef<'a> {}\n+impl<'a> TraitDef<'a> {}\n \n // TupleType\n #[derive(Debug, Clone, Copy)]\n-pub struct TupleType<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct TupleType<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for TupleType<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for TupleType<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             TUPLE_TYPE => Some(TupleType { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> TupleType<R> {}\n+impl<'a> TupleType<'a> {}\n \n // TypeDef\n #[derive(Debug, Clone, Copy)]\n-pub struct TypeDef<R: TreeRoot = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+pub struct TypeDef<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for TypeDef<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for TypeDef<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             TYPE_DEF => Some(TypeDef { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<R: TreeRoot> ast::NameOwner<R> for TypeDef<R> {}\n-impl<R: TreeRoot> ast::AttrsOwner<R> for TypeDef<R> {}\n-impl<R: TreeRoot> TypeDef<R> {}\n+impl<'a> ast::NameOwner<'a> for TypeDef<'a> {}\n+impl<'a> ast::AttrsOwner<'a> for TypeDef<'a> {}\n+impl<'a> TypeDef<'a> {}\n \n // TypeRef\n #[derive(Debug, Clone, Copy)]\n-pub enum TypeRef<R: TreeRoot = OwnedRoot> {\n-    ParenType(ParenType<R>),\n-    TupleType(TupleType<R>),\n-    NeverType(NeverType<R>),\n-    PathType(PathType<R>),\n-    PointerType(PointerType<R>),\n-    ArrayType(ArrayType<R>),\n-    SliceType(SliceType<R>),\n-    ReferenceType(ReferenceType<R>),\n-    PlaceholderType(PlaceholderType<R>),\n-    FnPointerType(FnPointerType<R>),\n-    ForType(ForType<R>),\n-    ImplTraitType(ImplTraitType<R>),\n-    DynTraitType(DynTraitType<R>),\n-}\n-\n-impl<R: TreeRoot> AstNode<R> for TypeRef<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+pub enum TypeRef<'a> {\n+    ParenType(ParenType<'a>),\n+    TupleType(TupleType<'a>),\n+    NeverType(NeverType<'a>),\n+    PathType(PathType<'a>),\n+    PointerType(PointerType<'a>),\n+    ArrayType(ArrayType<'a>),\n+    SliceType(SliceType<'a>),\n+    ReferenceType(ReferenceType<'a>),\n+    PlaceholderType(PlaceholderType<'a>),\n+    FnPointerType(FnPointerType<'a>),\n+    ForType(ForType<'a>),\n+    ImplTraitType(ImplTraitType<'a>),\n+    DynTraitType(DynTraitType<'a>),\n+}\n+\n+impl<'a> AstNode<'a> for TypeRef<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             PAREN_TYPE => Some(TypeRef::ParenType(ParenType { syntax })),\n             TUPLE_TYPE => Some(TypeRef::TupleType(TupleType { syntax })),\n@@ -608,7 +608,7 @@ impl<R: TreeRoot> AstNode<R> for TypeRef<R> {\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> {\n+    fn syntax(self) -> SyntaxNodeRef<'a> {\n         match self {\n             TypeRef::ParenType(inner) => inner.syntax(),\n             TypeRef::TupleType(inner) => inner.syntax(),\n@@ -627,5 +627,5 @@ impl<R: TreeRoot> AstNode<R> for TypeRef<R> {\n     }\n }\n \n-impl<R: TreeRoot> TypeRef<R> {}\n+impl<'a> TypeRef<'a> {}\n "}, {"sha": "0572cceaab6cd9bfdb986d71bdaeb3020797514d", "filename": "crates/libsyntax2/src/ast/generated.rs.tera", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibsyntax2%2Fsrc%2Fast%2Fgenerated.rs.tera", "raw_url": "https://github.com/rust-lang/rust/raw/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibsyntax2%2Fsrc%2Fast%2Fgenerated.rs.tera", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fast%2Fgenerated.rs.tera?ref=d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9", "patch": "@@ -1,29 +1,28 @@\n-use std::sync::Arc;\n use {\n     ast,\n-    SyntaxNode, SyntaxRoot, TreeRoot, AstNode,\n+    SyntaxNodeRef, AstNode,\n     SyntaxKind::*,\n };\n {% for node, methods in ast %}\n // {{ node }}\n {%- if methods.enum %}\n #[derive(Debug, Clone, Copy)]\n-pub enum {{ node }}<R: TreeRoot = Arc<SyntaxRoot>> {\n+pub enum {{ node }}<'a> {\n {%- for kind in methods.enum %}\n-    {{ kind }}({{ kind }}<R>),\n+    {{ kind }}({{ kind }}<'a>),\n {%- endfor %}\n }\n \n-impl<R: TreeRoot> AstNode<R> for {{ node }}<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for {{ node }}<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n {%- for kind in methods.enum %}\n             {{ kind | SCREAM }} => Some({{ node }}::{{ kind }}({{ kind }} { syntax })),\n {%- endfor %}\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> {\n+    fn syntax(self) -> SyntaxNodeRef<'a> {\n         match self {\n {%- for kind in methods.enum %}\n             {{ node }}::{{ kind }}(inner) => inner.syntax(),\n@@ -33,32 +32,32 @@ impl<R: TreeRoot> AstNode<R> for {{ node }}<R> {\n }\n {% else %}\n #[derive(Debug, Clone, Copy)]\n-pub struct {{ node }}<R: TreeRoot = Arc<SyntaxRoot>> {\n-    syntax: SyntaxNode<R>,\n+pub struct {{ node }}<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n }\n \n-impl<R: TreeRoot> AstNode<R> for {{ node }}<R> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+impl<'a> AstNode<'a> for {{ node }}<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n             {{ node | SCREAM }} => Some({{ node }} { syntax }),\n             _ => None,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode<R> { &self.syntax }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n {% endif %}\n {% if methods.traits -%}\n {%- for t in methods.traits -%}\n-impl<R: TreeRoot> ast::{{ t }}<R> for {{ node }}<R> {}\n+impl<'a> ast::{{ t }}<'a> for {{ node }}<'a> {}\n {% endfor -%}\n {%- endif -%}\n \n-impl<R: TreeRoot> {{ node }}<R> {\n+impl<'a> {{ node }}<'a> {\n {%- if methods.collections -%}\n {%- for m in methods.collections -%}\n {%- set method_name = m.0 -%}\n {%- set ChildName = m.1 %}\n-    pub fn {{ method_name }}<'a>(&'a self) -> impl Iterator<Item = {{ ChildName }}<R>> + 'a {\n+    pub fn {{ method_name }}(self) -> impl Iterator<Item = {{ ChildName }}<'a>> + 'a {\n         self.syntax()\n             .children()\n             .filter_map({{ ChildName }}::cast)\n@@ -70,7 +69,7 @@ impl<R: TreeRoot> {{ node }}<R> {\n {%- for m in methods.options -%}\n {%- set method_name = m.0 -%}\n {%- set ChildName = m.1 %}\n-    pub fn {{ method_name }}(&self) -> Option<{{ ChildName }}<R>> {\n+    pub fn {{ method_name }}(self) -> Option<{{ ChildName }}<'a>> {\n         self.syntax()\n             .children()\n             .filter_map({{ ChildName }}::cast)"}, {"sha": "46509b5ec6ad0608a40c4dbded4fdd2719a4c44f", "filename": "crates/libsyntax2/src/ast/mod.rs", "status": "modified", "additions": 34, "deletions": 27, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibsyntax2%2Fsrc%2Fast%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibsyntax2%2Fsrc%2Fast%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fast%2Fmod.rs?ref=d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9", "patch": "@@ -4,58 +4,65 @@ use itertools::Itertools;\n use smol_str::SmolStr;\n \n use {\n-    SyntaxNode, SyntaxNodeRef, OwnedRoot, TreeRoot, SyntaxError,\n+    SyntaxNode, SyntaxNodeRef, TreeRoot, SyntaxError,\n     SyntaxKind::*,\n };\n pub use self::generated::*;\n \n-pub trait AstNode<R: TreeRoot> {\n-    fn cast(syntax: SyntaxNode<R>) -> Option<Self>\n+pub trait AstNode<'a>: Clone + Copy {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self>\n         where Self: Sized;\n-    fn syntax(&self) -> &SyntaxNode<R>;\n-    fn syntax_ref<'a>(&'a self) -> SyntaxNodeRef<'a> where R: 'a {\n-        self.syntax().as_ref()\n-    }\n+    fn syntax(self) -> SyntaxNodeRef<'a>;\n }\n \n-pub trait NameOwner<R: TreeRoot>: AstNode<R> {\n-    fn name(&self) -> Option<Name<R>> {\n+pub trait NameOwner<'a>: AstNode<'a> {\n+    fn name(self) -> Option<Name<'a>> {\n         self.syntax()\n             .children()\n             .filter_map(Name::cast)\n             .next()\n     }\n }\n \n-pub trait AttrsOwner<R: TreeRoot>: AstNode<R> {\n-    fn attrs<'a>(&'a self) -> Box<Iterator<Item=Attr<R>> + 'a> where R: 'a {\n+pub trait AttrsOwner<'a>: AstNode<'a> {\n+    fn attrs(&self) -> Box<Iterator<Item=Attr<'a>> + 'a> {\n         let it = self.syntax().children()\n             .filter_map(Attr::cast);\n         Box::new(it)\n     }\n }\n \n-impl File<OwnedRoot> {\n-    pub fn parse(text: &str) -> Self {\n-        File::cast(::parse(text)).unwrap()\n-    }\n+#[derive(Clone, Debug)]\n+pub struct ParsedFile {\n+    root: SyntaxNode\n }\n \n-impl<R: TreeRoot> File<R> {\n+impl ParsedFile {\n+    pub fn parse(text: &str) -> Self {\n+        let root = ::parse(text);\n+        ParsedFile { root }\n+    }\n+    pub fn ast(&self) -> File {\n+        File::cast(self.syntax()).unwrap()\n+    }\n+    pub fn syntax(&self) -> SyntaxNodeRef {\n+        self.root.as_ref()\n+    }\n     pub fn errors(&self) -> Vec<SyntaxError> {\n         self.syntax().root.syntax_root().errors.clone()\n     }\n+\n }\n \n-impl<R: TreeRoot> FnDef<R> {\n+impl<'a> FnDef<'a> {\n     pub fn has_atom_attr(&self, atom: &str) -> bool {\n         self.attrs()\n             .filter_map(|x| x.as_atom())\n             .any(|x| x == atom)\n     }\n }\n \n-impl<R: TreeRoot> Attr<R> {\n+impl<'a> Attr<'a> {\n     pub fn as_atom(&self) -> Option<SmolStr> {\n         let tt = self.value()?;\n         let (_bra, attr, _ket) = tt.syntax().children().collect_tuple()?;\n@@ -66,7 +73,7 @@ impl<R: TreeRoot> Attr<R> {\n         }\n     }\n \n-    pub fn as_call(&self) -> Option<(SmolStr, TokenTree<R>)> {\n+    pub fn as_call(&self) -> Option<(SmolStr, TokenTree<'a>)> {\n         let tt = self.value()?;\n         let (_bra, attr, args, _ket) = tt.syntax().children().collect_tuple()?;\n         let args = TokenTree::cast(args)?;\n@@ -78,48 +85,48 @@ impl<R: TreeRoot> Attr<R> {\n     }\n }\n \n-impl<R: TreeRoot> Name<R> {\n+impl<'a> Name<'a> {\n     pub fn text(&self) -> SmolStr {\n         let ident = self.syntax().first_child()\n             .unwrap();\n         ident.leaf_text().unwrap()\n     }\n }\n \n-impl<R: TreeRoot> NameRef<R> {\n+impl<'a> NameRef<'a> {\n     pub fn text(&self) -> SmolStr {\n         let ident = self.syntax().first_child()\n             .unwrap();\n         ident.leaf_text().unwrap()\n     }\n }\n \n-impl <R: TreeRoot> ImplItem<R> {\n-    pub fn target_type(&self) -> Option<TypeRef<R>> {\n+impl<'a> ImplItem<'a> {\n+    pub fn target_type(&self) -> Option<TypeRef<'a>> {\n         match self.target() {\n             (Some(t), None) | (_, Some(t)) => Some(t),\n             _ => None,\n         }\n     }\n \n-    pub fn target_trait(&self) -> Option<TypeRef<R>> {\n+    pub fn target_trait(&self) -> Option<TypeRef<'a>> {\n         match self.target() {\n             (Some(t), Some(_)) => Some(t),\n             _ => None,\n         }\n     }\n \n-    fn target(&self) -> (Option<TypeRef<R>>, Option<TypeRef<R>>) {\n+    fn target(&self) -> (Option<TypeRef<'a>>, Option<TypeRef<'a>>) {\n         let mut types = self.syntax().children().filter_map(TypeRef::cast);\n         let first = types.next();\n         let second = types.next();\n         (first, second)\n     }\n }\n \n-impl <R: TreeRoot> Module<R> {\n+impl<'a> Module<'a> {\n     pub fn has_semi(&self) -> bool {\n-        match self.syntax_ref().last_child() {\n+        match self.syntax().last_child() {\n             None => false,\n             Some(node) => node.kind() == SEMI,\n         }"}, {"sha": "e837a8d2dbff90f763b0fa449326844602756959", "filename": "crates/libsyntax2/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibsyntax2%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibsyntax2%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Flib.rs?ref=d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9", "patch": "@@ -41,7 +41,7 @@ mod yellow;\n pub mod utils;\n \n pub use {\n-    ast::{AstNode, File},\n+    ast::{AstNode, ParsedFile},\n     lexer::{tokenize, Token},\n     syntax_kinds::SyntaxKind,\n     text_unit::{TextRange, TextUnit},"}, {"sha": "fbe48dd71c2433afdb0defc8ab9b91fb75d2a015", "filename": "crates/libsyntax2/src/utils.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibsyntax2%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibsyntax2%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Futils.rs?ref=d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9", "patch": "@@ -1,12 +1,11 @@\n use std::fmt::Write;\n use {\n     algo::walk::{walk, WalkEvent},\n-    SyntaxNode, TreeRoot,\n+    SyntaxNodeRef, TreeRoot,\n };\n \n /// Parse a file and create a string representation of the resulting parse tree.\n-pub fn dump_tree(syntax: &SyntaxNode) -> String {\n-    let syntax = syntax.as_ref();\n+pub fn dump_tree(syntax: SyntaxNodeRef) -> String {\n     let mut errors: Vec<_> = syntax.root.syntax_root().errors.iter().cloned().collect();\n     errors.sort_by_key(|e| e.offset);\n     let mut err_pos = 0;"}, {"sha": "87e4a159de634c5522ea5107b1b25b2505a58184", "filename": "crates/libsyntax2/src/yellow/syntax.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibsyntax2%2Fsrc%2Fyellow%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibsyntax2%2Fsrc%2Fyellow%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fyellow%2Fsyntax.rs?ref=d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9", "patch": "@@ -71,12 +71,16 @@ impl<R: TreeRoot> SyntaxNode<R> {\n         self.red().green().text()\n     }\n \n-    pub fn children<'a>(&'a self) -> impl Iterator<Item = SyntaxNode<R>> + 'a {\n-        let red = self.red();\n-        let n_children = red.n_children();\n-        (0..n_children).map(move |i| SyntaxNode {\n-            root: self.root.clone(),\n-            red: red.get_child(i).unwrap(),\n+    pub fn children(&self) -> impl Iterator<Item = SyntaxNode<R>> {\n+        let red = self.red;\n+        let n_children = self.red().n_children();\n+        let root = self.root.clone();\n+        (0..n_children).map(move |i| {\n+            let red = unsafe { red.get(&root) };\n+            SyntaxNode {\n+                root: root.clone(),\n+                red: red.get_child(i).unwrap(),\n+            }\n         })\n     }\n "}, {"sha": "d35935c646e3a65ead76e4e8a9fe0f03b27e9c50", "filename": "crates/libsyntax2/tests/test/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibsyntax2%2Ftests%2Ftest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9/crates%2Flibsyntax2%2Ftests%2Ftest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Ftests%2Ftest%2Fmain.rs?ref=d3c90ded2b9a4f75e101fa3abc60cd3aebc439c9", "patch": "@@ -21,7 +21,7 @@ fn lexer_tests() {\n fn parser_tests() {\n     dir_tests(&[\"parser/inline\", \"parser/ok\", \"parser/err\"], |text| {\n         let file = libsyntax2::parse(text);\n-        libsyntax2::utils::dump_tree(&file)\n+        libsyntax2::utils::dump_tree(file.as_ref())\n     })\n }\n "}]}