{"sha": "f1124a2f55406be8e758488352c59ae9deef17b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxMTI0YTJmNTU0MDZiZThlNzU4NDg4MzUyYzU5YWU5ZGVlZjE3YjM=", "commit": {"author": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-05-24T22:08:45Z"}, "committer": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-10-29T16:09:19Z"}, "message": "Add parser for `#[repr(...)]`; nothing uses it yet.\n\nAlso export enum attrs into metadata, and add a convenient interface for\nobtaining the repr hint from either a local or remote definition.", "tree": {"sha": "06cd816c346551e82db912d0edc7b4872a36de57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06cd816c346551e82db912d0edc7b4872a36de57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1124a2f55406be8e758488352c59ae9deef17b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1124a2f55406be8e758488352c59ae9deef17b3", "html_url": "https://github.com/rust-lang/rust/commit/f1124a2f55406be8e758488352c59ae9deef17b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1124a2f55406be8e758488352c59ae9deef17b3/comments", "author": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6650c87a3800264a043b7f129e6a4841c4cc3f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6650c87a3800264a043b7f129e6a4841c4cc3f7", "html_url": "https://github.com/rust-lang/rust/commit/e6650c87a3800264a043b7f129e6a4841c4cc3f7"}], "stats": {"total": 145, "additions": 133, "deletions": 12}, "files": [{"sha": "86c4ca0158f19c8d25a8f888acced425a8a698c8", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1124a2f55406be8e758488352c59ae9deef17b3/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1124a2f55406be8e758488352c59ae9deef17b3/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=f1124a2f55406be8e758488352c59ae9deef17b3", "patch": "@@ -989,6 +989,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_family(ebml_w, 't');\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ecx, ebml_w, item.ident);\n+        encode_attributes(ebml_w, item.attrs);\n         for v in (*enum_definition).variants.iter() {\n             encode_variant_id(ebml_w, local_def(v.node.id));\n         }"}, {"sha": "3945fcd80ae8a72eaff15e144990989ea77893b0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 37, "deletions": 11, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f1124a2f55406be8e758488352c59ae9deef17b3/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1124a2f55406be8e758488352c59ae9deef17b3/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f1124a2f55406be8e758488352c59ae9deef17b3", "patch": "@@ -38,6 +38,7 @@ use syntax::ast::*;\n use syntax::ast_util::is_local;\n use syntax::ast_util;\n use syntax::attr;\n+use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n use syntax::codemap;\n use syntax::parse::token;\n@@ -4101,27 +4102,42 @@ pub fn lookup_trait_def(cx: ctxt, did: ast::DefId) -> @ty::TraitDef {\n     }\n }\n \n-/// Determine whether an item is annotated with an attribute\n-pub fn has_attr(tcx: ctxt, did: DefId, attr: &str) -> bool {\n+/// Iterate over meta_items of a definition.\n+// (This should really be an iterator, but that would require csearch and\n+// decoder to use iterators instead of higher-order functions.)\n+pub fn each_attr(tcx: ctxt, did: DefId, f: &fn(@MetaItem) -> bool) -> bool {\n     if is_local(did) {\n         match tcx.items.find(&did.node) {\n-            Some(\n-                &ast_map::node_item(@ast::item {\n-                    attrs: ref attrs,\n-                    _\n-                }, _)) => attr::contains_name(*attrs, attr),\n+            Some(&ast_map::node_item(@ast::item {attrs: ref attrs, _}, _)) =>\n+                attrs.iter().advance(|attr| f(attr.node.value)),\n             _ => tcx.sess.bug(format!(\"has_attr: {:?} is not an item\",\n-                                   did))\n+                                      did))\n         }\n     } else {\n-        let mut ret = false;\n+        let mut cont = true;\n         do csearch::get_item_attrs(tcx.cstore, did) |meta_items| {\n-            ret = ret || attr::contains_name(meta_items, attr);\n+            if cont {\n+                cont = meta_items.iter().advance(|ptrptr| f(*ptrptr));\n+            }\n         }\n-        ret\n+        return cont;\n     }\n }\n \n+/// Determine whether an item is annotated with an attribute\n+pub fn has_attr(tcx: ctxt, did: DefId, attr: &str) -> bool {\n+    let mut found = false;\n+    each_attr(tcx, did, |item| {\n+        if attr == item.name() {\n+            found = true;\n+            false\n+        } else {\n+            true\n+        }\n+    });\n+    return found;\n+}\n+\n /// Determine whether an item is annotated with `#[packed]`\n pub fn lookup_packed(tcx: ctxt, did: DefId) -> bool {\n     has_attr(tcx, did, \"packed\")\n@@ -4132,6 +4148,16 @@ pub fn lookup_simd(tcx: ctxt, did: DefId) -> bool {\n     has_attr(tcx, did, \"simd\")\n }\n \n+// Obtain the the representation annotation for a definition.\n+pub fn lookup_repr_hint(tcx: ctxt, did: DefId) -> attr::ReprAttr {\n+    let mut acc = attr::ReprAny;\n+    ty::each_attr(tcx, did, |meta| {\n+        acc = attr::find_repr_attr(tcx.sess.diagnostic(), meta, acc);\n+        true\n+    });\n+    return acc;\n+}\n+\n // Look up a field ID, whether or not it's local\n // Takes a list of type substs in case the struct is generic\n pub fn lookup_field_type(tcx: ctxt,"}, {"sha": "e538e09c0569223f1b84536960316b00467026bc", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 95, "deletions": 1, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f1124a2f55406be8e758488352c59ae9deef17b3/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1124a2f55406be8e758488352c59ae9deef17b3/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=f1124a2f55406be8e758488352c59ae9deef17b3", "patch": "@@ -14,7 +14,7 @@ use extra;\n \n use ast;\n use ast::{Attribute, Attribute_, MetaItem, MetaWord, MetaNameValue, MetaList};\n-use codemap::{Spanned, spanned, dummy_spanned};\n+use codemap::{Span, Spanned, spanned, dummy_spanned};\n use codemap::BytePos;\n use diagnostic::span_handler;\n use parse::comments::{doc_comment_style, strip_doc_comment_decoration};\n@@ -363,3 +363,97 @@ pub fn require_unique_names(diagnostic: @mut span_handler,\n         }\n     }\n }\n+\n+\n+/**\n+ * Fold this over attributes to parse #[repr(...)] forms.\n+ *\n+ * Valid repr contents: any of the primitive integral type names (see\n+ * `int_type_of_word`, below) to specify the discriminant type; and `C`, to use\n+ * the same discriminant size that the corresponding C enum would.  These are\n+ * not allowed on univariant or zero-variant enums, which have no discriminant.\n+ *\n+ * If a discriminant type is so specified, then the discriminant will be\n+ * present (before fields, if any) with that type; reprensentation\n+ * optimizations which would remove it will not be done.\n+ */\n+pub fn find_repr_attr(diagnostic: @mut span_handler, attr: @ast::MetaItem, acc: ReprAttr)\n+    -> ReprAttr {\n+    let mut acc = acc;\n+    match attr.node {\n+        ast::MetaList(s, ref items) if \"repr\" == s => {\n+            for item in items.iter() {\n+                match item.node {\n+                    ast::MetaWord(word) => {\n+                        let word: &str = word;\n+                        let hint = match word {\n+                            // Can't use \"extern\" because it's not a lexical identifier.\n+                            \"C\" => ReprExtern,\n+                            _ => match int_type_of_word(word) {\n+                                Some(ity) => ReprInt(item.span, ity),\n+                                None => {\n+                                    // Not a word we recognize\n+                                    diagnostic.span_err(item.span,\n+                                                        \"unrecognized representation hint\");\n+                                    ReprAny\n+                                }\n+                            }\n+                        };\n+                        if hint != ReprAny {\n+                            if acc == ReprAny {\n+                                acc = hint;\n+                            } else if acc != hint {\n+                                diagnostic.span_warn(item.span,\n+                                                     \"conflicting representation hint ignored\")\n+                            }\n+                        }\n+                    }\n+                    // Not a word:\n+                    _ => diagnostic.span_err(item.span, \"unrecognized representation hint\")\n+                }\n+            }\n+        }\n+        // Not a \"repr\" hint: ignore.\n+        _ => { }\n+    }\n+    return acc;\n+}\n+\n+fn int_type_of_word(s: &str) -> Option<IntType> {\n+    match s {\n+        \"i8\" => Some(SignedInt(ast::ty_i8)),\n+        \"u8\" => Some(UnsignedInt(ast::ty_u8)),\n+        \"i16\" => Some(SignedInt(ast::ty_i16)),\n+        \"u16\" => Some(UnsignedInt(ast::ty_u16)),\n+        \"i32\" => Some(SignedInt(ast::ty_i32)),\n+        \"u32\" => Some(UnsignedInt(ast::ty_u32)),\n+        \"i64\" => Some(SignedInt(ast::ty_i64)),\n+        \"u64\" => Some(UnsignedInt(ast::ty_u64)),\n+        \"int\" => Some(SignedInt(ast::ty_i)),\n+        \"uint\" => Some(UnsignedInt(ast::ty_u)),\n+        _ => None\n+    }\n+}\n+\n+#[deriving(Eq)]\n+pub enum ReprAttr {\n+    ReprAny,\n+    ReprInt(Span, IntType),\n+    ReprExtern\n+}\n+\n+#[deriving(Eq)]\n+pub enum IntType {\n+    SignedInt(ast::int_ty),\n+    UnsignedInt(ast::uint_ty)\n+}\n+\n+impl IntType {\n+    #[inline]\n+    pub fn is_signed(self) -> bool {\n+        match self {\n+            SignedInt(*) => true,\n+            UnsignedInt(*) => false\n+        }\n+    }\n+}"}]}