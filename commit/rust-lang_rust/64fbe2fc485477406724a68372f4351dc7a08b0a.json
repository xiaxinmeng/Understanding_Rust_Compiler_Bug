{"sha": "64fbe2fc485477406724a68372f4351dc7a08b0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0ZmJlMmZjNDg1NDc3NDA2NzI0YTY4MzcyZjQzNTFkYzdhMDhiMGE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-23T13:42:35Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-25T13:44:16Z"}, "message": "Add helper method for determining the type of a discriminant", "tree": {"sha": "b300c56089ab6be9cd8d1caecbf62485ac351896", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b300c56089ab6be9cd8d1caecbf62485ac351896"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64fbe2fc485477406724a68372f4351dc7a08b0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64fbe2fc485477406724a68372f4351dc7a08b0a", "html_url": "https://github.com/rust-lang/rust/commit/64fbe2fc485477406724a68372f4351dc7a08b0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64fbe2fc485477406724a68372f4351dc7a08b0a/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d94923ea469b4c104719071a82a4bc051fed77ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/d94923ea469b4c104719071a82a4bc051fed77ac", "html_url": "https://github.com/rust-lang/rust/commit/d94923ea469b4c104719071a82a4bc051fed77ac"}], "stats": {"total": 84, "additions": 35, "deletions": 49}, "files": [{"sha": "174da7db1753dad60894a2a79b44e44ffbc93dca", "filename": "src/librustc_middle/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/64fbe2fc485477406724a68372f4351dc7a08b0a/src%2Flibrustc_middle%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64fbe2fc485477406724a68372f4351dc7a08b0a/src%2Flibrustc_middle%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Ftcx.rs?ref=64fbe2fc485477406724a68372f4351dc7a08b0a", "patch": "@@ -5,7 +5,6 @@\n \n use crate::mir::*;\n use crate::ty::subst::Subst;\n-use crate::ty::util::IntTypeExt;\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_hir as hir;\n use rustc_target::abi::VariantIdx;\n@@ -175,15 +174,7 @@ impl<'tcx> Rvalue<'tcx> {\n             }\n             Rvalue::UnaryOp(UnOp::Not | UnOp::Neg, ref operand) => operand.ty(local_decls, tcx),\n             Rvalue::Discriminant(ref place) => {\n-                let ty = place.ty(local_decls, tcx).ty;\n-                match ty.kind {\n-                    ty::Adt(adt_def, _) => adt_def.repr.discr_type().to_ty(tcx),\n-                    ty::Generator(_, substs, _) => substs.as_generator().discr_ty(tcx),\n-                    _ => {\n-                        // This can only be `0`, for now, so `u8` will suffice.\n-                        tcx.types.u8\n-                    }\n-                }\n+                place.ty(local_decls, tcx).ty.discriminant_type(tcx)\n             }\n             Rvalue::NullaryOp(NullOp::Box, t) => tcx.mk_box(t),\n             Rvalue::NullaryOp(NullOp::SizeOf, _) => tcx.types.usize,"}, {"sha": "6cee224219b63c04a20c7be15e8427f9d0b38607", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/64fbe2fc485477406724a68372f4351dc7a08b0a/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64fbe2fc485477406724a68372f4351dc7a08b0a/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=64fbe2fc485477406724a68372f4351dc7a08b0a", "patch": "@@ -29,6 +29,7 @@ use std::borrow::Cow;\n use std::cmp::Ordering;\n use std::marker::PhantomData;\n use std::ops::Range;\n+use ty::util::IntTypeExt;\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n #[derive(HashStable, TypeFoldable, Lift)]\n@@ -2104,6 +2105,15 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n+    /// Returns the type of the discriminant of this type.\n+    pub fn discriminant_type(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+        match self.kind {\n+            ty::Adt(adt_def, _) => adt_def.repr.discr_type().to_ty(tcx),\n+            ty::Generator(_, substs, _) => substs.as_generator().discr_ty(tcx),\n+            _ => bug!(\"{:?} does not have a discriminant\", self),\n+        }\n+    }\n+\n     /// When we create a closure, we record its kind (i.e., what trait\n     /// it implements) into its `ClosureSubsts` using a type\n     /// parameter. This is kind of a phantom type, except that the"}, {"sha": "139871310fbf3a1b1aa16669bafb264b29710e31", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 24, "deletions": 39, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/64fbe2fc485477406724a68372f4351dc7a08b0a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64fbe2fc485477406724a68372f4351dc7a08b0a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=64fbe2fc485477406724a68372f4351dc7a08b0a", "patch": "@@ -7,11 +7,11 @@ use std::fmt::Write;\n use rustc_errors::ErrorReported;\n use rustc_hir::def::Namespace;\n use rustc_macros::HashStable;\n-use rustc_middle::ty::layout::{IntegerExt, PrimitiveExt, TyAndLayout};\n+use rustc_middle::ty::layout::{PrimitiveExt, TyAndLayout};\n use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter, Printer};\n use rustc_middle::ty::Ty;\n use rustc_middle::{mir, ty};\n-use rustc_target::abi::{Abi, DiscriminantKind, HasDataLayout, Integer, LayoutOf, Size};\n+use rustc_target::abi::{Abi, DiscriminantKind, HasDataLayout, LayoutOf, Size};\n use rustc_target::abi::{VariantIdx, Variants};\n \n use super::{\n@@ -576,9 +576,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Read discriminant, return the runtime value as well as the variant index.\n     pub fn read_discriminant(\n         &self,\n-        rval: OpTy<'tcx, M::PointerTag>,\n+        op: OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, VariantIdx)> {\n-        trace!(\"read_discriminant_value {:#?}\", rval.layout);\n+        trace!(\"read_discriminant_value {:#?}\", op.layout);\n+\n+        // Get type and layout of the discriminant.\n+        let discr_layout = self.layout_of(op.layout.ty.discriminant_type(*self.tcx))?;\n+        trace!(\"discriminant type: {:?}\", discr_layout.ty);\n \n         // We use \"discriminant\" to refer to the value associated with a particualr enum variant.\n         // This is not to be confused with its \"variant index\", which is just determining its position in the\n@@ -587,18 +591,17 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // straight-forward (`DiscriminantKind::Tag`) or with a niche (`DiscriminantKind::Niche`).\n         // Unfortunately, the rest of the compiler calls the latter \"discriminant\", too, which makes things\n         // rather confusing.\n-        let (tag_scalar_layout, tag_kind, tag_index) = match rval.layout.variants {\n+        let (tag_scalar_layout, tag_kind, tag_index) = match op.layout.variants {\n             Variants::Single { index } => {\n-                let discr = match rval.layout.ty.discriminant_for_variant(*self.tcx, index) {\n+                let discr = match op.layout.ty.discriminant_for_variant(*self.tcx, index) {\n                     Some(discr) => {\n                         // This type actually has discriminants.\n-                        let discr_layout = self.layout_of(discr.ty)?;\n+                        assert_eq!(discr.ty, discr_layout.ty);\n                         Scalar::from_uint(discr.val, discr_layout.size)\n                     }\n                     None => {\n-                        // On a type without actual discriminants, variant is 0. Return variant idx as `u8`.\n+                        // On a type without actual discriminants, variant is 0.\n                         assert_eq!(index.as_u32(), 0);\n-                        let discr_layout = self.layout_of(self.tcx.types.u8)?;\n                         Scalar::from_uint(index.as_u32(), discr_layout.size)\n                     }\n                 };\n@@ -609,53 +612,36 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         };\n \n-        // There are *three* types/layouts that come into play here:\n-        // - The discriminant has a type for typechecking. This is `discr_ty`, and is used for\n+        // There are *three* layouts that come into play here:\n+        // - The discriminant has a type for typechecking. This is `discr_layout`, and is used for\n         //   the `Scalar` we return.\n-        // - The discriminant gets encoded as a tag/niche, with layout `tag_layout`.\n-        //   This is always an integer, and used to interpret the value we read from the\n-        //   tag field. For the return value, a cast to `discr_ty` is performed.\n-        // - The field storing the tag has a layout, which is very similar to\n-        //   `tag_layout` but may be a pointer. This is `tag_val.layout`;\n-        //   we just use it for sanity checks.\n+        // - The tag (encoded discriminant) has layout `tag_layout`. This is always an integer type,\n+        //   and used to interpret the value we read from the tag field.\n+        //   For the return value, a cast to `discr_layout` is performed.\n+        // - The field storing the tag has a layout, which is very similar to `tag_layout` but\n+        //   may be a pointer. This is `tag_val.layout`; we just use it for sanity checks.\n \n         // Get layout for tag.\n         let tag_layout = self.layout_of(tag_scalar_layout.value.to_int_ty(*self.tcx))?;\n \n         // Read tag and sanity-check `tag_layout`.\n-        let tag_val = self.read_immediate(self.operand_field(rval, tag_index)?)?;\n+        let tag_val = self.read_immediate(self.operand_field(op, tag_index)?)?;\n         assert_eq!(tag_layout.size, tag_val.layout.size);\n         assert_eq!(tag_layout.abi.is_signed(), tag_val.layout.abi.is_signed());\n         let tag_val = tag_val.to_scalar()?;\n         trace!(\"tag value: {:?}\", tag_val);\n \n-        // Get type used by typechecking.\n-        let discr_ty = match rval.layout.ty.kind {\n-            ty::Adt(adt, _) => {\n-                let discr_int_ty = Integer::from_attr(self, adt.repr.discr_type());\n-                // The signedness of tag and discriminant is the same.\n-                discr_int_ty.to_ty(*self.tcx, tag_layout.abi.is_signed())\n-            }\n-            ty::Generator(_, substs, _) => {\n-                let substs = substs.as_generator();\n-                substs.discr_ty(*self.tcx)\n-            }\n-            _ => bug!(\"multiple variants for non-adt non-generator\"),\n-        };\n-        trace!(\"discriminant type: {:?}\", discr_ty);\n-\n         // Figure out which discriminant and variant this corresponds to.\n         Ok(match *tag_kind {\n             DiscriminantKind::Tag => {\n                 let tag_bits = self\n                     .force_bits(tag_val, tag_layout.size)\n                     .map_err(|_| err_ub!(InvalidDiscriminant(tag_val.erase_tag())))?;\n                 // Cast bits from tag layout to discriminant layout.\n-                let discr_layout = self.layout_of(discr_ty)?;\n-                let discr_val_cast = self.cast_from_scalar(tag_bits, tag_layout, discr_ty);\n+                let discr_val_cast = self.cast_from_scalar(tag_bits, tag_layout, discr_layout.ty);\n                 let discr_bits = discr_val_cast.assert_bits(discr_layout.size);\n                 // Convert discriminant to variant index, and catch invalid discriminants.\n-                let index = match rval.layout.ty.kind {\n+                let index = match op.layout.ty.kind {\n                     ty::Adt(adt, _) => {\n                         adt.discriminants(self.tcx.tcx).find(|(_, var)| var.val == discr_bits)\n                     }\n@@ -705,7 +691,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             let variant_index = variants_start\n                                 .checked_add(variant_index_relative)\n                                 .expect(\"overflow computing absolute variant idx\");\n-                            let variants_len = rval\n+                            let variants_len = op\n                                 .layout\n                                 .ty\n                                 .ty_adt_def()\n@@ -722,8 +708,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Compute the size of the scalar we need to return.\n                 // No need to cast, because the variant index directly serves as discriminant and is\n                 // encoded in the tag.\n-                let size = self.layout_of(discr_ty)?.size;\n-                (Scalar::from_uint(variant.as_u32(), size), variant)\n+                (Scalar::from_uint(variant.as_u32(), discr_layout.size), variant)\n             }\n         })\n     }"}]}