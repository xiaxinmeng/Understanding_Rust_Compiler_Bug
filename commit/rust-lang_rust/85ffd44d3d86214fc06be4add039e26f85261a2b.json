{"sha": "85ffd44d3d86214fc06be4add039e26f85261a2b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1ZmZkNDRkM2Q4NjIxNGZjMDZiZTRhZGQwMzllMjZmODUyNjFhMmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-08T13:02:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-08T13:02:21Z"}, "message": "Auto merge of #68443 - eddyb:abi-compat-enum, r=nagisa\n\nrustc_target: treat enum variants like union members, in call ABIs.\n\nFixes #68190, by handling non-C-like `enum`s as-if they were an `union` of `struct`s, in call ABIs.\nTests were provided by @sw17ch, from theirs and @bitwalker's original examples.\n\ncc @nagisa @rkruppe", "tree": {"sha": "2a0ccd61d2fbdfa7674834572cf4942dd312d6a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a0ccd61d2fbdfa7674834572cf4942dd312d6a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85ffd44d3d86214fc06be4add039e26f85261a2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85ffd44d3d86214fc06be4add039e26f85261a2b", "html_url": "https://github.com/rust-lang/rust/commit/85ffd44d3d86214fc06be4add039e26f85261a2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85ffd44d3d86214fc06be4add039e26f85261a2b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cad7542da2f10e2110f942de4db59716bacb3df", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cad7542da2f10e2110f942de4db59716bacb3df", "html_url": "https://github.com/rust-lang/rust/commit/6cad7542da2f10e2110f942de4db59716bacb3df"}, {"sha": "d20e4aa8e3d7b087b322be18df19811d9bca69f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d20e4aa8e3d7b087b322be18df19811d9bca69f2", "html_url": "https://github.com/rust-lang/rust/commit/d20e4aa8e3d7b087b322be18df19811d9bca69f2"}], "stats": {"total": 811, "additions": 716, "deletions": 95}, "files": [{"sha": "c8bac5aebc6340a667ac7ff36d3eccef0147d635", "filename": "src/librustc_target/abi/call/aarch64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -6,7 +6,7 @@ where\n     Ty: TyLayoutMethods<'a, C> + Copy,\n     C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n {\n-    arg.layout.homogeneous_aggregate(cx).unit().and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n         let size = arg.layout.size;\n \n         // Ensure we have at most four uniquely addressable members."}, {"sha": "59ec87e3c9e095c0aeafed053ad24c1049a50a0c", "filename": "src/librustc_target/abi/call/arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -7,7 +7,7 @@ where\n     Ty: TyLayoutMethods<'a, C> + Copy,\n     C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n {\n-    arg.layout.homogeneous_aggregate(cx).unit().and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n         let size = arg.layout.size;\n \n         // Ensure we have at most four uniquely addressable members."}, {"sha": "e3cbf176c350eb6bf678dbf55ffa618ab5ae5302", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 104, "deletions": 59, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -219,26 +219,47 @@ impl CastTarget {\n     }\n }\n \n-/// Returns value from the `homogeneous_aggregate` test function.\n+/// Return value from the `homogeneous_aggregate` test function.\n #[derive(Copy, Clone, Debug)]\n pub enum HomogeneousAggregate {\n     /// Yes, all the \"leaf fields\" of this struct are passed in the\n     /// same way (specified in the `Reg` value).\n     Homogeneous(Reg),\n \n-    /// There are distinct leaf fields passed in different ways,\n-    /// or this is uninhabited.\n-    Heterogeneous,\n-\n     /// There are no leaf fields at all.\n     NoData,\n }\n \n+/// Error from the `homogeneous_aggregate` test function, indicating\n+/// there are distinct leaf fields passed in different ways,\n+/// or this is uninhabited.\n+#[derive(Copy, Clone, Debug)]\n+pub struct Heterogeneous;\n+\n impl HomogeneousAggregate {\n     /// If this is a homogeneous aggregate, returns the homogeneous\n     /// unit, else `None`.\n     pub fn unit(self) -> Option<Reg> {\n-        if let HomogeneousAggregate::Homogeneous(r) = self { Some(r) } else { None }\n+        match self {\n+            HomogeneousAggregate::Homogeneous(reg) => Some(reg),\n+            HomogeneousAggregate::NoData => None,\n+        }\n+    }\n+\n+    /// Try to combine two `HomogeneousAggregate`s, e.g. from two fields in\n+    /// the same `struct`. Only succeeds if only one of them has any data,\n+    /// or both units are identical.\n+    fn merge(self, other: HomogeneousAggregate) -> Result<HomogeneousAggregate, Heterogeneous> {\n+        match (self, other) {\n+            (x, HomogeneousAggregate::NoData) | (HomogeneousAggregate::NoData, x) => Ok(x),\n+\n+            (HomogeneousAggregate::Homogeneous(a), HomogeneousAggregate::Homogeneous(b)) => {\n+                if a != b {\n+                    return Err(Heterogeneous);\n+                }\n+                Ok(self)\n+            }\n+        }\n     }\n }\n \n@@ -250,8 +271,8 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n         }\n     }\n \n-    /// Returns `true` if this layout is an aggregate containing fields of only\n-    /// a single type (e.g., `(u32, u32)`). Such aggregates are often\n+    /// Returns `Homogeneous` if this layout is an aggregate containing fields of\n+    /// only a single type (e.g., `(u32, u32)`). Such aggregates are often\n     /// special-cased in ABIs.\n     ///\n     /// Note: We generally ignore fields of zero-sized type when computing\n@@ -260,94 +281,118 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n     /// This is public so that it can be used in unit tests, but\n     /// should generally only be relevant to the ABI details of\n     /// specific targets.\n-    pub fn homogeneous_aggregate<C>(&self, cx: &C) -> HomogeneousAggregate\n+    pub fn homogeneous_aggregate<C>(&self, cx: &C) -> Result<HomogeneousAggregate, Heterogeneous>\n     where\n         Ty: TyLayoutMethods<'a, C> + Copy,\n         C: LayoutOf<Ty = Ty, TyLayout = Self>,\n     {\n         match self.abi {\n-            Abi::Uninhabited => HomogeneousAggregate::Heterogeneous,\n+            Abi::Uninhabited => Err(Heterogeneous),\n \n             // The primitive for this algorithm.\n             Abi::Scalar(ref scalar) => {\n                 let kind = match scalar.value {\n                     abi::Int(..) | abi::Pointer => RegKind::Integer,\n                     abi::F32 | abi::F64 => RegKind::Float,\n                 };\n-                HomogeneousAggregate::Homogeneous(Reg { kind, size: self.size })\n+                Ok(HomogeneousAggregate::Homogeneous(Reg { kind, size: self.size }))\n             }\n \n             Abi::Vector { .. } => {\n                 assert!(!self.is_zst());\n-                HomogeneousAggregate::Homogeneous(Reg { kind: RegKind::Vector, size: self.size })\n+                Ok(HomogeneousAggregate::Homogeneous(Reg {\n+                    kind: RegKind::Vector,\n+                    size: self.size,\n+                }))\n             }\n \n             Abi::ScalarPair(..) | Abi::Aggregate { .. } => {\n-                let mut total = Size::ZERO;\n-                let mut result = None;\n-\n-                let is_union = match self.fields {\n-                    FieldPlacement::Array { count, .. } => {\n-                        if count > 0 {\n-                            return self.field(cx, 0).homogeneous_aggregate(cx);\n-                        } else {\n-                            return HomogeneousAggregate::NoData;\n-                        }\n-                    }\n-                    FieldPlacement::Union(_) => true,\n-                    FieldPlacement::Arbitrary { .. } => false,\n-                };\n+                // Helper for computing `homogenous_aggregate`, allowing a custom\n+                // starting offset (used below for handling variants).\n+                let from_fields_at =\n+                    |layout: Self,\n+                     start: Size|\n+                     -> Result<(HomogeneousAggregate, Size), Heterogeneous> {\n+                        let is_union = match layout.fields {\n+                            FieldPlacement::Array { count, .. } => {\n+                                assert_eq!(start, Size::ZERO);\n+\n+                                let result = if count > 0 {\n+                                    layout.field(cx, 0).homogeneous_aggregate(cx)?\n+                                } else {\n+                                    HomogeneousAggregate::NoData\n+                                };\n+                                return Ok((result, layout.size));\n+                            }\n+                            FieldPlacement::Union(_) => true,\n+                            FieldPlacement::Arbitrary { .. } => false,\n+                        };\n \n-                for i in 0..self.fields.count() {\n-                    if !is_union && total != self.fields.offset(i) {\n-                        return HomogeneousAggregate::Heterogeneous;\n-                    }\n+                        let mut result = HomogeneousAggregate::NoData;\n+                        let mut total = start;\n \n-                    let field = self.field(cx, i);\n+                        for i in 0..layout.fields.count() {\n+                            if !is_union && total != layout.fields.offset(i) {\n+                                return Err(Heterogeneous);\n+                            }\n \n-                    match (result, field.homogeneous_aggregate(cx)) {\n-                        (_, HomogeneousAggregate::NoData) => {\n-                            // Ignore fields that have no data\n-                        }\n-                        (_, HomogeneousAggregate::Heterogeneous) => {\n-                            // The field itself must be a homogeneous aggregate.\n-                            return HomogeneousAggregate::Heterogeneous;\n-                        }\n-                        // If this is the first field, record the unit.\n-                        (None, HomogeneousAggregate::Homogeneous(unit)) => {\n-                            result = Some(unit);\n-                        }\n-                        // For all following fields, the unit must be the same.\n-                        (Some(prev_unit), HomogeneousAggregate::Homogeneous(unit)) => {\n-                            if prev_unit != unit {\n-                                return HomogeneousAggregate::Heterogeneous;\n+                            let field = layout.field(cx, i);\n+\n+                            result = result.merge(field.homogeneous_aggregate(cx)?)?;\n+\n+                            // Keep track of the offset (without padding).\n+                            let size = field.size;\n+                            if is_union {\n+                                total = total.max(size);\n+                            } else {\n+                                total += size;\n                             }\n                         }\n-                    }\n \n-                    // Keep track of the offset (without padding).\n-                    let size = field.size;\n-                    if is_union {\n-                        total = total.max(size);\n-                    } else {\n-                        total += size;\n+                        Ok((result, total))\n+                    };\n+\n+                let (mut result, mut total) = from_fields_at(*self, Size::ZERO)?;\n+\n+                match &self.variants {\n+                    abi::Variants::Single { .. } => {}\n+                    abi::Variants::Multiple { variants, .. } => {\n+                        // Treat enum variants like union members.\n+                        // HACK(eddyb) pretend the `enum` field (discriminant)\n+                        // is at the start of every variant (otherwise the gap\n+                        // at the start of all variants would disqualify them).\n+                        //\n+                        // NB: for all tagged `enum`s (which include all non-C-like\n+                        // `enum`s with defined FFI representation), this will\n+                        // match the homogenous computation on the equivalent\n+                        // `struct { tag; union { variant1; ... } }` and/or\n+                        // `union { struct { tag; variant1; } ... }`\n+                        // (the offsets of variant fields should be identical\n+                        // between the two for either to be a homogenous aggregate).\n+                        let variant_start = total;\n+                        for variant_idx in variants.indices() {\n+                            let (variant_result, variant_total) =\n+                                from_fields_at(self.for_variant(cx, variant_idx), variant_start)?;\n+\n+                            result = result.merge(variant_result)?;\n+                            total = total.max(variant_total);\n+                        }\n                     }\n                 }\n \n                 // There needs to be no padding.\n                 if total != self.size {\n-                    HomogeneousAggregate::Heterogeneous\n+                    Err(Heterogeneous)\n                 } else {\n                     match result {\n-                        Some(reg) => {\n+                        HomogeneousAggregate::Homogeneous(_) => {\n                             assert_ne!(total, Size::ZERO);\n-                            HomogeneousAggregate::Homogeneous(reg)\n                         }\n-                        None => {\n+                        HomogeneousAggregate::NoData => {\n                             assert_eq!(total, Size::ZERO);\n-                            HomogeneousAggregate::NoData\n                         }\n                     }\n+                    Ok(result)\n                 }\n             }\n         }"}, {"sha": "93c4e97de10b94308b49b89c149f27f6a86d7fa2", "filename": "src/librustc_target/abi/call/powerpc64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -22,7 +22,7 @@ where\n     Ty: TyLayoutMethods<'a, C> + Copy,\n     C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n {\n-    arg.layout.homogeneous_aggregate(cx).unit().and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n         // ELFv1 only passes one-member aggregates transparently.\n         // ELFv2 passes up to eight uniquely addressable members.\n         if (abi == ELFv1 && arg.layout.size > unit.size)"}, {"sha": "c80f8316feb72cde3352dc6d5ef522bc9008a80a", "filename": "src/librustc_target/abi/call/sparc64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -8,7 +8,7 @@ where\n     Ty: TyLayoutMethods<'a, C> + Copy,\n     C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n {\n-    arg.layout.homogeneous_aggregate(cx).unit().and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n         // Ensure we have at most eight uniquely addressable members.\n         if arg.layout.size > unit.size.checked_mul(8, cx).unwrap() {\n             return None;"}, {"sha": "9aab64ef272b2ccd0c2f6ca808a35e228e6f6517", "filename": "src/librustc_target/abi/call/wasm32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Flibrustc_target%2Fabi%2Fcall%2Fwasm32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Flibrustc_target%2Fabi%2Fcall%2Fwasm32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fwasm32.rs?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -7,7 +7,7 @@ where\n     C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout,\n {\n     if val.layout.is_aggregate() {\n-        if let Some(unit) = val.layout.homogeneous_aggregate(cx).unit() {\n+        if let Some(unit) = val.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()) {\n             let size = val.layout.size;\n             if unit.size == size {\n                 val.cast_to(Uniform { unit, total: size });"}, {"sha": "e776a8b3fe4a96d0f215100d6e210e2956ae80cc", "filename": "src/librustc_target/abi/call/x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -100,7 +100,7 @@ where\n             };\n \n             // At this point we know this must be a primitive of sorts.\n-            let unit = arg.layout.homogeneous_aggregate(cx).unit().unwrap();\n+            let unit = arg.layout.homogeneous_aggregate(cx).unwrap().unit().unwrap();\n             assert_eq!(unit.size, arg.layout.size);\n             if unit.kind == RegKind::Float {\n                 continue;"}, {"sha": "4c192c46786befb34b17df34686d0a069c02bc06", "filename": "src/librustc_target/abi/call/x86_64.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -56,16 +56,24 @@ where\n \n             Abi::Vector { .. } => Class::Sse,\n \n-            Abi::ScalarPair(..) | Abi::Aggregate { .. } => match layout.variants {\n-                abi::Variants::Single { .. } => {\n-                    for i in 0..layout.fields.count() {\n-                        let field_off = off + layout.fields.offset(i);\n-                        classify(cx, layout.field(cx, i), cls, field_off)?;\n+            Abi::ScalarPair(..) | Abi::Aggregate { .. } => {\n+                for i in 0..layout.fields.count() {\n+                    let field_off = off + layout.fields.offset(i);\n+                    classify(cx, layout.field(cx, i), cls, field_off)?;\n+                }\n+\n+                match &layout.variants {\n+                    abi::Variants::Single { .. } => {}\n+                    abi::Variants::Multiple { variants, .. } => {\n+                        // Treat enum variants like union members.\n+                        for variant_idx in variants.indices() {\n+                            classify(cx, layout.for_variant(cx, variant_idx), cls, off)?;\n+                        }\n                     }\n-                    return Ok(());\n                 }\n-                abi::Variants::Multiple { .. } => return Err(Memory),\n-            },\n+\n+                return Ok(());\n+            }\n         };\n \n         // Fill in `cls` for scalars (Int/Sse) and vectors (Sse)."}, {"sha": "c1fe8b7743a8cc7751bfde7699a22abb33effe0f", "filename": "src/test/auxiliary/rust_test_helpers.c", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Fauxiliary%2Frust_test_helpers.c", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Fauxiliary%2Frust_test_helpers.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Frust_test_helpers.c?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -300,3 +300,87 @@ __int128 sub(__int128 a, __int128 b) {\n }\n \n #endif\n+\n+#define OPTION_TAG_NONE (0)\n+#define OPTION_TAG_SOME (1)\n+\n+struct U8TaggedEnumOptionU64 {\n+    uint8_t tag;\n+    union {\n+        uint64_t some;\n+    };\n+};\n+\n+struct U8TaggedEnumOptionU64\n+rust_dbg_new_some_u64(uint64_t some) {\n+    struct U8TaggedEnumOptionU64 r = {\n+        .tag = OPTION_TAG_SOME,\n+        .some = some,\n+    };\n+    return r;\n+}\n+\n+struct U8TaggedEnumOptionU64\n+rust_dbg_new_none_u64(void) {\n+    struct U8TaggedEnumOptionU64 r = {\n+        .tag = OPTION_TAG_NONE,\n+    };\n+    return r;\n+}\n+\n+int32_t\n+rust_dbg_unpack_option_u64(struct U8TaggedEnumOptionU64 o, uint64_t *into) {\n+    assert(into);\n+    switch (o.tag) {\n+    case OPTION_TAG_SOME:\n+        *into = o.some;\n+        return 1;\n+    case OPTION_TAG_NONE:\n+        return 0;\n+    default:\n+        assert(0 && \"unexpected tag\");\n+    }\n+}\n+\n+struct U8TaggedEnumOptionU64U64 {\n+    uint8_t tag;\n+    union {\n+        struct {\n+            uint64_t a;\n+            uint64_t b;\n+        } some;\n+    };\n+};\n+\n+struct U8TaggedEnumOptionU64U64\n+rust_dbg_new_some_u64u64(uint64_t a, uint64_t b) {\n+    struct U8TaggedEnumOptionU64U64 r = {\n+        .tag = OPTION_TAG_SOME,\n+        .some = { .a = a, .b = b },\n+    };\n+    return r;\n+}\n+\n+struct U8TaggedEnumOptionU64U64\n+rust_dbg_new_none_u64u64(void) {\n+    struct U8TaggedEnumOptionU64U64 r = {\n+        .tag = OPTION_TAG_NONE,\n+    };\n+    return r;\n+}\n+\n+int32_t\n+rust_dbg_unpack_option_u64u64(struct U8TaggedEnumOptionU64U64 o, uint64_t *a, uint64_t *b) {\n+    assert(a);\n+    assert(b);\n+    switch (o.tag) {\n+    case OPTION_TAG_SOME:\n+        *a = o.some.a;\n+        *b = o.some.b;\n+        return 1;\n+    case OPTION_TAG_NONE:\n+        return 0;\n+    default:\n+        assert(0 && \"unexpected tag\");\n+    }\n+}"}, {"sha": "5b5d620efe655f3e31f80d150beaabbeb6facd79", "filename": "src/test/run-make-fulldeps/arguments-non-c-like-enum/Makefile", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Frun-make-fulldeps%2Farguments-non-c-like-enum%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Frun-make-fulldeps%2Farguments-non-c-like-enum%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Farguments-non-c-like-enum%2FMakefile?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -0,0 +1,7 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) --crate-type=staticlib nonclike.rs\n+\t$(CC) test.c $(call STATICLIB,nonclike) $(call OUT_EXE,test) \\\n+\t\t$(EXTRACFLAGS) $(EXTRACXXFLAGS)\n+\t$(call RUN,test)"}, {"sha": "57c2c6127ed9cc01fa04dd8a9e49eeb6c9db20b0", "filename": "src/test/run-make-fulldeps/arguments-non-c-like-enum/nonclike.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Frun-make-fulldeps%2Farguments-non-c-like-enum%2Fnonclike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Frun-make-fulldeps%2Farguments-non-c-like-enum%2Fnonclike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Farguments-non-c-like-enum%2Fnonclike.rs?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -0,0 +1,31 @@\n+#[repr(C, u8)]\n+pub enum TT {\n+    AA(u64, u64),\n+    BB,\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn tt_add(a: TT, b: TT) -> u64 {\n+    match (a, b) {\n+        (TT::AA(a1, b1), TT::AA(a2, b2)) => a1 + a2 + b1 + b2,\n+        (TT::AA(a1, b1), TT::BB) => a1 + b1,\n+        (TT::BB, TT::AA(a1, b1)) => a1 + b1,\n+        _ => 0,\n+    }\n+}\n+\n+#[repr(C, u8)]\n+pub enum T {\n+    A(u64),\n+    B,\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn t_add(a: T, b: T) -> u64 {\n+    match (a, b) {\n+        (T::A(a), T::A(b)) => a + b,\n+        (T::A(a), T::B) => a,\n+        (T::B, T::A(b)) => b,\n+        _ => 0,\n+    }\n+}"}, {"sha": "0a1621e49f2eeed5e86a2622355c74c345d74131", "filename": "src/test/run-make-fulldeps/arguments-non-c-like-enum/test.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Frun-make-fulldeps%2Farguments-non-c-like-enum%2Ftest.c", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Frun-make-fulldeps%2Farguments-non-c-like-enum%2Ftest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Farguments-non-c-like-enum%2Ftest.c?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -0,0 +1,66 @@\n+#include <stdint.h>\n+#include <assert.h>\n+\n+#include <stdio.h>\n+\n+/* This is the code generated by cbindgen 0.12.1 for the `enum TT`\n+ * type in nonclike.rs . */\n+enum TT_Tag {\n+  AA,\n+  BB,\n+};\n+typedef uint8_t TT_Tag;\n+\n+typedef struct {\n+  uint64_t _0;\n+  uint64_t _1;\n+} AA_Body;\n+\n+typedef struct {\n+  TT_Tag tag;\n+  union {\n+    AA_Body aa;\n+  };\n+} TT;\n+\n+/* This is the code generated by cbindgen 0.12.1 for the `enum T` type\n+ * in nonclike.rs . */\n+enum T_Tag {\n+  A,\n+  B,\n+};\n+typedef uint8_t T_Tag;\n+\n+typedef struct {\n+  uint64_t _0;\n+} A_Body;\n+\n+typedef struct {\n+  T_Tag tag;\n+  union {\n+    A_Body a;\n+  };\n+} T;\n+\n+/* These symbols are defined by the Rust staticlib built from\n+ * nonclike.rs. */\n+extern uint64_t t_add(T a, T b);\n+extern uint64_t tt_add(TT a, TT b);\n+\n+int main(int argc, char *argv[]) {\n+  (void)argc; (void)argv;\n+\n+  /* This example works. */\n+  TT xx = { .tag = AA, .aa = { ._0 = 1, ._1 = 2 } };\n+  TT yy = { .tag = AA, .aa = { ._0 = 10, ._1 = 20 } };\n+  uint64_t rr = tt_add(xx, yy);\n+  assert(33 == rr);\n+\n+  /* This one used to return an incorrect result (see issue #68190). */\n+  T x = { .tag = A, .a = { ._0 = 1 } };\n+  T y = { .tag = A, .a = { ._0 = 10 } };\n+  uint64_t r = t_add(x, y);\n+  assert(11 == r);\n+\n+  return 0;\n+}"}, {"sha": "f3d9357865c168412f9105debed22437a64dab41", "filename": "src/test/run-make-fulldeps/pass-non-c-like-enum-to-c/Makefile", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Frun-make-fulldeps%2Fpass-non-c-like-enum-to-c%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Frun-make-fulldeps%2Fpass-non-c-like-enum-to-c%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fpass-non-c-like-enum-to-c%2FMakefile?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -0,0 +1,5 @@\n+-include ../tools.mk\n+\n+all: $(call NATIVE_STATICLIB,test)\n+\t$(RUSTC) nonclike.rs -L$(TMPDIR) -ltest\n+\t$(call RUN,nonclike)"}, {"sha": "517286a868d8ccd5600a41db5cff85b7eaf4320f", "filename": "src/test/run-make-fulldeps/pass-non-c-like-enum-to-c/nonclike.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Frun-make-fulldeps%2Fpass-non-c-like-enum-to-c%2Fnonclike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Frun-make-fulldeps%2Fpass-non-c-like-enum-to-c%2Fnonclike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fpass-non-c-like-enum-to-c%2Fnonclike.rs?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -0,0 +1,21 @@\n+#[repr(C, u8)]\n+pub enum TT {\n+    AA(u64, u64),\n+    BB,\n+}\n+\n+#[repr(C,u8)]\n+pub enum T {\n+    A(u64),\n+    B,\n+}\n+\n+extern \"C\" {\n+    pub fn t_add(a: T, b: T) -> u64;\n+    pub fn tt_add(a: TT, b: TT) -> u64;\n+}\n+\n+fn main() {\n+    assert_eq!(33, unsafe { tt_add(TT::AA(1,2), TT::AA(10,20)) });\n+    assert_eq!(11, unsafe { t_add(T::A(1), T::A(10)) });\n+}"}, {"sha": "99511b2530f0693979ed0ddaeb0d69e500759452", "filename": "src/test/run-make-fulldeps/pass-non-c-like-enum-to-c/test.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Frun-make-fulldeps%2Fpass-non-c-like-enum-to-c%2Ftest.c", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Frun-make-fulldeps%2Fpass-non-c-like-enum-to-c%2Ftest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fpass-non-c-like-enum-to-c%2Ftest.c?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -0,0 +1,85 @@\n+#include <stdint.h>\n+\n+/* This is the code generated by cbindgen 0.12.1 for the `enum TT`\n+ * type in nonclike.rs . */\n+enum TT_Tag {\n+  AA,\n+  BB,\n+};\n+typedef uint8_t TT_Tag;\n+\n+typedef struct {\n+  uint64_t _0;\n+  uint64_t _1;\n+} AA_Body;\n+\n+typedef struct {\n+  TT_Tag tag;\n+  union {\n+    AA_Body aa;\n+  };\n+} TT;\n+\n+/* This is the code generated by cbindgen 0.12.1 for the `enum T` type\n+ * in nonclike.rs . */\n+enum T_Tag {\n+  A,\n+  B,\n+};\n+typedef uint8_t T_Tag;\n+\n+typedef struct {\n+  uint64_t _0;\n+} A_Body;\n+\n+typedef struct {\n+  T_Tag tag;\n+  union {\n+    A_Body a;\n+  };\n+} T;\n+\n+uint64_t tt_add(TT a, TT b) {\n+  if (a.tag == AA && b.tag == AA) {\n+    return a.aa._0 + a.aa._1 + b.aa._0 + b.aa._1;\n+  } else if (a.tag == AA) {\n+    return a.aa._0 + a.aa._1;\n+  } else if (b.tag == BB) {\n+    return b.aa._0 + b.aa._1;\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+uint64_t t_add(T a, T b) {\n+  if (a.tag == A && b.tag == A) {\n+    return a.a._0 + b.a._0;\n+  } else if (a.tag == AA) {\n+    return a.a._0;\n+  } else if (b.tag == BB) {\n+    return b.a._0;\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+TT tt_new(uint64_t a, uint64_t b) {\n+  TT tt = {\n+    .tag = AA,\n+    .aa = {\n+      ._0 = a,\n+      ._1 = b,\n+    },\n+  };\n+  return tt;\n+}\n+\n+T t_new(uint64_t a) {\n+  T t = {\n+    .tag = A,\n+    .a = {\n+      ._0 = a,\n+    },\n+  };\n+  return t;\n+}"}, {"sha": "f3d9357865c168412f9105debed22437a64dab41", "filename": "src/test/run-make-fulldeps/return-non-c-like-enum-from-c/Makefile", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum-from-c%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum-from-c%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum-from-c%2FMakefile?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -0,0 +1,5 @@\n+-include ../tools.mk\n+\n+all: $(call NATIVE_STATICLIB,test)\n+\t$(RUSTC) nonclike.rs -L$(TMPDIR) -ltest\n+\t$(call RUN,nonclike)"}, {"sha": "ea22a2a56e09b44b9d7243ac5d1bf48b2b4f4feb", "filename": "src/test/run-make-fulldeps/return-non-c-like-enum-from-c/nonclike.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum-from-c%2Fnonclike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum-from-c%2Fnonclike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum-from-c%2Fnonclike.rs?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -0,0 +1,31 @@\n+#[repr(C, u8)]\n+pub enum TT {\n+    AA(u64, u64),\n+    BB,\n+}\n+\n+#[repr(C,u8)]\n+pub enum T {\n+    A(u64),\n+    B,\n+}\n+\n+extern \"C\" {\n+    pub fn t_new(a: u64) -> T;\n+    pub fn tt_new(a: u64, b: u64) -> TT;\n+}\n+\n+fn main() {\n+    if let TT::AA(a, b) = unsafe { tt_new(10, 11) } {\n+        assert_eq!(10, a);\n+        assert_eq!(11, b);\n+    } else {\n+        panic!(\"expected TT::AA\");\n+    }\n+\n+    if let T::A(a) = unsafe { t_new(10) } {\n+        assert_eq!(10, a);\n+    } else {\n+        panic!(\"expected T::A\");\n+    }\n+}"}, {"sha": "3ad135bab4a1e986c33ba940427ab52548d3688b", "filename": "src/test/run-make-fulldeps/return-non-c-like-enum-from-c/test.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum-from-c%2Ftest.c", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum-from-c%2Ftest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum-from-c%2Ftest.c?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -0,0 +1,61 @@\n+#include <stdint.h>\n+\n+/* This is the code generated by cbindgen 0.12.1 for the `enum TT`\n+ * type in nonclike.rs . */\n+enum TT_Tag {\n+  AA,\n+  BB,\n+};\n+typedef uint8_t TT_Tag;\n+\n+typedef struct {\n+  uint64_t _0;\n+  uint64_t _1;\n+} AA_Body;\n+\n+typedef struct {\n+  TT_Tag tag;\n+  union {\n+    AA_Body aa;\n+  };\n+} TT;\n+\n+/* This is the code generated by cbindgen 0.12.1 for the `enum T` type\n+ * in nonclike.rs . */\n+enum T_Tag {\n+  A,\n+  B,\n+};\n+typedef uint8_t T_Tag;\n+\n+typedef struct {\n+  uint64_t _0;\n+} A_Body;\n+\n+typedef struct {\n+  T_Tag tag;\n+  union {\n+    A_Body a;\n+  };\n+} T;\n+\n+TT tt_new(uint64_t a, uint64_t b) {\n+  TT tt = {\n+    .tag = AA,\n+    .aa = {\n+      ._0 = a,\n+      ._1 = b,\n+    },\n+  };\n+  return tt;\n+}\n+\n+T t_new(uint64_t a) {\n+  T t = {\n+    .tag = A,\n+    .a = {\n+      ._0 = a,\n+    },\n+  };\n+  return t;\n+}"}, {"sha": "5b5d620efe655f3e31f80d150beaabbeb6facd79", "filename": "src/test/run-make-fulldeps/return-non-c-like-enum/Makefile", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum%2FMakefile?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -0,0 +1,7 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) --crate-type=staticlib nonclike.rs\n+\t$(CC) test.c $(call STATICLIB,nonclike) $(call OUT_EXE,test) \\\n+\t\t$(EXTRACFLAGS) $(EXTRACXXFLAGS)\n+\t$(call RUN,test)"}, {"sha": "de529cf641ab06d44a936add077782d2074f1054", "filename": "src/test/run-make-fulldeps/return-non-c-like-enum/nonclike.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum%2Fnonclike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum%2Fnonclike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum%2Fnonclike.rs?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -0,0 +1,21 @@\n+#[repr(C, u8)]\n+pub enum TT {\n+    AA(u64, u64),\n+    BB,\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn tt_new(a: u64, b: u64) -> TT {\n+    TT::AA(a, b)\n+}\n+\n+#[repr(C,u8)]\n+pub enum T {\n+    A(u64),\n+    B,\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn t_new(a: u64) -> T {\n+    T::A(a)\n+}"}, {"sha": "afadd3c10c5ca0d51e5cacf18f3e937aaefdb76a", "filename": "src/test/run-make-fulldeps/return-non-c-like-enum/test.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum%2Ftest.c", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum%2Ftest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Freturn-non-c-like-enum%2Ftest.c?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -0,0 +1,63 @@\n+#include <stdint.h>\n+#include <assert.h>\n+\n+/* This is the code generated by cbindgen 0.12.1 for the `enum TT`\n+ * type in nonclike.rs . */\n+enum TT_Tag {\n+  AA,\n+  BB,\n+};\n+typedef uint8_t TT_Tag;\n+\n+typedef struct {\n+  uint64_t _0;\n+  uint64_t _1;\n+} AA_Body;\n+\n+typedef struct {\n+  TT_Tag tag;\n+  union {\n+    AA_Body aa;\n+  };\n+} TT;\n+\n+/* This is the code generated by cbindgen 0.12.1 for the `enum T` type\n+ * in nonclike.rs . */\n+enum T_Tag {\n+  A,\n+  B,\n+};\n+typedef uint8_t T_Tag;\n+\n+typedef struct {\n+  uint64_t _0;\n+} A_Body;\n+\n+typedef struct {\n+  T_Tag tag;\n+  union {\n+    A_Body a;\n+  };\n+} T;\n+\n+/* These symbols are defined by the Rust staticlib built from\n+ * nonclike.rs. */\n+extern TT tt_new(uint64_t a, uint64_t b);\n+extern T t_new(uint64_t v);\n+\n+int main(int argc, char *argv[]) {\n+  (void)argc; (void)argv;\n+\n+  /* This example works. */\n+  TT tt = tt_new(10, 20);\n+  assert(AA == tt.tag);\n+  assert(10 == tt.aa._0);\n+  assert(20 == tt.aa._1);\n+\n+  /* This one used to segfault (see issue #68190). */\n+  T t = t_new(10);\n+  assert(A == t.tag);\n+  assert(10 == t.a._0);\n+\n+  return 0;\n+}"}, {"sha": "c87353b93a7c0ebc8e6982defbd2f2fc2d1a55cc", "filename": "src/test/ui/abi/abi-sysv64-arg-passing.rs", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Fui%2Fabi%2Fabi-sysv64-arg-passing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Fui%2Fabi%2Fabi-sysv64-arg-passing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fabi%2Fabi-sysv64-arg-passing.rs?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -92,6 +92,18 @@ mod tests {\n     #[derive(Copy, Clone)]\n     pub struct Floats { a: f64, b: u8, c: f64 }\n \n+    #[repr(C, u8)]\n+    pub enum U8TaggedEnumOptionU64U64 {\n+        None,\n+        Some(u64,u64),\n+    }\n+\n+    #[repr(C, u8)]\n+    pub enum U8TaggedEnumOptionU64 {\n+        None,\n+        Some(u64),\n+    }\n+\n     #[link(name = \"rust_test_helpers\", kind = \"static\")]\n     extern \"sysv64\" {\n         pub fn rust_int8_to_int32(_: i8) -> i32;\n@@ -125,6 +137,16 @@ mod tests {\n         ) -> f32;\n         pub fn rust_dbg_abi_1(q: Quad) -> Quad;\n         pub fn rust_dbg_abi_2(f: Floats) -> Floats;\n+        pub fn rust_dbg_new_some_u64u64(a: u64, b: u64) -> U8TaggedEnumOptionU64U64;\n+        pub fn rust_dbg_new_none_u64u64() -> U8TaggedEnumOptionU64U64;\n+        pub fn rust_dbg_unpack_option_u64u64(\n+            o: U8TaggedEnumOptionU64U64,\n+            a: *mut u64,\n+            b: *mut u64,\n+        ) -> i32;\n+        pub fn rust_dbg_new_some_u64(some: u64) -> U8TaggedEnumOptionU64;\n+        pub fn rust_dbg_new_none_u64() -> U8TaggedEnumOptionU64;\n+        pub fn rust_dbg_unpack_option_u64(o: U8TaggedEnumOptionU64, v: *mut u64) -> i32;\n     }\n \n     pub fn cabi_int_widening() {\n@@ -336,6 +358,63 @@ mod tests {\n         test1();\n         test2();\n     }\n+\n+    pub fn enum_passing_and_return_pair() {\n+        let some_u64u64 = unsafe { rust_dbg_new_some_u64u64(10, 20) };\n+        if let U8TaggedEnumOptionU64U64::Some(a, b) = some_u64u64 {\n+            assert_eq!(10, a);\n+            assert_eq!(20, b);\n+        } else {\n+            panic!(\"unexpected none\");\n+        }\n+\n+        let none_u64u64 = unsafe { rust_dbg_new_none_u64u64() };\n+        if let U8TaggedEnumOptionU64U64::Some(_,_) = none_u64u64 {\n+            panic!(\"unexpected some\");\n+        }\n+\n+        let mut a: u64 = 0;\n+        let mut b: u64 = 0;\n+        let r = unsafe {\n+            rust_dbg_unpack_option_u64u64(some_u64u64, &mut a as *mut _, &mut b as *mut _)\n+        };\n+        assert_eq!(1, r);\n+        assert_eq!(10, a);\n+        assert_eq!(20, b);\n+\n+        let mut a: u64 = 0;\n+        let mut b: u64 = 0;\n+        let r = unsafe {\n+            rust_dbg_unpack_option_u64u64(none_u64u64, &mut a as *mut _, &mut b as *mut _)\n+        };\n+        assert_eq!(0, r);\n+        assert_eq!(0, a);\n+        assert_eq!(0, b);\n+    }\n+\n+    pub fn enum_passing_and_return() {\n+        let some_u64 = unsafe { rust_dbg_new_some_u64(10) };\n+        if let U8TaggedEnumOptionU64::Some(v) = some_u64 {\n+            assert_eq!(10, v);\n+        } else {\n+            panic!(\"unexpected none\");\n+        }\n+\n+        let none_u64 = unsafe { rust_dbg_new_none_u64() };\n+        if let U8TaggedEnumOptionU64::Some(_) = none_u64 {\n+            panic!(\"unexpected some\");\n+        }\n+\n+        let mut target: u64 = 0;\n+        let r = unsafe { rust_dbg_unpack_option_u64(some_u64, &mut target as *mut _) };\n+        assert_eq!(1, r);\n+        assert_eq!(10, target);\n+\n+        let mut target: u64 = 0;\n+        let r = unsafe { rust_dbg_unpack_option_u64(none_u64, &mut target as *mut _) };\n+        assert_eq!(0, r);\n+        assert_eq!(0, target);\n+    }\n }\n \n #[cfg(target_arch = \"x86_64\")]\n@@ -359,6 +438,8 @@ fn main() {\n     issue_28676();\n     issue_62350();\n     struct_return();\n+    enum_passing_and_return_pair();\n+    enum_passing_and_return();\n }\n \n #[cfg(not(target_arch = \"x86_64\"))]"}, {"sha": "7eecd99dc016ae4a256cf5398f18fae718d1e009", "filename": "src/test/ui/layout/homogeneous-aggr-zero-sized-c-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.rs?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -20,7 +20,7 @@ pub struct Middle {\n \n #[rustc_layout(homogeneous_aggregate)]\n pub type TestMiddle = Middle;\n-//~^ ERROR homogeneous_aggregate: Homogeneous\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous\n \n #[repr(C)]\n pub struct Final {\n@@ -31,6 +31,6 @@ pub struct Final {\n \n #[rustc_layout(homogeneous_aggregate)]\n pub type TestFinal = Final;\n-//~^ ERROR homogeneous_aggregate: Homogeneous\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous\n \n fn main() { }"}, {"sha": "cd3fb5ca5ea402124e930cf29bd16f8042f6d053", "filename": "src/test/ui/layout/homogeneous-aggr-zero-sized-c-struct.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.stderr?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -1,10 +1,10 @@\n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/homogeneous-aggr-zero-sized-c-struct.rs:22:1\n    |\n LL | pub type TestMiddle = Middle;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/homogeneous-aggr-zero-sized-c-struct.rs:33:1\n    |\n LL | pub type TestFinal = Final;"}, {"sha": "ec2c9b70224b5d4a8a31c375532da38284c668ed", "filename": "src/test/ui/layout/homogeneous-aggr-zero-sized-repr-rust.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.rs?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -52,22 +52,22 @@ pub struct WithEmptyRustEnum {\n \n #[rustc_layout(homogeneous_aggregate)]\n pub type Test1 = BaseCase;\n-//~^ ERROR homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n \n #[rustc_layout(homogeneous_aggregate)]\n pub type Test2 = WithPhantomData;\n-//~^ ERROR homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n \n #[rustc_layout(homogeneous_aggregate)]\n pub type Test3 = WithEmptyRustStruct;\n-//~^ ERROR homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n \n #[rustc_layout(homogeneous_aggregate)]\n pub type Test4 = WithTransitivelyEmptyRustStruct;\n-//~^ ERROR homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n \n #[rustc_layout(homogeneous_aggregate)]\n pub type Test5 = WithEmptyRustEnum;\n-//~^ ERROR homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n \n fn main() { }"}, {"sha": "ec2b08bf02d655a435129bb43427820d76d489de", "filename": "src/test/ui/layout/homogeneous-aggr-zero-sized-repr-rust.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.stderr?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -1,28 +1,28 @@\n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/homogeneous-aggr-zero-sized-repr-rust.rs:54:1\n    |\n LL | pub type Test1 = BaseCase;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/homogeneous-aggr-zero-sized-repr-rust.rs:58:1\n    |\n LL | pub type Test2 = WithPhantomData;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/homogeneous-aggr-zero-sized-repr-rust.rs:62:1\n    |\n LL | pub type Test3 = WithEmptyRustStruct;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/homogeneous-aggr-zero-sized-repr-rust.rs:66:1\n    |\n LL | pub type Test4 = WithTransitivelyEmptyRustStruct;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/homogeneous-aggr-zero-sized-repr-rust.rs:70:1\n    |\n LL | pub type Test5 = WithEmptyRustEnum;"}, {"sha": "1a662ba44677d647f0a3d7d634451650bd1fe624", "filename": "src/test/ui/layout/zero-sized-array-union.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.rs?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -57,7 +57,7 @@ struct Baz1 {\n \n #[rustc_layout(homogeneous_aggregate)]\n type TestBaz1 = Baz1;\n-//~^ ERROR homogeneous_aggregate: Homogeneous\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous\n \n #[repr(C)]\n struct Baz2 {\n@@ -68,7 +68,7 @@ struct Baz2 {\n \n #[rustc_layout(homogeneous_aggregate)]\n type TestBaz2 = Baz2;\n-//~^ ERROR homogeneous_aggregate: Homogeneous\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous\n \n #[repr(C)]\n struct Baz3 {\n@@ -79,7 +79,7 @@ struct Baz3 {\n \n #[rustc_layout(homogeneous_aggregate)]\n type TestBaz3 = Baz3;\n-//~^ ERROR homogeneous_aggregate: Homogeneous\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous\n \n #[repr(C)]\n struct Baz4 {\n@@ -90,6 +90,6 @@ struct Baz4 {\n \n #[rustc_layout(homogeneous_aggregate)]\n type TestBaz4 = Baz4;\n-//~^ ERROR homogeneous_aggregate: Homogeneous\n+//~^ ERROR homogeneous_aggregate: Ok(Homogeneous\n \n fn main() { }"}, {"sha": "43b1588266bb7cdd2f0c68a59af02c880672824b", "filename": "src/test/ui/layout/zero-sized-array-union.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/85ffd44d3d86214fc06be4add039e26f85261a2b/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.stderr?ref=85ffd44d3d86214fc06be4add039e26f85261a2b", "patch": "@@ -1,22 +1,22 @@\n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/zero-sized-array-union.rs:59:1\n    |\n LL | type TestBaz1 = Baz1;\n    | ^^^^^^^^^^^^^^^^^^^^^\n \n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/zero-sized-array-union.rs:70:1\n    |\n LL | type TestBaz2 = Baz2;\n    | ^^^^^^^^^^^^^^^^^^^^^\n \n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/zero-sized-array-union.rs:81:1\n    |\n LL | type TestBaz3 = Baz3;\n    | ^^^^^^^^^^^^^^^^^^^^^\n \n-error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+error: homogeneous_aggregate: Ok(Homogeneous(Reg { kind: Float, size: Size { raw: 4 } }))\n   --> $DIR/zero-sized-array-union.rs:92:1\n    |\n LL | type TestBaz4 = Baz4;"}]}