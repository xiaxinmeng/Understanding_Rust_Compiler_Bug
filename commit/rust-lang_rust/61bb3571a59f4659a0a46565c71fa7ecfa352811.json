{"sha": "61bb3571a59f4659a0a46565c71fa7ecfa352811", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxYmIzNTcxYTU5ZjQ2NTlhMGE0NjU2NWM3MWZhN2VjZmEzNTI4MTE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-23T22:56:40Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-24T02:23:46Z"}, "message": "rustc: Implement construction of monomorphic struct-like variants. r=nmatsakis", "tree": {"sha": "10be016bc2768311197959946e5756b3aeff65f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10be016bc2768311197959946e5756b3aeff65f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61bb3571a59f4659a0a46565c71fa7ecfa352811", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61bb3571a59f4659a0a46565c71fa7ecfa352811", "html_url": "https://github.com/rust-lang/rust/commit/61bb3571a59f4659a0a46565c71fa7ecfa352811", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61bb3571a59f4659a0a46565c71fa7ecfa352811/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "759e1c165f474314bb113d0b72e8ef85fc3864d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/759e1c165f474314bb113d0b72e8ef85fc3864d7", "html_url": "https://github.com/rust-lang/rust/commit/759e1c165f474314bb113d0b72e8ef85fc3864d7"}], "stats": {"total": 376, "additions": 303, "deletions": 73}, "files": [{"sha": "acf56ad81e965a499fd6916b90ceb18700777406", "filename": "src/rustc/middle/privacy.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/61bb3571a59f4659a0a46565c71fa7ecfa352811/src%2Frustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb3571a59f4659a0a46565c71fa7ecfa352811/src%2Frustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fprivacy.rs?ref=61bb3571a59f4659a0a46565c71fa7ecfa352811", "patch": "@@ -3,11 +3,11 @@\n \n use /*mod*/ syntax::ast;\n use /*mod*/ syntax::visit;\n-use syntax::ast::{expr_field, expr_struct, ident, item_class, item_impl};\n-use syntax::ast::{item_trait, local_crate, node_id, pat_struct, private};\n-use syntax::ast::{provided, required};\n+use syntax::ast::{def_variant, expr_field, expr_struct, ident, item_class};\n+use syntax::ast::{item_impl, item_trait, local_crate, node_id, pat_struct};\n+use syntax::ast::{private, provided, required};\n use syntax::ast_map::{node_item, node_method};\n-use ty::ty_class;\n+use ty::{ty_class, ty_enum};\n use typeck::{method_map, method_origin, method_param, method_self};\n use typeck::{method_static, method_trait};\n \n@@ -188,6 +188,30 @@ fn check_crate(tcx: ty::ctxt, method_map: &method_map, crate: @ast::crate) {\n                                 }\n                             }\n                         }\n+                        ty_enum(id, _) => {\n+                            if id.crate != local_crate ||\n+                                    !privileged_items.contains(&(id.node)) {\n+                                match tcx.def_map.get(expr.id) {\n+                                    def_variant(_, variant_id) => {\n+                                        for fields.each |field| {\n+                                                debug!(\"(privacy checking) \\\n+                                                        checking field in \\\n+                                                        struct variant \\\n+                                                        literal\");\n+                                            check_field(expr.span, variant_id,\n+                                                        field.node.ident);\n+                                        }\n+                                    }\n+                                    _ => {\n+                                        tcx.sess.span_bug(expr.span,\n+                                                          ~\"resolve didn't \\\n+                                                            map enum struct \\\n+                                                            constructor to a \\\n+                                                            variant def\");\n+                                    }\n+                                }\n+                            }\n+                        }\n                         _ => {\n                             tcx.sess.span_bug(expr.span, ~\"struct expr \\\n                                                            didn't have \\"}, {"sha": "4d2ced35338b6d701937b66fe3ba4779536ca957", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61bb3571a59f4659a0a46565c71fa7ecfa352811/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb3571a59f4659a0a46565c71fa7ecfa352811/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=61bb3571a59f4659a0a46565c71fa7ecfa352811", "patch": "@@ -909,7 +909,7 @@ fn compile_submatch(bcx: block,\n     let rec_fields = collect_record_or_struct_fields(m, col);\n     if rec_fields.len() > 0 {\n         let pat_ty = node_id_type(bcx, pat_id);\n-        do expr::with_field_tys(tcx, pat_ty) |_has_dtor, field_tys| {\n+        do expr::with_field_tys(tcx, pat_ty, None) |_has_dtor, field_tys| {\n             let rec_vals = rec_fields.map(|field_name| {\n                 let ix = ty::field_idx_strict(tcx, *field_name, field_tys);\n                 GEPi(bcx, val, struct_field(ix))\n@@ -1257,7 +1257,7 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n         ast::pat_rec(fields, _) | ast::pat_struct(_, fields, _) => {\n             let tcx = bcx.tcx();\n             let pat_ty = node_id_type(bcx, pat.id);\n-            do expr::with_field_tys(tcx, pat_ty) |_has_dtor, field_tys| {\n+            do expr::with_field_tys(tcx, pat_ty, None) |_hd, field_tys| {\n                 for vec::each(fields) |f| {\n                     let ix = ty::field_idx_strict(tcx, f.ident, field_tys);\n                     let fldptr = GEPi(bcx, val, struct_field(ix));"}, {"sha": "3896fdf0e7a06fb243f0de99ae45dcad77421097", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61bb3571a59f4659a0a46565c71fa7ecfa352811/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb3571a59f4659a0a46565c71fa7ecfa352811/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=61bb3571a59f4659a0a46565c71fa7ecfa352811", "patch": "@@ -547,7 +547,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n     let mut cx = cx;\n     match ty::get(t).sty {\n       ty::ty_rec(*) | ty::ty_class(*) => {\n-          do expr::with_field_tys(cx.tcx(), t) |_has_dtor, field_tys| {\n+          do expr::with_field_tys(cx.tcx(), t, None) |_has_dtor, field_tys| {\n               for vec::eachi(field_tys) |i, field_ty| {\n                   let llfld_a = GEPi(cx, av, struct_field(i));\n                   cx = f(cx, llfld_a, field_ty.mt.ty);"}, {"sha": "98ff7329b0f5cf3667b852697629c74595aeada8", "filename": "src/rustc/middle/trans/consts.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61bb3571a59f4659a0a46565c71fa7ecfa352811/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb3571a59f4659a0a46565c71fa7ecfa352811/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=61bb3571a59f4659a0a46565c71fa7ecfa352811", "patch": "@@ -162,7 +162,7 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n           let bt = ty::expr_ty(cx.tcx, base);\n           let bv = const_expr(cx, base);\n           let (bt, bv) = const_autoderef(cx, bt, bv);\n-          do expr::with_field_tys(cx.tcx, bt) |_has_dtor, field_tys| {\n+          do expr::with_field_tys(cx.tcx, bt, None) |_has_dtor, field_tys| {\n               let ix = ty::field_idx_strict(cx.tcx, field, field_tys);\n \n               // Note: ideally, we'd use `struct_field()` here instead\n@@ -294,7 +294,9 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n       }\n       ast::expr_struct(_, ref fs, _) => {\n           let ety = ty::expr_ty(cx.tcx, e);\n-          let cs = do expr::with_field_tys(cx.tcx, ety) |_hd, field_tys| {\n+          let cs = do expr::with_field_tys(cx.tcx,\n+                                           ety,\n+                                           None) |_hd, field_tys| {\n               field_tys.map(|field_ty| {\n                   match fs.find(|f| field_ty.ident == f.node.ident) {\n                       Some(f) => const_expr(cx, f.node.expr),"}, {"sha": "dee553536048a02d4cb9fc87d9c404a888325dda", "filename": "src/rustc/middle/trans/expr.rs", "status": "modified", "additions": 68, "deletions": 3, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/61bb3571a59f4659a0a46565c71fa7ecfa352811/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb3571a59f4659a0a46565c71fa7ecfa352811/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=61bb3571a59f4659a0a46565c71fa7ecfa352811", "patch": "@@ -850,7 +850,12 @@ fn fn_data_to_datum(bcx: block,\n     return bcx;\n }\n \n-fn with_field_tys<R>(tcx: ty::ctxt, ty: ty::t,\n+// The optional node ID here is the node ID of the path identifying the enum\n+// variant in use. If none, this cannot possibly an enum variant (so, if it\n+// is and `node_id_opt` is none, this function fails).\n+fn with_field_tys<R>(tcx: ty::ctxt,\n+                     ty: ty::t,\n+                     node_id_opt: Option<ast::node_id>,\n                      op: fn(bool, (&[ty::field])) -> R) -> R {\n     match ty::get(ty).sty {\n         ty::ty_rec(ref fields) => {\n@@ -862,6 +867,30 @@ fn with_field_tys<R>(tcx: ty::ctxt, ty: ty::t,\n             op(has_dtor, class_items_as_mutable_fields(tcx, did, substs))\n         }\n \n+        ty::ty_enum(_, ref substs) => {\n+            // We want the *variant* ID here, not the enum ID.\n+            match node_id_opt {\n+                None => {\n+                    tcx.sess.bug(fmt!(\n+                        \"cannot get field types from the enum type %s \\\n+                         without a node ID\",\n+                        ty_to_str(tcx, ty)));\n+                }\n+                Some(node_id) => {\n+                    match tcx.def_map.get(node_id) {\n+                        ast::def_variant(_, variant_id) => {\n+                            op(false, class_items_as_mutable_fields(\n+                                tcx, variant_id, substs))\n+                        }\n+                        _ => {\n+                            tcx.sess.bug(~\"resolve didn't map this expr to a \\\n+                                           variant ID\")\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n         _ => {\n             tcx.sess.bug(fmt!(\n                 \"cannot get field types from the type %s\",\n@@ -877,7 +906,7 @@ fn trans_rec_field(bcx: block,\n     let _icx = bcx.insn_ctxt(\"trans_rec_field\");\n \n     let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n-    do with_field_tys(bcx.tcx(), base_datum.ty) |_has_dtor, field_tys| {\n+    do with_field_tys(bcx.tcx(), base_datum.ty, None) |_dtor, field_tys| {\n         let ix = ty::field_idx_strict(bcx.tcx(), field, field_tys);\n         DatumBlock {\n             datum: base_datum.GEPi(bcx, [0u, 0u, ix], field_tys[ix].mt.ty),\n@@ -969,9 +998,45 @@ fn trans_rec_or_struct(bcx: block,\n         }\n     }\n \n+    // If this is a struct-like variant, write in the discriminant if\n+    // necessary, position the address at the right location, and cast the\n+    // address.\n     let ty = node_id_type(bcx, id);\n     let tcx = bcx.tcx();\n-    do with_field_tys(tcx, ty) |has_dtor, field_tys| {\n+    let addr = match ty::get(ty).sty {\n+        ty::ty_enum(_, ref substs) => {\n+            match tcx.def_map.get(id) {\n+                ast::def_variant(enum_id, variant_id) => {\n+                    let variant_info = ty::enum_variant_with_id(\n+                        tcx, enum_id, variant_id);\n+                    let addr = if ty::enum_is_univariant(tcx, enum_id) {\n+                        addr\n+                    } else {\n+                        Store(bcx,\n+                              C_int(bcx.ccx(), variant_info.disr_val),\n+                              GEPi(bcx, addr, [0, 0]));\n+                        GEPi(bcx, addr, [0, 1])\n+                    };\n+                    let fields = ty::class_items_as_mutable_fields(\n+                        tcx, variant_id, substs);\n+                    let field_lltys = do fields.map |field| {\n+                        type_of(bcx.ccx(),\n+                                ty::subst_tps(\n+                                    tcx, substs.tps, None, field.mt.ty))\n+                    };\n+                    PointerCast(bcx, addr,\n+                                T_ptr(T_struct(~[T_struct(field_lltys)])))\n+                }\n+                _ => {\n+                    tcx.sess.bug(~\"resolve didn't write the right def in for \\\n+                                   this struct-like variant\")\n+                }\n+            }\n+        }\n+        _ => addr\n+    };\n+\n+    do with_field_tys(tcx, ty, Some(id)) |has_dtor, field_tys| {\n         // evaluate each of the fields and store them into their\n         // correct locations\n         let mut temp_cleanups = ~[];"}, {"sha": "e065fdfe0bc7995573f0ad5f13fd44a9a442f207", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/61bb3571a59f4659a0a46565c71fa7ecfa352811/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb3571a59f4659a0a46565c71fa7ecfa352811/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=61bb3571a59f4659a0a46565c71fa7ecfa352811", "patch": "@@ -3721,6 +3721,17 @@ fn lookup_class_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n             _ => cx.sess.bug(~\"class ID bound to non-class\")\n          }\n        }\n+       Some(ast_map::node_variant(variant, _, _)) => {\n+          match variant.node.kind {\n+            ast::struct_variant_kind(struct_def) => {\n+              class_field_tys(struct_def.fields)\n+            }\n+            _ => {\n+              cx.sess.bug(~\"struct ID bound to enum variant that isn't \\\n+                            struct-like\")\n+            }\n+          }\n+       }\n        _ => {\n            cx.sess.bug(\n                fmt!(\"class ID not bound to an item: %s\","}, {"sha": "339a035b35cfac99bb253f8b4dbf19f238fedc7e", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 164, "deletions": 60, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/61bb3571a59f4659a0a46565c71fa7ecfa352811/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb3571a59f4659a0a46565c71fa7ecfa352811/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=61bb3571a59f4659a0a46565c71fa7ecfa352811", "patch": "@@ -1443,6 +1443,78 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         return bot;\n     }\n \n+    fn check_struct_or_variant_fields(fcx: @fn_ctxt,\n+                                      span: span,\n+                                      class_id: ast::def_id,\n+                                      substitutions: &ty::substs,\n+                                      field_types: ~[ty::field_ty],\n+                                      ast_fields: ~[ast::field],\n+                                      check_completeness: bool) -> bool {\n+        let tcx = fcx.ccx.tcx;\n+        let mut bot = false;\n+\n+        let class_field_map = HashMap();\n+        let mut fields_found = 0;\n+        for field_types.each |field| {\n+            // XXX: Check visibility here.\n+            class_field_map.insert(field.ident, (field.id, false));\n+        }\n+\n+        // Typecheck each field.\n+        for ast_fields.each |field| {\n+            match class_field_map.find(field.node.ident) {\n+                None => {\n+                    tcx.sess.span_err(\n+                        field.span,\n+                        fmt!(\"structure has no field named field named `%s`\",\n+                             tcx.sess.str_of(field.node.ident)));\n+                }\n+                Some((_, true)) => {\n+                    tcx.sess.span_err(\n+                        field.span,\n+                        fmt!(\"field `%s` specified more than once\",\n+                             tcx.sess.str_of(field.node.ident)));\n+                }\n+                Some((field_id, false)) => {\n+                    let expected_field_type =\n+                        ty::lookup_field_type(\n+                            tcx, class_id, field_id, substitutions);\n+                    bot |= check_expr(fcx,\n+                                      field.node.expr,\n+                                      Some(expected_field_type));\n+                    fields_found += 1;\n+                }\n+            }\n+        }\n+\n+        if check_completeness {\n+            // Make sure the programmer specified all the fields.\n+            assert fields_found <= ast_fields.len();\n+            if fields_found < ast_fields.len() {\n+                let mut missing_fields = ~[];\n+                for ast_fields.each |class_field| {\n+                    let name = class_field.node.ident;\n+                    let (_, seen) = class_field_map.get(name);\n+                    if !seen {\n+                        missing_fields.push(\n+                            ~\"`\" + tcx.sess.str_of(name) + ~\"`\");\n+                    }\n+                }\n+\n+                tcx.sess.span_err(span,\n+                                  fmt!(\"missing field%s: %s\",\n+                                       if missing_fields.len() == 1 {\n+                                           ~\"\"\n+                                       } else {\n+                                           ~\"s\"\n+                                       },\n+                                       str::connect(missing_fields, ~\", \")));\n+            }\n+        }\n+\n+        return bot;\n+    }\n+\n     fn check_struct_constructor(fcx: @fn_ctxt,\n                                 id: ast::node_id,\n                                 span: syntax::codemap::span,\n@@ -1501,76 +1573,99 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         let struct_type = ty::subst(tcx, &substitutions, raw_type);\n \n-        // Look up the class fields and build up a map.\n+        // Look up and check the fields.\n         let class_fields = ty::lookup_class_fields(tcx, class_id);\n-        let class_field_map = HashMap();\n-        let mut fields_found = 0;\n-        for class_fields.each |field| {\n-            // XXX: Check visibility here.\n-            class_field_map.insert(field.ident, (field.id, false));\n+        bot = check_struct_or_variant_fields(fcx,\n+                                             span,\n+                                             class_id,\n+                                             &substitutions,\n+                                             class_fields,\n+                                             fields,\n+                                             base_expr.is_none()) || bot;\n+\n+        // Check the base expression if necessary.\n+        match base_expr {\n+            None => {}\n+            Some(base_expr) => {\n+                bot = check_expr(fcx, base_expr, Some(struct_type)) || bot\n+            }\n         }\n \n-        // Typecheck each field.\n-        for fields.each |field| {\n-            match class_field_map.find(field.node.ident) {\n-                None => {\n-                    tcx.sess.span_err(\n-                        field.span,\n-                        fmt!(\"structure has no field named field named `%s`\",\n-                             tcx.sess.str_of(field.node.ident)));\n-                }\n-                Some((_, true)) => {\n-                    tcx.sess.span_err(\n-                        field.span,\n-                        fmt!(\"field `%s` specified more than once\",\n-                             tcx.sess.str_of(field.node.ident)));\n+        // Write in the resulting type.\n+        fcx.write_ty(id, struct_type);\n+        return bot;\n+    }\n+\n+    fn check_struct_enum_variant(fcx: @fn_ctxt,\n+                                 id: ast::node_id,\n+                                 span: syntax::codemap::span,\n+                                 enum_id: ast::def_id,\n+                                 variant_id: ast::def_id,\n+                                 fields: ~[ast::field]) -> bool {\n+        let mut bot = false;\n+        let tcx = fcx.ccx.tcx;\n+\n+        // Look up the number of type parameters and the raw type, and\n+        // determine whether the enum is region-parameterized.\n+        let type_parameter_count, region_parameterized, raw_type;\n+        if enum_id.crate == ast::local_crate {\n+            region_parameterized =\n+                tcx.region_paramd_items.find(enum_id.node);\n+            match tcx.items.find(enum_id.node) {\n+                Some(ast_map::node_item(@{\n+                        node: ast::item_enum(_, type_parameters),\n+                        _\n+                    }, _)) => {\n+\n+                    type_parameter_count = type_parameters.len();\n+\n+                    let self_region =\n+                        bound_self_region(region_parameterized);\n+\n+                    raw_type = ty::mk_enum(tcx, enum_id, {\n+                        self_r: self_region,\n+                        self_ty: None,\n+                        tps: ty::ty_params_to_tys(tcx, type_parameters)\n+                    });\n                 }\n-                Some((field_id, false)) => {\n-                    let expected_field_type =\n-                        ty::lookup_field_type(tcx, class_id, field_id,\n-                                              &substitutions);\n-                    bot |= check_expr(fcx,\n-                                      field.node.expr,\n-                                      Some(expected_field_type));\n-                    fields_found += 1;\n+                _ => {\n+                    tcx.sess.span_bug(span,\n+                                      ~\"resolve didn't map this to an enum\");\n                 }\n             }\n+        } else {\n+            let item_type = ty::lookup_item_type(tcx, enum_id);\n+            type_parameter_count = (*item_type.bounds).len();\n+            region_parameterized = item_type.region_param;\n+            raw_type = item_type.ty;\n         }\n \n-        match base_expr {\n-            None => {\n-                // Make sure the programmer specified all the fields.\n-                assert fields_found <= class_fields.len();\n-                if fields_found < class_fields.len() {\n-                    let mut missing_fields = ~[];\n-                    for class_fields.each |class_field| {\n-                        let name = class_field.ident;\n-                        let (_, seen) = class_field_map.get(name);\n-                        if !seen {\n-                            missing_fields.push(\n-                                ~\"`\" + tcx.sess.str_of(name) + ~\"`\");\n-                        }\n-                    }\n+        // Generate the enum type.\n+        let self_region =\n+            fcx.region_var_if_parameterized(region_parameterized,\n+                                            span,\n+                                            ty::re_scope(id));\n+        let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n+        let substitutions = {\n+            self_r: self_region,\n+            self_ty: None,\n+            tps: type_parameters\n+        };\n \n-                    tcx.sess.span_err(span,\n-                                      fmt!(\"missing field%s: %s\",\n-                                           if missing_fields.len() == 1 {\n-                                               ~\"\"\n-                                           } else {\n-                                               ~\"s\"\n-                                           },\n-                                           str::connect(missing_fields,\n-                                                        ~\", \")));\n-                }\n-            }\n-            Some(base_expr) => {\n-                // Just check the base expression.\n-                check_expr(fcx, base_expr, Some(struct_type));\n-            }\n-        }\n+        let enum_type = ty::subst(tcx, &substitutions, raw_type);\n+\n+        // Look up and check the enum variant fields.\n+        let variant_fields = ty::lookup_class_fields(tcx, variant_id);\n+        bot = check_struct_or_variant_fields(fcx,\n+                                             span,\n+                                             variant_id,\n+                                             &substitutions,\n+                                             variant_fields,\n+                                             fields,\n+                                             true) || bot;\n \n         // Write in the resulting type.\n-        fcx.write_ty(id, struct_type);\n+        fcx.write_ty(id, enum_type);\n         return bot;\n     }\n \n@@ -2045,6 +2140,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 check_struct_constructor(fcx, id, expr.span, type_def_id,\n                                          fields, base_expr);\n             }\n+            Some(ast::def_variant(enum_id, variant_id)) => {\n+                check_struct_enum_variant(fcx, id, expr.span, enum_id,\n+                                          variant_id, fields);\n+            }\n             _ => {\n                 tcx.sess.span_bug(path.span, ~\"structure constructor does \\\n                                                not name a structure type\");\n@@ -2314,9 +2413,14 @@ fn check_enum_variants(ccx: @crate_ctxt,\n                 ast::tuple_variant_kind(args) if args.len() > 0u => {\n                     arg_tys = Some(ty::ty_fn_args(ctor_ty).map(|a| a.ty));\n                 }\n-                ast::tuple_variant_kind(_) | ast::struct_variant_kind(_) => {\n+                ast::tuple_variant_kind(_) => {\n                     arg_tys = Some(~[]);\n                 }\n+                ast::struct_variant_kind(_) => {\n+                    arg_tys = Some(ty::lookup_class_fields(\n+                        ccx.tcx, local_def(v.node.id)).map(|cf|\n+                            ty::node_id_to_type(ccx.tcx, cf.id.node)));\n+                }\n                 ast::enum_variant_kind(_) => {\n                     arg_tys = None;\n                     do_check(ccx, sp, vs, id, disr_vals, disr_val, variants);"}, {"sha": "1660f1e076ce9ff2e8bed9691eae9cb63ccaa933", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/61bb3571a59f4659a0a46565c71fa7ecfa352811/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb3571a59f4659a0a46565c71fa7ecfa352811/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=61bb3571a59f4659a0a46565c71fa7ecfa352811", "patch": "@@ -139,9 +139,18 @@ fn get_enum_variant_types(ccx: @crate_ctxt,\n                                 output: enum_ty}\n                 }));\n             }\n-            ast::tuple_variant_kind(_) | ast::struct_variant_kind(_) => {\n+            ast::tuple_variant_kind(_) => {\n                 result_ty = Some(enum_ty);\n             }\n+            ast::struct_variant_kind(struct_def) => {\n+                result_ty = Some(enum_ty);\n+                // XXX: Merge with computation of the the same value below?\n+                let tpt = {bounds: ty_param_bounds(ccx, ty_params),\n+                           region_param: rp,\n+                           ty: enum_ty};\n+                convert_struct(\n+                    ccx, rp, struct_def, ty_params, tpt, variant.node.id);\n+            }\n             ast::enum_variant_kind(enum_definition) => {\n                 get_enum_variant_types(ccx, enum_ty, enum_definition.variants,\n                                        ty_params, rp);"}, {"sha": "ae7068495a5bba8bf2e4e21c105157eb31bb160c", "filename": "src/test/run-pass/struct-like-variant-construct.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/61bb3571a59f4659a0a46565c71fa7ecfa352811/src%2Ftest%2Frun-pass%2Fstruct-like-variant-construct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb3571a59f4659a0a46565c71fa7ecfa352811/src%2Ftest%2Frun-pass%2Fstruct-like-variant-construct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-like-variant-construct.rs?ref=61bb3571a59f4659a0a46565c71fa7ecfa352811", "patch": "@@ -0,0 +1,15 @@\n+enum Foo {\n+    Bar {\n+        a: int,\n+        b: int\n+    },\n+    Baz {\n+        c: float,\n+        d: float\n+    }\n+}\n+\n+fn main() {\n+    let x = Bar { a: 2, b: 3 };\n+}\n+"}]}