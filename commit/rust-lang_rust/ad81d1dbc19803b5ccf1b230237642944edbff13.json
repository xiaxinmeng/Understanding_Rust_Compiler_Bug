{"sha": "ad81d1dbc19803b5ccf1b230237642944edbff13", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkODFkMWRiYzE5ODAzYjVjY2YxYjIzMDIzNzY0Mjk0NGVkYmZmMTM=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-12-20T19:37:03Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-12-20T19:37:03Z"}, "message": "Add support macros in impl blocks", "tree": {"sha": "5af29382643b659b69523e65354e862d7e71087d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5af29382643b659b69523e65354e862d7e71087d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad81d1dbc19803b5ccf1b230237642944edbff13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad81d1dbc19803b5ccf1b230237642944edbff13", "html_url": "https://github.com/rust-lang/rust/commit/ad81d1dbc19803b5ccf1b230237642944edbff13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad81d1dbc19803b5ccf1b230237642944edbff13/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfc50ff160d0af2ce5cd931c6d41161abfdb2fbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfc50ff160d0af2ce5cd931c6d41161abfdb2fbd", "html_url": "https://github.com/rust-lang/rust/commit/cfc50ff160d0af2ce5cd931c6d41161abfdb2fbd"}], "stats": {"total": 162, "additions": 114, "deletions": 48}, "files": [{"sha": "a92c01f86f2c8f5f8c16e349c3931d2738abf6c8", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad81d1dbc19803b5ccf1b230237642944edbff13/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad81d1dbc19803b5ccf1b230237642944edbff13/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=ad81d1dbc19803b5ccf1b230237642944edbff13", "patch": "@@ -23,7 +23,7 @@ use crate::{\n     DefWithBodyId, HasModule, Lookup, ModuleDefId, ModuleId,\n };\n \n-struct Expander {\n+pub(crate) struct Expander {\n     crate_def_map: Arc<CrateDefMap>,\n     current_file_id: HirFileId,\n     hygiene: Hygiene,\n@@ -32,18 +32,22 @@ struct Expander {\n }\n \n impl Expander {\n-    fn new(db: &impl DefDatabase, current_file_id: HirFileId, module: ModuleId) -> Expander {\n+    pub(crate) fn new(\n+        db: &impl DefDatabase,\n+        current_file_id: HirFileId,\n+        module: ModuleId,\n+    ) -> Expander {\n         let crate_def_map = db.crate_def_map(module.krate);\n         let hygiene = Hygiene::new(db, current_file_id);\n         let ast_id_map = db.ast_id_map(current_file_id);\n         Expander { crate_def_map, current_file_id, hygiene, ast_id_map, module }\n     }\n \n-    fn enter_expand(\n+    pub(crate) fn enter_expand<T: ast::AstNode, DB: DefDatabase>(\n         &mut self,\n-        db: &impl DefDatabase,\n+        db: &DB,\n         macro_call: ast::MacroCall,\n-    ) -> Option<(Mark, ast::Expr)> {\n+    ) -> Option<(Mark, T)> {\n         let ast_id = AstId::new(\n             self.current_file_id,\n             db.ast_id_map(self.current_file_id).ast_id(&macro_call),\n@@ -54,7 +58,7 @@ impl Expander {\n                 let call_id = def.as_call_id(db, MacroCallKind::FnLike(ast_id));\n                 let file_id = call_id.as_file();\n                 if let Some(node) = db.parse_or_expand(file_id) {\n-                    if let Some(expr) = ast::Expr::cast(node) {\n+                    if let Some(expr) = T::cast(node) {\n                         log::debug!(\"macro expansion {:#?}\", expr.syntax());\n \n                         let mark = Mark {\n@@ -77,14 +81,14 @@ impl Expander {\n         None\n     }\n \n-    fn exit(&mut self, db: &impl DefDatabase, mut mark: Mark) {\n+    pub(crate) fn exit(&mut self, db: &impl DefDatabase, mut mark: Mark) {\n         self.hygiene = Hygiene::new(db, mark.file_id);\n         self.current_file_id = mark.file_id;\n         self.ast_id_map = mem::take(&mut mark.ast_id_map);\n         mark.bomb.defuse();\n     }\n \n-    fn to_source<T>(&self, value: T) -> InFile<T> {\n+    pub(crate) fn to_source<T>(&self, value: T) -> InFile<T> {\n         InFile { file_id: self.current_file_id, value }\n     }\n \n@@ -109,7 +113,7 @@ impl Expander {\n     }\n }\n \n-struct Mark {\n+pub(crate) struct Mark {\n     file_id: HirFileId,\n     ast_id_map: Arc<AstIdMap>,\n     bomb: DropBomb,"}, {"sha": "b0a3f178457dc51fdae3e8c261f2a9a02fce4769", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 80, "deletions": 39, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/ad81d1dbc19803b5ccf1b230237642944edbff13/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad81d1dbc19803b5ccf1b230237642944edbff13/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=ad81d1dbc19803b5ccf1b230237642944edbff13", "patch": "@@ -4,16 +4,16 @@ use std::sync::Arc;\n \n use hir_expand::{\n     name::{name, AsName, Name},\n-    AstId,\n+    AstId, InFile,\n };\n-use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n+use ra_syntax::ast::{self, AstNode, ImplItem, ModuleItemOwner, NameOwner, TypeAscriptionOwner};\n \n use crate::{\n     db::DefDatabase,\n     src::HasSource,\n     type_ref::{Mutability, TypeRef},\n-    AssocContainerId, AssocItemId, ConstId, ConstLoc, FunctionId, FunctionLoc, ImplId, Intern,\n-    Lookup, StaticId, TraitId, TypeAliasId, TypeAliasLoc,\n+    AssocContainerId, AssocItemId, ConstId, ConstLoc, Expander, FunctionId, FunctionLoc, HasModule,\n+    ImplId, Intern, Lookup, ModuleId, StaticId, TraitId, TypeAliasId, TypeAliasLoc,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -167,46 +167,24 @@ pub struct ImplData {\n \n impl ImplData {\n     pub(crate) fn impl_data_query(db: &impl DefDatabase, id: ImplId) -> Arc<ImplData> {\n-        let src = id.lookup(db).source(db);\n-        let items = db.ast_id_map(src.file_id);\n+        let impl_loc = id.lookup(db);\n+        let src = impl_loc.source(db);\n \n         let target_trait = src.value.target_trait().map(TypeRef::from_ast);\n         let target_type = TypeRef::from_ast_opt(src.value.target_type());\n         let is_negative = src.value.is_negative();\n+        let module_id = impl_loc.container.module(db);\n \n-        let items = if let Some(item_list) = src.value.item_list() {\n-            item_list\n-                .impl_items()\n-                .map(|item_node| match item_node {\n-                    ast::ImplItem::FnDef(it) => {\n-                        let def = FunctionLoc {\n-                            container: AssocContainerId::ImplId(id),\n-                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n-                        }\n-                        .intern(db);\n-                        def.into()\n-                    }\n-                    ast::ImplItem::ConstDef(it) => {\n-                        let def = ConstLoc {\n-                            container: AssocContainerId::ImplId(id),\n-                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n-                        }\n-                        .intern(db);\n-                        def.into()\n-                    }\n-                    ast::ImplItem::TypeAliasDef(it) => {\n-                        let def = TypeAliasLoc {\n-                            container: AssocContainerId::ImplId(id),\n-                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n-                        }\n-                        .intern(db);\n-                        def.into()\n-                    }\n-                })\n-                .collect()\n-        } else {\n-            Vec::new()\n-        };\n+        let mut items = Vec::new();\n+        if let Some(item_list) = src.value.item_list() {\n+            items.extend(collect_impl_items(db, item_list.impl_items(), src.file_id, id));\n+            items.extend(collect_impl_items_in_macros(\n+                db,\n+                module_id,\n+                &src.with_value(item_list),\n+                id,\n+            ));\n+        }\n \n         let res = ImplData { target_trait, target_type, items, is_negative };\n         Arc::new(res)\n@@ -237,3 +215,66 @@ impl ConstData {\n         ConstData { name, type_ref }\n     }\n }\n+\n+fn collect_impl_items_in_macros(\n+    db: &impl DefDatabase,\n+    module_id: ModuleId,\n+    impl_block: &InFile<ast::ItemList>,\n+    id: ImplId,\n+) -> Vec<AssocItemId> {\n+    let mut expander = Expander::new(db, impl_block.file_id, module_id);\n+    let mut res = Vec::new();\n+\n+    for m in impl_block.value.syntax().children().filter_map(ast::MacroCall::cast) {\n+        if let Some((mark, items)) = expander.enter_expand(db, m) {\n+            let items: InFile<ast::MacroItems> = expander.to_source(items);\n+            expander.exit(db, mark);\n+            res.extend(collect_impl_items(\n+                db,\n+                items.value.items().filter_map(|it| ImplItem::cast(it.syntax().clone())),\n+                items.file_id,\n+                id,\n+            ));\n+        }\n+    }\n+\n+    res\n+}\n+\n+fn collect_impl_items(\n+    db: &impl DefDatabase,\n+    impl_items: impl Iterator<Item = ImplItem>,\n+    file_id: crate::HirFileId,\n+    id: ImplId,\n+) -> Vec<AssocItemId> {\n+    let items = db.ast_id_map(file_id);\n+\n+    impl_items\n+        .map(|item_node| match item_node {\n+            ast::ImplItem::FnDef(it) => {\n+                let def = FunctionLoc {\n+                    container: AssocContainerId::ImplId(id),\n+                    ast_id: AstId::new(file_id, items.ast_id(&it)),\n+                }\n+                .intern(db);\n+                def.into()\n+            }\n+            ast::ImplItem::ConstDef(it) => {\n+                let def = ConstLoc {\n+                    container: AssocContainerId::ImplId(id),\n+                    ast_id: AstId::new(file_id, items.ast_id(&it)),\n+                }\n+                .intern(db);\n+                def.into()\n+            }\n+            ast::ImplItem::TypeAliasDef(it) => {\n+                let def = TypeAliasLoc {\n+                    container: AssocContainerId::ImplId(id),\n+                    ast_id: AstId::new(file_id, items.ast_id(&it)),\n+                }\n+                .intern(db);\n+                def.into()\n+            }\n+        })\n+        .collect()\n+}"}, {"sha": "6bb5408a862fb820dce49341215a52e547e9688e", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad81d1dbc19803b5ccf1b230237642944edbff13/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad81d1dbc19803b5ccf1b230237642944edbff13/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=ad81d1dbc19803b5ccf1b230237642944edbff13", "patch": "@@ -47,6 +47,7 @@ use ra_arena::{impl_arena_id, RawId};\n use ra_db::{impl_intern_key, salsa, CrateId};\n use ra_syntax::{ast, AstNode};\n \n+use crate::body::Expander;\n use crate::builtin_type::BuiltinType;\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]"}, {"sha": "d86445abfff6d93efe680f2ea425553222b5281e", "filename": "crates/ra_hir_expand/src/db.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad81d1dbc19803b5ccf1b230237642944edbff13/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad81d1dbc19803b5ccf1b230237642944edbff13/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=ad81d1dbc19803b5ccf1b230237642944edbff13", "patch": "@@ -188,6 +188,7 @@ fn to_fragment_kind(db: &dyn AstDatabase, macro_call_id: MacroCallId) -> Fragmen\n         ARG_LIST => FragmentKind::Expr,\n         TRY_EXPR => FragmentKind::Expr,\n         TUPLE_EXPR => FragmentKind::Expr,\n+        ITEM_LIST => FragmentKind::Items,\n         _ => {\n             // Unknown , Just guess it is `Items`\n             FragmentKind::Items"}, {"sha": "7fdbf996f42de2bf373d2d2c60252ee2f879efa3", "filename": "crates/ra_hir_ty/src/tests/macros.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ad81d1dbc19803b5ccf1b230237642944edbff13/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad81d1dbc19803b5ccf1b230237642944edbff13/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=ad81d1dbc19803b5ccf1b230237642944edbff13", "patch": "@@ -182,6 +182,25 @@ fn test() { S.foo()<|>; }\n     assert_eq!(t, \"u128\");\n }\n \n+#[test]\n+fn infer_impl_items_generated_by_macros() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+macro_rules! m {\n+    () => (fn foo(&self) -> u128 {0})\n+}\n+struct S;\n+impl S {\n+    m!();\n+}\n+\n+fn test() { S.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"u128\");\n+}\n+\n #[test]\n fn infer_macro_with_dollar_crate_is_correct_in_expr() {\n     let (db, pos) = TestDB::with_position("}]}