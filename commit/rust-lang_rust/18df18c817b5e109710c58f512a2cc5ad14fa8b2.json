{"sha": "18df18c817b5e109710c58f512a2cc5ad14fa8b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4ZGYxOGM4MTdiNWUxMDk3MTBjNThmNTEyYTJjYzVhZDE0ZmE4YjI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-22T01:24:42Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-23T04:57:11Z"}, "message": "libstd: Fix merge fallout.", "tree": {"sha": "09cb14a7fa03754cc978d4824a47979acc6d836e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09cb14a7fa03754cc978d4824a47979acc6d836e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18df18c817b5e109710c58f512a2cc5ad14fa8b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18df18c817b5e109710c58f512a2cc5ad14fa8b2", "html_url": "https://github.com/rust-lang/rust/commit/18df18c817b5e109710c58f512a2cc5ad14fa8b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18df18c817b5e109710c58f512a2cc5ad14fa8b2/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee52865c8848657e737e3c2071728b062ec9c8de", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee52865c8848657e737e3c2071728b062ec9c8de", "html_url": "https://github.com/rust-lang/rust/commit/ee52865c8848657e737e3c2071728b062ec9c8de"}], "stats": {"total": 1062, "additions": 1042, "deletions": 20}, "files": [{"sha": "57d6c46d9f38b25055ffe39e99bacab6eac9d61e", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=18df18c817b5e109710c58f512a2cc5ad14fa8b2", "patch": "@@ -54,18 +54,6 @@ pub fn each_lang_item(cstore: @mut cstore::CStore,\n }\n \n /// Iterates over all the paths in the given crate.\n-#[cfg(stage0)]\n-pub fn each_path(cstore: @mut cstore::CStore,\n-                 cnum: ast::crate_num,\n-                 f: &fn(&str, decoder::def_like, ast::visibility) -> bool) {\n-    let crate_data = cstore::get_crate_data(cstore, cnum);\n-    let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n-        cstore::get_crate_data(cstore, cnum)\n-    };\n-    decoder::each_path(cstore.intr, crate_data, get_crate_data, f)\n-}\n-/// Iterates over all the paths in the given crate.\n-#[cfg(not(stage0))]\n pub fn each_path(cstore: @mut cstore::CStore,\n                  cnum: ast::crate_num,\n                  f: &fn(&str, decoder::def_like, ast::visibility) -> bool)"}, {"sha": "2cc0382269ebcb695cc3a57395153136bad9e1f4", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=18df18c817b5e109710c58f512a2cc5ad14fa8b2", "patch": "@@ -566,14 +566,6 @@ pub fn _each_path(intr: @ident_interner,\n     return broken;\n }\n \n-#[cfg(stage0)]\n-pub fn each_path(intr: @ident_interner,\n-                 cdata: cmd,\n-                 get_crate_data: GetCrateDataCb,\n-                 f: &fn(&str, def_like, ast::visibility) -> bool) {\n-    _each_path(intr, cdata, get_crate_data, f);\n-}\n-#[cfg(not(stage0))]\n pub fn each_path(intr: @ident_interner,\n                  cdata: cmd,\n                  get_crate_data: GetCrateDataCb,"}, {"sha": "f7b30e22f0110eac279e0bbcfccd2b3471043edb", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=18df18c817b5e109710c58f512a2cc5ad14fa8b2", "patch": "@@ -11,6 +11,8 @@\n //! This module implements the check that the lifetime of a borrow\n //! does not exceed the lifetime of the value being borrowed.\n \n+use core::prelude::*;\n+\n use middle::borrowck::*;\n use mc = middle::mem_categorization;\n use middle::ty;"}, {"sha": "a422d99b6f5cf404ce3916dcfbfa09065ff6fb22", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=18df18c817b5e109710c58f512a2cc5ad14fa8b2", "patch": "@@ -16,6 +16,8 @@\n // their associated scopes.  In phase two, checking loans, we will then make\n // sure that all of these loans are honored.\n \n+use core::prelude::*;\n+\n use middle::borrowck::*;\n use mc = middle::mem_categorization;\n use middle::pat_util;"}, {"sha": "42b1c40a4b3c488d514f369ace6f60e6c13e4189", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=18df18c817b5e109710c58f512a2cc5ad14fa8b2", "patch": "@@ -10,6 +10,8 @@\n \n //! Computes the restrictions that result from a borrow.\n \n+use core::prelude::*;\n+\n use middle::borrowck::*;\n use mc = middle::mem_categorization;\n use middle::ty;"}, {"sha": "39479e726f8b6c44af18d057d8f72cb29d9a3013", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=18df18c817b5e109710c58f512a2cc5ad14fa8b2", "patch": "@@ -10,6 +10,8 @@\n \n /*! See doc.rs for a thorough explanation of the borrow checker */\n \n+use core::prelude::*;\n+\n use mc = middle::mem_categorization;\n use middle::ty;\n use middle::typeck;"}, {"sha": "6a6746ab20bd9b4a6c5205aed21d766d1060a75a", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=18df18c817b5e109710c58f512a2cc5ad14fa8b2", "patch": "@@ -22,6 +22,7 @@ use middle::lint::unused_imports;\n use middle::pat_util::pat_bindings;\n \n use syntax::ast::*;\n+use syntax::ast;\n use syntax::ast_util::{def_id_of_def, local_def};\n use syntax::ast_util::{path_to_ident, walk_pat, trait_method_to_ty_method};\n use syntax::ast_util::{Privacy, Public, Private};"}, {"sha": "576a402b70919f88e52750473b854b6a8a04595a", "filename": "src/libstd/rt/comm.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=18df18c817b5e109710c58f512a2cc5ad14fa8b2", "previous_filename": "src/libcore/rt/comm.rs"}, {"sha": "ce7ff87b44580c37fc22423cda6de3790a9813d4", "filename": "src/libstd/rt/global_heap.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=18df18c817b5e109710c58f512a2cc5ad14fa8b2", "patch": "@@ -0,0 +1,87 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use sys::{TypeDesc, size_of};\n+use libc::{c_void, size_t, uintptr_t};\n+use c_malloc = libc::malloc;\n+use c_free = libc::free;\n+use managed::raw::{BoxHeaderRepr, BoxRepr};\n+use cast::transmute;\n+use unstable::intrinsics::{atomic_xadd,atomic_xsub};\n+use ptr::null;\n+use intrinsic::TyDesc;\n+\n+pub unsafe fn malloc(td: *TypeDesc, size: uint) -> *c_void {\n+    assert!(td.is_not_null());\n+\n+    let total_size = get_box_size(size, (*td).align);\n+    let p = c_malloc(total_size as size_t);\n+    assert!(p.is_not_null());\n+\n+    // FIXME #3475: Converting between our two different tydesc types\n+    let td: *TyDesc = transmute(td);\n+\n+    let box: &mut BoxRepr = transmute(p);\n+    box.header.ref_count = -1; // Exchange values not ref counted\n+    box.header.type_desc = td;\n+    box.header.prev = null();\n+    box.header.next = null();\n+\n+    let exchange_count = &mut *exchange_count_ptr();\n+    atomic_xadd(exchange_count, 1);\n+\n+    return transmute(box);\n+}\n+/**\n+Thin wrapper around libc::malloc, none of the box header\n+stuff in exchange_alloc::malloc\n+*/\n+pub unsafe fn malloc_raw(size: uint) -> *c_void {\n+    let p = c_malloc(size as size_t);\n+    if p.is_null() {\n+        fail!(\"Failure in malloc_raw: result ptr is null\");\n+    }\n+    p\n+}\n+\n+pub unsafe fn free(ptr: *c_void) {\n+    let exchange_count = &mut *exchange_count_ptr();\n+    atomic_xsub(exchange_count, 1);\n+\n+    assert!(ptr.is_not_null());\n+    c_free(ptr);\n+}\n+///Thin wrapper around libc::free, as with exchange_alloc::malloc_raw\n+pub unsafe fn free_raw(ptr: *c_void) {\n+    c_free(ptr);\n+}\n+\n+fn get_box_size(body_size: uint, body_align: uint) -> uint {\n+    let header_size = size_of::<BoxHeaderRepr>();\n+    // FIXME (#2699): This alignment calculation is suspicious. Is it right?\n+    let total_size = align_to(header_size, body_align) + body_size;\n+    return total_size;\n+}\n+\n+// Rounds |size| to the nearest |alignment|. Invariant: |alignment| is a power\n+// of two.\n+fn align_to(size: uint, align: uint) -> uint {\n+    assert!(align != 0);\n+    (size + align - 1) & !(align - 1)\n+}\n+\n+fn exchange_count_ptr() -> *mut int {\n+    // XXX: Need mutable globals\n+    unsafe { transmute(&rust_exchange_count) }\n+}\n+\n+extern {\n+    static rust_exchange_count: uintptr_t;\n+}"}, {"sha": "b580b752bd985c8242eba880ed6c6d32344a6f7b", "filename": "src/libstd/rt/io/mock.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Fio%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Fio%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmock.rs?ref=18df18c817b5e109710c58f512a2cc5ad14fa8b2", "previous_filename": "src/libcore/rt/io/mock.rs"}, {"sha": "64a384ddff0b90e01f40be6fda577a35dea13d3c", "filename": "src/libstd/rt/local.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=18df18c817b5e109710c58f512a2cc5ad14fa8b2", "previous_filename": "src/libcore/rt/local.rs"}, {"sha": "80d797e8c65434ae89b0803ec0152a395734bfe5", "filename": "src/libstd/rt/local_ptr.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=18df18c817b5e109710c58f512a2cc5ad14fa8b2", "previous_filename": "src/libcore/rt/local_ptr.rs"}, {"sha": "a0d0539768912b1a0c36f7ce23f61a054018bb94", "filename": "src/libstd/rt/logging.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=18df18c817b5e109710c58f512a2cc5ad14fa8b2", "previous_filename": "src/libcore/rt/logging.rs"}, {"sha": "eaab9288ac8d00f34b7cab9d14455248acff0f70", "filename": "src/libstd/rt/message_queue.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Fmessage_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Fmessage_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmessage_queue.rs?ref=18df18c817b5e109710c58f512a2cc5ad14fa8b2", "previous_filename": "src/libcore/rt/message_queue.rs"}, {"sha": "1c0c8c14fdfa6404fa2be80abf552c6a55b26ef8", "filename": "src/libstd/rt/rc.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frc.rs?ref=18df18c817b5e109710c58f512a2cc5ad14fa8b2", "previous_filename": "src/libcore/rt/rc.rs"}, {"sha": "50c6a894093f3b1d6b05501fce48fe302e9c1794", "filename": "src/libstd/rt/sched.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=18df18c817b5e109710c58f512a2cc5ad14fa8b2", "previous_filename": "src/libcore/rt/sched.rs"}, {"sha": "b2f475a69660573b20924fa5bf44e54868d45064", "filename": "src/libstd/rt/tube.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Ftube.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Ftube.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftube.rs?ref=18df18c817b5e109710c58f512a2cc5ad14fa8b2", "previous_filename": "src/libcore/rt/tube.rs"}, {"sha": "2cf0b5c4872889d94e61e82dd1579b6eaeec1d68", "filename": "src/libstd/rt/uv/idle.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fidle.rs?ref=18df18c817b5e109710c58f512a2cc5ad14fa8b2", "previous_filename": "src/libcore/rt/uv/idle.rs"}, {"sha": "5557a58098751bceab944e81df1c2e6e6ff709cd", "filename": "src/libstd/rt/uv/timer.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs?ref=18df18c817b5e109710c58f512a2cc5ad14fa8b2", "previous_filename": "src/libcore/rt/uv/timer.rs"}, {"sha": "cacd67314ebac9a0dde6ac6ca540120cc79b6cd5", "filename": "src/libstd/rt/uv/uvio.rs", "status": "added", "additions": 492, "deletions": 0, "changes": 492, "blob_url": "https://github.com/rust-lang/rust/blob/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=18df18c817b5e109710c58f512a2cc5ad14fa8b2", "patch": "@@ -0,0 +1,492 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use option::*;\n+use result::*;\n+use ops::Drop;\n+use cell::{Cell, empty_cell};\n+use cast::transmute;\n+use clone::Clone;\n+use rt::io::IoError;\n+use rt::io::net::ip::IpAddr;\n+use rt::uv::*;\n+use rt::uv::idle::IdleWatcher;\n+use rt::rtio::*;\n+use rt::sched::Scheduler;\n+use rt::io::{standard_error, OtherIoError};\n+use rt::tube::Tube;\n+use rt::local::Local;\n+\n+#[cfg(test)] use container::Container;\n+#[cfg(test)] use uint;\n+#[cfg(test)] use unstable::run_in_bare_thread;\n+#[cfg(test)] use rt::test::*;\n+\n+pub struct UvEventLoop {\n+    uvio: UvIoFactory\n+}\n+\n+pub impl UvEventLoop {\n+    fn new() -> UvEventLoop {\n+        UvEventLoop {\n+            uvio: UvIoFactory(Loop::new())\n+        }\n+    }\n+\n+    /// A convenience constructor\n+    fn new_scheduler() -> Scheduler {\n+        Scheduler::new(~UvEventLoop::new())\n+    }\n+}\n+\n+impl Drop for UvEventLoop {\n+    fn finalize(&self) {\n+        // XXX: Need mutable finalizer\n+        let this = unsafe {\n+            transmute::<&UvEventLoop, &mut UvEventLoop>(self)\n+        };\n+        this.uvio.uv_loop().close();\n+    }\n+}\n+\n+impl EventLoop for UvEventLoop {\n+\n+    fn run(&mut self) {\n+        self.uvio.uv_loop().run();\n+    }\n+\n+    fn callback(&mut self, f: ~fn()) {\n+        let mut idle_watcher =  IdleWatcher::new(self.uvio.uv_loop());\n+        do idle_watcher.start |idle_watcher, status| {\n+            assert!(status.is_none());\n+            let mut idle_watcher = idle_watcher;\n+            idle_watcher.stop();\n+            idle_watcher.close(||());\n+            f();\n+        }\n+    }\n+\n+    fn callback_ms(&mut self, ms: u64, f: ~fn()) {\n+        let mut timer =  TimerWatcher::new(self.uvio.uv_loop());\n+        do timer.start(ms, 0) |timer, status| {\n+            assert!(status.is_none());\n+            timer.close(||());\n+            f();\n+        }\n+    }\n+\n+    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactoryObject> {\n+        Some(&mut self.uvio)\n+    }\n+}\n+\n+#[test]\n+fn test_callback_run_once() {\n+    do run_in_bare_thread {\n+        let mut event_loop = UvEventLoop::new();\n+        let mut count = 0;\n+        let count_ptr: *mut int = &mut count;\n+        do event_loop.callback {\n+            unsafe { *count_ptr += 1 }\n+        }\n+        event_loop.run();\n+        assert_eq!(count, 1);\n+    }\n+}\n+\n+pub struct UvIoFactory(Loop);\n+\n+pub impl UvIoFactory {\n+    fn uv_loop<'a>(&'a mut self) -> &'a mut Loop {\n+        match self { &UvIoFactory(ref mut ptr) => ptr }\n+    }\n+}\n+\n+impl IoFactory for UvIoFactory {\n+    // Connect to an address and return a new stream\n+    // NB: This blocks the task waiting on the connection.\n+    // It would probably be better to return a future\n+    fn tcp_connect(&mut self, addr: IpAddr) -> Result<~RtioTcpStreamObject, IoError> {\n+        // Create a cell in the task to hold the result. We will fill\n+        // the cell before resuming the task.\n+        let result_cell = empty_cell();\n+        let result_cell_ptr: *Cell<Result<~RtioTcpStreamObject, IoError>> = &result_cell;\n+\n+        let scheduler = Local::take::<Scheduler>();\n+        assert!(scheduler.in_task_context());\n+\n+        // Block this task and take ownership, switch to scheduler context\n+        do scheduler.deschedule_running_task_and_then |task| {\n+\n+            rtdebug!(\"connect: entered scheduler context\");\n+            do Local::borrow::<Scheduler> |scheduler| {\n+                assert!(!scheduler.in_task_context());\n+            }\n+            let mut tcp_watcher = TcpWatcher::new(self.uv_loop());\n+            let task_cell = Cell(task);\n+\n+            // Wait for a connection\n+            do tcp_watcher.connect(addr) |stream_watcher, status| {\n+                rtdebug!(\"connect: in connect callback\");\n+                if status.is_none() {\n+                    rtdebug!(\"status is none\");\n+                    let res = Ok(~UvTcpStream { watcher: stream_watcher });\n+\n+                    // Store the stream in the task's stack\n+                    unsafe { (*result_cell_ptr).put_back(res); }\n+\n+                    // Context switch\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_task_immediately(task_cell.take());\n+                } else {\n+                    rtdebug!(\"status is some\");\n+                    let task_cell = Cell(task_cell.take());\n+                    do stream_watcher.close {\n+                        let res = Err(uv_error_to_io_error(status.get()));\n+                        unsafe { (*result_cell_ptr).put_back(res); }\n+                        let scheduler = Local::take::<Scheduler>();\n+                        scheduler.resume_task_immediately(task_cell.take());\n+                    }\n+                };\n+            }\n+        }\n+\n+        assert!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n+\n+    fn tcp_bind(&mut self, addr: IpAddr) -> Result<~RtioTcpListenerObject, IoError> {\n+        let mut watcher = TcpWatcher::new(self.uv_loop());\n+        match watcher.bind(addr) {\n+            Ok(_) => Ok(~UvTcpListener::new(watcher)),\n+            Err(uverr) => {\n+                let scheduler = Local::take::<Scheduler>();\n+                do scheduler.deschedule_running_task_and_then |task| {\n+                    let task_cell = Cell(task);\n+                    do watcher.as_stream().close {\n+                        let scheduler = Local::take::<Scheduler>();\n+                        scheduler.resume_task_immediately(task_cell.take());\n+                    }\n+                }\n+                Err(uv_error_to_io_error(uverr))\n+            }\n+        }\n+    }\n+}\n+\n+// FIXME #6090: Prefer newtype structs but Drop doesn't work\n+pub struct UvTcpListener {\n+    watcher: TcpWatcher,\n+    listening: bool,\n+    incoming_streams: Tube<Result<~RtioTcpStreamObject, IoError>>\n+}\n+\n+impl UvTcpListener {\n+    fn new(watcher: TcpWatcher) -> UvTcpListener {\n+        UvTcpListener {\n+            watcher: watcher,\n+            listening: false,\n+            incoming_streams: Tube::new()\n+        }\n+    }\n+\n+    fn watcher(&self) -> TcpWatcher { self.watcher }\n+}\n+\n+impl Drop for UvTcpListener {\n+    fn finalize(&self) {\n+        let watcher = self.watcher();\n+        let scheduler = Local::take::<Scheduler>();\n+        do scheduler.deschedule_running_task_and_then |task| {\n+            let task_cell = Cell(task);\n+            do watcher.as_stream().close {\n+                let scheduler = Local::take::<Scheduler>();\n+                scheduler.resume_task_immediately(task_cell.take());\n+            }\n+        }\n+    }\n+}\n+\n+impl RtioTcpListener for UvTcpListener {\n+\n+    fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError> {\n+        rtdebug!(\"entering listen\");\n+\n+        if self.listening {\n+            return self.incoming_streams.recv();\n+        }\n+\n+        self.listening = true;\n+\n+        let server_tcp_watcher = self.watcher();\n+        let incoming_streams_cell = Cell(self.incoming_streams.clone());\n+\n+        let incoming_streams_cell = Cell(incoming_streams_cell.take());\n+        let mut server_tcp_watcher = server_tcp_watcher;\n+        do server_tcp_watcher.listen |server_stream_watcher, status| {\n+            let maybe_stream = if status.is_none() {\n+                let mut server_stream_watcher = server_stream_watcher;\n+                let mut loop_ = server_stream_watcher.event_loop();\n+                let client_tcp_watcher = TcpWatcher::new(&mut loop_);\n+                let client_tcp_watcher = client_tcp_watcher.as_stream();\n+                // XXX: Need's to be surfaced in interface\n+                server_stream_watcher.accept(client_tcp_watcher);\n+                Ok(~UvTcpStream { watcher: client_tcp_watcher })\n+            } else {\n+                Err(standard_error(OtherIoError))\n+            };\n+\n+            let mut incoming_streams = incoming_streams_cell.take();\n+            incoming_streams.send(maybe_stream);\n+            incoming_streams_cell.put_back(incoming_streams);\n+        }\n+\n+        return self.incoming_streams.recv();\n+    }\n+}\n+\n+// FIXME #6090: Prefer newtype structs but Drop doesn't work\n+pub struct UvTcpStream {\n+    watcher: StreamWatcher\n+}\n+\n+impl UvTcpStream {\n+    fn watcher(&self) -> StreamWatcher { self.watcher }\n+}\n+\n+impl Drop for UvTcpStream {\n+    fn finalize(&self) {\n+        rtdebug!(\"closing tcp stream\");\n+        let watcher = self.watcher();\n+        let scheduler = Local::take::<Scheduler>();\n+        do scheduler.deschedule_running_task_and_then |task| {\n+            let task_cell = Cell(task);\n+            do watcher.close {\n+                let scheduler = Local::take::<Scheduler>();\n+                scheduler.resume_task_immediately(task_cell.take());\n+            }\n+        }\n+    }\n+}\n+\n+impl RtioTcpStream for UvTcpStream {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        let result_cell = empty_cell();\n+        let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n+\n+        let scheduler = Local::take::<Scheduler>();\n+        assert!(scheduler.in_task_context());\n+        let watcher = self.watcher();\n+        let buf_ptr: *&mut [u8] = &buf;\n+        do scheduler.deschedule_running_task_and_then |task| {\n+            rtdebug!(\"read: entered scheduler context\");\n+            do Local::borrow::<Scheduler> |scheduler| {\n+                assert!(!scheduler.in_task_context());\n+            }\n+            let mut watcher = watcher;\n+            let task_cell = Cell(task);\n+            // XXX: We shouldn't reallocate these callbacks every\n+            // call to read\n+            let alloc: AllocCallback = |_| unsafe {\n+                slice_to_uv_buf(*buf_ptr)\n+            };\n+            do watcher.read_start(alloc) |watcher, nread, _buf, status| {\n+\n+                // Stop reading so that no read callbacks are\n+                // triggered before the user calls `read` again.\n+                // XXX: Is there a performance impact to calling\n+                // stop here?\n+                let mut watcher = watcher;\n+                watcher.read_stop();\n+\n+                let result = if status.is_none() {\n+                    assert!(nread >= 0);\n+                    Ok(nread as uint)\n+                } else {\n+                    Err(uv_error_to_io_error(status.unwrap()))\n+                };\n+\n+                unsafe { (*result_cell_ptr).put_back(result); }\n+\n+                let scheduler = Local::take::<Scheduler>();\n+                scheduler.resume_task_immediately(task_cell.take());\n+            }\n+        }\n+\n+        assert!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n+\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        let result_cell = empty_cell();\n+        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n+        let scheduler = Local::take::<Scheduler>();\n+        assert!(scheduler.in_task_context());\n+        let watcher = self.watcher();\n+        let buf_ptr: *&[u8] = &buf;\n+        do scheduler.deschedule_running_task_and_then |task| {\n+            let mut watcher = watcher;\n+            let task_cell = Cell(task);\n+            let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n+            do watcher.write(buf) |_watcher, status| {\n+                let result = if status.is_none() {\n+                    Ok(())\n+                } else {\n+                    Err(uv_error_to_io_error(status.unwrap()))\n+                };\n+\n+                unsafe { (*result_cell_ptr).put_back(result); }\n+\n+                let scheduler = Local::take::<Scheduler>();\n+                scheduler.resume_task_immediately(task_cell.take());\n+            }\n+        }\n+\n+        assert!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n+}\n+\n+#[test]\n+fn test_simple_io_no_connect() {\n+    do run_in_newsched_task {\n+        unsafe {\n+            let io = Local::unsafe_borrow::<IoFactoryObject>();\n+            let addr = next_test_ip4();\n+            let maybe_chan = (*io).tcp_connect(addr);\n+            assert!(maybe_chan.is_err());\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_simple_tcp_server_and_client() {\n+    do run_in_newsched_task {\n+        let addr = next_test_ip4();\n+\n+        // Start the server first so it's listening when we connect\n+        do spawntask_immediately {\n+            unsafe {\n+                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let mut listener = (*io).tcp_bind(addr).unwrap();\n+                let mut stream = listener.accept().unwrap();\n+                let mut buf = [0, .. 2048];\n+                let nread = stream.read(buf).unwrap();\n+                assert_eq!(nread, 8);\n+                for uint::range(0, nread) |i| {\n+                    rtdebug!(\"%u\", buf[i] as uint);\n+                    assert_eq!(buf[i], i as u8);\n+                }\n+            }\n+        }\n+\n+        do spawntask_immediately {\n+            unsafe {\n+                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let mut stream = (*io).tcp_connect(addr).unwrap();\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            }\n+        }\n+    }\n+}\n+\n+#[test] #[ignore(reason = \"busted\")]\n+fn test_read_and_block() {\n+    do run_in_newsched_task {\n+        let addr = next_test_ip4();\n+\n+        do spawntask_immediately {\n+            let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n+            let mut listener = unsafe { (*io).tcp_bind(addr).unwrap() };\n+            let mut stream = listener.accept().unwrap();\n+            let mut buf = [0, .. 2048];\n+\n+            let expected = 32;\n+            let mut current = 0;\n+            let mut reads = 0;\n+\n+            while current < expected {\n+                let nread = stream.read(buf).unwrap();\n+                for uint::range(0, nread) |i| {\n+                    let val = buf[i] as uint;\n+                    assert_eq!(val, current % 8);\n+                    current += 1;\n+                }\n+                reads += 1;\n+\n+                let scheduler = Local::take::<Scheduler>();\n+                // Yield to the other task in hopes that it\n+                // will trigger a read callback while we are\n+                // not ready for it\n+                do scheduler.deschedule_running_task_and_then |task| {\n+                    let task = Cell(task);\n+                    do Local::borrow::<Scheduler> |scheduler| {\n+                        scheduler.enqueue_task(task.take());\n+                    }\n+                }\n+            }\n+\n+            // Make sure we had multiple reads\n+            assert!(reads > 1);\n+        }\n+\n+        do spawntask_immediately {\n+            unsafe {\n+                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let mut stream = (*io).tcp_connect(addr).unwrap();\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            }\n+        }\n+\n+    }\n+}\n+\n+#[test]\n+fn test_read_read_read() {\n+    do run_in_newsched_task {\n+        let addr = next_test_ip4();\n+        static MAX: uint = 500000;\n+\n+        do spawntask_immediately {\n+            unsafe {\n+                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let mut listener = (*io).tcp_bind(addr).unwrap();\n+                let mut stream = listener.accept().unwrap();\n+                let buf = [1, .. 2048];\n+                let mut total_bytes_written = 0;\n+                while total_bytes_written < MAX {\n+                    stream.write(buf);\n+                    total_bytes_written += buf.len();\n+                }\n+            }\n+        }\n+\n+        do spawntask_immediately {\n+            unsafe {\n+                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let mut stream = (*io).tcp_connect(addr).unwrap();\n+                let mut buf = [0, .. 2048];\n+                let mut total_bytes_read = 0;\n+                while total_bytes_read < MAX {\n+                    let nread = stream.read(buf).unwrap();\n+                    rtdebug!(\"read %u bytes\", nread as uint);\n+                    total_bytes_read += nread;\n+                    for uint::range(0, nread) |i| {\n+                        assert_eq!(buf[i], 1);\n+                    }\n+                }\n+                rtdebug!(\"read %u bytes total\", total_bytes_read as uint);\n+            }\n+        }\n+    }\n+}"}, {"sha": "ddc9040d730915da8e2b8e58910355e65da5e5d9", "filename": "src/libstd/rt/uv/uvll.rs", "status": "added", "additions": 452, "deletions": 0, "changes": 452, "blob_url": "https://github.com/rust-lang/rust/blob/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=18df18c817b5e109710c58f512a2cc5ad14fa8b2", "patch": "@@ -0,0 +1,452 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Low-level bindings to the libuv library.\n+ *\n+ * This module contains a set of direct, 'bare-metal' wrappers around\n+ * the libuv C-API.\n+ *\n+ * We're not bothering yet to redefine uv's structs as Rust structs\n+ * because they are quite large and change often between versions.\n+ * The maintenance burden is just too high. Instead we use the uv's\n+ * `uv_handle_size` and `uv_req_size` to find the correct size of the\n+ * structs and allocate them on the heap. This can be revisited later.\n+ *\n+ * There are also a collection of helper functions to ease interacting\n+ * with the low-level API.\n+ *\n+ * As new functionality, existant in uv.h, is added to the rust stdlib,\n+ * the mappings should be added in this module.\n+ */\n+\n+#[allow(non_camel_case_types)]; // C types\n+\n+use libc::{size_t, c_int, c_uint, c_void, c_char, uintptr_t};\n+use libc::{malloc, free};\n+use prelude::*;\n+\n+pub static UNKNOWN: c_int = -1;\n+pub static OK: c_int = 0;\n+pub static EOF: c_int = 1;\n+pub static EADDRINFO: c_int = 2;\n+pub static EACCES: c_int = 3;\n+pub static ECONNREFUSED: c_int = 12;\n+pub static ECONNRESET: c_int = 13;\n+pub static EPIPE: c_int = 36;\n+\n+pub struct uv_err_t {\n+    code: c_int,\n+    sys_errno_: c_int\n+}\n+\n+pub struct uv_buf_t {\n+    base: *u8,\n+    len: libc::size_t,\n+}\n+\n+pub type uv_handle_t = c_void;\n+pub type uv_loop_t = c_void;\n+pub type uv_idle_t = c_void;\n+pub type uv_tcp_t = c_void;\n+pub type uv_connect_t = c_void;\n+pub type uv_write_t = c_void;\n+pub type uv_async_t = c_void;\n+pub type uv_timer_t = c_void;\n+pub type uv_stream_t = c_void;\n+pub type uv_fs_t = c_void;\n+\n+pub type uv_idle_cb = *u8;\n+\n+pub type sockaddr_in = c_void;\n+pub type sockaddr_in6 = c_void;\n+\n+#[deriving(Eq)]\n+pub enum uv_handle_type {\n+    UV_UNKNOWN_HANDLE,\n+    UV_ASYNC,\n+    UV_CHECK,\n+    UV_FS_EVENT,\n+    UV_FS_POLL,\n+    UV_HANDLE,\n+    UV_IDLE,\n+    UV_NAMED_PIPE,\n+    UV_POLL,\n+    UV_PREPARE,\n+    UV_PROCESS,\n+    UV_STREAM,\n+    UV_TCP,\n+    UV_TIMER,\n+    UV_TTY,\n+    UV_UDP,\n+    UV_SIGNAL,\n+    UV_FILE,\n+    UV_HANDLE_TYPE_MAX\n+}\n+\n+#[deriving(Eq)]\n+pub enum uv_req_type {\n+    UV_UNKNOWN_REQ,\n+    UV_REQ,\n+    UV_CONNECT,\n+    UV_WRITE,\n+    UV_SHUTDOWN,\n+    UV_UDP_SEND,\n+    UV_FS,\n+    UV_WORK,\n+    UV_GETADDRINFO,\n+    UV_REQ_TYPE_MAX\n+}\n+\n+pub unsafe fn malloc_handle(handle: uv_handle_type) -> *c_void {\n+    assert!(handle != UV_UNKNOWN_HANDLE && handle != UV_HANDLE_TYPE_MAX);\n+    let size = rust_uv_handle_size(handle as uint);\n+    let p = malloc(size);\n+    assert!(p.is_not_null());\n+    return p;\n+}\n+\n+pub unsafe fn free_handle(v: *c_void) {\n+    free(v)\n+}\n+\n+pub unsafe fn malloc_req(req: uv_req_type) -> *c_void {\n+    assert!(req != UV_UNKNOWN_REQ && req != UV_REQ_TYPE_MAX);\n+    let size = rust_uv_req_size(req as uint);\n+    let p = malloc(size);\n+    assert!(p.is_not_null());\n+    return p;\n+}\n+\n+pub unsafe fn free_req(v: *c_void) {\n+    free(v)\n+}\n+\n+#[test]\n+fn handle_sanity_check() {\n+    unsafe {\n+        assert_eq!(UV_HANDLE_TYPE_MAX as uint, rust_uv_handle_type_max());\n+    }\n+}\n+\n+#[test]\n+fn request_sanity_check() {\n+    unsafe {\n+        assert_eq!(UV_REQ_TYPE_MAX as uint, rust_uv_req_type_max());\n+    }\n+}\n+\n+pub unsafe fn loop_new() -> *c_void {\n+    return rust_uv_loop_new();\n+}\n+\n+pub unsafe fn loop_delete(loop_handle: *c_void) {\n+    rust_uv_loop_delete(loop_handle);\n+}\n+\n+pub unsafe fn run(loop_handle: *c_void) {\n+    rust_uv_run(loop_handle);\n+}\n+\n+pub unsafe fn close<T>(handle: *T, cb: *u8) {\n+    rust_uv_close(handle as *c_void, cb);\n+}\n+\n+pub unsafe fn walk(loop_handle: *c_void, cb: *u8, arg: *c_void) {\n+    rust_uv_walk(loop_handle, cb, arg);\n+}\n+\n+pub unsafe fn idle_new() -> *uv_idle_t {\n+    rust_uv_idle_new()\n+}\n+\n+pub unsafe fn idle_delete(handle: *uv_idle_t) {\n+    rust_uv_idle_delete(handle)\n+}\n+\n+pub unsafe fn idle_init(loop_handle: *uv_loop_t, handle: *uv_idle_t) -> c_int {\n+    rust_uv_idle_init(loop_handle, handle)\n+}\n+\n+pub unsafe fn idle_start(handle: *uv_idle_t, cb: uv_idle_cb) -> c_int {\n+    rust_uv_idle_start(handle, cb)\n+}\n+\n+pub unsafe fn idle_stop(handle: *uv_idle_t) -> c_int {\n+    rust_uv_idle_stop(handle)\n+}\n+\n+pub unsafe fn tcp_init(loop_handle: *c_void, handle: *uv_tcp_t) -> c_int {\n+    return rust_uv_tcp_init(loop_handle, handle);\n+}\n+\n+// FIXME ref #2064\n+pub unsafe fn tcp_connect(connect_ptr: *uv_connect_t,\n+                          tcp_handle_ptr: *uv_tcp_t,\n+                          addr_ptr: *sockaddr_in,\n+                          after_connect_cb: *u8) -> c_int {\n+    return rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr,\n+                                       after_connect_cb, addr_ptr);\n+}\n+// FIXME ref #2064\n+pub unsafe fn tcp_connect6(connect_ptr: *uv_connect_t,\n+                           tcp_handle_ptr: *uv_tcp_t,\n+                           addr_ptr: *sockaddr_in6,\n+                           after_connect_cb: *u8) -> c_int {\n+    return rust_uv_tcp_connect6(connect_ptr, tcp_handle_ptr,\n+                                        after_connect_cb, addr_ptr);\n+}\n+// FIXME ref #2064\n+pub unsafe fn tcp_bind(tcp_server_ptr: *uv_tcp_t, addr_ptr: *sockaddr_in) -> c_int {\n+    return rust_uv_tcp_bind(tcp_server_ptr, addr_ptr);\n+}\n+// FIXME ref #2064\n+pub unsafe fn tcp_bind6(tcp_server_ptr: *uv_tcp_t, addr_ptr: *sockaddr_in6) -> c_int {\n+    return rust_uv_tcp_bind6(tcp_server_ptr, addr_ptr);\n+}\n+\n+pub unsafe fn tcp_getpeername(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_in) -> c_int {\n+    return rust_uv_tcp_getpeername(tcp_handle_ptr, name);\n+}\n+\n+pub unsafe fn tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_in6) ->c_int {\n+    return rust_uv_tcp_getpeername6(tcp_handle_ptr, name);\n+}\n+\n+pub unsafe fn listen<T>(stream: *T, backlog: c_int, cb: *u8) -> c_int {\n+    return rust_uv_listen(stream as *c_void, backlog, cb);\n+}\n+\n+pub unsafe fn accept(server: *c_void, client: *c_void) -> c_int {\n+    return rust_uv_accept(server as *c_void, client as *c_void);\n+}\n+\n+pub unsafe fn write<T>(req: *uv_write_t, stream: *T, buf_in: &[uv_buf_t], cb: *u8) -> c_int {\n+    let buf_ptr = vec::raw::to_ptr(buf_in);\n+    let buf_cnt = buf_in.len() as i32;\n+    return rust_uv_write(req as *c_void, stream as *c_void, buf_ptr, buf_cnt, cb);\n+}\n+pub unsafe fn read_start(stream: *uv_stream_t, on_alloc: *u8, on_read: *u8) -> c_int {\n+    return rust_uv_read_start(stream as *c_void, on_alloc, on_read);\n+}\n+\n+pub unsafe fn read_stop(stream: *uv_stream_t) -> c_int {\n+    return rust_uv_read_stop(stream as *c_void);\n+}\n+\n+pub unsafe fn last_error(loop_handle: *c_void) -> uv_err_t {\n+    return rust_uv_last_error(loop_handle);\n+}\n+\n+pub unsafe fn strerror(err: *uv_err_t) -> *c_char {\n+    return rust_uv_strerror(err);\n+}\n+pub unsafe fn err_name(err: *uv_err_t) -> *c_char {\n+    return rust_uv_err_name(err);\n+}\n+\n+pub unsafe fn async_init(loop_handle: *c_void, async_handle: *uv_async_t, cb: *u8) -> c_int {\n+    return rust_uv_async_init(loop_handle, async_handle, cb);\n+}\n+\n+pub unsafe fn async_send(async_handle: *uv_async_t) {\n+    return rust_uv_async_send(async_handle);\n+}\n+pub unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n+    let out_buf = uv_buf_t { base: ptr::null(), len: 0 as size_t };\n+    let out_buf_ptr = ptr::to_unsafe_ptr(&out_buf);\n+    rust_uv_buf_init(out_buf_ptr, input, len as size_t);\n+    return out_buf;\n+}\n+\n+pub unsafe fn timer_init(loop_ptr: *c_void, timer_ptr: *uv_timer_t) -> c_int {\n+    return rust_uv_timer_init(loop_ptr, timer_ptr);\n+}\n+pub unsafe fn timer_start(timer_ptr: *uv_timer_t, cb: *u8, timeout: u64,\n+                          repeat: u64) -> c_int {\n+    return rust_uv_timer_start(timer_ptr, cb, timeout, repeat);\n+}\n+pub unsafe fn timer_stop(timer_ptr: *uv_timer_t) -> c_int {\n+    return rust_uv_timer_stop(timer_ptr);\n+}\n+\n+pub unsafe fn malloc_ip4_addr(ip: &str, port: int) -> *sockaddr_in {\n+    do str::as_c_str(ip) |ip_buf| {\n+        rust_uv_ip4_addrp(ip_buf as *u8, port as libc::c_int)\n+    }\n+}\n+pub unsafe fn malloc_ip6_addr(ip: &str, port: int) -> *sockaddr_in6 {\n+    do str::as_c_str(ip) |ip_buf| {\n+        rust_uv_ip6_addrp(ip_buf as *u8, port as libc::c_int)\n+    }\n+}\n+\n+pub unsafe fn free_ip4_addr(addr: *sockaddr_in) {\n+    rust_uv_free_ip4_addr(addr);\n+}\n+\n+pub unsafe fn free_ip6_addr(addr: *sockaddr_in6) {\n+    rust_uv_free_ip6_addr(addr);\n+}\n+\n+// data access helpers\n+pub unsafe fn get_loop_for_uv_handle<T>(handle: *T) -> *c_void {\n+    return rust_uv_get_loop_for_uv_handle(handle as *c_void);\n+}\n+pub unsafe fn get_stream_handle_from_connect_req(connect: *uv_connect_t) -> *uv_stream_t {\n+    return rust_uv_get_stream_handle_from_connect_req(connect);\n+}\n+pub unsafe fn get_stream_handle_from_write_req(write_req: *uv_write_t) -> *uv_stream_t {\n+    return rust_uv_get_stream_handle_from_write_req(write_req);\n+}\n+pub unsafe fn get_data_for_uv_loop(loop_ptr: *c_void) -> *c_void {\n+    rust_uv_get_data_for_uv_loop(loop_ptr)\n+}\n+pub unsafe fn set_data_for_uv_loop(loop_ptr: *c_void, data: *c_void) {\n+    rust_uv_set_data_for_uv_loop(loop_ptr, data);\n+}\n+pub unsafe fn get_data_for_uv_handle<T>(handle: *T) -> *c_void {\n+    return rust_uv_get_data_for_uv_handle(handle as *c_void);\n+}\n+pub unsafe fn set_data_for_uv_handle<T, U>(handle: *T, data: *U) {\n+    rust_uv_set_data_for_uv_handle(handle as *c_void, data as *c_void);\n+}\n+pub unsafe fn get_data_for_req<T>(req: *T) -> *c_void {\n+    return rust_uv_get_data_for_req(req as *c_void);\n+}\n+pub unsafe fn set_data_for_req<T, U>(req: *T, data: *U) {\n+    rust_uv_set_data_for_req(req as *c_void, data as *c_void);\n+}\n+pub unsafe fn get_base_from_buf(buf: uv_buf_t) -> *u8 {\n+    return rust_uv_get_base_from_buf(buf);\n+}\n+pub unsafe fn get_len_from_buf(buf: uv_buf_t) -> size_t {\n+    return rust_uv_get_len_from_buf(buf);\n+}\n+pub unsafe fn malloc_buf_base_of(suggested_size: size_t) -> *u8 {\n+    return rust_uv_malloc_buf_base_of(suggested_size);\n+}\n+pub unsafe fn free_base_of_buf(buf: uv_buf_t) {\n+    rust_uv_free_base_of_buf(buf);\n+}\n+\n+pub unsafe fn get_last_err_info(uv_loop: *c_void) -> ~str {\n+    let err = last_error(uv_loop);\n+    let err_ptr = ptr::to_unsafe_ptr(&err);\n+    let err_name = str::raw::from_c_str(err_name(err_ptr));\n+    let err_msg = str::raw::from_c_str(strerror(err_ptr));\n+    return fmt!(\"LIBUV ERROR: name: %s msg: %s\",\n+                    err_name, err_msg);\n+}\n+\n+pub unsafe fn get_last_err_data(uv_loop: *c_void) -> uv_err_data {\n+    let err = last_error(uv_loop);\n+    let err_ptr = ptr::to_unsafe_ptr(&err);\n+    let err_name = str::raw::from_c_str(err_name(err_ptr));\n+    let err_msg = str::raw::from_c_str(strerror(err_ptr));\n+    uv_err_data { err_name: err_name, err_msg: err_msg }\n+}\n+\n+pub struct uv_err_data {\n+    err_name: ~str,\n+    err_msg: ~str,\n+}\n+\n+extern {\n+\n+    fn rust_uv_handle_size(type_: uintptr_t) -> size_t;\n+    fn rust_uv_req_size(type_: uintptr_t) -> size_t;\n+    fn rust_uv_handle_type_max() -> uintptr_t;\n+    fn rust_uv_req_type_max() -> uintptr_t;\n+\n+    // libuv public API\n+    fn rust_uv_loop_new() -> *c_void;\n+    fn rust_uv_loop_delete(lp: *c_void);\n+    fn rust_uv_run(loop_handle: *c_void);\n+    fn rust_uv_close(handle: *c_void, cb: *u8);\n+    fn rust_uv_walk(loop_handle: *c_void, cb: *u8, arg: *c_void);\n+\n+    fn rust_uv_idle_new() -> *uv_idle_t;\n+    fn rust_uv_idle_delete(handle: *uv_idle_t);\n+    fn rust_uv_idle_init(loop_handle: *uv_loop_t, handle: *uv_idle_t) -> c_int;\n+    fn rust_uv_idle_start(handle: *uv_idle_t, cb: uv_idle_cb) -> c_int;\n+    fn rust_uv_idle_stop(handle: *uv_idle_t) -> c_int;\n+\n+    fn rust_uv_async_send(handle: *uv_async_t);\n+    fn rust_uv_async_init(loop_handle: *c_void,\n+                          async_handle: *uv_async_t,\n+                          cb: *u8) -> c_int;\n+    fn rust_uv_tcp_init(loop_handle: *c_void, handle_ptr: *uv_tcp_t) -> c_int;\n+    // FIXME ref #2604 .. ?\n+    fn rust_uv_buf_init(out_buf: *uv_buf_t, base: *u8, len: size_t);\n+    fn rust_uv_last_error(loop_handle: *c_void) -> uv_err_t;\n+    // FIXME ref #2064\n+    fn rust_uv_strerror(err: *uv_err_t) -> *c_char;\n+    // FIXME ref #2064\n+    fn rust_uv_err_name(err: *uv_err_t) -> *c_char;\n+    fn rust_uv_ip4_addrp(ip: *u8, port: c_int) -> *sockaddr_in;\n+    fn rust_uv_ip6_addrp(ip: *u8, port: c_int) -> *sockaddr_in6;\n+    fn rust_uv_free_ip4_addr(addr: *sockaddr_in);\n+    fn rust_uv_free_ip6_addr(addr: *sockaddr_in6);\n+    fn rust_uv_ip4_name(src: *sockaddr_in, dst: *u8, size: size_t) -> c_int;\n+    fn rust_uv_ip6_name(src: *sockaddr_in6, dst: *u8, size: size_t) -> c_int;\n+    fn rust_uv_ip4_port(src: *sockaddr_in) -> c_uint;\n+    fn rust_uv_ip6_port(src: *sockaddr_in6) -> c_uint;\n+    // FIXME ref #2064\n+    fn rust_uv_tcp_connect(connect_ptr: *uv_connect_t,\n+                           tcp_handle_ptr: *uv_tcp_t,\n+                           after_cb: *u8,\n+                           addr: *sockaddr_in) -> c_int;\n+    // FIXME ref #2064\n+    fn rust_uv_tcp_bind(tcp_server: *uv_tcp_t, addr: *sockaddr_in) -> c_int;\n+    // FIXME ref #2064\n+    fn rust_uv_tcp_connect6(connect_ptr: *uv_connect_t,\n+                            tcp_handle_ptr: *uv_tcp_t,\n+                            after_cb: *u8,\n+                            addr: *sockaddr_in6) -> c_int;\n+    // FIXME ref #2064\n+    fn rust_uv_tcp_bind6(tcp_server: *uv_tcp_t, addr: *sockaddr_in6) -> c_int;\n+    fn rust_uv_tcp_getpeername(tcp_handle_ptr: *uv_tcp_t,\n+                               name: *sockaddr_in) -> c_int;\n+    fn rust_uv_tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t,\n+                                name: *sockaddr_in6) ->c_int;\n+    fn rust_uv_listen(stream: *c_void, backlog: c_int, cb: *u8) -> c_int;\n+    fn rust_uv_accept(server: *c_void, client: *c_void) -> c_int;\n+    fn rust_uv_write(req: *c_void,\n+                     stream: *c_void,\n+                     buf_in: *uv_buf_t,\n+                     buf_cnt: c_int,\n+                     cb: *u8) -> c_int;\n+    fn rust_uv_read_start(stream: *c_void,\n+                          on_alloc: *u8,\n+                          on_read: *u8) -> c_int;\n+    fn rust_uv_read_stop(stream: *c_void) -> c_int;\n+    fn rust_uv_timer_init(loop_handle: *c_void,\n+                          timer_handle: *uv_timer_t) -> c_int;\n+    fn rust_uv_timer_start(timer_handle: *uv_timer_t,\n+                           cb: *u8,\n+                           timeout: libc::uint64_t,\n+                           repeat: libc::uint64_t) -> c_int;\n+    fn rust_uv_timer_stop(handle: *uv_timer_t) -> c_int;\n+\n+    fn rust_uv_malloc_buf_base_of(sug_size: size_t) -> *u8;\n+    fn rust_uv_free_base_of_buf(buf: uv_buf_t);\n+    fn rust_uv_get_stream_handle_from_connect_req(connect_req: *uv_connect_t) -> *uv_stream_t;\n+    fn rust_uv_get_stream_handle_from_write_req(write_req: *uv_write_t) -> *uv_stream_t;\n+    fn rust_uv_get_loop_for_uv_handle(handle: *c_void) -> *c_void;\n+    fn rust_uv_get_data_for_uv_loop(loop_ptr: *c_void) -> *c_void;\n+    fn rust_uv_set_data_for_uv_loop(loop_ptr: *c_void, data: *c_void);\n+    fn rust_uv_get_data_for_uv_handle(handle: *c_void) -> *c_void;\n+    fn rust_uv_set_data_for_uv_handle(handle: *c_void, data: *c_void);\n+    fn rust_uv_get_data_for_req(req: *c_void) -> *c_void;\n+    fn rust_uv_set_data_for_req(req: *c_void, data: *c_void);\n+    fn rust_uv_get_base_from_buf(buf: uv_buf_t) -> *u8;\n+    fn rust_uv_get_len_from_buf(buf: uv_buf_t) -> size_t;\n+}"}, {"sha": "791f7444b6226be53aba01284500e451ae3fd7c6", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18df18c817b5e109710c58f512a2cc5ad14fa8b2/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=18df18c817b5e109710c58f512a2cc5ad14fa8b2", "patch": "@@ -16,6 +16,8 @@\n  * other useful things like `push()` and `len()`.\n  */\n \n+use core::prelude::*;\n+\n use core::old_iter;\n use core::old_iter::BaseIter;\n "}]}