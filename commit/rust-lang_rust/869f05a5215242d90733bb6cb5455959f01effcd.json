{"sha": "869f05a5215242d90733bb6cb5455959f01effcd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2OWYwNWE1MjE1MjQyZDkwNzMzYmI2Y2I1NDU1OTU5ZjAxZWZmY2Q=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-07-04T13:57:55Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-08-16T13:53:27Z"}, "message": "Factored `MoveData` construction code into `builder` submodule.", "tree": {"sha": "a554d56e10975e72dd10f77fa229544d73bcde0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a554d56e10975e72dd10f77fa229544d73bcde0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/869f05a5215242d90733bb6cb5455959f01effcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/869f05a5215242d90733bb6cb5455959f01effcd", "html_url": "https://github.com/rust-lang/rust/commit/869f05a5215242d90733bb6cb5455959f01effcd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/869f05a5215242d90733bb6cb5455959f01effcd/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b8b8c6aebcc581bf2e74d9a0d3bf65a0ebb2742", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b8b8c6aebcc581bf2e74d9a0d3bf65a0ebb2742", "html_url": "https://github.com/rust-lang/rust/commit/9b8b8c6aebcc581bf2e74d9a0d3bf65a0ebb2742"}], "stats": {"total": 647, "additions": 334, "deletions": 313}, "files": [{"sha": "c45c91011d9f4028f6fb4967d5828b28af594ca8", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "added", "additions": 332, "deletions": 0, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/869f05a5215242d90733bb6cb5455959f01effcd/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869f05a5215242d90733bb6cb5455959f01effcd/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=869f05a5215242d90733bb6cb5455959f01effcd", "patch": "@@ -0,0 +1,332 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::ty::{self, TyCtxt};\n+use rustc::mir::*;\n+use rustc::mir::tcx::RvalueInitializationState;\n+use rustc::util::nodemap::FxHashMap;\n+use rustc_data_structures::indexed_vec::{IndexVec};\n+\n+use syntax::codemap::DUMMY_SP;\n+\n+use std::collections::hash_map::Entry;\n+use std::mem;\n+\n+use super::abs_domain::Lift;\n+\n+use super::{LocationMap, MoveData, MovePath, MovePathLookup, MovePathIndex, MoveOut, MoveOutIndex};\n+\n+pub(super) struct MoveDataBuilder<'a, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    data: MoveData<'tcx>,\n+}\n+\n+pub enum MovePathError {\n+    IllegalMove,\n+    UnionMove { path: MovePathIndex },\n+}\n+\n+impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n+    fn new(mir: &'a Mir<'tcx>,\n+           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+           param_env: ty::ParamEnv<'tcx>)\n+           -> Self {\n+        let mut move_paths = IndexVec::new();\n+        let mut path_map = IndexVec::new();\n+\n+        MoveDataBuilder {\n+            mir,\n+            tcx,\n+            param_env,\n+            data: MoveData {\n+                moves: IndexVec::new(),\n+                loc_map: LocationMap::new(mir),\n+                rev_lookup: MovePathLookup {\n+                    locals: mir.local_decls.indices().map(Lvalue::Local).map(|v| {\n+                        Self::new_move_path(&mut move_paths, &mut path_map, None, v)\n+                    }).collect(),\n+                    projections: FxHashMap(),\n+                },\n+                move_paths,\n+                path_map,\n+            }\n+        }\n+    }\n+\n+    fn new_move_path(move_paths: &mut IndexVec<MovePathIndex, MovePath<'tcx>>,\n+                     path_map: &mut IndexVec<MovePathIndex, Vec<MoveOutIndex>>,\n+                     parent: Option<MovePathIndex>,\n+                     lvalue: Lvalue<'tcx>)\n+                     -> MovePathIndex\n+    {\n+        let move_path = move_paths.push(MovePath {\n+            next_sibling: None,\n+            first_child: None,\n+            parent,\n+            lvalue,\n+        });\n+\n+        if let Some(parent) = parent {\n+            let next_sibling =\n+                mem::replace(&mut move_paths[parent].first_child, Some(move_path));\n+            move_paths[move_path].next_sibling = next_sibling;\n+        }\n+\n+        let path_map_ent = path_map.push(vec![]);\n+        assert_eq!(path_map_ent, move_path);\n+        move_path\n+    }\n+\n+    /// This creates a MovePath for a given lvalue, returning an `MovePathError`\n+    /// if that lvalue can't be moved from.\n+    ///\n+    /// NOTE: lvalues behind references *do not* get a move path, which is\n+    /// problematic for borrowck.\n+    ///\n+    /// Maybe we should have separate \"borrowck\" and \"moveck\" modes.\n+    fn move_path_for(&mut self, lval: &Lvalue<'tcx>)\n+                     -> Result<MovePathIndex, MovePathError>\n+    {\n+        debug!(\"lookup({:?})\", lval);\n+        match *lval {\n+            Lvalue::Local(local) => Ok(self.data.rev_lookup.locals[local]),\n+            // error: can't move out of a static\n+            Lvalue::Static(..) => Err(MovePathError::IllegalMove),\n+            Lvalue::Projection(ref proj) => {\n+                self.move_path_for_projection(lval, proj)\n+            }\n+        }\n+    }\n+\n+    fn create_move_path(&mut self, lval: &Lvalue<'tcx>) {\n+        // This is an assignment, not a move, so this not being a valid\n+        // move path is OK.\n+        let _ = self.move_path_for(lval);\n+    }\n+\n+    fn move_path_for_projection(&mut self,\n+                                lval: &Lvalue<'tcx>,\n+                                proj: &LvalueProjection<'tcx>)\n+                                -> Result<MovePathIndex, MovePathError>\n+    {\n+        let base = try!(self.move_path_for(&proj.base));\n+        let lv_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+        match lv_ty.sty {\n+            // error: can't move out of borrowed content\n+            ty::TyRef(..) | ty::TyRawPtr(..) => return Err(MovePathError::IllegalMove),\n+            // error: can't move out of struct with destructor\n+            ty::TyAdt(adt, _) if adt.has_dtor(self.tcx) && !adt.is_box() =>\n+                return Err(MovePathError::IllegalMove),\n+            // move out of union - always move the entire union\n+            ty::TyAdt(adt, _) if adt.is_union() =>\n+                return Err(MovePathError::UnionMove { path: base }),\n+            // error: can't move out of a slice\n+            ty::TySlice(..) =>\n+                return Err(MovePathError::IllegalMove),\n+            ty::TyArray(..) => match proj.elem {\n+                // error: can't move out of an array\n+                ProjectionElem::Index(..) => return Err(MovePathError::IllegalMove),\n+                _ => {\n+                    // FIXME: still badly broken\n+                }\n+            },\n+            _ => {}\n+        };\n+        match self.data.rev_lookup.projections.entry((base, proj.elem.lift())) {\n+            Entry::Occupied(ent) => Ok(*ent.get()),\n+            Entry::Vacant(ent) => {\n+                let path = Self::new_move_path(\n+                    &mut self.data.move_paths,\n+                    &mut self.data.path_map,\n+                    Some(base),\n+                    lval.clone()\n+                );\n+                ent.insert(path);\n+                Ok(path)\n+            }\n+        }\n+    }\n+\n+    fn finalize(self) -> MoveData<'tcx> {\n+        debug!(\"{}\", {\n+            debug!(\"moves for {:?}:\", self.mir.span);\n+            for (j, mo) in self.data.moves.iter_enumerated() {\n+                debug!(\"    {:?} = {:?}\", j, mo);\n+            }\n+            debug!(\"move paths for {:?}:\", self.mir.span);\n+            for (j, path) in self.data.move_paths.iter_enumerated() {\n+                debug!(\"    {:?} = {:?}\", j, path);\n+            }\n+            \"done dumping moves\"\n+        });\n+        self.data\n+    }\n+}\n+\n+pub(super) fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>,\n+                                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     param_env: ty::ParamEnv<'tcx>)\n+                                     -> MoveData<'tcx> {\n+    let mut builder = MoveDataBuilder::new(mir, tcx, param_env);\n+\n+    for (bb, block) in mir.basic_blocks().iter_enumerated() {\n+        for (i, stmt) in block.statements.iter().enumerate() {\n+            let source = Location { block: bb, statement_index: i };\n+            builder.gather_statement(source, stmt);\n+        }\n+\n+        let terminator_loc = Location {\n+            block: bb,\n+            statement_index: block.statements.len()\n+        };\n+        builder.gather_terminator(terminator_loc, block.terminator());\n+    }\n+\n+    builder.finalize()\n+}\n+\n+impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n+    fn gather_statement(&mut self, loc: Location, stmt: &Statement<'tcx>) {\n+        debug!(\"gather_statement({:?}, {:?})\", loc, stmt);\n+        match stmt.kind {\n+            StatementKind::Assign(ref lval, ref rval) => {\n+                self.create_move_path(lval);\n+                if let RvalueInitializationState::Shallow = rval.initialization_state() {\n+                    // Box starts out uninitialized - need to create a separate\n+                    // move-path for the interior so it will be separate from\n+                    // the exterior.\n+                    self.create_move_path(&lval.clone().deref());\n+                }\n+                self.gather_rvalue(loc, rval);\n+            }\n+            StatementKind::StorageLive(_) |\n+            StatementKind::StorageDead(_) => {}\n+            StatementKind::SetDiscriminant{ .. } => {\n+                span_bug!(stmt.source_info.span,\n+                          \"SetDiscriminant should not exist during borrowck\");\n+            }\n+            StatementKind::InlineAsm { .. } |\n+            StatementKind::EndRegion(_) |\n+            StatementKind::Validate(..) |\n+            StatementKind::Nop => {}\n+        }\n+    }\n+\n+    fn gather_rvalue(&mut self, loc: Location, rvalue: &Rvalue<'tcx>) {\n+        match *rvalue {\n+            Rvalue::Use(ref operand) |\n+            Rvalue::Repeat(ref operand, _) |\n+            Rvalue::Cast(_, ref operand, _) |\n+            Rvalue::UnaryOp(_, ref operand) => {\n+                self.gather_operand(loc, operand)\n+            }\n+            Rvalue::BinaryOp(ref _binop, ref lhs, ref rhs) |\n+            Rvalue::CheckedBinaryOp(ref _binop, ref lhs, ref rhs) => {\n+                self.gather_operand(loc, lhs);\n+                self.gather_operand(loc, rhs);\n+            }\n+            Rvalue::Aggregate(ref _kind, ref operands) => {\n+                for operand in operands {\n+                    self.gather_operand(loc, operand);\n+                }\n+            }\n+            Rvalue::Ref(..) |\n+            Rvalue::Discriminant(..) |\n+            Rvalue::Len(..) |\n+            Rvalue::NullaryOp(NullOp::SizeOf, _) |\n+            Rvalue::NullaryOp(NullOp::Box, _) => {\n+                // This returns an rvalue with uninitialized contents. We can't\n+                // move out of it here because it is an rvalue - assignments always\n+                // completely initialize their lvalue.\n+                //\n+                // However, this does not matter - MIR building is careful to\n+                // only emit a shallow free for the partially-initialized\n+                // temporary.\n+                //\n+                // In any case, if we want to fix this, we have to register a\n+                // special move and change the `statement_effect` functions.\n+            }\n+        }\n+    }\n+\n+    fn gather_terminator(&mut self, loc: Location, term: &Terminator<'tcx>) {\n+        debug!(\"gather_terminator({:?}, {:?})\", loc, term);\n+        match term.kind {\n+            TerminatorKind::Goto { target: _ } |\n+            TerminatorKind::Resume |\n+            TerminatorKind::Unreachable => { }\n+\n+            TerminatorKind::Return => {\n+                self.gather_move(loc, &Lvalue::Local(RETURN_POINTER));\n+            }\n+\n+            TerminatorKind::Assert { .. } |\n+            TerminatorKind::SwitchInt { .. } => {\n+                // branching terminators - these don't move anything\n+            }\n+\n+            TerminatorKind::Drop { ref location, target: _, unwind: _ } => {\n+                self.gather_move(loc, location);\n+            }\n+            TerminatorKind::DropAndReplace { ref location, ref value, .. } => {\n+                self.create_move_path(location);\n+                self.gather_operand(loc, value);\n+            }\n+            TerminatorKind::Call { ref func, ref args, ref destination, cleanup: _ } => {\n+                self.gather_operand(loc, func);\n+                for arg in args {\n+                    self.gather_operand(loc, arg);\n+                }\n+                if let Some((ref destination, _bb)) = *destination {\n+                    self.create_move_path(destination);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn gather_operand(&mut self, loc: Location, operand: &Operand<'tcx>) {\n+        match *operand {\n+            Operand::Constant(..) => {} // not-a-move\n+            Operand::Consume(ref lval) => { // a move\n+                self.gather_move(loc, lval);\n+            }\n+        }\n+    }\n+\n+    fn gather_move(&mut self, loc: Location, lval: &Lvalue<'tcx>) {\n+        debug!(\"gather_move({:?}, {:?})\", loc, lval);\n+\n+        let lv_ty = lval.ty(self.mir, self.tcx).to_ty(self.tcx);\n+        if !lv_ty.moves_by_default(self.tcx, self.param_env, DUMMY_SP) {\n+            debug!(\"gather_move({:?}, {:?}) - {:?} is Copy. skipping\", loc, lval, lv_ty);\n+            return\n+        }\n+\n+        let path = match self.move_path_for(lval) {\n+            Ok(path) | Err(MovePathError::UnionMove { path }) => path,\n+            Err(MovePathError::IllegalMove) => {\n+                // Moving out of a bad path. Eventually, this should be a MIR\n+                // borrowck error instead of a bug.\n+                span_bug!(self.mir.span,\n+                          \"Broken MIR: moving out of lvalue {:?}: {:?} at {:?}\",\n+                          lval, lv_ty, loc);\n+            }\n+        };\n+        let move_out = self.data.moves.push(MoveOut { path: path, source: loc });\n+\n+        debug!(\"gather_move({:?}, {:?}): adding move {:?} of {:?}\",\n+               loc, lval, move_out, path);\n+\n+        self.data.path_map[path].push(move_out);\n+        self.data.loc_map[loc].push(move_out);\n+    }\n+}"}, {"sha": "c7f8b3491342e7b102184bdfe27994c3ef092786", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 2, "deletions": 313, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/869f05a5215242d90733bb6cb5455959f01effcd/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869f05a5215242d90733bb6cb5455959f01effcd/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=869f05a5215242d90733bb6cb5455959f01effcd", "patch": "@@ -11,15 +11,10 @@\n \n use rustc::ty::{self, TyCtxt};\n use rustc::mir::*;\n-use rustc::mir::tcx::RvalueInitializationState;\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_vec::{IndexVec};\n \n-use syntax::codemap::DUMMY_SP;\n-\n-use std::collections::hash_map::Entry;\n use std::fmt;\n-use std::mem;\n use std::ops::{Index, IndexMut};\n \n use self::abs_domain::{AbstractElem, Lift};\n@@ -194,154 +189,7 @@ pub struct MovePathLookup<'tcx> {\n     projections: FxHashMap<(MovePathIndex, AbstractElem<'tcx>), MovePathIndex>\n }\n \n-pub(super) struct MoveDataBuilder<'a, 'tcx: 'a> {\n-    mir: &'a Mir<'tcx>,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    data: MoveData<'tcx>,\n-}\n-\n-pub enum MovePathError {\n-    IllegalMove,\n-    UnionMove { path: MovePathIndex },\n-}\n-\n-impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n-    fn new(mir: &'a Mir<'tcx>,\n-           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-           param_env: ty::ParamEnv<'tcx>)\n-           -> Self {\n-        let mut move_paths = IndexVec::new();\n-        let mut path_map = IndexVec::new();\n-\n-        MoveDataBuilder {\n-            mir,\n-            tcx,\n-            param_env,\n-            data: MoveData {\n-                moves: IndexVec::new(),\n-                loc_map: LocationMap::new(mir),\n-                rev_lookup: MovePathLookup {\n-                    locals: mir.local_decls.indices().map(Lvalue::Local).map(|v| {\n-                        Self::new_move_path(&mut move_paths, &mut path_map, None, v)\n-                    }).collect(),\n-                    projections: FxHashMap(),\n-                },\n-                move_paths,\n-                path_map,\n-            }\n-        }\n-    }\n-\n-    fn new_move_path(move_paths: &mut IndexVec<MovePathIndex, MovePath<'tcx>>,\n-                     path_map: &mut IndexVec<MovePathIndex, Vec<MoveOutIndex>>,\n-                     parent: Option<MovePathIndex>,\n-                     lvalue: Lvalue<'tcx>)\n-                     -> MovePathIndex\n-    {\n-        let move_path = move_paths.push(MovePath {\n-            next_sibling: None,\n-            first_child: None,\n-            parent,\n-            lvalue,\n-        });\n-\n-        if let Some(parent) = parent {\n-            let next_sibling =\n-                mem::replace(&mut move_paths[parent].first_child, Some(move_path));\n-            move_paths[move_path].next_sibling = next_sibling;\n-        }\n-\n-        let path_map_ent = path_map.push(vec![]);\n-        assert_eq!(path_map_ent, move_path);\n-        move_path\n-    }\n-\n-    /// This creates a MovePath for a given lvalue, returning an `MovePathError`\n-    /// if that lvalue can't be moved from.\n-    ///\n-    /// NOTE: lvalues behind references *do not* get a move path, which is\n-    /// problematic for borrowck.\n-    ///\n-    /// Maybe we should have separate \"borrowck\" and \"moveck\" modes.\n-    fn move_path_for(&mut self, lval: &Lvalue<'tcx>)\n-                     -> Result<MovePathIndex, MovePathError>\n-    {\n-        debug!(\"lookup({:?})\", lval);\n-        match *lval {\n-            Lvalue::Local(local) => Ok(self.data.rev_lookup.locals[local]),\n-            // error: can't move out of a static\n-            Lvalue::Static(..) => Err(MovePathError::IllegalMove),\n-            Lvalue::Projection(ref proj) => {\n-                self.move_path_for_projection(lval, proj)\n-            }\n-        }\n-    }\n-\n-    fn create_move_path(&mut self, lval: &Lvalue<'tcx>) {\n-        // This is an assignment, not a move, so this not being a valid\n-        // move path is OK.\n-        let _ = self.move_path_for(lval);\n-    }\n-\n-    fn move_path_for_projection(&mut self,\n-                                lval: &Lvalue<'tcx>,\n-                                proj: &LvalueProjection<'tcx>)\n-                                -> Result<MovePathIndex, MovePathError>\n-    {\n-        let base = try!(self.move_path_for(&proj.base));\n-        let lv_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n-        match lv_ty.sty {\n-            // error: can't move out of borrowed content\n-            ty::TyRef(..) | ty::TyRawPtr(..) => return Err(MovePathError::IllegalMove),\n-            // error: can't move out of struct with destructor\n-            ty::TyAdt(adt, _) if adt.has_dtor(self.tcx) && !adt.is_box() =>\n-                return Err(MovePathError::IllegalMove),\n-            // move out of union - always move the entire union\n-            ty::TyAdt(adt, _) if adt.is_union() =>\n-                return Err(MovePathError::UnionMove { path: base }),\n-            // error: can't move out of a slice\n-            ty::TySlice(..) =>\n-                return Err(MovePathError::IllegalMove),\n-            ty::TyArray(..) => match proj.elem {\n-                // error: can't move out of an array\n-                ProjectionElem::Index(..) => return Err(MovePathError::IllegalMove),\n-                _ => {\n-                    // FIXME: still badly broken\n-                }\n-            },\n-            _ => {}\n-        };\n-        match self.data.rev_lookup.projections.entry((base, proj.elem.lift())) {\n-            Entry::Occupied(ent) => Ok(*ent.get()),\n-            Entry::Vacant(ent) => {\n-                let path = Self::new_move_path(\n-                    &mut self.data.move_paths,\n-                    &mut self.data.path_map,\n-                    Some(base),\n-                    lval.clone()\n-                );\n-                ent.insert(path);\n-                Ok(path)\n-            }\n-        }\n-    }\n-\n-    fn finalize(self) -> MoveData<'tcx> {\n-        debug!(\"{}\", {\n-            debug!(\"moves for {:?}:\", self.mir.span);\n-            for (j, mo) in self.data.moves.iter_enumerated() {\n-                debug!(\"    {:?} = {:?}\", j, mo);\n-            }\n-            debug!(\"move paths for {:?}:\", self.mir.span);\n-            for (j, path) in self.data.move_paths.iter_enumerated() {\n-                debug!(\"    {:?} = {:?}\", j, path);\n-            }\n-            \"done dumping moves\"\n-        });\n-        self.data\n-    }\n-}\n+mod builder;\n \n #[derive(Copy, Clone, Debug)]\n pub enum LookupResult {\n@@ -378,165 +226,6 @@ impl<'a, 'tcx> MoveData<'tcx> {\n                         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         param_env: ty::ParamEnv<'tcx>)\n                         -> Self {\n-        gather_moves(mir, tcx, param_env)\n-    }\n-}\n-\n-fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          param_env: ty::ParamEnv<'tcx>)\n-                          -> MoveData<'tcx> {\n-    let mut builder = MoveDataBuilder::new(mir, tcx, param_env);\n-\n-    for (bb, block) in mir.basic_blocks().iter_enumerated() {\n-        for (i, stmt) in block.statements.iter().enumerate() {\n-            let source = Location { block: bb, statement_index: i };\n-            builder.gather_statement(source, stmt);\n-        }\n-\n-        let terminator_loc = Location {\n-            block: bb,\n-            statement_index: block.statements.len()\n-        };\n-        builder.gather_terminator(terminator_loc, block.terminator());\n-    }\n-\n-    builder.finalize()\n-}\n-\n-impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n-    fn gather_statement(&mut self, loc: Location, stmt: &Statement<'tcx>) {\n-        debug!(\"gather_statement({:?}, {:?})\", loc, stmt);\n-        match stmt.kind {\n-            StatementKind::Assign(ref lval, ref rval) => {\n-                self.create_move_path(lval);\n-                if let RvalueInitializationState::Shallow = rval.initialization_state() {\n-                    // Box starts out uninitialized - need to create a separate\n-                    // move-path for the interior so it will be separate from\n-                    // the exterior.\n-                    self.create_move_path(&lval.clone().deref());\n-                }\n-                self.gather_rvalue(loc, rval);\n-            }\n-            StatementKind::StorageLive(_) |\n-            StatementKind::StorageDead(_) => {}\n-            StatementKind::SetDiscriminant{ .. } => {\n-                span_bug!(stmt.source_info.span,\n-                          \"SetDiscriminant should not exist during borrowck\");\n-            }\n-            StatementKind::InlineAsm { .. } |\n-            StatementKind::EndRegion(_) |\n-            StatementKind::Validate(..) |\n-            StatementKind::Nop => {}\n-        }\n-    }\n-\n-    fn gather_rvalue(&mut self, loc: Location, rvalue: &Rvalue<'tcx>) {\n-        match *rvalue {\n-            Rvalue::Use(ref operand) |\n-            Rvalue::Repeat(ref operand, _) |\n-            Rvalue::Cast(_, ref operand, _) |\n-            Rvalue::UnaryOp(_, ref operand) => {\n-                self.gather_operand(loc, operand)\n-            }\n-            Rvalue::BinaryOp(ref _binop, ref lhs, ref rhs) |\n-            Rvalue::CheckedBinaryOp(ref _binop, ref lhs, ref rhs) => {\n-                self.gather_operand(loc, lhs);\n-                self.gather_operand(loc, rhs);\n-            }\n-            Rvalue::Aggregate(ref _kind, ref operands) => {\n-                for operand in operands {\n-                    self.gather_operand(loc, operand);\n-                }\n-            }\n-            Rvalue::Ref(..) |\n-            Rvalue::Discriminant(..) |\n-            Rvalue::Len(..) |\n-            Rvalue::NullaryOp(NullOp::SizeOf, _) |\n-            Rvalue::NullaryOp(NullOp::Box, _) => {\n-                // This returns an rvalue with uninitialized contents. We can't\n-                // move out of it here because it is an rvalue - assignments always\n-                // completely initialize their lvalue.\n-                //\n-                // However, this does not matter - MIR building is careful to\n-                // only emit a shallow free for the partially-initialized\n-                // temporary.\n-                //\n-                // In any case, if we want to fix this, we have to register a\n-                // special move and change the `statement_effect` functions.\n-            }\n-        }\n-    }\n-\n-    fn gather_terminator(&mut self, loc: Location, term: &Terminator<'tcx>) {\n-        debug!(\"gather_terminator({:?}, {:?})\", loc, term);\n-        match term.kind {\n-            TerminatorKind::Goto { target: _ } |\n-            TerminatorKind::Resume |\n-            TerminatorKind::Unreachable => { }\n-\n-            TerminatorKind::Return => {\n-                self.gather_move(loc, &Lvalue::Local(RETURN_POINTER));\n-            }\n-\n-            TerminatorKind::Assert { .. } |\n-            TerminatorKind::SwitchInt { .. } => {\n-                // branching terminators - these don't move anything\n-            }\n-\n-            TerminatorKind::Drop { ref location, target: _, unwind: _ } => {\n-                self.gather_move(loc, location);\n-            }\n-            TerminatorKind::DropAndReplace { ref location, ref value, .. } => {\n-                self.create_move_path(location);\n-                self.gather_operand(loc, value);\n-            }\n-            TerminatorKind::Call { ref func, ref args, ref destination, cleanup: _ } => {\n-                self.gather_operand(loc, func);\n-                for arg in args {\n-                    self.gather_operand(loc, arg);\n-                }\n-                if let Some((ref destination, _bb)) = *destination {\n-                    self.create_move_path(destination);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn gather_operand(&mut self, loc: Location, operand: &Operand<'tcx>) {\n-        match *operand {\n-            Operand::Constant(..) => {} // not-a-move\n-            Operand::Consume(ref lval) => { // a move\n-                self.gather_move(loc, lval);\n-            }\n-        }\n-    }\n-\n-    fn gather_move(&mut self, loc: Location, lval: &Lvalue<'tcx>) {\n-        debug!(\"gather_move({:?}, {:?})\", loc, lval);\n-\n-        let lv_ty = lval.ty(self.mir, self.tcx).to_ty(self.tcx);\n-        if !lv_ty.moves_by_default(self.tcx, self.param_env, DUMMY_SP) {\n-            debug!(\"gather_move({:?}, {:?}) - {:?} is Copy. skipping\", loc, lval, lv_ty);\n-            return\n-        }\n-\n-        let path = match self.move_path_for(lval) {\n-            Ok(path) | Err(MovePathError::UnionMove { path }) => path,\n-            Err(MovePathError::IllegalMove) => {\n-                // Moving out of a bad path. Eventually, this should be a MIR\n-                // borrowck error instead of a bug.\n-                span_bug!(self.mir.span,\n-                          \"Broken MIR: moving out of lvalue {:?}: {:?} at {:?}\",\n-                          lval, lv_ty, loc);\n-            }\n-        };\n-        let move_out = self.data.moves.push(MoveOut { path: path, source: loc });\n-\n-        debug!(\"gather_move({:?}, {:?}): adding move {:?} of {:?}\",\n-               loc, lval, move_out, path);\n-\n-        self.data.path_map[path].push(move_out);\n-        self.data.loc_map[loc].push(move_out);\n+        builder::gather_moves(mir, tcx, param_env)\n     }\n }"}]}