{"sha": "27f87c611fa57b0320f72f483c60e7b4d70ddc2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3Zjg3YzYxMWZhNTdiMDMyMGY3MmY0ODNjNjBlN2I0ZDcwZGRjMmE=", "commit": {"author": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2014-07-26T03:45:09Z"}, "committer": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2014-09-04T22:22:32Z"}, "message": "std: Fix overflow of HashMap's capacity", "tree": {"sha": "705b091f2177f36d47a4f3a60b4a5015d060cfd2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/705b091f2177f36d47a4f3a60b4a5015d060cfd2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27f87c611fa57b0320f72f483c60e7b4d70ddc2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27f87c611fa57b0320f72f483c60e7b4d70ddc2a", "html_url": "https://github.com/rust-lang/rust/commit/27f87c611fa57b0320f72f483c60e7b4d70ddc2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27f87c611fa57b0320f72f483c60e7b4d70ddc2a/comments", "author": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae7342a56a24eac539e3d4b13cd49c6719908426", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae7342a56a24eac539e3d4b13cd49c6719908426", "html_url": "https://github.com/rust-lang/rust/commit/ae7342a56a24eac539e3d4b13cd49c6719908426"}], "stats": {"total": 102, "additions": 70, "deletions": 32}, "files": [{"sha": "2edb8cd092e0c61e4107f0b17c3feb0ec59beb4c", "filename": "src/libstd/collections/hashmap/table.rs", "status": "modified", "additions": 49, "deletions": 32, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/27f87c611fa57b0320f72f483c60e7b4d70ddc2a/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f87c611fa57b0320f72f483c60e7b4d70ddc2a/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs?ref=27f87c611fa57b0320f72f483c60e7b4d70ddc2a", "patch": "@@ -526,32 +526,45 @@ fn test_rounding() {\n     assert_eq!(round_up_to_next(5, 4), 8);\n }\n \n-// Returns a tuple of (minimum required malloc alignment, hash_offset,\n-// key_offset, val_offset, array_size), from the start of a mallocated array.\n-fn calculate_offsets(\n-    hash_size: uint, hash_align: uint,\n-    keys_size: uint, keys_align: uint,\n-    vals_size: uint, vals_align: uint) -> (uint, uint, uint, uint, uint) {\n+// Returns a tuple of (key_offset, val_offset),\n+// from the start of a mallocated array.\n+fn calculate_offsets(hashes_size: uint,\n+                     keys_size: uint, keys_align: uint,\n+                     vals_align: uint)\n+                     -> (uint, uint) {\n+    let keys_offset = round_up_to_next(hashes_size, keys_align);\n+    let end_of_keys = keys_offset + keys_size;\n \n-    let hash_offset   = 0;\n-    let end_of_hashes = hash_offset + hash_size;\n+    let vals_offset = round_up_to_next(end_of_keys, vals_align);\n \n-    let keys_offset   = round_up_to_next(end_of_hashes, keys_align);\n-    let end_of_keys   = keys_offset + keys_size;\n+    (keys_offset, vals_offset)\n+}\n \n-    let vals_offset   = round_up_to_next(end_of_keys, vals_align);\n-    let end_of_vals   = vals_offset + vals_size;\n+// Returns a tuple of (minimum required malloc alignment, hash_offset,\n+// array_size), from the start of a mallocated array.\n+fn calculate_allocation(hash_size: uint, hash_align: uint,\n+                        keys_size: uint, keys_align: uint,\n+                        vals_size: uint, vals_align: uint)\n+                        -> (uint, uint, uint) {\n+    let hash_offset = 0;\n+    let (_, vals_offset) = calculate_offsets(hash_size,\n+                                             keys_size, keys_align,\n+                                                        vals_align);\n+    let end_of_vals = vals_offset + vals_size;\n \n     let min_align = cmp::max(hash_align, cmp::max(keys_align, vals_align));\n \n-    (min_align, hash_offset, keys_offset, vals_offset, end_of_vals)\n+    (min_align, hash_offset, end_of_vals)\n }\n \n #[test]\n fn test_offset_calculation() {\n-    assert_eq!(calculate_offsets(128, 8, 15, 1, 4, 4 ), (8, 0, 128, 144, 148));\n-    assert_eq!(calculate_offsets(3,   1, 2,  1, 1, 1 ), (1, 0, 3,   5,   6));\n-    assert_eq!(calculate_offsets(6,   2, 12, 4, 24, 8), (8, 0, 8,   24,  48));\n+    assert_eq!(calculate_allocation(128, 8, 15, 1, 4,  4), (8, 0, 148));\n+    assert_eq!(calculate_allocation(3,   1, 2,  1, 1,  1), (1, 0, 6));\n+    assert_eq!(calculate_allocation(6,   2, 12, 4, 24, 8), (8, 0, 48));\n+    assert_eq!(calculate_offsets(128, 15, 1, 4), (128, 144));\n+    assert_eq!(calculate_offsets(3,   2,  1, 1), (3,   5));\n+    assert_eq!(calculate_offsets(6,   12, 4, 8), (8,   24));\n }\n \n impl<K, V> RawTable<K, V> {\n@@ -566,12 +579,11 @@ impl<K, V> RawTable<K, V> {\n                 marker: marker::CovariantType,\n             };\n         }\n-        let hashes_size = capacity.checked_mul(&size_of::<u64>())\n-                                  .expect(\"capacity overflow\");\n-        let keys_size = capacity.checked_mul(&size_of::< K >())\n-                                .expect(\"capacity overflow\");\n-        let vals_size = capacity.checked_mul(&size_of::< V >())\n-                                .expect(\"capacity overflow\");\n+        // No need for `checked_mul` before a more restrictive check performed\n+        // later in this method.\n+        let hashes_size = capacity * size_of::<u64>();\n+        let keys_size   = capacity * size_of::< K >();\n+        let vals_size   = capacity * size_of::< V >();\n \n         // Allocating hashmaps is a little tricky. We need to allocate three\n         // arrays, but since we know their sizes and alignments up front,\n@@ -581,12 +593,19 @@ impl<K, V> RawTable<K, V> {\n         // This is great in theory, but in practice getting the alignment\n         // right is a little subtle. Therefore, calculating offsets has been\n         // factored out into a different function.\n-        let (malloc_alignment, hash_offset, _, _, size) =\n-            calculate_offsets(\n+        let (malloc_alignment, hash_offset, size) =\n+            calculate_allocation(\n                 hashes_size, min_align_of::<u64>(),\n                 keys_size,   min_align_of::< K >(),\n                 vals_size,   min_align_of::< V >());\n \n+        // One check for overflow that covers calculation and rounding of size.\n+        let size_of_bucket = size_of::<u64>().checked_add(&size_of::<K>()).unwrap()\n+                                             .checked_add(&size_of::<V>()).unwrap();\n+        assert!(size >= capacity.checked_mul(&size_of_bucket)\n+                                .expect(\"capacity overflow\"),\n+                \"capacity overflow\");\n+\n         let buffer = allocate(size, malloc_alignment);\n \n         let hashes = buffer.offset(hash_offset as int) as *mut u64;\n@@ -603,12 +622,10 @@ impl<K, V> RawTable<K, V> {\n         let hashes_size = self.capacity * size_of::<u64>();\n         let keys_size = self.capacity * size_of::<K>();\n \n-        let keys_offset = (hashes_size + min_align_of::<K>() - 1) & !(min_align_of::<K>() - 1);\n-        let end_of_keys = keys_offset + keys_size;\n-\n-        let vals_offset = (end_of_keys + min_align_of::<V>() - 1) & !(min_align_of::<V>() - 1);\n-\n         let buffer = self.hashes as *mut u8;\n+        let (keys_offset, vals_offset) = calculate_offsets(hashes_size,\n+                                                           keys_size, min_align_of::<K>(),\n+                                                           min_align_of::<V>());\n \n         unsafe {\n             RawBucket {\n@@ -866,9 +883,9 @@ impl<K, V> Drop for RawTable<K, V> {\n         let hashes_size = self.capacity * size_of::<u64>();\n         let keys_size = self.capacity * size_of::<K>();\n         let vals_size = self.capacity * size_of::<V>();\n-        let (align, _, _, _, size) = calculate_offsets(hashes_size, min_align_of::<u64>(),\n-                                                       keys_size, min_align_of::<K>(),\n-                                                       vals_size, min_align_of::<V>());\n+        let (align, _, size) = calculate_allocation(hashes_size, min_align_of::<u64>(),\n+                                                    keys_size, min_align_of::<K>(),\n+                                                    vals_size, min_align_of::<V>());\n \n         unsafe {\n             deallocate(self.hashes as *mut u8, size, align);"}, {"sha": "f68b511d0aa0ddc7b9df6ed23ecea27dcf5cfa33", "filename": "src/test/run-fail/hashmap-capacity-overflow.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/27f87c611fa57b0320f72f483c60e7b4d70ddc2a/src%2Ftest%2Frun-fail%2Fhashmap-capacity-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f87c611fa57b0320f72f483c60e7b4d70ddc2a/src%2Ftest%2Frun-fail%2Fhashmap-capacity-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fhashmap-capacity-overflow.rs?ref=27f87c611fa57b0320f72f483c60e7b4d70ddc2a", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:capacity overflow\n+\n+use std::collections::hashmap::HashMap;\n+use std::uint;\n+use std::mem::size_of;\n+\n+fn main() {\n+    let threshold = uint::MAX / size_of::<(u64, u64, u64)>();\n+    let mut h = HashMap::<u64, u64>::with_capacity(threshold + 100);\n+    h.insert(0, 0);\n+}"}]}