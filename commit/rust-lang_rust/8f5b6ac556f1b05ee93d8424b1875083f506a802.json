{"sha": "8f5b6ac556f1b05ee93d8424b1875083f506a802", "node_id": "C_kwDOAAsO6NoAKDhmNWI2YWM1NTZmMWIwNWVlOTNkODQyNGIxODc1MDgzZjUwNmE4MDI", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-03-17T11:39:42Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-03-17T16:03:54Z"}, "message": "Properly try unifying the receivers during method resolution\n\nInstead of hackily checking if they're equal.", "tree": {"sha": "623100a93d43ed0cf840eaed685ca7f42adf6515", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/623100a93d43ed0cf840eaed685ca7f42adf6515"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f5b6ac556f1b05ee93d8424b1875083f506a802", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f5b6ac556f1b05ee93d8424b1875083f506a802", "html_url": "https://github.com/rust-lang/rust/commit/8f5b6ac556f1b05ee93d8424b1875083f506a802", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f5b6ac556f1b05ee93d8424b1875083f506a802/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b71cd074de0645f2e209db48846b25a474014df", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b71cd074de0645f2e209db48846b25a474014df", "html_url": "https://github.com/rust-lang/rust/commit/1b71cd074de0645f2e209db48846b25a474014df"}], "stats": {"total": 345, "additions": 114, "deletions": 231}, "files": [{"sha": "5c77c0cdf8b9905867801dc3568e935686bbaa56", "filename": "crates/hir_ty/src/builder.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8f5b6ac556f1b05ee93d8424b1875083f506a802/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5b6ac556f1b05ee93d8424b1875083f506a802/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs?ref=8f5b6ac556f1b05ee93d8424b1875083f506a802", "patch": "@@ -15,10 +15,10 @@ use hir_def::{\n use smallvec::SmallVec;\n \n use crate::{\n-    consteval::unknown_const_as_generic, db::HirDatabase, primitive, to_assoc_type_id,\n-    to_chalk_trait_id, utils::generics, Binders, CallableSig, ConstData, ConstValue, GenericArg,\n-    GenericArgData, Interner, ProjectionTy, Substitution, TraitRef, Ty, TyDefId, TyExt, TyKind,\n-    ValueTyDefId,\n+    consteval::unknown_const_as_generic, db::HirDatabase, infer::unify::InferenceTable, primitive,\n+    to_assoc_type_id, to_chalk_trait_id, utils::generics, Binders, CallableSig, ConstData,\n+    ConstValue, GenericArg, GenericArgData, Interner, ProjectionTy, Substitution, TraitRef, Ty,\n+    TyDefId, TyExt, TyKind, ValueTyDefId,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -111,6 +111,15 @@ impl<D> TyBuilder<D> {\n         this\n     }\n \n+    pub(crate) fn fill_with_inference_vars(self, table: &mut InferenceTable) -> Self {\n+        self.fill(|x| match x {\n+            ParamKind::Type => GenericArgData::Ty(table.new_type_var()).intern(Interner),\n+            ParamKind::Const(ty) => {\n+                GenericArgData::Const(table.new_const_var(ty.clone())).intern(Interner)\n+            }\n+        })\n+    }\n+\n     pub fn fill(mut self, filler: impl FnMut(&ParamKind) -> GenericArg) -> Self {\n         self.vec.extend(self.param_kinds.iter().skip(self.vec.len()).map(filler));\n         assert_eq!(self.remaining(), 0);"}, {"sha": "442774d0be065f4c354df70d777f842a178ad548", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8f5b6ac556f1b05ee93d8424b1875083f506a802/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5b6ac556f1b05ee93d8424b1875083f506a802/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=8f5b6ac556f1b05ee93d8424b1875083f506a802", "patch": "@@ -35,18 +35,16 @@ use rustc_hash::FxHashMap;\n use stdx::impl_from;\n \n use crate::{\n-    builder::ParamKind, db::HirDatabase, fold_tys_and_consts, infer::coerce::CoerceMany,\n-    lower::ImplTraitLoweringMode, to_assoc_type_id, AliasEq, AliasTy, Const, DomainGoal,\n-    GenericArg, GenericArgData, Goal, InEnvironment, Interner, ProjectionTy, Substitution,\n-    TraitEnvironment, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n+    db::HirDatabase, fold_tys_and_consts, infer::coerce::CoerceMany, lower::ImplTraitLoweringMode,\n+    to_assoc_type_id, AliasEq, AliasTy, Const, DomainGoal, GenericArg, Goal, InEnvironment,\n+    Interner, ProjectionTy, Substitution, TraitEnvironment, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n };\n \n // This lint has a false positive here. See the link below for details.\n //\n // https://github.com/rust-lang/rust/issues/57411\n #[allow(unreachable_pub)]\n pub use unify::could_unify;\n-pub(crate) use unify::unify;\n \n pub(crate) mod unify;\n mod path;\n@@ -657,15 +655,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             TypeNs::TypeAliasId(it) => {\n                 let ty = TyBuilder::def_ty(self.db, it.into())\n-                    .fill(|x| match x {\n-                        ParamKind::Type => {\n-                            GenericArgData::Ty(self.table.new_type_var()).intern(Interner)\n-                        }\n-                        ParamKind::Const(ty) => {\n-                            GenericArgData::Const(self.table.new_const_var(ty.clone()))\n-                                .intern(Interner)\n-                        }\n-                    })\n+                    .fill_with_inference_vars(&mut self.table)\n                     .build();\n                 self.resolve_variant_on_alias(ty, unresolved, path)\n             }"}, {"sha": "53fe2131a35a9b388f6410ae69a59516f1e8024b", "filename": "crates/hir_ty/src/infer/path.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8f5b6ac556f1b05ee93d8424b1875083f506a802/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5b6ac556f1b05ee93d8424b1875083f506a802/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=8f5b6ac556f1b05ee93d8424b1875083f506a802", "patch": "@@ -104,9 +104,7 @@ impl<'a> InferenceContext<'a> {\n                     ParamKind::Type => {\n                         GenericArgData::Ty(TyKind::Error.intern(Interner)).intern(Interner)\n                     }\n-                    ParamKind::Const(_) => {\n-                        GenericArgData::Const(consteval::usize_const(None)).intern(Interner)\n-                    }\n+                    ParamKind::Const(ty) => consteval::unknown_const_as_generic(ty.clone()),\n                 })\n             })\n             .build();\n@@ -249,15 +247,7 @@ impl<'a> InferenceContext<'a> {\n                 let substs = match container {\n                     ItemContainerId::ImplId(impl_id) => {\n                         let impl_substs = TyBuilder::subst_for_def(self.db, impl_id)\n-                            .fill(|x| match x {\n-                                ParamKind::Type => {\n-                                    GenericArgData::Ty(self.table.new_type_var()).intern(Interner)\n-                                }\n-                                ParamKind::Const(ty) => {\n-                                    GenericArgData::Const(self.table.new_const_var(ty.clone()))\n-                                        .intern(Interner)\n-                                }\n-                            })\n+                            .fill_with_inference_vars(&mut self.table)\n                             .build();\n                         let impl_self_ty =\n                             self.db.impl_self_ty(impl_id).substitute(Interner, &impl_substs);\n@@ -268,15 +258,7 @@ impl<'a> InferenceContext<'a> {\n                         // we're picking this method\n                         let trait_ref = TyBuilder::trait_ref(self.db, trait_)\n                             .push(ty.clone())\n-                            .fill(|x| match x {\n-                                ParamKind::Type => {\n-                                    GenericArgData::Ty(self.table.new_type_var()).intern(Interner)\n-                                }\n-                                ParamKind::Const(ty) => {\n-                                    GenericArgData::Const(self.table.new_const_var(ty.clone()))\n-                                        .intern(Interner)\n-                                }\n-                            })\n+                            .fill_with_inference_vars(&mut self.table)\n                             .build();\n                         self.push_obligation(trait_ref.clone().cast(Interner));\n                         Some(trait_ref.substitution)"}, {"sha": "f917b43ff8c855f11219d449c22ae77f8fce1ac5", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 94, "deletions": 191, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/8f5b6ac556f1b05ee93d8424b1875083f506a802/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5b6ac556f1b05ee93d8424b1875083f506a802/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=8f5b6ac556f1b05ee93d8424b1875083f506a802", "patch": "@@ -18,16 +18,15 @@ use stdx::never;\n \n use crate::{\n     autoderef::{self, AutoderefKind},\n-    consteval::{self, ConstExt},\n+    consteval,\n     db::HirDatabase,\n     from_foreign_def_id,\n     infer::{unify::InferenceTable, Adjust, Adjustment, AutoBorrow, OverloadedDeref, PointerCast},\n     primitive::{self, FloatTy, IntTy, UintTy},\n     static_lifetime,\n     utils::all_super_traits,\n-    AdtId, Canonical, CanonicalVarKinds, DebruijnIndex, ForeignDefId, GenericArgData,\n-    InEnvironment, Interner, Scalar, Substitution, TraitEnvironment, TraitRefExt, Ty, TyBuilder,\n-    TyExt, TyKind,\n+    AdtId, Canonical, CanonicalVarKinds, DebruijnIndex, ForeignDefId, InEnvironment, Interner,\n+    Scalar, TraitEnvironment, TraitRefExt, Ty, TyBuilder, TyExt, TyKind,\n };\n \n /// This is used as a key for indexing impls.\n@@ -643,11 +642,10 @@ pub fn iterate_method_candidates_dyn(\n             let mut table = InferenceTable::new(db, env.clone());\n             let ty = table.instantiate_canonical(ty.clone());\n             let (deref_chain, adj) = autoderef_method_receiver(&mut table, ty);\n-            let deref_chains = stdx::slice_tails(&deref_chain);\n \n-            let result = deref_chains.zip(adj).try_for_each(|(deref_chain, adj)| {\n+            let result = deref_chain.into_iter().zip(adj).try_for_each(|(receiver_ty, adj)| {\n                 iterate_method_candidates_with_autoref(\n-                    deref_chain,\n+                    &receiver_ty,\n                     adj,\n                     db,\n                     env.clone(),\n@@ -675,7 +673,7 @@ pub fn iterate_method_candidates_dyn(\n }\n \n fn iterate_method_candidates_with_autoref(\n-    deref_chain: &[Canonical<Ty>],\n+    receiver_ty: &Canonical<Ty>,\n     first_adjustment: ReceiverAdjustments,\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n@@ -684,17 +682,9 @@ fn iterate_method_candidates_with_autoref(\n     name: Option<&Name>,\n     mut callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n-    let (receiver_ty, rest) = match deref_chain.split_first() {\n-        Some((rec, rest)) => (rec, rest),\n-        None => {\n-            never!(\"received empty deref-chain\");\n-            return ControlFlow::Break(());\n-        }\n-    };\n     iterate_method_candidates_by_receiver(\n         receiver_ty,\n         first_adjustment.clone(),\n-        rest,\n         db,\n         env.clone(),\n         traits_in_scope,\n@@ -712,7 +702,6 @@ fn iterate_method_candidates_with_autoref(\n     iterate_method_candidates_by_receiver(\n         &refed,\n         first_adjustment.with_autoref(Mutability::Not),\n-        deref_chain,\n         db,\n         env.clone(),\n         traits_in_scope,\n@@ -730,7 +719,6 @@ fn iterate_method_candidates_with_autoref(\n     iterate_method_candidates_by_receiver(\n         &ref_muted,\n         first_adjustment.with_autoref(Mutability::Mut),\n-        deref_chain,\n         db,\n         env,\n         traits_in_scope,\n@@ -743,38 +731,42 @@ fn iterate_method_candidates_with_autoref(\n fn iterate_method_candidates_by_receiver(\n     receiver_ty: &Canonical<Ty>,\n     receiver_adjustments: ReceiverAdjustments,\n-    rest_of_deref_chain: &[Canonical<Ty>],\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n     traits_in_scope: &FxHashSet<TraitId>,\n     visible_from_module: VisibleFromModule,\n     name: Option<&Name>,\n     mut callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n+    let mut table = InferenceTable::new(db, env);\n+    let receiver_ty = table.instantiate_canonical(receiver_ty.clone());\n+    let snapshot = table.snapshot();\n     // We're looking for methods with *receiver* type receiver_ty. These could\n     // be found in any of the derefs of receiver_ty, so we have to go through\n     // that.\n-    for self_ty in iter::once(receiver_ty).chain(rest_of_deref_chain) {\n+    let mut autoderef = autoderef::Autoderef::new(&mut table, receiver_ty.clone());\n+    while let Some((self_ty, _)) = autoderef.next() {\n         iterate_inherent_methods(\n-            self_ty,\n-            db,\n-            env.clone(),\n+            &self_ty,\n+            &mut autoderef.table,\n             name,\n-            Some(receiver_ty),\n+            Some(&receiver_ty),\n             Some(receiver_adjustments.clone()),\n             visible_from_module,\n             &mut callback,\n         )?\n     }\n \n-    for self_ty in iter::once(receiver_ty).chain(rest_of_deref_chain) {\n+    table.rollback_to(snapshot);\n+\n+    let mut autoderef = autoderef::Autoderef::new(&mut table, receiver_ty.clone());\n+    while let Some((self_ty, _)) = autoderef.next() {\n         iterate_trait_method_candidates(\n-            self_ty,\n-            db,\n-            env.clone(),\n+            &self_ty,\n+            &mut autoderef.table,\n             traits_in_scope,\n             name,\n-            Some(receiver_ty),\n+            Some(&receiver_ty),\n             Some(receiver_adjustments.clone()),\n             &mut callback,\n         )?\n@@ -792,43 +784,55 @@ fn iterate_method_candidates_for_self_ty(\n     name: Option<&Name>,\n     mut callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n+    let mut table = InferenceTable::new(db, env);\n+    let self_ty = table.instantiate_canonical(self_ty.clone());\n     iterate_inherent_methods(\n-        self_ty,\n-        db,\n-        env.clone(),\n+        &self_ty,\n+        &mut table,\n         name,\n         None,\n         None,\n         visible_from_module,\n         &mut callback,\n     )?;\n-    iterate_trait_method_candidates(self_ty, db, env, traits_in_scope, name, None, None, callback)\n+    iterate_trait_method_candidates(\n+        &self_ty,\n+        &mut table,\n+        traits_in_scope,\n+        name,\n+        None,\n+        None,\n+        callback,\n+    )\n }\n \n fn iterate_trait_method_candidates(\n-    self_ty: &Canonical<Ty>,\n-    db: &dyn HirDatabase,\n-    env: Arc<TraitEnvironment>,\n+    self_ty: &Ty,\n+    table: &mut InferenceTable,\n     traits_in_scope: &FxHashSet<TraitId>,\n     name: Option<&Name>,\n-    receiver_ty: Option<&Canonical<Ty>>,\n+    receiver_ty: Option<&Ty>,\n     receiver_adjustments: Option<ReceiverAdjustments>,\n     callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n-    let self_is_array = matches!(self_ty.value.kind(Interner), chalk_ir::TyKind::Array(..));\n+    let db = table.db;\n+    let env = table.trait_env.clone();\n+    let self_is_array = matches!(self_ty.kind(Interner), chalk_ir::TyKind::Array(..));\n     // if ty is `dyn Trait`, the trait doesn't need to be in scope\n     let inherent_trait =\n-        self_ty.value.dyn_trait().into_iter().flat_map(|t| all_super_traits(db.upcast(), t));\n-    let env_traits = matches!(self_ty.value.kind(Interner), TyKind::Placeholder(_))\n+        self_ty.dyn_trait().into_iter().flat_map(|t| all_super_traits(db.upcast(), t));\n+    let env_traits = matches!(self_ty.kind(Interner), TyKind::Placeholder(_))\n         // if we have `T: Trait` in the param env, the trait doesn't need to be in scope\n         .then(|| {\n-            env.traits_in_scope_from_clauses(self_ty.value.clone())\n+            env.traits_in_scope_from_clauses(self_ty.clone())\n                 .flat_map(|t| all_super_traits(db.upcast(), t))\n         })\n         .into_iter()\n         .flatten();\n     let traits = inherent_trait.chain(env_traits).chain(traits_in_scope.iter().copied());\n \n+    let canonical_self_ty = table.canonicalize(self_ty.clone()).value;\n+\n     'traits: for t in traits {\n         let data = db.trait_data(t);\n \n@@ -852,11 +856,11 @@ fn iterate_trait_method_candidates(\n         for &(_, item) in data.items.iter() {\n             // Don't pass a `visible_from_module` down to `is_valid_candidate`,\n             // since only inherent methods should be included into visibility checking.\n-            if !is_valid_candidate(db, env.clone(), name, receiver_ty, item, self_ty, None) {\n+            if !is_valid_candidate(table, name, receiver_ty, item, self_ty, None) {\n                 continue;\n             }\n             if !known_implemented {\n-                let goal = generic_implements_goal(db, env.clone(), t, self_ty);\n+                let goal = generic_implements_goal(db, env.clone(), t, &canonical_self_ty);\n                 if db.trait_solve(env.krate, goal.cast(Interner)).is_none() {\n                     continue 'traits;\n                 }\n@@ -868,40 +872,18 @@ fn iterate_trait_method_candidates(\n     ControlFlow::Continue(())\n }\n \n-fn filter_inherent_impls_for_self_ty<'i>(\n-    impls: &'i InherentImpls,\n-    self_ty: &Ty,\n-) -> impl Iterator<Item = &'i ImplId> {\n-    // inherent methods on arrays are fingerprinted as [T; {unknown}], so we must also consider them when\n-    // resolving a method call on an array with a known len\n-    let array_impls = {\n-        match self_ty.kind(Interner) {\n-            TyKind::Array(parameters, array_len) if !array_len.is_unknown() => {\n-                let unknown_array_len_ty =\n-                    TyKind::Array(parameters.clone(), consteval::usize_const(None));\n-\n-                Some(impls.for_self_ty(&unknown_array_len_ty.intern(Interner)))\n-            }\n-            _ => None,\n-        }\n-    }\n-    .into_iter()\n-    .flatten();\n-\n-    impls.for_self_ty(self_ty).iter().chain(array_impls)\n-}\n-\n fn iterate_inherent_methods(\n-    self_ty: &Canonical<Ty>,\n-    db: &dyn HirDatabase,\n-    env: Arc<TraitEnvironment>,\n+    self_ty: &Ty,\n+    table: &mut InferenceTable,\n     name: Option<&Name>,\n-    receiver_ty: Option<&Canonical<Ty>>,\n+    receiver_ty: Option<&Ty>,\n     receiver_adjustments: Option<ReceiverAdjustments>,\n     visible_from_module: VisibleFromModule,\n     callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n-    let def_crates = match def_crates(db, &self_ty.value, env.krate) {\n+    let db = table.db;\n+    let env = table.trait_env.clone();\n+    let def_crates = match def_crates(db, self_ty, env.krate) {\n         Some(k) => k,\n         None => return ControlFlow::Continue(()),\n     };\n@@ -917,8 +899,7 @@ fn iterate_inherent_methods(\n             impls_for_self_ty(\n                 &impls,\n                 self_ty,\n-                db,\n-                env.clone(),\n+                table,\n                 name,\n                 receiver_ty,\n                 receiver_adjustments.clone(),\n@@ -933,8 +914,7 @@ fn iterate_inherent_methods(\n         impls_for_self_ty(\n             &impls,\n             self_ty,\n-            db,\n-            env.clone(),\n+            table,\n             name,\n             receiver_ty,\n             receiver_adjustments.clone(),\n@@ -946,37 +926,20 @@ fn iterate_inherent_methods(\n \n     fn impls_for_self_ty(\n         impls: &InherentImpls,\n-        self_ty: &Canonical<Ty>,\n-        db: &dyn HirDatabase,\n-        env: Arc<TraitEnvironment>,\n+        self_ty: &Ty,\n+        table: &mut InferenceTable,\n         name: Option<&Name>,\n-        receiver_ty: Option<&Canonical<Ty>>,\n+        receiver_ty: Option<&Ty>,\n         receiver_adjustments: Option<ReceiverAdjustments>,\n         visible_from_module: Option<ModuleId>,\n         callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n     ) -> ControlFlow<()> {\n-        let impls_for_self_ty = filter_inherent_impls_for_self_ty(impls, &self_ty.value);\n+        let db = table.db;\n+        let impls_for_self_ty = impls.for_self_ty(self_ty);\n         for &impl_def in impls_for_self_ty {\n             for &item in &db.impl_data(impl_def).items {\n-                if !is_valid_candidate(\n-                    db,\n-                    env.clone(),\n-                    name,\n-                    receiver_ty,\n-                    item,\n-                    self_ty,\n-                    visible_from_module,\n-                ) {\n-                    continue;\n-                }\n-                // we have to check whether the self type unifies with the type\n-                // that the impl is for. If we have a receiver type, this\n-                // already happens in `is_valid_candidate` above; if not, we\n-                // check it here\n-                if receiver_ty.is_none()\n-                    && inherent_impl_substs(db, env.clone(), impl_def, self_ty).is_none()\n+                if !is_valid_candidate(table, name, receiver_ty, item, self_ty, visible_from_module)\n                 {\n-                    cov_mark::hit!(impl_self_type_match_without_receiver);\n                     continue;\n                 }\n                 callback(receiver_adjustments.clone().unwrap_or_default(), item)?;\n@@ -1005,37 +968,15 @@ pub fn resolve_indexing_op(\n     None\n }\n \n-fn is_transformed_receiver_ty_equal(transformed_receiver_ty: &Ty, receiver_ty: &Ty) -> bool {\n-    if transformed_receiver_ty == receiver_ty {\n-        return true;\n-    }\n-\n-    // a transformed receiver may be considered equal (and a valid method call candidate) if it is an array\n-    // with an unknown (i.e. generic) length, and the receiver is an array with the same item type but a known len,\n-    // this allows inherent methods on arrays to be considered valid resolution candidates\n-    match (transformed_receiver_ty.kind(Interner), receiver_ty.kind(Interner)) {\n-        (\n-            TyKind::Array(transformed_array_ty, transformed_array_len),\n-            TyKind::Array(receiver_array_ty, receiver_array_len),\n-        ) if transformed_array_ty == receiver_array_ty\n-            && transformed_array_len.is_unknown()\n-            && !receiver_array_len.is_unknown() =>\n-        {\n-            true\n-        }\n-        _ => false,\n-    }\n-}\n-\n fn is_valid_candidate(\n-    db: &dyn HirDatabase,\n-    env: Arc<TraitEnvironment>,\n+    table: &mut InferenceTable,\n     name: Option<&Name>,\n-    receiver_ty: Option<&Canonical<Ty>>,\n+    receiver_ty: Option<&Ty>,\n     item: AssocItemId,\n-    self_ty: &Canonical<Ty>,\n+    self_ty: &Ty,\n     visible_from_module: Option<ModuleId>,\n ) -> bool {\n+    let db = table.db;\n     match item {\n         AssocItemId::FunctionId(m) => {\n             let data = db.function_data(m);\n@@ -1044,18 +985,40 @@ fn is_valid_candidate(\n                     return false;\n                 }\n             }\n+            let snap = table.snapshot();\n+            let subst = TyBuilder::subst_for_def(db, m).fill_with_inference_vars(table).build();\n+            let expected_self_ty = match m.lookup(db.upcast()).container {\n+                ItemContainerId::TraitId(_) => {\n+                    subst.at(Interner, 0).assert_ty_ref(Interner).clone()\n+                }\n+                ItemContainerId::ImplId(impl_id) => {\n+                    subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner)\n+                }\n+                // We should only get called for associated items (impl/trait)\n+                ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => unreachable!(),\n+            };\n+            if !table.unify(&expected_self_ty, &self_ty) {\n+                // FIXME handle rollbacks better\n+                table.rollback_to(snap);\n+                return false;\n+            }\n             if let Some(receiver_ty) = receiver_ty {\n                 if !data.has_self_param() {\n+                    table.rollback_to(snap);\n                     return false;\n                 }\n-                let transformed_receiver_ty = match transform_receiver_ty(db, env, m, self_ty) {\n-                    Some(ty) => ty,\n-                    None => return false,\n-                };\n \n-                if !is_transformed_receiver_ty_equal(&transformed_receiver_ty, &receiver_ty.value) {\n+                let sig = db.callable_item_signature(m.into());\n+                let expected_receiver =\n+                    sig.map(|s| s.params()[0].clone()).substitute(Interner, &subst);\n+                let receiver_matches = table.unify(&receiver_ty, &expected_receiver);\n+                table.rollback_to(snap);\n+\n+                if !receiver_matches {\n                     return false;\n                 }\n+            } else {\n+                table.rollback_to(snap);\n             }\n             if let Some(from_module) = visible_from_module {\n                 if !db.function_visibility(m).is_visible_from(db.upcast(), from_module) {\n@@ -1068,49 +1031,14 @@ fn is_valid_candidate(\n         }\n         AssocItemId::ConstId(c) => {\n             let data = db.const_data(c);\n+            // TODO check unify self ty\n+            // TODO check visibility\n             name.map_or(true, |name| data.name.as_ref() == Some(name)) && receiver_ty.is_none()\n         }\n         _ => false,\n     }\n }\n \n-pub(crate) fn inherent_impl_substs(\n-    db: &dyn HirDatabase,\n-    env: Arc<TraitEnvironment>,\n-    impl_id: ImplId,\n-    self_ty: &Canonical<Ty>,\n-) -> Option<Substitution> {\n-    // we create a var for each type parameter of the impl; we need to keep in\n-    // mind here that `self_ty` might have vars of its own\n-    let self_ty_vars = self_ty.binders.len(Interner);\n-    let vars = TyBuilder::subst_for_def(db, impl_id)\n-        .fill_with_bound_vars(DebruijnIndex::INNERMOST, self_ty_vars)\n-        .build();\n-    let self_ty_with_vars = db.impl_self_ty(impl_id).substitute(Interner, &vars);\n-    let mut kinds = self_ty.binders.interned().to_vec();\n-    kinds.extend(vars.iter(Interner).map(|x| {\n-        let kind = match x.data(Interner) {\n-            GenericArgData::Ty(_) => chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General),\n-            GenericArgData::Const(c) => chalk_ir::VariableKind::Const(c.data(Interner).ty.clone()),\n-            GenericArgData::Lifetime(_) => chalk_ir::VariableKind::Lifetime,\n-        };\n-        chalk_ir::WithKind::new(kind, UniverseIndex::ROOT)\n-    }));\n-    let tys = Canonical {\n-        binders: CanonicalVarKinds::from_iter(Interner, kinds),\n-        value: (self_ty_with_vars, self_ty.value.clone()),\n-    };\n-    let substs = super::infer::unify(db, env, &tys)?;\n-    // We only want the substs for the vars we added, not the ones from self_ty.\n-    // Also, if any of the vars we added are still in there, we replace them by\n-    // Unknown. I think this can only really happen if self_ty contained\n-    // Unknown, and in that case we want the result to contain Unknown in those\n-    // places again.\n-    let suffix =\n-        Substitution::from_iter(Interner, substs.iter(Interner).skip(self_ty_vars).cloned());\n-    Some(fallback_bound_vars(suffix, self_ty_vars))\n-}\n-\n /// This replaces any 'free' Bound vars in `s` (i.e. those with indices past\n /// num_vars_to_keep) by `TyKind::Unknown`.\n pub(crate) fn fallback_bound_vars<T: Fold<Interner> + HasInterner<Interner = Interner>>(\n@@ -1136,31 +1064,6 @@ pub(crate) fn fallback_bound_vars<T: Fold<Interner> + HasInterner<Interner = Int\n     )\n }\n \n-fn transform_receiver_ty(\n-    db: &dyn HirDatabase,\n-    env: Arc<TraitEnvironment>,\n-    function_id: FunctionId,\n-    self_ty: &Canonical<Ty>,\n-) -> Option<Ty> {\n-    let substs = match function_id.lookup(db.upcast()).container {\n-        ItemContainerId::TraitId(_) => TyBuilder::subst_for_def(db, function_id)\n-            .push(self_ty.value.clone())\n-            .fill_with_unknown()\n-            .build(),\n-        ItemContainerId::ImplId(impl_id) => {\n-            let impl_substs = inherent_impl_substs(db, env, impl_id, self_ty)?;\n-            TyBuilder::subst_for_def(db, function_id)\n-                .use_parent_substs(&impl_substs)\n-                .fill_with_unknown()\n-                .build()\n-        }\n-        // No receiver\n-        ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => unreachable!(),\n-    };\n-    let sig = db.callable_item_signature(function_id.into());\n-    Some(sig.map(|s| s.params()[0].clone()).substitute(Interner, &substs))\n-}\n-\n pub fn implements_trait(\n     ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,"}, {"sha": "6fd574439b4a42d2d37c66defca0ad85ae8690a1", "filename": "crates/hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f5b6ac556f1b05ee93d8424b1875083f506a802/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5b6ac556f1b05ee93d8424b1875083f506a802/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=8f5b6ac556f1b05ee93d8424b1875083f506a802", "patch": "@@ -925,7 +925,6 @@ fn test() { S2.into(); }\n \n #[test]\n fn method_resolution_overloaded_method() {\n-    cov_mark::check!(impl_self_type_match_without_receiver);\n     check_types(\n         r#\"\n struct Wrapper<T>(T);"}]}