{"sha": "a86bdb4c507f9f9651f7372075eb17009c7da4a6", "node_id": "C_kwDOAAsO6NoAKGE4NmJkYjRjNTA3ZjlmOTY1MWY3MzcyMDc1ZWIxNzAwOWM3ZGE0YTY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-11-14T18:26:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-14T18:26:16Z"}, "message": "Rollup merge of #104223 - fmease:recover-fn-ptr-with-generics, r=estebank\n\nRecover from function pointer types with generic parameter list\n\nGive a more helpful error when encountering function pointer types with a generic parameter list like `fn<'a>(&'a str) -> bool` or `fn<T>(T) -> T` and suggest moving lifetime parameters to a `for<>` parameter list.\n\nI've added a bunch of extra code to properly handle (unlikely?) corner cases like `for<'a> fn<'b>()` (where there already exists a `for<>` parameter list) correctly suggesting `for<'a, 'b> fn()` (merging the lists). If you deem this useless, I can simplify the code by suggesting nothing at all in this case.\n\nI am quite open to suggestions regarding the wording of the diagnostic messages.\n\nFixes #103487.\n``@rustbot`` label A-diagnostics\nr? diagnostics", "tree": {"sha": "f93cdfdf9d7c99308c71992682066e83b1828878", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f93cdfdf9d7c99308c71992682066e83b1828878"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a86bdb4c507f9f9651f7372075eb17009c7da4a6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjcohICRBK7hj4Ov3rIwAAcWcIAEo2xMciP29h6rUkXy3cOuSp\nBWibiKIyIy4c0HHxtjeJ0a6YwlRjDSeNbhGC1H/kGcFATeIaovI5BjF8M49/EeQI\nmRBvXz34Z/2F9SZrzauz8+pTu9WtfeWzKhUnuCefYuPvuY4gjLPO11jXgtiEJyOM\n7sCK/XIV6QQPx47AB8ZninX5/8SrIrdXpfjRx2D1ooMyYfDQhtBt6kOnSVEz4JAJ\n6IeX0TcZfa+AGDS6i9y5Rt9GPiM/ZTLDyeGglDMgO09f9x6diDs1WzL/IKNLgyHX\nDzlJthAj5jOM/c8DB8YRc0pdY0zAjw/aIs6ysXY3OIf2nkSh8DtZi6N1BAx1vh0=\n=LKxG\n-----END PGP SIGNATURE-----\n", "payload": "tree f93cdfdf9d7c99308c71992682066e83b1828878\nparent 8c77da87d7451f275259c43c89ac3c9c24c1c8c8\nparent c2b906ba9a29591536042be4bbf8d0156225bb73\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1668450376 +0100\ncommitter GitHub <noreply@github.com> 1668450376 +0100\n\nRollup merge of #104223 - fmease:recover-fn-ptr-with-generics, r=estebank\n\nRecover from function pointer types with generic parameter list\n\nGive a more helpful error when encountering function pointer types with a generic parameter list like `fn<'a>(&'a str) -> bool` or `fn<T>(T) -> T` and suggest moving lifetime parameters to a `for<>` parameter list.\n\nI've added a bunch of extra code to properly handle (unlikely?) corner cases like `for<'a> fn<'b>()` (where there already exists a `for<>` parameter list) correctly suggesting `for<'a, 'b> fn()` (merging the lists). If you deem this useless, I can simplify the code by suggesting nothing at all in this case.\n\nI am quite open to suggestions regarding the wording of the diagnostic messages.\n\nFixes #103487.\n``@rustbot`` label A-diagnostics\nr? diagnostics\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a86bdb4c507f9f9651f7372075eb17009c7da4a6", "html_url": "https://github.com/rust-lang/rust/commit/a86bdb4c507f9f9651f7372075eb17009c7da4a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a86bdb4c507f9f9651f7372075eb17009c7da4a6/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c77da87d7451f275259c43c89ac3c9c24c1c8c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c77da87d7451f275259c43c89ac3c9c24c1c8c8", "html_url": "https://github.com/rust-lang/rust/commit/8c77da87d7451f275259c43c89ac3c9c24c1c8c8"}, {"sha": "c2b906ba9a29591536042be4bbf8d0156225bb73", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2b906ba9a29591536042be4bbf8d0156225bb73", "html_url": "https://github.com/rust-lang/rust/commit/c2b906ba9a29591536042be4bbf8d0156225bb73"}], "stats": {"total": 231, "additions": 228, "deletions": 3}, "files": [{"sha": "815e8f4d3567e6beee5c908fa23e3a8f7c672eb6", "filename": "compiler/rustc_error_messages/locales/en-US/parser.ftl", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a86bdb4c507f9f9651f7372075eb17009c7da4a6/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/a86bdb4c507f9f9651f7372075eb17009c7da4a6/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl?ref=a86bdb4c507f9f9651f7372075eb17009c7da4a6", "patch": "@@ -375,3 +375,12 @@ parser_async_move_order_incorrect = the order of `move` and `async` is incorrect\n \n parser_double_colon_in_bound = expected `:` followed by trait or lifetime\n     .suggestion = use single colon\n+\n+parser_fn_ptr_with_generics = function pointer types may not have generic parameters\n+    .suggestion = consider moving the lifetime {$arity ->\n+        [one] parameter\n+        *[other] parameters\n+    } to {$for_param_list_exists ->\n+        [true] the\n+        *[false] a\n+    } `for` parameter list"}, {"sha": "a39398950a53352545dbc3916c1c2dc6eb11559f", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a86bdb4c507f9f9651f7372075eb17009c7da4a6/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86bdb4c507f9f9651f7372075eb17009c7da4a6/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=a86bdb4c507f9f9651f7372075eb17009c7da4a6", "patch": "@@ -1280,3 +1280,24 @@ pub(crate) struct DoubleColonInBound {\n     #[suggestion(code = \": \", applicability = \"machine-applicable\")]\n     pub between: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(parser_fn_ptr_with_generics)]\n+pub(crate) struct FnPtrWithGenerics {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sugg: Option<FnPtrWithGenericsSugg>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(suggestion, applicability = \"maybe-incorrect\")]\n+pub(crate) struct FnPtrWithGenericsSugg {\n+    #[suggestion_part(code = \"{snippet}\")]\n+    pub left: Span,\n+    pub snippet: String,\n+    #[suggestion_part(code = \"\")]\n+    pub right: Span,\n+    pub arity: usize,\n+    pub for_param_list_exists: bool,\n+}"}, {"sha": "c78479b098ba000453afc83c2c27754d47af80aa", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a86bdb4c507f9f9651f7372075eb17009c7da4a6/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86bdb4c507f9f9651f7372075eb17009c7da4a6/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=a86bdb4c507f9f9651f7372075eb17009c7da4a6", "patch": "@@ -3,6 +3,7 @@\n #![feature(array_windows)]\n #![feature(box_patterns)]\n #![feature(if_let_guard)]\n+#![feature(iter_intersperse)]\n #![feature(let_chains)]\n #![feature(never_type)]\n #![feature(rustc_attrs)]"}, {"sha": "d6854f0702518dac028e26b78483dbbf46c3560e", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 55, "deletions": 3, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a86bdb4c507f9f9651f7372075eb17009c7da4a6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86bdb4c507f9f9651f7372075eb17009c7da4a6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=a86bdb4c507f9f9651f7372075eb17009c7da4a6", "patch": "@@ -1,5 +1,6 @@\n use super::{Parser, PathStyle, TokenType};\n \n+use crate::errors::{FnPtrWithGenerics, FnPtrWithGenericsSugg};\n use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n \n use rustc_ast::ptr::P;\n@@ -270,14 +271,19 @@ impl<'a> Parser<'a> {\n             TyKind::Infer\n         } else if self.check_fn_front_matter(false, Case::Sensitive) {\n             // Function pointer type\n-            self.parse_ty_bare_fn(lo, Vec::new(), recover_return_sign)?\n+            self.parse_ty_bare_fn(lo, Vec::new(), None, recover_return_sign)?\n         } else if self.check_keyword(kw::For) {\n             // Function pointer type or bound list (trait object type) starting with a poly-trait.\n             //   `for<'lt> [unsafe] [extern \"ABI\"] fn (&'lt S) -> T`\n             //   `for<'lt> Trait1<'lt> + Trait2 + 'a`\n             let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n             if self.check_fn_front_matter(false, Case::Sensitive) {\n-                self.parse_ty_bare_fn(lo, lifetime_defs, recover_return_sign)?\n+                self.parse_ty_bare_fn(\n+                    lo,\n+                    lifetime_defs,\n+                    Some(self.prev_token.span.shrink_to_lo()),\n+                    recover_return_sign,\n+                )?\n             } else {\n                 let path = self.parse_path(PathStyle::Type)?;\n                 let parse_plus = allow_plus == AllowPlus::Yes && self.check_plus();\n@@ -519,7 +525,8 @@ impl<'a> Parser<'a> {\n     fn parse_ty_bare_fn(\n         &mut self,\n         lo: Span,\n-        params: Vec<GenericParam>,\n+        mut params: Vec<GenericParam>,\n+        param_insertion_point: Option<Span>,\n         recover_return_sign: RecoverReturnSign,\n     ) -> PResult<'a, TyKind> {\n         let inherited_vis = rustc_ast::Visibility {\n@@ -530,6 +537,9 @@ impl<'a> Parser<'a> {\n         let span_start = self.token.span;\n         let ast::FnHeader { ext, unsafety, constness, asyncness } =\n             self.parse_fn_front_matter(&inherited_vis)?;\n+        if self.may_recover() && self.token.kind == TokenKind::Lt {\n+            self.recover_fn_ptr_with_generics(lo, &mut params, param_insertion_point)?;\n+        }\n         let decl = self.parse_fn_decl(|_| false, AllowPlus::No, recover_return_sign)?;\n         let whole_span = lo.to(self.prev_token.span);\n         if let ast::Const::Yes(span) = constness {\n@@ -545,6 +555,48 @@ impl<'a> Parser<'a> {\n         Ok(TyKind::BareFn(P(BareFnTy { ext, unsafety, generic_params: params, decl, decl_span })))\n     }\n \n+    /// Recover from function pointer types with a generic parameter list (e.g. `fn<'a>(&'a str)`).\n+    fn recover_fn_ptr_with_generics(\n+        &mut self,\n+        lo: Span,\n+        params: &mut Vec<GenericParam>,\n+        param_insertion_point: Option<Span>,\n+    ) -> PResult<'a, ()> {\n+        let generics = self.parse_generics()?;\n+        let arity = generics.params.len();\n+\n+        let mut lifetimes: Vec<_> = generics\n+            .params\n+            .into_iter()\n+            .filter(|param| matches!(param.kind, ast::GenericParamKind::Lifetime))\n+            .collect();\n+\n+        let sugg = if !lifetimes.is_empty() {\n+            let snippet =\n+                lifetimes.iter().map(|param| param.ident.as_str()).intersperse(\", \").collect();\n+\n+            let (left, snippet) = if let Some(span) = param_insertion_point {\n+                (span, if params.is_empty() { snippet } else { format!(\", {snippet}\") })\n+            } else {\n+                (lo.shrink_to_lo(), format!(\"for<{snippet}> \"))\n+            };\n+\n+            Some(FnPtrWithGenericsSugg {\n+                left,\n+                snippet,\n+                right: generics.span,\n+                arity,\n+                for_param_list_exists: param_insertion_point.is_some(),\n+            })\n+        } else {\n+            None\n+        };\n+\n+        self.sess.emit_err(FnPtrWithGenerics { span: generics.span, sugg });\n+        params.append(&mut lifetimes);\n+        Ok(())\n+    }\n+\n     /// Emit an error for the given bad function pointer qualifier.\n     fn error_fn_ptr_bad_qualifier(&self, span: Span, qual_span: Span, qual: &str) {\n         self.struct_span_err(span, &format!(\"an `fn` pointer type cannot be `{}`\", qual))"}, {"sha": "31de418be5f70c92c7eee114f51bc41268588bf4", "filename": "src/test/ui/parser/recover-fn-ptr-with-generics.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a86bdb4c507f9f9651f7372075eb17009c7da4a6/src%2Ftest%2Fui%2Fparser%2Frecover-fn-ptr-with-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86bdb4c507f9f9651f7372075eb17009c7da4a6/src%2Ftest%2Fui%2Fparser%2Frecover-fn-ptr-with-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-fn-ptr-with-generics.rs?ref=a86bdb4c507f9f9651f7372075eb17009c7da4a6", "patch": "@@ -0,0 +1,31 @@\n+fn main() {\n+    type Predicate = fn<'a>(&'a str) -> bool;\n+    //~^ ERROR function pointer types may not have generic parameters\n+\n+    type Identity = fn<T>(T) -> T;\n+    //~^ ERROR function pointer types may not have generic parameters\n+    //~| ERROR cannot find type `T` in this scope\n+    //~| ERROR cannot find type `T` in this scope\n+\n+    let _: fn<const N: usize, 'e, Q, 'f>();\n+    //~^ ERROR function pointer types may not have generic parameters\n+\n+    let _: for<'outer> fn<'inner>();\n+    //~^ ERROR function pointer types may not have generic parameters\n+\n+    let _: for<> fn<'r>();\n+    //~^ ERROR function pointer types may not have generic parameters\n+\n+    type Hmm = fn<>();\n+    //~^ ERROR function pointer types may not have generic parameters\n+\n+    let _: extern fn<'a: 'static>();\n+    //~^ ERROR function pointer types may not have generic parameters\n+    //~| ERROR lifetime bounds cannot be used in this context\n+\n+    let _: for<'any> extern \"C\" fn<'u>();\n+    //~^ ERROR function pointer types may not have generic parameters\n+\n+    type QuiteBroken = fn<const>();\n+    //~^ ERROR expected identifier, found `>`\n+}"}, {"sha": "1da9c18571b9ea712b6dfe840f35bca6837ad5f5", "filename": "src/test/ui/parser/recover-fn-ptr-with-generics.stderr", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/a86bdb4c507f9f9651f7372075eb17009c7da4a6/src%2Ftest%2Fui%2Fparser%2Frecover-fn-ptr-with-generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a86bdb4c507f9f9651f7372075eb17009c7da4a6/src%2Ftest%2Fui%2Fparser%2Frecover-fn-ptr-with-generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-fn-ptr-with-generics.stderr?ref=a86bdb4c507f9f9651f7372075eb17009c7da4a6", "patch": "@@ -0,0 +1,111 @@\n+error: function pointer types may not have generic parameters\n+  --> $DIR/recover-fn-ptr-with-generics.rs:2:24\n+   |\n+LL |     type Predicate = fn<'a>(&'a str) -> bool;\n+   |                        ^^^^\n+   |\n+help: consider moving the lifetime parameter to a `for` parameter list\n+   |\n+LL -     type Predicate = fn<'a>(&'a str) -> bool;\n+LL +     type Predicate = for<'a> fn(&'a str) -> bool;\n+   |\n+\n+error: function pointer types may not have generic parameters\n+  --> $DIR/recover-fn-ptr-with-generics.rs:5:23\n+   |\n+LL |     type Identity = fn<T>(T) -> T;\n+   |                       ^^^\n+\n+error: function pointer types may not have generic parameters\n+  --> $DIR/recover-fn-ptr-with-generics.rs:10:14\n+   |\n+LL |     let _: fn<const N: usize, 'e, Q, 'f>();\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider moving the lifetime parameters to a `for` parameter list\n+   |\n+LL -     let _: fn<const N: usize, 'e, Q, 'f>();\n+LL +     let _: for<'e, 'f> fn();\n+   |\n+\n+error: function pointer types may not have generic parameters\n+  --> $DIR/recover-fn-ptr-with-generics.rs:13:26\n+   |\n+LL |     let _: for<'outer> fn<'inner>();\n+   |                          ^^^^^^^^\n+   |\n+help: consider moving the lifetime parameter to the `for` parameter list\n+   |\n+LL -     let _: for<'outer> fn<'inner>();\n+LL +     let _: for<'outer, 'inner> fn();\n+   |\n+\n+error: function pointer types may not have generic parameters\n+  --> $DIR/recover-fn-ptr-with-generics.rs:16:20\n+   |\n+LL |     let _: for<> fn<'r>();\n+   |                    ^^^^\n+   |\n+help: consider moving the lifetime parameter to the `for` parameter list\n+   |\n+LL -     let _: for<> fn<'r>();\n+LL +     let _: for<'r> fn();\n+   |\n+\n+error: function pointer types may not have generic parameters\n+  --> $DIR/recover-fn-ptr-with-generics.rs:19:18\n+   |\n+LL |     type Hmm = fn<>();\n+   |                  ^^\n+\n+error: function pointer types may not have generic parameters\n+  --> $DIR/recover-fn-ptr-with-generics.rs:22:21\n+   |\n+LL |     let _: extern fn<'a: 'static>();\n+   |                     ^^^^^^^^^^^^^\n+   |\n+help: consider moving the lifetime parameter to a `for` parameter list\n+   |\n+LL -     let _: extern fn<'a: 'static>();\n+LL +     let _: for<'a> extern fn();\n+   |\n+\n+error: function pointer types may not have generic parameters\n+  --> $DIR/recover-fn-ptr-with-generics.rs:26:35\n+   |\n+LL |     let _: for<'any> extern \"C\" fn<'u>();\n+   |                                   ^^^^\n+   |\n+help: consider moving the lifetime parameter to the `for` parameter list\n+   |\n+LL -     let _: for<'any> extern \"C\" fn<'u>();\n+LL +     let _: for<'any, 'u> extern \"C\" fn();\n+   |\n+\n+error: expected identifier, found `>`\n+  --> $DIR/recover-fn-ptr-with-generics.rs:29:32\n+   |\n+LL |     type QuiteBroken = fn<const>();\n+   |                                ^ expected identifier\n+\n+error: lifetime bounds cannot be used in this context\n+  --> $DIR/recover-fn-ptr-with-generics.rs:22:26\n+   |\n+LL |     let _: extern fn<'a: 'static>();\n+   |                          ^^^^^^^\n+\n+error[E0412]: cannot find type `T` in this scope\n+  --> $DIR/recover-fn-ptr-with-generics.rs:5:27\n+   |\n+LL |     type Identity = fn<T>(T) -> T;\n+   |                           ^ not found in this scope\n+\n+error[E0412]: cannot find type `T` in this scope\n+  --> $DIR/recover-fn-ptr-with-generics.rs:5:33\n+   |\n+LL |     type Identity = fn<T>(T) -> T;\n+   |                                 ^ not found in this scope\n+\n+error: aborting due to 12 previous errors\n+\n+For more information about this error, try `rustc --explain E0412`."}]}