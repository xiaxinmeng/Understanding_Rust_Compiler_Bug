{"sha": "e8bf0788027932a0b547819cc9edd13c40426e36", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4YmYwNzg4MDI3OTMyYTBiNTQ3ODE5Y2M5ZWRkMTNjNDA0MjZlMzY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-14T08:21:43Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-19T04:06:40Z"}, "message": "Remove the C++ lock_and_signal type\n\nA the same time this purges all runtime support needed for statically\ninitialized mutexes, moving all users over to the new Mutex type instead.", "tree": {"sha": "9f64d86fc4275a096ad2236c198451a663c665be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f64d86fc4275a096ad2236c198451a663c665be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8bf0788027932a0b547819cc9edd13c40426e36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8bf0788027932a0b547819cc9edd13c40426e36", "html_url": "https://github.com/rust-lang/rust/commit/e8bf0788027932a0b547819cc9edd13c40426e36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8bf0788027932a0b547819cc9edd13c40426e36/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24eb1b445dd878c12ca6503a9fa040179b94e614", "url": "https://api.github.com/repos/rust-lang/rust/commits/24eb1b445dd878c12ca6503a9fa040179b94e614", "html_url": "https://github.com/rust-lang/rust/commit/24eb1b445dd878c12ca6503a9fa040179b94e614"}], "stats": {"total": 628, "additions": 92, "deletions": 536}, "files": [{"sha": "26e4222e4ebd7b8b359cbdce77f8e9abb07d27ed", "filename": "mk/rt.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8bf0788027932a0b547819cc9edd13c40426e36/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/e8bf0788027932a0b547819cc9edd13c40426e36/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=e8bf0788027932a0b547819cc9edd13c40426e36", "patch": "@@ -90,7 +90,6 @@ endif\n endif\n \n RUNTIME_CXXS_$(1)_$(2) := \\\n-              rt/sync/lock_and_signal.cpp \\\n               rt/rust_builtin.cpp \\\n               rt/rust_upcall.cpp \\\n               rt/miniz.cpp \\"}, {"sha": "3ea6e18f9427c6a4eea973087f59311c08f0c46b", "filename": "src/libstd/os.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e8bf0788027932a0b547819cc9edd13c40426e36/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bf0788027932a0b547819cc9edd13c40426e36/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=e8bf0788027932a0b547819cc9edd13c40426e36", "patch": "@@ -138,21 +138,19 @@ Accessing environment variables is not generally threadsafe.\n Serialize access through a global lock.\n */\n fn with_env_lock<T>(f: &fn() -> T) -> T {\n+    use unstable::mutex::{Mutex, MUTEX_INIT};\n     use unstable::finally::Finally;\n \n+    static mut lock: Mutex = MUTEX_INIT;\n+\n     unsafe {\n         return do (|| {\n-            rust_take_env_lock();\n+            lock.lock();\n             f()\n         }).finally {\n-            rust_drop_env_lock();\n+            lock.unlock();\n         };\n     }\n-\n-    extern {\n-        fn rust_take_env_lock();\n-        fn rust_drop_env_lock();\n-    }\n }\n \n /// Returns a vector of (variable, value) pairs for all the environment"}, {"sha": "b9238224d6e98bd19e33125fbb503e9fbb8e0182", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e8bf0788027932a0b547819cc9edd13c40426e36/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bf0788027932a0b547819cc9edd13c40426e36/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=e8bf0788027932a0b547819cc9edd13c40426e36", "patch": "@@ -21,32 +21,42 @@\n //! FIXME #7756: This has a lot of C glue for lack of globals.\n \n use option::Option;\n+#[cfg(test)] use option::{Some, None};\n+#[cfg(test)] use realstd;\n+#[cfg(test)] use realargs = realstd::rt::args;\n \n /// One-time global initialization.\n-pub unsafe fn init(argc: int, argv: **u8) {\n-    imp::init(argc, argv)\n-}\n+#[cfg(not(test))]\n+pub unsafe fn init(argc: int, argv: **u8) { imp::init(argc, argv) }\n+#[cfg(test)]\n+pub unsafe fn init(argc: int, argv: **u8) { realargs::init(argc, argv) }\n \n /// One-time global cleanup.\n-pub fn cleanup() {\n-    imp::cleanup()\n-}\n+#[cfg(not(test))] pub fn cleanup() { imp::cleanup() }\n+#[cfg(test)]      pub fn cleanup() { realargs::cleanup() }\n \n /// Take the global arguments from global storage.\n-pub fn take() -> Option<~[~str]> {\n-    imp::take()\n+#[cfg(not(test))] pub fn take() -> Option<~[~str]> { imp::take() }\n+#[cfg(test)]      pub fn take() -> Option<~[~str]> {\n+    match realargs::take() {\n+        realstd::option::Some(a) => Some(a),\n+        realstd::option::None => None,\n+    }\n }\n \n /// Give the global arguments to global storage.\n ///\n /// It is an error if the arguments already exist.\n-pub fn put(args: ~[~str]) {\n-    imp::put(args)\n-}\n+#[cfg(not(test))] pub fn put(args: ~[~str]) { imp::put(args) }\n+#[cfg(test)]      pub fn put(args: ~[~str]) { realargs::put(args) }\n \n /// Make a clone of the global arguments.\n-pub fn clone() -> Option<~[~str]> {\n-    imp::clone()\n+#[cfg(not(test))] pub fn clone() -> Option<~[~str]> { imp::clone() }\n+#[cfg(test)]      pub fn clone() -> Option<~[~str]> {\n+    match realargs::clone() {\n+        realstd::option::Some(a) => Some(a),\n+        realstd::option::None => None,\n+    }\n }\n \n #[cfg(target_os = \"linux\")]\n@@ -58,9 +68,12 @@ mod imp {\n     use iter::Iterator;\n     use str;\n     use unstable::finally::Finally;\n+    use unstable::mutex::{Mutex, MUTEX_INIT};\n     use util;\n     use vec;\n \n+    static mut global_args_ptr: uint = 0;\n+\n     pub unsafe fn init(argc: int, argv: **u8) {\n         let args = load_argc_and_argv(argc, argv);\n         put(args);\n@@ -94,20 +107,22 @@ mod imp {\n     }\n \n     fn with_lock<T>(f: &fn() -> T) -> T {\n+        static mut lock: Mutex = MUTEX_INIT;\n+\n         do (|| {\n             unsafe {\n-                rust_take_global_args_lock();\n+                lock.lock();\n                 f()\n             }\n         }).finally {\n             unsafe {\n-                rust_drop_global_args_lock();\n+                lock.unlock();\n             }\n         }\n     }\n \n     fn get_global_ptr() -> *mut Option<~~[~str]> {\n-        unsafe { rust_get_global_args_ptr() }\n+        unsafe { cast::transmute(&global_args_ptr) }\n     }\n \n     // Copied from `os`.\n@@ -117,12 +132,6 @@ mod imp {\n         }\n     }\n \n-    extern {\n-        fn rust_take_global_args_lock();\n-        fn rust_drop_global_args_lock();\n-        fn rust_get_global_args_ptr() -> *mut Option<~~[~str]>;\n-    }\n-\n     #[cfg(test)]\n     mod tests {\n         use option::{Some, None};"}, {"sha": "d5d1931a21725595affa8ba3580bf612b12d8f66", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e8bf0788027932a0b547819cc9edd13c40426e36/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bf0788027932a0b547819cc9edd13c40426e36/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=e8bf0788027932a0b547819cc9edd13c40426e36", "patch": "@@ -21,17 +21,23 @@ use ptr;\n use cell::Cell;\n use option::{Option, Some, None};\n use unstable::finally::Finally;\n+use unstable::mutex::{Mutex, MUTEX_INIT};\n use tls = rt::thread_local_storage;\n \n static mut RT_TLS_KEY: tls::Key = -1;\n \n /// Initialize the TLS key. Other ops will fail if this isn't executed first.\n pub fn init_tls_key() {\n+    static mut lock: Mutex = MUTEX_INIT;\n+    static mut initialized: bool = false;\n+\n     unsafe {\n-        rust_initialize_rt_tls_key(&mut RT_TLS_KEY);\n-        extern {\n-            fn rust_initialize_rt_tls_key(key: *mut tls::Key);\n+        lock.lock();\n+        if !initialized {\n+            tls::create(&mut RT_TLS_KEY);\n+            initialized = true;\n         }\n+        lock.unlock();\n     }\n }\n "}, {"sha": "c1a7893f5a5c1c85c59f6382d02c27a58addc6ed", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e8bf0788027932a0b547819cc9edd13c40426e36/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bf0788027932a0b547819cc9edd13c40426e36/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=e8bf0788027932a0b547819cc9edd13c40426e36", "patch": "@@ -14,7 +14,6 @@ use cell::Cell;\n use clone::Clone;\n use container::Container;\n use iter::{Iterator, range};\n-use libc;\n use option::{Some, None};\n use os;\n use path::GenericPath;\n@@ -361,11 +360,16 @@ pub fn cleanup_task(mut task: ~Task) {\n \n /// Get a port number, starting at 9600, for use in tests\n pub fn next_test_port() -> u16 {\n+    use unstable::mutex::{Mutex, MUTEX_INIT};\n+    static mut lock: Mutex = MUTEX_INIT;\n+    static mut next_offset: u16 = 0;\n     unsafe {\n-        return rust_dbg_next_port(base_port() as libc::uintptr_t) as u16;\n-    }\n-    extern {\n-        fn rust_dbg_next_port(base: libc::uintptr_t) -> libc::uintptr_t;\n+        let base = base_port();\n+        lock.lock();\n+        let ret = base + next_offset;\n+        next_offset += 1;\n+        lock.unlock();\n+        return ret;\n     }\n }\n \n@@ -395,13 +399,13 @@ The bots run multiple builds at the same time, and these builds\n all want to use ports. This function figures out which workspace\n it is running in and assigns a port range based on it.\n */\n-fn base_port() -> uint {\n+fn base_port() -> u16 {\n     use os;\n     use str::StrSlice;\n     use vec::ImmutableVector;\n \n-    let base = 9600u;\n-    let range = 1000;\n+    let base = 9600u16;\n+    let range = 1000u16;\n \n     let bases = [\n         (\"32-opt\", base + range * 1),"}, {"sha": "5a2251eaa461e5a446ca37eb9aaa7ba4c881d7a0", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e8bf0788027932a0b547819cc9edd13c40426e36/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bf0788027932a0b547819cc9edd13c40426e36/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=e8bf0788027932a0b547819cc9edd13c40426e36", "patch": "@@ -1141,22 +1141,10 @@ fn test_spawn_sched_childs_on_default_sched() {\n     po.recv();\n }\n \n-#[cfg(test)]\n-mod testrt {\n-    use libc;\n-\n-    extern {\n-        pub fn rust_dbg_lock_create() -> *libc::c_void;\n-        pub fn rust_dbg_lock_destroy(lock: *libc::c_void);\n-        pub fn rust_dbg_lock_lock(lock: *libc::c_void);\n-        pub fn rust_dbg_lock_unlock(lock: *libc::c_void);\n-        pub fn rust_dbg_lock_wait(lock: *libc::c_void);\n-        pub fn rust_dbg_lock_signal(lock: *libc::c_void);\n-    }\n-}\n-\n #[test]\n fn test_spawn_sched_blocking() {\n+    use unstable::mutex::Mutex;\n+\n     unsafe {\n \n         // Testing that a task in one scheduler can block in foreign code\n@@ -1165,16 +1153,18 @@ fn test_spawn_sched_blocking() {\n             let (start_po, start_ch) = stream();\n             let (fin_po, fin_ch) = stream();\n \n-            let lock = testrt::rust_dbg_lock_create();\n+            let mut lock = Mutex::new();\n+            let lock2 = Cell::new(lock.clone());\n \n             do spawn_sched(SingleThreaded) {\n-                testrt::rust_dbg_lock_lock(lock);\n+                let mut lock = lock2.take();\n+                lock.lock();\n \n                 start_ch.send(());\n \n                 // Block the scheduler thread\n-                testrt::rust_dbg_lock_wait(lock);\n-                testrt::rust_dbg_lock_unlock(lock);\n+                lock.wait();\n+                lock.unlock();\n \n                 fin_ch.send(());\n             };\n@@ -1201,11 +1191,11 @@ fn test_spawn_sched_blocking() {\n             let child_ch = setup_po.recv();\n             child_ch.send(20);\n             pingpong(&parent_po, &child_ch);\n-            testrt::rust_dbg_lock_lock(lock);\n-            testrt::rust_dbg_lock_signal(lock);\n-            testrt::rust_dbg_lock_unlock(lock);\n+            lock.lock();\n+            lock.signal();\n+            lock.unlock();\n             fin_po.recv();\n-            testrt::rust_dbg_lock_destroy(lock);\n+            lock.destroy();\n         }\n     }\n }"}, {"sha": "e0d284a32df1ef47524a9bb188378df8b22e6a5a", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e8bf0788027932a0b547819cc9edd13c40426e36/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bf0788027932a0b547819cc9edd13c40426e36/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=e8bf0788027932a0b547819cc9edd13c40426e36", "patch": "@@ -154,14 +154,17 @@ pub mod dl {\n     }\n \n     pub fn check_for_errors_in<T>(f: &fn()->T) -> Result<T, ~str> {\n+        use unstable::mutex::{Mutex, MUTEX_INIT};\n+        static mut lock: Mutex = MUTEX_INIT;\n+\n         unsafe {\n             // dlerror isn't thread safe, so we need to lock around this entire\n             // sequence. `atomically` asserts that we don't do anything that\n             // would cause this task to be descheduled, which could deadlock\n             // the scheduler if it happens while the lock is held.\n             // FIXME #9105 use a Rust mutex instead of C++ mutexes.\n             do atomically {\n-                rust_take_dlerror_lock();\n+                lock.lock();\n                 let _old_error = dlerror();\n \n                 let result = f();\n@@ -172,7 +175,7 @@ pub mod dl {\n                 } else {\n                     Err(str::raw::from_c_str(last_error))\n                 };\n-                rust_drop_dlerror_lock();\n+                lock.unlock();\n                 ret\n             }\n         }\n@@ -192,11 +195,6 @@ pub mod dl {\n         Local = 0,\n     }\n \n-    extern {\n-        fn rust_take_dlerror_lock();\n-        fn rust_drop_dlerror_lock();\n-    }\n-\n     #[link_name = \"dl\"]\n     extern {\n         fn dlopen(filename: *libc::c_char, flag: libc::c_int) -> *libc::c_void;"}, {"sha": "3423b995fda7854918b8aa03e962868d1b6df82e", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e8bf0788027932a0b547819cc9edd13c40426e36/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bf0788027932a0b547819cc9edd13c40426e36/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=e8bf0788027932a0b547819cc9edd13c40426e36", "patch": "@@ -11,12 +11,12 @@\n use cast;\n use cell::Cell;\n use comm;\n-use libc;\n use ptr;\n use option::{Option,Some,None};\n use task;\n use unstable::atomics::{AtomicOption,AtomicUint,Acquire,Release,Relaxed,SeqCst};\n use unstable::finally::Finally;\n+use unstable::mutex::Mutex;\n use ops::Drop;\n use clone::Clone;\n use kinds::Send;\n@@ -319,17 +319,14 @@ pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n     }\n }\n \n-#[allow(non_camel_case_types)] // runtime type\n-type rust_little_lock = *libc::c_void;\n-\n pub struct LittleLock {\n-    priv l: rust_little_lock,\n+    priv l: Mutex,\n }\n \n impl Drop for LittleLock {\n     fn drop(&mut self) {\n         unsafe {\n-            rust_destroy_little_lock(self.l);\n+            self.l.destroy();\n         }\n     }\n }\n@@ -338,29 +335,31 @@ impl LittleLock {\n     pub fn new() -> LittleLock {\n         unsafe {\n             LittleLock {\n-                l: rust_create_little_lock()\n+                l: Mutex::new()\n             }\n         }\n     }\n \n     pub unsafe fn lock<T>(&self, f: &fn() -> T) -> T {\n+        let this = cast::transmute_mut(self);\n         do atomically {\n-            rust_lock_little_lock(self.l);\n+            this.l.lock();\n             do (|| {\n                 f()\n             }).finally {\n-                rust_unlock_little_lock(self.l);\n+                this.l.unlock();\n             }\n         }\n     }\n \n     pub unsafe fn try_lock<T>(&self, f: &fn() -> T) -> Option<T> {\n+        let this = cast::transmute_mut(self);\n         do atomically {\n-            if rust_trylock_little_lock(self.l) {\n+            if this.l.trylock() {\n                 Some(do (|| {\n                     f()\n                 }).finally {\n-                    rust_unlock_little_lock(self.l);\n+                    this.l.unlock();\n                 })\n             } else {\n                 None\n@@ -369,18 +368,20 @@ impl LittleLock {\n     }\n \n     pub unsafe fn signal(&self) {\n-        rust_signal_little_lock(self.l);\n+        let this = cast::transmute_mut(self);\n+        this.l.signal();\n     }\n \n     pub unsafe fn lock_and_wait(&self, f: &fn() -> bool) {\n+        let this = cast::transmute_mut(self);\n         do atomically {\n-            rust_lock_little_lock(self.l);\n+            this.l.lock();\n             do (|| {\n                 if f() {\n-                    rust_wait_little_lock(self.l);\n+                    this.l.wait();\n                 }\n             }).finally {\n-                rust_unlock_little_lock(self.l);\n+                this.l.unlock();\n             }\n         }\n     }\n@@ -489,16 +490,6 @@ impl<T:Send> Exclusive<T> {\n     }\n }\n \n-extern {\n-    fn rust_create_little_lock() -> rust_little_lock;\n-    fn rust_destroy_little_lock(lock: rust_little_lock);\n-    fn rust_trylock_little_lock(lock: rust_little_lock) -> bool;\n-    fn rust_lock_little_lock(lock: rust_little_lock);\n-    fn rust_unlock_little_lock(lock: rust_little_lock);\n-    fn rust_signal_little_lock(lock: rust_little_lock);\n-    fn rust_wait_little_lock(lock: rust_little_lock);\n-}\n-\n #[cfg(test)]\n mod tests {\n     use cell::Cell;"}, {"sha": "31ab96f91b9cfd76c7b54e0502dfac267890f26b", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 1, "deletions": 106, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/e8bf0788027932a0b547819cc9edd13c40426e36/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e8bf0788027932a0b547819cc9edd13c40426e36/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=e8bf0788027932a0b547819cc9edd13c40426e36", "patch": "@@ -10,7 +10,7 @@\n \n /* Foreign builtins. */\n \n-#include \"sync/lock_and_signal.h\"\n+#include \"rust_globals.h\"\n #include \"vg/valgrind.h\"\n \n #include <time.h>\n@@ -379,41 +379,6 @@ rust_mktime(rust_tm* timeptr) {\n     return mktime(&t);\n }\n \n-extern \"C\" lock_and_signal*\n-rust_create_little_lock() {\n-    return new lock_and_signal();\n-}\n-\n-extern \"C\" void\n-rust_destroy_little_lock(lock_and_signal *lock) {\n-    delete lock;\n-}\n-\n-extern \"C\" void\n-rust_lock_little_lock(lock_and_signal *lock) {\n-    lock->lock();\n-}\n-\n-extern \"C\" bool\n-rust_trylock_little_lock(lock_and_signal *lock) {\n-    return lock->try_lock();\n-}\n-\n-extern \"C\" void\n-rust_unlock_little_lock(lock_and_signal *lock) {\n-    lock->unlock();\n-}\n-\n-extern \"C\" void\n-rust_wait_little_lock(lock_and_signal *lock) {\n-    lock->wait();\n-}\n-\n-extern \"C\" void\n-rust_signal_little_lock(lock_and_signal *lock) {\n-    lock->signal();\n-}\n-\n #ifndef _WIN32\n #include <sys/types.h>\n #include <dirent.h>\n@@ -440,34 +405,6 @@ rust_readdir() {\n \n #endif\n \n-#ifndef _WIN32\n-typedef pthread_key_t tls_key;\n-#else\n-typedef DWORD tls_key;\n-#endif\n-\n-// Initialize the TLS key used by the new scheduler\n-extern \"C\" CDECL void\n-rust_initialize_rt_tls_key(tls_key *key) {\n-\n-    static lock_and_signal init_lock;\n-    static bool initialized = false;\n-\n-    scoped_lock with(init_lock);\n-\n-    if (!initialized) {\n-\n-#ifndef _WIN32\n-        assert(!pthread_key_create(key, NULL));\n-#else\n-        *key = TlsAlloc();\n-        assert(*key != TLS_OUT_OF_INDEXES);\n-#endif\n-\n-        initialized = true;\n-    }\n-}\n-\n typedef void *(rust_try_fn)(void*, void*);\n \n extern \"C\" CDECL uintptr_t\n@@ -538,48 +475,6 @@ rust_get_num_cpus() {\n     return get_num_cpus();\n }\n \n-static lock_and_signal global_args_lock;\n-static uintptr_t global_args_ptr = 0;\n-\n-extern \"C\" CDECL void\n-rust_take_global_args_lock() {\n-    global_args_lock.lock();\n-}\n-\n-extern \"C\" CDECL void\n-rust_drop_global_args_lock() {\n-    global_args_lock.unlock();\n-}\n-\n-extern \"C\" CDECL uintptr_t*\n-rust_get_global_args_ptr() {\n-    return &global_args_ptr;\n-}\n-\n-static lock_and_signal env_lock;\n-\n-extern \"C\" CDECL void\n-rust_take_env_lock() {\n-    env_lock.lock();\n-}\n-\n-extern \"C\" CDECL void\n-rust_drop_env_lock() {\n-    env_lock.unlock();\n-}\n-\n-static lock_and_signal dlerror_lock;\n-\n-extern \"C\" CDECL void\n-rust_take_dlerror_lock() {\n-    dlerror_lock.lock();\n-}\n-\n-extern \"C\" CDECL void\n-rust_drop_dlerror_lock() {\n-    dlerror_lock.unlock();\n-}\n-\n extern \"C\" CDECL unsigned int\n rust_valgrind_stack_register(void *start, void *end) {\n   return VALGRIND_STACK_REGISTER(start, end);"}, {"sha": "bf5fb059e767390451956c64e2b877974b7bfe92", "filename": "src/rt/rust_test_helpers.cpp", "status": "modified", "additions": 1, "deletions": 47, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e8bf0788027932a0b547819cc9edd13c40426e36/src%2Frt%2Frust_test_helpers.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e8bf0788027932a0b547819cc9edd13c40426e36/src%2Frt%2Frust_test_helpers.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_test_helpers.cpp?ref=e8bf0788027932a0b547819cc9edd13c40426e36", "patch": "@@ -10,7 +10,7 @@\n \n // Helper functions used only in tests\n \n-#include \"sync/lock_and_signal.h\"\n+#include \"rust_globals.h\"\n \n // These functions are used in the unit tests for C ABI calls.\n \n@@ -34,41 +34,6 @@ rust_dbg_extern_identity_u8(char u) {\n     return u;\n }\n \n-extern \"C\" CDECL lock_and_signal *\n-rust_dbg_lock_create() {\n-    return new lock_and_signal();\n-}\n-\n-extern \"C\" CDECL void\n-rust_dbg_lock_destroy(lock_and_signal *lock) {\n-    assert(lock);\n-    delete lock;\n-}\n-\n-extern \"C\" CDECL void\n-rust_dbg_lock_lock(lock_and_signal *lock) {\n-    assert(lock);\n-    lock->lock();\n-}\n-\n-extern \"C\" CDECL void\n-rust_dbg_lock_unlock(lock_and_signal *lock) {\n-    assert(lock);\n-    lock->unlock();\n-}\n-\n-extern \"C\" CDECL void\n-rust_dbg_lock_wait(lock_and_signal *lock) {\n-    assert(lock);\n-    lock->wait();\n-}\n-\n-extern \"C\" CDECL void\n-rust_dbg_lock_signal(lock_and_signal *lock) {\n-    assert(lock);\n-    lock->signal();\n-}\n-\n typedef void *(*dbg_callback)(void*);\n \n extern \"C\" CDECL void *\n@@ -160,17 +125,6 @@ rust_dbg_extern_identity_TwoDoubles(TwoDoubles u) {\n     return u;\n }\n \n-// Generates increasing port numbers for network testing\n-extern \"C\" CDECL uintptr_t\n-rust_dbg_next_port(uintptr_t base_port) {\n-  static lock_and_signal dbg_port_lock;\n-  static uintptr_t next_offset = 0;\n-  scoped_lock with(dbg_port_lock);\n-  uintptr_t this_port = base_port + next_offset;\n-  next_offset += 1;\n-  return this_port;\n-}\n-\n extern \"C\" CDECL intptr_t\n rust_get_test_int() {\n   return 1;"}, {"sha": "c5b5e7f2c467a374c970b2d11e69d58331d8f425", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e8bf0788027932a0b547819cc9edd13c40426e36/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/e8bf0788027932a0b547819cc9edd13c40426e36/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=e8bf0788027932a0b547819cc9edd13c40426e36", "patch": "@@ -26,21 +26,8 @@ rust_win32_rand_gen\n rust_win32_rand_release\n upcall_rust_personality\n upcall_reset_stack_limit\n-rust_dbg_lock_create\n-rust_dbg_lock_destroy\n-rust_dbg_lock_lock\n-rust_dbg_lock_unlock\n-rust_dbg_lock_wait\n-rust_dbg_lock_signal\n rust_dbg_call\n rust_dbg_do_nothing\n-rust_create_little_lock\n-rust_destroy_little_lock\n-rust_lock_little_lock\n-rust_trylock_little_lock\n-rust_unlock_little_lock\n-rust_signal_little_lock\n-rust_wait_little_lock\n tdefl_compress_mem_to_heap\n tinfl_decompress_mem_to_heap\n rust_swap_registers\n@@ -59,19 +46,12 @@ rust_dbg_extern_return_TwoU32s\n rust_dbg_extern_return_TwoU64s\n rust_dbg_extern_identity_double\n rust_dbg_extern_identity_u8\n-rust_initialize_rt_tls_key\n-rust_dbg_next_port\n rust_try\n rust_begin_unwind\n rust_valgrind_stack_register\n rust_valgrind_stack_deregister\n-rust_take_env_lock\n-rust_drop_env_lock\n rust_running_on_valgrind\n rust_get_num_cpus\n-rust_get_global_args_ptr\n-rust_take_global_args_lock\n-rust_drop_global_args_lock\n rust_get_test_int\n rust_pthread_mutex_t_size\n rust_pthread_cond_t_size"}, {"sha": "fcf8ab5d88b390f98729aafb5e4f0f7f7c5440d8", "filename": "src/rt/sync/lock_and_signal.cpp", "status": "removed", "additions": 0, "deletions": 205, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/24eb1b445dd878c12ca6503a9fa040179b94e614/src%2Frt%2Fsync%2Flock_and_signal.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/24eb1b445dd878c12ca6503a9fa040179b94e614/src%2Frt%2Fsync%2Flock_and_signal.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_and_signal.cpp?ref=24eb1b445dd878c12ca6503a9fa040179b94e614", "patch": "@@ -1,205 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#include \"../rust_globals.h\"\n-#include \"lock_and_signal.h\"\n-\n-/*\n- * A \"lock-and-signal\" pair. These are necessarily coupled on pthreads\n- * systems, and artificially coupled (by this file) on win32. Put\n- * together here to minimize ifdefs elsewhere; you must use them as\n- * if you're using a pthreads cvar+mutex pair.\n- */\n-\n-// FIXME (#2683): This is not a portable way of specifying an invalid\n-// pthread_t\n-#define INVALID_THREAD 0\n-\n-\n-#if defined(__WIN32__)\n-lock_and_signal::lock_and_signal()\n-#if defined(DEBUG_LOCKS)\n-    : _holding_thread(INVALID_THREAD)\n-#endif\n-{\n-    _event = CreateEvent(NULL, FALSE, FALSE, NULL);\n-\n-    // If a CRITICAL_SECTION is not initialized with a spin count, it will\n-    // default to 0, even on multi-processor systems. MSDN suggests using\n-    // 4000. On single-processor systems, the spin count parameter is ignored\n-    // and the critical section's spin count defaults to 0.\n-    const DWORD SPIN_COUNT = 4000;\n-    CHECKED(!InitializeCriticalSectionAndSpinCount(&_cs, SPIN_COUNT));\n-\n-    // FIXME #2893 Consider checking\n-    // GetProcAddress(\"InitializeCriticalSectionEx\")\n-    // so Windows >= Vista we can use CRITICAL_SECTION_NO_DEBUG_INFO to avoid\n-    // allocating CRITICAL_SECTION debug info that is never released. See:\n-    // http://stackoverflow.com/questions/804848/\n-    //        critical-sections-leaking-memory-on-vista-win2008#889853\n-}\n-\n-#else\n-lock_and_signal::lock_and_signal()\n-#if defined(DEBUG_LOCKS)\n-    : _holding_thread(INVALID_THREAD)\n-#endif\n-{\n-    CHECKED(pthread_cond_init(&_cond, NULL));\n-    CHECKED(pthread_mutex_init(&_mutex, NULL));\n-}\n-#endif\n-\n-lock_and_signal::~lock_and_signal() {\n-#if defined(__WIN32__)\n-    CloseHandle(_event);\n-    DeleteCriticalSection(&_cs);\n-#else\n-    CHECKED(pthread_cond_destroy(&_cond));\n-    CHECKED(pthread_mutex_destroy(&_mutex));\n-#endif\n-}\n-\n-void lock_and_signal::lock() {\n-    must_not_have_lock();\n-#if defined(__WIN32__)\n-    EnterCriticalSection(&_cs);\n-#if defined(DEBUG_LOCKS)\n-    _holding_thread = GetCurrentThreadId();\n-#endif\n-#else\n-    CHECKED(pthread_mutex_lock(&_mutex));\n-#if defined(DEBUG_LOCKS)\n-    _holding_thread = pthread_self();\n-#endif\n-#endif\n-}\n-\n-bool lock_and_signal::try_lock() {\n-    must_not_have_lock();\n-#if defined(__WIN32__)\n-    if (TryEnterCriticalSection(&_cs)) {\n-#if defined(DEBUG_LOCKS)\n-        _holding_thread = GetCurrentThreadId();\n-#endif\n-        return true;\n-    }\n-#else // non-windows\n-    int trylock = pthread_mutex_trylock(&_mutex);\n-    if (trylock == 0) {\n-#if defined(DEBUG_LOCKS)\n-        _holding_thread = pthread_self();\n-#endif\n-        return true;\n-    } else if (trylock == EBUSY) {\n-        // EBUSY means lock was already held by someone else\n-        return false;\n-    }\n-    // abort on all other errors\n-    CHECKED(trylock);\n-#endif\n-    return false;\n-}\n-\n-void lock_and_signal::unlock() {\n-    must_have_lock();\n-#if defined(DEBUG_LOCKS)\n-    _holding_thread = INVALID_THREAD;\n-#endif\n-#if defined(__WIN32__)\n-    LeaveCriticalSection(&_cs);\n-#else\n-    CHECKED(pthread_mutex_unlock(&_mutex));\n-#endif\n-}\n-\n-/**\n- * Wait indefinitely until condition is signaled.\n- */\n-void lock_and_signal::wait() {\n-    must_have_lock();\n-#if defined(DEBUG_LOCKS)\n-    _holding_thread = INVALID_THREAD;\n-#endif\n-#if defined(__WIN32__)\n-    LeaveCriticalSection(&_cs);\n-    WaitForSingleObject(_event, INFINITE);\n-    EnterCriticalSection(&_cs);\n-    must_not_be_locked();\n-#if defined(DEBUG_LOCKS)\n-    _holding_thread = GetCurrentThreadId();\n-#endif\n-#else\n-    CHECKED(pthread_cond_wait(&_cond, &_mutex));\n-    must_not_be_locked();\n-#if defined(DEBUG_LOCKS)\n-    _holding_thread = pthread_self();\n-#endif\n-#endif\n-}\n-\n-/**\n- * Signal condition, and resume the waiting thread.\n- */\n-void lock_and_signal::signal() {\n-#if defined(__WIN32__)\n-    SetEvent(_event);\n-#else\n-    CHECKED(pthread_cond_signal(&_cond));\n-#endif\n-}\n-\n-#if defined(DEBUG_LOCKS)\n-bool lock_and_signal::lock_held_by_current_thread()\n-{\n-#if defined(__WIN32__)\n-    return _holding_thread == GetCurrentThreadId();\n-#else\n-    return pthread_equal(_holding_thread, pthread_self());\n-#endif\n-}\n-#endif\n-\n-#if defined(DEBUG_LOCKS)\n-void lock_and_signal::must_have_lock() {\n-    assert(lock_held_by_current_thread() && \"must have lock\");\n-}\n-void lock_and_signal::must_not_have_lock() {\n-    assert(!lock_held_by_current_thread() && \"must not have lock\");\n-}\n-void lock_and_signal::must_not_be_locked() {\n-}\n-#else\n-void lock_and_signal::must_have_lock() { }\n-void lock_and_signal::must_not_have_lock() { }\n-void lock_and_signal::must_not_be_locked() { }\n-#endif\n-\n-scoped_lock::scoped_lock(lock_and_signal &lock)\n-    : lock(lock)\n-{\n-    lock.lock();\n-}\n-\n-scoped_lock::~scoped_lock()\n-{\n-    lock.unlock();\n-}\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:"}, {"sha": "45e1f7198516c9cd7537c784e142addfe576d13d", "filename": "src/rt/sync/lock_and_signal.h", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/24eb1b445dd878c12ca6503a9fa040179b94e614/src%2Frt%2Fsync%2Flock_and_signal.h", "raw_url": "https://github.com/rust-lang/rust/raw/24eb1b445dd878c12ca6503a9fa040179b94e614/src%2Frt%2Fsync%2Flock_and_signal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_and_signal.h?ref=24eb1b445dd878c12ca6503a9fa040179b94e614", "patch": "@@ -1,63 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#ifndef LOCK_AND_SIGNAL_H\n-#define LOCK_AND_SIGNAL_H\n-\n-#include \"rust_globals.h\"\n-\n-#ifndef RUST_NDEBUG\n-#define DEBUG_LOCKS\n-#endif\n-\n-class lock_and_signal {\n-#if defined(__WIN32__)\n-    HANDLE _event;\n-    CRITICAL_SECTION _cs;\n-#if defined(DEBUG_LOCKS)\n-    DWORD _holding_thread;\n-#endif\n-#else\n-    pthread_cond_t _cond;\n-    pthread_mutex_t _mutex;\n-#if defined(DEBUG_LOCKS)\n-    pthread_t _holding_thread;\n-#endif\n-#endif\n-\n-#if defined(DEBUG_LOCKS)\n-    bool lock_held_by_current_thread();\n-#endif\n-\n-    void must_not_be_locked();\n-\n-public:\n-    lock_and_signal();\n-    virtual ~lock_and_signal();\n-\n-    void lock();\n-    bool try_lock();\n-    void unlock();\n-    void wait();\n-    void signal();\n-\n-    void must_have_lock();\n-    void must_not_have_lock();\n-};\n-\n-class scoped_lock {\n-  lock_and_signal &lock;\n-\n-public:\n-  scoped_lock(lock_and_signal &lock);\n-  ~scoped_lock();\n-};\n-\n-#endif /* LOCK_AND_SIGNAL_H */"}]}