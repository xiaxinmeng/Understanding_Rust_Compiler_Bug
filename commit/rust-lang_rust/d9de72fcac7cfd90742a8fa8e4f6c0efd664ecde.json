{"sha": "d9de72fcac7cfd90742a8fa8e4f6c0efd664ecde", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5ZGU3MmZjYWM3Y2ZkOTA3NDJhOGZhOGU0ZjZjMGVmZDY2NGVjZGU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-22T16:38:59Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-22T16:39:07Z"}, "message": "miri: restrict fn argument punning to Rust ABI", "tree": {"sha": "622574250eb92c71b5536be33803bc527643b5e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/622574250eb92c71b5536be33803bc527643b5e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9de72fcac7cfd90742a8fa8e4f6c0efd664ecde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9de72fcac7cfd90742a8fa8e4f6c0efd664ecde", "html_url": "https://github.com/rust-lang/rust/commit/d9de72fcac7cfd90742a8fa8e4f6c0efd664ecde", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9de72fcac7cfd90742a8fa8e4f6c0efd664ecde/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1ca4f63f4cee0c468325572b86f00badce70ad7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1ca4f63f4cee0c468325572b86f00badce70ad7", "html_url": "https://github.com/rust-lang/rust/commit/e1ca4f63f4cee0c468325572b86f00badce70ad7"}], "stats": {"total": 33, "additions": 21, "deletions": 12}, "files": [{"sha": "11c44fc943daa37831e1725ea29974c068448bd7", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d9de72fcac7cfd90742a8fa8e4f6c0efd664ecde/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9de72fcac7cfd90742a8fa8e4f6c0efd664ecde/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=d9de72fcac7cfd90742a8fa8e4f6c0efd664ecde", "patch": "@@ -182,19 +182,24 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     }\n \n     fn check_argument_compat(\n+        rust_abi: bool,\n         caller: TyLayout<'tcx>,\n         callee: TyLayout<'tcx>,\n     ) -> bool {\n         if caller.ty == callee.ty {\n             // No question\n             return true;\n         }\n+        if !rust_abi {\n+            // Don't risk anything\n+            return false;\n+        }\n         // Compare layout\n         match (&caller.abi, &callee.abi) {\n+            // Different valid ranges are okay (once we enforce validity,\n+            // that will take care to make it UB to leave the range, just\n+            // like for transmute).\n             (layout::Abi::Scalar(ref caller), layout::Abi::Scalar(ref callee)) =>\n-                // Different valid ranges are okay (once we enforce validity,\n-                // that will take care to make it UB to leave the range, just\n-                // like for transmute).\n                 caller.value == callee.value,\n             (layout::Abi::ScalarPair(ref caller1, ref caller2),\n              layout::Abi::ScalarPair(ref callee1, ref callee2)) =>\n@@ -207,22 +212,22 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     /// Pass a single argument, checking the types for compatibility.\n     fn pass_argument(\n         &mut self,\n-        skip_zst: bool,\n+        rust_abi: bool,\n         caller_arg: &mut impl Iterator<Item=OpTy<'tcx, M::PointerTag>>,\n         callee_arg: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n-        if skip_zst && callee_arg.layout.is_zst() {\n+        if rust_abi && callee_arg.layout.is_zst() {\n             // Nothing to do.\n             trace!(\"Skipping callee ZST\");\n             return Ok(());\n         }\n         let caller_arg = caller_arg.next()\n             .ok_or_else(|| EvalErrorKind::FunctionArgCountMismatch)?;\n-        if skip_zst {\n+        if rust_abi {\n             debug_assert!(!caller_arg.layout.is_zst(), \"ZSTs must have been already filtered out\");\n         }\n         // Now, check\n-        if !Self::check_argument_compat(caller_arg.layout, callee_arg.layout) {\n+        if !Self::check_argument_compat(rust_abi, caller_arg.layout, callee_arg.layout) {\n             return err!(FunctionArgMismatch(caller_arg.layout.ty, callee_arg.layout.ty));\n         }\n         // We allow some transmutes here\n@@ -322,7 +327,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     // Figure out how to pass which arguments.\n                     // We have two iterators: Where the arguments come from,\n                     // and where they go to.\n-                    let skip_zst = match caller_abi {\n+                    let rust_abi = match caller_abi {\n                         Abi::Rust | Abi::RustCall => true,\n                         _ => false\n                     };\n@@ -347,7 +352,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                         };\n                     // Skip ZSTs\n                     let mut caller_iter = caller_args.iter()\n-                        .filter(|op| !skip_zst || !op.layout.is_zst())\n+                        .filter(|op| !rust_abi || !op.layout.is_zst())\n                         .map(|op| *op);\n \n                     // Now we have to spread them out across the callee's locals,\n@@ -362,11 +367,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                             // Must be a tuple\n                             for i in 0..dest.layout.fields.count() {\n                                 let dest = self.place_field(dest, i as u64)?;\n-                                self.pass_argument(skip_zst, &mut caller_iter, dest)?;\n+                                self.pass_argument(rust_abi, &mut caller_iter, dest)?;\n                             }\n                         } else {\n                             // Normal argument\n-                            self.pass_argument(skip_zst, &mut caller_iter, dest)?;\n+                            self.pass_argument(rust_abi, &mut caller_iter, dest)?;\n                         }\n                     }\n                     // Now we should have no more caller args\n@@ -377,7 +382,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     // Don't forget to check the return type!\n                     if let Some(caller_ret) = dest {\n                         let callee_ret = self.eval_place(&mir::Place::Local(mir::RETURN_PLACE))?;\n-                        if !Self::check_argument_compat(caller_ret.layout, callee_ret.layout) {\n+                        if !Self::check_argument_compat(\n+                            rust_abi,\n+                            caller_ret.layout,\n+                            callee_ret.layout,\n+                        ) {\n                             return err!(FunctionRetMismatch(\n                                 caller_ret.layout.ty, callee_ret.layout.ty\n                             ));"}]}