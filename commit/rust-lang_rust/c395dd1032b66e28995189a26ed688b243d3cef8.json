{"sha": "c395dd1032b66e28995189a26ed688b243d3cef8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzOTVkZDEwMzJiNjZlMjg5OTUxODlhMjZlZDY4OGIyNDNkM2NlZjg=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-02-12T20:30:55Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-02-12T20:30:55Z"}, "message": "Implement constructor usage search for almost all items\n\nFor all struct kinds, unions and enums, as well as for record- and\ntuple-variants but not for unit-variants, as these have no trailing\ncharacter we can anchor the search to. Functionality wise it is\nimplemented though.", "tree": {"sha": "be88733f10b9cd71bcff79b9c9a4dba7f6cbdf55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be88733f10b9cd71bcff79b9c9a4dba7f6cbdf55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c395dd1032b66e28995189a26ed688b243d3cef8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c395dd1032b66e28995189a26ed688b243d3cef8", "html_url": "https://github.com/rust-lang/rust/commit/c395dd1032b66e28995189a26ed688b243d3cef8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c395dd1032b66e28995189a26ed688b243d3cef8/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88253907f4bc3beaa7b8f2e58cb652f653f92d56", "url": "https://api.github.com/repos/rust-lang/rust/commits/88253907f4bc3beaa7b8f2e58cb652f653f92d56", "html_url": "https://github.com/rust-lang/rust/commit/88253907f4bc3beaa7b8f2e58cb652f653f92d56"}], "stats": {"total": 299, "additions": 191, "deletions": 108}, "files": [{"sha": "9b228443f86bfdb89ac8dad094f2ed17091731ee", "filename": "crates/assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c395dd1032b66e28995189a26ed688b243d3cef8/crates%2Fassists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c395dd1032b66e28995189a26ed688b243d3cef8/crates%2Fassists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=c395dd1032b66e28995189a26ed688b243d3cef8", "patch": "@@ -1,6 +1,5 @@\n-use std::collections::HashMap;\n-\n use ide_db::{defs::Definition, search::FileReference};\n+use rustc_hash::FxHashMap;\n use syntax::{\n     ast::{self, AstNode, AstToken},\n     TextRange,\n@@ -111,7 +110,7 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n                 .collect::<Result<_, _>>()\n                 .map(|b| (file_id, b))\n         })\n-        .collect::<Result<HashMap<_, Vec<_>>, _>>()?;\n+        .collect::<Result<FxHashMap<_, Vec<_>>, _>>()?;\n \n     let init_str = initializer_expr.syntax().text().to_string();\n     let init_in_paren = format!(\"({})\", &init_str);"}, {"sha": "8a491f0772fbf89c367a6811c0e13feeff46208f", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 189, "deletions": 105, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/c395dd1032b66e28995189a26ed688b243d3cef8/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c395dd1032b66e28995189a26ed688b243d3cef8/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=c395dd1032b66e28995189a26ed688b243d3cef8", "patch": "@@ -11,7 +11,7 @@\n \n pub(crate) mod rename;\n \n-use hir::Semantics;\n+use hir::{PathResolution, Semantics};\n use ide_db::{\n     base_db::FileId,\n     defs::{Definition, NameClass, NameRefClass},\n@@ -22,7 +22,7 @@ use rustc_hash::FxHashMap;\n use syntax::{\n     algo::find_node_at_offset,\n     ast::{self, NameOwner},\n-    AstNode, SyntaxNode, TextRange, TokenAtOffset, T,\n+    match_ast, AstNode, SyntaxNode, TextRange, T,\n };\n \n use crate::{display::TryToNav, FilePosition, NavigationTarget};\n@@ -47,29 +47,43 @@ pub(crate) fn find_all_refs(\n     let _p = profile::span(\"find_all_refs\");\n     let syntax = sema.parse(position.file_id).syntax().clone();\n \n-    let (opt_name, ctor_filter): (_, Option<fn(&_) -> bool>) = if let Some(name) =\n-        get_struct_def_name_for_struct_literal_search(&sema, &syntax, position)\n-    {\n-        (\n-            Some(name),\n-            Some(|name_ref| is_record_lit_name_ref(name_ref) || is_call_expr_name_ref(name_ref)),\n-        )\n-    } else if let Some(name) = get_enum_def_name_for_struct_literal_search(&sema, &syntax, position)\n-    {\n-        (Some(name), Some(is_enum_lit_name_ref))\n-    } else {\n-        (sema.find_node_at_offset_with_descend::<ast::Name>(&syntax, position.offset), None)\n-    };\n-\n-    let def = find_def(&sema, &syntax, position, opt_name)?;\n+    let (def, is_literal_search) =\n+        if let Some(name) = get_name_of_item_declaration(&syntax, position) {\n+            (NameClass::classify(sema, &name)?.referenced_or_defined(sema.db), true)\n+        } else {\n+            (find_def(&sema, &syntax, position)?, false)\n+        };\n \n     let mut usages = def.usages(sema).set_scope(search_scope).all();\n-    if let Some(ctor_filter) = ctor_filter {\n+    if is_literal_search {\n         // filter for constructor-literals\n-        usages.references.values_mut().for_each(|it| {\n-            it.retain(|reference| reference.name.as_name_ref().map_or(false, ctor_filter));\n-        });\n-        usages.references.retain(|_, it| !it.is_empty());\n+        let refs = usages.references.values_mut();\n+        match def {\n+            Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Enum(enum_))) => {\n+                refs.for_each(|it| {\n+                    it.retain(|reference| {\n+                        reference\n+                            .name\n+                            .as_name_ref()\n+                            .map_or(false, |name_ref| is_enum_lit_name_ref(sema, enum_, name_ref))\n+                    })\n+                });\n+                usages.references.retain(|_, it| !it.is_empty());\n+            }\n+            Definition::ModuleDef(def @ hir::ModuleDef::Adt(_))\n+            | Definition::ModuleDef(def @ hir::ModuleDef::Variant(_)) => {\n+                refs.for_each(|it| {\n+                    it.retain(|reference| {\n+                        reference\n+                            .name\n+                            .as_name_ref()\n+                            .map_or(false, |name_ref| is_lit_name_ref(sema, def, name_ref))\n+                    })\n+                });\n+                usages.references.retain(|_, it| !it.is_empty());\n+            }\n+            _ => {}\n+        }\n     }\n     let nav = def.try_to_nav(sema.db)?;\n     let decl_range = nav.focus_or_full_range();\n@@ -89,9 +103,9 @@ fn find_def(\n     sema: &Semantics<RootDatabase>,\n     syntax: &SyntaxNode,\n     position: FilePosition,\n-    opt_name: Option<ast::Name>,\n ) -> Option<Definition> {\n-    if let Some(name) = opt_name {\n+    if let Some(name) = sema.find_node_at_offset_with_descend::<ast::Name>(&syntax, position.offset)\n+    {\n         let class = NameClass::classify(sema, &name)?;\n         Some(class.referenced_or_defined(sema.db))\n     } else if let Some(lifetime) =\n@@ -134,95 +148,96 @@ fn decl_access(def: &Definition, syntax: &SyntaxNode, range: TextRange) -> Optio\n     None\n }\n \n-fn get_struct_def_name_for_struct_literal_search(\n-    sema: &Semantics<RootDatabase>,\n-    syntax: &SyntaxNode,\n-    position: FilePosition,\n-) -> Option<ast::Name> {\n-    if let TokenAtOffset::Between(ref left, ref right) = syntax.token_at_offset(position.offset) {\n-        if right.kind() != T!['{'] && right.kind() != T!['('] {\n-            return None;\n-        }\n-        if let Some(name) =\n-            sema.find_node_at_offset_with_descend::<ast::Name>(&syntax, left.text_range().start())\n-        {\n-            return name.syntax().ancestors().find_map(ast::Struct::cast).and_then(|l| l.name());\n+fn get_name_of_item_declaration(syntax: &SyntaxNode, position: FilePosition) -> Option<ast::Name> {\n+    let token = syntax.token_at_offset(position.offset).right_biased()?;\n+    let kind = token.kind();\n+    if kind == T![;] {\n+        ast::Struct::cast(token.parent())\n+            .filter(|struct_| struct_.field_list().is_none())\n+            .and_then(|struct_| struct_.name())\n+    } else if kind == T!['{'] {\n+        match_ast! {\n+            match (token.parent()) {\n+                ast::RecordFieldList(rfl) => match_ast! {\n+                    match (rfl.syntax().parent()?) {\n+                        ast::Variant(it) => it.name(),\n+                        ast::Struct(it) => it.name(),\n+                        ast::Union(it) => it.name(),\n+                        _ => None,\n+                    }\n+                },\n+                ast::VariantList(vl) => ast::Enum::cast(vl.syntax().parent()?)?.name(),\n+                _ => None,\n+            }\n         }\n-        if sema\n-            .find_node_at_offset_with_descend::<ast::GenericParamList>(\n-                &syntax,\n-                left.text_range().start(),\n-            )\n-            .is_some()\n-        {\n-            return left.ancestors().find_map(ast::Struct::cast).and_then(|l| l.name());\n+    } else if kind == T!['('] {\n+        let tfl = ast::TupleFieldList::cast(token.parent())?;\n+        match_ast! {\n+            match (tfl.syntax().parent()?) {\n+                ast::Variant(it) => it.name(),\n+                ast::Struct(it) => it.name(),\n+                _ => None,\n+            }\n         }\n+    } else {\n+        None\n     }\n-    None\n }\n \n-fn get_enum_def_name_for_struct_literal_search(\n+fn is_enum_lit_name_ref(\n     sema: &Semantics<RootDatabase>,\n-    syntax: &SyntaxNode,\n-    position: FilePosition,\n-) -> Option<ast::Name> {\n-    if let TokenAtOffset::Between(ref left, ref right) = syntax.token_at_offset(position.offset) {\n-        if right.kind() != T!['{'] && right.kind() != T!['('] {\n-            return None;\n-        }\n-        if let Some(name) =\n-            sema.find_node_at_offset_with_descend::<ast::Name>(&syntax, left.text_range().start())\n-        {\n-            return name.syntax().ancestors().find_map(ast::Enum::cast).and_then(|l| l.name());\n-        }\n-        if sema\n-            .find_node_at_offset_with_descend::<ast::GenericParamList>(\n-                &syntax,\n-                left.text_range().start(),\n-            )\n-            .is_some()\n-        {\n-            return left.ancestors().find_map(ast::Enum::cast).and_then(|l| l.name());\n+    enum_: hir::Enum,\n+    name_ref: &ast::NameRef,\n+) -> bool {\n+    for ancestor in name_ref.syntax().ancestors() {\n+        match_ast! {\n+            match ancestor {\n+                ast::PathExpr(path_expr) => {\n+                    return matches!(\n+                        path_expr.path().and_then(|p| sema.resolve_path(&p)),\n+                        Some(PathResolution::Def(hir::ModuleDef::Variant(variant)))\n+                            if variant.parent_enum(sema.db) == enum_\n+                    )\n+                },\n+                ast::RecordExpr(record_expr) => {\n+                    return matches!(\n+                        record_expr.path().and_then(|p| sema.resolve_path(&p)),\n+                        Some(PathResolution::Def(hir::ModuleDef::Variant(variant)))\n+                            if variant.parent_enum(sema.db) == enum_\n+                    )\n+                },\n+                _ => (),\n+            }\n         }\n     }\n-    None\n+    false\n }\n \n-fn is_call_expr_name_ref(name_ref: &ast::NameRef) -> bool {\n-    name_ref\n-        .syntax()\n-        .ancestors()\n-        .find_map(ast::CallExpr::cast)\n-        .and_then(|c| match c.expr()? {\n-            ast::Expr::PathExpr(p) => {\n-                Some(p.path()?.segment()?.name_ref().as_ref() == Some(name_ref))\n+fn is_lit_name_ref(\n+    sema: &Semantics<RootDatabase>,\n+    def: hir::ModuleDef,\n+    name_ref: &ast::NameRef,\n+) -> bool {\n+    for ancestor in name_ref.syntax().ancestors() {\n+        match_ast! {\n+            match ancestor {\n+                ast::PathExpr(path_expr) => {\n+                    return matches!(\n+                        path_expr.path().and_then(|p| sema.resolve_path(&p)),\n+                        Some(PathResolution::Def(def2)) if def == def2\n+                    )\n+                },\n+                ast::RecordExpr(record_expr) => {\n+                    return matches!(\n+                        record_expr.path().and_then(|p| sema.resolve_path(&p)),\n+                        Some(PathResolution::Def(def2)) if def == def2\n+                    )\n+                },\n+                _ => (),\n             }\n-            _ => None,\n-        })\n-        .unwrap_or(false)\n-}\n-\n-fn is_record_lit_name_ref(name_ref: &ast::NameRef) -> bool {\n-    name_ref\n-        .syntax()\n-        .ancestors()\n-        .find_map(ast::RecordExpr::cast)\n-        .and_then(|l| l.path())\n-        .and_then(|p| p.segment())\n-        .map(|p| p.name_ref().as_ref() == Some(name_ref))\n-        .unwrap_or(false)\n-}\n-\n-fn is_enum_lit_name_ref(name_ref: &ast::NameRef) -> bool {\n-    name_ref\n-        .syntax()\n-        .ancestors()\n-        .find_map(ast::PathExpr::cast)\n-        .and_then(|p| p.path())\n-        .and_then(|p| p.qualifier())\n-        .and_then(|p| p.segment())\n-        .map(|p| p.name_ref().as_ref() == Some(name_ref))\n-        .unwrap_or(false)\n+        }\n+    }\n+    false\n }\n \n #[cfg(test)]\n@@ -312,23 +327,92 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn test_struct_literal_for_union() {\n+        check(\n+            r#\"\n+union Foo $0{\n+    x: u32\n+}\n+\n+fn main() {\n+    let f: Foo;\n+    f = Foo { x: 1 };\n+}\n+\"#,\n+            expect![[r#\"\n+                Foo Union FileId(0) 0..24 6..9\n+\n+                FileId(0) 62..65\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn test_enum_after_space() {\n         check(\n             r#\"\n enum Foo $0{\n     A,\n-    B,\n+    B(),\n+    C{},\n }\n fn main() {\n     let f: Foo;\n     f = Foo::A;\n+    f = Foo::B();\n+    f = Foo::C{};\n }\n \"#,\n             expect![[r#\"\n-                Foo Enum FileId(0) 0..26 5..8\n+                Foo Enum FileId(0) 0..37 5..8\n \n-                FileId(0) 63..66\n+                FileId(0) 74..77\n+                FileId(0) 90..93\n+                FileId(0) 108..111\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_variant_record_after_space() {\n+        check(\n+            r#\"\n+enum Foo {\n+    A $0{ n: i32 },\n+    B,\n+}\n+fn main() {\n+    let f: Foo;\n+    f = Foo::B;\n+    f = Foo::A { n: 92 };\n+}\n+\"#,\n+            expect![[r#\"\n+                A Variant FileId(0) 15..27 15..16\n+\n+                FileId(0) 95..96\n+            \"#]],\n+        );\n+    }\n+    #[test]\n+    fn test_variant_tuple_before_paren() {\n+        check(\n+            r#\"\n+enum Foo {\n+    A$0(i32),\n+    B,\n+}\n+fn main() {\n+    let f: Foo;\n+    f = Foo::B;\n+    f = Foo::A(92);\n+}\n+\"#,\n+            expect![[r#\"\n+                A Variant FileId(0) 15..21 15..16\n+\n+                FileId(0) 89..90\n             \"#]],\n         );\n     }"}]}