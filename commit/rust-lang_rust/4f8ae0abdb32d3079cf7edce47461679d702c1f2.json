{"sha": "4f8ae0abdb32d3079cf7edce47461679d702c1f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmOGFlMGFiZGIzMmQzMDc5Y2Y3ZWRjZTQ3NDYxNjc5ZDcwMmMxZjI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-02-25T02:18:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-02-25T02:18:01Z"}, "message": "Rollup merge of #58421 - nox:relax-bounds-binary-heap, r=dtolnay\n\nRelax some Ord bounds on BinaryHeap<T>\n\nNotably, iterators don't require any trait bounds to be iterated.", "tree": {"sha": "6ea820f8ccfe35797fd38e41dd466d210c87db9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ea820f8ccfe35797fd38e41dd466d210c87db9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f8ae0abdb32d3079cf7edce47461679d702c1f2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcc1BZCRBK7hj4Ov3rIwAAdHIIACfURQiUo9QhcCdSp+tikk9O\nNsiw6INzQYIRGuNFf09blba9bC3Apjk3+6Ywkc6OLI/1WuWe5ZzZidwS8gR1PdQo\nOHn2bfKD+FEgSdIGfRVmC5PMvoe3AADOkGnqf+s2mYhHlql+0LISQnn5MUpauZMs\nHa832bbqOJXgqNDJ8gKroW+HdVS0bl9LN6boRs8wcFHpPiA5FedTf13iOOEfltil\nhEUG7VUzZyP3JfuNQ4Pjzb2uVDufwcnC251ZurKMk2nPIB9OzWRmeM90SL/xPsAi\nqIe2xtLhKnJsROhJ6UCw7yYZnT9TEOZ3LGIFGuufHmh535s9dgiaTIeuc7z3Wnk=\n=KTdN\n-----END PGP SIGNATURE-----\n", "payload": "tree 6ea820f8ccfe35797fd38e41dd466d210c87db9a\nparent 03acebe2ca6bfeeb537449c786c397fbc45dc576\nparent ac32359f085875837007b575a7b52339df017a7b\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1551061081 +0100\ncommitter GitHub <noreply@github.com> 1551061081 +0100\n\nRollup merge of #58421 - nox:relax-bounds-binary-heap, r=dtolnay\n\nRelax some Ord bounds on BinaryHeap<T>\n\nNotably, iterators don't require any trait bounds to be iterated.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f8ae0abdb32d3079cf7edce47461679d702c1f2", "html_url": "https://github.com/rust-lang/rust/commit/4f8ae0abdb32d3079cf7edce47461679d702c1f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f8ae0abdb32d3079cf7edce47461679d702c1f2/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03acebe2ca6bfeeb537449c786c397fbc45dc576", "url": "https://api.github.com/repos/rust-lang/rust/commits/03acebe2ca6bfeeb537449c786c397fbc45dc576", "html_url": "https://github.com/rust-lang/rust/commit/03acebe2ca6bfeeb537449c786c397fbc45dc576"}, {"sha": "ac32359f085875837007b575a7b52339df017a7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac32359f085875837007b575a7b52339df017a7b", "html_url": "https://github.com/rust-lang/rust/commit/ac32359f085875837007b575a7b52339df017a7b"}], "stats": {"total": 488, "additions": 244, "deletions": 244}, "files": [{"sha": "a171f128c24d60cba4a7257e7127a34591535de4", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 244, "deletions": 244, "changes": 488, "blob_url": "https://github.com/rust-lang/rust/blob/4f8ae0abdb32d3079cf7edce47461679d702c1f2/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f8ae0abdb32d3079cf7edce47461679d702c1f2/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=4f8ae0abdb32d3079cf7edce47461679d702c1f2", "patch": "@@ -294,7 +294,7 @@ impl<T: Ord> Default for BinaryHeap<T> {\n }\n \n #[stable(feature = \"binaryheap_debug\", since = \"1.4.0\")]\n-impl<T: fmt::Debug + Ord> fmt::Debug for BinaryHeap<T> {\n+impl<T: fmt::Debug> fmt::Debug for BinaryHeap<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_list().entries(self.iter()).finish()\n     }\n@@ -336,49 +336,6 @@ impl<T: Ord> BinaryHeap<T> {\n         BinaryHeap { data: Vec::with_capacity(capacity) }\n     }\n \n-    /// Returns an iterator visiting all values in the underlying vector, in\n-    /// arbitrary order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::collections::BinaryHeap;\n-    /// let heap = BinaryHeap::from(vec![1, 2, 3, 4]);\n-    ///\n-    /// // Print 1, 2, 3, 4 in arbitrary order\n-    /// for x in heap.iter() {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter(&self) -> Iter<'_, T> {\n-        Iter { iter: self.data.iter() }\n-    }\n-\n-    /// Returns the greatest item in the binary heap, or `None` if it is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::collections::BinaryHeap;\n-    /// let mut heap = BinaryHeap::new();\n-    /// assert_eq!(heap.peek(), None);\n-    ///\n-    /// heap.push(1);\n-    /// heap.push(5);\n-    /// heap.push(2);\n-    /// assert_eq!(heap.peek(), Some(&5));\n-    ///\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn peek(&self) -> Option<&T> {\n-        self.data.get(0)\n-    }\n-\n     /// Returns a mutable reference to the greatest item in the binary heap, or\n     /// `None` if it is empty.\n     ///\n@@ -415,119 +372,6 @@ impl<T: Ord> BinaryHeap<T> {\n         }\n     }\n \n-    /// Returns the number of elements the binary heap can hold without reallocating.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::collections::BinaryHeap;\n-    /// let mut heap = BinaryHeap::with_capacity(100);\n-    /// assert!(heap.capacity() >= 100);\n-    /// heap.push(4);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> usize {\n-        self.data.capacity()\n-    }\n-\n-    /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n-    /// given `BinaryHeap`. Does nothing if the capacity is already sufficient.\n-    ///\n-    /// Note that the allocator may give the collection more space than it requests. Therefore\n-    /// capacity can not be relied upon to be precisely minimal. Prefer [`reserve`] if future\n-    /// insertions are expected.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the new capacity overflows `usize`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::collections::BinaryHeap;\n-    /// let mut heap = BinaryHeap::new();\n-    /// heap.reserve_exact(100);\n-    /// assert!(heap.capacity() >= 100);\n-    /// heap.push(4);\n-    /// ```\n-    ///\n-    /// [`reserve`]: #method.reserve\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_exact(&mut self, additional: usize) {\n-        self.data.reserve_exact(additional);\n-    }\n-\n-    /// Reserves capacity for at least `additional` more elements to be inserted in the\n-    /// `BinaryHeap`. The collection may reserve more space to avoid frequent reallocations.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the new capacity overflows `usize`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::collections::BinaryHeap;\n-    /// let mut heap = BinaryHeap::new();\n-    /// heap.reserve(100);\n-    /// assert!(heap.capacity() >= 100);\n-    /// heap.push(4);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve(&mut self, additional: usize) {\n-        self.data.reserve(additional);\n-    }\n-\n-    /// Discards as much additional capacity as possible.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::collections::BinaryHeap;\n-    /// let mut heap: BinaryHeap<i32> = BinaryHeap::with_capacity(100);\n-    ///\n-    /// assert!(heap.capacity() >= 100);\n-    /// heap.shrink_to_fit();\n-    /// assert!(heap.capacity() == 0);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn shrink_to_fit(&mut self) {\n-        self.data.shrink_to_fit();\n-    }\n-\n-    /// Discards capacity with a lower bound.\n-    ///\n-    /// The capacity will remain at least as large as both the length\n-    /// and the supplied value.\n-    ///\n-    /// Panics if the current capacity is smaller than the supplied\n-    /// minimum capacity.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(shrink_to)]\n-    /// use std::collections::BinaryHeap;\n-    /// let mut heap: BinaryHeap<i32> = BinaryHeap::with_capacity(100);\n-    ///\n-    /// assert!(heap.capacity() >= 100);\n-    /// heap.shrink_to(10);\n-    /// assert!(heap.capacity() >= 10);\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue=\"56431\")]\n-    pub fn shrink_to(&mut self, min_capacity: usize) {\n-        self.data.shrink_to(min_capacity)\n-    }\n-\n     /// Removes the greatest item from the binary heap and returns it, or `None` if it\n     /// is empty.\n     ///\n@@ -577,28 +421,6 @@ impl<T: Ord> BinaryHeap<T> {\n         self.sift_up(0, old_len);\n     }\n \n-    /// Consumes the `BinaryHeap` and returns the underlying vector\n-    /// in arbitrary order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::collections::BinaryHeap;\n-    /// let heap = BinaryHeap::from(vec![1, 2, 3, 4, 5, 6, 7]);\n-    /// let vec = heap.into_vec();\n-    ///\n-    /// // Will print in some order\n-    /// for x in vec {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"binary_heap_extras_15\", since = \"1.5.0\")]\n-    pub fn into_vec(self) -> Vec<T> {\n-        self.into()\n-    }\n-\n     /// Consumes the `BinaryHeap` and returns a vector in sorted\n     /// (ascending) order.\n     ///\n@@ -703,6 +525,247 @@ impl<T: Ord> BinaryHeap<T> {\n         self.sift_up(start, pos);\n     }\n \n+    fn rebuild(&mut self) {\n+        let mut n = self.len() / 2;\n+        while n > 0 {\n+            n -= 1;\n+            self.sift_down(n);\n+        }\n+    }\n+\n+    /// Moves all the elements of `other` into `self`, leaving `other` empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    ///\n+    /// let v = vec![-10, 1, 2, 3, 3];\n+    /// let mut a = BinaryHeap::from(v);\n+    ///\n+    /// let v = vec![-20, 5, 43];\n+    /// let mut b = BinaryHeap::from(v);\n+    ///\n+    /// a.append(&mut b);\n+    ///\n+    /// assert_eq!(a.into_sorted_vec(), [-20, -10, 1, 2, 3, 3, 5, 43]);\n+    /// assert!(b.is_empty());\n+    /// ```\n+    #[stable(feature = \"binary_heap_append\", since = \"1.11.0\")]\n+    pub fn append(&mut self, other: &mut Self) {\n+        if self.len() < other.len() {\n+            swap(self, other);\n+        }\n+\n+        if other.is_empty() {\n+            return;\n+        }\n+\n+        #[inline(always)]\n+        fn log2_fast(x: usize) -> usize {\n+            8 * size_of::<usize>() - (x.leading_zeros() as usize) - 1\n+        }\n+\n+        // `rebuild` takes O(len1 + len2) operations\n+        // and about 2 * (len1 + len2) comparisons in the worst case\n+        // while `extend` takes O(len2 * log_2(len1)) operations\n+        // and about 1 * len2 * log_2(len1) comparisons in the worst case,\n+        // assuming len1 >= len2.\n+        #[inline]\n+        fn better_to_rebuild(len1: usize, len2: usize) -> bool {\n+            2 * (len1 + len2) < len2 * log2_fast(len1)\n+        }\n+\n+        if better_to_rebuild(self.len(), other.len()) {\n+            self.data.append(&mut other.data);\n+            self.rebuild();\n+        } else {\n+            self.extend(other.drain());\n+        }\n+    }\n+}\n+\n+impl<T> BinaryHeap<T> {\n+    /// Returns an iterator visiting all values in the underlying vector, in\n+    /// arbitrary order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let heap = BinaryHeap::from(vec![1, 2, 3, 4]);\n+    ///\n+    /// // Print 1, 2, 3, 4 in arbitrary order\n+    /// for x in heap.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn iter(&self) -> Iter<'_, T> {\n+        Iter { iter: self.data.iter() }\n+    }\n+\n+    /// Returns the greatest item in the binary heap, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap = BinaryHeap::new();\n+    /// assert_eq!(heap.peek(), None);\n+    ///\n+    /// heap.push(1);\n+    /// heap.push(5);\n+    /// heap.push(2);\n+    /// assert_eq!(heap.peek(), Some(&5));\n+    ///\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn peek(&self) -> Option<&T> {\n+        self.data.get(0)\n+    }\n+\n+    /// Returns the number of elements the binary heap can hold without reallocating.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap = BinaryHeap::with_capacity(100);\n+    /// assert!(heap.capacity() >= 100);\n+    /// heap.push(4);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn capacity(&self) -> usize {\n+        self.data.capacity()\n+    }\n+\n+    /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n+    /// given `BinaryHeap`. Does nothing if the capacity is already sufficient.\n+    ///\n+    /// Note that the allocator may give the collection more space than it requests. Therefore\n+    /// capacity can not be relied upon to be precisely minimal. Prefer [`reserve`] if future\n+    /// insertions are expected.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `usize`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap = BinaryHeap::new();\n+    /// heap.reserve_exact(100);\n+    /// assert!(heap.capacity() >= 100);\n+    /// heap.push(4);\n+    /// ```\n+    ///\n+    /// [`reserve`]: #method.reserve\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn reserve_exact(&mut self, additional: usize) {\n+        self.data.reserve_exact(additional);\n+    }\n+\n+    /// Reserves capacity for at least `additional` more elements to be inserted in the\n+    /// `BinaryHeap`. The collection may reserve more space to avoid frequent reallocations.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `usize`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap = BinaryHeap::new();\n+    /// heap.reserve(100);\n+    /// assert!(heap.capacity() >= 100);\n+    /// heap.push(4);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn reserve(&mut self, additional: usize) {\n+        self.data.reserve(additional);\n+    }\n+\n+    /// Discards as much additional capacity as possible.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap: BinaryHeap<i32> = BinaryHeap::with_capacity(100);\n+    ///\n+    /// assert!(heap.capacity() >= 100);\n+    /// heap.shrink_to_fit();\n+    /// assert!(heap.capacity() == 0);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn shrink_to_fit(&mut self) {\n+        self.data.shrink_to_fit();\n+    }\n+\n+    /// Discards capacity with a lower bound.\n+    ///\n+    /// The capacity will remain at least as large as both the length\n+    /// and the supplied value.\n+    ///\n+    /// Panics if the current capacity is smaller than the supplied\n+    /// minimum capacity.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(shrink_to)]\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap: BinaryHeap<i32> = BinaryHeap::with_capacity(100);\n+    ///\n+    /// assert!(heap.capacity() >= 100);\n+    /// heap.shrink_to(10);\n+    /// assert!(heap.capacity() >= 10);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue=\"56431\")]\n+    pub fn shrink_to(&mut self, min_capacity: usize) {\n+        self.data.shrink_to(min_capacity)\n+    }\n+\n+    /// Consumes the `BinaryHeap` and returns the underlying vector\n+    /// in arbitrary order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let heap = BinaryHeap::from(vec![1, 2, 3, 4, 5, 6, 7]);\n+    /// let vec = heap.into_vec();\n+    ///\n+    /// // Will print in some order\n+    /// for x in vec {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"binary_heap_extras_15\", since = \"1.5.0\")]\n+    pub fn into_vec(self) -> Vec<T> {\n+        self.into()\n+    }\n+\n     /// Returns the length of the binary heap.\n     ///\n     /// # Examples\n@@ -789,67 +852,6 @@ impl<T: Ord> BinaryHeap<T> {\n     pub fn clear(&mut self) {\n         self.drain();\n     }\n-\n-    fn rebuild(&mut self) {\n-        let mut n = self.len() / 2;\n-        while n > 0 {\n-            n -= 1;\n-            self.sift_down(n);\n-        }\n-    }\n-\n-    /// Moves all the elements of `other` into `self`, leaving `other` empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::collections::BinaryHeap;\n-    ///\n-    /// let v = vec![-10, 1, 2, 3, 3];\n-    /// let mut a = BinaryHeap::from(v);\n-    ///\n-    /// let v = vec![-20, 5, 43];\n-    /// let mut b = BinaryHeap::from(v);\n-    ///\n-    /// a.append(&mut b);\n-    ///\n-    /// assert_eq!(a.into_sorted_vec(), [-20, -10, 1, 2, 3, 3, 5, 43]);\n-    /// assert!(b.is_empty());\n-    /// ```\n-    #[stable(feature = \"binary_heap_append\", since = \"1.11.0\")]\n-    pub fn append(&mut self, other: &mut Self) {\n-        if self.len() < other.len() {\n-            swap(self, other);\n-        }\n-\n-        if other.is_empty() {\n-            return;\n-        }\n-\n-        #[inline(always)]\n-        fn log2_fast(x: usize) -> usize {\n-            8 * size_of::<usize>() - (x.leading_zeros() as usize) - 1\n-        }\n-\n-        // `rebuild` takes O(len1 + len2) operations\n-        // and about 2 * (len1 + len2) comparisons in the worst case\n-        // while `extend` takes O(len2 * log_2(len1)) operations\n-        // and about 1 * len2 * log_2(len1) comparisons in the worst case,\n-        // assuming len1 >= len2.\n-        #[inline]\n-        fn better_to_rebuild(len1: usize, len2: usize) -> bool {\n-            2 * (len1 + len2) < len2 * log2_fast(len1)\n-        }\n-\n-        if better_to_rebuild(self.len(), other.len()) {\n-            self.data.append(&mut other.data);\n-            self.rebuild();\n-        } else {\n-            self.extend(other.drain());\n-        }\n-    }\n }\n \n /// Hole represents a hole in a slice i.e., an index without valid value\n@@ -1111,7 +1113,7 @@ impl<T: Ord> FromIterator<T> for BinaryHeap<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Ord> IntoIterator for BinaryHeap<T> {\n+impl<T> IntoIterator for BinaryHeap<T> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n \n@@ -1139,9 +1141,7 @@ impl<T: Ord> IntoIterator for BinaryHeap<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> IntoIterator for &'a BinaryHeap<T>\n-    where T: Ord\n-{\n+impl<'a, T> IntoIterator for &'a BinaryHeap<T> {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n "}]}