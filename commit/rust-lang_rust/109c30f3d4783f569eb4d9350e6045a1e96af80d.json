{"sha": "109c30f3d4783f569eb4d9350e6045a1e96af80d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwOWMzMGYzZDQ3ODNmNTY5ZWI0ZDkzNTBlNjA0NWExZTk2YWY4MGQ=", "commit": {"author": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2019-12-29T01:09:42Z"}, "committer": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2020-01-13T01:34:41Z"}, "message": "More separation of error reporting from region inference", "tree": {"sha": "df1d8bd010f8a0c81975978b7ae06def3154e0c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df1d8bd010f8a0c81975978b7ae06def3154e0c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/109c30f3d4783f569eb4d9350e6045a1e96af80d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/109c30f3d4783f569eb4d9350e6045a1e96af80d", "html_url": "https://github.com/rust-lang/rust/commit/109c30f3d4783f569eb4d9350e6045a1e96af80d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/109c30f3d4783f569eb4d9350e6045a1e96af80d/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ebcfa1451cfedc13a07e6353d8ade9742dfdc2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ebcfa1451cfedc13a07e6353d8ade9742dfdc2a", "html_url": "https://github.com/rust-lang/rust/commit/3ebcfa1451cfedc13a07e6353d8ade9742dfdc2a"}], "stats": {"total": 176, "additions": 77, "deletions": 99}, "files": [{"sha": "bf4a12b12a5c24c813d13e30c86383be7d5608cc", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/109c30f3d4783f569eb4d9350e6045a1e96af80d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/109c30f3d4783f569eb4d9350e6045a1e96af80d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=109c30f3d4783f569eb4d9350e6045a1e96af80d", "patch": "@@ -1,8 +1,7 @@\n //! Error reporting machinery for lifetime errors.\n \n use rustc::infer::{\n-    error_reporting::nice_region_error::NiceRegionError, region_constraints::GenericKind,\n-    InferCtxt, NLLRegionVariableOrigin,\n+    error_reporting::nice_region_error::NiceRegionError, InferCtxt, NLLRegionVariableOrigin,\n };\n use rustc::mir::{Body, ConstraintCategory, Location};\n use rustc::ty::{self, RegionVid, Ty};\n@@ -16,8 +15,11 @@ use std::collections::VecDeque;\n use crate::util::borrowck_errors;\n \n use crate::borrow_check::{\n-    constraints::OutlivesConstraint, nll::ConstraintDescription,\n-    region_infer::RegionInferenceContext, type_check::Locations, universal_regions::DefiningTy,\n+    constraints::OutlivesConstraint,\n+    nll::ConstraintDescription,\n+    region_infer::{values::RegionElement, RegionInferenceContext, TypeTest},\n+    type_check::Locations,\n+    universal_regions::DefiningTy,\n     MirBorrowckCtxt,\n };\n \n@@ -62,23 +64,8 @@ crate type RegionErrors<'tcx> = Vec<RegionErrorKind<'tcx>>;\n \n #[derive(Clone, Debug)]\n crate enum RegionErrorKind<'tcx> {\n-    /// An error for a type test: `T: 'a` does not live long enough.\n-    TypeTestDoesNotLiveLongEnough {\n-        /// The span of the type test.\n-        span: Span,\n-        /// The generic type of the type test.\n-        generic: GenericKind<'tcx>,\n-    },\n-\n-    /// A generic bound failure for a type test.\n-    TypeTestGenericBoundError {\n-        /// The span of the type test.\n-        span: Span,\n-        /// The generic type of the type test.\n-        generic: GenericKind<'tcx>,\n-        /// The lower bound region.\n-        lower_bound_region: ty::Region<'tcx>,\n-    },\n+    /// A generic bound failure for a type test (`T: 'a`).\n+    TypeTestError { type_test: TypeTest<'tcx> },\n \n     /// An unexpected hidden region for an opaque type.\n     UnexpectedHiddenRegion {\n@@ -94,8 +81,8 @@ crate enum RegionErrorKind<'tcx> {\n     BoundUniversalRegionError {\n         /// The placeholder free region.\n         longer_fr: RegionVid,\n-        /// The region that erroneously must be outlived by `longer_fr`.\n-        error_region: RegionVid,\n+        /// The region element that erroneously must be outlived by `longer_fr`.\n+        error_element: RegionElement,\n         /// The origin of the placeholder region.\n         fr_origin: NLLRegionVariableOrigin,\n     },"}, {"sha": "fc1b723c271203da3f183a209880f430e977f463", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 42, "deletions": 35, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/109c30f3d4783f569eb4d9350e6045a1e96af80d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/109c30f3d4783f569eb4d9350e6045a1e96af80d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=109c30f3d4783f569eb4d9350e6045a1e96af80d", "patch": "@@ -631,7 +631,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n \n                 debug!(\n                     \"visit_terminator_drop \\\n-                        loc: {:?} term: {:?} drop_place: {:?} drop_place_ty: {:?} span: {:?}\",\n+                     loc: {:?} term: {:?} drop_place: {:?} drop_place_ty: {:?} span: {:?}\",\n                     loc, term, drop_place, drop_place_ty, span\n                 );\n \n@@ -1477,38 +1477,42 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         for nll_error in nll_errors.into_iter() {\n             match nll_error {\n-                RegionErrorKind::TypeTestDoesNotLiveLongEnough { span, generic } => {\n-                    // FIXME. We should handle this case better. It\n-                    // indicates that we have e.g., some region variable\n-                    // whose value is like `'a+'b` where `'a` and `'b` are\n-                    // distinct unrelated univesal regions that are not\n-                    // known to outlive one another. It'd be nice to have\n-                    // some examples where this arises to decide how best\n-                    // to report it; we could probably handle it by\n-                    // iterating over the universal regions and reporting\n-                    // an error that multiple bounds are required.\n-                    self.infcx\n-                        .tcx\n-                        .sess\n-                        .struct_span_err(span, &format!(\"`{}` does not live long enough\", generic))\n-                        .buffer(&mut self.errors_buffer);\n-                }\n-\n-                RegionErrorKind::TypeTestGenericBoundError {\n-                    span,\n-                    generic,\n-                    lower_bound_region,\n-                } => {\n-                    let region_scope_tree = &self.infcx.tcx.region_scope_tree(self.mir_def_id);\n-                    self.infcx\n-                        .construct_generic_bound_failure(\n-                            region_scope_tree,\n-                            span,\n-                            None,\n-                            generic,\n-                            lower_bound_region,\n-                        )\n-                        .buffer(&mut self.errors_buffer);\n+                RegionErrorKind::TypeTestError { type_test } => {\n+                    // Try to convert the lower-bound region into something named we can print for the user.\n+                    let lower_bound_region =\n+                        self.nonlexical_regioncx.to_error_region(type_test.lower_bound);\n+\n+                    // Skip duplicate-ish errors.\n+                    let type_test_span = type_test.locations.span(&self.body);\n+\n+                    if let Some(lower_bound_region) = lower_bound_region {\n+                        let region_scope_tree = &self.infcx.tcx.region_scope_tree(self.mir_def_id);\n+                        self.infcx\n+                            .construct_generic_bound_failure(\n+                                region_scope_tree,\n+                                type_test_span,\n+                                None,\n+                                type_test.generic_kind,\n+                                lower_bound_region,\n+                            )\n+                            .buffer(&mut self.errors_buffer);\n+                    } else {\n+                        // FIXME. We should handle this case better. It indicates that we have\n+                        // e.g., some region variable whose value is like `'a+'b` where `'a` and\n+                        // `'b` are distinct unrelated univesal regions that are not known to\n+                        // outlive one another. It'd be nice to have some examples where this\n+                        // arises to decide how best to report it; we could probably handle it by\n+                        // iterating over the universal regions and reporting an error that\n+                        // multiple bounds are required.\n+                        self.infcx\n+                            .tcx\n+                            .sess\n+                            .struct_span_err(\n+                                type_test_span,\n+                                &format!(\"`{}` does not live long enough\", type_test.generic_kind),\n+                            )\n+                            .buffer(&mut self.errors_buffer);\n+                    }\n                 }\n \n                 RegionErrorKind::UnexpectedHiddenRegion {\n@@ -1530,8 +1534,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 RegionErrorKind::BoundUniversalRegionError {\n                     longer_fr,\n                     fr_origin,\n-                    error_region,\n+                    error_element,\n                 } => {\n+                    let error_region =\n+                        self.nonlexical_regioncx.region_from_element(longer_fr, error_element);\n+\n                     // Find the code to blame for the fact that `longer_fr` outlives `error_fr`.\n                     let (_, span) = self.nonlexical_regioncx.find_outlives_blame_span(\n                         &self.body,\n@@ -2225,7 +2232,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             let upvar = &self.upvars[field.index()];\n                             debug!(\n                                 \"upvar.mutability={:?} local_mutation_is_allowed={:?} \\\n-                                place={:?}\",\n+                                 place={:?}\",\n                                 upvar, is_local_mutation_allowed, place\n                             );\n                             match (upvar.mutability, is_local_mutation_allowed) {"}, {"sha": "baa1c5b617dcaa1ac28ec1ba0f1015bffc0bc8e6", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 24, "deletions": 40, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/109c30f3d4783f569eb4d9350e6045a1e96af80d/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/109c30f3d4783f569eb4d9350e6045a1e96af80d/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=109c30f3d4783f569eb4d9350e6045a1e96af80d", "patch": "@@ -838,39 +838,20 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n \n             // Type-test failed. Report the error.\n-\n-            // Try to convert the lower-bound region into something named we can print for the user.\n-            let lower_bound_region = self.to_error_region(type_test.lower_bound);\n-\n-            // Skip duplicate-ish errors.\n-            let type_test_span = type_test.locations.span(body);\n-            let erased_generic_kind = tcx.erase_regions(&type_test.generic_kind);\n-            if !deduplicate_errors.insert((\n+            let erased_generic_kind = infcx.tcx.erase_regions(&type_test.generic_kind);\n+            if deduplicate_errors.insert((\n                 erased_generic_kind,\n-                lower_bound_region,\n+                type_test.lower_bound,\n                 type_test.locations,\n             )) {\n-                continue;\n-            } else {\n                 debug!(\n                     \"check_type_test: reporting error for erased_generic_kind={:?}, \\\n                      lower_bound_region={:?}, \\\n                      type_test.locations={:?}\",\n-                    erased_generic_kind, lower_bound_region, type_test.locations,\n+                    erased_generic_kind, type_test.lower_bound, type_test.locations,\n                 );\n-            }\n \n-            if let Some(lower_bound_region) = lower_bound_region {\n-                errors_buffer.push(RegionErrorKind::TypeTestGenericBoundError {\n-                    span: type_test_span,\n-                    generic: type_test.generic_kind,\n-                    lower_bound_region,\n-                });\n-            } else {\n-                errors_buffer.push(RegionErrorKind::TypeTestDoesNotLiveLongEnough {\n-                    span: type_test_span,\n-                    generic: type_test.generic_kind,\n-                });\n+                errors_buffer.push(RegionErrorKind::TypeTestError { type_test: type_test.clone() });\n             }\n         }\n     }\n@@ -1355,7 +1336,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for (longer_fr, shorter_fr) in subset_errors.into_iter() {\n             debug!(\n                 \"check_polonius_subset_errors: subset_error longer_fr={:?},\\\n-                shorter_fr={:?}\",\n+                 shorter_fr={:?}\",\n                 longer_fr, shorter_fr\n             );\n \n@@ -1572,23 +1553,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         debug!(\"check_bound_universal_region: error_element = {:?}\", error_element);\n \n         // Find the region that introduced this `error_element`.\n-        let error_region = match error_element {\n-            RegionElement::Location(l) => self.find_sub_region_live_at(longer_fr, l),\n-            RegionElement::RootUniversalRegion(r) => r,\n-            RegionElement::PlaceholderRegion(error_placeholder) => self\n-                .definitions\n-                .iter_enumerated()\n-                .filter_map(|(r, definition)| match definition.origin {\n-                    NLLRegionVariableOrigin::Placeholder(p) if p == error_placeholder => Some(r),\n-                    _ => None,\n-                })\n-                .next()\n-                .unwrap(),\n-        };\n-\n         errors_buffer.push(RegionErrorKind::BoundUniversalRegionError {\n             longer_fr,\n-            error_region,\n+            error_element,\n             fr_origin: NLLRegionVariableOrigin::Placeholder(placeholder),\n         });\n     }\n@@ -1628,6 +1595,23 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             });\n         }\n     }\n+\n+    /// Get the region outlived by `longer_fr` and live at `element`.\n+    crate fn region_from_element(&self, longer_fr: RegionVid, element: RegionElement) -> RegionVid {\n+        match element {\n+            RegionElement::Location(l) => self.find_sub_region_live_at(longer_fr, l),\n+            RegionElement::RootUniversalRegion(r) => r,\n+            RegionElement::PlaceholderRegion(error_placeholder) => self\n+                .definitions\n+                .iter_enumerated()\n+                .filter_map(|(r, definition)| match definition.origin {\n+                    NLLRegionVariableOrigin::Placeholder(p) if p == error_placeholder => Some(r),\n+                    _ => None,\n+                })\n+                .next()\n+                .unwrap(),\n+        }\n+    }\n }\n \n impl<'tcx> RegionDefinition<'tcx> {"}, {"sha": "3126d44014b4ea3d0943c3497794c6a38e7dec9b", "filename": "src/librustc_mir/borrow_check/region_infer/values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/109c30f3d4783f569eb4d9350e6045a1e96af80d/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/109c30f3d4783f569eb4d9350e6045a1e96af80d/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs?ref=109c30f3d4783f569eb4d9350e6045a1e96af80d", "patch": "@@ -114,7 +114,7 @@ rustc_index::newtype_index! {\n \n /// An individual element in a region value -- the value of a\n /// particular region variable consists of a set of these elements.\n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n crate enum RegionElement {\n     /// A point in the control-flow graph.\n     Location(Location),"}]}