{"sha": "01d693b1cdc8b2b6aee2b78f0ef89540427029be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxZDY5M2IxY2RjOGIyYjZhZWUyYjc4ZjBlZjg5NTQwNDI3MDI5YmU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2014-10-14T20:36:11Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2014-10-15T11:17:34Z"}, "message": "Use the correct LLVM integer sizes\n\nUse the integer sizes LLVM uses, rather than having random projections\nlaying around. Sizes are u64, Alignments are u32, C_*int is target-dependent\nbut 64-bit is fine (the int -> C_int conversion is non-precision-losing,\nbut it can be preceded by `as int` conversions which are, so it is\nsomewhat ugly. However, being able to suffix a `u` to properly infer\ninteger types is nice).", "tree": {"sha": "f42b160ad9618a986fb1835651ca62a8c755d56f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f42b160ad9618a986fb1835651ca62a8c755d56f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01d693b1cdc8b2b6aee2b78f0ef89540427029be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01d693b1cdc8b2b6aee2b78f0ef89540427029be", "html_url": "https://github.com/rust-lang/rust/commit/01d693b1cdc8b2b6aee2b78f0ef89540427029be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01d693b1cdc8b2b6aee2b78f0ef89540427029be/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71dfa5befe2ddf3d16fb5e23f6922125cf1cf5e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/71dfa5befe2ddf3d16fb5e23f6922125cf1cf5e6", "html_url": "https://github.com/rust-lang/rust/commit/71dfa5befe2ddf3d16fb5e23f6922125cf1cf5e6"}], "stats": {"total": 164, "additions": 90, "deletions": 74}, "files": [{"sha": "f7f26ef88a3c81a202706a38aef95bdbfffd1865", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=01d693b1cdc8b2b6aee2b78f0ef89540427029be", "patch": "@@ -1088,7 +1088,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let sw = if kind == Switch {\n         build::Switch(bcx, test_val, else_cx.llbb, opts.len())\n     } else {\n-        C_int(ccx, 0) // Placeholder for when not using a switch\n+        C_int(ccx, 0i) // Placeholder for when not using a switch\n     };\n \n     let defaults = enter_default(else_cx, dm, m, col, val);"}, {"sha": "83b6040aff264db92bbcba5de49bcef26e5c7635", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=01d693b1cdc8b2b6aee2b78f0ef89540427029be", "patch": "@@ -45,7 +45,6 @@\n \n #![allow(unsigned_negate)]\n \n-use libc::c_ulonglong;\n use std::collections::Map;\n use std::num::Int;\n use std::rc::Rc;\n@@ -132,7 +131,7 @@ pub struct Struct {\n     // If the struct is DST, then the size and alignment do not take into\n     // account the unsized fields of the struct.\n     pub size: u64,\n-    pub align: u64,\n+    pub align: u32,\n     pub sized: bool,\n     pub packed: bool,\n     pub fields: Vec<ty::t>\n@@ -652,9 +651,7 @@ fn load_discr(bcx: Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n     } else {\n         // llvm::ConstantRange can deal with ranges that wrap around,\n         // so an overflow on (max + 1) is fine.\n-        LoadRangeAssert(bcx, ptr, min as c_ulonglong,\n-                        (max + 1) as c_ulonglong,\n-                        /* signed: */ True)\n+        LoadRangeAssert(bcx, ptr, min, (max+1), /* signed: */ True)\n     }\n }\n \n@@ -973,11 +970,11 @@ fn compute_struct_field_offsets(ccx: &CrateContext, st: &Struct) -> Vec<u64> {\n     for &ty in st.fields.iter() {\n         let llty = type_of::sizing_type_of(ccx, ty);\n         if !st.packed {\n-            let type_align = type_of::align_of(ccx, ty) as u64;\n+            let type_align = type_of::align_of(ccx, ty);\n             offset = roundup(offset, type_align);\n         }\n         offsets.push(offset);\n-        offset += machine::llsize_of_alloc(ccx, llty) as u64;\n+        offset += machine::llsize_of_alloc(ccx, llty);\n     }\n     assert_eq!(st.fields.len(), offsets.len());\n     offsets\n@@ -1004,8 +1001,7 @@ fn build_const_struct(ccx: &CrateContext, st: &Struct, vals: &[ValueRef])\n     let mut cfields = Vec::new();\n     for (&val, &target_offset) in vals.iter().zip(target_offsets.iter()) {\n         if !st.packed {\n-            let val_align = machine::llalign_of_min(ccx, val_ty(val))\n-                /*bad*/as u64;\n+            let val_align = machine::llalign_of_min(ccx, val_ty(val));\n             offset = roundup(offset, val_align);\n         }\n         if offset != target_offset {\n@@ -1014,7 +1010,7 @@ fn build_const_struct(ccx: &CrateContext, st: &Struct, vals: &[ValueRef])\n         }\n         assert!(!is_undef(val));\n         cfields.push(val);\n-        offset += machine::llsize_of_alloc(ccx, val_ty(val)) as u64;\n+        offset += machine::llsize_of_alloc(ccx, val_ty(val));\n     }\n \n     assert!(st.sized && offset <= st.size);\n@@ -1031,7 +1027,7 @@ fn padding(ccx: &CrateContext, size: u64) -> ValueRef {\n \n // FIXME this utility routine should be somewhere more general\n #[inline]\n-fn roundup(x: u64, a: u64) -> u64 { ((x + (a - 1)) / a) * a }\n+fn roundup(x: u64, a: u32) -> u64 { let a = a as u64; ((x + (a - 1)) / a) * a }\n \n /// Get the discriminant of a constant value.  (Not currently used.)\n pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef)"}, {"sha": "f7ecd84a34adb1458f6452284cbf72948bf0e06a", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=01d693b1cdc8b2b6aee2b78f0ef89540427029be", "patch": "@@ -398,7 +398,7 @@ pub fn malloc_raw_dyn_proc<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: ty::t) -> Resu\n \n     let llty = type_of(bcx.ccx(), t);\n     let size = llsize_of(bcx.ccx(), llty);\n-    let llalign = C_uint(ccx, llalign_of_min(bcx.ccx(), llty) as uint);\n+    let llalign = C_uint(ccx, llalign_of_min(bcx.ccx(), llty));\n \n     // Allocate space and store the destructor pointer:\n     let Result {bcx: bcx, val: llbox} = malloc_raw_dyn(bcx, ptr_llty, t, size, llalign);"}, {"sha": "025b5f368ecae3bdbd0c5cc3b67cd74a5cf62032", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=01d693b1cdc8b2b6aee2b78f0ef89540427029be", "patch": "@@ -21,7 +21,7 @@ use syntax::codemap::Span;\n use middle::trans::builder::Builder;\n use middle::trans::type_::Type;\n \n-use libc::{c_uint, c_ulonglong, c_char};\n+use libc::{c_uint, c_char};\n \n pub fn terminate(cx: Block, _: &str) {\n     debug!(\"terminate({})\", cx.to_str());\n@@ -380,8 +380,8 @@ pub fn AtomicLoad(cx: Block, pointer_val: ValueRef, order: AtomicOrdering) -> Va\n }\n \n \n-pub fn LoadRangeAssert(cx: Block, pointer_val: ValueRef, lo: c_ulonglong,\n-                       hi: c_ulonglong, signed: llvm::Bool) -> ValueRef {\n+pub fn LoadRangeAssert(cx: Block, pointer_val: ValueRef, lo: u64,\n+                       hi: u64, signed: llvm::Bool) -> ValueRef {\n     if cx.unreachable.get() {\n         let ccx = cx.fcx.ccx;\n         let ty = val_ty(pointer_val);"}, {"sha": "5724c65cfb583a0af9b3300c188f683a9add5f24", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=01d693b1cdc8b2b6aee2b78f0ef89540427029be", "patch": "@@ -19,7 +19,7 @@ use middle::trans::common::*;\n use middle::trans::machine::llalign_of_pref;\n use middle::trans::type_::Type;\n use std::collections::HashMap;\n-use libc::{c_uint, c_ulonglong, c_char};\n+use libc::{c_uint, c_char};\n use std::string::String;\n use syntax::codemap::Span;\n \n@@ -477,8 +477,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n \n-    pub fn load_range_assert(&self, ptr: ValueRef, lo: c_ulonglong,\n-                           hi: c_ulonglong, signed: llvm::Bool) -> ValueRef {\n+    pub fn load_range_assert(&self, ptr: ValueRef, lo: u64,\n+                             hi: u64, signed: llvm::Bool) -> ValueRef {\n         let value = self.load(ptr);\n \n         unsafe {\n@@ -490,7 +490,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             llvm::LLVMSetMetadata(value, llvm::MD_range as c_uint,\n                                   llvm::LLVMMDNodeInContext(self.ccx.llcx(),\n-                                                            v.as_ptr(), v.len() as c_uint));\n+                                                            v.as_ptr(),\n+                                                            v.len() as c_uint));\n         }\n \n         value"}, {"sha": "a4eb540174feabec7ddc8fdafc8bfda92ea7778c", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=01d693b1cdc8b2b6aee2b78f0ef89540427029be", "patch": "@@ -39,7 +39,7 @@ use util::nodemap::{DefIdMap, NodeMap};\n \n use arena::TypedArena;\n use std::collections::HashMap;\n-use libc::{c_uint, c_longlong, c_ulonglong, c_char};\n+use libc::{c_uint, c_char};\n use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n use std::rc::Rc;\n@@ -595,14 +595,26 @@ pub fn C_u64(ccx: &CrateContext, i: u64) -> ValueRef {\n     C_integral(Type::i64(ccx), i, false)\n }\n \n-pub fn C_int(ccx: &CrateContext, i: int) -> ValueRef {\n-    C_integral(ccx.int_type(), i as u64, true)\n+pub fn C_int<I: AsI64>(ccx: &CrateContext, i: I) -> ValueRef {\n+    C_integral(ccx.int_type(), i.as_i64() as u64, true)\n }\n \n-pub fn C_uint(ccx: &CrateContext, i: uint) -> ValueRef {\n-    C_integral(ccx.int_type(), i as u64, false)\n+pub fn C_uint<I: AsU64>(ccx: &CrateContext, i: I) -> ValueRef {\n+    C_integral(ccx.int_type(), i.as_u64(), false)\n }\n \n+pub trait AsI64 { fn as_i64(self) -> i64; }\n+pub trait AsU64 { fn as_u64(self) -> u64; }\n+\n+// FIXME: remove the intptr conversions\n+impl AsI64 for i64 { fn as_i64(self) -> i64 { self as i64 }}\n+impl AsI64 for i32 { fn as_i64(self) -> i64 { self as i64 }}\n+impl AsI64 for int { fn as_i64(self) -> i64 { self as i64 }}\n+\n+impl AsU64 for u64  { fn as_u64(self) -> u64 { self as u64 }}\n+impl AsU64 for u32  { fn as_u64(self) -> u64 { self as u64 }}\n+impl AsU64 for uint { fn as_u64(self) -> u64 { self as u64 }}\n+\n pub fn C_u8(ccx: &CrateContext, i: uint) -> ValueRef {\n     C_integral(Type::i8(ccx), i as u64, false)\n }\n@@ -717,13 +729,13 @@ pub fn is_const(v: ValueRef) -> bool {\n     }\n }\n \n-pub fn const_to_int(v: ValueRef) -> c_longlong {\n+pub fn const_to_int(v: ValueRef) -> i64 {\n     unsafe {\n         llvm::LLVMConstIntGetSExtValue(v)\n     }\n }\n \n-pub fn const_to_uint(v: ValueRef) -> c_ulonglong {\n+pub fn const_to_uint(v: ValueRef) -> u64 {\n     unsafe {\n         llvm::LLVMConstIntGetZExtValue(v)\n     }"}, {"sha": "3f08061ca88bd9c83304030c1b5bd56307516674", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=01d693b1cdc8b2b6aee2b78f0ef89540427029be", "patch": "@@ -499,7 +499,7 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let loc = bcx.sess().codemap().lookup_char_pos(sp.lo);\n     let filename = token::intern_and_get_ident(loc.file.name.as_slice());\n     let filename = C_str_slice(ccx, filename);\n-    let line = C_int(ccx, loc.line as int);\n+    let line = C_int(ccx, loc.line as i64);\n     let expr_file_line_const = C_struct(ccx, &[v_str, filename, line], false);\n     let expr_file_line = consts::const_addr_of(ccx, expr_file_line_const, ast::MutImmutable);\n     let args = vec!(expr_file_line);\n@@ -526,7 +526,7 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Invoke the lang item\n     let filename = C_str_slice(ccx,  filename);\n-    let line = C_int(ccx, loc.line as int);\n+    let line = C_int(ccx, loc.line as i64);\n     let file_line_const = C_struct(ccx, &[filename, line], false);\n     let file_line = consts::const_addr_of(ccx, file_line_const, ast::MutImmutable);\n     let args = vec!(file_line, index, len);"}, {"sha": "9d7dc96ae0366202d92a4e1d16d4ef0f6ec64f88", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=01d693b1cdc8b2b6aee2b78f0ef89540427029be", "patch": "@@ -202,7 +202,7 @@ use middle::ty;\n use middle::pat_util;\n use util::ppaux;\n \n-use libc::{c_uint, c_ulonglong, c_longlong};\n+use libc::c_uint;\n use std::c_str::{CString, ToCStr};\n use std::cell::{Cell, RefCell};\n use std::collections::HashMap;\n@@ -2384,7 +2384,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                     llvm::LLVMDIBuilderCreateEnumerator(\n                         DIB(cx),\n                         name,\n-                        v.disr_val as c_ulonglong)\n+                        v.disr_val as u64)\n                 }\n             })\n         })\n@@ -2663,9 +2663,9 @@ fn fixed_vec_metadata(cx: &CrateContext,\n \n     let subrange = unsafe {\n         llvm::LLVMDIBuilderGetOrCreateSubrange(\n-        DIB(cx),\n-        0,\n-        len as c_longlong)\n+            DIB(cx),\n+            0,\n+            len as i64)\n     };\n \n     let subscripts = create_DIArray(DIB(cx), [subrange]);\n@@ -3072,11 +3072,11 @@ fn span_start(cx: &CrateContext, span: Span) -> codemap::Loc {\n }\n \n fn size_and_align_of(cx: &CrateContext, llvm_type: Type) -> (u64, u64) {\n-    (machine::llsize_of_alloc(cx, llvm_type), machine::llalign_of_min(cx, llvm_type))\n+    (machine::llsize_of_alloc(cx, llvm_type), machine::llalign_of_min(cx, llvm_type) as u64)\n }\n \n-fn bytes_to_bits(bytes: u64) -> c_ulonglong {\n-    (bytes * 8) as c_ulonglong\n+fn bytes_to_bits(bytes: u64) -> u64 {\n+    bytes * 8\n }\n \n #[inline]"}, {"sha": "a4b6385a8912e2d2a02d5090cbd783df9b24987c", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=01d693b1cdc8b2b6aee2b78f0ef89540427029be", "patch": "@@ -1548,7 +1548,7 @@ fn trans_uniq_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     assert!(ty::type_is_sized(bcx.tcx(), contents_ty));\n     let llty = type_of::type_of(bcx.ccx(), contents_ty);\n     let size = llsize_of(bcx.ccx(), llty);\n-    let align = C_uint(bcx.ccx(), type_of::align_of(bcx.ccx(), contents_ty) as uint);\n+    let align = C_uint(bcx.ccx(), type_of::align_of(bcx.ccx(), contents_ty));\n     let llty_ptr = llty.ptr_to();\n     let Result { bcx, val } = malloc_raw_dyn(bcx, llty_ptr, box_ty, size, align);\n     // Unique boxes do not allocate for zero-size types. The standard library"}, {"sha": "00a94b120ed93e5d2ece3c75016ab2144fb283db", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=01d693b1cdc8b2b6aee2b78f0ef89540427029be", "patch": "@@ -476,7 +476,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let llalign = cmp::min(llforeign_align, llrust_align);\n             debug!(\"llrust_size={:?}\", llrust_size);\n             base::call_memcpy(bcx, llretptr_i8, llscratch_i8,\n-                              C_uint(ccx, llrust_size as uint), llalign as u32);\n+                              C_uint(ccx, llrust_size), llalign as u32);\n         }\n     }\n "}, {"sha": "d8ffd2bc2b9462fb1f06f42b05a03a7d6287388e", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=01d693b1cdc8b2b6aee2b78f0ef89540427029be", "patch": "@@ -58,9 +58,9 @@ pub fn trans_exchange_free_dyn<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef,\n }\n \n pub fn trans_exchange_free<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef,\n-                                       size: u64, align: u64) -> Block<'blk, 'tcx> {\n-    trans_exchange_free_dyn(cx, v, C_uint(cx.ccx(), size as uint),\n-                            C_uint(cx.ccx(), align as uint))\n+                                       size: u64, align: u32) -> Block<'blk, 'tcx> {\n+    trans_exchange_free_dyn(cx, v, C_uint(cx.ccx(), size),\n+                                   C_uint(cx.ccx(), align))\n }\n \n pub fn trans_exchange_free_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ptr: ValueRef,\n@@ -368,8 +368,8 @@ fn size_and_align_of_dst(bcx: Block, t :ty::t, info: ValueRef) -> (ValueRef, Val\n            bcx.ty_to_string(t), bcx.val_to_string(info));\n     if ty::type_is_sized(bcx.tcx(), t) {\n         let sizing_type = sizing_type_of(bcx.ccx(), t);\n-        let size = C_uint(bcx.ccx(), llsize_of_alloc(bcx.ccx(), sizing_type) as uint);\n-        let align = C_uint(bcx.ccx(), align_of(bcx.ccx(), t) as uint);\n+        let size = C_uint(bcx.ccx(), llsize_of_alloc(bcx.ccx(), sizing_type));\n+        let align = C_uint(bcx.ccx(), align_of(bcx.ccx(), t));\n         return (size, align);\n     }\n     match ty::get(t).sty {\n@@ -380,8 +380,8 @@ fn size_and_align_of_dst(bcx: Block, t :ty::t, info: ValueRef) -> (ValueRef, Val\n             assert!(!ty::type_is_simd(bcx.tcx(), t));\n             let repr = adt::represent_type(ccx, t);\n             let sizing_type = adt::sizing_type_of(ccx, &*repr, true);\n-            let sized_size = C_uint(ccx, llsize_of_alloc(ccx, sizing_type) as uint);\n-            let sized_align = C_uint(ccx, llalign_of_min(ccx, sizing_type) as uint);\n+            let sized_size = C_uint(ccx, llsize_of_alloc(ccx, sizing_type));\n+            let sized_align = C_uint(ccx, llalign_of_min(ccx, sizing_type));\n \n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n@@ -411,7 +411,7 @@ fn size_and_align_of_dst(bcx: Block, t :ty::t, info: ValueRef) -> (ValueRef, Val\n             // times the unit size.\n             let llunit_ty = sizing_type_of(bcx.ccx(), unit_ty);\n             let unit_size = llsize_of_alloc(bcx.ccx(), llunit_ty);\n-            (Mul(bcx, info, C_uint(bcx.ccx(), unit_size as uint)), C_uint(bcx.ccx(), 8))\n+            (Mul(bcx, info, C_uint(bcx.ccx(), unit_size)), C_uint(bcx.ccx(), 8u))\n         }\n         _ => bcx.sess().bug(format!(\"Unexpected unsized type, found {}\",\n                                     bcx.ty_to_string(t)).as_slice())"}, {"sha": "5c5d80d6b7e09d32d9dcf473a1b92db279be1c8a", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=01d693b1cdc8b2b6aee2b78f0ef89540427029be", "patch": "@@ -239,16 +239,16 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n         (_, \"size_of\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            C_uint(ccx, machine::llsize_of_real(ccx, lltp_ty) as uint)\n+            C_uint(ccx, machine::llsize_of_real(ccx, lltp_ty))\n         }\n         (_, \"min_align_of\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n-            C_uint(ccx, type_of::align_of(ccx, tp_ty) as uint)\n+            C_uint(ccx, type_of::align_of(ccx, tp_ty))\n         }\n         (_, \"pref_align_of\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty) as uint)\n+            C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty))\n         }\n         (_, \"move_val_init\") => {\n             // Create a datum reflecting the value being moved."}, {"sha": "f576dcc60c01a4217b5ab6abc623124bffb4d84c", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=01d693b1cdc8b2b6aee2b78f0ef89540427029be", "patch": "@@ -10,28 +10,34 @@\n \n // Information concerning the machine representation of various types.\n \n+#![allow(non_camel_case_types)]\n+\n use llvm;\n use llvm::{ValueRef};\n use llvm::False;\n use middle::trans::common::*;\n \n use middle::trans::type_::Type;\n \n+pub type llbits = u64;\n+pub type llsize = u64;\n+pub type llalign = u32;\n+\n // ______________________________________________________________________\n // compute sizeof / alignof\n \n // Returns the number of bytes clobbered by a Store to this type.\n-pub fn llsize_of_store(cx: &CrateContext, ty: Type) -> u64 {\n+pub fn llsize_of_store(cx: &CrateContext, ty: Type) -> llsize {\n     unsafe {\n-        return llvm::LLVMStoreSizeOfType(cx.td().lltd, ty.to_ref()) as u64;\n+        return llvm::LLVMStoreSizeOfType(cx.td().lltd, ty.to_ref());\n     }\n }\n \n // Returns the number of bytes between successive elements of type T in an\n // array of T. This is the \"ABI\" size. It includes any ABI-mandated padding.\n-pub fn llsize_of_alloc(cx: &CrateContext, ty: Type) -> u64 {\n+pub fn llsize_of_alloc(cx: &CrateContext, ty: Type) -> llsize {\n     unsafe {\n-        return llvm::LLVMABISizeOfType(cx.td().lltd, ty.to_ref()) as u64;\n+        return llvm::LLVMABISizeOfType(cx.td().lltd, ty.to_ref());\n     }\n }\n \n@@ -43,9 +49,9 @@ pub fn llsize_of_alloc(cx: &CrateContext, ty: Type) -> u64 {\n // that LLVM *does* distinguish between e.g. a 1-bit value and an 8-bit value\n // at the codegen level! In general you should prefer `llbitsize_of_real`\n // below.\n-pub fn llsize_of_real(cx: &CrateContext, ty: Type) -> u64 {\n+pub fn llsize_of_real(cx: &CrateContext, ty: Type) -> llsize {\n     unsafe {\n-        let nbits = llvm::LLVMSizeOfTypeInBits(cx.td().lltd, ty.to_ref()) as u64;\n+        let nbits = llvm::LLVMSizeOfTypeInBits(cx.td().lltd, ty.to_ref());\n         if nbits & 7 != 0 {\n             // Not an even number of bytes, spills into \"next\" byte.\n             1 + (nbits >> 3)\n@@ -56,9 +62,9 @@ pub fn llsize_of_real(cx: &CrateContext, ty: Type) -> u64 {\n }\n \n /// Returns the \"real\" size of the type in bits.\n-pub fn llbitsize_of_real(cx: &CrateContext, ty: Type) -> u64 {\n+pub fn llbitsize_of_real(cx: &CrateContext, ty: Type) -> llbits {\n     unsafe {\n-        llvm::LLVMSizeOfTypeInBits(cx.td().lltd, ty.to_ref()) as u64\n+        llvm::LLVMSizeOfTypeInBits(cx.td().lltd, ty.to_ref())\n     }\n }\n \n@@ -71,7 +77,7 @@ pub fn llsize_of(cx: &CrateContext, ty: Type) -> ValueRef {\n     // there's no need for that contrivance.  The instruction\n     // selection DAG generator would flatten that GEP(1) node into a\n     // constant of the type's alloc size, so let's save it some work.\n-    return C_uint(cx, llsize_of_alloc(cx, ty) as uint);\n+    return C_uint(cx, llsize_of_alloc(cx, ty));\n }\n \n // Returns the \"default\" size of t (see above), or 1 if the size would\n@@ -89,18 +95,18 @@ pub fn nonzero_llsize_of(cx: &CrateContext, ty: Type) -> ValueRef {\n // The preferred alignment may be larger than the alignment used when\n // packing the type into structs. This will be used for things like\n // allocations inside a stack frame, which LLVM has a free hand in.\n-pub fn llalign_of_pref(cx: &CrateContext, ty: Type) -> u64 {\n+pub fn llalign_of_pref(cx: &CrateContext, ty: Type) -> llalign {\n     unsafe {\n-        return llvm::LLVMPreferredAlignmentOfType(cx.td().lltd, ty.to_ref()) as u64;\n+        return llvm::LLVMPreferredAlignmentOfType(cx.td().lltd, ty.to_ref());\n     }\n }\n \n // Returns the minimum alignment of a type required by the platform.\n // This is the alignment that will be used for struct fields, arrays,\n // and similar ABI-mandated things.\n-pub fn llalign_of_min(cx: &CrateContext, ty: Type) -> u64 {\n+pub fn llalign_of_min(cx: &CrateContext, ty: Type) -> llalign {\n     unsafe {\n-        return llvm::LLVMABIAlignmentOfType(cx.td().lltd, ty.to_ref()) as u64;\n+        return llvm::LLVMABIAlignmentOfType(cx.td().lltd, ty.to_ref());\n     }\n }\n \n@@ -116,6 +122,7 @@ pub fn llalign_of(cx: &CrateContext, ty: Type) -> ValueRef {\n \n pub fn llelement_offset(cx: &CrateContext, struct_ty: Type, element: uint) -> u64 {\n     unsafe {\n-        return llvm::LLVMOffsetOfElement(cx.td().lltd, struct_ty.to_ref(), element as u32) as u64;\n+        return llvm::LLVMOffsetOfElement(cx.td().lltd, struct_ty.to_ref(),\n+                                         element as u32);\n     }\n }"}, {"sha": "f79d5a64f935e464a157bf72f7b20fa0a0e6e743", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=01d693b1cdc8b2b6aee2b78f0ef89540427029be", "patch": "@@ -648,9 +648,9 @@ pub fn get_vtable(bcx: Block,\n \n     let size_ty = sizing_type_of(ccx, trait_ref.self_ty());\n     let size = machine::llsize_of_alloc(ccx, size_ty);\n-    let ll_size = C_uint(ccx, size as uint);\n+    let ll_size = C_uint(ccx, size);\n     let align = align_of(ccx, trait_ref.self_ty());\n-    let ll_align = C_uint(ccx, align as uint);\n+    let ll_align = C_uint(ccx, align);\n \n     // Generate a destructor for the vtable.\n     let drop_glue = glue::get_drop_glue(ccx, box_ty);"}, {"sha": "fbb441f42e1e732cdf51355a8ee2cf4fda3ccf25", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=01d693b1cdc8b2b6aee2b78f0ef89540427029be", "patch": "@@ -74,10 +74,10 @@ pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let unit_size = llsize_of_alloc(ccx, llty);\n             if unit_size != 0 {\n                 let len = get_len(bcx, vptr);\n-                let not_empty = ICmp(bcx, llvm::IntNE, len, C_uint(ccx, 0));\n+                let not_empty = ICmp(bcx, llvm::IntNE, len, C_uint(ccx, 0u));\n                 with_cond(bcx, not_empty, |bcx| {\n-                    let llalign = C_uint(ccx, machine::llalign_of_min(ccx, llty) as uint);\n-                    let size = Mul(bcx, C_uint(ccx, unit_size as uint), len);\n+                    let llalign = C_uint(ccx, machine::llalign_of_min(ccx, llty));\n+                    let size = Mul(bcx, C_uint(ccx, unit_size), len);\n                     glue::trans_exchange_free_dyn(bcx, dataptr, size, llalign)\n                 })\n             } else {\n@@ -461,7 +461,7 @@ pub fn iter_vec_loop<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let loop_counter = {\n         // i = 0\n         let i = alloca(loop_bcx, bcx.ccx().int_type(), \"__i\");\n-        Store(loop_bcx, C_uint(bcx.ccx(), 0), i);\n+        Store(loop_bcx, C_uint(bcx.ccx(), 0u), i);\n \n         Br(loop_bcx, cond_bcx.llbb);\n         i\n@@ -489,7 +489,7 @@ pub fn iter_vec_loop<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     { // i += 1\n         let i = Load(inc_bcx, loop_counter);\n-        let plusone = Add(inc_bcx, i, C_uint(bcx.ccx(), 1));\n+        let plusone = Add(inc_bcx, i, C_uint(bcx.ccx(), 1u));\n         Store(inc_bcx, plusone, loop_counter);\n \n         Br(inc_bcx, cond_bcx.llbb);\n@@ -532,7 +532,7 @@ pub fn iter_vec_raw<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         CondBr(header_bcx, not_yet_at_end, body_bcx.llbb, next_bcx.llbb);\n         let body_bcx = f(body_bcx, data_ptr, vt.unit_ty);\n         AddIncomingToPhi(data_ptr, InBoundsGEP(body_bcx, data_ptr,\n-                                               [C_int(bcx.ccx(), 1)]),\n+                                               [C_int(bcx.ccx(), 1i)]),\n                          body_bcx.llbb);\n         Br(body_bcx, header_bcx.llbb);\n         next_bcx"}, {"sha": "f9d826d5655d541a1daad8b8fa77d7e193a336a0", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=01d693b1cdc8b2b6aee2b78f0ef89540427029be", "patch": "@@ -398,7 +398,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     return llty;\n }\n \n-pub fn align_of(cx: &CrateContext, t: ty::t) -> u64 {\n+pub fn align_of(cx: &CrateContext, t: ty::t) -> machine::llalign {\n     let llty = sizing_type_of(cx, t);\n     machine::llalign_of_min(cx, llty)\n }"}, {"sha": "03399e739084abeb190c7866ec1348d2d5279177", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d693b1cdc8b2b6aee2b78f0ef89540427029be/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=01d693b1cdc8b2b6aee2b78f0ef89540427029be", "patch": "@@ -1458,7 +1458,7 @@ extern {\n \n     /** Distance between successive elements in an array of T.\n     Includes ABI padding. */\n-    pub fn LLVMABISizeOfType(TD: TargetDataRef, Ty: TypeRef) -> c_uint;\n+    pub fn LLVMABISizeOfType(TD: TargetDataRef, Ty: TypeRef) -> c_ulonglong;\n \n     /** Returns the preferred alignment of a type. */\n     pub fn LLVMPreferredAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)"}]}