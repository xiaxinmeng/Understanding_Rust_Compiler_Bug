{"sha": "33696fa9cab5bec947147d65833233b957b5edd5", "node_id": "C_kwDOAAsO6NoAKDMzNjk2ZmE5Y2FiNWJlYzk0NzE0N2Q2NTgzMzIzM2I5NTdiNWVkZDU", "commit": {"author": {"name": "Frank Steffahn", "email": "frank.steffahn@stu.uni-kiel.de", "date": "2020-08-25T15:30:46Z"}, "committer": {"name": "Frank Steffahn", "email": "fdsteffahn@gmail.com", "date": "2023-01-21T16:43:25Z"}, "message": "Add Arc::into_inner for safely discarding Arcs without calling the destructor on the inner type.\n\nMainly rebased and squashed from PR rust-lang/rust#79665,\nfurthermore includes minor changes in comments.", "tree": {"sha": "f6d8b041c24bdacc852b0a6864173bb388cae8b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6d8b041c24bdacc852b0a6864173bb388cae8b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33696fa9cab5bec947147d65833233b957b5edd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33696fa9cab5bec947147d65833233b957b5edd5", "html_url": "https://github.com/rust-lang/rust/commit/33696fa9cab5bec947147d65833233b957b5edd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33696fa9cab5bec947147d65833233b957b5edd5/comments", "author": {"login": "steffahn", "id": 3986214, "node_id": "MDQ6VXNlcjM5ODYyMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3986214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steffahn", "html_url": "https://github.com/steffahn", "followers_url": "https://api.github.com/users/steffahn/followers", "following_url": "https://api.github.com/users/steffahn/following{/other_user}", "gists_url": "https://api.github.com/users/steffahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/steffahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steffahn/subscriptions", "organizations_url": "https://api.github.com/users/steffahn/orgs", "repos_url": "https://api.github.com/users/steffahn/repos", "events_url": "https://api.github.com/users/steffahn/events{/privacy}", "received_events_url": "https://api.github.com/users/steffahn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steffahn", "id": 3986214, "node_id": "MDQ6VXNlcjM5ODYyMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3986214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steffahn", "html_url": "https://github.com/steffahn", "followers_url": "https://api.github.com/users/steffahn/followers", "following_url": "https://api.github.com/users/steffahn/following{/other_user}", "gists_url": "https://api.github.com/users/steffahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/steffahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steffahn/subscriptions", "organizations_url": "https://api.github.com/users/steffahn/orgs", "repos_url": "https://api.github.com/users/steffahn/repos", "events_url": "https://api.github.com/users/steffahn/events{/privacy}", "received_events_url": "https://api.github.com/users/steffahn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44a500c8c187b245638684748f54bd6ec67e0b25", "url": "https://api.github.com/repos/rust-lang/rust/commits/44a500c8c187b245638684748f54bd6ec67e0b25", "html_url": "https://github.com/rust-lang/rust/commit/44a500c8c187b245638684748f54bd6ec67e0b25"}], "stats": {"total": 177, "additions": 177, "deletions": 0}, "files": [{"sha": "a31b597930c831c77de33813b0235203774bf78f", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/33696fa9cab5bec947147d65833233b957b5edd5/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33696fa9cab5bec947147d65833233b957b5edd5/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=33696fa9cab5bec947147d65833233b957b5edd5", "patch": "@@ -654,6 +654,20 @@ impl<T> Arc<T> {\n     ///\n     /// This will succeed even if there are outstanding weak references.\n     ///\n+    // FIXME: when `Arc::into_inner` is stabilized, add this paragraph:\n+    /*\n+    /// It is strongly recommended to use [`Arc::into_inner`] instead if you don't\n+    /// want to keep the `Arc` in the [`Err`] case.\n+    /// Immediately dropping the [`Err`] payload, like in the expression\n+    /// `Arc::try_unwrap(this).ok()`, can still cause the strong count to\n+    /// drop to zero and the inner value of the `Arc` to be dropped:\n+    /// For instance if two threads execute this expression in parallel, then\n+    /// there is a race condition. The threads could first both check whether they\n+    /// have the last clone of their `Arc` via `Arc::try_unwrap`, and then\n+    /// both drop their `Arc` in the call to [`ok`][`Result::ok`],\n+    /// taking the strong count from two down to zero.\n+    ///\n+     */\n     /// # Examples\n     ///\n     /// ```\n@@ -685,6 +699,137 @@ impl<T> Arc<T> {\n             Ok(elem)\n         }\n     }\n+\n+    /// Returns the inner value, if the `Arc` has exactly one strong reference.\n+    ///\n+    /// Otherwise, [`None`] is returned and the `Arc` is dropped.\n+    ///\n+    /// This will succeed even if there are outstanding weak references.\n+    ///\n+    /// If `Arc::into_inner` is called on every clone of this `Arc`,\n+    /// it is guaranteed that exactly one of the calls returns the inner value.\n+    /// This means in particular that the inner value is not dropped.\n+    ///\n+    /// The similar expression `Arc::try_unwrap(this).ok()` does not\n+    /// offer such a guarantee. See the last example below.\n+    //\n+    // FIXME: when `Arc::into_inner` is stabilized, add this to end\n+    // of the previous sentence:\n+    /*\n+    /// and the documentation of [`Arc::try_unwrap`].\n+     */\n+    ///\n+    /// # Examples\n+    ///\n+    /// Minimal example demonstrating the guarantee that `Arc::into_inner` gives.\n+    /// ```\n+    /// #![feature(arc_into_inner)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let x = Arc::new(3);\n+    /// let y = Arc::clone(&x);\n+    ///\n+    /// // Two threads calling `Arc::into_inner` on both clones of an `Arc`:\n+    /// let x_thread = std::thread::spawn(|| Arc::into_inner(x));\n+    /// let y_thread = std::thread::spawn(|| Arc::into_inner(y));\n+    ///\n+    /// let x_inner_value = x_thread.join().unwrap();\n+    /// let y_inner_value = y_thread.join().unwrap();\n+    ///\n+    /// // One of the threads is guaranteed to receive the inner value:\n+    /// assert!(matches!(\n+    ///     (x_inner_value, y_inner_value),\n+    ///     (None, Some(3)) | (Some(3), None)\n+    /// ));\n+    /// // The result could also be `(None, None)` if the threads called\n+    /// // `Arc::try_unwrap(x).ok()` and `Arc::try_unwrap(y).ok()` instead.\n+    /// ```\n+    ///\n+    /// A more practical example demonstrating the need for `Arc::into_inner`:\n+    /// ```\n+    /// #![feature(arc_into_inner)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// // Definition of a simple singly linked list using `Arc`:\n+    /// #[derive(Clone)]\n+    /// struct LinkedList<T>(Option<Arc<Node<T>>>);\n+    /// struct Node<T>(T, Option<Arc<Node<T>>>);\n+    ///\n+    /// // Dropping a long `LinkedList<T>` relying on the destructor of `Arc`\n+    /// // can cause a stack overflow. To prevent this, we can provide a\n+    /// // manual `Drop` implementation that does the destruction in a loop:\n+    /// impl<T> Drop for LinkedList<T> {\n+    ///     fn drop(&mut self) {\n+    ///         let mut link = self.0.take();\n+    ///         while let Some(arc_node) = link.take() {\n+    ///             if let Some(Node(_value, next)) = Arc::into_inner(arc_node) {\n+    ///                 link = next;\n+    ///             }\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// // Implementation of `new` and `push` omitted\n+    /// impl<T> LinkedList<T> {\n+    ///     /* ... */\n+    /// #   fn new() -> Self {\n+    /// #       LinkedList(None)\n+    /// #   }\n+    /// #   fn push(&mut self, x: T) {\n+    /// #       self.0 = Some(Arc::new(Node(x, self.0.take())));\n+    /// #   }\n+    /// }\n+    ///\n+    /// // The following code could have still caused a stack overflow\n+    /// // despite the manual `Drop` impl if that `Drop` impl had used\n+    /// // `Arc::try_unwrap(arc).ok()` instead of `Arc::into_inner(arc)`.\n+    ///\n+    /// // Create a long list and clone it\n+    /// let mut x = LinkedList::new();\n+    /// for i in 0..100000 {\n+    ///     x.push(i); // Adds i to the front of x\n+    /// }\n+    /// let y = x.clone();\n+    ///\n+    /// // Drop the clones in parallel\n+    /// let x_thread = std::thread::spawn(|| drop(x));\n+    /// let y_thread = std::thread::spawn(|| drop(y));\n+    /// x_thread.join().unwrap();\n+    /// y_thread.join().unwrap();\n+    /// ```\n+\n+    // FIXME: when `Arc::into_inner` is stabilized, adjust above documentation\n+    // and the documentation of `Arc::try_unwrap` according to the `FIXME`s. Also\n+    // open an issue on rust-lang/rust-clippy, asking for a lint against\n+    // `Arc::try_unwrap(...).ok()`.\n+    #[inline]\n+    #[unstable(feature = \"arc_into_inner\", issue = \"106894\")]\n+    pub fn into_inner(this: Self) -> Option<T> {\n+        // Make sure that the ordinary `Drop` implementation isn\u2019t called as well\n+        let mut this = mem::ManuallyDrop::new(this);\n+\n+        // Following the implementation of `drop` and `drop_slow`\n+        if this.inner().strong.fetch_sub(1, Release) != 1 {\n+            return None;\n+        }\n+\n+        acquire!(this.inner().strong);\n+\n+        // SAFETY: This mirrors the line\n+        //\n+        //     unsafe { ptr::drop_in_place(Self::get_mut_unchecked(self)) };\n+        //\n+        // in `drop_slow`. Instead of dropping the value behind the pointer,\n+        // it is read and eventually returned; `ptr::read` has the same\n+        // safety conditions as `ptr::drop_in_place`.\n+        let inner = unsafe { ptr::read(Self::get_mut_unchecked(&mut this)) };\n+\n+        drop(Weak { ptr: this.ptr });\n+\n+        Some(inner)\n+    }\n }\n \n impl<T> Arc<[T]> {"}, {"sha": "863d58bdf4d9cdad35f341f1aeb519a67f9bb63f", "filename": "library/alloc/src/sync/tests.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/33696fa9cab5bec947147d65833233b957b5edd5/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33696fa9cab5bec947147d65833233b957b5edd5/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs?ref=33696fa9cab5bec947147d65833233b957b5edd5", "patch": "@@ -101,6 +101,38 @@ fn try_unwrap() {\n     assert_eq!(Arc::try_unwrap(x), Ok(5));\n }\n \n+#[test]\n+fn into_inner() {\n+    for _ in 0..100\n+    // ^ Increase chances of hitting potential race conditions\n+    {\n+        let x = Arc::new(3);\n+        let y = Arc::clone(&x);\n+        let r_thread = std::thread::spawn(|| Arc::into_inner(x));\n+        let s_thread = std::thread::spawn(|| Arc::into_inner(y));\n+        let r = r_thread.join().expect(\"r_thread panicked\");\n+        let s = s_thread.join().expect(\"s_thread panicked\");\n+        assert!(\n+            matches!((r, s), (None, Some(3)) | (Some(3), None)),\n+            \"assertion failed: unexpected result `{:?}`\\\n+            \\n  expected `(None, Some(3))` or `(Some(3), None)`\",\n+            (r, s),\n+        );\n+    }\n+\n+    let x = Arc::new(3);\n+    assert_eq!(Arc::into_inner(x), Some(3));\n+\n+    let x = Arc::new(4);\n+    let y = Arc::clone(&x);\n+    assert_eq!(Arc::into_inner(x), None);\n+    assert_eq!(Arc::into_inner(y), Some(4));\n+\n+    let x = Arc::new(5);\n+    let _w = Arc::downgrade(&x);\n+    assert_eq!(Arc::into_inner(x), Some(5));\n+}\n+\n #[test]\n fn into_from_raw() {\n     let x = Arc::new(Box::new(\"hello\"));"}]}