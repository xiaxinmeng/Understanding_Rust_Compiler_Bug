{"sha": "f506aea1fac0977c7215b4240f4d99b45bf7ae97", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1MDZhZWExZmFjMDk3N2M3MjE1YjQyNDBmNGQ5OWI0NWJmN2FlOTc=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-04-03T18:21:51Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-05-21T18:37:38Z"}, "message": "Give match arms a drop/region scope\n\nAlso give arms the correct lint scope in MIR.", "tree": {"sha": "f95827bc4ff10da26b5e276cab04d6613f0bdbe8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f95827bc4ff10da26b5e276cab04d6613f0bdbe8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f506aea1fac0977c7215b4240f4d99b45bf7ae97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f506aea1fac0977c7215b4240f4d99b45bf7ae97", "html_url": "https://github.com/rust-lang/rust/commit/f506aea1fac0977c7215b4240f4d99b45bf7ae97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f506aea1fac0977c7215b4240f4d99b45bf7ae97/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af6a9a2c62ba2e7fe54f53884b94fcd2f9a9265b", "url": "https://api.github.com/repos/rust-lang/rust/commits/af6a9a2c62ba2e7fe54f53884b94fcd2f9a9265b", "html_url": "https://github.com/rust-lang/rust/commit/af6a9a2c62ba2e7fe54f53884b94fcd2f9a9265b"}], "stats": {"total": 444, "additions": 299, "deletions": 145}, "files": [{"sha": "ef0d4be268eaf36d1c60f2169f9f9f4bec3f1542", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f506aea1fac0977c7215b4240f4d99b45bf7ae97/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f506aea1fac0977c7215b4240f4d99b45bf7ae97/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=f506aea1fac0977c7215b4240f4d99b45bf7ae97", "patch": "@@ -419,7 +419,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         for arm in arms {\n             // Add an exit node for when we've visited all the\n             // patterns and the guard (if there is one) in the arm.\n-            let arm_exit = self.add_dummy_node(&[]);\n+            let bindings_exit = self.add_dummy_node(&[]);\n \n             for pat in &arm.pats {\n                 // Visit the pattern, coming from the discriminant exit\n@@ -453,14 +453,16 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n                 // Add an edge from the exit of this pattern to the\n                 // exit of the arm\n-                self.add_contained_edge(pat_exit, arm_exit);\n+                self.add_contained_edge(pat_exit, bindings_exit);\n             }\n \n             // Visit the body of this arm\n-            let body_exit = self.expr(&arm.body, arm_exit);\n+            let body_exit = self.expr(&arm.body, bindings_exit);\n+\n+            let arm_exit = self.add_ast_node(arm.hir_id.local_id, &[body_exit]);\n \n             // Link the body to the exit of the expression\n-            self.add_contained_edge(body_exit, expr_exit);\n+            self.add_contained_edge(arm_exit, expr_exit);\n         }\n \n         expr_exit"}, {"sha": "fa4e8e3d4769d34e2645048a60402aac2ff1757b", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f506aea1fac0977c7215b4240f4d99b45bf7ae97/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f506aea1fac0977c7215b4240f4d99b45bf7ae97/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=f506aea1fac0977c7215b4240f4d99b45bf7ae97", "patch": "@@ -119,18 +119,18 @@ impl fmt::Debug for Scope {\n pub enum ScopeData {\n     Node,\n \n-    // Scope of the call-site for a function or closure\n-    // (outlives the arguments as well as the body).\n+    /// Scope of the call-site for a function or closure\n+    /// (outlives the arguments as well as the body).\n     CallSite,\n \n-    // Scope of arguments passed to a function or closure\n-    // (they outlive its body).\n+    /// Scope of arguments passed to a function or closure\n+    /// (they outlive its body).\n     Arguments,\n \n-    // Scope of destructors for temporaries of node-id.\n+    /// Scope of destructors for temporaries of node-id.\n     Destruction,\n \n-    // Scope following a `let id = expr;` binding in a block.\n+    /// Scope following a `let id = expr;` binding in a block.\n     Remainder(FirstStatementIndex)\n }\n \n@@ -152,11 +152,11 @@ newtype_index! {\n     ///\n     /// * The subscope with `first_statement_index == 1` is scope of `c`,\n     ///   and thus does not include EXPR_2, but covers the `...`.\n-    pub struct FirstStatementIndex { .. }\n+    pub struct FirstStatementIndex {\n+        derive [HashStable]\n+    }\n }\n \n-impl_stable_hash_for!(struct crate::middle::region::FirstStatementIndex { private });\n-\n // compilation error if size of `ScopeData` is not the same as a `u32`\n static_assert_size!(ScopeData, 4);\n \n@@ -814,13 +814,25 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n }\n \n fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, arm: &'tcx hir::Arm) {\n+    let prev_cx = visitor.cx;\n+\n+    visitor.enter_scope(\n+        Scope {\n+            id: arm.hir_id.local_id,\n+            data: ScopeData::Node,\n+        }\n+    );\n+    visitor.cx.var_parent = visitor.cx.parent;\n+\n     visitor.terminating_scopes.insert(arm.body.hir_id.local_id);\n \n     if let Some(hir::Guard::If(ref expr)) = arm.guard {\n         visitor.terminating_scopes.insert(expr.hir_id.local_id);\n     }\n \n     intravisit::walk_arm(visitor, arm);\n+\n+    visitor.cx = prev_cx;\n }\n \n fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, pat: &'tcx hir::Pat) {\n@@ -893,10 +905,6 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n                 terminating(body.hir_id.local_id);\n             }\n \n-            hir::ExprKind::Match(..) => {\n-                visitor.cx.var_parent = visitor.cx.parent;\n-            }\n-\n             hir::ExprKind::DropTemps(ref expr) => {\n                 // `DropTemps(expr)` does not denote a conditional scope.\n                 // Rather, we want to achieve the same behavior as `{ let _t = expr; _t }`."}, {"sha": "091e39630d6cb87f9969b9a8d7d3b352b942f607", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 57, "deletions": 30, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/f506aea1fac0977c7215b4240f4d99b45bf7ae97/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f506aea1fac0977c7215b4240f4d99b45bf7ae97/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=f506aea1fac0977c7215b4240f4d99b45bf7ae97", "patch": "@@ -12,6 +12,7 @@ use crate::build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n use crate::hair::{self, *};\n use rustc::hir::HirId;\n use rustc::mir::*;\n+use rustc::middle::region;\n use rustc::ty::{self, CanonicalUserTypeAnnotation, Ty};\n use rustc::ty::layout::VariantIdx;\n use rustc_data_structures::bit_set::BitSet;\n@@ -251,45 +252,47 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         // Step 5. Create everything else: the guards and the arms.\n \n-        let outer_source_info = self.source_info(span);\n         let arm_end_blocks: Vec<_> = arm_candidates.into_iter().map(|(arm, candidates)| {\n-            let mut arm_block = self.cfg.start_new_block();\n-\n-            let body = self.hir.mirror(arm.body.clone());\n-            let scope = self.declare_bindings(\n-                None,\n-                body.span,\n-                &arm.patterns[0],\n-                ArmHasGuard(arm.guard.is_some()),\n-                Some((Some(&scrutinee_place), scrutinee_span)),\n-            );\n-\n-            if let Some(source_scope) = scope {\n-                this.source_scope = source_scope;\n-            }\n-\n-            for candidate in candidates {\n-                self.bind_and_guard_matched_candidate(\n-                    candidate,\n-                    arm.guard.clone(),\n-                    arm_block,\n-                    &fake_borrow_temps,\n-                    scrutinee_span,\n+            let arm_source_info = self.source_info(arm.span);\n+            let region_scope = (arm.scope, arm_source_info);\n+            self.in_scope(region_scope, arm.lint_level, |this| {\n+                let arm_block = this.cfg.start_new_block();\n+\n+                let body = this.hir.mirror(arm.body.clone());\n+                let scope = this.declare_bindings(\n+                    None,\n+                    arm.span,\n+                    &arm.patterns[0],\n+                    ArmHasGuard(arm.guard.is_some()),\n+                    Some((Some(&scrutinee_place), scrutinee_span)),\n                 );\n-            }\n \n+                if let Some(source_scope) = scope {\n+                    this.source_scope = source_scope;\n+                }\n \n-            unpack!(arm_block = self.into(destination, arm_block, body));\n+                for candidate in candidates {\n+                    this.clear_top_scope(arm.scope);\n+                    this.bind_and_guard_matched_candidate(\n+                        candidate,\n+                        arm.guard.clone(),\n+                        arm_block,\n+                        &fake_borrow_temps,\n+                        scrutinee_span,\n+                        region_scope,\n+                    );\n+                }\n \n-            arm_block\n+                this.into(destination, arm_block, body)\n+            })\n         }).collect();\n \n         // all the arm blocks will rejoin here\n         let end_block = self.cfg.start_new_block();\n \n         for arm_block in arm_end_blocks {\n             self.cfg.terminate(\n-                arm_block,\n+                unpack!(arm_block),\n                 outer_source_info,\n                 TerminatorKind::Goto { target: end_block },\n             );\n@@ -502,7 +505,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     visibility_scope =\n                         Some(this.new_source_scope(scope_span, LintLevel::Inherited, None));\n                 }\n-                let source_info = SourceInfo { span, this.source_scope };\n+                let source_info = SourceInfo { span, scope: this.source_scope };\n                 let visibility_scope = visibility_scope.unwrap();\n                 this.declare_binding(\n                     source_info,\n@@ -1315,6 +1318,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         arm_block: BasicBlock,\n         fake_borrows: &Vec<(&Place<'tcx>, Local)>,\n         scrutinee_span: Span,\n+        region_scope: (region::Scope, SourceInfo),\n     ) {\n         debug!(\"bind_and_guard_matched_candidate(candidate={:?})\", candidate);\n \n@@ -1497,17 +1501,40 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             //\n             // and that is clearly not correct.\n             let post_guard_block = self.cfg.start_new_block();\n+            let otherwise_post_guard_block = self.cfg.start_new_block();\n             self.cfg.terminate(\n                 block,\n                 source_info,\n                 TerminatorKind::if_(\n                     self.hir.tcx(),\n-                    cond,\n+                    cond.clone(),\n                     post_guard_block,\n-                    candidate.otherwise_block.unwrap()\n+                    otherwise_post_guard_block,\n                 ),\n             );\n \n+            self.exit_scope(\n+                source_info.span,\n+                region_scope,\n+                otherwise_post_guard_block,\n+                candidate.otherwise_block.unwrap(),\n+            );\n+\n+            if let Operand::Copy(cond_place) | Operand::Move(cond_place) = cond {\n+                if let Place::Base(PlaceBase::Local(cond_temp)) = cond_place {\n+                    // We will call `clear_top_scope` if there's another guard. So\n+                    // we have to drop this variable now or it will be \"storage\n+                    // leaked\".\n+                    self.pop_variable(\n+                        post_guard_block,\n+                        region_scope.0,\n+                        cond_temp\n+                    );\n+                } else {\n+                    bug!(\"Expected as_local_operand to produce a temporary\");\n+                }\n+            }\n+\n             let by_value_bindings = candidate.bindings.iter().filter(|binding| {\n                 if let BindingMode::ByValue = binding.binding_mode { true } else { false }\n             });"}, {"sha": "0d1d40a8af6333b42d3f9c73cebacf8c88e8ac7d", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 78, "deletions": 6, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f506aea1fac0977c7215b4240f4d99b45bf7ae97/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f506aea1fac0977c7215b4240f4d99b45bf7ae97/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=f506aea1fac0977c7215b4240f4d99b45bf7ae97", "patch": "@@ -19,13 +19,18 @@ paragraph). This is because region scopes are tied to\n them. Eventually, when we shift to non-lexical lifetimes, there should\n be no need to remember this mapping.\n \n-There is one additional wrinkle, actually, that I wanted to hide from\n-you but duty compels me to mention. In the course of building\n-matches, it sometimes happen that certain code (namely guards) gets\n-executed multiple times. This means that the scope lexical scope may\n-in fact correspond to multiple, disjoint SEME regions. So in fact our\n+### Not so SEME Regions\n+\n+In the course of building matches, it sometimes happens that certain code\n+(namely guards) gets executed multiple times. This means that the scope lexical\n+scope may in fact correspond to multiple, disjoint SEME regions. So in fact our\n mapping is from one scope to a vector of SEME regions.\n \n+Also in matches, the scopes assigned to arms are not even SEME regions! Each\n+arm has a single region with one entry for each pattern. We manually\n+manipulate the scheduled drops in this scope to avoid dropping things multiple\n+times, although drop elaboration would clean this up for value drops.\n+\n ### Drops\n \n The primary purpose for scopes is to insert drops: while building\n@@ -731,7 +736,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // Note that this code iterates scopes from the inner-most to the outer-most,\n             // invalidating caches of each scope visited. This way bare minimum of the\n             // caches gets invalidated. i.e., if a new drop is added into the middle scope, the\n-            // cache of outer scpoe stays intact.\n+            // cache of outer scope stays intact.\n             scope.invalidate_cache(!needs_drop, this_scope);\n             if this_scope {\n                 if let DropKind::Value { .. } = drop_kind {\n@@ -873,6 +878,73 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         success_block\n     }\n+\n+    // `match` arm scopes\n+    // ==================\n+    /// Unschedules any drops in the top scope.\n+    ///\n+    /// This is only needed for `match` arm scopes, because they have one\n+    /// entrance per pattern, but only one exit.\n+    pub fn clear_top_scope(&mut self, region_scope: region::Scope) {\n+        let top_scope = self.scopes.last_mut().unwrap();\n+\n+        assert_eq!(top_scope.region_scope, region_scope);\n+\n+        top_scope.drops.clear();\n+        top_scope.invalidate_cache(false, true);\n+    }\n+\n+    /// Drops the single variable provided\n+    ///\n+    /// * The scope must be the top scope.\n+    /// * The variable must be in that scope.\n+    /// * The variable must be at the top of that scope: it's the next thing\n+    ///   scheduled to drop.\n+    /// * The drop must be of DropKind::Storage.\n+    ///\n+    /// This is used for the boolean holding the result of the match guard. We\n+    /// do this because:\n+    ///\n+    /// * The boolean is different for each pattern\n+    /// * There is only one exit for the arm scope\n+    /// * The guard expression scope is too short, it ends just before the\n+    ///   boolean is tested.\n+    pub fn pop_variable(\n+        &mut self,\n+        block: BasicBlock,\n+        region_scope: region::Scope,\n+        variable: Local,\n+    ) {\n+        let top_scope = self.scopes.last_mut().unwrap();\n+\n+        assert_eq!(top_scope.region_scope, region_scope);\n+\n+        let top_drop_data = top_scope.drops.pop().unwrap();\n+\n+        match top_drop_data.kind {\n+            DropKind::Value { .. } => {\n+                bug!(\"Should not be calling pop_top_variable on non-copy type!\")\n+            }\n+            DropKind::Storage => {\n+                // Drop the storage for both value and storage drops.\n+                // Only temps and vars need their storage dead.\n+                match top_drop_data.location {\n+                    Place::Base(PlaceBase::Local(index)) => {\n+                        let source_info = top_scope.source_info(top_drop_data.span);\n+                        assert_eq!(index, variable);\n+                        self.cfg.push(block, Statement {\n+                            source_info,\n+                            kind: StatementKind::StorageDead(index)\n+                        });\n+                    }\n+                    _ => unreachable!(),\n+                }\n+            }\n+        }\n+\n+        top_scope.invalidate_cache(true, true);\n+    }\n+\n }\n \n /// Builds drops for pop_scope and exit_scope."}, {"sha": "d623f149988c7aed7893e9d1cc9614f7d26c9013", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f506aea1fac0977c7215b4240f4d99b45bf7ae97/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f506aea1fac0977c7215b4240f4d99b45bf7ae97/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=f506aea1fac0977c7215b4240f4d99b45bf7ae97", "patch": "@@ -879,8 +879,12 @@ fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>, arm: &'tcx hir::Arm)\n                 _ => None,\n             },\n         body: arm.body.to_ref(),\n-        // BUG: fix this\n-        lint_level: LintLevel::Inherited,\n+        lint_level: LintLevel::Explicit(arm.hir_id),\n+        scope: region::Scope {\n+            id: arm.hir_id.local_id,\n+            data: region::ScopeData::Node\n+        },\n+        span: arm.span,\n     }\n }\n "}, {"sha": "0850c552536c505d233444e2e679c7ae454d70d7", "filename": "src/test/mir-opt/match_false_edges.rs", "status": "modified", "additions": 78, "deletions": 48, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/f506aea1fac0977c7215b4240f4d99b45bf7ae97/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f506aea1fac0977c7215b4240f4d99b45bf7ae97/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs?ref=f506aea1fac0977c7215b4240f4d99b45bf7ae97", "patch": "@@ -45,13 +45,13 @@ fn main() {\n //      _2 = std::option::Option::<i32>::Some(const 42i32,);\n //      FakeRead(ForMatchedPlace, _2);\n //      _3 = discriminant(_2);\n-//      switchInt(move _3) -> [0isize: bb4, 1isize: bb2, otherwise: bb7];\n+//      switchInt(move _3) -> [0isize: bb4, 1isize: bb2, otherwise: bb6];\n //  }\n //  bb1 (cleanup): {\n //      resume;\n //  }\n //  bb2: {\n-//      falseEdges -> [real: bb8, imaginary: bb3]; //pre_binding1\n+//      falseEdges -> [real: bb7, imaginary: bb3]; //pre_binding1\n //  }\n //  bb3: {\n //      falseEdges -> [real: bb11, imaginary: bb4]; //pre_binding2\n@@ -62,48 +62,56 @@ fn main() {\n //  bb5: {\n //      unreachable;\n //  }\n-//  bb6: { // to pre_binding2\n-//      falseEdges -> [real: bb3, imaginary: bb3];\n-//  }\n-//  bb7: {\n+//  bb6: {\n //      unreachable;\n //  }\n-//  bb8: { // binding1 and guard\n+//  bb7: { // binding1 and guard\n //      StorageLive(_6);\n //      _6 = &(((promoted[0]: std::option::Option<i32>) as Some).0: i32);\n //      _4 = &shallow _2;\n //      StorageLive(_7);\n-//      _7 = const guard() -> [return: bb9, unwind: bb1];\n+//      _7 = const guard() -> [return: bb8, unwind: bb1];\n //  }\n-//  bb9: {\n+//  bb8: { // end of guard\n //      FakeRead(ForMatchGuard, _4);\n //      FakeRead(ForGuardBinding, _6);\n-//      switchInt(move _7) -> [false: bb6, otherwise: bb10];\n+//      switchInt(move _7) -> [false: bb10, otherwise: bb9];\n //  }\n-//  bb10: {\n+//  bb9: { // arm1\n+//      StorageDead(_7);\n //      StorageLive(_5);\n //      _5 = ((_2 as Some).0: i32);\n //      StorageLive(_8);\n //      _8 = _5;\n //      _1 = (const 1i32, move _8);\n //      StorageDead(_8);\n+//      StorageDead(_5);\n+//      StorageDead(_6);\n //      goto -> bb13;\n //  }\n-//  bb11: {\n+//  bb10: { // to pre_binding2\n+//      StorageDead(_7);\n+//      StorageDead(_6);\n+//      falseEdges -> [real: bb3, imaginary: bb3];\n+//  }\n+//  bb11: { // arm2\n //      StorageLive(_9);\n //      _9 = ((_2 as Some).0: i32);\n //      StorageLive(_10);\n //      _10 = _9;\n //      _1 = (const 2i32, move _10);\n //      StorageDead(_10);\n+//      StorageDead(_9);\n //      goto -> bb13;\n //  }\n-//  bb12: {\n+//  bb12: { // arm3\n //      _1 = (const 3i32, const 3i32);\n //      goto -> bb13;\n //  }\n //  bb13: {\n-//      ...\n+//      StorageDead(_1);\n+//      StorageDead(_2);\n+//      _0 = ();\n //      return;\n //  }\n // END rustc.full_tested_match.QualifyAndPromoteConstants.after.mir\n@@ -114,13 +122,13 @@ fn main() {\n //      _2 = std::option::Option::<i32>::Some(const 42i32,);\n //      FakeRead(ForMatchedPlace, _2);\n //      _3 = discriminant(_2);\n-//      switchInt(move _3) -> [0isize: bb3, 1isize: bb2, otherwise: bb7];\n+//      switchInt(move _3) -> [0isize: bb3, 1isize: bb2, otherwise: bb6];\n //  }\n //  bb1 (cleanup): {\n //      resume;\n //  }\n //  bb2: {\n-//      falseEdges -> [real: bb8, imaginary: bb3];\n+//      falseEdges -> [real: bb7, imaginary: bb3];\n //  }\n //  bb3: {\n //      falseEdges -> [real: bb11, imaginary: bb4];\n@@ -131,33 +139,38 @@ fn main() {\n //  bb5: {\n //      unreachable;\n //  }\n-//  bb6: { // to pre_binding3 (can skip 2 since this is `Some`)\n-//      falseEdges -> [real: bb4, imaginary: bb3];\n-//  }\n-//  bb7: {\n+//  bb6: {\n //      unreachable;\n //  }\n-//  bb8: { // binding1 and guard\n+//  bb7: { // binding1 and guard\n //      StorageLive(_6);\n //      _6 = &((_2 as Some).0: i32);\n //      _4 = &shallow _2;\n //      StorageLive(_7);\n-//      _7 = const guard() -> [return: bb9, unwind: bb1];\n+//      _7 = const guard() -> [return: bb8, unwind: bb1];\n //  }\n-//  bb9: { // end of guard\n+//  bb8: { // end of guard\n //      FakeRead(ForMatchGuard, _4);\n //      FakeRead(ForGuardBinding, _6);\n-//      switchInt(move _7) -> [false: bb6, otherwise: bb10];\n+//      switchInt(move _7) -> [false: bb10, otherwise: bb9];\n //  }\n-//  bb10: { // arm1\n+//  bb9: { // arm1\n+//      StorageDead(_7);\n //      StorageLive(_5);\n //      _5 = ((_2 as Some).0: i32);\n //      StorageLive(_8);\n //      _8 = _5;\n //      _1 = (const 1i32, move _8);\n //      StorageDead(_8);\n+//      StorageDead(_5);\n+//      StorageDead(_6);\n //      goto -> bb13;\n //  }\n+//  bb10: { // to pre_binding3 (can skip 2 since this is `Some`)\n+//      StorageDead(_7);\n+//      StorageDead(_6);\n+//      falseEdges -> [real: bb4, imaginary: bb3];\n+//  }\n //  bb11: { // arm2\n //      _1 = (const 3i32, const 3i32);\n //      goto -> bb13;\n@@ -169,16 +182,19 @@ fn main() {\n //      _10 = _9;\n //      _1 = (const 2i32, move _10);\n //      StorageDead(_10);\n+//      StorageDead(_9);\n //      goto -> bb13;\n //  }\n //  bb13: {\n-//      ...\n+//      StorageDead(_1);\n+//      StorageDead(_2);\n+//      _0 = ();\n //      return;\n //  }\n // END rustc.full_tested_match2.QualifyAndPromoteConstants.before.mir\n //\n // START rustc.main.QualifyAndPromoteConstants.before.mir\n-// bb0: {\n+//  bb0: {\n //     ...\n //      _2 = std::option::Option::<i32>::Some(const 1i32,);\n //      FakeRead(ForMatchedPlace, _2);\n@@ -189,79 +205,93 @@ fn main() {\n //      resume;\n //  }\n //  bb2: {\n-//      falseEdges -> [real: bb9, imaginary: bb3];\n+//      falseEdges -> [real: bb7, imaginary: bb3];\n //  }\n //  bb3: {\n-//      falseEdges -> [real: bb12, imaginary: bb4];\n+//      falseEdges -> [real: bb11, imaginary: bb4];\n //  }\n //  bb4: {\n-//      falseEdges -> [real: bb13, imaginary: bb5];\n+//      falseEdges -> [real: bb12, imaginary: bb5];\n //  }\n //  bb5: {\n //      falseEdges -> [real: bb16, imaginary: bb6];\n //  }\n //  bb6: {\n //      unreachable;\n //  }\n-//  bb7: {\n-//      falseEdges -> [real: bb3, imaginary: bb3];\n-//  }\n-//  bb8: {\n-//      falseEdges -> [real: bb5, imaginary: bb5];\n-//  }\n-//  bb9: { // binding1: Some(w) if guard()\n+//  bb7: { // binding1: Some(w) if guard()\n //      StorageLive(_7);\n //      _7 = &((_2 as Some).0: i32);\n //      _5 = &shallow _2;\n //      StorageLive(_8);\n-//      _8 = const guard() -> [return: bb10, unwind: bb1];\n+//      _8 = const guard() -> [return: bb8, unwind: bb1];\n //  }\n-//  bb10: { //end of guard\n+//  bb8: { //end of guard1\n //      FakeRead(ForMatchGuard, _5);\n //      FakeRead(ForGuardBinding, _7);\n-//      switchInt(move _8) -> [false: bb7, otherwise: bb11];\n+//      switchInt(move _8) -> [false: bb10, otherwise: bb9];\n //  }\n-//  bb11: { // set up bindings for arm1\n+//  bb9: {\n+//      StorageDead(_8);\n //      StorageLive(_6);\n //      _6 = ((_2 as Some).0: i32);\n //      _1 = const 1i32;\n+//      StorageDead(_6);\n+//      StorageDead(_7);\n //      goto -> bb17;\n //  }\n-//  bb12: { // binding2 & arm2\n+//  bb10: {\n+//      StorageDead(_8);\n+//      StorageDead(_7);\n+//      falseEdges -> [real: bb3, imaginary: bb3];\n+//  }\n+//  bb11: { // binding2 & arm2\n //      StorageLive(_9);\n //      _9 = _2;\n //      _1 = const 2i32;\n+//      StorageDead(_9);\n //      goto -> bb17;\n //  }\n-//  bb13: { // binding3: Some(y) if guard2(y)\n+//  bb12: { // binding3: Some(y) if guard2(y)\n //      StorageLive(_11);\n //      _11 = &((_2 as Some).0: i32);\n //      _5 = &shallow _2;\n //      StorageLive(_12);\n //      StorageLive(_13);\n //      _13 = (*_11);\n-//      _12 = const guard2(move _13) -> [return: bb14, unwind: bb1];\n+//      _12 = const guard2(move _13) -> [return: bb13, unwind: bb1];\n //  }\n-//  bb14: { // end of guard2\n+//  bb13: { // end of guard2\n //      StorageDead(_13);\n //      FakeRead(ForMatchGuard, _5);\n //      FakeRead(ForGuardBinding, _11);\n-//      switchInt(move _12) -> [false: bb8, otherwise: bb15];\n+//      switchInt(move _12) -> [false: bb15, otherwise: bb14];\n //  }\n-//  bb15: { // binding4 & arm4\n+//  bb14: { // binding4 & arm4\n+//      StorageDead(_12);\n //      StorageLive(_10);\n //      _10 = ((_2 as Some).0: i32);\n //      _1 = const 3i32;\n+//      StorageDead(_10);\n+//      StorageDead(_11);\n //      goto -> bb17;\n //  }\n+//  bb15: {\n+//      StorageDead(_12);\n+//      StorageDead(_11);\n+//      falseEdges -> [real: bb5, imaginary: bb5];\n+//  }\n //  bb16: {\n //      StorageLive(_14);\n //      _14 = _2;\n //      _1 = const 4i32;\n+//      StorageDead(_14);\n //      goto -> bb17;\n //  }\n //  bb17: {\n-//      ...\n+//      StorageDead(_1);\n+//      StorageDead(_2);\n+//      _0 = ();\n //      return;\n //  }\n // END rustc.main.QualifyAndPromoteConstants.before.mir"}, {"sha": "2ef9520c12c637e54c6bb00191c85d01f950a583", "filename": "src/test/mir-opt/match_test.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f506aea1fac0977c7215b4240f4d99b45bf7ae97/src%2Ftest%2Fmir-opt%2Fmatch_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f506aea1fac0977c7215b4240f4d99b45bf7ae97/src%2Ftest%2Fmir-opt%2Fmatch_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_test.rs?ref=f506aea1fac0977c7215b4240f4d99b45bf7ae97", "patch": "@@ -20,10 +20,10 @@ fn main() {\n // START rustc.main.SimplifyCfg-initial.after.mir\n //    bb0: {\n //        ...\n-//        switchInt(move _4) -> [false: bb7, otherwise: bb8];\n+//        switchInt(move _4) -> [false: bb6, otherwise: bb7];\n //    }\n //    bb1: {\n-//        falseEdges -> [real: bb12, imaginary: bb2];\n+//        falseEdges -> [real: bb10, imaginary: bb2];\n //    }\n //    bb2: {\n //        falseEdges -> [real: bb13, imaginary: bb3];\n@@ -38,33 +38,35 @@ fn main() {\n //        unreachable;\n //    }\n //    bb6: {\n-//        falseEdges -> [real: bb4, imaginary: bb2];\n+//        _6 = Le(const 10i32, _1);\n+//        switchInt(move _6) -> [false: bb8, otherwise: bb9];\n //    }\n //    bb7: {\n-//        _6 = Le(const 10i32, _1);\n-//        switchInt(move _6) -> [false: bb9, otherwise: bb10];\n+//        _5 = Lt(_1, const 10i32);\n+//        switchInt(move _5) -> [false: bb6, otherwise: bb1];\n //    }\n //    bb8: {\n-//        _5 = Lt(_1, const 10i32);\n-//        switchInt(move _5) -> [false: bb7, otherwise: bb1];\n+//        switchInt(_1) -> [-1i32: bb3, otherwise: bb4];\n //    }\n //    bb9: {\n-//        switchInt(_1) -> [-1i32: bb3, otherwise: bb4];\n+//        _7 = Le(_1, const 20i32);\n+//        switchInt(move _7) -> [false: bb8, otherwise: bb2];\n //    }\n //    bb10: {\n-//        _7 = Le(_1, const 20i32);\n-//        switchInt(move _7) -> [false: bb9, otherwise: bb2];\n+//        _8 = &shallow _1;\n+//        StorageLive(_9);\n+//        _9 = _2;\n+//        FakeRead(ForMatchGuard, _8);\n+//        switchInt(move _9) -> [false: bb12, otherwise: bb11];\n //    }\n //    bb11: {\n+//        StorageDead(_9);\n //        _3 = const 0i32;\n //        goto -> bb16;\n //    }\n //    bb12: {\n-//        _8 = &shallow _1;\n-//        StorageLive(_9);\n-//        _9 = _2;\n-//        FakeRead(ForMatchGuard, _8);\n-//        switchInt(move _9) -> [false: bb6, otherwise: bb11];\n+//        StorageDead(_9);\n+//        falseEdges -> [real: bb4, imaginary: bb2];\n //    }\n //    bb13: {\n //        _3 = const 1i32;\n@@ -79,7 +81,6 @@ fn main() {\n //        goto -> bb16;\n //    }\n //    bb16: {\n-//        StorageDead(_9);\n //        _0 = ();\n //        StorageDead(_2);\n //        StorageDead(_1);"}, {"sha": "6ac9cee79f53a82e53ace7b82f2c3f3a284ac84b", "filename": "src/test/mir-opt/remove_fake_borrows.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f506aea1fac0977c7215b4240f4d99b45bf7ae97/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f506aea1fac0977c7215b4240f4d99b45bf7ae97/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs?ref=f506aea1fac0977c7215b4240f4d99b45bf7ae97", "patch": "@@ -19,10 +19,10 @@ fn main() {\n // bb0: {\n //     FakeRead(ForMatchedPlace, _1);\n //     _3 = discriminant(_1);\n-//     switchInt(move _3) -> [1isize: bb5, otherwise: bb2];\n+//     switchInt(move _3) -> [1isize: bb4, otherwise: bb2];\n // }\n // bb1: {\n-//     goto -> bb7;\n+//     goto -> bb5;\n // }\n // bb2: {\n //     goto -> bb8;\n@@ -31,16 +31,9 @@ fn main() {\n //     unreachable;\n // }\n // bb4: {\n-//     goto -> bb2;\n-// }\n-// bb5: {\n //     switchInt((*(*((_1 as Some).0: &'<empty> &'<empty> i32)))) -> [0i32: bb1, otherwise: bb2];\n // }\n-// bb6: {\n-//     _0 = const 0i32;\n-//     goto -> bb9;\n-// }\n-// bb7: {\n+// bb5: {\n //     _4 = &shallow _1;\n //     _5 = &shallow ((_1 as Some).0: &'<empty> &'<empty> i32);\n //     _6 = &shallow (*((_1 as Some).0: &'<empty> &'<empty> i32));\n@@ -51,14 +44,22 @@ fn main() {\n //     FakeRead(ForMatchGuard, _5);\n //     FakeRead(ForMatchGuard, _6);\n //     FakeRead(ForMatchGuard, _7);\n-//     switchInt(move _8) -> [false: bb4, otherwise: bb6];\n+//     switchInt(move _8) -> [false: bb7, otherwise: bb6];\n+// }\n+// bb6: {\n+//     StorageDead(_8);\n+//     _0 = const 0i32;\n+//     goto -> bb9;\n+// }\n+// bb7: {\n+//     StorageDead(_8);\n+//     goto -> bb2;\n // }\n // bb8: {\n //     _0 = const 1i32;\n //     goto -> bb9;\n // }\n // bb9: {\n-//     StorageDead(_8);\n //     return;\n // }\n // bb10 (cleanup): {\n@@ -70,10 +71,10 @@ fn main() {\n // bb0: {\n //     nop;\n //     _3 = discriminant(_1);\n-//     switchInt(move _3) -> [1isize: bb5, otherwise: bb2];\n+//     switchInt(move _3) -> [1isize: bb4, otherwise: bb2];\n // }\n // bb1: {\n-//     goto -> bb7;\n+//     goto -> bb5;\n // }\n // bb2: {\n //     goto -> bb8;\n@@ -82,16 +83,9 @@ fn main() {\n //     unreachable;\n // }\n // bb4: {\n-//     goto -> bb2;\n-// }\n-// bb5: {\n //     switchInt((*(*((_1 as Some).0: &'<empty> &'<empty> i32)))) -> [0i32: bb1, otherwise: bb2];\n // }\n-// bb6: {\n-//     _0 = const 0i32;\n-//     goto -> bb9;\n-// }\n-// bb7: {\n+// bb5: {\n //     nop;\n //     nop;\n //     nop;\n@@ -102,14 +96,22 @@ fn main() {\n //     nop;\n //     nop;\n //     nop;\n-//     switchInt(move _8) -> [false: bb4, otherwise: bb6];\n+//     switchInt(move _8) -> [false: bb7, otherwise: bb6];\n+// }\n+// bb6: {\n+//     StorageDead(_8);\n+//     _0 = const 0i32;\n+//     goto -> bb9;\n+// }\n+// bb7: {\n+//     StorageDead(_8);\n+//     goto -> bb2;\n // }\n // bb8: {\n //     _0 = const 1i32;\n //     goto -> bb9;\n // }\n // bb9: {\n-//     StorageDead(_8);\n //     return;\n // }\n // bb10 (cleanup): {"}, {"sha": "78609a6e24b5eefd783900ca4485d0d4e01c43ed", "filename": "src/test/ui/lint/lint-unused-mut-variables.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f506aea1fac0977c7215b4240f4d99b45bf7ae97/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f506aea1fac0977c7215b4240f4d99b45bf7ae97/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.rs?ref=f506aea1fac0977c7215b4240f4d99b45bf7ae97", "patch": "@@ -105,6 +105,14 @@ fn main() {\n       _ => {}\n     }\n \n+    // Attribute should be respected on match arms\n+    match 0 {\n+        #[allow(unused_mut)]\n+        mut x => {\n+            let mut y = 1;\n+        },\n+    }\n+\n     let x = |mut y: isize| y = 32;\n     fn nothing(mut foo: isize) { foo = 37; }\n "}, {"sha": "1a175c9683ec729642b81dae0050c1299e65a14c", "filename": "src/test/ui/lint/lint-unused-mut-variables.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f506aea1fac0977c7215b4240f4d99b45bf7ae97/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f506aea1fac0977c7215b4240f4d99b45bf7ae97/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.stderr?ref=f506aea1fac0977c7215b4240f4d99b45bf7ae97", "patch": "@@ -133,15 +133,15 @@ LL |     fn mut_ref_arg(mut arg : &mut [u8]) -> &mut [u8] {\n    |                    help: remove this `mut`\n \n error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:130:9\n+  --> $DIR/lint-unused-mut-variables.rs:138:9\n    |\n LL |     let mut b = vec![2];\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n    |\n note: lint level defined here\n-  --> $DIR/lint-unused-mut-variables.rs:126:8\n+  --> $DIR/lint-unused-mut-variables.rs:134:8\n    |\n LL | #[deny(unused_mut)]\n    |        ^^^^^^^^^^"}]}