{"sha": "f209843e31af7f0e0212aa28ffec2efad2a70c6f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyMDk4NDNlMzFhZjdmMGUwMjEyYWEyOGZmZWMyZWZhZDJhNzBjNmY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-07-19T11:15:55Z"}, "committer": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-07-19T11:15:55Z"}, "message": "Merge #1545\n\n1545: migrate ra_syntax to the new rowan API r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "548227da78a3bea644f57714d075410c0bdf7469", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/548227da78a3bea644f57714d075410c0bdf7469"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f209843e31af7f0e0212aa28ffec2efad2a70c6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f209843e31af7f0e0212aa28ffec2efad2a70c6f", "html_url": "https://github.com/rust-lang/rust/commit/f209843e31af7f0e0212aa28ffec2efad2a70c6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f209843e31af7f0e0212aa28ffec2efad2a70c6f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "58d4983ba5745975446d60f2886d96f8d2adf0f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/58d4983ba5745975446d60f2886d96f8d2adf0f2", "html_url": "https://github.com/rust-lang/rust/commit/58d4983ba5745975446d60f2886d96f8d2adf0f2"}, {"sha": "d4a66166c002f0a49e41d856a49cb5685ac93202", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4a66166c002f0a49e41d856a49cb5685ac93202", "html_url": "https://github.com/rust-lang/rust/commit/d4a66166c002f0a49e41d856a49cb5685ac93202"}], "stats": {"total": 5084, "additions": 1984, "deletions": 3100}, "files": [{"sha": "141cc60882a3a355822b2a6a393970d557a61ec6", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -1313,7 +1313,7 @@ dependencies = [\n  \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_parser 0.1.0\",\n  \"ra_text_edit 0.1.0\",\n- \"rowan 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rowan 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smol_str 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n  \"unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1584,11 +1584,11 @@ dependencies = [\n \n [[package]]\n name = \"rowan\"\n-version = \"0.5.5\"\n+version = \"0.5.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"colosseum 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"parking_lot 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smol_str 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"text_unit 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2275,7 +2275,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0e7790c7f1cc73d831d28dc5a7deb316a006e7848e6a7f467cdb10a0a9e0fb1c\"\n \"checksum remove_dir_all 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4a83fa3702a688b9359eccba92d153ac33fd2e8462f9e0e3fdf155239ea7792e\"\n \"checksum ron 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"17f52a24414403f81528b67488cf8edc4eda977d3af1646bb6b106a600ead78f\"\n-\"checksum rowan 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"500ba7550373d42593a5228085bad391517378fa31ad2a84defe100dd8259fef\"\n+\"checksum rowan 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0c433ffe99ac9b96fa9882805d05eee5d750c9202fb42d0546c556e5d70d54be\"\n \"checksum rustc-demangle 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a7f4dccf6f4891ebcc0c39f9b6eb1a83b9bf5d747cb439ec6fba4f3b977038af\"\n \"checksum rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7540fc8b0c49f096ee9c961cda096467dce8084bec6bdca2fc83895fd9b28cb8\"\n \"checksum rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a\""}, {"sha": "f19196f53d6a890daf6012ffc44a2c5a632d07dd", "filename": "crates/ra_assists/src/add_derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fadd_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fadd_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_derive.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -9,7 +9,7 @@ use crate::{Assist, AssistCtx, AssistId};\n \n pub(crate) fn add_derive(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let nominal = ctx.node_at_offset::<ast::NominalDef>()?;\n-    let node_start = derive_insertion_offset(nominal)?;\n+    let node_start = derive_insertion_offset(&nominal)?;\n     ctx.add_action(AssistId(\"add_derive\"), \"add `#[derive]`\", |edit| {\n         let derive_attr = nominal\n             .attrs()"}, {"sha": "a69cfc8e3a36f54e8d883f271ba50609b2ef9b25", "filename": "crates/ra_assists/src/add_explicit_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_explicit_type.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -27,7 +27,7 @@ pub(crate) fn add_explicit_type(mut ctx: AssistCtx<impl HirDatabase>) -> Option<\n     // Infer type\n     let db = ctx.db;\n     let analyzer = hir::SourceAnalyzer::new(db, ctx.frange.file_id, stmt.syntax(), None);\n-    let ty = analyzer.type_of(db, expr)?;\n+    let ty = analyzer.type_of(db, &expr)?;\n     // Assist not applicable if the type is unknown\n     if is_unknown(&ty) {\n         return None;"}, {"sha": "cebc19539678e1d364f0154a661e49842b1acfee", "filename": "crates/ra_assists/src/add_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fadd_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fadd_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_impl.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -16,7 +16,7 @@ pub(crate) fn add_impl(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n         let start_offset = nominal.syntax().range().end();\n         let mut buf = String::new();\n         buf.push_str(\"\\n\\nimpl\");\n-        if let Some(type_params) = type_params {\n+        if let Some(type_params) = &type_params {\n             type_params.syntax().text().push_to(&mut buf);\n         }\n         buf.push_str(\" \");\n@@ -25,9 +25,9 @@ pub(crate) fn add_impl(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n             let lifetime_params = type_params\n                 .lifetime_params()\n                 .filter_map(|it| it.lifetime_token())\n-                .map(|it| it.text());\n+                .map(|it| it.text().clone());\n             let type_params =\n-                type_params.type_params().filter_map(|it| it.name()).map(|it| it.text());\n+                type_params.type_params().filter_map(|it| it.name()).map(|it| it.text().clone());\n             join(lifetime_params.chain(type_params)).surround_with(\"<\", \">\").to_buf(&mut buf);\n         }\n         buf.push_str(\" {\\n\");"}, {"sha": "b992a4dc80257c37b8213f2d882574f201788287", "filename": "crates/ra_assists/src/add_missing_impl_members.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -5,8 +5,8 @@ use crate::{\n \n use hir::{db::HirDatabase, HasSource};\n use ra_db::FilePosition;\n-use ra_syntax::ast::{self, AstNode, ImplItem, ImplItemKind, NameOwner};\n-use ra_syntax::{SmolStr, TreeArc};\n+use ra_syntax::ast::{self, AstNode, ImplItemKind, NameOwner};\n+use ra_syntax::SmolStr;\n \n #[derive(PartialEq)]\n enum AddMissingImplMembersMode {\n@@ -46,16 +46,16 @@ fn add_missing_impl_members_inner(\n         let position = FilePosition { file_id, offset: impl_node.syntax().range().start() };\n         let analyzer = hir::SourceAnalyzer::new(ctx.db, position.file_id, impl_node.syntax(), None);\n \n-        resolve_target_trait_def(ctx.db, &analyzer, impl_node)?\n+        resolve_target_trait_def(ctx.db, &analyzer, &impl_node)?\n     };\n \n-    let def_name = |kind| -> Option<&SmolStr> {\n+    let def_name = |kind| -> Option<SmolStr> {\n         match kind {\n-            ImplItemKind::FnDef(def) => def.name(),\n-            ImplItemKind::TypeAliasDef(def) => def.name(),\n-            ImplItemKind::ConstDef(def) => def.name(),\n+            ast::ImplItemKind::FnDef(def) => def.name(),\n+            ast::ImplItemKind::TypeAliasDef(def) => def.name(),\n+            ast::ImplItemKind::ConstDef(def) => def.name(),\n         }\n-        .map(ast::Name::text)\n+        .map(|it| it.text().clone())\n     };\n \n     let trait_items = trait_def.item_list()?.impl_items();\n@@ -78,18 +78,13 @@ fn add_missing_impl_members_inner(\n \n     ctx.add_action(AssistId(assist_id), label, |edit| {\n         let n_existing_items = impl_item_list.impl_items().count();\n-        let items: Vec<_> = missing_items\n-            .into_iter()\n-            .map(|it| match it.kind() {\n-                ImplItemKind::FnDef(def) => {\n-                    strip_docstring(ImplItem::cast(add_body(def).syntax()).unwrap())\n-                }\n-                _ => strip_docstring(it),\n-            })\n-            .collect();\n+        let items = missing_items.into_iter().map(|it| match it.kind() {\n+            ImplItemKind::FnDef(def) => strip_docstring(add_body(def).into()),\n+            _ => strip_docstring(it),\n+        });\n         let mut ast_editor = AstEditor::new(impl_item_list);\n \n-        ast_editor.append_items(items.iter().map(|it| &**it));\n+        ast_editor.append_items(items);\n \n         let first_new_item = ast_editor.ast().impl_items().nth(n_existing_items).unwrap();\n         let cursor_position = first_new_item.syntax().range().start();\n@@ -101,14 +96,14 @@ fn add_missing_impl_members_inner(\n     ctx.build()\n }\n \n-fn strip_docstring(item: &ast::ImplItem) -> TreeArc<ast::ImplItem> {\n+fn strip_docstring(item: ast::ImplItem) -> ast::ImplItem {\n     let mut ast_editor = AstEditor::new(item);\n     ast_editor.strip_attrs_and_docs();\n     ast_editor.ast().to_owned()\n }\n \n-fn add_body(fn_def: &ast::FnDef) -> TreeArc<ast::FnDef> {\n-    let mut ast_editor = AstEditor::new(fn_def);\n+fn add_body(fn_def: ast::FnDef) -> ast::FnDef {\n+    let mut ast_editor = AstEditor::new(fn_def.clone());\n     if fn_def.body().is_none() {\n         ast_editor.set_body(&AstBuilder::<ast::Block>::single_expr(\n             &AstBuilder::<ast::Expr>::unimplemented(),\n@@ -123,9 +118,12 @@ fn resolve_target_trait_def(\n     db: &impl HirDatabase,\n     analyzer: &hir::SourceAnalyzer,\n     impl_block: &ast::ImplBlock,\n-) -> Option<TreeArc<ast::TraitDef>> {\n-    let ast_path =\n-        impl_block.target_trait().map(AstNode::syntax).and_then(ast::PathType::cast)?.path()?;\n+) -> Option<ast::TraitDef> {\n+    let ast_path = impl_block\n+        .target_trait()\n+        .map(|it| it.syntax().clone())\n+        .and_then(ast::PathType::cast)?\n+        .path()?;\n \n     match analyzer.resolve_path(db, &ast_path) {\n         Some(hir::PathResolution::Def(hir::ModuleDef::Trait(def))) => Some(def.source(db).ast),"}, {"sha": "e52085f85dfd55b87520d3f26bd9c44f05461a7c", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -49,7 +49,7 @@ pub(crate) enum Assist {\n pub(crate) struct AssistCtx<'a, DB> {\n     pub(crate) db: &'a DB,\n     pub(crate) frange: FileRange,\n-    source_file: &'a SourceFile,\n+    source_file: SourceFile,\n     should_compute_edit: bool,\n     assist: Assist,\n }\n@@ -59,7 +59,7 @@ impl<'a, DB> Clone for AssistCtx<'a, DB> {\n         AssistCtx {\n             db: self.db,\n             frange: self.frange,\n-            source_file: self.source_file,\n+            source_file: self.source_file.clone(),\n             should_compute_edit: self.should_compute_edit,\n             assist: self.assist.clone(),\n         }\n@@ -104,18 +104,18 @@ impl<'a, DB: HirDatabase> AssistCtx<'a, DB> {\n         Some(self.assist)\n     }\n \n-    pub(crate) fn token_at_offset(&self) -> TokenAtOffset<SyntaxToken<'a>> {\n+    pub(crate) fn token_at_offset(&self) -> TokenAtOffset<SyntaxToken> {\n         find_token_at_offset(self.source_file.syntax(), self.frange.range.start())\n     }\n \n-    pub(crate) fn node_at_offset<N: AstNode>(&self) -> Option<&'a N> {\n+    pub(crate) fn node_at_offset<N: AstNode>(&self) -> Option<N> {\n         find_node_at_offset(self.source_file.syntax(), self.frange.range.start())\n     }\n-    pub(crate) fn covering_element(&self) -> SyntaxElement<'a> {\n+    pub(crate) fn covering_element(&self) -> SyntaxElement {\n         find_covering_element(self.source_file.syntax(), self.frange.range)\n     }\n \n-    pub(crate) fn covering_node_for_range(&self, range: TextRange) -> SyntaxElement<'a> {\n+    pub(crate) fn covering_node_for_range(&self, range: TextRange) -> SyntaxElement {\n         find_covering_element(self.source_file.syntax(), range)\n     }\n }\n@@ -139,7 +139,7 @@ impl AssistBuilder {\n     ) {\n         let mut replace_with = replace_with.into();\n         if let Some(indent) = leading_indent(node) {\n-            replace_with = reindent(&replace_with, indent)\n+            replace_with = reindent(&replace_with, &indent)\n         }\n         self.replace(node.range(), replace_with)\n     }"}, {"sha": "5fbcadfee80f94356672d5f293c390be64c5ecbf", "filename": "crates/ra_assists/src/ast_editor.rs", "status": "modified", "additions": 65, "deletions": 58, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_editor.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -4,18 +4,18 @@ use arrayvec::ArrayVec;\n use hir::Name;\n use ra_fmt::leading_indent;\n use ra_syntax::{\n-    ast, AstNode, Direction, InsertPosition, SourceFile, SyntaxElement, SyntaxKind::*, TreeArc, T,\n+    ast, AstNode, Direction, InsertPosition, SourceFile, SyntaxElement, SyntaxKind::*, T,\n };\n use ra_text_edit::TextEditBuilder;\n \n pub struct AstEditor<N: AstNode> {\n-    original_ast: TreeArc<N>,\n-    ast: TreeArc<N>,\n+    original_ast: N,\n+    ast: N,\n }\n \n impl<N: AstNode> AstEditor<N> {\n-    pub fn new(node: &N) -> AstEditor<N> {\n-        AstEditor { original_ast: node.to_owned(), ast: node.to_owned() }\n+    pub fn new(node: N) -> AstEditor<N> {\n+        AstEditor { original_ast: node.clone(), ast: node }\n     }\n \n     pub fn into_text_edit(self, builder: &mut TextEditBuilder) {\n@@ -26,27 +26,27 @@ impl<N: AstNode> AstEditor<N> {\n     }\n \n     pub fn ast(&self) -> &N {\n-        &*self.ast\n+        &self.ast\n     }\n \n     #[must_use]\n-    fn insert_children<'a>(\n+    fn insert_children(\n         &self,\n-        position: InsertPosition<SyntaxElement<'_>>,\n-        to_insert: impl Iterator<Item = SyntaxElement<'a>>,\n-    ) -> TreeArc<N> {\n+        position: InsertPosition<SyntaxElement>,\n+        to_insert: impl Iterator<Item = SyntaxElement>,\n+    ) -> N {\n         let new_syntax = self.ast().syntax().insert_children(position, to_insert);\n-        N::cast(&new_syntax).unwrap().to_owned()\n+        N::cast(new_syntax).unwrap()\n     }\n \n     #[must_use]\n-    fn replace_children<'a>(\n+    fn replace_children(\n         &self,\n-        to_delete: RangeInclusive<SyntaxElement<'_>>,\n-        to_insert: impl Iterator<Item = SyntaxElement<'a>>,\n-    ) -> TreeArc<N> {\n+        to_delete: RangeInclusive<SyntaxElement>,\n+        to_insert: impl Iterator<Item = SyntaxElement>,\n+    ) -> N {\n         let new_syntax = self.ast().syntax().replace_children(to_delete, to_insert);\n-        N::cast(&new_syntax).unwrap().to_owned()\n+        N::cast(new_syntax).unwrap()\n     }\n \n     fn do_make_multiline(&mut self) {\n@@ -66,16 +66,18 @@ impl<N: AstNode> AstEditor<N> {\n                 if ws.text().contains('\\n') {\n                     return;\n                 }\n-                Some(ws)\n+                Some(ws.clone())\n             }\n         };\n \n-        let indent = leading_indent(self.ast().syntax()).unwrap_or(\"\");\n+        let indent = leading_indent(self.ast().syntax()).unwrap_or(\"\".into());\n         let ws = tokens::WsBuilder::new(&format!(\"\\n{}\", indent));\n         let to_insert = iter::once(ws.ws().into());\n         self.ast = match existing_ws {\n             None => self.insert_children(InsertPosition::After(l_curly), to_insert),\n-            Some(ws) => self.replace_children(RangeInclusive::new(ws.into(), ws.into()), to_insert),\n+            Some(ws) => {\n+                self.replace_children(RangeInclusive::new(ws.clone().into(), ws.into()), to_insert)\n+            }\n         };\n     }\n }\n@@ -95,7 +97,7 @@ impl AstEditor<ast::NamedFieldList> {\n         let space = if is_multiline {\n             ws = tokens::WsBuilder::new(&format!(\n                 \"\\n{}    \",\n-                leading_indent(self.ast().syntax()).unwrap_or(\"\")\n+                leading_indent(self.ast().syntax()).unwrap_or(\"\".into())\n             ));\n             ws.ws()\n         } else {\n@@ -104,7 +106,7 @@ impl AstEditor<ast::NamedFieldList> {\n \n         let mut to_insert: ArrayVec<[SyntaxElement; 4]> = ArrayVec::new();\n         to_insert.push(space.into());\n-        to_insert.push(field.syntax().into());\n+        to_insert.push(field.syntax().clone().into());\n         to_insert.push(tokens::comma().into());\n \n         macro_rules! after_l_curly {\n@@ -127,7 +129,7 @@ impl AstEditor<ast::NamedFieldList> {\n                     InsertPosition::After(comma)\n                 } else {\n                     to_insert.insert(0, tokens::comma().into());\n-                    InsertPosition::After($anchor.syntax().into())\n+                    InsertPosition::After($anchor.syntax().clone().into())\n                 }\n             };\n         };\n@@ -144,7 +146,9 @@ impl AstEditor<ast::NamedFieldList> {\n                     None => after_l_curly!(),\n                 }\n             }\n-            InsertPosition::Before(anchor) => InsertPosition::Before(anchor.syntax().into()),\n+            InsertPosition::Before(anchor) => {\n+                InsertPosition::Before(anchor.syntax().clone().into())\n+            }\n             InsertPosition::After(anchor) => after_field!(anchor),\n         };\n \n@@ -157,30 +161,31 @@ impl AstEditor<ast::NamedFieldList> {\n }\n \n impl AstEditor<ast::ItemList> {\n-    pub fn append_items<'a>(&mut self, items: impl Iterator<Item = &'a ast::ImplItem>) {\n+    pub fn append_items(&mut self, items: impl Iterator<Item = ast::ImplItem>) {\n         let n_existing_items = self.ast().impl_items().count();\n         if n_existing_items == 0 {\n             self.do_make_multiline();\n         }\n         items.for_each(|it| self.append_item(it));\n     }\n \n-    pub fn append_item(&mut self, item: &ast::ImplItem) {\n+    pub fn append_item(&mut self, item: ast::ImplItem) {\n         let (indent, position) = match self.ast().impl_items().last() {\n             Some(it) => (\n-                leading_indent(it.syntax()).unwrap_or(\"\").to_string(),\n-                InsertPosition::After(it.syntax().into()),\n+                leading_indent(it.syntax()).unwrap_or_default().to_string(),\n+                InsertPosition::After(it.syntax().clone().into()),\n             ),\n             None => match self.l_curly() {\n                 Some(it) => (\n-                    \"    \".to_string() + leading_indent(self.ast().syntax()).unwrap_or(\"\"),\n+                    \"    \".to_string() + &leading_indent(self.ast().syntax()).unwrap_or_default(),\n                     InsertPosition::After(it),\n                 ),\n                 None => return,\n             },\n         };\n         let ws = tokens::WsBuilder::new(&format!(\"\\n{}\", indent));\n-        let to_insert: ArrayVec<[SyntaxElement; 2]> = [ws.ws().into(), item.syntax().into()].into();\n+        let to_insert: ArrayVec<[SyntaxElement; 2]> =\n+            [ws.ws().into(), item.syntax().clone().into()].into();\n         self.ast = self.insert_children(position, to_insert.into_iter());\n     }\n \n@@ -197,9 +202,9 @@ impl AstEditor<ast::ImplItem> {\n             .children_with_tokens()\n             .find(|it| it.kind() == ATTR || it.kind() == COMMENT)\n         {\n-            let end = match start.next_sibling_or_token() {\n-                Some(el) if el.kind() == WHITESPACE => el,\n-                Some(_) | None => start,\n+            let end = match &start.next_sibling_or_token() {\n+                Some(el) if el.kind() == WHITESPACE => el.clone(),\n+                Some(_) | None => start.clone(),\n             };\n             self.ast = self.replace_children(RangeInclusive::new(start, end), iter::empty());\n         }\n@@ -210,18 +215,18 @@ impl AstEditor<ast::FnDef> {\n     pub fn set_body(&mut self, body: &ast::Block) {\n         let mut to_insert: ArrayVec<[SyntaxElement; 2]> = ArrayVec::new();\n         let old_body_or_semi: SyntaxElement = if let Some(old_body) = self.ast().body() {\n-            old_body.syntax().into()\n+            old_body.syntax().clone().into()\n         } else if let Some(semi) = self.ast().semicolon_token() {\n             to_insert.push(tokens::single_space().into());\n             semi.into()\n         } else {\n             to_insert.push(tokens::single_space().into());\n-            to_insert.push(body.syntax().into());\n+            to_insert.push(body.syntax().clone().into());\n             self.ast = self.insert_children(InsertPosition::Last, to_insert.into_iter());\n             return;\n         };\n-        to_insert.push(body.syntax().into());\n-        let replace_range = RangeInclusive::new(old_body_or_semi, old_body_or_semi);\n+        to_insert.push(body.syntax().clone().into());\n+        let replace_range = RangeInclusive::new(old_body_or_semi.clone(), old_body_or_semi);\n         self.ast = self.replace_children(replace_range, to_insert.into_iter())\n     }\n }\n@@ -231,15 +236,15 @@ pub struct AstBuilder<N: AstNode> {\n }\n \n impl AstBuilder<ast::NamedField> {\n-    pub fn from_name(name: &Name) -> TreeArc<ast::NamedField> {\n+    pub fn from_name(name: &Name) -> ast::NamedField {\n         ast_node_from_file_text(&format!(\"fn f() {{ S {{ {}: (), }} }}\", name))\n     }\n \n-    fn from_text(text: &str) -> TreeArc<ast::NamedField> {\n+    fn from_text(text: &str) -> ast::NamedField {\n         ast_node_from_file_text(&format!(\"fn f() {{ S {{ {}, }} }}\", text))\n     }\n \n-    pub fn from_pieces(name: &ast::NameRef, expr: Option<&ast::Expr>) -> TreeArc<ast::NamedField> {\n+    pub fn from_pieces(name: &ast::NameRef, expr: Option<&ast::Expr>) -> ast::NamedField {\n         match expr {\n             Some(expr) => Self::from_text(&format!(\"{}: {}\", name.syntax(), expr.syntax())),\n             None => Self::from_text(&name.syntax().to_string()),\n@@ -248,84 +253,86 @@ impl AstBuilder<ast::NamedField> {\n }\n \n impl AstBuilder<ast::Block> {\n-    fn from_text(text: &str) -> TreeArc<ast::Block> {\n+    fn from_text(text: &str) -> ast::Block {\n         ast_node_from_file_text(&format!(\"fn f() {}\", text))\n     }\n \n-    pub fn single_expr(e: &ast::Expr) -> TreeArc<ast::Block> {\n+    pub fn single_expr(e: &ast::Expr) -> ast::Block {\n         Self::from_text(&format!(\"{{ {} }}\", e.syntax()))\n     }\n }\n \n impl AstBuilder<ast::Expr> {\n-    fn from_text(text: &str) -> TreeArc<ast::Expr> {\n+    fn from_text(text: &str) -> ast::Expr {\n         ast_node_from_file_text(&format!(\"fn f() {{ {}; }}\", text))\n     }\n \n-    pub fn unit() -> TreeArc<ast::Expr> {\n+    pub fn unit() -> ast::Expr {\n         Self::from_text(\"()\")\n     }\n \n-    pub fn unimplemented() -> TreeArc<ast::Expr> {\n+    pub fn unimplemented() -> ast::Expr {\n         Self::from_text(\"unimplemented!()\")\n     }\n }\n \n impl AstBuilder<ast::NameRef> {\n-    pub fn new(text: &str) -> TreeArc<ast::NameRef> {\n+    pub fn new(text: &str) -> ast::NameRef {\n         ast_node_from_file_text(&format!(\"fn f() {{ {}; }}\", text))\n     }\n }\n \n-fn ast_node_from_file_text<N: AstNode>(text: &str) -> TreeArc<N> {\n+fn ast_node_from_file_text<N: AstNode>(text: &str) -> N {\n     let parse = SourceFile::parse(text);\n     let res = parse.tree().syntax().descendants().find_map(N::cast).unwrap().to_owned();\n     res\n }\n \n mod tokens {\n     use once_cell::sync::Lazy;\n-    use ra_syntax::{AstNode, SourceFile, SyntaxKind::*, SyntaxToken, TreeArc, T};\n+    use ra_syntax::{AstNode, Parse, SourceFile, SyntaxKind::*, SyntaxToken, T};\n \n-    static SOURCE_FILE: Lazy<TreeArc<SourceFile>> =\n-        Lazy::new(|| SourceFile::parse(\",\\n; ;\").tree().to_owned());\n+    static SOURCE_FILE: Lazy<Parse<SourceFile>> = Lazy::new(|| SourceFile::parse(\",\\n; ;\"));\n \n-    pub(crate) fn comma() -> SyntaxToken<'static> {\n+    pub(crate) fn comma() -> SyntaxToken {\n         SOURCE_FILE\n+            .tree()\n             .syntax()\n             .descendants_with_tokens()\n-            .filter_map(|it| it.as_token())\n+            .filter_map(|it| it.as_token().cloned())\n             .find(|it| it.kind() == T![,])\n             .unwrap()\n     }\n \n-    pub(crate) fn single_space() -> SyntaxToken<'static> {\n+    pub(crate) fn single_space() -> SyntaxToken {\n         SOURCE_FILE\n+            .tree()\n             .syntax()\n             .descendants_with_tokens()\n-            .filter_map(|it| it.as_token())\n+            .filter_map(|it| it.as_token().cloned())\n             .find(|it| it.kind() == WHITESPACE && it.text().as_str() == \" \")\n             .unwrap()\n     }\n \n     #[allow(unused)]\n-    pub(crate) fn single_newline() -> SyntaxToken<'static> {\n+    pub(crate) fn single_newline() -> SyntaxToken {\n         SOURCE_FILE\n+            .tree()\n             .syntax()\n             .descendants_with_tokens()\n-            .filter_map(|it| it.as_token())\n+            .filter_map(|it| it.as_token().cloned())\n             .find(|it| it.kind() == WHITESPACE && it.text().as_str() == \"\\n\")\n             .unwrap()\n     }\n \n-    pub(crate) struct WsBuilder(TreeArc<SourceFile>);\n+    pub(crate) struct WsBuilder(SourceFile);\n \n     impl WsBuilder {\n         pub(crate) fn new(text: &str) -> WsBuilder {\n             WsBuilder(SourceFile::parse(text).ok().unwrap())\n         }\n-        pub(crate) fn ws(&self) -> SyntaxToken<'_> {\n-            self.0.syntax().first_child_or_token().unwrap().as_token().unwrap()\n+        pub(crate) fn ws(&self) -> SyntaxToken {\n+            self.0.syntax().first_child_or_token().unwrap().as_token().cloned().unwrap()\n         }\n     }\n "}, {"sha": "0eb4bdb6225bcb78d2d2030289a6c2739f1df30d", "filename": "crates/ra_assists/src/auto_import.rs", "status": "modified", "additions": 76, "deletions": 67, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fauto_import.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -12,25 +12,25 @@ use ra_syntax::{\n     SyntaxNode, TextRange, T,\n };\n \n-fn collect_path_segments_raw<'a>(\n-    segments: &mut Vec<&'a ast::PathSegment>,\n-    mut path: &'a ast::Path,\n+fn collect_path_segments_raw(\n+    segments: &mut Vec<ast::PathSegment>,\n+    mut path: ast::Path,\n ) -> Option<usize> {\n     let oldlen = segments.len();\n     loop {\n         let mut children = path.syntax().children_with_tokens();\n         let (first, second, third) = (\n-            children.next().map(|n| (n, n.kind())),\n-            children.next().map(|n| (n, n.kind())),\n-            children.next().map(|n| (n, n.kind())),\n+            children.next().map(|n| (n.clone(), n.kind())),\n+            children.next().map(|n| (n.clone(), n.kind())),\n+            children.next().map(|n| (n.clone(), n.kind())),\n         );\n         match (first, second, third) {\n             (Some((subpath, PATH)), Some((_, T![::])), Some((segment, PATH_SEGMENT))) => {\n-                path = ast::Path::cast(subpath.as_node()?)?;\n-                segments.push(ast::PathSegment::cast(segment.as_node()?)?);\n+                path = ast::Path::cast(subpath.as_node()?.clone())?;\n+                segments.push(ast::PathSegment::cast(segment.as_node()?.clone())?);\n             }\n             (Some((segment, PATH_SEGMENT)), _, _) => {\n-                segments.push(ast::PathSegment::cast(segment.as_node()?)?);\n+                segments.push(ast::PathSegment::cast(segment.as_node()?.clone())?);\n                 break;\n             }\n             (_, _, _) => return None,\n@@ -60,7 +60,7 @@ fn fmt_segments_raw(segments: &[SmolStr], buf: &mut String) {\n }\n \n // Returns the numeber of common segments.\n-fn compare_path_segments(left: &[SmolStr], right: &[&ast::PathSegment]) -> usize {\n+fn compare_path_segments(left: &[SmolStr], right: &[ast::PathSegment]) -> usize {\n     left.iter().zip(right).filter(|(l, r)| compare_path_segment(l, r)).count()\n }\n \n@@ -81,43 +81,43 @@ fn compare_path_segment_with_name(a: &SmolStr, b: &ast::Name) -> bool {\n     a == b.text()\n }\n \n-#[derive(Copy, Clone)]\n-enum ImportAction<'a> {\n+#[derive(Clone)]\n+enum ImportAction {\n     Nothing,\n     // Add a brand new use statement.\n     AddNewUse {\n-        anchor: Option<&'a SyntaxNode>, // anchor node\n+        anchor: Option<SyntaxNode>, // anchor node\n         add_after_anchor: bool,\n     },\n \n     // To split an existing use statement creating a nested import.\n     AddNestedImport {\n         // how may segments matched with the target path\n         common_segments: usize,\n-        path_to_split: &'a ast::Path,\n+        path_to_split: ast::Path,\n         // the first segment of path_to_split we want to add into the new nested list\n-        first_segment_to_split: Option<&'a ast::PathSegment>,\n+        first_segment_to_split: Option<ast::PathSegment>,\n         // Wether to add 'self' in addition to the target path\n         add_self: bool,\n     },\n     // To add the target path to an existing nested import tree list.\n     AddInTreeList {\n         common_segments: usize,\n         // The UseTreeList where to add the target path\n-        tree_list: &'a ast::UseTreeList,\n+        tree_list: ast::UseTreeList,\n         add_self: bool,\n     },\n }\n \n-impl<'a> ImportAction<'a> {\n-    fn add_new_use(anchor: Option<&'a SyntaxNode>, add_after_anchor: bool) -> Self {\n+impl ImportAction {\n+    fn add_new_use(anchor: Option<SyntaxNode>, add_after_anchor: bool) -> Self {\n         ImportAction::AddNewUse { anchor, add_after_anchor }\n     }\n \n     fn add_nested_import(\n         common_segments: usize,\n-        path_to_split: &'a ast::Path,\n-        first_segment_to_split: Option<&'a ast::PathSegment>,\n+        path_to_split: ast::Path,\n+        first_segment_to_split: Option<ast::PathSegment>,\n         add_self: bool,\n     ) -> Self {\n         ImportAction::AddNestedImport {\n@@ -130,14 +130,14 @@ impl<'a> ImportAction<'a> {\n \n     fn add_in_tree_list(\n         common_segments: usize,\n-        tree_list: &'a ast::UseTreeList,\n+        tree_list: ast::UseTreeList,\n         add_self: bool,\n     ) -> Self {\n         ImportAction::AddInTreeList { common_segments, tree_list, add_self }\n     }\n \n-    fn better<'b>(left: &'b ImportAction<'a>, right: &'b ImportAction<'a>) -> &'b ImportAction<'a> {\n-        if left.is_better(right) {\n+    fn better(left: ImportAction, right: ImportAction) -> ImportAction {\n+        if left.is_better(&right) {\n             left\n         } else {\n             right\n@@ -166,12 +166,12 @@ impl<'a> ImportAction<'a> {\n \n // Find out the best ImportAction to import target path against current_use_tree.\n // If current_use_tree has a nested import the function gets called recursively on every UseTree inside a UseTreeList.\n-fn walk_use_tree_for_best_action<'a>(\n-    current_path_segments: &mut Vec<&'a ast::PathSegment>, // buffer containing path segments\n-    current_parent_use_tree_list: Option<&'a ast::UseTreeList>, // will be Some value if we are in a nested import\n-    current_use_tree: &'a ast::UseTree, // the use tree we are currently examinating\n-    target: &[SmolStr],                 // the path we want to import\n-) -> ImportAction<'a> {\n+fn walk_use_tree_for_best_action(\n+    current_path_segments: &mut Vec<ast::PathSegment>, // buffer containing path segments\n+    current_parent_use_tree_list: Option<ast::UseTreeList>, // will be Some value if we are in a nested import\n+    current_use_tree: ast::UseTree, // the use tree we are currently examinating\n+    target: &[SmolStr],             // the path we want to import\n+) -> ImportAction {\n     // We save the number of segments in the buffer so we can restore the correct segments\n     // before returning. Recursive call will add segments so we need to delete them.\n     let prev_len = current_path_segments.len();\n@@ -188,32 +188,36 @@ fn walk_use_tree_for_best_action<'a>(\n                     .syntax()\n                     .ancestors()\n                     .find_map(ast::UseItem::cast)\n-                    .map(AstNode::syntax),\n+                    .map(|it| it.syntax().clone()),\n                 true,\n             );\n         }\n     };\n \n     // This can happen only if current_use_tree is a direct child of a UseItem\n-    if let Some(name) = alias.and_then(ast::NameOwner::name) {\n-        if compare_path_segment_with_name(&target[0], name) {\n+    if let Some(name) = alias.and_then(|it| it.name()) {\n+        if compare_path_segment_with_name(&target[0], &name) {\n             return ImportAction::Nothing;\n         }\n     }\n \n-    collect_path_segments_raw(current_path_segments, path);\n+    collect_path_segments_raw(current_path_segments, path.clone());\n \n     // We compare only the new segments added in the line just above.\n     // The first prev_len segments were already compared in 'parent' recursive calls.\n     let left = target.split_at(prev_len).1;\n     let right = current_path_segments.split_at(prev_len).1;\n-    let common = compare_path_segments(left, right);\n+    let common = compare_path_segments(left, &right);\n     let mut action = match common {\n         0 => ImportAction::add_new_use(\n             // e.g: target is std::fmt and we can have\n             // use foo::bar\n             // We add a brand new use statement\n-            current_use_tree.syntax().ancestors().find_map(ast::UseItem::cast).map(AstNode::syntax),\n+            current_use_tree\n+                .syntax()\n+                .ancestors()\n+                .find_map(ast::UseItem::cast)\n+                .map(|it| it.syntax().clone()),\n             true,\n         ),\n         common if common == left.len() && left.len() == right.len() => {\n@@ -223,9 +227,9 @@ fn walk_use_tree_for_best_action<'a>(\n             if let Some(list) = tree_list {\n                 // In case 2 we need to add self to the nested list\n                 // unless it's already there\n-                let has_self = list.use_trees().map(ast::UseTree::path).any(|p| {\n-                    p.and_then(ast::Path::segment)\n-                        .and_then(ast::PathSegment::kind)\n+                let has_self = list.use_trees().map(|it| it.path()).any(|p| {\n+                    p.and_then(|it| it.segment())\n+                        .and_then(|it| it.kind())\n                         .filter(|k| *k == ast::PathSegmentKind::SelfKw)\n                         .is_some()\n                 });\n@@ -248,7 +252,7 @@ fn walk_use_tree_for_best_action<'a>(\n             ImportAction::add_nested_import(\n                 prev_len + common,\n                 path,\n-                Some(segments_to_split[0]),\n+                Some(segments_to_split[0].clone()),\n                 false,\n             )\n         }\n@@ -263,14 +267,18 @@ fn walk_use_tree_for_best_action<'a>(\n                     .syntax()\n                     .ancestors()\n                     .find_map(ast::UseItem::cast)\n-                    .map(AstNode::syntax),\n+                    .map(|it| it.syntax().clone()),\n                 true,\n             );\n             if let Some(list) = tree_list {\n                 // Case 2, check recursively if the path is already imported in the nested list\n                 for u in list.use_trees() {\n-                    let child_action =\n-                        walk_use_tree_for_best_action(current_path_segments, Some(list), u, target);\n+                    let child_action = walk_use_tree_for_best_action(\n+                        current_path_segments,\n+                        Some(list.clone()),\n+                        u,\n+                        target,\n+                    );\n                     if child_action.is_better(&better_action) {\n                         better_action = child_action;\n                         if let ImportAction::Nothing = better_action {\n@@ -291,7 +299,7 @@ fn walk_use_tree_for_best_action<'a>(\n             ImportAction::add_nested_import(\n                 prev_len + common,\n                 path,\n-                Some(segments_to_split[0]),\n+                Some(segments_to_split[0].clone()),\n                 true,\n             )\n         }\n@@ -302,7 +310,7 @@ fn walk_use_tree_for_best_action<'a>(\n             ImportAction::add_nested_import(\n                 prev_len + common,\n                 path,\n-                Some(segments_to_split[0]),\n+                Some(segments_to_split[0].clone()),\n                 false,\n             )\n         }\n@@ -311,7 +319,7 @@ fn walk_use_tree_for_best_action<'a>(\n \n     // If we are inside a UseTreeList adding a use statement become adding to the existing\n     // tree list.\n-    action = match (current_parent_use_tree_list, action) {\n+    action = match (current_parent_use_tree_list, action.clone()) {\n         (Some(use_tree_list), ImportAction::AddNewUse { .. }) => {\n             ImportAction::add_in_tree_list(prev_len, use_tree_list, false)\n         }\n@@ -323,19 +331,20 @@ fn walk_use_tree_for_best_action<'a>(\n     action\n }\n \n-fn best_action_for_target<'b, 'a: 'b>(\n-    container: &'a SyntaxNode,\n-    anchor: &'a SyntaxNode,\n-    target: &'b [SmolStr],\n-) -> ImportAction<'a> {\n+fn best_action_for_target(\n+    container: SyntaxNode,\n+    anchor: SyntaxNode,\n+    target: &[SmolStr],\n+) -> ImportAction {\n     let mut storage = Vec::with_capacity(16); // this should be the only allocation\n     let best_action = container\n         .children()\n         .filter_map(ast::UseItem::cast)\n-        .filter_map(ast::UseItem::use_tree)\n+        .filter_map(|it| it.use_tree())\n         .map(|u| walk_use_tree_for_best_action(&mut storage, None, u, target))\n-        .fold(None, |best, a| {\n-            best.and_then(|best| Some(*ImportAction::better(&best, &a))).or_else(|| Some(a))\n+        .fold(None, |best, a| match best {\n+            Some(best) => Some(ImportAction::better(best, a)),\n+            None => Some(a),\n         });\n \n     match best_action {\n@@ -386,7 +395,7 @@ fn make_assist(action: &ImportAction, target: &[SmolStr], edit: &mut TextEditBui\n }\n \n fn make_assist_add_new_use(\n-    anchor: &Option<&SyntaxNode>,\n+    anchor: &Option<SyntaxNode>,\n     after: bool,\n     target: &[SmolStr],\n     edit: &mut TextEditBuilder,\n@@ -396,7 +405,7 @@ fn make_assist_add_new_use(\n         let mut buf = String::new();\n         if after {\n             buf.push_str(\"\\n\");\n-            if let Some(spaces) = indent {\n+            if let Some(spaces) = &indent {\n                 buf.push_str(spaces);\n             }\n         }\n@@ -405,8 +414,8 @@ fn make_assist_add_new_use(\n         buf.push_str(\";\");\n         if !after {\n             buf.push_str(\"\\n\\n\");\n-            if let Some(spaces) = indent {\n-                buf.push_str(spaces);\n+            if let Some(spaces) = &indent {\n+                buf.push_str(&spaces);\n             }\n         }\n         let position = if after { anchor.range().end() } else { anchor.range().start() };\n@@ -444,7 +453,7 @@ fn make_assist_add_in_tree_list(\n \n fn make_assist_add_nested_import(\n     path: &ast::Path,\n-    first_segment_to_split: &Option<&ast::PathSegment>,\n+    first_segment_to_split: &Option<ast::PathSegment>,\n     target: &[SmolStr],\n     add_self: bool,\n     edit: &mut TextEditBuilder,\n@@ -482,7 +491,7 @@ fn apply_auto_import(\n     target: &[SmolStr],\n     edit: &mut TextEditBuilder,\n ) {\n-    let action = best_action_for_target(container, path.syntax(), target);\n+    let action = best_action_for_target(container.clone(), path.syntax().clone(), target);\n     make_assist(&action, target, edit);\n     if let Some(last) = path.segment() {\n         // Here we are assuming the assist will provide a  correct use statement\n@@ -522,26 +531,26 @@ pub fn auto_import_text_edit(\n     edit: &mut TextEditBuilder,\n ) {\n     let container = position.ancestors().find_map(|n| {\n-        if let Some(module) = ast::Module::cast(n) {\n-            return module.item_list().map(ast::AstNode::syntax);\n+        if let Some(module) = ast::Module::cast(n.clone()) {\n+            return module.item_list().map(|it| it.syntax().clone());\n         }\n-        ast::SourceFile::cast(n).map(ast::AstNode::syntax)\n+        ast::SourceFile::cast(n).map(|it| it.syntax().clone())\n     });\n \n     if let Some(container) = container {\n-        let action = best_action_for_target(container, anchor, target);\n+        let action = best_action_for_target(container, anchor.clone(), target);\n         make_assist(&action, target, edit);\n     }\n }\n \n pub(crate) fn auto_import(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let path: &ast::Path = ctx.node_at_offset()?;\n+    let path: ast::Path = ctx.node_at_offset()?;\n     // We don't want to mess with use statements\n     if path.syntax().ancestors().find_map(ast::UseItem::cast).is_some() {\n         return None;\n     }\n \n-    let hir_path = hir::Path::from_ast(path)?;\n+    let hir_path = hir::Path::from_ast(path.clone())?;\n     let segments = collect_hir_path_segments(&hir_path);\n     if segments.len() < 2 {\n         return None;\n@@ -554,7 +563,7 @@ pub(crate) fn auto_import(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist\n                 format!(\"import {} in mod {}\", fmt_segments(&segments), name.text()),\n                 |edit| {\n                     let mut text_edit = TextEditBuilder::default();\n-                    apply_auto_import(item_list.syntax(), path, &segments, &mut text_edit);\n+                    apply_auto_import(item_list.syntax(), &path, &segments, &mut text_edit);\n                     edit.set_edit_builder(text_edit);\n                 },\n             );\n@@ -566,7 +575,7 @@ pub(crate) fn auto_import(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist\n             format!(\"import {} in the current file\", fmt_segments(&segments)),\n             |edit| {\n                 let mut text_edit = TextEditBuilder::default();\n-                apply_auto_import(current_file.syntax(), path, &segments, &mut text_edit);\n+                apply_auto_import(current_file.syntax(), &path, &segments, &mut text_edit);\n                 edit.set_edit_builder(text_edit);\n             },\n         );"}, {"sha": "ab10d2aa44c16307d3a0a33b80061e9b2a7b44e1", "filename": "crates/ra_assists/src/change_visibility.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fchange_visibility.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -35,7 +35,7 @@ fn add_vis(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n         if parent.children().any(|child| child.kind() == VISIBILITY) {\n             return None;\n         }\n-        (vis_offset(parent), keyword.range())\n+        (vis_offset(&parent), keyword.range())\n     } else {\n         let ident = ctx.token_at_offset().find(|leaf| leaf.kind() == IDENT)?;\n         let field = ident.parent().ancestors().find_map(ast::NamedFieldDef::cast)?;\n@@ -65,7 +65,7 @@ fn vis_offset(node: &SyntaxNode) -> TextUnit {\n         .unwrap_or_else(|| node.range().start())\n }\n \n-fn change_vis(mut ctx: AssistCtx<impl HirDatabase>, vis: &ast::Visibility) -> Option<Assist> {\n+fn change_vis(mut ctx: AssistCtx<impl HirDatabase>, vis: ast::Visibility) -> Option<Assist> {\n     if vis.syntax().text() == \"pub\" {\n         ctx.add_action(AssistId(\"change_visibility\"), \"change to pub(crate)\", |edit| {\n             edit.target(vis.syntax().range());"}, {"sha": "b96806ac6659dc4b6d4af5c9efab1cfc9eaa2e90", "filename": "crates/ra_assists/src/fill_match_arms.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -27,7 +27,7 @@ pub(crate) fn fill_match_arms(mut ctx: AssistCtx<impl HirDatabase>) -> Option<As\n         let mut arm_iter = arm_list.arms();\n         let first = arm_iter.next();\n \n-        match first {\n+        match &first {\n             // If there arm list is empty or there is only one trivial arm, then proceed.\n             Some(arm) if is_trivial_arm(arm) => {\n                 if arm_iter.next() != None {\n@@ -44,7 +44,7 @@ pub(crate) fn fill_match_arms(mut ctx: AssistCtx<impl HirDatabase>) -> Option<As\n \n     let expr = match_expr.expr()?;\n     let analyzer = hir::SourceAnalyzer::new(ctx.db, ctx.frange.file_id, expr.syntax(), None);\n-    let match_expr_ty = analyzer.type_of(ctx.db, expr)?;\n+    let match_expr_ty = analyzer.type_of(ctx.db, &expr)?;\n     let enum_def = analyzer.autoderef(ctx.db, match_expr_ty).find_map(|ty| match ty.as_adt() {\n         Some((AdtDef::Enum(e), _)) => Some(e),\n         _ => None,"}, {"sha": "2e591ad3bd40c293bc727eea8e2b6a7bb8d02e2f", "filename": "crates/ra_assists/src/flip_binexpr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fflip_binexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fflip_binexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fflip_binexpr.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -6,8 +6,8 @@ use crate::{Assist, AssistCtx, AssistId};\n /// Flip binary expression assist.\n pub(crate) fn flip_binexpr(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let expr = ctx.node_at_offset::<BinExpr>()?;\n-    let lhs = expr.lhs()?.syntax();\n-    let rhs = expr.rhs()?.syntax();\n+    let lhs = expr.lhs()?.syntax().clone();\n+    let rhs = expr.rhs()?.syntax().clone();\n     let op_range = expr.op_token()?.range();\n     // The assist should be applied only if the cursor is on the operator\n     let cursor_in_range = ctx.frange.range.is_subrange(&op_range);"}, {"sha": "13016ae06d64608b50e613ecab20f8ba7519bff5", "filename": "crates/ra_assists/src/flip_comma.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fflip_comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fflip_comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fflip_comma.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -5,8 +5,8 @@ use crate::{Assist, AssistCtx, AssistId};\n \n pub(crate) fn flip_comma(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let comma = ctx.token_at_offset().find(|leaf| leaf.kind() == T![,])?;\n-    let prev = non_trivia_sibling(comma.into(), Direction::Prev)?;\n-    let next = non_trivia_sibling(comma.into(), Direction::Next)?;\n+    let prev = non_trivia_sibling(comma.clone().into(), Direction::Prev)?;\n+    let next = non_trivia_sibling(comma.clone().into(), Direction::Next)?;\n     ctx.add_action(AssistId(\"flip_comma\"), \"flip comma\", |edit| {\n         edit.target(comma.range());\n         edit.replace(prev.range(), next.to_string());"}, {"sha": "3c17089deb920e737e06fdd5d1f5eef429b3eae1", "filename": "crates/ra_assists/src/inline_local_variable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Finline_local_variable.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -16,18 +16,18 @@ pub(crate) fn inline_local_varialbe(mut ctx: AssistCtx<impl HirDatabase>) -> Opt\n     if bind_pat.is_mutable() {\n         return None;\n     }\n-    let initializer_expr = let_stmt.initializer();\n+    let initializer_expr = let_stmt.initializer()?;\n     let delete_range = if let Some(whitespace) = let_stmt\n         .syntax()\n         .next_sibling_or_token()\n-        .and_then(|it| ast::Whitespace::cast(it.as_token()?))\n+        .and_then(|it| ast::Whitespace::cast(it.as_token()?.clone()))\n     {\n         TextRange::from_to(let_stmt.syntax().range().start(), whitespace.syntax().range().end())\n     } else {\n         let_stmt.syntax().range()\n     };\n     let analyzer = hir::SourceAnalyzer::new(ctx.db, ctx.frange.file_id, bind_pat.syntax(), None);\n-    let refs = analyzer.find_all_refs(bind_pat);\n+    let refs = analyzer.find_all_refs(&bind_pat);\n \n     let mut wrap_in_parens = vec![true; refs.len()];\n \n@@ -45,7 +45,7 @@ pub(crate) fn inline_local_varialbe(mut ctx: AssistCtx<impl HirDatabase>) -> Opt\n             }\n         };\n \n-        wrap_in_parens[i] = match (initializer_expr?.kind(), usage_parent.kind()) {\n+        wrap_in_parens[i] = match (initializer_expr.kind(), usage_parent.kind()) {\n             (ExprKind::CallExpr(_), _)\n             | (ExprKind::IndexExpr(_), _)\n             | (ExprKind::MethodCallExpr(_), _)\n@@ -71,7 +71,7 @@ pub(crate) fn inline_local_varialbe(mut ctx: AssistCtx<impl HirDatabase>) -> Opt\n         };\n     }\n \n-    let init_str = initializer_expr?.syntax().text().to_string();\n+    let init_str = initializer_expr.syntax().text().to_string();\n     let init_in_paren = format!(\"({})\", &init_str);\n \n     ctx.add_action("}, {"sha": "ce28132c9af93c233d7d84eebb17fae9fdbbbe01", "filename": "crates/ra_assists/src/introduce_variable.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fintroduce_variable.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -20,8 +20,8 @@ pub(crate) fn introduce_variable(mut ctx: AssistCtx<impl HirDatabase>) -> Option\n         return None;\n     }\n     let expr = node.ancestors().find_map(valid_target_expr)?;\n-    let (anchor_stmt, wrap_in_block) = anchor_stmt(expr)?;\n-    let indent = anchor_stmt.prev_sibling_or_token()?.as_token()?;\n+    let (anchor_stmt, wrap_in_block) = anchor_stmt(expr.clone())?;\n+    let indent = anchor_stmt.prev_sibling_or_token()?.as_token()?.clone();\n     if indent.kind() != WHITESPACE {\n         return None;\n     }\n@@ -37,9 +37,9 @@ pub(crate) fn introduce_variable(mut ctx: AssistCtx<impl HirDatabase>) -> Option\n         };\n \n         expr.syntax().text().push_to(&mut buf);\n-        let full_stmt = ast::ExprStmt::cast(anchor_stmt);\n-        let is_full_stmt = if let Some(expr_stmt) = full_stmt {\n-            Some(expr.syntax()) == expr_stmt.expr().map(|e| e.syntax())\n+        let full_stmt = ast::ExprStmt::cast(anchor_stmt.clone());\n+        let is_full_stmt = if let Some(expr_stmt) = &full_stmt {\n+            Some(expr.syntax().clone()) == expr_stmt.expr().map(|e| e.syntax().clone())\n         } else {\n             false\n         };\n@@ -81,7 +81,7 @@ pub(crate) fn introduce_variable(mut ctx: AssistCtx<impl HirDatabase>) -> Option\n \n /// Check whether the node is a valid expression which can be extracted to a variable.\n /// In general that's true for any expression, but in some cases that would produce invalid code.\n-fn valid_target_expr(node: &SyntaxNode) -> Option<&ast::Expr> {\n+fn valid_target_expr(node: SyntaxNode) -> Option<ast::Expr> {\n     match node.kind() {\n         PATH_EXPR => None,\n         BREAK_EXPR => ast::BreakExpr::cast(node).and_then(|e| e.expr()),\n@@ -96,14 +96,10 @@ fn valid_target_expr(node: &SyntaxNode) -> Option<&ast::Expr> {\n /// to produce correct code.\n /// It can be a statement, the last in a block expression or a wanna be block\n /// expression like a lambda or match arm.\n-fn anchor_stmt(expr: &ast::Expr) -> Option<(&SyntaxNode, bool)> {\n+fn anchor_stmt(expr: ast::Expr) -> Option<(SyntaxNode, bool)> {\n     expr.syntax().ancestors().find_map(|node| {\n-        if ast::Stmt::cast(node).is_some() {\n-            return Some((node, false));\n-        }\n-\n         if let Some(expr) = node.parent().and_then(ast::Block::cast).and_then(|it| it.expr()) {\n-            if expr.syntax() == node {\n+            if expr.syntax() == &node {\n                 tested_by!(test_introduce_var_last_expr);\n                 return Some((node, false));\n             }\n@@ -115,6 +111,10 @@ fn anchor_stmt(expr: &ast::Expr) -> Option<(&SyntaxNode, bool)> {\n             }\n         }\n \n+        if ast::Stmt::cast(node.clone()).is_some() {\n+            return Some((node, false));\n+        }\n+\n         None\n     })\n }"}, {"sha": "313c9ad1878ca9260d79a95419d2f87915b23762", "filename": "crates/ra_assists/src/move_guard.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fmove_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fmove_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fmove_guard.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -18,9 +18,9 @@ pub(crate) fn move_guard_to_arm_body(mut ctx: AssistCtx<impl HirDatabase>) -> Op\n \n     ctx.add_action(AssistId(\"move_guard_to_arm_body\"), \"move guard to arm body\", |edit| {\n         edit.target(guard.syntax().range());\n-        let offseting_amount = match space_before_guard {\n+        let offseting_amount = match &space_before_guard {\n             Some(SyntaxElement::Token(tok)) => {\n-                if let Some(_) = ast::Whitespace::cast(tok) {\n+                if let Some(_) = ast::Whitespace::cast(tok.clone()) {\n                     let ele = space_before_guard.unwrap().range();\n                     edit.delete(ele);\n                     ele.len()\n@@ -39,11 +39,11 @@ pub(crate) fn move_guard_to_arm_body(mut ctx: AssistCtx<impl HirDatabase>) -> Op\n }\n \n pub(crate) fn move_arm_cond_to_match_guard(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let match_arm: &MatchArm = ctx.node_at_offset::<MatchArm>()?;\n+    let match_arm: MatchArm = ctx.node_at_offset::<MatchArm>()?;\n     let last_match_pat = match_arm.pats().last()?;\n \n     let arm_body = match_arm.expr()?;\n-    let if_expr: &IfExpr = IfExpr::cast(arm_body.syntax())?;\n+    let if_expr: IfExpr = IfExpr::cast(arm_body.syntax().clone())?;\n     let cond = if_expr.condition()?;\n     let then_block = if_expr.then_branch()?;\n \n@@ -65,7 +65,7 @@ pub(crate) fn move_arm_cond_to_match_guard(mut ctx: AssistCtx<impl HirDatabase>)\n             edit.target(if_expr.syntax().range());\n             let then_only_expr = then_block.statements().next().is_none();\n \n-            match then_block.expr() {\n+            match &then_block.expr() {\n                 Some(then_expr) if then_only_expr => {\n                     edit.replace(if_expr.syntax().range(), then_expr.syntax().text())\n                 }"}, {"sha": "c330bc82783a11a3f329a5e755be06ef113568aa", "filename": "crates/ra_assists/src/remove_dbg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fremove_dbg.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -8,7 +8,7 @@ use ra_syntax::{\n pub(crate) fn remove_dbg(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let macro_call = ctx.node_at_offset::<ast::MacroCall>()?;\n \n-    if !is_valid_macrocall(macro_call, \"dbg\")? {\n+    if !is_valid_macrocall(&macro_call, \"dbg\")? {\n         return None;\n     }\n \n@@ -35,7 +35,7 @@ pub(crate) fn remove_dbg(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist>\n     };\n \n     let macro_content = {\n-        let macro_args = macro_call.token_tree()?.syntax();\n+        let macro_args = macro_call.token_tree()?.syntax().clone();\n         let range = macro_args.range();\n         let start = range.start() + TextUnit::of_char('(');\n         let end = range.end() - TextUnit::of_char(')');\n@@ -65,7 +65,7 @@ fn is_valid_macrocall(macro_call: &ast::MacroCall, macro_name: &str) -> Option<b\n         return None;\n     }\n \n-    let node = macro_call.token_tree()?.syntax();\n+    let node = macro_call.token_tree()?.syntax().clone();\n     let first_child = node.first_child_or_token()?;\n     let last_child = node.last_child_or_token()?;\n "}, {"sha": "5de6aa2664ad291c8a7f1724082eaf6d02a6aa3e", "filename": "crates/ra_assists/src/replace_if_let_with_match.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_assists%2Fsrc%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Freplace_if_let_with_match.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{ast, AstNode};\n use crate::{Assist, AssistCtx, AssistId};\n \n pub(crate) fn replace_if_let_with_match(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let if_expr: &ast::IfExpr = ctx.node_at_offset()?;\n+    let if_expr: ast::IfExpr = ctx.node_at_offset()?;\n     let cond = if_expr.condition()?;\n     let pat = cond.pat()?;\n     let expr = cond.expr()?;\n@@ -25,16 +25,11 @@ pub(crate) fn replace_if_let_with_match(mut ctx: AssistCtx<impl HirDatabase>) ->\n     ctx.build()\n }\n \n-fn build_match_expr(\n-    expr: &ast::Expr,\n-    pat1: &ast::Pat,\n-    arm1: &ast::Block,\n-    arm2: &ast::Block,\n-) -> String {\n+fn build_match_expr(expr: ast::Expr, pat1: ast::Pat, arm1: ast::Block, arm2: ast::Block) -> String {\n     let mut buf = String::new();\n     buf.push_str(&format!(\"match {} {{\\n\", expr.syntax().text()));\n-    buf.push_str(&format!(\"    {} => {}\\n\", pat1.syntax().text(), format_arm(arm1)));\n-    buf.push_str(&format!(\"    _ => {}\\n\", format_arm(arm2)));\n+    buf.push_str(&format!(\"    {} => {}\\n\", pat1.syntax().text(), format_arm(&arm1)));\n+    buf.push_str(&format!(\"    _ => {}\\n\", format_arm(&arm2)));\n     buf.push_str(\"}\");\n     buf\n }"}, {"sha": "375e2f508fa0a0f940d4e17724d1339686913478", "filename": "crates/ra_cli/src/main.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_cli%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_cli%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fmain.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -7,7 +7,7 @@ use clap::{App, Arg, SubCommand};\n use flexi_logger::Logger;\n use ra_ide_api::{file_structure, Analysis};\n use ra_prof::profile;\n-use ra_syntax::{AstNode, SourceFile, TreeArc};\n+use ra_syntax::{AstNode, SourceFile};\n \n type Result<T> = std::result::Result<T, Box<dyn Error + Send + Sync>>;\n \n@@ -100,9 +100,9 @@ fn main() -> Result<()> {\n     Ok(())\n }\n \n-fn file() -> Result<TreeArc<SourceFile>> {\n+fn file() -> Result<SourceFile> {\n     let text = read_stdin()?;\n-    Ok(SourceFile::parse(&text).tree().to_owned())\n+    Ok(SourceFile::parse(&text).tree())\n }\n \n fn read_stdin() -> Result<String> {"}, {"sha": "d6e89572939084cac3f598600adfe4c72852a0ff", "filename": "crates/ra_fmt/src/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_fmt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_fmt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_fmt%2Fsrc%2Flib.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -3,7 +3,7 @@\n use itertools::Itertools;\n use ra_syntax::{\n     ast::{self, AstNode, AstToken},\n-    SyntaxKind,\n+    SmolStr, SyntaxKind,\n     SyntaxKind::*,\n     SyntaxNode, SyntaxToken, T,\n };\n@@ -15,12 +15,12 @@ pub fn reindent(text: &str, indent: &str) -> String {\n }\n \n /// If the node is on the beginning of the line, calculate indent.\n-pub fn leading_indent(node: &SyntaxNode) -> Option<&str> {\n+pub fn leading_indent(node: &SyntaxNode) -> Option<SmolStr> {\n     for token in prev_tokens(node.first_token()?) {\n-        if let Some(ws) = ast::Whitespace::cast(token) {\n+        if let Some(ws) = ast::Whitespace::cast(token.clone()) {\n             let ws_text = ws.text();\n             if let Some(pos) = ws_text.rfind('\\n') {\n-                return Some(&ws_text[pos + 1..]);\n+                return Some(ws_text[pos + 1..].into());\n             }\n         }\n         if token.text().contains('\\n') {\n@@ -31,17 +31,17 @@ pub fn leading_indent(node: &SyntaxNode) -> Option<&str> {\n }\n \n fn prev_tokens(token: SyntaxToken) -> impl Iterator<Item = SyntaxToken> {\n-    successors(token.prev_token(), |&token| token.prev_token())\n+    successors(token.prev_token(), |token| token.prev_token())\n }\n \n-pub fn extract_trivial_expression(block: &ast::Block) -> Option<&ast::Expr> {\n+pub fn extract_trivial_expression(block: &ast::Block) -> Option<ast::Expr> {\n     let expr = block.expr()?;\n     if expr.syntax().text().contains('\\n') {\n         return None;\n     }\n     let non_trivial_children = block.syntax().children().filter(|it| match it.kind() {\n         WHITESPACE | T!['{'] | T!['}'] => false,\n-        _ => it != &expr.syntax(),\n+        _ => it != expr.syntax(),\n     });\n     if non_trivial_children.count() > 0 {\n         return None;"}, {"sha": "c65446df4a486b4fceb0a97776c93c3cf683d185", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -4,10 +4,7 @@\n use std::sync::Arc;\n \n use ra_arena::{impl_arena_id, Arena, RawId};\n-use ra_syntax::{\n-    ast::{self, NameOwner, StructKind, TypeAscriptionOwner},\n-    TreeArc,\n-};\n+use ra_syntax::ast::{self, NameOwner, StructKind, TypeAscriptionOwner};\n \n use crate::{\n     type_ref::TypeRef, AsName, AstDatabase, Crate, DefDatabase, Enum, EnumVariant, FieldSource,\n@@ -59,21 +56,21 @@ impl StructData {\n         struct_: Struct,\n     ) -> Arc<StructData> {\n         let src = struct_.source(db);\n-        Arc::new(StructData::new(&*src.ast))\n+        Arc::new(StructData::new(&src.ast))\n     }\n }\n \n-fn variants(enum_def: &ast::EnumDef) -> impl Iterator<Item = &ast::EnumVariant> {\n+fn variants(enum_def: &ast::EnumDef) -> impl Iterator<Item = ast::EnumVariant> {\n     enum_def.variant_list().into_iter().flat_map(|it| it.variants())\n }\n \n impl EnumVariant {\n     pub(crate) fn source_impl(\n         self,\n         db: &(impl DefDatabase + AstDatabase),\n-    ) -> Source<TreeArc<ast::EnumVariant>> {\n+    ) -> Source<ast::EnumVariant> {\n         let src = self.parent.source(db);\n-        let ast = variants(&*src.ast)\n+        let ast = variants(&src.ast)\n             .zip(db.enum_data(self.parent).variants.iter())\n             .find(|(_syntax, (id, _))| *id == self.id)\n             .unwrap()\n@@ -96,7 +93,7 @@ impl EnumData {\n     pub(crate) fn enum_data_query(db: &(impl DefDatabase + AstDatabase), e: Enum) -> Arc<EnumData> {\n         let src = e.source(db);\n         let name = src.ast.name().map(|n| n.as_name());\n-        let variants = variants(&*src.ast)\n+        let variants = variants(&src.ast)\n             .map(|var| EnumVariantData {\n                 name: var.name().map(|it| it.as_name()),\n                 variant_data: Arc::new(VariantData::new(var.kind())),"}, {"sha": "779764590cab63873df4b82f762eaf4e431bd5c5", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -4,10 +4,7 @@ pub(crate) mod docs;\n use std::sync::Arc;\n \n use ra_db::{CrateId, Edition, FileId, SourceRootId};\n-use ra_syntax::{\n-    ast::{self, NameOwner, TypeAscriptionOwner},\n-    TreeArc,\n-};\n+use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n \n use crate::{\n     adt::{EnumVariantId, StructFieldId, VariantDef},\n@@ -155,8 +152,8 @@ impl_froms!(\n );\n \n pub enum ModuleSource {\n-    SourceFile(TreeArc<ast::SourceFile>),\n-    Module(TreeArc<ast::Module>),\n+    SourceFile(ast::SourceFile),\n+    Module(ast::Module),\n }\n \n impl ModuleSource {\n@@ -199,7 +196,7 @@ impl Module {\n         self,\n         db: &impl HirDatabase,\n         import: ImportId,\n-    ) -> Either<TreeArc<ast::UseTree>, TreeArc<ast::ExternCrateItem>> {\n+    ) -> Either<ast::UseTree, ast::ExternCrateItem> {\n         let src = self.definition_source(db);\n         let (_, source_map) = db.raw_items_with_source_map(src.file_id);\n         source_map.get(&src.ast, import)\n@@ -321,8 +318,8 @@ pub struct StructField {\n \n #[derive(Debug)]\n pub enum FieldSource {\n-    Named(TreeArc<ast::NamedFieldDef>),\n-    Pos(TreeArc<ast::PosFieldDef>),\n+    Named(ast::NamedFieldDef),\n+    Pos(ast::PosFieldDef),\n }\n \n impl StructField {\n@@ -736,15 +733,15 @@ impl ConstData {\n         konst: Const,\n     ) -> Arc<ConstData> {\n         let node = konst.source(db).ast;\n-        const_data_for(&*node)\n+        const_data_for(&node)\n     }\n \n     pub(crate) fn static_data_query(\n         db: &(impl DefDatabase + AstDatabase),\n         konst: Static,\n     ) -> Arc<ConstData> {\n         let node = konst.source(db).ast;\n-        const_data_for(&*node)\n+        const_data_for(&node)\n     }\n }\n "}, {"sha": "a2b4d8e9752286a7c19f8a3c5955b00320f9c692", "filename": "crates/ra_hir/src/code_model/docs.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fdocs.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -71,21 +71,21 @@ pub(crate) fn documentation_query(\n     def: DocDef,\n ) -> Option<Documentation> {\n     match def {\n-        DocDef::Module(it) => docs_from_ast(&*it.declaration_source(db)?.ast),\n+        DocDef::Module(it) => docs_from_ast(&it.declaration_source(db)?.ast),\n         DocDef::StructField(it) => match it.source(db).ast {\n-            FieldSource::Named(named) => docs_from_ast(&*named),\n+            FieldSource::Named(named) => docs_from_ast(&named),\n             FieldSource::Pos(..) => None,\n         },\n-        DocDef::Struct(it) => docs_from_ast(&*it.source(db).ast),\n-        DocDef::Enum(it) => docs_from_ast(&*it.source(db).ast),\n-        DocDef::EnumVariant(it) => docs_from_ast(&*it.source(db).ast),\n-        DocDef::Static(it) => docs_from_ast(&*it.source(db).ast),\n-        DocDef::Const(it) => docs_from_ast(&*it.source(db).ast),\n-        DocDef::Function(it) => docs_from_ast(&*it.source(db).ast),\n-        DocDef::Union(it) => docs_from_ast(&*it.source(db).ast),\n-        DocDef::Trait(it) => docs_from_ast(&*it.source(db).ast),\n-        DocDef::TypeAlias(it) => docs_from_ast(&*it.source(db).ast),\n-        DocDef::MacroDef(it) => docs_from_ast(&*it.source(db).ast),\n+        DocDef::Struct(it) => docs_from_ast(&it.source(db).ast),\n+        DocDef::Enum(it) => docs_from_ast(&it.source(db).ast),\n+        DocDef::EnumVariant(it) => docs_from_ast(&it.source(db).ast),\n+        DocDef::Static(it) => docs_from_ast(&it.source(db).ast),\n+        DocDef::Const(it) => docs_from_ast(&it.source(db).ast),\n+        DocDef::Function(it) => docs_from_ast(&it.source(db).ast),\n+        DocDef::Union(it) => docs_from_ast(&it.source(db).ast),\n+        DocDef::Trait(it) => docs_from_ast(&it.source(db).ast),\n+        DocDef::TypeAlias(it) => docs_from_ast(&it.source(db).ast),\n+        DocDef::MacroDef(it) => docs_from_ast(&it.source(db).ast),\n     }\n }\n "}, {"sha": "32bd9c661ee14878deb5b5dd480c8e14b707dc9c", "filename": "crates/ra_hir/src/code_model/src.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -1,4 +1,4 @@\n-use ra_syntax::{ast, TreeArc};\n+use ra_syntax::ast;\n \n use crate::{\n     ids::AstItemDef, AstDatabase, Const, DefDatabase, Enum, EnumVariant, FieldSource, Function,\n@@ -34,7 +34,7 @@ impl Module {\n     pub fn declaration_source(\n         self,\n         db: &(impl DefDatabase + AstDatabase),\n-    ) -> Option<Source<TreeArc<ast::Module>>> {\n+    ) -> Option<Source<ast::Module>> {\n         let def_map = db.crate_def_map(self.krate);\n         let decl = def_map[self.module_id].declaration?;\n         let ast = decl.to_node(db);\n@@ -49,62 +49,62 @@ impl HasSource for StructField {\n     }\n }\n impl HasSource for Struct {\n-    type Ast = TreeArc<ast::StructDef>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::StructDef>> {\n+    type Ast = ast::StructDef;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::StructDef> {\n         self.id.source(db)\n     }\n }\n impl HasSource for Union {\n-    type Ast = TreeArc<ast::StructDef>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::StructDef>> {\n+    type Ast = ast::StructDef;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::StructDef> {\n         self.id.source(db)\n     }\n }\n impl HasSource for Enum {\n-    type Ast = TreeArc<ast::EnumDef>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::EnumDef>> {\n+    type Ast = ast::EnumDef;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::EnumDef> {\n         self.id.source(db)\n     }\n }\n impl HasSource for EnumVariant {\n-    type Ast = TreeArc<ast::EnumVariant>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::EnumVariant>> {\n+    type Ast = ast::EnumVariant;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::EnumVariant> {\n         self.source_impl(db)\n     }\n }\n impl HasSource for Function {\n-    type Ast = TreeArc<ast::FnDef>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::FnDef>> {\n+    type Ast = ast::FnDef;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::FnDef> {\n         self.id.source(db)\n     }\n }\n impl HasSource for Const {\n-    type Ast = TreeArc<ast::ConstDef>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::ConstDef>> {\n+    type Ast = ast::ConstDef;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::ConstDef> {\n         self.id.source(db)\n     }\n }\n impl HasSource for Static {\n-    type Ast = TreeArc<ast::StaticDef>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::StaticDef>> {\n+    type Ast = ast::StaticDef;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::StaticDef> {\n         self.id.source(db)\n     }\n }\n impl HasSource for Trait {\n-    type Ast = TreeArc<ast::TraitDef>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::TraitDef>> {\n+    type Ast = ast::TraitDef;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::TraitDef> {\n         self.id.source(db)\n     }\n }\n impl HasSource for TypeAlias {\n-    type Ast = TreeArc<ast::TypeAliasDef>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::TypeAliasDef>> {\n+    type Ast = ast::TypeAliasDef;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::TypeAliasDef> {\n         self.id.source(db)\n     }\n }\n impl HasSource for MacroDef {\n-    type Ast = TreeArc<ast::MacroCall>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::MacroCall>> {\n+    type Ast = ast::MacroCall;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::MacroCall> {\n         Source { file_id: self.id.0.file_id(), ast: self.id.0.to_node(db) }\n     }\n }"}, {"sha": "358365176301aae445d6f6e9f7eceeafa97038c1", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -2,7 +2,7 @@ use std::sync::Arc;\n \n use parking_lot::Mutex;\n use ra_db::{salsa, SourceDatabase};\n-use ra_syntax::{ast, Parse, SmolStr, SyntaxNode, TreeArc};\n+use ra_syntax::{ast, Parse, SmolStr, SyntaxNode};\n \n use crate::{\n     adt::{EnumData, StructData},\n@@ -62,11 +62,11 @@ pub trait AstDatabase: InternDatabase {\n \n     #[salsa::transparent]\n     #[salsa::invoke(crate::source_id::AstIdMap::file_item_query)]\n-    fn ast_id_to_node(&self, file_id: HirFileId, ast_id: ErasedFileAstId) -> TreeArc<SyntaxNode>;\n+    fn ast_id_to_node(&self, file_id: HirFileId, ast_id: ErasedFileAstId) -> SyntaxNode;\n \n     #[salsa::transparent]\n     #[salsa::invoke(crate::ids::HirFileId::parse_or_expand_query)]\n-    fn parse_or_expand(&self, file_id: HirFileId) -> Option<TreeArc<SyntaxNode>>;\n+    fn parse_or_expand(&self, file_id: HirFileId) -> Option<SyntaxNode>;\n \n     #[salsa::invoke(crate::ids::HirFileId::parse_macro_query)]\n     fn parse_macro(&self, macro_file: ids::MacroFile) -> Option<Parse<SyntaxNode>>;"}, {"sha": "0290483b389729685267d63c73522274e097f113", "filename": "crates/ra_hir/src/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -1,6 +1,6 @@\n use std::{any::Any, fmt};\n \n-use ra_syntax::{ast, AstNode, AstPtr, SyntaxNode, SyntaxNodePtr, TextRange, TreeArc};\n+use ra_syntax::{ast, AstNode, AstPtr, SyntaxNode, SyntaxNodePtr, TextRange};\n use relative_path::RelativePathBuf;\n \n use crate::{HirDatabase, HirFileId, Name};\n@@ -33,9 +33,9 @@ pub trait AstDiagnostic {\n }\n \n impl dyn Diagnostic {\n-    pub fn syntax_node(&self, db: &impl HirDatabase) -> TreeArc<SyntaxNode> {\n+    pub fn syntax_node(&self, db: &impl HirDatabase) -> SyntaxNode {\n         let node = db.parse_or_expand(self.file()).unwrap();\n-        self.syntax_node_ptr().to_node(&*node).to_owned()\n+        self.syntax_node_ptr().to_node(&node)\n     }\n \n     pub fn downcast_ref<D: Diagnostic>(&self) -> Option<&D> {\n@@ -143,11 +143,11 @@ impl Diagnostic for MissingFields {\n }\n \n impl AstDiagnostic for MissingFields {\n-    type AST = TreeArc<ast::NamedFieldList>;\n+    type AST = ast::NamedFieldList;\n \n     fn ast(&self, db: &impl HirDatabase) -> Self::AST {\n         let root = db.parse_or_expand(self.file()).unwrap();\n-        let node = self.syntax_node_ptr().to_node(&*root);\n-        ast::NamedFieldList::cast(&node).unwrap().to_owned()\n+        let node = self.syntax_node_ptr().to_node(&root);\n+        ast::NamedFieldList::cast(node).unwrap()\n     }\n }"}, {"sha": "70af3f119ebf62870a0f5745fd3ca7fc35a24de5", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -550,7 +550,7 @@ where\n         self.exprs.alloc(block)\n     }\n \n-    fn collect_expr(&mut self, expr: &ast::Expr) -> ExprId {\n+    fn collect_expr(&mut self, expr: ast::Expr) -> ExprId {\n         let syntax_ptr = SyntaxNodePtr::new(expr.syntax());\n         match expr.kind() {\n             ast::ExprKind::IfExpr(e) => {\n@@ -565,7 +565,8 @@ where\n                         .map(|b| match b {\n                             ast::ElseBranch::Block(it) => self.collect_block(it),\n                             ast::ElseBranch::IfExpr(elif) => {\n-                                let expr: &ast::Expr = ast::Expr::cast(elif.syntax()).unwrap();\n+                                let expr: ast::Expr =\n+                                    ast::Expr::cast(elif.syntax().clone()).unwrap();\n                                 self.collect_expr(expr)\n                             }\n                         })\n@@ -582,7 +583,7 @@ where\n                     let else_branch = e.else_branch().map(|b| match b {\n                         ast::ElseBranch::Block(it) => self.collect_block(it),\n                         ast::ElseBranch::IfExpr(elif) => {\n-                            let expr: &ast::Expr = ast::Expr::cast(elif.syntax()).unwrap();\n+                            let expr: ast::Expr = ast::Expr::cast(elif.syntax().clone()).unwrap();\n                             self.collect_expr(expr)\n                         }\n                     });\n@@ -689,7 +690,7 @@ where\n                 let struct_lit = if let Some(nfl) = e.named_field_list() {\n                     let fields = nfl\n                         .fields()\n-                        .inspect(|field| field_ptrs.push(AstPtr::new(*field)))\n+                        .inspect(|field| field_ptrs.push(AstPtr::new(field)))\n                         .map(|field| StructLitField {\n                             name: field\n                                 .name_ref()\n@@ -699,7 +700,7 @@ where\n                                 self.collect_expr(e)\n                             } else if let Some(nr) = field.name_ref() {\n                                 // field shorthand\n-                                let id = self.exprs.alloc(Expr::Path(Path::from_name_ref(nr)));\n+                                let id = self.exprs.alloc(Expr::Path(Path::from_name_ref(&nr)));\n                                 self.source_map\n                                     .expr_map\n                                     .insert(SyntaxNodePtr::new(nr.syntax()), id);\n@@ -837,19 +838,19 @@ where\n                 let ast_id = self\n                     .db\n                     .ast_id_map(self.current_file_id)\n-                    .ast_id(e)\n+                    .ast_id(&e)\n                     .with_file_id(self.current_file_id);\n \n                 if let Some(path) = e.path().and_then(Path::from_ast) {\n                     if let Some(def) = self.resolver.resolve_path_as_macro(self.db, &path) {\n                         let call_id = MacroCallLoc { def: def.id, ast_id }.id(self.db);\n                         let file_id = call_id.as_file(MacroFileKind::Expr);\n                         if let Some(node) = self.db.parse_or_expand(file_id) {\n-                            if let Some(expr) = ast::Expr::cast(&*node) {\n+                            if let Some(expr) = ast::Expr::cast(node) {\n                                 log::debug!(\"macro expansion {}\", expr.syntax().debug_dump());\n                                 let old_file_id =\n                                     std::mem::replace(&mut self.current_file_id, file_id);\n-                                let id = self.collect_expr(&expr);\n+                                let id = self.collect_expr(expr);\n                                 self.current_file_id = old_file_id;\n                                 return id;\n                             }\n@@ -863,15 +864,15 @@ where\n         }\n     }\n \n-    fn collect_expr_opt(&mut self, expr: Option<&ast::Expr>) -> ExprId {\n+    fn collect_expr_opt(&mut self, expr: Option<ast::Expr>) -> ExprId {\n         if let Some(expr) = expr {\n             self.collect_expr(expr)\n         } else {\n             self.exprs.alloc(Expr::Missing)\n         }\n     }\n \n-    fn collect_block(&mut self, block: &ast::Block) -> ExprId {\n+    fn collect_block(&mut self, block: ast::Block) -> ExprId {\n         let statements = block\n             .statements()\n             .map(|s| match s.kind() {\n@@ -890,15 +891,15 @@ where\n         self.alloc_expr(Expr::Block { statements, tail }, SyntaxNodePtr::new(block.syntax()))\n     }\n \n-    fn collect_block_opt(&mut self, block: Option<&ast::Block>) -> ExprId {\n+    fn collect_block_opt(&mut self, block: Option<ast::Block>) -> ExprId {\n         if let Some(block) = block {\n             self.collect_block(block)\n         } else {\n             self.exprs.alloc(Expr::Missing)\n         }\n     }\n \n-    fn collect_pat(&mut self, pat: &ast::Pat) -> PatId {\n+    fn collect_pat(&mut self, pat: ast::Pat) -> PatId {\n         let pattern = match pat.kind() {\n             ast::PatKind::BindPat(bp) => {\n                 let name = bp.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n@@ -932,7 +933,8 @@ where\n                 let mut fields: Vec<_> = field_pat_list\n                     .bind_pats()\n                     .filter_map(|bind_pat| {\n-                        let ast_pat = ast::Pat::cast(bind_pat.syntax()).expect(\"bind pat is a pat\");\n+                        let ast_pat =\n+                            ast::Pat::cast(bind_pat.syntax().clone()).expect(\"bind pat is a pat\");\n                         let pat = self.collect_pat(ast_pat);\n                         let name = bind_pat.name()?.as_name();\n                         Some(FieldPat { name, pat })\n@@ -953,32 +955,32 @@ where\n             ast::PatKind::LiteralPat(_) => Pat::Missing,\n             ast::PatKind::SlicePat(_) | ast::PatKind::RangePat(_) => Pat::Missing,\n         };\n-        let ptr = AstPtr::new(pat);\n+        let ptr = AstPtr::new(&pat);\n         self.alloc_pat(pattern, Either::A(ptr))\n     }\n \n-    fn collect_pat_opt(&mut self, pat: Option<&ast::Pat>) -> PatId {\n+    fn collect_pat_opt(&mut self, pat: Option<ast::Pat>) -> PatId {\n         if let Some(pat) = pat {\n             self.collect_pat(pat)\n         } else {\n             self.pats.alloc(Pat::Missing)\n         }\n     }\n \n-    fn collect_const_body(&mut self, node: &ast::ConstDef) {\n+    fn collect_const_body(&mut self, node: ast::ConstDef) {\n         let body = self.collect_expr_opt(node.body());\n         self.body_expr = Some(body);\n     }\n \n-    fn collect_static_body(&mut self, node: &ast::StaticDef) {\n+    fn collect_static_body(&mut self, node: ast::StaticDef) {\n         let body = self.collect_expr_opt(node.body());\n         self.body_expr = Some(body);\n     }\n \n-    fn collect_fn_body(&mut self, node: &ast::FnDef) {\n+    fn collect_fn_body(&mut self, node: ast::FnDef) {\n         if let Some(param_list) = node.param_list() {\n             if let Some(self_param) = param_list.self_param() {\n-                let ptr = AstPtr::new(self_param);\n+                let ptr = AstPtr::new(&self_param);\n                 let param_pat = self.alloc_pat(\n                     Pat::Bind {\n                         name: SELF_PARAM,\n@@ -1027,17 +1029,17 @@ pub(crate) fn body_with_source_map_query(\n         DefWithBody::Const(ref c) => {\n             let src = c.source(db);\n             collector = ExprCollector::new(def, src.file_id, def.resolver(db), db);\n-            collector.collect_const_body(&src.ast)\n+            collector.collect_const_body(src.ast)\n         }\n         DefWithBody::Function(ref f) => {\n             let src = f.source(db);\n             collector = ExprCollector::new(def, src.file_id, def.resolver(db), db);\n-            collector.collect_fn_body(&src.ast)\n+            collector.collect_fn_body(src.ast)\n         }\n         DefWithBody::Static(ref s) => {\n             let src = s.source(db);\n             collector = ExprCollector::new(def, src.file_id, def.resolver(db), db);\n-            collector.collect_static_body(&src.ast)\n+            collector.collect_static_body(src.ast)\n         }\n     }\n "}, {"sha": "6589b782c49aa5ca5622854c7f14ec4897f367c2", "filename": "crates/ra_hir/src/expr/scope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -190,7 +190,7 @@ mod tests {\n \n         let (db, _source_root, file_id) = MockDatabase::with_single_file(&code);\n         let file = db.parse(file_id).ok().unwrap();\n-        let marker: &ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n+        let marker: ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n         let analyzer = SourceAnalyzer::new(&db, file_id, marker.syntax(), None);\n \n         let scopes = analyzer.scopes();\n@@ -290,10 +290,10 @@ mod tests {\n         let file = db.parse(file_id).ok().unwrap();\n         let expected_name = find_node_at_offset::<ast::Name>(file.syntax(), expected_offset.into())\n             .expect(\"failed to find a name at the target offset\");\n-        let name_ref: &ast::NameRef = find_node_at_offset(file.syntax(), off).unwrap();\n+        let name_ref: ast::NameRef = find_node_at_offset(file.syntax(), off).unwrap();\n         let analyzer = SourceAnalyzer::new(&db, file_id, name_ref.syntax(), None);\n \n-        let local_name_entry = analyzer.resolve_local_name(name_ref).unwrap();\n+        let local_name_entry = analyzer.resolve_local_name(&name_ref).unwrap();\n         let local_name =\n             local_name_entry.ptr().either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr());\n         assert_eq!(local_name.range(), expected_name.syntax().range());"}, {"sha": "82a06ca25c759fe6cc3851b89998e55739bdcfd9", "filename": "crates/ra_hir/src/expr/validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -79,7 +79,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             .and_then(StructLit::cast)\n             .and_then(|lit| lit.named_field_list())\n         {\n-            let field_list_ptr = AstPtr::new(field_list_node);\n+            let field_list_ptr = AstPtr::new(&field_list_node);\n             self.sink.push(MissingFields {\n                 file: file_id,\n                 field_list: field_list_ptr,"}, {"sha": "bcbb4988d5c58dbf3fdb85ce1646cdb9f68a86a4", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -76,17 +76,17 @@ impl GenericParams {\n         generics.parent_params = parent.map(|p| db.generic_params(p));\n         let start = generics.parent_params.as_ref().map(|p| p.params.len()).unwrap_or(0) as u32;\n         match def {\n-            GenericDef::Function(it) => generics.fill(&*it.source(db).ast, start),\n-            GenericDef::Struct(it) => generics.fill(&*it.source(db).ast, start),\n-            GenericDef::Union(it) => generics.fill(&*it.source(db).ast, start),\n-            GenericDef::Enum(it) => generics.fill(&*it.source(db).ast, start),\n+            GenericDef::Function(it) => generics.fill(&it.source(db).ast, start),\n+            GenericDef::Struct(it) => generics.fill(&it.source(db).ast, start),\n+            GenericDef::Union(it) => generics.fill(&it.source(db).ast, start),\n+            GenericDef::Enum(it) => generics.fill(&it.source(db).ast, start),\n             GenericDef::Trait(it) => {\n                 // traits get the Self type as an implicit first type parameter\n                 generics.params.push(GenericParam { idx: start, name: SELF_TYPE, default: None });\n-                generics.fill(&*it.source(db).ast, start + 1);\n+                generics.fill(&it.source(db).ast, start + 1);\n             }\n-            GenericDef::TypeAlias(it) => generics.fill(&*it.source(db).ast, start),\n-            GenericDef::ImplBlock(it) => generics.fill(&*it.source(db).ast, start),\n+            GenericDef::TypeAlias(it) => generics.fill(&it.source(db).ast, start),\n+            GenericDef::ImplBlock(it) => generics.fill(&it.source(db).ast, start),\n             GenericDef::EnumVariant(_) => {}\n         }\n \n@@ -102,9 +102,9 @@ impl GenericParams {\n         }\n     }\n \n-    fn fill_params(&mut self, params: &ast::TypeParamList, start: u32) {\n+    fn fill_params(&mut self, params: ast::TypeParamList, start: u32) {\n         for (idx, type_param) in params.type_params().enumerate() {\n-            let name = type_param.name().map(AsName::as_name).unwrap_or_else(Name::missing);\n+            let name = type_param.name().map_or_else(Name::missing, |it| it.as_name());\n             let default = type_param.default_type().and_then(|t| t.path()).and_then(Path::from_ast);\n \n             let param = GenericParam { idx: idx as u32 + start, name: name.clone(), default };\n@@ -121,7 +121,7 @@ impl GenericParams {\n         }\n     }\n \n-    fn fill_where_predicates(&mut self, where_clause: &ast::WhereClause) {\n+    fn fill_where_predicates(&mut self, where_clause: ast::WhereClause) {\n         for pred in where_clause.predicates() {\n             let type_ref = match pred.type_ref() {\n                 Some(type_ref) => type_ref,\n@@ -134,7 +134,7 @@ impl GenericParams {\n         }\n     }\n \n-    fn add_where_predicate_from_bound(&mut self, bound: &ast::TypeBound, type_ref: TypeRef) {\n+    fn add_where_predicate_from_bound(&mut self, bound: ast::TypeBound, type_ref: TypeRef) {\n         let path = bound\n             .type_ref()\n             .and_then(|tr| match tr.kind() {"}, {"sha": "05a18eb56803edfbd2a306518016a5b23d9f82f4", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -6,7 +6,7 @@ use std::{\n use mbe::MacroRules;\n use ra_db::{salsa, FileId};\n use ra_prof::profile;\n-use ra_syntax::{ast, AstNode, Parse, SyntaxNode, TreeArc};\n+use ra_syntax::{ast, AstNode, Parse, SyntaxNode};\n \n use crate::{AstDatabase, AstId, DefDatabase, FileAstId, InternDatabase, Module, Source};\n \n@@ -58,11 +58,11 @@ impl HirFileId {\n     pub(crate) fn parse_or_expand_query(\n         db: &impl AstDatabase,\n         file_id: HirFileId,\n-    ) -> Option<TreeArc<SyntaxNode>> {\n+    ) -> Option<SyntaxNode> {\n         match file_id.0 {\n-            HirFileIdRepr::File(file_id) => Some(db.parse(file_id).tree().syntax().to_owned()),\n+            HirFileIdRepr::File(file_id) => Some(db.parse(file_id).tree().syntax().clone()),\n             HirFileIdRepr::Macro(macro_file) => {\n-                db.parse_macro(macro_file).map(|it| it.tree().to_owned())\n+                db.parse_macro(macro_file).map(|it| it.syntax_node())\n             }\n         }\n     }\n@@ -123,7 +123,7 @@ pub struct MacroDefId(pub(crate) AstId<ast::MacroCall>);\n pub(crate) fn macro_def_query(db: &impl AstDatabase, id: MacroDefId) -> Option<Arc<MacroRules>> {\n     let macro_call = id.0.to_node(db);\n     let arg = macro_call.token_tree()?;\n-    let (tt, _) = mbe::ast_to_token_tree(arg).or_else(|| {\n+    let (tt, _) = mbe::ast_to_token_tree(&arg).or_else(|| {\n         log::warn!(\"fail on macro_def to token tree: {:#?}\", arg);\n         None\n     })?;\n@@ -138,7 +138,7 @@ pub(crate) fn macro_arg_query(db: &impl AstDatabase, id: MacroCallId) -> Option<\n     let loc = id.loc(db);\n     let macro_call = loc.ast_id.to_node(db);\n     let arg = macro_call.token_tree()?;\n-    let (tt, _) = mbe::ast_to_token_tree(arg)?;\n+    let (tt, _) = mbe::ast_to_token_tree(&arg)?;\n     Some(Arc::new(tt))\n }\n \n@@ -262,7 +262,7 @@ pub(crate) trait AstItemDef<N: AstNode>: salsa::InternKey + Clone {\n         let loc = ItemLoc { module: ctx.module, ast_id: ast_id.with_file_id(ctx.file_id) };\n         Self::intern(ctx.db, loc)\n     }\n-    fn source(self, db: &(impl AstDatabase + DefDatabase)) -> Source<TreeArc<N>> {\n+    fn source(self, db: &(impl AstDatabase + DefDatabase)) -> Source<N> {\n         let loc = self.lookup_intern(db);\n         let ast = loc.ast_id.to_node(db);\n         Source { file_id: loc.ast_id.file_id(), ast }"}, {"sha": "8e62cf66d46c10ac235c9e4fdbf301ac236e29c5", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -4,7 +4,7 @@ use std::sync::Arc;\n use ra_arena::{impl_arena_id, map::ArenaMap, Arena, RawId};\n use ra_syntax::{\n     ast::{self, AstNode},\n-    AstPtr, SourceFile, TreeArc,\n+    AstPtr, SourceFile,\n };\n \n use crate::{\n@@ -28,9 +28,9 @@ impl ImplSourceMap {\n         self.map.insert(impl_id, AstPtr::new(impl_block))\n     }\n \n-    pub fn get(&self, source: &ModuleSource, impl_id: ImplId) -> TreeArc<ast::ImplBlock> {\n+    pub fn get(&self, source: &ModuleSource, impl_id: ImplId) -> ast::ImplBlock {\n         let file = match source {\n-            ModuleSource::SourceFile(file) => &*file,\n+            ModuleSource::SourceFile(file) => file.clone(),\n             ModuleSource::Module(m) => m.syntax().ancestors().find_map(SourceFile::cast).unwrap(),\n         };\n \n@@ -45,8 +45,8 @@ pub struct ImplBlock {\n }\n \n impl HasSource for ImplBlock {\n-    type Ast = TreeArc<ast::ImplBlock>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::ImplBlock>> {\n+    type Ast = ast::ImplBlock;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::ImplBlock> {\n         let source_map = db.impls_in_module_with_source_map(self.module).1;\n         let src = self.module.definition_source(db);\n         Source { file_id: src.file_id, ast: source_map.get(&src.ast, self.impl_id) }\n@@ -132,9 +132,9 @@ impl ImplData {\n             item_list\n                 .impl_items()\n                 .map(|item_node| match item_node.kind() {\n-                    ast::ImplItemKind::FnDef(it) => Function { id: ctx.to_def(it) }.into(),\n-                    ast::ImplItemKind::ConstDef(it) => Const { id: ctx.to_def(it) }.into(),\n-                    ast::ImplItemKind::TypeAliasDef(it) => TypeAlias { id: ctx.to_def(it) }.into(),\n+                    ast::ImplItemKind::FnDef(it) => Function { id: ctx.to_def(&it) }.into(),\n+                    ast::ImplItemKind::ConstDef(it) => Const { id: ctx.to_def(&it) }.into(),\n+                    ast::ImplItemKind::TypeAliasDef(it) => TypeAlias { id: ctx.to_def(&it) }.into(),\n                 })\n                 .collect()\n         } else {\n@@ -202,20 +202,20 @@ impl ModuleImplBlocks {\n \n         let src = m.module.definition_source(db);\n         let node = match &src.ast {\n-            ModuleSource::SourceFile(node) => node.syntax(),\n+            ModuleSource::SourceFile(node) => node.syntax().clone(),\n             ModuleSource::Module(node) => {\n-                node.item_list().expect(\"inline module should have item list\").syntax()\n+                node.item_list().expect(\"inline module should have item list\").syntax().clone()\n             }\n         };\n \n         for impl_block_ast in node.children().filter_map(ast::ImplBlock::cast) {\n-            let impl_block = ImplData::from_ast(db, src.file_id, m.module, impl_block_ast);\n+            let impl_block = ImplData::from_ast(db, src.file_id, m.module, &impl_block_ast);\n             let id = m.impls.alloc(impl_block);\n             for &impl_item in &m.impls[id].items {\n                 m.impls_by_def.insert(impl_item, id);\n             }\n \n-            source_map.insert(id, impl_block_ast);\n+            source_map.insert(id, &impl_block_ast);\n         }\n \n         m"}, {"sha": "fd6609fb8af7185744210c11f75b778e3772c159", "filename": "crates/ra_hir/src/lang_item.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flang_item.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -1,7 +1,7 @@\n use rustc_hash::FxHashMap;\n use std::sync::Arc;\n \n-use ra_syntax::{ast::AttrsOwner, SmolStr, TreeArc};\n+use ra_syntax::{ast::AttrsOwner, SmolStr};\n \n use crate::{\n     AstDatabase, Crate, DefDatabase, Enum, Function, HasSource, HirDatabase, ImplBlock, Module,\n@@ -95,7 +95,7 @@ impl LangItems {\n         // Look for impl targets\n         for impl_block in module.impl_blocks(db) {\n             let src = impl_block.source(db);\n-            if let Some(lang_item_name) = lang_item_name(&*src.ast) {\n+            if let Some(lang_item_name) = lang_item_name(&src.ast) {\n                 self.items\n                     .entry(lang_item_name)\n                     .or_insert_with(|| LangItemTarget::ImplBlock(impl_block));\n@@ -137,11 +137,11 @@ impl LangItems {\n         item: T,\n         constructor: fn(T) -> LangItemTarget,\n     ) where\n-        T: Copy + HasSource<Ast = TreeArc<N>>,\n+        T: Copy + HasSource<Ast = N>,\n         N: AttrsOwner,\n     {\n         let node = item.source(db).ast;\n-        if let Some(lang_item_name) = lang_item_name(&*node) {\n+        if let Some(lang_item_name) = lang_item_name(&node) {\n             self.items.entry(lang_item_name).or_insert_with(|| constructor(item));\n         }\n     }"}, {"sha": "c589f8aba6ece254267847af91b255b0cb16590a", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -75,7 +75,7 @@ impl AsName for ast::Name {\n     }\n }\n \n-impl<'a> AsName for ast::FieldKind<'a> {\n+impl AsName for ast::FieldKind {\n     fn as_name(&self) -> Name {\n         match self {\n             ast::FieldKind::Name(nr) => nr.as_name(),"}, {"sha": "8517f3c430dda9215aab89dbcbef8324453fee4d", "filename": "crates/ra_hir/src/nameres/raw.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -3,7 +3,7 @@ use std::{ops::Index, sync::Arc};\n use ra_arena::{impl_arena_id, map::ArenaMap, Arena, RawId};\n use ra_syntax::{\n     ast::{self, AttrsOwner, NameOwner},\n-    AstNode, AstPtr, SmolStr, SourceFile, TreeArc,\n+    AstNode, AstPtr, SmolStr, SourceFile,\n };\n use test_utils::tested_by;\n \n@@ -32,7 +32,7 @@ pub struct ImportSourceMap {\n }\n \n type ImportSourcePtr = Either<AstPtr<ast::UseTree>, AstPtr<ast::ExternCrateItem>>;\n-type ImportSource = Either<TreeArc<ast::UseTree>, TreeArc<ast::ExternCrateItem>>;\n+type ImportSource = Either<ast::UseTree, ast::ExternCrateItem>;\n \n impl ImportSourcePtr {\n     fn to_node(self, file: &SourceFile) -> ImportSource {\n@@ -50,11 +50,11 @@ impl ImportSourceMap {\n \n     pub(crate) fn get(&self, source: &ModuleSource, import: ImportId) -> ImportSource {\n         let file = match source {\n-            ModuleSource::SourceFile(file) => &*file,\n+            ModuleSource::SourceFile(file) => file.clone(),\n             ModuleSource::Module(m) => m.syntax().ancestors().find_map(SourceFile::cast).unwrap(),\n         };\n \n-        self.map[import].to_node(file)\n+        self.map[import].to_node(&file)\n     }\n }\n \n@@ -76,8 +76,8 @@ impl RawItems {\n             source_map: ImportSourceMap::default(),\n         };\n         if let Some(node) = db.parse_or_expand(file_id) {\n-            if let Some(source_file) = ast::SourceFile::cast(&node) {\n-                collector.process_module(None, &*source_file);\n+            if let Some(source_file) = ast::SourceFile::cast(node) {\n+                collector.process_module(None, source_file);\n             }\n         }\n         (Arc::new(collector.raw_items), Arc::new(collector.source_map))\n@@ -188,7 +188,7 @@ struct RawItemsCollector {\n }\n \n impl RawItemsCollector {\n-    fn process_module(&mut self, current_module: Option<Module>, body: &impl ast::ModuleItemOwner) {\n+    fn process_module(&mut self, current_module: Option<Module>, body: impl ast::ModuleItemOwner) {\n         for item_or_macro in body.items_with_macros() {\n             match item_or_macro {\n                 ast::ItemOrMacro::Macro(m) => self.add_macro(current_module, m),\n@@ -197,7 +197,7 @@ impl RawItemsCollector {\n         }\n     }\n \n-    fn add_item(&mut self, current_module: Option<Module>, item: &ast::ModuleItem) {\n+    fn add_item(&mut self, current_module: Option<Module>, item: ast::ModuleItem) {\n         let (kind, name) = match item.kind() {\n             ast::ModuleItemKind::Module(module) => {\n                 self.add_module(current_module, module);\n@@ -216,7 +216,7 @@ impl RawItemsCollector {\n                 return;\n             }\n             ast::ModuleItemKind::StructDef(it) => {\n-                let id = self.source_ast_id_map.ast_id(it);\n+                let id = self.source_ast_id_map.ast_id(&it);\n                 let name = it.name();\n                 if it.is_union() {\n                     (DefKind::Union(id), name)\n@@ -225,22 +225,22 @@ impl RawItemsCollector {\n                 }\n             }\n             ast::ModuleItemKind::EnumDef(it) => {\n-                (DefKind::Enum(self.source_ast_id_map.ast_id(it)), it.name())\n+                (DefKind::Enum(self.source_ast_id_map.ast_id(&it)), it.name())\n             }\n             ast::ModuleItemKind::FnDef(it) => {\n-                (DefKind::Function(self.source_ast_id_map.ast_id(it)), it.name())\n+                (DefKind::Function(self.source_ast_id_map.ast_id(&it)), it.name())\n             }\n             ast::ModuleItemKind::TraitDef(it) => {\n-                (DefKind::Trait(self.source_ast_id_map.ast_id(it)), it.name())\n+                (DefKind::Trait(self.source_ast_id_map.ast_id(&it)), it.name())\n             }\n             ast::ModuleItemKind::TypeAliasDef(it) => {\n-                (DefKind::TypeAlias(self.source_ast_id_map.ast_id(it)), it.name())\n+                (DefKind::TypeAlias(self.source_ast_id_map.ast_id(&it)), it.name())\n             }\n             ast::ModuleItemKind::ConstDef(it) => {\n-                (DefKind::Const(self.source_ast_id_map.ast_id(it)), it.name())\n+                (DefKind::Const(self.source_ast_id_map.ast_id(&it)), it.name())\n             }\n             ast::ModuleItemKind::StaticDef(it) => {\n-                (DefKind::Static(self.source_ast_id_map.ast_id(it)), it.name())\n+                (DefKind::Static(self.source_ast_id_map.ast_id(&it)), it.name())\n             }\n         };\n         if let Some(name) = name {\n@@ -250,14 +250,14 @@ impl RawItemsCollector {\n         }\n     }\n \n-    fn add_module(&mut self, current_module: Option<Module>, module: &ast::Module) {\n+    fn add_module(&mut self, current_module: Option<Module>, module: ast::Module) {\n         let name = match module.name() {\n             Some(it) => it.as_name(),\n             None => return,\n         };\n \n-        let attr_path = extract_mod_path_attribute(module);\n-        let ast_id = self.source_ast_id_map.ast_id(module);\n+        let attr_path = extract_mod_path_attribute(&module);\n+        let ast_id = self.source_ast_id_map.ast_id(&module);\n         if module.has_semi() {\n             let item =\n                 self.raw_items.modules.alloc(ModuleData::Declaration { name, ast_id, attr_path });\n@@ -278,10 +278,10 @@ impl RawItemsCollector {\n         tested_by!(name_res_works_for_broken_modules);\n     }\n \n-    fn add_use_item(&mut self, current_module: Option<Module>, use_item: &ast::UseItem) {\n+    fn add_use_item(&mut self, current_module: Option<Module>, use_item: ast::UseItem) {\n         let is_prelude = use_item.has_atom_attr(\"prelude_import\");\n \n-        Path::expand_use_item(use_item, |path, use_tree, is_glob, alias| {\n+        Path::expand_use_item(&use_item, |path, use_tree, is_glob, alias| {\n             let import_data =\n                 ImportData { path, alias, is_glob, is_prelude, is_extern_crate: false };\n             self.push_import(current_module, import_data, Either::A(AstPtr::new(use_tree)));\n@@ -291,30 +291,30 @@ impl RawItemsCollector {\n     fn add_extern_crate_item(\n         &mut self,\n         current_module: Option<Module>,\n-        extern_crate: &ast::ExternCrateItem,\n+        extern_crate: ast::ExternCrateItem,\n     ) {\n         if let Some(name_ref) = extern_crate.name_ref() {\n-            let path = Path::from_name_ref(name_ref);\n-            let alias = extern_crate.alias().and_then(|a| a.name()).map(AsName::as_name);\n+            let path = Path::from_name_ref(&name_ref);\n+            let alias = extern_crate.alias().and_then(|a| a.name()).map(|it| it.as_name());\n             let import_data = ImportData {\n                 path,\n                 alias,\n                 is_glob: false,\n                 is_prelude: false,\n                 is_extern_crate: true,\n             };\n-            self.push_import(current_module, import_data, Either::B(AstPtr::new(extern_crate)));\n+            self.push_import(current_module, import_data, Either::B(AstPtr::new(&extern_crate)));\n         }\n     }\n \n-    fn add_macro(&mut self, current_module: Option<Module>, m: &ast::MacroCall) {\n+    fn add_macro(&mut self, current_module: Option<Module>, m: ast::MacroCall) {\n         let path = match m.path().and_then(Path::from_ast) {\n             Some(it) => it,\n             _ => return,\n         };\n \n         let name = m.name().map(|it| it.as_name());\n-        let ast_id = self.source_ast_id_map.ast_id(m);\n+        let ast_id = self.source_ast_id_map.ast_id(&m);\n         let export = m.has_atom_attr(\"macro_export\");\n         let m = self.raw_items.macros.alloc(MacroData { ast_id, path, name, export });\n         self.push_item(current_module, RawItem::Macro(m));"}, {"sha": "882db76816209175bff5ca16428bb34d6cfb005a", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -47,17 +47,17 @@ pub enum PathKind {\n \n impl Path {\n     /// Calls `cb` with all paths, represented by this use item.\n-    pub fn expand_use_item<'a>(\n-        item: &'a ast::UseItem,\n-        mut cb: impl FnMut(Path, &'a ast::UseTree, bool, Option<Name>),\n+    pub fn expand_use_item(\n+        item: &ast::UseItem,\n+        mut cb: impl FnMut(Path, &ast::UseTree, bool, Option<Name>),\n     ) {\n         if let Some(tree) = item.use_tree() {\n             expand_use_tree(None, tree, &mut cb);\n         }\n     }\n \n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n-    pub fn from_ast(mut path: &ast::Path) -> Option<Path> {\n+    pub fn from_ast(mut path: ast::Path) -> Option<Path> {\n         let mut kind = PathKind::Plain;\n         let mut segments = Vec::new();\n         loop {\n@@ -87,15 +87,15 @@ impl Path {\n                     break;\n                 }\n             }\n-            path = match qualifier(path) {\n+            path = match qualifier(&path) {\n                 Some(it) => it,\n                 None => break,\n             };\n         }\n         segments.reverse();\n         return Some(Path { kind, segments });\n \n-        fn qualifier(path: &ast::Path) -> Option<&ast::Path> {\n+        fn qualifier(path: &ast::Path) -> Option<ast::Path> {\n             if let Some(q) = path.qualifier() {\n                 return Some(q);\n             }\n@@ -136,7 +136,7 @@ impl Path {\n }\n \n impl GenericArgs {\n-    pub(crate) fn from_ast(node: &ast::TypeArgList) -> Option<GenericArgs> {\n+    pub(crate) fn from_ast(node: ast::TypeArgList) -> Option<GenericArgs> {\n         let mut args = Vec::new();\n         for type_arg in node.type_args() {\n             let type_ref = TypeRef::from_ast_opt(type_arg.type_ref());\n@@ -160,10 +160,10 @@ impl From<Name> for Path {\n     }\n }\n \n-fn expand_use_tree<'a>(\n+fn expand_use_tree(\n     prefix: Option<Path>,\n-    tree: &'a ast::UseTree,\n-    cb: &mut impl FnMut(Path, &'a ast::UseTree, bool, Option<Name>),\n+    tree: ast::UseTree,\n+    cb: &mut impl FnMut(Path, &ast::UseTree, bool, Option<Name>),\n ) {\n     if let Some(use_tree_list) = tree.use_tree_list() {\n         let prefix = match tree.path() {\n@@ -188,23 +188,23 @@ fn expand_use_tree<'a>(\n                 if let Some(segment) = ast_path.segment() {\n                     if segment.kind() == Some(ast::PathSegmentKind::SelfKw) {\n                         if let Some(prefix) = prefix {\n-                            cb(prefix, tree, false, alias);\n+                            cb(prefix, &tree, false, alias);\n                             return;\n                         }\n                     }\n                 }\n             }\n             if let Some(path) = convert_path(prefix, ast_path) {\n                 let is_glob = tree.has_star();\n-                cb(path, tree, is_glob, alias)\n+                cb(path, &tree, is_glob, alias)\n             }\n             // FIXME: report errors somewhere\n             // We get here if we do\n         }\n     }\n }\n \n-fn convert_path(prefix: Option<Path>, path: &ast::Path) -> Option<Path> {\n+fn convert_path(prefix: Option<Path>, path: ast::Path) -> Option<Path> {\n     let prefix =\n         if let Some(qual) = path.qualifier() { Some(convert_path(prefix, qual)?) } else { prefix };\n     let segment = path.segment()?;"}, {"sha": "e7bc4df978898b7d2a7b736c1626d581fb7cdd5b", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -37,7 +37,7 @@ pub fn module_from_file_id(db: &impl HirDatabase, file_id: FileId) -> Option<Mod\n pub fn module_from_declaration(\n     db: &impl HirDatabase,\n     file_id: FileId,\n-    decl: &ast::Module,\n+    decl: ast::Module,\n ) -> Option<Module> {\n     let parent_module = module_from_file_id(db, file_id);\n     let child_name = decl.name();\n@@ -50,21 +50,21 @@ pub fn module_from_declaration(\n /// Locates the module by position in the source code.\n pub fn module_from_position(db: &impl HirDatabase, position: FilePosition) -> Option<Module> {\n     let parse = db.parse(position.file_id);\n-    match find_node_at_offset::<ast::Module>(parse.tree().syntax(), position.offset) {\n-        Some(m) if !m.has_semi() => module_from_inline(db, position.file_id, m),\n+    match &find_node_at_offset::<ast::Module>(parse.tree().syntax(), position.offset) {\n+        Some(m) if !m.has_semi() => module_from_inline(db, position.file_id, m.clone()),\n         _ => module_from_file_id(db, position.file_id),\n     }\n }\n \n fn module_from_inline(\n     db: &impl HirDatabase,\n     file_id: FileId,\n-    module: &ast::Module,\n+    module: ast::Module,\n ) -> Option<Module> {\n     assert!(!module.has_semi());\n     let file_id = file_id.into();\n     let ast_id_map = db.ast_id_map(file_id);\n-    let item_id = ast_id_map.ast_id(module).with_file_id(file_id);\n+    let item_id = ast_id_map.ast_id(&module).with_file_id(file_id);\n     module_from_source(db, file_id, Some(item_id))\n }\n \n@@ -127,16 +127,16 @@ fn try_get_resolver_for_node(\n     file_id: FileId,\n     node: &SyntaxNode,\n ) -> Option<Resolver> {\n-    if let Some(module) = ast::Module::cast(node) {\n+    if let Some(module) = ast::Module::cast(node.clone()) {\n         Some(module_from_declaration(db, file_id, module)?.resolver(db))\n-    } else if let Some(_) = ast::SourceFile::cast(node) {\n+    } else if let Some(_) = ast::SourceFile::cast(node.clone()) {\n         Some(module_from_source(db, file_id.into(), None)?.resolver(db))\n-    } else if let Some(s) = ast::StructDef::cast(node) {\n+    } else if let Some(s) = ast::StructDef::cast(node.clone()) {\n         let module = module_from_child_node(db, file_id, s.syntax())?;\n-        Some(struct_from_module(db, module, s).resolver(db))\n-    } else if let Some(e) = ast::EnumDef::cast(node) {\n+        Some(struct_from_module(db, module, &s).resolver(db))\n+    } else if let Some(e) = ast::EnumDef::cast(node.clone()) {\n         let module = module_from_child_node(db, file_id, e.syntax())?;\n-        Some(enum_from_module(db, module, e).resolver(db))\n+        Some(enum_from_module(db, module, &e).resolver(db))\n     } else if node.kind() == FN_DEF || node.kind() == CONST_DEF || node.kind() == STATIC_DEF {\n         Some(def_with_body_from_child_node(db, file_id, node)?.resolver(db))\n     } else {\n@@ -153,14 +153,14 @@ fn def_with_body_from_child_node(\n     let module = module_from_child_node(db, file_id, node)?;\n     let ctx = LocationCtx::new(db, module, file_id.into());\n     node.ancestors().find_map(|node| {\n-        if let Some(def) = ast::FnDef::cast(node) {\n-            return Some(Function { id: ctx.to_def(def) }.into());\n+        if let Some(def) = ast::FnDef::cast(node.clone()) {\n+            return Some(Function { id: ctx.to_def(&def) }.into());\n         }\n-        if let Some(def) = ast::ConstDef::cast(node) {\n-            return Some(Const { id: ctx.to_def(def) }.into());\n+        if let Some(def) = ast::ConstDef::cast(node.clone()) {\n+            return Some(Const { id: ctx.to_def(&def) }.into());\n         }\n-        if let Some(def) = ast::StaticDef::cast(node) {\n-            return Some(Static { id: ctx.to_def(def) }.into());\n+        if let Some(def) = ast::StaticDef::cast(node.clone()) {\n+            return Some(Static { id: ctx.to_def(&def) }.into());\n         }\n         None\n     })\n@@ -237,7 +237,7 @@ impl SourceAnalyzer {\n             SourceAnalyzer {\n                 resolver: node\n                     .ancestors()\n-                    .find_map(|node| try_get_resolver_for_node(db, file_id, node))\n+                    .find_map(|node| try_get_resolver_for_node(db, file_id, &node))\n                     .unwrap_or_default(),\n                 body_source_map: None,\n                 infer: None,\n@@ -257,17 +257,17 @@ impl SourceAnalyzer {\n     }\n \n     pub fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<Function> {\n-        let expr_id = self.body_source_map.as_ref()?.node_expr(call.into())?;\n+        let expr_id = self.body_source_map.as_ref()?.node_expr(&call.clone().into())?;\n         self.infer.as_ref()?.method_resolution(expr_id)\n     }\n \n     pub fn resolve_field(&self, field: &ast::FieldExpr) -> Option<crate::StructField> {\n-        let expr_id = self.body_source_map.as_ref()?.node_expr(field.into())?;\n+        let expr_id = self.body_source_map.as_ref()?.node_expr(&field.clone().into())?;\n         self.infer.as_ref()?.field_resolution(expr_id)\n     }\n \n     pub fn resolve_variant(&self, struct_lit: &ast::StructLit) -> Option<crate::VariantDef> {\n-        let expr_id = self.body_source_map.as_ref()?.node_expr(struct_lit.into())?;\n+        let expr_id = self.body_source_map.as_ref()?.node_expr(&struct_lit.clone().into())?;\n         self.infer.as_ref()?.variant_resolution(expr_id)\n     }\n \n@@ -290,18 +290,18 @@ impl SourceAnalyzer {\n \n     pub fn resolve_path(&self, db: &impl HirDatabase, path: &ast::Path) -> Option<PathResolution> {\n         if let Some(path_expr) = path.syntax().parent().and_then(ast::PathExpr::cast) {\n-            let expr_id = self.body_source_map.as_ref()?.node_expr(path_expr.into())?;\n+            let expr_id = self.body_source_map.as_ref()?.node_expr(&path_expr.into())?;\n             if let Some(assoc) = self.infer.as_ref()?.assoc_resolutions_for_expr(expr_id) {\n                 return Some(PathResolution::AssocItem(assoc));\n             }\n         }\n         if let Some(path_pat) = path.syntax().parent().and_then(ast::PathPat::cast) {\n-            let pat_id = self.body_source_map.as_ref()?.node_pat(path_pat.into())?;\n+            let pat_id = self.body_source_map.as_ref()?.node_pat(&path_pat.into())?;\n             if let Some(assoc) = self.infer.as_ref()?.assoc_resolutions_for_pat(pat_id) {\n                 return Some(PathResolution::AssocItem(assoc));\n             }\n         }\n-        let hir_path = crate::Path::from_ast(path)?;\n+        let hir_path = crate::Path::from_ast(path.clone())?;\n         let res = self.resolver.resolve_path_without_assoc_items(db, &hir_path);\n         let res = res.clone().take_types().or_else(|| res.take_values())?;\n         let res = match res {\n@@ -343,12 +343,12 @@ impl SourceAnalyzer {\n         // FIXME: at least, this should work with any DefWithBody, but ideally\n         // this should be hir-based altogether\n         let fn_def = pat.syntax().ancestors().find_map(ast::FnDef::cast).unwrap();\n-        let ptr = Either::A(AstPtr::new(pat.into()));\n+        let ptr = Either::A(AstPtr::new(&ast::Pat::from(pat.clone())));\n         fn_def\n             .syntax()\n             .descendants()\n             .filter_map(ast::NameRef::cast)\n-            .filter(|name_ref| match self.resolve_local_name(*name_ref) {\n+            .filter(|name_ref| match self.resolve_local_name(&name_ref) {\n                 None => false,\n                 Some(entry) => entry.ptr() == ptr,\n             })\n@@ -411,7 +411,7 @@ fn scope_for(\n     node: &SyntaxNode,\n ) -> Option<ScopeId> {\n     node.ancestors()\n-        .map(SyntaxNodePtr::new)\n+        .map(|it| SyntaxNodePtr::new(&it))\n         .filter_map(|ptr| source_map.syntax_expr(ptr))\n         .find_map(|it| scopes.scope_for(it))\n }"}, {"sha": "51cd65ddad502ae915a47cfbe500ff722bece119", "filename": "crates/ra_hir/src/source_id.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fsource_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fsource_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_id.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -5,7 +5,7 @@ use std::{\n };\n \n use ra_arena::{impl_arena_id, Arena, RawId};\n-use ra_syntax::{ast, AstNode, SyntaxNode, SyntaxNodePtr, TreeArc};\n+use ra_syntax::{ast, AstNode, SyntaxNode, SyntaxNodePtr};\n \n use crate::{AstDatabase, HirFileId};\n \n@@ -42,9 +42,9 @@ impl<N: AstNode> AstId<N> {\n         self.file_id\n     }\n \n-    pub(crate) fn to_node(&self, db: &impl AstDatabase) -> TreeArc<N> {\n+    pub(crate) fn to_node(&self, db: &impl AstDatabase) -> N {\n         let syntax_node = db.ast_id_to_node(self.file_id, self.file_ast_id.raw);\n-        N::cast(&syntax_node).unwrap().to_owned()\n+        N::cast(syntax_node).unwrap()\n     }\n }\n \n@@ -93,7 +93,7 @@ pub struct AstIdMap {\n impl AstIdMap {\n     pub(crate) fn ast_id_map_query(db: &impl AstDatabase, file_id: HirFileId) -> Arc<AstIdMap> {\n         let map = if let Some(node) = db.parse_or_expand(file_id) {\n-            AstIdMap::from_source(&*node)\n+            AstIdMap::from_source(&node)\n         } else {\n             AstIdMap::default()\n         };\n@@ -104,9 +104,9 @@ impl AstIdMap {\n         db: &impl AstDatabase,\n         file_id: HirFileId,\n         ast_id: ErasedFileAstId,\n-    ) -> TreeArc<SyntaxNode> {\n+    ) -> SyntaxNode {\n         let node = db.parse_or_expand(file_id).unwrap();\n-        db.ast_id_map(file_id).arena[ast_id].to_node(&*node).to_owned()\n+        db.ast_id_map(file_id).arena[ast_id].to_node(&node)\n     }\n \n     pub(crate) fn ast_id<N: AstNode>(&self, item: &N) -> FileAstId<N> {\n@@ -131,7 +131,7 @@ impl AstIdMap {\n         // change parent's id. This means that, say, adding a new function to a\n         // trait does not change ids of top-level items, which helps caching.\n         bfs(node, |it| {\n-            if let Some(module_item) = ast::ModuleItem::cast(it) {\n+            if let Some(module_item) = ast::ModuleItem::cast(it.clone()) {\n                 res.alloc(module_item.syntax());\n             } else if let Some(macro_call) = ast::MacroCall::cast(it) {\n                 res.alloc(macro_call.syntax());\n@@ -146,8 +146,8 @@ impl AstIdMap {\n }\n \n /// Walks the subtree in bfs order, calling `f` for each node.\n-fn bfs(node: &SyntaxNode, mut f: impl FnMut(&SyntaxNode)) {\n-    let mut curr_layer = vec![node];\n+fn bfs(node: &SyntaxNode, mut f: impl FnMut(SyntaxNode)) {\n+    let mut curr_layer = vec![node.clone()];\n     let mut next_layer = vec![];\n     while !curr_layer.is_empty() {\n         curr_layer.drain(..).for_each(|node| {"}, {"sha": "de26f1a68fed22397318f8937a20a64850ad81e5", "filename": "crates/ra_hir/src/traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftraits.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -31,9 +31,9 @@ impl TraitData {\n             item_list\n                 .impl_items()\n                 .map(|item_node| match item_node.kind() {\n-                    ast::ImplItemKind::FnDef(it) => Function { id: ctx.to_def(it) }.into(),\n-                    ast::ImplItemKind::ConstDef(it) => Const { id: ctx.to_def(it) }.into(),\n-                    ast::ImplItemKind::TypeAliasDef(it) => TypeAlias { id: ctx.to_def(it) }.into(),\n+                    ast::ImplItemKind::FnDef(it) => Function { id: ctx.to_def(&it) }.into(),\n+                    ast::ImplItemKind::ConstDef(it) => Const { id: ctx.to_def(&it) }.into(),\n+                    ast::ImplItemKind::TypeAliasDef(it) => TypeAlias { id: ctx.to_def(&it) }.into(),\n                 })\n                 .collect()\n         } else {"}, {"sha": "265740e542035dd469c7da9c3cf0cc933efebd0a", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -3086,7 +3086,7 @@ fn type_at_pos(db: &MockDatabase, pos: FilePosition) -> String {\n     let file = db.parse(pos.file_id).ok().unwrap();\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();\n     let analyzer = SourceAnalyzer::new(db, pos.file_id, expr.syntax(), Some(pos.offset));\n-    let ty = analyzer.type_of(db, expr).unwrap();\n+    let ty = analyzer.type_of(db, &expr).unwrap();\n     ty.display(db).to_string()\n }\n \n@@ -3126,7 +3126,7 @@ fn infer(content: &str) -> String {\n         types.sort_by_key(|(ptr, _)| (ptr.range().start(), ptr.range().end()));\n         for (syntax_ptr, ty) in &types {\n             let node = syntax_ptr.to_node(source_file.syntax());\n-            let (range, text) = if let Some(self_param) = ast::SelfParam::cast(node) {\n+            let (range, text) = if let Some(self_param) = ast::SelfParam::cast(node.clone()) {\n                 (self_param.self_kw_token().range(), \"self\".to_string())\n             } else {\n                 (syntax_ptr.range(), node.text().to_string().replace(\"\\n\", \" \"))\n@@ -3137,7 +3137,7 @@ fn infer(content: &str) -> String {\n \n     for node in source_file.syntax().descendants() {\n         if node.kind() == FN_DEF || node.kind() == CONST_DEF || node.kind() == STATIC_DEF {\n-            let analyzer = SourceAnalyzer::new(&db, file_id, node, None);\n+            let analyzer = SourceAnalyzer::new(&db, file_id, &node, None);\n             infer_def(analyzer.inference_result(), analyzer.body_source_map());\n         }\n     }\n@@ -3179,7 +3179,7 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n         let node =\n             algo::find_token_at_offset(file.syntax(), pos.offset).right_biased().unwrap().parent();\n         let events = db.log_executed(|| {\n-            SourceAnalyzer::new(&db, pos.file_id, node, None);\n+            SourceAnalyzer::new(&db, pos.file_id, &node, None);\n         });\n         assert!(format!(\"{:?}\", events).contains(\"infer\"))\n     }\n@@ -3200,7 +3200,7 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n         let node =\n             algo::find_token_at_offset(file.syntax(), pos.offset).right_biased().unwrap().parent();\n         let events = db.log_executed(|| {\n-            SourceAnalyzer::new(&db, pos.file_id, node, None);\n+            SourceAnalyzer::new(&db, pos.file_id, &node, None);\n         });\n         assert!(!format!(\"{:?}\", events).contains(\"infer\"), \"{:#?}\", events)\n     }"}, {"sha": "8536ae44a155478cdbf97154ff39777a552dc0f4", "filename": "crates/ra_hir/src/type_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -56,7 +56,7 @@ pub enum TypeRef {\n \n impl TypeRef {\n     /// Converts an `ast::TypeRef` to a `hir::TypeRef`.\n-    pub(crate) fn from_ast(node: &ast::TypeRef) -> Self {\n+    pub(crate) fn from_ast(node: ast::TypeRef) -> Self {\n         use ra_syntax::ast::TypeRefKind::*;\n         match node.kind() {\n             ParenType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n@@ -95,7 +95,7 @@ impl TypeRef {\n         }\n     }\n \n-    pub(crate) fn from_ast_opt(node: Option<&ast::TypeRef>) -> Self {\n+    pub(crate) fn from_ast_opt(node: Option<ast::TypeRef>) -> Self {\n         if let Some(node) = node {\n             TypeRef::from_ast(node)\n         } else {"}, {"sha": "270499612bb216459a69d91fcb634a7d9222281d", "filename": "crates/ra_ide_api/src/call_info.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -11,24 +11,24 @@ use crate::{db::RootDatabase, CallInfo, FilePosition, FunctionSignature};\n /// Computes parameter information for the given call expression.\n pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<CallInfo> {\n     let parse = db.parse(position.file_id);\n-    let syntax = parse.tree().syntax();\n+    let syntax = parse.tree().syntax().clone();\n \n     // Find the calling expression and it's NameRef\n-    let calling_node = FnCallNode::with_node(syntax, position.offset)?;\n+    let calling_node = FnCallNode::with_node(&syntax, position.offset)?;\n     let name_ref = calling_node.name_ref()?;\n \n     let analyzer = hir::SourceAnalyzer::new(db, position.file_id, name_ref.syntax(), None);\n-    let function = match calling_node {\n+    let function = match &calling_node {\n         FnCallNode::CallExpr(expr) => {\n             //FIXME: apply subst\n-            let (callable_def, _subst) = analyzer.type_of(db, expr.expr()?)?.as_callable()?;\n+            let (callable_def, _subst) = analyzer.type_of(db, &expr.expr()?)?.as_callable()?;\n             match callable_def {\n                 hir::CallableDef::Function(it) => it,\n                 //FIXME: handle other callables\n                 _ => return None,\n             }\n         }\n-        FnCallNode::MethodCallExpr(expr) => analyzer.resolve_method_call(expr)?,\n+        FnCallNode::MethodCallExpr(expr) => analyzer.resolve_method_call(&expr)?,\n     };\n \n     let mut call_info = CallInfo::new(db, function);\n@@ -73,13 +73,13 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n     Some(call_info)\n }\n \n-enum FnCallNode<'a> {\n-    CallExpr(&'a ast::CallExpr),\n-    MethodCallExpr(&'a ast::MethodCallExpr),\n+enum FnCallNode {\n+    CallExpr(ast::CallExpr),\n+    MethodCallExpr(ast::MethodCallExpr),\n }\n \n-impl<'a> FnCallNode<'a> {\n-    fn with_node(syntax: &'a SyntaxNode, offset: TextUnit) -> Option<FnCallNode<'a>> {\n+impl FnCallNode {\n+    fn with_node(syntax: &SyntaxNode, offset: TextUnit) -> Option<FnCallNode> {\n         if let Some(expr) = find_node_at_offset::<ast::CallExpr>(syntax, offset) {\n             return Some(FnCallNode::CallExpr(expr));\n         }\n@@ -89,8 +89,8 @@ impl<'a> FnCallNode<'a> {\n         None\n     }\n \n-    fn name_ref(&self) -> Option<&'a ast::NameRef> {\n-        match *self {\n+    fn name_ref(&self) -> Option<ast::NameRef> {\n+        match self {\n             FnCallNode::CallExpr(call_expr) => Some(match call_expr.expr()?.kind() {\n                 ast::ExprKind::PathExpr(path_expr) => path_expr.path()?.segment()?.name_ref()?,\n                 _ => return None,\n@@ -102,8 +102,8 @@ impl<'a> FnCallNode<'a> {\n         }\n     }\n \n-    fn arg_list(&self) -> Option<&'a ast::ArgList> {\n-        match *self {\n+    fn arg_list(&self) -> Option<ast::ArgList> {\n+        match self {\n             FnCallNode::CallExpr(expr) => expr.arg_list(),\n             FnCallNode::MethodCallExpr(expr) => expr.arg_list(),\n         }"}, {"sha": "536ba36dff3e25f4ddd68c12111c076c0fb3ed9e", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -5,10 +5,11 @@ use rustc_hash::FxHashSet;\n \n /// Complete dot accesses, i.e. fields or methods (currently only fields).\n pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n-    let receiver_ty = match ctx.dot_receiver.and_then(|it| ctx.analyzer.type_of(ctx.db, it)) {\n-        Some(it) => it,\n-        None => return,\n-    };\n+    let receiver_ty =\n+        match ctx.dot_receiver.as_ref().and_then(|it| ctx.analyzer.type_of(ctx.db, it)) {\n+            Some(it) => it,\n+            None => return,\n+        };\n     if !ctx.is_call {\n         complete_fields(acc, ctx, receiver_ty.clone());\n     }"}, {"sha": "0887ef1f687f5eb276753061e3f91c7ba2ee3b15", "filename": "crates/ra_ide_api/src/completion/complete_fn_param.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -20,7 +20,7 @@ pub(super) fn complete_fn_param(acc: &mut Completions, ctx: &CompletionContext)\n         let _ = visitor_ctx(&mut params)\n             .visit::<ast::SourceFile, _>(process)\n             .visit::<ast::ItemList, _>(process)\n-            .accept(node);\n+            .accept(&node);\n     }\n     params\n         .into_iter()\n@@ -38,10 +38,7 @@ pub(super) fn complete_fn_param(acc: &mut Completions, ctx: &CompletionContext)\n                 .add_to(acc)\n         });\n \n-    fn process<'a, N: ast::FnDefOwner>(\n-        node: &'a N,\n-        params: &mut FxHashMap<String, (u32, &'a ast::Param)>,\n-    ) {\n+    fn process<N: ast::FnDefOwner>(node: N, params: &mut FxHashMap<String, (u32, ast::Param)>) {\n         node.functions().filter_map(|it| it.param_list()).flat_map(|it| it.params()).for_each(\n             |param| {\n                 let text = param.syntax().text().to_string();"}, {"sha": "4cf34eff8a24b8007ebf8329ade3cc12b4bf2d14", "filename": "crates/ra_ide_api/src/completion/complete_keyword.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -52,7 +52,7 @@ pub(super) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n         return;\n     }\n \n-    let fn_def = match ctx.function_syntax {\n+    let fn_def = match &ctx.function_syntax {\n         Some(it) => it,\n         None => return,\n     };\n@@ -65,7 +65,7 @@ pub(super) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n         acc.add(keyword(ctx, \"else\", \"else {$0}\"));\n         acc.add(keyword(ctx, \"else if\", \"else if $0 {}\"));\n     }\n-    if is_in_loop_body(ctx.token) {\n+    if is_in_loop_body(&ctx.token) {\n         if ctx.can_be_stmt {\n             acc.add(keyword(ctx, \"continue\", \"continue;\"));\n             acc.add(keyword(ctx, \"break\", \"break;\"));\n@@ -74,19 +74,19 @@ pub(super) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n             acc.add(keyword(ctx, \"break\", \"break\"));\n         }\n     }\n-    acc.add_all(complete_return(ctx, fn_def, ctx.can_be_stmt));\n+    acc.add_all(complete_return(ctx, &fn_def, ctx.can_be_stmt));\n }\n \n-fn is_in_loop_body(leaf: SyntaxToken) -> bool {\n+fn is_in_loop_body(leaf: &SyntaxToken) -> bool {\n     for node in leaf.parent().ancestors() {\n         if node.kind() == FN_DEF || node.kind() == LAMBDA_EXPR {\n             break;\n         }\n         let loop_body = visitor()\n-            .visit::<ast::ForExpr, _>(LoopBodyOwner::loop_body)\n-            .visit::<ast::WhileExpr, _>(LoopBodyOwner::loop_body)\n-            .visit::<ast::LoopExpr, _>(LoopBodyOwner::loop_body)\n-            .accept(node);\n+            .visit::<ast::ForExpr, _>(|it| it.loop_body())\n+            .visit::<ast::WhileExpr, _>(|it| it.loop_body())\n+            .visit::<ast::LoopExpr, _>(|it| it.loop_body())\n+            .accept(&node);\n         if let Some(Some(body)) = loop_body {\n             if leaf.range().is_subrange(&body.syntax().range()) {\n                 return true;"}, {"sha": "c75b1c159c3684b92387b65b6bae08614229d059", "filename": "crates/ra_ide_api/src/completion/complete_postfix.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -11,7 +11,8 @@ use ra_text_edit::TextEditBuilder;\n \n fn postfix_snippet(ctx: &CompletionContext, label: &str, detail: &str, snippet: &str) -> Builder {\n     let edit = {\n-        let receiver_range = ctx.dot_receiver.expect(\"no receiver available\").syntax().range();\n+        let receiver_range =\n+            ctx.dot_receiver.as_ref().expect(\"no receiver available\").syntax().range();\n         let delete_range = TextRange::from_to(receiver_range.start(), ctx.source_range().end());\n         let mut builder = TextEditBuilder::default();\n         builder.replace(delete_range, snippet.to_string());\n@@ -38,9 +39,9 @@ fn is_bool_or_unknown(ty: Option<Ty>) -> bool {\n }\n \n pub(super) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n-    if let Some(dot_receiver) = ctx.dot_receiver {\n+    if let Some(dot_receiver) = &ctx.dot_receiver {\n         let receiver_text = dot_receiver.syntax().text().to_string();\n-        let receiver_ty = ctx.analyzer.type_of(ctx.db, dot_receiver);\n+        let receiver_ty = ctx.analyzer.type_of(ctx.db, &dot_receiver);\n         if is_bool_or_unknown(receiver_ty) {\n             postfix_snippet(ctx, \"if\", \"if expr {}\", &format!(\"if {} {{$0}}\", receiver_text))\n                 .add_to(acc);"}, {"sha": "f920340557c7a749719f89b9c76a897d7ddb9cf4", "filename": "crates/ra_ide_api/src/completion/complete_scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -20,8 +20,8 @@ pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) {\n                     let mut builder = TextEditBuilder::default();\n                     builder.replace(ctx.source_range(), name.to_string());\n                     auto_import::auto_import_text_edit(\n-                        ctx.token.parent(),\n-                        ctx.token.parent(),\n+                        &ctx.token.parent(),\n+                        &ctx.token.parent(),\n                         &path,\n                         &mut builder,\n                     );"}, {"sha": "9410f740ffe97864b1a59f1b47b8937e0bc310d8", "filename": "crates/ra_ide_api/src/completion/complete_struct_literal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_struct_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_struct_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_struct_literal.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -4,8 +4,8 @@ use crate::completion::{CompletionContext, Completions};\n \n /// Complete fields in fields literals.\n pub(super) fn complete_struct_literal(acc: &mut Completions, ctx: &CompletionContext) {\n-    let (ty, variant) = match ctx.struct_lit_syntax.and_then(|it| {\n-        Some((ctx.analyzer.type_of(ctx.db, it.into())?, ctx.analyzer.resolve_variant(it)?))\n+    let (ty, variant) = match ctx.struct_lit_syntax.as_ref().and_then(|it| {\n+        Some((ctx.analyzer.type_of(ctx.db, &it.clone().into())?, ctx.analyzer.resolve_variant(it)?))\n     }) {\n         Some(it) => it,\n         _ => return,"}, {"sha": "b803271abaf28725dc83792fea189e09f0a5520f", "filename": "crates/ra_ide_api/src/completion/completion_context.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -16,11 +16,11 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) db: &'a db::RootDatabase,\n     pub(super) analyzer: hir::SourceAnalyzer,\n     pub(super) offset: TextUnit,\n-    pub(super) token: SyntaxToken<'a>,\n+    pub(super) token: SyntaxToken,\n     pub(super) module: Option<hir::Module>,\n-    pub(super) function_syntax: Option<&'a ast::FnDef>,\n-    pub(super) use_item_syntax: Option<&'a ast::UseItem>,\n-    pub(super) struct_lit_syntax: Option<&'a ast::StructLit>,\n+    pub(super) function_syntax: Option<ast::FnDef>,\n+    pub(super) use_item_syntax: Option<ast::UseItem>,\n+    pub(super) struct_lit_syntax: Option<ast::StructLit>,\n     pub(super) is_param: bool,\n     /// If a name-binding or reference to a const in a pattern.\n     /// Irrefutable patterns (like let) are excluded.\n@@ -35,7 +35,7 @@ pub(crate) struct CompletionContext<'a> {\n     /// Something is typed at the \"top\" level, in module or impl/trait.\n     pub(super) is_new_item: bool,\n     /// The receiver if this is a field or method access, i.e. writing something.<|>\n-    pub(super) dot_receiver: Option<&'a ast::Expr>,\n+    pub(super) dot_receiver: Option<ast::Expr>,\n     /// If this is a call (method or function) in particular, i.e. the () are already there.\n     pub(super) is_call: bool,\n }\n@@ -50,7 +50,7 @@ impl<'a> CompletionContext<'a> {\n         let token =\n             find_token_at_offset(original_parse.tree().syntax(), position.offset).left_biased()?;\n         let analyzer =\n-            hir::SourceAnalyzer::new(db, position.file_id, token.parent(), Some(position.offset));\n+            hir::SourceAnalyzer::new(db, position.file_id, &token.parent(), Some(position.offset));\n         let mut ctx = CompletionContext {\n             db,\n             analyzer,\n@@ -109,7 +109,7 @@ impl<'a> CompletionContext<'a> {\n             if is_node::<ast::BindPat>(name.syntax()) {\n                 let bind_pat = name.syntax().ancestors().find_map(ast::BindPat::cast).unwrap();\n                 let parent = bind_pat.syntax().parent();\n-                if parent.and_then(ast::MatchArm::cast).is_some()\n+                if parent.clone().and_then(ast::MatchArm::cast).is_some()\n                     || parent.and_then(ast::Condition::cast).is_some()\n                 {\n                     self.is_pat_binding = true;\n@@ -122,7 +122,7 @@ impl<'a> CompletionContext<'a> {\n         }\n     }\n \n-    fn classify_name_ref(&mut self, original_file: &'a SourceFile, name_ref: &ast::NameRef) {\n+    fn classify_name_ref(&mut self, original_file: SourceFile, name_ref: ast::NameRef) {\n         let name_range = name_ref.syntax().range();\n         if name_ref.syntax().parent().and_then(ast::NamedField::cast).is_some() {\n             self.struct_lit_syntax = find_node_at_offset(original_file.syntax(), self.offset);\n@@ -153,7 +153,7 @@ impl<'a> CompletionContext<'a> {\n             None => return,\n         };\n \n-        if let Some(segment) = ast::PathSegment::cast(parent) {\n+        if let Some(segment) = ast::PathSegment::cast(parent.clone()) {\n             let path = segment.parent_path();\n             self.is_call = path\n                 .syntax()\n@@ -162,7 +162,7 @@ impl<'a> CompletionContext<'a> {\n                 .and_then(|it| it.syntax().parent().and_then(ast::CallExpr::cast))\n                 .is_some();\n \n-            if let Some(mut path) = hir::Path::from_ast(path) {\n+            if let Some(mut path) = hir::Path::from_ast(path.clone()) {\n                 if !path.is_ident() {\n                     path.segments.pop().unwrap();\n                     self.path_prefix = Some(path);\n@@ -179,7 +179,7 @@ impl<'a> CompletionContext<'a> {\n                     .syntax()\n                     .ancestors()\n                     .find_map(|node| {\n-                        if let Some(stmt) = ast::ExprStmt::cast(node) {\n+                        if let Some(stmt) = ast::ExprStmt::cast(node.clone()) {\n                             return Some(stmt.syntax().range() == name_ref.syntax().range());\n                         }\n                         if let Some(block) = ast::Block::cast(node) {\n@@ -203,7 +203,7 @@ impl<'a> CompletionContext<'a> {\n                 }\n             }\n         }\n-        if let Some(field_expr) = ast::FieldExpr::cast(parent) {\n+        if let Some(field_expr) = ast::FieldExpr::cast(parent.clone()) {\n             // The receiver comes before the point of insertion of the fake\n             // ident, so it should have the same range in the non-modified file\n             self.dot_receiver = field_expr\n@@ -222,7 +222,7 @@ impl<'a> CompletionContext<'a> {\n     }\n }\n \n-fn find_node_with_range<N: AstNode>(syntax: &SyntaxNode, range: TextRange) -> Option<&N> {\n+fn find_node_with_range<N: AstNode>(syntax: &SyntaxNode, range: TextRange) -> Option<N> {\n     find_covering_element(syntax, range).ancestors().find_map(N::cast)\n }\n "}, {"sha": "affbad6cd05822d29cfc2effe8970fbe73cf8b89", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -35,8 +35,8 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n     }));\n \n     for node in parse.tree().syntax().descendants() {\n-        check_unnecessary_braces_in_use_statement(&mut res, file_id, node);\n-        check_struct_shorthand_initialization(&mut res, file_id, node);\n+        check_unnecessary_braces_in_use_statement(&mut res, file_id, &node);\n+        check_struct_shorthand_initialization(&mut res, file_id, &node);\n     }\n     let res = RefCell::new(res);\n     let mut sink = DiagnosticSink::new(|d| {\n@@ -60,7 +60,7 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n     })\n     .on::<hir::diagnostics::MissingFields, _>(|d| {\n         let node = d.ast(db);\n-        let mut ast_editor = AstEditor::new(&*node);\n+        let mut ast_editor = AstEditor::new(node);\n         for f in d.missed_fields.iter() {\n             ast_editor.append_field(&AstBuilder::<NamedField>::from_name(f));\n         }\n@@ -94,11 +94,11 @@ fn check_unnecessary_braces_in_use_statement(\n     file_id: FileId,\n     node: &SyntaxNode,\n ) -> Option<()> {\n-    let use_tree_list = ast::UseTreeList::cast(node)?;\n+    let use_tree_list = ast::UseTreeList::cast(node.clone())?;\n     if let Some((single_use_tree,)) = use_tree_list.use_trees().collect_tuple() {\n         let range = use_tree_list.syntax().range();\n         let edit =\n-            text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(single_use_tree)\n+            text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(&single_use_tree)\n                 .unwrap_or_else(|| {\n                     let to_replace = single_use_tree.syntax().text().to_string();\n                     let mut edit_builder = TextEditBuilder::default();\n@@ -141,7 +141,7 @@ fn check_struct_shorthand_initialization(\n     file_id: FileId,\n     node: &SyntaxNode,\n ) -> Option<()> {\n-    let struct_lit = ast::StructLit::cast(node)?;\n+    let struct_lit = ast::StructLit::cast(node.clone())?;\n     let named_field_list = struct_lit.named_field_list()?;\n     for named_field in named_field_list.fields() {\n         if let (Some(name_ref), Some(expr)) = (named_field.name_ref(), named_field.expr()) {\n@@ -184,7 +184,7 @@ mod tests {\n         let parse = SourceFile::parse(code);\n         let mut diagnostics = Vec::new();\n         for node in parse.tree().syntax().descendants() {\n-            func(&mut diagnostics, FileId(0), node);\n+            func(&mut diagnostics, FileId(0), &node);\n         }\n         assert!(diagnostics.is_empty());\n     }\n@@ -193,7 +193,7 @@ mod tests {\n         let parse = SourceFile::parse(before);\n         let mut diagnostics = Vec::new();\n         for node in parse.tree().syntax().descendants() {\n-            func(&mut diagnostics, FileId(0), node);\n+            func(&mut diagnostics, FileId(0), &node);\n         }\n         let diagnostic =\n             diagnostics.pop().unwrap_or_else(|| panic!(\"no diagnostics for:\\n{}\\n\", before));"}, {"sha": "644a4532b61d8c55857657ccb5c693bf61660032", "filename": "crates/ra_ide_api/src/display/function_signature.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -38,7 +38,7 @@ impl FunctionSignature {\n     pub(crate) fn from_hir(db: &db::RootDatabase, function: hir::Function) -> Self {\n         let doc = function.docs(db);\n         let ast_node = function.source(db).ast;\n-        FunctionSignature::from(&*ast_node).with_doc_opt(doc)\n+        FunctionSignature::from(&ast_node).with_doc_opt(doc)\n     }\n }\n "}, {"sha": "8cc853dd143871b0a97ba6e70cbdeab645cda513", "filename": "crates/ra_ide_api/src/display/navigation_target.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{\n     ast::{self, DocCommentsOwner},\n     AstNode, AstPtr, SmolStr,\n     SyntaxKind::{self, NAME},\n-    SyntaxNode, TextRange, TreeArc,\n+    SyntaxNode, TextRange,\n };\n \n use super::short_label::ShortLabel;\n@@ -169,7 +169,7 @@ impl NavigationTarget {\n         let file_id = src.file_id.original_file(db);\n         match src.ast {\n             FieldSource::Named(it) => {\n-                NavigationTarget::from_named(file_id, &*it, it.doc_comment_text(), it.short_label())\n+                NavigationTarget::from_named(file_id, &it, it.doc_comment_text(), it.short_label())\n             }\n             FieldSource::Pos(it) => {\n                 NavigationTarget::from_syntax(file_id, \"\".into(), None, it.syntax(), None, None)\n@@ -179,13 +179,13 @@ impl NavigationTarget {\n \n     pub(crate) fn from_def_source<A, D>(db: &RootDatabase, def: D) -> NavigationTarget\n     where\n-        D: HasSource<Ast = TreeArc<A>>,\n+        D: HasSource<Ast = A>,\n         A: ast::DocCommentsOwner + ast::NameOwner + ShortLabel,\n     {\n         let src = def.source(db);\n         NavigationTarget::from_named(\n             src.file_id.original_file(db),\n-            &*src.ast,\n+            &src.ast,\n             src.ast.doc_comment_text(),\n             src.ast.short_label(),\n         )\n@@ -249,7 +249,7 @@ impl NavigationTarget {\n         log::debug!(\"nav target {}\", src.ast.syntax().debug_dump());\n         NavigationTarget::from_named(\n             src.file_id.original_file(db),\n-            &*src.ast,\n+            &src.ast,\n             src.ast.doc_comment_text(),\n             None,\n         )\n@@ -318,22 +318,18 @@ pub(crate) fn docs_from_symbol(db: &RootDatabase, symbol: &FileSymbol) -> Option\n     let parse = db.parse(symbol.file_id);\n     let node = symbol.ptr.to_node(parse.tree().syntax()).to_owned();\n \n-    fn doc_comments<N: ast::DocCommentsOwner>(node: &N) -> Option<String> {\n-        node.doc_comment_text()\n-    }\n-\n     visitor()\n-        .visit(doc_comments::<ast::FnDef>)\n-        .visit(doc_comments::<ast::StructDef>)\n-        .visit(doc_comments::<ast::EnumDef>)\n-        .visit(doc_comments::<ast::TraitDef>)\n-        .visit(doc_comments::<ast::Module>)\n-        .visit(doc_comments::<ast::TypeAliasDef>)\n-        .visit(doc_comments::<ast::ConstDef>)\n-        .visit(doc_comments::<ast::StaticDef>)\n-        .visit(doc_comments::<ast::NamedFieldDef>)\n-        .visit(doc_comments::<ast::EnumVariant>)\n-        .visit(doc_comments::<ast::MacroCall>)\n+        .visit(|it: ast::FnDef| it.doc_comment_text())\n+        .visit(|it: ast::StructDef| it.doc_comment_text())\n+        .visit(|it: ast::EnumDef| it.doc_comment_text())\n+        .visit(|it: ast::TraitDef| it.doc_comment_text())\n+        .visit(|it: ast::Module| it.doc_comment_text())\n+        .visit(|it: ast::TypeAliasDef| it.doc_comment_text())\n+        .visit(|it: ast::ConstDef| it.doc_comment_text())\n+        .visit(|it: ast::StaticDef| it.doc_comment_text())\n+        .visit(|it: ast::NamedFieldDef| it.doc_comment_text())\n+        .visit(|it: ast::EnumVariant| it.doc_comment_text())\n+        .visit(|it: ast::MacroCall| it.doc_comment_text())\n         .accept(&node)?\n }\n \n@@ -345,15 +341,15 @@ pub(crate) fn description_from_symbol(db: &RootDatabase, symbol: &FileSymbol) ->\n     let node = symbol.ptr.to_node(parse.tree().syntax()).to_owned();\n \n     visitor()\n-        .visit(|node: &ast::FnDef| node.short_label())\n-        .visit(|node: &ast::StructDef| node.short_label())\n-        .visit(|node: &ast::EnumDef| node.short_label())\n-        .visit(|node: &ast::TraitDef| node.short_label())\n-        .visit(|node: &ast::Module| node.short_label())\n-        .visit(|node: &ast::TypeAliasDef| node.short_label())\n-        .visit(|node: &ast::ConstDef| node.short_label())\n-        .visit(|node: &ast::StaticDef| node.short_label())\n-        .visit(|node: &ast::NamedFieldDef| node.short_label())\n-        .visit(|node: &ast::EnumVariant| node.short_label())\n+        .visit(|node: ast::FnDef| node.short_label())\n+        .visit(|node: ast::StructDef| node.short_label())\n+        .visit(|node: ast::EnumDef| node.short_label())\n+        .visit(|node: ast::TraitDef| node.short_label())\n+        .visit(|node: ast::Module| node.short_label())\n+        .visit(|node: ast::TypeAliasDef| node.short_label())\n+        .visit(|node: ast::ConstDef| node.short_label())\n+        .visit(|node: ast::StaticDef| node.short_label())\n+        .visit(|node: ast::NamedFieldDef| node.short_label())\n+        .visit(|node: ast::EnumVariant| node.short_label())\n         .accept(&node)?\n }"}, {"sha": "2e183d2f60fc25620aa6a53b44f226cb554d5c80", "filename": "crates/ra_ide_api/src/display/structure.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fstructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fstructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fstructure.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -24,14 +24,14 @@ pub fn file_structure(file: &SourceFile) -> Vec<StructureNode> {\n     for event in file.syntax().preorder() {\n         match event {\n             WalkEvent::Enter(node) => {\n-                if let Some(mut symbol) = structure_node(node) {\n+                if let Some(mut symbol) = structure_node(&node) {\n                     symbol.parent = stack.last().copied();\n                     stack.push(res.len());\n                     res.push(symbol);\n                 }\n             }\n             WalkEvent::Leave(node) => {\n-                if structure_node(node).is_some() {\n+                if structure_node(&node).is_some() {\n                     stack.pop().unwrap();\n                 }\n             }\n@@ -41,19 +41,20 @@ pub fn file_structure(file: &SourceFile) -> Vec<StructureNode> {\n }\n \n fn structure_node(node: &SyntaxNode) -> Option<StructureNode> {\n-    fn decl<N: NameOwner + AttrsOwner>(node: &N) -> Option<StructureNode> {\n+    fn decl<N: NameOwner + AttrsOwner>(node: N) -> Option<StructureNode> {\n         decl_with_detail(node, None)\n     }\n \n     fn decl_with_ascription<N: NameOwner + AttrsOwner + TypeAscriptionOwner>(\n-        node: &N,\n+        node: N,\n     ) -> Option<StructureNode> {\n-        decl_with_type_ref(node, node.ascribed_type())\n+        let ty = node.ascribed_type();\n+        decl_with_type_ref(node, ty)\n     }\n \n     fn decl_with_type_ref<N: NameOwner + AttrsOwner>(\n-        node: &N,\n-        type_ref: Option<&ast::TypeRef>,\n+        node: N,\n+        type_ref: Option<ast::TypeRef>,\n     ) -> Option<StructureNode> {\n         let detail = type_ref.map(|type_ref| {\n             let mut detail = String::new();\n@@ -64,7 +65,7 @@ fn structure_node(node: &SyntaxNode) -> Option<StructureNode> {\n     }\n \n     fn decl_with_detail<N: NameOwner + AttrsOwner>(\n-        node: &N,\n+        node: N,\n         detail: Option<String>,\n     ) -> Option<StructureNode> {\n         let name = node.name()?;\n@@ -82,22 +83,24 @@ fn structure_node(node: &SyntaxNode) -> Option<StructureNode> {\n \n     fn collapse_ws(node: &SyntaxNode, output: &mut String) {\n         let mut can_insert_ws = false;\n-        for line in node.text().chunks().flat_map(|chunk| chunk.lines()) {\n-            let line = line.trim();\n-            if line.is_empty() {\n-                if can_insert_ws {\n-                    output.push_str(\" \");\n-                    can_insert_ws = false;\n+        for chunk in node.text().chunks() {\n+            for line in chunk.lines() {\n+                let line = line.trim();\n+                if line.is_empty() {\n+                    if can_insert_ws {\n+                        output.push_str(\" \");\n+                        can_insert_ws = false;\n+                    }\n+                } else {\n+                    output.push_str(line);\n+                    can_insert_ws = true;\n                 }\n-            } else {\n-                output.push_str(line);\n-                can_insert_ws = true;\n             }\n         }\n     }\n \n     visitor()\n-        .visit(|fn_def: &ast::FnDef| {\n+        .visit(|fn_def: ast::FnDef| {\n             let mut detail = String::from(\"fn\");\n             if let Some(type_param_list) = fn_def.type_param_list() {\n                 collapse_ws(type_param_list.syntax(), &mut detail);\n@@ -117,11 +120,14 @@ fn structure_node(node: &SyntaxNode) -> Option<StructureNode> {\n         .visit(decl::<ast::EnumVariant>)\n         .visit(decl::<ast::TraitDef>)\n         .visit(decl::<ast::Module>)\n-        .visit(|td: &ast::TypeAliasDef| decl_with_type_ref(td, td.type_ref()))\n+        .visit(|td: ast::TypeAliasDef| {\n+            let ty = td.type_ref();\n+            decl_with_type_ref(td, ty)\n+        })\n         .visit(decl_with_ascription::<ast::NamedFieldDef>)\n         .visit(decl_with_ascription::<ast::ConstDef>)\n         .visit(decl_with_ascription::<ast::StaticDef>)\n-        .visit(|im: &ast::ImplBlock| {\n+        .visit(|im: ast::ImplBlock| {\n             let target_type = im.target_type()?;\n             let target_trait = im.target_trait();\n             let label = match target_trait {\n@@ -142,14 +148,14 @@ fn structure_node(node: &SyntaxNode) -> Option<StructureNode> {\n             };\n             Some(node)\n         })\n-        .visit(|mc: &ast::MacroCall| {\n+        .visit(|mc: ast::MacroCall| {\n             let first_token = mc.syntax().first_token().unwrap();\n             if first_token.text().as_str() != \"macro_rules\" {\n                 return None;\n             }\n             decl(mc)\n         })\n-        .accept(node)?\n+        .accept(&node)?\n }\n \n #[cfg(test)]"}, {"sha": "8c49960f529a93a0037c1b6fb7540bb4c4e4f21f", "filename": "crates/ra_ide_api/src/extend_selection.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -42,7 +42,7 @@ fn try_extend_selection(root: &SyntaxNode, range: TextRange) -> Option<TextRange\n             TokenAtOffset::None => return None,\n             TokenAtOffset::Single(l) => {\n                 if string_kinds.contains(&l.kind()) {\n-                    extend_single_word_in_comment_or_string(l, offset).unwrap_or_else(|| l.range())\n+                    extend_single_word_in_comment_or_string(&l, offset).unwrap_or_else(|| l.range())\n                 } else {\n                     l.range()\n                 }\n@@ -56,7 +56,7 @@ fn try_extend_selection(root: &SyntaxNode, range: TextRange) -> Option<TextRange\n             if token.range() != range {\n                 return Some(token.range());\n             }\n-            if let Some(comment) = ast::Comment::cast(token) {\n+            if let Some(comment) = ast::Comment::cast(token.clone()) {\n                 if let Some(range) = extend_comments(comment) {\n                     return Some(range);\n                 }\n@@ -73,7 +73,7 @@ fn try_extend_selection(root: &SyntaxNode, range: TextRange) -> Option<TextRange\n     let node = node.ancestors().take_while(|n| n.range() == node.range()).last().unwrap();\n \n     if node.parent().map(|n| list_kinds.contains(&n.kind())) == Some(true) {\n-        if let Some(range) = extend_list_item(node) {\n+        if let Some(range) = extend_list_item(&node) {\n             return Some(range);\n         }\n     }\n@@ -82,7 +82,7 @@ fn try_extend_selection(root: &SyntaxNode, range: TextRange) -> Option<TextRange\n }\n \n fn extend_single_word_in_comment_or_string(\n-    leaf: SyntaxToken,\n+    leaf: &SyntaxToken,\n     offset: TextUnit,\n ) -> Option<TextRange> {\n     let text: &str = leaf.text();\n@@ -131,9 +131,9 @@ fn extend_ws(root: &SyntaxNode, ws: SyntaxToken, offset: TextUnit) -> TextRange\n     ws.range()\n }\n \n-fn pick_best<'a>(l: SyntaxToken<'a>, r: SyntaxToken<'a>) -> SyntaxToken<'a> {\n-    return if priority(r) > priority(l) { r } else { l };\n-    fn priority(n: SyntaxToken) -> usize {\n+fn pick_best<'a>(l: SyntaxToken, r: SyntaxToken) -> SyntaxToken {\n+    return if priority(&r) > priority(&l) { r } else { l };\n+    fn priority(n: &SyntaxToken) -> usize {\n         match n.kind() {\n             WHITESPACE => 0,\n             IDENT | T![self] | T![super] | T![crate] | LIFETIME => 2,\n@@ -156,7 +156,7 @@ fn extend_list_item(node: &SyntaxNode) -> Option<TextRange> {\n                 SyntaxElement::Token(it) => is_single_line_ws(it),\n             })\n             .next()\n-            .and_then(|it| it.as_token())\n+            .and_then(|it| it.as_token().cloned())\n             .filter(|node| node.kind() == T![,])\n     }\n \n@@ -167,7 +167,7 @@ fn extend_list_item(node: &SyntaxNode) -> Option<TextRange> {\n         // Include any following whitespace when comma if after list item.\n         let final_node = comma_node\n             .next_sibling_or_token()\n-            .and_then(|it| it.as_token())\n+            .and_then(|it| it.as_token().cloned())\n             .filter(|node| is_single_line_ws(node))\n             .unwrap_or(comma_node);\n \n@@ -178,23 +178,23 @@ fn extend_list_item(node: &SyntaxNode) -> Option<TextRange> {\n }\n \n fn extend_comments(comment: ast::Comment) -> Option<TextRange> {\n-    let prev = adj_comments(comment, Direction::Prev);\n-    let next = adj_comments(comment, Direction::Next);\n+    let prev = adj_comments(&comment, Direction::Prev);\n+    let next = adj_comments(&comment, Direction::Next);\n     if prev != next {\n         Some(TextRange::from_to(prev.syntax().range().start(), next.syntax().range().end()))\n     } else {\n         None\n     }\n }\n \n-fn adj_comments(comment: ast::Comment, dir: Direction) -> ast::Comment {\n-    let mut res = comment;\n+fn adj_comments(comment: &ast::Comment, dir: Direction) -> ast::Comment {\n+    let mut res = comment.clone();\n     for element in comment.syntax().siblings_with_tokens(dir) {\n         let token = match element.as_token() {\n             None => break,\n             Some(token) => token,\n         };\n-        if let Some(c) = ast::Comment::cast(token) {\n+        if let Some(c) = ast::Comment::cast(token.clone()) {\n             res = c\n         } else if token.kind() != WHITESPACE || token.text().contains(\"\\n\\n\") {\n             break;"}, {"sha": "c2b981aedc100f3646c8c1ac79040b4648bc96a3", "filename": "crates/ra_ide_api/src/folding_ranges.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Ffolding_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Ffolding_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Ffolding_ranges.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -30,7 +30,7 @@ pub(crate) fn folding_ranges(file: &SourceFile) -> Vec<Fold> {\n     for element in file.syntax().descendants_with_tokens() {\n         // Fold items that span multiple lines\n         if let Some(kind) = fold_kind(element.kind()) {\n-            let is_multiline = match element {\n+            let is_multiline = match &element {\n                 SyntaxElement::Node(node) => node.text().contains('\\n'),\n                 SyntaxElement::Token(token) => token.text().contains('\\n'),\n             };\n@@ -56,7 +56,7 @@ pub(crate) fn folding_ranges(file: &SourceFile) -> Vec<Fold> {\n             SyntaxElement::Node(node) => {\n                 // Fold groups of imports\n                 if node.kind() == USE_ITEM && !visited_imports.contains(&node) {\n-                    if let Some(range) = contiguous_range_for_group(node, &mut visited_imports) {\n+                    if let Some(range) = contiguous_range_for_group(&node, &mut visited_imports) {\n                         res.push(Fold { range, kind: FoldKind::Imports })\n                     }\n                 }\n@@ -65,7 +65,7 @@ pub(crate) fn folding_ranges(file: &SourceFile) -> Vec<Fold> {\n                 if node.kind() == MODULE && !has_visibility(&node) && !visited_mods.contains(&node)\n                 {\n                     if let Some(range) =\n-                        contiguous_range_for_group_unless(node, has_visibility, &mut visited_mods)\n+                        contiguous_range_for_group_unless(&node, has_visibility, &mut visited_mods)\n                     {\n                         res.push(Fold { range, kind: FoldKind::Mods })\n                     }\n@@ -88,24 +88,24 @@ fn fold_kind(kind: SyntaxKind) -> Option<FoldKind> {\n }\n \n fn has_visibility(node: &SyntaxNode) -> bool {\n-    ast::Module::cast(node).and_then(|m| m.visibility()).is_some()\n+    ast::Module::cast(node.clone()).and_then(|m| m.visibility()).is_some()\n }\n \n-fn contiguous_range_for_group<'a>(\n-    first: &'a SyntaxNode,\n-    visited: &mut FxHashSet<&'a SyntaxNode>,\n+fn contiguous_range_for_group(\n+    first: &SyntaxNode,\n+    visited: &mut FxHashSet<SyntaxNode>,\n ) -> Option<TextRange> {\n     contiguous_range_for_group_unless(first, |_| false, visited)\n }\n \n-fn contiguous_range_for_group_unless<'a>(\n-    first: &'a SyntaxNode,\n-    unless: impl Fn(&'a SyntaxNode) -> bool,\n-    visited: &mut FxHashSet<&'a SyntaxNode>,\n+fn contiguous_range_for_group_unless(\n+    first: &SyntaxNode,\n+    unless: impl Fn(&SyntaxNode) -> bool,\n+    visited: &mut FxHashSet<SyntaxNode>,\n ) -> Option<TextRange> {\n-    visited.insert(first);\n+    visited.insert(first.clone());\n \n-    let mut last = first;\n+    let mut last = first.clone();\n     for element in first.siblings_with_tokens(Direction::Next) {\n         let node = match element {\n             SyntaxElement::Token(token) => {\n@@ -123,47 +123,47 @@ fn contiguous_range_for_group_unless<'a>(\n         };\n \n         // Stop if we find a node that doesn't belong to the group\n-        if node.kind() != first.kind() || unless(node) {\n+        if node.kind() != first.kind() || unless(&node) {\n             break;\n         }\n \n-        visited.insert(node);\n+        visited.insert(node.clone());\n         last = node;\n     }\n \n-    if first != last {\n+    if first != &last {\n         Some(TextRange::from_to(first.range().start(), last.range().end()))\n     } else {\n         // The group consists of only one element, therefore it cannot be folded\n         None\n     }\n }\n \n-fn contiguous_range_for_comment<'a>(\n-    first: ast::Comment<'a>,\n-    visited: &mut FxHashSet<ast::Comment<'a>>,\n+fn contiguous_range_for_comment(\n+    first: ast::Comment,\n+    visited: &mut FxHashSet<ast::Comment>,\n ) -> Option<TextRange> {\n-    visited.insert(first);\n+    visited.insert(first.clone());\n \n     // Only fold comments of the same flavor\n     let group_kind = first.kind();\n     if !group_kind.shape.is_line() {\n         return None;\n     }\n \n-    let mut last = first;\n+    let mut last = first.clone();\n     for element in first.syntax().siblings_with_tokens(Direction::Next) {\n         match element {\n             SyntaxElement::Token(token) => {\n-                if let Some(ws) = ast::Whitespace::cast(token) {\n+                if let Some(ws) = ast::Whitespace::cast(token.clone()) {\n                     if !ws.spans_multiple_lines() {\n                         // Ignore whitespace without blank lines\n                         continue;\n                     }\n                 }\n                 if let Some(c) = ast::Comment::cast(token) {\n                     if c.kind() == group_kind {\n-                        visited.insert(c);\n+                        visited.insert(c.clone());\n                         last = c;\n                         continue;\n                     }\n@@ -193,7 +193,7 @@ mod tests {\n     fn do_check(text: &str, fold_kinds: &[FoldKind]) {\n         let (ranges, text) = extract_ranges(text, \"fold\");\n         let parse = SourceFile::parse(&text);\n-        let folds = folding_ranges(parse.tree());\n+        let folds = folding_ranges(&parse.tree());\n \n         assert_eq!(\n             folds.len(),"}, {"sha": "82b5e3b5e173b5592ae3bb39a1e482239c9df578", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 78, "deletions": 28, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -20,13 +20,13 @@ pub(crate) fn goto_definition(\n     position: FilePosition,\n ) -> Option<RangeInfo<Vec<NavigationTarget>>> {\n     let parse = db.parse(position.file_id);\n-    let syntax = parse.tree().syntax();\n-    if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, position.offset) {\n-        let navs = reference_definition(db, position.file_id, name_ref).to_vec();\n+    let syntax = parse.tree().syntax().clone();\n+    if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(&syntax, position.offset) {\n+        let navs = reference_definition(db, position.file_id, &name_ref).to_vec();\n         return Some(RangeInfo::new(name_ref.syntax().range(), navs.to_vec()));\n     }\n-    if let Some(name) = find_node_at_offset::<ast::Name>(syntax, position.offset) {\n-        let navs = name_definition(db, position.file_id, name)?;\n+    if let Some(name) = find_node_at_offset::<ast::Name>(&syntax, position.offset) {\n+        let navs = name_definition(db, position.file_id, &name)?;\n         return Some(RangeInfo::new(name.syntax().range(), navs));\n     }\n     None\n@@ -94,7 +94,7 @@ pub(crate) fn name_definition(\n ) -> Option<Vec<NavigationTarget>> {\n     let parent = name.syntax().parent()?;\n \n-    if let Some(module) = ast::Module::cast(&parent) {\n+    if let Some(module) = ast::Module::cast(parent.clone()) {\n         if module.has_semi() {\n             if let Some(child_module) =\n                 hir::source_binder::module_from_declaration(db, file_id, module)\n@@ -114,38 +114,88 @@ pub(crate) fn name_definition(\n \n fn named_target(file_id: FileId, node: &SyntaxNode) -> Option<NavigationTarget> {\n     visitor()\n-        .visit(|node: &ast::StructDef| {\n-            NavigationTarget::from_named(file_id, node, node.doc_comment_text(), node.short_label())\n+        .visit(|node: ast::StructDef| {\n+            NavigationTarget::from_named(\n+                file_id,\n+                &node,\n+                node.doc_comment_text(),\n+                node.short_label(),\n+            )\n         })\n-        .visit(|node: &ast::EnumDef| {\n-            NavigationTarget::from_named(file_id, node, node.doc_comment_text(), node.short_label())\n+        .visit(|node: ast::EnumDef| {\n+            NavigationTarget::from_named(\n+                file_id,\n+                &node,\n+                node.doc_comment_text(),\n+                node.short_label(),\n+            )\n         })\n-        .visit(|node: &ast::EnumVariant| {\n-            NavigationTarget::from_named(file_id, node, node.doc_comment_text(), node.short_label())\n+        .visit(|node: ast::EnumVariant| {\n+            NavigationTarget::from_named(\n+                file_id,\n+                &node,\n+                node.doc_comment_text(),\n+                node.short_label(),\n+            )\n         })\n-        .visit(|node: &ast::FnDef| {\n-            NavigationTarget::from_named(file_id, node, node.doc_comment_text(), node.short_label())\n+        .visit(|node: ast::FnDef| {\n+            NavigationTarget::from_named(\n+                file_id,\n+                &node,\n+                node.doc_comment_text(),\n+                node.short_label(),\n+            )\n         })\n-        .visit(|node: &ast::TypeAliasDef| {\n-            NavigationTarget::from_named(file_id, node, node.doc_comment_text(), node.short_label())\n+        .visit(|node: ast::TypeAliasDef| {\n+            NavigationTarget::from_named(\n+                file_id,\n+                &node,\n+                node.doc_comment_text(),\n+                node.short_label(),\n+            )\n         })\n-        .visit(|node: &ast::ConstDef| {\n-            NavigationTarget::from_named(file_id, node, node.doc_comment_text(), node.short_label())\n+        .visit(|node: ast::ConstDef| {\n+            NavigationTarget::from_named(\n+                file_id,\n+                &node,\n+                node.doc_comment_text(),\n+                node.short_label(),\n+            )\n         })\n-        .visit(|node: &ast::StaticDef| {\n-            NavigationTarget::from_named(file_id, node, node.doc_comment_text(), node.short_label())\n+        .visit(|node: ast::StaticDef| {\n+            NavigationTarget::from_named(\n+                file_id,\n+                &node,\n+                node.doc_comment_text(),\n+                node.short_label(),\n+            )\n         })\n-        .visit(|node: &ast::TraitDef| {\n-            NavigationTarget::from_named(file_id, node, node.doc_comment_text(), node.short_label())\n+        .visit(|node: ast::TraitDef| {\n+            NavigationTarget::from_named(\n+                file_id,\n+                &node,\n+                node.doc_comment_text(),\n+                node.short_label(),\n+            )\n         })\n-        .visit(|node: &ast::NamedFieldDef| {\n-            NavigationTarget::from_named(file_id, node, node.doc_comment_text(), node.short_label())\n+        .visit(|node: ast::NamedFieldDef| {\n+            NavigationTarget::from_named(\n+                file_id,\n+                &node,\n+                node.doc_comment_text(),\n+                node.short_label(),\n+            )\n         })\n-        .visit(|node: &ast::Module| {\n-            NavigationTarget::from_named(file_id, node, node.doc_comment_text(), node.short_label())\n+        .visit(|node: ast::Module| {\n+            NavigationTarget::from_named(\n+                file_id,\n+                &node,\n+                node.doc_comment_text(),\n+                node.short_label(),\n+            )\n         })\n-        .visit(|node: &ast::MacroCall| {\n-            NavigationTarget::from_named(file_id, node, node.doc_comment_text(), None)\n+        .visit(|node: ast::MacroCall| {\n+            NavigationTarget::from_named(file_id, &node, node.doc_comment_text(), None)\n         })\n         .accept(node)\n }"}, {"sha": "fc4b6e1af59c6c8b34508e36463b031c71147ae6", "filename": "crates/ra_ide_api/src/goto_type_definition.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_type_definition.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -13,15 +13,17 @@ pub(crate) fn goto_type_definition(\n         token\n             .parent()\n             .ancestors()\n-            .find(|n| ast::Expr::cast(*n).is_some() || ast::Pat::cast(*n).is_some())\n+            .find(|n| ast::Expr::cast(n.clone()).is_some() || ast::Pat::cast(n.clone()).is_some())\n     })?;\n \n-    let analyzer = hir::SourceAnalyzer::new(db, position.file_id, node, None);\n+    let analyzer = hir::SourceAnalyzer::new(db, position.file_id, &node, None);\n \n-    let ty: hir::Ty = if let Some(ty) = ast::Expr::cast(node).and_then(|e| analyzer.type_of(db, e))\n+    let ty: hir::Ty = if let Some(ty) =\n+        ast::Expr::cast(node.clone()).and_then(|e| analyzer.type_of(db, &e))\n     {\n         ty\n-    } else if let Some(ty) = ast::Pat::cast(node).and_then(|p| analyzer.type_of_pat(db, p)) {\n+    } else if let Some(ty) = ast::Pat::cast(node.clone()).and_then(|p| analyzer.type_of_pat(db, &p))\n+    {\n         ty\n     } else {\n         return None;"}, {"sha": "e503bf6a96aa4aa1a8bf0f12fb0e8c635ceab3e4", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -6,7 +6,7 @@ use ra_syntax::{\n         visit::{visitor, Visitor},\n     },\n     ast::{self, DocCommentsOwner},\n-    AstNode, TreeArc,\n+    AstNode,\n };\n \n use crate::{\n@@ -104,7 +104,7 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n \n         let mut no_fallback = false;\n \n-        match classify_name_ref(db, &analyzer, name_ref) {\n+        match classify_name_ref(db, &analyzer, &name_ref) {\n             Some(Method(it)) => res.extend(from_def_source(db, it)),\n             Some(Macro(it)) => {\n                 let src = it.source(db);\n@@ -163,7 +163,7 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n \n         if res.is_empty() && !no_fallback {\n             // Fallback index based approach:\n-            let symbols = crate::symbol_index::index_resolve(db, name_ref);\n+            let symbols = crate::symbol_index::index_resolve(db, &name_ref);\n             for sym in symbols {\n                 let docs = docs_from_symbol(db, &sym);\n                 let desc = description_from_symbol(db, &sym);\n@@ -177,34 +177,32 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n     } else if let Some(name) = find_node_at_offset::<ast::Name>(file.syntax(), position.offset) {\n         if let Some(parent) = name.syntax().parent() {\n             let text = visitor()\n-                .visit(|node: &ast::StructDef| {\n+                .visit(|node: ast::StructDef| {\n                     hover_text(node.doc_comment_text(), node.short_label())\n                 })\n-                .visit(|node: &ast::EnumDef| {\n+                .visit(|node: ast::EnumDef| hover_text(node.doc_comment_text(), node.short_label()))\n+                .visit(|node: ast::EnumVariant| {\n                     hover_text(node.doc_comment_text(), node.short_label())\n                 })\n-                .visit(|node: &ast::EnumVariant| {\n+                .visit(|node: ast::FnDef| hover_text(node.doc_comment_text(), node.short_label()))\n+                .visit(|node: ast::TypeAliasDef| {\n                     hover_text(node.doc_comment_text(), node.short_label())\n                 })\n-                .visit(|node: &ast::FnDef| hover_text(node.doc_comment_text(), node.short_label()))\n-                .visit(|node: &ast::TypeAliasDef| {\n+                .visit(|node: ast::ConstDef| {\n                     hover_text(node.doc_comment_text(), node.short_label())\n                 })\n-                .visit(|node: &ast::ConstDef| {\n+                .visit(|node: ast::StaticDef| {\n                     hover_text(node.doc_comment_text(), node.short_label())\n                 })\n-                .visit(|node: &ast::StaticDef| {\n+                .visit(|node: ast::TraitDef| {\n                     hover_text(node.doc_comment_text(), node.short_label())\n                 })\n-                .visit(|node: &ast::TraitDef| {\n+                .visit(|node: ast::NamedFieldDef| {\n                     hover_text(node.doc_comment_text(), node.short_label())\n                 })\n-                .visit(|node: &ast::NamedFieldDef| {\n-                    hover_text(node.doc_comment_text(), node.short_label())\n-                })\n-                .visit(|node: &ast::Module| hover_text(node.doc_comment_text(), node.short_label()))\n-                .visit(|node: &ast::MacroCall| hover_text(node.doc_comment_text(), None))\n-                .accept(parent);\n+                .visit(|node: ast::Module| hover_text(node.doc_comment_text(), node.short_label()))\n+                .visit(|node: ast::MacroCall| hover_text(node.doc_comment_text(), None))\n+                .accept(&parent);\n \n             if let Some(text) = text {\n                 res.extend(text);\n@@ -217,8 +215,9 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n     }\n \n     if range.is_none() {\n-        let node = ancestors_at_offset(file.syntax(), position.offset)\n-            .find(|n| ast::Expr::cast(*n).is_some() || ast::Pat::cast(*n).is_some())?;\n+        let node = ancestors_at_offset(file.syntax(), position.offset).find(|n| {\n+            ast::Expr::cast(n.clone()).is_some() || ast::Pat::cast(n.clone()).is_some()\n+        })?;\n         let frange = FileRange { file_id: position.file_id, range: node.range() };\n         res.extend(type_of(db, frange).map(rust_code_markup));\n         range = Some(node.range());\n@@ -233,7 +232,7 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n \n     fn from_def_source<A, D>(db: &RootDatabase, def: D) -> Option<String>\n     where\n-        D: HasSource<Ast = TreeArc<A>>,\n+        D: HasSource<Ast = A>,\n         A: ast::DocCommentsOwner + ast::NameOwner + ShortLabel,\n     {\n         let src = def.source(db);\n@@ -243,17 +242,17 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n \n pub(crate) fn type_of(db: &RootDatabase, frange: FileRange) -> Option<String> {\n     let parse = db.parse(frange.file_id);\n-    let syntax = parse.tree().syntax();\n-    let leaf_node = find_covering_element(syntax, frange.range);\n+    let leaf_node = find_covering_element(parse.tree().syntax(), frange.range);\n     // if we picked identifier, expand to pattern/expression\n     let node = leaf_node\n         .ancestors()\n         .take_while(|it| it.range() == leaf_node.range())\n-        .find(|&it| ast::Expr::cast(it).is_some() || ast::Pat::cast(it).is_some())?;\n-    let analyzer = hir::SourceAnalyzer::new(db, frange.file_id, node, None);\n-    let ty = if let Some(ty) = ast::Expr::cast(node).and_then(|e| analyzer.type_of(db, e)) {\n+        .find(|it| ast::Expr::cast(it.clone()).is_some() || ast::Pat::cast(it.clone()).is_some())?;\n+    let analyzer = hir::SourceAnalyzer::new(db, frange.file_id, &node, None);\n+    let ty = if let Some(ty) = ast::Expr::cast(node.clone()).and_then(|e| analyzer.type_of(db, &e))\n+    {\n         ty\n-    } else if let Some(ty) = ast::Pat::cast(node).and_then(|p| analyzer.type_of_pat(db, p)) {\n+    } else if let Some(ty) = ast::Pat::cast(node).and_then(|p| analyzer.type_of_pat(db, &p)) {\n         ty\n     } else {\n         return None;"}, {"sha": "15999d4331adc5ebe6bdad12ea6989bf9aa1cc92", "filename": "crates/ra_ide_api/src/impls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -9,19 +9,19 @@ pub(crate) fn goto_implementation(\n     position: FilePosition,\n ) -> Option<RangeInfo<Vec<NavigationTarget>>> {\n     let parse = db.parse(position.file_id);\n-    let syntax = parse.tree().syntax();\n+    let syntax = parse.tree().syntax().clone();\n \n     let module = source_binder::module_from_position(db, position)?;\n \n-    if let Some(nominal_def) = find_node_at_offset::<ast::NominalDef>(syntax, position.offset) {\n+    if let Some(nominal_def) = find_node_at_offset::<ast::NominalDef>(&syntax, position.offset) {\n         return Some(RangeInfo::new(\n             nominal_def.syntax().range(),\n-            impls_for_def(db, nominal_def, module)?,\n+            impls_for_def(db, &nominal_def, module)?,\n         ));\n-    } else if let Some(trait_def) = find_node_at_offset::<ast::TraitDef>(syntax, position.offset) {\n+    } else if let Some(trait_def) = find_node_at_offset::<ast::TraitDef>(&syntax, position.offset) {\n         return Some(RangeInfo::new(\n             trait_def.syntax().range(),\n-            impls_for_trait(db, trait_def, module)?,\n+            impls_for_trait(db, &trait_def, module)?,\n         ));\n     }\n "}, {"sha": "50bcfb5b76a1436a962f556e6bd7fc4a92d9b360", "filename": "crates/ra_ide_api/src/join_lines.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fjoin_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fjoin_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fjoin_lines.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -27,7 +27,7 @@ pub fn join_lines(file: &SourceFile, range: TextRange) -> TextEdit {\n         SyntaxElement::Token(token) => token.parent(),\n     };\n     let mut edit = TextEditBuilder::default();\n-    for token in node.descendants_with_tokens().filter_map(|it| it.as_token()) {\n+    for token in node.descendants_with_tokens().filter_map(|it| it.as_token().cloned()) {\n         let range = match range.intersection(&token.range()) {\n             Some(range) => range,\n             None => continue,\n@@ -37,15 +37,15 @@ pub fn join_lines(file: &SourceFile, range: TextRange) -> TextEdit {\n             let pos: TextUnit = (pos as u32).into();\n             let off = token.range().start() + range.start() + pos;\n             if !edit.invalidates_offset(off) {\n-                remove_newline(&mut edit, token, off);\n+                remove_newline(&mut edit, &token, off);\n             }\n         }\n     }\n \n     edit.finish()\n }\n \n-fn remove_newline(edit: &mut TextEditBuilder, token: SyntaxToken, offset: TextUnit) {\n+fn remove_newline(edit: &mut TextEditBuilder, token: &SyntaxToken, offset: TextUnit) {\n     if token.kind() != WHITESPACE || token.text().bytes().filter(|&b| b == b'\\n').count() != 1 {\n         // The node is either the first or the last in the file\n         let suff = &token.text()[TextRange::from_to(\n@@ -98,9 +98,10 @@ fn remove_newline(edit: &mut TextEditBuilder, token: SyntaxToken, offset: TextUn\n             TextRange::from_to(prev.range().start(), token.range().end()),\n             space.to_string(),\n         );\n-    } else if let (Some(_), Some(next)) =\n-        (prev.as_token().and_then(ast::Comment::cast), next.as_token().and_then(ast::Comment::cast))\n-    {\n+    } else if let (Some(_), Some(next)) = (\n+        prev.as_token().cloned().and_then(ast::Comment::cast),\n+        next.as_token().cloned().and_then(ast::Comment::cast),\n+    ) {\n         // Removes: newline (incl. surrounding whitespace), start of the next comment\n         edit.delete(TextRange::from_to(\n             token.range().start(),\n@@ -113,16 +114,16 @@ fn remove_newline(edit: &mut TextEditBuilder, token: SyntaxToken, offset: TextUn\n }\n \n fn has_comma_after(node: &SyntaxNode) -> bool {\n-    match non_trivia_sibling(node.into(), Direction::Next) {\n+    match non_trivia_sibling(node.clone().into(), Direction::Next) {\n         Some(n) => n.kind() == T![,],\n         _ => false,\n     }\n }\n \n-fn join_single_expr_block(edit: &mut TextEditBuilder, token: SyntaxToken) -> Option<()> {\n+fn join_single_expr_block(edit: &mut TextEditBuilder, token: &SyntaxToken) -> Option<()> {\n     let block = ast::Block::cast(token.parent())?;\n     let block_expr = ast::BlockExpr::cast(block.syntax().parent()?)?;\n-    let expr = extract_trivial_expression(block)?;\n+    let expr = extract_trivial_expression(&block)?;\n \n     let block_range = block_expr.syntax().range();\n     let mut buf = expr.syntax().text().to_string();\n@@ -139,7 +140,7 @@ fn join_single_expr_block(edit: &mut TextEditBuilder, token: SyntaxToken) -> Opt\n     Some(())\n }\n \n-fn join_single_use_tree(edit: &mut TextEditBuilder, token: SyntaxToken) -> Option<()> {\n+fn join_single_use_tree(edit: &mut TextEditBuilder, token: &SyntaxToken) -> Option<()> {\n     let use_tree_list = ast::UseTreeList::cast(token.parent())?;\n     let (tree,) = use_tree_list.use_trees().collect_tuple()?;\n     edit.replace(use_tree_list.syntax().range(), tree.syntax().text().to_string());\n@@ -504,7 +505,7 @@ fn foo() {\n     fn check_join_lines_sel(before: &str, after: &str) {\n         let (sel, before) = extract_range(before);\n         let parse = SourceFile::parse(&before);\n-        let result = join_lines(parse.tree(), sel);\n+        let result = join_lines(&parse.tree(), sel);\n         let actual = result.apply(&before);\n         assert_eq_text!(after, &actual);\n     }"}, {"sha": "c54d574bcc5db2bbd0f4f668f18186c7c0b95cc5", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -50,7 +50,7 @@ use ra_db::{\n     salsa::{self, ParallelDatabase},\n     CheckCanceled, SourceDatabase,\n };\n-use ra_syntax::{SourceFile, TextRange, TextUnit, TreeArc};\n+use ra_syntax::{SourceFile, TextRange, TextUnit};\n use ra_text_edit::TextEdit;\n use relative_path::RelativePathBuf;\n \n@@ -325,8 +325,8 @@ impl Analysis {\n     }\n \n     /// Gets the syntax tree of the file.\n-    pub fn parse(&self, file_id: FileId) -> TreeArc<SourceFile> {\n-        self.db.parse(file_id).tree().to_owned()\n+    pub fn parse(&self, file_id: FileId) -> SourceFile {\n+        self.db.parse(file_id).tree()\n     }\n \n     /// Gets the file's `LineIndex`: data structure to convert between absolute\n@@ -360,7 +360,7 @@ impl Analysis {\n         let parse = self.db.parse(frange.file_id);\n         let file_edit = SourceFileEdit {\n             file_id: frange.file_id,\n-            edit: join_lines::join_lines(parse.tree(), frange.range),\n+            edit: join_lines::join_lines(&parse.tree(), frange.range),\n         };\n         SourceChange::source_file_edit(\"join lines\", file_edit)\n     }\n@@ -393,13 +393,13 @@ impl Analysis {\n     /// file outline.\n     pub fn file_structure(&self, file_id: FileId) -> Vec<StructureNode> {\n         let parse = self.db.parse(file_id);\n-        file_structure(parse.tree())\n+        file_structure(&parse.tree())\n     }\n \n     /// Returns the set of folding ranges.\n     pub fn folding_ranges(&self, file_id: FileId) -> Vec<Fold> {\n         let parse = self.db.parse(file_id);\n-        folding_ranges::folding_ranges(parse.tree())\n+        folding_ranges::folding_ranges(&parse.tree())\n     }\n \n     /// Fuzzy searches for a symbol."}, {"sha": "102327fd73930fb3e968042aa4e7ded506813f70", "filename": "crates/ra_ide_api/src/matching_brace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fmatching_brace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fmatching_brace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fmatching_brace.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -26,7 +26,7 @@ mod tests {\n         fn do_check(before: &str, after: &str) {\n             let (pos, before) = extract_offset(before);\n             let parse = SourceFile::parse(&before);\n-            let new_pos = match matching_brace(parse.tree(), pos) {\n+            let new_pos = match matching_brace(&parse.tree(), pos) {\n                 None => pos,\n                 Some(pos) => pos,\n             };"}, {"sha": "6832acf5dd22fbc4872c0d9eb2ca39cee3681374", "filename": "crates/ra_ide_api/src/name_ref_kind.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fname_ref_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fname_ref_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fname_ref_kind.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -26,7 +26,7 @@ pub(crate) fn classify_name_ref(\n     // Check if it is a method\n     if let Some(method_call) = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast) {\n         tested_by!(goto_definition_works_for_methods);\n-        if let Some(func) = analyzer.resolve_method_call(method_call) {\n+        if let Some(func) = analyzer.resolve_method_call(&method_call) {\n             return Some(Method(func));\n         }\n     }\n@@ -40,15 +40,15 @@ pub(crate) fn classify_name_ref(\n         .and_then(ast::MacroCall::cast)\n     {\n         tested_by!(goto_definition_works_for_macros);\n-        if let Some(mac) = analyzer.resolve_macro_call(db, macro_call) {\n+        if let Some(mac) = analyzer.resolve_macro_call(db, &macro_call) {\n             return Some(Macro(mac));\n         }\n     }\n \n     // It could also be a field access\n     if let Some(field_expr) = name_ref.syntax().parent().and_then(ast::FieldExpr::cast) {\n         tested_by!(goto_definition_works_for_fields);\n-        if let Some(field) = analyzer.resolve_field(field_expr) {\n+        if let Some(field) = analyzer.resolve_field(&field_expr) {\n             return Some(FieldAccess(field));\n         };\n     }\n@@ -59,7 +59,7 @@ pub(crate) fn classify_name_ref(\n \n         let struct_lit = field_expr.syntax().ancestors().find_map(ast::StructLit::cast);\n \n-        if let Some(ty) = struct_lit.and_then(|lit| analyzer.type_of(db, lit.into())) {\n+        if let Some(ty) = struct_lit.and_then(|lit| analyzer.type_of(db, &lit.into())) {\n             if let Some((hir::AdtDef::Struct(s), _)) = ty.as_adt() {\n                 let hir_path = hir::Path::from_name_ref(name_ref);\n                 let hir_name = hir_path.as_ident().unwrap();\n@@ -73,7 +73,7 @@ pub(crate) fn classify_name_ref(\n \n     // General case, a path or a local:\n     if let Some(path) = name_ref.syntax().ancestors().find_map(ast::Path::cast) {\n-        if let Some(resolved) = analyzer.resolve_path(db, path) {\n+        if let Some(resolved) = analyzer.resolve_path(db, &path) {\n             return match resolved {\n                 hir::PathResolution::Def(def) => Some(Def(def)),\n                 hir::PathResolution::LocalBinding(Either::A(pat)) => Some(Pat(pat)),"}, {"sha": "1c4cd49dccebf9a48d0a08911bbdfc264cf9435f", "filename": "crates/ra_ide_api/src/references.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -50,11 +50,11 @@ pub(crate) fn find_all_refs(\n     position: FilePosition,\n ) -> Option<ReferenceSearchResult> {\n     let parse = db.parse(position.file_id);\n-    let (binding, analyzer) = find_binding(db, parse.tree(), position)?;\n-    let declaration = NavigationTarget::from_bind_pat(position.file_id, binding);\n+    let (binding, analyzer) = find_binding(db, &parse.tree(), position)?;\n+    let declaration = NavigationTarget::from_bind_pat(position.file_id, &binding);\n \n     let references = analyzer\n-        .find_all_refs(binding)\n+        .find_all_refs(&binding)\n         .into_iter()\n         .map(move |ref_desc| FileRange { file_id: position.file_id, range: ref_desc.range })\n         .collect::<Vec<_>>();\n@@ -63,17 +63,17 @@ pub(crate) fn find_all_refs(\n \n     fn find_binding<'a>(\n         db: &RootDatabase,\n-        source_file: &'a SourceFile,\n+        source_file: &SourceFile,\n         position: FilePosition,\n-    ) -> Option<(&'a ast::BindPat, hir::SourceAnalyzer)> {\n+    ) -> Option<(ast::BindPat, hir::SourceAnalyzer)> {\n         let syntax = source_file.syntax();\n         if let Some(binding) = find_node_at_offset::<ast::BindPat>(syntax, position.offset) {\n             let analyzer = hir::SourceAnalyzer::new(db, position.file_id, binding.syntax(), None);\n             return Some((binding, analyzer));\n         };\n         let name_ref = find_node_at_offset::<ast::NameRef>(syntax, position.offset)?;\n         let analyzer = hir::SourceAnalyzer::new(db, position.file_id, name_ref.syntax(), None);\n-        let resolved = analyzer.resolve_local_name(name_ref)?;\n+        let resolved = analyzer.resolve_local_name(&name_ref)?;\n         if let Either::A(ptr) = resolved.ptr() {\n             if let ast::PatKind::BindPat(binding) = ptr.to_node(source_file.syntax()).kind() {\n                 return Some((binding, analyzer));\n@@ -89,10 +89,10 @@ pub(crate) fn rename(\n     new_name: &str,\n ) -> Option<SourceChange> {\n     let parse = db.parse(position.file_id);\n-    let syntax = parse.tree().syntax();\n-\n-    if let Some((ast_name, ast_module)) = find_name_and_module_at_offset(syntax, position) {\n-        rename_mod(db, ast_name, ast_module, position, new_name)\n+    if let Some((ast_name, ast_module)) =\n+        find_name_and_module_at_offset(parse.tree().syntax(), position)\n+    {\n+        rename_mod(db, &ast_name, &ast_module, position, new_name)\n     } else {\n         rename_reference(db, position, new_name)\n     }\n@@ -101,14 +101,10 @@ pub(crate) fn rename(\n fn find_name_and_module_at_offset(\n     syntax: &SyntaxNode,\n     position: FilePosition,\n-) -> Option<(&ast::Name, &ast::Module)> {\n-    let ast_name = find_node_at_offset::<ast::Name>(syntax, position.offset);\n-    let ast_name_parent = ast::Module::cast(ast_name?.syntax().parent()?);\n-\n-    if let (Some(ast_module), Some(name)) = (ast_name_parent, ast_name) {\n-        return Some((name, ast_module));\n-    }\n-    None\n+) -> Option<(ast::Name, ast::Module)> {\n+    let ast_name = find_node_at_offset::<ast::Name>(syntax, position.offset)?;\n+    let ast_module = ast::Module::cast(ast_name.syntax().parent()?)?;\n+    Some((ast_name, ast_module))\n }\n \n fn source_edit_from_fileid_range(\n@@ -135,7 +131,8 @@ fn rename_mod(\n ) -> Option<SourceChange> {\n     let mut source_file_edits = Vec::new();\n     let mut file_system_edits = Vec::new();\n-    if let Some(module) = source_binder::module_from_declaration(db, position.file_id, &ast_module)\n+    if let Some(module) =\n+        source_binder::module_from_declaration(db, position.file_id, ast_module.clone())\n     {\n         let src = module.definition_source(db);\n         let file_id = src.file_id.as_original_file();"}, {"sha": "2009584341fcda9f7981b3fe13e6e25b1a23695c", "filename": "crates/ra_ide_api/src/runnables.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -26,8 +26,8 @@ pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Vec<Runnable> {\n     parse.tree().syntax().descendants().filter_map(|i| runnable(db, file_id, i)).collect()\n }\n \n-fn runnable(db: &RootDatabase, file_id: FileId, item: &SyntaxNode) -> Option<Runnable> {\n-    if let Some(fn_def) = ast::FnDef::cast(item) {\n+fn runnable(db: &RootDatabase, file_id: FileId, item: SyntaxNode) -> Option<Runnable> {\n+    if let Some(fn_def) = ast::FnDef::cast(item.clone()) {\n         runnable_fn(fn_def)\n     } else if let Some(m) = ast::Module::cast(item) {\n         runnable_mod(db, file_id, m)\n@@ -36,8 +36,8 @@ fn runnable(db: &RootDatabase, file_id: FileId, item: &SyntaxNode) -> Option<Run\n     }\n }\n \n-fn runnable_fn(fn_def: &ast::FnDef) -> Option<Runnable> {\n-    let name = fn_def.name()?.text();\n+fn runnable_fn(fn_def: ast::FnDef) -> Option<Runnable> {\n+    let name = fn_def.name()?.text().clone();\n     let kind = if name == \"main\" {\n         RunnableKind::Bin\n     } else if fn_def.has_atom_attr(\"test\") {\n@@ -50,7 +50,7 @@ fn runnable_fn(fn_def: &ast::FnDef) -> Option<Runnable> {\n     Some(Runnable { range: fn_def.syntax().range(), kind })\n }\n \n-fn runnable_mod(db: &RootDatabase, file_id: FileId, module: &ast::Module) -> Option<Runnable> {\n+fn runnable_mod(db: &RootDatabase, file_id: FileId, module: ast::Module) -> Option<Runnable> {\n     let has_test_function = module\n         .item_list()?\n         .items()"}, {"sha": "d533d1742c46fb27939bcc1ea7c50a4fb527e808", "filename": "crates/ra_ide_api/src/status.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fstatus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fstatus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fstatus.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -104,7 +104,7 @@ impl FromIterator<TableEntry<MacroFile, Option<Parse<SyntaxNode>>>> for SyntaxTr\n         let mut res = SyntaxTreeStats::default();\n         for entry in iter {\n             res.total += 1;\n-            if let Some(tree) = entry.value.and_then(|it| it).map(|it| it.tree().to_owned()) {\n+            if let Some(tree) = entry.value.and_then(|it| it).map(|it| it.syntax_node()) {\n                 res.retained += 1;\n                 res.retained_size += tree.memory_size_of_subtree();\n             }"}, {"sha": "e784b5f69a19ff6921ebf23c7529c68b619900ee", "filename": "crates/ra_ide_api/src/symbol_index.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -61,7 +61,7 @@ fn file_symbols(db: &impl SymbolsDatabase, file_id: FileId) -> Arc<SymbolIndex>\n     db.check_canceled();\n     let parse = db.parse(file_id);\n \n-    let symbols = source_file_to_file_symbols(parse.tree(), file_id);\n+    let symbols = source_file_to_file_symbols(&parse.tree(), file_id);\n \n     // FIXME: add macros here\n \n@@ -173,7 +173,7 @@ impl SymbolIndex {\n         files: impl ParallelIterator<Item = (FileId, Parse<ast::SourceFile>)>,\n     ) -> SymbolIndex {\n         let symbols = files\n-            .flat_map(|(file_id, file)| source_file_to_file_symbols(file.tree(), file_id))\n+            .flat_map(|(file_id, file)| source_file_to_file_symbols(&file.tree(), file_id))\n             .collect::<Vec<_>>();\n         SymbolIndex::new(symbols)\n     }\n@@ -249,7 +249,7 @@ fn source_file_to_file_symbols(source_file: &SourceFile, file_id: FileId) -> Vec\n     for event in source_file.syntax().preorder() {\n         match event {\n             WalkEvent::Enter(node) => {\n-                if let Some(mut symbol) = to_file_symbol(node, file_id) {\n+                if let Some(mut symbol) = to_file_symbol(&node, file_id) {\n                     symbol.container_name = stack.last().cloned();\n \n                     stack.push(symbol.name.clone());\n@@ -258,7 +258,7 @@ fn source_file_to_file_symbols(source_file: &SourceFile, file_id: FileId) -> Vec\n             }\n \n             WalkEvent::Leave(node) => {\n-                if to_symbol(node).is_some() {\n+                if to_symbol(&node).is_some() {\n                     stack.pop();\n                 }\n             }\n@@ -269,7 +269,7 @@ fn source_file_to_file_symbols(source_file: &SourceFile, file_id: FileId) -> Vec\n }\n \n fn to_symbol(node: &SyntaxNode) -> Option<(SmolStr, SyntaxNodePtr, TextRange)> {\n-    fn decl<N: NameOwner>(node: &N) -> Option<(SmolStr, SyntaxNodePtr, TextRange)> {\n+    fn decl<N: NameOwner>(node: N) -> Option<(SmolStr, SyntaxNodePtr, TextRange)> {\n         let name = node.name()?;\n         let name_range = name.syntax().range();\n         let name = name.text().clone();"}, {"sha": "16a7287899fc6a5944b2aa1c88f894df7566ba09", "filename": "crates/ra_ide_api/src/syntax_highlighting.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -31,8 +31,8 @@ fn is_control_keyword(kind: SyntaxKind) -> bool {\n     }\n }\n \n-fn is_variable_mutable(db: &RootDatabase, analyzer: &hir::SourceAnalyzer, pat: &ast::Pat) -> bool {\n-    let ty = analyzer.type_of_pat(db, pat).unwrap_or(Ty::Unknown);\n+fn is_variable_mutable(db: &RootDatabase, analyzer: &hir::SourceAnalyzer, pat: ast::Pat) -> bool {\n+    let ty = analyzer.type_of_pat(db, &pat).unwrap_or(Ty::Unknown);\n     let is_ty_mut = {\n         if let Some((_, mutability)) = ty.as_reference() {\n             match mutability {\n@@ -55,7 +55,7 @@ fn is_variable_mutable(db: &RootDatabase, analyzer: &hir::SourceAnalyzer, pat: &\n pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRange> {\n     let _p = profile(\"highlight\");\n     let parse = db.parse(file_id);\n-    let root = parse.tree().syntax();\n+    let root = parse.tree().syntax().clone();\n \n     fn calc_binding_hash(file_id: FileId, text: &SmolStr, shadow_count: u32) -> u64 {\n         fn hash<T: std::hash::Hash + std::fmt::Debug>(x: T) -> u64 {\n@@ -70,6 +70,7 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n     }\n \n     // Visited nodes to handle highlighting priorities\n+    // FIXME: retain only ranges here\n     let mut highlighted: FxHashSet<SyntaxElement> = FxHashSet::default();\n     let mut bindings_shadow_count: FxHashMap<SmolStr, u32> = FxHashMap::default();\n \n@@ -84,14 +85,14 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n             STRING | RAW_STRING | RAW_BYTE_STRING | BYTE_STRING => \"string\",\n             ATTR => \"attribute\",\n             NAME_REF => {\n-                if let Some(name_ref) = node.as_node().and_then(ast::NameRef::cast) {\n+                if let Some(name_ref) = node.as_node().cloned().and_then(ast::NameRef::cast) {\n                     // FIXME: revisit this after #1340\n                     use crate::name_ref_kind::{classify_name_ref, NameRefKind::*};\n                     use hir::{ImplItem, ModuleDef};\n \n                     // FIXME: try to reuse the SourceAnalyzers\n                     let analyzer = hir::SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n-                    match classify_name_ref(db, &analyzer, name_ref) {\n+                    match classify_name_ref(db, &analyzer, &name_ref) {\n                         Some(Method(_)) => \"function\",\n                         Some(Macro(_)) => \"macro\",\n                         Some(FieldAccess(_)) => \"field\",\n@@ -113,13 +114,13 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n                         Some(Pat(ptr)) => {\n                             binding_hash = Some({\n                                 let text =\n-                                    ptr.syntax_node_ptr().to_node(root).text().to_smol_string();\n+                                    ptr.syntax_node_ptr().to_node(&root).text().to_smol_string();\n                                 let shadow_count =\n                                     bindings_shadow_count.entry(text.clone()).or_default();\n                                 calc_binding_hash(file_id, &text, *shadow_count)\n                             });\n \n-                            if is_variable_mutable(db, &analyzer, ptr.to_node(root)) {\n+                            if is_variable_mutable(db, &analyzer, ptr.to_node(&root)) {\n                                 \"variable.mut\"\n                             } else {\n                                 \"variable\"\n@@ -134,7 +135,7 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n                 }\n             }\n             NAME => {\n-                if let Some(name) = node.as_node().and_then(ast::Name::cast) {\n+                if let Some(name) = node.as_node().cloned().and_then(ast::Name::cast) {\n                     let analyzer = hir::SourceAnalyzer::new(db, file_id, name.syntax(), None);\n                     if let Some(pat) = name.syntax().ancestors().find_map(ast::Pat::cast) {\n                         binding_hash = Some({\n@@ -176,12 +177,11 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n             k if is_control_keyword(k) => \"keyword.control\",\n             k if k.is_keyword() => \"keyword\",\n             _ => {\n-                // let analyzer = hir::SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n-                if let Some(macro_call) = node.as_node().and_then(ast::MacroCall::cast) {\n+                if let Some(macro_call) = node.as_node().cloned().and_then(ast::MacroCall::cast) {\n                     if let Some(path) = macro_call.path() {\n                         if let Some(segment) = path.segment() {\n                             if let Some(name_ref) = segment.name_ref() {\n-                                highlighted.insert(name_ref.syntax().into());\n+                                highlighted.insert(name_ref.syntax().clone().into());\n                                 let range_start = name_ref.syntax().range().start();\n                                 let mut range_end = name_ref.syntax().range().end();\n                                 for sibling in path.syntax().siblings_with_tokens(Direction::Next) {\n@@ -230,7 +230,8 @@ pub(crate) fn highlight_as_html(db: &RootDatabase, file_id: FileId, rainbow: boo\n     let mut buf = String::new();\n     buf.push_str(&STYLE);\n     buf.push_str(\"<pre><code>\");\n-    let tokens = parse.tree().syntax().descendants_with_tokens().filter_map(|it| it.as_token());\n+    let tokens =\n+        parse.tree().syntax().descendants_with_tokens().filter_map(|it| it.as_token().cloned());\n     for token in tokens {\n         could_intersect.retain(|it| token.range().start() <= it.range.end());\n         while let Some(r) = ranges.get(frontier) {"}, {"sha": "3d7373d02bce1879d392b6a105b3785b6343efdf", "filename": "crates/ra_ide_api/src/syntax_tree.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fsyntax_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Fsyntax_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsyntax_tree.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -18,7 +18,7 @@ pub(crate) fn syntax_tree(\n         let node = match algo::find_covering_element(parse.tree().syntax(), text_range) {\r\n             SyntaxElement::Node(node) => node,\r\n             SyntaxElement::Token(token) => {\r\n-                if let Some(tree) = syntax_tree_for_string(token, text_range) {\r\n+                if let Some(tree) = syntax_tree_for_string(&token, text_range) {\r\n                     return tree;\r\n                 }\r\n                 token.parent()\r\n@@ -33,7 +33,7 @@ pub(crate) fn syntax_tree(\n \r\n /// Attempts parsing the selected contents of a string literal\r\n /// as rust syntax and returns its syntax tree\r\n-fn syntax_tree_for_string(token: SyntaxToken, text_range: TextRange) -> Option<String> {\r\n+fn syntax_tree_for_string(token: &SyntaxToken, text_range: TextRange) -> Option<String> {\r\n     // When the range is inside a string\r\n     // we'll attempt parsing it as rust syntax\r\n     // to provide the syntax tree of the contents of the string\r\n@@ -43,7 +43,7 @@ fn syntax_tree_for_string(token: SyntaxToken, text_range: TextRange) -> Option<S\n     }\r\n }\r\n \r\n-fn syntax_tree_for_token(node: SyntaxToken, text_range: TextRange) -> Option<String> {\r\n+fn syntax_tree_for_token(node: &SyntaxToken, text_range: TextRange) -> Option<String> {\r\n     // Range of the full node\r\n     let node_range = node.range();\r\n     let text = node.text().to_string();\r"}, {"sha": "ad0ababcc0aa2d7a8cc115b21b657a325547d735", "filename": "crates/ra_ide_api/src/typing.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -1,15 +1,16 @@\n-use crate::{db::RootDatabase, SourceChange, SourceFileEdit};\n use ra_db::{FilePosition, SourceDatabase};\n use ra_fmt::leading_indent;\n use ra_syntax::{\n     algo::{find_node_at_offset, find_token_at_offset, TokenAtOffset},\n     ast::{self, AstToken},\n-    AstNode, SourceFile,\n+    AstNode, SmolStr, SourceFile,\n     SyntaxKind::*,\n     SyntaxToken, TextRange, TextUnit,\n };\n use ra_text_edit::{TextEdit, TextEditBuilder};\n \n+use crate::{db::RootDatabase, SourceChange, SourceFileEdit};\n+\n pub(crate) fn on_enter(db: &RootDatabase, position: FilePosition) -> Option<SourceChange> {\n     let parse = db.parse(position.file_id);\n     let file = parse.tree();\n@@ -43,15 +44,15 @@ pub(crate) fn on_enter(db: &RootDatabase, position: FilePosition) -> Option<Sour\n     )\n }\n \n-fn node_indent<'a>(file: &'a SourceFile, token: SyntaxToken) -> Option<&'a str> {\n+fn node_indent(file: &SourceFile, token: &SyntaxToken) -> Option<SmolStr> {\n     let ws = match find_token_at_offset(file.syntax(), token.range().start()) {\n         TokenAtOffset::Between(l, r) => {\n-            assert!(r == token);\n+            assert!(r == *token);\n             l\n         }\n         TokenAtOffset::Single(n) => {\n-            assert!(n == token);\n-            return Some(\"\");\n+            assert!(n == *token);\n+            return Some(\"\".into());\n         }\n         TokenAtOffset::None => unreachable!(),\n     };\n@@ -60,12 +61,12 @@ fn node_indent<'a>(file: &'a SourceFile, token: SyntaxToken) -> Option<&'a str>\n     }\n     let text = ws.text();\n     let pos = text.rfind('\\n').map(|it| it + 1).unwrap_or(0);\n-    Some(&text[pos..])\n+    Some(text[pos..].into())\n }\n \n pub fn on_eq_typed(file: &SourceFile, eq_offset: TextUnit) -> Option<TextEdit> {\n     assert_eq!(file.syntax().text().char_at(eq_offset), Some('='));\n-    let let_stmt: &ast::LetStmt = find_node_at_offset(file.syntax(), eq_offset)?;\n+    let let_stmt: ast::LetStmt = find_node_at_offset(file.syntax(), eq_offset)?;\n     if let_stmt.has_semi() {\n         return None;\n     }\n@@ -141,7 +142,7 @@ mod tests {\n             edit.insert(offset, \"=\".to_string());\n             let before = edit.finish().apply(&before);\n             let parse = SourceFile::parse(&before);\n-            if let Some(result) = on_eq_typed(parse.tree(), offset) {\n+            if let Some(result) = on_eq_typed(&parse.tree(), offset) {\n                 let actual = result.apply(&before);\n                 assert_eq_text!(after, &actual);\n             } else {"}, {"sha": "f185aecb7183926c7f6709fbdc58e8bdf2d09bfb", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -599,7 +599,8 @@ mod tests {\n         let macro_definition =\n             source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n \n-        let (definition_tt, _) = ast_to_token_tree(macro_definition.token_tree().unwrap()).unwrap();\n+        let (definition_tt, _) =\n+            ast_to_token_tree(&macro_definition.token_tree().unwrap()).unwrap();\n         crate::MacroRules::parse(&definition_tt).unwrap()\n     }\n \n@@ -611,7 +612,8 @@ mod tests {\n         let macro_invocation =\n             source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n \n-        let (invocation_tt, _) = ast_to_token_tree(macro_invocation.token_tree().unwrap()).unwrap();\n+        let (invocation_tt, _) =\n+            ast_to_token_tree(&macro_invocation.token_tree().unwrap()).unwrap();\n \n         expand_rule(&rules.rules[0], &invocation_tt)\n     }"}, {"sha": "954b84d9d7decdd6f3181b5ea9ecd06c12c6b98c", "filename": "crates/ra_mbe/src/mbe_parser.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -179,7 +179,8 @@ mod tests {\n         let macro_definition =\n             source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n \n-        let (definition_tt, _) = ast_to_token_tree(macro_definition.token_tree().unwrap()).unwrap();\n+        let (definition_tt, _) =\n+            ast_to_token_tree(&macro_definition.token_tree().unwrap()).unwrap();\n         parse(&definition_tt)\n     }\n "}, {"sha": "64ed6a517dad07733614ee0fbd4eb9c7904ef247", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -2,7 +2,7 @@ use crate::subtree_source::SubtreeTokenSource;\n use crate::ExpandError;\n use ra_parser::{ParseError, TreeSink};\n use ra_syntax::{\n-    ast, AstNode, Parse, SmolStr, SyntaxElement, SyntaxKind, SyntaxKind::*, SyntaxNode,\n+    ast, AstNode, AstToken, Parse, SmolStr, SyntaxElement, SyntaxKind, SyntaxKind::*, SyntaxNode,\n     SyntaxTreeBuilder, TextRange, TextUnit, T,\n };\n use tt::buffer::{Cursor, TokenBuffer};\n@@ -116,8 +116,6 @@ impl TokenMap {\n /// and strips the ending `*/`\n /// And then quote the string, which is needed to convert to `tt::Literal`\n fn doc_comment_text(comment: &ast::Comment) -> SmolStr {\n-    use ast::AstToken;\n-\n     let prefix_len = comment.prefix().len();\n     let mut text = &comment.text()[prefix_len..];\n \n@@ -132,9 +130,8 @@ fn doc_comment_text(comment: &ast::Comment) -> SmolStr {\n     text.into()\n }\n \n-fn convert_doc_comment<'a>(token: &ra_syntax::SyntaxToken<'a>) -> Option<Vec<tt::TokenTree>> {\n-    use ast::AstToken;\n-    let comment = ast::Comment::cast(*token)?;\n+fn convert_doc_comment(token: &ra_syntax::SyntaxToken) -> Option<Vec<tt::TokenTree>> {\n+    let comment = ast::Comment::cast(token.clone())?;\n     let doc = comment.kind().doc?;\n \n     // Make `doc=\"\\\" Comments\\\"\"\n@@ -245,7 +242,7 @@ fn convert_tt(\n                 }\n             }\n             SyntaxElement::Node(node) => {\n-                let child = convert_tt(token_map, global_offset, node)?.into();\n+                let child = convert_tt(token_map, global_offset, &node)?.into();\n                 token_trees.push(child);\n             }\n         };"}, {"sha": "38a31109d9f97b3bed3cc18241463ee0323b38fa", "filename": "crates/ra_mbe/src/tests.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -37,8 +37,8 @@ impl_froms!(TokenTree: Leaf, Subtree);\n     let macro_invocation =\n         source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n \n-    let (definition_tt, _) = ast_to_token_tree(macro_definition.token_tree().unwrap()).unwrap();\n-    let (invocation_tt, _) = ast_to_token_tree(macro_invocation.token_tree().unwrap()).unwrap();\n+    let (definition_tt, _) = ast_to_token_tree(&macro_definition.token_tree().unwrap()).unwrap();\n+    let (invocation_tt, _) = ast_to_token_tree(&macro_invocation.token_tree().unwrap()).unwrap();\n     let rules = crate::MacroRules::parse(&definition_tt).unwrap();\n     let expansion = rules.expand(&invocation_tt).unwrap();\n     assert_eq!(\n@@ -53,7 +53,7 @@ pub(crate) fn create_rules(macro_definition: &str) -> MacroRules {\n     let macro_definition =\n         source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n \n-    let (definition_tt, _) = ast_to_token_tree(macro_definition.token_tree().unwrap()).unwrap();\n+    let (definition_tt, _) = ast_to_token_tree(&macro_definition.token_tree().unwrap()).unwrap();\n     crate::MacroRules::parse(&definition_tt).unwrap()\n }\n \n@@ -62,42 +62,33 @@ pub(crate) fn expand(rules: &MacroRules, invocation: &str) -> tt::Subtree {\n     let macro_invocation =\n         source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n \n-    let (invocation_tt, _) = ast_to_token_tree(macro_invocation.token_tree().unwrap()).unwrap();\n+    let (invocation_tt, _) = ast_to_token_tree(&macro_invocation.token_tree().unwrap()).unwrap();\n \n     rules.expand(&invocation_tt).unwrap()\n }\n \n-pub(crate) fn expand_to_items(\n-    rules: &MacroRules,\n-    invocation: &str,\n-) -> ra_syntax::TreeArc<ast::MacroItems> {\n+pub(crate) fn expand_to_items(rules: &MacroRules, invocation: &str) -> ast::MacroItems {\n     let expanded = expand(rules, invocation);\n-    token_tree_to_macro_items(&expanded).unwrap().tree().to_owned()\n+    token_tree_to_macro_items(&expanded).unwrap().tree()\n }\n \n #[allow(unused)]\n-pub(crate) fn expand_to_stmts(\n-    rules: &MacroRules,\n-    invocation: &str,\n-) -> ra_syntax::TreeArc<ast::MacroStmts> {\n+pub(crate) fn expand_to_stmts(rules: &MacroRules, invocation: &str) -> ast::MacroStmts {\n     let expanded = expand(rules, invocation);\n-    token_tree_to_macro_stmts(&expanded).unwrap().tree().to_owned()\n+    token_tree_to_macro_stmts(&expanded).unwrap().tree()\n }\n \n-pub(crate) fn expand_to_expr(\n-    rules: &MacroRules,\n-    invocation: &str,\n-) -> ra_syntax::TreeArc<ast::Expr> {\n+pub(crate) fn expand_to_expr(rules: &MacroRules, invocation: &str) -> ast::Expr {\n     let expanded = expand(rules, invocation);\n-    token_tree_to_expr(&expanded).unwrap().tree().to_owned()\n+    token_tree_to_expr(&expanded).unwrap().tree()\n }\n \n pub(crate) fn text_to_tokentree(text: &str) -> tt::Subtree {\n     // wrap the given text to a macro call\n     let wrapped = format!(\"wrap_macro!( {} )\", text);\n     let wrapped = ast::SourceFile::parse(&wrapped);\n     let wrapped = wrapped.tree().syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n-    let mut wrapped = ast_to_token_tree(wrapped).unwrap().0;\n+    let mut wrapped = ast_to_token_tree(&wrapped).unwrap().0;\n     wrapped.delimiter = tt::Delimiter::None;\n \n     wrapped\n@@ -164,8 +155,8 @@ pub(crate) fn assert_expansion(\n \n     let (expanded_tree, expected_tree) = match kind {\n         MacroKind::Items => {\n-            let expanded_tree = token_tree_to_macro_items(&expanded).unwrap().tree().to_owned();\n-            let expected_tree = token_tree_to_macro_items(&expected).unwrap().tree().to_owned();\n+            let expanded_tree = token_tree_to_macro_items(&expanded).unwrap().tree();\n+            let expected_tree = token_tree_to_macro_items(&expected).unwrap().tree();\n \n             (\n                 debug_dump_ignore_spaces(expanded_tree.syntax()).trim().to_string(),\n@@ -174,8 +165,8 @@ pub(crate) fn assert_expansion(\n         }\n \n         MacroKind::Stmts => {\n-            let expanded_tree = token_tree_to_macro_stmts(&expanded).unwrap().tree().to_owned();\n-            let expected_tree = token_tree_to_macro_stmts(&expected).unwrap().tree().to_owned();\n+            let expanded_tree = token_tree_to_macro_stmts(&expanded).unwrap().tree();\n+            let expected_tree = token_tree_to_macro_stmts(&expected).unwrap().tree();\n \n             (\n                 debug_dump_ignore_spaces(expanded_tree.syntax()).trim().to_string(),\n@@ -419,7 +410,7 @@ fn test_expand_to_item_list() {\n             \",\n     );\n     let expansion = expand(&rules, \"structs!(Foo, Bar);\");\n-    let tree = token_tree_to_macro_items(&expansion).unwrap().tree().to_owned();\n+    let tree = token_tree_to_macro_items(&expansion).unwrap().tree();\n     assert_eq!(\n         tree.syntax().debug_dump().trim(),\n         r#\"\n@@ -537,7 +528,7 @@ fn test_tt_to_stmts() {\n     );\n \n     let expanded = expand(&rules, \"foo!{}\");\n-    let stmts = token_tree_to_macro_stmts(&expanded).unwrap().tree().to_owned();\n+    let stmts = token_tree_to_macro_stmts(&expanded).unwrap().tree();\n \n     assert_eq!(\n         stmts.syntax().debug_dump().trim(),"}, {"sha": "a5565de33f1aa8d3db3de1b348cf08b6c5b0117d", "filename": "crates/ra_syntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2FCargo.toml?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -10,7 +10,7 @@ repository = \"https://github.com/rust-analyzer/rust-analyzer\"\n [dependencies]\n unicode-xid = \"0.1.0\"\n itertools = \"0.8.0\"\n-rowan = \"0.5.0\"\n+rowan = \"0.5.6\"\n \n # ideally, `serde` should be enabled by `ra_lsp_server`, but we enable it here\n # to reduce number of compilations"}, {"sha": "e2de5e0e39bab1dd08e2bdfb0d991017133f76ad", "filename": "crates/ra_syntax/src/algo.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -9,8 +9,8 @@ pub use rowan::TokenAtOffset;\n pub fn find_token_at_offset(node: &SyntaxNode, offset: TextUnit) -> TokenAtOffset<SyntaxToken> {\n     match node.0.token_at_offset(offset) {\n         TokenAtOffset::None => TokenAtOffset::None,\n-        TokenAtOffset::Single(n) => TokenAtOffset::Single(n.into()),\n-        TokenAtOffset::Between(l, r) => TokenAtOffset::Between(l.into(), r.into()),\n+        TokenAtOffset::Single(n) => TokenAtOffset::Single(SyntaxToken(n)),\n+        TokenAtOffset::Between(l, r) => TokenAtOffset::Between(SyntaxToken(l), SyntaxToken(r)),\n     }\n }\n \n@@ -22,7 +22,7 @@ pub fn find_token_at_offset(node: &SyntaxNode, offset: TextUnit) -> TokenAtOffse\n pub fn ancestors_at_offset(\n     node: &SyntaxNode,\n     offset: TextUnit,\n-) -> impl Iterator<Item = &SyntaxNode> {\n+) -> impl Iterator<Item = SyntaxNode> {\n     find_token_at_offset(node, offset)\n         .map(|token| token.parent().ancestors())\n         .kmerge_by(|node1, node2| node1.range().len() < node2.range().len())\n@@ -37,7 +37,7 @@ pub fn ancestors_at_offset(\n /// ```\n ///\n /// then the shorter node will be silently preferred.\n-pub fn find_node_at_offset<N: AstNode>(syntax: &SyntaxNode, offset: TextUnit) -> Option<&N> {\n+pub fn find_node_at_offset<N: AstNode>(syntax: &SyntaxNode, offset: TextUnit) -> Option<N> {\n     ancestors_at_offset(syntax, offset).find_map(N::cast)\n }\n \n@@ -59,5 +59,5 @@ pub fn non_trivia_sibling(element: SyntaxElement, direction: Direction) -> Optio\n }\n \n pub fn find_covering_element(root: &SyntaxNode, range: TextRange) -> SyntaxElement {\n-    root.0.covering_node(range).into()\n+    SyntaxElement::new(root.0.covering_node(range))\n }"}, {"sha": "87bd15cc0c5bde966f7958629ee14f9044bcbab1", "filename": "crates/ra_syntax/src/algo/visit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Falgo%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Falgo%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo%2Fvisit.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -16,7 +16,7 @@ pub trait Visitor<'a>: Sized {\n     fn visit<N, F>(self, f: F) -> Vis<Self, N, F>\n     where\n         N: AstNode + 'a,\n-        F: FnOnce(&'a N) -> Self::Output,\n+        F: FnOnce(N) -> Self::Output,\n     {\n         Vis { inner: self, f, ph: PhantomData }\n     }\n@@ -29,7 +29,7 @@ pub trait VisitorCtx<'a>: Sized {\n     fn visit<N, F>(self, f: F) -> VisCtx<Self, N, F>\n     where\n         N: AstNode + 'a,\n-        F: FnOnce(&'a N, Self::Ctx) -> Self::Output,\n+        F: FnOnce(N, Self::Ctx) -> Self::Output,\n     {\n         VisCtx { inner: self, f, ph: PhantomData }\n     }\n@@ -74,13 +74,13 @@ impl<'a, V, N, F> Visitor<'a> for Vis<V, N, F>\n where\n     V: Visitor<'a>,\n     N: AstNode + 'a,\n-    F: FnOnce(&'a N) -> <V as Visitor<'a>>::Output,\n+    F: FnOnce(N) -> <V as Visitor<'a>>::Output,\n {\n     type Output = <V as Visitor<'a>>::Output;\n \n     fn accept(self, node: &'a SyntaxNode) -> Option<Self::Output> {\n         let Vis { inner, f, .. } = self;\n-        inner.accept(node).or_else(|| N::cast(node).map(f))\n+        inner.accept(node).or_else(|| N::cast(node.clone()).map(f))\n     }\n }\n \n@@ -95,14 +95,14 @@ impl<'a, V, N, F> VisitorCtx<'a> for VisCtx<V, N, F>\n where\n     V: VisitorCtx<'a>,\n     N: AstNode + 'a,\n-    F: FnOnce(&'a N, <V as VisitorCtx<'a>>::Ctx) -> <V as VisitorCtx<'a>>::Output,\n+    F: FnOnce(N, <V as VisitorCtx<'a>>::Ctx) -> <V as VisitorCtx<'a>>::Output,\n {\n     type Output = <V as VisitorCtx<'a>>::Output;\n     type Ctx = <V as VisitorCtx<'a>>::Ctx;\n \n     fn accept(self, node: &'a SyntaxNode) -> Result<Self::Output, Self::Ctx> {\n         let VisCtx { inner, f, .. } = self;\n-        inner.accept(node).or_else(|ctx| match N::cast(node) {\n+        inner.accept(node).or_else(|ctx| match N::cast(node.clone()) {\n             None => Err(ctx),\n             Some(node) => Ok(f(node, ctx)),\n         })"}, {"sha": "ceb603c5052f57541af17db9c74cf3cadc5e7174", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -9,7 +9,7 @@ mod expr_extensions;\n use std::marker::PhantomData;\n \n use crate::{\n-    syntax_node::{SyntaxNode, SyntaxNodeChildren, SyntaxToken, TreeArc},\n+    syntax_node::{SyntaxNode, SyntaxNodeChildren, SyntaxToken},\n     SmolStr,\n };\n \n@@ -25,51 +25,49 @@ pub use self::{\n /// conversion itself has zero runtime cost: ast and syntax nodes have exactly\n /// the same representation: a pointer to the tree root and a pointer to the\n /// node itself.\n-pub trait AstNode:\n-    rowan::TransparentNewType<Repr = rowan::SyntaxNode> + ToOwned<Owned = TreeArc<Self>>\n-{\n-    fn cast(syntax: &SyntaxNode) -> Option<&Self>\n+pub trait AstNode: Clone {\n+    fn cast(syntax: SyntaxNode) -> Option<Self>\n     where\n         Self: Sized;\n     fn syntax(&self) -> &SyntaxNode;\n }\n \n /// Like `AstNode`, but wraps tokens rather than interior nodes.\n-pub trait AstToken<'a> {\n-    fn cast(token: SyntaxToken<'a>) -> Option<Self>\n+pub trait AstToken {\n+    fn cast(token: SyntaxToken) -> Option<Self>\n     where\n         Self: Sized;\n-    fn syntax(&self) -> SyntaxToken<'a>;\n-    fn text(&self) -> &'a SmolStr {\n+    fn syntax(&self) -> &SyntaxToken;\n+    fn text(&self) -> &SmolStr {\n         self.syntax().text()\n     }\n }\n \n /// An iterator over `SyntaxNode` children of a particular AST type.\n #[derive(Debug)]\n-pub struct AstChildren<'a, N> {\n-    inner: SyntaxNodeChildren<'a>,\n+pub struct AstChildren<N> {\n+    inner: SyntaxNodeChildren,\n     ph: PhantomData<N>,\n }\n \n-impl<'a, N> AstChildren<'a, N> {\n-    fn new(parent: &'a SyntaxNode) -> Self {\n+impl<N> AstChildren<N> {\n+    fn new(parent: &SyntaxNode) -> Self {\n         AstChildren { inner: parent.children(), ph: PhantomData }\n     }\n }\n \n-impl<'a, N: AstNode + 'a> Iterator for AstChildren<'a, N> {\n-    type Item = &'a N;\n-    fn next(&mut self) -> Option<&'a N> {\n+impl<N: AstNode> Iterator for AstChildren<N> {\n+    type Item = N;\n+    fn next(&mut self) -> Option<N> {\n         self.inner.by_ref().find_map(N::cast)\n     }\n }\n \n-fn child_opt<P: AstNode, C: AstNode>(parent: &P) -> Option<&C> {\n+fn child_opt<P: AstNode + ?Sized, C: AstNode>(parent: &P) -> Option<C> {\n     children(parent).next()\n }\n \n-fn children<P: AstNode, C: AstNode>(parent: &P) -> AstChildren<C> {\n+fn children<P: AstNode + ?Sized, C: AstNode>(parent: &P) -> AstChildren<C> {\n     AstChildren::new(parent.syntax())\n }\n \n@@ -123,7 +121,7 @@ fn test_doc_comment_preserves_indents() {\n \n #[test]\n fn test_where_predicates() {\n-    fn assert_bound(text: &str, bound: Option<&TypeBound>) {\n+    fn assert_bound(text: &str, bound: Option<TypeBound>) {\n         assert_eq!(text, bound.unwrap().syntax().text().to_string());\n     }\n "}, {"sha": "ca1773908a19aeb9fec0db3624b0b9860647ef52", "filename": "crates/ra_syntax/src/ast/expr_extensions.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -8,20 +8,20 @@ use crate::{\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n-pub enum ElseBranch<'a> {\n-    Block(&'a ast::Block),\n-    IfExpr(&'a ast::IfExpr),\n+pub enum ElseBranch {\n+    Block(ast::Block),\n+    IfExpr(ast::IfExpr),\n }\n \n impl ast::IfExpr {\n-    pub fn then_branch(&self) -> Option<&ast::Block> {\n+    pub fn then_branch(&self) -> Option<ast::Block> {\n         self.blocks().nth(0)\n     }\n     pub fn else_branch(&self) -> Option<ElseBranch> {\n         let res = match self.blocks().nth(1) {\n             Some(block) => ElseBranch::Block(block),\n             None => {\n-                let elif: &ast::IfExpr = child_opt(self)?;\n+                let elif: ast::IfExpr = child_opt(self)?;\n                 ElseBranch::IfExpr(elif)\n             }\n         };\n@@ -60,7 +60,7 @@ impl ast::PrefixExpr {\n     }\n \n     pub fn op_token(&self) -> Option<SyntaxToken> {\n-        self.syntax().first_child_or_token()?.as_token()\n+        self.syntax().first_child_or_token()?.as_token().cloned()\n     }\n }\n \n@@ -132,7 +132,7 @@ pub enum BinOp {\n \n impl ast::BinExpr {\n     fn op_details(&self) -> Option<(SyntaxToken, BinOp)> {\n-        self.syntax().children_with_tokens().filter_map(|it| it.as_token()).find_map(|c| {\n+        self.syntax().children_with_tokens().filter_map(|it| it.as_token().cloned()).find_map(|c| {\n             match c.kind() {\n                 T![||] => Some((c, BinOp::BooleanOr)),\n                 T![&&] => Some((c, BinOp::BooleanAnd)),\n@@ -178,25 +178,25 @@ impl ast::BinExpr {\n         self.op_details().map(|t| t.0)\n     }\n \n-    pub fn lhs(&self) -> Option<&ast::Expr> {\n+    pub fn lhs(&self) -> Option<ast::Expr> {\n         children(self).nth(0)\n     }\n \n-    pub fn rhs(&self) -> Option<&ast::Expr> {\n+    pub fn rhs(&self) -> Option<ast::Expr> {\n         children(self).nth(1)\n     }\n \n-    pub fn sub_exprs(&self) -> (Option<&ast::Expr>, Option<&ast::Expr>) {\n+    pub fn sub_exprs(&self) -> (Option<ast::Expr>, Option<ast::Expr>) {\n         let mut children = children(self);\n         let first = children.next();\n         let second = children.next();\n         (first, second)\n     }\n }\n \n-pub enum ArrayExprKind<'a> {\n-    Repeat { initializer: Option<&'a ast::Expr>, repeat: Option<&'a ast::Expr> },\n-    ElementList(AstChildren<'a, ast::Expr>),\n+pub enum ArrayExprKind {\n+    Repeat { initializer: Option<ast::Expr>, repeat: Option<ast::Expr> },\n+    ElementList(AstChildren<ast::Expr>),\n }\n \n impl ast::ArrayExpr {\n@@ -275,12 +275,12 @@ impl ast::Literal {\n #[test]\n fn test_literal_with_attr() {\n     let parse = ast::SourceFile::parse(r#\"const _: &str = { #[attr] \"Hello\" };\"#);\n-    let lit = parse.tree.syntax().descendants().find_map(ast::Literal::cast).unwrap();\n+    let lit = parse.tree().syntax().descendants().find_map(ast::Literal::cast).unwrap();\n     assert_eq!(lit.token().text(), r#\"\"Hello\"\"#);\n }\n \n impl ast::NamedField {\n-    pub fn parent_struct_lit(&self) -> &ast::StructLit {\n+    pub fn parent_struct_lit(&self) -> ast::StructLit {\n         self.syntax().ancestors().find_map(ast::StructLit::cast).unwrap()\n     }\n }"}, {"sha": "5420f67ff07dacbe527b522df06d9b6038c5e63f", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 35, "deletions": 29, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -4,7 +4,7 @@\n use itertools::Itertools;\n \n use crate::{\n-    ast::{self, child_opt, children, AstNode},\n+    ast::{self, child_opt, children, AstNode, SyntaxNode},\n     SmolStr, SyntaxElement,\n     SyntaxKind::*,\n     SyntaxToken, T,\n@@ -13,15 +13,20 @@ use ra_parser::SyntaxKind;\n \n impl ast::Name {\n     pub fn text(&self) -> &SmolStr {\n-        let ident = self.syntax().first_child_or_token().unwrap().as_token().unwrap();\n-        ident.text()\n+        text_of_first_token(self.syntax())\n     }\n }\n \n impl ast::NameRef {\n     pub fn text(&self) -> &SmolStr {\n-        let ident = self.syntax().first_child_or_token().unwrap().as_token().unwrap();\n-        ident.text()\n+        text_of_first_token(self.syntax())\n+    }\n+}\n+\n+fn text_of_first_token(node: &SyntaxNode) -> &SmolStr {\n+    match node.0.green().children().first() {\n+        Some(rowan::GreenElement::Token(it)) => it.text(),\n+        _ => panic!(),\n     }\n }\n \n@@ -50,10 +55,10 @@ impl ast::Attr {\n         }\n     }\n \n-    pub fn as_call(&self) -> Option<(SmolStr, &ast::TokenTree)> {\n+    pub fn as_call(&self) -> Option<(SmolStr, ast::TokenTree)> {\n         let tt = self.value()?;\n         let (_bra, attr, args, _ket) = tt.syntax().children_with_tokens().collect_tuple()?;\n-        let args = ast::TokenTree::cast(args.as_node()?)?;\n+        let args = ast::TokenTree::cast(args.as_node()?.clone())?;\n         if attr.kind() == IDENT {\n             Some((attr.as_token()?.text().clone(), args))\n         } else {\n@@ -86,16 +91,16 @@ impl ast::Attr {\n     }\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum PathSegmentKind<'a> {\n-    Name(&'a ast::NameRef),\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum PathSegmentKind {\n+    Name(ast::NameRef),\n     SelfKw,\n     SuperKw,\n     CrateKw,\n }\n \n impl ast::PathSegment {\n-    pub fn parent_path(&self) -> &ast::Path {\n+    pub fn parent_path(&self) -> ast::Path {\n         self.syntax()\n             .parent()\n             .and_then(ast::Path::cast)\n@@ -125,7 +130,7 @@ impl ast::PathSegment {\n }\n \n impl ast::Path {\n-    pub fn parent_path(&self) -> Option<&ast::Path> {\n+    pub fn parent_path(&self) -> Option<ast::Path> {\n         self.syntax().parent().and_then(ast::Path::cast)\n     }\n }\n@@ -146,7 +151,7 @@ impl ast::UseTree {\n }\n \n impl ast::UseTreeList {\n-    pub fn parent_use_tree(&self) -> &ast::UseTree {\n+    pub fn parent_use_tree(&self) -> ast::UseTree {\n         self.syntax()\n             .parent()\n             .and_then(ast::UseTree::cast)\n@@ -155,21 +160,21 @@ impl ast::UseTreeList {\n }\n \n impl ast::ImplBlock {\n-    pub fn target_type(&self) -> Option<&ast::TypeRef> {\n+    pub fn target_type(&self) -> Option<ast::TypeRef> {\n         match self.target() {\n             (Some(t), None) | (_, Some(t)) => Some(t),\n             _ => None,\n         }\n     }\n \n-    pub fn target_trait(&self) -> Option<&ast::TypeRef> {\n+    pub fn target_trait(&self) -> Option<ast::TypeRef> {\n         match self.target() {\n             (Some(t), Some(_)) => Some(t),\n             _ => None,\n         }\n     }\n \n-    fn target(&self) -> (Option<&ast::TypeRef>, Option<&ast::TypeRef>) {\n+    fn target(&self) -> (Option<ast::TypeRef>, Option<ast::TypeRef>) {\n         let mut types = children(self);\n         let first = types.next();\n         let second = types.next();\n@@ -182,13 +187,13 @@ impl ast::ImplBlock {\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n-pub enum StructKind<'a> {\n-    Tuple(&'a ast::PosFieldDefList),\n-    Named(&'a ast::NamedFieldDefList),\n+pub enum StructKind {\n+    Tuple(ast::PosFieldDefList),\n+    Named(ast::NamedFieldDefList),\n     Unit,\n }\n \n-impl StructKind<'_> {\n+impl StructKind {\n     fn from_node<N: AstNode>(node: &N) -> StructKind {\n         if let Some(nfdl) = child_opt::<_, ast::NamedFieldDefList>(node) {\n             StructKind::Named(nfdl)\n@@ -218,7 +223,7 @@ impl ast::StructDef {\n }\n \n impl ast::EnumVariant {\n-    pub fn parent_enum(&self) -> &ast::EnumDef {\n+    pub fn parent_enum(&self) -> ast::EnumDef {\n         self.syntax()\n             .parent()\n             .and_then(|it| it.parent())\n@@ -231,10 +236,10 @@ impl ast::EnumVariant {\n }\n \n impl ast::FnDef {\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken<'_>> {\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> {\n         self.syntax()\n             .last_child_or_token()\n-            .and_then(|it| it.as_token())\n+            .and_then(|it| it.as_token().cloned())\n             .filter(|it| it.kind() == T![;])\n     }\n }\n@@ -258,9 +263,9 @@ impl ast::ExprStmt {\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n-pub enum FieldKind<'a> {\n-    Name(&'a ast::NameRef),\n-    Index(SyntaxToken<'a>),\n+pub enum FieldKind {\n+    Name(ast::NameRef),\n+    Index(SyntaxToken),\n }\n \n impl ast::FieldExpr {\n@@ -271,6 +276,7 @@ impl ast::FieldExpr {\n             .find(|c| c.kind() == SyntaxKind::INT_NUMBER || c.kind() == SyntaxKind::FLOAT_NUMBER)\n             .as_ref()\n             .and_then(SyntaxElement::as_token)\n+            .cloned()\n     }\n \n     pub fn field_access(&self) -> Option<FieldKind> {\n@@ -326,7 +332,7 @@ impl ast::SelfParam {\n     pub fn self_kw_token(&self) -> SyntaxToken {\n         self.syntax()\n             .children_with_tokens()\n-            .filter_map(|it| it.as_token())\n+            .filter_map(|it| it.as_token().cloned())\n             .find(|it| it.kind() == T![self])\n             .expect(\"invalid tree: self param must have self\")\n     }\n@@ -355,7 +361,7 @@ impl ast::LifetimeParam {\n     pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n         self.syntax()\n             .children_with_tokens()\n-            .filter_map(|it| it.as_token())\n+            .filter_map(|it| it.as_token().cloned())\n             .find(|it| it.kind() == LIFETIME)\n     }\n }\n@@ -364,7 +370,7 @@ impl ast::WherePred {\n     pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n         self.syntax()\n             .children_with_tokens()\n-            .filter_map(|it| it.as_token())\n+            .filter_map(|it| it.as_token().cloned())\n             .find(|it| it.kind() == LIFETIME)\n     }\n }"}, {"sha": "a1f320257892ccebe49acc329977c0077c5f7a59", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 832, "deletions": 1888, "changes": 2720, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f"}, {"sha": "f3365c5602ef3d8b28f5829bdb33cbeac8012a11", "filename": "crates/ra_syntax/src/ast/generated.rs.tera", "status": "modified", "additions": 15, "deletions": 36, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -11,94 +11,73 @@ the below applies to the result of this template\n \n #![cfg_attr(rustfmt, rustfmt_skip)]\n \n-use rowan::TransparentNewType;\n-\n use crate::{\n     SyntaxNode, SyntaxKind::*,\n-    syntax_node::{TreeArc},\n     ast::{self, AstNode},\n };\n {% for node, methods in ast %}\n // {{ node }}\n \n {%- if methods.enum %}\n-#[derive(Debug, PartialEq, Eq, Hash)]\n-#[repr(transparent)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct {{ node }} {\n     pub(crate) syntax: SyntaxNode,\n }\n-unsafe impl TransparentNewType for {{ node }} {\n-    type Repr = rowan::SyntaxNode;\n-}\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum {{ node }}Kind<'a> {\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum {{ node }}Kind {\n {%- for kind in methods.enum %}\n-    {{ kind }}(&'a {{ kind }}),\n+    {{ kind }}({{ kind }}),\n {%- endfor %}\n }\n \n {%- for kind in methods.enum %}\n-impl<'a> From<&'a {{ kind }}> for &'a {{ node }} {\n-    fn from(n: &'a {{ kind }}) -> &'a {{ node }} {\n-        {{ node }}::cast(&n.syntax).unwrap()\n+impl From<{{ kind }}> for {{ node }} {\n+    fn from(n: {{ kind }}) -> {{ node }} {\n+        {{ node }}::cast(n.syntax).unwrap()\n     }\n }\n {%- endfor %}\n \n \n impl AstNode for {{ node }} {\n-    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n         match syntax.kind() {\n             {%- for kind in methods.enum %}\n             | {{ kind | SCREAM }}\n-            {%- endfor %} => Some({{ node }}::from_repr(syntax.into_repr())),\n+            {%- endfor %} => Some({{ node }} { syntax }),\n             _ => None,\n         }\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n-impl ToOwned for {{ node }} {\n-    type Owned = TreeArc<{{ node }}>;\n-    fn to_owned(&self) -> TreeArc<{{ node }}> { TreeArc::cast(self.syntax.to_owned()) }\n-}\n-\n impl {{ node }} {\n     pub fn kind(&self) -> {{ node }}Kind {\n         match self.syntax.kind() {\n             {%- for kind in methods.enum %}\n-            {{ kind | SCREAM }} => {{ node }}Kind::{{ kind }}({{ kind }}::cast(&self.syntax).unwrap()),\n+            {{ kind | SCREAM }} => {{ node }}Kind::{{ kind }}({{ kind }}::cast(self.syntax.clone()).unwrap()),\n             {%- endfor %}\n             _ => unreachable!(),\n         }\n     }\n }\n {% else %}\n-#[derive(Debug, PartialEq, Eq, Hash)]\n-#[repr(transparent)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct {{ node }} {\n     pub(crate) syntax: SyntaxNode,\n }\n-unsafe impl TransparentNewType for {{ node }} {\n-    type Repr = rowan::SyntaxNode;\n-}\n \n impl AstNode for {{ node }} {\n-    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n         match syntax.kind() {\n-            {{ node | SCREAM }} => Some({{ node }}::from_repr(syntax.into_repr())),\n+            {{ node | SCREAM }} => Some({{ node }} { syntax }),\n             _ => None,\n         }\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n-impl ToOwned for {{ node }} {\n-    type Owned = TreeArc<{{ node }}>;\n-    fn to_owned(&self) -> TreeArc<{{ node }}> { TreeArc::cast(self.syntax.to_owned()) }\n-}\n-\n {% endif %}\n {% if methods.traits -%}\n \n@@ -113,7 +92,7 @@ impl {{ node }} {\n {%- for m in methods.collections -%}\n {%- set method_name = m.0 -%}\n {%- set ChildName = m.1 %}\n-    pub fn {{ method_name }}(&self) -> impl Iterator<Item = &{{ ChildName }}> {\n+    pub fn {{ method_name }}(&self) -> impl Iterator<Item = {{ ChildName }}> {\n         super::children(self)\n     }\n {% endfor -%}\n@@ -129,7 +108,7 @@ impl {{ node }} {\n {%- set method_name = m.0 -%}\n {%- set ChildName = m.1 %}\n {%- endif %}\n-    pub fn {{ method_name }}(&self) -> Option<&{{ ChildName }}> {\n+    pub fn {{ method_name }}(&self) -> Option<{{ ChildName }}> {\n         super::child_opt(self)\n     }\n {% endfor -%}"}, {"sha": "87cca325d3fc9dec956abce06e6908167c8d8203", "filename": "crates/ra_syntax/src/ast/tokens.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -6,23 +6,23 @@ use crate::{\n     SyntaxToken,\n };\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct Comment<'a>(SyntaxToken<'a>);\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Comment(SyntaxToken);\n \n-impl<'a> AstToken<'a> for Comment<'a> {\n-    fn cast(token: SyntaxToken<'a>) -> Option<Self> {\n+impl AstToken for Comment {\n+    fn cast(token: SyntaxToken) -> Option<Self> {\n         if token.kind() == COMMENT {\n             Some(Comment(token))\n         } else {\n             None\n         }\n     }\n-    fn syntax(&self) -> SyntaxToken<'a> {\n-        self.0\n+    fn syntax(&self) -> &SyntaxToken {\n+        &self.0\n     }\n }\n \n-impl<'a> Comment<'a> {\n+impl Comment {\n     pub fn kind(&self) -> CommentKind {\n         kind_by_prefix(self.text())\n     }\n@@ -90,22 +90,22 @@ fn prefix_by_kind(kind: CommentKind) -> &'static str {\n     unreachable!()\n }\n \n-pub struct Whitespace<'a>(SyntaxToken<'a>);\n+pub struct Whitespace(SyntaxToken);\n \n-impl<'a> AstToken<'a> for Whitespace<'a> {\n-    fn cast(token: SyntaxToken<'a>) -> Option<Self> {\n+impl AstToken for Whitespace {\n+    fn cast(token: SyntaxToken) -> Option<Self> {\n         if token.kind() == WHITESPACE {\n             Some(Whitespace(token))\n         } else {\n             None\n         }\n     }\n-    fn syntax(&self) -> SyntaxToken<'a> {\n-        self.0\n+    fn syntax(&self) -> &SyntaxToken {\n+        &self.0\n     }\n }\n \n-impl<'a> Whitespace<'a> {\n+impl Whitespace {\n     pub fn spans_multiple_lines(&self) -> bool {\n         let text = self.text();\n         text.find('\\n').map_or(false, |idx| text[idx + 1..].contains('\\n'))"}, {"sha": "ecbd2d4271db9e26c5648e74ab2d49a54ee77eb6", "filename": "crates/ra_syntax/src/ast/traits.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -10,37 +10,37 @@ use crate::{\n };\n \n pub trait TypeAscriptionOwner: AstNode {\n-    fn ascribed_type(&self) -> Option<&ast::TypeRef> {\n+    fn ascribed_type(&self) -> Option<ast::TypeRef> {\n         child_opt(self)\n     }\n }\n \n pub trait NameOwner: AstNode {\n-    fn name(&self) -> Option<&ast::Name> {\n+    fn name(&self) -> Option<ast::Name> {\n         child_opt(self)\n     }\n }\n \n pub trait VisibilityOwner: AstNode {\n-    fn visibility(&self) -> Option<&ast::Visibility> {\n+    fn visibility(&self) -> Option<ast::Visibility> {\n         child_opt(self)\n     }\n }\n \n pub trait LoopBodyOwner: AstNode {\n-    fn loop_body(&self) -> Option<&ast::Block> {\n+    fn loop_body(&self) -> Option<ast::Block> {\n         child_opt(self)\n     }\n }\n \n pub trait TryBlockBodyOwner: AstNode {\n-    fn try_body(&self) -> Option<&ast::Block> {\n+    fn try_body(&self) -> Option<ast::Block> {\n         child_opt(self)\n     }\n }\n \n pub trait ArgListOwner: AstNode {\n-    fn arg_list(&self) -> Option<&ast::ArgList> {\n+    fn arg_list(&self) -> Option<ast::ArgList> {\n         child_opt(self)\n     }\n }\n@@ -51,10 +51,10 @@ pub trait FnDefOwner: AstNode {\n     }\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum ItemOrMacro<'a> {\n-    Item(&'a ast::ModuleItem),\n-    Macro(&'a ast::MacroCall),\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum ItemOrMacro {\n+    Item(ast::ModuleItem),\n+    Macro(ast::MacroCall),\n }\n \n pub trait ModuleItemOwner: AstNode {\n@@ -67,14 +67,14 @@ pub trait ModuleItemOwner: AstNode {\n }\n \n #[derive(Debug)]\n-pub struct ItemOrMacroIter<'a>(SyntaxNodeChildren<'a>);\n+pub struct ItemOrMacroIter(SyntaxNodeChildren);\n \n-impl<'a> Iterator for ItemOrMacroIter<'a> {\n-    type Item = ItemOrMacro<'a>;\n-    fn next(&mut self) -> Option<ItemOrMacro<'a>> {\n+impl Iterator for ItemOrMacroIter {\n+    type Item = ItemOrMacro;\n+    fn next(&mut self) -> Option<ItemOrMacro> {\n         loop {\n             let n = self.0.next()?;\n-            if let Some(item) = ast::ModuleItem::cast(n) {\n+            if let Some(item) = ast::ModuleItem::cast(n.clone()) {\n                 return Some(ItemOrMacro::Item(item));\n             }\n             if let Some(call) = ast::MacroCall::cast(n) {\n@@ -85,17 +85,17 @@ impl<'a> Iterator for ItemOrMacroIter<'a> {\n }\n \n pub trait TypeParamsOwner: AstNode {\n-    fn type_param_list(&self) -> Option<&ast::TypeParamList> {\n+    fn type_param_list(&self) -> Option<ast::TypeParamList> {\n         child_opt(self)\n     }\n \n-    fn where_clause(&self) -> Option<&ast::WhereClause> {\n+    fn where_clause(&self) -> Option<ast::WhereClause> {\n         child_opt(self)\n     }\n }\n \n pub trait TypeBoundsOwner: AstNode {\n-    fn type_bound_list(&self) -> Option<&ast::TypeBoundList> {\n+    fn type_bound_list(&self) -> Option<ast::TypeBoundList> {\n         child_opt(self)\n     }\n }\n@@ -148,19 +148,19 @@ pub trait DocCommentsOwner: AstNode {\n     }\n }\n \n-pub struct CommentIter<'a> {\n-    iter: SyntaxElementChildren<'a>,\n+pub struct CommentIter {\n+    iter: SyntaxElementChildren,\n }\n \n-impl<'a> Iterator for CommentIter<'a> {\n-    type Item = ast::Comment<'a>;\n-    fn next(&mut self) -> Option<ast::Comment<'a>> {\n-        self.iter.by_ref().find_map(|el| el.as_token().and_then(ast::Comment::cast))\n+impl Iterator for CommentIter {\n+    type Item = ast::Comment;\n+    fn next(&mut self) -> Option<ast::Comment> {\n+        self.iter.by_ref().find_map(|el| el.as_token().cloned().and_then(ast::Comment::cast))\n     }\n }\n \n pub trait DefaultTypeParamOwner: AstNode {\n-    fn default_type(&self) -> Option<&ast::PathType> {\n+    fn default_type(&self) -> Option<ast::PathType> {\n         child_opt(self)\n     }\n }"}, {"sha": "716925b2f052ea76a46ab10b5993145fef86160e", "filename": "crates/ra_syntax/src/fuzz.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Ffuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Ffuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Ffuzz.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -9,7 +9,7 @@ fn check_file_invariants(file: &SourceFile) {\n \n pub fn check_parser(text: &str) {\n     let file = SourceFile::parse(text);\n-    check_file_invariants(&file.tree);\n+    check_file_invariants(&file.tree());\n }\n \n #[derive(Debug, Clone)]\n@@ -45,16 +45,16 @@ impl CheckReparse {\n     pub fn run(&self) {\n         let parse = SourceFile::parse(&self.text);\n         let new_parse = parse.reparse(&self.edit);\n-        check_file_invariants(&new_parse.tree);\n-        assert_eq!(&new_parse.tree.syntax().text().to_string(), &self.edited_text);\n+        check_file_invariants(&new_parse.tree());\n+        assert_eq!(&new_parse.tree().syntax().text().to_string(), &self.edited_text);\n         let full_reparse = SourceFile::parse(&self.edited_text);\n         for (a, b) in\n-            new_parse.tree.syntax().descendants().zip(full_reparse.tree.syntax().descendants())\n+            new_parse.tree().syntax().descendants().zip(full_reparse.tree().syntax().descendants())\n         {\n             if (a.kind(), a.range()) != (b.kind(), b.range()) {\n-                eprint!(\"original:\\n{}\", parse.tree.syntax().debug_dump());\n-                eprint!(\"reparsed:\\n{}\", new_parse.tree.syntax().debug_dump());\n-                eprint!(\"full reparse:\\n{}\", full_reparse.tree.syntax().debug_dump());\n+                eprint!(\"original:\\n{}\", parse.tree().syntax().debug_dump());\n+                eprint!(\"reparsed:\\n{}\", new_parse.tree().syntax().debug_dump());\n+                eprint!(\"full reparse:\\n{}\", full_reparse.tree().syntax().debug_dump());\n                 assert_eq!(\n                     format!(\"{:?}\", a),\n                     format!(\"{:?}\", b),"}, {"sha": "2dca4e3e857d125ecd469ebc338053ff76829afa", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 58, "deletions": 64, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -31,7 +31,7 @@ pub mod ast;\n #[doc(hidden)]\n pub mod fuzz;\n \n-use std::{fmt::Write, sync::Arc};\n+use std::{fmt::Write, marker::PhantomData, sync::Arc};\n \n use ra_text_edit::AtomTextEdit;\n \n@@ -43,8 +43,8 @@ pub use crate::{\n     ptr::{AstPtr, SyntaxNodePtr},\n     syntax_error::{Location, SyntaxError, SyntaxErrorKind},\n     syntax_node::{\n-        Direction, InsertPosition, SyntaxElement, SyntaxNode, SyntaxNodeWrapper, SyntaxToken,\n-        SyntaxTreeBuilder, TreeArc, WalkEvent,\n+        Direction, InsertPosition, SyntaxElement, SyntaxNode, SyntaxToken, SyntaxTreeBuilder,\n+        WalkEvent,\n     },\n     syntax_text::SyntaxText,\n };\n@@ -58,48 +58,63 @@ pub use rowan::{SmolStr, TextRange, TextUnit};\n /// Note that we always produce a syntax tree, even for completely invalid\n /// files.\n #[derive(Debug, PartialEq, Eq)]\n-pub struct Parse<T: SyntaxNodeWrapper> {\n-    tree: TreeArc<T>,\n+pub struct Parse<T> {\n+    green: GreenNode,\n     errors: Arc<Vec<SyntaxError>>,\n+    _ty: PhantomData<fn() -> T>,\n }\n \n-impl<T: SyntaxNodeWrapper> Clone for Parse<T> {\n+impl<T> Clone for Parse<T> {\n     fn clone(&self) -> Parse<T> {\n-        Parse { tree: self.tree.clone(), errors: self.errors.clone() }\n+        Parse { green: self.green.clone(), errors: self.errors.clone(), _ty: PhantomData }\n     }\n }\n \n-impl<T: SyntaxNodeWrapper> Parse<T> {\n-    fn new(tree: TreeArc<T>, errors: Vec<SyntaxError>) -> Parse<T> {\n-        Parse { tree, errors: Arc::new(errors) }\n+impl<T> Parse<T> {\n+    fn new(green: GreenNode, errors: Vec<SyntaxError>) -> Parse<T> {\n+        Parse { green, errors: Arc::new(errors), _ty: PhantomData }\n     }\n \n-    pub fn tree(&self) -> &T {\n-        &*self.tree\n+    pub fn syntax_node(&self) -> SyntaxNode {\n+        SyntaxNode::new(self.green.clone())\n+    }\n+}\n+\n+impl<T: AstNode> Parse<T> {\n+    pub fn to_syntax(self) -> Parse<SyntaxNode> {\n+        Parse { green: self.green, errors: self.errors, _ty: PhantomData }\n+    }\n+\n+    pub fn tree(&self) -> T {\n+        T::cast(self.syntax_node()).unwrap()\n     }\n \n     pub fn errors(&self) -> &[SyntaxError] {\n         &*self.errors\n     }\n \n-    pub fn ok(self) -> Result<TreeArc<T>, Arc<Vec<SyntaxError>>> {\n+    pub fn ok(self) -> Result<T, Arc<Vec<SyntaxError>>> {\n         if self.errors.is_empty() {\n-            Ok(self.tree)\n+            Ok(self.tree())\n         } else {\n             Err(self.errors)\n         }\n     }\n }\n \n-impl<T: AstNode> Parse<T> {\n-    pub fn to_syntax(this: Self) -> Parse<SyntaxNode> {\n-        Parse { tree: this.tree().syntax().to_owned(), errors: this.errors }\n+impl Parse<SyntaxNode> {\n+    pub fn cast<N: AstNode>(self) -> Option<Parse<N>> {\n+        if N::cast(self.syntax_node()).is_some() {\n+            Some(Parse { green: self.green, errors: self.errors, _ty: PhantomData })\n+        } else {\n+            None\n+        }\n     }\n }\n \n impl Parse<SourceFile> {\n     pub fn debug_dump(&self) -> String {\n-        let mut buf = self.tree.syntax().debug_dump();\n+        let mut buf = self.tree().syntax().debug_dump();\n         for err in self.errors.iter() {\n             writeln!(buf, \"error {:?}: {}\", err.location(), err.kind()).unwrap();\n         }\n@@ -112,45 +127,38 @@ impl Parse<SourceFile> {\n \n     fn incremental_reparse(&self, edit: &AtomTextEdit) -> Option<Parse<SourceFile>> {\n         // FIXME: validation errors are not handled here\n-        parsing::incremental_reparse(self.tree.syntax(), edit, self.errors.to_vec()).map(\n+        parsing::incremental_reparse(self.tree().syntax(), edit, self.errors.to_vec()).map(\n             |(green_node, errors, _reparsed_range)| Parse {\n-                tree: SourceFile::new(green_node),\n+                green: green_node,\n                 errors: Arc::new(errors),\n+                _ty: PhantomData,\n             },\n         )\n     }\n \n     fn full_reparse(&self, edit: &AtomTextEdit) -> Parse<SourceFile> {\n-        let text = edit.apply(self.tree.syntax().text().to_string());\n+        let text = edit.apply(self.tree().syntax().text().to_string());\n         SourceFile::parse(&text)\n     }\n }\n \n-impl Parse<SyntaxNode> {\n-    pub fn cast<T: AstNode>(self) -> Option<Parse<T>> {\n-        let node = T::cast(&self.tree)?;\n-        Some(Parse { tree: node.to_owned(), errors: self.errors })\n-    }\n-}\n-\n /// `SourceFile` represents a parse tree for a single Rust file.\n pub use crate::ast::SourceFile;\n \n impl SourceFile {\n-    fn new(green: GreenNode) -> TreeArc<SourceFile> {\n+    fn new(green: GreenNode) -> SourceFile {\n         let root = SyntaxNode::new(green);\n         if cfg!(debug_assertions) {\n             validation::validate_block_structure(&root);\n         }\n         assert_eq!(root.kind(), SyntaxKind::SOURCE_FILE);\n-        TreeArc::cast(root)\n+        SourceFile::cast(root).unwrap()\n     }\n \n     pub fn parse(text: &str) -> Parse<SourceFile> {\n         let (green, mut errors) = parsing::parse_text(text);\n-        let tree = SourceFile::new(green);\n-        errors.extend(validation::validate(&tree));\n-        Parse { tree, errors: Arc::new(errors) }\n+        errors.extend(validation::validate(&SourceFile::new(green.clone())));\n+        Parse { green, errors: Arc::new(errors), _ty: PhantomData }\n     }\n }\n \n@@ -170,46 +178,41 @@ fn api_walkthrough() {\n     // The `parse` method returns a `Parse` -- a pair of syntax tree and a list\n     // of errors. That is, syntax tree is constructed even in presence of errors.\n     let parse = SourceFile::parse(source_code);\n-    assert!(parse.errors.is_empty());\n+    assert!(parse.errors().is_empty());\n \n-    // Due to the way ownership is set up, owned syntax Nodes always live behind\n-    // a `TreeArc` smart pointer. `TreeArc` is roughly an `std::sync::Arc` which\n-    // points to the whole file instead of an individual node.\n-    let file: TreeArc<SourceFile> = parse.tree;\n+    // The `tree` method returns an owned syntax node of type `SourceFile`.\n+    // Owned nodes are cheap: inside, they are `Rc` handles to the underling data.\n+    let file: SourceFile = parse.tree();\n \n-    // `SourceFile` is the root of the syntax tree. We can iterate file's items:\n+    // `SourceFile` is the root of the syntax tree. We can iterate file's items.\n+    // Let's fetch the `foo` function.\n     let mut func = None;\n     for item in file.items() {\n         match item.kind() {\n             ast::ModuleItemKind::FnDef(f) => func = Some(f),\n             _ => unreachable!(),\n         }\n     }\n-    // The returned items are always references.\n-    let func: &ast::FnDef = func.unwrap();\n-\n-    // All nodes implement `ToOwned` trait, with `Owned = TreeArc<Self>`.\n-    // `to_owned` is a cheap operation: atomic increment.\n-    let _owned_func: TreeArc<ast::FnDef> = func.to_owned();\n+    let func: ast::FnDef = func.unwrap();\n \n     // Each AST node has a bunch of getters for children. All getters return\n     // `Option`s though, to account for incomplete code. Some getters are common\n     // for several kinds of node. In this case, a trait like `ast::NameOwner`\n     // usually exists. By convention, all ast types should be used with `ast::`\n     // qualifier.\n-    let name: Option<&ast::Name> = func.name();\n+    let name: Option<ast::Name> = func.name();\n     let name = name.unwrap();\n     assert_eq!(name.text(), \"foo\");\n \n     // Let's get the `1 + 1` expression!\n-    let block: &ast::Block = func.body().unwrap();\n-    let expr: &ast::Expr = block.expr().unwrap();\n+    let block: ast::Block = func.body().unwrap();\n+    let expr: ast::Expr = block.expr().unwrap();\n \n     // \"Enum\"-like nodes are represented using the \"kind\" pattern. It allows us\n     // to match exhaustively against all flavors of nodes, while maintaining\n     // internal representation flexibility. The drawback is that one can't write\n     // nested matches as one pattern.\n-    let bin_expr: &ast::BinExpr = match expr.kind() {\n+    let bin_expr: ast::BinExpr = match expr.kind() {\n         ast::ExprKind::BinExpr(e) => e,\n         _ => unreachable!(),\n     };\n@@ -219,23 +222,14 @@ fn api_walkthrough() {\n     let expr_syntax: &SyntaxNode = expr.syntax();\n \n     // Note how `expr` and `bin_expr` are in fact the same node underneath:\n-    assert!(std::ptr::eq(expr_syntax, bin_expr.syntax()));\n+    assert!(expr_syntax == bin_expr.syntax());\n \n     // To go from CST to AST, `AstNode::cast` function is used:\n-    let expr = match ast::Expr::cast(expr_syntax) {\n+    let _expr: ast::Expr = match ast::Expr::cast(expr_syntax.clone()) {\n         Some(e) => e,\n         None => unreachable!(),\n     };\n \n-    // Note how expr is also a reference!\n-    let expr: &ast::Expr = expr;\n-\n-    // This is possible because the underlying representation is the same:\n-    assert_eq!(\n-        expr as *const ast::Expr as *const u8,\n-        expr_syntax as *const SyntaxNode as *const u8\n-    );\n-\n     // The two properties each syntax node has is a `SyntaxKind`:\n     assert_eq!(expr_syntax.kind(), SyntaxKind::BIN_EXPR);\n \n@@ -248,7 +242,7 @@ fn api_walkthrough() {\n     assert_eq!(text.to_string(), \"1 + 1\");\n \n     // There's a bunch of traversal methods on `SyntaxNode`:\n-    assert_eq!(expr_syntax.parent(), Some(block.syntax()));\n+    assert_eq!(expr_syntax.parent().as_ref(), Some(block.syntax()));\n     assert_eq!(block.syntax().first_child_or_token().map(|it| it.kind()), Some(T!['{']));\n     assert_eq!(\n         expr_syntax.next_sibling_or_token().map(|it| it.kind()),\n@@ -257,7 +251,7 @@ fn api_walkthrough() {\n \n     // As well as some iterator helpers:\n     let f = expr_syntax.ancestors().find_map(ast::FnDef::cast);\n-    assert_eq!(f, Some(&*func));\n+    assert_eq!(f, Some(func));\n     assert!(expr_syntax.siblings_with_tokens(Direction::Next).any(|it| it.kind() == T!['}']));\n     assert_eq!(\n         expr_syntax.descendants_with_tokens().count(),\n@@ -272,7 +266,7 @@ fn api_walkthrough() {\n     for event in expr_syntax.preorder_with_tokens() {\n         match event {\n             WalkEvent::Enter(node) => {\n-                let text = match node {\n+                let text = match &node {\n                     SyntaxElement::Node(it) => it.text().to_string(),\n                     SyntaxElement::Token(it) => it.text().to_string(),\n                 };\n@@ -319,7 +313,7 @@ fn api_walkthrough() {\n     let mut exprs_visit = Vec::new();\n     for node in file.syntax().descendants() {\n         if let Some(result) =\n-            visitor().visit::<ast::Expr, _>(|expr| expr.syntax().text().to_string()).accept(node)\n+            visitor().visit::<ast::Expr, _>(|expr| expr.syntax().text().to_string()).accept(&node)\n         {\n             exprs_visit.push(result);\n         }"}, {"sha": "b4ad9e0199aea249df1d8aa6fc33a18a1c83564e", "filename": "crates/ra_syntax/src/parsing/reparsing.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -41,7 +41,7 @@ fn reparse_token<'node>(\n     root: &'node SyntaxNode,\n     edit: &AtomTextEdit,\n ) -> Option<(GreenNode, TextRange)> {\n-    let token = algo::find_covering_element(root, edit.delete).as_token()?;\n+    let token = algo::find_covering_element(root, edit.delete).as_token()?.clone();\n     match token.kind() {\n         WHITESPACE | COMMENT | IDENT | STRING | RAW_STRING => {\n             if token.kind() == WHITESPACE || token.kind() == COMMENT {\n@@ -51,7 +51,7 @@ fn reparse_token<'node>(\n                 }\n             }\n \n-            let text = get_text_after_edit(token.into(), &edit);\n+            let text = get_text_after_edit(token.clone().into(), &edit);\n             let lex_tokens = tokenize(&text);\n             let lex_token = match lex_tokens[..] {\n                 [lex_token] if lex_token.kind == token.kind() => lex_token,\n@@ -81,7 +81,7 @@ fn reparse_block<'node>(\n     edit: &AtomTextEdit,\n ) -> Option<(GreenNode, Vec<SyntaxError>, TextRange)> {\n     let (node, reparser) = find_reparsable_node(root, edit.delete)?;\n-    let text = get_text_after_edit(node.into(), &edit);\n+    let text = get_text_after_edit(node.clone().into(), &edit);\n     let tokens = tokenize(&text);\n     if !is_balanced(&tokens) {\n         return None;\n@@ -109,7 +109,7 @@ fn is_contextual_kw(text: &str) -> bool {\n     }\n }\n \n-fn find_reparsable_node(node: &SyntaxNode, range: TextRange) -> Option<(&SyntaxNode, Reparser)> {\n+fn find_reparsable_node(node: &SyntaxNode, range: TextRange) -> Option<(SyntaxNode, Reparser)> {\n     let node = algo::find_covering_element(node, range);\n     let mut ancestors = match node {\n         SyntaxElement::Token(it) => it.parent().ancestors(),\n@@ -167,8 +167,6 @@ fn merge_errors(\n \n #[cfg(test)]\n mod tests {\n-    use std::sync::Arc;\n-\n     use test_utils::{assert_eq_text, extract_range};\n \n     use super::*;\n@@ -180,18 +178,18 @@ mod tests {\n         let after = edit.apply(before.clone());\n \n         let fully_reparsed = SourceFile::parse(&after);\n-        let incrementally_reparsed = {\n+        let incrementally_reparsed: Parse<SourceFile> = {\n             let f = SourceFile::parse(&before);\n             let edit = AtomTextEdit { delete: range, insert: replace_with.to_string() };\n             let (green, new_errors, range) =\n-                incremental_reparse(f.tree.syntax(), &edit, f.errors.to_vec()).unwrap();\n+                incremental_reparse(f.tree().syntax(), &edit, f.errors.to_vec()).unwrap();\n             assert_eq!(range.len(), reparsed_len.into(), \"reparsed fragment has wrong length\");\n-            Parse { tree: SourceFile::new(green), errors: Arc::new(new_errors) }\n+            Parse::new(green, new_errors)\n         };\n \n         assert_eq_text!(\n-            &fully_reparsed.tree.syntax().debug_dump(),\n-            &incrementally_reparsed.tree.syntax().debug_dump(),\n+            &fully_reparsed.tree().syntax().debug_dump(),\n+            &incrementally_reparsed.tree().syntax().debug_dump(),\n         );\n     }\n "}, {"sha": "01625607547236ab0ce6a2d19bb83906b1bedd10", "filename": "crates/ra_syntax/src/ptr.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fptr.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -1,6 +1,7 @@\n-use crate::{AstNode, SyntaxKind, SyntaxNode, TextRange};\n use std::{iter::successors, marker::PhantomData};\n \n+use crate::{AstNode, SyntaxKind, SyntaxNode, TextRange};\n+\n /// A pointer to a syntax node inside a file. It can be used to remember a\n /// specific node across reparses of the same file.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -14,9 +15,9 @@ impl SyntaxNodePtr {\n         SyntaxNodePtr { range: node.range(), kind: node.kind() }\n     }\n \n-    pub fn to_node(self, root: &SyntaxNode) -> &SyntaxNode {\n+    pub fn to_node(self, root: &SyntaxNode) -> SyntaxNode {\n         assert!(root.parent().is_none());\n-        successors(Some(root), |&node| {\n+        successors(Some(root.clone()), |node| {\n             node.children().find(|it| self.range.is_subrange(&it.range()))\n         })\n         .find(|it| it.range() == self.range && it.kind() == self.kind)\n@@ -51,7 +52,7 @@ impl<N: AstNode> AstPtr<N> {\n         AstPtr { raw: SyntaxNodePtr::new(node.syntax()), _ty: PhantomData }\n     }\n \n-    pub fn to_node(self, root: &SyntaxNode) -> &N {\n+    pub fn to_node(self, root: &SyntaxNode) -> N {\n         let syntax_node = self.raw.to_node(root);\n         N::cast(syntax_node).unwrap()\n     }\n@@ -75,5 +76,5 @@ fn test_local_syntax_ptr() {\n     let field = file.syntax().descendants().find_map(ast::NamedFieldDef::cast).unwrap();\n     let ptr = SyntaxNodePtr::new(field.syntax());\n     let field_syntax = ptr.to_node(file.syntax());\n-    assert_eq!(field.syntax(), &*field_syntax);\n+    assert_eq!(field.syntax(), &field_syntax);\n }"}, {"sha": "cf680e66aabe729d5ceddcce6358c30a4ddb21f4", "filename": "crates/ra_syntax/src/syntax_node.rs", "status": "modified", "additions": 120, "deletions": 211, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -7,14 +7,13 @@\n //! modules just wraps its API.\n \n use std::{\n-    borrow::Borrow,\n     fmt::{self, Write},\n     iter::successors,\n     ops::RangeInclusive,\n };\n \n use ra_parser::ParseError;\n-use rowan::{GreenNodeBuilder, TransparentNewType};\n+use rowan::GreenNodeBuilder;\n \n use crate::{\n     syntax_error::{SyntaxError, SyntaxErrorKind},\n@@ -33,86 +32,8 @@ pub enum InsertPosition<T> {\n     After(T),\n }\n \n-/// Marker trait for CST and AST nodes\n-pub trait SyntaxNodeWrapper: TransparentNewType<Repr = rowan::SyntaxNode> {}\n-impl<T: TransparentNewType<Repr = rowan::SyntaxNode>> SyntaxNodeWrapper for T {}\n-\n-/// An owning smart pointer for CST or AST node.\n-#[derive(PartialEq, Eq, Hash)]\n-pub struct TreeArc<T: SyntaxNodeWrapper>(pub(crate) rowan::TreeArc<T>);\n-\n-impl<T: SyntaxNodeWrapper> Borrow<T> for TreeArc<T> {\n-    fn borrow(&self) -> &T {\n-        &*self\n-    }\n-}\n-\n-impl<T> TreeArc<T>\n-where\n-    T: SyntaxNodeWrapper,\n-{\n-    pub(crate) fn cast<U>(this: TreeArc<T>) -> TreeArc<U>\n-    where\n-        U: SyntaxNodeWrapper,\n-    {\n-        TreeArc(rowan::TreeArc::cast(this.0))\n-    }\n-}\n-\n-impl<T> std::ops::Deref for TreeArc<T>\n-where\n-    T: SyntaxNodeWrapper,\n-{\n-    type Target = T;\n-    fn deref(&self) -> &T {\n-        self.0.deref()\n-    }\n-}\n-\n-impl<T> PartialEq<T> for TreeArc<T>\n-where\n-    T: SyntaxNodeWrapper,\n-    T: PartialEq<T>,\n-{\n-    fn eq(&self, other: &T) -> bool {\n-        let t: &T = self;\n-        t == other\n-    }\n-}\n-\n-impl<T> Clone for TreeArc<T>\n-where\n-    T: SyntaxNodeWrapper,\n-{\n-    fn clone(&self) -> TreeArc<T> {\n-        TreeArc(self.0.clone())\n-    }\n-}\n-\n-impl<T> fmt::Debug for TreeArc<T>\n-where\n-    T: SyntaxNodeWrapper,\n-    T: fmt::Debug,\n-{\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&self.0, fmt)\n-    }\n-}\n-\n-#[derive(PartialEq, Eq, Hash)]\n-#[repr(transparent)]\n-pub struct SyntaxNode(pub(crate) rowan::SyntaxNode);\n-unsafe impl TransparentNewType for SyntaxNode {\n-    type Repr = rowan::SyntaxNode;\n-}\n-\n-impl ToOwned for SyntaxNode {\n-    type Owned = TreeArc<SyntaxNode>;\n-    fn to_owned(&self) -> TreeArc<SyntaxNode> {\n-        let ptr = TreeArc(self.0.to_owned());\n-        TreeArc::cast(ptr)\n-    }\n-}\n+#[derive(PartialEq, Eq, Hash, Clone)]\n+pub struct SyntaxNode(pub(crate) rowan::cursor::SyntaxNode);\n \n impl fmt::Debug for SyntaxNode {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n@@ -133,57 +54,57 @@ pub enum Direction {\n }\n \n impl SyntaxNode {\n-    pub(crate) fn new(green: GreenNode) -> TreeArc<SyntaxNode> {\n-        let ptr = TreeArc(rowan::SyntaxNode::new(green, None));\n-        TreeArc::cast(ptr)\n+    pub(crate) fn new(green: GreenNode) -> SyntaxNode {\n+        let inner = rowan::cursor::SyntaxNode::new_root(green);\n+        SyntaxNode(inner)\n     }\n \n     pub fn kind(&self) -> SyntaxKind {\n         self.0.kind().0.into()\n     }\n \n     pub fn range(&self) -> TextRange {\n-        self.0.range()\n+        self.0.text_range()\n     }\n \n     pub fn text(&self) -> SyntaxText {\n         SyntaxText::new(self)\n     }\n \n-    pub fn parent(&self) -> Option<&SyntaxNode> {\n-        self.0.parent().map(SyntaxNode::from_repr)\n+    pub fn parent(&self) -> Option<SyntaxNode> {\n+        self.0.parent().map(SyntaxNode)\n     }\n \n-    pub fn first_child(&self) -> Option<&SyntaxNode> {\n-        self.0.first_child().map(SyntaxNode::from_repr)\n+    pub fn first_child(&self) -> Option<SyntaxNode> {\n+        self.0.first_child().map(SyntaxNode)\n     }\n \n     pub fn first_child_or_token(&self) -> Option<SyntaxElement> {\n-        self.0.first_child_or_token().map(SyntaxElement::from)\n+        self.0.first_child_or_token().map(SyntaxElement::new)\n     }\n \n-    pub fn last_child(&self) -> Option<&SyntaxNode> {\n-        self.0.last_child().map(SyntaxNode::from_repr)\n+    pub fn last_child(&self) -> Option<SyntaxNode> {\n+        self.0.last_child().map(SyntaxNode)\n     }\n \n     pub fn last_child_or_token(&self) -> Option<SyntaxElement> {\n-        self.0.last_child_or_token().map(SyntaxElement::from)\n+        self.0.last_child_or_token().map(SyntaxElement::new)\n     }\n \n-    pub fn next_sibling(&self) -> Option<&SyntaxNode> {\n-        self.0.next_sibling().map(SyntaxNode::from_repr)\n+    pub fn next_sibling(&self) -> Option<SyntaxNode> {\n+        self.0.next_sibling().map(SyntaxNode)\n     }\n \n     pub fn next_sibling_or_token(&self) -> Option<SyntaxElement> {\n-        self.0.next_sibling_or_token().map(SyntaxElement::from)\n+        self.0.next_sibling_or_token().map(SyntaxElement::new)\n     }\n \n-    pub fn prev_sibling(&self) -> Option<&SyntaxNode> {\n-        self.0.prev_sibling().map(SyntaxNode::from_repr)\n+    pub fn prev_sibling(&self) -> Option<SyntaxNode> {\n+        self.0.prev_sibling().map(SyntaxNode)\n     }\n \n     pub fn prev_sibling_or_token(&self) -> Option<SyntaxElement> {\n-        self.0.prev_sibling_or_token().map(SyntaxElement::from)\n+        self.0.prev_sibling_or_token().map(SyntaxElement::new)\n     }\n \n     pub fn children(&self) -> SyntaxNodeChildren {\n@@ -195,18 +116,18 @@ impl SyntaxNode {\n     }\n \n     pub fn first_token(&self) -> Option<SyntaxToken> {\n-        self.0.first_token().map(SyntaxToken::from)\n+        self.0.first_token().map(SyntaxToken)\n     }\n \n     pub fn last_token(&self) -> Option<SyntaxToken> {\n-        self.0.last_token().map(SyntaxToken::from)\n+        self.0.last_token().map(SyntaxToken)\n     }\n \n-    pub fn ancestors(&self) -> impl Iterator<Item = &SyntaxNode> {\n-        successors(Some(self), |&node| node.parent())\n+    pub fn ancestors(&self) -> impl Iterator<Item = SyntaxNode> {\n+        successors(Some(self.clone()), |node| node.parent())\n     }\n \n-    pub fn descendants(&self) -> impl Iterator<Item = &SyntaxNode> {\n+    pub fn descendants(&self) -> impl Iterator<Item = SyntaxNode> {\n         self.preorder().filter_map(|event| match event {\n             WalkEvent::Enter(node) => Some(node),\n             WalkEvent::Leave(_) => None,\n@@ -220,8 +141,8 @@ impl SyntaxNode {\n         })\n     }\n \n-    pub fn siblings(&self, direction: Direction) -> impl Iterator<Item = &SyntaxNode> {\n-        successors(Some(self), move |&node| match direction {\n+    pub fn siblings(&self, direction: Direction) -> impl Iterator<Item = SyntaxNode> {\n+        successors(Some(self.clone()), move |node| match direction {\n             Direction::Next => node.next_sibling(),\n             Direction::Prev => node.prev_sibling(),\n         })\n@@ -231,29 +152,29 @@ impl SyntaxNode {\n         &self,\n         direction: Direction,\n     ) -> impl Iterator<Item = SyntaxElement> {\n-        let me: SyntaxElement = self.into();\n+        let me: SyntaxElement = self.clone().into();\n         successors(Some(me), move |el| match direction {\n             Direction::Next => el.next_sibling_or_token(),\n             Direction::Prev => el.prev_sibling_or_token(),\n         })\n     }\n \n-    pub fn preorder(&self) -> impl Iterator<Item = WalkEvent<&SyntaxNode>> {\n+    pub fn preorder(&self) -> impl Iterator<Item = WalkEvent<SyntaxNode>> {\n         self.0.preorder().map(|event| match event {\n-            WalkEvent::Enter(n) => WalkEvent::Enter(SyntaxNode::from_repr(n)),\n-            WalkEvent::Leave(n) => WalkEvent::Leave(SyntaxNode::from_repr(n)),\n+            WalkEvent::Enter(n) => WalkEvent::Enter(SyntaxNode(n)),\n+            WalkEvent::Leave(n) => WalkEvent::Leave(SyntaxNode(n)),\n         })\n     }\n \n     pub fn preorder_with_tokens(&self) -> impl Iterator<Item = WalkEvent<SyntaxElement>> {\n         self.0.preorder_with_tokens().map(|event| match event {\n-            WalkEvent::Enter(n) => WalkEvent::Enter(n.into()),\n-            WalkEvent::Leave(n) => WalkEvent::Leave(n.into()),\n+            WalkEvent::Enter(n) => WalkEvent::Enter(SyntaxElement::new(n)),\n+            WalkEvent::Leave(n) => WalkEvent::Leave(SyntaxElement::new(n)),\n         })\n     }\n \n     pub fn memory_size_of_subtree(&self) -> usize {\n-        self.0.memory_size_of_subtree()\n+        0\n     }\n \n     pub fn debug_dump(&self) -> String {\n@@ -290,11 +211,11 @@ impl SyntaxNode {\n     ///\n     /// This is a type-unsafe low-level editing API, if you need to use it,\n     /// prefer to create a type-safe abstraction on top of it instead.\n-    pub fn insert_children<'a>(\n+    pub fn insert_children(\n         &self,\n-        position: InsertPosition<SyntaxElement<'_>>,\n-        to_insert: impl Iterator<Item = SyntaxElement<'a>>,\n-    ) -> TreeArc<SyntaxNode> {\n+        position: InsertPosition<SyntaxElement>,\n+        to_insert: impl Iterator<Item = SyntaxElement>,\n+    ) -> SyntaxNode {\n         let mut delta = TextUnit::default();\n         let to_insert = to_insert.map(|element| {\n             delta += element.text_len();\n@@ -303,7 +224,7 @@ impl SyntaxNode {\n \n         let old_children = self.0.green().children();\n \n-        let new_children = match position {\n+        let new_children = match &position {\n             InsertPosition::First => {\n                 to_insert.chain(old_children.iter().cloned()).collect::<Box<[_]>>()\n             }\n@@ -312,7 +233,7 @@ impl SyntaxNode {\n             }\n             InsertPosition::Before(anchor) | InsertPosition::After(anchor) => {\n                 let take_anchor = if let InsertPosition::After(_) = position { 1 } else { 0 };\n-                let split_at = self.position_of_child(anchor) + take_anchor;\n+                let split_at = self.position_of_child(anchor.clone()) + take_anchor;\n                 let (before, after) = old_children.split_at(split_at);\n                 before\n                     .iter()\n@@ -330,13 +251,13 @@ impl SyntaxNode {\n     ///\n     /// This is a type-unsafe low-level editing API, if you need to use it,\n     /// prefer to create a type-safe abstraction on top of it instead.\n-    pub fn replace_children<'a>(\n+    pub fn replace_children(\n         &self,\n-        to_delete: RangeInclusive<SyntaxElement<'_>>,\n-        to_insert: impl Iterator<Item = SyntaxElement<'a>>,\n-    ) -> TreeArc<SyntaxNode> {\n-        let start = self.position_of_child(*to_delete.start());\n-        let end = self.position_of_child(*to_delete.end());\n+        to_delete: RangeInclusive<SyntaxElement>,\n+        to_insert: impl Iterator<Item = SyntaxElement>,\n+    ) -> SyntaxNode {\n+        let start = self.position_of_child(to_delete.start().clone());\n+        let end = self.position_of_child(to_delete.end().clone());\n         let old_children = self.0.green().children();\n \n         let new_children = old_children[..start]\n@@ -348,7 +269,7 @@ impl SyntaxNode {\n         self.with_children(new_children)\n     }\n \n-    fn with_children(&self, new_children: Box<[rowan::GreenElement]>) -> TreeArc<SyntaxNode> {\n+    fn with_children(&self, new_children: Box<[rowan::GreenElement]>) -> SyntaxNode {\n         let len = new_children.iter().map(|it| it.text_len()).sum::<TextUnit>();\n         let new_node = GreenNode::new(rowan::SyntaxKind(self.kind() as u16), new_children);\n         let new_file_node = self.replace_with(new_node);\n@@ -364,7 +285,7 @@ impl SyntaxNode {\n     fn position_of_child(&self, child: SyntaxElement) -> usize {\n         self.children_with_tokens()\n             .position(|it| it == child)\n-            .expect(\"elemetn is not a child of current element\")\n+            .expect(\"element is not a child of current element\")\n     }\n }\n \n@@ -377,11 +298,11 @@ fn to_green_element(element: SyntaxElement) -> rowan::GreenElement {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct SyntaxToken<'a>(pub(crate) rowan::SyntaxToken<'a>);\n+#[derive(Clone, PartialEq, Eq, Hash)]\n+pub struct SyntaxToken(pub(crate) rowan::cursor::SyntaxToken);\n \n //FIXME: always output text\n-impl<'a> fmt::Debug for SyntaxToken<'a> {\n+impl fmt::Debug for SyntaxToken {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"{:?}@{:?}\", self.kind(), self.range())?;\n         if self.text().len() < 25 {\n@@ -398,74 +319,80 @@ impl<'a> fmt::Debug for SyntaxToken<'a> {\n     }\n }\n \n-impl<'a> fmt::Display for SyntaxToken<'a> {\n+impl fmt::Display for SyntaxToken {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(self.text(), fmt)\n     }\n }\n \n-impl<'a> From<rowan::SyntaxToken<'a>> for SyntaxToken<'a> {\n-    fn from(t: rowan::SyntaxToken<'a>) -> Self {\n-        SyntaxToken(t)\n-    }\n-}\n-\n-impl<'a> SyntaxToken<'a> {\n+impl SyntaxToken {\n     pub fn kind(&self) -> SyntaxKind {\n         self.0.kind().0.into()\n     }\n \n-    pub fn text(&self) -> &'a SmolStr {\n+    pub fn text(&self) -> &SmolStr {\n         self.0.text()\n     }\n \n     pub fn range(&self) -> TextRange {\n-        self.0.range()\n+        self.0.text_range()\n     }\n \n-    pub fn parent(&self) -> &'a SyntaxNode {\n-        SyntaxNode::from_repr(self.0.parent())\n+    pub fn parent(&self) -> SyntaxNode {\n+        SyntaxNode(self.0.parent())\n     }\n \n-    pub fn next_sibling_or_token(&self) -> Option<SyntaxElement<'a>> {\n-        self.0.next_sibling_or_token().map(SyntaxElement::from)\n+    pub fn next_sibling_or_token(&self) -> Option<SyntaxElement> {\n+        self.0.next_sibling_or_token().map(SyntaxElement::new)\n     }\n \n-    pub fn prev_sibling_or_token(&self) -> Option<SyntaxElement<'a>> {\n-        self.0.prev_sibling_or_token().map(SyntaxElement::from)\n+    pub fn prev_sibling_or_token(&self) -> Option<SyntaxElement> {\n+        self.0.prev_sibling_or_token().map(SyntaxElement::new)\n     }\n \n     pub fn siblings_with_tokens(\n         &self,\n         direction: Direction,\n-    ) -> impl Iterator<Item = SyntaxElement<'a>> {\n-        let me: SyntaxElement = (*self).into();\n+    ) -> impl Iterator<Item = SyntaxElement> {\n+        let me: SyntaxElement = self.clone().into();\n         successors(Some(me), move |el| match direction {\n             Direction::Next => el.next_sibling_or_token(),\n             Direction::Prev => el.prev_sibling_or_token(),\n         })\n     }\n \n-    pub fn next_token(&self) -> Option<SyntaxToken<'a>> {\n-        self.0.next_token().map(SyntaxToken::from)\n+    pub fn next_token(&self) -> Option<SyntaxToken> {\n+        self.0.next_token().map(SyntaxToken)\n     }\n \n-    pub fn prev_token(&self) -> Option<SyntaxToken<'a>> {\n-        self.0.prev_token().map(SyntaxToken::from)\n+    pub fn prev_token(&self) -> Option<SyntaxToken> {\n+        self.0.prev_token().map(SyntaxToken)\n     }\n \n     pub(crate) fn replace_with(&self, new_token: GreenToken) -> GreenNode {\n         self.0.replace_with(new_token)\n     }\n }\n \n-#[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]\n-pub enum SyntaxElement<'a> {\n-    Node(&'a SyntaxNode),\n-    Token(SyntaxToken<'a>),\n+#[derive(Debug, PartialEq, Eq, Hash, Clone)]\n+pub enum SyntaxElement {\n+    Node(SyntaxNode),\n+    Token(SyntaxToken),\n }\n \n-impl<'a> fmt::Display for SyntaxElement<'a> {\n+impl From<SyntaxNode> for SyntaxElement {\n+    fn from(node: SyntaxNode) -> Self {\n+        SyntaxElement::Node(node)\n+    }\n+}\n+\n+impl From<SyntaxToken> for SyntaxElement {\n+    fn from(token: SyntaxToken) -> Self {\n+        SyntaxElement::Token(token)\n+    }\n+}\n+\n+impl fmt::Display for SyntaxElement {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match self {\n             SyntaxElement::Node(it) => fmt::Display::fmt(it, fmt),\n@@ -474,107 +401,89 @@ impl<'a> fmt::Display for SyntaxElement<'a> {\n     }\n }\n \n-impl<'a> SyntaxElement<'a> {\n+impl SyntaxElement {\n+    pub(crate) fn new(el: rowan::cursor::SyntaxElement) -> Self {\n+        match el {\n+            rowan::cursor::SyntaxElement::Node(it) => SyntaxElement::Node(SyntaxNode(it)),\n+            rowan::cursor::SyntaxElement::Token(it) => SyntaxElement::Token(SyntaxToken(it)),\n+        }\n+    }\n+\n     pub fn kind(&self) -> SyntaxKind {\n         match self {\n             SyntaxElement::Node(it) => it.kind(),\n             SyntaxElement::Token(it) => it.kind(),\n         }\n     }\n \n-    pub fn as_node(&self) -> Option<&'a SyntaxNode> {\n+    pub fn as_node(&self) -> Option<&SyntaxNode> {\n         match self {\n-            SyntaxElement::Node(node) => Some(*node),\n+            SyntaxElement::Node(node) => Some(node),\n             SyntaxElement::Token(_) => None,\n         }\n     }\n \n-    pub fn as_token(&self) -> Option<SyntaxToken<'a>> {\n+    pub fn as_token(&self) -> Option<&SyntaxToken> {\n         match self {\n             SyntaxElement::Node(_) => None,\n-            SyntaxElement::Token(token) => Some(*token),\n+            SyntaxElement::Token(token) => Some(token),\n         }\n     }\n \n-    pub fn next_sibling_or_token(&self) -> Option<SyntaxElement<'a>> {\n+    pub fn next_sibling_or_token(&self) -> Option<SyntaxElement> {\n         match self {\n             SyntaxElement::Node(it) => it.next_sibling_or_token(),\n             SyntaxElement::Token(it) => it.next_sibling_or_token(),\n         }\n     }\n \n-    pub fn prev_sibling_or_token(&self) -> Option<SyntaxElement<'a>> {\n+    pub fn prev_sibling_or_token(&self) -> Option<SyntaxElement> {\n         match self {\n             SyntaxElement::Node(it) => it.prev_sibling_or_token(),\n             SyntaxElement::Token(it) => it.prev_sibling_or_token(),\n         }\n     }\n \n-    pub fn ancestors(&self) -> impl Iterator<Item = &'a SyntaxNode> {\n+    pub fn ancestors(&self) -> impl Iterator<Item = SyntaxNode> {\n         match self {\n-            SyntaxElement::Node(it) => it,\n+            SyntaxElement::Node(it) => it.clone(),\n             SyntaxElement::Token(it) => it.parent(),\n         }\n         .ancestors()\n     }\n \n-    fn text_len(&self) -> TextUnit {\n+    pub fn range(&self) -> TextRange {\n         match self {\n-            SyntaxElement::Node(node) => node.0.green().text_len(),\n-            SyntaxElement::Token(token) => TextUnit::of_str(token.0.text()),\n-        }\n-    }\n-}\n-\n-impl<'a> From<rowan::SyntaxElement<'a>> for SyntaxElement<'a> {\n-    fn from(el: rowan::SyntaxElement<'a>) -> Self {\n-        match el {\n-            rowan::SyntaxElement::Node(n) => SyntaxElement::Node(SyntaxNode::from_repr(n)),\n-            rowan::SyntaxElement::Token(t) => SyntaxElement::Token(t.into()),\n+            SyntaxElement::Node(it) => it.range(),\n+            SyntaxElement::Token(it) => it.range(),\n         }\n     }\n-}\n-\n-impl<'a> From<&'a SyntaxNode> for SyntaxElement<'a> {\n-    fn from(node: &'a SyntaxNode) -> SyntaxElement<'a> {\n-        SyntaxElement::Node(node)\n-    }\n-}\n-\n-impl<'a> From<SyntaxToken<'a>> for SyntaxElement<'a> {\n-    fn from(token: SyntaxToken<'a>) -> SyntaxElement<'a> {\n-        SyntaxElement::Token(token)\n-    }\n-}\n \n-impl<'a> SyntaxElement<'a> {\n-    pub fn range(&self) -> TextRange {\n+    fn text_len(&self) -> TextUnit {\n         match self {\n-            SyntaxElement::Node(it) => it.range(),\n-            SyntaxElement::Token(it) => it.range(),\n+            SyntaxElement::Node(node) => node.0.green().text_len(),\n+            SyntaxElement::Token(token) => TextUnit::of_str(token.0.text()),\n         }\n     }\n }\n \n-#[derive(Debug)]\n-pub struct SyntaxNodeChildren<'a>(rowan::SyntaxNodeChildren<'a>);\n+#[derive(Clone, Debug)]\n+pub struct SyntaxNodeChildren(rowan::cursor::SyntaxNodeChildren);\n \n-impl<'a> Iterator for SyntaxNodeChildren<'a> {\n-    type Item = &'a SyntaxNode;\n-\n-    fn next(&mut self) -> Option<&'a SyntaxNode> {\n-        self.0.next().map(SyntaxNode::from_repr)\n+impl Iterator for SyntaxNodeChildren {\n+    type Item = SyntaxNode;\n+    fn next(&mut self) -> Option<SyntaxNode> {\n+        self.0.next().map(SyntaxNode)\n     }\n }\n \n-#[derive(Debug)]\n-pub struct SyntaxElementChildren<'a>(rowan::SyntaxElementChildren<'a>);\n-\n-impl<'a> Iterator for SyntaxElementChildren<'a> {\n-    type Item = SyntaxElement<'a>;\n+#[derive(Clone, Debug)]\n+pub struct SyntaxElementChildren(rowan::cursor::SyntaxElementChildren);\n \n-    fn next(&mut self) -> Option<SyntaxElement<'a>> {\n-        self.0.next().map(SyntaxElement::from)\n+impl Iterator for SyntaxElementChildren {\n+    type Item = SyntaxElement;\n+    fn next(&mut self) -> Option<SyntaxElement> {\n+        self.0.next().map(SyntaxElement::new)\n     }\n }\n \n@@ -601,7 +510,7 @@ impl SyntaxTreeBuilder {\n         if cfg!(debug_assertions) {\n             crate::validation::validate_block_structure(&node);\n         }\n-        Parse::new(node, errors)\n+        Parse::new(node.0.green().clone(), errors)\n     }\n \n     pub fn token(&mut self, kind: SyntaxKind, text: SmolStr) {"}, {"sha": "6902a04a24e23289a48189274975448c93748677", "filename": "crates/ra_syntax/src/syntax_text.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fsyntax_text.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fsyntax_text.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_text.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -16,29 +16,36 @@ impl<'a> SyntaxText<'a> {\n         SyntaxText { node, range: node.range() }\n     }\n \n-    pub fn chunks(&self) -> impl Iterator<Item = &'a str> {\n+    pub fn chunks(&self) -> impl Iterator<Item = SmolStr> {\n         let range = self.range;\n         self.node.descendants_with_tokens().filter_map(move |el| match el {\n             SyntaxElement::Token(t) => {\n                 let text = t.text();\n                 let range = range.intersection(&t.range())?;\n-                let range = range - t.range().start();\n-                Some(&text[range])\n+                let res = if range == t.range() {\n+                    t.text().clone()\n+                } else {\n+                    let range = range - t.range().start();\n+                    text[range].into()\n+                };\n+                Some(res)\n             }\n             SyntaxElement::Node(_) => None,\n         })\n     }\n \n     pub fn push_to(&self, buf: &mut String) {\n-        self.chunks().for_each(|it| buf.push_str(it));\n+        self.chunks().for_each(|it| buf.push_str(it.as_str()));\n     }\n \n     pub fn to_string(&self) -> String {\n-        self.chunks().collect()\n+        let mut buf = String::new();\n+        self.push_to(&mut buf);\n+        buf\n     }\n \n     pub fn to_smol_string(&self) -> SmolStr {\n-        self.chunks().collect()\n+        self.to_string().into()\n     }\n \n     pub fn contains(&self, c: char) -> bool {\n@@ -52,7 +59,7 @@ impl<'a> SyntaxText<'a> {\n                 let pos: TextUnit = (pos as u32).into();\n                 return Some(acc + pos);\n             }\n-            acc += TextUnit::of_str(chunk);\n+            acc += TextUnit::of_str(chunk.as_str());\n         }\n         None\n     }\n@@ -97,7 +104,7 @@ impl<'a> SyntaxText<'a> {\n         let mut start: TextUnit = 0.into();\n         let offset = offset.into();\n         for chunk in self.chunks() {\n-            let end = start + TextUnit::of_str(chunk);\n+            let end = start + TextUnit::of_str(chunk.as_str());\n             if start <= offset && offset < end {\n                 let off: usize = u32::from(offset - start) as usize;\n                 return Some(chunk[off..].chars().next().unwrap());\n@@ -129,7 +136,7 @@ impl From<SyntaxText<'_>> for String {\n impl PartialEq<str> for SyntaxText<'_> {\n     fn eq(&self, mut rhs: &str) -> bool {\n         for chunk in self.chunks() {\n-            if !rhs.starts_with(chunk) {\n+            if !rhs.starts_with(chunk.as_str()) {\n                 return false;\n             }\n             rhs = &rhs[chunk.len()..];"}, {"sha": "7140d10c33305911d38f18953cb08d2da67a2ae5", "filename": "crates/ra_syntax/src/validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -19,13 +19,13 @@ pub(crate) fn validate(file: &SourceFile) -> Vec<SyntaxError> {\n             .visit::<ast::Literal, _>(validate_literal)\n             .visit::<ast::Block, _>(block::validate_block_node)\n             .visit::<ast::FieldExpr, _>(field_expr::validate_field_expr_node)\n-            .accept(node);\n+            .accept(&node);\n     }\n     errors\n }\n \n // FIXME: kill duplication\n-fn validate_literal(literal: &ast::Literal, acc: &mut Vec<SyntaxError>) {\n+fn validate_literal(literal: ast::Literal, acc: &mut Vec<SyntaxError>) {\n     let token = literal.token();\n     let text = token.text().as_str();\n     match token.kind() {"}, {"sha": "f5573bd8f00f1dbb80874aaa2e46e953c5a0086e", "filename": "crates/ra_syntax/src/validation/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fblock.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -5,7 +5,7 @@ use crate::{\n     SyntaxKind::*,\n };\n \n-pub(crate) fn validate_block_node(node: &ast::Block, errors: &mut Vec<SyntaxError>) {\n+pub(crate) fn validate_block_node(node: ast::Block, errors: &mut Vec<SyntaxError>) {\n     if let Some(parent) = node.syntax().parent() {\n         match parent.kind() {\n             FN_DEF => return,"}, {"sha": "0e18bd9ca016bdc62db6c4e8552ca1e153e84d11", "filename": "crates/ra_syntax/src/validation/field_expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Ffield_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f209843e31af7f0e0212aa28ffec2efad2a70c6f/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Ffield_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Ffield_expr.rs?ref=f209843e31af7f0e0212aa28ffec2efad2a70c6f", "patch": "@@ -4,7 +4,7 @@ use crate::{\n     SyntaxErrorKind::*,\r\n };\r\n \r\n-pub(crate) fn validate_field_expr_node(node: &ast::FieldExpr, errors: &mut Vec<SyntaxError>) {\r\n+pub(crate) fn validate_field_expr_node(node: ast::FieldExpr, errors: &mut Vec<SyntaxError>) {\r\n     if let Some(FieldKind::Index(idx)) = node.field_access() {\r\n         if idx.text().chars().any(|c| c < '0' || c > '9') {\r\n             errors.push(SyntaxError::new(InvalidTupleIndexFormat, idx.range()));\r"}]}