{"sha": "b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd", "node_id": "C_kwDOAAsO6NoAKGIyNzYzY2M0Y2ZhNzYxYTFkNDJjYzAxYzc2MDNiYTZhOThjMDllY2Q", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-13T13:30:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-13T13:30:18Z"}, "message": "Auto merge of #94899 - workingjubilee:bump-simd-clamp, r=workingjubilee\n\nBump portable-simd to shadow Ord\n\nYon usual bump.\nSummary for reference:\n- We are moving away from the subjective \"directional\" nomenclature, so `horizontal_*` becomes `reduce_*`, et cetera.\n- In addition, `Simd<Int, N>` now has methods which shadow Ord's methods directly, making those methods behave like the already \"overloaded\" float methods do.", "tree": {"sha": "908a1e65394ca71f1df13550cc8c2c188ef010a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/908a1e65394ca71f1df13550cc8c2c188ef010a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd", "html_url": "https://github.com/rust-lang/rust/commit/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4800c7816ee1937d028407066d229f74b4673c92", "url": "https://api.github.com/repos/rust-lang/rust/commits/4800c7816ee1937d028407066d229f74b4673c92", "html_url": "https://github.com/rust-lang/rust/commit/4800c7816ee1937d028407066d229f74b4673c92"}, {"sha": "2b1f249ecf4a3b52bdac520a641c502be5048f8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b1f249ecf4a3b52bdac520a641c502be5048f8a", "html_url": "https://github.com/rust-lang/rust/commit/2b1f249ecf4a3b52bdac520a641c502be5048f8a"}], "stats": {"total": 319, "additions": 214, "deletions": 105}, "files": [{"sha": "c0eb000e87791549c7e83498a3389483eb72aa1d", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd", "patch": "@@ -3536,7 +3536,7 @@ impl<T> [T] {\n     ///         suffix.iter().copied().sum(),\n     ///     ]);\n     ///     let sums = middle.iter().copied().fold(sums, f32x4::add);\n-    ///     sums.horizontal_sum()\n+    ///     sums.reduce_sum()\n     /// }\n     ///\n     /// let numbers: Vec<f32> = (1..101).map(|x| x as _).collect();"}, {"sha": "75158e5aa855017f4e4289bc4be21305ba2edd30", "filename": "library/portable-simd/beginners-guide.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fbeginners-guide.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fbeginners-guide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fbeginners-guide.md?ref=b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd", "patch": "@@ -33,7 +33,7 @@ SIMD has a few special vocabulary terms you should know:\n \n * **Vertical:** When an operation is \"vertical\", each lane processes individually without regard to the other lanes in the same vector. For example, a \"vertical add\" between two vectors would add lane 0 in `a` with lane 0 in `b`, with the total in lane 0 of `out`, and then the same thing for lanes 1, 2, etc. Most SIMD operations are vertical operations, so if your problem is a vertical problem then you can probably solve it with SIMD.\n \n-* **Horizontal:** When an operation is \"horizontal\", the lanes within a single vector interact in some way. A \"horizontal add\" might add up lane 0 of `a` with lane 1 of `a`, with the total in lane 0 of `out`.\n+* **Reducing/Reduce:** When an operation is \"reducing\" (functions named `reduce_*`), the lanes within a single vector are merged using some operation such as addition, returning the merged value as a scalar. For instance, a reducing add would return the sum of all the lanes' values.\n \n * **Target Feature:** Rust calls a CPU architecture extension a `target_feature`. Proper SIMD requires various CPU extensions to be enabled (details below). Don't confuse this with `feature`, which is a Cargo crate concept.\n \n@@ -83,4 +83,4 @@ Fortunately, most SIMD types have a fairly predictable size. `i32x4` is bit-equi\n However, this is not the same as alignment. Computer architectures generally prefer aligned accesses, especially when moving data between memory and vector registers, and while some support specialized operations that can bend the rules to help with this, unaligned access is still typically slow, or even undefined behavior. In addition, different architectures can require different alignments when interacting with their native SIMD types. For this reason, any `#[repr(simd)]` type has a non-portable alignment. If it is necessary to directly interact with the alignment of these types, it should be via [`mem::align_of`].\n \n [`mem::transmute`]: https://doc.rust-lang.org/core/mem/fn.transmute.html\n-[`mem::align_of`]: https://doc.rust-lang.org/core/mem/fn.align_of.html\n\\ No newline at end of file\n+[`mem::align_of`]: https://doc.rust-lang.org/core/mem/fn.align_of.html"}, {"sha": "8877c6df66eda2dfd73f095bef1d4f977a4c0425", "filename": "library/portable-simd/crates/core_simd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2FCargo.toml?ref=b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd", "patch": "@@ -9,7 +9,7 @@ categories = [\"hardware-support\", \"no-std\"]\n license = \"MIT OR Apache-2.0\"\n \n [features]\n-default = [\"std\", \"generic_const_exprs\"]\n+default = []\n std = []\n generic_const_exprs = []\n "}, {"sha": "39f530f68f57a3bb241eb95e1771bf0a5aabe88a", "filename": "library/portable-simd/crates/core_simd/examples/matrix_inversion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fmatrix_inversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fmatrix_inversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fmatrix_inversion.rs?ref=b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd", "patch": "@@ -233,7 +233,7 @@ pub fn simd_inv4x4(m: Matrix4x4) -> Option<Matrix4x4> {\n     let det = det.rotate_lanes_right::<2>() + det;\n     let det = det.reverse().rotate_lanes_right::<2>() + det;\n \n-    if det.horizontal_sum() == 0. {\n+    if det.reduce_sum() == 0. {\n         return None;\n     }\n     // calculate the reciprocal"}, {"sha": "df38a00967febb7ba0f38868fec31462d6dab77f", "filename": "library/portable-simd/crates/core_simd/examples/nbody.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fnbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fnbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fnbody.rs?ref=b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd", "patch": "@@ -107,10 +107,10 @@ mod nbody {\n         let mut e = 0.;\n         for i in 0..N_BODIES {\n             let bi = &bodies[i];\n-            e += bi.mass * (bi.v * bi.v).horizontal_sum() * 0.5;\n+            e += bi.mass * (bi.v * bi.v).reduce_sum() * 0.5;\n             for bj in bodies.iter().take(N_BODIES).skip(i + 1) {\n                 let dx = bi.x - bj.x;\n-                e -= bi.mass * bj.mass / (dx * dx).horizontal_sum().sqrt()\n+                e -= bi.mass * bj.mass / (dx * dx).reduce_sum().sqrt()\n             }\n         }\n         e\n@@ -134,8 +134,8 @@ mod nbody {\n         let mut mag = [0.0; N];\n         for i in (0..N).step_by(2) {\n             let d2s = f64x2::from_array([\n-                (r[i] * r[i]).horizontal_sum(),\n-                (r[i + 1] * r[i + 1]).horizontal_sum(),\n+                (r[i] * r[i]).reduce_sum(),\n+                (r[i + 1] * r[i + 1]).reduce_sum(),\n             ]);\n             let dmags = f64x2::splat(dt) / (d2s * d2s.sqrt());\n             mag[i] = dmags[0];"}, {"sha": "012182e090b9f1b2ab3bef92a654a6bfd7ec0837", "filename": "library/portable-simd/crates/core_simd/examples/spectral_norm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fspectral_norm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fspectral_norm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fspectral_norm.rs?ref=b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd", "patch": "@@ -20,7 +20,7 @@ fn mult_av(v: &[f64], out: &mut [f64]) {\n             sum += b / a;\n             j += 2\n         }\n-        *out = sum.horizontal_sum();\n+        *out = sum.reduce_sum();\n     }\n }\n \n@@ -38,7 +38,7 @@ fn mult_atv(v: &[f64], out: &mut [f64]) {\n             sum += b / a;\n             j += 2\n         }\n-        *out = sum.horizontal_sum();\n+        *out = sum.reduce_sum();\n     }\n }\n "}, {"sha": "7b0d0a6864b9e631f5e4be1c417fcf5b4c01ef6e", "filename": "library/portable-simd/crates/core_simd/src/comparisons.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcomparisons.rs?ref=b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd", "patch": "@@ -66,3 +66,55 @@ where\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_ge(self, other)) }\n     }\n }\n+\n+macro_rules! impl_ord_methods_vector {\n+    { $type:ty } => {\n+        impl<const LANES: usize> Simd<$type, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            /// Returns the lane-wise minimum with `other`.\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+            #[inline]\n+            pub fn min(self, other: Self) -> Self {\n+                self.lanes_gt(other).select(other, self)\n+            }\n+\n+            /// Returns the lane-wise maximum with `other`.\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+            #[inline]\n+            pub fn max(self, other: Self) -> Self {\n+                self.lanes_lt(other).select(other, self)\n+            }\n+\n+            /// Restrict each lane to a certain interval.\n+            ///\n+            /// For each lane, returns `max` if `self` is greater than `max`, and `min` if `self` is\n+            /// less than `min`. Otherwise returns `self`.\n+            ///\n+            /// # Panics\n+            ///\n+            /// Panics if `min > max` on any lane.\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+            #[inline]\n+            pub fn clamp(self, min: Self, max: Self) -> Self {\n+                assert!(\n+                    min.lanes_le(max).all(),\n+                    \"each lane in `min` must be less than or equal to the corresponding lane in `max`\",\n+                );\n+                self.max(min).min(max)\n+            }\n+        }\n+    }\n+}\n+\n+impl_ord_methods_vector!(i8);\n+impl_ord_methods_vector!(i16);\n+impl_ord_methods_vector!(i32);\n+impl_ord_methods_vector!(i64);\n+impl_ord_methods_vector!(isize);\n+impl_ord_methods_vector!(u8);\n+impl_ord_methods_vector!(u16);\n+impl_ord_methods_vector!(u32);\n+impl_ord_methods_vector!(u64);\n+impl_ord_methods_vector!(usize);"}, {"sha": "426c4de6ab1eae5046a72ba5cb42c307ed562d76", "filename": "library/portable-simd/crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd", "patch": "@@ -18,7 +18,6 @@\n //!\n //! Unless stated otherwise, all intrinsics for binary operations require SIMD vectors of equal types and lengths.\n \n-\n // These intrinsics aren't linked directly from LLVM and are mostly undocumented, however they are\n // mostly lowered to the matching LLVM instructions by the compiler in a fairly straightforward manner.\n // The associated LLVM instruction or intrinsic is documented alongside each Rust intrinsic function.\n@@ -130,6 +129,14 @@ extern \"platform-intrinsic\" {\n     pub(crate) fn simd_reduce_xor<T, U>(x: T) -> U;\n \n     // truncate integer vector to bitmask\n+    // `fn simd_bitmask(vector) -> unsigned integer` takes a vector of integers and\n+    // returns either an unsigned integer or array of `u8`.\n+    // Every element in the vector becomes a single bit in the returned bitmask.\n+    // If the vector has less than 8 lanes, a u8 is returned with zeroed trailing bits.\n+    // The bit order of the result depends on the byte endianness. LSB-first for little\n+    // endian and MSB-first for big endian.\n+    //\n+    // UB if called on a vector with values other than 0 and -1.\n     #[allow(unused)]\n     pub(crate) fn simd_bitmask<T, U>(x: T) -> U;\n "}, {"sha": "2632073622edf8487a0e543823e04d0a465c3464", "filename": "library/portable-simd/crates/core_simd/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flib.rs?ref=b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd", "patch": "@@ -1,6 +1,5 @@\n-#![cfg_attr(not(feature = \"std\"), no_std)]\n+#![no_std]\n #![feature(\n-    const_fn_trait_bound,\n     convert_float_to_int,\n     decl_macro,\n     intra_doc_pointers,"}, {"sha": "c263f6a4eec3878145b8b71fb123ecb937144d36", "filename": "library/portable-simd/crates/core_simd/src/masks/to_bitmask.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs?ref=b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd", "patch": "@@ -50,6 +50,9 @@ macro_rules! impl_integer_intrinsic {\n }\n \n impl_integer_intrinsic! {\n+    unsafe impl ToBitMask<BitMask=u8> for Mask<_, 1>\n+    unsafe impl ToBitMask<BitMask=u8> for Mask<_, 2>\n+    unsafe impl ToBitMask<BitMask=u8> for Mask<_, 4>\n     unsafe impl ToBitMask<BitMask=u8> for Mask<_, 8>\n     unsafe impl ToBitMask<BitMask=u16> for Mask<_, 16>\n     unsafe impl ToBitMask<BitMask=u32> for Mask<_, 32>"}, {"sha": "606021e983ed176b2c73c8117b9dde4f362bf808", "filename": "library/portable-simd/crates/core_simd/src/math.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmath.rs?ref=b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd", "patch": "@@ -10,8 +10,7 @@ macro_rules! impl_uint_arith {\n             /// # Examples\n             /// ```\n             /// # #![feature(portable_simd)]\n-            /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n-            /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+            /// # use core::simd::Simd;\n             #[doc = concat!(\"# use core::\", stringify!($ty), \"::MAX;\")]\n             /// let x = Simd::from_array([2, 1, 0, MAX]);\n             /// let max = Simd::splat(MAX);\n@@ -31,8 +30,7 @@ macro_rules! impl_uint_arith {\n             /// # Examples\n             /// ```\n             /// # #![feature(portable_simd)]\n-            /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n-            /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+            /// # use core::simd::Simd;\n             #[doc = concat!(\"# use core::\", stringify!($ty), \"::MAX;\")]\n             /// let x = Simd::from_array([2, 1, 0, MAX]);\n             /// let max = Simd::splat(MAX);\n@@ -58,8 +56,7 @@ macro_rules! impl_int_arith {\n             /// # Examples\n             /// ```\n             /// # #![feature(portable_simd)]\n-            /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n-            /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+            /// # use core::simd::Simd;\n             #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n             /// let x = Simd::from_array([MIN, 0, 1, MAX]);\n             /// let max = Simd::splat(MAX);\n@@ -79,8 +76,7 @@ macro_rules! impl_int_arith {\n             /// # Examples\n             /// ```\n             /// # #![feature(portable_simd)]\n-            /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n-            /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+            /// # use core::simd::Simd;\n             #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n             /// let x = Simd::from_array([MIN, -2, -1, MAX]);\n             /// let max = Simd::splat(MAX);\n@@ -100,8 +96,7 @@ macro_rules! impl_int_arith {\n             /// # Examples\n             /// ```\n             /// # #![feature(portable_simd)]\n-            /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n-            /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+            /// # use core::simd::Simd;\n             #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n             /// let xs = Simd::from_array([MIN, MIN +1, -5, 0]);\n             /// assert_eq!(xs.abs(), Simd::from_array([MIN, MAX, 5, 0]));\n@@ -119,8 +114,7 @@ macro_rules! impl_int_arith {\n             /// # Examples\n             /// ```\n             /// # #![feature(portable_simd)]\n-            /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n-            /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+            /// # use core::simd::Simd;\n             #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n             /// let xs = Simd::from_array([MIN, -2, 0, 3]);\n             /// let unsat = xs.abs();\n@@ -142,8 +136,7 @@ macro_rules! impl_int_arith {\n             /// # Examples\n             /// ```\n             /// # #![feature(portable_simd)]\n-            /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n-            /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+            /// # use core::simd::Simd;\n             #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n             /// let x = Simd::from_array([MIN, -2, 3, MAX]);\n             /// let unsat = -x;"}, {"sha": "3177fd167fc44bcf2ad168503d1b6d7fd96190ef", "filename": "library/portable-simd/crates/core_simd/src/reduction.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Freduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Freduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Freduction.rs?ref=b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd", "patch": "@@ -11,30 +11,30 @@ macro_rules! impl_integer_reductions {\n         where\n             LaneCount<LANES>: SupportedLaneCount,\n         {\n-            /// Horizontal wrapping add.  Returns the sum of the lanes of the vector, with wrapping addition.\n+            /// Reducing wrapping add.  Returns the sum of the lanes of the vector, with wrapping addition.\n             #[inline]\n-            pub fn horizontal_sum(self) -> $scalar {\n+            pub fn reduce_sum(self) -> $scalar {\n                 // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_add_ordered(self, 0) }\n             }\n \n-            /// Horizontal wrapping multiply.  Returns the product of the lanes of the vector, with wrapping multiplication.\n+            /// Reducing wrapping multiply.  Returns the product of the lanes of the vector, with wrapping multiplication.\n             #[inline]\n-            pub fn horizontal_product(self) -> $scalar {\n+            pub fn reduce_product(self) -> $scalar {\n                 // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_mul_ordered(self, 1) }\n             }\n \n-            /// Horizontal maximum.  Returns the maximum lane in the vector.\n+            /// Reducing maximum.  Returns the maximum lane in the vector.\n             #[inline]\n-            pub fn horizontal_max(self) -> $scalar {\n+            pub fn reduce_max(self) -> $scalar {\n                 // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_max(self) }\n             }\n \n-            /// Horizontal minimum.  Returns the minimum lane in the vector.\n+            /// Reducing minimum.  Returns the minimum lane in the vector.\n             #[inline]\n-            pub fn horizontal_min(self) -> $scalar {\n+            pub fn reduce_min(self) -> $scalar {\n                 // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_min(self) }\n             }\n@@ -60,9 +60,9 @@ macro_rules! impl_float_reductions {\n             LaneCount<LANES>: SupportedLaneCount,\n         {\n \n-            /// Horizontal add.  Returns the sum of the lanes of the vector.\n+            /// Reducing add.  Returns the sum of the lanes of the vector.\n             #[inline]\n-            pub fn horizontal_sum(self) -> $scalar {\n+            pub fn reduce_sum(self) -> $scalar {\n                 // LLVM sum is inaccurate on i586\n                 if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n                     self.as_array().iter().sum()\n@@ -72,9 +72,9 @@ macro_rules! impl_float_reductions {\n                 }\n             }\n \n-            /// Horizontal multiply.  Returns the product of the lanes of the vector.\n+            /// Reducing multiply.  Returns the product of the lanes of the vector.\n             #[inline]\n-            pub fn horizontal_product(self) -> $scalar {\n+            pub fn reduce_product(self) -> $scalar {\n                 // LLVM product is inaccurate on i586\n                 if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n                     self.as_array().iter().product()\n@@ -84,22 +84,22 @@ macro_rules! impl_float_reductions {\n                 }\n             }\n \n-            /// Horizontal maximum.  Returns the maximum lane in the vector.\n+            /// Reducing maximum.  Returns the maximum lane in the vector.\n             ///\n             /// Returns values based on equality, so a vector containing both `0.` and `-0.` may\n             /// return either.  This function will not return `NaN` unless all lanes are `NaN`.\n             #[inline]\n-            pub fn horizontal_max(self) -> $scalar {\n+            pub fn reduce_max(self) -> $scalar {\n                 // Safety: `self` is a float vector\n                 unsafe { simd_reduce_max(self) }\n             }\n \n-            /// Horizontal minimum.  Returns the minimum lane in the vector.\n+            /// Reducing minimum.  Returns the minimum lane in the vector.\n             ///\n             /// Returns values based on equality, so a vector containing both `0.` and `-0.` may\n             /// return either.  This function will not return `NaN` unless all lanes are `NaN`.\n             #[inline]\n-            pub fn horizontal_min(self) -> $scalar {\n+            pub fn reduce_min(self) -> $scalar {\n                 // Safety: `self` is a float vector\n                 unsafe { simd_reduce_min(self) }\n             }\n@@ -116,10 +116,10 @@ where\n     T: SimdElement + BitAnd<T, Output = T>,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n-    /// Horizontal bitwise \"and\".  Returns the cumulative bitwise \"and\" across the lanes of\n+    /// Reducing bitwise \"and\".  Returns the cumulative bitwise \"and\" across the lanes of\n     /// the vector.\n     #[inline]\n-    pub fn horizontal_and(self) -> T {\n+    pub fn reduce_and(self) -> T {\n         unsafe { simd_reduce_and(self) }\n     }\n }\n@@ -130,10 +130,10 @@ where\n     T: SimdElement + BitOr<T, Output = T>,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n-    /// Horizontal bitwise \"or\".  Returns the cumulative bitwise \"or\" across the lanes of\n+    /// Reducing bitwise \"or\".  Returns the cumulative bitwise \"or\" across the lanes of\n     /// the vector.\n     #[inline]\n-    pub fn horizontal_or(self) -> T {\n+    pub fn reduce_or(self) -> T {\n         unsafe { simd_reduce_or(self) }\n     }\n }\n@@ -144,10 +144,10 @@ where\n     T: SimdElement + BitXor<T, Output = T>,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n-    /// Horizontal bitwise \"xor\".  Returns the cumulative bitwise \"xor\" across the lanes of\n+    /// Reducing bitwise \"xor\".  Returns the cumulative bitwise \"xor\" across the lanes of\n     /// the vector.\n     #[inline]\n-    pub fn horizontal_xor(self) -> T {\n+    pub fn reduce_xor(self) -> T {\n         unsafe { simd_reduce_xor(self) }\n     }\n }"}, {"sha": "065c5987d3fc903d1d2b7aa624fc7f12f22a4297", "filename": "library/portable-simd/crates/core_simd/src/select.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fselect.rs?ref=b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd", "patch": "@@ -14,8 +14,7 @@ where\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n-    /// # #[cfg(feature = \"std\")] use core_simd::{Simd, Mask};\n-    /// # #[cfg(not(feature = \"std\"))] use core::simd::{Simd, Mask};\n+    /// # use core::simd::{Simd, Mask};\n     /// let a = Simd::from_array([0, 1, 2, 3]);\n     /// let b = Simd::from_array([4, 5, 6, 7]);\n     /// let mask = Mask::from_array([true, false, false, true]);\n@@ -45,8 +44,7 @@ where\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n-    /// # #[cfg(feature = \"std\")] use core_simd::Mask;\n-    /// # #[cfg(not(feature = \"std\"))] use core::simd::Mask;\n+    /// # use core::simd::Mask;\n     /// let a = Mask::<i32, 4>::from_array([true, true, false, false]);\n     /// let b = Mask::<i32, 4>::from_array([false, false, true, true]);\n     /// let mask = Mask::<i32, 4>::from_array([true, false, false, true]);"}, {"sha": "ef47c4f3a4c5e73faa8326ba69f4b5ee387399a6", "filename": "library/portable-simd/crates/core_simd/src/swizzle.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle.rs?ref=b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd", "patch": "@@ -12,8 +12,7 @@ use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n /// ## One source vector\n /// ```\n /// # #![feature(portable_simd)]\n-/// # #[cfg(feature = \"std\")] use core_simd::{Simd, simd_swizzle};\n-/// # #[cfg(not(feature = \"std\"))] use core::simd::{Simd, simd_swizzle};\n+/// # use core::simd::{Simd, simd_swizzle};\n /// let v = Simd::<f32, 4>::from_array([0., 1., 2., 3.]);\n ///\n /// // Keeping the same size\n@@ -28,8 +27,7 @@ use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n /// ## Two source vectors\n /// ```\n /// # #![feature(portable_simd)]\n-/// # #[cfg(feature = \"std\")] use core_simd::{Simd, simd_swizzle, Which};\n-/// # #[cfg(not(feature = \"std\"))] use core::simd::{Simd, simd_swizzle, Which};\n+/// # use core::simd::{Simd, simd_swizzle, Which};\n /// use Which::*;\n /// let a = Simd::<f32, 4>::from_array([0., 1., 2., 3.]);\n /// let b = Simd::<f32, 4>::from_array([4., 5., 6., 7.]);\n@@ -273,8 +271,7 @@ where\n     ///\n     /// ```\n     /// #![feature(portable_simd)]\n-    /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n-    /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+    /// # use core::simd::Simd;\n     /// let a = Simd::from_array([0, 1, 2, 3]);\n     /// let b = Simd::from_array([4, 5, 6, 7]);\n     /// let (x, y) = a.interleave(b);\n@@ -337,8 +334,7 @@ where\n     ///\n     /// ```\n     /// #![feature(portable_simd)]\n-    /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n-    /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+    /// # use core::simd::Simd;\n     /// let a = Simd::from_array([0, 4, 1, 5]);\n     /// let b = Simd::from_array([2, 6, 3, 7]);\n     /// let (x, y) = a.deinterleave(b);"}, {"sha": "b9cd2e2021eae5a67ea765576c8d58cb80ccc6a0", "filename": "library/portable-simd/crates/core_simd/src/vector.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd", "patch": "@@ -153,8 +153,7 @@ where\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n-    /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n-    /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+    /// # use core::simd::Simd;\n     /// let floats: Simd<f32, 4> = Simd::from_array([1.9, -4.5, f32::INFINITY, f32::NAN]);\n     /// let ints = floats.cast::<i32>();\n     /// assert_eq!(ints, Simd::from_array([1, -4, i32::MAX, 0]));\n@@ -180,8 +179,7 @@ where\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n-    /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n-    /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+    /// # use core::simd::Simd;\n     /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n     /// let idxs = Simd::from_array([9, 3, 0, 5]);\n     /// let alt = Simd::from_array([-5, -4, -3, -2]);\n@@ -201,8 +199,7 @@ where\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n-    /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n-    /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+    /// # use core::simd::Simd;\n     /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n     /// let idxs = Simd::from_array([9, 3, 0, 5]);\n     ///\n@@ -225,8 +222,7 @@ where\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n-    /// # #[cfg(feature = \"std\")] use core_simd::{Simd, Mask};\n-    /// # #[cfg(not(feature = \"std\"))] use core::simd::{Simd, Mask};\n+    /// # use core::simd::{Simd, Mask};\n     /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n     /// let idxs = Simd::from_array([9, 3, 0, 5]);\n     /// let alt = Simd::from_array([-5, -4, -3, -2]);\n@@ -260,8 +256,7 @@ where\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n-    /// # #[cfg(feature = \"std\")] use core_simd::{Simd, Mask};\n-    /// # #[cfg(not(feature = \"std\"))] use core::simd::{Simd, Mask};\n+    /// # use core::simd::{Simd, Mask};\n     /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n     /// let idxs = Simd::from_array([9, 3, 0, 5]);\n     /// let alt = Simd::from_array([-5, -4, -3, -2]);\n@@ -296,8 +291,7 @@ where\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n-    /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n-    /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+    /// # use core::simd::Simd;\n     /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n     /// let idxs = Simd::from_array([9, 3, 0, 0]);\n     /// let vals = Simd::from_array([-27, 82, -41, 124]);\n@@ -319,8 +313,7 @@ where\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n-    /// # #[cfg(feature = \"std\")] use core_simd::{Simd, Mask};\n-    /// # #[cfg(not(feature = \"std\"))] use core::simd::{Simd, Mask};\n+    /// # use core::simd::{Simd, Mask};\n     /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n     /// let idxs = Simd::from_array([9, 3, 0, 0]);\n     /// let vals = Simd::from_array([-27, 82, -41, 124]);\n@@ -354,8 +347,7 @@ where\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n-    /// # #[cfg(feature = \"std\")] use core_simd::{Simd, Mask};\n-    /// # #[cfg(not(feature = \"std\"))] use core::simd::{Simd, Mask};\n+    /// # use core::simd::{Simd, Mask};\n     /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n     /// let idxs = Simd::from_array([9, 3, 0, 0]);\n     /// let vals = Simd::from_array([-27, 82, -41, 124]);"}, {"sha": "171e5b472fa76e224eb722451f3a1a474e0e7612", "filename": "library/portable-simd/crates/core_simd/tests/i16_ops.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fi16_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fi16_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fi16_ops.rs?ref=b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd", "patch": "@@ -1,5 +1,32 @@\n #![feature(portable_simd)]\n+use core_simd::i16x2;\n \n #[macro_use]\n mod ops_macros;\n impl_signed_tests! { i16 }\n+\n+#[test]\n+fn max_is_not_lexicographic() {\n+    let a = i16x2::splat(10);\n+    let b = i16x2::from_array([-4, 12]);\n+    assert_eq!(a.max(b), i16x2::from_array([10, 12]));\n+}\n+\n+#[test]\n+fn min_is_not_lexicographic() {\n+    let a = i16x2::splat(10);\n+    let b = i16x2::from_array([12, -4]);\n+    assert_eq!(a.min(b), i16x2::from_array([10, -4]));\n+}\n+\n+#[test]\n+fn clamp_is_not_lexicographic() {\n+    let a = i16x2::splat(10);\n+    let lo = i16x2::from_array([-12, -4]);\n+    let up = i16x2::from_array([-4, 12]);\n+    assert_eq!(a.clamp(lo, up), i16x2::from_array([-4, 10]));\n+\n+    let x = i16x2::from_array([1, 10]);\n+    let y = x.clamp(i16x2::splat(0), i16x2::splat(9));\n+    assert_eq!(y, i16x2::from_array([1, 9]));\n+}"}, {"sha": "7c9b17673efe3e4d18989ce5132114e71f9371c0", "filename": "library/portable-simd/crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 51, "deletions": 22, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd", "patch": "@@ -94,70 +94,70 @@ macro_rules! impl_binary_checked_op_test {\n macro_rules! impl_common_integer_tests {\n     { $vector:ident, $scalar:ident } => {\n         test_helpers::test_lanes! {\n-            fn horizontal_sum<const LANES: usize>() {\n+            fn reduce_sum<const LANES: usize>() {\n                 test_helpers::test_1(&|x| {\n                     test_helpers::prop_assert_biteq! (\n-                        $vector::<LANES>::from_array(x).horizontal_sum(),\n+                        $vector::<LANES>::from_array(x).reduce_sum(),\n                         x.iter().copied().fold(0 as $scalar, $scalar::wrapping_add),\n                     );\n                     Ok(())\n                 });\n             }\n \n-            fn horizontal_product<const LANES: usize>() {\n+            fn reduce_product<const LANES: usize>() {\n                 test_helpers::test_1(&|x| {\n                     test_helpers::prop_assert_biteq! (\n-                        $vector::<LANES>::from_array(x).horizontal_product(),\n+                        $vector::<LANES>::from_array(x).reduce_product(),\n                         x.iter().copied().fold(1 as $scalar, $scalar::wrapping_mul),\n                     );\n                     Ok(())\n                 });\n             }\n \n-            fn horizontal_and<const LANES: usize>() {\n+            fn reduce_and<const LANES: usize>() {\n                 test_helpers::test_1(&|x| {\n                     test_helpers::prop_assert_biteq! (\n-                        $vector::<LANES>::from_array(x).horizontal_and(),\n+                        $vector::<LANES>::from_array(x).reduce_and(),\n                         x.iter().copied().fold(-1i8 as $scalar, <$scalar as core::ops::BitAnd>::bitand),\n                     );\n                     Ok(())\n                 });\n             }\n \n-            fn horizontal_or<const LANES: usize>() {\n+            fn reduce_or<const LANES: usize>() {\n                 test_helpers::test_1(&|x| {\n                     test_helpers::prop_assert_biteq! (\n-                        $vector::<LANES>::from_array(x).horizontal_or(),\n+                        $vector::<LANES>::from_array(x).reduce_or(),\n                         x.iter().copied().fold(0 as $scalar, <$scalar as core::ops::BitOr>::bitor),\n                     );\n                     Ok(())\n                 });\n             }\n \n-            fn horizontal_xor<const LANES: usize>() {\n+            fn reduce_xor<const LANES: usize>() {\n                 test_helpers::test_1(&|x| {\n                     test_helpers::prop_assert_biteq! (\n-                        $vector::<LANES>::from_array(x).horizontal_xor(),\n+                        $vector::<LANES>::from_array(x).reduce_xor(),\n                         x.iter().copied().fold(0 as $scalar, <$scalar as core::ops::BitXor>::bitxor),\n                     );\n                     Ok(())\n                 });\n             }\n \n-            fn horizontal_max<const LANES: usize>() {\n+            fn reduce_max<const LANES: usize>() {\n                 test_helpers::test_1(&|x| {\n                     test_helpers::prop_assert_biteq! (\n-                        $vector::<LANES>::from_array(x).horizontal_max(),\n+                        $vector::<LANES>::from_array(x).reduce_max(),\n                         x.iter().copied().max().unwrap(),\n                     );\n                     Ok(())\n                 });\n             }\n \n-            fn horizontal_min<const LANES: usize>() {\n+            fn reduce_min<const LANES: usize>() {\n                 test_helpers::test_1(&|x| {\n                     test_helpers::prop_assert_biteq! (\n-                        $vector::<LANES>::from_array(x).horizontal_min(),\n+                        $vector::<LANES>::from_array(x).reduce_min(),\n                         x.iter().copied().min().unwrap(),\n                     );\n                     Ok(())\n@@ -222,6 +222,35 @@ macro_rules! impl_signed_tests {\n                     assert_eq!(a % b, Vector::<LANES>::splat(0));\n                 }\n \n+                fn min<const LANES: usize>() {\n+                    let a = Vector::<LANES>::splat(Scalar::MIN);\n+                    let b = Vector::<LANES>::splat(0);\n+                    assert_eq!(a.min(b), a);\n+                    let a = Vector::<LANES>::splat(Scalar::MAX);\n+                    let b = Vector::<LANES>::splat(0);\n+                    assert_eq!(a.min(b), b);\n+                }\n+\n+                fn max<const LANES: usize>() {\n+                    let a = Vector::<LANES>::splat(Scalar::MIN);\n+                    let b = Vector::<LANES>::splat(0);\n+                    assert_eq!(a.max(b), b);\n+                    let a = Vector::<LANES>::splat(Scalar::MAX);\n+                    let b = Vector::<LANES>::splat(0);\n+                    assert_eq!(a.max(b), a);\n+                }\n+\n+                fn clamp<const LANES: usize>() {\n+                    let min = Vector::<LANES>::splat(Scalar::MIN);\n+                    let max = Vector::<LANES>::splat(Scalar::MAX);\n+                    let zero = Vector::<LANES>::splat(0);\n+                    let one = Vector::<LANES>::splat(1);\n+                    let negone = Vector::<LANES>::splat(-1);\n+                    assert_eq!(zero.clamp(min, max), zero);\n+                    assert_eq!(zero.clamp(min, one), zero);\n+                    assert_eq!(zero.clamp(one, max), one);\n+                    assert_eq!(zero.clamp(min, negone), negone);\n+                }\n             }\n \n             test_helpers::test_lanes_panic! {\n@@ -499,29 +528,29 @@ macro_rules! impl_float_tests {\n                     })\n                 }\n \n-                fn horizontal_sum<const LANES: usize>() {\n+                fn reduce_sum<const LANES: usize>() {\n                     test_helpers::test_1(&|x| {\n                         test_helpers::prop_assert_biteq! (\n-                            Vector::<LANES>::from_array(x).horizontal_sum(),\n+                            Vector::<LANES>::from_array(x).reduce_sum(),\n                             x.iter().sum(),\n                         );\n                         Ok(())\n                     });\n                 }\n \n-                fn horizontal_product<const LANES: usize>() {\n+                fn reduce_product<const LANES: usize>() {\n                     test_helpers::test_1(&|x| {\n                         test_helpers::prop_assert_biteq! (\n-                            Vector::<LANES>::from_array(x).horizontal_product(),\n+                            Vector::<LANES>::from_array(x).reduce_product(),\n                             x.iter().product(),\n                         );\n                         Ok(())\n                     });\n                 }\n \n-                fn horizontal_max<const LANES: usize>() {\n+                fn reduce_max<const LANES: usize>() {\n                     test_helpers::test_1(&|x| {\n-                        let vmax = Vector::<LANES>::from_array(x).horizontal_max();\n+                        let vmax = Vector::<LANES>::from_array(x).reduce_max();\n                         let smax = x.iter().copied().fold(Scalar::NAN, Scalar::max);\n                         // 0 and -0 are treated the same\n                         if !(x.contains(&0.) && x.contains(&-0.) && vmax.abs() == 0. && smax.abs() == 0.) {\n@@ -531,9 +560,9 @@ macro_rules! impl_float_tests {\n                     });\n                 }\n \n-                fn horizontal_min<const LANES: usize>() {\n+                fn reduce_min<const LANES: usize>() {\n                     test_helpers::test_1(&|x| {\n-                        let vmax = Vector::<LANES>::from_array(x).horizontal_min();\n+                        let vmax = Vector::<LANES>::from_array(x).reduce_min();\n                         let smax = x.iter().copied().fold(Scalar::NAN, Scalar::min);\n                         // 0 and -0 are treated the same\n                         if !(x.contains(&0.) && x.contains(&-0.) && vmax.abs() == 0. && smax.abs() == 0.) {"}, {"sha": "7feb0320a16c52b86c0724f7e086ec4fa879d24b", "filename": "library/portable-simd/crates/core_simd/tests/round.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fround.rs?ref=b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd", "patch": "@@ -9,7 +9,6 @@ macro_rules! float_rounding_test {\n             type Scalar = $scalar;\n             type IntScalar = $int_scalar;\n \n-            #[cfg(feature = \"std\")]\n             test_helpers::test_lanes! {\n                 fn ceil<const LANES: usize>() {\n                     test_helpers::test_unary_elementwise("}, {"sha": "84c69774cbdfe10a5ac113ea36982471ddc0e525", "filename": "library/portable-simd/crates/std_float/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fstd_float%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Fstd_float%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fstd_float%2FCargo.toml?ref=b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd", "patch": "@@ -6,7 +6,7 @@ edition = \"2021\"\n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n [dependencies]\n-core_simd = { path = \"../core_simd\" }\n+core_simd = { path = \"../core_simd\", default-features = false }\n \n [features]\n default = [\"as_crate\"]"}, {"sha": "8bf7f5ed3d2a483ec3618f15060ffbc5c49cf04f", "filename": "library/portable-simd/crates/test_helpers/src/lib.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Flib.rs?ref=b2763cc4cfa761a1d42cc01c7603ba6a98c09ecd", "patch": "@@ -77,19 +77,29 @@ impl<T: core::fmt::Debug + DefaultStrategy, const LANES: usize> DefaultStrategy\n     }\n }\n \n+#[cfg(not(miri))]\n+fn make_runner() -> proptest::test_runner::TestRunner {\n+    Default::default()\n+}\n+#[cfg(miri)]\n+fn make_runner() -> proptest::test_runner::TestRunner {\n+    // Only run a few tests on Miri\n+    proptest::test_runner::TestRunner::new(proptest::test_runner::Config::with_cases(4))\n+}\n+\n /// Test a function that takes a single value.\n pub fn test_1<A: core::fmt::Debug + DefaultStrategy>(\n     f: &dyn Fn(A) -> proptest::test_runner::TestCaseResult,\n ) {\n-    let mut runner = proptest::test_runner::TestRunner::default();\n+    let mut runner = make_runner();\n     runner.run(&A::default_strategy(), f).unwrap();\n }\n \n /// Test a function that takes two values.\n pub fn test_2<A: core::fmt::Debug + DefaultStrategy, B: core::fmt::Debug + DefaultStrategy>(\n     f: &dyn Fn(A, B) -> proptest::test_runner::TestCaseResult,\n ) {\n-    let mut runner = proptest::test_runner::TestRunner::default();\n+    let mut runner = make_runner();\n     runner\n         .run(&(A::default_strategy(), B::default_strategy()), |(a, b)| {\n             f(a, b)\n@@ -105,7 +115,7 @@ pub fn test_3<\n >(\n     f: &dyn Fn(A, B, C) -> proptest::test_runner::TestCaseResult,\n ) {\n-    let mut runner = proptest::test_runner::TestRunner::default();\n+    let mut runner = make_runner();\n     runner\n         .run(\n             &(\n@@ -361,24 +371,28 @@ macro_rules! test_lanes {\n \n                 #[test]\n                 #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n+                #[cfg(not(miri))] // Miri intrinsic implementations are uniform and larger tests are sloooow\n                 fn lanes_8() {\n                     implementation::<8>();\n                 }\n \n                 #[test]\n                 #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n+                #[cfg(not(miri))] // Miri intrinsic implementations are uniform and larger tests are sloooow\n                 fn lanes_16() {\n                     implementation::<16>();\n                 }\n \n                 #[test]\n                 #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n+                #[cfg(not(miri))] // Miri intrinsic implementations are uniform and larger tests are sloooow\n                 fn lanes_32() {\n                     implementation::<32>();\n                 }\n \n                 #[test]\n                 #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n+                #[cfg(not(miri))] // Miri intrinsic implementations are uniform and larger tests are sloooow\n                 fn lanes_64() {\n                     implementation::<64>();\n                 }"}]}