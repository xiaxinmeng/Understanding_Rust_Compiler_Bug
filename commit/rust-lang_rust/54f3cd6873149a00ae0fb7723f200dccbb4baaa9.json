{"sha": "54f3cd6873149a00ae0fb7723f200dccbb4baaa9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0ZjNjZDY4NzMxNDlhMDBhZTBmYjc3MjNmMjAwZGNjYmI0YmFhYTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-17T13:26:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-17T13:26:40Z"}, "message": "Auto merge of #56810 - sinkuu:build_match, r=oli-obk\n\nImprove MIR match generation for ranges\n\nImproves MIR match generation to rule out ranges/values distinct from the range that has been tested. e.g., for this code:\n\n```rust\nmatch x {\n    0..=5 if b => 0,\n    6..=10 => 1,\n    _ => 2,\n}\n```\n\nMIR (before):\n\n```rust\nbb0: { ...; _4 = Le(const 0i32, _1); switchInt(move _4) -> [false: bb6, otherwise: bb5]; }\nbb1: { _3 = const 0i32; goto -> bb8; }\nbb2: { _6 = _2; switchInt(move _6) -> [false: bb6, otherwise: bb1]; } // If `!b`, jumps to test if `6 <= x <= 10`.\nbb3: { _3 = const 1i32; goto -> bb8; }\nbb4: { _3 = const 2i32; goto -> bb8; }\nbb5: { _5 = Le(_1, const 5i32); switchInt(move _5) -> [false: bb6, otherwise: bb2]; }\nbb6: { _7 = Le(const 6i32, _1); switchInt(move _7) -> [false: bb4, otherwise: bb7]; }\nbb7: { _8 = Le(_1, const 10i32); switchInt(move _8) -> [false: bb4, otherwise: bb3]; }\n```\n\nMIR (after):\n```rust\nbb0: { ...; _4 = Le(const 0i32, _1); switchInt(move _4) -> [false: bb5, otherwise: bb6]; }\nbb1: { _3 = const 0i32; goto -> bb8; }\nbb2: { _6 = _2; switchInt(move _6) -> [false: bb4, otherwise: bb1]; } // If `!b`, jumps to `_ =>` arm.\nbb3: { _3 = const 1i32; goto -> bb8; }\nbb4: { _3 = const 2i32; goto -> bb8; }\nbb5: { _7 = Le(const 6i32, _1); switchInt(move _7) -> [false: bb4, otherwise: bb7]; }\nbb6: { _5 = Le(_1, const 5i32); switchInt(move _5) -> [false: bb5, otherwise: bb2]; }\nbb7: { _8 = Le(_1, const 10i32); switchInt(move _8) -> [false: bb4, otherwise: bb3]; }\n```\n\ncc #29623", "tree": {"sha": "62e98a6c692c48666e49c6b9441596cc3013d071", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62e98a6c692c48666e49c6b9441596cc3013d071"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54f3cd6873149a00ae0fb7723f200dccbb4baaa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54f3cd6873149a00ae0fb7723f200dccbb4baaa9", "html_url": "https://github.com/rust-lang/rust/commit/54f3cd6873149a00ae0fb7723f200dccbb4baaa9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54f3cd6873149a00ae0fb7723f200dccbb4baaa9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "640c7ff4323ca11ceffb18fdd9c6d02f5a0ce3af", "url": "https://api.github.com/repos/rust-lang/rust/commits/640c7ff4323ca11ceffb18fdd9c6d02f5a0ce3af", "html_url": "https://github.com/rust-lang/rust/commit/640c7ff4323ca11ceffb18fdd9c6d02f5a0ce3af"}, {"sha": "d66a55e4de9604c5e4f56c0756a747990ae0bc4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d66a55e4de9604c5e4f56c0756a747990ae0bc4b", "html_url": "https://github.com/rust-lang/rust/commit/d66a55e4de9604c5e4f56c0756a747990ae0bc4b"}], "stats": {"total": 408, "additions": 339, "deletions": 69}, "files": [{"sha": "4d61bf8dae681b5451116e2cb0a0f70022dabcf6", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/54f3cd6873149a00ae0fb7723f200dccbb4baaa9/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f3cd6873149a00ae0fb7723f200dccbb4baaa9/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=54f3cd6873149a00ae0fb7723f200dccbb4baaa9", "patch": "@@ -19,7 +19,6 @@ use build::{BlockAnd, BlockAndExtension, Builder};\n use build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n use hair::*;\n use hair::pattern::PatternTypeProjections;\n-use rustc::hir;\n use rustc::mir::*;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::VariantIdx;\n@@ -100,7 +99,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             .collect();\n \n         // create binding start block for link them by false edges\n-        let candidate_count = arms.iter().fold(0, |ac, c| ac + c.patterns.len());\n+        let candidate_count = arms.iter().map(|c| c.patterns.len()).sum::<usize>();\n         let pre_binding_blocks: Vec<_> = (0..=candidate_count)\n             .map(|_| self.cfg.start_new_block())\n             .collect();\n@@ -337,7 +336,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     pub fn place_into_pattern(\n         &mut self,\n-        mut block: BasicBlock,\n+        block: BasicBlock,\n         irrefutable_pat: Pattern<'tcx>,\n         initializer: &Place<'tcx>,\n         set_match_place: bool,\n@@ -359,7 +358,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         // Simplify the candidate. Since the pattern is irrefutable, this should\n         // always convert all match-pairs into bindings.\n-        unpack!(block = self.simplify_candidate(block, &mut candidate));\n+        self.simplify_candidate(&mut candidate);\n \n         if !candidate.match_pairs.is_empty() {\n             span_bug!(\n@@ -681,12 +680,7 @@ enum TestKind<'tcx> {\n     },\n \n     // test whether the value falls within an inclusive or exclusive range\n-    Range {\n-        lo: &'tcx ty::Const<'tcx>,\n-        hi: &'tcx ty::Const<'tcx>,\n-        ty: Ty<'tcx>,\n-        end: hir::RangeEnd,\n-    },\n+    Range(PatternRange<'tcx>),\n \n     // test length of the slice is equal to len\n     Len {\n@@ -745,7 +739,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // complete, all the match pairs which remain require some\n         // form of test, whether it be a switch or pattern comparison.\n         for candidate in &mut candidates {\n-            unpack!(block = self.simplify_candidate(block, candidate));\n+            self.simplify_candidate(candidate);\n         }\n \n         // The candidates are sorted by priority. Check to see\n@@ -1035,7 +1029,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             test, match_pair\n         );\n         let target_blocks = self.perform_test(block, &match_pair.place, &test);\n-        let mut target_candidates: Vec<_> = (0..target_blocks.len()).map(|_| vec![]).collect();\n+        let mut target_candidates = vec![vec![]; target_blocks.len()];\n \n         // Sort the candidates into the appropriate vector in\n         // `target_candidates`. Note that at some point we may"}, {"sha": "0ce642838707ed5aac8e95b3d1b659fa87e7b8c2", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/54f3cd6873149a00ae0fb7723f200dccbb4baaa9/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f3cd6873149a00ae0fb7723f200dccbb4baaa9/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=54f3cd6873149a00ae0fb7723f200dccbb4baaa9", "patch": "@@ -22,10 +22,9 @@\n //! sort of test: for example, testing which variant an enum is, or\n //! testing a value against a constant.\n \n-use build::{BlockAnd, BlockAndExtension, Builder};\n+use build::Builder;\n use build::matches::{Ascription, Binding, MatchPair, Candidate};\n use hair::*;\n-use rustc::mir::*;\n use rustc::ty;\n use rustc::ty::layout::{Integer, IntegerExt, Size};\n use syntax::attr::{SignedInt, UnsignedInt};\n@@ -35,24 +34,23 @@ use std::mem;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn simplify_candidate<'pat>(&mut self,\n-                                    block: BasicBlock,\n-                                    candidate: &mut Candidate<'pat, 'tcx>)\n-                                    -> BlockAnd<()> {\n+                                    candidate: &mut Candidate<'pat, 'tcx>) {\n         // repeatedly simplify match pairs until fixed point is reached\n         loop {\n             let match_pairs = mem::replace(&mut candidate.match_pairs, vec![]);\n-            let mut progress = match_pairs.len(); // count how many were simplified\n+            let mut changed = false;\n             for match_pair in match_pairs {\n                 match self.simplify_match_pair(match_pair, candidate) {\n-                    Ok(()) => {}\n+                    Ok(()) => {\n+                        changed = true;\n+                    }\n                     Err(match_pair) => {\n                         candidate.match_pairs.push(match_pair);\n-                        progress -= 1; // this one was not simplified\n                     }\n                 }\n             }\n-            if progress == 0 {\n-                return block.unit(); // if we were not able to simplify any, done.\n+            if !changed {\n+                return; // if we were not able to simplify any, done.\n             }\n         }\n     }\n@@ -109,7 +107,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 Err(match_pair)\n             }\n \n-            PatternKind::Range { lo, hi, ty, end } => {\n+            PatternKind::Range(PatternRange { lo, hi, ty, end }) => {\n                 let range = match ty.sty {\n                     ty::Char => {\n                         Some(('\\u{0000}' as u128, '\\u{10FFFF}' as u128, Size::from_bits(32)))"}, {"sha": "c8dec6d0b9764b67528e2d531a5d06f17f3dce03", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 128, "deletions": 24, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/54f3cd6873149a00ae0fb7723f200dccbb4baaa9/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f3cd6873149a00ae0fb7723f200dccbb4baaa9/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=54f3cd6873149a00ae0fb7723f200dccbb4baaa9", "patch": "@@ -18,6 +18,7 @@\n use build::Builder;\n use build::matches::{Candidate, MatchPair, Test, TestKind};\n use hair::*;\n+use hair::pattern::compare_const_vals;\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::fx::FxHashMap;\n use rustc::ty::{self, Ty};\n@@ -71,16 +72,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatternKind::Range { lo, hi, ty, end } => {\n-                assert!(ty == match_pair.pattern.ty);\n+            PatternKind::Range(range) => {\n+                assert!(range.ty == match_pair.pattern.ty);\n                 Test {\n                     span: match_pair.pattern.span,\n-                    kind: TestKind::Range {\n-                        lo,\n-                        hi,\n-                        ty,\n-                        end,\n-                    },\n+                    kind: TestKind::Range(range),\n                 }\n             }\n \n@@ -136,7 +132,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             PatternKind::Variant { .. } => {\n                 panic!(\"you should have called add_variants_to_switch instead!\");\n             }\n-            PatternKind::Range { .. } |\n+            PatternKind::Range(range) => {\n+                // Check that none of the switch values are in the range.\n+                self.values_not_contained_in_range(range, indices)\n+                    .unwrap_or(false)\n+            }\n             PatternKind::Slice { .. } |\n             PatternKind::Array { .. } |\n             PatternKind::Wild |\n@@ -200,20 +200,18 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 for (idx, discr) in adt_def.discriminants(tcx) {\n                     target_blocks.push(if variants.contains(idx) {\n                         values.push(discr.val);\n-                        targets.push(self.cfg.start_new_block());\n-                        *targets.last().unwrap()\n+                        let block = self.cfg.start_new_block();\n+                        targets.push(block);\n+                        block\n                     } else {\n-                        if otherwise_block.is_none() {\n-                            otherwise_block = Some(self.cfg.start_new_block());\n-                        }\n-                        otherwise_block.unwrap()\n+                        *otherwise_block\n+                            .get_or_insert_with(|| self.cfg.start_new_block())\n                     });\n                 }\n-                if let Some(otherwise_block) = otherwise_block {\n-                    targets.push(otherwise_block);\n-                } else {\n-                    targets.push(self.unreachable_block());\n-                }\n+                targets.push(\n+                    otherwise_block\n+                        .unwrap_or_else(|| self.unreachable_block()),\n+                );\n                 debug!(\"num_enum_variants: {}, tested variants: {:?}, variants: {:?}\",\n                        num_enum_variants, values, variants);\n                 let discr_ty = adt_def.repr.discr_type().to_ty(tcx);\n@@ -378,7 +376,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            TestKind::Range { ref lo, ref hi, ty, ref end } => {\n+            TestKind::Range(PatternRange { ref lo, ref hi, ty, ref end }) => {\n                 // Test `val` by computing `lo <= val && val <= hi`, using primitive comparisons.\n                 let lo = self.literal_operand(test.span, ty.clone(), lo.clone());\n                 let hi = self.literal_operand(test.span, ty.clone(), hi.clone());\n@@ -490,8 +488,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // away.)\n         let tested_match_pair = candidate.match_pairs.iter()\n                                                      .enumerate()\n-                                                     .filter(|&(_, mp)| mp.place == *test_place)\n-                                                     .next();\n+                                                     .find(|&(_, mp)| mp.place == *test_place);\n         let (match_pair_index, match_pair) = match tested_match_pair {\n             Some(pair) => pair,\n             None => {\n@@ -532,6 +529,24 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 resulting_candidates[index].push(new_candidate);\n                 true\n             }\n+\n+            (&TestKind::SwitchInt { switch_ty: _, ref options, ref indices },\n+             &PatternKind::Range(range)) => {\n+                let not_contained = self\n+                    .values_not_contained_in_range(range, indices)\n+                    .unwrap_or(false);\n+\n+                if not_contained {\n+                    // No switch values are contained in the pattern range,\n+                    // so the pattern can be matched only if this test fails.\n+                    let otherwise = options.len();\n+                    resulting_candidates[otherwise].push(candidate.clone());\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+\n             (&TestKind::SwitchInt { .. }, _) => false,\n \n \n@@ -610,8 +625,63 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n+            (&TestKind::Range(test),\n+             &PatternKind::Range(pat)) => {\n+                if test == pat {\n+                    resulting_candidates[0]\n+                        .push(self.candidate_without_match_pair(\n+                            match_pair_index,\n+                            candidate,\n+                        ));\n+                    return true;\n+                }\n+\n+                let no_overlap = (|| {\n+                    use std::cmp::Ordering::*;\n+                    use rustc::hir::RangeEnd::*;\n+\n+                    let param_env = ty::ParamEnv::empty().and(test.ty);\n+                    let tcx = self.hir.tcx();\n+\n+                    let lo = compare_const_vals(tcx, test.lo, pat.hi, param_env)?;\n+                    let hi = compare_const_vals(tcx, test.hi, pat.lo, param_env)?;\n+\n+                    match (test.end, pat.end, lo, hi) {\n+                        // pat < test\n+                        (_, _, Greater, _) |\n+                        (_, Excluded, Equal, _) |\n+                        // pat > test\n+                        (_, _, _, Less) |\n+                        (Excluded, _, _, Equal) => Some(true),\n+                        _ => Some(false),\n+                    }\n+                })();\n+\n+                if no_overlap == Some(true) {\n+                    // Testing range does not overlap with pattern range,\n+                    // so the pattern can be matched only if this test fails.\n+                    resulting_candidates[1].push(candidate.clone());\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+\n+            (&TestKind::Range(range), &PatternKind::Constant { ref value }) => {\n+                if self.const_range_contains(range, value) == Some(false) {\n+                    // `value` is not contained in the testing range,\n+                    // so `value` can be matched only if this test fails.\n+                    resulting_candidates[1].push(candidate.clone());\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+\n+            (&TestKind::Range { .. }, _) => false,\n+\n+\n             (&TestKind::Eq { .. }, _) |\n-            (&TestKind::Range { .. }, _) |\n             (&TestKind::Len { .. }, _) => {\n                 // These are all binary tests.\n                 //\n@@ -722,6 +792,40 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                   \"simplifyable pattern found: {:?}\",\n                   match_pair.pattern)\n     }\n+\n+    fn const_range_contains(\n+        &self,\n+        range: PatternRange<'tcx>,\n+        value: &'tcx ty::Const<'tcx>,\n+    ) -> Option<bool> {\n+        use std::cmp::Ordering::*;\n+\n+        let param_env = ty::ParamEnv::empty().and(range.ty);\n+        let tcx = self.hir.tcx();\n+\n+        let a = compare_const_vals(tcx, range.lo, value, param_env)?;\n+        let b = compare_const_vals(tcx, value, range.hi, param_env)?;\n+\n+        match (b, range.end) {\n+            (Less, _) |\n+            (Equal, RangeEnd::Included) if a != Greater => Some(true),\n+            _ => Some(false),\n+        }\n+    }\n+\n+    fn values_not_contained_in_range(\n+        &self,\n+        range: PatternRange<'tcx>,\n+        indices: &FxHashMap<&'tcx ty::Const<'tcx>, usize>,\n+    ) -> Option<bool> {\n+        for val in indices.keys() {\n+            if self.const_range_contains(range, val)? {\n+                return Some(false);\n+            }\n+        }\n+\n+        Some(true)\n+    }\n }\n \n fn is_switch_ty<'tcx>(ty: Ty<'tcx>) -> bool {"}, {"sha": "b254fce4b7684a6678d77ad99c75e2da1733d340", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54f3cd6873149a00ae0fb7723f200dccbb4baaa9/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f3cd6873149a00ae0fb7723f200dccbb4baaa9/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=54f3cd6873149a00ae0fb7723f200dccbb4baaa9", "patch": "@@ -29,7 +29,7 @@ pub mod cx;\n mod constant;\n \n pub mod pattern;\n-pub use self::pattern::{BindingMode, Pattern, PatternKind, FieldPattern};\n+pub use self::pattern::{BindingMode, Pattern, PatternKind, PatternRange, FieldPattern};\n pub(crate) use self::pattern::{PatternTypeProjection, PatternTypeProjections};\n \n mod util;"}, {"sha": "7ec6bbfe3c11e32a057491edf217551487c0782a", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/54f3cd6873149a00ae0fb7723f200dccbb4baaa9/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f3cd6873149a00ae0fb7723f200dccbb4baaa9/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=54f3cd6873149a00ae0fb7723f200dccbb4baaa9", "patch": "@@ -173,7 +173,7 @@ use self::WitnessPreference::*;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n \n-use super::{FieldPattern, Pattern, PatternKind};\n+use super::{FieldPattern, Pattern, PatternKind, PatternRange};\n use super::{PatternFoldable, PatternFolder, compare_const_vals};\n \n use rustc::hir::def_id::DefId;\n@@ -604,12 +604,12 @@ impl<'tcx> Witness<'tcx> {\n                 _ => {\n                     match *ctor {\n                         ConstantValue(value) => PatternKind::Constant { value },\n-                        ConstantRange(lo, hi, ty, end) => PatternKind::Range {\n+                        ConstantRange(lo, hi, ty, end) => PatternKind::Range(PatternRange {\n                             lo: ty::Const::from_bits(cx.tcx, lo, ty::ParamEnv::empty().and(ty)),\n                             hi: ty::Const::from_bits(cx.tcx, hi, ty::ParamEnv::empty().and(ty)),\n                             ty,\n                             end,\n-                        },\n+                        }),\n                         _ => PatternKind::Wild,\n                     }\n                 }\n@@ -872,7 +872,7 @@ impl<'tcx> IntRange<'tcx> {\n                 -> Option<IntRange<'tcx>> {\n         Self::from_ctor(tcx, &match pat.kind {\n             box PatternKind::Constant { value } => ConstantValue(value),\n-            box PatternKind::Range { lo, hi, ty, end } => ConstantRange(\n+            box PatternKind::Range(PatternRange { lo, hi, ty, end }) => ConstantRange(\n                 lo.to_bits(tcx, ty::ParamEnv::empty().and(ty)).unwrap(),\n                 hi.to_bits(tcx, ty::ParamEnv::empty().and(ty)).unwrap(),\n                 ty,\n@@ -1311,7 +1311,7 @@ fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n             Some(vec![Variant(adt_def.variants[variant_index].did)])\n         }\n         PatternKind::Constant { value } => Some(vec![ConstantValue(value)]),\n-        PatternKind::Range { lo, hi, ty, end } =>\n+        PatternKind::Range(PatternRange { lo, hi, ty, end }) =>\n             Some(vec![ConstantRange(\n                 lo.to_bits(cx.tcx, ty::ParamEnv::empty().and(ty)).unwrap(),\n                 hi.to_bits(cx.tcx, ty::ParamEnv::empty().and(ty)).unwrap(),\n@@ -1642,7 +1642,7 @@ fn constructor_covered_by_range<'a, 'tcx>(\n ) -> Result<bool, ErrorReported> {\n     let (from, to, end, ty) = match pat.kind {\n         box PatternKind::Constant { value } => (value, value, RangeEnd::Included, value.ty),\n-        box PatternKind::Range { lo, hi, ty, end } => (lo, hi, end, ty),\n+        box PatternKind::Range(PatternRange { lo, hi, end, ty }) => (lo, hi, end, ty),\n         _ => bug!(\"`constructor_covered_by_range` called with {:?}\", pat),\n     };\n     trace!(\"constructor_covered_by_range {:#?}, {:#?}, {:#?}, {}\", ctor, from, to, ty);"}, {"sha": "f78a70f6a25f436895cc84261616ad8de0ba509a", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/54f3cd6873149a00ae0fb7723f200dccbb4baaa9/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f3cd6873149a00ae0fb7723f200dccbb4baaa9/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=54f3cd6873149a00ae0fb7723f200dccbb4baaa9", "patch": "@@ -24,7 +24,7 @@ use hair::constant::*;\n use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n use rustc::mir::{ProjectionElem, UserTypeAnnotation, UserTypeProjection, UserTypeProjections};\n use rustc::mir::interpret::{Scalar, GlobalId, ConstValue, sign_extend};\n-use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty};\n+use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty, Lift};\n use rustc::ty::subst::{Substs, Kind};\n use rustc::ty::layout::VariantIdx;\n use rustc::hir::{self, PatKind, RangeEnd};\n@@ -219,12 +219,7 @@ pub enum PatternKind<'tcx> {\n         value: &'tcx ty::Const<'tcx>,\n     },\n \n-    Range {\n-        lo: &'tcx ty::Const<'tcx>,\n-        hi: &'tcx ty::Const<'tcx>,\n-        ty: Ty<'tcx>,\n-        end: RangeEnd,\n-    },\n+    Range(PatternRange<'tcx>),\n \n     /// matches against a slice, checking the length and extracting elements.\n     /// irrefutable when there is a slice pattern and both `prefix` and `suffix` are empty.\n@@ -243,6 +238,14 @@ pub enum PatternKind<'tcx> {\n     },\n }\n \n+#[derive(Clone, Copy, Debug, PartialEq)]\n+pub struct PatternRange<'tcx> {\n+    pub lo: &'tcx ty::Const<'tcx>,\n+    pub hi: &'tcx ty::Const<'tcx>,\n+    pub ty: Ty<'tcx>,\n+    pub end: RangeEnd,\n+}\n+\n impl<'tcx> fmt::Display for Pattern<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self.kind {\n@@ -354,7 +357,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n             PatternKind::Constant { value } => {\n                 fmt_const_val(f, value)\n             }\n-            PatternKind::Range { lo, hi, ty: _, end } => {\n+            PatternKind::Range(PatternRange { lo, hi, ty: _, end }) => {\n                 fmt_const_val(f, lo)?;\n                 match end {\n                     RangeEnd::Included => write!(f, \"..=\")?,\n@@ -483,7 +486,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         );\n                         match (end, cmp) {\n                             (RangeEnd::Excluded, Some(Ordering::Less)) =>\n-                                PatternKind::Range { lo, hi, ty, end },\n+                                PatternKind::Range(PatternRange { lo, hi, ty, end }),\n                             (RangeEnd::Excluded, _) => {\n                                 span_err!(\n                                     self.tcx.sess,\n@@ -497,7 +500,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                 PatternKind::Constant { value: lo }\n                             }\n                             (RangeEnd::Included, Some(Ordering::Less)) => {\n-                                PatternKind::Range { lo, hi, ty, end }\n+                                PatternKind::Range(PatternRange { lo, hi, ty, end })\n                             }\n                             (RangeEnd::Included, _) => {\n                                 let mut err = struct_span_err!(\n@@ -1177,17 +1180,17 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n             } => PatternKind::Constant {\n                 value: value.fold_with(folder)\n             },\n-            PatternKind::Range {\n+            PatternKind::Range(PatternRange {\n                 lo,\n                 hi,\n                 ty,\n                 end,\n-            } => PatternKind::Range {\n+            }) => PatternKind::Range(PatternRange {\n                 lo: lo.fold_with(folder),\n                 hi: hi.fold_with(folder),\n                 ty: ty.fold_with(folder),\n                 end,\n-            },\n+            }),\n             PatternKind::Slice {\n                 ref prefix,\n                 ref slice,\n@@ -1210,8 +1213,8 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n     }\n }\n \n-pub fn compare_const_vals<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn compare_const_vals<'a, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     a: &'tcx ty::Const<'tcx>,\n     b: &'tcx ty::Const<'tcx>,\n     ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n@@ -1233,6 +1236,9 @@ pub fn compare_const_vals<'a, 'tcx>(\n         return fallback();\n     }\n \n+    let tcx = tcx.global_tcx();\n+    let (a, b, ty) = (a, b, ty).lift_to_tcx(tcx).unwrap();\n+\n     // FIXME: This should use assert_bits(ty) instead of use_bits\n     // but triggers possibly bugs due to mismatching of arrays and slices\n     if let (Some(a), Some(b)) = (a.to_bits(tcx, ty), b.to_bits(tcx, ty)) {"}, {"sha": "9bfb728e1346152de7ce5ceb408453dea7d110ac", "filename": "src/test/mir-opt/match_test.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/54f3cd6873149a00ae0fb7723f200dccbb4baaa9/src%2Ftest%2Fmir-opt%2Fmatch_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f3cd6873149a00ae0fb7723f200dccbb4baaa9/src%2Ftest%2Fmir-opt%2Fmatch_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_test.rs?ref=54f3cd6873149a00ae0fb7723f200dccbb4baaa9", "patch": "@@ -0,0 +1,85 @@\n+// Make sure redundant testing paths in `match` expressions are sorted out.\n+\n+#![feature(exclusive_range_pattern)]\n+\n+fn main() {\n+    let x = 3;\n+    let b = true;\n+\n+    // When `(0..=10).contains(x) && !b`, we should jump to the last arm\n+    // without testing two other candidates.\n+    match x {\n+        0..10 if b => 0,\n+        10..=20 => 1,\n+        -1 => 2,\n+        _ => 3,\n+    };\n+}\n+\n+// END RUST SOURCE\n+// START rustc.main.SimplifyCfg-initial.after.mir\n+//    bb0: {\n+//        ...\n+//        _4 = Le(const 0i32, _1);\n+//        switchInt(move _4) -> [false: bb10, otherwise: bb11];\n+//    }\n+//    bb1: {\n+//        _3 = const 0i32;\n+//        goto -> bb16;\n+//    }\n+//    bb2: {\n+//        _3 = const 1i32;\n+//        goto -> bb16;\n+//    }\n+//    bb3: {\n+//        _3 = const 2i32;\n+//        goto -> bb16;\n+//    }\n+//    bb4: {\n+//        _3 = const 3i32;\n+//        goto -> bb16;\n+//    }\n+//    bb5: {\n+//        falseEdges -> [real: bb12, imaginary: bb6];\n+//    }\n+//    bb6: {\n+//        falseEdges -> [real: bb2, imaginary: bb7];\n+//    }\n+//    bb7: {\n+//        falseEdges -> [real: bb3, imaginary: bb8];\n+//    }\n+//    bb8: {\n+//        falseEdges -> [real: bb4, imaginary: bb9];\n+//    }\n+//    bb9: {\n+//        unreachable;\n+//    }\n+//    bb10: {\n+//        _7 = Le(const 10i32, _1);\n+//        switchInt(move _7) -> [false: bb14, otherwise: bb15];\n+//    }\n+//    bb11: {\n+//        _5 = Lt(_1, const 10i32);\n+//        switchInt(move _5) -> [false: bb10, otherwise: bb5];\n+//    }\n+//    bb12: {\n+//        StorageLive(_6);\n+//        _6 = _2;\n+//        switchInt(move _6) -> [false: bb13, otherwise: bb1];\n+//    }\n+//    bb13: {\n+//        falseEdges -> [real: bb8, imaginary: bb6];\n+//    }\n+//    bb14: {\n+//        switchInt(_1) -> [-1i32: bb7, otherwise: bb8];\n+//    }\n+//    bb15: {\n+//        _8 = Le(_1, const 20i32);\n+//        switchInt(move _8) -> [false: bb14, otherwise: bb6];\n+//    }\n+//    bb16: {\n+//        StorageDead(_6);\n+//        ...\n+//        return;\n+//    }\n+// END rustc.main.SimplifyCfg-initial.after.mir"}, {"sha": "1f96d6737e0afaae370a342638f7190c7b4df20b", "filename": "src/test/run-pass/mir/mir_match_test.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/54f3cd6873149a00ae0fb7723f200dccbb4baaa9/src%2Ftest%2Frun-pass%2Fmir%2Fmir_match_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f3cd6873149a00ae0fb7723f200dccbb4baaa9/src%2Ftest%2Frun-pass%2Fmir%2Fmir_match_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir%2Fmir_match_test.rs?ref=54f3cd6873149a00ae0fb7723f200dccbb4baaa9", "patch": "@@ -0,0 +1,83 @@\n+#![feature(exclusive_range_pattern)]\n+\n+// run-pass\n+\n+fn main() {\n+    let incl_range = |x, b| {\n+        match x {\n+            0..=5 if b => 0,\n+            5..=10 if b => 1,\n+            1..=4 if !b => 2,\n+            _ => 3,\n+        }\n+    };\n+    assert_eq!(incl_range(3, false), 2);\n+    assert_eq!(incl_range(3, true), 0);\n+    assert_eq!(incl_range(5, false), 3);\n+    assert_eq!(incl_range(5, true), 0);\n+\n+    let excl_range = |x, b| {\n+        match x {\n+            0..5 if b => 0,\n+            5..10 if b => 1,\n+            1..4 if !b => 2,\n+            _ => 3,\n+        }\n+    };\n+    assert_eq!(excl_range(3, false), 2);\n+    assert_eq!(excl_range(3, true), 0);\n+    assert_eq!(excl_range(5, false), 3);\n+    assert_eq!(excl_range(5, true), 1);\n+\n+    let incl_range_vs_const = |x, b| {\n+        match x {\n+            0..=5 if b => 0,\n+            7 => 1,\n+            3 => 2,\n+            _ => 3,\n+        }\n+    };\n+    assert_eq!(incl_range_vs_const(5, false), 3);\n+    assert_eq!(incl_range_vs_const(5, true), 0);\n+    assert_eq!(incl_range_vs_const(3, false), 2);\n+    assert_eq!(incl_range_vs_const(3, true), 0);\n+    assert_eq!(incl_range_vs_const(7, false), 1);\n+    assert_eq!(incl_range_vs_const(7, true), 1);\n+\n+    let excl_range_vs_const = |x, b| {\n+        match x {\n+            0..5 if b => 0,\n+            7 => 1,\n+            3 => 2,\n+            _ => 3,\n+        }\n+    };\n+    assert_eq!(excl_range_vs_const(5, false), 3);\n+    assert_eq!(excl_range_vs_const(5, true), 3);\n+    assert_eq!(excl_range_vs_const(3, false), 2);\n+    assert_eq!(excl_range_vs_const(3, true), 0);\n+    assert_eq!(excl_range_vs_const(7, false), 1);\n+    assert_eq!(excl_range_vs_const(7, true), 1);\n+\n+    let const_vs_incl_range = |x, b| {\n+        match x {\n+            3 if b => 0,\n+            5..=7 => 2,\n+            1..=4 => 1,\n+            _ => 3,\n+        }\n+    };\n+    assert_eq!(const_vs_incl_range(3, false), 1);\n+    assert_eq!(const_vs_incl_range(3, true), 0);\n+\n+    let const_vs_excl_range = |x, b| {\n+        match x {\n+            3 if b => 0,\n+            5..7 => 2,\n+            1..4 => 1,\n+            _ => 3,\n+        }\n+    };\n+    assert_eq!(const_vs_excl_range(3, false), 1);\n+    assert_eq!(const_vs_excl_range(3, true), 0);\n+}"}]}