{"sha": "0e668e0496fcc13fa042be416b64ba6823669cca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlNjY4ZTA0OTZmY2MxM2ZhMDQyYmU0MTZiNjRiYTY4MjM2NjljY2E=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-07-25T00:58:29Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-08-21T18:52:38Z"}, "message": "Strip code to the left and right in diagnostics for long lines", "tree": {"sha": "f094f92facb95576c3f8bcc0a800db97802b571d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f094f92facb95576c3f8bcc0a800db97802b571d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e668e0496fcc13fa042be416b64ba6823669cca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e668e0496fcc13fa042be416b64ba6823669cca", "html_url": "https://github.com/rust-lang/rust/commit/0e668e0496fcc13fa042be416b64ba6823669cca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e668e0496fcc13fa042be416b64ba6823669cca/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b0085a613e69cb69fc9e4eb5d422fa4a39d5de1", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b0085a613e69cb69fc9e4eb5d422fa4a39d5de1", "html_url": "https://github.com/rust-lang/rust/commit/7b0085a613e69cb69fc9e4eb5d422fa4a39d5de1"}], "stats": {"total": 180, "additions": 133, "deletions": 47}, "files": [{"sha": "007c6369c7bd0ba3718b7a2ca6e34458e516ce7c", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 118, "deletions": 32, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/0e668e0496fcc13fa042be416b64ba6823669cca/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e668e0496fcc13fa042be416b64ba6823669cca/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=0e668e0496fcc13fa042be416b64ba6823669cca", "patch": "@@ -179,6 +179,7 @@ pub struct EmitterWriter {\n     sm: Option<Lrc<SourceMapperDyn>>,\n     short_message: bool,\n     teach: bool,\n+    strip_margin: bool,\n     ui_testing: bool,\n }\n \n@@ -201,6 +202,7 @@ impl EmitterWriter {\n             sm: source_map,\n             short_message,\n             teach,\n+            strip_margin: false,\n             ui_testing: false,\n         }\n     }\n@@ -217,6 +219,7 @@ impl EmitterWriter {\n             sm: source_map,\n             short_message,\n             teach,\n+            strip_margin: false,\n             ui_testing: false,\n         }\n     }\n@@ -234,12 +237,29 @@ impl EmitterWriter {\n         }\n     }\n \n-    fn render_source_line(&self,\n-                          buffer: &mut StyledBuffer,\n-                          file: Lrc<SourceFile>,\n-                          line: &Line,\n-                          width_offset: usize,\n-                          code_offset: usize) -> Vec<(usize, Style)> {\n+    fn render_source_line(\n+        &self,\n+        buffer: &mut StyledBuffer,\n+        file: Lrc<SourceFile>,\n+        line: &Line,\n+        width_offset: usize,\n+        code_offset: usize,\n+        margin: usize,\n+        right_span_margin: usize\n+    ) -> Vec<(usize, Style)> {\n+        // Draw:\n+        //\n+        //   LL | ... code ...\n+        //      |     ^^-^ span label\n+        //      |       |\n+        //      |       secondary span label\n+        //\n+        //   ^^ ^ ^^^ ^^^^ ^^^ we don't care about code too far to the right of a span, we trim it\n+        //   |  | |   |\n+        //   |  | |   actual code found in your source code and the spans we use to mark it\n+        //   |  | when there's too much wasted space to the left, we trim it to focus where it matters\n+        //   |  vertical divider between the column number and the code\n+        //   column number\n         if line.line_index == 0 {\n             return Vec::new();\n         }\n@@ -251,12 +271,28 @@ impl EmitterWriter {\n \n         let line_offset = buffer.num_lines();\n \n-        // First create the source line we will highlight.\n-        buffer.puts(line_offset, code_offset, &source_string, Style::Quotation);\n-        buffer.puts(line_offset,\n-                    0,\n-                    &self.maybe_anonymized(line.line_index),\n-                    Style::LineNumber);\n+        let left_margin = std::cmp::min(margin, source_string.len());\n+        let right_margin = if source_string.len() > right_span_margin + 120 {\n+            right_span_margin + 120\n+        } else {\n+            source_string.len()\n+        };\n+        // Create the source line we will highlight.\n+        buffer.puts(\n+            line_offset,\n+            code_offset,\n+            &source_string[left_margin..right_margin], // On long lines, we strip the source line\n+            Style::Quotation,\n+        );\n+        if margin > 0 { // We have stripped some code/whitespace from the beginning, make it clear.\n+            buffer.puts(line_offset, code_offset, \"...\", Style::LineNumber);\n+        }\n+        if right_margin != source_string.len() {\n+            // We have stripped some code after the right-most span end, make it clear we did so.\n+            let offset = code_offset + right_margin - left_margin;\n+            buffer.puts(line_offset, offset, \"...\", Style::LineNumber);\n+        }\n+        buffer.puts(line_offset, 0, &self.maybe_anonymized(line.line_index), Style::LineNumber);\n \n         draw_col_separator(buffer, line_offset, width_offset - 2);\n \n@@ -279,18 +315,13 @@ impl EmitterWriter {\n         if line.annotations.len() == 1 {\n             if let Some(ref ann) = line.annotations.get(0) {\n                 if let AnnotationType::MultilineStart(depth) = ann.annotation_type {\n-                    if source_string.chars()\n-                                    .take(ann.start_col)\n-                                    .all(|c| c.is_whitespace()) {\n+                    if source_string.chars().take(ann.start_col).all(|c| c.is_whitespace()) {\n                         let style = if ann.is_primary {\n                             Style::UnderlinePrimary\n                         } else {\n                             Style::UnderlineSecondary\n                         };\n-                        buffer.putc(line_offset,\n-                                    width_offset + depth - 1,\n-                                    '/',\n-                                    style);\n+                        buffer.putc(line_offset, width_offset + depth - 1, '/', style);\n                         return vec![(depth, style)];\n                     }\n                 }\n@@ -515,13 +546,13 @@ impl EmitterWriter {\n                                '_',\n                                line_offset + pos,\n                                width_offset + depth,\n-                               code_offset + annotation.start_col,\n+                               code_offset + annotation.start_col - margin,\n                                style);\n                 }\n                 _ if self.teach => {\n                     buffer.set_style_range(line_offset,\n-                                           code_offset + annotation.start_col,\n-                                           code_offset + annotation.end_col,\n+                                           code_offset + annotation.start_col - margin,\n+                                           code_offset + annotation.end_col - margin,\n                                            style,\n                                            annotation.is_primary);\n                 }\n@@ -551,7 +582,7 @@ impl EmitterWriter {\n             if pos > 1 && (annotation.has_label() || annotation.takes_space()) {\n                 for p in line_offset + 1..=line_offset + pos {\n                     buffer.putc(p,\n-                                code_offset + annotation.start_col,\n+                                code_offset + annotation.start_col - margin,\n                                 '|',\n                                 style);\n                 }\n@@ -595,9 +626,9 @@ impl EmitterWriter {\n                 Style::LabelSecondary\n             };\n             let (pos, col) = if pos == 0 {\n-                (pos + 1, annotation.end_col + 1)\n+                (pos + 1, annotation.end_col + 1 - margin)\n             } else {\n-                (pos + 2, annotation.start_col)\n+                (pos + 2, annotation.start_col - margin)\n             };\n             if let Some(ref label) = annotation.label {\n                 buffer.puts(line_offset + pos,\n@@ -639,7 +670,7 @@ impl EmitterWriter {\n             };\n             for p in annotation.start_col..annotation.end_col {\n                 buffer.putc(line_offset + 1,\n-                            code_offset + p,\n+                            code_offset + p - margin,\n                             underline,\n                             style);\n             }\n@@ -1037,6 +1068,51 @@ impl EmitterWriter {\n                 // Contains the vertical lines' positions for active multiline annotations\n                 let mut multilines = FxHashMap::default();\n \n+                // Get the left-side margin to remove it\n+                let mut margin = std::usize::MAX;\n+                for line_idx in 0..annotated_file.lines.len() {\n+                    let file = annotated_file.file.clone();\n+                    let line = &annotated_file.lines[line_idx];\n+                    if let Some(source_string) = file.get_line(line.line_index - 1) {\n+                        let leading_whitespace = source_string\n+                            .chars()\n+                            .take_while(|c| c.is_whitespace())\n+                            .count();\n+                        if source_string.chars().any(|c| !c.is_whitespace()) {\n+                            margin = std::cmp::min(margin, leading_whitespace);\n+                        }\n+                    }\n+                }\n+                if margin >= 20 { // On errors with generous margins, trim it\n+                    margin = margin - 16; // Keep at least 4 spaces margin\n+                } else if margin == std::usize::MAX || !self.strip_margin {\n+                    margin = 0;\n+                }\n+\n+                // Left-most column any visible span points at.\n+                let mut span_left_margin = std::usize::MAX;\n+                for line in &annotated_file.lines {\n+                    for ann in &line.annotations {\n+                        span_left_margin = std::cmp::min(span_left_margin, ann.start_col);\n+                        span_left_margin = std::cmp::min(span_left_margin, ann.end_col);\n+                    }\n+                }\n+                if span_left_margin == std::usize::MAX {\n+                    span_left_margin = 0;\n+                }\n+                if span_left_margin > 160 {\n+                    margin = std::cmp::max(margin, span_left_margin - 100);\n+                }\n+\n+                // Right-most column any visible span points at.\n+                let mut span_right_margin = 0;\n+                for line in &annotated_file.lines {\n+                    for ann in &line.annotations {\n+                        span_right_margin = std::cmp::max(span_right_margin, ann.start_col);\n+                        span_right_margin = std::cmp::max(span_right_margin, ann.end_col);\n+                    }\n+                }\n+\n                 // Next, output the annotate source for this file\n                 for line_idx in 0..annotated_file.lines.len() {\n                     let previous_buffer_line = buffer.num_lines();\n@@ -1048,11 +1124,15 @@ impl EmitterWriter {\n                         width_offset + annotated_file.multiline_depth + 1\n                     };\n \n-                    let depths = self.render_source_line(&mut buffer,\n-                                                         annotated_file.file.clone(),\n-                                                         &annotated_file.lines[line_idx],\n-                                                         width_offset,\n-                                                         code_offset);\n+                    let depths = self.render_source_line(\n+                        &mut buffer,\n+                        annotated_file.file.clone(),\n+                        &annotated_file.lines[line_idx],\n+                        width_offset,\n+                        code_offset,\n+                        margin,\n+                        span_right_margin,\n+                    );\n \n                     let mut to_add = FxHashMap::default();\n \n@@ -1107,9 +1187,15 @@ impl EmitterWriter {\n                             draw_col_separator(&mut buffer,\n                                                last_buffer_line_num,\n                                                1 + max_line_num_len);\n+                            let left_margin = std::cmp::min(margin, unannotated_line.len());\n+                            let right_margin = if unannotated_line.len() > span_right_margin + 120 {\n+                                span_right_margin + 120\n+                            } else {\n+                                unannotated_line.len()\n+                            };\n                             buffer.puts(last_buffer_line_num,\n                                         code_offset,\n-                                        &unannotated_line,\n+                                        &unannotated_line[left_margin..right_margin],\n                                         Style::Quotation);\n \n                             for (depth, style) in &multilines {"}, {"sha": "d5c1cf51dafaa38f8ef7fd8f335b2036f111555b", "filename": "src/test/ui/inline-asm-bad-operand.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e668e0496fcc13fa042be416b64ba6823669cca/src%2Ftest%2Fui%2Finline-asm-bad-operand.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e668e0496fcc13fa042be416b64ba6823669cca/src%2Ftest%2Fui%2Finline-asm-bad-operand.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-asm-bad-operand.stderr?ref=0e668e0496fcc13fa042be416b64ba6823669cca", "patch": "@@ -37,8 +37,8 @@ LL |         asm!(\"mov sp, $0\"::\"r\"(addr),\n error[E0669]: invalid value for constraint in inline assembly\n   --> $DIR/inline-asm-bad-operand.rs:56:32\n    |\n-LL |                            \"r\"(\"hello e0669\"));\n-   |                                ^^^^^^^^^^^^^\n+LL | ...             \"r\"(\"hello e0669\"));\n+   |                     ^^^^^^^^^^^^^\n \n error: aborting due to 7 previous errors\n "}, {"sha": "3262662a2a5e6f07b1e5839d965386b85d7616db", "filename": "src/test/ui/lint/issue-47390-unused-variable-in-struct-pattern.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e668e0496fcc13fa042be416b64ba6823669cca/src%2Ftest%2Fui%2Flint%2Fissue-47390-unused-variable-in-struct-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e668e0496fcc13fa042be416b64ba6823669cca/src%2Ftest%2Fui%2Flint%2Fissue-47390-unused-variable-in-struct-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-47390-unused-variable-in-struct-pattern.stderr?ref=0e668e0496fcc13fa042be416b64ba6823669cca", "patch": "@@ -38,8 +38,8 @@ LL |     if let SoulHistory { corridors_of_light,\n warning: variable `hours_are_suns` is assigned to, but never used\n   --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:38:30\n    |\n-LL |                          mut hours_are_suns,\n-   |                              ^^^^^^^^^^^^^^\n+LL | ...             mut hours_are_suns,\n+   |                     ^^^^^^^^^^^^^^\n    |\n    = note: consider using `_hours_are_suns` instead\n "}, {"sha": "fe44d3a29dab51cba1ba9492f5058d3052ee2951", "filename": "src/test/ui/methods/method-missing-call.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e668e0496fcc13fa042be416b64ba6823669cca/src%2Ftest%2Fui%2Fmethods%2Fmethod-missing-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e668e0496fcc13fa042be416b64ba6823669cca/src%2Ftest%2Fui%2Fmethods%2Fmethod-missing-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-missing-call.stderr?ref=0e668e0496fcc13fa042be416b64ba6823669cca", "patch": "@@ -1,8 +1,8 @@\n error[E0615]: attempted to take value of method `get_x` on type `Point`\n   --> $DIR/method-missing-call.rs:22:26\n    |\n-LL |                         .get_x;\n-   |                          ^^^^^ help: use parentheses to call the method: `get_x()`\n+LL | ...             .get_x;\n+   |                  ^^^^^ help: use parentheses to call the method: `get_x()`\n \n error[E0615]: attempted to take value of method `filter_map` on type `std::iter::Filter<std::iter::Map<std::slice::Iter<'_, {integer}>, [closure@$DIR/method-missing-call.rs:27:20: 27:25]>, [closure@$DIR/method-missing-call.rs:28:23: 28:35]>`\n   --> $DIR/method-missing-call.rs:29:16"}, {"sha": "6eff7b06d53a56bae514774beae03944cd574576", "filename": "src/test/ui/moves/moves-based-on-type-no-recursive-stack-closure.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0e668e0496fcc13fa042be416b64ba6823669cca/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-no-recursive-stack-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e668e0496fcc13fa042be416b64ba6823669cca/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-no-recursive-stack-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-no-recursive-stack-closure.stderr?ref=0e668e0496fcc13fa042be416b64ba6823669cca", "patch": "@@ -1,11 +1,11 @@\n error[E0499]: cannot borrow `*f` as mutable more than once at a time\n   --> $DIR/moves-based-on-type-no-recursive-stack-closure.rs:20:27\n    |\n-LL |                     (f.c)(f, true);\n-   |                     ----- ^ second mutable borrow occurs here\n-   |                     |\n-   |                     first mutable borrow occurs here\n-   |                     first borrow later used by call\n+LL | ...             (f.c)(f, true);\n+   |                 ----- ^ second mutable borrow occurs here\n+   |                 |\n+   |                 first mutable borrow occurs here\n+   |                 first borrow later used by call\n \n error[E0382]: borrow of moved value: `f`\n   --> $DIR/moves-based-on-type-no-recursive-stack-closure.rs:32:5"}, {"sha": "fe0345c3a380c0969e0f4d6cc9544c88dc3b5049", "filename": "src/test/ui/regions/regions-name-undeclared.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e668e0496fcc13fa042be416b64ba6823669cca/src%2Ftest%2Fui%2Fregions%2Fregions-name-undeclared.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e668e0496fcc13fa042be416b64ba6823669cca/src%2Ftest%2Fui%2Fregions%2Fregions-name-undeclared.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-name-undeclared.stderr?ref=0e668e0496fcc13fa042be416b64ba6823669cca", "patch": "@@ -49,14 +49,14 @@ LL | fn fn_types(a: &'a isize,\n error[E0261]: use of undeclared lifetime name `'b`\n   --> $DIR/regions-name-undeclared.rs:42:36\n    |\n-LL |                                   &'b isize,\n-   |                                    ^^ undeclared lifetime\n+LL | ...             &'b isize,\n+   |                  ^^ undeclared lifetime\n \n error[E0261]: use of undeclared lifetime name `'b`\n   --> $DIR/regions-name-undeclared.rs:45:36\n    |\n-LL |                                   &'b isize)>,\n-   |                                    ^^ undeclared lifetime\n+LL | ...             &'b isize)>,\n+   |                  ^^ undeclared lifetime\n \n error[E0261]: use of undeclared lifetime name `'a`\n   --> $DIR/regions-name-undeclared.rs:46:17"}]}