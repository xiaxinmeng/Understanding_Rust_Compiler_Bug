{"sha": "bc8317a12aff35c6a85d7727628429f0f3758234", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjODMxN2ExMmFmZjM1YzZhODVkNzcyNzYyODQyOWYwZjM3NTgyMzQ=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-12-06T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-12-06T00:00:00Z"}, "message": "Compress RWU from at least 32 bits to 4 bits\n\nThe liveness uses a mixed representation of RWUs based on the\nobservation that most of them have invalid reader and invalid\nwriter. The packed variant uses 32 bits and unpacked 96 bits.\nUnpacked data contains reader live node and writer live node.\n\nSince live nodes are used only to determine their validity,\nRWUs can always be stored in a packed form with four bits for\neach: reader bit, writer bit, used bit, and one extra padding\nbit to simplify packing and unpacking operations.", "tree": {"sha": "d7e356369c163e3aa75e87247f7473f75037d7b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7e356369c163e3aa75e87247f7473f75037d7b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc8317a12aff35c6a85d7727628429f0f3758234", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc8317a12aff35c6a85d7727628429f0f3758234", "html_url": "https://github.com/rust-lang/rust/commit/bc8317a12aff35c6a85d7727628429f0f3758234", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc8317a12aff35c6a85d7727628429f0f3758234/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d577c535b4fac58c63c850b97d45b66993c6df3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d577c535b4fac58c63c850b97d45b66993c6df3d", "html_url": "https://github.com/rust-lang/rust/commit/d577c535b4fac58c63c850b97d45b66993c6df3d"}], "stats": {"total": 305, "additions": 146, "deletions": 159}, "files": [{"sha": "8c4fe549d12ed790d055e0a8f56130e7eb2cba94", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 146, "deletions": 159, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/bc8317a12aff35c6a85d7727628429f0f3758234/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc8317a12aff35c6a85d7727628429f0f3758234/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=bc8317a12aff35c6a85d7727628429f0f3758234", "patch": "@@ -470,96 +470,144 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n \n #[derive(Clone, Copy)]\n struct RWU {\n-    reader: Option<LiveNode>,\n-    writer: Option<LiveNode>,\n+    reader: bool,\n+    writer: bool,\n     used: bool,\n }\n \n-/// Conceptually, this is like a `Vec<RWU>`. But the number of `RWU`s can get\n-/// very large, so it uses a more compact representation that takes advantage\n-/// of the fact that when the number of `RWU`s is large, most of them have an\n-/// invalid reader and an invalid writer.\n+/// Conceptually, this is like a `Vec<Vec<RWU>>`. But the number of\n+/// RWU`s can get very large, so it uses a more compact representation.\n struct RWUTable {\n-    /// Each entry in `packed_rwus` is either INV_INV_FALSE, INV_INV_TRUE, or\n-    /// an index into `unpacked_rwus`. In the common cases, this compacts the\n-    /// 65 bits of data into 32; in the uncommon cases, it expands the 65 bits\n-    /// in 96.\n+    /// Total number of live nodes.\n+    live_nodes: usize,\n+    /// Total number of variables.\n+    vars: usize,\n+\n+    /// A compressed representation of `RWU`s.\n+    ///\n+    /// Each word represents 2 different `RWU`s packed together. Each packed RWU\n+    /// is stored in 4 bits: a reader bit, a writer bit, a used bit and a\n+    /// padding bit.\n     ///\n-    /// More compact representations are possible -- e.g., use only 2 bits per\n-    /// packed `RWU` and make the secondary table a HashMap that maps from\n-    /// indices to `RWU`s -- but this one strikes a good balance between size\n-    /// and speed.\n-    packed_rwus: Vec<u32>,\n-    unpacked_rwus: Vec<RWU>,\n+    /// The data for each live node is contiguous and starts at a word boundary,\n+    /// so there might be an unused space left.\n+    words: Vec<u8>,\n+    /// Number of words per each live node.\n+    live_node_words: usize,\n }\n \n-// A constant representing `RWU { reader: None; writer: None; used: false }`.\n-const INV_INV_FALSE: u32 = u32::MAX;\n-\n-// A constant representing `RWU { reader: None; writer: None; used: true }`.\n-const INV_INV_TRUE: u32 = u32::MAX - 1;\n-\n impl RWUTable {\n-    fn new(num_rwus: usize) -> RWUTable {\n-        Self { packed_rwus: vec![INV_INV_FALSE; num_rwus], unpacked_rwus: vec![] }\n+    const RWU_READER: u8 = 0b0001;\n+    const RWU_WRITER: u8 = 0b0010;\n+    const RWU_USED: u8 = 0b0100;\n+    const RWU_MASK: u8 = 0b1111;\n+\n+    /// Size of packed RWU in bits.\n+    const RWU_BITS: usize = 4;\n+    /// Size of a word in bits.\n+    const WORD_BITS: usize = std::mem::size_of::<u8>() * 8;\n+    /// Number of packed RWUs that fit into a single word.\n+    const WORD_RWU_COUNT: usize = Self::WORD_BITS / Self::RWU_BITS;\n+\n+    fn new(live_nodes: usize, vars: usize) -> RWUTable {\n+        let live_node_words = (vars + Self::WORD_RWU_COUNT - 1) / Self::WORD_RWU_COUNT;\n+        Self { live_nodes, vars, live_node_words, words: vec![0u8; live_node_words * live_nodes] }\n+    }\n+\n+    fn word_and_shift(&self, ln: LiveNode, var: Variable) -> (usize, u32) {\n+        assert!(ln.index() < self.live_nodes);\n+        assert!(var.index() < self.vars);\n+\n+        let var = var.index();\n+        let word = var / Self::WORD_RWU_COUNT;\n+        let shift = Self::RWU_BITS * (var % Self::WORD_RWU_COUNT);\n+        (ln.index() * self.live_node_words + word, shift as u32)\n+    }\n+\n+    fn pick2_rows_mut(&mut self, a: LiveNode, b: LiveNode) -> (&mut [u8], &mut [u8]) {\n+        assert!(a.index() < self.live_nodes);\n+        assert!(b.index() < self.live_nodes);\n+        assert!(a != b);\n+\n+        let a_start = a.index() * self.live_node_words;\n+        let b_start = b.index() * self.live_node_words;\n+\n+        unsafe {\n+            let ptr = self.words.as_mut_ptr();\n+            (\n+                std::slice::from_raw_parts_mut(ptr.add(a_start), self.live_node_words),\n+                std::slice::from_raw_parts_mut(ptr.add(b_start), self.live_node_words),\n+            )\n+        }\n     }\n \n-    fn get(&self, idx: usize) -> RWU {\n-        let packed_rwu = self.packed_rwus[idx];\n-        match packed_rwu {\n-            INV_INV_FALSE => RWU { reader: None, writer: None, used: false },\n-            INV_INV_TRUE => RWU { reader: None, writer: None, used: true },\n-            _ => self.unpacked_rwus[packed_rwu as usize],\n+    fn copy(&mut self, dst: LiveNode, src: LiveNode) {\n+        if dst == src {\n+            return;\n         }\n+\n+        let (dst_row, src_row) = self.pick2_rows_mut(dst, src);\n+        dst_row.copy_from_slice(src_row);\n     }\n \n-    fn get_reader(&self, idx: usize) -> Option<LiveNode> {\n-        let packed_rwu = self.packed_rwus[idx];\n-        match packed_rwu {\n-            INV_INV_FALSE | INV_INV_TRUE => None,\n-            _ => self.unpacked_rwus[packed_rwu as usize].reader,\n+    /// Sets `dst` to the union of `dst` and `src`, returns true if `dst` was\n+    /// changed.\n+    fn union(&mut self, dst: LiveNode, src: LiveNode) -> bool {\n+        if dst == src {\n+            return false;\n         }\n-    }\n \n-    fn get_writer(&self, idx: usize) -> Option<LiveNode> {\n-        let packed_rwu = self.packed_rwus[idx];\n-        match packed_rwu {\n-            INV_INV_FALSE | INV_INV_TRUE => None,\n-            _ => self.unpacked_rwus[packed_rwu as usize].writer,\n+        let mut changed = false;\n+        let (dst_row, src_row) = self.pick2_rows_mut(dst, src);\n+        for (dst_word, src_word) in dst_row.iter_mut().zip(src_row.iter()) {\n+            let old = *dst_word;\n+            let new = *dst_word | src_word;\n+            *dst_word = new;\n+            changed |= old != new;\n         }\n+        changed\n     }\n \n-    fn get_used(&self, idx: usize) -> bool {\n-        let packed_rwu = self.packed_rwus[idx];\n-        match packed_rwu {\n-            INV_INV_FALSE => false,\n-            INV_INV_TRUE => true,\n-            _ => self.unpacked_rwus[packed_rwu as usize].used,\n-        }\n+    fn get_reader(&self, ln: LiveNode, var: Variable) -> bool {\n+        let (word, shift) = self.word_and_shift(ln, var);\n+        (self.words[word] >> shift) & Self::RWU_READER != 0\n     }\n \n-    #[inline]\n-    fn copy_packed(&mut self, dst_idx: usize, src_idx: usize) {\n-        self.packed_rwus[dst_idx] = self.packed_rwus[src_idx];\n+    fn get_writer(&self, ln: LiveNode, var: Variable) -> bool {\n+        let (word, shift) = self.word_and_shift(ln, var);\n+        (self.words[word] >> shift) & Self::RWU_WRITER != 0\n     }\n \n-    fn assign_unpacked(&mut self, idx: usize, rwu: RWU) {\n-        if rwu.reader == None && rwu.writer == None {\n-            // When we overwrite an indexing entry in `self.packed_rwus` with\n-            // `INV_INV_{TRUE,FALSE}` we don't remove the corresponding entry\n-            // from `self.unpacked_rwus`; it's not worth the effort, and we\n-            // can't have entries shifting around anyway.\n-            self.packed_rwus[idx] = if rwu.used { INV_INV_TRUE } else { INV_INV_FALSE }\n-        } else {\n-            // Add a new RWU to `unpacked_rwus` and make `packed_rwus[idx]`\n-            // point to it.\n-            self.packed_rwus[idx] = self.unpacked_rwus.len() as u32;\n-            self.unpacked_rwus.push(rwu);\n+    fn get_used(&self, ln: LiveNode, var: Variable) -> bool {\n+        let (word, shift) = self.word_and_shift(ln, var);\n+        (self.words[word] >> shift) & Self::RWU_USED != 0\n+    }\n+\n+    fn get(&self, ln: LiveNode, var: Variable) -> RWU {\n+        let (word, shift) = self.word_and_shift(ln, var);\n+        let rwu_packed = self.words[word] >> shift;\n+        RWU {\n+            reader: rwu_packed & Self::RWU_READER != 0,\n+            writer: rwu_packed & Self::RWU_WRITER != 0,\n+            used: rwu_packed & Self::RWU_USED != 0,\n         }\n     }\n \n-    fn assign_inv_inv(&mut self, idx: usize) {\n-        self.packed_rwus[idx] = if self.get_used(idx) { INV_INV_TRUE } else { INV_INV_FALSE };\n+    fn set(&mut self, ln: LiveNode, var: Variable, rwu: RWU) {\n+        let mut packed = 0;\n+        if rwu.reader {\n+            packed |= Self::RWU_READER;\n+        }\n+        if rwu.writer {\n+            packed |= Self::RWU_WRITER;\n+        }\n+        if rwu.used {\n+            packed |= Self::RWU_USED;\n+        }\n+\n+        let (word, shift) = self.word_and_shift(ln, var);\n+        let word = &mut self.words[word];\n+        *word = (*word & !(Self::RWU_MASK << shift)) | (packed << shift)\n     }\n }\n \n@@ -613,7 +661,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             upvars,\n             closure_captures,\n             successors: IndexVec::from_elem_n(None, num_live_nodes),\n-            rwu_table: RWUTable::new(num_live_nodes * num_vars),\n+            rwu_table: RWUTable::new(num_live_nodes, num_vars),\n             closure_ln,\n             exit_ln,\n             break_ln: Default::default(),\n@@ -652,61 +700,37 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         succ\n     }\n \n-    fn idx(&self, ln: LiveNode, var: Variable) -> usize {\n-        ln.index() * self.ir.var_kinds.len() + var.index()\n-    }\n-\n-    fn live_on_entry(&self, ln: LiveNode, var: Variable) -> Option<LiveNodeKind> {\n-        if let Some(reader) = self.rwu_table.get_reader(self.idx(ln, var)) {\n-            Some(self.ir.lnks[reader])\n-        } else {\n-            None\n-        }\n+    fn live_on_entry(&self, ln: LiveNode, var: Variable) -> bool {\n+        self.rwu_table.get_reader(ln, var)\n     }\n \n     // Is this variable live on entry to any of its successor nodes?\n-    fn live_on_exit(&self, ln: LiveNode, var: Variable) -> Option<LiveNodeKind> {\n+    fn live_on_exit(&self, ln: LiveNode, var: Variable) -> bool {\n         let successor = self.successors[ln].unwrap();\n         self.live_on_entry(successor, var)\n     }\n \n     fn used_on_entry(&self, ln: LiveNode, var: Variable) -> bool {\n-        self.rwu_table.get_used(self.idx(ln, var))\n+        self.rwu_table.get_used(ln, var)\n     }\n \n-    fn assigned_on_entry(&self, ln: LiveNode, var: Variable) -> Option<LiveNodeKind> {\n-        if let Some(writer) = self.rwu_table.get_writer(self.idx(ln, var)) {\n-            Some(self.ir.lnks[writer])\n-        } else {\n-            None\n-        }\n+    fn assigned_on_entry(&self, ln: LiveNode, var: Variable) -> bool {\n+        self.rwu_table.get_writer(ln, var)\n     }\n \n-    fn assigned_on_exit(&self, ln: LiveNode, var: Variable) -> Option<LiveNodeKind> {\n+    fn assigned_on_exit(&self, ln: LiveNode, var: Variable) -> bool {\n         let successor = self.successors[ln].unwrap();\n         self.assigned_on_entry(successor, var)\n     }\n \n-    fn indices2<F>(&mut self, ln: LiveNode, succ_ln: LiveNode, mut op: F)\n+    fn write_vars<F>(&self, wr: &mut dyn Write, mut test: F) -> io::Result<()>\n     where\n-        F: FnMut(&mut Liveness<'a, 'tcx>, usize, usize),\n+        F: FnMut(Variable) -> bool,\n     {\n-        let node_base_idx = self.idx(ln, Variable::from(0u32));\n-        let succ_base_idx = self.idx(succ_ln, Variable::from(0u32));\n         for var_idx in 0..self.ir.var_kinds.len() {\n-            op(self, node_base_idx + var_idx, succ_base_idx + var_idx);\n-        }\n-    }\n-\n-    fn write_vars<F>(&self, wr: &mut dyn Write, ln: LiveNode, mut test: F) -> io::Result<()>\n-    where\n-        F: FnMut(usize) -> bool,\n-    {\n-        let node_base_idx = self.idx(ln, Variable::from(0u32));\n-        for var_idx in 0..self.ir.var_kinds.len() {\n-            let idx = node_base_idx + var_idx;\n-            if test(idx) {\n-                write!(wr, \" {:?}\", Variable::from(var_idx))?;\n+            let var = Variable::from(var_idx);\n+            if test(var) {\n+                write!(wr, \" {:?}\", var)?;\n             }\n         }\n         Ok(())\n@@ -718,11 +742,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         {\n             let wr = &mut wr as &mut dyn Write;\n             write!(wr, \"[{:?} of kind {:?} reads\", ln, self.ir.lnks[ln]);\n-            self.write_vars(wr, ln, |idx| self.rwu_table.get_reader(idx).is_some());\n+            self.write_vars(wr, |var| self.rwu_table.get_reader(ln, var));\n             write!(wr, \"  writes\");\n-            self.write_vars(wr, ln, |idx| self.rwu_table.get_writer(idx).is_some());\n+            self.write_vars(wr, |var| self.rwu_table.get_writer(ln, var));\n             write!(wr, \"  uses\");\n-            self.write_vars(wr, ln, |idx| self.rwu_table.get_used(idx));\n+            self.write_vars(wr, |var| self.rwu_table.get_used(ln, var));\n \n             write!(wr, \"  precedes {:?}]\", self.successors[ln]);\n         }\n@@ -747,17 +771,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.successors[ln] = Some(succ_ln);\n \n         // It is not necessary to initialize the RWUs here because they are all\n-        // set to INV_INV_FALSE when they are created, and the sets only grow\n-        // during iterations.\n+        // empty when created, and the sets only grow during iterations.\n     }\n \n     fn init_from_succ(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n         // more efficient version of init_empty() / merge_from_succ()\n         self.successors[ln] = Some(succ_ln);\n-\n-        self.indices2(ln, succ_ln, |this, idx, succ_idx| {\n-            this.rwu_table.copy_packed(idx, succ_idx);\n-        });\n+        self.rwu_table.copy(ln, succ_ln);\n         debug!(\"init_from_succ(ln={}, succ={})\", self.ln_str(ln), self.ln_str(succ_ln));\n     }\n \n@@ -766,81 +786,48 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             return false;\n         }\n \n-        let mut any_changed = false;\n-        self.indices2(ln, succ_ln, |this, idx, succ_idx| {\n-            // This is a special case, pulled out from the code below, where we\n-            // don't have to do anything. It occurs about 60-70% of the time.\n-            if this.rwu_table.packed_rwus[succ_idx] == INV_INV_FALSE {\n-                return;\n-            }\n-\n-            let mut changed = false;\n-            let mut rwu = this.rwu_table.get(idx);\n-            let succ_rwu = this.rwu_table.get(succ_idx);\n-            if succ_rwu.reader.is_some() && rwu.reader.is_none() {\n-                rwu.reader = succ_rwu.reader;\n-                changed = true\n-            }\n-\n-            if succ_rwu.writer.is_some() && rwu.writer.is_none() {\n-                rwu.writer = succ_rwu.writer;\n-                changed = true\n-            }\n-\n-            if succ_rwu.used && !rwu.used {\n-                rwu.used = true;\n-                changed = true;\n-            }\n-\n-            if changed {\n-                this.rwu_table.assign_unpacked(idx, rwu);\n-                any_changed = true;\n-            }\n-        });\n-\n+        let changed = self.rwu_table.union(ln, succ_ln);\n         debug!(\n             \"merge_from_succ(ln={:?}, succ={}, first_merge={}, changed={})\",\n             ln,\n             self.ln_str(succ_ln),\n             first_merge,\n-            any_changed\n+            changed\n         );\n-        any_changed\n+        changed\n     }\n \n     // Indicates that a local variable was *defined*; we know that no\n     // uses of the variable can precede the definition (resolve checks\n     // this) so we just clear out all the data.\n     fn define(&mut self, writer: LiveNode, var: Variable) {\n-        let idx = self.idx(writer, var);\n-        self.rwu_table.assign_inv_inv(idx);\n-\n-        debug!(\"{:?} defines {:?} (idx={}): {}\", writer, var, idx, self.ln_str(writer));\n+        let used = self.rwu_table.get_used(writer, var);\n+        self.rwu_table.set(writer, var, RWU { reader: false, writer: false, used });\n+        debug!(\"{:?} defines {:?}: {}\", writer, var, self.ln_str(writer));\n     }\n \n     // Either read, write, or both depending on the acc bitset\n     fn acc(&mut self, ln: LiveNode, var: Variable, acc: u32) {\n         debug!(\"{:?} accesses[{:x}] {:?}: {}\", ln, acc, var, self.ln_str(ln));\n \n-        let idx = self.idx(ln, var);\n-        let mut rwu = self.rwu_table.get(idx);\n+        let mut rwu = self.rwu_table.get(ln, var);\n \n         if (acc & ACC_WRITE) != 0 {\n-            rwu.reader = None;\n-            rwu.writer = Some(ln);\n+            rwu.reader = false;\n+            rwu.writer = true;\n         }\n \n         // Important: if we both read/write, must do read second\n         // or else the write will override.\n         if (acc & ACC_READ) != 0 {\n-            rwu.reader = Some(ln);\n+            rwu.reader = true;\n         }\n \n         if (acc & ACC_USE) != 0 {\n             rwu.used = true;\n         }\n \n-        self.rwu_table.assign_unpacked(idx, rwu);\n+        self.rwu_table.set(ln, var, rwu);\n     }\n \n     fn compute(&mut self, body: &hir::Body<'_>, hir_id: HirId) -> LiveNode {\n@@ -1575,7 +1562,7 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                 ty::UpvarCapture::ByRef(..) => continue,\n             };\n             if self.used_on_entry(entry_ln, var) {\n-                if self.live_on_entry(entry_ln, var).is_none() {\n+                if !self.live_on_entry(entry_ln, var) {\n                     if let Some(name) = self.should_warn(var) {\n                         self.ir.tcx.struct_span_lint_hir(\n                             lint::builtin::UNUSED_ASSIGNMENTS,\n@@ -1609,7 +1596,7 @@ impl<'tcx> Liveness<'_, 'tcx> {\n     fn warn_about_unused_args(&self, body: &hir::Body<'_>, entry_ln: LiveNode) {\n         for p in body.params {\n             self.check_unused_vars_in_pat(&p.pat, Some(entry_ln), |spans, hir_id, ln, var| {\n-                if self.live_on_entry(ln, var).is_none() {\n+                if !self.live_on_entry(ln, var) {\n                     self.report_unsed_assign(hir_id, spans, var, |name| {\n                         format!(\"value passed to `{}` is never read\", name)\n                     });\n@@ -1658,7 +1645,7 @@ impl<'tcx> Liveness<'_, 'tcx> {\n             // {ret}`, there is only one node, so asking about\n             // assigned_on_exit() is not meaningful.\n             let is_assigned =\n-                if ln == self.exit_ln { false } else { self.assigned_on_exit(ln, var).is_some() };\n+                if ln == self.exit_ln { false } else { self.assigned_on_exit(ln, var) };\n \n             if is_assigned {\n                 self.ir.tcx.struct_span_lint_hir(\n@@ -1725,7 +1712,7 @@ impl<'tcx> Liveness<'_, 'tcx> {\n     }\n \n     fn warn_about_dead_assign(&self, spans: Vec<Span>, hir_id: HirId, ln: LiveNode, var: Variable) {\n-        if self.live_on_exit(ln, var).is_none() {\n+        if !self.live_on_exit(ln, var) {\n             self.report_unsed_assign(hir_id, spans, var, |name| {\n                 format!(\"value assigned to `{}` is never read\", name)\n             });"}]}