{"sha": "2efcff7f75a9a88d50600d4208db6b33be2705e3", "node_id": "C_kwDOAAsO6NoAKDJlZmNmZjdmNzVhOWE4OGQ1MDYwMGQ0MjA4ZGI2YjMzYmUyNzA1ZTM", "commit": {"author": {"name": "vi_mi", "email": "fenil.jain2018@vitstudent.ac.in", "date": "2021-10-12T07:58:10Z"}, "committer": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2021-10-16T10:36:06Z"}, "message": "fix: Adding tuple fields in ADT, chore: test action section\nunindentation", "tree": {"sha": "9e2962cb06ccde2b6245708652c50f809357e21d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e2962cb06ccde2b6245708652c50f809357e21d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2efcff7f75a9a88d50600d4208db6b33be2705e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2efcff7f75a9a88d50600d4208db6b33be2705e3", "html_url": "https://github.com/rust-lang/rust/commit/2efcff7f75a9a88d50600d4208db6b33be2705e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2efcff7f75a9a88d50600d4208db6b33be2705e3/comments", "author": {"login": "feniljain", "id": 49019259, "node_id": "MDQ6VXNlcjQ5MDE5MjU5", "avatar_url": "https://avatars.githubusercontent.com/u/49019259?v=4", "gravatar_id": "", "url": "https://api.github.com/users/feniljain", "html_url": "https://github.com/feniljain", "followers_url": "https://api.github.com/users/feniljain/followers", "following_url": "https://api.github.com/users/feniljain/following{/other_user}", "gists_url": "https://api.github.com/users/feniljain/gists{/gist_id}", "starred_url": "https://api.github.com/users/feniljain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/feniljain/subscriptions", "organizations_url": "https://api.github.com/users/feniljain/orgs", "repos_url": "https://api.github.com/users/feniljain/repos", "events_url": "https://api.github.com/users/feniljain/events{/privacy}", "received_events_url": "https://api.github.com/users/feniljain/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "227490c06935d7f901b027621ef77d85aa7cac8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/227490c06935d7f901b027621ef77d85aa7cac8a", "html_url": "https://github.com/rust-lang/rust/commit/227490c06935d7f901b027621ef77d85aa7cac8a"}], "stats": {"total": 361, "additions": 190, "deletions": 171}, "files": [{"sha": "e466b3990e659c3df3ca9a5814523724dae060f2", "filename": "crates/ide_assists/src/handlers/extract_module.rs", "status": "modified", "additions": 190, "deletions": 171, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/2efcff7f75a9a88d50600d4208db6b33be2705e3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2efcff7f75a9a88d50600d4208db6b33be2705e3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_module.rs?ref=2efcff7f75a9a88d50600d4208db6b33be2705e3", "patch": "@@ -100,6 +100,8 @@ pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n         \"Extract Module\",\n         module.text_range,\n         |builder| {\n+            let _ = &module;\n+\n             let mut body_items = Vec::new();\n             let new_item_indent = old_item_indent + 1;\n             for item in module.body_items {\n@@ -148,7 +150,7 @@ struct Module {\n }\n \n fn extract_target(node: &SyntaxNode, selection_range: TextRange) -> Option<Module> {\n-    let body_items: Vec<ast::Item> = node\n+    let mut body_items: Vec<ast::Item> = node\n         .children()\n         .filter_map(|child| {\n             if let Some(item) = ast::Item::cast(child.clone()) {\n@@ -161,6 +163,10 @@ fn extract_target(node: &SyntaxNode, selection_range: TextRange) -> Option<Modul\n         })\n         .collect();\n \n+    if let Some(node_item) = ast::Item::cast(node.clone()) {\n+        body_items.push(node_item);\n+    }\n+\n     Some(Module { text_range: selection_range, name: \"modname\".to_string(), body_items })\n }\n \n@@ -169,7 +175,7 @@ impl Module {\n         &self,\n         ctx: &AssistContext,\n     ) -> (HashMap<FileId, Vec<(TextRange, String)>>, Vec<SyntaxNode>) {\n-        let mut record_fields = Vec::new();\n+        let mut adt_fields = Vec::new();\n         let mut refs: HashMap<FileId, Vec<(TextRange, String)>> = HashMap::new();\n \n         //Here impl is not included as each item inside impl will be tied to the parent of\n@@ -183,18 +189,31 @@ impl Module {\n                             let node_def = Definition::ModuleDef(nod.into());\n                             self.expand_and_group_usages_file_wise(ctx, node_def, &mut refs);\n \n-                            let mut get_record_fields = |it: ast::Adt| {\n-                                for desc in it.syntax().descendants() {\n-                                    if let Some(record_field) = ast::RecordField::cast(desc) {\n-                                        record_fields.push(record_field.syntax().clone());\n-                                    }\n-                                }\n-                            };\n-\n                             //Enum Fields are not allowed to explicitly specify pub, it is implied\n                             match it {\n-                                ast::Adt::Struct(_) => get_record_fields(it),\n-                                ast::Adt::Union(_) => get_record_fields(it),\n+                                ast::Adt::Struct(x) => {\n+                                    if let Some(field_list) = x.field_list() {\n+                                        match field_list {\n+                                            ast::FieldList::RecordFieldList(record_field_list) => {\n+                                                record_field_list.fields().for_each(|record_field| {\n+                                                    adt_fields.push(record_field.syntax().clone());\n+                                                });\n+                                            },\n+                                            ast::FieldList::TupleFieldList(tuple_field_list) => {\n+                                                tuple_field_list.fields().for_each(|tuple_field| {\n+                                                    adt_fields.push(tuple_field.syntax().clone());\n+                                                });\n+                                            },\n+                                        }\n+                                    }\n+                                },\n+                                ast::Adt::Union(x) => {\n+                                        if let Some(record_field_list) = x.record_field_list() {\n+                                            record_field_list.fields().for_each(|record_field| {\n+                                                    adt_fields.push(record_field.syntax().clone());\n+                                            });\n+                                        }\n+                                },\n                                 ast::Adt::Enum(_) => {},\n                             }\n                         }\n@@ -228,7 +247,7 @@ impl Module {\n             }\n         });\n \n-        return (refs, record_fields);\n+        return (refs, adt_fields);\n     }\n \n     fn expand_and_group_usages_file_wise(\n@@ -881,9 +900,9 @@ mod tests {\n         check_assist_not_applicable(\n             extract_module,\n             r\"\n-                $0pub struct PublicStruct {\n-                    field: i32,\n-                }\n+$0pub struct PublicStruct {\n+    field: i32,\n+}\n             \",\n         )\n     }\n@@ -920,25 +939,25 @@ mod tests {\n                     let _a = bar();\n                 }\n \n-                $0\n-                struct PrivateStruct {\n-                    inner: SomeType,\n-                }\n+$0\n+struct PrivateStruct {\n+    inner: SomeType,\n+}\n \n-                pub struct PrivateStruct1 {\n-                    pub inner: i32,\n-                }\n+pub struct PrivateStruct1 {\n+    pub inner: i32,\n+}\n \n-                impl PrivateStruct {\n-                    fn new() -> Self {\n-                         PrivateStruct { inner: SomeType }\n-                    }\n-                }\n+impl PrivateStruct {\n+    fn new() -> Self {\n+         PrivateStruct { inner: SomeType }\n+    }\n+}\n \n-                fn bar() -> i32 {\n-                    2\n-                }\n-                $0\n+fn bar() -> i32 {\n+    2\n+}\n+$0\n             }\n             \",\n             r\"\n@@ -969,27 +988,27 @@ mod tests {\n                     let _a = modname::bar();\n                 }\n \n-                mod modname {\n-                    use crate::thirdpartycrate::nest::SomeType;\n+mod modname {\n+    use crate::thirdpartycrate::nest::SomeType;\n \n-                    pub(crate) struct PrivateStruct {\n-                        pub(crate) inner: SomeType,\n-                    }\n+    pub(crate) struct PrivateStruct {\n+        pub(crate) inner: SomeType,\n+    }\n \n-                    pub(crate) struct PrivateStruct1 {\n-                        pub(crate) inner: i32,\n-                    }\n+    pub(crate) struct PrivateStruct1 {\n+        pub(crate) inner: i32,\n+    }\n \n-                    impl PrivateStruct {\n-                        pub(crate) fn new() -> Self {\n-                             PrivateStruct { inner: SomeType }\n-                        }\n-                    }\n+    impl PrivateStruct {\n+        pub(crate) fn new() -> Self {\n+             PrivateStruct { inner: SomeType }\n+        }\n+    }\n \n-                    pub(crate) fn bar() -> i32 {\n-                        2\n-                    }\n-                }\n+    pub(crate) fn bar() -> i32 {\n+        2\n+    }\n+}\n             }\n             \",\n         );\n@@ -1000,22 +1019,22 @@ mod tests {\n         check_assist(\n             extract_module,\n             r\"\n-                $0\n-                fn foo(name: i32) -> i32 {\n-                    name + 1\n-                }\n-                $0\n+$0\n+fn foo(name: i32) -> i32 {\n+    name + 1\n+}\n+$0\n \n                 fn bar(name: i32) -> i32 {\n                     name + 2\n                 }\n             \",\n             r\"\n-                mod modname {\n-                    pub(crate) fn foo(name: i32) -> i32 {\n-                        name + 1\n-                    }\n-                }\n+mod modname {\n+    pub(crate) fn foo(name: i32) -> i32 {\n+        name + 1\n+    }\n+}\n \n                 fn bar(name: i32) -> i32 {\n                     name + 2\n@@ -1030,15 +1049,15 @@ mod tests {\n             extract_module,\n             r\"\n             mod impl_play {\n-                $0\n-                struct A {}\n+$0\n+struct A {}\n \n-                impl A {\n-                    pub fn new_a() -> i32 {\n-                        2\n-                    }\n-                }\n-                $0\n+impl A {\n+    pub fn new_a() -> i32 {\n+        2\n+    }\n+}\n+$0\n \n                 fn a() {\n                     let _a = A::new_a();\n@@ -1047,15 +1066,15 @@ mod tests {\n             \",\n             r\"\n             mod impl_play {\n-                mod modname {\n-                    pub(crate) struct A {}\n+mod modname {\n+    pub(crate) struct A {}\n \n-                    impl A {\n-                        pub(crate) fn new_a() -> i32 {\n-                            2\n-                        }\n-                    }\n-                }\n+    impl A {\n+        pub(crate) fn new_a() -> i32 {\n+            2\n+        }\n+    }\n+}\n \n                 fn a() {\n                     let _a = modname::A::new_a();\n@@ -1078,11 +1097,11 @@ mod tests {\n             mod bar {\n                 use super::foo::{PrivateStruct, PrivateStruct1};\n \n-                $0\n-                struct Strukt {\n-                    field: PrivateStruct,\n-                }\n-                $0\n+$0\n+struct Strukt {\n+    field: PrivateStruct,\n+}\n+$0\n \n                 struct Strukt1 {\n                     field: PrivateStruct1,\n@@ -1098,13 +1117,13 @@ mod tests {\n             mod bar {\n                 use super::foo::{PrivateStruct1};\n \n-                mod modname {\n-                    use super::super::foo::PrivateStruct;\n+mod modname {\n+    use super::super::foo::PrivateStruct;\n \n-                    pub(crate) struct Strukt {\n-                        pub(crate) field: PrivateStruct,\n-                    }\n-                }\n+    pub(crate) struct Strukt {\n+        pub(crate) field: PrivateStruct,\n+    }\n+}\n \n                 struct Strukt1 {\n                     field: PrivateStruct1,\n@@ -1126,11 +1145,11 @@ mod tests {\n             mod bar {\n                 use super::foo::PrivateStruct;\n \n-                $0\n-                struct Strukt {\n-                    field: PrivateStruct,\n-                }\n-                $0\n+$0\n+struct Strukt {\n+    field: PrivateStruct,\n+}\n+$0\n \n                 struct Strukt1 {\n                     field: PrivateStruct,\n@@ -1145,13 +1164,13 @@ mod tests {\n             mod bar {\n                 use super::foo::PrivateStruct;\n \n-                mod modname {\n-                    use super::super::foo::PrivateStruct;\n+mod modname {\n+    use super::super::foo::PrivateStruct;\n \n-                    pub(crate) struct Strukt {\n-                        pub(crate) field: PrivateStruct,\n-                    }\n-                }\n+    pub(crate) struct Strukt {\n+        pub(crate) field: PrivateStruct,\n+    }\n+}\n \n                 struct Strukt1 {\n                     field: PrivateStruct,\n@@ -1169,11 +1188,11 @@ mod tests {\n             mod bar {\n                 pub struct PrivateStruct;\n \n-                $0\n-                struct Strukt {\n-                    field: PrivateStruct,\n-                }\n-                $0\n+$0\n+struct Strukt {\n+    field: PrivateStruct,\n+}\n+$0\n \n                 struct Strukt1 {\n                     field: PrivateStruct,\n@@ -1184,13 +1203,13 @@ mod tests {\n             mod bar {\n                 pub struct PrivateStruct;\n \n-                mod modname {\n-                    use super::PrivateStruct;\n+mod modname {\n+    use super::PrivateStruct;\n \n-                    pub(crate) struct Strukt {\n-                        pub(crate) field: PrivateStruct,\n-                    }\n-                }\n+    pub(crate) struct Strukt {\n+        pub(crate) field: PrivateStruct,\n+    }\n+}\n \n                 struct Strukt1 {\n                     field: PrivateStruct,\n@@ -1208,13 +1227,13 @@ mod tests {\n             mod impl_play {\n                 struct A {}\n \n-                $0\n-                impl A {\n-                    pub fn new_a() -> i32 {\n-                        2\n-                    }\n-                }\n-                $0\n+$0\n+impl A {\n+    pub fn new_a() -> i32 {\n+        2\n+    }\n+}\n+$0\n \n                 fn a() {\n                     let _a = A::new_a();\n@@ -1225,15 +1244,15 @@ mod tests {\n             mod impl_play {\n                 struct A {}\n \n-                mod modname {\n-                    use super::A;\n+mod modname {\n+    use super::A;\n \n-                    impl A {\n-                        pub(crate) fn new_a() -> i32 {\n-                            2\n-                        }\n-                    }\n-                }\n+    impl A {\n+        pub(crate) fn new_a() -> i32 {\n+            2\n+        }\n+    }\n+}\n \n                 fn a() {\n                     let _a = A::new_a();\n@@ -1255,13 +1274,13 @@ mod tests {\n             mod impl_play {\n                 use super::foo::A;\n \n-                $0\n-                impl A {\n-                    pub fn new_a() -> i32 {\n-                        2\n-                    }\n-                }\n-                $0\n+$0\n+impl A {\n+    pub fn new_a() -> i32 {\n+        2\n+    }\n+}\n+$0\n \n                 fn a() {\n                     let _a = A::new_a();\n@@ -1275,15 +1294,15 @@ mod tests {\n             mod impl_play {\n                 use super::foo::A;\n \n-                mod modname {\n-                    use super::super::foo::A;\n+mod modname {\n+    use super::super::foo::A;\n \n-                    impl A {\n-                        pub(crate) fn new_a() -> i32 {\n-                            2\n-                        }\n-                    }\n-                }\n+    impl A {\n+        pub(crate) fn new_a() -> i32 {\n+            2\n+        }\n+    }\n+}\n \n                 fn a() {\n                     let _a = A::new_a();\n@@ -1301,42 +1320,42 @@ mod tests {\n             mod impl_play2 {\n                 trait JustATrait {}\n \n-                $0\n-                struct A {}\n+$0\n+struct A {}\n \n-                fn foo<T: JustATrait>(arg: T) -> T {\n-                    arg\n-                }\n+fn foo<T: JustATrait>(arg: T) -> T {\n+    arg\n+}\n \n-                impl JustATrait for A {}\n+impl JustATrait for A {}\n \n-                fn bar() {\n-                    let a = A {};\n-                    foo(a);\n-                }\n-                $0\n+fn bar() {\n+    let a = A {};\n+    foo(a);\n+}\n+$0\n             }\n             \",\n             r\"\n             mod impl_play2 {\n                 trait JustATrait {}\n \n-                mod modname {\n-                    use super::JustATrait;\n+mod modname {\n+    use super::JustATrait;\n \n-                    pub(crate) struct A {}\n+    pub(crate) struct A {}\n \n-                    pub(crate) fn foo<T: JustATrait>(arg: T) -> T {\n-                        arg\n-                    }\n+    pub(crate) fn foo<T: JustATrait>(arg: T) -> T {\n+        arg\n+    }\n \n-                    impl JustATrait for A {}\n+    impl JustATrait for A {}\n \n-                    pub(crate) fn bar() {\n-                        let a = A {};\n-                        foo(a);\n-                    }\n-                }\n+    pub(crate) fn bar() {\n+        let a = A {};\n+        foo(a);\n+    }\n+}\n             }\n             \",\n         )\n@@ -1348,20 +1367,20 @@ mod tests {\n             extract_module,\n             r\"\n             mod impl_play2 {\n-                $0\n-                mod impl_play {\n-                    pub struct A {}\n-                }\n-                $0\n+$0\n+mod impl_play {\n+    pub struct A {}\n+}\n+$0\n             }\n             \",\n             r\"\n             mod impl_play2 {\n-                mod modname {\n-                    pub(crate) mod impl_play {\n-                        pub struct A {}\n-                    }\n-                }\n+mod modname {\n+    pub(crate) mod impl_play {\n+        pub struct A {}\n+    }\n+}\n             }\n             \",\n         )"}]}