{"sha": "dd240707999216a64e7914c2290cb59c54d9c60c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkMjQwNzA3OTk5MjE2YTY0ZTc5MTRjMjI5MGNiNTljNTRkOWM2MGM=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-04-03T00:51:38Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-04-21T16:09:41Z"}, "message": "Check for shadowing between lifetimes and loop labels in function bodies.\n\nNote: this Warns rather than error on shadowing problems involving labels.\nWe took this more conservative option mostly due to issues with\nhygiene being broken for labels and/or lifetimes.\n\nAdd FIXME regarding non-hygienic comparison.", "tree": {"sha": "e34e58d1cec8e748fb957e1084c51b61ff26e1e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e34e58d1cec8e748fb957e1084c51b61ff26e1e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd240707999216a64e7914c2290cb59c54d9c60c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd240707999216a64e7914c2290cb59c54d9c60c", "html_url": "https://github.com/rust-lang/rust/commit/dd240707999216a64e7914c2290cb59c54d9c60c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd240707999216a64e7914c2290cb59c54d9c60c/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77acda1c8ee75f9eb923ddd811ee591951b2d43f", "url": "https://api.github.com/repos/rust-lang/rust/commits/77acda1c8ee75f9eb923ddd811ee591951b2d43f", "html_url": "https://github.com/rust-lang/rust/commit/77acda1c8ee75f9eb923ddd811ee591951b2d43f"}], "stats": {"total": 213, "additions": 201, "deletions": 12}, "files": [{"sha": "6f40e17855a78255779a033ee4015b32323672f7", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 201, "deletions": 12, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/dd240707999216a64e7914c2290cb59c54d9c60c/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd240707999216a64e7914c2290cb59c54d9c60c/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=dd240707999216a64e7914c2290cb59c54d9c60c", "patch": "@@ -24,6 +24,7 @@ use middle::region;\n use middle::subst;\n use middle::ty;\n use std::fmt;\n+use std::mem::replace;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token::special_idents;\n@@ -70,6 +71,9 @@ struct LifetimeContext<'a> {\n \n     // I'm sorry.\n     trait_ref_hack: bool,\n+\n+    // List of labels in the function/method currently under analysis.\n+    labels_in_fn: Vec<(ast::Ident, Span)>,\n }\n \n enum ScopeChain<'a> {\n@@ -97,13 +101,18 @@ pub fn krate(sess: &Session, krate: &ast::Crate, def_map: &DefMap) -> NamedRegio\n         scope: &ROOT_SCOPE,\n         def_map: def_map,\n         trait_ref_hack: false,\n+        labels_in_fn: vec![],\n     }, krate);\n     sess.abort_if_errors();\n     named_region_map\n }\n \n impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     fn visit_item(&mut self, item: &ast::Item) {\n+        // Items save/restore the set of labels. This way innner items\n+        // can freely reuse names, be they loop labels or lifetimes.\n+        let saved = replace(&mut self.labels_in_fn, vec![]);\n+\n         // Items always introduce a new root scope\n         self.with(RootScope, |_, this| {\n             match item.node {\n@@ -137,23 +146,26 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                 }\n             }\n         });\n+\n+        // Done traversing the item; restore saved set of labels.\n+        replace(&mut self.labels_in_fn, saved);\n     }\n \n     fn visit_fn(&mut self, fk: visit::FnKind<'v>, fd: &'v ast::FnDecl,\n                 b: &'v ast::Block, s: Span, _: ast::NodeId) {\n         match fk {\n             visit::FkItemFn(_, generics, _, _, _) => {\n                 self.visit_early_late(subst::FnSpace, generics, |this| {\n-                    visit::walk_fn(this, fk, fd, b, s)\n+                    this.walk_fn(fk, fd, b, s)\n                 })\n             }\n             visit::FkMethod(_, sig, _) => {\n                 self.visit_early_late(subst::FnSpace, &sig.generics, |this| {\n-                    visit::walk_fn(this, fk, fd, b, s)\n+                    this.walk_fn(fk, fd, b, s)\n                 })\n             }\n             visit::FkFnBlock(..) => {\n-                visit::walk_fn(self, fk, fd, b, s)\n+                self.walk_fn(fk, fd, b, s)\n             }\n         }\n     }\n@@ -190,13 +202,19 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n+        // We reset the labels on every trait item, so that different\n+        // methods in an impl can reuse label names.\n+        let saved = replace(&mut self.labels_in_fn, vec![]);\n+\n         if let ast::MethodTraitItem(ref sig, None) = trait_item.node {\n             self.visit_early_late(\n                 subst::FnSpace, &sig.generics,\n                 |this| visit::walk_trait_item(this, trait_item))\n         } else {\n             visit::walk_trait_item(self, trait_item);\n         }\n+\n+        replace(&mut self.labels_in_fn, saved);\n     }\n \n     fn visit_block(&mut self, b: &ast::Block) {\n@@ -286,7 +304,170 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq)]\n+enum ShadowKind { Label, Lifetime }\n+struct Original { kind: ShadowKind, span: Span }\n+struct Shadower { kind: ShadowKind, span: Span }\n+\n+fn original_label(span: Span) -> Original {\n+    Original { kind: ShadowKind::Label, span: span }\n+}\n+fn shadower_label(span: Span) -> Shadower {\n+    Shadower { kind: ShadowKind::Label, span: span }\n+}\n+fn original_lifetime(l: &ast::Lifetime) -> Original {\n+    Original { kind: ShadowKind::Lifetime, span: l.span }\n+}\n+fn shadower_lifetime(l: &ast::Lifetime) -> Shadower {\n+    Shadower { kind: ShadowKind::Lifetime, span: l.span }\n+}\n+\n+impl ShadowKind {\n+    fn desc(&self) -> &'static str {\n+        match *self {\n+            ShadowKind::Label => \"label\",\n+            ShadowKind::Lifetime => \"lifetime\",\n+        }\n+    }\n+}\n+\n+fn signal_shadowing_problem(\n+    sess: &Session, name: ast::Name, orig: Original, shadower: Shadower) {\n+    if let (ShadowKind::Lifetime, ShadowKind::Lifetime) = (orig.kind, shadower.kind) {\n+        // lifetime/lifetime shadowing is an error\n+        sess.span_err(shadower.span,\n+                      &format!(\"{} name `{}` shadows a \\\n+                                {} name that is already in scope\",\n+                               shadower.kind.desc(), name, orig.kind.desc()));\n+    } else {\n+        // shadowing involving a label is only a warning, due to issues with\n+        // labels and lifetimes not being macro-hygienic.\n+        sess.span_warn(shadower.span,\n+                      &format!(\"{} name `{}` shadows a \\\n+                                {} name that is already in scope\",\n+                               shadower.kind.desc(), name, orig.kind.desc()));\n+    }\n+    sess.span_note(orig.span,\n+                   &format!(\"shadowed {} `{}` declared here\",\n+                            orig.kind.desc(), name));\n+}\n+\n+// Adds all labels in `b` to `ctxt.labels_in_fn`, signalling a warning\n+// if one of the label shadows a lifetime or another label.\n+fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v ast::Block) {\n+\n+    struct GatherLabels<'a> {\n+        sess: &'a Session,\n+        scope: Scope<'a>,\n+        labels_in_fn: &'a mut Vec<(ast::Ident, Span)>,\n+    }\n+\n+    let mut gather = GatherLabels {\n+        sess: ctxt.sess,\n+        scope: ctxt.scope,\n+        labels_in_fn: &mut ctxt.labels_in_fn,\n+    };\n+    gather.visit_block(b);\n+    return;\n+\n+    impl<'v, 'a> Visitor<'v> for GatherLabels<'a> {\n+        fn visit_expr(&mut self, ex: &'v ast::Expr) {\n+            if let Some(label) = expression_label(ex) {\n+                for &(prior, prior_span) in &self.labels_in_fn[..] {\n+                    // FIXME (#24278): non-hygienic comparision\n+                    if label.name == prior.name {\n+                        signal_shadowing_problem(self.sess,\n+                                                 label.name,\n+                                                 original_label(prior_span),\n+                                                 shadower_label(ex.span));\n+                    }\n+                }\n+\n+                check_if_label_shadows_lifetime(self.sess,\n+                                                self.scope,\n+                                                label,\n+                                                ex.span);\n+\n+                self.labels_in_fn.push((label, ex.span));\n+            }\n+            visit::walk_expr(self, ex)\n+        }\n+\n+        fn visit_item(&mut self, _: &ast::Item) {\n+            // do not recurse into items defined in the block\n+        }\n+    }\n+\n+    fn expression_label(ex: &ast::Expr) -> Option<ast::Ident> {\n+        match ex.node {\n+            ast::ExprWhile(_, _, Some(label))       |\n+            ast::ExprWhileLet(_, _, _, Some(label)) |\n+            ast::ExprForLoop(_, _, _, Some(label))  |\n+            ast::ExprLoop(_, Some(label))          => Some(label),\n+            _ => None,\n+        }\n+    }\n+\n+    fn check_if_label_shadows_lifetime<'a>(sess: &'a Session,\n+                                           mut scope: Scope<'a>,\n+                                           label: ast::Ident,\n+                                           label_span: Span) {\n+        loop {\n+            match *scope {\n+                BlockScope(_, s) => { scope = s; }\n+                RootScope => { return; }\n+\n+                EarlyScope(_, lifetimes, s) |\n+                LateScope(lifetimes, s) => {\n+                    for lifetime_def in lifetimes {\n+                        // FIXME (#24278): non-hygienic comparision\n+                        if label.name == lifetime_def.lifetime.name {\n+                            signal_shadowing_problem(\n+                                sess,\n+                                label.name,\n+                                original_lifetime(&lifetime_def.lifetime),\n+                                shadower_label(label_span));\n+                            return;\n+                        }\n+                    }\n+                    scope = s;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n impl<'a> LifetimeContext<'a> {\n+    // This is just like visit::walk_fn, except that it extracts the\n+    // labels of the function body and swaps them in before visiting\n+    // the function body itself.\n+    fn walk_fn<'b>(&mut self,\n+                   fk: visit::FnKind,\n+                   fd: &ast::FnDecl,\n+                   fb: &'b ast::Block,\n+                   _span: Span) {\n+        match fk {\n+            visit::FkItemFn(_, generics, _, _, _) => {\n+                visit::walk_fn_decl(self, fd);\n+                self.visit_generics(generics);\n+            }\n+            visit::FkMethod(_, sig, _) => {\n+                visit::walk_fn_decl(self, fd);\n+                self.visit_generics(&sig.generics);\n+                self.visit_explicit_self(&sig.explicit_self);\n+            }\n+            visit::FkFnBlock(..) => {\n+                visit::walk_fn_decl(self, fd);\n+            }\n+        }\n+\n+        // After inpsecting the decl, add all labels from the body to\n+        // `self.labels_in_fn`.\n+        extract_labels(self, fb);\n+\n+        self.visit_block(fb);\n+    }\n+\n     fn with<F>(&mut self, wrap_scope: ScopeChain, f: F) where\n         F: FnOnce(Scope, &mut LifetimeContext),\n     {\n@@ -297,6 +478,7 @@ impl<'a> LifetimeContext<'a> {\n             scope: &wrap_scope,\n             def_map: self.def_map,\n             trait_ref_hack: self.trait_ref_hack,\n+            labels_in_fn: self.labels_in_fn.clone(),\n         };\n         debug!(\"entering scope {:?}\", this.scope);\n         f(self.scope, &mut this);\n@@ -494,6 +676,17 @@ impl<'a> LifetimeContext<'a> {\n                                         mut old_scope: Scope,\n                                         lifetime: &ast::Lifetime)\n     {\n+        for &(label, label_span) in &self.labels_in_fn {\n+            // FIXME (#24278): non-hygienic comparision\n+            if lifetime.name == label.name {\n+                signal_shadowing_problem(self.sess,\n+                                         lifetime.name,\n+                                         original_label(label_span),\n+                                         shadower_lifetime(&lifetime));\n+                return;\n+            }\n+        }\n+\n         loop {\n             match *old_scope {\n                 BlockScope(_, s) => {\n@@ -507,15 +700,11 @@ impl<'a> LifetimeContext<'a> {\n                 EarlyScope(_, lifetimes, s) |\n                 LateScope(lifetimes, s) => {\n                     if let Some((_, lifetime_def)) = search_lifetimes(lifetimes, lifetime) {\n-                        self.sess.span_err(\n-                            lifetime.span,\n-                            &format!(\"lifetime name `{}` shadows another \\\n-                                     lifetime name that is already in scope\",\n-                                     token::get_name(lifetime.name)));\n-                        self.sess.span_note(\n-                            lifetime_def.span,\n-                            &format!(\"shadowed lifetime `{}` declared here\",\n-                                     token::get_name(lifetime.name)));\n+                        signal_shadowing_problem(\n+                            self.sess,\n+                            lifetime.name,\n+                            original_lifetime(&lifetime_def),\n+                            shadower_lifetime(&lifetime));\n                         return;\n                     }\n "}]}