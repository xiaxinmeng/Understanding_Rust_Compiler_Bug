{"sha": "14cb85809b39c4bdaa19d119cded25a8dffe8692", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0Y2I4NTgwOWIzOWM0YmRhYTE5ZDExOWNkZWQyNWE4ZGZmZTg2OTI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-20T20:20:33Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-20T20:24:06Z"}, "message": "always test alignment in memory.rs", "tree": {"sha": "310da2b328f48ca4e9964cec7da5eff4b211fd9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/310da2b328f48ca4e9964cec7da5eff4b211fd9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14cb85809b39c4bdaa19d119cded25a8dffe8692", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14cb85809b39c4bdaa19d119cded25a8dffe8692", "html_url": "https://github.com/rust-lang/rust/commit/14cb85809b39c4bdaa19d119cded25a8dffe8692", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14cb85809b39c4bdaa19d119cded25a8dffe8692/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f822ad5c637f0e2d51370a9ea45c3a21f5e2d7dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/f822ad5c637f0e2d51370a9ea45c3a21f5e2d7dd", "html_url": "https://github.com/rust-lang/rust/commit/f822ad5c637f0e2d51370a9ea45c3a21f5e2d7dd"}], "stats": {"total": 68, "additions": 52, "deletions": 16}, "files": [{"sha": "481744b11c4905b37053bb60258e4161b60ef716", "filename": "src/memory.rs", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/14cb85809b39c4bdaa19d119cded25a8dffe8692/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14cb85809b39c4bdaa19d119cded25a8dffe8692/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=14cb85809b39c4bdaa19d119cded25a8dffe8692", "patch": "@@ -194,7 +194,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n \n         let ptr = self.allocate(bytes.len() as u64, 1, Kind::UninitializedStatic)?;\n-        self.write_bytes(PrimVal::Ptr(ptr), bytes)?;\n+        self.write_bytes(ptr.into(), bytes)?;\n         self.mark_static_initalized(ptr.alloc_id, Mutability::Immutable)?;\n         self.literal_alloc_cache.insert(bytes.to_vec(), ptr.alloc_id);\n         Ok(ptr)\n@@ -280,6 +280,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.layout.endian\n     }\n \n+    /// Check that the pointer is aligned and non-NULL\n     pub fn check_align(&self, ptr: Pointer, align: u64) -> EvalResult<'tcx> {\n         let offset = match ptr.into_inner_primval() {\n             PrimVal::Ptr(ptr) => {\n@@ -532,13 +533,13 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n /// Byte accessors\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     fn get_bytes_unchecked(&self, ptr: MemoryPointer, size: u64, align: u64) -> EvalResult<'tcx, &[u8]> {\n-        if size == 0 {\n-            return Ok(&[]);\n-        }\n-        // FIXME: check alignment for zst memory accesses?\n+        // Zero-sized accesses can use dangling pointers, but they still have to be aligned and non-NULL\n         if self.reads_are_aligned {\n             self.check_align(ptr.into(), align)?;\n         }\n+        if size == 0 {\n+            return Ok(&[]);\n+        }\n         self.check_bounds(ptr.offset(size, self.layout)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get(ptr.alloc_id)?;\n         assert_eq!(ptr.offset as usize as u64, ptr.offset);\n@@ -548,13 +549,13 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     fn get_bytes_unchecked_mut(&mut self, ptr: MemoryPointer, size: u64, align: u64) -> EvalResult<'tcx, &mut [u8]> {\n-        if size == 0 {\n-            return Ok(&mut []);\n-        }\n-        // FIXME: check alignment for zst memory accesses?\n+        // Zero-sized accesses can use dangling pointers, but they still have to be aligned and non-NULL\n         if self.writes_are_aligned {\n             self.check_align(ptr.into(), align)?;\n         }\n+        if size == 0 {\n+            return Ok(&mut []);\n+        }\n         self.check_bounds(ptr.offset(size, self.layout)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get_mut(ptr.alloc_id)?;\n         assert_eq!(ptr.offset as usize as u64, ptr.offset);\n@@ -643,7 +644,13 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     pub fn copy(&mut self, src: Pointer, dest: Pointer, size: u64, align: u64, nonoverlapping: bool) -> EvalResult<'tcx> {\n         if size == 0 {\n-            // TODO: Should we check for alignment here? (Also see write_bytes intrinsic)\n+            // Empty accesses don't need to be valid pointers, but they should still be aligned\n+            if self.reads_are_aligned {\n+                self.check_align(src, align)?;\n+            }\n+            if self.writes_are_aligned {\n+                self.check_align(dest, align)?;\n+            }\n             return Ok(());\n         }\n         let src = src.to_ptr()?;\n@@ -695,13 +702,21 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     pub fn read_bytes(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, &[u8]> {\n         if size == 0 {\n+            // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n+            if self.reads_are_aligned {\n+                self.check_align(ptr, 1)?;\n+            }\n             return Ok(&[]);\n         }\n         self.get_bytes(ptr.to_ptr()?, size, 1)\n     }\n \n-    pub fn write_bytes(&mut self, ptr: PrimVal, src: &[u8]) -> EvalResult<'tcx> {\n+    pub fn write_bytes(&mut self, ptr: Pointer, src: &[u8]) -> EvalResult<'tcx> {\n         if src.is_empty() {\n+            // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n+            if self.writes_are_aligned {\n+                self.check_align(ptr, 1)?;\n+            }\n             return Ok(());\n         }\n         let bytes = self.get_bytes_mut(ptr.to_ptr()?, src.len() as u64, 1)?;\n@@ -711,6 +726,10 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: u64) -> EvalResult<'tcx> {\n         if count == 0 {\n+            // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n+            if self.writes_are_aligned {\n+                self.check_align(ptr, 1)?;\n+            }\n             return Ok(());\n         }\n         let bytes = self.get_bytes_mut(ptr.to_ptr()?, count, 1)?;"}, {"sha": "2be5b7666f0517cb09b7fce65243b3b9c6ffbd57", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/14cb85809b39c4bdaa19d119cded25a8dffe8692/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14cb85809b39c4bdaa19d119cded25a8dffe8692/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=14cb85809b39c4bdaa19d119cded25a8dffe8692", "patch": "@@ -143,11 +143,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"copy_nonoverlapping\" => {\n                 let elem_ty = substs.type_at(0);\n                 let elem_size = self.type_size(elem_ty)?.expect(\"cannot copy unsized value\");\n-                if elem_size != 0 {\n+                let count = self.value_to_primval(arg_vals[2], usize)?.to_u64()?;\n+                if count * elem_size != 0 {\n+                    // TODO: We do not even validate alignment for the 0-bytes case.  libstd relies on this in vec::IntoIter::next.\n+                    // Also see the write_bytes intrinsic.\n                     let elem_align = self.type_align(elem_ty)?;\n                     let src = arg_vals[0].into_ptr(&mut self.memory)?;\n                     let dest = arg_vals[1].into_ptr(&mut self.memory)?;\n-                    let count = self.value_to_primval(arg_vals[2], usize)?.to_u64()?;\n                     self.memory.copy(src, dest, count * elem_size, elem_align, intrinsic_name.ends_with(\"_nonoverlapping\"))?;\n                 }\n             }\n@@ -465,7 +467,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ptr = arg_vals[0].into_ptr(&mut self.memory)?;\n                 let count = self.value_to_primval(arg_vals[2], usize)?.to_u64()?;\n                 if count > 0 {\n-                    // TODO: Should we, at least, validate the alignment? (Also see memory::copy)\n+                    // HashMap relies on write_bytes on a NULL ptr with count == 0 to work\n+                    // TODO: Should we, at least, validate the alignment? (Also see the copy intrinsic)\n                     self.memory.check_align(ptr, ty_align)?;\n                     self.memory.write_repeat(ptr, val_byte, size * count)?;\n                 }"}, {"sha": "12cec11b72315ea75365ded2a6305e43c5b86591", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14cb85809b39c4bdaa19d119cded25a8dffe8692/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14cb85809b39c4bdaa19d119cded25a8dffe8692/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=14cb85809b39c4bdaa19d119cded25a8dffe8692", "patch": "@@ -813,8 +813,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 if let Some((name, value)) = new {\n                     // +1 for the null terminator\n                     let value_copy = self.memory.allocate((value.len() + 1) as u64, 1, Kind::Env)?;\n-                    self.memory.write_bytes(PrimVal::Ptr(value_copy), &value)?;\n-                    self.memory.write_bytes(PrimVal::Ptr(value_copy.offset(value.len() as u64, self.memory.layout)?), &[0])?;\n+                    self.memory.write_bytes(value_copy.into(), &value)?;\n+                    self.memory.write_bytes(value_copy.offset(value.len() as u64, self.memory.layout)?.into(), &[0])?;\n                     if let Some(var) = self.env_vars.insert(name.to_owned(), value_copy) {\n                         self.memory.deallocate(var, None, Kind::Env)?;\n                     }"}, {"sha": "fc603840684e8b0369274e0e37d197a0b1ac313d", "filename": "tests/compile-fail/unaligned_ptr_cast_zst.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/14cb85809b39c4bdaa19d119cded25a8dffe8692/tests%2Fcompile-fail%2Funaligned_ptr_cast_zst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14cb85809b39c4bdaa19d119cded25a8dffe8692/tests%2Fcompile-fail%2Funaligned_ptr_cast_zst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funaligned_ptr_cast_zst.rs?ref=14cb85809b39c4bdaa19d119cded25a8dffe8692", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let x = &2u16;\n+    let x = x as *const _ as *const [u32; 0];\n+    // This must fail because alignment is violated.  Test specifically for loading ZST.\n+    let _x = unsafe { *x }; //~ ERROR: tried to access memory with alignment 2, but alignment 4 is required\n+}"}, {"sha": "776791bbc9b9ee1394231bb2080f4aaadee14155", "filename": "tests/run-pass-fullmir/vecs.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/14cb85809b39c4bdaa19d119cded25a8dffe8692/tests%2Frun-pass-fullmir%2Fvecs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14cb85809b39c4bdaa19d119cded25a8dffe8692/tests%2Frun-pass-fullmir%2Fvecs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fvecs.rs?ref=14cb85809b39c4bdaa19d119cded25a8dffe8692", "patch": "@@ -24,6 +24,13 @@ fn vec_into_iter() -> u8 {\n         .fold(0, |x, y| x + y)\n }\n \n+fn vec_into_iter_zst() -> usize {\n+    vec![[0u64; 0], [0u64; 0]]\n+        .into_iter()\n+        .map(|x| x.len())\n+        .sum()\n+}\n+\n fn vec_reallocate() -> Vec<u8> {\n     let mut v = vec![1, 2];\n     v.push(3);\n@@ -35,6 +42,7 @@ fn vec_reallocate() -> Vec<u8> {\n fn main() {\n     assert_eq!(vec_reallocate().len(), 5);\n     assert_eq!(vec_into_iter(), 30);\n+    assert_eq!(vec_into_iter_zst(), 0);\n     assert_eq!(make_vec().capacity(), 4);\n     assert_eq!(make_vec_macro(), [1, 2]);\n     assert_eq!(make_vec_macro_repeat(), [42; 5]);"}]}