{"sha": "279de38cc8d1c1a1c68d714b9384da32c240e420", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3OWRlMzhjYzhkMWMxYTFjNjhkNzE0YjkzODRkYTMyYzI0MGU0MjA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-06T02:50:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-06T22:28:37Z"}, "message": "Support methods invoked on projection types based on the bounds found in the trait.", "tree": {"sha": "9719257ed895e45d7ceb832134e8d149e99ba611", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9719257ed895e45d7ceb832134e8d149e99ba611"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/279de38cc8d1c1a1c68d714b9384da32c240e420", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/279de38cc8d1c1a1c68d714b9384da32c240e420", "html_url": "https://github.com/rust-lang/rust/commit/279de38cc8d1c1a1c68d714b9384da32c240e420", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/279de38cc8d1c1a1c68d714b9384da32c240e420/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcc23238fd40c568cf3f7e1a2947ebb93277091e", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcc23238fd40c568cf3f7e1a2947ebb93277091e", "html_url": "https://github.com/rust-lang/rust/commit/fcc23238fd40c568cf3f7e1a2947ebb93277091e"}], "stats": {"total": 201, "additions": 185, "deletions": 16}, "files": [{"sha": "772d7b2532a7b1dae72f5093b9d2017f77cd06b5", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/279de38cc8d1c1a1c68d714b9384da32c240e420/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279de38cc8d1c1a1c68d714b9384da32c240e420/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=279de38cc8d1c1a1c68d714b9384da32c240e420", "patch": "@@ -427,6 +427,16 @@ impl<'tcx> Combineable<'tcx> for ty::TraitRef<'tcx> {\n     }\n }\n \n+impl<'tcx> Combineable<'tcx> for Ty<'tcx> {\n+    fn combine<C:Combine<'tcx>>(combiner: &C,\n+                                a: &Ty<'tcx>,\n+                                b: &Ty<'tcx>)\n+                                -> cres<'tcx, Ty<'tcx>>\n+    {\n+        combiner.tys(*a, *b)\n+    }\n+}\n+\n impl<'tcx> Combineable<'tcx> for ty::ProjectionPredicate<'tcx> {\n     fn combine<C:Combine<'tcx>>(combiner: &C,\n                                 a: &ty::ProjectionPredicate<'tcx>,"}, {"sha": "05b8d9da06fe521cec04ce4a4d57bfd57e872d61", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/279de38cc8d1c1a1c68d714b9384da32c240e420/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279de38cc8d1c1a1c68d714b9384da32c240e420/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=279de38cc8d1c1a1c68d714b9384da32c240e420", "patch": "@@ -39,7 +39,7 @@ use util::ppaux::{ty_to_string};\n use util::ppaux::{Repr, UserString};\n \n use self::coercion::Coerce;\n-use self::combine::{Combine, CombineFields};\n+use self::combine::{Combine, Combineable, CombineFields};\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n use self::equate::Equate;\n use self::sub::Sub;\n@@ -360,17 +360,9 @@ pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n     })\n }\n \n-pub fn can_mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                             a: Ty<'tcx>, b: Ty<'tcx>)\n-                             -> ures<'tcx> {\n-    debug!(\"can_mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n-    cx.probe(|_| {\n-        let trace = TypeTrace {\n-            origin: Misc(codemap::DUMMY_SP),\n-            values: Types(expected_found(true, a, b))\n-        };\n-        cx.equate(true, trace).tys(a, b)\n-    }).to_ures()\n+pub fn can_mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> ures<'tcx>\n+{\n+    cx.can_equate(&a, &b)\n }\n \n pub fn mk_subr<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n@@ -1072,6 +1064,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         self.region_vars.verify_generic_bound(origin, kind, a, bs);\n     }\n+\n+    pub fn can_equate<T>(&self, a: &T, b: &T) -> ures<'tcx>\n+        where T : Combineable<'tcx> + Repr<'tcx>\n+    {\n+        debug!(\"can_equate({}, {})\", a.repr(self.tcx), b.repr(self.tcx));\n+        self.probe(|_| {\n+            // Gin up a dummy trace, since this won't be committed\n+            // anyhow. We should make this typetrace stuff more\n+            // generic so we don't have to do anything quite this\n+            // terrible.\n+            let e = self.tcx.types.err;\n+            let trace = TypeTrace { origin: Misc(codemap::DUMMY_SP),\n+                                    values: Types(expected_found(true, e, e)) };\n+            let eq = self.equate(true, trace);\n+            Combineable::combine(&eq, a, b)\n+        }).to_ures()\n+    }\n }\n \n impl<'tcx> TypeTrace<'tcx> {"}, {"sha": "5227dc0a83a7d456f102ba75cb743298838f8abd", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/279de38cc8d1c1a1c68d714b9384da32c240e420/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279de38cc8d1c1a1c68d714b9384da32c240e420/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=279de38cc8d1c1a1c68d714b9384da32c240e420", "patch": "@@ -394,7 +394,7 @@ impl<T> VecPerParamSpace<T> {\n         self.content.as_slice()\n     }\n \n-    pub fn to_vec(self) -> Vec<T> {\n+    pub fn into_vec(self) -> Vec<T> {\n         self.content\n     }\n "}, {"sha": "df246a9ed4173cb8a4c7a7f98d1d87c4485d6b6a", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/279de38cc8d1c1a1c68d714b9384da32c240e420/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279de38cc8d1c1a1c68d714b9384da32c240e420/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=279de38cc8d1c1a1c68d714b9384da32c240e420", "patch": "@@ -641,7 +641,7 @@ fn confirm_candidate<'cx,'tcx>(\n             }\n \n             match impl_ty {\n-                Some(ty) => (ty, impl_vtable.nested.to_vec()),\n+                Some(ty) => (ty, impl_vtable.nested.into_vec()),\n                 None => {\n                     // This means that the impl is missing a\n                     // definition for the associated type. This error"}, {"sha": "cdd040a7bc69b785237634340a7acd9287233622", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/279de38cc8d1c1a1c68d714b9384da32c240e420/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279de38cc8d1c1a1c68d714b9384da32c240e420/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=279de38cc8d1c1a1c68d714b9384da32c240e420", "patch": "@@ -835,7 +835,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                bounds.repr(self.tcx()));\n \n         let matching_bound =\n-            util::elaborate_predicates(self.tcx(), bounds.predicates.to_vec())\n+            util::elaborate_predicates(self.tcx(), bounds.predicates.into_vec())\n             .filter_to_traits()\n             .find(\n                 |bound| self.infcx.probe("}, {"sha": "d7a42b59a123bb534d0fd166c85d776e723056b8", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/279de38cc8d1c1a1c68d714b9384da32c240e420/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279de38cc8d1c1a1c68d714b9384da32c240e420/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=279de38cc8d1c1a1c68d714b9384da32c240e420", "patch": "@@ -62,6 +62,7 @@ enum CandidateKind<'tcx> {\n                            subst::Substs<'tcx>, MethodIndex),\n     UnboxedClosureCandidate(/* Trait */ ast::DefId, MethodIndex),\n     WhereClauseCandidate(ty::PolyTraitRef<'tcx>, MethodIndex),\n+    ProjectionCandidate(ast::DefId, MethodIndex),\n }\n \n pub struct Pick<'tcx> {\n@@ -479,6 +480,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                  method.clone(),\n                                                  matching_index);\n \n+        self.assemble_projection_candidates(trait_def_id,\n+                                            method.clone(),\n+                                            matching_index);\n+\n         self.assemble_where_clause_candidates(trait_def_id,\n                                               method,\n                                               matching_index);\n@@ -608,6 +613,64 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n     }\n \n+    fn assemble_projection_candidates(&mut self,\n+                                      trait_def_id: ast::DefId,\n+                                      method: Rc<ty::Method<'tcx>>,\n+                                      method_index: uint)\n+    {\n+        debug!(\"assemble_projection_candidates(\\\n+               trait_def_id={}, \\\n+               method={}, \\\n+               method_index={})\",\n+               trait_def_id.repr(self.tcx()),\n+               method.repr(self.tcx()),\n+               method_index);\n+\n+        for step in self.steps.iter() {\n+            debug!(\"assemble_projection_candidates: step={}\",\n+                   step.repr(self.tcx()));\n+\n+            let projection_trait_ref = match step.self_ty.sty {\n+                ty::ty_projection(ref data) => &data.trait_ref,\n+                _ => continue,\n+            };\n+\n+            debug!(\"assemble_projection_candidates: projection_trait_ref={}\",\n+                   projection_trait_ref.repr(self.tcx()));\n+\n+            let trait_def = ty::lookup_trait_def(self.tcx(), projection_trait_ref.def_id);\n+            let bounds = trait_def.generics.to_bounds(self.tcx(), projection_trait_ref.substs);\n+            let predicates = bounds.predicates.into_vec();\n+            debug!(\"assemble_projection_candidates: predicates={}\",\n+                   predicates.repr(self.tcx()));\n+            for poly_bound in\n+                traits::elaborate_predicates(self.tcx(), predicates)\n+                .filter_map(|p| p.to_opt_poly_trait_ref()) // TODO filter_to_traits()\n+                .filter(|b| b.def_id() == trait_def_id)\n+            {\n+                let bound = self.erase_late_bound_regions(&poly_bound);\n+\n+                debug!(\"assemble_projection_candidates: projection_trait_ref={} bound={}\",\n+                       projection_trait_ref.repr(self.tcx()),\n+                       bound.repr(self.tcx()));\n+\n+                if self.infcx().can_equate(&step.self_ty, &bound.self_ty()).is_ok() {\n+                    let xform_self_ty = self.xform_self_ty(&method, bound.substs);\n+\n+                    debug!(\"assemble_projection_candidates: bound={} xform_self_ty={}\",\n+                           bound.repr(self.tcx()),\n+                           xform_self_ty.repr(self.tcx()));\n+\n+                    self.extension_candidates.push(Candidate {\n+                        xform_self_ty: xform_self_ty,\n+                        method_ty: method.clone(),\n+                        kind: ProjectionCandidate(trait_def_id, method_index)\n+                    });\n+                }\n+            }\n+        }\n+    }\n+\n     fn assemble_where_clause_candidates(&mut self,\n                                         trait_def_id: ast::DefId,\n                                         method_ty: Rc<ty::Method<'tcx>>,\n@@ -616,7 +679,6 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         debug!(\"assemble_where_clause_candidates(trait_def_id={})\",\n                trait_def_id.repr(self.tcx()));\n \n-        // Check whether there are any where-clauses pertaining to this trait.\n         let caller_predicates =\n             self.fcx.inh.param_env.caller_bounds.predicates.as_slice().to_vec();\n         for poly_bound in traits::elaborate_predicates(self.tcx(), caller_predicates)\n@@ -835,6 +897,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                         norm_obligations.iter().all(|o| selcx.evaluate_obligation(o))\n                 }\n \n+                ProjectionCandidate(..) |\n                 ObjectCandidate(..) |\n                 UnboxedClosureCandidate(..) |\n                 WhereClauseCandidate(..) => {\n@@ -1072,6 +1135,9 @@ impl<'tcx> Candidate<'tcx> {\n \n                     WhereClausePick((*trait_ref).clone(), index)\n                 }\n+                ProjectionCandidate(def_id, index) => {\n+                    TraitPick(def_id, index)\n+                }\n             }\n         }\n     }\n@@ -1083,6 +1149,7 @@ impl<'tcx> Candidate<'tcx> {\n             ExtensionImplCandidate(def_id, _, _, _) => ImplSource(def_id),\n             UnboxedClosureCandidate(trait_def_id, _) => TraitSource(trait_def_id),\n             WhereClauseCandidate(ref trait_ref, _) => TraitSource(trait_ref.def_id()),\n+            ProjectionCandidate(trait_def_id, _) => TraitSource(trait_def_id),\n         }\n     }\n \n@@ -1101,6 +1168,9 @@ impl<'tcx> Candidate<'tcx> {\n             WhereClauseCandidate(ref trait_ref, method_num) => {\n                 Some((trait_ref.def_id(), method_num))\n             }\n+            ProjectionCandidate(trait_def_id, method_num) => {\n+                Some((trait_def_id, method_num))\n+            }\n         }\n     }\n }\n@@ -1127,6 +1197,8 @@ impl<'tcx> Repr<'tcx> for CandidateKind<'tcx> {\n                 format!(\"UnboxedClosureCandidate({},{})\", a.repr(tcx), b),\n             WhereClauseCandidate(ref a, ref b) =>\n                 format!(\"WhereClauseCandidate({},{})\", a.repr(tcx), b),\n+            ProjectionCandidate(ref a, ref b) =>\n+                format!(\"ProjectionCandidate({},{})\", a.repr(tcx), b),\n         }\n     }\n }"}, {"sha": "6f72a163981c9d653e480ff4392c5089fa204a7e", "filename": "src/test/run-pass/method-projection.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/279de38cc8d1c1a1c68d714b9384da32c240e420/src%2Ftest%2Frun-pass%2Fmethod-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279de38cc8d1c1a1c68d714b9384da32c240e420/src%2Ftest%2Frun-pass%2Fmethod-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-projection.rs?ref=279de38cc8d1c1a1c68d714b9384da32c240e420", "patch": "@@ -0,0 +1,78 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we can use method notation to call methods based on a\n+// projection bound from a trait. Issue #20469.\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+trait MakeString {\n+    fn make_string(&self) -> String;\n+}\n+\n+impl MakeString for int {\n+    fn make_string(&self) -> String {\n+        format!(\"{}\", *self)\n+    }\n+}\n+\n+impl MakeString for uint {\n+    fn make_string(&self) -> String {\n+        format!(\"{}\", *self)\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+trait Foo {\n+    type F: MakeString;\n+\n+    fn get(&self) -> &Self::F;\n+}\n+\n+fn foo<F:Foo>(f: &F) -> String {\n+    f.get().make_string()\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+struct SomeStruct {\n+    field: int,\n+}\n+\n+impl Foo for SomeStruct {\n+    type F = int;\n+\n+    fn get(&self) -> &int {\n+        &self.field\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+struct SomeOtherStruct {\n+    field: uint,\n+}\n+\n+impl Foo for SomeOtherStruct {\n+    type F = uint;\n+\n+    fn get(&self) -> &uint {\n+        &self.field\n+    }\n+}\n+\n+fn main() {\n+    let x = SomeStruct { field: 22 };\n+    assert_eq!(foo(&x), format!(\"22\"));\n+\n+    let x = SomeOtherStruct { field: 44 };\n+    assert_eq!(foo(&x), format!(\"44\"));\n+}"}]}