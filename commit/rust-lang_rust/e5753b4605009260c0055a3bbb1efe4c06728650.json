{"sha": "e5753b4605009260c0055a3bbb1efe4c06728650", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1NzUzYjQ2MDUwMDkyNjBjMDA1NWEzYmJiMWVmZTRjMDY3Mjg2NTA=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2016-03-11T23:51:35Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2016-03-14T22:05:15Z"}, "message": "Fixes after rebase", "tree": {"sha": "f0e295354b4e7901a49b7729863ac0c7dba7aa5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0e295354b4e7901a49b7729863ac0c7dba7aa5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5753b4605009260c0055a3bbb1efe4c06728650", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5753b4605009260c0055a3bbb1efe4c06728650", "html_url": "https://github.com/rust-lang/rust/commit/e5753b4605009260c0055a3bbb1efe4c06728650", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5753b4605009260c0055a3bbb1efe4c06728650/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e36620dd9c29e39da688d87e1a6566710aa2ccc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e36620dd9c29e39da688d87e1a6566710aa2ccc5", "html_url": "https://github.com/rust-lang/rust/commit/e36620dd9c29e39da688d87e1a6566710aa2ccc5"}], "stats": {"total": 76, "additions": 47, "deletions": 29}, "files": [{"sha": "64d1c992cbf1d475928d82c2a49a6720abdf946b", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e5753b4605009260c0055a3bbb1efe4c06728650/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5753b4605009260c0055a3bbb1efe4c06728650/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=e5753b4605009260c0055a3bbb1efe4c06728650", "patch": "@@ -11,7 +11,6 @@\n //! See `README.md` for high-level documentation\n \n use super::{SelectionContext, Obligation, ObligationCause};\n-use super::util;\n \n use middle::cstore::LOCAL_CRATE;\n use middle::def_id::DefId;"}, {"sha": "5f66e9e6344ad76d6034043ca1d9047c12c4b0de", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e5753b4605009260c0055a3bbb1efe4c06728650/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5753b4605009260c0055a3bbb1efe4c06728650/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=e5753b4605009260c0055a3bbb1efe4c06728650", "patch": "@@ -433,7 +433,10 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n \n     let elaborated_env = unnormalized_env.with_caller_bounds(predicates);\n \n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(elaborated_env), ProjectionMode::AnyFinal);\n+    let infcx = infer::new_infer_ctxt(tcx,\n+                                      &tcx.tables,\n+                                      Some(elaborated_env),\n+                                      ProjectionMode::AnyFinal);\n     let predicates = match fully_normalize(&infcx,\n                                            cause,\n                                            &infcx.parameter_environment.caller_bounds) {"}, {"sha": "e86f3ed01a49d6c8ceb0558259edc58072983417", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5753b4605009260c0055a3bbb1efe4c06728650/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5753b4605009260c0055a3bbb1efe4c06728650/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=e5753b4605009260c0055a3bbb1efe4c06728650", "patch": "@@ -1121,7 +1121,7 @@ fn confirm_impl_candidate<'cx,'tcx>(\n                 tcx.types.err\n             });\n             let substs = translate_substs(selcx.infcx(), impl_def_id, substs, node_item.node);\n-            (ty.subst(tcx, &substs), nested)\n+            (ty.subst(tcx, substs), nested)\n         }\n         None => {\n             tcx.sess.span_bug(obligation.cause.span,\n@@ -1135,7 +1135,9 @@ fn confirm_impl_candidate<'cx,'tcx>(\n ///\n /// Based on the \"projection mode\", this lookup may in fact only examine the\n /// topmost impl. See the comments for `ProjectionMode` for more details.\n-fn assoc_ty_def<'cx, 'tcx>(selcx: &SelectionContext<'cx, 'tcx>, impl_def_id: DefId, assoc_ty_name: ast::Name)\n+fn assoc_ty_def<'cx, 'tcx>(selcx: &SelectionContext<'cx, 'tcx>,\n+                           impl_def_id: DefId,\n+                           assoc_ty_name: ast::Name)\n                            -> Option<specialization_graph::NodeItem<Rc<ty::AssociatedType<'tcx>>>>\n {\n     let trait_def_id = selcx.tcx().impl_trait_ref(impl_def_id).unwrap().def_id;"}, {"sha": "a692fe55a77899e79d5b27a19b8b17280d39cbc0", "filename": "src/librustc/middle/traits/specialize/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e5753b4605009260c0055a3bbb1efe4c06728650/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5753b4605009260c0055a3bbb1efe4c06728650/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fmod.rs?ref=e5753b4605009260c0055a3bbb1efe4c06728650", "patch": "@@ -75,9 +75,9 @@ pub struct Overlap<'a, 'tcx: 'a> {\n /// resolved.\n pub fn translate_substs<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                   source_impl: DefId,\n-                                  source_substs: Substs<'tcx>,\n+                                  source_substs: &'tcx Substs<'tcx>,\n                                   target_node: specialization_graph::Node)\n-                                  -> Substs<'tcx> {\n+                                  -> &'tcx Substs<'tcx> {\n     let source_trait_ref = infcx.tcx\n                                 .impl_trait_ref(source_impl)\n                                 .unwrap()\n@@ -111,7 +111,7 @@ pub fn translate_substs<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     };\n \n     // directly inherent the method generics, since those do not vary across impls\n-    target_substs.with_method_from_subst(&source_substs)\n+    infcx.tcx.mk_substs(target_substs.with_method_from_subst(source_substs))\n }\n \n /// Is impl1 a specialization of impl2?\n@@ -164,7 +164,7 @@ pub fn specializes(tcx: &TyCtxt, impl1_def_id: DefId, impl2_def_id: DefId) -> bo\n     };\n     penv.caller_bounds.extend(normalization_obligations.into_iter().map(|o| o.predicate));\n \n-    // Install the parameter environment, which means we take the predicates of impl1 as assumptions:\n+    // Install the parameter environment, taking the predicates of impl1 as assumptions:\n     infcx.parameter_environment = penv;\n \n     // Attempt to prove that impl2 applies, given all of the above.\n@@ -217,7 +217,7 @@ fn fulfill_implication<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                    infcx.parameter_environment.caller_bounds);\n             Err(())\n         } else {\n-            debug!(\"fulfill_implication: an impl for {:?} specializes {:?} (`where` clauses elided)\",\n+            debug!(\"fulfill_implication: an impl for {:?} specializes {:?}\",\n                    source_trait_ref,\n                    target_trait_ref);\n "}, {"sha": "f2170f75a11fe5cc19d353282d3a0f0ada0a4d60", "filename": "src/librustc/middle/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5753b4605009260c0055a3bbb1efe4c06728650/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5753b4605009260c0055a3bbb1efe4c06728650/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=e5753b4605009260c0055a3bbb1efe4c06728650", "patch": "@@ -97,7 +97,7 @@ impl Graph {\n                 let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, ProjectionMode::Topmost);\n                 let overlap = traits::overlapping_impls(&infcx, possible_sibling, impl_def_id);\n \n-                if let Some(trait_ref) = overlap {\n+                if let Some(impl_header) = overlap {\n                     let le = specializes(tcx, impl_def_id, possible_sibling);\n                     let ge = specializes(tcx, possible_sibling, impl_def_id);\n \n@@ -124,7 +124,7 @@ impl Graph {\n                         // overlap, but no specialization; error out\n                         return Err(Overlap {\n                             with_impl: possible_sibling,\n-                            on_trait_ref: trait_ref,\n+                            on_trait_ref: impl_header.trait_ref.unwrap(),\n                             in_context: infcx,\n                         });\n                     }"}, {"sha": "437672c551464f90cefc2296186a19c4a451ed45", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5753b4605009260c0055a3bbb1efe4c06728650/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5753b4605009260c0055a3bbb1efe4c06728650/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=e5753b4605009260c0055a3bbb1efe4c06728650", "patch": "@@ -22,6 +22,7 @@ use rustc_typeck::middle::resolve_lifetime;\n use rustc_typeck::middle::stability;\n use rustc_typeck::middle::subst;\n use rustc_typeck::middle::subst::Subst;\n+use rustc_typeck::middle::traits::ProjectionMode;\n use rustc_typeck::middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_typeck::middle::ty::relate::TypeRelation;\n use rustc_typeck::middle::infer::{self, TypeOrigin};\n@@ -143,7 +144,10 @@ fn test_env<F>(source_string: &str,\n                                lang_items,\n                                index,\n                                |tcx| {\n-                                   let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+                                   let infcx = infer::new_infer_ctxt(tcx,\n+                                                                     &tcx.tables,\n+                                                                     None,\n+                                                                     ProjectionMode::AnyFinal);\n                                    body(Env { infcx: &infcx });\n                                    let free_regions = FreeRegionMap::new();\n                                    infcx.resolve_regions_and_report_errors(&free_regions,"}, {"sha": "d99e6ff4bf55de40e53fd87fe34b594b44a8d795", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e5753b4605009260c0055a3bbb1efe4c06728650/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5753b4605009260c0055a3bbb1efe4c06728650/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=e5753b4605009260c0055a3bbb1efe4c06728650", "patch": "@@ -13,7 +13,7 @@\n \n use rustc::dep_graph::DepNode;\n use rustc::middle::infer::{self, InferCtxt};\n-use rustc::middle::traits;\n+use rustc::middle::traits::{self, ProjectionMode};\n use rustc::middle::ty::fold::TypeFoldable;\n use rustc::middle::ty::{self, Ty, TyCtxt};\n use rustc::mir::repr::*;\n@@ -582,7 +582,10 @@ impl<'tcx> MirPass<'tcx> for TypeckMir {\n         }\n         let _task = tcx.dep_graph.in_task(DepNode::MirTypeck(id));\n         let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n-        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env));\n+        let infcx = infer::new_infer_ctxt(tcx,\n+                                          &tcx.tables,\n+                                          Some(param_env),\n+                                          ProjectionMode::AnyFinal);\n         let mut checker = TypeChecker::new(&infcx);\n         {\n             let mut verifier = TypeVerifier::new(&mut checker, mir);"}, {"sha": "cea97c1a1e77fc854cdc006a3a64f22580b90863", "filename": "src/librustc_trans/trans/collector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e5753b4605009260c0055a3bbb1efe4c06728650/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5753b4605009260c0055a3bbb1efe4c06728650/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs?ref=e5753b4605009260c0055a3bbb1efe4c06728650", "patch": "@@ -823,7 +823,7 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                     impl_did,\n                                                     tcx.mk_substs(callee_substs),\n                                                     trait_method.name);\n-            Some((impl_method.method.def_id, impl_method.substs))\n+            Some((impl_method.method.def_id, &impl_method.substs))\n         }\n         // If we have a closure or a function pointer, we will also encounter\n         // the concrete closure/function somewhere else (during closure or fn\n@@ -983,7 +983,7 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                             if can_have_local_instance(ccx, impl_method.method.def_id) {\n                                 Some(create_fn_trans_item(ccx,\n                                                           impl_method.method.def_id,\n-                                                          impl_method.substs,\n+                                                          &impl_method.substs,\n                                                           &Substs::trans_empty()))\n                             } else {\n                                 None\n@@ -1163,12 +1163,12 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     // the method type from the impl to substitute into.\n                     let mth = meth::get_impl_method(tcx,\n                                                     impl_def_id,\n-                                                    callee_substs.clone(),\n+                                                    callee_substs,\n                                                     default_impl.name);\n \n                     assert!(mth.is_provided);\n \n-                    let predicates = mth.method.predicates.predicates.subst(tcx, mth.substs);\n+                    let predicates = mth.method.predicates.predicates.subst(tcx, &mth.substs);\n                     if !normalize_and_test_predicates(ccx, predicates.into_vec()) {\n                         continue;\n                     }"}, {"sha": "7397ccc2505f173a3d984591ad7f9ad5645fdfc4", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e5753b4605009260c0055a3bbb1efe4c06728650/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5753b4605009260c0055a3bbb1efe4c06728650/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=e5753b4605009260c0055a3bbb1efe4c06728650", "patch": "@@ -34,7 +34,6 @@ use trans::machine;\n use trans::type_::Type;\n use trans::type_of::*;\n use middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use middle::ty::MethodCall;\n \n use syntax::ast::{self, Name};\n use syntax::attr;\n@@ -110,7 +109,7 @@ pub fn callee_for_trait_impl<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             // those from the impl and those from the method:\n             let impl_substs = vtable_impl.substs.with_method_from(&substs);\n             let substs = ccx.tcx().mk_substs(impl_substs);\n-            let mth = get_impl_method(ccx.tcx(), impl_did, impl_substs, mname);\n+            let mth = get_impl_method(ccx.tcx(), impl_did, substs, mname);\n \n             // Translate the function, bypassing Callee::def.\n             // That is because default methods have the same ID as the\n@@ -318,7 +317,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 trans_fn_ref_with_substs(ccx,\n                                                          mth.method.def_id,\n                                                          None,\n-                                                         mth.substs).val\n+                                                         &mth.substs).val\n                             }\n                             None => nullptr\n                         }\n@@ -431,7 +430,7 @@ pub fn get_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n             // The substitutions we have are on the impl, so we grab\n             // the method type from the impl to substitute into.\n-            let mth = get_impl_method(tcx, impl_id, substs.clone(), name);\n+            let mth = get_impl_method(tcx, impl_id, substs, name);\n \n             debug!(\"get_vtable_methods: mth={:?}\", mth);\n \n@@ -441,7 +440,7 @@ pub fn get_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             // method could then never be called, so we do not want to\n             // try and trans it, in that case. Issue #23435.\n             if mth.is_provided {\n-                let predicates = mth.method.predicates.predicates.subst(tcx, mth.substs);\n+                let predicates = mth.method.predicates.predicates.subst(tcx, &mth.substs);\n                 if !normalize_and_test_predicates(ccx, predicates.into_vec()) {\n                     debug!(\"get_vtable_methods: predicates do not hold\");\n                     return None;\n@@ -473,14 +472,14 @@ fn opaque_method_ty<'tcx>(tcx: &TyCtxt<'tcx>, method_ty: &ty::BareFnTy<'tcx>)\n #[derive(Debug)]\n pub struct ImplMethod<'tcx> {\n     pub method: Rc<ty::Method<'tcx>>,\n-    pub substs: Substs<'tcx>,\n+    pub substs: &'tcx Substs<'tcx>,\n     pub is_provided: bool\n }\n \n /// Locates the applicable definition of a method, given its name.\n pub fn get_impl_method<'tcx>(tcx: &TyCtxt<'tcx>,\n                              impl_def_id: DefId,\n-                             substs: Substs<'tcx>,\n+                             substs: &'tcx Substs<'tcx>,\n                              name: Name)\n                              -> ImplMethod<'tcx>\n {"}, {"sha": "99dd72538c9869b8e759281a0ff36b8cc4b24860", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e5753b4605009260c0055a3bbb1efe4c06728650/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5753b4605009260c0055a3bbb1efe4c06728650/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=e5753b4605009260c0055a3bbb1efe4c06728650", "patch": "@@ -13,9 +13,12 @@\n //! constructor provide a method with the same name.\n \n use middle::cstore::CrateStore;\n-use middle::traits;\n+use middle::def_id::DefId;\n+use middle::traits::{self, ProjectionMode};\n+use middle::infer;\n use middle::ty::{self, TyCtxt};\n use syntax::ast;\n+use syntax::codemap::Span;\n use rustc::dep_graph::DepNode;\n use rustc_front::hir;\n use rustc_front::intravisit;\n@@ -86,7 +89,10 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n \n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n             for &impl2_def_id in &impls[(i+1)..] {\n-                let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None);\n+                let infcx = infer::new_infer_ctxt(self.tcx,\n+                                                  &self.tcx.tables,\n+                                                  None,\n+                                                  ProjectionMode::Topmost);\n                 if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n                     self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n                 }\n@@ -117,7 +123,8 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                         self.tcx.span_of_impl(impl_def_id).unwrap(), E0519,\n                         \"redundant default implementations of trait `{}`:\",\n                         trait_ref);\n-                    err.span_note(self.tcx.span_of_impl(self.tcx.map.local_def_id(prev_id)).unwrap(),\n+                    err.span_note(self.tcx.span_of_impl(self.tcx.map.local_def_id(prev_id))\n+                                      .unwrap(),\n                                   \"redundant implementation is here:\");\n                     err.emit();\n                 }"}, {"sha": "0f88640b629510040efdab8a9fa7c1c9638a7f17", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e5753b4605009260c0055a3bbb1efe4c06728650/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5753b4605009260c0055a3bbb1efe4c06728650/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e5753b4605009260c0055a3bbb1efe4c06728650", "patch": "@@ -804,7 +804,8 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n                     convert_method(ccx, ImplContainer(def_id),\n                                    impl_item.name, impl_item.id, method_vis,\n-                                   sig, impl_item.defaultness, selfty, &ty_generics, &ty_predicates);\n+                                   sig, impl_item.defaultness, selfty, &ty_generics,\n+                                   &ty_predicates);\n                 }\n             }\n "}]}