{"sha": "75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ZjkxNTkwMDljZDA4MTRiZDZiNWMzYmY2YTU0MDZkZTdjNGZlOGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-12T05:50:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-12T05:50:26Z"}, "message": "Auto merge of #58389 - Centril:rollup, r=Centril\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #58105 (libarena => 2018)\n - #58111 (libterm => 2018)\n - #58287 (rustc-std-workspace-core => 2018)\n - #58288 (rustc-workspace-hack => 2018)\n - #58300 (librustc_typeck => 2018)\n - #58313 (Use `?` in librustc macros)\n - #58318 (libserialize => 2018)\n - #58322 (librustc_codegen_ssa => 2018)\n - #58342 (Revert removed #![feature(nll)])\n - #58367 (Remove two dead functions.)\n - #58382 (docs: remove \"experimental\" wording from std::os::unix)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "dbfb36089ef3b8fc32fc5127e206e775411ce821", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbfb36089ef3b8fc32fc5127e206e775411ce821"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "html_url": "https://github.com/rust-lang/rust/commit/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba2853b6d3a197cdbec5543be2592ca430b49af6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba2853b6d3a197cdbec5543be2592ca430b49af6", "html_url": "https://github.com/rust-lang/rust/commit/ba2853b6d3a197cdbec5543be2592ca430b49af6"}, {"sha": "33d2c9f5337215963d67d855f0c64919bd7407a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/33d2c9f5337215963d67d855f0c64919bd7407a4", "html_url": "https://github.com/rust-lang/rust/commit/33d2c9f5337215963d67d855f0c64919bd7407a4"}], "stats": {"total": 4249, "additions": 2104, "deletions": 2145}, "files": [{"sha": "82fc64ba64e331645d075fbd879a6696e04cf523", "filename": "src/libarena/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibarena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibarena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2FCargo.toml?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -2,11 +2,12 @@\n authors = [\"The Rust Project Developers\"]\n name = \"arena\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"arena\"\n path = \"lib.rs\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n-rustc_data_structures = { path = \"../librustc_data_structures\" }\n\\ No newline at end of file\n+rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "8ae046c0796bc53e8f57eaa413af43a7e1bad17e", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -11,17 +11,17 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        test(no_crate_inject, attr(deny(warnings))))]\n \n+#![deny(rust_2018_idioms)]\n+\n #![feature(alloc)]\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n-#![feature(nll)]\n #![feature(raw_vec_internals)]\n #![cfg_attr(test, feature(test))]\n \n #![allow(deprecated)]\n \n extern crate alloc;\n-extern crate rustc_data_structures;\n \n use rustc_data_structures::sync::MTLock;\n \n@@ -476,7 +476,7 @@ impl SyncDroplessArena {\n #[cfg(test)]\n mod tests {\n     extern crate test;\n-    use self::test::Bencher;\n+    use test::Bencher;\n     use super::TypedArena;\n     use std::cell::Cell;\n \n@@ -511,15 +511,15 @@ mod tests {\n \n         impl<'a> Wrap<'a> {\n             fn alloc_inner<F: Fn() -> Inner>(&self, f: F) -> &Inner {\n-                let r: &EI = self.0.alloc(EI::I(f()));\n+                let r: &EI<'_> = self.0.alloc(EI::I(f()));\n                 if let &EI::I(ref i) = r {\n                     i\n                 } else {\n                     panic!(\"mismatch\");\n                 }\n             }\n-            fn alloc_outer<F: Fn() -> Outer<'a>>(&self, f: F) -> &Outer {\n-                let r: &EI = self.0.alloc(EI::O(f()));\n+            fn alloc_outer<F: Fn() -> Outer<'a>>(&self, f: F) -> &Outer<'_> {\n+                let r: &EI<'_> = self.0.alloc(EI::O(f()));\n                 if let &EI::O(ref o) = r {\n                     o\n                 } else {\n@@ -609,7 +609,7 @@ mod tests {\n         count: &'a Cell<u32>,\n     }\n \n-    impl<'a> Drop for DropCounter<'a> {\n+    impl Drop for DropCounter<'_> {\n         fn drop(&mut self) {\n             self.count.set(self.count.get() + 1);\n         }\n@@ -619,7 +619,7 @@ mod tests {\n     fn test_typed_arena_drop_count() {\n         let counter = Cell::new(0);\n         {\n-            let arena: TypedArena<DropCounter> = TypedArena::default();\n+            let arena: TypedArena<DropCounter<'_>> = TypedArena::default();\n             for _ in 0..100 {\n                 // Allocate something with drop glue to make sure it doesn't leak.\n                 arena.alloc(DropCounter { count: &counter });\n@@ -631,7 +631,7 @@ mod tests {\n     #[test]\n     fn test_typed_arena_drop_on_clear() {\n         let counter = Cell::new(0);\n-        let mut arena: TypedArena<DropCounter> = TypedArena::default();\n+        let mut arena: TypedArena<DropCounter<'_>> = TypedArena::default();\n         for i in 0..10 {\n             for _ in 0..100 {\n                 // Allocate something with drop glue to make sure it doesn't leak."}, {"sha": "aacd6cec565a5a971576f7ae79cf00e273387f67", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -10,6 +10,7 @@\n \n #![deny(rust_2018_idioms)]\n \n+#![feature(nll)]\n #![feature(rustc_private)]\n \n pub use Piece::*;"}, {"sha": "fadcfaec4b268467cbbb1f849ddab3afec2758c9", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -276,6 +276,7 @@\n \n #![deny(rust_2018_idioms)]\n \n+#![feature(nll)]\n #![feature(str_escape)]\n \n use LabelText::*;"}, {"sha": "edc97cd28a52af89d4d65147286cdf864904c821", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -14,6 +14,7 @@\n \n #![feature(core_intrinsics)]\n #![feature(libc)]\n+#![feature(nll)]\n #![feature(panic_runtime)]\n #![feature(staged_api)]\n #![feature(rustc_attrs)]"}, {"sha": "09a4a964abf09db8fbc8901c0b01b4b0b8f653c5", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -17,6 +17,7 @@\n \n #![deny(rust_2018_idioms)]\n \n+#![feature(nll)]\n #![feature(staged_api)]\n #![feature(const_fn)]\n #![feature(extern_types)]"}, {"sha": "2ce1a110b44c0c8f8d080599ee008f71a7f0dabb", "filename": "src/libprofiler_builtins/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibprofiler_builtins%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibprofiler_builtins%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -5,5 +5,6 @@\n             reason = \"internal implementation detail of rustc right now\",\n             issue = \"0\")]\n #![allow(unused_features)]\n+#![feature(nll)]\n #![feature(staged_api)]\n #![deny(rust_2018_idioms)]"}, {"sha": "dabe1755b0bb63f42d5f524389b5624c68eba1fa", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1291,14 +1291,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         value.visit_with(&mut r)\n     }\n \n-    pub fn resolve_type_and_region_vars_if_possible<T>(&self, value: &T) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        let mut r = resolve::OpportunisticTypeAndRegionResolver::new(self);\n-        value.fold_with(&mut r)\n-    }\n-\n     pub fn fully_resolve<T: TypeFoldable<'tcx>>(&self, value: &T) -> FixupResult<T> {\n         /*!\n          * Attempts to resolve all type/region variables in"}, {"sha": "ccae9d3ad5a82792a3d9e4a9e8de75014d6bfa1e", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -62,38 +62,36 @@ macro_rules! __impl_stable_hash_field {\n #[macro_export]\n macro_rules! impl_stable_hash_for {\n     // Enums\n-    // FIXME(mark-i-m): Some of these should be `?` rather than `*`. See the git blame and change\n-    // them back when `?` is supported again.\n     (enum $enum_name:path {\n         $( $variant:ident\n            // this incorrectly allows specifying both tuple-like and struct-like fields, as in `Variant(a,b){c,d}`,\n            // when it should be only one or the other\n-           $( ( $($field:ident $(-> $delegate:tt)*),* ) )*\n-           $( { $($named_field:ident $(-> $named_delegate:tt)*),* } )*\n-        ),* $(,)*\n+           $( ( $($field:ident $(-> $delegate:tt)?),* ) )?\n+           $( { $($named_field:ident $(-> $named_delegate:tt)?),* } )?\n+        ),* $(,)?\n     }) => {\n         impl_stable_hash_for!(\n             impl<> for enum $enum_name [ $enum_name ] { $( $variant\n-                $( ( $($field $(-> $delegate)*),* ) )*\n-                $( { $($named_field $(-> $named_delegate)*),* } )*\n+                $( ( $($field $(-> $delegate)?),* ) )?\n+                $( { $($named_field $(-> $named_delegate)?),* } )?\n             ),* }\n         );\n     };\n     // We want to use the enum name both in the `impl ... for $enum_name` as well as for\n     // importing all the variants. Unfortunately it seems we have to take the name\n     // twice for this purpose\n-    (impl<$($lt:lifetime $(: $lt_bound:lifetime)* ),* $(,)* $($T:ident),* $(,)*>\n+    (impl<$($lt:lifetime $(: $lt_bound:lifetime)? ),* $(,)? $($T:ident),* $(,)?>\n         for enum $enum_name:path\n         [ $enum_path:path ]\n     {\n         $( $variant:ident\n            // this incorrectly allows specifying both tuple-like and struct-like fields, as in `Variant(a,b){c,d}`,\n            // when it should be only one or the other\n-           $( ( $($field:ident $(-> $delegate:tt)*),* ) )*\n-           $( { $($named_field:ident $(-> $named_delegate:tt)*),* } )*\n-        ),* $(,)*\n+           $( ( $($field:ident $(-> $delegate:tt)?),* ) )?\n+           $( { $($named_field:ident $(-> $named_delegate:tt)?),* } )?\n+        ),* $(,)?\n     }) => {\n-        impl<'a, $($lt $(: $lt_bound)*,)* $($T,)*>\n+        impl<'a, $($lt $(: $lt_bound)?,)* $($T,)*>\n             ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>\n             for $enum_name\n             where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n@@ -107,26 +105,25 @@ macro_rules! impl_stable_hash_for {\n \n                 match *self {\n                     $(\n-                        $variant $( ( $(ref $field),* ) )* $( { $(ref $named_field),* } )* => {\n-                            $($( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)*) );*)*\n-                            $($( __impl_stable_hash_field!($named_field, __ctx, __hasher $(, $named_delegate)*) );*)*\n+                        $variant $( ( $(ref $field),* ) )? $( { $(ref $named_field),* } )? => {\n+                            $($( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)?) );*)?\n+                            $($( __impl_stable_hash_field!($named_field, __ctx, __hasher $(, $named_delegate)?) );*)?\n                         }\n                     )*\n                 }\n             }\n         }\n     };\n     // Structs\n-    // FIXME(mark-i-m): same here.\n-    (struct $struct_name:path { $($field:ident $(-> $delegate:tt)*),*  $(,)* }) => {\n+    (struct $struct_name:path { $($field:ident $(-> $delegate:tt)?),* $(,)? }) => {\n         impl_stable_hash_for!(\n-            impl<'tcx> for struct $struct_name { $($field $(-> $delegate)*),* }\n+            impl<'tcx> for struct $struct_name { $($field $(-> $delegate)?),* }\n         );\n     };\n-    (impl<$($lt:lifetime $(: $lt_bound:lifetime)* ),* $(,)* $($T:ident),* $(,)*> for struct $struct_name:path {\n-        $($field:ident $(-> $delegate:tt)*),* $(,)*\n+    (impl<$($lt:lifetime $(: $lt_bound:lifetime)? ),* $(,)? $($T:ident),* $(,)?> for struct $struct_name:path {\n+        $($field:ident $(-> $delegate:tt)?),* $(,)?\n     }) => {\n-        impl<'a, $($lt $(: $lt_bound)*,)* $($T,)*>\n+        impl<'a, $($lt $(: $lt_bound)?,)* $($T,)*>\n             ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name\n             where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n         {\n@@ -138,21 +135,20 @@ macro_rules! impl_stable_hash_for {\n                     $(ref $field),*\n                 } = *self;\n \n-                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)*) );*\n+                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)?) );*\n             }\n         }\n     };\n     // Tuple structs\n-    // We cannot use normale parentheses here, the parser won't allow it\n-    // FIXME(mark-i-m): same here.\n-    (tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)*),*  $(,)* }) => {\n+    // We cannot use normal parentheses here, the parser won't allow it\n+    (tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)?),*  $(,)? }) => {\n         impl_stable_hash_for!(\n-            impl<'tcx> for tuple_struct $struct_name { $($field $(-> $delegate)*),* }\n+            impl<'tcx> for tuple_struct $struct_name { $($field $(-> $delegate)?),* }\n         );\n     };\n-    (impl<$($lt:lifetime $(: $lt_bound:lifetime)* ),* $(,)* $($T:ident),* $(,)*>\n-     for tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)*),*  $(,)* }) => {\n-        impl<'a, $($lt $(: $lt_bound)*,)* $($T,)*>\n+    (impl<$($lt:lifetime $(: $lt_bound:lifetime)? ),* $(,)? $($T:ident),* $(,)?>\n+     for tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)?),*  $(,)? }) => {\n+        impl<'a, $($lt $(: $lt_bound)?,)* $($T,)*>\n             ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name\n             where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n         {\n@@ -164,7 +160,7 @@ macro_rules! impl_stable_hash_for {\n                     $(ref $field),*\n                 ) = *self;\n \n-                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)*) );*\n+                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)?) );*\n             }\n         }\n     };"}, {"sha": "e5828039ac29cb33fb1510aa05359a75a9a7a7d4", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 220, "deletions": 230, "changes": 450, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -38,10 +38,10 @@ use syntax_pos::Span;\n // ```rust\n // fn super_basic_block_data(&mut self,\n //                           block: BasicBlock,\n-//                           data: & $($mutability)* BasicBlockData<'tcx>) {\n+//                           data: & $($mutability)? BasicBlockData<'tcx>) {\n //     let BasicBlockData {\n-//         ref $($mutability)* statements,\n-//         ref $($mutability)* terminator,\n+//         statements,\n+//         terminator,\n //         is_cleanup: _\n //     } = *data;\n //\n@@ -67,111 +67,111 @@ use syntax_pos::Span;\n // `is_cleanup` above.\n \n macro_rules! make_mir_visitor {\n-    ($visitor_trait_name:ident, $($mutability:ident)*) => {\n+    ($visitor_trait_name:ident, $($mutability:ident)?) => {\n         pub trait $visitor_trait_name<'tcx> {\n             // Override these, and call `self.super_xxx` to revert back to the\n             // default behavior.\n \n-            fn visit_mir(&mut self, mir: & $($mutability)* Mir<'tcx>) {\n+            fn visit_mir(&mut self, mir: & $($mutability)? Mir<'tcx>) {\n                 self.super_mir(mir);\n             }\n \n             fn visit_basic_block_data(&mut self,\n                                       block: BasicBlock,\n-                                      data: & $($mutability)* BasicBlockData<'tcx>) {\n+                                      data: & $($mutability)? BasicBlockData<'tcx>) {\n                 self.super_basic_block_data(block, data);\n             }\n \n             fn visit_source_scope_data(&mut self,\n-                                           scope_data: & $($mutability)* SourceScopeData) {\n+                                           scope_data: & $($mutability)? SourceScopeData) {\n                 self.super_source_scope_data(scope_data);\n             }\n \n             fn visit_statement(&mut self,\n                                block: BasicBlock,\n-                               statement: & $($mutability)* Statement<'tcx>,\n+                               statement: & $($mutability)? Statement<'tcx>,\n                                location: Location) {\n                 self.super_statement(block, statement, location);\n             }\n \n             fn visit_assign(&mut self,\n                             block: BasicBlock,\n-                            place: & $($mutability)* Place<'tcx>,\n-                            rvalue: & $($mutability)* Rvalue<'tcx>,\n+                            place: & $($mutability)? Place<'tcx>,\n+                            rvalue: & $($mutability)? Rvalue<'tcx>,\n                             location: Location) {\n                 self.super_assign(block, place, rvalue, location);\n             }\n \n             fn visit_terminator(&mut self,\n                                 block: BasicBlock,\n-                                terminator: & $($mutability)* Terminator<'tcx>,\n+                                terminator: & $($mutability)? Terminator<'tcx>,\n                                 location: Location) {\n                 self.super_terminator(block, terminator, location);\n             }\n \n             fn visit_terminator_kind(&mut self,\n                                      block: BasicBlock,\n-                                     kind: & $($mutability)* TerminatorKind<'tcx>,\n+                                     kind: & $($mutability)? TerminatorKind<'tcx>,\n                                      location: Location) {\n                 self.super_terminator_kind(block, kind, location);\n             }\n \n             fn visit_assert_message(&mut self,\n-                                    msg: & $($mutability)* AssertMessage<'tcx>,\n+                                    msg: & $($mutability)? AssertMessage<'tcx>,\n                                     location: Location) {\n                 self.super_assert_message(msg, location);\n             }\n \n             fn visit_rvalue(&mut self,\n-                            rvalue: & $($mutability)* Rvalue<'tcx>,\n+                            rvalue: & $($mutability)? Rvalue<'tcx>,\n                             location: Location) {\n                 self.super_rvalue(rvalue, location);\n             }\n \n             fn visit_operand(&mut self,\n-                             operand: & $($mutability)* Operand<'tcx>,\n+                             operand: & $($mutability)? Operand<'tcx>,\n                              location: Location) {\n                 self.super_operand(operand, location);\n             }\n \n             fn visit_ascribe_user_ty(&mut self,\n-                                     place: & $($mutability)* Place<'tcx>,\n-                                     variance: & $($mutability)* ty::Variance,\n-                                     user_ty: & $($mutability)* UserTypeProjection<'tcx>,\n+                                     place: & $($mutability)? Place<'tcx>,\n+                                     variance: & $($mutability)? ty::Variance,\n+                                     user_ty: & $($mutability)? UserTypeProjection<'tcx>,\n                                      location: Location) {\n                 self.super_ascribe_user_ty(place, variance, user_ty, location);\n             }\n \n             fn visit_retag(&mut self,\n-                           kind: & $($mutability)* RetagKind,\n-                           place: & $($mutability)* Place<'tcx>,\n+                           kind: & $($mutability)? RetagKind,\n+                           place: & $($mutability)? Place<'tcx>,\n                            location: Location) {\n                 self.super_retag(kind, place, location);\n             }\n \n             fn visit_place(&mut self,\n-                            place: & $($mutability)* Place<'tcx>,\n+                            place: & $($mutability)? Place<'tcx>,\n                             context: PlaceContext<'tcx>,\n                             location: Location) {\n                 self.super_place(place, context, location);\n             }\n \n             fn visit_static(&mut self,\n-                            static_: & $($mutability)* Static<'tcx>,\n+                            static_: & $($mutability)? Static<'tcx>,\n                             context: PlaceContext<'tcx>,\n                             location: Location) {\n                 self.super_static(static_, context, location);\n             }\n \n             fn visit_projection(&mut self,\n-                                place: & $($mutability)* PlaceProjection<'tcx>,\n+                                place: & $($mutability)? PlaceProjection<'tcx>,\n                                 context: PlaceContext<'tcx>,\n                                 location: Location) {\n                 self.super_projection(place, context, location);\n             }\n \n             fn visit_projection_elem(&mut self,\n-                                     place: & $($mutability)* PlaceElem<'tcx>,\n+                                     place: & $($mutability)? PlaceElem<'tcx>,\n                                      location: Location) {\n                 self.super_projection_elem(place, location);\n             }\n@@ -183,101 +183,101 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_constant(&mut self,\n-                              constant: & $($mutability)* Constant<'tcx>,\n+                              constant: & $($mutability)? Constant<'tcx>,\n                               location: Location) {\n                 self.super_constant(constant, location);\n             }\n \n             fn visit_def_id(&mut self,\n-                            def_id: & $($mutability)* DefId,\n+                            def_id: & $($mutability)? DefId,\n                             _: Location) {\n                 self.super_def_id(def_id);\n             }\n \n             fn visit_span(&mut self,\n-                          span: & $($mutability)* Span) {\n+                          span: & $($mutability)? Span) {\n                 self.super_span(span);\n             }\n \n             fn visit_source_info(&mut self,\n-                                 source_info: & $($mutability)* SourceInfo) {\n+                                 source_info: & $($mutability)? SourceInfo) {\n                 self.super_source_info(source_info);\n             }\n \n             fn visit_ty(&mut self,\n-                        ty: & $($mutability)* Ty<'tcx>,\n+                        ty: & $($mutability)? Ty<'tcx>,\n                         _: TyContext) {\n                 self.super_ty(ty);\n             }\n \n             fn visit_user_type_projection(\n                 &mut self,\n-                ty: & $($mutability)* UserTypeProjection<'tcx>,\n+                ty: & $($mutability)? UserTypeProjection<'tcx>,\n             ) {\n                 self.super_user_type_projection(ty);\n             }\n \n             fn visit_user_type_annotation(\n                 &mut self,\n                 index: UserTypeAnnotationIndex,\n-                ty: & $($mutability)* CanonicalUserTypeAnnotation<'tcx>,\n+                ty: & $($mutability)? CanonicalUserTypeAnnotation<'tcx>,\n             ) {\n                 self.super_user_type_annotation(index, ty);\n             }\n \n             fn visit_region(&mut self,\n-                            region: & $($mutability)* ty::Region<'tcx>,\n+                            region: & $($mutability)? ty::Region<'tcx>,\n                             _: Location) {\n                 self.super_region(region);\n             }\n \n             fn visit_const(&mut self,\n-                           constant: & $($mutability)* &'tcx ty::LazyConst<'tcx>,\n+                           constant: & $($mutability)? &'tcx ty::LazyConst<'tcx>,\n                            _: Location) {\n                 self.super_const(constant);\n             }\n \n             fn visit_substs(&mut self,\n-                            substs: & $($mutability)* &'tcx Substs<'tcx>,\n+                            substs: & $($mutability)? &'tcx Substs<'tcx>,\n                             _: Location) {\n                 self.super_substs(substs);\n             }\n \n             fn visit_closure_substs(&mut self,\n-                                    substs: & $($mutability)* ClosureSubsts<'tcx>,\n+                                    substs: & $($mutability)? ClosureSubsts<'tcx>,\n                                     _: Location) {\n                 self.super_closure_substs(substs);\n             }\n \n             fn visit_generator_substs(&mut self,\n-                                      substs: & $($mutability)* GeneratorSubsts<'tcx>,\n+                                      substs: & $($mutability)? GeneratorSubsts<'tcx>,\n                                     _: Location) {\n                 self.super_generator_substs(substs);\n             }\n \n             fn visit_local_decl(&mut self,\n                                 local: Local,\n-                                local_decl: & $($mutability)* LocalDecl<'tcx>) {\n+                                local_decl: & $($mutability)? LocalDecl<'tcx>) {\n                 self.super_local_decl(local, local_decl);\n             }\n \n             fn visit_local(&mut self,\n-                            _local: & $($mutability)* Local,\n+                            _local: & $($mutability)? Local,\n                             _context: PlaceContext<'tcx>,\n                             _location: Location) {\n             }\n \n             fn visit_source_scope(&mut self,\n-                                      scope: & $($mutability)* SourceScope) {\n+                                      scope: & $($mutability)? SourceScope) {\n                 self.super_source_scope(scope);\n             }\n \n             // The `super_xxx` methods comprise the default behavior and are\n             // not meant to be overridden.\n \n             fn super_mir(&mut self,\n-                         mir: & $($mutability)* Mir<'tcx>) {\n-                if let Some(yield_ty) = &$($mutability)* mir.yield_ty {\n+                         mir: & $($mutability)? Mir<'tcx>) {\n+                if let Some(yield_ty) = &$($mutability)? mir.yield_ty {\n                     self.visit_ty(yield_ty, TyContext::YieldTy(SourceInfo {\n                         span: mir.span,\n                         scope: OUTERMOST_SOURCE_SCOPE,\n@@ -291,45 +291,45 @@ macro_rules! make_mir_visitor {\n                     (mut) => (mir.basic_blocks_mut().iter_enumerated_mut());\n                     () => (mir.basic_blocks().iter_enumerated());\n                 };\n-                for (bb, data) in basic_blocks!($($mutability)*) {\n+                for (bb, data) in basic_blocks!($($mutability)?) {\n                     self.visit_basic_block_data(bb, data);\n                 }\n \n-                for scope in &$($mutability)* mir.source_scopes {\n+                for scope in &$($mutability)? mir.source_scopes {\n                     self.visit_source_scope_data(scope);\n                 }\n \n-                self.visit_ty(&$($mutability)* mir.return_ty(), TyContext::ReturnTy(SourceInfo {\n+                self.visit_ty(&$($mutability)? mir.return_ty(), TyContext::ReturnTy(SourceInfo {\n                     span: mir.span,\n                     scope: OUTERMOST_SOURCE_SCOPE,\n                 }));\n \n                 for local in mir.local_decls.indices() {\n-                    self.visit_local_decl(local, & $($mutability)* mir.local_decls[local]);\n+                    self.visit_local_decl(local, & $($mutability)? mir.local_decls[local]);\n                 }\n \n                 macro_rules! type_annotations {\n                     (mut) => (mir.user_type_annotations.iter_enumerated_mut());\n                     () => (mir.user_type_annotations.iter_enumerated());\n                 };\n \n-                for (index, annotation) in type_annotations!($($mutability)*) {\n+                for (index, annotation) in type_annotations!($($mutability)?) {\n                     self.visit_user_type_annotation(\n                         index, annotation\n                     );\n                 }\n \n-                self.visit_span(&$($mutability)* mir.span);\n+                self.visit_span(&$($mutability)? mir.span);\n             }\n \n             fn super_basic_block_data(&mut self,\n                                       block: BasicBlock,\n-                                      data: & $($mutability)* BasicBlockData<'tcx>) {\n+                                      data: & $($mutability)? BasicBlockData<'tcx>) {\n                 let BasicBlockData {\n-                    ref $($mutability)* statements,\n-                    ref $($mutability)* terminator,\n+                    statements,\n+                    terminator,\n                     is_cleanup: _\n-                } = *data;\n+                } = data;\n \n                 let mut index = 0;\n                 for statement in statements {\n@@ -338,92 +338,83 @@ macro_rules! make_mir_visitor {\n                     index += 1;\n                 }\n \n-                if let Some(ref $($mutability)* terminator) = *terminator {\n+                if let Some(terminator) = terminator {\n                     let location = Location { block: block, statement_index: index };\n                     self.visit_terminator(block, terminator, location);\n                 }\n             }\n \n-            fn super_source_scope_data(&mut self,\n-                                           scope_data: & $($mutability)* SourceScopeData) {\n+            fn super_source_scope_data(&mut self, scope_data: & $($mutability)? SourceScopeData) {\n                 let SourceScopeData {\n-                    ref $($mutability)* span,\n-                    ref $($mutability)* parent_scope,\n-                } = *scope_data;\n+                    span,\n+                    parent_scope,\n+                } = scope_data;\n \n                 self.visit_span(span);\n-                if let Some(ref $($mutability)* parent_scope) = *parent_scope {\n+                if let Some(parent_scope) = parent_scope {\n                     self.visit_source_scope(parent_scope);\n                 }\n             }\n \n             fn super_statement(&mut self,\n                                block: BasicBlock,\n-                               statement: & $($mutability)* Statement<'tcx>,\n+                               statement: & $($mutability)? Statement<'tcx>,\n                                location: Location) {\n                 let Statement {\n-                    ref $($mutability)* source_info,\n-                    ref $($mutability)* kind,\n-                } = *statement;\n+                    source_info,\n+                    kind,\n+                } = statement;\n \n                 self.visit_source_info(source_info);\n-                match *kind {\n-                    StatementKind::Assign(ref $($mutability)* place,\n-                                          ref $($mutability)* rvalue) => {\n+                match kind {\n+                    StatementKind::Assign(place, rvalue) => {\n                         self.visit_assign(block, place, rvalue, location);\n                     }\n-                    StatementKind::FakeRead(_, ref $($mutability)* place) => {\n+                    StatementKind::FakeRead(_, place) => {\n                         self.visit_place(\n                             place,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Inspect),\n                             location\n                         );\n                     }\n-                    StatementKind::SetDiscriminant{ ref $($mutability)* place, .. } => {\n+                    StatementKind::SetDiscriminant { place, .. } => {\n                         self.visit_place(\n                             place,\n                             PlaceContext::MutatingUse(MutatingUseContext::Store),\n                             location\n                         );\n                     }\n-                    StatementKind::StorageLive(ref $($mutability)* local) => {\n+                    StatementKind::StorageLive(local) => {\n                         self.visit_local(\n                             local,\n                             PlaceContext::NonUse(NonUseContext::StorageLive),\n                             location\n                         );\n                     }\n-                    StatementKind::StorageDead(ref $($mutability)* local) => {\n+                    StatementKind::StorageDead(local) => {\n                         self.visit_local(\n                             local,\n                             PlaceContext::NonUse(NonUseContext::StorageDead),\n                             location\n                         );\n                     }\n-                    StatementKind::InlineAsm { ref $($mutability)* outputs,\n-                                               ref $($mutability)* inputs,\n-                                               asm: _ } => {\n-                        for output in & $($mutability)* outputs[..] {\n+                    StatementKind::InlineAsm { outputs, inputs, asm: _ } => {\n+                        for output in & $($mutability)? outputs[..] {\n                             self.visit_place(\n                                 output,\n                                 PlaceContext::MutatingUse(MutatingUseContext::AsmOutput),\n                                 location\n                             );\n                         }\n-                        for (span, input) in & $($mutability)* inputs[..] {\n+                        for (span, input) in & $($mutability)? inputs[..] {\n                             self.visit_span(span);\n                             self.visit_operand(input, location);\n                         }\n                     }\n-                    StatementKind::Retag ( ref $($mutability)* kind,\n-                                           ref $($mutability)* place ) => {\n+                    StatementKind::Retag(kind, place) => {\n                         self.visit_retag(kind, place, location);\n                     }\n-                    StatementKind::AscribeUserType(\n-                        ref $($mutability)* place,\n-                        ref $($mutability)* variance,\n-                        ref $($mutability)* user_ty,\n-                    ) => {\n+                    StatementKind::AscribeUserType(place, variance, user_ty) => {\n                         self.visit_ascribe_user_ty(place, variance, user_ty, location);\n                     }\n                     StatementKind::Nop => {}\n@@ -432,8 +423,8 @@ macro_rules! make_mir_visitor {\n \n             fn super_assign(&mut self,\n                             _block: BasicBlock,\n-                            place: &$($mutability)* Place<'tcx>,\n-                            rvalue: &$($mutability)* Rvalue<'tcx>,\n+                            place: &$($mutability)? Place<'tcx>,\n+                            rvalue: &$($mutability)? Rvalue<'tcx>,\n                             location: Location) {\n                 self.visit_place(\n                     place,\n@@ -445,34 +436,33 @@ macro_rules! make_mir_visitor {\n \n             fn super_terminator(&mut self,\n                                 block: BasicBlock,\n-                                terminator: &$($mutability)* Terminator<'tcx>,\n+                                terminator: &$($mutability)? Terminator<'tcx>,\n                                 location: Location) {\n-                let Terminator {\n-                    ref $($mutability)* source_info,\n-                    ref $($mutability)* kind,\n-                } = *terminator;\n+                let Terminator { source_info, kind } = terminator;\n \n                 self.visit_source_info(source_info);\n                 self.visit_terminator_kind(block, kind, location);\n             }\n \n             fn super_terminator_kind(&mut self,\n                                      block: BasicBlock,\n-                                     kind: & $($mutability)* TerminatorKind<'tcx>,\n+                                     kind: & $($mutability)? TerminatorKind<'tcx>,\n                                      source_location: Location) {\n-                match *kind {\n+                match kind {\n                     TerminatorKind::Goto { target } => {\n-                        self.visit_branch(block, target);\n+                        self.visit_branch(block, *target);\n                     }\n \n-                    TerminatorKind::SwitchInt { ref $($mutability)* discr,\n-                                                ref $($mutability)* switch_ty,\n-                                                values: _,\n-                                                ref targets } => {\n+                    TerminatorKind::SwitchInt {\n+                        discr,\n+                        switch_ty,\n+                        values: _,\n+                        targets\n+                    } => {\n                         self.visit_operand(discr, source_location);\n                         self.visit_ty(switch_ty, TyContext::Location(source_location));\n-                        for &target in targets {\n-                            self.visit_branch(block, target);\n+                        for target in targets {\n+                            self.visit_branch(block, *target);\n                         }\n                     }\n \n@@ -483,113 +473,120 @@ macro_rules! make_mir_visitor {\n                     TerminatorKind::Unreachable => {\n                     }\n \n-                    TerminatorKind::Drop { ref $($mutability)* location,\n-                                           target,\n-                                           unwind } => {\n+                    TerminatorKind::Drop {\n+                        location,\n+                        target,\n+                        unwind,\n+                    } => {\n                         self.visit_place(\n                             location,\n                             PlaceContext::MutatingUse(MutatingUseContext::Drop),\n                             source_location\n                         );\n-                        self.visit_branch(block, target);\n+                        self.visit_branch(block, *target);\n                         unwind.map(|t| self.visit_branch(block, t));\n                     }\n \n-                    TerminatorKind::DropAndReplace { ref $($mutability)* location,\n-                                                     ref $($mutability)* value,\n-                                                     target,\n-                                                     unwind } => {\n+                    TerminatorKind::DropAndReplace {\n+                        location,\n+                        value,\n+                        target,\n+                        unwind,\n+                    } => {\n                         self.visit_place(\n                             location,\n                             PlaceContext::MutatingUse(MutatingUseContext::Drop),\n                             source_location\n                         );\n                         self.visit_operand(value, source_location);\n-                        self.visit_branch(block, target);\n+                        self.visit_branch(block, *target);\n                         unwind.map(|t| self.visit_branch(block, t));\n                     }\n \n-                    TerminatorKind::Call { ref $($mutability)* func,\n-                                           ref $($mutability)* args,\n-                                           ref $($mutability)* destination,\n-                                           cleanup,\n-                                           from_hir_call: _, } => {\n+                    TerminatorKind::Call {\n+                        func,\n+                        args,\n+                        destination,\n+                        cleanup,\n+                        from_hir_call: _,\n+                    } => {\n                         self.visit_operand(func, source_location);\n                         for arg in args {\n                             self.visit_operand(arg, source_location);\n                         }\n-                        if let Some((ref $($mutability)* destination, target)) = *destination {\n+                        if let Some((destination, target)) = destination {\n                             self.visit_place(\n                                 destination,\n                                 PlaceContext::MutatingUse(MutatingUseContext::Call),\n                                 source_location\n                             );\n-                            self.visit_branch(block, target);\n+                            self.visit_branch(block, *target);\n                         }\n                         cleanup.map(|t| self.visit_branch(block, t));\n                     }\n \n-                    TerminatorKind::Assert { ref $($mutability)* cond,\n-                                             expected: _,\n-                                             ref $($mutability)* msg,\n-                                             target,\n-                                             cleanup } => {\n+                    TerminatorKind::Assert {\n+                        cond,\n+                        expected: _,\n+                        msg,\n+                        target,\n+                        cleanup,\n+                    } => {\n                         self.visit_operand(cond, source_location);\n                         self.visit_assert_message(msg, source_location);\n-                        self.visit_branch(block, target);\n+                        self.visit_branch(block, *target);\n                         cleanup.map(|t| self.visit_branch(block, t));\n                     }\n \n-                    TerminatorKind::Yield { ref $($mutability)* value,\n-                                              resume,\n-                                              drop } => {\n+                    TerminatorKind::Yield {\n+                        value,\n+                        resume,\n+                        drop,\n+                    } => {\n                         self.visit_operand(value, source_location);\n-                        self.visit_branch(block, resume);\n+                        self.visit_branch(block, *resume);\n                         drop.map(|t| self.visit_branch(block, t));\n                     }\n \n-                    TerminatorKind::FalseEdges { real_target, ref imaginary_targets} => {\n-                        self.visit_branch(block, real_target);\n+                    TerminatorKind::FalseEdges { real_target, imaginary_targets } => {\n+                        self.visit_branch(block, *real_target);\n                         for target in imaginary_targets {\n                             self.visit_branch(block, *target);\n                         }\n                     }\n \n                     TerminatorKind::FalseUnwind { real_target, unwind } => {\n-                        self.visit_branch(block, real_target);\n+                        self.visit_branch(block, *real_target);\n                         if let Some(unwind) = unwind {\n-                            self.visit_branch(block, unwind);\n+                            self.visit_branch(block, *unwind);\n                         }\n                     }\n                 }\n             }\n \n             fn super_assert_message(&mut self,\n-                                    msg: & $($mutability)* AssertMessage<'tcx>,\n+                                    msg: & $($mutability)? AssertMessage<'tcx>,\n                                     location: Location) {\n                 use crate::mir::interpret::EvalErrorKind::*;\n-                if let BoundsCheck {\n-                        ref $($mutability)* len,\n-                        ref $($mutability)* index\n-                    } = *msg {\n+                if let BoundsCheck { len, index } = msg {\n                     self.visit_operand(len, location);\n                     self.visit_operand(index, location);\n                 }\n             }\n \n             fn super_rvalue(&mut self,\n-                            rvalue: & $($mutability)* Rvalue<'tcx>,\n+                            rvalue: & $($mutability)? Rvalue<'tcx>,\n                             location: Location) {\n-                match *rvalue {\n-                    Rvalue::Use(ref $($mutability)* operand) => {\n+                match rvalue {\n+                    Rvalue::Use(operand) => {\n                         self.visit_operand(operand, location);\n                     }\n \n-                    Rvalue::Repeat(ref $($mutability)* value, _) => {\n+                    Rvalue::Repeat(value, _) => {\n                         self.visit_operand(value, location);\n                     }\n \n-                    Rvalue::Ref(ref $($mutability)* r, bk, ref $($mutability)* path) => {\n+                    Rvalue::Ref(r, bk, path) => {\n                         self.visit_region(r, location);\n                         let ctx = match bk {\n                             BorrowKind::Shared => PlaceContext::NonMutatingUse(\n@@ -607,71 +604,70 @@ macro_rules! make_mir_visitor {\n                         self.visit_place(path, ctx, location);\n                     }\n \n-                    Rvalue::Len(ref $($mutability)* path) => {\n+                    Rvalue::Len(path) => {\n                         self.visit_place(\n                             path,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Inspect),\n                             location\n                         );\n                     }\n \n-                    Rvalue::Cast(_cast_kind,\n-                                 ref $($mutability)* operand,\n-                                 ref $($mutability)* ty) => {\n+                    Rvalue::Cast(_cast_kind, operand, ty) => {\n                         self.visit_operand(operand, location);\n                         self.visit_ty(ty, TyContext::Location(location));\n                     }\n \n-                    Rvalue::BinaryOp(_bin_op,\n-                                     ref $($mutability)* lhs,\n-                                     ref $($mutability)* rhs) |\n-                    Rvalue::CheckedBinaryOp(_bin_op,\n-                                     ref $($mutability)* lhs,\n-                                     ref $($mutability)* rhs) => {\n+                    Rvalue::BinaryOp(_bin_op, lhs, rhs)\n+                    | Rvalue::CheckedBinaryOp(_bin_op, lhs, rhs) => {\n                         self.visit_operand(lhs, location);\n                         self.visit_operand(rhs, location);\n                     }\n \n-                    Rvalue::UnaryOp(_un_op, ref $($mutability)* op) => {\n+                    Rvalue::UnaryOp(_un_op, op) => {\n                         self.visit_operand(op, location);\n                     }\n \n-                    Rvalue::Discriminant(ref $($mutability)* place) => {\n+                    Rvalue::Discriminant(place) => {\n                         self.visit_place(\n                             place,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Inspect),\n                             location\n                         );\n                     }\n \n-                    Rvalue::NullaryOp(_op, ref $($mutability)* ty) => {\n+                    Rvalue::NullaryOp(_op, ty) => {\n                         self.visit_ty(ty, TyContext::Location(location));\n                     }\n \n-                    Rvalue::Aggregate(ref $($mutability)* kind,\n-                                      ref $($mutability)* operands) => {\n-                        let kind = &$($mutability)* **kind;\n-                        match *kind {\n-                            AggregateKind::Array(ref $($mutability)* ty) => {\n+                    Rvalue::Aggregate(kind, operands) => {\n+                        let kind = &$($mutability)? **kind;\n+                        match kind {\n+                            AggregateKind::Array(ty) => {\n                                 self.visit_ty(ty, TyContext::Location(location));\n                             }\n                             AggregateKind::Tuple => {\n                             }\n-                            AggregateKind::Adt(_adt_def,\n-                                               _variant_index,\n-                                               ref $($mutability)* substs,\n-                                               _user_substs,\n-                                               _active_field_index) => {\n+                            AggregateKind::Adt(\n+                                _adt_def,\n+                                _variant_index,\n+                                substs,\n+                                _user_substs,\n+                                _active_field_index\n+                            ) => {\n                                 self.visit_substs(substs, location);\n                             }\n-                            AggregateKind::Closure(ref $($mutability)* def_id,\n-                                                   ref $($mutability)* closure_substs) => {\n+                            AggregateKind::Closure(\n+                                def_id,\n+                                closure_substs\n+                            ) => {\n                                 self.visit_def_id(def_id, location);\n                                 self.visit_closure_substs(closure_substs, location);\n                             }\n-                            AggregateKind::Generator(ref $($mutability)* def_id,\n-                                                     ref $($mutability)* generator_substs,\n-                                                     _movability) => {\n+                            AggregateKind::Generator(\n+                                def_id,\n+                                generator_substs,\n+                                _movability,\n+                            ) => {\n                                 self.visit_def_id(def_id, location);\n                                 self.visit_generator_substs(generator_substs, location);\n                             }\n@@ -685,33 +681,33 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_operand(&mut self,\n-                             operand: & $($mutability)* Operand<'tcx>,\n+                             operand: & $($mutability)? Operand<'tcx>,\n                              location: Location) {\n-                match *operand {\n-                    Operand::Copy(ref $($mutability)* place) => {\n+                match operand {\n+                    Operand::Copy(place) => {\n                         self.visit_place(\n                             place,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n                             location\n                         );\n                     }\n-                    Operand::Move(ref $($mutability)* place) => {\n+                    Operand::Move(place) => {\n                         self.visit_place(\n                             place,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Move),\n                             location\n                         );\n                     }\n-                    Operand::Constant(ref $($mutability)* constant) => {\n+                    Operand::Constant(constant) => {\n                         self.visit_constant(constant, location);\n                     }\n                 }\n             }\n \n             fn super_ascribe_user_ty(&mut self,\n-                                     place: & $($mutability)* Place<'tcx>,\n-                                     _variance: & $($mutability)* ty::Variance,\n-                                     user_ty: & $($mutability)* UserTypeProjection<'tcx>,\n+                                     place: & $($mutability)? Place<'tcx>,\n+                                     _variance: & $($mutability)? ty::Variance,\n+                                     user_ty: & $($mutability)? UserTypeProjection<'tcx>,\n                                      location: Location) {\n                 self.visit_place(\n                     place,\n@@ -722,8 +718,8 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_retag(&mut self,\n-                           _kind: & $($mutability)* RetagKind,\n-                           place: & $($mutability)* Place<'tcx>,\n+                           _kind: & $($mutability)? RetagKind,\n+                           place: & $($mutability)? Place<'tcx>,\n                            location: Location) {\n                 self.visit_place(\n                     place,\n@@ -733,45 +729,39 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_place(&mut self,\n-                            place: & $($mutability)* Place<'tcx>,\n+                            place: & $($mutability)? Place<'tcx>,\n                             context: PlaceContext<'tcx>,\n                             location: Location) {\n-                match *place {\n-                    Place::Local(ref $($mutability)* local) => {\n+                match place {\n+                    Place::Local(local) => {\n                         self.visit_local(local, context, location);\n                     }\n-                    Place::Static(ref $($mutability)* static_) => {\n+                    Place::Static(static_) => {\n                         self.visit_static(static_, context, location);\n                     }\n-                    Place::Promoted(ref $($mutability)* promoted) => {\n-                        self.visit_ty(& $($mutability)* promoted.1, TyContext::Location(location));\n+                    Place::Promoted(promoted) => {\n+                        self.visit_ty(& $($mutability)? promoted.1, TyContext::Location(location));\n                     },\n-                    Place::Projection(ref $($mutability)* proj) => {\n+                    Place::Projection(proj) => {\n                         self.visit_projection(proj, context, location);\n                     }\n                 }\n             }\n \n             fn super_static(&mut self,\n-                            static_: & $($mutability)* Static<'tcx>,\n+                            static_: & $($mutability)? Static<'tcx>,\n                             _context: PlaceContext<'tcx>,\n                             location: Location) {\n-                let Static {\n-                    ref $($mutability)* def_id,\n-                    ref $($mutability)* ty,\n-                } = *static_;\n+                let Static { def_id, ty } = static_;\n                 self.visit_def_id(def_id, location);\n                 self.visit_ty(ty, TyContext::Location(location));\n             }\n \n             fn super_projection(&mut self,\n-                                proj: & $($mutability)* PlaceProjection<'tcx>,\n+                                proj: & $($mutability)? PlaceProjection<'tcx>,\n                                 context: PlaceContext<'tcx>,\n                                 location: Location) {\n-                let Projection {\n-                    ref $($mutability)* base,\n-                    ref $($mutability)* elem,\n-                } = *proj;\n+                let Projection { base, elem } = proj;\n                 let context = if context.is_mutating_use() {\n                     PlaceContext::MutatingUse(MutatingUseContext::Projection)\n                 } else {\n@@ -782,17 +772,17 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_projection_elem(&mut self,\n-                                     proj: & $($mutability)* PlaceElem<'tcx>,\n+                                     proj: & $($mutability)? PlaceElem<'tcx>,\n                                      location: Location) {\n-                match *proj {\n+                match proj {\n                     ProjectionElem::Deref => {\n                     }\n                     ProjectionElem::Subslice { from: _, to: _ } => {\n                     }\n-                    ProjectionElem::Field(_field, ref $($mutability)* ty) => {\n+                    ProjectionElem::Field(_field, ty) => {\n                         self.visit_ty(ty, TyContext::Location(location));\n                     }\n-                    ProjectionElem::Index(ref $($mutability)* local) => {\n+                    ProjectionElem::Index(local) => {\n                         self.visit_local(\n                             local,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n@@ -810,32 +800,32 @@ macro_rules! make_mir_visitor {\n \n             fn super_local_decl(&mut self,\n                                 local: Local,\n-                                local_decl: & $($mutability)* LocalDecl<'tcx>) {\n+                                local_decl: & $($mutability)? LocalDecl<'tcx>) {\n                 let LocalDecl {\n                     mutability: _,\n-                    ref $($mutability)* ty,\n-                    ref $($mutability)* user_ty,\n+                    ty,\n+                    user_ty,\n                     name: _,\n-                    ref $($mutability)* source_info,\n-                    ref $($mutability)* visibility_scope,\n+                    source_info,\n+                    visibility_scope,\n                     internal: _,\n                     is_user_variable: _,\n                     is_block_tail: _,\n-                } = *local_decl;\n+                } = local_decl;\n \n                 self.visit_ty(ty, TyContext::LocalDecl {\n                     local,\n                     source_info: *source_info,\n                 });\n-                for (user_ty, _) in & $($mutability)* user_ty.contents {\n+                for (user_ty, _) in & $($mutability)? user_ty.contents {\n                     self.visit_user_type_projection(user_ty);\n                 }\n                 self.visit_source_info(source_info);\n                 self.visit_source_scope(visibility_scope);\n             }\n \n             fn super_source_scope(&mut self,\n-                                      _scope: & $($mutability)* SourceScope) {\n+                                      _scope: & $($mutability)? SourceScope) {\n             }\n \n             fn super_branch(&mut self,\n@@ -844,82 +834,82 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_constant(&mut self,\n-                              constant: & $($mutability)* Constant<'tcx>,\n+                              constant: & $($mutability)? Constant<'tcx>,\n                               location: Location) {\n                 let Constant {\n-                    ref $($mutability)* span,\n-                    ref $($mutability)* ty,\n-                    ref $($mutability)* user_ty,\n-                    ref $($mutability)* literal,\n-                } = *constant;\n+                    span,\n+                    ty,\n+                    user_ty,\n+                    literal,\n+                } = constant;\n \n                 self.visit_span(span);\n                 self.visit_ty(ty, TyContext::Location(location));\n                 drop(user_ty); // no visit method for this\n                 self.visit_const(literal, location);\n             }\n \n-            fn super_def_id(&mut self, _def_id: & $($mutability)* DefId) {\n+            fn super_def_id(&mut self, _def_id: & $($mutability)? DefId) {\n             }\n \n-            fn super_span(&mut self, _span: & $($mutability)* Span) {\n+            fn super_span(&mut self, _span: & $($mutability)? Span) {\n             }\n \n-            fn super_source_info(&mut self, source_info: & $($mutability)* SourceInfo) {\n+            fn super_source_info(&mut self, source_info: & $($mutability)? SourceInfo) {\n                 let SourceInfo {\n-                    ref $($mutability)* span,\n-                    ref $($mutability)* scope,\n-                } = *source_info;\n+                    span,\n+                    scope,\n+                } = source_info;\n \n                 self.visit_span(span);\n                 self.visit_source_scope(scope);\n             }\n \n             fn super_user_type_projection(\n                 &mut self,\n-                _ty: & $($mutability)* UserTypeProjection<'tcx>,\n+                _ty: & $($mutability)? UserTypeProjection<'tcx>,\n             ) {\n             }\n \n             fn super_user_type_annotation(\n                 &mut self,\n                 _index: UserTypeAnnotationIndex,\n-                ty: & $($mutability)* CanonicalUserTypeAnnotation<'tcx>,\n+                ty: & $($mutability)? CanonicalUserTypeAnnotation<'tcx>,\n             ) {\n-                self.visit_span(& $($mutability)* ty.span);\n-                self.visit_ty(& $($mutability)* ty.inferred_ty, TyContext::UserTy(ty.span));\n+                self.visit_span(& $($mutability)? ty.span);\n+                self.visit_ty(& $($mutability)? ty.inferred_ty, TyContext::UserTy(ty.span));\n             }\n \n-            fn super_ty(&mut self, _ty: & $($mutability)* Ty<'tcx>) {\n+            fn super_ty(&mut self, _ty: & $($mutability)? Ty<'tcx>) {\n             }\n \n-            fn super_region(&mut self, _region: & $($mutability)* ty::Region<'tcx>) {\n+            fn super_region(&mut self, _region: & $($mutability)? ty::Region<'tcx>) {\n             }\n \n-            fn super_const(&mut self, _const: & $($mutability)* &'tcx ty::LazyConst<'tcx>) {\n+            fn super_const(&mut self, _const: & $($mutability)? &'tcx ty::LazyConst<'tcx>) {\n             }\n \n-            fn super_substs(&mut self, _substs: & $($mutability)* &'tcx Substs<'tcx>) {\n+            fn super_substs(&mut self, _substs: & $($mutability)? &'tcx Substs<'tcx>) {\n             }\n \n             fn super_generator_substs(&mut self,\n-                                      _substs: & $($mutability)* GeneratorSubsts<'tcx>) {\n+                                      _substs: & $($mutability)? GeneratorSubsts<'tcx>) {\n             }\n \n             fn super_closure_substs(&mut self,\n-                                    _substs: & $($mutability)* ClosureSubsts<'tcx>) {\n+                                    _substs: & $($mutability)? ClosureSubsts<'tcx>) {\n             }\n \n             // Convenience methods\n \n-            fn visit_location(&mut self, mir: & $($mutability)* Mir<'tcx>, location: Location) {\n-                let basic_block = & $($mutability)* mir[location.block];\n+            fn visit_location(&mut self, mir: & $($mutability)? Mir<'tcx>, location: Location) {\n+                let basic_block = & $($mutability)? mir[location.block];\n                 if basic_block.statements.len() == location.statement_index {\n-                    if let Some(ref $($mutability)* terminator) = basic_block.terminator {\n+                    if let Some(ref $($mutability)? terminator) = basic_block.terminator {\n                         self.visit_terminator(location.block, terminator, location)\n                     }\n                 } else {\n-                    let statement = & $($mutability)*\n+                    let statement = & $($mutability)?\n                         basic_block.statements[location.statement_index];\n                     self.visit_statement(location.block, statement, location)\n                 }"}, {"sha": "551554b7e7f1259a391cc7286e13c6910efe6127", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -586,31 +586,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }).0\n     }\n \n-    /// Flattens multiple binding levels into one. So `for<'a> for<'b> Foo`\n-    /// becomes `for<'a,'b> Foo`.\n-    pub fn flatten_late_bound_regions<T>(self, bound2_value: &Binder<Binder<T>>)\n-                                         -> Binder<T>\n-        where T: TypeFoldable<'tcx>\n-    {\n-        let bound0_value = bound2_value.skip_binder().skip_binder();\n-        let value = self.fold_regions(bound0_value, &mut false, |region, current_depth| {\n-            match *region {\n-                ty::ReLateBound(debruijn, br) => {\n-                    // We assume no regions bound *outside* of the\n-                    // binders in `bound2_value` (nmatsakis added in\n-                    // the course of this PR; seems like a reasonable\n-                    // sanity check though).\n-                    assert!(debruijn == current_depth);\n-                    self.mk_region(ty::ReLateBound(current_depth, br))\n-                }\n-                _ => {\n-                    region\n-                }\n-            }\n-        });\n-        Binder::bind(value)\n-    }\n-\n     /// Returns a set of all late-bound regions that are constrained\n     /// by `value`, meaning that if we instantiate those LBR with\n     /// variables and equate `value` with something else, those"}, {"sha": "9d6e728e13557556735ab1ac8bb5b3a50511efee", "filename": "src/librustc_allocator/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_allocator%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_allocator%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,3 +1,4 @@\n+#![feature(nll)]\n #![feature(rustc_private)]\n \n #![deny(rust_2018_idioms)]"}, {"sha": "6653df8ffe92eee828fcc5ada229202976150075", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -34,6 +34,7 @@\n #![forbid(unsafe_code)]\n #![deny(rust_2018_idioms)]\n \n+#![feature(nll)]\n #![feature(try_from)]\n // See librustc_cratesio_shim/Cargo.toml for a comment explaining this.\n #[allow(unused_extern_crates)]"}, {"sha": "3bdb86d313dcbb703db8bc2763a3baf9c71f1ab3", "filename": "src/librustc_asan/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_asan%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_asan%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_asan%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,4 +1,5 @@\n #![sanitizer_runtime]\n+#![feature(nll)]\n #![feature(sanitizer_runtime)]\n #![feature(staged_api)]\n #![no_std]"}, {"sha": "0aba43580f1f6e0132c764db736c1a1f35ecea06", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"rustc_codegen_ssa\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"rustc_codegen_ssa\""}, {"sha": "7f1aebace8fc67396907e53c7dd913bbc55bc056", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -9,7 +9,7 @@ use rustc_target::spec::LinkerFlavor;\n use rustc::hir::def_id::CrateNum;\n \n use super::command::Command;\n-use CrateInfo;\n+use crate::CrateInfo;\n \n use cc::windows_registry;\n use std::fs;"}, {"sha": "7f0eba7b0850bc5fd886d0c046e28bb717f94b88", "filename": "src/librustc_codegen_ssa/back/lto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flto.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,6 +1,6 @@\n use super::write::CodegenContext;\n-use traits::*;\n-use ModuleCodegen;\n+use crate::traits::*;\n+use crate::ModuleCodegen;\n \n use rustc::util::time_graph::Timeline;\n use rustc_errors::FatalError;"}, {"sha": "eeb191b09e2494a428f3ccc99c013b6fca4fd8fc", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,12 +1,12 @@\n-use {ModuleCodegen, ModuleKind, CachedModuleCodegen, CompiledModule, CrateInfo, CodegenResults,\n-    RLIB_BYTECODE_EXTENSION};\n+use crate::{ModuleCodegen, ModuleKind, CachedModuleCodegen, CompiledModule, CrateInfo,\n+    CodegenResults, RLIB_BYTECODE_EXTENSION};\n use super::linker::LinkerInfo;\n use super::lto::{self, SerializedModule};\n use super::link::{self, remove, get_linker};\n use super::command::Command;\n use super::symbol_export::ExportedSymbols;\n \n-use memmap;\n+use crate::traits::*;\n use rustc_incremental::{copy_cgu_workproducts_to_incr_comp_cache_dir,\n                         in_incr_comp_dir, in_incr_comp_dir_sess};\n use rustc::dep_graph::{WorkProduct, WorkProductId, WorkProductFileKind};\n@@ -16,7 +16,6 @@ use rustc::session::config::{self, OutputFilenames, OutputType, Passes, Sanitize\n use rustc::session::Session;\n use rustc::util::nodemap::FxHashMap;\n use rustc::util::time_graph::{self, TimeGraph, Timeline};\n-use traits::*;\n use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc::ty::TyCtxt;\n use rustc::util::common::{time_depth, set_time_depth, print_time_passes_entry};"}, {"sha": "988e3bbd71d8acf3167b35b4c40044c6ce009d64", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -13,7 +13,7 @@\n //!     but one llvm::Type corresponds to many `Ty`s; for instance, tup(int, int,\n //!     int) and rec(x=int, y=int, z=int) will have the same llvm::Type.\n \n-use {ModuleCodegen, ModuleKind, CachedModuleCodegen};\n+use crate::{ModuleCodegen, ModuleKind, CachedModuleCodegen};\n \n use rustc::dep_graph::cgu_reuse_tracker::CguReuse;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n@@ -28,26 +28,26 @@ use rustc::util::common::{time, print_time_passes_entry};\n use rustc::util::profiling::ProfileCategory;\n use rustc::session::config::{self, EntryFnType, Lto};\n use rustc::session::Session;\n-use mir::place::PlaceRef;\n-use back::write::{OngoingCodegen, start_async_codegen, submit_pre_lto_module_to_llvm,\n-    submit_post_lto_module_to_llvm};\n-use {MemFlags, CrateInfo};\n-use callee;\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n-use common::{RealPredicate, TypeKind, IntPredicate};\n-use meth;\n-use mir;\n use rustc::util::time_graph;\n use rustc_mir::monomorphize::Instance;\n use rustc_mir::monomorphize::partitioning::{CodegenUnit, CodegenUnitExt};\n-use mono_item::MonoItem;\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::sync::Lrc;\n use rustc_codegen_utils::{symbol_names_test, check_for_rustc_errors_attr};\n use rustc::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n+use crate::mir::place::PlaceRef;\n+use crate::back::write::{OngoingCodegen, start_async_codegen, submit_pre_lto_module_to_llvm,\n+    submit_post_lto_module_to_llvm};\n+use crate::{MemFlags, CrateInfo};\n+use crate::callee;\n+use crate::common::{RealPredicate, TypeKind, IntPredicate};\n+use crate::meth;\n+use crate::mir;\n+use crate::mono_item::MonoItem;\n \n-use traits::*;\n+use crate::traits::*;\n \n use std::any::Any;\n use std::cmp;\n@@ -58,7 +58,7 @@ use syntax_pos::Span;\n use syntax::attr;\n use rustc::hir;\n \n-use mir::operand::OperandValue;\n+use crate::mir::operand::OperandValue;\n \n use std::marker::PhantomData;\n "}, {"sha": "3665d45d1e9c7489e3a1b2fb7436778f1ff9d47b", "filename": "src/librustc_codegen_ssa/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcallee.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,4 +1,4 @@\n-use traits::*;\n+use crate::traits::*;\n use rustc::ty;\n use rustc::ty::subst::Substs;\n use rustc::hir::def_id::DefId;"}, {"sha": "1b87f160cc35dd6025cdc7ef73434a55f92815a7", "filename": "src/librustc_codegen_ssa/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcommon.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -5,11 +5,11 @@ use syntax_pos::{DUMMY_SP, Span};\n \n use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items::LangItem;\n-use base;\n-use traits::*;\n+use crate::base;\n+use crate::traits::*;\n \n use rustc::hir;\n-use traits::BuilderMethods;\n+use crate::traits::BuilderMethods;\n \n pub fn type_needs_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n     ty.needs_drop(tcx, ty::ParamEnv::reveal_all())\n@@ -123,7 +123,7 @@ pub enum TypeKind {\n mod temp_stable_hash_impls {\n     use rustc_data_structures::stable_hasher::{StableHasherResult, StableHasher,\n                                                HashStable};\n-    use ModuleCodegen;\n+    use crate::ModuleCodegen;\n \n     impl<HCX, M> HashStable<HCX> for ModuleCodegen<M> {\n         fn hash_stable<W: StableHasherResult>(&self,"}, {"sha": "e2b49de05bd110d40657ab20188f086c66d48ea6", "filename": "src/librustc_codegen_ssa/glue.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fglue.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -2,12 +2,10 @@\n //\n // Code relating to drop glue.\n \n-use std;\n-\n-use common::IntPredicate;\n-use meth;\n use rustc::ty::{self, Ty};\n-use traits::*;\n+use crate::common::IntPredicate;\n+use crate::meth;\n+use crate::traits::*;\n \n pub fn size_and_align_of_dst<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,"}, {"sha": "ad894bfe1cdf1c7be245cb440023df050b79e577", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -10,34 +10,19 @@\n #![feature(nll)]\n #![allow(unused_attributes)]\n #![allow(dead_code)]\n+#![deny(rust_2018_idioms)]\n+#![allow(explicit_outlives_requirements)]\n+#![allow(elided_lifetimes_in_paths)]\n \n #![recursion_limit=\"256\"]\n \n //! This crate contains codegen code that is used by all codegen backends (LLVM and others).\n //! The backend-agnostic functions of this crate use functions defined in various traits that\n //! have to be implemented by each backends.\n \n-#[macro_use] extern crate bitflags;\n #[macro_use] extern crate log;\n-extern crate rustc_apfloat;\n-#[macro_use]  extern crate rustc;\n-extern crate rustc_target;\n-extern crate rustc_mir;\n+#[macro_use] extern crate rustc;\n #[macro_use] extern crate syntax;\n-extern crate syntax_pos;\n-extern crate rustc_incremental;\n-extern crate rustc_codegen_utils;\n-extern crate rustc_data_structures;\n-extern crate rustc_allocator;\n-extern crate rustc_fs_util;\n-extern crate serialize;\n-extern crate rustc_errors;\n-extern crate rustc_demangle;\n-extern crate cc;\n-extern crate libc;\n-extern crate jobserver;\n-extern crate memmap;\n-extern crate num_cpus;\n \n use std::path::PathBuf;\n use rustc::dep_graph::WorkProduct;\n@@ -133,7 +118,7 @@ pub enum ModuleKind {\n     Allocator,\n }\n \n-bitflags! {\n+bitflags::bitflags! {\n     pub struct MemFlags: u8 {\n         const VOLATILE = 1 << 0;\n         const NONTEMPORAL = 1 << 1;"}, {"sha": "49f3c87ee2d9dc8de0eb13820a7d9b2c27a2dcf2", "filename": "src/librustc_codegen_ssa/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmeth.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,8 +1,8 @@\n use rustc_target::abi::call::FnType;\n-use callee;\n use rustc_mir::monomorphize;\n \n-use traits::*;\n+use crate::callee;\n+use crate::traits::*;\n \n use rustc::ty::{self, Ty};\n "}, {"sha": "9fe2e58bc203cffcd13c6961d08095644bd995f3", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -10,7 +10,7 @@ use rustc::mir::traversal;\n use rustc::ty;\n use rustc::ty::layout::{LayoutOf, HasTyCtxt};\n use super::FunctionCx;\n-use traits::*;\n+use crate::traits::*;\n \n pub fn non_ssa_locals<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     fx: &FunctionCx<'a, 'tcx, Bx>"}, {"sha": "af510d402eb8a61ca4551332d5ac0d104dcd025c", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -5,13 +5,13 @@ use rustc::mir;\n use rustc::mir::interpret::EvalErrorKind;\n use rustc_target::abi::call::{ArgType, FnType, PassMode};\n use rustc_target::spec::abi::Abi;\n-use base;\n-use MemFlags;\n-use common::{self, IntPredicate};\n-use meth;\n use rustc_mir::monomorphize;\n+use crate::base;\n+use crate::MemFlags;\n+use crate::common::{self, IntPredicate};\n+use crate::meth;\n \n-use traits::*;\n+use crate::traits::*;\n \n use syntax::symbol::Symbol;\n use syntax_pos::Pos;"}, {"sha": "6bc69efa4a7d5a64ca5d13ca5fc6a6a8241cee48", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -6,7 +6,7 @@ use rustc::mir::interpret::GlobalId;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout;\n use syntax::source_map::Span;\n-use traits::*;\n+use crate::traits::*;\n \n use super::FunctionCx;\n "}, {"sha": "2e2cb3dd46717f0aa11e4de1a4b673f6e1718ab7", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -4,11 +4,11 @@ use rustc::ty::layout::{TyLayout, HasTyCtxt};\n use rustc::mir::{self, Mir};\n use rustc::ty::subst::Substs;\n use rustc::session::config::DebugInfo;\n-use base;\n-use debuginfo::{self, VariableAccess, VariableKind, FunctionDebugContext};\n use rustc_mir::monomorphize::Instance;\n use rustc_target::abi::call::{FnType, PassMode};\n-use traits::*;\n+use crate::base;\n+use crate::debuginfo::{self, VariableAccess, VariableKind, FunctionDebugContext};\n+use crate::traits::*;\n \n use syntax_pos::{DUMMY_SP, NO_EXPANSION, BytePos, Span};\n use syntax::symbol::keywords;"}, {"sha": "2c6d968bb032af5709602cab3c32bc82cfc8f373", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -3,11 +3,11 @@ use rustc::mir;\n use rustc::ty;\n use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n \n-use base;\n-use MemFlags;\n-use glue;\n+use crate::base;\n+use crate::MemFlags;\n+use crate::glue;\n \n-use traits::*;\n+use crate::traits::*;\n \n use std::fmt;\n "}, {"sha": "ffc774c38ea3670d20528a55f5dcaaf80df0e07e", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -2,11 +2,11 @@ use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n use rustc::mir;\n use rustc::mir::tcx::PlaceTy;\n-use MemFlags;\n-use common::IntPredicate;\n-use glue;\n+use crate::MemFlags;\n+use crate::common::IntPredicate;\n+use crate::glue;\n \n-use traits::*;\n+use crate::traits::*;\n \n use super::{FunctionCx, LocalRef};\n use super::operand::OperandValue;"}, {"sha": "25a7754d118d739c3f2a4427d1950bbd7111491e", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -6,13 +6,13 @@ use rustc::middle::lang_items::ExchangeMallocFnLangItem;\n use rustc_apfloat::{ieee, Float, Status, Round};\n use std::{u128, i128};\n \n-use base;\n-use MemFlags;\n-use callee;\n-use common::{self, RealPredicate, IntPredicate};\n+use crate::base;\n+use crate::MemFlags;\n+use crate::callee;\n+use crate::common::{self, RealPredicate, IntPredicate};\n use rustc_mir::monomorphize;\n \n-use traits::*;\n+use crate::traits::*;\n \n use super::{FunctionCx, LocalRef};\n use super::operand::{OperandRef, OperandValue};"}, {"sha": "a1bd919c433541b89a472542100bc605a77fb06e", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,10 +1,10 @@\n use rustc::mir;\n \n-use traits::BuilderMethods;\n+use crate::traits::BuilderMethods;\n use super::FunctionCx;\n use super::LocalRef;\n use super::OperandValue;\n-use traits::*;\n+use crate::traits::*;\n \n impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn codegen_statement("}, {"sha": "bfb6a9153809a8ea4f951cdf4cd0f7ce018d66d3", "filename": "src/librustc_codegen_ssa/mono_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmono_item.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,10 +1,10 @@\n-use base;\n use rustc::hir;\n use rustc::hir::def::Def;\n use rustc::mir::mono::{Linkage, Visibility};\n use rustc::ty::layout::HasTyCtxt;\n use std::fmt;\n-use traits::*;\n+use crate::base;\n+use crate::traits::*;\n \n pub use rustc::mir::mono::MonoItem;\n "}, {"sha": "a95bf3af5bf277c10c06e49dbcb7f1a7898821ac", "filename": "src/librustc_codegen_ssa/traits/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Ftraits%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Ftraits%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fasm.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,5 +1,5 @@\n use super::BackendTypes;\n-use mir::place::PlaceRef;\n+use crate::mir::place::PlaceRef;\n use rustc::hir::{GlobalAsm, InlineAsm};\n \n pub trait AsmBuilderMethods<'tcx>: BackendTypes {"}, {"sha": "bda0f3dc779663165981b06285117e7281eec9d6", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -4,13 +4,14 @@ use super::debuginfo::DebugInfoBuilderMethods;\n use super::intrinsic::IntrinsicCallMethods;\n use super::type_::ArgTypeMethods;\n use super::{HasCodegen, StaticBuilderMethods};\n-use common::{AtomicOrdering, AtomicRmwBinOp, IntPredicate, RealPredicate, SynchronizationScope};\n-use mir::operand::OperandRef;\n-use mir::place::PlaceRef;\n+use crate::common::{AtomicOrdering, AtomicRmwBinOp, IntPredicate, RealPredicate,\n+    SynchronizationScope};\n+use crate::mir::operand::OperandRef;\n+use crate::mir::place::PlaceRef;\n+use crate::MemFlags;\n use rustc::ty::Ty;\n use rustc::ty::layout::{Align, Size};\n use std::ffi::CStr;\n-use MemFlags;\n \n use std::borrow::Cow;\n use std::ops::Range;"}, {"sha": "319f4b4e5e4b5c6b0013328baaab7e9fc370943e", "filename": "src/librustc_codegen_ssa/traits/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,5 +1,5 @@\n use super::BackendTypes;\n-use mir::place::PlaceRef;\n+use crate::mir::place::PlaceRef;\n use rustc::mir::interpret::Allocation;\n use rustc::mir::interpret::Scalar;\n use rustc::ty::layout;"}, {"sha": "0e606e744c6295f7aa9051e4899f8e78ad4b9c98", "filename": "src/librustc_codegen_ssa/traits/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,5 +1,5 @@\n use super::BackendTypes;\n-use debuginfo::{FunctionDebugContext, MirDebugScope, VariableAccess, VariableKind};\n+use crate::debuginfo::{FunctionDebugContext, MirDebugScope, VariableAccess, VariableKind};\n use rustc::hir::def_id::CrateNum;\n use rustc::mir;\n use rustc::ty::{self, Ty};"}, {"sha": "3cd0c39d4139a9c823375307c6f32c1f5c64a0d0", "filename": "src/librustc_codegen_ssa/traits/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,5 +1,5 @@\n use super::BackendTypes;\n-use mir::operand::OperandRef;\n+use crate::mir::operand::OperandRef;\n use rustc::ty::Ty;\n use rustc_target::abi::call::FnType;\n use syntax_pos::Span;"}, {"sha": "122aea035cea5151c1e627b7d6ab1d448c5efa6d", "filename": "src/librustc_codegen_ssa/traits/type_.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,8 +1,8 @@\n use super::misc::MiscMethods;\n use super::Backend;\n use super::HasCodegen;\n-use common::{self, TypeKind};\n-use mir::place::PlaceRef;\n+use crate::common::{self, TypeKind};\n+use crate::mir::place::PlaceRef;\n use rustc::ty::layout::{self, Align, Size, TyLayout};\n use rustc::ty::{self, Ty};\n use rustc::util::nodemap::FxHashMap;"}, {"sha": "e8ef815b32acb39f3dc2ff50e1d422ba91c19d5c", "filename": "src/librustc_codegen_ssa/traits/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,6 +1,6 @@\n-use back::lto::{LtoModuleCodegen, SerializedModule, ThinModule};\n-use back::write::{CodegenContext, ModuleConfig};\n-use {CompiledModule, ModuleCodegen};\n+use crate::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule};\n+use crate::back::write::{CodegenContext, ModuleConfig};\n+use crate::{CompiledModule, ModuleCodegen};\n \n use rustc::dep_graph::WorkProduct;\n use rustc::util::time_graph::Timeline;"}, {"sha": "0fc7b59ff15482be434c8dc3e67ac9d31275718d", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -4,6 +4,7 @@\n #![allow(unused_attributes)]\n #![feature(range_contains)]\n #![cfg_attr(unix, feature(libc))]\n+#![feature(nll)]\n #![feature(optin_builtin_traits)]\n #![deny(rust_2018_idioms)]\n "}, {"sha": "292ce8b0a01b0bea69a3bab3e6bfb79b32e46e14", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,4 +1,5 @@\n #![deny(rust_2018_idioms)]\n+#![feature(nll)]\n #![feature(static_nobundle)]\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]"}, {"sha": "3bdb86d313dcbb703db8bc2763a3baf9c71f1ab3", "filename": "src/librustc_lsan/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_lsan%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_lsan%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lsan%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,4 +1,5 @@\n #![sanitizer_runtime]\n+#![feature(nll)]\n #![feature(sanitizer_runtime)]\n #![feature(staged_api)]\n #![no_std]"}, {"sha": "3bdb86d313dcbb703db8bc2763a3baf9c71f1ab3", "filename": "src/librustc_msan/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_msan%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_msan%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_msan%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,4 +1,5 @@\n #![sanitizer_runtime]\n+#![feature(nll)]\n #![feature(sanitizer_runtime)]\n #![feature(staged_api)]\n #![no_std]"}, {"sha": "0ea1634c0b4c5e9c38bc63155b0e6924e14e83a0", "filename": "src/librustc_plugin/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -52,6 +52,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n+#![feature(nll)]\n #![feature(rustc_diagnostic_macros)]\n \n #![recursion_limit=\"256\"]"}, {"sha": "d31dadd3402922af1a37f0c6bc61fd320ec7df6d", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -2,6 +2,7 @@\n \n #![deny(rust_2018_idioms)]\n \n+#![feature(nll)]\n #![feature(rustc_diagnostic_macros)]\n \n #![recursion_limit=\"256\"]"}, {"sha": "ad73b30ae3fd925d60e14686fa096e8b0be8bba7", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -2,6 +2,7 @@\n \n #![feature(crate_visibility_modifier)]\n #![feature(label_break_value)]\n+#![feature(nll)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]\n "}, {"sha": "1f7b6d7733327f4ad11ac5b0de08925cf0e30b39", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,5 +1,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(custom_attribute)]\n+#![feature(nll)]\n #![deny(rust_2018_idioms)]\n #![allow(unused_attributes)]\n "}, {"sha": "3bdb86d313dcbb703db8bc2763a3baf9c71f1ab3", "filename": "src/librustc_tsan/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_tsan%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_tsan%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_tsan%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,4 +1,5 @@\n #![sanitizer_runtime]\n+#![feature(nll)]\n #![feature(sanitizer_runtime)]\n #![feature(staged_api)]\n #![no_std]"}, {"sha": "dcfcd74257e6fcb4d85c47da724483b533dbbfed", "filename": "src/librustc_typeck/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2FCargo.toml?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"rustc_typeck\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"rustc_typeck\"\n@@ -14,7 +15,7 @@ arena = { path = \"../libarena\" }\n log = \"0.4\"\n rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n-rustc_errors = { path = \"../librustc_errors\" }\n+errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n rustc_target = { path = \"../librustc_target\" }\n smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "ee3fd6e1601c2a886f52dd27f918a839abaa94df", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -3,13 +3,13 @@\n //! instance of `AstConv`.\n \n use errors::{Applicability, DiagnosticId};\n-use hir::{self, GenericArg, GenericArgs};\n-use hir::def::Def;\n-use hir::def_id::DefId;\n-use hir::HirVec;\n-use lint;\n-use middle::resolve_lifetime as rl;\n-use namespace::Namespace;\n+use crate::hir::{self, GenericArg, GenericArgs};\n+use crate::hir::def::Def;\n+use crate::hir::def_id::DefId;\n+use crate::hir::HirVec;\n+use crate::lint;\n+use crate::middle::resolve_lifetime as rl;\n+use crate::namespace::Namespace;\n use rustc::lint::builtin::AMBIGUOUS_ASSOCIATED_ITEMS;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n@@ -18,15 +18,15 @@ use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::ty::wf::object_region_bounds;\n use rustc_data_structures::sync::Lrc;\n use rustc_target::spec::abi;\n-use require_c_abi_if_variadic;\n+use crate::require_c_abi_if_variadic;\n use smallvec::SmallVec;\n use syntax::ast;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{DUMMY_SP, Span, MultiSpan};\n-use util::common::ErrorReported;\n-use util::nodemap::FxHashMap;\n+use crate::util::common::ErrorReported;\n+use crate::util::nodemap::FxHashMap;\n \n use std::collections::BTreeSet;\n use std::iter;"}, {"sha": "3a670c8e2f15eca152fd121efb651ad3b2e33420", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,5 +1,6 @@\n-use check::{FnCtxt, Expectation, Diverges, Needs};\n-use check::coercion::CoerceMany;\n+use crate::check::{FnCtxt, Expectation, Diverges, Needs};\n+use crate::check::coercion::CoerceMany;\n+use crate::util::nodemap::FxHashMap;\n use errors::Applicability;\n use rustc::hir::{self, PatKind};\n use rustc::hir::def::{Def, CtorKind};\n@@ -13,7 +14,6 @@ use syntax::source_map::Spanned;\n use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n-use util::nodemap::FxHashMap;\n \n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::cmp;"}, {"sha": "be6d432a67f9ee1f5902ad0d5b2a162651500195", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -31,8 +31,8 @@\n use super::FnCtxt;\n \n use errors::{DiagnosticBuilder,Applicability};\n-use hir::def_id::DefId;\n-use lint;\n+use crate::hir::def_id::DefId;\n+use crate::lint;\n use rustc::hir;\n use rustc::session::Session;\n use rustc::traits;\n@@ -43,7 +43,7 @@ use rustc::ty::subst::Substs;\n use rustc::middle::lang_items;\n use syntax::ast;\n use syntax_pos::Span;\n-use util::common::ErrorReported;\n+use crate::util::common::ErrorReported;\n \n /// Reifies a cast check to be checked once we have full type information for\n /// a function context.\n@@ -294,7 +294,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                                   .emit();\n             }\n             CastError::SizedUnsizedCast => {\n-                use structured_errors::{SizedUnsizedCastError, StructuredDiagnostic};\n+                use crate::structured_errors::{SizedUnsizedCastError, StructuredDiagnostic};\n                 SizedUnsizedCastError::new(&fcx.tcx.sess,\n                                            self.span,\n                                            self.expr_ty,"}, {"sha": "24c300911b384d5705bf43b24380b66bf36079cd", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -2,8 +2,8 @@\n \n use super::{check_fn, Expectation, FnCtxt, GeneratorTypes};\n \n-use astconv::AstConv;\n-use middle::region;\n+use crate::astconv::AstConv;\n+use crate::middle::region;\n use rustc::hir::def_id::DefId;\n use rustc::infer::{InferOk, InferResult};\n use rustc::infer::LateBoundRegionConversionTime;"}, {"sha": "8a91e425db7bf40d194f2994bbafc60e81a4c307", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -50,7 +50,7 @@\n //! sort of a minor point so I've opted to leave it for later---after all\n //! we may want to adjust precisely when coercions occur.\n \n-use check::{FnCtxt, Needs};\n+use crate::check::{FnCtxt, Needs};\n use errors::DiagnosticBuilder;\n use rustc::hir;\n use rustc::hir::def_id::DefId;"}, {"sha": "82f00374521bd4c5ea753af501053d29854d15f2", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,4 +1,4 @@\n-use check::FnCtxt;\n+use crate::check::FnCtxt;\n use rustc::infer::InferOk;\n use rustc::traits::{ObligationCause, ObligationCauseCode};\n "}, {"sha": "0fc8241ef9d14aea15316fb30c97ac953a86e157", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,13 +1,13 @@\n-use check::regionck::RegionCtxt;\n+use crate::check::regionck::RegionCtxt;\n \n-use hir::def_id::DefId;\n+use crate::hir::def_id::DefId;\n use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::infer::{self, InferOk, SuppressRegionErrors};\n use rustc::middle::region;\n use rustc::traits::{ObligationCause, TraitEngine, TraitEngineExt};\n use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt};\n-use util::common::ErrorReported;\n+use crate::util::common::ErrorReported;\n \n use syntax::ast;\n use syntax_pos::Span;"}, {"sha": "7f4b0a96a15ab19c0e9acfda97fea432b1dd83fd", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -11,7 +11,7 @@ use rustc::ty::{self, Ty};\n use rustc_data_structures::sync::Lrc;\n use syntax_pos::Span;\n use super::FnCtxt;\n-use util::nodemap::FxHashMap;\n+use crate::util::nodemap::FxHashMap;\n \n struct InteriorVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,"}, {"sha": "912ea39dce3ce6a552e2c0415e71f514a5787051", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -4,7 +4,7 @@\n use rustc::traits::{ObligationCause, ObligationCauseCode};\n use rustc::ty::{self, TyCtxt, Ty};\n use rustc::ty::subst::Subst;\n-use require_same_types;\n+use crate::require_same_types;\n \n use rustc_target::spec::abi::Abi;\n use syntax::symbol::Symbol;"}, {"sha": "34b248a106cb08cdb425afc3e0f68c6938429070", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,9 +1,9 @@\n use super::{probe, MethodCallee};\n \n-use astconv::AstConv;\n-use check::{FnCtxt, PlaceOp, callee, Needs};\n-use hir::GenericArg;\n-use hir::def_id::DefId;\n+use crate::astconv::AstConv;\n+use crate::check::{FnCtxt, PlaceOp, callee, Needs};\n+use crate::hir::GenericArg;\n+use crate::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, Ty, GenericParamDefKind};"}, {"sha": "02cd5b79855947962d828e80f60d5f6912f164fb", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -10,9 +10,9 @@ pub use self::MethodError::*;\n pub use self::CandidateSource::*;\n pub use self::suggest::{SelfSource, TraitInfo};\n \n-use check::FnCtxt;\n+use crate::check::FnCtxt;\n+use crate::namespace::Namespace;\n use errors::{Applicability, DiagnosticBuilder};\n-use namespace::Namespace;\n use rustc_data_structures::sync::Lrc;\n use rustc::hir;\n use rustc::hir::def::Def;\n@@ -29,7 +29,7 @@ use syntax_pos::Span;\n use crate::{check_type_alias_enum_variants_enabled};\n use self::probe::{IsSuggestion, ProbeScope};\n \n-pub fn provide(providers: &mut ty::query::Providers) {\n+pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     suggest::provide(providers);\n     probe::provide(providers);\n }"}, {"sha": "cf31a54a54b369923b496b2710512ca2c2cd97ba", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -3,11 +3,11 @@ use super::NoMatchData;\n use super::{CandidateSource, ImplSource, TraitSource};\n use super::suggest;\n \n-use check::autoderef::{self, Autoderef};\n-use check::FnCtxt;\n-use hir::def_id::DefId;\n-use hir::def::Def;\n-use namespace::Namespace;\n+use crate::check::autoderef::{self, Autoderef};\n+use crate::check::FnCtxt;\n+use crate::hir::def_id::DefId;\n+use crate::hir::def::Def;\n+use crate::namespace::Namespace;\n \n use rustc_data_structures::sync::Lrc;\n use rustc::hir;"}, {"sha": "8f98b347b4cc695c905afa6391b3add6060a407e", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,10 +1,11 @@\n //! Give useful errors and suggestions to users when an item can't be\n //! found or is otherwise invalid.\n \n-use check::FnCtxt;\n+use crate::check::FnCtxt;\n+use crate::middle::lang_items::FnOnceTraitLangItem;\n+use crate::namespace::Namespace;\n+use crate::util::nodemap::FxHashSet;\n use errors::{Applicability, DiagnosticBuilder};\n-use middle::lang_items::FnOnceTraitLangItem;\n-use namespace::Namespace;\n use rustc_data_structures::sync::Lrc;\n use rustc::hir::{self, ExprKind, Node, QPath};\n use rustc::hir::def::Def;\n@@ -15,7 +16,6 @@ use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::traits::Obligation;\n use rustc::ty::{self, Adt, Ty, TyCtxt, ToPolyTraitRef, ToPredicate, TypeFoldable};\n use rustc::ty::item_path::with_crate_prefix;\n-use util::nodemap::FxHashSet;\n use syntax_pos::{Span, FileName};\n use syntax::ast;\n use syntax::util::lev_distance::find_best_match_for_name;"}, {"sha": "467032f05d6a8e552c9f63fa1717013b70ef3fba", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -83,15 +83,15 @@ mod generator_interior;\n pub mod intrinsic;\n mod op;\n \n-use astconv::{AstConv, PathSeg};\n+use crate::astconv::{AstConv, PathSeg};\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n use rustc::hir::{self, ExprKind, GenericArg, ItemKind, Node, PatKind, QPath};\n use rustc::hir::def::{CtorKind, Def};\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use middle::lang_items;\n-use namespace::Namespace;\n+use crate::middle::lang_items;\n+use crate::namespace::Namespace;\n use rustc::infer::{self, InferCtxt, InferOk, InferResult, RegionVariableOrigin};\n use rustc::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n use rustc_data_structures::indexed_vec::Idx;\n@@ -130,14 +130,14 @@ use std::mem::replace;\n use std::ops::{self, Deref};\n use std::slice;\n \n-use require_c_abi_if_variadic;\n-use session::{CompileIncomplete, Session};\n-use session::config::EntryFnType;\n-use TypeAndSubsts;\n-use lint;\n-use util::captures::Captures;\n-use util::common::{ErrorReported, indenter};\n-use util::nodemap::{DefIdMap, DefIdSet, FxHashMap, FxHashSet, NodeMap};\n+use crate::require_c_abi_if_variadic;\n+use crate::session::{CompileIncomplete, Session};\n+use crate::session::config::EntryFnType;\n+use crate::TypeAndSubsts;\n+use crate::lint;\n+use crate::util::captures::Captures;\n+use crate::util::common::{ErrorReported, indenter};\n+use crate::util::nodemap::{DefIdMap, DefIdSet, FxHashMap, FxHashSet, NodeMap};\n \n pub use self::Expectation::*;\n use self::autoderef::Autoderef;\n@@ -3044,7 +3044,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // arguments which we skipped above.\n         if variadic {\n             fn variadic_error<'tcx>(s: &Session, span: Span, t: Ty<'tcx>, cast_ty: &str) {\n-                use structured_errors::{VariadicError, StructuredDiagnostic};\n+                use crate::structured_errors::{VariadicError, StructuredDiagnostic};\n                 VariadicError::new(s, span, t, cast_ty).diagnostic().emit();\n             }\n \n@@ -3685,8 +3685,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         display\n     }\n \n-    fn no_such_field_err<T: Display>(&self, span: Span, field: T, expr_t: &ty::TyS)\n-        -> DiagnosticBuilder {\n+    fn no_such_field_err<T: Display>(&self, span: Span, field: T, expr_t: &ty::TyS<'_>)\n+        -> DiagnosticBuilder<'_> {\n         type_error_struct!(self.tcx().sess, span, expr_t, E0609,\n                            \"no field `{}` on type `{}`\",\n                            field, expr_t)\n@@ -5257,7 +5257,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         blk: &'gcx hir::Block,\n         expected_ty: Ty<'tcx>,\n-        err: &mut DiagnosticBuilder,\n+        err: &mut DiagnosticBuilder<'_>,\n     ) {\n         if let Some(span_semi) = self.could_remove_semicolon(blk, expected_ty) {\n             err.span_suggestion(\n@@ -5725,7 +5725,7 @@ fn fatally_break_rust(sess: &Session) {\n     );\n     handler.note_without_error(&format!(\"rustc {} running on {}\",\n         option_env!(\"CFG_VERSION\").unwrap_or(\"unknown_version\"),\n-        ::session::config::host_triple(),\n+        crate::session::config::host_triple(),\n     ));\n }\n "}, {"sha": "c058977181c9bd534b759c919d96d4d385efcc46", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -72,11 +72,11 @@\n //! relation, except that a borrowed pointer never owns its\n //! contents.\n \n-use check::dropck;\n-use check::FnCtxt;\n-use middle::mem_categorization as mc;\n-use middle::mem_categorization::Categorization;\n-use middle::region;\n+use crate::check::dropck;\n+use crate::check::FnCtxt;\n+use crate::middle::mem_categorization as mc;\n+use crate::middle::mem_categorization::Categorization;\n+use crate::middle::region;\n use rustc::hir::def_id::DefId;\n use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::infer::{self, RegionObligation, SuppressRegionErrors};"}, {"sha": "1816b7454dd2d12174d71dbe4427ccee560b1901", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -32,9 +32,9 @@\n \n use super::FnCtxt;\n \n-use middle::expr_use_visitor as euv;\n-use middle::mem_categorization as mc;\n-use middle::mem_categorization::Categorization;\n+use crate::middle::expr_use_visitor as euv;\n+use crate::middle::mem_categorization as mc;\n+use crate::middle::mem_categorization::Categorization;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::def_id::LocalDefId;"}, {"sha": "b51fd58b75c20063c534fda4401149947e07add1", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,7 +1,7 @@\n-use check::{Inherited, FnCtxt};\n-use constrained_type_params::{identify_constrained_type_params, Parameter};\n+use crate::check::{Inherited, FnCtxt};\n+use crate::constrained_type_params::{identify_constrained_type_params, Parameter};\n \n-use hir::def_id::DefId;\n+use crate::hir::def_id::DefId;\n use rustc::traits::{self, ObligationCauseCode};\n use rustc::ty::{self, Lift, Ty, TyCtxt, TyKind, GenericParamDefKind, TypeFoldable, ToPredicate};\n use rustc::ty::subst::{Subst, Substs};"}, {"sha": "e02e70651d6c130d26e306a9975a843890293308", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -2,7 +2,7 @@\n // unresolved type variables and replaces \"ty_var\" types with their\n // substitutions.\n \n-use check::FnCtxt;\n+use crate::check::FnCtxt;\n use errors::DiagnosticBuilder;\n use rustc::hir;\n use rustc::hir::def_id::{DefId, DefIndex};"}, {"sha": "18194eeba80a273bcf85285911e6c2d47612ff03", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,4 +1,4 @@\n-use lint;\n+use crate::lint;\n use rustc::ty::TyCtxt;\n \n use errors::Applicability;"}, {"sha": "138c598a7bbf0c1340c474fe12ca2e73740533a7", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,11 +1,11 @@\n-use namespace::Namespace;\n+use crate::namespace::Namespace;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::traits::{self, IntercrateMode};\n use rustc::ty::TyCtxt;\n \n-use lint;\n+use crate::lint;\n \n pub fn crate_inherent_impls_overlap_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                     crate_num: CrateNum) {"}, {"sha": "4eee68b99d968433ead88b0c424b26b75844c964", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -5,7 +5,7 @@\n // done by the orphan and overlap modules. Then we build up various\n // mappings. That mapping code resides here.\n \n-use hir::def_id::{DefId, LOCAL_CRATE};\n+use crate::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::traits;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n use rustc::ty::query::Providers;"}, {"sha": "bb4fba105f7326ac3419e26e170085cb1b140477", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -14,13 +14,13 @@\n //! At present, however, we do run collection across all items in the\n //! crate as a kind of pass. This should eventually be factored away.\n \n-use astconv::{AstConv, Bounds};\n-use constrained_type_params as ctp;\n-use check::intrinsic::intrisic_operation_unsafety;\n-use lint;\n-use middle::lang_items::SizedTraitLangItem;\n-use middle::resolve_lifetime as rl;\n-use middle::weak_lang_items;\n+use crate::astconv::{AstConv, Bounds};\n+use crate::constrained_type_params as ctp;\n+use crate::check::intrinsic::intrisic_operation_unsafety;\n+use crate::lint;\n+use crate::middle::lang_items::SizedTraitLangItem;\n+use crate::middle::resolve_lifetime as rl;\n+use crate::middle::weak_lang_items;\n use rustc::mir::mono::Linkage;\n use rustc::ty::query::Providers;\n use rustc::ty::subst::Substs;\n@@ -68,7 +68,7 @@ fn collect_mod_item_types<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefI\n     );\n }\n \n-pub fn provide(providers: &mut Providers) {\n+pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers {\n         type_of,\n         generics_of,"}, {"sha": "d1f33b65fc07a510fde0102f056ae1fca5f48e9b", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -124,7 +124,7 @@ pub fn identify_constrained_type_params<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n /// which is determined by 1, which requires `U`, that is determined\n /// by 0. I should probably pick a less tangled example, but I can't\n /// think of any.\n-pub fn setup_constraining_predicates<'tcx>(tcx: TyCtxt,\n+pub fn setup_constraining_predicates<'tcx>(tcx: TyCtxt<'_, '_, '_>,\n                                            predicates: &mut [(ty::Predicate<'tcx>, Span)],\n                                            impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n                                            input_parameters: &mut FxHashSet<Parameter>)"}, {"sha": "6de06b64816959334d2ff3199649087a532f765e", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -8,7 +8,7 @@\n //! specialization errors. These things can (and probably should) be\n //! fixed, but for the moment it's easier to do these checks early.\n \n-use constrained_type_params as ctp;\n+use crate::constrained_type_params as ctp;\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::def_id::DefId;\n@@ -162,7 +162,7 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // used elsewhere are not projected back out.\n }\n \n-fn report_unused_parameter(tcx: TyCtxt,\n+fn report_unused_parameter(tcx: TyCtxt<'_, '_, '_>,\n                            span: Span,\n                            kind: &str,\n                            name: &str)"}, {"sha": "e99ec539c772137110c447413fc5818e38d6591c", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -72,17 +72,15 @@ This API is completely unstable and subject to change.\n \n #![recursion_limit=\"256\"]\n \n+#![deny(rust_2018_idioms)]\n+#![allow(explicit_outlives_requirements)]\n+\n+#![allow(elided_lifetimes_in_paths)] // WIP\n+\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n-extern crate syntax_pos;\n-\n-extern crate arena;\n \n #[macro_use] extern crate rustc;\n-extern crate rustc_data_structures;\n-extern crate rustc_errors as errors;\n-extern crate rustc_target;\n-extern crate smallvec;\n \n // N.B., this module needs to be declared first so diagnostics are\n // registered before they are used.\n@@ -141,7 +139,7 @@ fn check_type_alias_enum_variants_enabled<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx,\n     }\n }\n \n-fn require_c_abi_if_variadic(tcx: TyCtxt,\n+fn require_c_abi_if_variadic(tcx: TyCtxt<'_, '_, '_>,\n                              decl: &hir::FnDecl,\n                              abi: Abi,\n                              span: Span) {\n@@ -310,7 +308,7 @@ fn check_for_entry_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     }\n }\n \n-pub fn provide(providers: &mut Providers) {\n+pub fn provide(providers: &mut Providers<'_>) {\n     collect::provide(providers);\n     coherence::provide(providers);\n     check::provide(providers);"}, {"sha": "574086f780a9d01683525e8bfa1825b2ecac29d0", "filename": "src/librustc_typeck/outlives/explicit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,6 +1,6 @@\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, OutlivesPredicate, TyCtxt};\n-use util::nodemap::FxHashMap;\n+use crate::util::nodemap::FxHashMap;\n \n use super::utils::*;\n "}, {"sha": "0ff884d72b19fac8bb7067b6d6f2384d5d3f8aa7", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,5 +1,4 @@\n-use rustc::hir;\n-use hir::Node;\n+use rustc::hir::{self, Node};\n use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::subst::{Kind, Subst, UnpackedKind};"}, {"sha": "b3634d37cc2b8553620e3e1f17711046b6b98f0b", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -12,7 +12,7 @@ mod implicit_infer;\n pub mod test;\n mod utils;\n \n-pub fn provide(providers: &mut Providers) {\n+pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers {\n         inferred_outlives_of,\n         inferred_outlives_crate,"}, {"sha": "ec0acfb63a89a2354fc0f783b489fa81238efca7", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -15,7 +15,7 @@ use std::fmt;\n use syntax::ast;\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use util::nodemap::NodeMap;\n+use crate::util::nodemap::NodeMap;\n \n use self::VarianceTerm::*;\n "}, {"sha": "949af0e2b97464a9c030c054cb9fca16b004569e", "filename": "src/libserialize/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibserialize%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibserialize%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2FCargo.toml?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"serialize\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"serialize\""}, {"sha": "c0a8fa9d0016dba395a62aa036d90b78f6b54e9c", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -2,7 +2,7 @@\n \n use std::hash::{Hash, BuildHasher};\n \n-use {Decodable, Encodable, Decoder, Encoder};\n+use crate::{Decodable, Encodable, Decoder, Encoder};\n use std::collections::{LinkedList, VecDeque, BTreeMap, BTreeSet, HashMap, HashSet};\n use std::rc::Rc;\n use std::sync::Arc;"}, {"sha": "73b9122b13cea679a18d6c4974b580f87d4717a7", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -60,7 +60,7 @@ pub enum FromHexError {\n }\n \n impl fmt::Display for FromHexError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             InvalidHexCharacter(ch, idx) =>\n                 write!(f, \"Invalid character '{}' at position {}\", ch, idx),\n@@ -145,8 +145,8 @@ impl FromHex for str {\n #[cfg(test)]\n mod tests {\n     extern crate test;\n-    use self::test::Bencher;\n-    use hex::{FromHex, ToHex};\n+    use test::Bencher;\n+    use crate::hex::{FromHex, ToHex};\n \n     #[test]\n     pub fn test_to_hex() {"}, {"sha": "5b3444b9f456f33d94ac14f6db30bb8faa26d144", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 32, "deletions": 1310, "changes": 1342, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -199,9 +199,8 @@ use std::ops::Index;\n use std::str::FromStr;\n use std::string;\n use std::{char, f64, fmt, str};\n-use std;\n \n-use Encodable;\n+use crate::Encodable;\n \n /// Represents a json value\n #[derive(Clone, PartialEq, PartialOrd, Debug)]\n@@ -221,8 +220,8 @@ pub type Object = BTreeMap<string::String, Json>;\n \n pub struct PrettyJson<'a> { inner: &'a Json }\n \n-pub struct AsJson<'a, T: 'a> { inner: &'a T }\n-pub struct AsPrettyJson<'a, T: 'a> { inner: &'a T, indent: Option<usize> }\n+pub struct AsJson<'a, T> { inner: &'a T }\n+pub struct AsPrettyJson<'a, T> { inner: &'a T, indent: Option<usize> }\n \n /// The errors that can arise while parsing a JSON stream.\n #[derive(Clone, Copy, PartialEq, Debug)]\n@@ -295,18 +294,18 @@ pub fn error_str(error: ErrorCode) -> &'static str {\n }\n \n /// Shortcut function to decode a JSON `&str` into an object\n-pub fn decode<T: ::Decodable>(s: &str) -> DecodeResult<T> {\n+pub fn decode<T: crate::Decodable>(s: &str) -> DecodeResult<T> {\n     let json = match from_str(s) {\n         Ok(x) => x,\n         Err(e) => return Err(ParseError(e))\n     };\n \n     let mut decoder = Decoder::new(json);\n-    ::Decodable::decode(&mut decoder)\n+    crate::Decodable::decode(&mut decoder)\n }\n \n /// Shortcut function to encode a `T` into a JSON `String`\n-pub fn encode<T: ::Encodable>(object: &T) -> Result<string::String, EncoderError> {\n+pub fn encode<T: crate::Encodable>(object: &T) -> Result<string::String, EncoderError> {\n     let mut s = String::new();\n     {\n         let mut encoder = Encoder::new(&mut s);\n@@ -316,7 +315,7 @@ pub fn encode<T: ::Encodable>(object: &T) -> Result<string::String, EncoderError\n }\n \n impl fmt::Display for ErrorCode {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         error_str(*self).fmt(f)\n     }\n }\n@@ -326,14 +325,14 @@ fn io_error_to_error(io: io::Error) -> ParserError {\n }\n \n impl fmt::Display for ParserError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // FIXME this should be a nicer error\n         fmt::Debug::fmt(self, f)\n     }\n }\n \n impl fmt::Display for DecoderError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // FIXME this should be a nicer error\n         fmt::Debug::fmt(self, f)\n     }\n@@ -344,7 +343,7 @@ impl std::error::Error for DecoderError {\n }\n \n impl fmt::Display for EncoderError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // FIXME this should be a nicer error\n         fmt::Debug::fmt(self, f)\n     }\n@@ -477,7 +476,7 @@ macro_rules! emit_enquoted_if_mapkey {\n     })\n }\n \n-impl<'a> ::Encoder for Encoder<'a> {\n+impl<'a> crate::Encoder for Encoder<'a> {\n     type Error = EncoderError;\n \n     fn emit_unit(&mut self) -> EncodeResult {\n@@ -727,7 +726,7 @@ impl<'a> PrettyEncoder<'a> {\n     }\n }\n \n-impl<'a> ::Encoder for PrettyEncoder<'a> {\n+impl<'a> crate::Encoder for PrettyEncoder<'a> {\n     type Error = EncoderError;\n \n     fn emit_unit(&mut self) -> EncodeResult {\n@@ -997,7 +996,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n }\n \n impl Encodable for Json {\n-    fn encode<E: ::Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n+    fn encode<E: crate::Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n         match *self {\n             Json::I64(v) => v.encode(e),\n             Json::U64(v) => v.encode(e),\n@@ -1013,20 +1012,20 @@ impl Encodable for Json {\n \n /// Create an `AsJson` wrapper which can be used to print a value as JSON\n /// on-the-fly via `write!`\n-pub fn as_json<T>(t: &T) -> AsJson<T> {\n+pub fn as_json<T>(t: &T) -> AsJson<'_, T> {\n     AsJson { inner: t }\n }\n \n /// Create an `AsPrettyJson` wrapper which can be used to print a value as JSON\n /// on-the-fly via `write!`\n-pub fn as_pretty_json<T>(t: &T) -> AsPrettyJson<T> {\n+pub fn as_pretty_json<T>(t: &T) -> AsPrettyJson<'_, T> {\n     AsPrettyJson { inner: t, indent: None }\n }\n \n impl Json {\n     /// Borrow this json object as a pretty object to generate a pretty\n     /// representation for it via `Display`.\n-    pub fn pretty(&self) -> PrettyJson {\n+    pub fn pretty(&self) -> PrettyJson<'_> {\n         PrettyJson { inner: self }\n     }\n \n@@ -1300,7 +1299,7 @@ impl Stack {\n     /// Provides access to the StackElement at a given index.\n     /// lower indices are at the bottom of the stack while higher indices are\n     /// at the top.\n-    pub fn get(&self, idx: usize) -> StackElement {\n+    pub fn get(&self, idx: usize) -> StackElement<'_> {\n         match self.stack[idx] {\n             InternalIndex(i) => StackElement::Index(i),\n             InternalKey(start, size) => {\n@@ -1311,8 +1310,8 @@ impl Stack {\n         }\n     }\n \n-    /// Compares this stack with an array of StackElements.\n-    pub fn is_equal_to(&self, rhs: &[StackElement]) -> bool {\n+    /// Compares this stack with an array of StackElement<'_>s.\n+    pub fn is_equal_to(&self, rhs: &[StackElement<'_>]) -> bool {\n         if self.stack.len() != rhs.len() { return false; }\n         for (i, r) in rhs.iter().enumerate() {\n             if self.get(i) != *r { return false; }\n@@ -1322,7 +1321,7 @@ impl Stack {\n \n     /// Returns true if the bottom-most elements of this stack are the same as\n     /// the ones passed as parameter.\n-    pub fn starts_with(&self, rhs: &[StackElement]) -> bool {\n+    pub fn starts_with(&self, rhs: &[StackElement<'_>]) -> bool {\n         if self.stack.len() < rhs.len() { return false; }\n         for (i, r) in rhs.iter().enumerate() {\n             if self.get(i) != *r { return false; }\n@@ -1332,7 +1331,7 @@ impl Stack {\n \n     /// Returns true if the top-most elements of this stack are the same as\n     /// the ones passed as parameter.\n-    pub fn ends_with(&self, rhs: &[StackElement]) -> bool {\n+    pub fn ends_with(&self, rhs: &[StackElement<'_>]) -> bool {\n         if self.stack.len() < rhs.len() { return false; }\n         let offset = self.stack.len() - rhs.len();\n         for (i, r) in rhs.iter().enumerate() {\n@@ -1342,7 +1341,7 @@ impl Stack {\n     }\n \n     /// Returns the top-most element (if any).\n-    pub fn top(&self) -> Option<StackElement> {\n+    pub fn top(&self) -> Option<StackElement<'_>> {\n         match self.stack.last() {\n             None => None,\n             Some(&InternalIndex(i)) => Some(StackElement::Index(i)),\n@@ -2115,7 +2114,7 @@ macro_rules! read_primitive {\n     }\n }\n \n-impl ::Decoder for Decoder {\n+impl crate::Decoder for Decoder {\n     type Error = DecoderError;\n \n     fn read_nil(&mut self) -> DecodeResult<()> {\n@@ -2172,7 +2171,7 @@ impl ::Decoder for Decoder {\n         Err(ExpectedError(\"single character string\".to_owned(), s.to_string()))\n     }\n \n-    fn read_str(&mut self) -> DecodeResult<Cow<str>> {\n+    fn read_str(&mut self) -> DecodeResult<Cow<'_, str>> {\n         expect!(self.pop(), String).map(Cow::Owned)\n     }\n \n@@ -2518,7 +2517,7 @@ impl<'a, 'b> fmt::Write for FormatShim<'a, 'b> {\n \n impl fmt::Display for Json {\n     /// Encodes a json value into a string\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n         let mut encoder = Encoder::new(&mut shim);\n         match self.encode(&mut encoder) {\n@@ -2530,7 +2529,7 @@ impl fmt::Display for Json {\n \n impl<'a> fmt::Display for PrettyJson<'a> {\n     /// Encodes a json value into a string\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n         let mut encoder = PrettyEncoder::new(&mut shim);\n         match self.inner.encode(&mut encoder) {\n@@ -2542,7 +2541,7 @@ impl<'a> fmt::Display for PrettyJson<'a> {\n \n impl<'a, T: Encodable> fmt::Display for AsJson<'a, T> {\n     /// Encodes a json value into a string\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n         let mut encoder = Encoder::new(&mut shim);\n         match self.inner.encode(&mut encoder) {\n@@ -2562,7 +2561,7 @@ impl<'a, T> AsPrettyJson<'a, T> {\n \n impl<'a, T: Encodable> fmt::Display for AsPrettyJson<'a, T> {\n     /// Encodes a json value into a string\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n         let mut encoder = PrettyEncoder::new(&mut shim);\n         if let Some(n) = self.indent {\n@@ -2584,1220 +2583,13 @@ impl FromStr for Json {\n \n #[cfg(test)]\n mod tests {\n+    // Benchmarks and tests that require private items\n+\n     extern crate test;\n-    use self::Animal::*;\n-    use self::test::Bencher;\n-    use {Encodable, Decodable};\n-    use super::Json::*;\n-    use super::ErrorCode::*;\n-    use super::ParserError::*;\n-    use super::DecoderError::*;\n-    use super::JsonEvent::*;\n-    use super::{Json, from_str, DecodeResult, DecoderError, JsonEvent, Parser,\n-                StackElement, Stack, Decoder, Encoder, EncoderError};\n-    use std::{i64, u64, f32, f64};\n-    use std::io::prelude::*;\n-    use std::collections::BTreeMap;\n+    use test::Bencher;\n+    use super::{from_str, Parser, StackElement, Stack};\n     use std::string;\n \n-    #[derive(RustcDecodable, Eq, PartialEq, Debug)]\n-    struct OptionData {\n-        opt: Option<usize>,\n-    }\n-\n-    #[test]\n-    fn test_decode_option_none() {\n-        let s =\"{}\";\n-        let obj: OptionData = super::decode(s).unwrap();\n-        assert_eq!(obj, OptionData { opt: None });\n-    }\n-\n-    #[test]\n-    fn test_decode_option_some() {\n-        let s = \"{ \\\"opt\\\": 10 }\";\n-        let obj: OptionData = super::decode(s).unwrap();\n-        assert_eq!(obj, OptionData { opt: Some(10) });\n-    }\n-\n-    #[test]\n-    fn test_decode_option_malformed() {\n-        check_err::<OptionData>(\"{ \\\"opt\\\": [] }\",\n-                                ExpectedError(\"Number\".to_string(), \"[]\".to_string()));\n-        check_err::<OptionData>(\"{ \\\"opt\\\": false }\",\n-                                ExpectedError(\"Number\".to_string(), \"false\".to_string()));\n-    }\n-\n-    #[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n-    enum Animal {\n-        Dog,\n-        Frog(string::String, isize)\n-    }\n-\n-    #[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n-    struct Inner {\n-        a: (),\n-        b: usize,\n-        c: Vec<string::String>,\n-    }\n-\n-    #[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n-    struct Outer {\n-        inner: Vec<Inner>,\n-    }\n-\n-    fn mk_object(items: &[(string::String, Json)]) -> Json {\n-        let mut d = BTreeMap::new();\n-\n-        for item in items {\n-            match *item {\n-                (ref key, ref value) => { d.insert((*key).clone(), (*value).clone()); },\n-            }\n-        };\n-\n-        Object(d)\n-    }\n-\n-    #[test]\n-    fn test_from_str_trait() {\n-        let s = \"null\";\n-        assert!(s.parse::<Json>().unwrap() == s.parse().unwrap());\n-    }\n-\n-    #[test]\n-    fn test_write_null() {\n-        assert_eq!(Null.to_string(), \"null\");\n-        assert_eq!(Null.pretty().to_string(), \"null\");\n-    }\n-\n-    #[test]\n-    fn test_write_i64() {\n-        assert_eq!(U64(0).to_string(), \"0\");\n-        assert_eq!(U64(0).pretty().to_string(), \"0\");\n-\n-        assert_eq!(U64(1234).to_string(), \"1234\");\n-        assert_eq!(U64(1234).pretty().to_string(), \"1234\");\n-\n-        assert_eq!(I64(-5678).to_string(), \"-5678\");\n-        assert_eq!(I64(-5678).pretty().to_string(), \"-5678\");\n-\n-        assert_eq!(U64(7650007200025252000).to_string(), \"7650007200025252000\");\n-        assert_eq!(U64(7650007200025252000).pretty().to_string(), \"7650007200025252000\");\n-    }\n-\n-    #[test]\n-    fn test_write_f64() {\n-        assert_eq!(F64(3.0).to_string(), \"3.0\");\n-        assert_eq!(F64(3.0).pretty().to_string(), \"3.0\");\n-\n-        assert_eq!(F64(3.1).to_string(), \"3.1\");\n-        assert_eq!(F64(3.1).pretty().to_string(), \"3.1\");\n-\n-        assert_eq!(F64(-1.5).to_string(), \"-1.5\");\n-        assert_eq!(F64(-1.5).pretty().to_string(), \"-1.5\");\n-\n-        assert_eq!(F64(0.5).to_string(), \"0.5\");\n-        assert_eq!(F64(0.5).pretty().to_string(), \"0.5\");\n-\n-        assert_eq!(F64(f64::NAN).to_string(), \"null\");\n-        assert_eq!(F64(f64::NAN).pretty().to_string(), \"null\");\n-\n-        assert_eq!(F64(f64::INFINITY).to_string(), \"null\");\n-        assert_eq!(F64(f64::INFINITY).pretty().to_string(), \"null\");\n-\n-        assert_eq!(F64(f64::NEG_INFINITY).to_string(), \"null\");\n-        assert_eq!(F64(f64::NEG_INFINITY).pretty().to_string(), \"null\");\n-    }\n-\n-    #[test]\n-    fn test_write_str() {\n-        assert_eq!(String(\"\".to_string()).to_string(), \"\\\"\\\"\");\n-        assert_eq!(String(\"\".to_string()).pretty().to_string(), \"\\\"\\\"\");\n-\n-        assert_eq!(String(\"homura\".to_string()).to_string(), \"\\\"homura\\\"\");\n-        assert_eq!(String(\"madoka\".to_string()).pretty().to_string(), \"\\\"madoka\\\"\");\n-    }\n-\n-    #[test]\n-    fn test_write_bool() {\n-        assert_eq!(Boolean(true).to_string(), \"true\");\n-        assert_eq!(Boolean(true).pretty().to_string(), \"true\");\n-\n-        assert_eq!(Boolean(false).to_string(), \"false\");\n-        assert_eq!(Boolean(false).pretty().to_string(), \"false\");\n-    }\n-\n-    #[test]\n-    fn test_write_array() {\n-        assert_eq!(Array(vec![]).to_string(), \"[]\");\n-        assert_eq!(Array(vec![]).pretty().to_string(), \"[]\");\n-\n-        assert_eq!(Array(vec![Boolean(true)]).to_string(), \"[true]\");\n-        assert_eq!(\n-            Array(vec![Boolean(true)]).pretty().to_string(),\n-            \"\\\n-            [\\n  \\\n-                true\\n\\\n-            ]\"\n-        );\n-\n-        let long_test_array = Array(vec![\n-            Boolean(false),\n-            Null,\n-            Array(vec![String(\"foo\\nbar\".to_string()), F64(3.5)])]);\n-\n-        assert_eq!(long_test_array.to_string(),\n-            \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n-        assert_eq!(\n-            long_test_array.pretty().to_string(),\n-            \"\\\n-            [\\n  \\\n-                false,\\n  \\\n-                null,\\n  \\\n-                [\\n    \\\n-                    \\\"foo\\\\nbar\\\",\\n    \\\n-                    3.5\\n  \\\n-                ]\\n\\\n-            ]\"\n-        );\n-    }\n-\n-    #[test]\n-    fn test_write_object() {\n-        assert_eq!(mk_object(&[]).to_string(), \"{}\");\n-        assert_eq!(mk_object(&[]).pretty().to_string(), \"{}\");\n-\n-        assert_eq!(\n-            mk_object(&[\n-                (\"a\".to_string(), Boolean(true))\n-            ]).to_string(),\n-            \"{\\\"a\\\":true}\"\n-        );\n-        assert_eq!(\n-            mk_object(&[(\"a\".to_string(), Boolean(true))]).pretty().to_string(),\n-            \"\\\n-            {\\n  \\\n-                \\\"a\\\": true\\n\\\n-            }\"\n-        );\n-\n-        let complex_obj = mk_object(&[\n-                (\"b\".to_string(), Array(vec![\n-                    mk_object(&[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n-                    mk_object(&[(\"d\".to_string(), String(\"\".to_string()))])\n-                ]))\n-            ]);\n-\n-        assert_eq!(\n-            complex_obj.to_string(),\n-            \"{\\\n-                \\\"b\\\":[\\\n-                    {\\\"c\\\":\\\"\\\\f\\\\r\\\"},\\\n-                    {\\\"d\\\":\\\"\\\"}\\\n-                ]\\\n-            }\"\n-        );\n-        assert_eq!(\n-            complex_obj.pretty().to_string(),\n-            \"\\\n-            {\\n  \\\n-                \\\"b\\\": [\\n    \\\n-                    {\\n      \\\n-                        \\\"c\\\": \\\"\\\\f\\\\r\\\"\\n    \\\n-                    },\\n    \\\n-                    {\\n      \\\n-                        \\\"d\\\": \\\"\\\"\\n    \\\n-                    }\\n  \\\n-                ]\\n\\\n-            }\"\n-        );\n-\n-        let a = mk_object(&[\n-            (\"a\".to_string(), Boolean(true)),\n-            (\"b\".to_string(), Array(vec![\n-                mk_object(&[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n-                mk_object(&[(\"d\".to_string(), String(\"\".to_string()))])\n-            ]))\n-        ]);\n-\n-        // We can't compare the strings directly because the object fields be\n-        // printed in a different order.\n-        assert_eq!(a.clone(), a.to_string().parse().unwrap());\n-        assert_eq!(a.clone(), a.pretty().to_string().parse().unwrap());\n-    }\n-\n-    #[test]\n-    fn test_write_enum() {\n-        let animal = Dog;\n-        assert_eq!(\n-            super::as_json(&animal).to_string(),\n-            \"\\\"Dog\\\"\"\n-        );\n-        assert_eq!(\n-            super::as_pretty_json(&animal).to_string(),\n-            \"\\\"Dog\\\"\"\n-        );\n-\n-        let animal = Frog(\"Henry\".to_string(), 349);\n-        assert_eq!(\n-            super::as_json(&animal).to_string(),\n-            \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\"\n-        );\n-        assert_eq!(\n-            super::as_pretty_json(&animal).to_string(),\n-            \"{\\n  \\\n-               \\\"variant\\\": \\\"Frog\\\",\\n  \\\n-               \\\"fields\\\": [\\n    \\\n-                 \\\"Henry\\\",\\n    \\\n-                 349\\n  \\\n-               ]\\n\\\n-             }\"\n-        );\n-    }\n-\n-    macro_rules! check_encoder_for_simple {\n-        ($value:expr, $expected:expr) => ({\n-            let s = super::as_json(&$value).to_string();\n-            assert_eq!(s, $expected);\n-\n-            let s = super::as_pretty_json(&$value).to_string();\n-            assert_eq!(s, $expected);\n-        })\n-    }\n-\n-    #[test]\n-    fn test_write_some() {\n-        check_encoder_for_simple!(Some(\"jodhpurs\".to_string()), \"\\\"jodhpurs\\\"\");\n-    }\n-\n-    #[test]\n-    fn test_write_none() {\n-        check_encoder_for_simple!(None::<string::String>, \"null\");\n-    }\n-\n-    #[test]\n-    fn test_write_char() {\n-        check_encoder_for_simple!('a', \"\\\"a\\\"\");\n-        check_encoder_for_simple!('\\t', \"\\\"\\\\t\\\"\");\n-        check_encoder_for_simple!('\\u{0000}', \"\\\"\\\\u0000\\\"\");\n-        check_encoder_for_simple!('\\u{001b}', \"\\\"\\\\u001b\\\"\");\n-        check_encoder_for_simple!('\\u{007f}', \"\\\"\\\\u007f\\\"\");\n-        check_encoder_for_simple!('\\u{00a0}', \"\\\"\\u{00a0}\\\"\");\n-        check_encoder_for_simple!('\\u{abcd}', \"\\\"\\u{abcd}\\\"\");\n-        check_encoder_for_simple!('\\u{10ffff}', \"\\\"\\u{10ffff}\\\"\");\n-    }\n-\n-    #[test]\n-    fn test_trailing_characters() {\n-        assert_eq!(from_str(\"nulla\"),  Err(SyntaxError(TrailingCharacters, 1, 5)));\n-        assert_eq!(from_str(\"truea\"),  Err(SyntaxError(TrailingCharacters, 1, 5)));\n-        assert_eq!(from_str(\"falsea\"), Err(SyntaxError(TrailingCharacters, 1, 6)));\n-        assert_eq!(from_str(\"1a\"),     Err(SyntaxError(TrailingCharacters, 1, 2)));\n-        assert_eq!(from_str(\"[]a\"),    Err(SyntaxError(TrailingCharacters, 1, 3)));\n-        assert_eq!(from_str(\"{}a\"),    Err(SyntaxError(TrailingCharacters, 1, 3)));\n-    }\n-\n-    #[test]\n-    fn test_read_identifiers() {\n-        assert_eq!(from_str(\"n\"),    Err(SyntaxError(InvalidSyntax, 1, 2)));\n-        assert_eq!(from_str(\"nul\"),  Err(SyntaxError(InvalidSyntax, 1, 4)));\n-        assert_eq!(from_str(\"t\"),    Err(SyntaxError(InvalidSyntax, 1, 2)));\n-        assert_eq!(from_str(\"truz\"), Err(SyntaxError(InvalidSyntax, 1, 4)));\n-        assert_eq!(from_str(\"f\"),    Err(SyntaxError(InvalidSyntax, 1, 2)));\n-        assert_eq!(from_str(\"faz\"),  Err(SyntaxError(InvalidSyntax, 1, 3)));\n-\n-        assert_eq!(from_str(\"null\"), Ok(Null));\n-        assert_eq!(from_str(\"true\"), Ok(Boolean(true)));\n-        assert_eq!(from_str(\"false\"), Ok(Boolean(false)));\n-        assert_eq!(from_str(\" null \"), Ok(Null));\n-        assert_eq!(from_str(\" true \"), Ok(Boolean(true)));\n-        assert_eq!(from_str(\" false \"), Ok(Boolean(false)));\n-    }\n-\n-    #[test]\n-    fn test_decode_identifiers() {\n-        let v: () = super::decode(\"null\").unwrap();\n-        assert_eq!(v, ());\n-\n-        let v: bool = super::decode(\"true\").unwrap();\n-        assert_eq!(v, true);\n-\n-        let v: bool = super::decode(\"false\").unwrap();\n-        assert_eq!(v, false);\n-    }\n-\n-    #[test]\n-    fn test_read_number() {\n-        assert_eq!(from_str(\"+\"),   Err(SyntaxError(InvalidSyntax, 1, 1)));\n-        assert_eq!(from_str(\".\"),   Err(SyntaxError(InvalidSyntax, 1, 1)));\n-        assert_eq!(from_str(\"NaN\"), Err(SyntaxError(InvalidSyntax, 1, 1)));\n-        assert_eq!(from_str(\"-\"),   Err(SyntaxError(InvalidNumber, 1, 2)));\n-        assert_eq!(from_str(\"00\"),  Err(SyntaxError(InvalidNumber, 1, 2)));\n-        assert_eq!(from_str(\"1.\"),  Err(SyntaxError(InvalidNumber, 1, 3)));\n-        assert_eq!(from_str(\"1e\"),  Err(SyntaxError(InvalidNumber, 1, 3)));\n-        assert_eq!(from_str(\"1e+\"), Err(SyntaxError(InvalidNumber, 1, 4)));\n-\n-        assert_eq!(from_str(\"18446744073709551616\"), Err(SyntaxError(InvalidNumber, 1, 20)));\n-        assert_eq!(from_str(\"-9223372036854775809\"), Err(SyntaxError(InvalidNumber, 1, 21)));\n-\n-        assert_eq!(from_str(\"3\"), Ok(U64(3)));\n-        assert_eq!(from_str(\"3.1\"), Ok(F64(3.1)));\n-        assert_eq!(from_str(\"-1.2\"), Ok(F64(-1.2)));\n-        assert_eq!(from_str(\"0.4\"), Ok(F64(0.4)));\n-        assert_eq!(from_str(\"0.4e5\"), Ok(F64(0.4e5)));\n-        assert_eq!(from_str(\"0.4e+15\"), Ok(F64(0.4e15)));\n-        assert_eq!(from_str(\"0.4e-01\"), Ok(F64(0.4e-01)));\n-        assert_eq!(from_str(\" 3 \"), Ok(U64(3)));\n-\n-        assert_eq!(from_str(\"-9223372036854775808\"), Ok(I64(i64::MIN)));\n-        assert_eq!(from_str(\"9223372036854775807\"), Ok(U64(i64::MAX as u64)));\n-        assert_eq!(from_str(\"18446744073709551615\"), Ok(U64(u64::MAX)));\n-    }\n-\n-    #[test]\n-    fn test_decode_numbers() {\n-        let v: f64 = super::decode(\"3\").unwrap();\n-        assert_eq!(v, 3.0);\n-\n-        let v: f64 = super::decode(\"3.1\").unwrap();\n-        assert_eq!(v, 3.1);\n-\n-        let v: f64 = super::decode(\"-1.2\").unwrap();\n-        assert_eq!(v, -1.2);\n-\n-        let v: f64 = super::decode(\"0.4\").unwrap();\n-        assert_eq!(v, 0.4);\n-\n-        let v: f64 = super::decode(\"0.4e5\").unwrap();\n-        assert_eq!(v, 0.4e5);\n-\n-        let v: f64 = super::decode(\"0.4e15\").unwrap();\n-        assert_eq!(v, 0.4e15);\n-\n-        let v: f64 = super::decode(\"0.4e-01\").unwrap();\n-        assert_eq!(v, 0.4e-01);\n-\n-        let v: u64 = super::decode(\"0\").unwrap();\n-        assert_eq!(v, 0);\n-\n-        let v: u64 = super::decode(\"18446744073709551615\").unwrap();\n-        assert_eq!(v, u64::MAX);\n-\n-        let v: i64 = super::decode(\"-9223372036854775808\").unwrap();\n-        assert_eq!(v, i64::MIN);\n-\n-        let v: i64 = super::decode(\"9223372036854775807\").unwrap();\n-        assert_eq!(v, i64::MAX);\n-\n-        let res: DecodeResult<i64> = super::decode(\"765.25\");\n-        assert_eq!(res, Err(ExpectedError(\"Integer\".to_string(),\n-                                          \"765.25\".to_string())));\n-    }\n-\n-    #[test]\n-    fn test_read_str() {\n-        assert_eq!(from_str(\"\\\"\"),    Err(SyntaxError(EOFWhileParsingString, 1, 2)));\n-        assert_eq!(from_str(\"\\\"lol\"), Err(SyntaxError(EOFWhileParsingString, 1, 5)));\n-\n-        assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(\"\".to_string())));\n-        assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(\"foo\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(\"\\\"\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(\"\\x08\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(\"\\n\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(\"\\r\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(\"\\t\".to_string())));\n-        assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(\"foo\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(\"\\u{12ab}\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(\"\\u{AB12}\".to_string())));\n-    }\n-\n-    #[test]\n-    fn test_decode_str() {\n-        let s = [(\"\\\"\\\"\", \"\"),\n-                 (\"\\\"foo\\\"\", \"foo\"),\n-                 (\"\\\"\\\\\\\"\\\"\", \"\\\"\"),\n-                 (\"\\\"\\\\b\\\"\", \"\\x08\"),\n-                 (\"\\\"\\\\n\\\"\", \"\\n\"),\n-                 (\"\\\"\\\\r\\\"\", \"\\r\"),\n-                 (\"\\\"\\\\t\\\"\", \"\\t\"),\n-                 (\"\\\"\\\\u12ab\\\"\", \"\\u{12ab}\"),\n-                 (\"\\\"\\\\uAB12\\\"\", \"\\u{AB12}\")];\n-\n-        for &(i, o) in &s {\n-            let v: string::String = super::decode(i).unwrap();\n-            assert_eq!(v, o);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_array() {\n-        assert_eq!(from_str(\"[\"),     Err(SyntaxError(EOFWhileParsingValue, 1, 2)));\n-        assert_eq!(from_str(\"[1\"),    Err(SyntaxError(EOFWhileParsingArray, 1, 3)));\n-        assert_eq!(from_str(\"[1,\"),   Err(SyntaxError(EOFWhileParsingValue, 1, 4)));\n-        assert_eq!(from_str(\"[1,]\"),  Err(SyntaxError(InvalidSyntax,        1, 4)));\n-        assert_eq!(from_str(\"[6 7]\"), Err(SyntaxError(InvalidSyntax,        1, 4)));\n-\n-        assert_eq!(from_str(\"[]\"), Ok(Array(vec![])));\n-        assert_eq!(from_str(\"[ ]\"), Ok(Array(vec![])));\n-        assert_eq!(from_str(\"[true]\"), Ok(Array(vec![Boolean(true)])));\n-        assert_eq!(from_str(\"[ false ]\"), Ok(Array(vec![Boolean(false)])));\n-        assert_eq!(from_str(\"[null]\"), Ok(Array(vec![Null])));\n-        assert_eq!(from_str(\"[3, 1]\"),\n-                     Ok(Array(vec![U64(3), U64(1)])));\n-        assert_eq!(from_str(\"\\n[3, 2]\\n\"),\n-                     Ok(Array(vec![U64(3), U64(2)])));\n-        assert_eq!(from_str(\"[2, [4, 1]]\"),\n-               Ok(Array(vec![U64(2), Array(vec![U64(4), U64(1)])])));\n-    }\n-\n-    #[test]\n-    fn test_decode_array() {\n-        let v: Vec<()> = super::decode(\"[]\").unwrap();\n-        assert_eq!(v, []);\n-\n-        let v: Vec<()> = super::decode(\"[null]\").unwrap();\n-        assert_eq!(v, [()]);\n-\n-        let v: Vec<bool> = super::decode(\"[true]\").unwrap();\n-        assert_eq!(v, [true]);\n-\n-        let v: Vec<isize> = super::decode(\"[3, 1]\").unwrap();\n-        assert_eq!(v, [3, 1]);\n-\n-        let v: Vec<Vec<usize>> = super::decode(\"[[3], [1, 2]]\").unwrap();\n-        assert_eq!(v, [vec![3], vec![1, 2]]);\n-    }\n-\n-    #[test]\n-    fn test_decode_tuple() {\n-        let t: (usize, usize, usize) = super::decode(\"[1, 2, 3]\").unwrap();\n-        assert_eq!(t, (1, 2, 3));\n-\n-        let t: (usize, string::String) = super::decode(\"[1, \\\"two\\\"]\").unwrap();\n-        assert_eq!(t, (1, \"two\".to_string()));\n-    }\n-\n-    #[test]\n-    fn test_decode_tuple_malformed_types() {\n-        assert!(super::decode::<(usize, string::String)>(\"[1, 2]\").is_err());\n-    }\n-\n-    #[test]\n-    fn test_decode_tuple_malformed_length() {\n-        assert!(super::decode::<(usize, usize)>(\"[1, 2, 3]\").is_err());\n-    }\n-\n-    #[test]\n-    fn test_read_object() {\n-        assert_eq!(from_str(\"{\"),       Err(SyntaxError(EOFWhileParsingObject, 1, 2)));\n-        assert_eq!(from_str(\"{ \"),      Err(SyntaxError(EOFWhileParsingObject, 1, 3)));\n-        assert_eq!(from_str(\"{1\"),      Err(SyntaxError(KeyMustBeAString,      1, 2)));\n-        assert_eq!(from_str(\"{ \\\"a\\\"\"), Err(SyntaxError(EOFWhileParsingObject, 1, 6)));\n-        assert_eq!(from_str(\"{\\\"a\\\"\"),  Err(SyntaxError(EOFWhileParsingObject, 1, 5)));\n-        assert_eq!(from_str(\"{\\\"a\\\" \"), Err(SyntaxError(EOFWhileParsingObject, 1, 6)));\n-\n-        assert_eq!(from_str(\"{\\\"a\\\" 1\"),   Err(SyntaxError(ExpectedColon,         1, 6)));\n-        assert_eq!(from_str(\"{\\\"a\\\":\"),    Err(SyntaxError(EOFWhileParsingValue,  1, 6)));\n-        assert_eq!(from_str(\"{\\\"a\\\":1\"),   Err(SyntaxError(EOFWhileParsingObject, 1, 7)));\n-        assert_eq!(from_str(\"{\\\"a\\\":1 1\"), Err(SyntaxError(InvalidSyntax,         1, 8)));\n-        assert_eq!(from_str(\"{\\\"a\\\":1,\"),  Err(SyntaxError(EOFWhileParsingObject, 1, 8)));\n-\n-        assert_eq!(from_str(\"{}\").unwrap(), mk_object(&[]));\n-        assert_eq!(from_str(\"{\\\"a\\\": 3}\").unwrap(),\n-                  mk_object(&[(\"a\".to_string(), U64(3))]));\n-\n-        assert_eq!(from_str(\n-                      \"{ \\\"a\\\": null, \\\"b\\\" : true }\").unwrap(),\n-                  mk_object(&[\n-                      (\"a\".to_string(), Null),\n-                      (\"b\".to_string(), Boolean(true))]));\n-        assert_eq!(from_str(\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\").unwrap(),\n-                  mk_object(&[\n-                      (\"a\".to_string(), Null),\n-                      (\"b\".to_string(), Boolean(true))]));\n-        assert_eq!(from_str(\n-                      \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\").unwrap(),\n-                  mk_object(&[\n-                      (\"a\".to_string(), F64(1.0)),\n-                      (\"b\".to_string(), Array(vec![Boolean(true)]))\n-                  ]));\n-        assert_eq!(from_str(\n-                      \"{\\\n-                          \\\"a\\\": 1.0, \\\n-                          \\\"b\\\": [\\\n-                              true,\\\n-                              \\\"foo\\\\nbar\\\", \\\n-                              { \\\"c\\\": {\\\"d\\\": null} } \\\n-                          ]\\\n-                      }\").unwrap(),\n-                  mk_object(&[\n-                      (\"a\".to_string(), F64(1.0)),\n-                      (\"b\".to_string(), Array(vec![\n-                          Boolean(true),\n-                          String(\"foo\\nbar\".to_string()),\n-                          mk_object(&[\n-                              (\"c\".to_string(), mk_object(&[(\"d\".to_string(), Null)]))\n-                          ])\n-                      ]))\n-                  ]));\n-    }\n-\n-    #[test]\n-    fn test_decode_struct() {\n-        let s = \"{\n-            \\\"inner\\\": [\n-                { \\\"a\\\": null, \\\"b\\\": 2, \\\"c\\\": [\\\"abc\\\", \\\"xyz\\\"] }\n-            ]\n-        }\";\n-\n-        let v: Outer = super::decode(s).unwrap();\n-        assert_eq!(\n-            v,\n-            Outer {\n-                inner: vec![\n-                    Inner { a: (), b: 2, c: vec![\"abc\".to_string(), \"xyz\".to_string()] }\n-                ]\n-            }\n-        );\n-    }\n-\n-    #[derive(RustcDecodable)]\n-    struct FloatStruct {\n-        f: f64,\n-        a: Vec<f64>\n-    }\n-    #[test]\n-    fn test_decode_struct_with_nan() {\n-        let s = \"{\\\"f\\\":null,\\\"a\\\":[null,123]}\";\n-        let obj: FloatStruct = super::decode(s).unwrap();\n-        assert!(obj.f.is_nan());\n-        assert!(obj.a[0].is_nan());\n-        assert_eq!(obj.a[1], 123f64);\n-    }\n-\n-    #[test]\n-    fn test_decode_option() {\n-        let value: Option<string::String> = super::decode(\"null\").unwrap();\n-        assert_eq!(value, None);\n-\n-        let value: Option<string::String> = super::decode(\"\\\"jodhpurs\\\"\").unwrap();\n-        assert_eq!(value, Some(\"jodhpurs\".to_string()));\n-    }\n-\n-    #[test]\n-    fn test_decode_enum() {\n-        let value: Animal = super::decode(\"\\\"Dog\\\"\").unwrap();\n-        assert_eq!(value, Dog);\n-\n-        let s = \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\";\n-        let value: Animal = super::decode(s).unwrap();\n-        assert_eq!(value, Frog(\"Henry\".to_string(), 349));\n-    }\n-\n-    #[test]\n-    fn test_decode_map() {\n-        let s = \"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": {\\\"variant\\\":\\\"Frog\\\",\\\n-                  \\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n-        let mut map: BTreeMap<string::String, Animal> = super::decode(s).unwrap();\n-\n-        assert_eq!(map.remove(&\"a\".to_string()), Some(Dog));\n-        assert_eq!(map.remove(&\"b\".to_string()), Some(Frog(\"Henry\".to_string(), 349)));\n-    }\n-\n-    #[test]\n-    fn test_multiline_errors() {\n-        assert_eq!(from_str(\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\"),\n-            Err(SyntaxError(EOFWhileParsingObject, 3, 8)));\n-    }\n-\n-    #[derive(RustcDecodable)]\n-    #[allow(dead_code)]\n-    struct DecodeStruct {\n-        x: f64,\n-        y: bool,\n-        z: string::String,\n-        w: Vec<DecodeStruct>\n-    }\n-    #[derive(RustcDecodable)]\n-    enum DecodeEnum {\n-        A(f64),\n-        B(string::String)\n-    }\n-    fn check_err<T: Decodable>(to_parse: &'static str, expected: DecoderError) {\n-        let res: DecodeResult<T> = match from_str(to_parse) {\n-            Err(e) => Err(ParseError(e)),\n-            Ok(json) => Decodable::decode(&mut Decoder::new(json))\n-        };\n-        match res {\n-            Ok(_) => panic!(\"`{:?}` parsed & decoded ok, expecting error `{:?}`\",\n-                              to_parse, expected),\n-            Err(ParseError(e)) => panic!(\"`{:?}` is not valid json: {:?}\",\n-                                           to_parse, e),\n-            Err(e) => {\n-                assert_eq!(e, expected);\n-            }\n-        }\n-    }\n-    #[test]\n-    fn test_decode_errors_struct() {\n-        check_err::<DecodeStruct>(\"[]\", ExpectedError(\"Object\".to_string(), \"[]\".to_string()));\n-        check_err::<DecodeStruct>(\"{\\\"x\\\": true, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n-                                  ExpectedError(\"Number\".to_string(), \"true\".to_string()));\n-        check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": [], \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n-                                  ExpectedError(\"Boolean\".to_string(), \"[]\".to_string()));\n-        check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": {}, \\\"w\\\": []}\",\n-                                  ExpectedError(\"String\".to_string(), \"{}\".to_string()));\n-        check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": null}\",\n-                                  ExpectedError(\"Array\".to_string(), \"null\".to_string()));\n-        check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\"}\",\n-                                  MissingFieldError(\"w\".to_string()));\n-    }\n-    #[test]\n-    fn test_decode_errors_enum() {\n-        check_err::<DecodeEnum>(\"{}\",\n-                                MissingFieldError(\"variant\".to_string()));\n-        check_err::<DecodeEnum>(\"{\\\"variant\\\": 1}\",\n-                                ExpectedError(\"String\".to_string(), \"1\".to_string()));\n-        check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\"}\",\n-                                MissingFieldError(\"fields\".to_string()));\n-        check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\", \\\"fields\\\": null}\",\n-                                ExpectedError(\"Array\".to_string(), \"null\".to_string()));\n-        check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"C\\\", \\\"fields\\\": []}\",\n-                                UnknownVariantError(\"C\".to_string()));\n-    }\n-\n-    #[test]\n-    fn test_find(){\n-        let json_value = from_str(\"{\\\"dog\\\" : \\\"cat\\\"}\").unwrap();\n-        let found_str = json_value.find(\"dog\");\n-        assert!(found_str.unwrap().as_string().unwrap() == \"cat\");\n-    }\n-\n-    #[test]\n-    fn test_find_path(){\n-        let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n-        let found_str = json_value.find_path(&[\"dog\", \"cat\", \"mouse\"]);\n-        assert!(found_str.unwrap().as_string().unwrap() == \"cheese\");\n-    }\n-\n-    #[test]\n-    fn test_search(){\n-        let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n-        let found_str = json_value.search(\"mouse\").and_then(|j| j.as_string());\n-        assert!(found_str.unwrap() == \"cheese\");\n-    }\n-\n-    #[test]\n-    fn test_index(){\n-        let json_value = from_str(\"{\\\"animals\\\":[\\\"dog\\\",\\\"cat\\\",\\\"mouse\\\"]}\").unwrap();\n-        let ref array = json_value[\"animals\"];\n-        assert_eq!(array[0].as_string().unwrap(), \"dog\");\n-        assert_eq!(array[1].as_string().unwrap(), \"cat\");\n-        assert_eq!(array[2].as_string().unwrap(), \"mouse\");\n-    }\n-\n-    #[test]\n-    fn test_is_object(){\n-        let json_value = from_str(\"{}\").unwrap();\n-        assert!(json_value.is_object());\n-    }\n-\n-    #[test]\n-    fn test_as_object(){\n-        let json_value = from_str(\"{}\").unwrap();\n-        let json_object = json_value.as_object();\n-        assert!(json_object.is_some());\n-    }\n-\n-    #[test]\n-    fn test_is_array(){\n-        let json_value = from_str(\"[1, 2, 3]\").unwrap();\n-        assert!(json_value.is_array());\n-    }\n-\n-    #[test]\n-    fn test_as_array(){\n-        let json_value = from_str(\"[1, 2, 3]\").unwrap();\n-        let json_array = json_value.as_array();\n-        let expected_length = 3;\n-        assert!(json_array.is_some() && json_array.unwrap().len() == expected_length);\n-    }\n-\n-    #[test]\n-    fn test_is_string(){\n-        let json_value = from_str(\"\\\"dog\\\"\").unwrap();\n-        assert!(json_value.is_string());\n-    }\n-\n-    #[test]\n-    fn test_as_string(){\n-        let json_value = from_str(\"\\\"dog\\\"\").unwrap();\n-        let json_str = json_value.as_string();\n-        let expected_str = \"dog\";\n-        assert_eq!(json_str, Some(expected_str));\n-    }\n-\n-    #[test]\n-    fn test_is_number(){\n-        let json_value = from_str(\"12\").unwrap();\n-        assert!(json_value.is_number());\n-    }\n-\n-    #[test]\n-    fn test_is_i64(){\n-        let json_value = from_str(\"-12\").unwrap();\n-        assert!(json_value.is_i64());\n-\n-        let json_value = from_str(\"12\").unwrap();\n-        assert!(!json_value.is_i64());\n-\n-        let json_value = from_str(\"12.0\").unwrap();\n-        assert!(!json_value.is_i64());\n-    }\n-\n-    #[test]\n-    fn test_is_u64(){\n-        let json_value = from_str(\"12\").unwrap();\n-        assert!(json_value.is_u64());\n-\n-        let json_value = from_str(\"-12\").unwrap();\n-        assert!(!json_value.is_u64());\n-\n-        let json_value = from_str(\"12.0\").unwrap();\n-        assert!(!json_value.is_u64());\n-    }\n-\n-    #[test]\n-    fn test_is_f64(){\n-        let json_value = from_str(\"12\").unwrap();\n-        assert!(!json_value.is_f64());\n-\n-        let json_value = from_str(\"-12\").unwrap();\n-        assert!(!json_value.is_f64());\n-\n-        let json_value = from_str(\"12.0\").unwrap();\n-        assert!(json_value.is_f64());\n-\n-        let json_value = from_str(\"-12.0\").unwrap();\n-        assert!(json_value.is_f64());\n-    }\n-\n-    #[test]\n-    fn test_as_i64(){\n-        let json_value = from_str(\"-12\").unwrap();\n-        let json_num = json_value.as_i64();\n-        assert_eq!(json_num, Some(-12));\n-    }\n-\n-    #[test]\n-    fn test_as_u64(){\n-        let json_value = from_str(\"12\").unwrap();\n-        let json_num = json_value.as_u64();\n-        assert_eq!(json_num, Some(12));\n-    }\n-\n-    #[test]\n-    fn test_as_f64(){\n-        let json_value = from_str(\"12.0\").unwrap();\n-        let json_num = json_value.as_f64();\n-        assert_eq!(json_num, Some(12f64));\n-    }\n-\n-    #[test]\n-    fn test_is_boolean(){\n-        let json_value = from_str(\"false\").unwrap();\n-        assert!(json_value.is_boolean());\n-    }\n-\n-    #[test]\n-    fn test_as_boolean(){\n-        let json_value = from_str(\"false\").unwrap();\n-        let json_bool = json_value.as_boolean();\n-        let expected_bool = false;\n-        assert!(json_bool.is_some() && json_bool.unwrap() == expected_bool);\n-    }\n-\n-    #[test]\n-    fn test_is_null(){\n-        let json_value = from_str(\"null\").unwrap();\n-        assert!(json_value.is_null());\n-    }\n-\n-    #[test]\n-    fn test_as_null(){\n-        let json_value = from_str(\"null\").unwrap();\n-        let json_null = json_value.as_null();\n-        let expected_null = ();\n-        assert!(json_null.is_some() && json_null.unwrap() == expected_null);\n-    }\n-\n-    #[test]\n-    fn test_encode_hashmap_with_numeric_key() {\n-        use std::str::from_utf8;\n-        use std::collections::HashMap;\n-        let mut hm: HashMap<usize, bool> = HashMap::new();\n-        hm.insert(1, true);\n-        let mut mem_buf = Vec::new();\n-        write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n-        let json_str = from_utf8(&mem_buf[..]).unwrap();\n-        match from_str(json_str) {\n-            Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n-            _ => {} // it parsed and we are good to go\n-        }\n-    }\n-\n-    #[test]\n-    fn test_prettyencode_hashmap_with_numeric_key() {\n-        use std::str::from_utf8;\n-        use std::collections::HashMap;\n-        let mut hm: HashMap<usize, bool> = HashMap::new();\n-        hm.insert(1, true);\n-        let mut mem_buf = Vec::new();\n-        write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n-        let json_str = from_utf8(&mem_buf[..]).unwrap();\n-        match from_str(json_str) {\n-            Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n-            _ => {} // it parsed and we are good to go\n-        }\n-    }\n-\n-    #[test]\n-    fn test_prettyencoder_indent_level_param() {\n-        use std::str::from_utf8;\n-        use std::collections::BTreeMap;\n-\n-        let mut tree = BTreeMap::new();\n-\n-        tree.insert(\"hello\".to_string(), String(\"guten tag\".to_string()));\n-        tree.insert(\"goodbye\".to_string(), String(\"sayonara\".to_string()));\n-\n-        let json = Array(\n-            // The following layout below should look a lot like\n-            // the pretty-printed JSON (indent * x)\n-            vec!\n-            ( // 0x\n-                String(\"greetings\".to_string()), // 1x\n-                Object(tree), // 1x + 2x + 2x + 1x\n-            ) // 0x\n-            // End JSON array (7 lines)\n-        );\n-\n-        // Helper function for counting indents\n-        fn indents(source: &str) -> usize {\n-            let trimmed = source.trim_start_matches(' ');\n-            source.len() - trimmed.len()\n-        }\n-\n-        // Test up to 4 spaces of indents (more?)\n-        for i in 0..4 {\n-            let mut writer = Vec::new();\n-            write!(&mut writer, \"{}\",\n-                   super::as_pretty_json(&json).indent(i)).unwrap();\n-\n-            let printed = from_utf8(&writer[..]).unwrap();\n-\n-            // Check for indents at each line\n-            let lines: Vec<&str> = printed.lines().collect();\n-            assert_eq!(lines.len(), 7); // JSON should be 7 lines\n-\n-            assert_eq!(indents(lines[0]), 0 * i); // [\n-            assert_eq!(indents(lines[1]), 1 * i); //   \"greetings\",\n-            assert_eq!(indents(lines[2]), 1 * i); //   {\n-            assert_eq!(indents(lines[3]), 2 * i); //     \"hello\": \"guten tag\",\n-            assert_eq!(indents(lines[4]), 2 * i); //     \"goodbye\": \"sayonara\"\n-            assert_eq!(indents(lines[5]), 1 * i); //   },\n-            assert_eq!(indents(lines[6]), 0 * i); // ]\n-\n-            // Finally, test that the pretty-printed JSON is valid\n-            from_str(printed).ok().expect(\"Pretty-printed JSON is invalid!\");\n-        }\n-    }\n-\n-    #[test]\n-    fn test_hashmap_with_enum_key() {\n-        use std::collections::HashMap;\n-        use json;\n-        #[derive(RustcEncodable, Eq, Hash, PartialEq, RustcDecodable, Debug)]\n-        enum Enum {\n-            Foo,\n-            #[allow(dead_code)]\n-            Bar,\n-        }\n-        let mut map = HashMap::new();\n-        map.insert(Enum::Foo, 0);\n-        let result = json::encode(&map).unwrap();\n-        assert_eq!(&result[..], r#\"{\"Foo\":0}\"#);\n-        let decoded: HashMap<Enum, _> = json::decode(&result).unwrap();\n-        assert_eq!(map, decoded);\n-    }\n-\n-    #[test]\n-    fn test_hashmap_with_numeric_key_can_handle_double_quote_delimited_key() {\n-        use std::collections::HashMap;\n-        use Decodable;\n-        let json_str = \"{\\\"1\\\":true}\";\n-        let json_obj = match from_str(json_str) {\n-            Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n-            Ok(o) => o\n-        };\n-        let mut decoder = Decoder::new(json_obj);\n-        let _hm: HashMap<usize, bool> = Decodable::decode(&mut decoder).unwrap();\n-    }\n-\n-    #[test]\n-    fn test_hashmap_with_numeric_key_will_error_with_string_keys() {\n-        use std::collections::HashMap;\n-        use Decodable;\n-        let json_str = \"{\\\"a\\\":true}\";\n-        let json_obj = match from_str(json_str) {\n-            Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n-            Ok(o) => o\n-        };\n-        let mut decoder = Decoder::new(json_obj);\n-        let result: Result<HashMap<usize, bool>, DecoderError> = Decodable::decode(&mut decoder);\n-        assert_eq!(result, Err(ExpectedError(\"Number\".to_string(), \"a\".to_string())));\n-    }\n-\n-    fn assert_stream_equal(src: &str,\n-                           expected: Vec<(JsonEvent, Vec<StackElement>)>) {\n-        let mut parser = Parser::new(src.chars());\n-        let mut i = 0;\n-        loop {\n-            let evt = match parser.next() {\n-                Some(e) => e,\n-                None => { break; }\n-            };\n-            let (ref expected_evt, ref expected_stack) = expected[i];\n-            if !parser.stack().is_equal_to(expected_stack) {\n-                panic!(\"Parser stack is not equal to {:?}\", expected_stack);\n-            }\n-            assert_eq!(&evt, expected_evt);\n-            i+=1;\n-        }\n-    }\n-    #[test]\n-    fn test_streaming_parser() {\n-        assert_stream_equal(\n-            r#\"{ \"foo\":\"bar\", \"array\" : [0, 1, 2, 3, 4, 5], \"idents\":[null,true,false]}\"#,\n-            vec![\n-                (ObjectStart,             vec![]),\n-                  (StringValue(\"bar\".to_string()),   vec![StackElement::Key(\"foo\")]),\n-                  (ArrayStart,            vec![StackElement::Key(\"array\")]),\n-                    (U64Value(0),         vec![StackElement::Key(\"array\"), StackElement::Index(0)]),\n-                    (U64Value(1),         vec![StackElement::Key(\"array\"), StackElement::Index(1)]),\n-                    (U64Value(2),         vec![StackElement::Key(\"array\"), StackElement::Index(2)]),\n-                    (U64Value(3),         vec![StackElement::Key(\"array\"), StackElement::Index(3)]),\n-                    (U64Value(4),         vec![StackElement::Key(\"array\"), StackElement::Index(4)]),\n-                    (U64Value(5),         vec![StackElement::Key(\"array\"), StackElement::Index(5)]),\n-                  (ArrayEnd,              vec![StackElement::Key(\"array\")]),\n-                  (ArrayStart,            vec![StackElement::Key(\"idents\")]),\n-                    (NullValue,           vec![StackElement::Key(\"idents\"),\n-                                               StackElement::Index(0)]),\n-                    (BooleanValue(true),  vec![StackElement::Key(\"idents\"),\n-                                               StackElement::Index(1)]),\n-                    (BooleanValue(false), vec![StackElement::Key(\"idents\"),\n-                                               StackElement::Index(2)]),\n-                  (ArrayEnd,              vec![StackElement::Key(\"idents\")]),\n-                (ObjectEnd,               vec![]),\n-            ]\n-        );\n-    }\n-    fn last_event(src: &str) -> JsonEvent {\n-        let mut parser = Parser::new(src.chars());\n-        let mut evt = NullValue;\n-        loop {\n-            evt = match parser.next() {\n-                Some(e) => e,\n-                None => return evt,\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_object_streaming() {\n-        assert_eq!(last_event(\"{ \"),      Error(SyntaxError(EOFWhileParsingObject, 1, 3)));\n-        assert_eq!(last_event(\"{1\"),      Error(SyntaxError(KeyMustBeAString,      1, 2)));\n-        assert_eq!(last_event(\"{ \\\"a\\\"\"), Error(SyntaxError(EOFWhileParsingObject, 1, 6)));\n-        assert_eq!(last_event(\"{\\\"a\\\"\"),  Error(SyntaxError(EOFWhileParsingObject, 1, 5)));\n-        assert_eq!(last_event(\"{\\\"a\\\" \"), Error(SyntaxError(EOFWhileParsingObject, 1, 6)));\n-\n-        assert_eq!(last_event(\"{\\\"a\\\" 1\"),   Error(SyntaxError(ExpectedColon,         1, 6)));\n-        assert_eq!(last_event(\"{\\\"a\\\":\"),    Error(SyntaxError(EOFWhileParsingValue,  1, 6)));\n-        assert_eq!(last_event(\"{\\\"a\\\":1\"),   Error(SyntaxError(EOFWhileParsingObject, 1, 7)));\n-        assert_eq!(last_event(\"{\\\"a\\\":1 1\"), Error(SyntaxError(InvalidSyntax,         1, 8)));\n-        assert_eq!(last_event(\"{\\\"a\\\":1,\"),  Error(SyntaxError(EOFWhileParsingObject, 1, 8)));\n-        assert_eq!(last_event(\"{\\\"a\\\":1,}\"), Error(SyntaxError(TrailingComma, 1, 8)));\n-\n-        assert_stream_equal(\n-            \"{}\",\n-            vec![(ObjectStart, vec![]), (ObjectEnd, vec![])]\n-        );\n-        assert_stream_equal(\n-            \"{\\\"a\\\": 3}\",\n-            vec![\n-                (ObjectStart,        vec![]),\n-                  (U64Value(3),      vec![StackElement::Key(\"a\")]),\n-                (ObjectEnd,          vec![]),\n-            ]\n-        );\n-        assert_stream_equal(\n-            \"{ \\\"a\\\": null, \\\"b\\\" : true }\",\n-            vec![\n-                (ObjectStart,           vec![]),\n-                  (NullValue,           vec![StackElement::Key(\"a\")]),\n-                  (BooleanValue(true),  vec![StackElement::Key(\"b\")]),\n-                (ObjectEnd,             vec![]),\n-            ]\n-        );\n-        assert_stream_equal(\n-            \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\",\n-            vec![\n-                (ObjectStart,           vec![]),\n-                  (F64Value(1.0),       vec![StackElement::Key(\"a\")]),\n-                  (ArrayStart,          vec![StackElement::Key(\"b\")]),\n-                    (BooleanValue(true),vec![StackElement::Key(\"b\"), StackElement::Index(0)]),\n-                  (ArrayEnd,            vec![StackElement::Key(\"b\")]),\n-                (ObjectEnd,             vec![]),\n-            ]\n-        );\n-        assert_stream_equal(\n-            r#\"{\n-                \"a\": 1.0,\n-                \"b\": [\n-                    true,\n-                    \"foo\\nbar\",\n-                    { \"c\": {\"d\": null} }\n-                ]\n-            }\"#,\n-            vec![\n-                (ObjectStart,                   vec![]),\n-                  (F64Value(1.0),               vec![StackElement::Key(\"a\")]),\n-                  (ArrayStart,                  vec![StackElement::Key(\"b\")]),\n-                    (BooleanValue(true),        vec![StackElement::Key(\"b\"),\n-                                                     StackElement::Index(0)]),\n-                    (StringValue(\"foo\\nbar\".to_string()),  vec![StackElement::Key(\"b\"),\n-                                                                StackElement::Index(1)]),\n-                    (ObjectStart,               vec![StackElement::Key(\"b\"),\n-                                                     StackElement::Index(2)]),\n-                      (ObjectStart,             vec![StackElement::Key(\"b\"),\n-                                                     StackElement::Index(2),\n-                                                     StackElement::Key(\"c\")]),\n-                        (NullValue,             vec![StackElement::Key(\"b\"),\n-                                                     StackElement::Index(2),\n-                                                     StackElement::Key(\"c\"),\n-                                                     StackElement::Key(\"d\")]),\n-                      (ObjectEnd,               vec![StackElement::Key(\"b\"),\n-                                                     StackElement::Index(2),\n-                                                     StackElement::Key(\"c\")]),\n-                    (ObjectEnd,                 vec![StackElement::Key(\"b\"),\n-                                                     StackElement::Index(2)]),\n-                  (ArrayEnd,                    vec![StackElement::Key(\"b\")]),\n-                (ObjectEnd,                     vec![]),\n-            ]\n-        );\n-    }\n-    #[test]\n-    fn test_read_array_streaming() {\n-        assert_stream_equal(\n-            \"[]\",\n-            vec![\n-                (ArrayStart, vec![]),\n-                (ArrayEnd,   vec![]),\n-            ]\n-        );\n-        assert_stream_equal(\n-            \"[ ]\",\n-            vec![\n-                (ArrayStart, vec![]),\n-                (ArrayEnd,   vec![]),\n-            ]\n-        );\n-        assert_stream_equal(\n-            \"[true]\",\n-            vec![\n-                (ArrayStart,             vec![]),\n-                    (BooleanValue(true), vec![StackElement::Index(0)]),\n-                (ArrayEnd,               vec![]),\n-            ]\n-        );\n-        assert_stream_equal(\n-            \"[ false ]\",\n-            vec![\n-                (ArrayStart,              vec![]),\n-                    (BooleanValue(false), vec![StackElement::Index(0)]),\n-                (ArrayEnd,                vec![]),\n-            ]\n-        );\n-        assert_stream_equal(\n-            \"[null]\",\n-            vec![\n-                (ArrayStart,    vec![]),\n-                    (NullValue, vec![StackElement::Index(0)]),\n-                (ArrayEnd,      vec![]),\n-            ]\n-        );\n-        assert_stream_equal(\n-            \"[3, 1]\",\n-            vec![\n-                (ArrayStart,      vec![]),\n-                    (U64Value(3), vec![StackElement::Index(0)]),\n-                    (U64Value(1), vec![StackElement::Index(1)]),\n-                (ArrayEnd,        vec![]),\n-            ]\n-        );\n-        assert_stream_equal(\n-            \"\\n[3, 2]\\n\",\n-            vec![\n-                (ArrayStart,      vec![]),\n-                    (U64Value(3), vec![StackElement::Index(0)]),\n-                    (U64Value(2), vec![StackElement::Index(1)]),\n-                (ArrayEnd,        vec![]),\n-            ]\n-        );\n-        assert_stream_equal(\n-            \"[2, [4, 1]]\",\n-            vec![\n-                (ArrayStart,           vec![]),\n-                    (U64Value(2),      vec![StackElement::Index(0)]),\n-                    (ArrayStart,       vec![StackElement::Index(1)]),\n-                        (U64Value(4),  vec![StackElement::Index(1), StackElement::Index(0)]),\n-                        (U64Value(1),  vec![StackElement::Index(1), StackElement::Index(1)]),\n-                    (ArrayEnd,         vec![StackElement::Index(1)]),\n-                (ArrayEnd,             vec![]),\n-            ]\n-        );\n-\n-        assert_eq!(last_event(\"[\"), Error(SyntaxError(EOFWhileParsingValue, 1,  2)));\n-\n-        assert_eq!(from_str(\"[\"),     Err(SyntaxError(EOFWhileParsingValue, 1, 2)));\n-        assert_eq!(from_str(\"[1\"),    Err(SyntaxError(EOFWhileParsingArray, 1, 3)));\n-        assert_eq!(from_str(\"[1,\"),   Err(SyntaxError(EOFWhileParsingValue, 1, 4)));\n-        assert_eq!(from_str(\"[1,]\"),  Err(SyntaxError(InvalidSyntax,        1, 4)));\n-        assert_eq!(from_str(\"[6 7]\"), Err(SyntaxError(InvalidSyntax,        1, 4)));\n-\n-    }\n-    #[test]\n-    fn test_trailing_characters_streaming() {\n-        assert_eq!(last_event(\"nulla\"),  Error(SyntaxError(TrailingCharacters, 1, 5)));\n-        assert_eq!(last_event(\"truea\"),  Error(SyntaxError(TrailingCharacters, 1, 5)));\n-        assert_eq!(last_event(\"falsea\"), Error(SyntaxError(TrailingCharacters, 1, 6)));\n-        assert_eq!(last_event(\"1a\"),     Error(SyntaxError(TrailingCharacters, 1, 2)));\n-        assert_eq!(last_event(\"[]a\"),    Error(SyntaxError(TrailingCharacters, 1, 3)));\n-        assert_eq!(last_event(\"{}a\"),    Error(SyntaxError(TrailingCharacters, 1, 3)));\n-    }\n-    #[test]\n-    fn test_read_identifiers_streaming() {\n-        assert_eq!(Parser::new(\"null\".chars()).next(), Some(NullValue));\n-        assert_eq!(Parser::new(\"true\".chars()).next(), Some(BooleanValue(true)));\n-        assert_eq!(Parser::new(\"false\".chars()).next(), Some(BooleanValue(false)));\n-\n-        assert_eq!(last_event(\"n\"),    Error(SyntaxError(InvalidSyntax, 1, 2)));\n-        assert_eq!(last_event(\"nul\"),  Error(SyntaxError(InvalidSyntax, 1, 4)));\n-        assert_eq!(last_event(\"t\"),    Error(SyntaxError(InvalidSyntax, 1, 2)));\n-        assert_eq!(last_event(\"truz\"), Error(SyntaxError(InvalidSyntax, 1, 4)));\n-        assert_eq!(last_event(\"f\"),    Error(SyntaxError(InvalidSyntax, 1, 2)));\n-        assert_eq!(last_event(\"faz\"),  Error(SyntaxError(InvalidSyntax, 1, 3)));\n-    }\n-\n     #[test]\n     fn test_stack() {\n         let mut stack = Stack::new();\n@@ -3862,76 +2654,6 @@ mod tests {\n         assert!(stack.get(1) == StackElement::Key(\"foo\"));\n     }\n \n-    #[test]\n-    fn test_to_json() {\n-        use std::collections::{HashMap,BTreeMap};\n-        use super::ToJson;\n-\n-        let array2 = Array(vec![U64(1), U64(2)]);\n-        let array3 = Array(vec![U64(1), U64(2), U64(3)]);\n-        let object = {\n-            let mut tree_map = BTreeMap::new();\n-            tree_map.insert(\"a\".to_string(), U64(1));\n-            tree_map.insert(\"b\".to_string(), U64(2));\n-            Object(tree_map)\n-        };\n-\n-        assert_eq!(array2.to_json(), array2);\n-        assert_eq!(object.to_json(), object);\n-        assert_eq!(3_isize.to_json(), I64(3));\n-        assert_eq!(4_i8.to_json(), I64(4));\n-        assert_eq!(5_i16.to_json(), I64(5));\n-        assert_eq!(6_i32.to_json(), I64(6));\n-        assert_eq!(7_i64.to_json(), I64(7));\n-        assert_eq!(8_usize.to_json(), U64(8));\n-        assert_eq!(9_u8.to_json(), U64(9));\n-        assert_eq!(10_u16.to_json(), U64(10));\n-        assert_eq!(11_u32.to_json(), U64(11));\n-        assert_eq!(12_u64.to_json(), U64(12));\n-        assert_eq!(13.0_f32.to_json(), F64(13.0_f64));\n-        assert_eq!(14.0_f64.to_json(), F64(14.0_f64));\n-        assert_eq!(().to_json(), Null);\n-        assert_eq!(f32::INFINITY.to_json(), Null);\n-        assert_eq!(f64::NAN.to_json(), Null);\n-        assert_eq!(true.to_json(), Boolean(true));\n-        assert_eq!(false.to_json(), Boolean(false));\n-        assert_eq!(\"abc\".to_json(), String(\"abc\".to_string()));\n-        assert_eq!(\"abc\".to_string().to_json(), String(\"abc\".to_string()));\n-        assert_eq!((1_usize, 2_usize).to_json(), array2);\n-        assert_eq!((1_usize, 2_usize, 3_usize).to_json(), array3);\n-        assert_eq!([1_usize, 2_usize].to_json(), array2);\n-        assert_eq!((&[1_usize, 2_usize, 3_usize]).to_json(), array3);\n-        assert_eq!((vec![1_usize, 2_usize]).to_json(), array2);\n-        assert_eq!(vec![1_usize, 2_usize, 3_usize].to_json(), array3);\n-        let mut tree_map = BTreeMap::new();\n-        tree_map.insert(\"a\".to_string(), 1 as usize);\n-        tree_map.insert(\"b\".to_string(), 2);\n-        assert_eq!(tree_map.to_json(), object);\n-        let mut hash_map = HashMap::new();\n-        hash_map.insert(\"a\".to_string(), 1 as usize);\n-        hash_map.insert(\"b\".to_string(), 2);\n-        assert_eq!(hash_map.to_json(), object);\n-        assert_eq!(Some(15).to_json(), I64(15));\n-        assert_eq!(Some(15 as usize).to_json(), U64(15));\n-        assert_eq!(None::<isize>.to_json(), Null);\n-    }\n-\n-    #[test]\n-    fn test_encode_hashmap_with_arbitrary_key() {\n-        use std::collections::HashMap;\n-        #[derive(PartialEq, Eq, Hash, RustcEncodable)]\n-        struct ArbitraryType(usize);\n-        let mut hm: HashMap<ArbitraryType, bool> = HashMap::new();\n-        hm.insert(ArbitraryType(1), true);\n-        let mut mem_buf = string::String::new();\n-        let mut encoder = Encoder::new(&mut mem_buf);\n-        let result = hm.encode(&mut encoder);\n-        match result.unwrap_err() {\n-            EncoderError::BadHashmapKey => (),\n-            _ => panic!(\"expected bad hash map key\")\n-        }\n-    }\n-\n     #[bench]\n     fn bench_streaming_small(b: &mut Bencher) {\n         b.iter( || {"}, {"sha": "b8eeb4d2b34af30c1bf25db7ca5661687612a8d9", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -8,6 +8,8 @@ Core encoding and decoding interfaces.\n        html_playground_url = \"https://play.rust-lang.org/\",\n        test(attr(allow(unused_variables), deny(warnings))))]\n \n+#![deny(rust_2018_idioms)]\n+\n #![feature(box_syntax)]\n #![feature(core_intrinsics)]\n #![feature(specialization)]\n@@ -20,8 +22,6 @@ pub use self::serialize::{Decoder, Encoder, Decodable, Encodable};\n pub use self::serialize::{SpecializationError, SpecializedEncoder, SpecializedDecoder};\n pub use self::serialize::{UseSpecializedEncodable, UseSpecializedDecodable};\n \n-extern crate smallvec;\n-\n mod serialize;\n mod collection_impls;\n \n@@ -30,7 +30,3 @@ pub mod json;\n \n pub mod opaque;\n pub mod leb128;\n-\n-mod rustc_serialize {\n-    pub use serialize::*;\n-}"}, {"sha": "a6a5c318079f1ccb1c74db6ba60d9d3fc6436174", "filename": "src/libserialize/opaque.rs", "status": "modified", "additions": 3, "deletions": 288, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibserialize%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibserialize%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fopaque.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,6 +1,6 @@\n-use leb128::{self, read_signed_leb128, write_signed_leb128};\n+use crate::leb128::{self, read_signed_leb128, write_signed_leb128};\n+use crate::serialize;\n use std::borrow::Cow;\n-use serialize;\n \n // -----------------------------------------------------------------------------\n // Encoder\n@@ -312,7 +312,7 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n     }\n \n     #[inline]\n-    fn read_str(&mut self) -> Result<Cow<str>, Self::Error> {\n+    fn read_str(&mut self) -> Result<Cow<'_, str>, Self::Error> {\n         let len = self.read_usize()?;\n         let s = ::std::str::from_utf8(&self.data[self.position..self.position + len]).unwrap();\n         self.position += len;\n@@ -324,288 +324,3 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n         err.to_string()\n     }\n }\n-\n-\n-#[cfg(test)]\n-mod tests {\n-    use serialize::{Encodable, Decodable};\n-    use std::fmt::Debug;\n-    use super::{Encoder, Decoder};\n-\n-    #[derive(PartialEq, Clone, Debug, RustcEncodable, RustcDecodable)]\n-    struct Struct {\n-        a: (),\n-        b: u8,\n-        c: u16,\n-        d: u32,\n-        e: u64,\n-        f: usize,\n-\n-        g: i8,\n-        h: i16,\n-        i: i32,\n-        j: i64,\n-        k: isize,\n-\n-        l: char,\n-        m: String,\n-        n: f32,\n-        o: f64,\n-        p: bool,\n-        q: Option<u32>,\n-    }\n-\n-\n-    fn check_round_trip<T: Encodable + Decodable + PartialEq + Debug>(values: Vec<T>) {\n-        let mut encoder = Encoder::new(Vec::new());\n-\n-        for value in &values {\n-            Encodable::encode(&value, &mut encoder).unwrap();\n-        }\n-\n-        let data = encoder.into_inner();\n-        let mut decoder = Decoder::new(&data[..], 0);\n-\n-        for value in values {\n-            let decoded = Decodable::decode(&mut decoder).unwrap();\n-            assert_eq!(value, decoded);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_unit() {\n-        check_round_trip(vec![(), (), (), ()]);\n-    }\n-\n-    #[test]\n-    fn test_u8() {\n-        let mut vec = vec![];\n-        for i in ::std::u8::MIN..::std::u8::MAX {\n-            vec.push(i);\n-        }\n-        check_round_trip(vec);\n-    }\n-\n-    #[test]\n-    fn test_u16() {\n-        for i in ::std::u16::MIN..::std::u16::MAX {\n-            check_round_trip(vec![1, 2, 3, i, i, i]);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_u32() {\n-        check_round_trip(vec![1, 2, 3, ::std::u32::MIN, 0, 1, ::std::u32::MAX, 2, 1]);\n-    }\n-\n-    #[test]\n-    fn test_u64() {\n-        check_round_trip(vec![1, 2, 3, ::std::u64::MIN, 0, 1, ::std::u64::MAX, 2, 1]);\n-    }\n-\n-    #[test]\n-    fn test_usize() {\n-        check_round_trip(vec![1, 2, 3, ::std::usize::MIN, 0, 1, ::std::usize::MAX, 2, 1]);\n-    }\n-\n-    #[test]\n-    fn test_i8() {\n-        let mut vec = vec![];\n-        for i in ::std::i8::MIN..::std::i8::MAX {\n-            vec.push(i);\n-        }\n-        check_round_trip(vec);\n-    }\n-\n-    #[test]\n-    fn test_i16() {\n-        for i in ::std::i16::MIN..::std::i16::MAX {\n-            check_round_trip(vec![-1, 2, -3, i, i, i, 2]);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_i32() {\n-        check_round_trip(vec![-1, 2, -3, ::std::i32::MIN, 0, 1, ::std::i32::MAX, 2, 1]);\n-    }\n-\n-    #[test]\n-    fn test_i64() {\n-        check_round_trip(vec![-1, 2, -3, ::std::i64::MIN, 0, 1, ::std::i64::MAX, 2, 1]);\n-    }\n-\n-    #[test]\n-    fn test_isize() {\n-        check_round_trip(vec![-1, 2, -3, ::std::isize::MIN, 0, 1, ::std::isize::MAX, 2, 1]);\n-    }\n-\n-    #[test]\n-    fn test_bool() {\n-        check_round_trip(vec![false, true, true, false, false]);\n-    }\n-\n-    #[test]\n-    fn test_f32() {\n-        let mut vec = vec![];\n-        for i in -100..100 {\n-            vec.push((i as f32) / 3.0);\n-        }\n-        check_round_trip(vec);\n-    }\n-\n-    #[test]\n-    fn test_f64() {\n-        let mut vec = vec![];\n-        for i in -100..100 {\n-            vec.push((i as f64) / 3.0);\n-        }\n-        check_round_trip(vec);\n-    }\n-\n-    #[test]\n-    fn test_char() {\n-        let vec = vec!['a', 'b', 'c', 'd', 'A', 'X', ' ', '#', '\u00d6', '\u00c4', '\u00b5', '\u20ac'];\n-        check_round_trip(vec);\n-    }\n-\n-    #[test]\n-    fn test_string() {\n-        let vec = vec![\"abcbu\u00d6eiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpnvapeapmaebn\".to_string(),\n-                       \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpnvapeapmaebn\".to_string(),\n-                       \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpapmaebn\".to_string(),\n-                       \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmeabpnvapeapmaebn\".to_string(),\n-                       \"abcbu\u00d6ganei\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpnvapeapmaebn\".to_string(),\n-                       \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpmaebn\".to_string(),\n-                       \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5nvapeapmaebn\".to_string()];\n-\n-        check_round_trip(vec);\n-    }\n-\n-    #[test]\n-    fn test_option() {\n-        check_round_trip(vec![Some(-1i8)]);\n-        check_round_trip(vec![Some(-2i16)]);\n-        check_round_trip(vec![Some(-3i32)]);\n-        check_round_trip(vec![Some(-4i64)]);\n-        check_round_trip(vec![Some(-5isize)]);\n-\n-        let none_i8: Option<i8> = None;\n-        check_round_trip(vec![none_i8]);\n-\n-        let none_i16: Option<i16> = None;\n-        check_round_trip(vec![none_i16]);\n-\n-        let none_i32: Option<i32> = None;\n-        check_round_trip(vec![none_i32]);\n-\n-        let none_i64: Option<i64> = None;\n-        check_round_trip(vec![none_i64]);\n-\n-        let none_isize: Option<isize> = None;\n-        check_round_trip(vec![none_isize]);\n-    }\n-\n-    #[test]\n-    fn test_struct() {\n-        check_round_trip(vec![Struct {\n-                                  a: (),\n-                                  b: 10,\n-                                  c: 11,\n-                                  d: 12,\n-                                  e: 13,\n-                                  f: 14,\n-\n-                                  g: 15,\n-                                  h: 16,\n-                                  i: 17,\n-                                  j: 18,\n-                                  k: 19,\n-\n-                                  l: 'x',\n-                                  m: \"abc\".to_string(),\n-                                  n: 20.5,\n-                                  o: 21.5,\n-                                  p: false,\n-                                  q: None,\n-                              }]);\n-\n-        check_round_trip(vec![Struct {\n-                                  a: (),\n-                                  b: 101,\n-                                  c: 111,\n-                                  d: 121,\n-                                  e: 131,\n-                                  f: 141,\n-\n-                                  g: -15,\n-                                  h: -16,\n-                                  i: -17,\n-                                  j: -18,\n-                                  k: -19,\n-\n-                                  l: 'y',\n-                                  m: \"def\".to_string(),\n-                                  n: -20.5,\n-                                  o: -21.5,\n-                                  p: true,\n-                                  q: Some(1234567),\n-                              }]);\n-    }\n-\n-    #[derive(PartialEq, Clone, Debug, RustcEncodable, RustcDecodable)]\n-    enum Enum {\n-        Variant1,\n-        Variant2(usize, f32),\n-        Variant3 {\n-            a: i32,\n-            b: char,\n-            c: bool,\n-        },\n-    }\n-\n-    #[test]\n-    fn test_enum() {\n-        check_round_trip(vec![Enum::Variant1,\n-                              Enum::Variant2(1, 2.5),\n-                              Enum::Variant3 {\n-                                  a: 3,\n-                                  b: 'b',\n-                                  c: false,\n-                              },\n-                              Enum::Variant3 {\n-                                  a: -4,\n-                                  b: 'f',\n-                                  c: true,\n-                              }]);\n-    }\n-\n-    #[test]\n-    fn test_sequence() {\n-        let mut vec = vec![];\n-        for i in -100i64..100i64 {\n-            vec.push(i * 100000);\n-        }\n-\n-        check_round_trip(vec![vec]);\n-    }\n-\n-    #[test]\n-    fn test_hash_map() {\n-        use std::collections::HashMap;\n-        let mut map = HashMap::new();\n-        for i in -100i64..100i64 {\n-            map.insert(i * 100000, i * 10000);\n-        }\n-\n-        check_round_trip(vec![map]);\n-    }\n-\n-    #[test]\n-    fn test_tuples() {\n-        check_round_trip(vec![('x', (), false, 0.5f32)]);\n-        check_round_trip(vec![(9i8, 10u16, 1.5f64)]);\n-        check_round_trip(vec![(-12i16, 11u8, 12usize)]);\n-        check_round_trip(vec![(1234567isize, 100000000000000u64, 99999999999999i64)]);\n-        check_round_trip(vec![(String::new(), \"some string\".to_string())]);\n-    }\n-}"}, {"sha": "977a36a220fdd9d22293d18910a6652bddd3581b", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -175,7 +175,7 @@ pub trait Decoder {\n     fn read_f64(&mut self) -> Result<f64, Self::Error>;\n     fn read_f32(&mut self) -> Result<f32, Self::Error>;\n     fn read_char(&mut self) -> Result<char, Self::Error>;\n-    fn read_str(&mut self) -> Result<Cow<str>, Self::Error>;\n+    fn read_str(&mut self) -> Result<Cow<'_, str>, Self::Error>;\n \n     // Compound types:\n     fn read_enum<T, F>(&mut self, _name: &str, f: F) -> Result<T, Self::Error>"}, {"sha": "3fb6bda679bc1173522da11c328c8acb5465a9ff", "filename": "src/libserialize/tests/json.rs", "status": "added", "additions": 1282, "deletions": 0, "changes": 1282, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibserialize%2Ftests%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibserialize%2Ftests%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Ftests%2Fjson.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -0,0 +1,1282 @@\n+extern crate serialize as rustc_serialize;\n+\n+use rustc_serialize::{Encodable, Decodable};\n+use rustc_serialize::json;\n+use json::Json::*;\n+use json::ErrorCode::*;\n+use json::ParserError::*;\n+use json::DecoderError::*;\n+use json::JsonEvent::*;\n+use json::{Json, from_str, DecodeResult, DecoderError, JsonEvent, Parser, StackElement,\n+           Decoder, Encoder, EncoderError};\n+\n+use Animal::*;\n+use std::{i64, u64, f32, f64};\n+use std::io::prelude::*;\n+use std::collections::BTreeMap;\n+use std::string;\n+\n+#[derive(RustcDecodable, Eq, PartialEq, Debug)]\n+struct OptionData {\n+    opt: Option<usize>,\n+}\n+\n+#[test]\n+fn test_decode_option_none() {\n+    let s =\"{}\";\n+    let obj: OptionData = json::decode(s).unwrap();\n+    assert_eq!(obj, OptionData { opt: None });\n+}\n+\n+#[test]\n+fn test_decode_option_some() {\n+    let s = \"{ \\\"opt\\\": 10 }\";\n+    let obj: OptionData = json::decode(s).unwrap();\n+    assert_eq!(obj, OptionData { opt: Some(10) });\n+}\n+\n+#[test]\n+fn test_decode_option_malformed() {\n+    check_err::<OptionData>(\"{ \\\"opt\\\": [] }\",\n+                            ExpectedError(\"Number\".to_string(), \"[]\".to_string()));\n+    check_err::<OptionData>(\"{ \\\"opt\\\": false }\",\n+                            ExpectedError(\"Number\".to_string(), \"false\".to_string()));\n+}\n+\n+#[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+enum Animal {\n+    Dog,\n+    Frog(string::String, isize)\n+}\n+\n+#[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+struct Inner {\n+    a: (),\n+    b: usize,\n+    c: Vec<string::String>,\n+}\n+\n+#[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+struct Outer {\n+    inner: Vec<Inner>,\n+}\n+\n+fn mk_object(items: &[(string::String, Json)]) -> Json {\n+    let mut d = BTreeMap::new();\n+\n+    for item in items {\n+        match *item {\n+            (ref key, ref value) => { d.insert((*key).clone(), (*value).clone()); },\n+        }\n+    };\n+\n+    Object(d)\n+}\n+\n+#[test]\n+fn test_from_str_trait() {\n+    let s = \"null\";\n+    assert!(s.parse::<Json>().unwrap() == s.parse().unwrap());\n+}\n+\n+#[test]\n+fn test_write_null() {\n+    assert_eq!(Null.to_string(), \"null\");\n+    assert_eq!(Null.pretty().to_string(), \"null\");\n+}\n+\n+#[test]\n+fn test_write_i64() {\n+    assert_eq!(U64(0).to_string(), \"0\");\n+    assert_eq!(U64(0).pretty().to_string(), \"0\");\n+\n+    assert_eq!(U64(1234).to_string(), \"1234\");\n+    assert_eq!(U64(1234).pretty().to_string(), \"1234\");\n+\n+    assert_eq!(I64(-5678).to_string(), \"-5678\");\n+    assert_eq!(I64(-5678).pretty().to_string(), \"-5678\");\n+\n+    assert_eq!(U64(7650007200025252000).to_string(), \"7650007200025252000\");\n+    assert_eq!(U64(7650007200025252000).pretty().to_string(), \"7650007200025252000\");\n+}\n+\n+#[test]\n+fn test_write_f64() {\n+    assert_eq!(F64(3.0).to_string(), \"3.0\");\n+    assert_eq!(F64(3.0).pretty().to_string(), \"3.0\");\n+\n+    assert_eq!(F64(3.1).to_string(), \"3.1\");\n+    assert_eq!(F64(3.1).pretty().to_string(), \"3.1\");\n+\n+    assert_eq!(F64(-1.5).to_string(), \"-1.5\");\n+    assert_eq!(F64(-1.5).pretty().to_string(), \"-1.5\");\n+\n+    assert_eq!(F64(0.5).to_string(), \"0.5\");\n+    assert_eq!(F64(0.5).pretty().to_string(), \"0.5\");\n+\n+    assert_eq!(F64(f64::NAN).to_string(), \"null\");\n+    assert_eq!(F64(f64::NAN).pretty().to_string(), \"null\");\n+\n+    assert_eq!(F64(f64::INFINITY).to_string(), \"null\");\n+    assert_eq!(F64(f64::INFINITY).pretty().to_string(), \"null\");\n+\n+    assert_eq!(F64(f64::NEG_INFINITY).to_string(), \"null\");\n+    assert_eq!(F64(f64::NEG_INFINITY).pretty().to_string(), \"null\");\n+}\n+\n+#[test]\n+fn test_write_str() {\n+    assert_eq!(String(\"\".to_string()).to_string(), \"\\\"\\\"\");\n+    assert_eq!(String(\"\".to_string()).pretty().to_string(), \"\\\"\\\"\");\n+\n+    assert_eq!(String(\"homura\".to_string()).to_string(), \"\\\"homura\\\"\");\n+    assert_eq!(String(\"madoka\".to_string()).pretty().to_string(), \"\\\"madoka\\\"\");\n+}\n+\n+#[test]\n+fn test_write_bool() {\n+    assert_eq!(Boolean(true).to_string(), \"true\");\n+    assert_eq!(Boolean(true).pretty().to_string(), \"true\");\n+\n+    assert_eq!(Boolean(false).to_string(), \"false\");\n+    assert_eq!(Boolean(false).pretty().to_string(), \"false\");\n+}\n+\n+#[test]\n+fn test_write_array() {\n+    assert_eq!(Array(vec![]).to_string(), \"[]\");\n+    assert_eq!(Array(vec![]).pretty().to_string(), \"[]\");\n+\n+    assert_eq!(Array(vec![Boolean(true)]).to_string(), \"[true]\");\n+    assert_eq!(\n+        Array(vec![Boolean(true)]).pretty().to_string(),\n+        \"\\\n+        [\\n  \\\n+            true\\n\\\n+        ]\"\n+    );\n+\n+    let long_test_array = Array(vec![\n+        Boolean(false),\n+        Null,\n+        Array(vec![String(\"foo\\nbar\".to_string()), F64(3.5)])]);\n+\n+    assert_eq!(long_test_array.to_string(),\n+        \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n+    assert_eq!(\n+        long_test_array.pretty().to_string(),\n+        \"\\\n+        [\\n  \\\n+            false,\\n  \\\n+            null,\\n  \\\n+            [\\n    \\\n+                \\\"foo\\\\nbar\\\",\\n    \\\n+                3.5\\n  \\\n+            ]\\n\\\n+        ]\"\n+    );\n+}\n+\n+#[test]\n+fn test_write_object() {\n+    assert_eq!(mk_object(&[]).to_string(), \"{}\");\n+    assert_eq!(mk_object(&[]).pretty().to_string(), \"{}\");\n+\n+    assert_eq!(\n+        mk_object(&[\n+            (\"a\".to_string(), Boolean(true))\n+        ]).to_string(),\n+        \"{\\\"a\\\":true}\"\n+    );\n+    assert_eq!(\n+        mk_object(&[(\"a\".to_string(), Boolean(true))]).pretty().to_string(),\n+        \"\\\n+        {\\n  \\\n+            \\\"a\\\": true\\n\\\n+        }\"\n+    );\n+\n+    let complex_obj = mk_object(&[\n+            (\"b\".to_string(), Array(vec![\n+                mk_object(&[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n+                mk_object(&[(\"d\".to_string(), String(\"\".to_string()))])\n+            ]))\n+        ]);\n+\n+    assert_eq!(\n+        complex_obj.to_string(),\n+        \"{\\\n+            \\\"b\\\":[\\\n+                {\\\"c\\\":\\\"\\\\f\\\\r\\\"},\\\n+                {\\\"d\\\":\\\"\\\"}\\\n+            ]\\\n+        }\"\n+    );\n+    assert_eq!(\n+        complex_obj.pretty().to_string(),\n+        \"\\\n+        {\\n  \\\n+            \\\"b\\\": [\\n    \\\n+                {\\n      \\\n+                    \\\"c\\\": \\\"\\\\f\\\\r\\\"\\n    \\\n+                },\\n    \\\n+                {\\n      \\\n+                    \\\"d\\\": \\\"\\\"\\n    \\\n+                }\\n  \\\n+            ]\\n\\\n+        }\"\n+    );\n+\n+    let a = mk_object(&[\n+        (\"a\".to_string(), Boolean(true)),\n+        (\"b\".to_string(), Array(vec![\n+            mk_object(&[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n+            mk_object(&[(\"d\".to_string(), String(\"\".to_string()))])\n+        ]))\n+    ]);\n+\n+    // We can't compare the strings directly because the object fields be\n+    // printed in a different order.\n+    assert_eq!(a.clone(), a.to_string().parse().unwrap());\n+    assert_eq!(a.clone(), a.pretty().to_string().parse().unwrap());\n+}\n+\n+#[test]\n+fn test_write_enum() {\n+    let animal = Dog;\n+    assert_eq!(\n+        json::as_json(&animal).to_string(),\n+        \"\\\"Dog\\\"\"\n+    );\n+    assert_eq!(\n+        json::as_pretty_json(&animal).to_string(),\n+        \"\\\"Dog\\\"\"\n+    );\n+\n+    let animal = Frog(\"Henry\".to_string(), 349);\n+    assert_eq!(\n+        json::as_json(&animal).to_string(),\n+        \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\"\n+    );\n+    assert_eq!(\n+        json::as_pretty_json(&animal).to_string(),\n+        \"{\\n  \\\n+           \\\"variant\\\": \\\"Frog\\\",\\n  \\\n+           \\\"fields\\\": [\\n    \\\n+             \\\"Henry\\\",\\n    \\\n+             349\\n  \\\n+           ]\\n\\\n+         }\"\n+    );\n+}\n+\n+macro_rules! check_encoder_for_simple {\n+    ($value:expr, $expected:expr) => ({\n+        let s = json::as_json(&$value).to_string();\n+        assert_eq!(s, $expected);\n+\n+        let s = json::as_pretty_json(&$value).to_string();\n+        assert_eq!(s, $expected);\n+    })\n+}\n+\n+#[test]\n+fn test_write_some() {\n+    check_encoder_for_simple!(Some(\"jodhpurs\".to_string()), \"\\\"jodhpurs\\\"\");\n+}\n+\n+#[test]\n+fn test_write_none() {\n+    check_encoder_for_simple!(None::<string::String>, \"null\");\n+}\n+\n+#[test]\n+fn test_write_char() {\n+    check_encoder_for_simple!('a', \"\\\"a\\\"\");\n+    check_encoder_for_simple!('\\t', \"\\\"\\\\t\\\"\");\n+    check_encoder_for_simple!('\\u{0000}', \"\\\"\\\\u0000\\\"\");\n+    check_encoder_for_simple!('\\u{001b}', \"\\\"\\\\u001b\\\"\");\n+    check_encoder_for_simple!('\\u{007f}', \"\\\"\\\\u007f\\\"\");\n+    check_encoder_for_simple!('\\u{00a0}', \"\\\"\\u{00a0}\\\"\");\n+    check_encoder_for_simple!('\\u{abcd}', \"\\\"\\u{abcd}\\\"\");\n+    check_encoder_for_simple!('\\u{10ffff}', \"\\\"\\u{10ffff}\\\"\");\n+}\n+\n+#[test]\n+fn test_trailing_characters() {\n+    assert_eq!(from_str(\"nulla\"),  Err(SyntaxError(TrailingCharacters, 1, 5)));\n+    assert_eq!(from_str(\"truea\"),  Err(SyntaxError(TrailingCharacters, 1, 5)));\n+    assert_eq!(from_str(\"falsea\"), Err(SyntaxError(TrailingCharacters, 1, 6)));\n+    assert_eq!(from_str(\"1a\"),     Err(SyntaxError(TrailingCharacters, 1, 2)));\n+    assert_eq!(from_str(\"[]a\"),    Err(SyntaxError(TrailingCharacters, 1, 3)));\n+    assert_eq!(from_str(\"{}a\"),    Err(SyntaxError(TrailingCharacters, 1, 3)));\n+}\n+\n+#[test]\n+fn test_read_identifiers() {\n+    assert_eq!(from_str(\"n\"),    Err(SyntaxError(InvalidSyntax, 1, 2)));\n+    assert_eq!(from_str(\"nul\"),  Err(SyntaxError(InvalidSyntax, 1, 4)));\n+    assert_eq!(from_str(\"t\"),    Err(SyntaxError(InvalidSyntax, 1, 2)));\n+    assert_eq!(from_str(\"truz\"), Err(SyntaxError(InvalidSyntax, 1, 4)));\n+    assert_eq!(from_str(\"f\"),    Err(SyntaxError(InvalidSyntax, 1, 2)));\n+    assert_eq!(from_str(\"faz\"),  Err(SyntaxError(InvalidSyntax, 1, 3)));\n+\n+    assert_eq!(from_str(\"null\"), Ok(Null));\n+    assert_eq!(from_str(\"true\"), Ok(Boolean(true)));\n+    assert_eq!(from_str(\"false\"), Ok(Boolean(false)));\n+    assert_eq!(from_str(\" null \"), Ok(Null));\n+    assert_eq!(from_str(\" true \"), Ok(Boolean(true)));\n+    assert_eq!(from_str(\" false \"), Ok(Boolean(false)));\n+}\n+\n+#[test]\n+fn test_decode_identifiers() {\n+    let v: () = json::decode(\"null\").unwrap();\n+    assert_eq!(v, ());\n+\n+    let v: bool = json::decode(\"true\").unwrap();\n+    assert_eq!(v, true);\n+\n+    let v: bool = json::decode(\"false\").unwrap();\n+    assert_eq!(v, false);\n+}\n+\n+#[test]\n+fn test_read_number() {\n+    assert_eq!(from_str(\"+\"),   Err(SyntaxError(InvalidSyntax, 1, 1)));\n+    assert_eq!(from_str(\".\"),   Err(SyntaxError(InvalidSyntax, 1, 1)));\n+    assert_eq!(from_str(\"NaN\"), Err(SyntaxError(InvalidSyntax, 1, 1)));\n+    assert_eq!(from_str(\"-\"),   Err(SyntaxError(InvalidNumber, 1, 2)));\n+    assert_eq!(from_str(\"00\"),  Err(SyntaxError(InvalidNumber, 1, 2)));\n+    assert_eq!(from_str(\"1.\"),  Err(SyntaxError(InvalidNumber, 1, 3)));\n+    assert_eq!(from_str(\"1e\"),  Err(SyntaxError(InvalidNumber, 1, 3)));\n+    assert_eq!(from_str(\"1e+\"), Err(SyntaxError(InvalidNumber, 1, 4)));\n+\n+    assert_eq!(from_str(\"18446744073709551616\"), Err(SyntaxError(InvalidNumber, 1, 20)));\n+    assert_eq!(from_str(\"-9223372036854775809\"), Err(SyntaxError(InvalidNumber, 1, 21)));\n+\n+    assert_eq!(from_str(\"3\"), Ok(U64(3)));\n+    assert_eq!(from_str(\"3.1\"), Ok(F64(3.1)));\n+    assert_eq!(from_str(\"-1.2\"), Ok(F64(-1.2)));\n+    assert_eq!(from_str(\"0.4\"), Ok(F64(0.4)));\n+    assert_eq!(from_str(\"0.4e5\"), Ok(F64(0.4e5)));\n+    assert_eq!(from_str(\"0.4e+15\"), Ok(F64(0.4e15)));\n+    assert_eq!(from_str(\"0.4e-01\"), Ok(F64(0.4e-01)));\n+    assert_eq!(from_str(\" 3 \"), Ok(U64(3)));\n+\n+    assert_eq!(from_str(\"-9223372036854775808\"), Ok(I64(i64::MIN)));\n+    assert_eq!(from_str(\"9223372036854775807\"), Ok(U64(i64::MAX as u64)));\n+    assert_eq!(from_str(\"18446744073709551615\"), Ok(U64(u64::MAX)));\n+}\n+\n+#[test]\n+fn test_decode_numbers() {\n+    let v: f64 = json::decode(\"3\").unwrap();\n+    assert_eq!(v, 3.0);\n+\n+    let v: f64 = json::decode(\"3.1\").unwrap();\n+    assert_eq!(v, 3.1);\n+\n+    let v: f64 = json::decode(\"-1.2\").unwrap();\n+    assert_eq!(v, -1.2);\n+\n+    let v: f64 = json::decode(\"0.4\").unwrap();\n+    assert_eq!(v, 0.4);\n+\n+    let v: f64 = json::decode(\"0.4e5\").unwrap();\n+    assert_eq!(v, 0.4e5);\n+\n+    let v: f64 = json::decode(\"0.4e15\").unwrap();\n+    assert_eq!(v, 0.4e15);\n+\n+    let v: f64 = json::decode(\"0.4e-01\").unwrap();\n+    assert_eq!(v, 0.4e-01);\n+\n+    let v: u64 = json::decode(\"0\").unwrap();\n+    assert_eq!(v, 0);\n+\n+    let v: u64 = json::decode(\"18446744073709551615\").unwrap();\n+    assert_eq!(v, u64::MAX);\n+\n+    let v: i64 = json::decode(\"-9223372036854775808\").unwrap();\n+    assert_eq!(v, i64::MIN);\n+\n+    let v: i64 = json::decode(\"9223372036854775807\").unwrap();\n+    assert_eq!(v, i64::MAX);\n+\n+    let res: DecodeResult<i64> = json::decode(\"765.25\");\n+    assert_eq!(res, Err(ExpectedError(\"Integer\".to_string(),\n+                                      \"765.25\".to_string())));\n+}\n+\n+#[test]\n+fn test_read_str() {\n+    assert_eq!(from_str(\"\\\"\"),    Err(SyntaxError(EOFWhileParsingString, 1, 2)));\n+    assert_eq!(from_str(\"\\\"lol\"), Err(SyntaxError(EOFWhileParsingString, 1, 5)));\n+\n+    assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(\"\".to_string())));\n+    assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(\"foo\".to_string())));\n+    assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(\"\\\"\".to_string())));\n+    assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(\"\\x08\".to_string())));\n+    assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(\"\\n\".to_string())));\n+    assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(\"\\r\".to_string())));\n+    assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(\"\\t\".to_string())));\n+    assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(\"foo\".to_string())));\n+    assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(\"\\u{12ab}\".to_string())));\n+    assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(\"\\u{AB12}\".to_string())));\n+}\n+\n+#[test]\n+fn test_decode_str() {\n+    let s = [(\"\\\"\\\"\", \"\"),\n+             (\"\\\"foo\\\"\", \"foo\"),\n+             (\"\\\"\\\\\\\"\\\"\", \"\\\"\"),\n+             (\"\\\"\\\\b\\\"\", \"\\x08\"),\n+             (\"\\\"\\\\n\\\"\", \"\\n\"),\n+             (\"\\\"\\\\r\\\"\", \"\\r\"),\n+             (\"\\\"\\\\t\\\"\", \"\\t\"),\n+             (\"\\\"\\\\u12ab\\\"\", \"\\u{12ab}\"),\n+             (\"\\\"\\\\uAB12\\\"\", \"\\u{AB12}\")];\n+\n+    for &(i, o) in &s {\n+        let v: string::String = json::decode(i).unwrap();\n+        assert_eq!(v, o);\n+    }\n+}\n+\n+#[test]\n+fn test_read_array() {\n+    assert_eq!(from_str(\"[\"),     Err(SyntaxError(EOFWhileParsingValue, 1, 2)));\n+    assert_eq!(from_str(\"[1\"),    Err(SyntaxError(EOFWhileParsingArray, 1, 3)));\n+    assert_eq!(from_str(\"[1,\"),   Err(SyntaxError(EOFWhileParsingValue, 1, 4)));\n+    assert_eq!(from_str(\"[1,]\"),  Err(SyntaxError(InvalidSyntax,        1, 4)));\n+    assert_eq!(from_str(\"[6 7]\"), Err(SyntaxError(InvalidSyntax,        1, 4)));\n+\n+    assert_eq!(from_str(\"[]\"), Ok(Array(vec![])));\n+    assert_eq!(from_str(\"[ ]\"), Ok(Array(vec![])));\n+    assert_eq!(from_str(\"[true]\"), Ok(Array(vec![Boolean(true)])));\n+    assert_eq!(from_str(\"[ false ]\"), Ok(Array(vec![Boolean(false)])));\n+    assert_eq!(from_str(\"[null]\"), Ok(Array(vec![Null])));\n+    assert_eq!(from_str(\"[3, 1]\"),\n+                 Ok(Array(vec![U64(3), U64(1)])));\n+    assert_eq!(from_str(\"\\n[3, 2]\\n\"),\n+                 Ok(Array(vec![U64(3), U64(2)])));\n+    assert_eq!(from_str(\"[2, [4, 1]]\"),\n+           Ok(Array(vec![U64(2), Array(vec![U64(4), U64(1)])])));\n+}\n+\n+#[test]\n+fn test_decode_array() {\n+    let v: Vec<()> = json::decode(\"[]\").unwrap();\n+    assert_eq!(v, []);\n+\n+    let v: Vec<()> = json::decode(\"[null]\").unwrap();\n+    assert_eq!(v, [()]);\n+\n+    let v: Vec<bool> = json::decode(\"[true]\").unwrap();\n+    assert_eq!(v, [true]);\n+\n+    let v: Vec<isize> = json::decode(\"[3, 1]\").unwrap();\n+    assert_eq!(v, [3, 1]);\n+\n+    let v: Vec<Vec<usize>> = json::decode(\"[[3], [1, 2]]\").unwrap();\n+    assert_eq!(v, [vec![3], vec![1, 2]]);\n+}\n+\n+#[test]\n+fn test_decode_tuple() {\n+    let t: (usize, usize, usize) = json::decode(\"[1, 2, 3]\").unwrap();\n+    assert_eq!(t, (1, 2, 3));\n+\n+    let t: (usize, string::String) = json::decode(\"[1, \\\"two\\\"]\").unwrap();\n+    assert_eq!(t, (1, \"two\".to_string()));\n+}\n+\n+#[test]\n+fn test_decode_tuple_malformed_types() {\n+    assert!(json::decode::<(usize, string::String)>(\"[1, 2]\").is_err());\n+}\n+\n+#[test]\n+fn test_decode_tuple_malformed_length() {\n+    assert!(json::decode::<(usize, usize)>(\"[1, 2, 3]\").is_err());\n+}\n+\n+#[test]\n+fn test_read_object() {\n+    assert_eq!(from_str(\"{\"),       Err(SyntaxError(EOFWhileParsingObject, 1, 2)));\n+    assert_eq!(from_str(\"{ \"),      Err(SyntaxError(EOFWhileParsingObject, 1, 3)));\n+    assert_eq!(from_str(\"{1\"),      Err(SyntaxError(KeyMustBeAString,      1, 2)));\n+    assert_eq!(from_str(\"{ \\\"a\\\"\"), Err(SyntaxError(EOFWhileParsingObject, 1, 6)));\n+    assert_eq!(from_str(\"{\\\"a\\\"\"),  Err(SyntaxError(EOFWhileParsingObject, 1, 5)));\n+    assert_eq!(from_str(\"{\\\"a\\\" \"), Err(SyntaxError(EOFWhileParsingObject, 1, 6)));\n+\n+    assert_eq!(from_str(\"{\\\"a\\\" 1\"),   Err(SyntaxError(ExpectedColon,         1, 6)));\n+    assert_eq!(from_str(\"{\\\"a\\\":\"),    Err(SyntaxError(EOFWhileParsingValue,  1, 6)));\n+    assert_eq!(from_str(\"{\\\"a\\\":1\"),   Err(SyntaxError(EOFWhileParsingObject, 1, 7)));\n+    assert_eq!(from_str(\"{\\\"a\\\":1 1\"), Err(SyntaxError(InvalidSyntax,         1, 8)));\n+    assert_eq!(from_str(\"{\\\"a\\\":1,\"),  Err(SyntaxError(EOFWhileParsingObject, 1, 8)));\n+\n+    assert_eq!(from_str(\"{}\").unwrap(), mk_object(&[]));\n+    assert_eq!(from_str(\"{\\\"a\\\": 3}\").unwrap(),\n+                mk_object(&[(\"a\".to_string(), U64(3))]));\n+\n+    assert_eq!(from_str(\n+                    \"{ \\\"a\\\": null, \\\"b\\\" : true }\").unwrap(),\n+                mk_object(&[\n+                    (\"a\".to_string(), Null),\n+                    (\"b\".to_string(), Boolean(true))]));\n+    assert_eq!(from_str(\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\").unwrap(),\n+                mk_object(&[\n+                    (\"a\".to_string(), Null),\n+                    (\"b\".to_string(), Boolean(true))]));\n+    assert_eq!(from_str(\n+                    \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\").unwrap(),\n+                mk_object(&[\n+                    (\"a\".to_string(), F64(1.0)),\n+                    (\"b\".to_string(), Array(vec![Boolean(true)]))\n+                ]));\n+    assert_eq!(from_str(\n+                    \"{\\\n+                        \\\"a\\\": 1.0, \\\n+                        \\\"b\\\": [\\\n+                            true,\\\n+                            \\\"foo\\\\nbar\\\", \\\n+                            { \\\"c\\\": {\\\"d\\\": null} } \\\n+                        ]\\\n+                    }\").unwrap(),\n+                mk_object(&[\n+                    (\"a\".to_string(), F64(1.0)),\n+                    (\"b\".to_string(), Array(vec![\n+                        Boolean(true),\n+                        String(\"foo\\nbar\".to_string()),\n+                        mk_object(&[\n+                            (\"c\".to_string(), mk_object(&[(\"d\".to_string(), Null)]))\n+                        ])\n+                    ]))\n+                ]));\n+}\n+\n+#[test]\n+fn test_decode_struct() {\n+    let s = \"{\n+        \\\"inner\\\": [\n+            { \\\"a\\\": null, \\\"b\\\": 2, \\\"c\\\": [\\\"abc\\\", \\\"xyz\\\"] }\n+        ]\n+    }\";\n+\n+    let v: Outer = json::decode(s).unwrap();\n+    assert_eq!(\n+        v,\n+        Outer {\n+            inner: vec![\n+                Inner { a: (), b: 2, c: vec![\"abc\".to_string(), \"xyz\".to_string()] }\n+            ]\n+        }\n+    );\n+}\n+\n+#[derive(RustcDecodable)]\n+struct FloatStruct {\n+    f: f64,\n+    a: Vec<f64>\n+}\n+#[test]\n+fn test_decode_struct_with_nan() {\n+    let s = \"{\\\"f\\\":null,\\\"a\\\":[null,123]}\";\n+    let obj: FloatStruct = json::decode(s).unwrap();\n+    assert!(obj.f.is_nan());\n+    assert!(obj.a[0].is_nan());\n+    assert_eq!(obj.a[1], 123f64);\n+}\n+\n+#[test]\n+fn test_decode_option() {\n+    let value: Option<string::String> = json::decode(\"null\").unwrap();\n+    assert_eq!(value, None);\n+\n+    let value: Option<string::String> = json::decode(\"\\\"jodhpurs\\\"\").unwrap();\n+    assert_eq!(value, Some(\"jodhpurs\".to_string()));\n+}\n+\n+#[test]\n+fn test_decode_enum() {\n+    let value: Animal = json::decode(\"\\\"Dog\\\"\").unwrap();\n+    assert_eq!(value, Dog);\n+\n+    let s = \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\";\n+    let value: Animal = json::decode(s).unwrap();\n+    assert_eq!(value, Frog(\"Henry\".to_string(), 349));\n+}\n+\n+#[test]\n+fn test_decode_map() {\n+    let s = \"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": {\\\"variant\\\":\\\"Frog\\\",\\\n+              \\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n+    let mut map: BTreeMap<string::String, Animal> = json::decode(s).unwrap();\n+\n+    assert_eq!(map.remove(&\"a\".to_string()), Some(Dog));\n+    assert_eq!(map.remove(&\"b\".to_string()), Some(Frog(\"Henry\".to_string(), 349)));\n+}\n+\n+#[test]\n+fn test_multiline_errors() {\n+    assert_eq!(from_str(\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\"),\n+        Err(SyntaxError(EOFWhileParsingObject, 3, 8)));\n+}\n+\n+#[derive(RustcDecodable)]\n+#[allow(dead_code)]\n+struct DecodeStruct {\n+    x: f64,\n+    y: bool,\n+    z: string::String,\n+    w: Vec<DecodeStruct>\n+}\n+#[derive(RustcDecodable)]\n+enum DecodeEnum {\n+    A(f64),\n+    B(string::String)\n+}\n+fn check_err<T: Decodable>(to_parse: &'static str, expected: DecoderError) {\n+    let res: DecodeResult<T> = match from_str(to_parse) {\n+        Err(e) => Err(ParseError(e)),\n+        Ok(json) => Decodable::decode(&mut Decoder::new(json))\n+    };\n+    match res {\n+        Ok(_) => panic!(\"`{:?}` parsed & decoded ok, expecting error `{:?}`\",\n+                           to_parse, expected),\n+        Err(ParseError(e)) => panic!(\"`{:?}` is not valid json: {:?}\",\n+                                        to_parse, e),\n+        Err(e) => {\n+            assert_eq!(e, expected);\n+        }\n+    }\n+}\n+#[test]\n+fn test_decode_errors_struct() {\n+    check_err::<DecodeStruct>(\"[]\", ExpectedError(\"Object\".to_string(), \"[]\".to_string()));\n+    check_err::<DecodeStruct>(\"{\\\"x\\\": true, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n+                              ExpectedError(\"Number\".to_string(), \"true\".to_string()));\n+    check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": [], \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n+                              ExpectedError(\"Boolean\".to_string(), \"[]\".to_string()));\n+    check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": {}, \\\"w\\\": []}\",\n+                              ExpectedError(\"String\".to_string(), \"{}\".to_string()));\n+    check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": null}\",\n+                              ExpectedError(\"Array\".to_string(), \"null\".to_string()));\n+    check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\"}\",\n+                              MissingFieldError(\"w\".to_string()));\n+}\n+#[test]\n+fn test_decode_errors_enum() {\n+    check_err::<DecodeEnum>(\"{}\",\n+                            MissingFieldError(\"variant\".to_string()));\n+    check_err::<DecodeEnum>(\"{\\\"variant\\\": 1}\",\n+                            ExpectedError(\"String\".to_string(), \"1\".to_string()));\n+    check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\"}\",\n+                            MissingFieldError(\"fields\".to_string()));\n+    check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\", \\\"fields\\\": null}\",\n+                            ExpectedError(\"Array\".to_string(), \"null\".to_string()));\n+    check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"C\\\", \\\"fields\\\": []}\",\n+                            UnknownVariantError(\"C\".to_string()));\n+}\n+\n+#[test]\n+fn test_find(){\n+    let json_value = from_str(\"{\\\"dog\\\" : \\\"cat\\\"}\").unwrap();\n+    let found_str = json_value.find(\"dog\");\n+    assert!(found_str.unwrap().as_string().unwrap() == \"cat\");\n+}\n+\n+#[test]\n+fn test_find_path(){\n+    let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n+    let found_str = json_value.find_path(&[\"dog\", \"cat\", \"mouse\"]);\n+    assert!(found_str.unwrap().as_string().unwrap() == \"cheese\");\n+}\n+\n+#[test]\n+fn test_search(){\n+    let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n+    let found_str = json_value.search(\"mouse\").and_then(|j| j.as_string());\n+    assert!(found_str.unwrap() == \"cheese\");\n+}\n+\n+#[test]\n+fn test_index(){\n+    let json_value = from_str(\"{\\\"animals\\\":[\\\"dog\\\",\\\"cat\\\",\\\"mouse\\\"]}\").unwrap();\n+    let ref array = json_value[\"animals\"];\n+    assert_eq!(array[0].as_string().unwrap(), \"dog\");\n+    assert_eq!(array[1].as_string().unwrap(), \"cat\");\n+    assert_eq!(array[2].as_string().unwrap(), \"mouse\");\n+}\n+\n+#[test]\n+fn test_is_object(){\n+    let json_value = from_str(\"{}\").unwrap();\n+    assert!(json_value.is_object());\n+}\n+\n+#[test]\n+fn test_as_object(){\n+    let json_value = from_str(\"{}\").unwrap();\n+    let json_object = json_value.as_object();\n+    assert!(json_object.is_some());\n+}\n+\n+#[test]\n+fn test_is_array(){\n+    let json_value = from_str(\"[1, 2, 3]\").unwrap();\n+    assert!(json_value.is_array());\n+}\n+\n+#[test]\n+fn test_as_array(){\n+    let json_value = from_str(\"[1, 2, 3]\").unwrap();\n+    let json_array = json_value.as_array();\n+    let expected_length = 3;\n+    assert!(json_array.is_some() && json_array.unwrap().len() == expected_length);\n+}\n+\n+#[test]\n+fn test_is_string(){\n+    let json_value = from_str(\"\\\"dog\\\"\").unwrap();\n+    assert!(json_value.is_string());\n+}\n+\n+#[test]\n+fn test_as_string(){\n+    let json_value = from_str(\"\\\"dog\\\"\").unwrap();\n+    let json_str = json_value.as_string();\n+    let expected_str = \"dog\";\n+    assert_eq!(json_str, Some(expected_str));\n+}\n+\n+#[test]\n+fn test_is_number(){\n+    let json_value = from_str(\"12\").unwrap();\n+    assert!(json_value.is_number());\n+}\n+\n+#[test]\n+fn test_is_i64(){\n+    let json_value = from_str(\"-12\").unwrap();\n+    assert!(json_value.is_i64());\n+\n+    let json_value = from_str(\"12\").unwrap();\n+    assert!(!json_value.is_i64());\n+\n+    let json_value = from_str(\"12.0\").unwrap();\n+    assert!(!json_value.is_i64());\n+}\n+\n+#[test]\n+fn test_is_u64(){\n+    let json_value = from_str(\"12\").unwrap();\n+    assert!(json_value.is_u64());\n+\n+    let json_value = from_str(\"-12\").unwrap();\n+    assert!(!json_value.is_u64());\n+\n+    let json_value = from_str(\"12.0\").unwrap();\n+    assert!(!json_value.is_u64());\n+}\n+\n+#[test]\n+fn test_is_f64(){\n+    let json_value = from_str(\"12\").unwrap();\n+    assert!(!json_value.is_f64());\n+\n+    let json_value = from_str(\"-12\").unwrap();\n+    assert!(!json_value.is_f64());\n+\n+    let json_value = from_str(\"12.0\").unwrap();\n+    assert!(json_value.is_f64());\n+\n+    let json_value = from_str(\"-12.0\").unwrap();\n+    assert!(json_value.is_f64());\n+}\n+\n+#[test]\n+fn test_as_i64(){\n+    let json_value = from_str(\"-12\").unwrap();\n+    let json_num = json_value.as_i64();\n+    assert_eq!(json_num, Some(-12));\n+}\n+\n+#[test]\n+fn test_as_u64(){\n+    let json_value = from_str(\"12\").unwrap();\n+    let json_num = json_value.as_u64();\n+    assert_eq!(json_num, Some(12));\n+}\n+\n+#[test]\n+fn test_as_f64(){\n+    let json_value = from_str(\"12.0\").unwrap();\n+    let json_num = json_value.as_f64();\n+    assert_eq!(json_num, Some(12f64));\n+}\n+\n+#[test]\n+fn test_is_boolean(){\n+    let json_value = from_str(\"false\").unwrap();\n+    assert!(json_value.is_boolean());\n+}\n+\n+#[test]\n+fn test_as_boolean(){\n+    let json_value = from_str(\"false\").unwrap();\n+    let json_bool = json_value.as_boolean();\n+    let expected_bool = false;\n+    assert!(json_bool.is_some() && json_bool.unwrap() == expected_bool);\n+}\n+\n+#[test]\n+fn test_is_null(){\n+    let json_value = from_str(\"null\").unwrap();\n+    assert!(json_value.is_null());\n+}\n+\n+#[test]\n+fn test_as_null(){\n+    let json_value = from_str(\"null\").unwrap();\n+    let json_null = json_value.as_null();\n+    let expected_null = ();\n+    assert!(json_null.is_some() && json_null.unwrap() == expected_null);\n+}\n+\n+#[test]\n+fn test_encode_hashmap_with_numeric_key() {\n+    use std::str::from_utf8;\n+    use std::collections::HashMap;\n+    let mut hm: HashMap<usize, bool> = HashMap::new();\n+    hm.insert(1, true);\n+    let mut mem_buf = Vec::new();\n+    write!(&mut mem_buf, \"{}\", json::as_pretty_json(&hm)).unwrap();\n+    let json_str = from_utf8(&mem_buf[..]).unwrap();\n+    match from_str(json_str) {\n+        Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n+        _ => {} // it parsed and we are good to go\n+    }\n+}\n+\n+#[test]\n+fn test_prettyencode_hashmap_with_numeric_key() {\n+    use std::str::from_utf8;\n+    use std::collections::HashMap;\n+    let mut hm: HashMap<usize, bool> = HashMap::new();\n+    hm.insert(1, true);\n+    let mut mem_buf = Vec::new();\n+    write!(&mut mem_buf, \"{}\", json::as_pretty_json(&hm)).unwrap();\n+    let json_str = from_utf8(&mem_buf[..]).unwrap();\n+    match from_str(json_str) {\n+        Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n+        _ => {} // it parsed and we are good to go\n+    }\n+}\n+\n+#[test]\n+fn test_prettyencoder_indent_level_param() {\n+    use std::str::from_utf8;\n+    use std::collections::BTreeMap;\n+\n+    let mut tree = BTreeMap::new();\n+\n+    tree.insert(\"hello\".to_string(), String(\"guten tag\".to_string()));\n+    tree.insert(\"goodbye\".to_string(), String(\"sayonara\".to_string()));\n+\n+    let json = Array(\n+        // The following layout below should look a lot like\n+        // the pretty-printed JSON (indent * x)\n+        vec!\n+        ( // 0x\n+            String(\"greetings\".to_string()), // 1x\n+            Object(tree), // 1x + 2x + 2x + 1x\n+        ) // 0x\n+        // End JSON array (7 lines)\n+    );\n+\n+    // Helper function for counting indents\n+    fn indents(source: &str) -> usize {\n+        let trimmed = source.trim_start_matches(' ');\n+        source.len() - trimmed.len()\n+    }\n+\n+    // Test up to 4 spaces of indents (more?)\n+    for i in 0..4 {\n+        let mut writer = Vec::new();\n+        write!(&mut writer, \"{}\",\n+                json::as_pretty_json(&json).indent(i)).unwrap();\n+\n+        let printed = from_utf8(&writer[..]).unwrap();\n+\n+        // Check for indents at each line\n+        let lines: Vec<&str> = printed.lines().collect();\n+        assert_eq!(lines.len(), 7); // JSON should be 7 lines\n+\n+        assert_eq!(indents(lines[0]), 0 * i); // [\n+        assert_eq!(indents(lines[1]), 1 * i); //   \"greetings\",\n+        assert_eq!(indents(lines[2]), 1 * i); //   {\n+        assert_eq!(indents(lines[3]), 2 * i); //     \"hello\": \"guten tag\",\n+        assert_eq!(indents(lines[4]), 2 * i); //     \"goodbye\": \"sayonara\"\n+        assert_eq!(indents(lines[5]), 1 * i); //   },\n+        assert_eq!(indents(lines[6]), 0 * i); // ]\n+\n+        // Finally, test that the pretty-printed JSON is valid\n+        from_str(printed).ok().expect(\"Pretty-printed JSON is invalid!\");\n+    }\n+}\n+\n+#[test]\n+fn test_hashmap_with_enum_key() {\n+    use std::collections::HashMap;\n+    #[derive(RustcEncodable, Eq, Hash, PartialEq, RustcDecodable, Debug)]\n+    enum Enum {\n+        Foo,\n+        #[allow(dead_code)]\n+        Bar,\n+    }\n+    let mut map = HashMap::new();\n+    map.insert(Enum::Foo, 0);\n+    let result = json::encode(&map).unwrap();\n+    assert_eq!(&result[..], r#\"{\"Foo\":0}\"#);\n+    let decoded: HashMap<Enum, _> = json::decode(&result).unwrap();\n+    assert_eq!(map, decoded);\n+}\n+\n+#[test]\n+fn test_hashmap_with_numeric_key_can_handle_double_quote_delimited_key() {\n+    use std::collections::HashMap;\n+    let json_str = \"{\\\"1\\\":true}\";\n+    let json_obj = match from_str(json_str) {\n+        Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n+        Ok(o) => o\n+    };\n+    let mut decoder = Decoder::new(json_obj);\n+    let _hm: HashMap<usize, bool> = Decodable::decode(&mut decoder).unwrap();\n+}\n+\n+#[test]\n+fn test_hashmap_with_numeric_key_will_error_with_string_keys() {\n+    use std::collections::HashMap;\n+    let json_str = \"{\\\"a\\\":true}\";\n+    let json_obj = match from_str(json_str) {\n+        Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n+        Ok(o) => o\n+    };\n+    let mut decoder = Decoder::new(json_obj);\n+    let result: Result<HashMap<usize, bool>, DecoderError> = Decodable::decode(&mut decoder);\n+    assert_eq!(result, Err(ExpectedError(\"Number\".to_string(), \"a\".to_string())));\n+}\n+\n+fn assert_stream_equal(src: &str,\n+                        expected: Vec<(JsonEvent, Vec<StackElement<'_>>)>) {\n+    let mut parser = Parser::new(src.chars());\n+    let mut i = 0;\n+    loop {\n+        let evt = match parser.next() {\n+            Some(e) => e,\n+            None => { break; }\n+        };\n+        let (ref expected_evt, ref expected_stack) = expected[i];\n+        if !parser.stack().is_equal_to(expected_stack) {\n+            panic!(\"Parser stack is not equal to {:?}\", expected_stack);\n+        }\n+        assert_eq!(&evt, expected_evt);\n+        i+=1;\n+    }\n+}\n+#[test]\n+fn test_streaming_parser() {\n+    assert_stream_equal(\n+        r#\"{ \"foo\":\"bar\", \"array\" : [0, 1, 2, 3, 4, 5], \"idents\":[null,true,false]}\"#,\n+        vec![\n+            (ObjectStart,             vec![]),\n+              (StringValue(\"bar\".to_string()),   vec![StackElement::Key(\"foo\")]),\n+              (ArrayStart,            vec![StackElement::Key(\"array\")]),\n+                (U64Value(0),         vec![StackElement::Key(\"array\"), StackElement::Index(0)]),\n+                (U64Value(1),         vec![StackElement::Key(\"array\"), StackElement::Index(1)]),\n+                (U64Value(2),         vec![StackElement::Key(\"array\"), StackElement::Index(2)]),\n+                (U64Value(3),         vec![StackElement::Key(\"array\"), StackElement::Index(3)]),\n+                (U64Value(4),         vec![StackElement::Key(\"array\"), StackElement::Index(4)]),\n+                (U64Value(5),         vec![StackElement::Key(\"array\"), StackElement::Index(5)]),\n+              (ArrayEnd,              vec![StackElement::Key(\"array\")]),\n+              (ArrayStart,            vec![StackElement::Key(\"idents\")]),\n+                (NullValue,           vec![StackElement::Key(\"idents\"),\n+                                           StackElement::Index(0)]),\n+                (BooleanValue(true),  vec![StackElement::Key(\"idents\"),\n+                                           StackElement::Index(1)]),\n+                (BooleanValue(false), vec![StackElement::Key(\"idents\"),\n+                                           StackElement::Index(2)]),\n+              (ArrayEnd,              vec![StackElement::Key(\"idents\")]),\n+            (ObjectEnd,               vec![]),\n+        ]\n+    );\n+}\n+fn last_event(src: &str) -> JsonEvent {\n+    let mut parser = Parser::new(src.chars());\n+    let mut evt = NullValue;\n+    loop {\n+        evt = match parser.next() {\n+            Some(e) => e,\n+            None => return evt,\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_read_object_streaming() {\n+    assert_eq!(last_event(\"{ \"),      Error(SyntaxError(EOFWhileParsingObject, 1, 3)));\n+    assert_eq!(last_event(\"{1\"),      Error(SyntaxError(KeyMustBeAString,      1, 2)));\n+    assert_eq!(last_event(\"{ \\\"a\\\"\"), Error(SyntaxError(EOFWhileParsingObject, 1, 6)));\n+    assert_eq!(last_event(\"{\\\"a\\\"\"),  Error(SyntaxError(EOFWhileParsingObject, 1, 5)));\n+    assert_eq!(last_event(\"{\\\"a\\\" \"), Error(SyntaxError(EOFWhileParsingObject, 1, 6)));\n+\n+    assert_eq!(last_event(\"{\\\"a\\\" 1\"),   Error(SyntaxError(ExpectedColon,         1, 6)));\n+    assert_eq!(last_event(\"{\\\"a\\\":\"),    Error(SyntaxError(EOFWhileParsingValue,  1, 6)));\n+    assert_eq!(last_event(\"{\\\"a\\\":1\"),   Error(SyntaxError(EOFWhileParsingObject, 1, 7)));\n+    assert_eq!(last_event(\"{\\\"a\\\":1 1\"), Error(SyntaxError(InvalidSyntax,         1, 8)));\n+    assert_eq!(last_event(\"{\\\"a\\\":1,\"),  Error(SyntaxError(EOFWhileParsingObject, 1, 8)));\n+    assert_eq!(last_event(\"{\\\"a\\\":1,}\"), Error(SyntaxError(TrailingComma, 1, 8)));\n+\n+    assert_stream_equal(\n+        \"{}\",\n+        vec![(ObjectStart, vec![]), (ObjectEnd, vec![])]\n+    );\n+    assert_stream_equal(\n+        \"{\\\"a\\\": 3}\",\n+        vec![\n+            (ObjectStart,        vec![]),\n+              (U64Value(3),      vec![StackElement::Key(\"a\")]),\n+            (ObjectEnd,          vec![]),\n+        ]\n+    );\n+    assert_stream_equal(\n+        \"{ \\\"a\\\": null, \\\"b\\\" : true }\",\n+        vec![\n+            (ObjectStart,           vec![]),\n+              (NullValue,           vec![StackElement::Key(\"a\")]),\n+              (BooleanValue(true),  vec![StackElement::Key(\"b\")]),\n+            (ObjectEnd,             vec![]),\n+        ]\n+    );\n+    assert_stream_equal(\n+        \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\",\n+        vec![\n+            (ObjectStart,           vec![]),\n+              (F64Value(1.0),       vec![StackElement::Key(\"a\")]),\n+              (ArrayStart,          vec![StackElement::Key(\"b\")]),\n+                (BooleanValue(true),vec![StackElement::Key(\"b\"), StackElement::Index(0)]),\n+              (ArrayEnd,            vec![StackElement::Key(\"b\")]),\n+            (ObjectEnd,             vec![]),\n+        ]\n+    );\n+    assert_stream_equal(\n+        r#\"{\n+            \"a\": 1.0,\n+            \"b\": [\n+                true,\n+                \"foo\\nbar\",\n+                { \"c\": {\"d\": null} }\n+            ]\n+        }\"#,\n+        vec![\n+            (ObjectStart,                   vec![]),\n+              (F64Value(1.0),               vec![StackElement::Key(\"a\")]),\n+              (ArrayStart,                  vec![StackElement::Key(\"b\")]),\n+                (BooleanValue(true),        vec![StackElement::Key(\"b\"),\n+                                                StackElement::Index(0)]),\n+                (StringValue(\"foo\\nbar\".to_string()),  vec![StackElement::Key(\"b\"),\n+                                                            StackElement::Index(1)]),\n+                (ObjectStart,               vec![StackElement::Key(\"b\"),\n+                                                 StackElement::Index(2)]),\n+                  (ObjectStart,             vec![StackElement::Key(\"b\"),\n+                                                 StackElement::Index(2),\n+                                                 StackElement::Key(\"c\")]),\n+                    (NullValue,             vec![StackElement::Key(\"b\"),\n+                                                 StackElement::Index(2),\n+                                                 StackElement::Key(\"c\"),\n+                                                 StackElement::Key(\"d\")]),\n+                  (ObjectEnd,               vec![StackElement::Key(\"b\"),\n+                                                 StackElement::Index(2),\n+                                                 StackElement::Key(\"c\")]),\n+                (ObjectEnd,                 vec![StackElement::Key(\"b\"),\n+                                                 StackElement::Index(2)]),\n+              (ArrayEnd,                    vec![StackElement::Key(\"b\")]),\n+            (ObjectEnd,                     vec![]),\n+        ]\n+    );\n+}\n+#[test]\n+fn test_read_array_streaming() {\n+    assert_stream_equal(\n+        \"[]\",\n+        vec![\n+            (ArrayStart, vec![]),\n+            (ArrayEnd,   vec![]),\n+        ]\n+    );\n+    assert_stream_equal(\n+        \"[ ]\",\n+        vec![\n+            (ArrayStart, vec![]),\n+            (ArrayEnd,   vec![]),\n+        ]\n+    );\n+    assert_stream_equal(\n+        \"[true]\",\n+        vec![\n+            (ArrayStart,             vec![]),\n+                (BooleanValue(true), vec![StackElement::Index(0)]),\n+            (ArrayEnd,               vec![]),\n+        ]\n+    );\n+    assert_stream_equal(\n+        \"[ false ]\",\n+        vec![\n+            (ArrayStart,              vec![]),\n+                (BooleanValue(false), vec![StackElement::Index(0)]),\n+            (ArrayEnd,                vec![]),\n+        ]\n+    );\n+    assert_stream_equal(\n+        \"[null]\",\n+        vec![\n+            (ArrayStart,    vec![]),\n+                (NullValue, vec![StackElement::Index(0)]),\n+            (ArrayEnd,      vec![]),\n+        ]\n+    );\n+    assert_stream_equal(\n+        \"[3, 1]\",\n+        vec![\n+            (ArrayStart,      vec![]),\n+                (U64Value(3), vec![StackElement::Index(0)]),\n+                (U64Value(1), vec![StackElement::Index(1)]),\n+            (ArrayEnd,        vec![]),\n+        ]\n+    );\n+    assert_stream_equal(\n+        \"\\n[3, 2]\\n\",\n+        vec![\n+            (ArrayStart,      vec![]),\n+                (U64Value(3), vec![StackElement::Index(0)]),\n+                (U64Value(2), vec![StackElement::Index(1)]),\n+            (ArrayEnd,        vec![]),\n+        ]\n+    );\n+    assert_stream_equal(\n+        \"[2, [4, 1]]\",\n+        vec![\n+            (ArrayStart,           vec![]),\n+                (U64Value(2),      vec![StackElement::Index(0)]),\n+                (ArrayStart,       vec![StackElement::Index(1)]),\n+                    (U64Value(4),  vec![StackElement::Index(1), StackElement::Index(0)]),\n+                    (U64Value(1),  vec![StackElement::Index(1), StackElement::Index(1)]),\n+                (ArrayEnd,         vec![StackElement::Index(1)]),\n+            (ArrayEnd,             vec![]),\n+        ]\n+    );\n+\n+    assert_eq!(last_event(\"[\"), Error(SyntaxError(EOFWhileParsingValue, 1,  2)));\n+\n+    assert_eq!(from_str(\"[\"),     Err(SyntaxError(EOFWhileParsingValue, 1, 2)));\n+    assert_eq!(from_str(\"[1\"),    Err(SyntaxError(EOFWhileParsingArray, 1, 3)));\n+    assert_eq!(from_str(\"[1,\"),   Err(SyntaxError(EOFWhileParsingValue, 1, 4)));\n+    assert_eq!(from_str(\"[1,]\"),  Err(SyntaxError(InvalidSyntax,        1, 4)));\n+    assert_eq!(from_str(\"[6 7]\"), Err(SyntaxError(InvalidSyntax,        1, 4)));\n+\n+}\n+#[test]\n+fn test_trailing_characters_streaming() {\n+    assert_eq!(last_event(\"nulla\"),  Error(SyntaxError(TrailingCharacters, 1, 5)));\n+    assert_eq!(last_event(\"truea\"),  Error(SyntaxError(TrailingCharacters, 1, 5)));\n+    assert_eq!(last_event(\"falsea\"), Error(SyntaxError(TrailingCharacters, 1, 6)));\n+    assert_eq!(last_event(\"1a\"),     Error(SyntaxError(TrailingCharacters, 1, 2)));\n+    assert_eq!(last_event(\"[]a\"),    Error(SyntaxError(TrailingCharacters, 1, 3)));\n+    assert_eq!(last_event(\"{}a\"),    Error(SyntaxError(TrailingCharacters, 1, 3)));\n+}\n+#[test]\n+fn test_read_identifiers_streaming() {\n+    assert_eq!(Parser::new(\"null\".chars()).next(), Some(NullValue));\n+    assert_eq!(Parser::new(\"true\".chars()).next(), Some(BooleanValue(true)));\n+    assert_eq!(Parser::new(\"false\".chars()).next(), Some(BooleanValue(false)));\n+\n+    assert_eq!(last_event(\"n\"),    Error(SyntaxError(InvalidSyntax, 1, 2)));\n+    assert_eq!(last_event(\"nul\"),  Error(SyntaxError(InvalidSyntax, 1, 4)));\n+    assert_eq!(last_event(\"t\"),    Error(SyntaxError(InvalidSyntax, 1, 2)));\n+    assert_eq!(last_event(\"truz\"), Error(SyntaxError(InvalidSyntax, 1, 4)));\n+    assert_eq!(last_event(\"f\"),    Error(SyntaxError(InvalidSyntax, 1, 2)));\n+    assert_eq!(last_event(\"faz\"),  Error(SyntaxError(InvalidSyntax, 1, 3)));\n+}\n+\n+#[test]\n+fn test_to_json() {\n+    use std::collections::{HashMap,BTreeMap};\n+    use json::ToJson;\n+\n+    let array2 = Array(vec![U64(1), U64(2)]);\n+    let array3 = Array(vec![U64(1), U64(2), U64(3)]);\n+    let object = {\n+        let mut tree_map = BTreeMap::new();\n+        tree_map.insert(\"a\".to_string(), U64(1));\n+        tree_map.insert(\"b\".to_string(), U64(2));\n+        Object(tree_map)\n+    };\n+\n+    assert_eq!(array2.to_json(), array2);\n+    assert_eq!(object.to_json(), object);\n+    assert_eq!(3_isize.to_json(), I64(3));\n+    assert_eq!(4_i8.to_json(), I64(4));\n+    assert_eq!(5_i16.to_json(), I64(5));\n+    assert_eq!(6_i32.to_json(), I64(6));\n+    assert_eq!(7_i64.to_json(), I64(7));\n+    assert_eq!(8_usize.to_json(), U64(8));\n+    assert_eq!(9_u8.to_json(), U64(9));\n+    assert_eq!(10_u16.to_json(), U64(10));\n+    assert_eq!(11_u32.to_json(), U64(11));\n+    assert_eq!(12_u64.to_json(), U64(12));\n+    assert_eq!(13.0_f32.to_json(), F64(13.0_f64));\n+    assert_eq!(14.0_f64.to_json(), F64(14.0_f64));\n+    assert_eq!(().to_json(), Null);\n+    assert_eq!(f32::INFINITY.to_json(), Null);\n+    assert_eq!(f64::NAN.to_json(), Null);\n+    assert_eq!(true.to_json(), Boolean(true));\n+    assert_eq!(false.to_json(), Boolean(false));\n+    assert_eq!(\"abc\".to_json(), String(\"abc\".to_string()));\n+    assert_eq!(\"abc\".to_string().to_json(), String(\"abc\".to_string()));\n+    assert_eq!((1_usize, 2_usize).to_json(), array2);\n+    assert_eq!((1_usize, 2_usize, 3_usize).to_json(), array3);\n+    assert_eq!([1_usize, 2_usize].to_json(), array2);\n+    assert_eq!((&[1_usize, 2_usize, 3_usize]).to_json(), array3);\n+    assert_eq!((vec![1_usize, 2_usize]).to_json(), array2);\n+    assert_eq!(vec![1_usize, 2_usize, 3_usize].to_json(), array3);\n+    let mut tree_map = BTreeMap::new();\n+    tree_map.insert(\"a\".to_string(), 1 as usize);\n+    tree_map.insert(\"b\".to_string(), 2);\n+    assert_eq!(tree_map.to_json(), object);\n+    let mut hash_map = HashMap::new();\n+    hash_map.insert(\"a\".to_string(), 1 as usize);\n+    hash_map.insert(\"b\".to_string(), 2);\n+    assert_eq!(hash_map.to_json(), object);\n+    assert_eq!(Some(15).to_json(), I64(15));\n+    assert_eq!(Some(15 as usize).to_json(), U64(15));\n+    assert_eq!(None::<isize>.to_json(), Null);\n+}\n+\n+#[test]\n+fn test_encode_hashmap_with_arbitrary_key() {\n+    use std::collections::HashMap;\n+    #[derive(PartialEq, Eq, Hash, RustcEncodable)]\n+    struct ArbitraryType(usize);\n+    let mut hm: HashMap<ArbitraryType, bool> = HashMap::new();\n+    hm.insert(ArbitraryType(1), true);\n+    let mut mem_buf = string::String::new();\n+    let mut encoder = Encoder::new(&mut mem_buf);\n+    let result = hm.encode(&mut encoder);\n+    match result.unwrap_err() {\n+        EncoderError::BadHashmapKey => (),\n+        _ => panic!(\"expected bad hash map key\")\n+    }\n+}"}, {"sha": "fff6fc69e78428301107b5c101cf70b6d0f47ff3", "filename": "src/libserialize/tests/opaque.rs", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibserialize%2Ftests%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibserialize%2Ftests%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Ftests%2Fopaque.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -0,0 +1,282 @@\n+extern crate serialize as rustc_serialize;\n+\n+use rustc_serialize::{Encodable, Decodable};\n+use rustc_serialize::opaque::{Encoder, Decoder};\n+use std::fmt::Debug;\n+\n+#[derive(PartialEq, Clone, Debug, RustcEncodable, RustcDecodable)]\n+struct Struct {\n+    a: (),\n+    b: u8,\n+    c: u16,\n+    d: u32,\n+    e: u64,\n+    f: usize,\n+\n+    g: i8,\n+    h: i16,\n+    i: i32,\n+    j: i64,\n+    k: isize,\n+\n+    l: char,\n+    m: String,\n+    n: f32,\n+    o: f64,\n+    p: bool,\n+    q: Option<u32>,\n+}\n+\n+\n+fn check_round_trip<T: Encodable + Decodable + PartialEq + Debug>(values: Vec<T>) {\n+    let mut encoder = Encoder::new(Vec::new());\n+\n+    for value in &values {\n+        Encodable::encode(&value, &mut encoder).unwrap();\n+    }\n+\n+    let data = encoder.into_inner();\n+    let mut decoder = Decoder::new(&data[..], 0);\n+\n+    for value in values {\n+        let decoded = Decodable::decode(&mut decoder).unwrap();\n+        assert_eq!(value, decoded);\n+    }\n+}\n+\n+#[test]\n+fn test_unit() {\n+    check_round_trip(vec![(), (), (), ()]);\n+}\n+\n+#[test]\n+fn test_u8() {\n+    let mut vec = vec![];\n+    for i in ::std::u8::MIN..::std::u8::MAX {\n+        vec.push(i);\n+    }\n+    check_round_trip(vec);\n+}\n+\n+#[test]\n+fn test_u16() {\n+    for i in ::std::u16::MIN..::std::u16::MAX {\n+        check_round_trip(vec![1, 2, 3, i, i, i]);\n+    }\n+}\n+\n+#[test]\n+fn test_u32() {\n+    check_round_trip(vec![1, 2, 3, ::std::u32::MIN, 0, 1, ::std::u32::MAX, 2, 1]);\n+}\n+\n+#[test]\n+fn test_u64() {\n+    check_round_trip(vec![1, 2, 3, ::std::u64::MIN, 0, 1, ::std::u64::MAX, 2, 1]);\n+}\n+\n+#[test]\n+fn test_usize() {\n+    check_round_trip(vec![1, 2, 3, ::std::usize::MIN, 0, 1, ::std::usize::MAX, 2, 1]);\n+}\n+\n+#[test]\n+fn test_i8() {\n+    let mut vec = vec![];\n+    for i in ::std::i8::MIN..::std::i8::MAX {\n+        vec.push(i);\n+    }\n+    check_round_trip(vec);\n+}\n+\n+#[test]\n+fn test_i16() {\n+    for i in ::std::i16::MIN..::std::i16::MAX {\n+        check_round_trip(vec![-1, 2, -3, i, i, i, 2]);\n+    }\n+}\n+\n+#[test]\n+fn test_i32() {\n+    check_round_trip(vec![-1, 2, -3, ::std::i32::MIN, 0, 1, ::std::i32::MAX, 2, 1]);\n+}\n+\n+#[test]\n+fn test_i64() {\n+    check_round_trip(vec![-1, 2, -3, ::std::i64::MIN, 0, 1, ::std::i64::MAX, 2, 1]);\n+}\n+\n+#[test]\n+fn test_isize() {\n+    check_round_trip(vec![-1, 2, -3, ::std::isize::MIN, 0, 1, ::std::isize::MAX, 2, 1]);\n+}\n+\n+#[test]\n+fn test_bool() {\n+    check_round_trip(vec![false, true, true, false, false]);\n+}\n+\n+#[test]\n+fn test_f32() {\n+    let mut vec = vec![];\n+    for i in -100..100 {\n+        vec.push((i as f32) / 3.0);\n+    }\n+    check_round_trip(vec);\n+}\n+\n+#[test]\n+fn test_f64() {\n+    let mut vec = vec![];\n+    for i in -100..100 {\n+        vec.push((i as f64) / 3.0);\n+    }\n+    check_round_trip(vec);\n+}\n+\n+#[test]\n+fn test_char() {\n+    let vec = vec!['a', 'b', 'c', 'd', 'A', 'X', ' ', '#', '\u00d6', '\u00c4', '\u00b5', '\u20ac'];\n+    check_round_trip(vec);\n+}\n+\n+#[test]\n+fn test_string() {\n+    let vec = vec![\"abcbu\u00d6eiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpnvapeapmaebn\".to_string(),\n+                   \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpnvapeapmaebn\".to_string(),\n+                   \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpapmaebn\".to_string(),\n+                   \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmeabpnvapeapmaebn\".to_string(),\n+                   \"abcbu\u00d6ganei\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpnvapeapmaebn\".to_string(),\n+                   \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpmaebn\".to_string(),\n+                   \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5nvapeapmaebn\".to_string()];\n+\n+    check_round_trip(vec);\n+}\n+\n+#[test]\n+fn test_option() {\n+    check_round_trip(vec![Some(-1i8)]);\n+    check_round_trip(vec![Some(-2i16)]);\n+    check_round_trip(vec![Some(-3i32)]);\n+    check_round_trip(vec![Some(-4i64)]);\n+    check_round_trip(vec![Some(-5isize)]);\n+\n+    let none_i8: Option<i8> = None;\n+    check_round_trip(vec![none_i8]);\n+\n+    let none_i16: Option<i16> = None;\n+    check_round_trip(vec![none_i16]);\n+\n+    let none_i32: Option<i32> = None;\n+    check_round_trip(vec![none_i32]);\n+\n+    let none_i64: Option<i64> = None;\n+    check_round_trip(vec![none_i64]);\n+\n+    let none_isize: Option<isize> = None;\n+    check_round_trip(vec![none_isize]);\n+}\n+\n+#[test]\n+fn test_struct() {\n+    check_round_trip(vec![Struct {\n+                              a: (),\n+                              b: 10,\n+                              c: 11,\n+                              d: 12,\n+                              e: 13,\n+                              f: 14,\n+\n+                              g: 15,\n+                              h: 16,\n+                              i: 17,\n+                              j: 18,\n+                              k: 19,\n+\n+                              l: 'x',\n+                              m: \"abc\".to_string(),\n+                              n: 20.5,\n+                              o: 21.5,\n+                              p: false,\n+                              q: None,\n+                          }]);\n+\n+    check_round_trip(vec![Struct {\n+                              a: (),\n+                              b: 101,\n+                              c: 111,\n+                              d: 121,\n+                              e: 131,\n+                              f: 141,\n+\n+                              g: -15,\n+                              h: -16,\n+                              i: -17,\n+                              j: -18,\n+                              k: -19,\n+\n+                              l: 'y',\n+                              m: \"def\".to_string(),\n+                              n: -20.5,\n+                              o: -21.5,\n+                              p: true,\n+                              q: Some(1234567),\n+                          }]);\n+}\n+\n+#[derive(PartialEq, Clone, Debug, RustcEncodable, RustcDecodable)]\n+enum Enum {\n+    Variant1,\n+    Variant2(usize, f32),\n+    Variant3 {\n+        a: i32,\n+        b: char,\n+        c: bool,\n+    },\n+}\n+\n+#[test]\n+fn test_enum() {\n+    check_round_trip(vec![Enum::Variant1,\n+                          Enum::Variant2(1, 2.5),\n+                          Enum::Variant3 {\n+                              a: 3,\n+                              b: 'b',\n+                              c: false,\n+                          },\n+                          Enum::Variant3 {\n+                              a: -4,\n+                              b: 'f',\n+                              c: true,\n+                          }]);\n+}\n+\n+#[test]\n+fn test_sequence() {\n+    let mut vec = vec![];\n+    for i in -100i64..100i64 {\n+        vec.push(i * 100000);\n+    }\n+\n+    check_round_trip(vec![vec]);\n+}\n+\n+#[test]\n+fn test_hash_map() {\n+    use std::collections::HashMap;\n+    let mut map = HashMap::new();\n+    for i in -100i64..100i64 {\n+        map.insert(i * 100000, i * 10000);\n+    }\n+\n+    check_round_trip(vec![map]);\n+}\n+\n+#[test]\n+fn test_tuples() {\n+    check_round_trip(vec![('x', (), false, 0.5f32)]);\n+    check_round_trip(vec![(9i8, 10u16, 1.5f64)]);\n+    check_round_trip(vec![(-12i16, 11u8, 12usize)]);\n+    check_round_trip(vec![(1234567isize, 100000000000000u64, 99999999999999i64)]);\n+    check_round_trip(vec![(String::new(), \"some string\".to_string())]);\n+}"}, {"sha": "ccbac1a3e4b5983e46677909268f61170dd48d91", "filename": "src/libstd/sys/unix/ext/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,4 +1,4 @@\n-//! Experimental extensions to `std` for Unix platforms.\n+//! Platform-specific extensions to `std` for Unix platforms.\n //!\n //! Provides access to platform-level information on Unix platforms, and\n //! exposes Unix-specific functions that would otherwise be inappropriate as"}, {"sha": "c844f9e2a91eecc5d45ce98cd0e8b6bf0bec6a1e", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -11,6 +11,7 @@\n \n #![feature(crate_visibility_modifier)]\n #![feature(label_break_value)]\n+#![feature(nll)]\n #![feature(rustc_attrs)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]"}, {"sha": "7d7fd03085912f4dc8d366bb4af267c082951d24", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -9,6 +9,7 @@\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_span)]\n #![feature(decl_macro)]\n+#![feature(nll)]\n #![feature(str_escape)]\n #![feature(rustc_diagnostic_macros)]\n "}, {"sha": "dbb4f8f8159dc84ac00c436607b95552611241ed", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -11,6 +11,7 @@\n #![feature(const_fn)]\n #![feature(crate_visibility_modifier)]\n #![feature(custom_attribute)]\n+#![feature(nll)]\n #![feature(non_exhaustive)]\n #![feature(optin_builtin_traits)]\n #![feature(rustc_attrs)]"}, {"sha": "4eba9a9d79cc431f2bd43ee8cae66c5fda0400eb", "filename": "src/libterm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibterm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibterm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2FCargo.toml?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"term\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"term\""}, {"sha": "caca9fa4823122f7cc99b41b771f622af6431d29", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -35,20 +35,20 @@\n        test(attr(deny(warnings))))]\n #![deny(missing_docs)]\n \n+#![deny(rust_2018_idioms)]\n+\n #![cfg_attr(windows, feature(libc))]\n // Handle rustfmt skips\n #![feature(custom_attribute)]\n-#![feature(nll)]\n #![allow(unused_attributes)]\n \n use std::io::prelude::*;\n+use std::io::{self, Stdout, Stderr};\n \n pub use terminfo::TerminfoTerminal;\n #[cfg(windows)]\n pub use win::WinConsole;\n \n-use std::io::{self, Stdout, Stderr};\n-\n pub mod terminfo;\n \n #[cfg(windows)]"}, {"sha": "4c3b0b19e27172d852c56c11f5d208a63c5bd0be", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -5,18 +5,16 @@ use std::env;\n use std::error;\n use std::fmt;\n use std::fs::File;\n-use std::io::prelude::*;\n-use std::io;\n-use std::io::BufReader;\n+use std::io::{self, prelude::*, BufReader};\n use std::path::Path;\n \n-use Attr;\n-use color;\n-use Terminal;\n-use self::searcher::get_dbpath_for_term;\n-use self::parser::compiled::{parse, msys_terminfo};\n-use self::parm::{expand, Variables, Param};\n+use crate::Attr;\n+use crate::color;\n+use crate::Terminal;\n \n+use searcher::get_dbpath_for_term;\n+use parser::compiled::{parse, msys_terminfo};\n+use parm::{expand, Variables, Param};\n \n /// A parsed terminfo database entry.\n #[derive(Debug)]\n@@ -49,7 +47,7 @@ impl error::Error for Error {\n     }\n \n     fn cause(&self) -> Option<&dyn error::Error> {\n-        use self::Error::*;\n+        use Error::*;\n         match *self {\n             IoError(ref e) => Some(e),\n             _ => None,\n@@ -58,8 +56,8 @@ impl error::Error for Error {\n }\n \n impl fmt::Display for Error {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        use self::Error::*;\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use Error::*;\n         match *self {\n             TermUnset => Ok(()),\n             MalformedTerminfo(ref e) => e.fmt(f),"}, {"sha": "4e81b8a7f28a6b892c604679ac3d8f6aab0a0214", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -40,23 +40,27 @@ pub enum Param {\n /// Container for static and dynamic variable arrays\n pub struct Variables {\n     /// Static variables A-Z\n-    sta: [Param; 26],\n+    sta_va: [Param; 26],\n     /// Dynamic variables a-z\n-    dyn: [Param; 26],\n+    dyn_va: [Param; 26],\n }\n \n impl Variables {\n     /// Return a new zero-initialized Variables\n     pub fn new() -> Variables {\n         Variables {\n-            sta: [Number(0), Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n-                  Number(0), Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n-                  Number(0), Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n-                  Number(0), Number(0), Number(0), Number(0), Number(0)],\n-            dyn: [Number(0), Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n-                  Number(0), Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n-                  Number(0), Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n-                  Number(0), Number(0), Number(0), Number(0), Number(0)],\n+            sta_va: [\n+                Number(0), Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n+                Number(0), Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n+                Number(0), Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n+                Number(0), Number(0), Number(0), Number(0), Number(0)\n+            ],\n+            dyn_va: [\n+                Number(0), Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n+                Number(0), Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n+                Number(0), Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n+                Number(0), Number(0), Number(0), Number(0), Number(0)\n+            ],\n         }\n     }\n }\n@@ -249,14 +253,14 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n                 if cur >= 'A' && cur <= 'Z' {\n                     if let Some(arg) = stack.pop() {\n                         let idx = (cur as u8) - b'A';\n-                        vars.sta[idx as usize] = arg;\n+                        vars.sta_va[idx as usize] = arg;\n                     } else {\n                         return Err(\"stack is empty\".to_string());\n                     }\n                 } else if cur >= 'a' && cur <= 'z' {\n                     if let Some(arg) = stack.pop() {\n                         let idx = (cur as u8) - b'a';\n-                        vars.dyn[idx as usize] = arg;\n+                        vars.dyn_va[idx as usize] = arg;\n                     } else {\n                         return Err(\"stack is empty\".to_string());\n                     }\n@@ -267,10 +271,10 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n             GetVar => {\n                 if cur >= 'A' && cur <= 'Z' {\n                     let idx = (cur as u8) - b'A';\n-                    stack.push(vars.sta[idx as usize].clone());\n+                    stack.push(vars.sta_va[idx as usize].clone());\n                 } else if cur >= 'a' && cur <= 'z' {\n                     let idx = (cur as u8) - b'a';\n-                    stack.push(vars.dyn[idx as usize].clone());\n+                    stack.push(vars.dyn_va[idx as usize].clone());\n                 } else {\n                     return Err(\"bad variable name in %g\".to_string());\n                 }"}, {"sha": "b7b9ce89bf3f6beedb317bef04e79681de8be680", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -3,14 +3,14 @@\n //! ncurses-compatible compiled terminfo format parsing (term(5))\n \n use std::collections::HashMap;\n-use std::io::prelude::*;\n use std::io;\n+use std::io::prelude::*;\n use super::super::TermInfo;\n \n // These are the orders ncurses uses in its compiled format (as of 5.9). Not sure if portable.\n \n #[rustfmt_skip]\n-pub static boolfnames: &'static[&'static str] = &[\"auto_left_margin\", \"auto_right_margin\",\n+pub static boolfnames: &[&str] = &[\"auto_left_margin\", \"auto_right_margin\",\n     \"no_esc_ctlc\", \"ceol_standout_glitch\", \"eat_newline_glitch\", \"erase_overstrike\", \"generic_type\",\n     \"hard_copy\", \"has_meta_key\", \"has_status_line\", \"insert_null_glitch\", \"memory_above\",\n     \"memory_below\", \"move_insert_mode\", \"move_standout_mode\", \"over_strike\", \"status_line_esc_ok\",\n@@ -23,13 +23,13 @@ pub static boolfnames: &'static[&'static str] = &[\"auto_left_margin\", \"auto_righ\n     \"return_does_clr_eol\"];\n \n #[rustfmt_skip]\n-pub static boolnames: &'static[&'static str] = &[\"bw\", \"am\", \"xsb\", \"xhp\", \"xenl\", \"eo\",\n+pub static boolnames: &[&str] = &[\"bw\", \"am\", \"xsb\", \"xhp\", \"xenl\", \"eo\",\n     \"gn\", \"hc\", \"km\", \"hs\", \"in\", \"db\", \"da\", \"mir\", \"msgr\", \"os\", \"eslok\", \"xt\", \"hz\", \"ul\", \"xon\",\n     \"nxon\", \"mc5i\", \"chts\", \"nrrmc\", \"npc\", \"ndscr\", \"ccc\", \"bce\", \"hls\", \"xhpa\", \"crxm\", \"daisy\",\n     \"xvpa\", \"sam\", \"cpix\", \"lpix\", \"OTbs\", \"OTns\", \"OTnc\", \"OTMT\", \"OTNL\", \"OTpt\", \"OTxr\"];\n \n #[rustfmt_skip]\n-pub static numfnames: &'static[&'static str] = &[ \"columns\", \"init_tabs\", \"lines\",\n+pub static numfnames: &[&str] = &[ \"columns\", \"init_tabs\", \"lines\",\n     \"lines_of_memory\", \"magic_cookie_glitch\", \"padding_baud_rate\", \"virtual_terminal\",\n     \"width_status_line\", \"num_labels\", \"label_height\", \"label_width\", \"max_attributes\",\n     \"maximum_windows\", \"max_colors\", \"max_pairs\", \"no_color_video\", \"buffer_capacity\",\n@@ -40,13 +40,13 @@ pub static numfnames: &'static[&'static str] = &[ \"columns\", \"init_tabs\", \"lines\n     \"new_line_delay\", \"backspace_delay\", \"horizontal_tab_delay\", \"number_of_function_keys\"];\n \n #[rustfmt_skip]\n-pub static numnames: &'static[&'static str] = &[ \"cols\", \"it\", \"lines\", \"lm\", \"xmc\", \"pb\",\n+pub static numnames: &[&str] = &[ \"cols\", \"it\", \"lines\", \"lm\", \"xmc\", \"pb\",\n     \"vt\", \"wsl\", \"nlab\", \"lh\", \"lw\", \"ma\", \"wnum\", \"colors\", \"pairs\", \"ncv\", \"bufsz\", \"spinv\",\n     \"spinh\", \"maddr\", \"mjump\", \"mcs\", \"mls\", \"npins\", \"orc\", \"orl\", \"orhi\", \"orvi\", \"cps\", \"widcs\",\n     \"btns\", \"bitwin\", \"bitype\", \"UTug\", \"OTdC\", \"OTdN\", \"OTdB\", \"OTdT\", \"OTkn\"];\n \n #[rustfmt_skip]\n-pub static stringfnames: &'static[&'static str] = &[ \"back_tab\", \"bell\", \"carriage_return\",\n+pub static stringfnames: &[&str] = &[ \"back_tab\", \"bell\", \"carriage_return\",\n     \"change_scroll_region\", \"clear_all_tabs\", \"clear_screen\", \"clr_eol\", \"clr_eos\",\n     \"column_address\", \"command_character\", \"cursor_address\", \"cursor_down\", \"cursor_home\",\n     \"cursor_invisible\", \"cursor_left\", \"cursor_mem_address\", \"cursor_normal\", \"cursor_right\",\n@@ -120,7 +120,7 @@ pub static stringfnames: &'static[&'static str] = &[ \"back_tab\", \"bell\", \"carria\n     \"acs_plus\", \"memory_lock\", \"memory_unlock\", \"box_chars_1\"];\n \n #[rustfmt_skip]\n-pub static stringnames: &'static[&'static str] = &[ \"cbt\", \"_\", \"cr\", \"csr\", \"tbc\", \"clear\",\n+pub static stringnames: &[&str] = &[ \"cbt\", \"_\", \"cr\", \"csr\", \"tbc\", \"clear\",\n     \"_\", \"_\", \"hpa\", \"cmdch\", \"cup\", \"cud1\", \"home\", \"civis\", \"cub1\", \"mrcup\", \"cnorm\", \"cuf1\",\n     \"ll\", \"cuu1\", \"cvvis\", \"dch1\", \"dl1\", \"dsl\", \"hd\", \"smacs\", \"blink\", \"bold\", \"smcup\", \"smdc\",\n     \"dim\", \"smir\", \"invis\", \"prot\", \"rev\", \"smso\", \"smul\", \"ech\", \"rmacs\", \"sgr0\", \"rmcup\", \"rmdc\","}, {"sha": "1051ddf1986f474ee8a8e61b584a71fdcad5b779", "filename": "src/libterm/win.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibterm%2Fwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibterm%2Fwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fwin.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -7,9 +7,9 @@ extern crate libc;\n use std::io;\n use std::io::prelude::*;\n \n-use Attr;\n-use color;\n-use Terminal;\n+use crate::Attr;\n+use crate::color;\n+use crate::Terminal;\n \n /// A Terminal implementation which uses the Win32 Console API.\n pub struct WinConsole<T> {"}, {"sha": "0ccffea317053ded4942fb2fc547ea6f2f13d7c7", "filename": "src/libunwind/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibunwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Flibunwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -4,6 +4,7 @@\n #![deny(rust_2018_idioms)]\n \n #![feature(link_cfg)]\n+#![feature(nll)]\n #![feature(staged_api)]\n #![feature(unwind_attributes)]\n #![feature(static_nobundle)]"}, {"sha": "d527ce12bc3a15335f491c7a7a23f42ae7b3d94a", "filename": "src/tools/rustc-std-workspace-core/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Ftools%2Frustc-std-workspace-core%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Ftools%2Frustc-std-workspace-core%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustc-std-workspace-core%2FCargo.toml?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -6,6 +6,7 @@ license = 'MIT/Apache-2.0'\n description = \"\"\"\n Hack for the compiler's own build system\n \"\"\"\n+edition = \"2018\"\n \n [lib]\n path = \"lib.rs\""}, {"sha": "99d51bc2d56acaf2ed40878d987120e22947e9eb", "filename": "src/tools/rustc-std-workspace-core/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Ftools%2Frustc-std-workspace-core%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Ftools%2Frustc-std-workspace-core%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustc-std-workspace-core%2Flib.rs?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -1,6 +1,5 @@\n #![feature(no_core)]\n #![no_core]\n-\n-extern crate core;\n+#![deny(rust_2018_idioms)]\n \n pub use core::*;"}, {"sha": "f943ac9815ac6d9e27f89a65ddb4db884c9d47a2", "filename": "src/tools/rustc-workspace-hack/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml?ref=75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "patch": "@@ -6,6 +6,7 @@ license = 'MIT/Apache-2.0'\n description = \"\"\"\n Hack for the compiler's own build system\n \"\"\"\n+edition = \"2018\"\n \n [lib]\n path = \"lib.rs\""}]}