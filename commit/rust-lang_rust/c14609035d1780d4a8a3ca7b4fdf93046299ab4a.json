{"sha": "c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNDYwOTAzNWQxNzgwZDRhOGEzY2E3YjRmZGY5MzA0NjI5OWFiNGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-09T08:53:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-09T08:53:45Z"}, "message": "Auto merge of #28857 - nrc:lowering, r=nikomatsakis\n\nr? @nikomatsakis", "tree": {"sha": "e2cd7e864e6d87be5ef3f9c044d0d2a510c6c96e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2cd7e864e6d87be5ef3f9c044d0d2a510c6c96e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "html_url": "https://github.com/rust-lang/rust/commit/c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cea9a714130b7b85caf91c2a1d126539f41c383", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cea9a714130b7b85caf91c2a1d126539f41c383", "html_url": "https://github.com/rust-lang/rust/commit/7cea9a714130b7b85caf91c2a1d126539f41c383"}, {"sha": "a62a529eea3e00b3ce9e659daa4235add2cb8551", "url": "https://api.github.com/repos/rust-lang/rust/commits/a62a529eea3e00b3ce9e659daa4235add2cb8551", "html_url": "https://github.com/rust-lang/rust/commit/a62a529eea3e00b3ce9e659daa4235add2cb8551"}], "stats": {"total": 2490, "additions": 1602, "deletions": 888}, "files": [{"sha": "6673b9b28e7163a3c71e0fdd41dec83bd224a08d", "filename": "mk/crates.mk", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -61,51 +61,55 @@ HOST_CRATES := syntax $(RUSTC_CRATES) rustdoc fmt_macros\n TOOLS := compiletest rustdoc rustc rustbook error-index-generator\n \n DEPS_core :=\n+DEPS_alloc := core libc alloc_system\n+DEPS_alloc_system := core libc\n+DEPS_collections := core alloc rustc_unicode\n DEPS_libc := core\n+DEPS_rand := core\n+DEPS_rustc_bitflags := core\n DEPS_rustc_unicode := core\n-DEPS_alloc := core libc alloc_system\n+\n DEPS_std := core libc rand alloc collections rustc_unicode \\\n \tnative:rust_builtin native:backtrace \\\n \talloc_system\n+DEPS_arena := std\n+DEPS_glob := std\n+DEPS_flate := std native:miniz\n+DEPS_fmt_macros = std\n+DEPS_getopts := std\n DEPS_graphviz := std\n+DEPS_log := std\n+DEPS_num := std\n+DEPS_rbml := std log serialize\n+DEPS_serialize := std log\n+DEPS_term := std log\n+DEPS_test := std getopts serialize rbml term native:rust_test_helpers\n+\n DEPS_syntax := std term serialize log fmt_macros arena libc rustc_bitflags\n+\n+DEPS_rustc := syntax flate arena serialize getopts rbml rustc_front\\\n+              log graphviz rustc_llvm rustc_back rustc_data_structures\n+DEPS_rustc_back := std syntax rustc_llvm rustc_front flate log libc\n+DEPS_rustc_borrowck := rustc rustc_front log graphviz syntax\n+DEPS_rustc_data_structures := std log serialize\n DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_borrowck \\\n                      rustc_typeck rustc_mir rustc_resolve log syntax serialize rustc_llvm \\\n \t\t             rustc_trans rustc_privacy rustc_lint rustc_front\n \n-DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back \\\n-\t                log syntax serialize rustc_llvm rustc_front rustc_platform_intrinsics\n-DEPS_rustc_mir := rustc rustc_front syntax\n-DEPS_rustc_typeck := rustc syntax rustc_front rustc_platform_intrinsics\n-DEPS_rustc_borrowck := rustc rustc_front log graphviz syntax\n-DEPS_rustc_resolve := rustc rustc_front log syntax\n-DEPS_rustc_privacy := rustc rustc_front log syntax\n+DEPS_rustc_front := std syntax log serialize\n DEPS_rustc_lint := rustc log syntax\n-DEPS_rustc := syntax flate arena serialize getopts rbml \\\n-              log graphviz rustc_llvm rustc_back rustc_data_structures\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags\n+DEPS_rustc_mir := rustc rustc_front syntax\n+DEPS_rustc_resolve := rustc rustc_front log syntax\n DEPS_rustc_platform_intrinsics := rustc rustc_llvm\n-DEPS_rustc_back := std syntax rustc_llvm rustc_front flate log libc\n-DEPS_rustc_front := std syntax log serialize\n-DEPS_rustc_data_structures := std log serialize\n+DEPS_rustc_privacy := rustc rustc_front log syntax\n+DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back \\\n+                    log syntax serialize rustc_llvm rustc_front rustc_platform_intrinsics\n+DEPS_rustc_typeck := rustc syntax rustc_front rustc_platform_intrinsics\n+\n DEPS_rustdoc := rustc rustc_driver native:hoedown serialize getopts \\\n                 test rustc_lint rustc_front\n-DEPS_rustc_bitflags := core\n-DEPS_flate := std native:miniz\n-DEPS_arena := std\n-DEPS_graphviz := std\n-DEPS_glob := std\n-DEPS_serialize := std log\n-DEPS_rbml := std log serialize\n-DEPS_term := std log\n-DEPS_getopts := std\n-DEPS_collections := core alloc rustc_unicode\n-DEPS_num := std\n-DEPS_test := std getopts serialize rbml term native:rust_test_helpers\n-DEPS_rand := core\n-DEPS_log := std\n-DEPS_fmt_macros = std\n-DEPS_alloc_system := core libc\n+\n \n TOOL_DEPS_compiletest := test getopts\n TOOL_DEPS_rustdoc := rustdoc"}, {"sha": "3b4cb56ec741f4b793463a8246d1f0726ae714ad", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -36,6 +36,7 @@ use middle::subst;\n use middle::ty::{self, Ty};\n \n use syntax::{ast, ast_util, codemap};\n+use syntax::ast::NodeIdAssigner;\n use syntax::codemap::Span;\n use syntax::ptr::P;\n \n@@ -53,8 +54,9 @@ use serialize::EncoderHelpers;\n \n #[cfg(test)] use std::io::Cursor;\n #[cfg(test)] use syntax::parse;\n+#[cfg(test)] use syntax::ast::NodeId;\n #[cfg(test)] use rustc_front::print::pprust;\n-#[cfg(test)] use rustc_front::lowering::lower_item;\n+#[cfg(test)] use rustc_front::lowering::{lower_item, LoweringContext};\n \n struct DecodeContext<'a, 'b, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n@@ -1376,6 +1378,22 @@ impl FakeExtCtxt for parse::ParseSess {\n     fn parse_sess(&self) -> &parse::ParseSess { self }\n }\n \n+#[cfg(test)]\n+struct FakeNodeIdAssigner;\n+\n+#[cfg(test)]\n+// It should go without saying that this may give unexpected results. Avoid\n+// lowering anything which needs new nodes.\n+impl NodeIdAssigner for FakeNodeIdAssigner {\n+    fn next_node_id(&self) -> NodeId {\n+        0\n+    }\n+\n+    fn peek_node_id(&self) -> NodeId {\n+        0\n+    }\n+}\n+\n #[cfg(test)]\n fn mk_ctxt() -> parse::ParseSess {\n     parse::ParseSess::new()\n@@ -1394,23 +1412,29 @@ fn roundtrip(in_item: P<hir::Item>) {\n #[test]\n fn test_basic() {\n     let cx = mk_ctxt();\n-    roundtrip(lower_item(&quote_item!(&cx,\n+    let fnia = FakeNodeIdAssigner;\n+    let lcx = LoweringContext::new(&fnia, None);\n+    roundtrip(lower_item(&lcx, &quote_item!(&cx,\n         fn foo() {}\n     ).unwrap()));\n }\n \n #[test]\n fn test_smalltalk() {\n     let cx = mk_ctxt();\n-    roundtrip(lower_item(&quote_item!(&cx,\n+    let fnia = FakeNodeIdAssigner;\n+    let lcx = LoweringContext::new(&fnia, None);\n+    roundtrip(lower_item(&lcx, &quote_item!(&cx,\n         fn foo() -> isize { 3 + 4 } // first smalltalk program ever executed.\n     ).unwrap()));\n }\n \n #[test]\n fn test_more() {\n     let cx = mk_ctxt();\n-    roundtrip(lower_item(&quote_item!(&cx,\n+    let fnia = FakeNodeIdAssigner;\n+    let lcx = LoweringContext::new(&fnia, None);\n+    roundtrip(lower_item(&lcx, &quote_item!(&cx,\n         fn foo(x: usize, y: usize) -> usize {\n             let z = x + y;\n             return z;\n@@ -1427,10 +1451,12 @@ fn test_simplification() {\n             return alist {eq_fn: eq_int, data: Vec::new()};\n         }\n     ).unwrap();\n-    let hir_item = lower_item(&item);\n+    let fnia = FakeNodeIdAssigner;\n+    let lcx = LoweringContext::new(&fnia, None);\n+    let hir_item = lower_item(&lcx, &item);\n     let item_in = InlinedItemRef::Item(&hir_item);\n     let item_out = simplify_ast(item_in);\n-    let item_exp = InlinedItem::Item(lower_item(&quote_item!(&cx,\n+    let item_exp = InlinedItem::Item(lower_item(&lcx, &quote_item!(&cx,\n         fn new_int_alist<B>() -> alist<isize, B> {\n             return alist {eq_fn: eq_int, data: Vec::new()};\n         }"}, {"sha": "f849580871c845c563e836334c1e9c67b1a0c58f", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -102,7 +102,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n     fn visit_block(&mut self, block: &hir::Block) {\n         let old_unsafe_context = self.unsafe_context;\n         match block.rules {\n-            hir::DefaultBlock => {}\n             hir::UnsafeBlock(source) => {\n                 // By default only the outermost `unsafe` block is\n                 // \"used\" and so nested unsafe blocks are pointless\n@@ -131,6 +130,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 self.unsafe_context.push_unsafe_count =\n                     self.unsafe_context.push_unsafe_count.checked_sub(1).unwrap();\n             }\n+            hir::DefaultBlock | hir::PushUnstableBlock | hir:: PopUnstableBlock => {}\n         }\n \n         visit::walk_block(self, block);"}, {"sha": "bdf01f941c4b2cd6843766924bb2926035cb16d5", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -377,7 +377,7 @@ impl RegionMaps {\n         self.code_extents.borrow()[e.0 as usize]\n     }\n     pub fn each_encl_scope<E>(&self, mut e:E) where E: FnMut(&CodeExtent, &CodeExtent) {\n-        for child_id in (1..self.code_extents.borrow().len()) {\n+        for child_id in 1..self.code_extents.borrow().len() {\n             let child = CodeExtent(child_id as u32);\n             if let Some(parent) = self.opt_encl_scope(child) {\n                 e(&child, &parent)"}, {"sha": "c2235591ceef10d5408131aa82aa8e096fcb2458", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -270,7 +270,8 @@ pub fn check_unstable_api_usage(tcx: &ty::ctxt)\n     let mut checker = Checker {\n         tcx: tcx,\n         active_features: active_features,\n-        used_features: FnvHashMap()\n+        used_features: FnvHashMap(),\n+        in_skip_block: 0,\n     };\n \n     let krate = tcx.map.krate();\n@@ -283,14 +284,23 @@ pub fn check_unstable_api_usage(tcx: &ty::ctxt)\n struct Checker<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n     active_features: FnvHashSet<InternedString>,\n-    used_features: FnvHashMap<InternedString, attr::StabilityLevel>\n+    used_features: FnvHashMap<InternedString, attr::StabilityLevel>,\n+    // Within a block where feature gate checking can be skipped.\n+    in_skip_block: u32,\n }\n \n impl<'a, 'tcx> Checker<'a, 'tcx> {\n     fn check(&mut self, id: DefId, span: Span, stab: &Option<&Stability>) {\n         // Only the cross-crate scenario matters when checking unstable APIs\n         let cross_crate = !id.is_local();\n-        if !cross_crate { return }\n+        if !cross_crate {\n+            return\n+        }\n+\n+        // We don't need to check for stability - presumably compiler generated code.\n+        if self.in_skip_block > 0 {\n+            return;\n+        }\n \n         match *stab {\n             Some(&Stability { level: attr::Unstable, ref feature, ref reason, issue, .. }) => {\n@@ -369,6 +379,21 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n                   &mut |id, sp, stab| self.check(id, sp, stab));\n         visit::walk_pat(self, pat)\n     }\n+\n+    fn visit_block(&mut self, b: &hir::Block) {\n+        let old_skip_count = self.in_skip_block;\n+        match b.rules {\n+            hir::BlockCheckMode::PushUnstableBlock => {\n+                self.in_skip_block += 1;\n+            }\n+            hir::BlockCheckMode::PopUnstableBlock => {\n+                self.in_skip_block = self.in_skip_block.checked_sub(1).unwrap();\n+            }\n+            _ => {}\n+        }\n+        visit::walk_block(self, b);\n+        self.in_skip_block = old_skip_count;\n+    }\n }\n \n /// Helper for discovering nodes to check for stability"}, {"sha": "830232cf373b8fe02115ac4f07e4efcf27eb7c24", "filename": "src/librustc/middle/ty/context.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -219,7 +219,7 @@ pub struct ctxt<'tcx> {\n     /// Common types, pre-interned for your convenience.\n     pub types: CommonTypes<'tcx>,\n \n-    pub sess: Session,\n+    pub sess: &'tcx Session,\n     pub def_map: DefMap,\n \n     pub named_region_map: resolve_lifetime::NamedRegionMap,\n@@ -443,7 +443,7 @@ impl<'tcx> ctxt<'tcx> {\n     /// to the context. The closure enforces that the type context and any interned\n     /// value (types, substs, etc.) can only be used while `ty::tls` has a valid\n     /// reference to the context, to allow formatting values that need it.\n-    pub fn create_and_enter<F, R>(s: Session,\n+    pub fn create_and_enter<F, R>(s: &'tcx Session,\n                                  arenas: &'tcx CtxtArenas<'tcx>,\n                                  def_map: DefMap,\n                                  named_region_map: resolve_lifetime::NamedRegionMap,\n@@ -452,7 +452,7 @@ impl<'tcx> ctxt<'tcx> {\n                                  region_maps: RegionMaps,\n                                  lang_items: middle::lang_items::LanguageItems,\n                                  stability: stability::Index<'tcx>,\n-                                 f: F) -> (Session, R)\n+                                 f: F) -> R\n                                  where F: FnOnce(&ctxt<'tcx>) -> R\n     {\n         let interner = RefCell::new(FnvHashMap());\n@@ -556,7 +556,6 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n \n pub mod tls {\n     use middle::ty;\n-    use session::Session;\n \n     use std::fmt;\n     use syntax::codemap;\n@@ -574,17 +573,15 @@ pub mod tls {\n         })\n     }\n \n-    pub fn enter<'tcx, F: FnOnce(&ty::ctxt<'tcx>) -> R, R>(tcx: ty::ctxt<'tcx>, f: F)\n-                                                           -> (Session, R) {\n-        let result = codemap::SPAN_DEBUG.with(|span_dbg| {\n+    pub fn enter<'tcx, F: FnOnce(&ty::ctxt<'tcx>) -> R, R>(tcx: ty::ctxt<'tcx>, f: F) -> R {\n+        codemap::SPAN_DEBUG.with(|span_dbg| {\n             let original_span_debug = span_dbg.get();\n             span_dbg.set(span_debug);\n             let tls_ptr = &tcx as *const _ as *const ThreadLocalTyCx;\n             let result = TLS_TCX.set(unsafe { &*tls_ptr }, || f(&tcx));\n             span_dbg.set(original_span_debug);\n             result\n-        });\n-        (tcx.sess, result)\n+        })\n     }\n \n     pub fn with<F: FnOnce(&ty::ctxt) -> R, R>(f: F) -> R {"}, {"sha": "0a1df25f115a6ef92741ec4d77e91859ea342079", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -15,7 +15,7 @@ use middle::dependency_format;\n use session::search_paths::PathKind;\n use util::nodemap::{NodeMap, FnvHashMap};\n \n-use syntax::ast::NodeId;\n+use syntax::ast::{NodeId, NodeIdAssigner};\n use syntax::codemap::Span;\n use syntax::diagnostic::{self, Emitter};\n use syntax::diagnostics;\n@@ -236,9 +236,6 @@ impl Session {\n         }\n         lints.insert(id, vec!((lint_id, sp, msg)));\n     }\n-    pub fn next_node_id(&self) -> ast::NodeId {\n-        self.reserve_node_ids(1)\n-    }\n     pub fn reserve_node_ids(&self, count: ast::NodeId) -> ast::NodeId {\n         let id = self.next_node_id.get();\n \n@@ -317,6 +314,16 @@ impl Session {\n     }\n }\n \n+impl NodeIdAssigner for Session {\n+    fn next_node_id(&self) -> NodeId {\n+        self.reserve_node_ids(1)\n+    }\n+\n+    fn peek_node_id(&self) -> NodeId {\n+        self.next_node_id.get().checked_add(1).unwrap()\n+    }\n+}\n+\n fn split_msg_into_multilines(msg: &str) -> Option<String> {\n     // Conditions for enabling multi-line errors:\n     if !msg.contains(\"mismatched types\") &&"}, {"sha": "619fcd3406cbca662e53bfd3ac41116251b2a7a8", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -31,7 +31,7 @@ use rustc_trans::trans;\n use rustc_typeck as typeck;\n use rustc_privacy;\n use rustc_front::hir;\n-use rustc_front::lowering::lower_crate;\n+use rustc_front::lowering::{lower_crate, LoweringContext};\n use super::Compilation;\n \n use serialize::json;\n@@ -42,7 +42,7 @@ use std::ffi::{OsString, OsStr};\n use std::fs;\n use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n-use syntax::ast;\n+use syntax::ast::{self, NodeIdAssigner};\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::diagnostics;\n@@ -71,7 +71,7 @@ pub fn compile_input(sess: Session,\n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n-    let (sess, result) = {\n+    let result = {\n         let (outputs, expanded_crate, id) = {\n             let krate = phase_1_parse_input(&sess, cfg, input);\n \n@@ -112,9 +112,10 @@ pub fn compile_input(sess: Session,\n \n         let expanded_crate = assign_node_ids(&sess, expanded_crate);\n         // Lower ast -> hir.\n+        let lcx = LoweringContext::new(&sess, Some(&expanded_crate));\n         let mut hir_forest = time(sess.time_passes(),\n                                   \"lowering ast -> hir\",\n-                                  || hir_map::Forest::new(lower_crate(&expanded_crate)));\n+                                  || hir_map::Forest::new(lower_crate(&lcx, &expanded_crate)));\n         let arenas = ty::CtxtArenas::new();\n         let ast_map = make_map(&sess, &mut hir_forest);\n \n@@ -128,7 +129,8 @@ pub fn compile_input(sess: Session,\n                                                                      &ast_map,\n                                                                      &expanded_crate,\n                                                                      &ast_map.krate(),\n-                                                                     &id[..]));\n+                                                                     &id[..],\n+                                                                     &lcx));\n \n         time(sess.time_passes(), \"attribute checking\", || {\n             front::check_attr::check_crate(&sess, &expanded_crate);\n@@ -138,7 +140,7 @@ pub fn compile_input(sess: Session,\n             lint::check_ast_crate(&sess, &expanded_crate)\n         });\n \n-        phase_3_run_analysis_passes(sess,\n+        phase_3_run_analysis_passes(&sess,\n                                     ast_map,\n                                     &arenas,\n                                     id,\n@@ -152,7 +154,8 @@ pub fn compile_input(sess: Session,\n                                                                &expanded_crate,\n                                                                tcx.map.krate(),\n                                                                &analysis,\n-                                                               tcx);\n+                                                               tcx,\n+                                                               &lcx);\n                 (control.after_analysis.callback)(state);\n \n                 tcx.sess.abort_if_errors();\n@@ -278,6 +281,7 @@ pub struct CompileState<'a, 'ast: 'a, 'tcx: 'a> {\n     pub ast_map: Option<&'a hir_map::Map<'ast>>,\n     pub analysis: Option<&'a ty::CrateAnalysis>,\n     pub tcx: Option<&'a ty::ctxt<'tcx>>,\n+    pub lcx: Option<&'a LoweringContext<'a>>,\n     pub trans: Option<&'a trans::CrateTranslation>,\n }\n \n@@ -299,6 +303,7 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n             ast_map: None,\n             analysis: None,\n             tcx: None,\n+            lcx: None,\n             trans: None,\n         }\n     }\n@@ -333,13 +338,15 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n                               ast_map: &'a hir_map::Map<'ast>,\n                               krate: &'a ast::Crate,\n                               hir_crate: &'a hir::Crate,\n-                              crate_name: &'a str)\n+                              crate_name: &'a str,\n+                              lcx: &'a LoweringContext<'a>)\n                               -> CompileState<'a, 'ast, 'tcx> {\n         CompileState {\n             crate_name: Some(crate_name),\n             ast_map: Some(ast_map),\n             krate: Some(krate),\n             hir_crate: Some(hir_crate),\n+            lcx: Some(lcx),\n             .. CompileState::empty(input, session, out_dir)\n         }\n     }\n@@ -350,13 +357,15 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n                             krate: &'a ast::Crate,\n                             hir_crate: &'a hir::Crate,\n                             analysis: &'a ty::CrateAnalysis,\n-                            tcx: &'a ty::ctxt<'tcx>)\n+                            tcx: &'a ty::ctxt<'tcx>,\n+                            lcx: &'a LoweringContext<'a>)\n                             -> CompileState<'a, 'ast, 'tcx> {\n         CompileState {\n             analysis: Some(analysis),\n             tcx: Some(tcx),\n             krate: Some(krate),\n             hir_crate: Some(hir_crate),\n+            lcx: Some(lcx),\n             .. CompileState::empty(input, session, out_dir)\n         }\n     }\n@@ -649,21 +658,21 @@ pub fn make_map<'ast>(sess: &Session,\n /// Run the resolution, typechecking, region checking and other\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis.\n-pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n+pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                ast_map: front::map::Map<'tcx>,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                name: String,\n                                                make_glob_map: resolve::MakeGlobMap,\n                                                f: F)\n-                                               -> (Session, R)\n+                                               -> R\n                                                where F: for<'a> FnOnce(&'a ty::ctxt<'tcx>,\n                                                                        ty::CrateAnalysis) -> R\n {\n     let time_passes = sess.time_passes();\n     let krate = ast_map.krate();\n \n     time(time_passes, \"external crate/lib resolution\", ||\n-         LocalCrateReader::new(&sess, &ast_map).read_crates(krate));\n+         LocalCrateReader::new(sess, &ast_map).read_crates(krate));\n \n     let lang_items = time(time_passes, \"language item collection\", ||\n                           middle::lang_items::collect_language_items(&sess, &ast_map));\n@@ -677,32 +686,32 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n         glob_map,\n     } =\n         time(time_passes, \"resolution\",\n-             || resolve::resolve_crate(&sess, &ast_map, make_glob_map));\n+             || resolve::resolve_crate(sess, &ast_map, make_glob_map));\n \n     // Discard MTWT tables that aren't required past resolution.\n     if !sess.opts.debugging_opts.keep_mtwt_tables {\n         syntax::ext::mtwt::clear_tables();\n     }\n \n     let named_region_map = time(time_passes, \"lifetime resolution\",\n-                                || middle::resolve_lifetime::krate(&sess, krate, &def_map));\n+                                || middle::resolve_lifetime::krate(sess, krate, &def_map));\n \n     time(time_passes, \"looking for entry point\",\n-         || middle::entry::find_entry_point(&sess, &ast_map));\n+         || middle::entry::find_entry_point(sess, &ast_map));\n \n     sess.plugin_registrar_fn.set(\n         time(time_passes, \"looking for plugin registrar\", ||\n             plugin::build::find_plugin_registrar(\n                 sess.diagnostic(), krate)));\n \n     let region_map = time(time_passes, \"region resolution\", ||\n-                          middle::region::resolve_crate(&sess, krate));\n+                          middle::region::resolve_crate(sess, krate));\n \n     time(time_passes, \"loop checking\", ||\n-         middle::check_loop::check_crate(&sess, krate));\n+         middle::check_loop::check_crate(sess, krate));\n \n     time(time_passes, \"static item recursion checking\", ||\n-         middle::check_static_recursion::check_crate(&sess, krate, &def_map, &ast_map));\n+         middle::check_static_recursion::check_crate(sess, krate, &def_map, &ast_map));\n \n     ty::ctxt::create_and_enter(sess,\n                                arenas,"}, {"sha": "276b747feb2042b23359d73191b7c0d254f12d18", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -396,6 +396,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                 time(state.session.time_passes(),\n                      \"save analysis\",\n                      || save::process_crate(state.tcx.unwrap(),\n+                                            state.lcx.unwrap(),\n                                             state.krate.unwrap(),\n                                             state.analysis.unwrap(),\n                                             state.out_dir));"}, {"sha": "57186cb6ce837f0eab2411fc879b2234166d4a6b", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -47,7 +47,7 @@ use std::str::FromStr;\n use rustc::front::map as hir_map;\n use rustc::front::map::{blocks, NodePrinter};\n use rustc_front::hir;\n-use rustc_front::lowering::lower_crate;\n+use rustc_front::lowering::{lower_crate, LoweringContext};\n use rustc_front::print::pprust as pprust_hir;\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n@@ -131,7 +131,7 @@ pub fn parse_pretty(sess: &Session,\n impl PpSourceMode {\n     /// Constructs a `PrinterSupport` object and passes it to `f`.\n     fn call_with_pp_support<'tcx, A, B, F>(&self,\n-                                           sess: Session,\n+                                           sess: &'tcx Session,\n                                            ast_map: Option<hir_map::Map<'tcx>>,\n                                            payload: B,\n                                            f: F) -> A where\n@@ -155,7 +155,7 @@ impl PpSourceMode {\n         }\n     }\n     fn call_with_pp_support_hir<'tcx, A, B, F>(&self,\n-                                               sess: Session,\n+                                               sess: &'tcx Session,\n                                                ast_map: &hir_map::Map<'tcx>,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                id: String,\n@@ -185,7 +185,7 @@ impl PpSourceMode {\n                                                     |tcx, _| {\n                     let annotation = TypedAnnotation { tcx: tcx };\n                     f(&annotation, payload, &ast_map.forest.krate)\n-                }).1\n+                })\n             }\n             _ => panic!(\"Should use call_with_pp_support\"),\n         }\n@@ -225,12 +225,12 @@ trait HirPrinterSupport<'ast>: pprust_hir::PpAnn {\n }\n \n struct NoAnn<'ast> {\n-    sess: Session,\n+    sess: &'ast Session,\n     ast_map: Option<hir_map::Map<'ast>>\n }\n \n impl<'ast> PrinterSupport<'ast> for NoAnn<'ast> {\n-    fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n+    fn sess<'a>(&'a self) -> &'a Session { self.sess }\n \n     fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n         self.ast_map.as_ref()\n@@ -240,7 +240,7 @@ impl<'ast> PrinterSupport<'ast> for NoAnn<'ast> {\n }\n \n impl<'ast> HirPrinterSupport<'ast> for NoAnn<'ast> {\n-    fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n+    fn sess<'a>(&'a self) -> &'a Session { self.sess }\n \n     fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n         self.ast_map.as_ref()\n@@ -253,12 +253,12 @@ impl<'ast> pprust::PpAnn for NoAnn<'ast> {}\n impl<'ast> pprust_hir::PpAnn for NoAnn<'ast> {}\n \n struct IdentifiedAnnotation<'ast> {\n-    sess: Session,\n+    sess: &'ast Session,\n     ast_map: Option<hir_map::Map<'ast>>,\n }\n \n impl<'ast> PrinterSupport<'ast> for IdentifiedAnnotation<'ast> {\n-    fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n+    fn sess<'a>(&'a self) -> &'a Session { self.sess }\n \n     fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n         self.ast_map.as_ref()\n@@ -308,7 +308,7 @@ impl<'ast> pprust::PpAnn for IdentifiedAnnotation<'ast> {\n }\n \n impl<'ast> HirPrinterSupport<'ast> for IdentifiedAnnotation<'ast> {\n-    fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n+    fn sess<'a>(&'a self) -> &'a Session { self.sess }\n \n     fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n         self.ast_map.as_ref()\n@@ -357,12 +357,12 @@ impl<'ast> pprust_hir::PpAnn for IdentifiedAnnotation<'ast> {\n }\n \n struct HygieneAnnotation<'ast> {\n-    sess: Session,\n+    sess: &'ast Session,\n     ast_map: Option<hir_map::Map<'ast>>,\n }\n \n impl<'ast> PrinterSupport<'ast> for HygieneAnnotation<'ast> {\n-    fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n+    fn sess<'a>(&'a self) -> &'a Session { self.sess }\n \n     fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n         self.ast_map.as_ref()\n@@ -670,9 +670,10 @@ pub fn pretty_print_input(sess: Session,\n     // There is some twisted, god-forsaken tangle of lifetimes here which makes\n     // the ordering of stuff super-finicky.\n     let mut hir_forest;\n+    let lcx = LoweringContext::new(&sess, Some(&krate));\n     let arenas = ty::CtxtArenas::new();\n     let ast_map = if compute_ast_map {\n-        hir_forest = hir_map::Forest::new(lower_crate(&krate));\n+        hir_forest = hir_map::Forest::new(lower_crate(&lcx, &krate));\n         let map = driver::make_map(&sess, &mut hir_forest);\n         Some(map)\n     } else {\n@@ -695,7 +696,7 @@ pub fn pretty_print_input(sess: Session,\n             // Silently ignores an identified node.\n             let out: &mut Write = &mut out;\n             s.call_with_pp_support(\n-                sess, ast_map, box out, |annotation, out| {\n+                &sess, ast_map, box out, |annotation, out| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     pprust::print_crate(sess.codemap(),\n@@ -712,7 +713,7 @@ pub fn pretty_print_input(sess: Session,\n         (PpmHir(s), None) => {\n             let out: &mut Write = &mut out;\n             s.call_with_pp_support_hir(\n-                sess, &ast_map.unwrap(), &arenas, id, box out, |annotation, out, krate| {\n+                &sess, &ast_map.unwrap(), &arenas, id, box out, |annotation, out, krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     pprust_hir::print_crate(sess.codemap(),\n@@ -728,7 +729,7 @@ pub fn pretty_print_input(sess: Session,\n \n         (PpmHir(s), Some(uii)) => {\n             let out: &mut Write = &mut out;\n-            s.call_with_pp_support_hir(sess,\n+            s.call_with_pp_support_hir(&sess,\n                                        &ast_map.unwrap(),\n                                        &arenas,\n                                        id,\n@@ -776,14 +777,14 @@ pub fn pretty_print_input(sess: Session,\n             match code {\n                 Some(code) => {\n                     let variants = gather_flowgraph_variants(&sess);\n-                    driver::phase_3_run_analysis_passes(sess,\n+                    driver::phase_3_run_analysis_passes(&sess,\n                                                         ast_map,\n                                                         &arenas,\n                                                         id,\n                                                         resolve::MakeGlobMap::No,\n                                                         |tcx, _| {\n                         print_flowgraph(variants, tcx, code, mode, out)\n-                    }).1\n+                    })\n                 }\n                 None => {\n                     let message = format!(\"--pretty=flowgraph needs \\"}, {"sha": "0c83851ba002ab6f2813fe29aa18588190ee846f", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -38,7 +38,7 @@ use syntax::diagnostic::{Level, RenderSpan, Bug, Fatal, Error, Warning, Note, He\n use syntax::parse::token;\n use syntax::feature_gate::UnstableFeatures;\n \n-use rustc_front::lowering::lower_crate;\n+use rustc_front::lowering::{lower_crate, LoweringContext};\n use rustc_front::hir;\n \n struct Env<'a, 'tcx: 'a> {\n@@ -124,7 +124,8 @@ fn test_env<F>(source_string: &str,\n                     .expect(\"phase 2 aborted\");\n \n     let krate = driver::assign_node_ids(&sess, krate);\n-    let mut hir_forest = hir_map::Forest::new(lower_crate(&krate));\n+    let lcx = LoweringContext::new(&sess, Some(&krate));\n+    let mut hir_forest = hir_map::Forest::new(lower_crate(&lcx, &krate));\n     let arenas = ty::CtxtArenas::new();\n     let ast_map = driver::make_map(&sess, &mut hir_forest);\n     let krate = ast_map.krate();\n@@ -135,7 +136,7 @@ fn test_env<F>(source_string: &str,\n         resolve::resolve_crate(&sess, &ast_map, resolve::MakeGlobMap::No);\n     let named_region_map = resolve_lifetime::krate(&sess, krate, &def_map);\n     let region_map = region::resolve_crate(&sess, krate);\n-    ty::ctxt::create_and_enter(sess,\n+    ty::ctxt::create_and_enter(&sess,\n                                &arenas,\n                                def_map,\n                                named_region_map,"}, {"sha": "9066b93262cd64639fb0e8b4dfa1177b1395d596", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -574,6 +574,9 @@ pub enum BlockCheckMode {\n     UnsafeBlock(UnsafeSource),\n     PushUnsafeBlock(UnsafeSource),\n     PopUnsafeBlock(UnsafeSource),\n+    // Within this block (but outside a PopUnstableBlock), we suspend checking of stability.\n+    PushUnstableBlock,\n+    PopUnstableBlock,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -583,7 +586,7 @@ pub enum UnsafeSource {\n }\n \n /// An expression\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash,)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub struct Expr {\n     pub id: NodeId,\n     pub node: Expr_,"}, {"sha": "4ee5fa2c1e9b5389c894dcfd4249f1e8f61e28a7", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 1180, "deletions": 284, "changes": 1464, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -8,27 +8,147 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Lowers the AST to the HIR\n+// Lowers the AST to the HIR.\n+//\n+// Since the AST and HIR are fairly similar, this is mostly a simple procedure,\n+// much like a fold. Where lowering involves a bit more work things get more\n+// interesting and there are some invariants you should know about. These mostly\n+// concern spans and ids.\n+//\n+// Spans are assigned to AST nodes during parsing and then are modified during\n+// expansion to indicate the origin of a node and the process it went through\n+// being expanded. Ids are assigned to AST nodes just before lowering.\n+//\n+// For the simpler lowering steps, ids and spans should be preserved. Unlike\n+// expansion we do not preserve the process of lowering in the spans, so spans\n+// should not be modified here. When creating a new node (as opposed to\n+// 'folding' an existing one), then you create a new id using `next_id()`.\n+//\n+// You must ensure that ids are unique. That means that you should only use the\n+// id from an AST node in a single HIR node (you can assume that AST node ids\n+// are unique). Every new node must have a unique id. Avoid cloning HIR nodes.\n+// If you do, you must then set the new node's id to a fresh one.\n+//\n+// Lowering must be reproducable (the compiler only lowers once, but tools and\n+// custom lints may lower an AST node to a HIR node to interact with the\n+// compiler). The most interesting bit of this is ids - if you lower an AST node\n+// and create new HIR nodes with fresh ids, when re-lowering the same node, you\n+// must ensure you get the same ids! To do this, we keep track of the next id\n+// when we translate a node which requires new ids. By checking this cache and\n+// using node ids starting with the cached id, we ensure ids are reproducible.\n+// To use this system, you just need to hold on to a CachedIdSetter object\n+// whilst lowering. This is an RAII object that takes care of setting and\n+// restoring the cached id, etc.\n+//\n+// This whole system relies on node ids being incremented one at a time and\n+// all increments being for lowering. This means that you should not call any\n+// non-lowering function which will use new node ids.\n+//\n+// We must also cache gensym'ed Idents to ensure that we get the same Ident\n+// every time we lower a node with gensym'ed names. One consequence of this is\n+// that you can only gensym a name once in a lowering (you don't need to worry\n+// about nested lowering though). That's because we cache based on the name and\n+// the currently cached node id, which is unique per lowered node.\n+//\n+// Spans are used for error messages and for tools to map semantics back to\n+// source code. It is therefore not as important with spans as ids to be strict\n+// about use (you can't break the compiler by screwing up a span). Obviously, a\n+// HIR node can only have a single span. But multiple nodes can have the same\n+// span and spans don't need to be kept in order, etc. Where code is preserved\n+// by lowering, it should have the same span as in the AST. Where HIR nodes are\n+// new it is probably best to give a span for the whole AST node being lowered.\n+// All nodes should have real spans, don't use dummy spans. Tools are likely to\n+// get confused if the spans from leaf AST nodes occur in multiple places\n+// in the HIR, especially for multiple identifiers.\n \n use hir;\n \n+use std::collections::HashMap;\n+\n use syntax::ast::*;\n use syntax::ptr::P;\n-use syntax::codemap::{respan, Spanned};\n+use syntax::codemap::{respan, Spanned, Span};\n use syntax::owned_slice::OwnedSlice;\n+use syntax::parse::token::{self, str_to_ident};\n+use syntax::std_inject;\n+\n+use std::cell::{Cell, RefCell};\n+\n+pub struct LoweringContext<'a> {\n+    crate_root: Option<&'static str>,\n+    // Map AST ids to ids used for expanded nodes.\n+    id_cache: RefCell<HashMap<NodeId, NodeId>>,\n+    // Use if there are no cached ids for the current node.\n+    id_assigner: &'a NodeIdAssigner,\n+    // 0 == no cached id. Must be incremented to align with previous id\n+    // incrementing.\n+    cached_id: Cell<u32>,\n+    // Keep track of gensym'ed idents.\n+    gensym_cache: RefCell<HashMap<(NodeId, &'static str), Ident>>,\n+    // A copy of cached_id, but is also set to an id while it is being cached.\n+    gensym_key: Cell<u32>,\n+}\n+\n+impl<'a, 'hir> LoweringContext<'a> {\n+    pub fn new(id_assigner: &'a NodeIdAssigner, c: Option<&Crate>) -> LoweringContext<'a> {\n+        let crate_root = c.and_then(|c| {\n+            if std_inject::no_core(c) {\n+                None\n+            } else if std_inject::no_std(c) {\n+                Some(\"core\")\n+            } else {\n+                Some(\"std\")\n+            }\n+        });\n+\n+        LoweringContext {\n+            crate_root: crate_root,\n+            id_cache: RefCell::new(HashMap::new()),\n+            id_assigner: id_assigner,\n+            cached_id: Cell::new(0),\n+            gensym_cache: RefCell::new(HashMap::new()),\n+            gensym_key: Cell::new(0),\n+        }\n+    }\n+\n+    fn next_id(&self) -> NodeId {\n+        let cached = self.cached_id.get();\n+        if cached == 0 {\n+            return self.id_assigner.next_node_id()\n+        }\n \n+        self.cached_id.set(cached + 1);\n+        cached\n+    }\n+\n+    fn str_to_ident(&self, s: &'static str) -> Ident {\n+        let cached_id = self.gensym_key.get();\n+        if cached_id == 0 {\n+            return token::gensym_ident(s);\n+        }\n \n-pub fn lower_view_path(view_path: &ViewPath) -> P<hir::ViewPath> {\n+        let cached = self.gensym_cache.borrow().contains_key(&(cached_id, s));\n+        if cached {\n+            self.gensym_cache.borrow()[&(cached_id, s)]\n+        } else {\n+            let result = token::gensym_ident(s);\n+            self.gensym_cache.borrow_mut().insert((cached_id, s), result);\n+            result\n+        }\n+    }\n+}\n+\n+pub fn lower_view_path(_lctx: &LoweringContext, view_path: &ViewPath) -> P<hir::ViewPath> {\n     P(Spanned {\n         node: match view_path.node {\n             ViewPathSimple(ident, ref path) => {\n-                hir::ViewPathSimple(ident.name, lower_path(path))\n+                hir::ViewPathSimple(ident.name, lower_path(_lctx, path))\n             }\n             ViewPathGlob(ref path) => {\n-                hir::ViewPathGlob(lower_path(path))\n+                hir::ViewPathGlob(lower_path(_lctx, path))\n             }\n             ViewPathList(ref path, ref path_list_idents) => {\n-                hir::ViewPathList(lower_path(path),\n+                hir::ViewPathList(lower_path(_lctx, path),\n                                   path_list_idents.iter()\n                                                   .map(|path_list_ident| {\n                                                       Spanned {\n@@ -55,92 +175,93 @@ pub fn lower_view_path(view_path: &ViewPath) -> P<hir::ViewPath> {\n     })\n }\n \n-pub fn lower_arm(arm: &Arm) -> hir::Arm {\n+pub fn lower_arm(_lctx: &LoweringContext, arm: &Arm) -> hir::Arm {\n     hir::Arm {\n         attrs: arm.attrs.clone(),\n-        pats: arm.pats.iter().map(|x| lower_pat(x)).collect(),\n-        guard: arm.guard.as_ref().map(|ref x| lower_expr(x)),\n-        body: lower_expr(&arm.body),\n+        pats: arm.pats.iter().map(|x| lower_pat(_lctx, x)).collect(),\n+        guard: arm.guard.as_ref().map(|ref x| lower_expr(_lctx, x)),\n+        body: lower_expr(_lctx, &arm.body),\n     }\n }\n \n-pub fn lower_decl(d: &Decl) -> P<hir::Decl> {\n+pub fn lower_decl(_lctx: &LoweringContext, d: &Decl) -> P<hir::Decl> {\n     match d.node {\n         DeclLocal(ref l) => P(Spanned {\n-            node: hir::DeclLocal(lower_local(l)),\n+            node: hir::DeclLocal(lower_local(_lctx, l)),\n             span: d.span,\n         }),\n         DeclItem(ref it) => P(Spanned {\n-            node: hir::DeclItem(lower_item(it)),\n+            node: hir::DeclItem(lower_item(_lctx, it)),\n             span: d.span,\n         }),\n     }\n }\n \n-pub fn lower_ty_binding(b: &TypeBinding) -> P<hir::TypeBinding> {\n+pub fn lower_ty_binding(_lctx: &LoweringContext, b: &TypeBinding) -> P<hir::TypeBinding> {\n     P(hir::TypeBinding {\n         id: b.id,\n         name: b.ident.name,\n-        ty: lower_ty(&b.ty),\n+        ty: lower_ty(_lctx, &b.ty),\n         span: b.span,\n     })\n }\n \n-pub fn lower_ty(t: &Ty) -> P<hir::Ty> {\n+pub fn lower_ty(_lctx: &LoweringContext, t: &Ty) -> P<hir::Ty> {\n     P(hir::Ty {\n         id: t.id,\n         node: match t.node {\n             TyInfer => hir::TyInfer,\n-            TyVec(ref ty) => hir::TyVec(lower_ty(ty)),\n-            TyPtr(ref mt) => hir::TyPtr(lower_mt(mt)),\n+            TyVec(ref ty) => hir::TyVec(lower_ty(_lctx, ty)),\n+            TyPtr(ref mt) => hir::TyPtr(lower_mt(_lctx, mt)),\n             TyRptr(ref region, ref mt) => {\n-                hir::TyRptr(lower_opt_lifetime(region), lower_mt(mt))\n+                hir::TyRptr(lower_opt_lifetime(_lctx, region),\n+                            lower_mt(_lctx, mt))\n             }\n             TyBareFn(ref f) => {\n                 hir::TyBareFn(P(hir::BareFnTy {\n-                    lifetimes: lower_lifetime_defs(&f.lifetimes),\n-                    unsafety: lower_unsafety(f.unsafety),\n+                    lifetimes: lower_lifetime_defs(_lctx, &f.lifetimes),\n+                    unsafety: lower_unsafety(_lctx, f.unsafety),\n                     abi: f.abi,\n-                    decl: lower_fn_decl(&f.decl),\n+                    decl: lower_fn_decl(_lctx, &f.decl),\n                 }))\n             }\n-            TyTup(ref tys) => hir::TyTup(tys.iter().map(|ty| lower_ty(ty)).collect()),\n-            TyParen(ref ty) => hir::TyParen(lower_ty(ty)),\n+            TyTup(ref tys) => hir::TyTup(tys.iter().map(|ty| lower_ty(_lctx, ty)).collect()),\n+            TyParen(ref ty) => hir::TyParen(lower_ty(_lctx, ty)),\n             TyPath(ref qself, ref path) => {\n                 let qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n                     hir::QSelf {\n-                        ty: lower_ty(ty),\n+                        ty: lower_ty(_lctx, ty),\n                         position: position,\n                     }\n                 });\n-                hir::TyPath(qself, lower_path(path))\n+                hir::TyPath(qself, lower_path(_lctx, path))\n             }\n             TyObjectSum(ref ty, ref bounds) => {\n-                hir::TyObjectSum(lower_ty(ty), lower_bounds(bounds))\n+                hir::TyObjectSum(lower_ty(_lctx, ty), lower_bounds(_lctx, bounds))\n             }\n             TyFixedLengthVec(ref ty, ref e) => {\n-                hir::TyFixedLengthVec(lower_ty(ty), lower_expr(e))\n+                hir::TyFixedLengthVec(lower_ty(_lctx, ty), lower_expr(_lctx, e))\n             }\n             TyTypeof(ref expr) => {\n-                hir::TyTypeof(lower_expr(expr))\n+                hir::TyTypeof(lower_expr(_lctx, expr))\n             }\n             TyPolyTraitRef(ref bounds) => {\n-                hir::TyPolyTraitRef(bounds.iter().map(|b| lower_ty_param_bound(b)).collect())\n+                hir::TyPolyTraitRef(bounds.iter().map(|b| lower_ty_param_bound(_lctx, b)).collect())\n             }\n             TyMac(_) => panic!(\"TyMac should have been expanded by now.\"),\n         },\n         span: t.span,\n     })\n }\n \n-pub fn lower_foreign_mod(fm: &ForeignMod) -> hir::ForeignMod {\n+pub fn lower_foreign_mod(_lctx: &LoweringContext, fm: &ForeignMod) -> hir::ForeignMod {\n     hir::ForeignMod {\n         abi: fm.abi,\n-        items: fm.items.iter().map(|x| lower_foreign_item(x)).collect(),\n+        items: fm.items.iter().map(|x| lower_foreign_item(_lctx, x)).collect(),\n     }\n }\n \n-pub fn lower_variant(v: &Variant) -> P<hir::Variant> {\n+pub fn lower_variant(_lctx: &LoweringContext, v: &Variant) -> P<hir::Variant> {\n     P(Spanned {\n         node: hir::Variant_ {\n             id: v.node.id,\n@@ -149,202 +270,218 @@ pub fn lower_variant(v: &Variant) -> P<hir::Variant> {\n             kind: match v.node.kind {\n                 TupleVariantKind(ref variant_args) => {\n                     hir::TupleVariantKind(variant_args.iter()\n-                                                      .map(|ref x| lower_variant_arg(x))\n+                                                      .map(|ref x| lower_variant_arg(_lctx, x))\n                                                       .collect())\n                 }\n                 StructVariantKind(ref struct_def) => {\n-                    hir::StructVariantKind(lower_struct_def(struct_def))\n+                    hir::StructVariantKind(lower_struct_def(_lctx, struct_def))\n                 }\n             },\n-            disr_expr: v.node.disr_expr.as_ref().map(|e| lower_expr(e)),\n+            disr_expr: v.node.disr_expr.as_ref().map(|e| lower_expr(_lctx, e)),\n         },\n         span: v.span,\n     })\n }\n \n-pub fn lower_path(p: &Path) -> hir::Path {\n+pub fn lower_path(_lctx: &LoweringContext, p: &Path) -> hir::Path {\n     hir::Path {\n         global: p.global,\n         segments: p.segments\n                    .iter()\n                    .map(|&PathSegment { identifier, ref parameters }| {\n                        hir::PathSegment {\n                            identifier: identifier,\n-                           parameters: lower_path_parameters(parameters),\n+                           parameters: lower_path_parameters(_lctx, parameters),\n                        }\n                    })\n                    .collect(),\n         span: p.span,\n     }\n }\n \n-pub fn lower_path_parameters(path_parameters: &PathParameters) -> hir::PathParameters {\n+pub fn lower_path_parameters(_lctx: &LoweringContext,\n+                             path_parameters: &PathParameters)\n+                             -> hir::PathParameters {\n     match *path_parameters {\n         AngleBracketedParameters(ref data) =>\n-            hir::AngleBracketedParameters(lower_angle_bracketed_parameter_data(data)),\n+            hir::AngleBracketedParameters(lower_angle_bracketed_parameter_data(_lctx, data)),\n         ParenthesizedParameters(ref data) =>\n-            hir::ParenthesizedParameters(lower_parenthesized_parameter_data(data)),\n+            hir::ParenthesizedParameters(lower_parenthesized_parameter_data(_lctx, data)),\n     }\n }\n \n-pub fn lower_angle_bracketed_parameter_data(data: &AngleBracketedParameterData)\n+pub fn lower_angle_bracketed_parameter_data(_lctx: &LoweringContext,\n+                                            data: &AngleBracketedParameterData)\n                                             -> hir::AngleBracketedParameterData {\n     let &AngleBracketedParameterData { ref lifetimes, ref types, ref bindings } = data;\n     hir::AngleBracketedParameterData {\n-        lifetimes: lower_lifetimes(lifetimes),\n-        types: types.iter().map(|ty| lower_ty(ty)).collect(),\n-        bindings: bindings.iter().map(|b| lower_ty_binding(b)).collect(),\n+        lifetimes: lower_lifetimes(_lctx, lifetimes),\n+        types: types.iter().map(|ty| lower_ty(_lctx, ty)).collect(),\n+        bindings: bindings.iter().map(|b| lower_ty_binding(_lctx, b)).collect(),\n     }\n }\n \n-pub fn lower_parenthesized_parameter_data(data: &ParenthesizedParameterData)\n+pub fn lower_parenthesized_parameter_data(_lctx: &LoweringContext,\n+                                          data: &ParenthesizedParameterData)\n                                           -> hir::ParenthesizedParameterData {\n     let &ParenthesizedParameterData { ref inputs, ref output, span } = data;\n     hir::ParenthesizedParameterData {\n-        inputs: inputs.iter().map(|ty| lower_ty(ty)).collect(),\n-        output: output.as_ref().map(|ty| lower_ty(ty)),\n+        inputs: inputs.iter().map(|ty| lower_ty(_lctx, ty)).collect(),\n+        output: output.as_ref().map(|ty| lower_ty(_lctx, ty)),\n         span: span,\n     }\n }\n \n-pub fn lower_local(l: &Local) -> P<hir::Local> {\n+pub fn lower_local(_lctx: &LoweringContext, l: &Local) -> P<hir::Local> {\n     P(hir::Local {\n         id: l.id,\n-        ty: l.ty.as_ref().map(|t| lower_ty(t)),\n-        pat: lower_pat(&l.pat),\n-        init: l.init.as_ref().map(|e| lower_expr(e)),\n+        ty: l.ty.as_ref().map(|t| lower_ty(_lctx, t)),\n+        pat: lower_pat(_lctx, &l.pat),\n+        init: l.init.as_ref().map(|e| lower_expr(_lctx, e)),\n         span: l.span,\n     })\n }\n \n-pub fn lower_explicit_self_underscore(es: &ExplicitSelf_) -> hir::ExplicitSelf_ {\n+pub fn lower_explicit_self_underscore(_lctx: &LoweringContext,\n+                                      es: &ExplicitSelf_)\n+                                      -> hir::ExplicitSelf_ {\n     match *es {\n         SelfStatic => hir::SelfStatic,\n         SelfValue(v) => hir::SelfValue(v.name),\n         SelfRegion(ref lifetime, m, ident) => {\n-            hir::SelfRegion(lower_opt_lifetime(lifetime),\n-                            lower_mutability(m),\n+            hir::SelfRegion(lower_opt_lifetime(_lctx, lifetime),\n+                            lower_mutability(_lctx, m),\n                             ident.name)\n         }\n         SelfExplicit(ref typ, ident) => {\n-            hir::SelfExplicit(lower_ty(typ), ident.name)\n+            hir::SelfExplicit(lower_ty(_lctx, typ), ident.name)\n         }\n     }\n }\n \n-pub fn lower_mutability(m: Mutability) -> hir::Mutability {\n+pub fn lower_mutability(_lctx: &LoweringContext, m: Mutability) -> hir::Mutability {\n     match m {\n         MutMutable => hir::MutMutable,\n         MutImmutable => hir::MutImmutable,\n     }\n }\n \n-pub fn lower_explicit_self(s: &ExplicitSelf) -> hir::ExplicitSelf {\n+pub fn lower_explicit_self(_lctx: &LoweringContext, s: &ExplicitSelf) -> hir::ExplicitSelf {\n     Spanned {\n-        node: lower_explicit_self_underscore(&s.node),\n+        node: lower_explicit_self_underscore(_lctx, &s.node),\n         span: s.span,\n     }\n }\n \n-pub fn lower_arg(arg: &Arg) -> hir::Arg {\n+pub fn lower_arg(_lctx: &LoweringContext, arg: &Arg) -> hir::Arg {\n     hir::Arg {\n         id: arg.id,\n-        pat: lower_pat(&arg.pat),\n-        ty: lower_ty(&arg.ty),\n+        pat: lower_pat(_lctx, &arg.pat),\n+        ty: lower_ty(_lctx, &arg.ty),\n     }\n }\n \n-pub fn lower_fn_decl(decl: &FnDecl) -> P<hir::FnDecl> {\n+pub fn lower_fn_decl(_lctx: &LoweringContext, decl: &FnDecl) -> P<hir::FnDecl> {\n     P(hir::FnDecl {\n-        inputs: decl.inputs.iter().map(|x| lower_arg(x)).collect(),\n+        inputs: decl.inputs.iter().map(|x| lower_arg(_lctx, x)).collect(),\n         output: match decl.output {\n-            Return(ref ty) => hir::Return(lower_ty(ty)),\n+            Return(ref ty) => hir::Return(lower_ty(_lctx, ty)),\n             DefaultReturn(span) => hir::DefaultReturn(span),\n             NoReturn(span) => hir::NoReturn(span),\n         },\n         variadic: decl.variadic,\n     })\n }\n \n-pub fn lower_ty_param_bound(tpb: &TyParamBound) -> hir::TyParamBound {\n+pub fn lower_ty_param_bound(_lctx: &LoweringContext, tpb: &TyParamBound) -> hir::TyParamBound {\n     match *tpb {\n         TraitTyParamBound(ref ty, modifier) => {\n-            hir::TraitTyParamBound(lower_poly_trait_ref(ty),\n-                                   lower_trait_bound_modifier(modifier))\n+            hir::TraitTyParamBound(lower_poly_trait_ref(_lctx, ty),\n+                                   lower_trait_bound_modifier(_lctx, modifier))\n+        }\n+        RegionTyParamBound(ref lifetime) => {\n+            hir::RegionTyParamBound(lower_lifetime(_lctx, lifetime))\n         }\n-        RegionTyParamBound(ref lifetime) => hir::RegionTyParamBound(lower_lifetime(lifetime)),\n     }\n }\n \n-pub fn lower_ty_param(tp: &TyParam) -> hir::TyParam {\n+pub fn lower_ty_param(_lctx: &LoweringContext, tp: &TyParam) -> hir::TyParam {\n     hir::TyParam {\n         id: tp.id,\n         name: tp.ident.name,\n-        bounds: lower_bounds(&tp.bounds),\n-        default: tp.default.as_ref().map(|x| lower_ty(x)),\n+        bounds: lower_bounds(_lctx, &tp.bounds),\n+        default: tp.default.as_ref().map(|x| lower_ty(_lctx, x)),\n         span: tp.span,\n     }\n }\n \n-pub fn lower_ty_params(tps: &OwnedSlice<TyParam>) -> OwnedSlice<hir::TyParam> {\n-    tps.iter().map(|tp| lower_ty_param(tp)).collect()\n+pub fn lower_ty_params(_lctx: &LoweringContext,\n+                       tps: &OwnedSlice<TyParam>)\n+                       -> OwnedSlice<hir::TyParam> {\n+    tps.iter().map(|tp| lower_ty_param(_lctx, tp)).collect()\n }\n \n-pub fn lower_lifetime(l: &Lifetime) -> hir::Lifetime {\n+pub fn lower_lifetime(_lctx: &LoweringContext, l: &Lifetime) -> hir::Lifetime {\n     hir::Lifetime {\n         id: l.id,\n         name: l.name,\n         span: l.span,\n     }\n }\n \n-pub fn lower_lifetime_def(l: &LifetimeDef) -> hir::LifetimeDef {\n+pub fn lower_lifetime_def(_lctx: &LoweringContext, l: &LifetimeDef) -> hir::LifetimeDef {\n     hir::LifetimeDef {\n-        lifetime: lower_lifetime(&l.lifetime),\n-        bounds: lower_lifetimes(&l.bounds),\n+        lifetime: lower_lifetime(_lctx, &l.lifetime),\n+        bounds: lower_lifetimes(_lctx, &l.bounds),\n     }\n }\n \n-pub fn lower_lifetimes(lts: &Vec<Lifetime>) -> Vec<hir::Lifetime> {\n-    lts.iter().map(|l| lower_lifetime(l)).collect()\n+pub fn lower_lifetimes(_lctx: &LoweringContext, lts: &Vec<Lifetime>) -> Vec<hir::Lifetime> {\n+    lts.iter().map(|l| lower_lifetime(_lctx, l)).collect()\n }\n \n-pub fn lower_lifetime_defs(lts: &Vec<LifetimeDef>) -> Vec<hir::LifetimeDef> {\n-    lts.iter().map(|l| lower_lifetime_def(l)).collect()\n+pub fn lower_lifetime_defs(_lctx: &LoweringContext,\n+                           lts: &Vec<LifetimeDef>)\n+                           -> Vec<hir::LifetimeDef> {\n+    lts.iter().map(|l| lower_lifetime_def(_lctx, l)).collect()\n }\n \n-pub fn lower_opt_lifetime(o_lt: &Option<Lifetime>) -> Option<hir::Lifetime> {\n-    o_lt.as_ref().map(|lt| lower_lifetime(lt))\n+pub fn lower_opt_lifetime(_lctx: &LoweringContext,\n+                          o_lt: &Option<Lifetime>)\n+                          -> Option<hir::Lifetime> {\n+    o_lt.as_ref().map(|lt| lower_lifetime(_lctx, lt))\n }\n \n-pub fn lower_generics(g: &Generics) -> hir::Generics {\n+pub fn lower_generics(_lctx: &LoweringContext, g: &Generics) -> hir::Generics {\n     hir::Generics {\n-        ty_params: lower_ty_params(&g.ty_params),\n-        lifetimes: lower_lifetime_defs(&g.lifetimes),\n-        where_clause: lower_where_clause(&g.where_clause),\n+        ty_params: lower_ty_params(_lctx, &g.ty_params),\n+        lifetimes: lower_lifetime_defs(_lctx, &g.lifetimes),\n+        where_clause: lower_where_clause(_lctx, &g.where_clause),\n     }\n }\n \n-pub fn lower_where_clause(wc: &WhereClause) -> hir::WhereClause {\n+pub fn lower_where_clause(_lctx: &LoweringContext, wc: &WhereClause) -> hir::WhereClause {\n     hir::WhereClause {\n         id: wc.id,\n         predicates: wc.predicates\n                       .iter()\n-                      .map(|predicate| lower_where_predicate(predicate))\n+                      .map(|predicate| lower_where_predicate(_lctx, predicate))\n                       .collect(),\n     }\n }\n \n-pub fn lower_where_predicate(pred: &WherePredicate) -> hir::WherePredicate {\n+pub fn lower_where_predicate(_lctx: &LoweringContext,\n+                             pred: &WherePredicate)\n+                             -> hir::WherePredicate {\n     match *pred {\n         WherePredicate::BoundPredicate(WhereBoundPredicate{ ref bound_lifetimes,\n                                                             ref bounded_ty,\n                                                             ref bounds,\n                                                             span}) => {\n             hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n-                bound_lifetimes: lower_lifetime_defs(bound_lifetimes),\n-                bounded_ty: lower_ty(bounded_ty),\n-                bounds: bounds.iter().map(|x| lower_ty_param_bound(x)).collect(),\n+                bound_lifetimes: lower_lifetime_defs(_lctx, bound_lifetimes),\n+                bounded_ty: lower_ty(_lctx, bounded_ty),\n+                bounds: bounds.iter().map(|x| lower_ty_param_bound(_lctx, x)).collect(),\n                 span: span,\n             })\n         }\n@@ -353,8 +490,8 @@ pub fn lower_where_predicate(pred: &WherePredicate) -> hir::WherePredicate {\n                                                               span}) => {\n             hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n                 span: span,\n-                lifetime: lower_lifetime(lifetime),\n-                bounds: bounds.iter().map(|bound| lower_lifetime(bound)).collect(),\n+                lifetime: lower_lifetime(_lctx, lifetime),\n+                bounds: bounds.iter().map(|bound| lower_lifetime(_lctx, bound)).collect(),\n             })\n         }\n         WherePredicate::EqPredicate(WhereEqPredicate{ id,\n@@ -363,213 +500,220 @@ pub fn lower_where_predicate(pred: &WherePredicate) -> hir::WherePredicate {\n                                                       span}) => {\n             hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                 id: id,\n-                path: lower_path(path),\n-                ty: lower_ty(ty),\n+                path: lower_path(_lctx, path),\n+                ty: lower_ty(_lctx, ty),\n                 span: span,\n             })\n         }\n     }\n }\n \n-pub fn lower_struct_def(sd: &StructDef) -> P<hir::StructDef> {\n+pub fn lower_struct_def(_lctx: &LoweringContext, sd: &StructDef) -> P<hir::StructDef> {\n     P(hir::StructDef {\n-        fields: sd.fields.iter().map(|f| lower_struct_field(f)).collect(),\n+        fields: sd.fields.iter().map(|f| lower_struct_field(_lctx, f)).collect(),\n         ctor_id: sd.ctor_id,\n     })\n }\n \n-pub fn lower_trait_ref(p: &TraitRef) -> hir::TraitRef {\n+pub fn lower_trait_ref(_lctx: &LoweringContext, p: &TraitRef) -> hir::TraitRef {\n     hir::TraitRef {\n-        path: lower_path(&p.path),\n+        path: lower_path(_lctx, &p.path),\n         ref_id: p.ref_id,\n     }\n }\n \n-pub fn lower_poly_trait_ref(p: &PolyTraitRef) -> hir::PolyTraitRef {\n+pub fn lower_poly_trait_ref(_lctx: &LoweringContext, p: &PolyTraitRef) -> hir::PolyTraitRef {\n     hir::PolyTraitRef {\n-        bound_lifetimes: lower_lifetime_defs(&p.bound_lifetimes),\n-        trait_ref: lower_trait_ref(&p.trait_ref),\n+        bound_lifetimes: lower_lifetime_defs(_lctx, &p.bound_lifetimes),\n+        trait_ref: lower_trait_ref(_lctx, &p.trait_ref),\n         span: p.span,\n     }\n }\n \n-pub fn lower_struct_field(f: &StructField) -> hir::StructField {\n+pub fn lower_struct_field(_lctx: &LoweringContext, f: &StructField) -> hir::StructField {\n     Spanned {\n         node: hir::StructField_ {\n             id: f.node.id,\n-            kind: lower_struct_field_kind(&f.node.kind),\n-            ty: lower_ty(&f.node.ty),\n+            kind: lower_struct_field_kind(_lctx, &f.node.kind),\n+            ty: lower_ty(_lctx, &f.node.ty),\n             attrs: f.node.attrs.clone(),\n         },\n         span: f.span,\n     }\n }\n \n-pub fn lower_field(f: &Field) -> hir::Field {\n+pub fn lower_field(_lctx: &LoweringContext, f: &Field) -> hir::Field {\n     hir::Field {\n         name: respan(f.ident.span, f.ident.node.name),\n-        expr: lower_expr(&f.expr),\n+        expr: lower_expr(_lctx, &f.expr),\n         span: f.span,\n     }\n }\n \n-pub fn lower_mt(mt: &MutTy) -> hir::MutTy {\n+pub fn lower_mt(_lctx: &LoweringContext, mt: &MutTy) -> hir::MutTy {\n     hir::MutTy {\n-        ty: lower_ty(&mt.ty),\n-        mutbl: lower_mutability(mt.mutbl),\n+        ty: lower_ty(_lctx, &mt.ty),\n+        mutbl: lower_mutability(_lctx, mt.mutbl),\n     }\n }\n \n-pub fn lower_opt_bounds(b: &Option<OwnedSlice<TyParamBound>>)\n+pub fn lower_opt_bounds(_lctx: &LoweringContext,\n+                        b: &Option<OwnedSlice<TyParamBound>>)\n                         -> Option<OwnedSlice<hir::TyParamBound>> {\n-    b.as_ref().map(|ref bounds| lower_bounds(bounds))\n+    b.as_ref().map(|ref bounds| lower_bounds(_lctx, bounds))\n }\n \n-fn lower_bounds(bounds: &TyParamBounds) -> hir::TyParamBounds {\n-    bounds.iter().map(|bound| lower_ty_param_bound(bound)).collect()\n+fn lower_bounds(_lctx: &LoweringContext, bounds: &TyParamBounds) -> hir::TyParamBounds {\n+    bounds.iter().map(|bound| lower_ty_param_bound(_lctx, bound)).collect()\n }\n \n-fn lower_variant_arg(va: &VariantArg) -> hir::VariantArg {\n+fn lower_variant_arg(_lctx: &LoweringContext, va: &VariantArg) -> hir::VariantArg {\n     hir::VariantArg {\n         id: va.id,\n-        ty: lower_ty(&va.ty),\n+        ty: lower_ty(_lctx, &va.ty),\n     }\n }\n \n-pub fn lower_block(b: &Block) -> P<hir::Block> {\n+pub fn lower_block(_lctx: &LoweringContext, b: &Block) -> P<hir::Block> {\n     P(hir::Block {\n         id: b.id,\n-        stmts: b.stmts.iter().map(|s| lower_stmt(s)).collect(),\n-        expr: b.expr.as_ref().map(|ref x| lower_expr(x)),\n-        rules: lower_block_check_mode(&b.rules),\n+        stmts: b.stmts.iter().map(|s| lower_stmt(_lctx, s)).collect(),\n+        expr: b.expr.as_ref().map(|ref x| lower_expr(_lctx, x)),\n+        rules: lower_block_check_mode(_lctx, &b.rules),\n         span: b.span,\n     })\n }\n \n-pub fn lower_item_underscore(i: &Item_) -> hir::Item_ {\n+pub fn lower_item_underscore(_lctx: &LoweringContext, i: &Item_) -> hir::Item_ {\n     match *i {\n         ItemExternCrate(string) => hir::ItemExternCrate(string),\n         ItemUse(ref view_path) => {\n-            hir::ItemUse(lower_view_path(view_path))\n+            hir::ItemUse(lower_view_path(_lctx, view_path))\n         }\n         ItemStatic(ref t, m, ref e) => {\n-            hir::ItemStatic(lower_ty(t), lower_mutability(m), lower_expr(e))\n+            hir::ItemStatic(lower_ty(_lctx, t),\n+                            lower_mutability(_lctx, m),\n+                            lower_expr(_lctx, e))\n         }\n         ItemConst(ref t, ref e) => {\n-            hir::ItemConst(lower_ty(t), lower_expr(e))\n+            hir::ItemConst(lower_ty(_lctx, t), lower_expr(_lctx, e))\n         }\n         ItemFn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n-            hir::ItemFn(lower_fn_decl(decl),\n-                        lower_unsafety(unsafety),\n-                        lower_constness(constness),\n+            hir::ItemFn(lower_fn_decl(_lctx, decl),\n+                        lower_unsafety(_lctx, unsafety),\n+                        lower_constness(_lctx, constness),\n                         abi,\n-                        lower_generics(generics),\n-                        lower_block(body))\n+                        lower_generics(_lctx, generics),\n+                        lower_block(_lctx, body))\n         }\n-        ItemMod(ref m) => hir::ItemMod(lower_mod(m)),\n-        ItemForeignMod(ref nm) => hir::ItemForeignMod(lower_foreign_mod(nm)),\n+        ItemMod(ref m) => hir::ItemMod(lower_mod(_lctx, m)),\n+        ItemForeignMod(ref nm) => hir::ItemForeignMod(lower_foreign_mod(_lctx, nm)),\n         ItemTy(ref t, ref generics) => {\n-            hir::ItemTy(lower_ty(t), lower_generics(generics))\n+            hir::ItemTy(lower_ty(_lctx, t), lower_generics(_lctx, generics))\n         }\n         ItemEnum(ref enum_definition, ref generics) => {\n             hir::ItemEnum(hir::EnumDef {\n                               variants: enum_definition.variants\n                                                        .iter()\n-                                                       .map(|x| lower_variant(x))\n+                                                       .map(|x| lower_variant(_lctx, x))\n                                                        .collect(),\n                           },\n-                          lower_generics(generics))\n+                          lower_generics(_lctx, generics))\n         }\n         ItemStruct(ref struct_def, ref generics) => {\n-            let struct_def = lower_struct_def(struct_def);\n-            hir::ItemStruct(struct_def, lower_generics(generics))\n+            let struct_def = lower_struct_def(_lctx, struct_def);\n+            hir::ItemStruct(struct_def, lower_generics(_lctx, generics))\n         }\n         ItemDefaultImpl(unsafety, ref trait_ref) => {\n-            hir::ItemDefaultImpl(lower_unsafety(unsafety), lower_trait_ref(trait_ref))\n+            hir::ItemDefaultImpl(lower_unsafety(_lctx, unsafety),\n+                                 lower_trait_ref(_lctx, trait_ref))\n         }\n         ItemImpl(unsafety, polarity, ref generics, ref ifce, ref ty, ref impl_items) => {\n-            let new_impl_items = impl_items.iter().map(|item| lower_impl_item(item)).collect();\n-            let ifce = ifce.as_ref().map(|trait_ref| lower_trait_ref(trait_ref));\n-            hir::ItemImpl(lower_unsafety(unsafety),\n-                          lower_impl_polarity(polarity),\n-                          lower_generics(generics),\n+            let new_impl_items = impl_items.iter()\n+                                           .map(|item| lower_impl_item(_lctx, item))\n+                                           .collect();\n+            let ifce = ifce.as_ref().map(|trait_ref| lower_trait_ref(_lctx, trait_ref));\n+            hir::ItemImpl(lower_unsafety(_lctx, unsafety),\n+                          lower_impl_polarity(_lctx, polarity),\n+                          lower_generics(_lctx, generics),\n                           ifce,\n-                          lower_ty(ty),\n+                          lower_ty(_lctx, ty),\n                           new_impl_items)\n         }\n         ItemTrait(unsafety, ref generics, ref bounds, ref items) => {\n-            let bounds = lower_bounds(bounds);\n-            let items = items.iter().map(|item| lower_trait_item(item)).collect();\n-            hir::ItemTrait(lower_unsafety(unsafety),\n-                           lower_generics(generics),\n+            let bounds = lower_bounds(_lctx, bounds);\n+            let items = items.iter().map(|item| lower_trait_item(_lctx, item)).collect();\n+            hir::ItemTrait(lower_unsafety(_lctx, unsafety),\n+                           lower_generics(_lctx, generics),\n                            bounds,\n                            items)\n         }\n         ItemMac(_) => panic!(\"Shouldn't still be around\"),\n     }\n }\n \n-pub fn lower_trait_item(i: &TraitItem) -> P<hir::TraitItem> {\n+pub fn lower_trait_item(_lctx: &LoweringContext, i: &TraitItem) -> P<hir::TraitItem> {\n     P(hir::TraitItem {\n         id: i.id,\n         name: i.ident.name,\n         attrs: i.attrs.clone(),\n         node: match i.node {\n             ConstTraitItem(ref ty, ref default) => {\n-                hir::ConstTraitItem(lower_ty(ty),\n-                                    default.as_ref().map(|x| lower_expr(x)))\n+                hir::ConstTraitItem(lower_ty(_lctx, ty),\n+                                    default.as_ref().map(|x| lower_expr(_lctx, x)))\n             }\n             MethodTraitItem(ref sig, ref body) => {\n-                hir::MethodTraitItem(lower_method_sig(sig),\n-                                     body.as_ref().map(|x| lower_block(x)))\n+                hir::MethodTraitItem(lower_method_sig(_lctx, sig),\n+                                     body.as_ref().map(|x| lower_block(_lctx, x)))\n             }\n             TypeTraitItem(ref bounds, ref default) => {\n-                hir::TypeTraitItem(lower_bounds(bounds),\n-                                   default.as_ref().map(|x| lower_ty(x)))\n+                hir::TypeTraitItem(lower_bounds(_lctx, bounds),\n+                                   default.as_ref().map(|x| lower_ty(_lctx, x)))\n             }\n         },\n         span: i.span,\n     })\n }\n \n-pub fn lower_impl_item(i: &ImplItem) -> P<hir::ImplItem> {\n+pub fn lower_impl_item(_lctx: &LoweringContext, i: &ImplItem) -> P<hir::ImplItem> {\n     P(hir::ImplItem {\n         id: i.id,\n         name: i.ident.name,\n         attrs: i.attrs.clone(),\n-        vis: lower_visibility(i.vis),\n+        vis: lower_visibility(_lctx, i.vis),\n         node: match i.node {\n             ConstImplItem(ref ty, ref expr) => {\n-                hir::ConstImplItem(lower_ty(ty), lower_expr(expr))\n+                hir::ConstImplItem(lower_ty(_lctx, ty), lower_expr(_lctx, expr))\n             }\n             MethodImplItem(ref sig, ref body) => {\n-                hir::MethodImplItem(lower_method_sig(sig), lower_block(body))\n+                hir::MethodImplItem(lower_method_sig(_lctx, sig),\n+                                    lower_block(_lctx, body))\n             }\n-            TypeImplItem(ref ty) => hir::TypeImplItem(lower_ty(ty)),\n+            TypeImplItem(ref ty) => hir::TypeImplItem(lower_ty(_lctx, ty)),\n             MacImplItem(..) => panic!(\"Shouldn't exist any more\"),\n         },\n         span: i.span,\n     })\n }\n \n-pub fn lower_mod(m: &Mod) -> hir::Mod {\n+pub fn lower_mod(_lctx: &LoweringContext, m: &Mod) -> hir::Mod {\n     hir::Mod {\n         inner: m.inner,\n-        items: m.items.iter().map(|x| lower_item(x)).collect(),\n+        items: m.items.iter().map(|x| lower_item(_lctx, x)).collect(),\n     }\n }\n \n-pub fn lower_crate(c: &Crate) -> hir::Crate {\n+pub fn lower_crate(_lctx: &LoweringContext, c: &Crate) -> hir::Crate {\n     hir::Crate {\n-        module: lower_mod(&c.module),\n+        module: lower_mod(_lctx, &c.module),\n         attrs: c.attrs.clone(),\n         config: c.config.clone(),\n         span: c.span,\n-        exported_macros: c.exported_macros.iter().map(|m| lower_macro_def(m)).collect(),\n+        exported_macros: c.exported_macros.iter().map(|m| lower_macro_def(_lctx, m)).collect(),\n     }\n }\n \n-pub fn lower_macro_def(m: &MacroDef) -> hir::MacroDef {\n+pub fn lower_macro_def(_lctx: &LoweringContext, m: &MacroDef) -> hir::MacroDef {\n     hir::MacroDef {\n         name: m.ident.name,\n         attrs: m.attrs.clone(),\n@@ -584,76 +728,77 @@ pub fn lower_macro_def(m: &MacroDef) -> hir::MacroDef {\n }\n \n // fold one item into possibly many items\n-pub fn lower_item(i: &Item) -> P<hir::Item> {\n-    P(lower_item_simple(i))\n+pub fn lower_item(_lctx: &LoweringContext, i: &Item) -> P<hir::Item> {\n+    P(lower_item_simple(_lctx, i))\n }\n \n // fold one item into exactly one item\n-pub fn lower_item_simple(i: &Item) -> hir::Item {\n-    let node = lower_item_underscore(&i.node);\n+pub fn lower_item_simple(_lctx: &LoweringContext, i: &Item) -> hir::Item {\n+    let node = lower_item_underscore(_lctx, &i.node);\n \n     hir::Item {\n         id: i.id,\n         name: i.ident.name,\n         attrs: i.attrs.clone(),\n         node: node,\n-        vis: lower_visibility(i.vis),\n+        vis: lower_visibility(_lctx, i.vis),\n         span: i.span,\n     }\n }\n \n-pub fn lower_foreign_item(i: &ForeignItem) -> P<hir::ForeignItem> {\n+pub fn lower_foreign_item(_lctx: &LoweringContext, i: &ForeignItem) -> P<hir::ForeignItem> {\n     P(hir::ForeignItem {\n         id: i.id,\n         name: i.ident.name,\n         attrs: i.attrs.clone(),\n         node: match i.node {\n             ForeignItemFn(ref fdec, ref generics) => {\n-                hir::ForeignItemFn(lower_fn_decl(fdec), lower_generics(generics))\n+                hir::ForeignItemFn(lower_fn_decl(_lctx, fdec),\n+                                   lower_generics(_lctx, generics))\n             }\n             ForeignItemStatic(ref t, m) => {\n-                hir::ForeignItemStatic(lower_ty(t), m)\n+                hir::ForeignItemStatic(lower_ty(_lctx, t), m)\n             }\n         },\n-        vis: lower_visibility(i.vis),\n+        vis: lower_visibility(_lctx, i.vis),\n         span: i.span,\n     })\n }\n \n-pub fn lower_method_sig(sig: &MethodSig) -> hir::MethodSig {\n+pub fn lower_method_sig(_lctx: &LoweringContext, sig: &MethodSig) -> hir::MethodSig {\n     hir::MethodSig {\n-        generics: lower_generics(&sig.generics),\n+        generics: lower_generics(_lctx, &sig.generics),\n         abi: sig.abi,\n-        explicit_self: lower_explicit_self(&sig.explicit_self),\n-        unsafety: lower_unsafety(sig.unsafety),\n-        constness: lower_constness(sig.constness),\n-        decl: lower_fn_decl(&sig.decl),\n+        explicit_self: lower_explicit_self(_lctx, &sig.explicit_self),\n+        unsafety: lower_unsafety(_lctx, sig.unsafety),\n+        constness: lower_constness(_lctx, sig.constness),\n+        decl: lower_fn_decl(_lctx, &sig.decl),\n     }\n }\n \n-pub fn lower_unsafety(u: Unsafety) -> hir::Unsafety {\n+pub fn lower_unsafety(_lctx: &LoweringContext, u: Unsafety) -> hir::Unsafety {\n     match u {\n         Unsafety::Unsafe => hir::Unsafety::Unsafe,\n         Unsafety::Normal => hir::Unsafety::Normal,\n     }\n }\n \n-pub fn lower_constness(c: Constness) -> hir::Constness {\n+pub fn lower_constness(_lctx: &LoweringContext, c: Constness) -> hir::Constness {\n     match c {\n         Constness::Const => hir::Constness::Const,\n         Constness::NotConst => hir::Constness::NotConst,\n     }\n }\n \n-pub fn lower_unop(u: UnOp) -> hir::UnOp {\n+pub fn lower_unop(_lctx: &LoweringContext, u: UnOp) -> hir::UnOp {\n     match u {\n         UnDeref => hir::UnDeref,\n         UnNot => hir::UnNot,\n         UnNeg => hir::UnNeg,\n     }\n }\n \n-pub fn lower_binop(b: BinOp) -> hir::BinOp {\n+pub fn lower_binop(_lctx: &LoweringContext, b: BinOp) -> hir::BinOp {\n     Spanned {\n         node: match b.node {\n             BiAdd => hir::BiAdd,\n@@ -679,149 +824,349 @@ pub fn lower_binop(b: BinOp) -> hir::BinOp {\n     }\n }\n \n-pub fn lower_pat(p: &Pat) -> P<hir::Pat> {\n+pub fn lower_pat(_lctx: &LoweringContext, p: &Pat) -> P<hir::Pat> {\n     P(hir::Pat {\n         id: p.id,\n         node: match p.node {\n-            PatWild(k) => hir::PatWild(lower_pat_wild_kind(k)),\n+            PatWild(k) => hir::PatWild(lower_pat_wild_kind(_lctx, k)),\n             PatIdent(ref binding_mode, pth1, ref sub) => {\n-                hir::PatIdent(lower_binding_mode(binding_mode),\n+                hir::PatIdent(lower_binding_mode(_lctx, binding_mode),\n                               pth1,\n-                              sub.as_ref().map(|x| lower_pat(x)))\n+                              sub.as_ref().map(|x| lower_pat(_lctx, x)))\n             }\n-            PatLit(ref e) => hir::PatLit(lower_expr(e)),\n+            PatLit(ref e) => hir::PatLit(lower_expr(_lctx, e)),\n             PatEnum(ref pth, ref pats) => {\n-                hir::PatEnum(lower_path(pth),\n-                             pats.as_ref().map(|pats| pats.iter().map(|x| lower_pat(x)).collect()))\n+                hir::PatEnum(lower_path(_lctx, pth),\n+                             pats.as_ref()\n+                                 .map(|pats| pats.iter().map(|x| lower_pat(_lctx, x)).collect()))\n             }\n             PatQPath(ref qself, ref pth) => {\n                 let qself = hir::QSelf {\n-                    ty: lower_ty(&qself.ty),\n+                    ty: lower_ty(_lctx, &qself.ty),\n                     position: qself.position,\n                 };\n-                hir::PatQPath(qself, lower_path(pth))\n+                hir::PatQPath(qself, lower_path(_lctx, pth))\n             }\n             PatStruct(ref pth, ref fields, etc) => {\n-                let pth = lower_path(pth);\n+                let pth = lower_path(_lctx, pth);\n                 let fs = fields.iter()\n                                .map(|f| {\n                                    Spanned {\n                                        span: f.span,\n                                        node: hir::FieldPat {\n                                            name: f.node.ident.name,\n-                                           pat: lower_pat(&f.node.pat),\n+                                           pat: lower_pat(_lctx, &f.node.pat),\n                                            is_shorthand: f.node.is_shorthand,\n                                        },\n                                    }\n                                })\n                                .collect();\n                 hir::PatStruct(pth, fs, etc)\n             }\n-            PatTup(ref elts) => hir::PatTup(elts.iter().map(|x| lower_pat(x)).collect()),\n-            PatBox(ref inner) => hir::PatBox(lower_pat(inner)),\n-            PatRegion(ref inner, mutbl) =>\n-                hir::PatRegion(lower_pat(inner), lower_mutability(mutbl)),\n+            PatTup(ref elts) => hir::PatTup(elts.iter().map(|x| lower_pat(_lctx, x)).collect()),\n+            PatBox(ref inner) => hir::PatBox(lower_pat(_lctx, inner)),\n+            PatRegion(ref inner, mutbl) => hir::PatRegion(lower_pat(_lctx, inner),\n+                                                          lower_mutability(_lctx, mutbl)),\n             PatRange(ref e1, ref e2) => {\n-                hir::PatRange(lower_expr(e1), lower_expr(e2))\n+                hir::PatRange(lower_expr(_lctx, e1), lower_expr(_lctx, e2))\n             }\n             PatVec(ref before, ref slice, ref after) => {\n-                hir::PatVec(before.iter().map(|x| lower_pat(x)).collect(),\n-                            slice.as_ref().map(|x| lower_pat(x)),\n-                            after.iter().map(|x| lower_pat(x)).collect())\n+                hir::PatVec(before.iter().map(|x| lower_pat(_lctx, x)).collect(),\n+                            slice.as_ref().map(|x| lower_pat(_lctx, x)),\n+                            after.iter().map(|x| lower_pat(_lctx, x)).collect())\n             }\n             PatMac(_) => panic!(\"Shouldn't exist here\"),\n         },\n         span: p.span,\n     })\n }\n \n-pub fn lower_expr(e: &Expr) -> P<hir::Expr> {\n+// RAII utility for setting and unsetting the cached id.\n+struct CachedIdSetter<'a> {\n+    reset: bool,\n+    lctx: &'a LoweringContext<'a>,\n+}\n+\n+impl<'a> CachedIdSetter<'a> {\n+    fn new(lctx: &'a LoweringContext, expr_id: NodeId) -> CachedIdSetter<'a> {\n+        // Only reset the id if it was previously 0, i.e., was not cached.\n+        // If it was cached, we are in a nested node, but our id count will\n+        // still count towards the parent's count.\n+        let reset_cached_id = lctx.cached_id.get() == 0;\n+\n+        let id_cache: &mut HashMap<_, _> = &mut lctx.id_cache.borrow_mut();\n+\n+        if id_cache.contains_key(&expr_id) {\n+            let cached_id = lctx.cached_id.get();\n+            if cached_id == 0 {\n+                // We're entering a node where we need to track ids, but are not\n+                // yet tracking.\n+                lctx.cached_id.set(id_cache[&expr_id]);\n+                lctx.gensym_key.set(id_cache[&expr_id]);\n+            } else {\n+                // We're already tracking - check that the tracked id is the same\n+                // as the expected id.\n+                assert!(cached_id == id_cache[&expr_id], \"id mismatch\");\n+            }\n+        } else {\n+            let next_id = lctx.id_assigner.peek_node_id();\n+            id_cache.insert(expr_id, next_id);\n+            lctx.gensym_key.set(next_id);\n+        }\n+\n+        CachedIdSetter {\n+            reset: reset_cached_id,\n+            lctx: lctx,\n+        }\n+    }\n+}\n+\n+impl<'a> Drop for CachedIdSetter<'a> {\n+    fn drop(&mut self) {\n+        if self.reset {\n+            self.lctx.cached_id.set(0);\n+            self.lctx.gensym_key.set(0);\n+        }\n+    }\n+}\n+\n+pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n     P(hir::Expr {\n         id: e.id,\n         node: match e.node {\n+            // Issue #22181:\n+            // Eventually a desugaring for `box EXPR`\n+            // (similar to the desugaring above for `in PLACE BLOCK`)\n+            // should go here, desugaring\n+            //\n+            // to:\n+            //\n+            // let mut place = BoxPlace::make_place();\n+            // let raw_place = Place::pointer(&mut place);\n+            // let value = $value;\n+            // unsafe {\n+            //     ::std::ptr::write(raw_place, value);\n+            //     Boxed::finalize(place)\n+            // }\n+            //\n+            // But for now there are type-inference issues doing that.\n             ExprBox(ref e) => {\n-                hir::ExprBox(lower_expr(e))\n+                hir::ExprBox(lower_expr(lctx, e))\n             }\n+\n+            // Desugar ExprBox: `in (PLACE) EXPR`\n+            ExprInPlace(ref placer, ref value_expr) => {\n+                // to:\n+                //\n+                // let p = PLACE;\n+                // let mut place = Placer::make_place(p);\n+                // let raw_place = Place::pointer(&mut place);\n+                // push_unsafe!({\n+                //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n+                //     InPlace::finalize(place)\n+                // })\n+                let _old_cached = CachedIdSetter::new(lctx, e.id);\n+\n+                let placer_expr = lower_expr(lctx, placer);\n+                let value_expr = lower_expr(lctx, value_expr);\n+\n+                let placer_ident = lctx.str_to_ident(\"placer\");\n+                let agent_ident = lctx.str_to_ident(\"place\");\n+                let p_ptr_ident = lctx.str_to_ident(\"p_ptr\");\n+\n+                let make_place = [\"ops\", \"Placer\", \"make_place\"];\n+                let place_pointer = [\"ops\", \"Place\", \"pointer\"];\n+                let move_val_init = [\"intrinsics\", \"move_val_init\"];\n+                let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n+\n+                let make_call = |lctx, p, args| {\n+                    let path = core_path(lctx, e.span, p);\n+                    let path = expr_path(lctx, path);\n+                    expr_call(lctx, e.span, path, args)\n+                };\n+\n+                let mk_stmt_let = |lctx, bind, expr| stmt_let(lctx, e.span, false, bind, expr);\n+                let mk_stmt_let_mut = |lctx, bind, expr| stmt_let(lctx, e.span, true, bind, expr);\n+\n+                // let placer = <placer_expr> ;\n+                let s1 = mk_stmt_let(lctx,\n+                                     placer_ident,\n+                                     signal_block_expr(lctx,\n+                                                       vec![],\n+                                                       placer_expr,\n+                                                       e.span,\n+                                                       hir::PopUnstableBlock));\n+\n+                // let mut place = Placer::make_place(placer);\n+                let s2 = {\n+                    let call = make_call(lctx,\n+                                         &make_place,\n+                                         vec![expr_ident(lctx, e.span, placer_ident)]);\n+                    mk_stmt_let_mut(lctx, agent_ident, call)\n+                };\n+\n+                // let p_ptr = Place::pointer(&mut place);\n+                let s3 = {\n+                    let args = vec![expr_mut_addr_of(lctx,\n+                                                     e.span,\n+                                                     expr_ident(lctx, e.span, agent_ident))];\n+                    let call = make_call(lctx, &place_pointer, args);\n+                    mk_stmt_let(lctx, p_ptr_ident, call)\n+                };\n+\n+                // pop_unsafe!(EXPR));\n+                let pop_unsafe_expr =\n+                    signal_block_expr(lctx,\n+                                      vec![],\n+                                      signal_block_expr(lctx,\n+                                                        vec![],\n+                                                        value_expr,\n+                                                        e.span,\n+                                                        hir::PopUnstableBlock),\n+                                      e.span,\n+                                      hir::PopUnsafeBlock(hir::CompilerGenerated));\n+\n+                // push_unsafe!({\n+                //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n+                //     InPlace::finalize(place)\n+                // })\n+                let expr = {\n+                    let call_move_val_init = hir::StmtSemi(make_call(lctx,\n+                                                    &move_val_init,\n+                                                    vec![expr_ident(lctx, e.span, p_ptr_ident),\n+                                                         pop_unsafe_expr]),\n+                                                           lctx.next_id());\n+                    let call_move_val_init = respan(e.span, call_move_val_init);\n+\n+                    let call = make_call(lctx,\n+                                         &inplace_finalize,\n+                                         vec![expr_ident(lctx, e.span, agent_ident)]);\n+                    signal_block_expr(lctx,\n+                                      vec![P(call_move_val_init)],\n+                                      call,\n+                                      e.span,\n+                                      hir::PushUnsafeBlock(hir::CompilerGenerated))\n+                };\n+\n+                return signal_block_expr(lctx,\n+                                         vec![s1, s2, s3],\n+                                         expr,\n+                                         e.span,\n+                                         hir::PushUnstableBlock);\n+            }\n+\n             ExprVec(ref exprs) => {\n-                hir::ExprVec(exprs.iter().map(|x| lower_expr(x)).collect())\n+                hir::ExprVec(exprs.iter().map(|x| lower_expr(lctx, x)).collect())\n             }\n             ExprRepeat(ref expr, ref count) => {\n-                hir::ExprRepeat(lower_expr(expr), lower_expr(count))\n+                hir::ExprRepeat(lower_expr(lctx, expr), lower_expr(lctx, count))\n+            }\n+            ExprTup(ref elts) => {\n+                hir::ExprTup(elts.iter().map(|x| lower_expr(lctx, x)).collect())\n             }\n-            ExprTup(ref elts) => hir::ExprTup(elts.iter().map(|x| lower_expr(x)).collect()),\n             ExprCall(ref f, ref args) => {\n-                hir::ExprCall(lower_expr(f),\n-                              args.iter().map(|x| lower_expr(x)).collect())\n+                hir::ExprCall(lower_expr(lctx, f),\n+                              args.iter().map(|x| lower_expr(lctx, x)).collect())\n             }\n             ExprMethodCall(i, ref tps, ref args) => {\n                 hir::ExprMethodCall(respan(i.span, i.node.name),\n-                                    tps.iter().map(|x| lower_ty(x)).collect(),\n-                                    args.iter().map(|x| lower_expr(x)).collect())\n+                                    tps.iter().map(|x| lower_ty(lctx, x)).collect(),\n+                                    args.iter().map(|x| lower_expr(lctx, x)).collect())\n             }\n             ExprBinary(binop, ref lhs, ref rhs) => {\n-                hir::ExprBinary(lower_binop(binop), lower_expr(lhs), lower_expr(rhs))\n+                hir::ExprBinary(lower_binop(lctx, binop),\n+                                lower_expr(lctx, lhs),\n+                                lower_expr(lctx, rhs))\n             }\n             ExprUnary(op, ref ohs) => {\n-                hir::ExprUnary(lower_unop(op), lower_expr(ohs))\n+                hir::ExprUnary(lower_unop(lctx, op), lower_expr(lctx, ohs))\n             }\n             ExprLit(ref l) => hir::ExprLit(P((**l).clone())),\n             ExprCast(ref expr, ref ty) => {\n-                hir::ExprCast(lower_expr(expr), lower_ty(ty))\n+                hir::ExprCast(lower_expr(lctx, expr), lower_ty(lctx, ty))\n+            }\n+            ExprAddrOf(m, ref ohs) => {\n+                hir::ExprAddrOf(lower_mutability(lctx, m), lower_expr(lctx, ohs))\n             }\n-            ExprAddrOf(m, ref ohs) => hir::ExprAddrOf(lower_mutability(m), lower_expr(ohs)),\n-            ExprIf(ref cond, ref tr, ref fl) => {\n-                hir::ExprIf(lower_expr(cond),\n-                            lower_block(tr),\n-                            fl.as_ref().map(|x| lower_expr(x)))\n+            // More complicated than you might expect because the else branch\n+            // might be `if let`.\n+            ExprIf(ref cond, ref blk, ref else_opt) => {\n+                let else_opt = else_opt.as_ref().map(|els| {\n+                    match els.node {\n+                        ExprIfLet(..) => {\n+                            let _old_cached = CachedIdSetter::new(lctx, e.id);\n+                            // wrap the if-let expr in a block\n+                            let span = els.span;\n+                            let blk = P(hir::Block {\n+                                stmts: vec![],\n+                                expr: Some(lower_expr(lctx, els)),\n+                                id: lctx.next_id(),\n+                                rules: hir::DefaultBlock,\n+                                span: span,\n+                            });\n+                            expr_block(lctx, blk)\n+                        }\n+                        _ => lower_expr(lctx, els),\n+                    }\n+                });\n+\n+                hir::ExprIf(lower_expr(lctx, cond),\n+                            lower_block(lctx, blk),\n+                            else_opt)\n             }\n             ExprWhile(ref cond, ref body, opt_ident) => {\n-                hir::ExprWhile(lower_expr(cond), lower_block(body), opt_ident)\n+                hir::ExprWhile(lower_expr(lctx, cond),\n+                               lower_block(lctx, body),\n+                               opt_ident)\n             }\n             ExprLoop(ref body, opt_ident) => {\n-                hir::ExprLoop(lower_block(body), opt_ident)\n+                hir::ExprLoop(lower_block(lctx, body), opt_ident)\n             }\n-            ExprMatch(ref expr, ref arms, ref source) => {\n-                hir::ExprMatch(lower_expr(expr),\n-                               arms.iter().map(|x| lower_arm(x)).collect(),\n-                               lower_match_source(source))\n+            ExprMatch(ref expr, ref arms) => {\n+                hir::ExprMatch(lower_expr(lctx, expr),\n+                               arms.iter().map(|x| lower_arm(lctx, x)).collect(),\n+                               hir::MatchSource::Normal)\n             }\n             ExprClosure(capture_clause, ref decl, ref body) => {\n-                hir::ExprClosure(lower_capture_clause(capture_clause),\n-                                 lower_fn_decl(decl),\n-                                 lower_block(body))\n+                hir::ExprClosure(lower_capture_clause(lctx, capture_clause),\n+                                 lower_fn_decl(lctx, decl),\n+                                 lower_block(lctx, body))\n             }\n-            ExprBlock(ref blk) => hir::ExprBlock(lower_block(blk)),\n+            ExprBlock(ref blk) => hir::ExprBlock(lower_block(lctx, blk)),\n             ExprAssign(ref el, ref er) => {\n-                hir::ExprAssign(lower_expr(el), lower_expr(er))\n+                hir::ExprAssign(lower_expr(lctx, el), lower_expr(lctx, er))\n             }\n             ExprAssignOp(op, ref el, ref er) => {\n-                hir::ExprAssignOp(lower_binop(op), lower_expr(el), lower_expr(er))\n+                hir::ExprAssignOp(lower_binop(lctx, op),\n+                                  lower_expr(lctx, el),\n+                                  lower_expr(lctx, er))\n             }\n             ExprField(ref el, ident) => {\n-                hir::ExprField(lower_expr(el), respan(ident.span, ident.node.name))\n+                hir::ExprField(lower_expr(lctx, el),\n+                               respan(ident.span, ident.node.name))\n             }\n             ExprTupField(ref el, ident) => {\n-                hir::ExprTupField(lower_expr(el), ident)\n+                hir::ExprTupField(lower_expr(lctx, el), ident)\n             }\n             ExprIndex(ref el, ref er) => {\n-                hir::ExprIndex(lower_expr(el), lower_expr(er))\n+                hir::ExprIndex(lower_expr(lctx, el), lower_expr(lctx, er))\n             }\n             ExprRange(ref e1, ref e2) => {\n-                hir::ExprRange(e1.as_ref().map(|x| lower_expr(x)),\n-                               e2.as_ref().map(|x| lower_expr(x)))\n+                hir::ExprRange(e1.as_ref().map(|x| lower_expr(lctx, x)),\n+                               e2.as_ref().map(|x| lower_expr(lctx, x)))\n             }\n             ExprPath(ref qself, ref path) => {\n                 let qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n                     hir::QSelf {\n-                        ty: lower_ty(ty),\n+                        ty: lower_ty(lctx, ty),\n                         position: position,\n                     }\n                 });\n-                hir::ExprPath(qself, lower_path(path))\n+                hir::ExprPath(qself, lower_path(lctx, path))\n             }\n             ExprBreak(opt_ident) => hir::ExprBreak(opt_ident),\n             ExprAgain(opt_ident) => hir::ExprAgain(opt_ident),\n-            ExprRet(ref e) => hir::ExprRet(e.as_ref().map(|x| lower_expr(x))),\n+            ExprRet(ref e) => hir::ExprRet(e.as_ref().map(|x| lower_expr(lctx, x))),\n             ExprInlineAsm(InlineAsm {\n                     ref inputs,\n                     ref outputs,\n@@ -834,11 +1179,11 @@ pub fn lower_expr(e: &Expr) -> P<hir::Expr> {\n                     expn_id,\n                 }) => hir::ExprInlineAsm(hir::InlineAsm {\n                 inputs: inputs.iter()\n-                              .map(|&(ref c, ref input)| (c.clone(), lower_expr(input)))\n+                              .map(|&(ref c, ref input)| (c.clone(), lower_expr(lctx, input)))\n                               .collect(),\n                 outputs: outputs.iter()\n                                 .map(|&(ref c, ref out, ref is_rw)| {\n-                                    (c.clone(), lower_expr(out), *is_rw)\n+                                    (c.clone(), lower_expr(lctx, out), *is_rw)\n                                 })\n                                 .collect(),\n                 asm: asm.clone(),\n@@ -850,119 +1195,670 @@ pub fn lower_expr(e: &Expr) -> P<hir::Expr> {\n                 expn_id: expn_id,\n             }),\n             ExprStruct(ref path, ref fields, ref maybe_expr) => {\n-                hir::ExprStruct(lower_path(path),\n-                                fields.iter().map(|x| lower_field(x)).collect(),\n-                                maybe_expr.as_ref().map(|x| lower_expr(x)))\n+                hir::ExprStruct(lower_path(lctx, path),\n+                                fields.iter().map(|x| lower_field(lctx, x)).collect(),\n+                                maybe_expr.as_ref().map(|x| lower_expr(lctx, x)))\n             }\n             ExprParen(ref ex) => {\n-                return lower_expr(ex);\n+                return lower_expr(lctx, ex);\n+            }\n+\n+            // Desugar ExprIfLet\n+            // From: `if let <pat> = <sub_expr> <body> [<else_opt>]`\n+            ExprIfLet(ref pat, ref sub_expr, ref body, ref else_opt) => {\n+                // to:\n+                //\n+                //   match <sub_expr> {\n+                //     <pat> => <body>,\n+                //     [_ if <else_opt_if_cond> => <else_opt_if_body>,]\n+                //     _ => [<else_opt> | ()]\n+                //   }\n+\n+                let _old_cached = CachedIdSetter::new(lctx, e.id);\n+\n+                // `<pat> => <body>`\n+                let pat_arm = {\n+                    let body_expr = expr_block(lctx, lower_block(lctx, body));\n+                    arm(vec![lower_pat(lctx, pat)], body_expr)\n+                };\n+\n+                // `[_ if <else_opt_if_cond> => <else_opt_if_body>,]`\n+                let mut else_opt = else_opt.as_ref().map(|e| lower_expr(lctx, e));\n+                let else_if_arms = {\n+                    let mut arms = vec![];\n+                    loop {\n+                        let else_opt_continue = else_opt.and_then(|els| {\n+                            els.and_then(|els| {\n+                                match els.node {\n+                                    // else if\n+                                    hir::ExprIf(cond, then, else_opt) => {\n+                                        let pat_under = pat_wild(lctx, e.span);\n+                                        arms.push(hir::Arm {\n+                                            attrs: vec![],\n+                                            pats: vec![pat_under],\n+                                            guard: Some(cond),\n+                                            body: expr_block(lctx, then),\n+                                        });\n+                                        else_opt.map(|else_opt| (else_opt, true))\n+                                    }\n+                                    _ => Some((P(els), false)),\n+                                }\n+                            })\n+                        });\n+                        match else_opt_continue {\n+                            Some((e, true)) => {\n+                                else_opt = Some(e);\n+                            }\n+                            Some((e, false)) => {\n+                                else_opt = Some(e);\n+                                break;\n+                            }\n+                            None => {\n+                                else_opt = None;\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    arms\n+                };\n+\n+                let contains_else_clause = else_opt.is_some();\n+\n+                // `_ => [<else_opt> | ()]`\n+                let else_arm = {\n+                    let pat_under = pat_wild(lctx, e.span);\n+                    let else_expr = else_opt.unwrap_or_else(|| expr_tuple(lctx, e.span, vec![]));\n+                    arm(vec![pat_under], else_expr)\n+                };\n+\n+                let mut arms = Vec::with_capacity(else_if_arms.len() + 2);\n+                arms.push(pat_arm);\n+                arms.extend(else_if_arms);\n+                arms.push(else_arm);\n+\n+                let match_expr = expr(lctx,\n+                                      e.span,\n+                                      hir::ExprMatch(lower_expr(lctx, sub_expr),\n+                                                     arms,\n+                                                     hir::MatchSource::IfLetDesugar {\n+                                                         contains_else_clause: contains_else_clause,\n+                                                     }));\n+                return match_expr;\n             }\n-            ExprInPlace(..) |\n-            ExprIfLet(..) |\n-            ExprWhileLet(..) |\n-            ExprForLoop(..) |\n+\n+            // Desugar ExprWhileLet\n+            // From: `[opt_ident]: while let <pat> = <sub_expr> <body>`\n+            ExprWhileLet(ref pat, ref sub_expr, ref body, opt_ident) => {\n+                // to:\n+                //\n+                //   [opt_ident]: loop {\n+                //     match <sub_expr> {\n+                //       <pat> => <body>,\n+                //       _ => break\n+                //     }\n+                //   }\n+\n+                let _old_cached = CachedIdSetter::new(lctx, e.id);\n+\n+                // `<pat> => <body>`\n+                let pat_arm = {\n+                    let body_expr = expr_block(lctx, lower_block(lctx, body));\n+                    arm(vec![lower_pat(lctx, pat)], body_expr)\n+                };\n+\n+                // `_ => break`\n+                let break_arm = {\n+                    let pat_under = pat_wild(lctx, e.span);\n+                    let break_expr = expr_break(lctx, e.span);\n+                    arm(vec![pat_under], break_expr)\n+                };\n+\n+                // `match <sub_expr> { ... }`\n+                let arms = vec![pat_arm, break_arm];\n+                let match_expr = expr(lctx,\n+                                      e.span,\n+                                      hir::ExprMatch(lower_expr(lctx, sub_expr),\n+                                                     arms,\n+                                                     hir::MatchSource::WhileLetDesugar));\n+\n+                // `[opt_ident]: loop { ... }`\n+                let loop_block = block_expr(lctx, match_expr);\n+                return expr(lctx, e.span, hir::ExprLoop(loop_block, opt_ident));\n+            }\n+\n+            // Desugar ExprForLoop\n+            // From: `[opt_ident]: for <pat> in <head> <body>`\n+            ExprForLoop(ref pat, ref head, ref body, opt_ident) => {\n+                // to:\n+                //\n+                //   {\n+                //     let result = match ::std::iter::IntoIterator::into_iter(<head>) {\n+                //       mut iter => {\n+                //         [opt_ident]: loop {\n+                //           match ::std::iter::Iterator::next(&mut iter) {\n+                //             ::std::option::Option::Some(<pat>) => <body>,\n+                //             ::std::option::Option::None => break\n+                //           }\n+                //         }\n+                //       }\n+                //     };\n+                //     result\n+                //   }\n+\n+                let _old_cached = CachedIdSetter::new(lctx, e.id);\n+\n+                // expand <head>\n+                let head = lower_expr(lctx, head);\n+\n+                let iter = lctx.str_to_ident(\"iter\");\n+\n+                // `::std::option::Option::Some(<pat>) => <body>`\n+                let pat_arm = {\n+                    let body_block = lower_block(lctx, body);\n+                    let body_span = body_block.span;\n+                    let body_expr = P(hir::Expr {\n+                        id: lctx.next_id(),\n+                        node: hir::ExprBlock(body_block),\n+                        span: body_span,\n+                    });\n+                    let pat = lower_pat(lctx, pat);\n+                    let some_pat = pat_some(lctx, e.span, pat);\n+\n+                    arm(vec![some_pat], body_expr)\n+                };\n+\n+                // `::std::option::Option::None => break`\n+                let break_arm = {\n+                    let break_expr = expr_break(lctx, e.span);\n+\n+                    arm(vec![pat_none(lctx, e.span)], break_expr)\n+                };\n+\n+                // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n+                let match_expr = {\n+                    let next_path = {\n+                        let strs = std_path(lctx, &[\"iter\", \"Iterator\", \"next\"]);\n+\n+                        path_global(e.span, strs)\n+                    };\n+                    let ref_mut_iter = expr_mut_addr_of(lctx,\n+                                                        e.span,\n+                                                        expr_ident(lctx, e.span, iter));\n+                    let next_expr = expr_call(lctx,\n+                                              e.span,\n+                                              expr_path(lctx, next_path),\n+                                              vec![ref_mut_iter]);\n+                    let arms = vec![pat_arm, break_arm];\n+\n+                    expr(lctx,\n+                         e.span,\n+                         hir::ExprMatch(next_expr, arms, hir::MatchSource::ForLoopDesugar))\n+                };\n+\n+                // `[opt_ident]: loop { ... }`\n+                let loop_block = block_expr(lctx, match_expr);\n+                let loop_expr = expr(lctx, e.span, hir::ExprLoop(loop_block, opt_ident));\n+\n+                // `mut iter => { ... }`\n+                let iter_arm = {\n+                    let iter_pat = pat_ident_binding_mode(lctx,\n+                                                          e.span,\n+                                                          iter,\n+                                                          hir::BindByValue(hir::MutMutable));\n+                    arm(vec![iter_pat], loop_expr)\n+                };\n+\n+                // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n+                let into_iter_expr = {\n+                    let into_iter_path = {\n+                        let strs = std_path(lctx, &[\"iter\", \"IntoIterator\", \"into_iter\"]);\n+\n+                        path_global(e.span, strs)\n+                    };\n+\n+                    expr_call(lctx,\n+                              e.span,\n+                              expr_path(lctx, into_iter_path),\n+                              vec![head])\n+                };\n+\n+                let match_expr = expr_match(lctx, e.span, into_iter_expr, vec![iter_arm]);\n+\n+                // `{ let result = ...; result }`\n+                let result_ident = lctx.str_to_ident(\"result\");\n+                return expr_block(lctx,\n+                                  block_all(lctx,\n+                                            e.span,\n+                                            vec![stmt_let(lctx,\n+                                                          e.span,\n+                                                          false,\n+                                                          result_ident,\n+                                                          match_expr)],\n+                                            Some(expr_ident(lctx, e.span, result_ident))))\n+            }\n+\n             ExprMac(_) => panic!(\"Shouldn't exist here\"),\n         },\n         span: e.span,\n     })\n }\n \n-pub fn lower_stmt(s: &Stmt) -> P<hir::Stmt> {\n+pub fn lower_stmt(_lctx: &LoweringContext, s: &Stmt) -> P<hir::Stmt> {\n     match s.node {\n         StmtDecl(ref d, id) => {\n             P(Spanned {\n-                node: hir::StmtDecl(lower_decl(d), id),\n+                node: hir::StmtDecl(lower_decl(_lctx, d), id),\n                 span: s.span,\n             })\n         }\n         StmtExpr(ref e, id) => {\n             P(Spanned {\n-                node: hir::StmtExpr(lower_expr(e), id),\n+                node: hir::StmtExpr(lower_expr(_lctx, e), id),\n                 span: s.span,\n             })\n         }\n         StmtSemi(ref e, id) => {\n             P(Spanned {\n-                node: hir::StmtSemi(lower_expr(e), id),\n+                node: hir::StmtSemi(lower_expr(_lctx, e), id),\n                 span: s.span,\n             })\n         }\n         StmtMac(..) => panic!(\"Shouldn't exist here\"),\n     }\n }\n \n-pub fn lower_match_source(m: &MatchSource) -> hir::MatchSource {\n-    match *m {\n-        MatchSource::Normal => hir::MatchSource::Normal,\n-        MatchSource::IfLetDesugar { contains_else_clause } => {\n-            hir::MatchSource::IfLetDesugar { contains_else_clause: contains_else_clause }\n-        }\n-        MatchSource::WhileLetDesugar => hir::MatchSource::WhileLetDesugar,\n-        MatchSource::ForLoopDesugar => hir::MatchSource::ForLoopDesugar,\n-    }\n-}\n-\n-pub fn lower_capture_clause(c: CaptureClause) -> hir::CaptureClause {\n+pub fn lower_capture_clause(_lctx: &LoweringContext, c: CaptureClause) -> hir::CaptureClause {\n     match c {\n         CaptureByValue => hir::CaptureByValue,\n         CaptureByRef => hir::CaptureByRef,\n     }\n }\n \n-pub fn lower_visibility(v: Visibility) -> hir::Visibility {\n+pub fn lower_visibility(_lctx: &LoweringContext, v: Visibility) -> hir::Visibility {\n     match v {\n         Public => hir::Public,\n         Inherited => hir::Inherited,\n     }\n }\n \n-pub fn lower_block_check_mode(b: &BlockCheckMode) -> hir::BlockCheckMode {\n+pub fn lower_block_check_mode(_lctx: &LoweringContext, b: &BlockCheckMode) -> hir::BlockCheckMode {\n     match *b {\n         DefaultBlock => hir::DefaultBlock,\n-        UnsafeBlock(u) => hir::UnsafeBlock(lower_unsafe_source(u)),\n-        PushUnsafeBlock(u) => hir::PushUnsafeBlock(lower_unsafe_source(u)),\n-        PopUnsafeBlock(u) => hir::PopUnsafeBlock(lower_unsafe_source(u)),\n+        UnsafeBlock(u) => hir::UnsafeBlock(lower_unsafe_source(_lctx, u)),\n+        PushUnsafeBlock(u) => hir::PushUnsafeBlock(lower_unsafe_source(_lctx, u)),\n+        PopUnsafeBlock(u) => hir::PopUnsafeBlock(lower_unsafe_source(_lctx, u)),\n     }\n }\n \n-pub fn lower_pat_wild_kind(p: PatWildKind) -> hir::PatWildKind {\n+pub fn lower_pat_wild_kind(_lctx: &LoweringContext, p: PatWildKind) -> hir::PatWildKind {\n     match p {\n         PatWildSingle => hir::PatWildSingle,\n         PatWildMulti => hir::PatWildMulti,\n     }\n }\n \n-pub fn lower_binding_mode(b: &BindingMode) -> hir::BindingMode {\n+pub fn lower_binding_mode(_lctx: &LoweringContext, b: &BindingMode) -> hir::BindingMode {\n     match *b {\n-        BindByRef(m) => hir::BindByRef(lower_mutability(m)),\n-        BindByValue(m) => hir::BindByValue(lower_mutability(m)),\n+        BindByRef(m) => hir::BindByRef(lower_mutability(_lctx, m)),\n+        BindByValue(m) => hir::BindByValue(lower_mutability(_lctx, m)),\n     }\n }\n \n-pub fn lower_struct_field_kind(s: &StructFieldKind) -> hir::StructFieldKind {\n+pub fn lower_struct_field_kind(_lctx: &LoweringContext,\n+                               s: &StructFieldKind)\n+                               -> hir::StructFieldKind {\n     match *s {\n-        NamedField(ident, vis) => hir::NamedField(ident.name, lower_visibility(vis)),\n-        UnnamedField(vis) => hir::UnnamedField(lower_visibility(vis)),\n+        NamedField(ident, vis) => hir::NamedField(ident.name, lower_visibility(_lctx, vis)),\n+        UnnamedField(vis) => hir::UnnamedField(lower_visibility(_lctx, vis)),\n     }\n }\n \n-pub fn lower_unsafe_source(u: UnsafeSource) -> hir::UnsafeSource {\n+pub fn lower_unsafe_source(_lctx: &LoweringContext, u: UnsafeSource) -> hir::UnsafeSource {\n     match u {\n         CompilerGenerated => hir::CompilerGenerated,\n         UserProvided => hir::UserProvided,\n     }\n }\n \n-pub fn lower_impl_polarity(i: ImplPolarity) -> hir::ImplPolarity {\n+pub fn lower_impl_polarity(_lctx: &LoweringContext, i: ImplPolarity) -> hir::ImplPolarity {\n     match i {\n         ImplPolarity::Positive => hir::ImplPolarity::Positive,\n         ImplPolarity::Negative => hir::ImplPolarity::Negative,\n     }\n }\n \n-pub fn lower_trait_bound_modifier(f: TraitBoundModifier) -> hir::TraitBoundModifier {\n+pub fn lower_trait_bound_modifier(_lctx: &LoweringContext,\n+                                  f: TraitBoundModifier)\n+                                  -> hir::TraitBoundModifier {\n     match f {\n         TraitBoundModifier::None => hir::TraitBoundModifier::None,\n         TraitBoundModifier::Maybe => hir::TraitBoundModifier::Maybe,\n     }\n }\n+\n+// Helper methods for building HIR.\n+\n+fn arm(pats: Vec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n+    hir::Arm {\n+        attrs: vec!(),\n+        pats: pats,\n+        guard: None,\n+        body: expr,\n+    }\n+}\n+\n+fn expr_break(lctx: &LoweringContext, span: Span) -> P<hir::Expr> {\n+    expr(lctx, span, hir::ExprBreak(None))\n+}\n+\n+fn expr_call(lctx: &LoweringContext,\n+             span: Span,\n+             e: P<hir::Expr>,\n+             args: Vec<P<hir::Expr>>)\n+             -> P<hir::Expr> {\n+    expr(lctx, span, hir::ExprCall(e, args))\n+}\n+\n+fn expr_ident(lctx: &LoweringContext, span: Span, id: Ident) -> P<hir::Expr> {\n+    expr_path(lctx, path_ident(span, id))\n+}\n+\n+fn expr_mut_addr_of(lctx: &LoweringContext, span: Span, e: P<hir::Expr>) -> P<hir::Expr> {\n+    expr(lctx, span, hir::ExprAddrOf(hir::MutMutable, e))\n+}\n+\n+fn expr_path(lctx: &LoweringContext, path: hir::Path) -> P<hir::Expr> {\n+    expr(lctx, path.span, hir::ExprPath(None, path))\n+}\n+\n+fn expr_match(lctx: &LoweringContext,\n+              span: Span,\n+              arg: P<hir::Expr>,\n+              arms: Vec<hir::Arm>)\n+              -> P<hir::Expr> {\n+    expr(lctx,\n+         span,\n+         hir::ExprMatch(arg, arms, hir::MatchSource::Normal))\n+}\n+\n+fn expr_block(lctx: &LoweringContext, b: P<hir::Block>) -> P<hir::Expr> {\n+    expr(lctx, b.span, hir::ExprBlock(b))\n+}\n+\n+fn expr_tuple(lctx: &LoweringContext, sp: Span, exprs: Vec<P<hir::Expr>>) -> P<hir::Expr> {\n+    expr(lctx, sp, hir::ExprTup(exprs))\n+}\n+\n+fn expr(lctx: &LoweringContext, span: Span, node: hir::Expr_) -> P<hir::Expr> {\n+    P(hir::Expr {\n+        id: lctx.next_id(),\n+        node: node,\n+        span: span,\n+    })\n+}\n+\n+fn stmt_let(lctx: &LoweringContext,\n+            sp: Span,\n+            mutbl: bool,\n+            ident: Ident,\n+            ex: P<hir::Expr>)\n+            -> P<hir::Stmt> {\n+    let pat = if mutbl {\n+        pat_ident_binding_mode(lctx, sp, ident, hir::BindByValue(hir::MutMutable))\n+    } else {\n+        pat_ident(lctx, sp, ident)\n+    };\n+    let local = P(hir::Local {\n+        pat: pat,\n+        ty: None,\n+        init: Some(ex),\n+        id: lctx.next_id(),\n+        span: sp,\n+    });\n+    let decl = respan(sp, hir::DeclLocal(local));\n+    P(respan(sp, hir::StmtDecl(P(decl), lctx.next_id())))\n+}\n+\n+fn block_expr(lctx: &LoweringContext, expr: P<hir::Expr>) -> P<hir::Block> {\n+    block_all(lctx, expr.span, Vec::new(), Some(expr))\n+}\n+\n+fn block_all(lctx: &LoweringContext,\n+             span: Span,\n+             stmts: Vec<P<hir::Stmt>>,\n+             expr: Option<P<hir::Expr>>)\n+             -> P<hir::Block> {\n+    P(hir::Block {\n+        stmts: stmts,\n+        expr: expr,\n+        id: lctx.next_id(),\n+        rules: hir::DefaultBlock,\n+        span: span,\n+    })\n+}\n+\n+fn pat_some(lctx: &LoweringContext, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n+    let some = std_path(lctx, &[\"option\", \"Option\", \"Some\"]);\n+    let path = path_global(span, some);\n+    pat_enum(lctx, span, path, vec!(pat))\n+}\n+\n+fn pat_none(lctx: &LoweringContext, span: Span) -> P<hir::Pat> {\n+    let none = std_path(lctx, &[\"option\", \"Option\", \"None\"]);\n+    let path = path_global(span, none);\n+    pat_enum(lctx, span, path, vec![])\n+}\n+\n+fn pat_enum(lctx: &LoweringContext,\n+            span: Span,\n+            path: hir::Path,\n+            subpats: Vec<P<hir::Pat>>)\n+            -> P<hir::Pat> {\n+    let pt = hir::PatEnum(path, Some(subpats));\n+    pat(lctx, span, pt)\n+}\n+\n+fn pat_ident(lctx: &LoweringContext, span: Span, ident: Ident) -> P<hir::Pat> {\n+    pat_ident_binding_mode(lctx, span, ident, hir::BindByValue(hir::MutImmutable))\n+}\n+\n+fn pat_ident_binding_mode(lctx: &LoweringContext,\n+                          span: Span,\n+                          ident: Ident,\n+                          bm: hir::BindingMode)\n+                          -> P<hir::Pat> {\n+    let pat_ident = hir::PatIdent(bm,\n+                                  Spanned {\n+                                      span: span,\n+                                      node: ident,\n+                                  },\n+                                  None);\n+    pat(lctx, span, pat_ident)\n+}\n+\n+fn pat_wild(lctx: &LoweringContext, span: Span) -> P<hir::Pat> {\n+    pat(lctx, span, hir::PatWild(hir::PatWildSingle))\n+}\n+\n+fn pat(lctx: &LoweringContext, span: Span, pat: hir::Pat_) -> P<hir::Pat> {\n+    P(hir::Pat {\n+        id: lctx.next_id(),\n+        node: pat,\n+        span: span,\n+    })\n+}\n+\n+fn path_ident(span: Span, id: Ident) -> hir::Path {\n+    path(span, vec!(id))\n+}\n+\n+fn path(span: Span, strs: Vec<Ident>) -> hir::Path {\n+    path_all(span, false, strs, Vec::new(), Vec::new(), Vec::new())\n+}\n+\n+fn path_global(span: Span, strs: Vec<Ident>) -> hir::Path {\n+    path_all(span, true, strs, Vec::new(), Vec::new(), Vec::new())\n+}\n+\n+fn path_all(sp: Span,\n+            global: bool,\n+            mut idents: Vec<Ident>,\n+            lifetimes: Vec<hir::Lifetime>,\n+            types: Vec<P<hir::Ty>>,\n+            bindings: Vec<P<hir::TypeBinding>>)\n+            -> hir::Path {\n+    let last_identifier = idents.pop().unwrap();\n+    let mut segments: Vec<hir::PathSegment> = idents.into_iter()\n+                                                    .map(|ident| {\n+                                                        hir::PathSegment {\n+                                                            identifier: ident,\n+                                                            parameters: hir::PathParameters::none(),\n+                                                        }\n+                                                    })\n+                                                    .collect();\n+    segments.push(hir::PathSegment {\n+        identifier: last_identifier,\n+        parameters: hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n+            lifetimes: lifetimes,\n+            types: OwnedSlice::from_vec(types),\n+            bindings: OwnedSlice::from_vec(bindings),\n+        }),\n+    });\n+    hir::Path {\n+        span: sp,\n+        global: global,\n+        segments: segments,\n+    }\n+}\n+\n+fn std_path(lctx: &LoweringContext, components: &[&str]) -> Vec<Ident> {\n+    let mut v = Vec::new();\n+    if let Some(s) = lctx.crate_root {\n+        v.push(str_to_ident(s));\n+    }\n+    v.extend(components.iter().map(|s| str_to_ident(s)));\n+    return v\n+}\n+\n+// Given suffix [\"b\",\"c\",\"d\"], returns path `::std::b::c::d` when\n+// `fld.cx.use_std`, and `::core::b::c::d` otherwise.\n+fn core_path(lctx: &LoweringContext, span: Span, components: &[&str]) -> hir::Path {\n+    let idents = std_path(lctx, components);\n+    path_global(span, idents)\n+}\n+\n+fn signal_block_expr(lctx: &LoweringContext,\n+                     stmts: Vec<P<hir::Stmt>>,\n+                     expr: P<hir::Expr>,\n+                     span: Span,\n+                     rule: hir::BlockCheckMode)\n+                     -> P<hir::Expr> {\n+    expr_block(lctx,\n+               P(hir::Block {\n+                   rules: rule,\n+                   span: span,\n+                   id: lctx.next_id(),\n+                   stmts: stmts,\n+                   expr: Some(expr),\n+               }))\n+}\n+\n+\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use syntax::ast::{self, NodeId, NodeIdAssigner};\n+    use syntax::{parse, codemap};\n+    use syntax::fold::Folder;\n+    use std::cell::Cell;\n+\n+    struct MockAssigner {\n+        next_id: Cell<NodeId>,\n+    }\n+\n+    impl MockAssigner {\n+        fn new() -> MockAssigner {\n+            MockAssigner {\n+                next_id: Cell::new(0),\n+            }\n+        }\n+    }\n+\n+    trait FakeExtCtxt {\n+        fn call_site(&self) -> codemap::Span;\n+        fn cfg(&self) -> ast::CrateConfig;\n+        fn ident_of(&self, st: &str) -> ast::Ident;\n+        fn name_of(&self, st: &str) -> ast::Name;\n+        fn parse_sess(&self) -> &parse::ParseSess;\n+    }\n+\n+    impl FakeExtCtxt for parse::ParseSess {\n+        fn call_site(&self) -> codemap::Span {\n+            codemap::Span {\n+                lo: codemap::BytePos(0),\n+                hi: codemap::BytePos(0),\n+                expn_id: codemap::NO_EXPANSION,\n+            }\n+        }\n+        fn cfg(&self) -> ast::CrateConfig { Vec::new() }\n+        fn ident_of(&self, st: &str) -> ast::Ident {\n+            parse::token::str_to_ident(st)\n+        }\n+        fn name_of(&self, st: &str) -> ast::Name {\n+            parse::token::intern(st)\n+        }\n+        fn parse_sess(&self) -> &parse::ParseSess { self }\n+    }\n+\n+    impl NodeIdAssigner for MockAssigner {\n+        fn next_node_id(&self) -> NodeId {\n+            let result = self.next_id.get();\n+            self.next_id.set(result + 1);\n+            result\n+        }\n+\n+        fn peek_node_id(&self) -> NodeId {\n+            self.next_id.get()\n+        }\n+    }\n+\n+    impl Folder for MockAssigner {\n+        fn new_id(&mut self, old_id: NodeId) -> NodeId {\n+            assert_eq!(old_id, ast::DUMMY_NODE_ID);\n+            self.next_node_id()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_preserves_ids() {\n+        let cx = parse::ParseSess::new();\n+        let mut assigner = MockAssigner::new();\n+\n+        let ast_if_let = quote_expr!(&cx, if let Some(foo) = baz { bar(foo); });\n+        let ast_if_let = assigner.fold_expr(ast_if_let);\n+        let ast_while_let = quote_expr!(&cx, while let Some(foo) = baz { bar(foo); });\n+        let ast_while_let = assigner.fold_expr(ast_while_let);\n+        let ast_for = quote_expr!(&cx, for i in 0..10 { foo(i); });\n+        let ast_for = assigner.fold_expr(ast_for);\n+        let ast_in = quote_expr!(&cx, in HEAP { foo() });\n+        let ast_in = assigner.fold_expr(ast_in);\n+\n+        let lctx = LoweringContext::new(&assigner, None);\n+        let hir1 = lower_expr(&lctx, &ast_if_let);\n+        let hir2 = lower_expr(&lctx, &ast_if_let);\n+        assert!(hir1 == hir2);\n+\n+        let hir1 = lower_expr(&lctx, &ast_while_let);\n+        let hir2 = lower_expr(&lctx, &ast_while_let);\n+        assert!(hir1 == hir2);\n+\n+        let hir1 = lower_expr(&lctx, &ast_for);\n+        let hir2 = lower_expr(&lctx, &ast_for);\n+        assert!(hir1 == hir2);\n+\n+        let hir1 = lower_expr(&lctx, &ast_in);\n+        let hir2 = lower_expr(&lctx, &ast_in);\n+        assert!(hir1 == hir2);\n+    }\n+}"}, {"sha": "80b0a984681a310184560b8a41ff2363226f1d66", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -1089,8 +1089,12 @@ impl<'a> State<'a> {\n                                       close_box: bool)\n                                       -> io::Result<()> {\n         match blk.rules {\n-            hir::UnsafeBlock(..) | hir::PushUnsafeBlock(..) => try!(self.word_space(\"unsafe\")),\n-            hir::DefaultBlock | hir::PopUnsafeBlock(..) => (),\n+            hir::UnsafeBlock(..) => try!(self.word_space(\"unsafe\")),\n+            hir::PushUnsafeBlock(..) => try!(self.word_space(\"push_unsafe\")),\n+            hir::PopUnsafeBlock(..) => try!(self.word_space(\"pop_unsafe\")),\n+            hir::PushUnstableBlock => try!(self.word_space(\"push_unstable\")),\n+            hir::PopUnstableBlock => try!(self.word_space(\"pop_unstable\")),\n+            hir::DefaultBlock => (),\n         }\n         try!(self.maybe_print_comment(blk.span.lo));\n         try!(self.ann.pre(self, NodeBlock(blk)));"}, {"sha": "6eee6872be21f1a2bf67bceba23630f78f3b2710", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -363,12 +363,10 @@ impl EarlyLintPass for UnusedParens {\n         let (value, msg, struct_lit_needs_parens) = match e.node {\n             ast::ExprIf(ref cond, _, _) => (cond, \"`if` condition\", true),\n             ast::ExprWhile(ref cond, _, _) => (cond, \"`while` condition\", true),\n-            ast::ExprMatch(ref head, _, source) => match source {\n-                ast::MatchSource::Normal => (head, \"`match` head expression\", true),\n-                ast::MatchSource::IfLetDesugar { .. } => (head, \"`if let` head expression\", true),\n-                ast::MatchSource::WhileLetDesugar => (head, \"`while let` head expression\", true),\n-                ast::MatchSource::ForLoopDesugar => (head, \"`for` head expression\", true),\n-            },\n+            ast::ExprIfLet(_, ref cond, _, _) => (cond, \"`if let` head expression\", true),\n+            ast::ExprWhileLet(_, ref cond, _, _) => (cond, \"`while let` head expression\", true),\n+            ast::ExprForLoop(_, ref cond, _, _) => (cond, \"`for` head expression\", true),\n+            ast::ExprMatch(ref head, _) => (head, \"`match` head expression\", true),\n             ast::ExprRet(Some(ref value)) => (value, \"`return` value\", false),\n             ast::ExprAssign(_, ref value) => (value, \"assigned value\", false),\n             ast::ExprAssignOp(_, _, ref value) => (value, \"assigned value\", false),"}, {"sha": "09825f1f919394439c24477ada884cfba7c387ec", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 50, "deletions": 25, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -47,7 +47,7 @@ use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{path_to_string, ty_to_string};\n use syntax::ptr::P;\n \n-use rustc_front::lowering::lower_expr;\n+use rustc_front::lowering::{lower_expr, LoweringContext};\n \n use super::span_utils::SpanUtils;\n use super::recorder::{Recorder, FmtStrs};\n@@ -76,14 +76,15 @@ pub struct DumpCsvVisitor<'l, 'tcx: 'l> {\n \n impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n     pub fn new(tcx: &'l ty::ctxt<'tcx>,\n+               lcx: &'l LoweringContext<'l>,\n                analysis: &'l ty::CrateAnalysis,\n                output_file: Box<File>)\n                -> DumpCsvVisitor<'l, 'tcx> {\n         let span_utils = SpanUtils::new(&tcx.sess);\n         DumpCsvVisitor {\n             sess: &tcx.sess,\n             tcx: tcx,\n-            save_ctxt: SaveContext::from_span_utils(tcx, span_utils.clone()),\n+            save_ctxt: SaveContext::from_span_utils(tcx, lcx, span_utils.clone()),\n             analysis: analysis,\n             span: span_utils.clone(),\n             fmt: FmtStrs::new(box Recorder {\n@@ -795,6 +796,35 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             _ => visit::walk_pat(self, p),\n         }\n     }\n+\n+\n+    fn process_var_decl(&mut self, p: &ast::Pat, value: String) {\n+        // The local could declare multiple new vars, we must walk the\n+        // pattern and collect them all.\n+        let mut collector = PathCollector::new();\n+        collector.visit_pat(&p);\n+        self.visit_pat(&p);\n+\n+        for &(id, ref p, immut, _) in &collector.collected_paths {\n+            let value = if immut == ast::MutImmutable {\n+                value.to_string()\n+            } else {\n+                \"<mutable>\".to_string()\n+            };\n+            let types = self.tcx.node_types();\n+            let typ = types.get(&id).unwrap().to_string();\n+            // Get the span only for the name of the variable (I hope the path\n+            // is only ever a variable name, but who knows?).\n+            let sub_span = self.span.span_for_last_ident(p.span);\n+            // Rust uses the id of the pattern for var lookups, so we'll use it too.\n+            self.fmt.variable_str(p.span,\n+                                  sub_span,\n+                                  id,\n+                                  &path_to_string(p),\n+                                  &value,\n+                                  &typ);\n+        }\n+    }\n }\n \n impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n@@ -1035,7 +1065,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 visit::walk_expr(self, ex);\n             }\n             ast::ExprStruct(ref path, ref fields, ref base) => {\n-                let hir_expr = lower_expr(ex);\n+                let hir_expr = lower_expr(self.save_ctxt.lcx, ex);\n                 let adt = self.tcx.expr_ty(&hir_expr).ty_adt_def().unwrap();\n                 let def = self.tcx.resolve_expr(&hir_expr);\n                 self.process_struct_lit(ex, path, fields, adt.variant_of_def(def), base)\n@@ -1064,7 +1094,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n \n                 self.visit_expr(&**sub_ex);\n \n-                let hir_node = lower_expr(sub_ex);\n+                let hir_node = lower_expr(self.save_ctxt.lcx, sub_ex);\n                 let ty = &self.tcx.expr_ty_adjusted(&hir_node).sty;\n                 match *ty {\n                     ty::TyStruct(def, _) => {\n@@ -1102,6 +1132,20 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 // walk the body\n                 self.nest(ex.id, |v| v.visit_block(&**body));\n             }\n+            ast::ExprForLoop(ref pattern, ref subexpression, ref block, _) |\n+            ast::ExprWhileLet(ref pattern, ref subexpression, ref block, _) => {\n+                let value = self.span.snippet(mk_sp(ex.span.lo, subexpression.span.hi));\n+                self.process_var_decl(pattern, value);\n+                visit::walk_expr(self, subexpression);\n+                visit::walk_block(self, block);\n+            }\n+            ast::ExprIfLet(ref pattern, ref subexpression, ref block, ref opt_else) => {\n+                let value = self.span.snippet(mk_sp(ex.span.lo, subexpression.span.hi));\n+                self.process_var_decl(pattern, value);\n+                visit::walk_expr(self, subexpression);\n+                visit::walk_block(self, block);\n+                opt_else.as_ref().map(|el| visit::walk_expr(self, el));\n+            }\n             _ => {\n                 visit::walk_expr(self, ex)\n             }\n@@ -1179,31 +1223,12 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n             return\n         }\n \n-        // The local could declare multiple new vars, we must walk the\n-        // pattern and collect them all.\n-        let mut collector = PathCollector::new();\n-        collector.visit_pat(&l.pat);\n-        self.visit_pat(&l.pat);\n-\n         let value = self.span.snippet(l.span);\n-\n-        for &(id, ref p, immut, _) in &collector.collected_paths {\n-            let value = if immut == ast::MutImmutable {\n-                value.to_string()\n-            } else {\n-                \"<mutable>\".to_string()\n-            };\n-            let types = self.tcx.node_types();\n-            let typ = types.get(&id).unwrap().to_string();\n-            // Get the span only for the name of the variable (I hope the path\n-            // is only ever a variable name, but who knows?).\n-            let sub_span = self.span.span_for_last_ident(p.span);\n-            // Rust uses the id of the pattern for var lookups, so we'll use it too.\n-            self.fmt.variable_str(p.span, sub_span, id, &path_to_string(p), &value, &typ);\n-        }\n+        self.process_var_decl(&l.pat, value);\n \n         // Just walk the initialiser and type (don't want to walk the pattern again).\n         walk_list!(self, visit_ty, &l.ty);\n         walk_list!(self, visit_expr, &l.init);\n     }\n }\n+"}, {"sha": "72f665f63bf9efbbb758feba70042c27c349b843", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -38,6 +38,7 @@ mod dump_csv;\n \n pub struct SaveContext<'l, 'tcx: 'l> {\n     tcx: &'l ty::ctxt<'tcx>,\n+    lcx: &'l lowering::LoweringContext<'l>,\n     span_utils: SpanUtils<'l>,\n }\n \n@@ -176,16 +177,20 @@ pub struct MethodCallData {\n \n \n impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n-    pub fn new(tcx: &'l ty::ctxt<'tcx>) -> SaveContext<'l, 'tcx> {\n+    pub fn new(tcx: &'l ty::ctxt<'tcx>,\n+               lcx: &'l lowering::LoweringContext<'l>)\n+               -> SaveContext<'l, 'tcx> {\n         let span_utils = SpanUtils::new(&tcx.sess);\n-        SaveContext::from_span_utils(tcx, span_utils)\n+        SaveContext::from_span_utils(tcx, lcx, span_utils)\n     }\n \n     pub fn from_span_utils(tcx: &'l ty::ctxt<'tcx>,\n+                           lcx: &'l lowering::LoweringContext<'l>,\n                            span_utils: SpanUtils<'l>)\n                            -> SaveContext<'l, 'tcx> {\n         SaveContext {\n             tcx: tcx,\n+            lcx: lcx,\n             span_utils: span_utils,\n         }\n     }\n@@ -454,7 +459,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_expr_data(&self, expr: &ast::Expr) -> Option<Data> {\n         match expr.node {\n             ast::ExprField(ref sub_ex, ident) => {\n-                let hir_node = lowering::lower_expr(sub_ex);\n+                let hir_node = lowering::lower_expr(self.lcx, sub_ex);\n                 let ty = &self.tcx.expr_ty_adjusted(&hir_node).sty;\n                 match *ty {\n                     ty::TyStruct(def, _) => {\n@@ -474,7 +479,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }\n             }\n             ast::ExprStruct(ref path, _, _) => {\n-                let hir_node = lowering::lower_expr(expr);\n+                let hir_node = lowering::lower_expr(self.lcx, expr);\n                 let ty = &self.tcx.expr_ty_adjusted(&hir_node).sty;\n                 match *ty {\n                     ty::TyStruct(def, _) => {\n@@ -705,10 +710,11 @@ impl<'v> Visitor<'v> for PathCollector {\n     }\n }\n \n-pub fn process_crate(tcx: &ty::ctxt,\n-                     krate: &ast::Crate,\n-                     analysis: &ty::CrateAnalysis,\n-                     odir: Option<&Path>) {\n+pub fn process_crate<'l, 'tcx>(tcx: &'l ty::ctxt<'tcx>,\n+                               lcx: &'l lowering::LoweringContext<'l>,\n+                               krate: &ast::Crate,\n+                               analysis: &ty::CrateAnalysis,\n+                               odir: Option<&Path>) {\n     if generated_code(krate.span) {\n         return;\n     }\n@@ -757,7 +763,7 @@ pub fn process_crate(tcx: &ty::ctxt,\n     };\n     root_path.pop();\n \n-    let mut visitor = dump_csv::DumpCsvVisitor::new(tcx, analysis, output_file);\n+    let mut visitor = dump_csv::DumpCsvVisitor::new(tcx, lcx, analysis, output_file);\n \n     visitor.dump_crate_info(&cratename, krate);\n     visit::walk_crate(&mut visitor, krate);"}, {"sha": "f6b007018b88a6b3b97c83ef7d3eace3715ae67d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -269,7 +269,7 @@ impl UnsafetyState {\n                         (unsafety, blk.id, self.unsafe_push_count.checked_sub(1).unwrap()),\n                     hir::UnsafeBlock(..) =>\n                         (hir::Unsafety::Unsafe, blk.id, self.unsafe_push_count),\n-                    hir::DefaultBlock =>\n+                    hir::DefaultBlock | hir::PushUnstableBlock | hir:: PopUnstableBlock =>\n                         (unsafety, self.def, self.unsafe_push_count),\n                 };\n                 UnsafetyState{ def: def,\n@@ -1810,7 +1810,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // There is a possibility that this algorithm will have to run an arbitrary number of times\n         // to terminate so we bound it by the compiler's recursion limit.\n-        for _ in (0..self.tcx().sess.recursion_limit.get()) {\n+        for _ in 0..self.tcx().sess.recursion_limit.get() {\n             // First we try to solve all obligations, it is possible that the last iteration\n             // has made it possible to make more progress.\n             self.select_obligations_where_possible();"}, {"sha": "776917d6724d82632fb002eeebee8ce1f487edec", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -19,7 +19,7 @@ use rustc::lint;\n use rustc::util::nodemap::DefIdSet;\n use rustc_trans::back::link;\n use rustc_resolve as resolve;\n-use rustc_front::lowering::lower_crate;\n+use rustc_front::lowering::{lower_crate, LoweringContext};\n \n use syntax::{ast, codemap, diagnostic};\n use syntax::feature_gate::UnstableFeatures;\n@@ -37,7 +37,7 @@ pub use rustc::session::search_paths::SearchPaths;\n /// Are we generating documentation (`Typed`) or tests (`NotTyped`)?\n pub enum MaybeTyped<'a, 'tcx: 'a> {\n     Typed(&'a ty::ctxt<'tcx>),\n-    NotTyped(session::Session)\n+    NotTyped(&'a session::Session)\n }\n \n pub type ExternalPaths = RefCell<Option<HashMap<DefId,\n@@ -135,11 +135,12 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n \n     let krate = driver::assign_node_ids(&sess, krate);\n     // Lower ast -> hir.\n-    let mut hir_forest = hir_map::Forest::new(lower_crate(&krate));\n+    let lcx = LoweringContext::new(&sess, Some(&krate));\n+    let mut hir_forest = hir_map::Forest::new(lower_crate(&lcx, &krate));\n     let arenas = ty::CtxtArenas::new();\n     let hir_map = driver::make_map(&sess, &mut hir_forest);\n \n-    driver::phase_3_run_analysis_passes(sess,\n+    driver::phase_3_run_analysis_passes(&sess,\n                                         hir_map,\n                                         &arenas,\n                                         name,\n@@ -194,5 +195,5 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n         *analysis.inlined.borrow_mut() = map;\n         analysis.deref_trait_did = ctxt.deref_trait_did.get();\n         (krate, analysis)\n-    }).1\n+    })\n }"}, {"sha": "d6114737ab5a2bfab0eadcb8b44453457267ef18", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -26,7 +26,7 @@ use rustc::front::map as hir_map;\n use rustc::session::{self, config};\n use rustc::session::config::{get_unstable_features_setting, OutputType};\n use rustc::session::search_paths::{SearchPaths, PathKind};\n-use rustc_front::lowering::lower_crate;\n+use rustc_front::lowering::{lower_crate, LoweringContext};\n use rustc_back::tempdir::TempDir;\n use rustc_driver::{driver, Compilation};\n use syntax::codemap::CodeMap;\n@@ -83,7 +83,8 @@ pub fn run(input: &str,\n                                                      \"rustdoc-test\", None)\n         .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n     let krate = driver::assign_node_ids(&sess, krate);\n-    let krate = lower_crate(&krate);\n+    let lcx = LoweringContext::new(&sess, Some(&krate));\n+    let krate = lower_crate(&lcx, &krate);\n \n     let opts = scrape_test_config(&krate);\n \n@@ -92,7 +93,7 @@ pub fn run(input: &str,\n \n     let ctx = core::DocContext {\n         map: &map,\n-        maybe_typed: core::NotTyped(sess),\n+        maybe_typed: core::NotTyped(&sess),\n         input: input,\n         external_paths: RefCell::new(Some(HashMap::new())),\n         external_traits: RefCell::new(None),"}, {"sha": "34b99ab8cce1c062a2e604554f8f72e0ac6d6c35", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -375,6 +375,11 @@ pub const CRATE_NODE_ID: NodeId = 0;\n /// small, positive ids.\n pub const DUMMY_NODE_ID: NodeId = !0;\n \n+pub trait NodeIdAssigner {\n+    fn next_node_id(&self) -> NodeId;\n+    fn peek_node_id(&self) -> NodeId;\n+}\n+\n /// The AST represents all type param bounds as types.\n /// typeck::collect::compute_bounds matches these against\n /// the \"special\" built-in traits (see middle::lang_items) and\n@@ -850,9 +855,8 @@ pub enum Expr_ {\n     ///\n     /// `'label: loop { block }`\n     ExprLoop(P<Block>, Option<Ident>),\n-    /// A `match` block, with a source that indicates whether or not it is\n-    /// the result of a desugaring, and if so, which kind.\n-    ExprMatch(P<Expr>, Vec<Arm>, MatchSource),\n+    /// A `match` block.\n+    ExprMatch(P<Expr>, Vec<Arm>),\n     /// A closure (for example, `move |a, b, c| {a + b + c}`)\n     ExprClosure(CaptureClause, P<FnDecl>, P<Block>),\n     /// A block (`{ ... }`)\n@@ -931,14 +935,6 @@ pub struct QSelf {\n     pub position: usize\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub enum MatchSource {\n-    Normal,\n-    IfLetDesugar { contains_else_clause: bool },\n-    WhileLetDesugar,\n-    ForLoopDesugar,\n-}\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum CaptureClause {\n     CaptureByValue,"}, {"sha": "a73fd4534c96cc142398d9f0bda62e1e62b517fb", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -29,7 +29,6 @@ use std::io::{self, Read};\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n-use parse::token::intern;\n use ast::Name;\n \n // _____________________________________________________________________________\n@@ -269,28 +268,8 @@ pub enum ExpnFormat {\n     MacroAttribute(Name),\n     /// e.g. `format!()`\n     MacroBang(Name),\n-    /// Syntax sugar expansion performed by the compiler (libsyntax::expand).\n-    CompilerExpansion(CompilerExpansionFormat),\n }\n \n-#[derive(Clone, Copy, Hash, Debug, PartialEq, Eq)]\n-pub enum CompilerExpansionFormat {\n-    IfLet,\n-    PlacementIn,\n-    WhileLet,\n-    ForLoop,\n-}\n-\n-impl CompilerExpansionFormat {\n-    pub fn name(self) -> &'static str {\n-        match self {\n-            CompilerExpansionFormat::IfLet => \"if let expansion\",\n-            CompilerExpansionFormat::PlacementIn => \"placement-in expansion\",\n-            CompilerExpansionFormat::WhileLet => \"while let expansion\",\n-            CompilerExpansionFormat::ForLoop => \"for loop expansion\",\n-        }\n-    }\n-}\n #[derive(Clone, Hash, Debug)]\n pub struct NameAndSpan {\n     /// The format with which the macro was invoked.\n@@ -310,7 +289,6 @@ impl NameAndSpan {\n         match self.format {\n             ExpnFormat::MacroAttribute(s) => s,\n             ExpnFormat::MacroBang(s) => s,\n-            ExpnFormat::CompilerExpansion(ce) => intern(ce.name()),\n         }\n     }\n }"}, {"sha": "2d266be3242a57c3743157f413f0fe17a867148d", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -225,10 +225,10 @@ fn fold_expr<F>(cx: &mut Context<F>, expr: P<ast::Expr>) -> P<ast::Expr> where\n         fold::noop_fold_expr(ast::Expr {\n             id: id,\n             node: match node {\n-                ast::ExprMatch(m, arms, source) => {\n+                ast::ExprMatch(m, arms) => {\n                     ast::ExprMatch(m, arms.into_iter()\n                                         .filter(|a| (cx.in_cfg)(&a.attrs))\n-                                        .collect(), source)\n+                                        .collect())\n                 }\n                 _ => node\n             },"}, {"sha": "2a8cdf138b0e6fad127e06180fe12e87c85387d4", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -737,7 +737,6 @@ impl EmitterWriter {\n                         let (pre, post) = match ei.callee.format {\n                             codemap::MacroAttribute(..) => (\"#[\", \"]\"),\n                             codemap::MacroBang(..) => (\"\", \"!\"),\n-                            codemap::CompilerExpansion(..) => (\"\", \"\"),\n                         };\n                         // Don't print recursive invocations\n                         if ei.call_site != last_span {"}, {"sha": "6196062b08af15e2e02963d8150b5c2d37c14ee3", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -13,7 +13,7 @@ pub use self::SyntaxExtension::*;\n use ast;\n use ast::Name;\n use codemap;\n-use codemap::{CodeMap, Span, ExpnId, ExpnInfo, NO_EXPANSION, CompilerExpansion};\n+use codemap::{CodeMap, Span, ExpnId, ExpnInfo, NO_EXPANSION};\n use ext;\n use ext::expand;\n use ext::tt::macro_rules;\n@@ -651,10 +651,7 @@ impl<'a> ExtCtxt<'a> {\n                         return None;\n                     }\n                     expn_id = i.call_site.expn_id;\n-                    match i.callee.format {\n-                        CompilerExpansion(..) => (),\n-                        _ => last_macro = Some(i.call_site),\n-                    }\n+                    last_macro = Some(i.call_site);\n                     return Some(());\n                 })\n             }).is_none() {"}, {"sha": "efea85f916252e3ba7679e3d0bb78d4e65b90ad0", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -868,7 +868,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_match(&self, span: Span, arg: P<ast::Expr>, arms: Vec<ast::Arm>) -> P<Expr> {\n-        self.expr(span, ast::ExprMatch(arg, arms, ast::MatchSource::Normal))\n+        self.expr(span, ast::ExprMatch(arg, arms))\n     }\n \n     fn expr_if(&self, span: Span, cond: P<ast::Expr>,"}, {"sha": "b1b4605d5ec6573b9702479f4847174ac9dc23cd", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 72, "deletions": 394, "changes": 466, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -20,53 +20,20 @@ use attr;\n use attr::AttrMetaMethods;\n use codemap;\n use codemap::{Span, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n-use codemap::{CompilerExpansion, CompilerExpansionFormat};\n use ext::base::*;\n use feature_gate::{self, Features, GatedCfg};\n use fold;\n use fold::*;\n use parse;\n use parse::token::{fresh_mark, fresh_name, intern};\n-use parse::token;\n use ptr::P;\n use util::small_vector::SmallVector;\n use visit;\n use visit::Visitor;\n use std_inject;\n \n-// Given suffix [\"b\",\"c\",\"d\"], returns path `::std::b::c::d` when\n-// `fld.cx.use_std`, and `::core::b::c::d` otherwise.\n-fn mk_core_path(fld: &mut MacroExpander,\n-                span: Span,\n-                suffix: &[&'static str]) -> ast::Path {\n-    let idents = fld.cx.std_path(suffix);\n-    fld.cx.path_global(span, idents)\n-}\n \n pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n-    fn push_compiler_expansion(fld: &mut MacroExpander, span: Span,\n-                               expansion_type: CompilerExpansionFormat) {\n-        fld.cx.bt_push(ExpnInfo {\n-            call_site: span,\n-            callee: NameAndSpan {\n-                format: CompilerExpansion(expansion_type),\n-\n-                // This does *not* mean code generated after\n-                // `push_compiler_expansion` is automatically exempt\n-                // from stability lints; must also tag such code with\n-                // an appropriate span from `fld.cx.backtrace()`.\n-                allow_internal_unstable: true,\n-\n-                span: None,\n-            },\n-        });\n-    }\n-\n-    // Sets the expn_id so that we can use unstable methods.\n-    fn allow_unstable(fld: &mut MacroExpander, span: Span) -> Span {\n-        Span { expn_id: fld.cx.backtrace(), ..span }\n-    }\n-\n     let expr_span = e.span;\n     return e.and_then(|ast::Expr {id, node, span}| match node {\n \n@@ -94,368 +61,79 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             })\n         }\n \n-        // Desugar ExprInPlace: `in PLACE { EXPR }`\n         ast::ExprInPlace(placer, value_expr) => {\n-            // to:\n-            //\n-            // let p = PLACE;\n-            // let mut place = Placer::make_place(p);\n-            // let raw_place = Place::pointer(&mut place);\n-            // push_unsafe!({\n-            //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n-            //     InPlace::finalize(place)\n-            // })\n-\n             // Ensure feature-gate is enabled\n             feature_gate::check_for_placement_in(\n                 fld.cx.ecfg.features,\n                 &fld.cx.parse_sess.span_diagnostic,\n                 expr_span);\n \n-            push_compiler_expansion(fld, expr_span, CompilerExpansionFormat::PlacementIn);\n-\n-            let value_span = value_expr.span;\n-            let placer_span = placer.span;\n-\n-            let placer_expr = fld.fold_expr(placer);\n+            let placer = fld.fold_expr(placer);\n             let value_expr = fld.fold_expr(value_expr);\n-\n-            let placer_ident = token::gensym_ident(\"placer\");\n-            let agent_ident = token::gensym_ident(\"place\");\n-            let p_ptr_ident = token::gensym_ident(\"p_ptr\");\n-\n-            let placer = fld.cx.expr_ident(span, placer_ident);\n-            let agent = fld.cx.expr_ident(span, agent_ident);\n-            let p_ptr = fld.cx.expr_ident(span, p_ptr_ident);\n-\n-            let make_place = [\"ops\", \"Placer\", \"make_place\"];\n-            let place_pointer = [\"ops\", \"Place\", \"pointer\"];\n-            let move_val_init = [\"intrinsics\", \"move_val_init\"];\n-            let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n-\n-            let make_call = |fld: &mut MacroExpander, p, args| {\n-                // We feed in the `expr_span` because codemap's span_allows_unstable\n-                // allows the call_site span to inherit the `allow_internal_unstable`\n-                // setting.\n-                let span_unstable = allow_unstable(fld, expr_span);\n-                let path = mk_core_path(fld, span_unstable, p);\n-                let path = fld.cx.expr_path(path);\n-                let expr_span_unstable = allow_unstable(fld, span);\n-                fld.cx.expr_call(expr_span_unstable, path, args)\n-            };\n-\n-            let stmt_let = |fld: &mut MacroExpander, bind, expr| {\n-                fld.cx.stmt_let(placer_span, false, bind, expr)\n-            };\n-            let stmt_let_mut = |fld: &mut MacroExpander, bind, expr| {\n-                fld.cx.stmt_let(placer_span, true, bind, expr)\n-            };\n-\n-            // let placer = <placer_expr> ;\n-            let s1 = stmt_let(fld, placer_ident, placer_expr);\n-\n-            // let mut place = Placer::make_place(placer);\n-            let s2 = {\n-                let call = make_call(fld, &make_place, vec![placer]);\n-                stmt_let_mut(fld, agent_ident, call)\n-            };\n-\n-            // let p_ptr = Place::pointer(&mut place);\n-            let s3 = {\n-                let args = vec![fld.cx.expr_mut_addr_of(placer_span, agent.clone())];\n-                let call = make_call(fld, &place_pointer, args);\n-                stmt_let(fld, p_ptr_ident, call)\n-            };\n-\n-            // pop_unsafe!(EXPR));\n-            let pop_unsafe_expr = pop_unsafe_expr(fld.cx, value_expr, value_span);\n-\n-            // push_unsafe!({\n-            //     ptr::write(p_ptr, pop_unsafe!(<value_expr>));\n-            //     InPlace::finalize(place)\n-            // })\n-            let expr = {\n-                let call_move_val_init = StmtSemi(make_call(\n-                    fld, &move_val_init, vec![p_ptr, pop_unsafe_expr]), ast::DUMMY_NODE_ID);\n-                let call_move_val_init = codemap::respan(value_span, call_move_val_init);\n-\n-                let call = make_call(fld, &inplace_finalize, vec![agent]);\n-                Some(push_unsafe_expr(fld.cx, vec![P(call_move_val_init)], call, span))\n-            };\n-\n-            let block = fld.cx.block_all(span, vec![s1, s2, s3], expr);\n-            let result = fld.cx.expr_block(block);\n-            fld.cx.bt_pop();\n-            result\n+            fld.cx.expr(span, ast::ExprInPlace(placer, value_expr))\n         }\n \n-        // Issue #22181:\n-        // Eventually a desugaring for `box EXPR`\n-        // (similar to the desugaring above for `in PLACE BLOCK`)\n-        // should go here, desugaring\n-        //\n-        // to:\n-        //\n-        // let mut place = BoxPlace::make_place();\n-        // let raw_place = Place::pointer(&mut place);\n-        // let value = $value;\n-        // unsafe {\n-        //     ::std::ptr::write(raw_place, value);\n-        //     Boxed::finalize(place)\n-        // }\n-        //\n-        // But for now there are type-inference issues doing that.\n-\n         ast::ExprWhile(cond, body, opt_ident) => {\n             let cond = fld.fold_expr(cond);\n             let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n             fld.cx.expr(span, ast::ExprWhile(cond, body, opt_ident))\n         }\n \n-        // Desugar ExprWhileLet\n-        // From: `[opt_ident]: while let <pat> = <expr> <body>`\n         ast::ExprWhileLet(pat, expr, body, opt_ident) => {\n-            // to:\n-            //\n-            //   [opt_ident]: loop {\n-            //     match <expr> {\n-            //       <pat> => <body>,\n-            //       _ => break\n-            //     }\n-            //   }\n-\n-            push_compiler_expansion(fld, span, CompilerExpansionFormat::WhileLet);\n-\n-            // `<pat> => <body>`\n-            let pat_arm = {\n-                let body_expr = fld.cx.expr_block(body);\n-                fld.cx.arm(pat.span, vec![pat], body_expr)\n-            };\n-\n-            // `_ => break`\n-            let break_arm = {\n-                let pat_under = fld.cx.pat_wild(span);\n-                let break_expr = fld.cx.expr_break(span);\n-                fld.cx.arm(span, vec![pat_under], break_expr)\n-            };\n-\n-            // `match <expr> { ... }`\n-            let arms = vec![pat_arm, break_arm];\n-            let match_expr = fld.cx.expr(span,\n-                                    ast::ExprMatch(expr, arms, ast::MatchSource::WhileLetDesugar));\n-\n-            // `[opt_ident]: loop { ... }`\n-            let loop_block = fld.cx.block_expr(match_expr);\n-            let (loop_block, opt_ident) = expand_loop_block(loop_block, opt_ident, fld);\n-            let result = fld.cx.expr(span, ast::ExprLoop(loop_block, opt_ident));\n-            fld.cx.bt_pop();\n-            result\n-        }\n-\n-        // Desugar ExprIfLet\n-        // From: `if let <pat> = <expr> <body> [<elseopt>]`\n-        ast::ExprIfLet(pat, expr, body, mut elseopt) => {\n-            // to:\n-            //\n-            //   match <expr> {\n-            //     <pat> => <body>,\n-            //     [_ if <elseopt_if_cond> => <elseopt_if_body>,]\n-            //     _ => [<elseopt> | ()]\n-            //   }\n-\n-            push_compiler_expansion(fld, span, CompilerExpansionFormat::IfLet);\n-\n-            // `<pat> => <body>`\n-            let pat_arm = {\n-                let body_expr = fld.cx.expr_block(body);\n-                fld.cx.arm(pat.span, vec![pat], body_expr)\n-            };\n-\n-            // `[_ if <elseopt_if_cond> => <elseopt_if_body>,]`\n-            let else_if_arms = {\n-                let mut arms = vec![];\n-                loop {\n-                    let elseopt_continue = elseopt\n-                        .and_then(|els| els.and_then(|els| match els.node {\n-                        // else if\n-                        ast::ExprIf(cond, then, elseopt) => {\n-                            let pat_under = fld.cx.pat_wild(span);\n-                            arms.push(ast::Arm {\n-                                attrs: vec![],\n-                                pats: vec![pat_under],\n-                                guard: Some(cond),\n-                                body: fld.cx.expr_block(then)\n-                            });\n-                            elseopt.map(|elseopt| (elseopt, true))\n-                        }\n-                        _ => Some((P(els), false))\n-                    }));\n-                    match elseopt_continue {\n-                        Some((e, true)) => {\n-                            elseopt = Some(e);\n-                        }\n-                        Some((e, false)) => {\n-                            elseopt = Some(e);\n-                            break;\n-                        }\n-                        None => {\n-                            elseopt = None;\n-                            break;\n-                        }\n-                    }\n-                }\n-                arms\n-            };\n-\n-            let contains_else_clause = elseopt.is_some();\n-\n-            // `_ => [<elseopt> | ()]`\n-            let else_arm = {\n-                let pat_under = fld.cx.pat_wild(span);\n-                let else_expr = elseopt.unwrap_or_else(|| fld.cx.expr_tuple(span, vec![]));\n-                fld.cx.arm(span, vec![pat_under], else_expr)\n-            };\n-\n-            let mut arms = Vec::with_capacity(else_if_arms.len() + 2);\n-            arms.push(pat_arm);\n-            arms.extend(else_if_arms);\n-            arms.push(else_arm);\n-\n-            let match_expr = fld.cx.expr(span,\n-                                         ast::ExprMatch(expr, arms,\n-                                                ast::MatchSource::IfLetDesugar {\n-                                                    contains_else_clause: contains_else_clause,\n-                                                }));\n-            let result = fld.fold_expr(match_expr);\n-            fld.cx.bt_pop();\n-            result\n-        }\n+            let pat = fld.fold_pat(pat);\n+            let expr = fld.fold_expr(expr);\n+\n+            // Hygienic renaming of the body.\n+            let ((body, opt_ident), mut rewritten_pats) =\n+                rename_in_scope(vec![pat],\n+                                fld,\n+                                (body, opt_ident),\n+                                |rename_fld, fld, (body, opt_ident)| {\n+                expand_loop_block(rename_fld.fold_block(body), opt_ident, fld)\n+            });\n+            assert!(rewritten_pats.len() == 1);\n \n-        // Desugar support for ExprIfLet in the ExprIf else position\n-        ast::ExprIf(cond, blk, elseopt) => {\n-            let elseopt = elseopt.map(|els| els.and_then(|els| match els.node {\n-                ast::ExprIfLet(..) => {\n-                    push_compiler_expansion(fld, span, CompilerExpansionFormat::IfLet);\n-                    // wrap the if-let expr in a block\n-                    let span = els.span;\n-                    let blk = P(ast::Block {\n-                        stmts: vec![],\n-                        expr: Some(P(els)),\n-                        id: ast::DUMMY_NODE_ID,\n-                        rules: ast::DefaultBlock,\n-                        span: span\n-                    });\n-                    let result = fld.cx.expr_block(blk);\n-                    fld.cx.bt_pop();\n-                    result\n-                }\n-                _ => P(els)\n-            }));\n-            let if_expr = fld.cx.expr(span, ast::ExprIf(cond, blk, elseopt));\n-            if_expr.map(|e| noop_fold_expr(e, fld))\n+            fld.cx.expr(span, ast::ExprWhileLet(rewritten_pats.remove(0), expr, body, opt_ident))\n         }\n \n         ast::ExprLoop(loop_block, opt_ident) => {\n             let (loop_block, opt_ident) = expand_loop_block(loop_block, opt_ident, fld);\n             fld.cx.expr(span, ast::ExprLoop(loop_block, opt_ident))\n         }\n \n-        // Desugar ExprForLoop\n-        // From: `[opt_ident]: for <pat> in <head> <body>`\n         ast::ExprForLoop(pat, head, body, opt_ident) => {\n-            // to:\n-            //\n-            //   {\n-            //     let result = match ::std::iter::IntoIterator::into_iter(<head>) {\n-            //       mut iter => {\n-            //         [opt_ident]: loop {\n-            //           match ::std::iter::Iterator::next(&mut iter) {\n-            //             ::std::option::Option::Some(<pat>) => <body>,\n-            //             ::std::option::Option::None => break\n-            //           }\n-            //         }\n-            //       }\n-            //     };\n-            //     result\n-            //   }\n-\n-            push_compiler_expansion(fld, span, CompilerExpansionFormat::ForLoop);\n-\n-            let span = fld.new_span(span);\n+            let pat = fld.fold_pat(pat);\n+\n+            // Hygienic renaming of the for loop body (for loop binds its pattern).\n+            let ((body, opt_ident), mut rewritten_pats) =\n+                rename_in_scope(vec![pat],\n+                                fld,\n+                                (body, opt_ident),\n+                                |rename_fld, fld, (body, opt_ident)| {\n+                expand_loop_block(rename_fld.fold_block(body), opt_ident, fld)\n+            });\n+            assert!(rewritten_pats.len() == 1);\n \n-            // expand <head>\n             let head = fld.fold_expr(head);\n+            fld.cx.expr(span, ast::ExprForLoop(rewritten_pats.remove(0), head, body, opt_ident))\n+        }\n \n-            let iter = token::gensym_ident(\"iter\");\n-\n-            let pat_span = fld.new_span(pat.span);\n-            // `::std::option::Option::Some(<pat>) => <body>`\n-            let pat_arm = {\n-                let body_expr = fld.cx.expr_block(body);\n-                let pat = fld.fold_pat(pat);\n-                let some_pat = fld.cx.pat_some(pat_span, pat);\n-\n-                fld.cx.arm(pat_span, vec![some_pat], body_expr)\n-            };\n-\n-            // `::std::option::Option::None => break`\n-            let break_arm = {\n-                let break_expr = fld.cx.expr_break(span);\n-\n-                fld.cx.arm(span, vec![fld.cx.pat_none(span)], break_expr)\n-            };\n-\n-            // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n-            let match_expr = {\n-                let next_path = {\n-                    let strs = fld.cx.std_path(&[\"iter\", \"Iterator\", \"next\"]);\n-\n-                    fld.cx.path_global(span, strs)\n-                };\n-                let ref_mut_iter = fld.cx.expr_mut_addr_of(span, fld.cx.expr_ident(span, iter));\n-                let next_expr =\n-                    fld.cx.expr_call(span, fld.cx.expr_path(next_path), vec![ref_mut_iter]);\n-                let arms = vec![pat_arm, break_arm];\n-\n-                fld.cx.expr(pat_span,\n-                            ast::ExprMatch(next_expr, arms, ast::MatchSource::ForLoopDesugar))\n-            };\n-\n-            // `[opt_ident]: loop { ... }`\n-            let loop_block = fld.cx.block_expr(match_expr);\n-            let (loop_block, opt_ident) = expand_loop_block(loop_block, opt_ident, fld);\n-            let loop_expr = fld.cx.expr(span, ast::ExprLoop(loop_block, opt_ident));\n-\n-            // `mut iter => { ... }`\n-            let iter_arm = {\n-                let iter_pat =\n-                    fld.cx.pat_ident_binding_mode(span, iter, ast::BindByValue(ast::MutMutable));\n-                fld.cx.arm(span, vec![iter_pat], loop_expr)\n-            };\n-\n-            // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n-            let into_iter_expr = {\n-                let into_iter_path = {\n-                    let strs = fld.cx.std_path(&[\"iter\", \"IntoIterator\",\n-                                                 \"into_iter\"]);\n-\n-                    fld.cx.path_global(span, strs)\n-                };\n-\n-                fld.cx.expr_call(span, fld.cx.expr_path(into_iter_path), vec![head])\n-            };\n+        ast::ExprIfLet(pat, sub_expr, body, else_opt) => {\n+            let pat = fld.fold_pat(pat);\n \n-            let match_expr = fld.cx.expr_match(span, into_iter_expr, vec![iter_arm]);\n+            // Hygienic renaming of the body.\n+            let (body, mut rewritten_pats) =\n+                rename_in_scope(vec![pat],\n+                                fld,\n+                                body,\n+                                |rename_fld, fld, body| {\n+                fld.fold_block(rename_fld.fold_block(body))\n+            });\n+            assert!(rewritten_pats.len() == 1);\n \n-            // `{ let result = ...; result }`\n-            let result_ident = token::gensym_ident(\"result\");\n-            let result = fld.cx.expr_block(\n-                fld.cx.block_all(\n-                    span,\n-                    vec![fld.cx.stmt_let(span, false, result_ident, match_expr)],\n-                    Some(fld.cx.expr_ident(span, result_ident))));\n-            fld.cx.bt_pop();\n-            result\n+            let else_opt = else_opt.map(|else_opt| fld.fold_expr(else_opt));\n+            let sub_expr = fld.fold_expr(sub_expr);\n+            fld.cx.expr(span, ast::ExprIfLet(rewritten_pats.remove(0), sub_expr, body, else_opt))\n         }\n \n         ast::ExprClosure(capture_clause, fn_decl, block) => {\n@@ -475,25 +153,6 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             }, fld))\n         }\n     });\n-\n-    fn push_unsafe_expr(cx: &mut ExtCtxt, stmts: Vec<P<ast::Stmt>>,\n-                        expr: P<ast::Expr>, span: Span)\n-                        -> P<ast::Expr> {\n-        let rules = ast::PushUnsafeBlock(ast::CompilerGenerated);\n-        cx.expr_block(P(ast::Block {\n-            rules: rules, span: span, id: ast::DUMMY_NODE_ID,\n-            stmts: stmts, expr: Some(expr),\n-        }))\n-    }\n-\n-    fn pop_unsafe_expr(cx: &mut ExtCtxt, expr: P<ast::Expr>, span: Span)\n-                       -> P<ast::Expr> {\n-        let rules = ast::PopUnsafeBlock(ast::CompilerGenerated);\n-        cx.expr_block(P(ast::Block {\n-            rules: rules, span: span, id: ast::DUMMY_NODE_ID,\n-            stmts: vec![], expr: Some(expr),\n-        }))\n-    }\n }\n \n /// Expand a (not-ident-style) macro invocation. Returns the result\n@@ -948,18 +607,18 @@ fn expand_arm(arm: ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n     if expanded_pats.is_empty() {\n         panic!(\"encountered match arm with 0 patterns\");\n     }\n-    // all of the pats must have the same set of bindings, so use the\n-    // first one to extract them and generate new names:\n-    let idents = pattern_bindings(&*expanded_pats[0]);\n-    let new_renames = idents.into_iter().map(|id| (id, fresh_name(id))).collect();\n-    // apply the renaming, but only to the PatIdents:\n-    let mut rename_pats_fld = PatIdentRenamer{renames:&new_renames};\n-    let rewritten_pats = expanded_pats.move_map(|pat| rename_pats_fld.fold_pat(pat));\n+\n     // apply renaming and then expansion to the guard and the body:\n-    let mut rename_fld = IdentRenamer{renames:&new_renames};\n-    let rewritten_guard =\n-        arm.guard.map(|g| fld.fold_expr(rename_fld.fold_expr(g)));\n-    let rewritten_body = fld.fold_expr(rename_fld.fold_expr(arm.body));\n+    let ((rewritten_guard, rewritten_body), rewritten_pats) =\n+        rename_in_scope(expanded_pats,\n+                        fld,\n+                        (arm.guard, arm.body),\n+                        |rename_fld, fld, (ag, ab)|{\n+        let rewritten_guard = ag.map(|g| fld.fold_expr(rename_fld.fold_expr(g)));\n+        let rewritten_body = fld.fold_expr(rename_fld.fold_expr(ab));\n+        (rewritten_guard, rewritten_body)\n+    });\n+\n     ast::Arm {\n         attrs: fold::fold_attrs(arm.attrs, fld),\n         pats: rewritten_pats,\n@@ -968,6 +627,25 @@ fn expand_arm(arm: ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n     }\n }\n \n+fn rename_in_scope<X, F>(pats: Vec<P<ast::Pat>>,\n+                         fld: &mut MacroExpander,\n+                         x: X,\n+                         f: F)\n+                         -> (X, Vec<P<ast::Pat>>)\n+    where F: Fn(&mut IdentRenamer, &mut MacroExpander, X) -> X\n+{\n+    // all of the pats must have the same set of bindings, so use the\n+    // first one to extract them and generate new names:\n+    let idents = pattern_bindings(&*pats[0]);\n+    let new_renames = idents.into_iter().map(|id| (id, fresh_name(id))).collect();\n+    // apply the renaming, but only to the PatIdents:\n+    let mut rename_pats_fld = PatIdentRenamer{renames:&new_renames};\n+    let rewritten_pats = pats.move_map(|pat| rename_pats_fld.fold_pat(pat));\n+\n+    let mut rename_fld = IdentRenamer{ renames:&new_renames };\n+    (f(&mut rename_fld, fld, x), rewritten_pats)\n+}\n+\n /// A visitor that extracts the PatIdent (binding) paths\n /// from a given thingy and puts them in a mutable\n /// array"}, {"sha": "8efeaa330c0068eb6068684745c72ca9bfb80964", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -726,7 +726,7 @@ impl<'a, 'v> Visitor<'v> for MacroVisitor<'a> {\n }\n \n struct PostExpansionVisitor<'a> {\n-    context: &'a Context<'a>\n+    context: &'a Context<'a>,\n }\n \n impl<'a> PostExpansionVisitor<'a> {"}, {"sha": "3c1aa992a3c16aa77fda64e1982cd8f4c5c58a48", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -1256,10 +1256,9 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                 ExprLoop(folder.fold_block(body),\n                         opt_ident.map(|i| folder.fold_ident(i)))\n             }\n-            ExprMatch(expr, arms, source) => {\n+            ExprMatch(expr, arms) => {\n                 ExprMatch(folder.fold_expr(expr),\n-                        arms.move_map(|x| folder.fold_arm(x)),\n-                        source)\n+                          arms.move_map(|x| folder.fold_arm(x)))\n             }\n             ExprClosure(capture_clause, decl, body) => {\n                 ExprClosure(capture_clause,"}, {"sha": "443cea696b682150af3e30ed48b7fc90db1f02ed", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -37,7 +37,7 @@ use ast::{LifetimeDef, Lit, Lit_};\n use ast::{LitBool, LitChar, LitByte, LitByteStr};\n use ast::{LitStr, LitInt, Local};\n use ast::{MacStmtWithBraces, MacStmtWithSemicolon, MacStmtWithoutBraces};\n-use ast::{MutImmutable, MutMutable, Mac_, MatchSource};\n+use ast::{MutImmutable, MutMutable, Mac_};\n use ast::{MutTy, BiMul, Mutability};\n use ast::{MethodImplItem, NamedField, UnNeg, NoReturn, UnNot};\n use ast::{Pat, PatBox, PatEnum, PatIdent, PatLit, PatQPath, PatMac, PatRange};\n@@ -2927,7 +2927,7 @@ impl<'a> Parser<'a> {\n         }\n         let hi = self.span.hi;\n         try!(self.bump());\n-        return Ok(self.mk_expr(lo, hi, ExprMatch(discriminant, arms, MatchSource::Normal)));\n+        return Ok(self.mk_expr(lo, hi, ExprMatch(discriminant, arms)));\n     }\n \n     pub fn parse_arm_nopanic(&mut self) -> PResult<Arm> {"}, {"sha": "f5f3907a4e6c874decdd62d738e7bd4fc49f6eb3", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -2045,7 +2045,7 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.print_block(&**blk));\n             }\n-            ast::ExprMatch(ref expr, ref arms, _) => {\n+            ast::ExprMatch(ref expr, ref arms) => {\n                 try!(self.cbox(indent_unit));\n                 try!(self.ibox(4));\n                 try!(self.word_nbsp(\"match\"));"}, {"sha": "091580b9bd837c1318a4d9d6b46e75ca93c852ed", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -731,7 +731,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_block(block);\n             walk_opt_ident(visitor, expression.span, opt_ident)\n         }\n-        ExprMatch(ref subexpression, ref arms, _) => {\n+        ExprMatch(ref subexpression, ref arms) => {\n             visitor.visit_expr(subexpression);\n             walk_list!(visitor, visit_arm, arms);\n         }"}, {"sha": "81c4db68628d45517bc966725049aefb6ac0e084", "filename": "src/test/compile-fail/for-loop-refutable-pattern-error-message.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Ftest%2Fcompile-fail%2Ffor-loop-refutable-pattern-error-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Ftest%2Fcompile-fail%2Ffor-loop-refutable-pattern-error-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-loop-refutable-pattern-error-message.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -9,7 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    for\n-        &1 //~ ERROR refutable pattern in `for` loop binding\n-        in [1].iter() {}\n+    for &1 in [1].iter() {} //~ ERROR refutable pattern in `for` loop binding\n }"}, {"sha": "898e6be6fc85c0ce863a590dcc9a0ec8cc635041", "filename": "src/test/compile-fail/issue-15167.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Ftest%2Fcompile-fail%2Fissue-15167.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Ftest%2Fcompile-fail%2Fissue-15167.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15167.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -16,4 +16,17 @@ fn main() -> (){\n     for n in 0..1 {\n         println!(\"{}\", f!()); //~ ERROR unresolved name `n`\n     }\n+\n+    if let Some(n) = None {\n+        println!(\"{}\", f!()); //~ ERROR unresolved name `n`\n+    }\n+\n+    if false {\n+    } else if let Some(n) = None {\n+        println!(\"{}\", f!()); //~ ERROR unresolved name `n`\n+    }\n+\n+    while let Some(n) = None {\n+        println!(\"{}\", f!()); //~ ERROR unresolved name `n`\n+    }\n }"}, {"sha": "ec29a84f44e4bd105019295b97c1bb15c69665c6", "filename": "src/test/compile-fail/issue-15381.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Ftest%2Fcompile-fail%2Fissue-15381.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Ftest%2Fcompile-fail%2Fissue-15381.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15381.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -13,10 +13,8 @@\n fn main() {\n     let values: Vec<u8> = vec![1,2,3,4,5,6,7,8];\n \n-    for\n-        [x,y,z]\n-//~^ ERROR refutable pattern in `for` loop binding: `[]` not covered\n-        in values.chunks(3).filter(|&xs| xs.len() == 3) {\n+    for [x,y,z] in values.chunks(3).filter(|&xs| xs.len() == 3) {\n+        //~^ ERROR refutable pattern in `for` loop binding: `[]` not covered\n         println!(\"y={}\", y);\n     }\n }"}, {"sha": "50a840e6c9b7f8407ee256106718926b449ef930", "filename": "src/test/compile-fail/placement-expr-unsafe.rs", "status": "renamed", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unsafe.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -8,11 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that we get an expansion stack for `for` loops.\n+// Check that placement in respects unsafe code checks.\n \n-// error-pattern:in this expansion of for loop expansion\n+#![feature(box_heap)]\n+#![feature(placement_in_syntax)]\n \n fn main() {\n-    for t in &foo {\n-    }\n+    use std::boxed::HEAP;\n+\n+    let p: *const i32 = &42;\n+    let _ = in HEAP { *p }; //~ ERROR requires unsafe\n+\n+    let p: *const _ = &HEAP;\n+    let _ = in *p { 42 }; //~ ERROR requires unsafe\n }", "previous_filename": "src/test/compile-fail/for-expn-2.rs"}, {"sha": "d981b71a8132ddb4269c71361aee8928637c2b83", "filename": "src/test/compile-fail/placement-expr-unstable.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unstable.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that placement in respects unstable code checks.\n+\n+#![feature(placement_in_syntax)]\n+#![feature(core)]\n+\n+extern crate core;\n+\n+fn main() {\n+    use std::boxed::HEAP; //~ ERROR use of unstable library feature\n+\n+    let _ = in HEAP { //~ ERROR use of unstable library feature\n+        ::core::raw::Slice { //~ ERROR use of unstable library feature\n+            data: &42, //~ ERROR use of unstable library feature\n+            len: 1 //~ ERROR use of unstable library feature\n+        }\n+    };\n+}"}, {"sha": "bad0afe79d69189da14ba3730f36ad0dbff1ba21", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -31,7 +31,7 @@ use rustc::middle::ty;\n use rustc::session::config::{self, basic_options, build_configuration, Input, Options};\n use rustc::session::build_session;\n use rustc_driver::driver;\n-use rustc_front::lowering::lower_crate;\n+use rustc_front::lowering::{lower_crate, LoweringContext};\n use rustc_resolve::MakeGlobMap;\n use libc::c_void;\n \n@@ -223,12 +223,13 @@ fn compile_program(input: &str, sysroot: PathBuf)\n             .expect(\"phase_2 returned `None`\");\n \n         let krate = driver::assign_node_ids(&sess, krate);\n-        let mut hir_forest = ast_map::Forest::new(lower_crate(&krate));\n+        let lcx = LoweringContext::new(&sess, Some(&krate));\n+        let mut hir_forest = ast_map::Forest::new(lower_crate(&lcx, &krate));\n         let arenas = ty::CtxtArenas::new();\n         let ast_map = driver::make_map(&sess, &mut hir_forest);\n \n         driver::phase_3_run_analysis_passes(\n-            sess, ast_map, &arenas, id, MakeGlobMap::No, |tcx, analysis| {\n+            &sess, ast_map, &arenas, id, MakeGlobMap::No, |tcx, analysis| {\n \n             let trans = driver::phase_4_translate_to_llvm(tcx, analysis);\n \n@@ -246,7 +247,7 @@ fn compile_program(input: &str, sysroot: PathBuf)\n             let modp = llmod as usize;\n \n             (modp, deps)\n-        }).1\n+        })\n     }).unwrap();\n \n     match handle.join() {"}, {"sha": "3e4ba5af80c4de604c7c11528d0abaa4bd1b6093", "filename": "src/test/run-make/save-analysis/foo.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14609035d1780d4a8a3ca7b4fdf93046299ab4a/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs?ref=c14609035d1780d4a8a3ca7b4fdf93046299ab4a", "patch": "@@ -339,8 +339,27 @@ fn main() { // foo\n     if let SomeEnum::Strings(..) = s7 {\n         println!(\"hello!\");\n     }\n+\n+    for i in 0..5 {\n+        foo_foo(i);\n+    }\n+\n+    if let Some(x) = None {\n+        foo_foo(x);\n+    }\n+\n+    if false {\n+    } else if let Some(y) = None {\n+        foo_foo(y);\n+    }\n+\n+    while let Some(z) = None {\n+        foo_foo(z);\n+    }\n }\n \n+fn foo_foo(_: i32) {}\n+\n impl Iterator for nofields {\n     type Item = (usize, usize);\n "}]}