{"sha": "3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3NTJiM2QzYTU2YmYzZWFiYjU4OGI3ZDU5NWNkMWY4YWNjYzAyODY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-24T21:26:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-24T21:26:57Z"}, "message": "Auto merge of #59382 - davidtwco:rfc-2008-refactoring, r=petrochenkov\n\nSeparate `DefId`s for variants and their constructors\n\nPart of #44109. Split off from #59376. See [Zulip topic](https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/rfc-2008/near/132663140) for previous discussion.\n\nr? @petrochenkov", "tree": {"sha": "cb3574e7525a5eb9deb097ff8af38da1581b8d6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb3574e7525a5eb9deb097ff8af38da1581b8d6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "html_url": "https://github.com/rust-lang/rust/commit/3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0576ac109b1ee40cc3201ac3c9ed58339487140e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0576ac109b1ee40cc3201ac3c9ed58339487140e", "html_url": "https://github.com/rust-lang/rust/commit/0576ac109b1ee40cc3201ac3c9ed58339487140e"}, {"sha": "23cae1d3f06ccb339f2f780e63b6d6d5c1c6a9da", "url": "https://api.github.com/repos/rust-lang/rust/commits/23cae1d3f06ccb339f2f780e63b6d6d5c1c6a9da", "html_url": "https://github.com/rust-lang/rust/commit/23cae1d3f06ccb339f2f780e63b6d6d5c1c6a9da"}], "stats": {"total": 1639, "additions": 859, "deletions": 780}, "files": [{"sha": "3cc23ccdb642c586afb9e8cb200495128996526a", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -9,6 +9,15 @@ use crate::ty;\n \n use self::Namespace::*;\n \n+/// Encodes if a `Def::Ctor` is the constructor of an enum variant or a struct.\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n+pub enum CtorOf {\n+    /// This `Def::Ctor` is a synthesized constructor of a tuple or unit struct.\n+    Struct,\n+    /// This `Def::Ctor` is a synthesized constructor of a tuple or unit variant.\n+    Variant,\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n pub enum CtorKind {\n     /// Constructor function automatically created by a tuple struct/variant.\n@@ -37,9 +46,11 @@ pub enum NonMacroAttrKind {\n pub enum Def {\n     // Type namespace\n     Mod(DefId),\n-    Struct(DefId), // `DefId` refers to `NodeId` of the struct itself\n+    /// `DefId` refers to the struct itself, `Def::Ctor` refers to its constructor if it exists.\n+    Struct(DefId),\n     Union(DefId),\n     Enum(DefId),\n+    /// `DefId` refers to the variant itself, `Def::Ctor` refers to its constructor if it exists.\n     Variant(DefId),\n     Trait(DefId),\n     /// `existential type Foo: Bar;`\n@@ -61,8 +72,8 @@ pub enum Def {\n     Const(DefId),\n     ConstParam(DefId),\n     Static(DefId, bool /* is_mutbl */),\n-    StructCtor(DefId, CtorKind), // `DefId` refers to `NodeId` of the struct's constructor\n-    VariantCtor(DefId, CtorKind), // `DefId` refers to the enum variant\n+    /// `DefId` refers to the struct or enum variant's constructor.\n+    Ctor(DefId, CtorOf, CtorKind),\n     SelfCtor(DefId /* impl */),  // `DefId` refers to the impl\n     Method(DefId),\n     AssociatedConst(DefId),\n@@ -265,10 +276,9 @@ impl Def {\n     pub fn opt_def_id(&self) -> Option<DefId> {\n         match *self {\n             Def::Fn(id) | Def::Mod(id) | Def::Static(id, _) |\n-            Def::Variant(id) | Def::VariantCtor(id, ..) | Def::Enum(id) |\n+            Def::Variant(id) | Def::Ctor(id, ..) | Def::Enum(id) |\n             Def::TyAlias(id) | Def::TraitAlias(id) |\n             Def::AssociatedTy(id) | Def::TyParam(id) | Def::ConstParam(id) | Def::Struct(id) |\n-            Def::StructCtor(id, ..) |\n             Def::Union(id) | Def::Trait(id) | Def::Method(id) | Def::Const(id) |\n             Def::AssociatedConst(id) | Def::Macro(id, ..) |\n             Def::Existential(id) | Def::AssociatedExistential(id) | Def::ForeignTy(id) => {\n@@ -303,20 +313,21 @@ impl Def {\n             Def::Fn(..) => \"function\",\n             Def::Mod(..) => \"module\",\n             Def::Static(..) => \"static\",\n-            Def::Variant(..) => \"variant\",\n-            Def::VariantCtor(.., CtorKind::Fn) => \"tuple variant\",\n-            Def::VariantCtor(.., CtorKind::Const) => \"unit variant\",\n-            Def::VariantCtor(.., CtorKind::Fictive) => \"struct variant\",\n             Def::Enum(..) => \"enum\",\n+            Def::Variant(..) => \"variant\",\n+            Def::Ctor(_, CtorOf::Variant, CtorKind::Fn) => \"tuple variant\",\n+            Def::Ctor(_, CtorOf::Variant, CtorKind::Const) => \"unit variant\",\n+            Def::Ctor(_, CtorOf::Variant, CtorKind::Fictive) => \"struct variant\",\n+            Def::Struct(..) => \"struct\",\n+            Def::Ctor(_, CtorOf::Struct, CtorKind::Fn) => \"tuple struct\",\n+            Def::Ctor(_, CtorOf::Struct, CtorKind::Const) => \"unit struct\",\n+            Def::Ctor(_, CtorOf::Struct, CtorKind::Fictive) =>\n+                bug!(\"impossible struct constructor\"),\n             Def::Existential(..) => \"existential type\",\n             Def::TyAlias(..) => \"type alias\",\n             Def::TraitAlias(..) => \"trait alias\",\n             Def::AssociatedTy(..) => \"associated type\",\n             Def::AssociatedExistential(..) => \"associated existential type\",\n-            Def::Struct(..) => \"struct\",\n-            Def::StructCtor(.., CtorKind::Fn) => \"tuple struct\",\n-            Def::StructCtor(.., CtorKind::Const) => \"unit struct\",\n-            Def::StructCtor(.., CtorKind::Fictive) => bug!(\"impossible struct constructor\"),\n             Def::SelfCtor(..) => \"self constructor\",\n             Def::Union(..) => \"union\",\n             Def::Trait(..) => \"trait\","}, {"sha": "bce528189ad1e0dd011b4630bff2875c23e17f55", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -559,6 +559,7 @@ pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n                                         generics: &'v Generics,\n                                         parent_item_id: HirId) {\n     visitor.visit_ident(variant.node.ident);\n+    visitor.visit_id(variant.node.id);\n     visitor.visit_variant_data(&variant.node.data,\n                                variant.node.ident.name,\n                                generics,\n@@ -923,7 +924,9 @@ pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'\n \n \n pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V, struct_definition: &'v VariantData) {\n-    visitor.visit_id(struct_definition.hir_id());\n+    if let Some(ctor_hir_id) = struct_definition.ctor_hir_id() {\n+        visitor.visit_id(ctor_hir_id);\n+    }\n     walk_list!(visitor, visit_struct_field, struct_definition.fields());\n }\n "}, {"sha": "8db90035c8e0ccd072d109ca8ee8f78552b45ba9", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -1615,9 +1615,11 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_variant(&mut self, v: &Variant) -> hir::Variant {\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(v.node.id);\n         Spanned {\n             node: hir::VariantKind {\n                 ident: v.node.ident,\n+                id: hir_id,\n                 attrs: self.lower_attrs(&v.node.attrs),\n                 data: self.lower_variant_data(&v.node.data),\n                 disr_expr: v.node.disr_expr.as_ref().map(|e| self.lower_anon_const(e)),\n@@ -2669,19 +2671,10 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_variant_data(&mut self, vdata: &VariantData) -> hir::VariantData {\n         match *vdata {\n-            VariantData::Struct(ref fields, id, recovered) => {\n-                let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(id);\n-\n-                hir::VariantData::Struct(\n-                    fields\n-                        .iter()\n-                        .enumerate()\n-                        .map(|f| self.lower_struct_field(f))\n-                        .collect(),\n-                    hir_id,\n-                    recovered,\n-                )\n-            },\n+            VariantData::Struct(ref fields, recovered) => hir::VariantData::Struct(\n+                fields.iter().enumerate().map(|f| self.lower_struct_field(f)).collect(),\n+                recovered,\n+            ),\n             VariantData::Tuple(ref fields, id) => {\n                 let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(id);\n \n@@ -2696,7 +2689,6 @@ impl<'a> LoweringContext<'a> {\n             },\n             VariantData::Unit(id) => {\n                 let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(id);\n-\n                 hir::VariantData::Unit(hir_id)\n             },\n         }"}, {"sha": "75d7d843dea7e89fe3e4f98a919d55e0c98bdf45", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -360,9 +360,9 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n             this.insert(i.span, i.hir_id, Node::Item(i));\n             this.with_parent(i.hir_id, |this| {\n                 if let ItemKind::Struct(ref struct_def, _) = i.node {\n-                    // If this is a tuple-like struct, register the constructor.\n-                    if !struct_def.is_struct() {\n-                        this.insert(i.span, struct_def.hir_id(), Node::StructCtor(struct_def));\n+                    // If this is a tuple or unit-like struct, register the constructor.\n+                    if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n+                        this.insert(i.span, ctor_hir_id, Node::Ctor(struct_def));\n                     }\n                 }\n                 intravisit::walk_item(this, i);\n@@ -515,8 +515,12 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_variant(&mut self, v: &'hir Variant, g: &'hir Generics, item_id: HirId) {\n-        self.insert(v.span, v.node.data.hir_id(), Node::Variant(v));\n-        self.with_parent(v.node.data.hir_id(), |this| {\n+        self.insert(v.span, v.node.id, Node::Variant(v));\n+        self.with_parent(v.node.id, |this| {\n+            // Register the constructor of this variant.\n+            if let Some(ctor_hir_id) = v.node.data.ctor_hir_id() {\n+                this.insert(v.span, ctor_hir_id, Node::Ctor(&v.node.data));\n+            }\n             intravisit::walk_variant(this, v, g, item_id);\n         });\n     }"}, {"sha": "1a3bbc5ecc49ed3bce7c9f370efa8a65059f5860", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -158,12 +158,9 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         self.with_parent(def, |this| {\n             match i.node {\n                 ItemKind::Struct(ref struct_def, _) | ItemKind::Union(ref struct_def, _) => {\n-                    // If this is a tuple-like struct, register the constructor.\n-                    if !struct_def.is_struct() {\n-                        this.create_def(struct_def.id(),\n-                                        DefPathData::StructCtor,\n-                                        REGULAR_SPACE,\n-                                        i.span);\n+                    // If this is a unit or tuple-like struct, register the constructor.\n+                    if let Some(ctor_hir_id) = struct_def.ctor_id() {\n+                        this.create_def(ctor_hir_id, DefPathData::Ctor, REGULAR_SPACE, i.span);\n                     }\n                 }\n                 _ => {}\n@@ -193,11 +190,16 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_variant(&mut self, v: &'a Variant, g: &'a Generics, item_id: NodeId) {\n-        let def = self.create_def(v.node.data.id(),\n+        let def = self.create_def(v.node.id,\n                                   DefPathData::EnumVariant(v.node.ident.as_interned_str()),\n                                   REGULAR_SPACE,\n                                   v.span);\n-        self.with_parent(def, |this| visit::walk_variant(this, v, g, item_id));\n+        self.with_parent(def, |this| {\n+            if let Some(ctor_hir_id) = v.node.data.ctor_id() {\n+                this.create_def(ctor_hir_id, DefPathData::Ctor, REGULAR_SPACE, v.span);\n+            }\n+            visit::walk_variant(this, v, g, item_id)\n+        });\n     }\n \n     fn visit_variant_data(&mut self, data: &'a VariantData, _: Ident,"}, {"sha": "1006d813e65ed6cd29183fa0fff77da36c9f00b6", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -366,8 +366,8 @@ pub enum DefPathData {\n     EnumVariant(InternedString),\n     /// A struct field\n     Field(InternedString),\n-    /// Implicit ctor for a tuple-like struct\n-    StructCtor,\n+    /// Implicit ctor for a unit or tuple-like struct or enum variant.\n+    Ctor,\n     /// A constant expression (see {ast,hir}::AnonConst).\n     AnonConst,\n     /// An `impl Trait` type node\n@@ -652,7 +652,7 @@ impl DefPathData {\n             CrateRoot |\n             Misc |\n             ClosureExpr |\n-            StructCtor |\n+            Ctor |\n             AnonConst |\n             ImplTrait => None\n         }\n@@ -683,7 +683,7 @@ impl DefPathData {\n             Impl => \"{{impl}}\",\n             Misc => \"{{misc}}\",\n             ClosureExpr => \"{{closure}}\",\n-            StructCtor => \"{{constructor}}\",\n+            Ctor => \"{{constructor}}\",\n             AnonConst => \"{{constant}}\",\n             ImplTrait => \"{{opaque}}\",\n         };"}, {"sha": "d810a9310c55fae4638161c91d60ce29b8749ddd", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -366,12 +366,18 @@ impl<'hir> Map<'hir> {\n                 }\n             }\n             Node::Variant(variant) => {\n-                let def_id = self.local_def_id_from_hir_id(variant.node.data.hir_id());\n+                let def_id = self.local_def_id_from_hir_id(variant.node.id);\n                 Some(Def::Variant(def_id))\n             }\n-            Node::StructCtor(variant) => {\n-                let def_id = self.local_def_id_from_hir_id(variant.hir_id());\n-                Some(Def::StructCtor(def_id, def::CtorKind::from_hir(variant)))\n+            Node::Ctor(variant_data) => {\n+                let ctor_of = match self.find(self.get_parent_node(node_id)) {\n+                    Some(Node::Item(..)) => def::CtorOf::Struct,\n+                    Some(Node::Variant(..)) => def::CtorOf::Variant,\n+                    _ => unreachable!(),\n+                };\n+                variant_data.ctor_hir_id()\n+                    .map(|hir_id| self.local_def_id_from_hir_id(hir_id))\n+                    .map(|def_id| Def::Ctor(def_id, ctor_of, def::CtorKind::from_hir(variant_data)))\n             }\n             Node::AnonConst(_) |\n             Node::Field(_) |\n@@ -516,8 +522,7 @@ impl<'hir> Map<'hir> {\n             Node::AnonConst(_) => {\n                 BodyOwnerKind::Const\n             }\n-            Node::Variant(&Spanned { node: VariantKind { data: VariantData::Tuple(..), .. }, .. }) |\n-            Node::StructCtor(..) |\n+            Node::Ctor(..) |\n             Node::Item(&Item { node: ItemKind::Fn(..), .. }) |\n             Node::TraitItem(&TraitItem { node: TraitItemKind::Method(..), .. }) |\n             Node::ImplItem(&ImplItem { node: ImplItemKind::Method(..), .. }) => {\n@@ -948,8 +953,8 @@ impl<'hir> Map<'hir> {\n                     _ => bug!(\"struct ID bound to non-struct {}\", self.hir_to_string(id))\n                 }\n             }\n-            Some(Node::StructCtor(data)) => data,\n             Some(Node::Variant(variant)) => &variant.node.data,\n+            Some(Node::Ctor(data)) => data,\n             _ => bug!(\"expected struct or variant, found {}\", self.hir_to_string(id))\n         }\n     }\n@@ -993,7 +998,7 @@ impl<'hir> Map<'hir> {\n             Node::Lifetime(lt) => lt.name.ident().name,\n             Node::GenericParam(param) => param.name.ident().name,\n             Node::Binding(&Pat { node: PatKind::Binding(_, _, l, _), .. }) => l.name,\n-            Node::StructCtor(_) => self.name(self.get_parent(id)),\n+            Node::Ctor(..) => self.name(self.get_parent(id)),\n             _ => bug!(\"no name for {}\", self.node_to_string(id))\n         }\n     }\n@@ -1019,9 +1024,9 @@ impl<'hir> Map<'hir> {\n             Some(Node::Expr(ref e)) => Some(&*e.attrs),\n             Some(Node::Stmt(ref s)) => Some(s.node.attrs()),\n             Some(Node::GenericParam(param)) => Some(&param.attrs[..]),\n-            // unit/tuple structs take the attributes straight from\n-            // the struct definition.\n-            Some(Node::StructCtor(_)) => return self.attrs(self.get_parent(id)),\n+            // Unit/tuple structs/variants take the attributes straight from\n+            // the struct/variant definition.\n+            Some(Node::Ctor(..)) => return self.attrs(self.get_parent(id)),\n             _ => None\n         };\n         attrs.unwrap_or(&[])\n@@ -1068,7 +1073,11 @@ impl<'hir> Map<'hir> {\n             Some(Node::Binding(pat)) => pat.span,\n             Some(Node::Pat(pat)) => pat.span,\n             Some(Node::Block(block)) => block.span,\n-            Some(Node::StructCtor(_)) => self.expect_item(self.get_parent(id)).span,\n+            Some(Node::Ctor(..)) => match self.find(self.get_parent_node(id)) {\n+                Some(Node::Item(item)) => item.span,\n+                Some(Node::Variant(variant)) => variant.span,\n+                _ => unreachable!(),\n+            }\n             Some(Node::Lifetime(lifetime)) => lifetime.span,\n             Some(Node::GenericParam(param)) => param.span,\n             Some(Node::Visibility(&Spanned {\n@@ -1324,7 +1333,7 @@ impl<'a> print::State<'a> {\n             // these cases do not carry enough information in the\n             // hir_map to reconstruct their full structure for pretty\n             // printing.\n-            Node::StructCtor(_)   => bug!(\"cannot print isolated StructCtor\"),\n+            Node::Ctor(..)        => bug!(\"cannot print isolated Ctor\"),\n             Node::Local(a)        => self.print_local_decl(&a),\n             Node::MacroDef(_)     => bug!(\"cannot print MacroDef\"),\n             Node::Crate           => bug!(\"cannot print Crate\"),\n@@ -1443,8 +1452,8 @@ fn node_id_to_string(map: &Map<'_>, id: NodeId, include_id: bool) -> String {\n         Some(Node::Local(_)) => {\n             format!(\"local {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(Node::StructCtor(_)) => {\n-            format!(\"struct_ctor {}{}\", path_str(), id_str)\n+        Some(Node::Ctor(..)) => {\n+            format!(\"ctor {}{}\", path_str(), id_str)\n         }\n         Some(Node::Lifetime(_)) => {\n             format!(\"lifetime {}{}\", map.node_to_pretty_string(id), id_str)"}, {"sha": "1bf7eed71bf0ff67dcfd7d504b9929ef2c7fe959", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 26, "deletions": 40, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -2049,9 +2049,14 @@ pub struct EnumDef {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct VariantKind {\n+    /// Name of the variant.\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n+    /// Attributes of the variant.\n     pub attrs: HirVec<Attribute>,\n+    /// Id of the variant (not the constructor, see `VariantData::ctor_hir_id()`).\n+    pub id: HirId,\n+    /// Fields and constructor id of the variant.\n     pub data: VariantData,\n     /// Explicit discriminant (e.g., `Foo = 1`).\n     pub disr_expr: Option<AnonConst>,\n@@ -2063,7 +2068,7 @@ pub type Variant = Spanned<VariantKind>;\n pub enum UseKind {\n     /// One import, e.g., `use foo::bar` or `use foo::bar as baz`.\n     /// Also produced for each element of a list `use`, e.g.\n-    // `use foo::{a, b}` lowers to `use foo::a; use foo::b;`.\n+    /// `use foo::{a, b}` lowers to `use foo::a; use foo::b;`.\n     Single,\n \n     /// Glob import, e.g., `use foo::*`.\n@@ -2170,57 +2175,37 @@ impl StructField {\n     }\n }\n \n-/// Fields and Ids of enum variants and structs\n-///\n-/// For enum variants: `NodeId` represents both an Id of the variant itself (relevant for all\n-/// variant kinds) and an Id of the variant's constructor (not relevant for `Struct`-variants).\n-/// One shared Id can be successfully used for these two purposes.\n-/// Id of the whole enum lives in `Item`.\n-///\n-/// For structs: `NodeId` represents an Id of the structure's constructor, so it is not actually\n-/// used for `Struct`-structs (but still present). Structures don't have an analogue of \"Id of\n-/// the variant itself\" from enum variants.\n-/// Id of the whole struct lives in `Item`.\n+/// Fields and constructor ids of enum variants and structs\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum VariantData {\n-    Struct(HirVec<StructField>, HirId, /* recovered */ bool),\n+    /// Struct variant.\n+    ///\n+    /// e.g., `Bar { .. }` as in `enum Foo { Bar { .. } }`.\n+    Struct(HirVec<StructField>, /* recovered */ bool),\n+    /// Tuple variant.\n+    ///\n+    /// E.g., `Bar(..)` as in `enum Foo { Bar(..) }`.\n     Tuple(HirVec<StructField>, HirId),\n+    /// Unit variant.\n+    ///\n+    /// E.g., `Bar = ..` as in `enum Foo { Bar = .. }`.\n     Unit(HirId),\n }\n \n impl VariantData {\n+    /// Return the fields of this variant.\n     pub fn fields(&self) -> &[StructField] {\n         match *self {\n             VariantData::Struct(ref fields, ..) | VariantData::Tuple(ref fields, ..) => fields,\n             _ => &[],\n         }\n     }\n-    pub fn hir_id(&self) -> HirId {\n+\n+    /// Return the `HirId` of this variant's constructor, if it has one.\n+    pub fn ctor_hir_id(&self) -> Option<HirId> {\n         match *self {\n-            VariantData::Struct(_, hir_id, _)\n-            | VariantData::Tuple(_, hir_id)\n-            | VariantData::Unit(hir_id) => hir_id,\n-        }\n-    }\n-    pub fn is_struct(&self) -> bool {\n-        if let VariantData::Struct(..) = *self {\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-    pub fn is_tuple(&self) -> bool {\n-        if let VariantData::Tuple(..) = *self {\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-    pub fn is_unit(&self) -> bool {\n-        if let VariantData::Unit(..) = *self {\n-            true\n-        } else {\n-            false\n+            VariantData::Struct(_, _) => None,\n+            VariantData::Tuple(_, hir_id) | VariantData::Unit(hir_id) => Some(hir_id),\n         }\n     }\n }\n@@ -2594,8 +2579,9 @@ pub enum Node<'hir> {\n     Local(&'hir Local),\n     MacroDef(&'hir MacroDef),\n \n-    /// StructCtor represents a tuple struct.\n-    StructCtor(&'hir VariantData),\n+    /// `Ctor` refers to the constructor of an enum variant or struct. Only tuple or unit variants\n+    /// with synthesized constructors.\n+    Ctor(&'hir VariantData),\n \n     Lifetime(&'hir Lifetime),\n     GenericParam(&'hir GenericParam),"}, {"sha": "e7eda5aab133fb2778a4e51df14484e4be92f906", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -1,4 +1,4 @@\n-use crate::hir::def::Def;\n+use crate::hir::def::{CtorOf, Def};\n use crate::hir::def_id::DefId;\n use crate::hir::{self, HirId, PatKind};\n use syntax::ast;\n@@ -55,7 +55,7 @@ impl hir::Pat {\n             PatKind::TupleStruct(hir::QPath::Resolved(_, ref path), ..) |\n             PatKind::Struct(hir::QPath::Resolved(_, ref path), ..) => {\n                 match path.def {\n-                    Def::Variant(..) | Def::VariantCtor(..) => true,\n+                    Def::Variant(..) => true,\n                     _ => false\n                 }\n             }\n@@ -125,8 +125,8 @@ impl hir::Pat {\n                 PatKind::TupleStruct(hir::QPath::Resolved(_, ref path), ..) |\n                 PatKind::Struct(hir::QPath::Resolved(_, ref path), ..) => {\n                     match path.def {\n-                        Def::Variant(id) |\n-                        Def::VariantCtor(id, ..) => variants.push(id),\n+                        Def::Variant(id) => variants.push(id),\n+                        Def::Ctor(id, CtorOf::Variant, ..) => variants.push(id),\n                         _ => ()\n                     }\n                 }"}, {"sha": "cdd4043f4bc2189624ac137b55d0aa23ea853af3", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 35, "deletions": 32, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -860,41 +860,44 @@ impl<'a> State<'a> {\n                         -> io::Result<()> {\n         self.print_name(name)?;\n         self.print_generic_params(&generics.params)?;\n-        if !struct_def.is_struct() {\n-            if struct_def.is_tuple() {\n-                self.popen()?;\n-                self.commasep(Inconsistent, struct_def.fields(), |s, field| {\n-                    s.maybe_print_comment(field.span.lo())?;\n-                    s.print_outer_attributes(&field.attrs)?;\n-                    s.print_visibility(&field.vis)?;\n-                    s.print_type(&field.ty)\n-                })?;\n-                self.pclose()?;\n-            }\n-            self.print_where_clause(&generics.where_clause)?;\n-            if print_finalizer {\n-                self.s.word(\";\")?;\n+        match struct_def {\n+            hir::VariantData::Tuple(..) | hir::VariantData::Unit(..) => {\n+                if let hir::VariantData::Tuple(..) = struct_def {\n+                    self.popen()?;\n+                    self.commasep(Inconsistent, struct_def.fields(), |s, field| {\n+                        s.maybe_print_comment(field.span.lo())?;\n+                        s.print_outer_attributes(&field.attrs)?;\n+                        s.print_visibility(&field.vis)?;\n+                        s.print_type(&field.ty)\n+                    })?;\n+                    self.pclose()?;\n+                }\n+                self.print_where_clause(&generics.where_clause)?;\n+                if print_finalizer {\n+                    self.s.word(\";\")?;\n+                }\n+                self.end()?;\n+                self.end() // close the outer-box\n             }\n-            self.end()?;\n-            self.end() // close the outer-box\n-        } else {\n-            self.print_where_clause(&generics.where_clause)?;\n-            self.nbsp()?;\n-            self.bopen()?;\n-            self.hardbreak_if_not_bol()?;\n-\n-            for field in struct_def.fields() {\n+            hir::VariantData::Struct(..) => {\n+                self.print_where_clause(&generics.where_clause)?;\n+                self.nbsp()?;\n+                self.bopen()?;\n                 self.hardbreak_if_not_bol()?;\n-                self.maybe_print_comment(field.span.lo())?;\n-                self.print_outer_attributes(&field.attrs)?;\n-                self.print_visibility(&field.vis)?;\n-                self.print_ident(field.ident)?;\n-                self.word_nbsp(\":\")?;\n-                self.print_type(&field.ty)?;\n-                self.s.word(\",\")?;\n-            }\n \n-            self.bclose(span)\n+                for field in struct_def.fields() {\n+                    self.hardbreak_if_not_bol()?;\n+                    self.maybe_print_comment(field.span.lo())?;\n+                    self.print_outer_attributes(&field.attrs)?;\n+                    self.print_visibility(&field.vis)?;\n+                    self.print_ident(field.ident)?;\n+                    self.word_nbsp(\":\")?;\n+                    self.print_type(&field.ty)?;\n+                    self.s.word(\",\")?;\n+                }\n+\n+                self.bclose(span)\n+            }\n         }\n     }\n "}, {"sha": "94f1d9c2710071ba795c108054427d90118c0cc2", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -917,7 +917,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n-        self.with_lint_attrs(v.node.data.hir_id(), &v.node.attrs, |cx| {\n+        self.with_lint_attrs(v.node.id, &v.node.attrs, |cx| {\n             run_lints!(cx, check_variant, v, g);\n             hir_visit::walk_variant(cx, v, g, item_id);\n             run_lints!(cx, check_variant_post, v, g);\n@@ -1073,7 +1073,9 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n                         item_id: ast::NodeId,\n                         _: Span) {\n         run_early_pass!(self, check_struct_def, s, ident, g, item_id);\n-        self.check_id(s.id());\n+        if let Some(ctor_hir_id) = s.ctor_id() {\n+            self.check_id(ctor_hir_id);\n+        }\n         ast_visit::walk_struct_def(self, s);\n         run_early_pass!(self, check_struct_def_post, s, ident, g, item_id);\n     }"}, {"sha": "e96fe3d3b7741b1dcc5122836a51e1474cdca83a", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -803,7 +803,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'a, 'tcx> {\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n-        self.with_lint_attrs(v.node.data.hir_id(), &v.node.attrs, |builder| {\n+        self.with_lint_attrs(v.node.id, &v.node.attrs, |builder| {\n             intravisit::walk_variant(builder, v, g, item_id);\n         })\n     }"}, {"sha": "f12367a89bbf3dae3c94414aa4a09812e8f812d6", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -7,7 +7,7 @@ use crate::hir::{self, PatKind, TyKind};\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::hir::itemlikevisit::ItemLikeVisitor;\n \n-use crate::hir::def::Def;\n+use crate::hir::def::{CtorOf, Def};\n use crate::hir::CodegenFnAttrFlags;\n use crate::hir::def_id::{DefId, LOCAL_CRATE};\n use crate::lint;\n@@ -54,8 +54,7 @@ struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn check_def_id(&mut self, def_id: DefId) {\n         if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n-            if should_explore(self.tcx, hir_id) ||\n-               self.struct_constructors.contains_key(&hir_id) {\n+            if should_explore(self.tcx, hir_id) || self.struct_constructors.contains_key(&hir_id) {\n                 self.worklist.push(hir_id);\n             }\n             self.live_symbols.insert(hir_id);\n@@ -77,10 +76,17 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             _ if self.in_pat => (),\n             Def::PrimTy(..) | Def::SelfTy(..) | Def::SelfCtor(..) |\n             Def::Local(..) | Def::Upvar(..) => {}\n-            Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n-                if let Some(enum_id) = self.tcx.parent(variant_id) {\n-                    self.check_def_id(enum_id);\n+            Def::Ctor(ctor_def_id, CtorOf::Variant, ..) => {\n+                let variant_id = self.tcx.parent(ctor_def_id).unwrap();\n+                let enum_id = self.tcx.parent(variant_id).unwrap();\n+                self.check_def_id(enum_id);\n+                if !self.ignore_variant_stack.contains(&ctor_def_id) {\n+                    self.check_def_id(variant_id);\n                 }\n+            }\n+            Def::Variant(variant_id) => {\n+                let enum_id = self.tcx.parent(variant_id).unwrap();\n+                self.check_def_id(enum_id);\n                 if !self.ignore_variant_stack.contains(&variant_id) {\n                     self.check_def_id(variant_id);\n                 }\n@@ -360,9 +366,16 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n             self.worklist.push(item.hir_id);\n         }\n         match item.node {\n-            hir::ItemKind::Enum(ref enum_def, _) if allow_dead_code => {\n-                self.worklist.extend(enum_def.variants.iter()\n-                                                      .map(|variant| variant.node.data.hir_id()));\n+            hir::ItemKind::Enum(ref enum_def, _) => {\n+                if allow_dead_code {\n+                    self.worklist.extend(enum_def.variants.iter().map(|variant| variant.node.id));\n+                }\n+\n+                for variant in &enum_def.variants {\n+                    if let Some(ctor_hir_id) = variant.node.data.ctor_hir_id() {\n+                        self.struct_constructors.insert(ctor_hir_id, variant.node.id);\n+                    }\n+                }\n             }\n             hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 for trait_item_ref in trait_item_refs {\n@@ -392,7 +405,9 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n                 }\n             }\n             hir::ItemKind::Struct(ref variant_data, _) => {\n-                self.struct_constructors.insert(variant_data.hir_id(), item.hir_id);\n+                if let Some(ctor_hir_id) = variant_data.ctor_hir_id() {\n+                    self.struct_constructors.insert(ctor_hir_id, item.hir_id);\n+                }\n             }\n             _ => ()\n         }\n@@ -484,9 +499,9 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     }\n \n     fn should_warn_about_variant(&mut self, variant: &hir::VariantKind) -> bool {\n-        !self.symbol_is_live(variant.data.hir_id())\n+        !self.symbol_is_live(variant.id)\n             && !has_allow_dead_code_or_lang_attr(self.tcx,\n-                                                 variant.data.hir_id(),\n+                                                 variant.id,\n                                                  &variant.attrs)\n     }\n \n@@ -583,7 +598,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n                      g: &'tcx hir::Generics,\n                      id: hir::HirId) {\n         if self.should_warn_about_variant(&variant.node) {\n-            self.warn_dead_code(variant.node.data.hir_id(), variant.span, variant.node.ident.name,\n+            self.warn_dead_code(variant.node.id, variant.span, variant.node.ident.name,\n                                 \"variant\", \"constructed\");\n         } else {\n             intravisit::walk_variant(self, variant, g, id);"}, {"sha": "6c8d9fe29d7a0e8832a0a4da4a18cb4794a7c250", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -9,12 +9,12 @@ pub use self::MatchMode::*;\n use self::TrackMatchMode::*;\n use self::OverloadedCallType::*;\n \n-use crate::hir::def::Def;\n+use crate::hir::def::{CtorOf, Def};\n use crate::hir::def_id::DefId;\n use crate::infer::InferCtxt;\n use crate::middle::mem_categorization as mc;\n use crate::middle::region;\n-use crate::ty::{self, TyCtxt, adjustment};\n+use crate::ty::{self, DefIdTree, TyCtxt, adjustment};\n \n use crate::hir::{self, PatKind};\n use rustc_data_structures::sync::Lrc;\n@@ -902,14 +902,20 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             };\n             let def = mc.tables.qpath_def(qpath, pat.hir_id);\n             match def {\n-                Def::Variant(variant_did) |\n-                Def::VariantCtor(variant_did, ..) => {\n+                Def::Ctor(variant_ctor_did, CtorOf::Variant, ..) => {\n+                    let variant_did = mc.tcx.parent(variant_ctor_did).unwrap();\n+                    let downcast_cmt = mc.cat_downcast_if_needed(pat, cmt_pat, variant_did);\n+\n+                    debug!(\"variantctor downcast_cmt={:?} pat={:?}\", downcast_cmt, pat);\n+                    delegate.matched_pat(pat, &downcast_cmt, match_mode);\n+                }\n+                Def::Variant(variant_did) => {\n                     let downcast_cmt = mc.cat_downcast_if_needed(pat, cmt_pat, variant_did);\n \n                     debug!(\"variant downcast_cmt={:?} pat={:?}\", downcast_cmt, pat);\n                     delegate.matched_pat(pat, &downcast_cmt, match_mode);\n                 }\n-                Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n+                Def::Struct(..) | Def::Ctor(..) | Def::Union(..) |\n                 Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) => {\n                     debug!(\"struct cmt_pat={:?} pat={:?}\", cmt_pat, pat);\n                     delegate.matched_pat(pat, &cmt_pat, match_mode);"}, {"sha": "4b169dea06c7c7970bf17e7375f2ae1316cbd930", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -62,7 +62,7 @@ use crate::middle::region;\n use crate::hir::def_id::{DefId, LocalDefId};\n use crate::hir::Node;\n use crate::infer::InferCtxt;\n-use crate::hir::def::{Def, CtorKind};\n+use crate::hir::def::{CtorOf, Def, CtorKind};\n use crate::ty::adjustment;\n use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n use crate::ty::fold::TypeFoldable;\n@@ -704,7 +704,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                hir_id, expr_ty, def);\n \n         match def {\n-            Def::StructCtor(..) | Def::VariantCtor(..) | Def::Const(..) | Def::ConstParam(..) |\n+            Def::Ctor(..) | Def::Const(..) | Def::ConstParam(..) |\n             Def::AssociatedConst(..) | Def::Fn(..) | Def::Method(..) | Def::SelfCtor(..) => {\n                 Ok(self.cat_rvalue_node(hir_id, span, expr_ty))\n             }\n@@ -1274,12 +1274,14 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                         debug!(\"access to unresolvable pattern {:?}\", pat);\n                         return Err(())\n                     }\n-                    Def::VariantCtor(def_id, CtorKind::Fn) => {\n-                        let enum_def = self.tcx.parent(def_id).unwrap();\n-                        (self.cat_downcast_if_needed(pat, cmt, def_id),\n-                        self.tcx.adt_def(enum_def).variant_with_id(def_id).fields.len())\n+                    Def::Ctor(variant_ctor_did, CtorOf::Variant, CtorKind::Fn) => {\n+                        let variant_did = self.tcx.parent(variant_ctor_did).unwrap();\n+                        let enum_did = self.tcx.parent(variant_did).unwrap();\n+                        (self.cat_downcast_if_needed(pat, cmt, variant_did),\n+                         self.tcx.adt_def(enum_did)\n+                             .variant_with_ctor_id(variant_ctor_did).fields.len())\n                     }\n-                    Def::StructCtor(_, CtorKind::Fn) | Def::SelfCtor(..) => {\n+                    Def::Ctor(_, CtorOf::Struct, CtorKind::Fn) | Def::SelfCtor(..) => {\n                         let ty = self.pat_ty_unadjusted(&pat)?;\n                         match ty.sty {\n                             ty::Adt(adt_def, _) => {\n@@ -1314,8 +1316,11 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                         debug!(\"access to unresolvable pattern {:?}\", pat);\n                         return Err(())\n                     }\n-                    Def::Variant(variant_did) |\n-                    Def::VariantCtor(variant_did, ..) => {\n+                    Def::Ctor(variant_ctor_did, CtorOf::Variant, _) => {\n+                        let variant_did = self.tcx.parent(variant_ctor_did).unwrap();\n+                        self.cat_downcast_if_needed(pat, cmt, variant_did)\n+                    }\n+                    Def::Variant(variant_did) => {\n                         self.cat_downcast_if_needed(pat, cmt, variant_did)\n                     }\n                     _ => cmt,"}, {"sha": "b57f96f2d469de6a82950cdff300c7ae5f304370", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -311,7 +311,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             // Nothing to recurse on for these\n             Node::ForeignItem(_) |\n             Node::Variant(_) |\n-            Node::StructCtor(_) |\n+            Node::Ctor(..) |\n             Node::Field(_) |\n             Node::Ty(_) |\n             Node::MacroDef(_) => {}"}, {"sha": "772c6ab4745439891d1c47645e66fe1549f999e9", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -258,8 +258,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n                 self.in_trait_impl = true;\n             }\n             hir::ItemKind::Struct(ref sd, _) => {\n-                if !sd.is_struct() {\n-                    self.annotate(sd.hir_id(), &i.attrs, i.span, AnnotationKind::Required, |_| {})\n+                if let Some(ctor_hir_id) = sd.ctor_hir_id() {\n+                    self.annotate(ctor_hir_id, &i.attrs, i.span, AnnotationKind::Required, |_| {})\n                 }\n             }\n             _ => {}\n@@ -289,8 +289,15 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     }\n \n     fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: HirId) {\n-        self.annotate(var.node.data.hir_id(), &var.node.attrs, var.span, AnnotationKind::Required,\n-            |v| { intravisit::walk_variant(v, var, g, item_id) })\n+        self.annotate(var.node.id, &var.node.attrs, var.span, AnnotationKind::Required,\n+            |v| {\n+                if let Some(ctor_hir_id) = var.node.data.ctor_hir_id() {\n+                    v.annotate(ctor_hir_id, &var.node.attrs, var.span, AnnotationKind::Required,\n+                               |_| {});\n+                }\n+\n+                intravisit::walk_variant(v, var, g, item_id)\n+            })\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx StructField) {\n@@ -364,7 +371,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n     }\n \n     fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: HirId) {\n-        self.check_missing_stability(var.node.data.hir_id(), var.span, \"variant\");\n+        self.check_missing_stability(var.node.id, var.span, \"variant\");\n         intravisit::walk_variant(self, var, g, item_id);\n     }\n "}, {"sha": "d747f348ac990c65b569470ef1cddee8ff4eb0e8", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -2410,7 +2410,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                         ty::tls::with(|tcx| {\n                             let substs = tcx.lift(&substs).expect(\"could not lift for printing\");\n                             FmtPrinter::new(tcx, f, Namespace::ValueNS)\n-                                .print_def_path(variant_def.did, substs)?;\n+                                .print_def_path(variant_def.def_id, substs)?;\n                             Ok(())\n                         })?;\n "}, {"sha": "5b5a7cc9ed85b1d3a237ceb2b062c3d19fe6de49", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -1077,23 +1077,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     _ => ArgKind::empty()\n                 }).collect::<Vec<ArgKind>>())\n             }\n-            Node::Variant(&hir::Variant {\n-                span,\n-                node: hir::VariantKind {\n-                    data: hir::VariantData::Tuple(ref fields, ..),\n-                    ..\n-                },\n-                ..\n-            }) => {\n-                (self.tcx.sess.source_map().def_span(span),\n-                 fields.iter().map(|field|\n-                     ArgKind::Arg(field.ident.to_string(), \"_\".to_string())\n-                 ).collect::<Vec<_>>())\n-            }\n-            Node::StructCtor(ref variant_data) => {\n-                (self.tcx.sess.source_map().def_span(\n-                    self.tcx.hir().span_by_hir_id(variant_data.hir_id())),\n-                 vec![ArgKind::empty(); variant_data.fields().len()])\n+            Node::Ctor(ref variant_data) => {\n+                let span = variant_data.ctor_hir_id()\n+                    .map(|hir_id| self.tcx.hir().span_by_hir_id(hir_id))\n+                    .unwrap_or(DUMMY_SP);\n+                let span = self.tcx.sess.source_map().def_span(span);\n+\n+                (span, vec![ArgKind::empty(); variant_data.fields().len()])\n             }\n             _ => panic!(\"non-FnLike node found: {:?}\", node),\n         }"}, {"sha": "963b4b439f84da38c29f6641142de6c6e617b786", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -104,33 +104,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     fn ty_inhabitedness_forest(self, ty: Ty<'tcx>) -> DefIdForest {\n         ty.uninhabited_from(self)\n     }\n-\n-    pub fn is_enum_variant_uninhabited_from(self,\n-                                            module: DefId,\n-                                            variant: &'tcx VariantDef,\n-                                            substs: SubstsRef<'tcx>)\n-                                            -> bool\n-    {\n-        self.variant_inhabitedness_forest(variant, substs).contains(self, module)\n-    }\n-\n-    pub fn is_variant_uninhabited_from_all_modules(self,\n-                                                   variant: &'tcx VariantDef,\n-                                                   substs: SubstsRef<'tcx>)\n-                                                   -> bool\n-    {\n-        !self.variant_inhabitedness_forest(variant, substs).is_empty()\n-    }\n-\n-    fn variant_inhabitedness_forest(self, variant: &'tcx VariantDef, substs: SubstsRef<'tcx>)\n-                                    -> DefIdForest {\n-        // Determine the ADT kind:\n-        let adt_def_id = self.adt_def_id_of_variant(variant);\n-        let adt_kind = self.adt_def(adt_def_id).adt_kind();\n-\n-        // Compute inhabitedness forest:\n-        variant.uninhabited_from(self, substs, adt_kind)\n-    }\n }\n \n impl<'a, 'gcx, 'tcx> AdtDef {\n@@ -148,7 +121,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n \n impl<'a, 'gcx, 'tcx> VariantDef {\n     /// Calculate the forest of DefIds from which this variant is visibly uninhabited.\n-    fn uninhabited_from(\n+    pub fn uninhabited_from(\n         &self,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         substs: SubstsRef<'tcx>,"}, {"sha": "f54e69f352a4ed481a0436086f5de8a448e7f4d4", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -150,9 +150,7 @@ impl<'tcx> InstanceDef<'tcx> {\n             _ => return true\n         };\n         match tcx.def_key(def_id).disambiguated_data.data {\n-            DefPathData::StructCtor |\n-            DefPathData::EnumVariant(..) |\n-            DefPathData::ClosureExpr => true,\n+            DefPathData::Ctor | DefPathData::ClosureExpr => true,\n             _ => false\n         }\n     }"}, {"sha": "f0045136f41bfc7f0b6016e3f896646a54d03052", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 105, "deletions": 75, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -6,9 +6,8 @@ pub use self::fold::TypeFoldable;\n \n use crate::hir::{map as hir_map, FreevarMap, GlobMap, TraitMap};\n use crate::hir::{HirId, Node};\n-use crate::hir::def::{Def, CtorKind, ExportMap};\n+use crate::hir::def::{Def, CtorOf, CtorKind, ExportMap};\n use crate::hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use crate::hir::map::DefPathData;\n use rustc_data_structures::svh::Svh;\n use rustc_macros::HashStable;\n use crate::ich::Fingerprint;\n@@ -1775,12 +1774,19 @@ bitflags! {\n     #[derive(HashStable)]\n     pub struct AdtFlags: u32 {\n         const NO_ADT_FLAGS        = 0;\n+        /// Indicates whether the ADT is an enum.\n         const IS_ENUM             = 1 << 0;\n+        /// Indicates whether the ADT is a union.\n         const IS_UNION            = 1 << 1;\n+        /// Indicates whether the ADT is a struct.\n         const IS_STRUCT           = 1 << 2;\n+        /// Indicates whether the ADT is a struct and has a constructor.\n         const HAS_CTOR            = 1 << 3;\n+        /// Indicates whether the type is a `PhantomData`.\n         const IS_PHANTOM_DATA     = 1 << 4;\n+        /// Indicates whether the type has a `#[fundamental]` attribute.\n         const IS_FUNDAMENTAL      = 1 << 5;\n+        /// Indicates whether the type is a `Box`.\n         const IS_BOX              = 1 << 6;\n         /// Indicates whether the type is an `Arc`.\n         const IS_ARC              = 1 << 7;\n@@ -1801,55 +1807,73 @@ bitflags! {\n     }\n }\n \n+/// Definition of a variant -- a struct's fields or a enum variant.\n #[derive(Debug)]\n pub struct VariantDef {\n-    /// The variant's `DefId`. If this is a tuple-like struct,\n-    /// this is the `DefId` of the struct's ctor.\n-    pub did: DefId,\n-    pub ident: Ident, // struct's name if this is a struct\n+    /// `DefId` that identifies the variant itself.\n+    /// If this variant belongs to a struct or union, then this is a copy of its `DefId`.\n+    pub def_id: DefId,\n+    /// `DefId` that identifies the variant's constructor.\n+    /// If this variant is a struct variant, then this is `None`.\n+    pub ctor_def_id: Option<DefId>,\n+    /// Variant or struct name.\n+    pub ident: Ident,\n+    /// Discriminant of this variant.\n     pub discr: VariantDiscr,\n+    /// Fields of this variant.\n     pub fields: Vec<FieldDef>,\n+    /// Type of constructor of variant.\n     pub ctor_kind: CtorKind,\n+    /// Flags of the variant (e.g. is field list non-exhaustive)?\n     flags: VariantFlags,\n+    /// Recovered?\n     pub recovered: bool,\n }\n \n impl<'a, 'gcx, 'tcx> VariantDef {\n     /// Creates a new `VariantDef`.\n     ///\n-    /// - `did` is the `DefId` used for the variant.\n-    /// This is the constructor `DefId` for tuple stucts, and the variant `DefId` for everything\n-    /// else.\n-    /// - `attribute_def_id` is the DefId that has the variant's attributes.\n-    /// This is the struct `DefId` for structs, and the variant `DefId` for variants.\n+    /// `variant_did` is the `DefId` that identifies the enum variant (if this `VariantDef`\n+    /// represents an enum variant).\n+    ///\n+    /// `ctor_did` is the `DefId` that identifies the constructor of unit or\n+    /// tuple-variants/structs. If this is a `struct`-variant then this should be `None`.\n     ///\n-    /// Note that we *could* use the constructor `DefId`, because the constructor attributes\n-    /// redirect to the base attributes, but compiling a small crate requires\n-    /// loading the `AdtDef`s for all the structs in the universe (e.g., coherence for any\n+    /// `parent_did` is the `DefId` of the `AdtDef` representing the enum or struct that\n+    /// owns this variant. It is used for checking if a struct has `#[non_exhaustive]` w/out having\n+    /// to go through the redirect of checking the ctor's attributes - but compiling a small crate\n+    /// requires loading the `AdtDef`s for all the structs in the universe (e.g., coherence for any\n     /// built-in trait), and we do not want to load attributes twice.\n     ///\n     /// If someone speeds up attribute loading to not be a performance concern, they can\n     /// remove this hack and use the constructor `DefId` everywhere.\n     pub fn new(\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-        did: DefId,\n         ident: Ident,\n+        variant_did: Option<DefId>,\n+        ctor_def_id: Option<DefId>,\n         discr: VariantDiscr,\n         fields: Vec<FieldDef>,\n-        adt_kind: AdtKind,\n         ctor_kind: CtorKind,\n-        attribute_def_id: DefId,\n+        adt_kind: AdtKind,\n+        parent_did: DefId,\n         recovered: bool,\n     ) -> Self {\n-        debug!(\"VariantDef::new({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?})\", did, ident, discr,\n-               fields, adt_kind, ctor_kind, attribute_def_id);\n+        debug!(\n+            \"VariantDef::new(ident = {:?}, variant_did = {:?}, ctor_def_id = {:?}, discr = {:?},\n+             fields = {:?}, ctor_kind = {:?}, adt_kind = {:?}, parent_did = {:?})\",\n+             ident, variant_did, ctor_def_id, discr, fields, ctor_kind, adt_kind, parent_did,\n+        );\n+\n         let mut flags = VariantFlags::NO_VARIANT_FLAGS;\n-        if adt_kind == AdtKind::Struct && tcx.has_attr(attribute_def_id, \"non_exhaustive\") {\n-            debug!(\"found non-exhaustive field list for {:?}\", did);\n+        if adt_kind == AdtKind::Struct && tcx.has_attr(parent_did, \"non_exhaustive\") {\n+            debug!(\"found non-exhaustive field list for {:?}\", parent_did);\n             flags = flags | VariantFlags::IS_FIELD_LIST_NON_EXHAUSTIVE;\n         }\n+\n         VariantDef {\n-            did,\n+            def_id: variant_did.unwrap_or(parent_did),\n+            ctor_def_id,\n             ident,\n             discr,\n             fields,\n@@ -1859,14 +1883,16 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n         }\n     }\n \n+    /// Is this field list non-exhaustive?\n     #[inline]\n     pub fn is_field_list_non_exhaustive(&self) -> bool {\n         self.flags.intersects(VariantFlags::IS_FIELD_LIST_NON_EXHAUSTIVE)\n     }\n }\n \n impl_stable_hash_for!(struct VariantDef {\n-    did,\n+    def_id,\n+    ctor_def_id,\n     ident -> (ident.name),\n     discr,\n     fields,\n@@ -1898,12 +1924,15 @@ pub struct FieldDef {\n \n /// The definition of an abstract data type -- a struct or enum.\n ///\n-/// These are all interned (by `intern_adt_def`) into the `adt_defs`\n-/// table.\n+/// These are all interned (by `intern_adt_def`) into the `adt_defs` table.\n pub struct AdtDef {\n+    /// `DefId` of the struct, enum or union item.\n     pub did: DefId,\n+    /// Variants of the ADT. If this is a struct or enum, then there will be a single variant.\n     pub variants: IndexVec<self::layout::VariantIdx, VariantDef>,\n+    /// Flags of the ADT (e.g. is this a struct? is this non-exhaustive?)\n     flags: AdtFlags,\n+    /// Repr options provided by the user.\n     pub repr: ReprOptions,\n }\n \n@@ -2102,11 +2131,14 @@ impl ReprOptions {\n }\n \n impl<'a, 'gcx, 'tcx> AdtDef {\n-    fn new(tcx: TyCtxt<'_, '_, '_>,\n-           did: DefId,\n-           kind: AdtKind,\n-           variants: IndexVec<VariantIdx, VariantDef>,\n-           repr: ReprOptions) -> Self {\n+    /// Creates a new `AdtDef`.\n+    fn new(\n+        tcx: TyCtxt<'_, '_, '_>,\n+        did: DefId,\n+        kind: AdtKind,\n+        variants: IndexVec<VariantIdx, VariantDef>,\n+        repr: ReprOptions\n+    ) -> Self {\n         debug!(\"AdtDef::new({:?}, {:?}, {:?}, {:?})\", did, kind, variants, repr);\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n \n@@ -2120,13 +2152,8 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             AdtKind::Struct => AdtFlags::IS_STRUCT,\n         };\n \n-        if let AdtKind::Struct = kind {\n-            let variant_def = &variants[VariantIdx::new(0)];\n-            let def_key = tcx.def_key(variant_def.did);\n-            match def_key.disambiguated_data.data {\n-                DefPathData::StructCtor => flags |= AdtFlags::HAS_CTOR,\n-                _ => (),\n-            }\n+        if kind == AdtKind::Struct && variants[VariantIdx::new(0)].ctor_def_id.is_some() {\n+            flags |= AdtFlags::HAS_CTOR;\n         }\n \n         let attrs = tcx.get_attrs(did);\n@@ -2154,21 +2181,25 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n     }\n \n+    /// Returns `true` if this is a struct.\n     #[inline]\n     pub fn is_struct(&self) -> bool {\n         self.flags.contains(AdtFlags::IS_STRUCT)\n     }\n \n+    /// Returns `true` if this is a union.\n     #[inline]\n     pub fn is_union(&self) -> bool {\n         self.flags.contains(AdtFlags::IS_UNION)\n     }\n \n+    /// Returns `true` if this is a enum.\n     #[inline]\n     pub fn is_enum(&self) -> bool {\n         self.flags.contains(AdtFlags::IS_ENUM)\n     }\n \n+    /// Returns `true` if the variant list of this ADT is `#[non_exhaustive]`.\n     #[inline]\n     pub fn is_variant_list_non_exhaustive(&self) -> bool {\n         self.flags.contains(AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE)\n@@ -2186,6 +2217,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n     }\n \n+    /// Returns a description of this abstract data type.\n     pub fn descr(&self) -> &'static str {\n         match self.adt_kind() {\n             AdtKind::Struct => \"struct\",\n@@ -2194,6 +2226,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n     }\n \n+    /// Returns a description of a variant of this abstract data type.\n     #[inline]\n     pub fn variant_descr(&self) -> &'static str {\n         match self.adt_kind() {\n@@ -2267,24 +2300,30 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     }\n \n     pub fn variant_with_id(&self, vid: DefId) -> &VariantDef {\n-        self.variants\n-            .iter()\n-            .find(|v| v.did == vid)\n+        self.variants.iter().find(|v| v.def_id == vid)\n             .expect(\"variant_with_id: unknown variant\")\n     }\n \n+    pub fn variant_with_ctor_id(&self, cid: DefId) -> &VariantDef {\n+        self.variants.iter().find(|v| v.ctor_def_id == Some(cid))\n+            .expect(\"variant_with_ctor_id: unknown variant\")\n+    }\n+\n     pub fn variant_index_with_id(&self, vid: DefId) -> VariantIdx {\n-        self.variants\n-            .iter_enumerated()\n-            .find(|(_, v)| v.did == vid)\n-            .expect(\"variant_index_with_id: unknown variant\")\n-            .0\n+        self.variants.iter_enumerated().find(|(_, v)| v.def_id == vid)\n+            .expect(\"variant_index_with_id: unknown variant\").0\n+    }\n+\n+    pub fn variant_index_with_ctor_id(&self, cid: DefId) -> VariantIdx {\n+        self.variants.iter_enumerated().find(|(_, v)| v.ctor_def_id == Some(cid))\n+            .expect(\"variant_index_with_ctor_id: unknown variant\").0\n     }\n \n     pub fn variant_of_def(&self, def: Def) -> &VariantDef {\n         match def {\n-            Def::Variant(vid) | Def::VariantCtor(vid, ..) => self.variant_with_id(vid),\n-            Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n+            Def::Variant(vid) => self.variant_with_id(vid),\n+            Def::Ctor(cid, ..) => self.variant_with_ctor_id(cid),\n+            Def::Struct(..) | Def::Union(..) |\n             Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) |\n             Def::SelfCtor(..) => self.non_enum_variant(),\n             _ => bug!(\"unexpected def {:?} in variant_of_def\", def)\n@@ -2820,7 +2859,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn find_field_index(self, ident: Ident, variant: &VariantDef) -> Option<usize> {\n         variant.fields.iter().position(|field| {\n-            self.adjust_ident(ident, variant.did, hir::DUMMY_HIR_ID).0 == field.ident.modern()\n+            self.adjust_ident(ident, variant.def_id, hir::DUMMY_HIR_ID).0 == field.ident.modern()\n         })\n     }\n \n@@ -2895,50 +2934,41 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     // or variant or their constructors, panics otherwise.\n     pub fn expect_variant_def(self, def: Def) -> &'tcx VariantDef {\n         match def {\n-            Def::Variant(did) | Def::VariantCtor(did, ..) => {\n+            Def::Variant(did) => {\n                 let enum_did = self.parent(did).unwrap();\n                 self.adt_def(enum_did).variant_with_id(did)\n             }\n             Def::Struct(did) | Def::Union(did) => {\n                 self.adt_def(did).non_enum_variant()\n             }\n-            Def::StructCtor(ctor_did, ..) => {\n-                let did = self.parent(ctor_did).expect(\"struct ctor has no parent\");\n-                self.adt_def(did).non_enum_variant()\n+            Def::Ctor(variant_ctor_did, CtorOf::Variant, ..) => {\n+                let variant_did = self.parent(variant_ctor_did).unwrap();\n+                let enum_did = self.parent(variant_did).unwrap();\n+                self.adt_def(enum_did).variant_with_ctor_id(variant_ctor_did)\n+            }\n+            Def::Ctor(ctor_did, CtorOf::Struct, ..) => {\n+                let struct_did = self.parent(ctor_did).expect(\"struct ctor has no parent\");\n+                self.adt_def(struct_did).non_enum_variant()\n             }\n             _ => bug!(\"expect_variant_def used with unexpected def {:?}\", def)\n         }\n     }\n \n-    /// Given a `VariantDef`, returns the def-id of the `AdtDef` of which it is a part.\n-    pub fn adt_def_id_of_variant(self, variant_def: &'tcx VariantDef) -> DefId {\n-        let def_key = self.def_key(variant_def.did);\n-        match def_key.disambiguated_data.data {\n-            // for enum variants and tuple structs, the def-id of the ADT itself\n-            // is the *parent* of the variant\n-            DefPathData::EnumVariant(..) | DefPathData::StructCtor =>\n-                DefId { krate: variant_def.did.krate, index: def_key.parent.unwrap() },\n-\n-            // otherwise, for structs and unions, they share a def-id\n-            _ => variant_def.did,\n-        }\n-    }\n-\n     pub fn item_name(self, id: DefId) -> InternedString {\n         if id.index == CRATE_DEF_INDEX {\n             self.original_crate_name(id.krate).as_interned_str()\n         } else {\n             let def_key = self.def_key(id);\n-            // The name of a StructCtor is that of its struct parent.\n-            if let hir_map::DefPathData::StructCtor = def_key.disambiguated_data.data {\n-                self.item_name(DefId {\n-                    krate: id.krate,\n-                    index: def_key.parent.unwrap()\n-                })\n-            } else {\n-                def_key.disambiguated_data.data.get_opt_name().unwrap_or_else(|| {\n+            match def_key.disambiguated_data.data {\n+                // The name of a constructor is that of its parent.\n+                hir_map::DefPathData::Ctor =>\n+                    self.item_name(DefId {\n+                        krate: id.krate,\n+                        index: def_key.parent.unwrap()\n+                    }),\n+                _ => def_key.disambiguated_data.data.get_opt_name().unwrap_or_else(|| {\n                     bug!(\"item_name: no name for {:?}\", self.def_path(id));\n-                })\n+                }),\n             }\n         }\n     }"}, {"sha": "c9a4961a8e044cabfabbe53fb0ff850a0a6eb31e", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -285,14 +285,18 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n         let mut cur_def_key = self.tcx().def_key(def_id);\n         debug!(\"try_print_visible_def_path: cur_def_key={:?}\", cur_def_key);\n \n-        // For a UnitStruct or TupleStruct we want the name of its parent rather than <unnamed>.\n-        if let DefPathData::StructCtor = cur_def_key.disambiguated_data.data {\n-            let parent = DefId {\n-                krate: def_id.krate,\n-                index: cur_def_key.parent.expect(\"DefPathData::StructCtor missing a parent\"),\n-            };\n+        // For a constructor we want the name of its parent rather than <unnamed>.\n+        match cur_def_key.disambiguated_data.data {\n+            DefPathData::Ctor => {\n+                let parent = DefId {\n+                    krate: def_id.krate,\n+                    index: cur_def_key.parent\n+                        .expect(\"DefPathData::Ctor/VariantData missing a parent\"),\n+                };\n \n-            cur_def_key = self.tcx().def_key(parent);\n+                cur_def_key = self.tcx().def_key(parent);\n+            },\n+            _ => {},\n         }\n \n         let visible_parent = match visible_parent_map.get(&def_id).cloned() {\n@@ -860,7 +864,7 @@ impl TyCtxt<'_, '_, '_> {\n             DefPathData::AnonConst |\n             DefPathData::ConstParam(..) |\n             DefPathData::ClosureExpr |\n-            DefPathData::StructCtor => Namespace::ValueNS,\n+            DefPathData::Ctor => Namespace::ValueNS,\n \n             DefPathData::MacroDef(..) => Namespace::MacroNS,\n \n@@ -1024,7 +1028,7 @@ impl<F: fmt::Write> Printer<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F> {\n \n         // Skip `::{{constructor}}` on tuple/unit structs.\n         match disambiguated_data.data {\n-            DefPathData::StructCtor => return Ok(self),\n+            DefPathData::Ctor => return Ok(self),\n             _ => {}\n         }\n "}, {"sha": "ccead14e76b23ea68da5e34d49f32d69ce5cdca8", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -549,8 +549,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     /// Returns `true` if this `DefId` refers to the implicit constructor for\n     /// a tuple struct like `struct Foo(u32)`, and `false` otherwise.\n-    pub fn is_struct_constructor(self, def_id: DefId) -> bool {\n-        self.def_key(def_id).disambiguated_data.data == DefPathData::StructCtor\n+    pub fn is_constructor(self, def_id: DefId) -> bool {\n+        self.def_key(def_id).disambiguated_data.data == DefPathData::Ctor\n     }\n \n     /// Given the `DefId` of a fn or closure, returns the `DefId` of"}, {"sha": "09de907b75104c30533e5769acc814439192959a", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -85,8 +85,7 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n     let owner_id = tcx.hir().as_local_hir_id(owner_def_id).unwrap();\n \n     match tcx.hir().get_by_hir_id(owner_id) {\n-        Node::StructCtor(_) |\n-        Node::Variant(_) => {\n+        Node::Ctor(..) => {\n             // We get invoked with anything that has MIR, but some of\n             // those things (notably the synthesized constructors from\n             // tuple structs/variants) do not have an associated body"}, {"sha": "ebd48f0ae1e2b751a3fa63f9eb9a37fbaca47efb", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -522,7 +522,7 @@ impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n \n         // Skip `::{{constructor}}` on tuple/unit structs.\n         match disambiguated_data.data {\n-            DefPathData::StructCtor => return Ok(self),\n+            DefPathData::Ctor => return Ok(self),\n             _ => {}\n         }\n "}, {"sha": "6d694dcfac7be380474231a51f32714959a9d9ed", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -528,7 +528,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n \n     fn check_variant(&mut self, cx: &LateContext<'_, '_>, v: &hir::Variant, _: &hir::Generics) {\n         self.check_missing_docs_attrs(cx,\n-                                      Some(v.node.data.hir_id()),\n+                                      Some(v.node.id),\n                                       &v.node.attrs,\n                                       v.span,\n                                       \"a variant\");"}, {"sha": "995532a00cd6e98c91e8a06b8602658bbe27607b", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -407,6 +407,14 @@ impl cstore::CStore {\n         self.get_crate_data(def.krate).get_struct_field_names(def.index)\n     }\n \n+    pub fn ctor_kind_untracked(&self, def: DefId) -> def::CtorKind {\n+        self.get_crate_data(def.krate).get_ctor_kind(def.index)\n+    }\n+\n+    pub fn item_attrs_untracked(&self, def: DefId, sess: &Session) -> Lrc<[ast::Attribute]> {\n+        self.get_crate_data(def.krate).get_item_attrs(def.index, sess)\n+    }\n+\n     pub fn item_children_untracked(&self, def_id: DefId, sess: &Session) -> Vec<def::Export> {\n         let mut result = vec![];\n         self.get_crate_data(def_id.krate)"}, {"sha": "fb519407398fe9a1074a216b0cf0ddb5e25d1e86", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 37, "deletions": 28, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -8,7 +8,7 @@ use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash, Definitions};\n use rustc::hir;\n use rustc::middle::cstore::LinkagePreference;\n use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n-use rustc::hir::def::{self, Def, CtorKind};\n+use rustc::hir::def::{self, Def, CtorOf, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, DefIndexAddressSpace,\n                          CRATE_DEF_INDEX, LOCAL_CRATE, LocalDefId};\n use rustc::hir::map::definitions::DefPathTable;\n@@ -544,27 +544,33 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    fn get_variant(&self,\n-                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                   item: &Entry<'_>,\n-                   index: DefIndex,\n-                   adt_kind: ty::AdtKind)\n-                   -> ty::VariantDef\n-    {\n+    fn get_variant(\n+        &self,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        item: &Entry<'_>,\n+        index: DefIndex,\n+        parent_did: DefId,\n+        adt_kind: ty::AdtKind\n+    ) -> ty::VariantDef {\n         let data = match item.kind {\n             EntryKind::Variant(data) |\n             EntryKind::Struct(data, _) |\n             EntryKind::Union(data, _) => data.decode(self),\n             _ => bug!(),\n         };\n \n-        let def_id = self.local_def_id(data.struct_ctor.unwrap_or(index));\n-        let attribute_def_id = self.local_def_id(index);\n+        let variant_did = if adt_kind == ty::AdtKind::Enum {\n+            Some(self.local_def_id(index))\n+        } else {\n+            None\n+        };\n+        let ctor_did = data.ctor.map(|index| self.local_def_id(index));\n \n         ty::VariantDef::new(\n             tcx,\n-            def_id,\n             Ident::from_interned_str(self.item_name(index)),\n+            variant_did,\n+            ctor_did,\n             data.discr,\n             item.children.decode(self).map(|index| {\n                 let f = self.entry(index);\n@@ -574,9 +580,9 @@ impl<'a, 'tcx> CrateMetadata {\n                     vis: f.visibility.decode(self)\n                 }\n             }).collect(),\n-            adt_kind,\n             data.ctor_kind,\n-            attribute_def_id,\n+            adt_kind,\n+            parent_did,\n             false,\n         )\n     }\n@@ -599,11 +605,11 @@ impl<'a, 'tcx> CrateMetadata {\n             item.children\n                 .decode(self)\n                 .map(|index| {\n-                    self.get_variant(tcx, &self.entry(index), index, kind)\n+                    self.get_variant(tcx, &self.entry(index), index, did, kind)\n                 })\n                 .collect()\n         } else {\n-            std::iter::once(self.get_variant(tcx, &item, item_id, kind)).collect()\n+            std::iter::once(self.get_variant(tcx, &item, item_id, did, kind)).collect()\n         };\n \n         tcx.alloc_adt_def(did, kind, variants, repr)\n@@ -808,22 +814,22 @@ impl<'a, 'tcx> CrateMetadata {\n                     // Re-export lists automatically contain constructors when necessary.\n                     match def {\n                         Def::Struct(..) => {\n-                            if let Some(ctor_def_id) = self.get_struct_ctor_def_id(child_index) {\n+                            if let Some(ctor_def_id) = self.get_ctor_def_id(child_index) {\n                                 let ctor_kind = self.get_ctor_kind(child_index);\n-                                let ctor_def = Def::StructCtor(ctor_def_id, ctor_kind);\n-                                callback(def::Export {\n-                                    def: ctor_def,\n-                                    vis: self.get_visibility(ctor_def_id.index),\n-                                    ident, span,\n-                                });\n+                                let ctor_def = Def::Ctor(ctor_def_id, CtorOf::Struct, ctor_kind);\n+                                let vis = self.get_visibility(ctor_def_id.index);\n+                                callback(def::Export { def: ctor_def, vis, ident, span });\n                             }\n                         }\n                         Def::Variant(def_id) => {\n                             // Braced variants, unlike structs, generate unusable names in\n                             // value namespace, they are reserved for possible future use.\n+                            // It's ok to use the variant's id as a ctor id since an\n+                            // error will be reported on any use of such resolution anyway.\n+                            let ctor_def_id = self.get_ctor_def_id(child_index).unwrap_or(def_id);\n                             let ctor_kind = self.get_ctor_kind(child_index);\n-                            let ctor_def = Def::VariantCtor(def_id, ctor_kind);\n-                            let vis = self.get_visibility(child_index);\n+                            let ctor_def = Def::Ctor(ctor_def_id, CtorOf::Variant, ctor_kind);\n+                            let vis = self.get_visibility(ctor_def_id.index);\n                             callback(def::Export { def: ctor_def, ident, vis, span });\n                         }\n                         _ => {}\n@@ -925,10 +931,13 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_struct_ctor_def_id(&self, node_id: DefIndex) -> Option<DefId> {\n+    pub fn get_ctor_def_id(&self, node_id: DefIndex) -> Option<DefId> {\n         match self.entry(node_id).kind {\n             EntryKind::Struct(data, _) => {\n-                data.decode(self).struct_ctor.map(|index| self.local_def_id(index))\n+                data.decode(self).ctor.map(|index| self.local_def_id(index))\n+            }\n+            EntryKind::Variant(data) => {\n+                data.decode(self).ctor.map(|index| self.local_def_id(index))\n             }\n             _ => None,\n         }\n@@ -939,11 +948,11 @@ impl<'a, 'tcx> CrateMetadata {\n             return Lrc::new([]);\n         }\n \n-        // The attributes for a tuple struct are attached to the definition, not the ctor;\n+        // The attributes for a tuple struct/variant are attached to the definition, not the ctor;\n         // we assume that someone passing in a tuple struct ctor is actually wanting to\n         // look at the definition\n         let def_key = self.def_key(node_id);\n-        let item_id = if def_key.disambiguated_data.data == DefPathData::StructCtor {\n+        let item_id = if def_key.disambiguated_data.data == DefPathData::Ctor {\n             def_key.parent.unwrap()\n         } else {\n             node_id"}, {"sha": "78a186fbb714ae37c9cff0e3ae18601a7df314cb", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 75, "deletions": 24, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -572,24 +572,21 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     /// will have to lookup the adt-def by its id, and that gives us\n     /// the right to access any information in the adt-def (including,\n     /// e.g., the length of the various vectors).\n-    fn encode_enum_variant_info(&mut self,\n-                                (enum_did, Untracked(index)): (DefId, Untracked<VariantIdx>))\n-                                -> Entry<'tcx> {\n+    fn encode_enum_variant_info(\n+        &mut self,\n+        (enum_did, Untracked(index)): (DefId, Untracked<VariantIdx>),\n+    ) -> Entry<'tcx> {\n         let tcx = self.tcx;\n         let def = tcx.adt_def(enum_did);\n         let variant = &def.variants[index];\n-        let def_id = variant.did;\n+        let def_id = variant.def_id;\n         debug!(\"IsolatedEncoder::encode_enum_variant_info({:?})\", def_id);\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n-            struct_ctor: None,\n-            ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n-                Some(self.lazy(&tcx.fn_sig(def_id)))\n-            } else {\n-                None\n-            }\n+            ctor: variant.ctor_def_id.map(|did| did.index),\n+            ctor_sig: None,\n         };\n \n         let enum_id = tcx.hir().as_local_hir_id(enum_did).unwrap();\n@@ -622,6 +619,57 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         }\n     }\n \n+    /// Encode the constructor for the given variant of the given ADT. See\n+    /// `encode_enum_variant_info` for an explanation about why the index is untracked.\n+    fn encode_enum_variant_ctor(\n+        &mut self,\n+        (enum_did, Untracked(index)): (DefId, Untracked<VariantIdx>),\n+    ) -> Entry<'tcx> {\n+        let tcx = self.tcx;\n+        let def = tcx.adt_def(enum_did);\n+        let variant = &def.variants[index];\n+        let def_id = variant.ctor_def_id.unwrap();\n+        debug!(\"IsolatedEncoder::encode_enum_variant_ctor({:?})\", def_id);\n+\n+        let data = VariantData {\n+            ctor_kind: variant.ctor_kind,\n+            discr: variant.discr,\n+            ctor: Some(def_id.index),\n+            ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n+                Some(self.lazy(&tcx.fn_sig(def_id)))\n+            } else {\n+                None\n+            }\n+        };\n+\n+        // Variant constructors have the same visibility as the parent enums.\n+        let enum_id = tcx.hir().as_local_hir_id(enum_did).unwrap();\n+        let enum_vis = &tcx.hir().expect_item_by_hir_id(enum_id).vis;\n+\n+        Entry {\n+            kind: EntryKind::Variant(self.lazy(&data)),\n+            visibility: self.lazy(&ty::Visibility::from_hir(enum_vis, enum_id, tcx)),\n+            span: self.lazy(&tcx.def_span(def_id)),\n+            attributes: LazySeq::empty(),\n+            children: LazySeq::empty(),\n+            stability: self.encode_stability(def_id),\n+            deprecation: self.encode_deprecation(def_id),\n+\n+            ty: Some(self.encode_item_type(def_id)),\n+            inherent_impls: LazySeq::empty(),\n+            variances: if variant.ctor_kind == CtorKind::Fn {\n+                self.encode_variances_of(def_id)\n+            } else {\n+                LazySeq::empty()\n+            },\n+            generics: Some(self.encode_generics(def_id)),\n+            predicates: Some(self.encode_predicates(def_id)),\n+            predicates_defined_on: None,\n+\n+            mir: self.encode_optimized_mir(def_id),\n+        }\n+    }\n+\n     fn encode_info_for_mod(&mut self,\n                            FromId(id, (md, attrs, vis)): FromId<(&hir::Mod,\n                                                                  &[ast::Attribute],\n@@ -678,7 +726,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         let def_id = field.did;\n         debug!(\"IsolatedEncoder::encode_field({:?})\", def_id);\n \n-        let variant_id = tcx.hir().as_local_hir_id(variant.did).unwrap();\n+        let variant_id = tcx.hir().as_local_hir_id(variant.def_id).unwrap();\n         let variant_data = tcx.hir().expect_variant_data(variant_id);\n \n         Entry {\n@@ -710,7 +758,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n-            struct_ctor: Some(def_id.index),\n+            ctor: Some(def_id.index),\n             ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n                 Some(self.lazy(&tcx.fn_sig(def_id)))\n             } else {\n@@ -1072,18 +1120,15 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 // Encode def_ids for each field and method\n                 // for methods, write all the stuff get_trait_method\n                 // needs to know\n-                let struct_ctor = if !struct_def.is_struct() {\n-                    Some(tcx.hir().local_def_id_from_hir_id(struct_def.hir_id()).index)\n-                } else {\n-                    None\n-                };\n+                let ctor = struct_def.ctor_hir_id()\n+                    .map(|ctor_hir_id| tcx.hir().local_def_id_from_hir_id(ctor_hir_id).index);\n \n                 let repr_options = get_repr_options(&tcx, def_id);\n \n                 EntryKind::Struct(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n-                    struct_ctor,\n+                    ctor,\n                     ctor_sig: None,\n                 }), repr_options)\n             }\n@@ -1094,7 +1139,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 EntryKind::Union(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n-                    struct_ctor: None,\n+                    ctor: None,\n                     ctor_sig: None,\n                 }), repr_options)\n             }\n@@ -1171,8 +1216,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 hir::ItemKind::Enum(..) => {\n                     let def = self.tcx.adt_def(def_id);\n                     self.lazy_seq(def.variants.iter().map(|v| {\n-                        assert!(v.did.is_local());\n-                        v.did.index\n+                        assert!(v.def_id.is_local());\n+                        v.def_id.index\n                     }))\n                 }\n                 hir::ItemKind::Struct(..) |\n@@ -1765,17 +1810,23 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n \n                 let def = self.tcx.adt_def(def_id);\n                 for (i, variant) in def.variants.iter_enumerated() {\n-                    self.record(variant.did,\n+                    self.record(variant.def_id,\n                                 IsolatedEncoder::encode_enum_variant_info,\n                                 (def_id, Untracked(i)));\n+\n+                    if let Some(ctor_def_id) = variant.ctor_def_id {\n+                        self.record(ctor_def_id,\n+                                    IsolatedEncoder::encode_enum_variant_ctor,\n+                                    (def_id, Untracked(i)));\n+                    }\n                 }\n             }\n             hir::ItemKind::Struct(ref struct_def, _) => {\n                 self.encode_fields(def_id);\n \n                 // If the struct has a constructor, encode it.\n-                if !struct_def.is_struct() {\n-                    let ctor_def_id = self.tcx.hir().local_def_id_from_hir_id(struct_def.hir_id());\n+                if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n+                    let ctor_def_id = self.tcx.hir().local_def_id_from_hir_id(ctor_hir_id);\n                     self.record(ctor_def_id,\n                                 IsolatedEncoder::encode_struct_ctor,\n                                 (def_id, ctor_def_id));"}, {"sha": "5b6166ebeaf59cc693321247827e826ece79715e", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -445,11 +445,8 @@ impl_stable_hash_for!(struct FnData<'tcx> { constness, arg_names, sig });\n pub struct VariantData<'tcx> {\n     pub ctor_kind: CtorKind,\n     pub discr: ty::VariantDiscr,\n-\n-    /// If this is a struct's only variant, this\n-    /// is the index of the \"struct ctor\" item.\n-    pub struct_ctor: Option<DefIndex>,\n-\n+    /// If this is unit or tuple-variant/struct, then this is the index of the ctor id.\n+    pub ctor: Option<DefIndex>,\n     /// If this is a tuple struct or variant\n     /// ctor, this is its \"function\" signature.\n     pub ctor_sig: Option<Lazy<ty::PolyFnSig<'tcx>>>,\n@@ -458,7 +455,7 @@ pub struct VariantData<'tcx> {\n impl_stable_hash_for!(struct VariantData<'tcx> {\n     ctor_kind,\n     discr,\n-    struct_ctor,\n+    ctor,\n     ctor_sig\n });\n "}, {"sha": "dc37c1a67c02369782d35be81bbd18dc75d69153", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -75,8 +75,8 @@ fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> BorrowC\n     // Return early if we are not supposed to use MIR borrow checker for this function.\n     return_early = !tcx.has_attr(def_id, \"rustc_mir\") && !tcx.use_mir_borrowck();\n \n-    if tcx.is_struct_constructor(def_id) {\n-        // We are not borrow checking the automatically generated struct constructors\n+    if tcx.is_constructor(def_id) {\n+        // We are not borrow checking the automatically generated struct/variant constructors\n         // because we want to accept structs such as this (taken from the `linked-hash-map`\n         // crate):\n         // ```rust"}, {"sha": "d3d6b98627703ac3e9f948e665a5aa69e21ad783", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -2685,8 +2685,8 @@ impl MirPass for TypeckMir {\n             return;\n         }\n \n-        if tcx.is_struct_constructor(def_id) {\n-            // We just assume that the automatically generated struct constructors are\n+        if tcx.is_constructor(def_id) {\n+            // We just assume that the automatically generated struct/variant constructors are\n             // correct. See the comment in the `mir_borrowck` implementation for an\n             // explanation why we need this.\n             return;"}, {"sha": "2e4f53023f409e918cd5447f6fc1ef39e1dccb65", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -163,7 +163,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     i == variant_index || {\n                         self.hir.tcx().features().never_type &&\n                         self.hir.tcx().features().exhaustive_patterns &&\n-                        self.hir.tcx().is_variant_uninhabited_from_all_modules(v, substs)\n+                        !v.uninhabited_from(self.hir.tcx(), substs, adt_def.adt_kind()).is_empty()\n                     }\n                 });\n                 if irrefutable {"}, {"sha": "7fe86d11c9ee4df56e961f8ab70ed920e36128d8", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -31,10 +31,7 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n \n     // Figure out what primary body this item has.\n     let (body_id, return_ty_span) = match tcx.hir().get_by_hir_id(id) {\n-        Node::Variant(variant) =>\n-            return create_constructor_shim(tcx, id, &variant.node.data),\n-        Node::StructCtor(ctor) =>\n-            return create_constructor_shim(tcx, id, ctor),\n+        Node::Ctor(ctor) => return create_constructor_shim(tcx, id, ctor),\n \n         Node::Expr(hir::Expr { node: hir::ExprKind::Closure(_, decl, body_id, _, _), .. })\n         | Node::Item(hir::Item { node: hir::ItemKind::Fn(decl, _, _, body_id), .. })"}, {"sha": "2ca44ecaba220d586a9826ff69bba44ecc4d28b4", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -4,7 +4,7 @@ use crate::hair::cx::block;\n use crate::hair::cx::to_ref::ToRef;\n use crate::hair::util::UserAnnotatedTyHelpers;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc::hir::def::{Def, CtorKind};\n+use rustc::hir::def::{CtorOf, Def, CtorKind};\n use rustc::mir::interpret::{GlobalId, ErrorHandled, ConstValue};\n use rustc::ty::{self, AdtKind, Ty};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability};\n@@ -261,10 +261,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     // Tuple-like ADTs are represented as ExprKind::Call. We convert them here.\n                     expr_ty.ty_adt_def().and_then(|adt_def| {\n                         match path.def {\n-                            Def::VariantCtor(variant_id, CtorKind::Fn) => {\n-                                Some((adt_def, adt_def.variant_index_with_id(variant_id)))\n-                            }\n-                            Def::StructCtor(_, CtorKind::Fn) |\n+                            Def::Ctor(ctor_id, _, CtorKind::Fn) =>\n+                                Some((adt_def, adt_def.variant_index_with_ctor_id(ctor_id))),\n                             Def::SelfCtor(..) => Some((adt_def, VariantIdx::new(0))),\n                             _ => None,\n                         }\n@@ -677,8 +675,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         .ty_adt_def()\n                         .and_then(|adt_def| {\n                         match def {\n-                            Def::VariantCtor(variant_id, CtorKind::Const) => {\n-                                let idx = adt_def.variant_index_with_id(variant_id);\n+                            Def::Ctor(variant_ctor_id, CtorOf::Variant, CtorKind::Const) => {\n+                                let idx = adt_def.variant_index_with_ctor_id(variant_ctor_id);\n                                 let (d, o) = adt_def.discriminant_def_for_variant(idx);\n                                 use rustc::ty::util::IntTypeExt;\n                                 let ty = adt_def.repr.discr_type();\n@@ -804,17 +802,15 @@ fn user_substs_applied_to_def(\n         // `Fn` but with the user-given substitutions.\n         Def::Fn(_) |\n         Def::Method(_) |\n-        Def::StructCtor(_, CtorKind::Fn) |\n-        Def::VariantCtor(_, CtorKind::Fn) |\n+        Def::Ctor(_, _, CtorKind::Fn) |\n         Def::Const(_) |\n         Def::AssociatedConst(_) => cx.tables().user_provided_types().get(hir_id).map(|u_ty| *u_ty),\n \n         // A unit struct/variant which is used as a value (e.g.,\n         // `None`). This has the type of the enum/struct that defines\n         // this variant -- but with the substitutions given by the\n         // user.\n-        Def::StructCtor(_def_id, CtorKind::Const) |\n-        Def::VariantCtor(_def_id, CtorKind::Const) =>\n+        Def::Ctor(_, _, CtorKind::Const) =>\n             cx.user_substs_applied_to_ty_of_hir_id(hir_id),\n \n         // `Self` is used in expression as a tuple struct constructor or an unit struct constructor\n@@ -911,8 +907,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         // A regular function, constructor function or a constant.\n         Def::Fn(_) |\n         Def::Method(_) |\n-        Def::StructCtor(_, CtorKind::Fn) |\n-        Def::VariantCtor(_, CtorKind::Fn) |\n+        Def::Ctor(_, _, CtorKind::Fn) |\n         Def::SelfCtor(..) => {\n             let user_ty = user_substs_applied_to_def(cx, expr.hir_id, &def);\n             debug!(\"convert_path_expr: user_ty={:?}\", user_ty);\n@@ -956,8 +951,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         },\n \n-        Def::StructCtor(def_id, CtorKind::Const) |\n-        Def::VariantCtor(def_id, CtorKind::Const) => {\n+        Def::Ctor(def_id, _, CtorKind::Const) => {\n             let user_provided_types = cx.tables.user_provided_types();\n             let user_provided_type = user_provided_types.get(expr.hir_id).map(|u_ty| *u_ty);\n             debug!(\"convert_path_expr: user_provided_type={:?}\", user_provided_type);\n@@ -968,7 +962,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 ty::Adt(adt_def, substs) => {\n                     ExprKind::Adt {\n                         adt_def,\n-                        variant_index: adt_def.variant_index_with_id(def_id),\n+                        variant_index: adt_def.variant_index_with_ctor_id(def_id),\n                         substs,\n                         user_ty: user_provided_type,\n                         fields: vec![],"}, {"sha": "303ffcb3bfb3ab653a5d17137982f0c59bb8add8", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 12, "deletions": 23, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -168,7 +168,7 @@ use super::{PatternFoldable, PatternFolder, compare_const_vals};\n \n use rustc::hir::def_id::DefId;\n use rustc::hir::RangeEnd;\n-use rustc::ty::{self, subst::SubstsRef, Ty, TyCtxt, TypeFoldable, Const};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Const};\n use rustc::ty::layout::{Integer, IntegerExt, VariantIdx, Size};\n \n use rustc::mir::Field;\n@@ -399,22 +399,10 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n             _ => false,\n         }\n     }\n-\n-    fn is_variant_uninhabited(&self,\n-                              variant: &'tcx ty::VariantDef,\n-                              substs: SubstsRef<'tcx>)\n-                              -> bool\n-    {\n-        if self.tcx.features().exhaustive_patterns {\n-            self.tcx.is_enum_variant_uninhabited_from(self.module, variant, substs)\n-        } else {\n-            false\n-        }\n-    }\n }\n \n #[derive(Clone, Debug, PartialEq)]\n-pub enum Constructor<'tcx> {\n+enum Constructor<'tcx> {\n     /// The constructor of all patterns that don't vary by constructor,\n     /// e.g., struct patterns and fixed-length arrays.\n     Single,\n@@ -435,7 +423,7 @@ impl<'tcx> Constructor<'tcx> {\n         adt: &'tcx ty::AdtDef,\n     ) -> VariantIdx {\n         match self {\n-            &Variant(vid) => adt.variant_index_with_id(vid),\n+            &Variant(id) => adt.variant_index_with_id(id),\n             &Single => {\n                 assert!(!adt.is_enum());\n                 VariantIdx::new(0)\n@@ -658,8 +646,11 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         }\n         ty::Adt(def, substs) if def.is_enum() => {\n             def.variants.iter()\n-                .filter(|v| !cx.is_variant_uninhabited(v, substs))\n-                .map(|v| Variant(v.did))\n+                .filter(|v| {\n+                    !cx.tcx.features().exhaustive_patterns ||\n+                    !v.uninhabited_from(cx.tcx, substs, def.adt_kind()).contains(cx.tcx, cx.module)\n+                })\n+                .map(|v| Variant(v.def_id))\n                 .collect()\n         }\n         ty::Char => {\n@@ -1307,7 +1298,7 @@ fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n         PatternKind::Binding { .. } | PatternKind::Wild => None,\n         PatternKind::Leaf { .. } | PatternKind::Deref { .. } => Some(vec![Single]),\n         PatternKind::Variant { adt_def, variant_index, .. } => {\n-            Some(vec![Variant(adt_def.variants[variant_index].did)])\n+            Some(vec![Variant(adt_def.variants[variant_index].def_id)])\n         }\n         PatternKind::Constant { value } => Some(vec![ConstantValue(value)]),\n         PatternKind::Range(PatternRange { lo, hi, ty, end }) =>\n@@ -1742,11 +1733,9 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n \n         PatternKind::Variant { adt_def, variant_index, ref subpatterns, .. } => {\n             let ref variant = adt_def.variants[variant_index];\n-            if *constructor == Variant(variant.did) {\n-                Some(patterns_for_variant(subpatterns, wild_patterns))\n-            } else {\n-                None\n-            }\n+            Some(Variant(variant.def_id))\n+                .filter(|variant_constructor| variant_constructor == constructor)\n+                .map(|_| patterns_for_variant(subpatterns, wild_patterns))\n         }\n \n         PatternKind::Leaf { ref subpatterns } => {"}, {"sha": "6c532fce57f0eab1bb69443397b64ffa2082819c", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -18,7 +18,7 @@ use rustc::ty::{CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTyp\n use rustc::ty::subst::{SubstsRef, Kind};\n use rustc::ty::layout::VariantIdx;\n use rustc::hir::{self, PatKind, RangeEnd};\n-use rustc::hir::def::{Def, CtorKind};\n+use rustc::hir::def::{CtorOf, Def, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n \n use rustc_data_structures::indexed_vec::Idx;\n@@ -733,8 +733,16 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         ty: Ty<'tcx>,\n         subpatterns: Vec<FieldPattern<'tcx>>,\n     ) -> PatternKind<'tcx> {\n+        let def = match def {\n+            Def::Ctor(variant_ctor_id, CtorOf::Variant, ..) => {\n+                let variant_id = self.tcx.parent(variant_ctor_id).unwrap();\n+                Def::Variant(variant_id)\n+            },\n+            def => def,\n+        };\n+\n         let mut kind = match def {\n-            Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n+            Def::Variant(variant_id) => {\n                 let enum_id = self.tcx.parent(variant_id).unwrap();\n                 let adt_def = self.tcx.adt_def(enum_id);\n                 if adt_def.is_enum() {\n@@ -757,7 +765,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 }\n             }\n \n-            Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n+            Def::Struct(..) | Def::Ctor(_, CtorOf::Struct, ..) | Def::Union(..) |\n             Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) | Def::SelfCtor(..) => {\n                 PatternKind::Leaf { subpatterns }\n             }"}, {"sha": "cb25db73cd2becaca867c00c2f150c48078ad548", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -880,7 +880,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n     };\n \n     let variant_no = if adt_def.is_enum() {\n-        adt_def.variant_index_with_id(def_id)\n+        adt_def.variant_index_with_ctor_id(def_id)\n     } else {\n         VariantIdx::new(0)\n     };"}, {"sha": "5e5e451b75bf2d2b853aedf5c0c316302142bb94", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -1,5 +1,4 @@\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc::hir::def::CtorKind;\n use rustc::mir::*;\n use rustc::mir::visit::Visitor;\n use rustc::ty::{self, TyCtxt};\n@@ -587,15 +586,12 @@ fn write_mir_sig(\n     trace!(\"write_mir_sig: {:?}\", src.instance);\n     let descr = tcx.describe_def(src.def_id());\n     let is_function = match descr {\n-        Some(Def::Fn(_)) | Some(Def::Method(_)) | Some(Def::Variant(..)) |\n-        Some(Def::StructCtor(_, CtorKind::Fn)) => true,\n+        Some(Def::Fn(_)) | Some(Def::Method(_)) | Some(Def::Ctor(..)) => true,\n         _ => tcx.is_closure(src.def_id()),\n     };\n     match (descr, src.promoted) {\n         (_, Some(i)) => write!(w, \"{:?} in \", i)?,\n-        (Some(Def::StructCtor(..)), _) => write!(w, \"struct \")?,\n-        (Some(Def::Const(_)), _)\n-        | (Some(Def::AssociatedConst(_)), _) => write!(w, \"const \")?,\n+        (Some(Def::Const(_)), _) | (Some(Def::AssociatedConst(_)), _) => write!(w, \"const \")?,\n         (Some(Def::Static(_, /*is_mutbl*/false)), _) => write!(w, \"static \")?,\n         (Some(Def::Static(_, /*is_mutbl*/true)), _) => write!(w, \"static mut \")?,\n         (_, _) if is_function => write!(w, \"fn \")?,"}, {"sha": "4e2aefe623167ffdb16e967db09ada688b74ca7e", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -661,7 +661,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 }\n             }\n             ItemKind::Union(ref vdata, _) => {\n-                if !vdata.is_struct() {\n+                if let VariantData::Tuple(..) | VariantData::Unit(..) = vdata {\n                     self.err_handler().span_err(item.span,\n                                                 \"tuple and unit unions are not permitted\");\n                 }"}, {"sha": "71eb6ed7e0517be357bfb9038198eb437f60f0f0", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -322,8 +322,8 @@ fn check_expr_kind<'a, 'tcx>(\n         hir::ExprKind::Path(ref qpath) => {\n             let def = v.tables.qpath_def(qpath, e.hir_id);\n             match def {\n-                Def::VariantCtor(..) | Def::StructCtor(..) |\n-                Def::Fn(..) | Def::Method(..) | Def::SelfCtor(..) => Promotable,\n+                Def::Ctor(..) | Def::Fn(..) | Def::Method(..) | Def::SelfCtor(..) =>\n+                    Promotable,\n \n                 // References to a static that are themselves within a static\n                 // are inherently promotable with the exception\n@@ -387,8 +387,7 @@ fn check_expr_kind<'a, 'tcx>(\n                 Def::Err\n             };\n             let def_result = match def {\n-                Def::StructCtor(_, CtorKind::Fn) |\n-                Def::VariantCtor(_, CtorKind::Fn) |\n+                Def::Ctor(_, _, CtorKind::Fn) |\n                 Def::SelfCtor(..) => Promotable,\n                 Def::Fn(did) => v.handle_const_fn_call(did),\n                 Def::Method(did) => {"}, {"sha": "bbd03e82a3730b8e262103c833394f74e87c89a5", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 46, "deletions": 31, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -239,36 +239,48 @@ fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                         node => bug!(\"unexpected node kind: {:?}\", node),\n                     }\n                 }\n-                Node::StructCtor(vdata) => {\n-                    let struct_hir_id = tcx.hir().get_parent_item(hir_id);\n-                    let item = match tcx.hir().get_by_hir_id(struct_hir_id) {\n-                        Node::Item(item) => item,\n-                        node => bug!(\"unexpected node kind: {:?}\", node),\n-                    };\n-                    let (mut ctor_vis, mut span, mut descr) =\n-                        (ty::Visibility::from_hir(&item.vis, struct_hir_id, tcx),\n-                         item.vis.span, item.vis.node.descr());\n-                    for field in vdata.fields() {\n-                        let field_vis = ty::Visibility::from_hir(&field.vis, hir_id, tcx);\n-                        if ctor_vis.is_at_least(field_vis, tcx) {\n-                            ctor_vis = field_vis;\n-                            span = field.vis.span;\n-                            descr = field.vis.node.descr();\n+                Node::Ctor(vdata) => {\n+                    let parent_hir_id = tcx.hir().get_parent_node_by_hir_id(hir_id);\n+                    match tcx.hir().get_by_hir_id(parent_hir_id) {\n+                        Node::Variant(..) => {\n+                            let parent_did = tcx.hir().local_def_id_from_hir_id(parent_hir_id);\n+                            return def_id_visibility(tcx, parent_did);\n                         }\n-                    }\n+                        Node::Item(..) => {\n+                            let item = match tcx.hir().get_by_hir_id(parent_hir_id) {\n+                                Node::Item(item) => item,\n+                                node => bug!(\"unexpected node kind: {:?}\", node),\n+                            };\n+                            let (mut ctor_vis, mut span, mut descr) =\n+                                (ty::Visibility::from_hir(&item.vis, parent_hir_id, tcx),\n+                                item.vis.span, item.vis.node.descr());\n+                            for field in vdata.fields() {\n+                                let field_vis = ty::Visibility::from_hir(&field.vis, hir_id, tcx);\n+                                if ctor_vis.is_at_least(field_vis, tcx) {\n+                                    ctor_vis = field_vis;\n+                                    span = field.vis.span;\n+                                    descr = field.vis.node.descr();\n+                                }\n+                            }\n \n-                    // If the structure is marked as non_exhaustive then lower the\n-                    // visibility to within the crate.\n-                    if ctor_vis == ty::Visibility::Public {\n-                        let adt_def = tcx.adt_def(tcx.hir().get_parent_did_by_hir_id(hir_id));\n-                        if adt_def.non_enum_variant().is_field_list_non_exhaustive() {\n-                            ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n-                            span = attr::find_by_name(&item.attrs, \"non_exhaustive\").unwrap().span;\n-                            descr = \"crate-visible\";\n+                            // If the structure is marked as non_exhaustive then lower the\n+                            // visibility to within the crate.\n+                            if ctor_vis == ty::Visibility::Public {\n+                                let adt_def =\n+                                    tcx.adt_def(tcx.hir().get_parent_did_by_hir_id(hir_id));\n+                                if adt_def.non_enum_variant().is_field_list_non_exhaustive() {\n+                                    ctor_vis =\n+                                        ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n+                                    span = attr::find_by_name(&item.attrs, \"non_exhaustive\")\n+                                                .unwrap().span;\n+                                    descr = \"crate-visible\";\n+                                }\n+                            }\n+\n+                            return (ctor_vis, span, descr);\n                         }\n+                        node => bug!(\"unexpected node kind: {:?}\", node),\n                     }\n-\n-                    return (ctor_vis, span, descr);\n                 }\n                 Node::Expr(expr) => {\n                     return (ty::Visibility::Restricted(\n@@ -504,7 +516,10 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n         match item.node {\n             hir::ItemKind::Enum(ref def, _) => {\n                 for variant in &def.variants {\n-                    let variant_level = self.update(variant.node.data.hir_id(), item_level);\n+                    let variant_level = self.update(variant.node.id, item_level);\n+                    if let Some(ctor_hir_id) = variant.node.data.ctor_hir_id() {\n+                        self.update(ctor_hir_id, item_level);\n+                    }\n                     for field in variant.node.data.fields() {\n                         self.update(field.hir_id, variant_level);\n                     }\n@@ -523,8 +538,8 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ItemKind::Struct(ref def, _) | hir::ItemKind::Union(ref def, _) => {\n-                if !def.is_struct() {\n-                    self.update(def.hir_id(), item_level);\n+                if let Some(ctor_hir_id) = def.ctor_hir_id() {\n+                    self.update(ctor_hir_id, item_level);\n                 }\n                 for field in def.fields() {\n                     if field.vis.node.is_pub() {\n@@ -624,7 +639,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                     self.reach(item.hir_id, item_level).generics().predicates();\n                 }\n                 for variant in &def.variants {\n-                    let variant_level = self.get(variant.node.data.hir_id());\n+                    let variant_level = self.get(variant.node.id);\n                     if variant_level.is_some() {\n                         for field in variant.node.data.fields() {\n                             self.reach(field.hir_id, variant_level).ty();\n@@ -1468,7 +1483,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n-        if self.access_levels.is_reachable(v.node.data.hir_id()) {\n+        if self.access_levels.is_reachable(v.node.id) {\n             self.in_variant = true;\n             intravisit::walk_variant(self, v, g, item_id);\n             self.in_variant = false;"}, {"sha": "f55425c3168ec0140163866ebc6872573a0744aa", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -532,9 +532,10 @@ impl<'a> Resolver<'a> {\n \n                 // If this is a tuple or unit struct, define a name\n                 // in the value namespace as well.\n-                if !struct_def.is_struct() {\n-                    let ctor_def = Def::StructCtor(self.definitions.local_def_id(struct_def.id()),\n-                                                   CtorKind::from_ast(struct_def));\n+                if let Some(ctor_node_id) = struct_def.ctor_id() {\n+                    let ctor_def = Def::Ctor(self.definitions.local_def_id(ctor_node_id),\n+                                             CtorOf::Struct,\n+                                             CtorKind::from_ast(struct_def));\n                     self.define(parent, ident, ValueNS, (ctor_def, ctor_vis, sp, expansion));\n                     self.struct_constructors.insert(def.def_id(), (ctor_def, ctor_vis));\n                 }\n@@ -581,18 +582,21 @@ impl<'a> Resolver<'a> {\n                                        vis: ty::Visibility,\n                                        expansion: Mark) {\n         let ident = variant.node.ident;\n-        let def_id = self.definitions.local_def_id(variant.node.data.id());\n \n         // Define a name in the type namespace.\n+        let def_id = self.definitions.local_def_id(variant.node.id);\n         let def = Def::Variant(def_id);\n         self.define(parent, ident, TypeNS, (def, vis, variant.span, expansion));\n \n         // Define a constructor name in the value namespace.\n         // Braced variants, unlike structs, generate unusable names in\n         // value namespace, they are reserved for possible future use.\n+        // It's ok to use the variant's id as a ctor id since an\n+        // error will be reported on any use of such resolution anyway.\n+        let ctor_node_id = variant.node.data.ctor_id().unwrap_or(variant.node.id);\n+        let ctor_def_id = self.definitions.local_def_id(ctor_node_id);\n         let ctor_kind = CtorKind::from_ast(&variant.node.data);\n-        let ctor_def = Def::VariantCtor(def_id, ctor_kind);\n-\n+        let ctor_def = Def::Ctor(ctor_def_id, CtorOf::Variant, ctor_kind);\n         self.define(parent, ident, ValueNS, (ctor_def, vis, variant.span, expansion));\n     }\n \n@@ -649,10 +653,11 @@ impl<'a> Resolver<'a> {\n             Def::TraitAlias(..) | Def::PrimTy(..) | Def::ToolMod => {\n                 self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, expansion));\n             }\n-            Def::Fn(..) | Def::Static(..) | Def::Const(..) | Def::VariantCtor(..) => {\n+            Def::Fn(..) | Def::Static(..) | Def::Const(..) |\n+            Def::Ctor(_, CtorOf::Variant, ..) => {\n                 self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, expansion));\n             }\n-            Def::StructCtor(def_id, ..) => {\n+            Def::Ctor(def_id, CtorOf::Struct, ..) => {\n                 self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, expansion));\n \n                 if let Some(struct_def_id) ="}, {"sha": "fc8452e49ad1b386d20e53cd5c25557acf78235e", "filename": "src/librustc_resolve/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -2,8 +2,7 @@ use std::cmp::Reverse;\n \n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n use log::debug;\n-use rustc::hir::def::*;\n-use rustc::hir::def::Namespace::*;\n+use rustc::hir::def::{Def, CtorKind, Namespace::*};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::session::config::nightly_options;\n use syntax::ast::{ExprKind};\n@@ -417,7 +416,7 @@ impl<'a> Resolver<'a> {\n             }\n             (Def::Union(..), _) |\n             (Def::Variant(..), _) |\n-            (Def::VariantCtor(_, CtorKind::Fictive), _) if ns == ValueNS => {\n+            (Def::Ctor(_, _, CtorKind::Fictive), _) if ns == ValueNS => {\n                 err.span_label(span, format!(\"did you mean `{} {{ /* fields */ }}`?\",\n                                              path_str));\n             }"}, {"sha": "5d5185101953b68bceb66255dc01a07e3202b28e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -571,24 +571,20 @@ impl<'a> PathSource<'a> {\n                 _ => false,\n             },\n             PathSource::Expr(..) => match def {\n-                Def::StructCtor(_, CtorKind::Const) | Def::StructCtor(_, CtorKind::Fn) |\n-                Def::VariantCtor(_, CtorKind::Const) | Def::VariantCtor(_, CtorKind::Fn) |\n+                Def::Ctor(_, _, CtorKind::Const) | Def::Ctor(_, _, CtorKind::Fn) |\n                 Def::Const(..) | Def::Static(..) | Def::Local(..) | Def::Upvar(..) |\n                 Def::Fn(..) | Def::Method(..) | Def::AssociatedConst(..) |\n                 Def::SelfCtor(..) | Def::ConstParam(..) => true,\n                 _ => false,\n             },\n             PathSource::Pat => match def {\n-                Def::StructCtor(_, CtorKind::Const) |\n-                Def::VariantCtor(_, CtorKind::Const) |\n+                Def::Ctor(_, _, CtorKind::Const) |\n                 Def::Const(..) | Def::AssociatedConst(..) |\n                 Def::SelfCtor(..) => true,\n                 _ => false,\n             },\n             PathSource::TupleStruct => match def {\n-                Def::StructCtor(_, CtorKind::Fn) |\n-                Def::VariantCtor(_, CtorKind::Fn) |\n-                Def::SelfCtor(..) => true,\n+                Def::Ctor(_, _, CtorKind::Fn) | Def::SelfCtor(..) => true,\n                 _ => false,\n             },\n             PathSource::Struct => match def {\n@@ -1368,7 +1364,7 @@ impl<'a> NameBinding<'a> {\n     fn is_variant(&self) -> bool {\n         match self.kind {\n             NameBindingKind::Def(Def::Variant(..), _) |\n-            NameBindingKind::Def(Def::VariantCtor(..), _) => true,\n+            NameBindingKind::Def(Def::Ctor(_, CtorOf::Variant, ..), _) => true,\n             _ => false,\n         }\n     }\n@@ -3093,16 +3089,14 @@ impl<'a> Resolver<'a> {\n                         let is_syntactic_ambiguity = opt_pat.is_none() &&\n                             bmode == BindingMode::ByValue(Mutability::Immutable);\n                         match def {\n-                            Def::StructCtor(_, CtorKind::Const) |\n-                            Def::VariantCtor(_, CtorKind::Const) |\n+                            Def::Ctor(_, _, CtorKind::Const) |\n                             Def::Const(..) if is_syntactic_ambiguity => {\n                                 // Disambiguate in favor of a unit struct/variant\n                                 // or constant pattern.\n                                 self.record_use(ident, ValueNS, binding.unwrap(), false);\n                                 Some(PathResolution::new(def))\n                             }\n-                            Def::StructCtor(..) | Def::VariantCtor(..) |\n-                            Def::Const(..) | Def::Static(..) => {\n+                            Def::Ctor(..) | Def::Const(..) | Def::Static(..) => {\n                                 // This is unambiguously a fresh binding, either syntactically\n                                 // (e.g., `IDENT @ PAT` or `ref IDENT`) or because `IDENT` resolves\n                                 // to something unusable as a pattern (e.g., constructor function),\n@@ -4465,8 +4459,7 @@ impl<'a> Resolver<'a> {\n                         // outside crate private modules => no need to check this)\n                         if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n                             let did = match def {\n-                                Def::StructCtor(did, _) | Def::VariantCtor(did, _) =>\n-                                    self.parent(did),\n+                                Def::Ctor(did, ..) => self.parent(did),\n                                 _ => def.opt_def_id(),\n                             };\n                             candidates.push(ImportSuggestion { did, path });"}, {"sha": "c2d2bd753c82e0a532f0ace851d3536d38cb9643", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -880,10 +880,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 Ok(binding) => {\n                     let imported_binding = this.import(binding, directive);\n                     target_bindings[ns].set(Some(imported_binding));\n-                    let conflict = this.try_define(parent, target, ns, imported_binding);\n-                    if let Err(old_binding) = conflict {\n-                        this.report_conflict(parent, target, ns, imported_binding, old_binding);\n-                    }\n+                    this.define(parent, target, ns, imported_binding);\n                 }\n             }\n         });"}, {"sha": "263f5acb662fc6ba1e3505d81e7f2abf8b13407e", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -488,8 +488,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         };\n \n         let (value, fields) = match item.node {\n-            ast::ItemKind::Struct(ast::VariantData::Struct(ref fields, ..), _) |\n-            ast::ItemKind::Union(ast::VariantData::Struct(ref fields, ..), _) => {\n+            ast::ItemKind::Struct(ast::VariantData::Struct(ref fields, ..), ..) |\n+            ast::ItemKind::Union(ast::VariantData::Struct(ref fields, ..), ..) => {\n                 let include_priv_fields = !self.save_ctxt.config.pub_only;\n                 let fields_str = fields\n                     .iter()\n@@ -581,7 +581,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     let value = format!(\"{}::{} {{ {} }}\", enum_data.name, name, fields_str);\n                     if !self.span.filter_generated(name_span) {\n                         let span = self.span_from_span(name_span);\n-                        let id = id_from_node_id(variant.node.data.id(), &self.save_ctxt);\n+                        let id = id_from_node_id(variant.node.id, &self.save_ctxt);\n                         let parent = Some(id_from_node_id(item.id, &self.save_ctxt));\n \n                         self.dumper.dump_def(\n@@ -619,7 +619,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     }\n                     if !self.span.filter_generated(name_span) {\n                         let span = self.span_from_span(name_span);\n-                        let id = id_from_node_id(variant.node.data.id(), &self.save_ctxt);\n+                        let id = id_from_node_id(variant.node.id, &self.save_ctxt);\n                         let parent = Some(id_from_node_id(item.id, &self.save_ctxt));\n \n                         self.dumper.dump_def(\n@@ -648,7 +648,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n \n             for field in variant.node.data.fields() {\n-                self.process_struct_field_def(field, variant.node.data.id());\n+                self.process_struct_field_def(field, variant.node.id);\n                 self.visit_ty(&field.ty);\n             }\n         }\n@@ -957,8 +957,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                         );\n                     }\n                 }\n-                HirDef::StructCtor(..) |\n-                HirDef::VariantCtor(..) |\n+                HirDef::Ctor(_, _, _) |\n                 HirDef::Const(..) |\n                 HirDef::AssociatedConst(..) |\n                 HirDef::Struct(..) |"}, {"sha": "828ef802dd714a437edd7c6a9046b41b682fe095", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -14,7 +14,7 @@ mod span_utils;\n mod sig;\n \n use rustc::hir;\n-use rustc::hir::def::Def as HirDef;\n+use rustc::hir::def::{CtorOf, Def as HirDef};\n use rustc::hir::Node;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::privacy::AccessLevels;\n@@ -298,7 +298,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     parent: None,\n                     children: def.variants\n                         .iter()\n-                        .map(|v| id_from_node_id(v.node.data.id(), self))\n+                        .map(|v| id_from_node_id(v.node.id, self))\n                         .collect(),\n                     decl_id: None,\n                     docs: self.docs_for_attrs(&item.attrs),\n@@ -725,16 +725,6 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     ref_id: id_from_node_id(id, self),\n                 })\n             }\n-            HirDef::Static(..) |\n-            HirDef::Const(..) |\n-            HirDef::AssociatedConst(..) |\n-            HirDef::VariantCtor(..) => {\n-                Some(Ref {\n-                    kind: RefKind::Variable,\n-                    span,\n-                    ref_id: id_from_def_id(def.def_id()),\n-                })\n-            }\n             HirDef::Trait(def_id) if fn_type(path_seg) => {\n                 Some(Ref {\n                     kind: RefKind::Type,\n@@ -767,7 +757,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     ref_id: id_from_def_id(def_id),\n                 })\n             }\n-            HirDef::StructCtor(def_id, _) => {\n+            HirDef::Ctor(def_id, CtorOf::Struct, ..) => {\n                 // This is a reference to a tuple struct where the def_id points\n                 // to an invisible constructor function. That is not a very useful\n                 // def, so adjust to point to the tuple struct itself.\n@@ -778,6 +768,16 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     ref_id: id_from_def_id(parent_def_id),\n                 })\n             }\n+            HirDef::Static(..) |\n+            HirDef::Const(..) |\n+            HirDef::AssociatedConst(..) |\n+            HirDef::Ctor(..) => {\n+                Some(Ref {\n+                    kind: RefKind::Variable,\n+                    span,\n+                    ref_id: id_from_def_id(def.def_id()),\n+                })\n+            }\n             HirDef::Method(decl_id) => {\n                 let def_id = if decl_id.is_local() {\n                     let ti = self.tcx.associated_item(decl_id);"}, {"sha": "76034f32c741c9d396ab550a6733eb22040f986e", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -586,7 +586,7 @@ impl Sig for ast::Path {\n                     refs: vec![],\n                 })\n             }\n-            Def::AssociatedConst(..) | Def::Variant(..) | Def::VariantCtor(..) => {\n+            Def::AssociatedConst(..) | Def::Variant(..) | Def::Ctor(..) => {\n                 let len = self.segments.len();\n                 if len < 2 {\n                     return Err(\"Bad path\");\n@@ -700,10 +700,11 @@ impl Sig for ast::StructField {\n \n \n impl Sig for ast::Variant_ {\n-    fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext<'_, '_>) -> Result {\n+    fn make(&self, offset: usize, parent_id: Option<NodeId>, scx: &SaveContext<'_, '_>) -> Result {\n         let mut text = self.ident.to_string();\n         match self.data {\n-            ast::VariantData::Struct(ref fields, id, r) => {\n+            ast::VariantData::Struct(ref fields, r) => {\n+                let id = parent_id.unwrap();\n                 let name_def = SigElement {\n                     id: id_from_node_id(id, scx),\n                     start: offset,"}, {"sha": "3e61b175b76e048b34e8bdf8fafdade676a44c39", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -4,7 +4,7 @@\n \n use errors::{Applicability, DiagnosticId};\n use crate::hir::{self, GenericArg, GenericArgs, ExprKind};\n-use crate::hir::def::Def;\n+use crate::hir::def::{CtorOf, Def};\n use crate::hir::def_id::DefId;\n use crate::hir::HirVec;\n use crate::lint;\n@@ -1318,10 +1318,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     tcx.hygienic_eq(assoc_ident, vd.ident, adt_def.did)\n                 });\n                 if let Some(variant_def) = variant_def {\n-                    let def = Def::Variant(variant_def.did);\n+                    let def = Def::Variant(variant_def.def_id);\n                     if permit_variants {\n                         check_type_alias_enum_variants_enabled(tcx, span);\n-                        tcx.check_stability(variant_def.did, Some(hir_ref_id), span);\n+                        tcx.check_stability(variant_def.def_id, Some(hir_ref_id), span);\n                         return (qself_ty, def);\n                     } else {\n                         variant_resolution = Some(def);\n@@ -1596,7 +1596,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n \n         match def {\n             // Case 1. Reference to a struct constructor.\n-            Def::StructCtor(def_id, ..) |\n+            Def::Ctor(def_id, CtorOf::Struct, ..) |\n             Def::SelfCtor(.., def_id) => {\n                 // Everything but the final segment should have no\n                 // parameters at all.\n@@ -1608,15 +1608,22 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             }\n \n             // Case 2. Reference to a variant constructor.\n-            Def::Variant(def_id) |\n-            Def::VariantCtor(def_id, ..) => {\n+            Def::Ctor(def_id, CtorOf::Variant, ..) | Def::Variant(def_id, ..) => {\n                 let adt_def = self_ty.map(|t| t.ty_adt_def().unwrap());\n                 let (generics_def_id, index) = if let Some(adt_def) = adt_def {\n                     debug_assert!(adt_def.is_enum());\n                     (adt_def.did, last)\n                 } else if last >= 1 && segments[last - 1].args.is_some() {\n                     // Everything but the penultimate segment should have no\n                     // parameters at all.\n+                    let mut def_id = def_id;\n+\n+                    // `Def::Ctor` -> `Def::Variant`\n+                    if let Def::Ctor(..) = def {\n+                        def_id = tcx.parent(def_id).unwrap()\n+                    }\n+\n+                    // `Def::Variant` -> `Def::Item` (enum)\n                     let enum_def_id = tcx.parent(def_id).unwrap();\n                     (enum_def_id, last - 1)\n                 } else {"}, {"sha": "5f46a5a165213470d68f15b2f1f9c6fb22d07348", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -807,14 +807,12 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 report_unexpected_variant_def(tcx, &def, pat.span, qpath);\n                 return tcx.types.err;\n             }\n-            Def::VariantCtor(_, CtorKind::Fictive) |\n-            Def::VariantCtor(_, CtorKind::Fn) => {\n+            Def::Ctor(_, _, CtorKind::Fictive) |\n+            Def::Ctor(_, _, CtorKind::Fn) => {\n                 report_unexpected_variant_def(tcx, &def, pat.span, qpath);\n                 return tcx.types.err;\n             }\n-            Def::VariantCtor(_, CtorKind::Const) |\n-            Def::StructCtor(_, CtorKind::Const) |\n-            Def::SelfCtor(..) |\n+            Def::Ctor(_, _, CtorKind::Const) | Def::SelfCtor(..) |\n             Def::Const(..) | Def::AssociatedConst(..) => {} // OK\n             _ => bug!(\"unexpected pattern definition: {:?}\", def)\n         }\n@@ -876,8 +874,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 report_unexpected_def(def);\n                 return tcx.types.err;\n             }\n-            Def::VariantCtor(_, CtorKind::Fn) |\n-            Def::StructCtor(_, CtorKind::Fn) => {\n+            Def::Ctor(_, _, CtorKind::Fn) => {\n                 tcx.expect_variant_def(def)\n             }\n             _ => bug!(\"unexpected pattern definition: {:?}\", def)\n@@ -950,7 +947,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         let mut inexistent_fields = vec![];\n         // Typecheck each field.\n         for &Spanned { node: ref field, span } in fields {\n-            let ident = tcx.adjust_ident(field.ident, variant.did, self.body_id).0;\n+            let ident = tcx.adjust_ident(field.ident, variant.def_id, self.body_id).0;\n             let field_ty = match used_fields.entry(ident) {\n                 Occupied(occupied) => {\n                     struct_span_err!(tcx.sess, span, E0025,\n@@ -1003,13 +1000,13 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                                            E0026,\n                                            \"{} `{}` does not have {}\",\n                                            kind_name,\n-                                           tcx.def_path_str(variant.did),\n+                                           tcx.def_path_str(variant.def_id),\n                                            field_names);\n             if let Some((span, ident)) = inexistent_fields.last() {\n                 err.span_label(*span,\n                                format!(\"{} `{}` does not have {} field{}\",\n                                        kind_name,\n-                                       tcx.def_path_str(variant.did),\n+                                       tcx.def_path_str(variant.def_id),\n                                        t,\n                                        plural));\n                 if plural == \"\" {"}, {"sha": "b1a249d821bec77b279f3d3629d90e2fbadc237d", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         let sole_field = &variant.fields[0];\n                         let sole_field_ty = sole_field.ty(self.tcx, substs);\n                         if self.can_coerce(expr_ty, sole_field_ty) {\n-                            let variant_path = self.tcx.def_path_str(variant.did);\n+                            let variant_path = self.tcx.def_path_str(variant.def_id);\n                             // FIXME #56861: DRYer prelude filtering\n                             Some(variant_path.trim_start_matches(\"std::prelude::v1::\").to_string())\n                         } else {"}, {"sha": "34a24308e491aa7950e1f5dfec2939db9971cb62", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -15,7 +15,7 @@ use crate::namespace::Namespace;\n use errors::{Applicability, DiagnosticBuilder};\n use rustc_data_structures::sync::Lrc;\n use rustc::hir;\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{CtorOf, Def};\n use rustc::hir::def_id::DefId;\n use rustc::traits;\n use rustc::ty::subst::{InternalSubsts, SubstsRef};\n@@ -417,7 +417,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if let Some(variant_def) = variant_def {\n                     check_type_alias_enum_variants_enabled(tcx, span);\n \n-                    let def = Def::VariantCtor(variant_def.did, variant_def.ctor_kind);\n+                    // Braced variants generate unusable names in value namespace (reserved for\n+                    // possible future use), so variants resolved as associated items may refer to\n+                    // them as well. It's ok to use the variant's id as a ctor id since an\n+                    // error will be reported on any use of such resolution anyway.\n+                    let ctor_def_id = variant_def.ctor_def_id.unwrap_or(variant_def.def_id);\n+                    let def = Def::Ctor(ctor_def_id, CtorOf::Variant, variant_def.ctor_kind);\n                     tcx.check_stability(def.def_id(), Some(expr_id), span);\n                     return Ok(def);\n                 }"}, {"sha": "94f76b03a643cf4b83e744330eae69d2fe3ef4e4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -86,7 +86,7 @@ mod op;\n use crate::astconv::{AstConv, PathSeg};\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n use rustc::hir::{self, ExprKind, GenericArg, ItemKind, Node, PatKind, QPath};\n-use rustc::hir::def::{CtorKind, Def};\n+use rustc::hir::def::{CtorOf, CtorKind, Def};\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -1863,7 +1863,7 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     for ((_, discr), v) in def.discriminants(tcx).zip(vs) {\n         // Check for duplicate discriminant values\n         if let Some(i) = disr_vals.iter().position(|&x| x.val == discr.val) {\n-            let variant_did = def.variants[VariantIdx::new(i)].did;\n+            let variant_did = def.variants[VariantIdx::new(i)].def_id;\n             let variant_i_hir_id = tcx.hir().as_local_hir_id(variant_did).unwrap();\n             let variant_i = tcx.hir().expect_variant(variant_i_hir_id);\n             let i_span = match variant_i.node.disr_expr {\n@@ -3693,7 +3693,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let names = variant.fields.iter().filter_map(|field| {\n             // ignore already set fields and private fields from non-local crates\n             if skip.iter().any(|x| *x == field.ident.as_str()) ||\n-               (variant.did.krate != LOCAL_CRATE && field.vis != Visibility::Public) {\n+               (!variant.def_id.is_local() && field.vis != Visibility::Public)\n+            {\n                 None\n             } else {\n                 Some(&field.ident.name)\n@@ -3705,7 +3706,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn available_field_names(&self, variant: &'tcx ty::VariantDef) -> Vec<ast::Name> {\n         variant.fields.iter().filter(|field| {\n-            let def_scope = self.tcx.adjust_ident(field.ident, variant.did, self.body_id).1;\n+            let def_scope = self.tcx.adjust_ident(field.ident, variant.def_id, self.body_id).1;\n             field.vis.is_accessible_from(def_scope, self.tcx)\n         })\n         .map(|field| field.ident.name)\n@@ -3823,7 +3824,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Type-check each field.\n         for field in ast_fields {\n-            let ident = tcx.adjust_ident(field.ident, variant.did, self.body_id).0;\n+            let ident = tcx.adjust_ident(field.ident, variant.def_id, self.body_id).0;\n             let field_type = if let Some((i, v_field)) = remaining_fields.remove(&ident) {\n                 seen_fields.insert(ident, field.span);\n                 self.write_field_index(field.hir_id, i);\n@@ -4237,7 +4238,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         self.set_tainted_by_errors();\n                         tcx.types.err\n                     }\n-                    Def::VariantCtor(_, CtorKind::Fictive) => {\n+                    Def::Ctor(_, _, CtorKind::Fictive) => {\n                         report_unexpected_variant_def(tcx, &def, expr.span, qpath);\n                         tcx.types.err\n                     }\n@@ -5333,7 +5334,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         Some(original_span.with_lo(original_span.hi() - BytePos(1)))\n     }\n \n-    // Rewrite `SelfCtor` to `StructCtor`\n+    // Rewrite `SelfCtor` to `Ctor`\n     pub fn rewrite_self_ctor(&self, def: Def, span: Span) -> (Def, DefId, Ty<'tcx>) {\n         let tcx = self.tcx;\n         if let Def::SelfCtor(impl_def_id) = def {\n@@ -5343,8 +5344,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             match adt_def {\n                 Some(adt_def) if adt_def.has_ctor() => {\n                     let variant = adt_def.non_enum_variant();\n-                    let def = Def::StructCtor(variant.did, variant.ctor_kind);\n-                    (def, variant.did, tcx.type_of(variant.did))\n+                    let ctor_def_id = variant.ctor_def_id.unwrap();\n+                    let def = Def::Ctor(ctor_def_id, CtorOf::Struct, variant.ctor_kind);\n+                    (def, ctor_def_id, tcx.type_of(ctor_def_id))\n                 }\n                 _ => {\n                     let mut err = tcx.sess.struct_span_err(span,\n@@ -5416,7 +5418,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut user_self_ty = None;\n         let mut is_alias_variant_ctor = false;\n         match def {\n-            Def::VariantCtor(_, _) => {\n+            Def::Ctor(_, CtorOf::Variant, _) => {\n                 if let Some(self_ty) = self_ty {\n                     let adt_def = self_ty.ty_adt_def().unwrap();\n                     user_self_ty = Some(UserSelfTy {"}, {"sha": "06450424776d4cfca0e1c1bc142d55fdd3e371b6", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 66, "deletions": 73, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -446,8 +446,8 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: hir::HirId) {\n                 tcx.predicates_of(def_id);\n             }\n \n-            if !struct_def.is_struct() {\n-                convert_variant_ctor(tcx, struct_def.hir_id());\n+            if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n+                convert_variant_ctor(tcx, ctor_hir_id);\n             }\n         }\n \n@@ -556,21 +556,24 @@ fn convert_enum_variant_types<'a, 'tcx>(\n \n         // Convert the ctor, if any. This also registers the variant as\n         // an item.\n-        convert_variant_ctor(tcx, variant.node.data.hir_id());\n+        if let Some(ctor_hir_id) = variant.node.data.ctor_hir_id() {\n+            convert_variant_ctor(tcx, ctor_hir_id);\n+        }\n     }\n }\n \n fn convert_variant<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    did: DefId,\n+    variant_did: Option<DefId>,\n+    ctor_did: Option<DefId>,\n     ident: Ident,\n     discr: ty::VariantDiscr,\n     def: &hir::VariantData,\n     adt_kind: ty::AdtKind,\n-    attribute_def_id: DefId\n+    parent_did: DefId\n ) -> ty::VariantDef {\n     let mut seen_fields: FxHashMap<ast::Ident, Span> = Default::default();\n-    let hir_id = tcx.hir().as_local_hir_id(did).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(variant_did.unwrap_or(parent_did)).unwrap();\n     let fields = def\n         .fields()\n         .iter()\n@@ -599,17 +602,19 @@ fn convert_variant<'a, 'tcx>(\n         })\n         .collect();\n     let recovered = match def {\n-        hir::VariantData::Struct(_, _, r) => *r,\n+        hir::VariantData::Struct(_, r) => *r,\n         _ => false,\n     };\n-    ty::VariantDef::new(tcx,\n-        did,\n+    ty::VariantDef::new(\n+        tcx,\n         ident,\n+        variant_did,\n+        ctor_did,\n         discr,\n         fields,\n-        adt_kind,\n         CtorKind::from_hir(def),\n-        attribute_def_id,\n+        adt_kind,\n+        parent_did,\n         recovered,\n     )\n }\n@@ -627,58 +632,52 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Ad\n     let (kind, variants) = match item.node {\n         ItemKind::Enum(ref def, _) => {\n             let mut distance_from_explicit = 0;\n-            (\n-                AdtKind::Enum,\n-                def.variants\n-                    .iter()\n-                    .map(|v| {\n-                        let did = tcx.hir().local_def_id_from_hir_id(v.node.data.hir_id());\n-                        let discr = if let Some(ref e) = v.node.disr_expr {\n-                            distance_from_explicit = 0;\n-                            ty::VariantDiscr::Explicit(tcx.hir().local_def_id_from_hir_id(e.hir_id))\n-                        } else {\n-                            ty::VariantDiscr::Relative(distance_from_explicit)\n-                        };\n-                        distance_from_explicit += 1;\n+            let variants = def.variants\n+                .iter()\n+                .map(|v| {\n+                    let variant_did = Some(tcx.hir().local_def_id_from_hir_id(v.node.id));\n+                    let ctor_did = v.node.data.ctor_hir_id()\n+                        .map(|hir_id| tcx.hir().local_def_id_from_hir_id(hir_id));\n+\n+                    let discr = if let Some(ref e) = v.node.disr_expr {\n+                        distance_from_explicit = 0;\n+                        ty::VariantDiscr::Explicit(tcx.hir().local_def_id_from_hir_id(e.hir_id))\n+                    } else {\n+                        ty::VariantDiscr::Relative(distance_from_explicit)\n+                    };\n+                    distance_from_explicit += 1;\n \n-                        convert_variant(tcx, did, v.node.ident, discr, &v.node.data, AdtKind::Enum,\n-                                        did)\n-                    })\n-                    .collect(),\n-            )\n+                    convert_variant(tcx, variant_did, ctor_did, v.node.ident, discr,\n+                                    &v.node.data, AdtKind::Enum, def_id)\n+                })\n+                .collect();\n+\n+            (AdtKind::Enum, variants)\n         }\n         ItemKind::Struct(ref def, _) => {\n-            // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n-            let ctor_id = if !def.is_struct() {\n-                Some(tcx.hir().local_def_id_from_hir_id(def.hir_id()))\n-            } else {\n-                None\n-            };\n-            (\n-                AdtKind::Struct,\n-                std::iter::once(convert_variant(\n-                    tcx,\n-                    ctor_id.unwrap_or(def_id),\n-                    item.ident,\n-                    ty::VariantDiscr::Relative(0),\n-                    def,\n-                    AdtKind::Struct,\n-                    def_id\n-                )).collect(),\n-            )\n-        }\n-        ItemKind::Union(ref def, _) => (\n-            AdtKind::Union,\n-            std::iter::once(convert_variant(\n-                tcx,\n-                def_id,\n-                item.ident,\n-                ty::VariantDiscr::Relative(0),\n-                def,\n-                AdtKind::Union,\n-                def_id\n-            )).collect(),\n-        ),\n+            let variant_did = None;\n+            let ctor_did = def.ctor_hir_id()\n+                .map(|hir_id| tcx.hir().local_def_id_from_hir_id(hir_id));\n+\n+            let variants = std::iter::once(convert_variant(\n+                tcx, variant_did, ctor_did, item.ident, ty::VariantDiscr::Relative(0), def,\n+                AdtKind::Struct, def_id,\n+            )).collect();\n+\n+            (AdtKind::Struct, variants)\n+        }\n+        ItemKind::Union(ref def, _) => {\n+            let variant_did = None;\n+            let ctor_did = def.ctor_hir_id()\n+                .map(|hir_id| tcx.hir().local_def_id_from_hir_id(hir_id));\n+\n+            let variants = std::iter::once(convert_variant(\n+                tcx, variant_did, ctor_did, item.ident, ty::VariantDiscr::Relative(0), def,\n+                AdtKind::Union, def_id,\n+            )).collect();\n+\n+            (AdtKind::Union, variants)\n+        },\n         _ => bug!(),\n     };\n     tcx.alloc_adt_def(def_id, kind, variants, repr)\n@@ -889,8 +888,8 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n \n     let node = tcx.hir().get_by_hir_id(hir_id);\n     let parent_def_id = match node {\n-        Node::ImplItem(_) | Node::TraitItem(_) | Node::Variant(_)\n-        | Node::StructCtor(_) | Node::Field(_) => {\n+        Node::ImplItem(_) | Node::TraitItem(_) | Node::Variant(_) |\n+        Node::Ctor(..) | Node::Field(_) => {\n             let parent_id = tcx.hir().get_parent_item(hir_id);\n             Some(tcx.hir().local_def_id_from_hir_id(parent_id))\n         }\n@@ -1248,8 +1247,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             ForeignItemKind::Type => tcx.mk_foreign(def_id),\n         },\n \n-        Node::StructCtor(&ref def)\n-        | Node::Variant(&Spanned {\n+        Node::Ctor(&ref def) | Node::Variant(&Spanned {\n             node: hir::VariantKind { data: ref def, .. },\n             ..\n         }) => match *def {\n@@ -1627,17 +1625,12 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::PolyFnSig\n             compute_sig_of_foreign_fn_decl(tcx, def_id, fn_decl, abi)\n         }\n \n-        StructCtor(&VariantData::Tuple(ref fields, ..))\n-        | Variant(&Spanned {\n-            node:\n-                hir::VariantKind {\n-                    data: VariantData::Tuple(ref fields, ..),\n-                    ..\n-                },\n+        Ctor(data) | Variant(Spanned {\n+            node: hir::VariantKind { data, ..  },\n             ..\n-        }) => {\n+        }) if data.ctor_hir_id().is_some() => {\n             let ty = tcx.type_of(tcx.hir().get_parent_did_by_hir_id(hir_id));\n-            let inputs = fields\n+            let inputs = data.fields()\n                 .iter()\n                 .map(|f| tcx.type_of(tcx.hir().local_def_id_from_hir_id(f.hir_id)));\n             ty::Binder::bind(tcx.mk_fn_sig("}, {"sha": "f2406bd8540b5b804bde26bbdd1687a0bef150bf", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -75,7 +75,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n                 self.visit_node_helper(item.hir_id);\n \n                 if let hir::VariantData::Tuple(..) = *struct_def {\n-                    self.visit_node_helper(struct_def.hir_id());\n+                    self.visit_node_helper(struct_def.ctor_hir_id().unwrap());\n                 }\n             }\n \n@@ -84,7 +84,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n \n                 for variant in &enum_def.variants {\n                     if let hir::VariantData::Tuple(..) = variant.node.data {\n-                        self.visit_node_helper(variant.node.data.hir_id());\n+                        self.visit_node_helper(variant.node.data.ctor_hir_id().unwrap());\n                     }\n                 }\n             }"}, {"sha": "9b9a6bace96b10fbf35454ab9201b4ceee089fe2", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -79,7 +79,7 @@ fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n             _ => unsupported()\n         },\n \n-        Node::Variant(_) | Node::StructCtor(_) => {}\n+        Node::Variant(_) | Node::Ctor(..) => {}\n \n         _ => unsupported()\n     }"}, {"sha": "ac686e40076eb54a8de4e6923c7a7a5728fc1c9f", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -136,7 +136,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n                 self.add_inferreds_for_item(item.hir_id);\n \n                 if let hir::VariantData::Tuple(..) = *struct_def {\n-                    self.add_inferreds_for_item(struct_def.hir_id());\n+                    self.add_inferreds_for_item(struct_def.ctor_hir_id().unwrap());\n                 }\n             }\n \n@@ -145,7 +145,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n \n                 for variant in &enum_def.variants {\n                     if let hir::VariantData::Tuple(..) = variant.node.data {\n-                        self.add_inferreds_for_item(variant.node.data.hir_id());\n+                        self.add_inferreds_for_item(variant.node.data.ctor_hir_id().unwrap());\n                     }\n                 }\n             }"}, {"sha": "5969aa758df2c292fa7e933e33d3f3a8272fa909", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -88,9 +88,7 @@ pub fn try_inline(\n         Def::Variant(..) => return None,\n         // Assume that enum variants and struct types are re-exported next to\n         // their constructors.\n-        Def::VariantCtor(..) |\n-        Def::StructCtor(..) |\n-        Def::SelfCtor(..) => return Some(Vec::new()),\n+        Def::Ctor(..) | Def::SelfCtor(..) => return Some(Vec::new()),\n         Def::Mod(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Module);\n             clean::ModuleItem(build_module(cx, did, visited))"}, {"sha": "61dbf00a1f536af81fdc52ef1fd8b470cba2adf9", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -3133,7 +3133,7 @@ impl Clean<Item> for doctree::Variant {\n             visibility: None,\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.def.hir_id()),\n+            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n             inner: VariantItem(Variant {\n                 kind: self.def.clean(cx),\n             }),\n@@ -3171,13 +3171,13 @@ impl<'tcx> Clean<Item> for ty::VariantDef {\n         };\n         Item {\n             name: Some(self.ident.clean(cx)),\n-            attrs: inline::load_attrs(cx, self.did),\n-            source: cx.tcx.def_span(self.did).clean(cx),\n+            attrs: inline::load_attrs(cx, self.def_id),\n+            source: cx.tcx.def_span(self.def_id).clean(cx),\n             visibility: Some(Inherited),\n-            def_id: self.did,\n+            def_id: self.def_id,\n             inner: VariantItem(Variant { kind }),\n-            stability: get_stability(cx, self.did),\n-            deprecation: get_deprecation(cx, self.did),\n+            stability: get_stability(cx, self.def_id),\n+            deprecation: get_deprecation(cx, self.def_id),\n         }\n     }\n }\n@@ -3191,12 +3191,11 @@ pub enum VariantKind {\n \n impl Clean<VariantKind> for hir::VariantData {\n     fn clean(&self, cx: &DocContext<'_>) -> VariantKind {\n-        if self.is_struct() {\n-            VariantKind::Struct(self.clean(cx))\n-        } else if self.is_unit() {\n-            VariantKind::CLike\n-        } else {\n-            VariantKind::Tuple(self.fields().iter().map(|x| x.ty.clean(cx)).collect())\n+        match self {\n+            hir::VariantData::Struct(..) => VariantKind::Struct(self.clean(cx)),\n+            hir::VariantData::Tuple(..) =>\n+                VariantKind::Tuple(self.fields().iter().map(|x| x.ty.clean(cx)).collect()),\n+            hir::VariantData::Unit(..) => VariantKind::CLike,\n         }\n     }\n }"}, {"sha": "7a528e50e9c3f8aaccc00936d51d84ed3a3d2920", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -125,6 +125,7 @@ pub struct Enum {\n \n pub struct Variant {\n     pub name: Name,\n+    pub id: hir::HirId,\n     pub attrs: hir::HirVec<ast::Attribute>,\n     pub def: hir::VariantData,\n     pub stab: Option<attr::Stability>,"}, {"sha": "ee182237b49ec540d8f5546a8e7adf3decf04d91", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -344,9 +344,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                                 .and_then(|(def, fragment)| {\n                                     // Constructors are picked up in the type namespace.\n                                     match def {\n-                                        Def::StructCtor(..)\n-                                        | Def::VariantCtor(..)\n-                                        | Def::SelfCtor(..) => None,\n+                                        Def::Ctor(..) | Def::SelfCtor(..) => None,\n                                         _ => Some((def, fragment))\n                                     }\n                                 }),"}, {"sha": "a7e2b2155e9f34dacd0d2598655482edab98522c", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -141,9 +141,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             name,\n             variants: def.variants.iter().map(|v| Variant {\n                 name: v.node.ident.name,\n+                id: v.node.id,\n                 attrs: v.node.attrs.clone(),\n-                stab: self.stability(v.node.data.hir_id()),\n-                depr: self.deprecation(v.node.data.hir_id()),\n+                stab: self.stability(v.node.id),\n+                depr: self.deprecation(v.node.id),\n                 def: v.node.data.clone(),\n                 whence: v.span,\n             }).collect(),\n@@ -420,8 +421,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 // Struct and variant constructors and proc macro stubs always show up alongside\n                 // their definitions, we've already processed them so just discard these.\n                 match path.def {\n-                    Def::StructCtor(..) | Def::VariantCtor(..) | Def::SelfCtor(..) |\n-                    Def::Macro(_, MacroKind::ProcMacroStub) => return,\n+                    Def::Ctor(..) | Def::SelfCtor(..) | Def::Macro(_, MacroKind::ProcMacroStub) =>\n+                        return,\n                     _ => {}\n                 }\n "}, {"sha": "bcc8fdf8cd4e7fc68e3955b3214d8b69e9aff66f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 13, "deletions": 35, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -1956,8 +1956,13 @@ pub struct EnumDef {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Variant_ {\n+    /// Name of the variant.\n     pub ident: Ident,\n+    /// Attributes of the variant.\n     pub attrs: Vec<Attribute>,\n+    /// Id of the variant (not the constructor, see `VariantData::ctor_id()`).\n+    pub id: NodeId,\n+    /// Fields and constructor id of the variant.\n     pub data: VariantData,\n     /// Explicit discriminant, e.g., `Foo = 1`.\n     pub disr_expr: Option<AnonConst>,\n@@ -2117,23 +2122,13 @@ pub struct StructField {\n     pub attrs: Vec<Attribute>,\n }\n \n-/// Fields and Ids of enum variants and structs\n-///\n-/// For enum variants: `NodeId` represents both an Id of the variant itself (relevant for all\n-/// variant kinds) and an Id of the variant's constructor (not relevant for `Struct`-variants).\n-/// One shared Id can be successfully used for these two purposes.\n-/// Id of the whole enum lives in `Item`.\n-///\n-/// For structs: `NodeId` represents an Id of the structure's constructor, so it is not actually\n-/// used for `Struct`-structs (but still presents). Structures don't have an analogue of \"Id of\n-/// the variant itself\" from enum variants.\n-/// Id of the whole struct lives in `Item`.\n+/// Fields and constructor ids of enum variants and structs.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum VariantData {\n     /// Struct variant.\n     ///\n     /// E.g., `Bar { .. }` as in `enum Foo { Bar { .. } }`.\n-    Struct(Vec<StructField>, NodeId, bool),\n+    Struct(Vec<StructField>, bool),\n     /// Tuple variant.\n     ///\n     /// E.g., `Bar(..)` as in `enum Foo { Bar(..) }`.\n@@ -2145,36 +2140,19 @@ pub enum VariantData {\n }\n \n impl VariantData {\n+    /// Return the fields of this variant.\n     pub fn fields(&self) -> &[StructField] {\n         match *self {\n             VariantData::Struct(ref fields, ..) | VariantData::Tuple(ref fields, _) => fields,\n             _ => &[],\n         }\n     }\n-    pub fn id(&self) -> NodeId {\n+\n+    /// Return the `NodeId` of this variant's constructor, if it has one.\n+    pub fn ctor_id(&self) -> Option<NodeId> {\n         match *self {\n-            VariantData::Struct(_, id, _) | VariantData::Tuple(_, id) | VariantData::Unit(id) => id,\n-        }\n-    }\n-    pub fn is_struct(&self) -> bool {\n-        if let VariantData::Struct(..) = *self {\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-    pub fn is_tuple(&self) -> bool {\n-        if let VariantData::Tuple(..) = *self {\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-    pub fn is_unit(&self) -> bool {\n-        if let VariantData::Unit(..) = *self {\n-            true\n-        } else {\n-            false\n+            VariantData::Struct(..) => None,\n+            VariantData::Tuple(_, id) | VariantData::Unit(id) => Some(id),\n         }\n     }\n }"}, {"sha": "18173628a2602f922cf89d8b0cb89ed675ffc295", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -225,10 +225,9 @@ impl<'a> StripUnconfigured<'a> {\n \n     fn configure_variant_data(&mut self, vdata: &mut ast::VariantData) {\n         match vdata {\n-            ast::VariantData::Struct(fields, _id, _) |\n-            ast::VariantData::Tuple(fields, _id) =>\n+            ast::VariantData::Struct(fields, ..) | ast::VariantData::Tuple(fields, _) =>\n                 fields.flat_map_in_place(|field| self.configure(field)),\n-            ast::VariantData::Unit(_id) => {}\n+            ast::VariantData::Unit(_) => {}\n         }\n     }\n "}, {"sha": "614967bdeb447002eef0cd67bd5604608ae19872", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -1062,6 +1062,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         respan(span,\n                ast::Variant_ {\n                    ident,\n+                   id: ast::DUMMY_NODE_ID,\n                    attrs: Vec::new(),\n                    data: vdata,\n                    disr_expr: None,"}, {"sha": "784d0049ac51f7069a1aecf83e0b1861a6f0b807", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -450,9 +450,10 @@ pub fn noop_visit_foreign_mod<T: MutVisitor>(foreign_mod: &mut ForeignMod, vis:\n }\n \n pub fn noop_visit_variant<T: MutVisitor>(variant: &mut Variant, vis: &mut T) {\n-    let Spanned { node: Variant_ { ident, attrs, data, disr_expr }, span } = variant;\n+    let Spanned { node: Variant_ { ident, attrs, id, data, disr_expr }, span } = variant;\n     vis.visit_ident(ident);\n     visit_attrs(attrs, vis);\n+    vis.visit_id(id);\n     vis.visit_variant_data(data);\n     visit_opt(disr_expr, |disr_expr| vis.visit_anon_const(disr_expr));\n     vis.visit_span(span);\n@@ -765,11 +766,11 @@ pub fn noop_visit_where_predicate<T: MutVisitor>(pred: &mut WherePredicate, vis:\n \n pub fn noop_visit_variant_data<T: MutVisitor>(vdata: &mut VariantData, vis: &mut T) {\n     match vdata {\n-        VariantData::Struct(fields, id, _) |\n+        VariantData::Struct(fields, ..) => visit_vec(fields, |field| vis.visit_struct_field(field)),\n         VariantData::Tuple(fields, id) => {\n             visit_vec(fields, |field| vis.visit_struct_field(field));\n             vis.visit_id(id);\n-        }\n+        },\n         VariantData::Unit(id) => vis.visit_id(id),\n     }\n }"}, {"sha": "d7a2170342d7f42fbc435a453b26992c7eb673e1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -6844,15 +6844,15 @@ impl<'a> Parser<'a> {\n             } else {\n                 // If we see: `struct Foo<T> where T: Copy { ... }`\n                 let (fields, recovered) = self.parse_record_struct_body()?;\n-                VariantData::Struct(fields, ast::DUMMY_NODE_ID, recovered)\n+                VariantData::Struct(fields, recovered)\n             }\n         // No `where` so: `struct Foo<T>;`\n         } else if self.eat(&token::Semi) {\n             VariantData::Unit(ast::DUMMY_NODE_ID)\n         // Record-style struct definition\n         } else if self.token == token::OpenDelim(token::Brace) {\n             let (fields, recovered) = self.parse_record_struct_body()?;\n-            VariantData::Struct(fields, ast::DUMMY_NODE_ID, recovered)\n+            VariantData::Struct(fields, recovered)\n         // Tuple-style struct definition with optional where-clause.\n         } else if self.token == token::OpenDelim(token::Paren) {\n             let body = VariantData::Tuple(self.parse_tuple_struct_body()?, ast::DUMMY_NODE_ID);\n@@ -6881,10 +6881,10 @@ impl<'a> Parser<'a> {\n         let vdata = if self.token.is_keyword(keywords::Where) {\n             generics.where_clause = self.parse_where_clause()?;\n             let (fields, recovered) = self.parse_record_struct_body()?;\n-            VariantData::Struct(fields, ast::DUMMY_NODE_ID, recovered)\n+            VariantData::Struct(fields, recovered)\n         } else if self.token == token::OpenDelim(token::Brace) {\n             let (fields, recovered) = self.parse_record_struct_body()?;\n-            VariantData::Struct(fields, ast::DUMMY_NODE_ID, recovered)\n+            VariantData::Struct(fields, recovered)\n         } else {\n             let token_str = self.this_token_descr();\n             let mut err = self.fatal(&format!(\n@@ -7708,7 +7708,7 @@ impl<'a> Parser<'a> {\n                 // Parse a struct variant.\n                 all_nullary = false;\n                 let (fields, recovered) = self.parse_record_struct_body()?;\n-                struct_def = VariantData::Struct(fields, ast::DUMMY_NODE_ID, recovered);\n+                struct_def = VariantData::Struct(fields, recovered);\n             } else if self.check(&token::OpenDelim(token::Paren)) {\n                 all_nullary = false;\n                 struct_def = VariantData::Tuple(\n@@ -7730,6 +7730,7 @@ impl<'a> Parser<'a> {\n \n             let vr = ast::Variant_ {\n                 ident,\n+                id: ast::DUMMY_NODE_ID,\n                 attrs: variant_attrs,\n                 data: struct_def,\n                 disr_expr,"}, {"sha": "f5a9aded8455e5a40a5bd8ec9ac60fa88e521324", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -1550,44 +1550,47 @@ impl<'a> State<'a> {\n                         print_finalizer: bool) -> io::Result<()> {\n         self.print_ident(ident)?;\n         self.print_generic_params(&generics.params)?;\n-        if !struct_def.is_struct() {\n-            if struct_def.is_tuple() {\n-                self.popen()?;\n-                self.commasep(\n-                    Inconsistent, struct_def.fields(),\n-                    |s, field| {\n-                        s.maybe_print_comment(field.span.lo())?;\n-                        s.print_outer_attributes(&field.attrs)?;\n-                        s.print_visibility(&field.vis)?;\n-                        s.print_type(&field.ty)\n-                    }\n-                )?;\n-                self.pclose()?;\n-            }\n-            self.print_where_clause(&generics.where_clause)?;\n-            if print_finalizer {\n-                self.s.word(\";\")?;\n+        match struct_def {\n+            ast::VariantData::Tuple(..) | ast::VariantData::Unit(..) => {\n+                if let ast::VariantData::Tuple(..) = struct_def {\n+                    self.popen()?;\n+                    self.commasep(\n+                        Inconsistent, struct_def.fields(),\n+                        |s, field| {\n+                            s.maybe_print_comment(field.span.lo())?;\n+                            s.print_outer_attributes(&field.attrs)?;\n+                            s.print_visibility(&field.vis)?;\n+                            s.print_type(&field.ty)\n+                        }\n+                    )?;\n+                    self.pclose()?;\n+                }\n+                self.print_where_clause(&generics.where_clause)?;\n+                if print_finalizer {\n+                    self.s.word(\";\")?;\n+                }\n+                self.end()?;\n+                self.end() // close the outer-box\n             }\n-            self.end()?;\n-            self.end() // close the outer-box\n-        } else {\n-            self.print_where_clause(&generics.where_clause)?;\n-            self.nbsp()?;\n-            self.bopen()?;\n-            self.hardbreak_if_not_bol()?;\n-\n-            for field in struct_def.fields() {\n+            ast::VariantData::Struct(..) => {\n+                self.print_where_clause(&generics.where_clause)?;\n+                self.nbsp()?;\n+                self.bopen()?;\n                 self.hardbreak_if_not_bol()?;\n-                self.maybe_print_comment(field.span.lo())?;\n-                self.print_outer_attributes(&field.attrs)?;\n-                self.print_visibility(&field.vis)?;\n-                self.print_ident(field.ident.unwrap())?;\n-                self.word_nbsp(\":\")?;\n-                self.print_type(&field.ty)?;\n-                self.s.word(\",\")?;\n-            }\n \n-            self.bclose(span)\n+                for field in struct_def.fields() {\n+                    self.hardbreak_if_not_bol()?;\n+                    self.maybe_print_comment(field.span.lo())?;\n+                    self.print_outer_attributes(&field.attrs)?;\n+                    self.print_visibility(&field.vis)?;\n+                    self.print_ident(field.ident.unwrap())?;\n+                    self.word_nbsp(\":\")?;\n+                    self.print_type(&field.ty)?;\n+                    self.s.word(\",\")?;\n+                }\n+\n+                self.bclose(span)\n+            }\n         }\n     }\n \n@@ -3266,6 +3269,7 @@ mod tests {\n             let var = source_map::respan(syntax_pos::DUMMY_SP, ast::Variant_ {\n                 ident,\n                 attrs: Vec::new(),\n+                id: ast::DUMMY_NODE_ID,\n                 // making this up as I go.... ?\n                 data: ast::VariantData::Unit(ast::DUMMY_NODE_ID),\n                 disr_expr: None,"}, {"sha": "7c47c6ff79ac1f25d45f077c2887f3e67029e43d", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 46, "deletions": 50, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -51,9 +51,9 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     // build fmt.debug_struct(<name>).field(<fieldname>, &<fieldval>)....build()\n     // or fmt.debug_tuple(<name>).field(&<fieldval>)....build()\n     // based on the \"shape\".\n-    let (ident, is_struct) = match *substr.fields {\n-        Struct(vdata, _) => (substr.type_ident, vdata.is_struct()),\n-        EnumMatching(_, _, v, _) => (v.node.ident, v.node.data.is_struct()),\n+    let (ident, vdata, fields) = match substr.fields {\n+        Struct(vdata, fields) => (substr.type_ident, *vdata, fields),\n+        EnumMatching(_, _, v, fields) => (v.node.ident, &v.node.data, fields),\n         EnumNonMatchingCollapsed(..) |\n         StaticStruct(..) |\n         StaticEnum(..) => cx.span_bug(span, \"nonsensical .fields in `#[derive(Debug)]`\"),\n@@ -67,55 +67,51 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n \n     let fmt = substr.nonself_args[0].clone();\n \n-    let mut stmts = match *substr.fields {\n-        Struct(_, ref fields) |\n-        EnumMatching(.., ref fields) => {\n-            let mut stmts = vec![];\n-            if !is_struct {\n-                // tuple struct/\"normal\" variant\n-                let expr =\n-                    cx.expr_method_call(span, fmt, Ident::from_str(\"debug_tuple\"), vec![name]);\n-                stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n-\n-                for field in fields {\n-                    // Use double indirection to make sure this works for unsized types\n-                    let field = cx.expr_addr_of(field.span, field.self_.clone());\n-                    let field = cx.expr_addr_of(field.span, field);\n-\n-                    let expr = cx.expr_method_call(span,\n-                                                   builder_expr.clone(),\n-                                                   Ident::from_str(\"field\"),\n-                                                   vec![field]);\n-\n-                    // Use `let _ = expr;` to avoid triggering the\n-                    // unused_results lint.\n-                    stmts.push(stmt_let_undescore(cx, span, expr));\n-                }\n-            } else {\n-                // normal struct/struct variant\n-                let expr =\n-                    cx.expr_method_call(span, fmt, Ident::from_str(\"debug_struct\"), vec![name]);\n-                stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n-\n-                for field in fields {\n-                    let name = cx.expr_lit(field.span,\n-                                           ast::LitKind::Str(field.name.unwrap().name,\n-                                                             ast::StrStyle::Cooked));\n-\n-                    // Use double indirection to make sure this works for unsized types\n-                    let field = cx.expr_addr_of(field.span, field.self_.clone());\n-                    let field = cx.expr_addr_of(field.span, field);\n-                    let expr = cx.expr_method_call(span,\n-                                                   builder_expr.clone(),\n-                                                   Ident::from_str(\"field\"),\n-                                                   vec![name, field]);\n-                    stmts.push(stmt_let_undescore(cx, span, expr));\n-                }\n+    let mut stmts = vec![];\n+    match vdata {\n+        ast::VariantData::Tuple(..) | ast::VariantData::Unit(..) => {\n+            // tuple struct/\"normal\" variant\n+            let expr =\n+                cx.expr_method_call(span, fmt, Ident::from_str(\"debug_tuple\"), vec![name]);\n+            stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n+\n+            for field in fields {\n+                // Use double indirection to make sure this works for unsized types\n+                let field = cx.expr_addr_of(field.span, field.self_.clone());\n+                let field = cx.expr_addr_of(field.span, field);\n+\n+                let expr = cx.expr_method_call(span,\n+                                                builder_expr.clone(),\n+                                                Ident::from_str(\"field\"),\n+                                                vec![field]);\n+\n+                // Use `let _ = expr;` to avoid triggering the\n+                // unused_results lint.\n+                stmts.push(stmt_let_undescore(cx, span, expr));\n             }\n-            stmts\n         }\n-        _ => unreachable!(),\n-    };\n+        ast::VariantData::Struct(..) => {\n+            // normal struct/struct variant\n+            let expr =\n+                cx.expr_method_call(span, fmt, Ident::from_str(\"debug_struct\"), vec![name]);\n+            stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n+\n+            for field in fields {\n+                let name = cx.expr_lit(field.span,\n+                                        ast::LitKind::Str(field.name.unwrap().name,\n+                                                            ast::StrStyle::Cooked));\n+\n+                // Use double indirection to make sure this works for unsized types\n+                let field = cx.expr_addr_of(field.span, field.self_.clone());\n+                let field = cx.expr_addr_of(field.span, field);\n+                let expr = cx.expr_method_call(span,\n+                                                builder_expr.clone(),\n+                                                Ident::from_str(\"field\"),\n+                                                vec![name, field]);\n+                stmts.push(stmt_let_undescore(cx, span, expr));\n+            }\n+        }\n+    }\n \n     let expr = cx.expr_method_call(span, builder_expr, Ident::from_str(\"finish\"), vec![]);\n "}, {"sha": "dc0d72a7830e633b646be56054f818ccbad66cd3", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -1539,6 +1539,7 @@ impl<'a> TraitDef<'a> {\n             }\n         }\n \n+        let is_tuple = if let ast::VariantData::Tuple(..) = struct_def { true } else { false };\n         match (just_spans.is_empty(), named_idents.is_empty()) {\n             (false, false) => {\n                 cx.span_bug(self.span,\n@@ -1547,9 +1548,10 @@ impl<'a> TraitDef<'a> {\n             }\n             // named fields\n             (_, false) => Named(named_idents),\n-            // empty structs\n-            _ if struct_def.is_struct() => Named(named_idents),\n-            _ => Unnamed(just_spans, struct_def.is_tuple()),\n+            // unnamed fields\n+            (false, _) => Unnamed(just_spans, is_tuple),\n+            // empty\n+            _ => Named(Vec::new()),\n         }\n     }\n "}, {"sha": "606503151c985911077be563dde3d98a1da4174e", "filename": "src/test/mir-opt/unusual-item-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Ftest%2Fmir-opt%2Funusual-item-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3752b3d3a56bf3eabb588b7d595cd1f8accc0286/src%2Ftest%2Fmir-opt%2Funusual-item-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funusual-item-types.rs?ref=3752b3d3a56bf3eabb588b7d595cd1f8accc0286", "patch": "@@ -72,7 +72,7 @@ fn main() {\n // }\n // END rustc.ptr-real_drop_in_place.std__vec__Vec_i32_.AddMovesForPackedDrops.before.mir\n \n-// START rustc.Test-X.mir_map.0.mir\n+// START rustc.Test-X-{{constructor}}.mir_map.0.mir\n // fn Test::X(_1: usize) -> Test {\n //     let mut _0: Test;\n //\n@@ -81,4 +81,4 @@ fn main() {\n //         return;\n //     }\n // }\n-// END rustc.Test-X.mir_map.0.mir\n+// END rustc.Test-X-{{constructor}}.mir_map.0.mir"}]}