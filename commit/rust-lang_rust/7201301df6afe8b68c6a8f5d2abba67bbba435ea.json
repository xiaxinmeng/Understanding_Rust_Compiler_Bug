{"sha": "7201301df6afe8b68c6a8f5d2abba67bbba435ea", "node_id": "C_kwDOAAsO6NoAKDcyMDEzMDFkZjZhZmU4YjY4YzZhOGY1ZDJhYmJhNjdiYmJhNDM1ZWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-09T13:05:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-09T13:05:56Z"}, "message": "Auto merge of #109500 - petrochenkov:modchainld, r=oli-obk\n\nresolve: Preserve reexport chains in `ModChild`ren\n\nThis may be potentially useful for\n- avoiding uses of `hir::ItemKind::Use` (which usually lead to correctness issues)\n- preserving documentation comments on all reexports, including those from other crates\n- preserving and checking stability/deprecation info on reexports\n- all kinds of diagnostics\n\nThe second commit then migrates some hacky logic from rustdoc to `module_reexports` to make it simpler and more correct.\nIdeally rustdoc should use `module_reexports` immediately at the top level, so `hir::ItemKind::Use`s are never used.\nThe second commit also fixes issues with https://github.com/rust-lang/rust/pull/109330 and therefore\nFixes https://github.com/rust-lang/rust/issues/109631\nFixes https://github.com/rust-lang/rust/issues/109614\nFixes https://github.com/rust-lang/rust/issues/109424", "tree": {"sha": "2ef2b24cdda8c266e98cf4d06f9fc9ffcc3f12f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ef2b24cdda8c266e98cf4d06f9fc9ffcc3f12f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7201301df6afe8b68c6a8f5d2abba67bbba435ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7201301df6afe8b68c6a8f5d2abba67bbba435ea", "html_url": "https://github.com/rust-lang/rust/commit/7201301df6afe8b68c6a8f5d2abba67bbba435ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7201301df6afe8b68c6a8f5d2abba67bbba435ea/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56e0626836d92973cd12cb505179eef9795efc61", "url": "https://api.github.com/repos/rust-lang/rust/commits/56e0626836d92973cd12cb505179eef9795efc61", "html_url": "https://github.com/rust-lang/rust/commit/56e0626836d92973cd12cb505179eef9795efc61"}, {"sha": "9da9373bf0ebaf5fb2e4911d263a1950e2306157", "url": "https://api.github.com/repos/rust-lang/rust/commits/9da9373bf0ebaf5fb2e4911d263a1950e2306157", "html_url": "https://github.com/rust-lang/rust/commit/9da9373bf0ebaf5fb2e4911d263a1950e2306157"}], "stats": {"total": 265, "additions": 97, "deletions": 168}, "files": [{"sha": "f9d32ffceef61fa6828f30d4b15f9b7f25020a78", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7201301df6afe8b68c6a8f5d2abba67bbba435ea/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7201301df6afe8b68c6a8f5d2abba67bbba435ea/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=7201301df6afe8b68c6a8f5d2abba67bbba435ea", "patch": "@@ -991,7 +991,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             _ => false,\n         };\n \n-        ModChild { ident, res, vis, span, macro_rules }\n+        ModChild { ident, res, vis, span, macro_rules, reexport_chain: Default::default() }\n     }\n \n     /// Iterates over all named children of the given module,"}, {"sha": "4291b9aa14266a68a3299434198dcbd04db75d62", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7201301df6afe8b68c6a8f5d2abba67bbba435ea/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7201301df6afe8b68c6a8f5d2abba67bbba435ea/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=7201301df6afe8b68c6a8f5d2abba67bbba435ea", "patch": "@@ -1327,8 +1327,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 }\n             }));\n \n-            if let Some(reexports) = tcx.module_reexports(local_def_id) {\n-                assert!(!reexports.is_empty());\n+            let reexports = tcx.module_reexports(local_def_id);\n+            if !reexports.is_empty() {\n                 record_array!(self.tables.module_reexports[def_id] <- reexports);\n             }\n         }"}, {"sha": "dd1e254f405b65983b0e8be00f3fa889bfa8b1a5", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7201301df6afe8b68c6a8f5d2abba67bbba435ea/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7201301df6afe8b68c6a8f5d2abba67bbba435ea/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=7201301df6afe8b68c6a8f5d2abba67bbba435ea", "patch": "@@ -119,6 +119,7 @@ macro_rules! arena_types {\n             [] external_constraints: rustc_middle::traits::solve::ExternalConstraintsData<'tcx>,\n             [decode] doc_link_resolutions: rustc_hir::def::DocLinkResMap,\n             [] closure_kind_origin: (rustc_span::Span, rustc_middle::hir::place::Place<'tcx>),\n+            [] mod_child: rustc_middle::metadata::ModChild,\n         ]);\n     )\n }"}, {"sha": "fabc6bce7317bd24fa259ea384cee7441abe8c57", "filename": "compiler/rustc_middle/src/metadata.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7201301df6afe8b68c6a8f5d2abba67bbba435ea/compiler%2Frustc_middle%2Fsrc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7201301df6afe8b68c6a8f5d2abba67bbba435ea/compiler%2Frustc_middle%2Fsrc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmetadata.rs?ref=7201301df6afe8b68c6a8f5d2abba67bbba435ea", "patch": "@@ -5,13 +5,34 @@ use rustc_macros::HashStable;\n use rustc_span::def_id::DefId;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n+use smallvec::SmallVec;\n+\n+/// A simplified version of `ImportKind` from resolve.\n+/// `DefId`s here correspond to `use` and `extern crate` items themselves, not their targets.\n+#[derive(Clone, Copy, Debug, TyEncodable, TyDecodable, HashStable)]\n+pub enum Reexport {\n+    Single(DefId),\n+    Glob(DefId),\n+    ExternCrate(DefId),\n+    MacroUse,\n+    MacroExport,\n+}\n+\n+impl Reexport {\n+    pub fn id(self) -> Option<DefId> {\n+        match self {\n+            Reexport::Single(id) | Reexport::Glob(id) | Reexport::ExternCrate(id) => Some(id),\n+            Reexport::MacroUse | Reexport::MacroExport => None,\n+        }\n+    }\n+}\n \n /// This structure is supposed to keep enough data to re-create `NameBinding`s for other crates\n /// during name resolution. Right now the bindings are not recreated entirely precisely so we may\n /// need to add more data in the future to correctly support macros 2.0, for example.\n /// Module child can be either a proper item or a reexport (including private imports).\n /// In case of reexport all the fields describe the reexport item itself, not what it refers to.\n-#[derive(Copy, Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n+#[derive(Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct ModChild {\n     /// Name of the item.\n     pub ident: Ident,\n@@ -24,4 +45,7 @@ pub struct ModChild {\n     pub span: Span,\n     /// A proper `macro_rules` item (not a reexport).\n     pub macro_rules: bool,\n+    /// Reexport chain linking this module child to its original reexported item.\n+    /// Empty if the module child is a proper item.\n+    pub reexport_chain: SmallVec<[Reexport; 2]>,\n }"}, {"sha": "24d98665a7b445809434f6a3bd442e707721b85b", "filename": "compiler/rustc_middle/src/query/erase.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7201301df6afe8b68c6a8f5d2abba67bbba435ea/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7201301df6afe8b68c6a8f5d2abba67bbba435ea/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs?ref=7201301df6afe8b68c6a8f5d2abba67bbba435ea", "patch": "@@ -235,7 +235,6 @@ trivial! {\n     rustc_hir::OwnerId,\n     rustc_hir::Upvar,\n     rustc_index::bit_set::FiniteBitSet<u32>,\n-    rustc_middle::metadata::ModChild,\n     rustc_middle::middle::dependency_format::Linkage,\n     rustc_middle::middle::exported_symbols::SymbolExportInfo,\n     rustc_middle::middle::resolve_bound_vars::ObjectLifetimeDefault,"}, {"sha": "a0fce4b47ca30b16cfe1de1fcd9fc4538fd08822", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7201301df6afe8b68c6a8f5d2abba67bbba435ea/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7201301df6afe8b68c6a8f5d2abba67bbba435ea/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=7201301df6afe8b68c6a8f5d2abba67bbba435ea", "patch": "@@ -1510,7 +1510,7 @@ rustc_queries! {\n         desc { \"getting traits in scope at a block\" }\n     }\n \n-    query module_reexports(def_id: LocalDefId) -> Option<&'tcx [ModChild]> {\n+    query module_reexports(def_id: LocalDefId) -> &'tcx [ModChild] {\n         desc { |tcx| \"looking up reexports of module `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n     }\n "}, {"sha": "2ef6180c4cbd2d95415b71d03545b55588aaade8", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7201301df6afe8b68c6a8f5d2abba67bbba435ea/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7201301df6afe8b68c6a8f5d2abba67bbba435ea/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=7201301df6afe8b68c6a8f5d2abba67bbba435ea", "patch": "@@ -2502,7 +2502,7 @@ pub struct DeducedParamAttrs {\n \n pub fn provide(providers: &mut ty::query::Providers) {\n     providers.module_reexports =\n-        |tcx, id| tcx.resolutions(()).reexport_map.get(&id).map(|v| &v[..]);\n+        |tcx, id| tcx.resolutions(()).reexport_map.get(&id).map_or(&[], |v| &v[..]);\n     providers.maybe_unused_trait_imports =\n         |tcx, ()| &tcx.resolutions(()).maybe_unused_trait_imports;\n     providers.names_imported_by_glob_use = |tcx, id| {"}, {"sha": "089e043d61c3c0bce58a25cb47088bdcdf6237ec", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7201301df6afe8b68c6a8f5d2abba67bbba435ea/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7201301df6afe8b68c6a8f5d2abba67bbba435ea/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=7201301df6afe8b68c6a8f5d2abba67bbba435ea", "patch": "@@ -515,16 +515,12 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n             let vis = self.tcx.local_visibility(item_id.owner_id.def_id);\n             self.update_macro_reachable_def(item_id.owner_id.def_id, def_kind, vis, defining_mod);\n         }\n-        if let Some(exports) = self.tcx.module_reexports(module_def_id) {\n-            for export in exports {\n-                if export.vis.is_accessible_from(defining_mod, self.tcx) {\n-                    if let Res::Def(def_kind, def_id) = export.res {\n-                        if let Some(def_id) = def_id.as_local() {\n-                            let vis = self.tcx.local_visibility(def_id);\n-                            self.update_macro_reachable_def(def_id, def_kind, vis, defining_mod);\n-                        }\n-                    }\n-                }\n+        for export in self.tcx.module_reexports(module_def_id) {\n+            if export.vis.is_accessible_from(defining_mod, self.tcx)\n+                && let Res::Def(def_kind, def_id) = export.res\n+                && let Some(def_id) = def_id.as_local() {\n+                let vis = self.tcx.local_visibility(def_id);\n+                self.update_macro_reachable_def(def_id, def_kind, vis, defining_mod);\n             }\n         }\n     }"}, {"sha": "1f2a90829ec729325796c5552b5051e6ecc054fc", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7201301df6afe8b68c6a8f5d2abba67bbba435ea/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7201301df6afe8b68c6a8f5d2abba67bbba435ea/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=7201301df6afe8b68c6a8f5d2abba67bbba435ea", "patch": "@@ -931,7 +931,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n     /// Builds the reduced graph for a single item in an external crate.\n     fn build_reduced_graph_for_external_crate_res(&mut self, child: ModChild) {\n         let parent = self.parent_scope.module;\n-        let ModChild { ident, res, vis, span, macro_rules } = child;\n+        let ModChild { ident, res, vis, span, macro_rules, .. } = child;\n         let res = res.expect_non_local();\n         let expansion = self.parent_scope.expansion;\n         // Record primary definitions."}, {"sha": "77bfcb659de106967088562a9cb9a1436f39fa0e", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7201301df6afe8b68c6a8f5d2abba67bbba435ea/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7201301df6afe8b68c6a8f5d2abba67bbba435ea/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=7201301df6afe8b68c6a8f5d2abba67bbba435ea", "patch": "@@ -17,6 +17,7 @@ use rustc_data_structures::intern::Interned;\n use rustc_errors::{pluralize, struct_span_err, Applicability, MultiSpan};\n use rustc_hir::def::{self, DefKind, PartialRes};\n use rustc_middle::metadata::ModChild;\n+use rustc_middle::metadata::Reexport;\n use rustc_middle::span_bug;\n use rustc_middle::ty;\n use rustc_session::lint::builtin::{\n@@ -27,6 +28,7 @@ use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::hygiene::LocalExpnId;\n use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::Span;\n+use smallvec::SmallVec;\n \n use std::cell::Cell;\n use std::{mem, ptr};\n@@ -190,6 +192,17 @@ impl<'a> Import<'a> {\n             ImportKind::MacroUse | ImportKind::MacroExport => None,\n         }\n     }\n+\n+    fn simplify(&self, r: &Resolver<'_, '_>) -> Reexport {\n+        let to_def_id = |id| r.local_def_id(id).to_def_id();\n+        match self.kind {\n+            ImportKind::Single { id, .. } => Reexport::Single(to_def_id(id)),\n+            ImportKind::Glob { id, .. } => Reexport::Glob(to_def_id(id)),\n+            ImportKind::ExternCrate { id, .. } => Reexport::ExternCrate(to_def_id(id)),\n+            ImportKind::MacroUse => Reexport::MacroUse,\n+            ImportKind::MacroExport => Reexport::MacroExport,\n+        }\n+    }\n }\n \n /// Records information about the resolution of a name in a namespace of a module.\n@@ -1252,12 +1265,20 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             module.for_each_child(self, |this, ident, _, binding| {\n                 if let Some(res) = this.is_reexport(binding) {\n+                    let mut reexport_chain = SmallVec::new();\n+                    let mut next_binding = binding;\n+                    while let NameBindingKind::Import { binding, import, .. } = next_binding.kind {\n+                        reexport_chain.push(import.simplify(this));\n+                        next_binding = binding;\n+                    }\n+\n                     reexports.push(ModChild {\n                         ident,\n                         res,\n                         vis: binding.vis,\n                         span: binding.span,\n                         macro_rules: false,\n+                        reexport_chain,\n                     });\n                 }\n             });"}, {"sha": "575f56ff4df29b2504a17925be74c48cbb731436", "filename": "library/std/src/collections/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7201301df6afe8b68c6a8f5d2abba67bbba435ea/library%2Fstd%2Fsrc%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7201301df6afe8b68c6a8f5d2abba67bbba435ea/library%2Fstd%2Fsrc%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fmod.rs?ref=7201301df6afe8b68c6a8f5d2abba67bbba435ea", "patch": "@@ -416,8 +416,10 @@ pub use alloc_crate::collections::{BTreeMap, BTreeSet, BinaryHeap};\n pub use alloc_crate::collections::{LinkedList, VecDeque};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(inline)]\n pub use self::hash_map::HashMap;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(inline)]\n pub use self::hash_set::HashSet;\n \n #[stable(feature = \"try_reserve\", since = \"1.57.0\")]"}, {"sha": "9270d1c02e21135ff0de2da8d6c3f014de7f3285", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7201301df6afe8b68c6a8f5d2abba67bbba435ea/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7201301df6afe8b68c6a8f5d2abba67bbba435ea/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=7201301df6afe8b68c6a8f5d2abba67bbba435ea", "patch": "@@ -153,7 +153,6 @@ pub(crate) fn try_inline_glob(\n             let reexports = cx\n                 .tcx\n                 .module_reexports(current_mod)\n-                .unwrap_or_default()\n                 .iter()\n                 .filter_map(|child| child.res.opt_def_id())\n                 .collect();\n@@ -558,7 +557,7 @@ fn build_module_items(\n     // If we're re-exporting a re-export it may actually re-export something in\n     // two namespaces, so the target may be listed twice. Make sure we only\n     // visit each node at most once.\n-    for &item in cx.tcx.module_children(did).iter() {\n+    for item in cx.tcx.module_children(did).iter() {\n         if item.vis.is_public() {\n             let res = item.res.expect_non_local();\n             if let Some(def_id) = res.opt_def_id()"}, {"sha": "7f150f3802538b366bf7529247e5b73c659bea94", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 29, "deletions": 140, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/7201301df6afe8b68c6a8f5d2abba67bbba435ea/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7201301df6afe8b68c6a8f5d2abba67bbba435ea/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7201301df6afe8b68c6a8f5d2abba67bbba435ea", "patch": "@@ -21,6 +21,7 @@ use rustc_hir::def_id::{DefId, DefIdMap, DefIdSet, LocalDefId, LOCAL_CRATE};\n use rustc_hir::PredicateOrigin;\n use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_infer::infer::region_constraints::{Constraint, RegionConstraintData};\n+use rustc_middle::metadata::Reexport;\n use rustc_middle::middle::resolve_bound_vars as rbv;\n use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::InternalSubsts;\n@@ -2056,141 +2057,44 @@ fn clean_bare_fn_ty<'tcx>(\n     BareFunctionDecl { unsafety: bare_fn.unsafety, abi: bare_fn.abi, decl, generic_params }\n }\n \n-/// Get DefId of of an item's user-visible parent.\n-///\n-/// \"User-visible\" should account for re-exporting and inlining, which is why this function isn't\n-/// just `tcx.parent(def_id)`. If the provided `path` has more than one path element, the `DefId`\n-/// of the second-to-last will be given.\n-///\n-/// ```text\n-/// use crate::foo::Bar;\n-///            ^^^ DefId of this item will be returned\n-/// ```\n-///\n-/// If the provided path has only one item, `tcx.parent(def_id)` will be returned instead.\n-fn get_path_parent_def_id(\n-    tcx: TyCtxt<'_>,\n-    def_id: DefId,\n-    path: &hir::UsePath<'_>,\n-) -> Option<DefId> {\n-    if let [.., parent_segment, _] = &path.segments {\n-        match parent_segment.res {\n-            hir::def::Res::Def(_, parent_def_id) => Some(parent_def_id),\n-            _ if parent_segment.ident.name == kw::Crate => {\n-                // In case the \"parent\" is the crate, it'll give `Res::Err` so we need to\n-                // circumvent it this way.\n-                Some(tcx.parent(def_id))\n-            }\n-            _ => None,\n-        }\n-    } else {\n-        // If the path doesn't have a parent, then the parent is the current module.\n-        Some(tcx.parent(def_id))\n-    }\n-}\n-\n-/// This visitor is used to find an HIR Item based on its `use` path. This doesn't use the ordinary\n-/// name resolver because it does not walk all the way through a chain of re-exports.\n-pub(crate) struct OneLevelVisitor<'hir> {\n-    map: rustc_middle::hir::map::Map<'hir>,\n-    pub(crate) item: Option<&'hir hir::Item<'hir>>,\n-    looking_for: Ident,\n+pub(crate) fn reexport_chain<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    import_def_id: LocalDefId,\n     target_def_id: LocalDefId,\n-}\n-\n-impl<'hir> OneLevelVisitor<'hir> {\n-    pub(crate) fn new(map: rustc_middle::hir::map::Map<'hir>, target_def_id: LocalDefId) -> Self {\n-        Self { map, item: None, looking_for: Ident::empty(), target_def_id }\n-    }\n-\n-    pub(crate) fn find_target(\n-        &mut self,\n-        tcx: TyCtxt<'_>,\n-        def_id: DefId,\n-        path: &hir::UsePath<'_>,\n-    ) -> Option<&'hir hir::Item<'hir>> {\n-        let parent_def_id = get_path_parent_def_id(tcx, def_id, path)?;\n-        let parent = self.map.get_if_local(parent_def_id)?;\n-\n-        // We get the `Ident` we will be looking for into `item`.\n-        self.looking_for = path.segments[path.segments.len() - 1].ident;\n-        // We reset the `item`.\n-        self.item = None;\n-\n-        match parent {\n-            hir::Node::Item(parent_item) => {\n-                hir::intravisit::walk_item(self, parent_item);\n-            }\n-            hir::Node::Crate(m) => {\n-                hir::intravisit::walk_mod(\n-                    self,\n-                    m,\n-                    tcx.local_def_id_to_hir_id(parent_def_id.as_local().unwrap()),\n-                );\n-            }\n-            _ => return None,\n-        }\n-        self.item\n-    }\n-}\n-\n-impl<'hir> hir::intravisit::Visitor<'hir> for OneLevelVisitor<'hir> {\n-    type NestedFilter = rustc_middle::hir::nested_filter::All;\n-\n-    fn nested_visit_map(&mut self) -> Self::Map {\n-        self.map\n-    }\n-\n-    fn visit_item(&mut self, item: &'hir hir::Item<'hir>) {\n-        if self.item.is_none()\n-            && item.ident == self.looking_for\n-            && (matches!(item.kind, hir::ItemKind::Use(_, _))\n-                || item.owner_id.def_id == self.target_def_id)\n+) -> &'tcx [Reexport] {\n+    for child in tcx.module_reexports(tcx.local_parent(import_def_id)) {\n+        if child.res.opt_def_id() == Some(target_def_id.to_def_id())\n+            && child.reexport_chain[0].id() == Some(import_def_id.to_def_id())\n         {\n-            self.item = Some(item);\n+            return &child.reexport_chain;\n         }\n     }\n+    &[]\n }\n \n-/// Because a `Use` item directly links to the imported item, we need to manually go through each\n-/// import one by one. To do so, we go to the parent item and look for the `Ident` into it. Then,\n-/// if we found the \"end item\" (the imported one), we stop there because we don't need its\n-/// documentation. Otherwise, we repeat the same operation until we find the \"end item\".\n+/// Collect attributes from the whole import chain.\n fn get_all_import_attributes<'hir>(\n-    mut item: &hir::Item<'hir>,\n     cx: &mut DocContext<'hir>,\n+    import_def_id: LocalDefId,\n     target_def_id: LocalDefId,\n     is_inline: bool,\n-    mut prev_import: LocalDefId,\n ) -> Vec<(Cow<'hir, ast::Attribute>, Option<DefId>)> {\n-    let mut attributes: Vec<(Cow<'hir, ast::Attribute>, Option<DefId>)> = Vec::new();\n+    let mut attrs = Vec::new();\n     let mut first = true;\n-    let hir_map = cx.tcx.hir();\n-    let mut visitor = OneLevelVisitor::new(hir_map, target_def_id);\n-    let mut visited = FxHashSet::default();\n-\n-    // If the item is an import and has at least a path with two parts, we go into it.\n-    while let hir::ItemKind::Use(path, _) = item.kind && visited.insert(item.hir_id()) {\n-        let import_parent = cx.tcx.opt_local_parent(prev_import).map(|def_id| def_id.to_def_id());\n+    for def_id in reexport_chain(cx.tcx, import_def_id, target_def_id)\n+        .iter()\n+        .flat_map(|reexport| reexport.id())\n+    {\n+        let import_attrs = inline::load_attrs(cx, def_id);\n         if first {\n             // This is the \"original\" reexport so we get all its attributes without filtering them.\n-            attributes = hir_map.attrs(item.hir_id())\n-                .iter()\n-                .map(|attr| (Cow::Borrowed(attr), import_parent))\n-                .collect::<Vec<_>>();\n+            attrs = import_attrs.iter().map(|attr| (Cow::Borrowed(attr), Some(def_id))).collect();\n             first = false;\n         } else {\n-            add_without_unwanted_attributes(&mut attributes, hir_map.attrs(item.hir_id()), is_inline, import_parent);\n+            add_without_unwanted_attributes(&mut attrs, import_attrs, is_inline, Some(def_id));\n         }\n-\n-        if let Some(i) = visitor.find_target(cx.tcx, item.owner_id.def_id.to_def_id(), path) {\n-            item = i;\n-        } else {\n-            break;\n-        }\n-        prev_import = item.owner_id.def_id;\n     }\n-    attributes\n+    attrs\n }\n \n fn filter_tokens_from_list(\n@@ -2375,39 +2279,24 @@ fn clean_maybe_renamed_item<'tcx>(\n             _ => unreachable!(\"not yet converted\"),\n         };\n \n-        let attrs = if let Some(import_id) = import_id &&\n-            let Some(hir::Node::Item(use_node)) = cx.tcx.hir().find_by_def_id(import_id)\n-        {\n+        let target_attrs = inline::load_attrs(cx, def_id);\n+        let attrs = if let Some(import_id) = import_id {\n             let is_inline = inline::load_attrs(cx, import_id.to_def_id())\n                 .lists(sym::doc)\n                 .get_word_attr(sym::inline)\n                 .is_some();\n-            // Then we get all the various imports' attributes.\n-            let mut attrs = get_all_import_attributes(\n-                use_node,\n-                cx,\n-                item.owner_id.def_id,\n-                is_inline,\n-                import_id,\n-            );\n-\n-            add_without_unwanted_attributes(\n-                &mut attrs,\n-                inline::load_attrs(cx, def_id),\n-                is_inline,\n-                None\n-            );\n+            let mut attrs =\n+                get_all_import_attributes(cx, import_id, item.owner_id.def_id, is_inline);\n+            add_without_unwanted_attributes(&mut attrs, target_attrs, is_inline, None);\n             attrs\n         } else {\n             // We only keep the item's attributes.\n-            inline::load_attrs(cx, def_id).iter().map(|attr| (Cow::Borrowed(attr), None)).collect::<Vec<_>>()\n+            target_attrs.iter().map(|attr| (Cow::Borrowed(attr), None)).collect()\n         };\n \n         let cfg = attrs.cfg(cx.tcx, &cx.cache.hidden_cfg);\n-        let attrs = Attributes::from_ast_iter(attrs.iter().map(|(attr, did)| match attr {\n-            Cow::Borrowed(attr) => (*attr, *did),\n-            Cow::Owned(attr) => (attr, *did)\n-        }), false);\n+        let attrs =\n+            Attributes::from_ast_iter(attrs.iter().map(|(attr, did)| (&**attr, *did)), false);\n \n         let mut item =\n             Item::from_def_id_and_attrs_and_parts(def_id, Some(name), kind, Box::new(attrs), cfg);"}, {"sha": "393d51fe0906949e2af836f3aa7445c24e598e4b", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7201301df6afe8b68c6a8f5d2abba67bbba435ea/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7201301df6afe8b68c6a8f5d2abba67bbba435ea/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=7201301df6afe8b68c6a8f5d2abba67bbba435ea", "patch": "@@ -13,9 +13,9 @@ use rustc_span::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n \n-use std::mem;\n+use std::{iter, mem};\n \n-use crate::clean::{cfg::Cfg, AttributesExt, NestedAttributesExt, OneLevelVisitor};\n+use crate::clean::{cfg::Cfg, reexport_chain, AttributesExt, NestedAttributesExt};\n use crate::core;\n \n /// This module is used to store stuff from Rust's AST in a more convenient\n@@ -133,7 +133,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         // is declared but also a reexport of itself producing two exports of the same\n         // macro in the same module.\n         let mut inserted = FxHashSet::default();\n-        for export in self.cx.tcx.module_reexports(CRATE_DEF_ID).unwrap_or(&[]) {\n+        for export in self.cx.tcx.module_reexports(CRATE_DEF_ID) {\n             if let Res::Def(DefKind::Macro(_), def_id) = export.res &&\n                 let Some(local_def_id) = def_id.as_local() &&\n                 self.cx.tcx.has_attr(def_id, sym::macro_export) &&\n@@ -220,7 +220,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         renamed: Option<Symbol>,\n         glob: bool,\n         please_inline: bool,\n-        path: &hir::UsePath<'_>,\n     ) -> bool {\n         debug!(\"maybe_inline_local res: {:?}\", res);\n \n@@ -266,9 +265,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         }\n \n         if !please_inline &&\n-            let mut visitor = OneLevelVisitor::new(self.cx.tcx.hir(), res_did) &&\n-            let Some(item) = visitor.find_target(self.cx.tcx, def_id.to_def_id(), path) &&\n-            let item_def_id = item.owner_id.def_id &&\n+            let Some(item_def_id) = reexport_chain(self.cx.tcx, def_id, res_did).iter()\n+                .flat_map(|reexport| reexport.id()).map(|id| id.expect_local())\n+                .chain(iter::once(res_did)).nth(1) &&\n             item_def_id != def_id &&\n             self\n                 .cx\n@@ -383,7 +382,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                             ident,\n                             is_glob,\n                             please_inline,\n-                            path,\n                         ) {\n                             continue;\n                         }"}]}