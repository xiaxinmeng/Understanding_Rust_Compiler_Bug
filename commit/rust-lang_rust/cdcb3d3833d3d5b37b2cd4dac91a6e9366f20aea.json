{"sha": "cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkY2IzZDM4MzNkM2Q1YjM3YjJjZDRkYWM5MWE2ZTkzNjZmMjBhZWE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-12-29T12:24:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-29T12:24:19Z"}, "message": "Merge #2667\n\n2667: Visibility r=matklad a=flodiebold\n\nThis adds the infrastructure for handling visibility (for fields and methods, not in name resolution) in the HIR and code model, and as a first application hides struct fields from completions if they're not visible from the current module. (We might want to relax this again later, but I think it's ok for now?)\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "c9750e1ef8079a691caed3dc941392c99fda1524", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9750e1ef8079a691caed3dc941392c99fda1524"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeCJrzCRBK7hj4Ov3rIwAAdHIIAKiO2ecOPl18lVA+ghVfyNqG\nrV37VocNcasNaiCH7KFY889U8/+q2yZYKOtB/TrtvJp+Jm5+PHoCyfkQcX/MbNTs\nbmsm2myFKF1RPCNSTNmiDI0PUK6mZss9ogl1PM2oWHG1RGdVZwBlYn2Qgpn4b5HI\nDelUaO31tgP3JmaBp/fQ/kB5ocd+dcnPsao3amki31APNtvnON1NwODg/DHkR073\nhUg3NSpSXnfXj1xBNXhreIJtxz7oedC1vV5bAnsguefLy2dMqcpOGWt//iwWTCWL\nKevf9x17iFmZoLDFGH5t+1QV5cxF8IDD3eTaTjNudpPu/imqhAX/Jgc6rNWDqqY=\n=eAln\n-----END PGP SIGNATURE-----\n", "payload": "tree c9750e1ef8079a691caed3dc941392c99fda1524\nparent c5a48bea1218afb63d7932a6816f34c810bbab6b\nparent 9fd2c813ca355c3a1f10f54993c16e81778b867b\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1577622259 +0000\ncommitter GitHub <noreply@github.com> 1577622259 +0000\n\nMerge #2667\n\n2667: Visibility r=matklad a=flodiebold\n\nThis adds the infrastructure for handling visibility (for fields and methods, not in name resolution) in the HIR and code model, and as a first application hides struct fields from completions if they're not visible from the current module. (We might want to relax this again later, but I think it's ok for now?)\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "html_url": "https://github.com/rust-lang/rust/commit/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5a48bea1218afb63d7932a6816f34c810bbab6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5a48bea1218afb63d7932a6816f34c810bbab6b", "html_url": "https://github.com/rust-lang/rust/commit/c5a48bea1218afb63d7932a6816f34c810bbab6b"}, {"sha": "9fd2c813ca355c3a1f10f54993c16e81778b867b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fd2c813ca355c3a1f10f54993c16e81778b867b", "html_url": "https://github.com/rust-lang/rust/commit/9fd2c813ca355c3a1f10f54993c16e81778b867b"}], "stats": {"total": 723, "additions": 609, "deletions": 114}, "files": [{"sha": "488f74cfb13f3cb39b3cf87ba5fa9c7ff515aaf0", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -118,7 +118,7 @@ impl_froms!(\n     BuiltinType\n );\n \n-pub use hir_def::attr::Attrs;\n+pub use hir_def::{attr::Attrs, visibility::Visibility};\n \n impl Module {\n     pub(crate) fn new(krate: Crate, crate_module_id: LocalModuleId) -> Module {\n@@ -255,6 +255,15 @@ impl StructField {\n     }\n }\n \n+impl HasVisibility for StructField {\n+    fn visibility(&self, db: &impl HirDatabase) -> Visibility {\n+        let variant_data = self.parent.variant_data(db);\n+        let visibility = &variant_data.fields()[self.id].visibility;\n+        let parent_id: hir_def::VariantId = self.parent.into();\n+        visibility.resolve(db, &parent_id.resolver(db))\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Struct {\n     pub(crate) id: StructId,\n@@ -1041,3 +1050,11 @@ impl<T: Into<AttrDef> + Copy> Docs for T {\n         db.documentation(def.into())\n     }\n }\n+\n+pub trait HasVisibility {\n+    fn visibility(&self, db: &impl HirDatabase) -> Visibility;\n+    fn is_visible_from(&self, db: &impl HirDatabase, module: Module) -> bool {\n+        let vis = self.visibility(db);\n+        vis.is_visible_from(db, module.id)\n+    }\n+}"}, {"sha": "3d13978d459a4012bdcfb55dcf06b1bb19bc177f", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -40,8 +40,8 @@ mod from_source;\n pub use crate::{\n     code_model::{\n         Adt, AssocItem, AttrDef, Const, Crate, CrateDependency, DefWithBody, Docs, Enum,\n-        EnumVariant, FieldSource, Function, GenericDef, HasAttrs, ImplBlock, Local, MacroDef,\n-        Module, ModuleDef, ScopeDef, Static, Struct, StructField, Trait, Type, TypeAlias,\n+        EnumVariant, FieldSource, Function, GenericDef, HasAttrs, HasVisibility, ImplBlock, Local,\n+        MacroDef, Module, ModuleDef, ScopeDef, Static, Struct, StructField, Trait, Type, TypeAlias,\n         TypeParam, Union, VariantDef,\n     },\n     from_source::FromSource,"}, {"sha": "aac5f3e15360eb9fb9bd0ce20deeef0ea58c3066", "filename": "crates/ra_hir_def/src/adt.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fadt.rs?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -9,11 +9,12 @@ use hir_expand::{\n };\n use ra_arena::{map::ArenaMap, Arena};\n use ra_prof::profile;\n-use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n+use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner, VisibilityOwner};\n \n use crate::{\n-    db::DefDatabase, src::HasChildSource, src::HasSource, trace::Trace, type_ref::TypeRef, EnumId,\n-    LocalEnumVariantId, LocalStructFieldId, Lookup, StructId, UnionId, VariantId,\n+    db::DefDatabase, src::HasChildSource, src::HasSource, trace::Trace, type_ref::TypeRef,\n+    visibility::RawVisibility, EnumId, LocalEnumVariantId, LocalStructFieldId, Lookup, StructId,\n+    UnionId, VariantId,\n };\n \n /// Note that we use `StructData` for unions as well!\n@@ -47,24 +48,27 @@ pub enum VariantData {\n pub struct StructFieldData {\n     pub name: Name,\n     pub type_ref: TypeRef,\n+    pub visibility: RawVisibility,\n }\n \n impl StructData {\n     pub(crate) fn struct_data_query(db: &impl DefDatabase, id: StructId) -> Arc<StructData> {\n         let src = id.lookup(db).source(db);\n         let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n-        let variant_data = VariantData::new(src.value.kind());\n+        let variant_data = VariantData::new(db, src.map(|s| s.kind()));\n         let variant_data = Arc::new(variant_data);\n         Arc::new(StructData { name, variant_data })\n     }\n     pub(crate) fn union_data_query(db: &impl DefDatabase, id: UnionId) -> Arc<StructData> {\n         let src = id.lookup(db).source(db);\n         let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n         let variant_data = VariantData::new(\n-            src.value\n-                .record_field_def_list()\n-                .map(ast::StructKind::Record)\n-                .unwrap_or(ast::StructKind::Unit),\n+            db,\n+            src.map(|s| {\n+                s.record_field_def_list()\n+                    .map(ast::StructKind::Record)\n+                    .unwrap_or(ast::StructKind::Unit)\n+            }),\n         );\n         let variant_data = Arc::new(variant_data);\n         Arc::new(StructData { name, variant_data })\n@@ -77,7 +81,7 @@ impl EnumData {\n         let src = e.lookup(db).source(db);\n         let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n         let mut trace = Trace::new_for_arena();\n-        lower_enum(&mut trace, &src.value);\n+        lower_enum(db, &mut trace, &src);\n         Arc::new(EnumData { name, variants: trace.into_arena() })\n     }\n \n@@ -93,30 +97,31 @@ impl HasChildSource for EnumId {\n     fn child_source(&self, db: &impl DefDatabase) -> InFile<ArenaMap<Self::ChildId, Self::Value>> {\n         let src = self.lookup(db).source(db);\n         let mut trace = Trace::new_for_map();\n-        lower_enum(&mut trace, &src.value);\n+        lower_enum(db, &mut trace, &src);\n         src.with_value(trace.into_map())\n     }\n }\n \n fn lower_enum(\n+    db: &impl DefDatabase,\n     trace: &mut Trace<LocalEnumVariantId, EnumVariantData, ast::EnumVariant>,\n-    ast: &ast::EnumDef,\n+    ast: &InFile<ast::EnumDef>,\n ) {\n-    for var in ast.variant_list().into_iter().flat_map(|it| it.variants()) {\n+    for var in ast.value.variant_list().into_iter().flat_map(|it| it.variants()) {\n         trace.alloc(\n             || var.clone(),\n             || EnumVariantData {\n                 name: var.name().map_or_else(Name::missing, |it| it.as_name()),\n-                variant_data: Arc::new(VariantData::new(var.kind())),\n+                variant_data: Arc::new(VariantData::new(db, ast.with_value(var.kind()))),\n             },\n         );\n     }\n }\n \n impl VariantData {\n-    fn new(flavor: ast::StructKind) -> Self {\n+    fn new(db: &impl DefDatabase, flavor: InFile<ast::StructKind>) -> Self {\n         let mut trace = Trace::new_for_arena();\n-        match lower_struct(&mut trace, &flavor) {\n+        match lower_struct(db, &mut trace, &flavor) {\n             StructKind::Tuple => VariantData::Tuple(trace.into_arena()),\n             StructKind::Record => VariantData::Record(trace.into_arena()),\n             StructKind::Unit => VariantData::Unit,\n@@ -163,7 +168,7 @@ impl HasChildSource for VariantId {\n             }),\n         };\n         let mut trace = Trace::new_for_map();\n-        lower_struct(&mut trace, &src.value);\n+        lower_struct(db, &mut trace, &src);\n         src.with_value(trace.into_map())\n     }\n }\n@@ -175,21 +180,23 @@ enum StructKind {\n }\n \n fn lower_struct(\n+    db: &impl DefDatabase,\n     trace: &mut Trace<\n         LocalStructFieldId,\n         StructFieldData,\n         Either<ast::TupleFieldDef, ast::RecordFieldDef>,\n     >,\n-    ast: &ast::StructKind,\n+    ast: &InFile<ast::StructKind>,\n ) -> StructKind {\n-    match ast {\n+    match &ast.value {\n         ast::StructKind::Tuple(fl) => {\n             for (i, fd) in fl.fields().enumerate() {\n                 trace.alloc(\n                     || Either::Left(fd.clone()),\n                     || StructFieldData {\n                         name: Name::new_tuple_field(i),\n                         type_ref: TypeRef::from_ast_opt(fd.type_ref()),\n+                        visibility: RawVisibility::from_ast(db, ast.with_value(fd.visibility())),\n                     },\n                 );\n             }\n@@ -202,6 +209,7 @@ fn lower_struct(\n                     || StructFieldData {\n                         name: fd.name().map(|n| n.as_name()).unwrap_or_else(Name::missing),\n                         type_ref: TypeRef::from_ast_opt(fd.ascribed_type()),\n+                        visibility: RawVisibility::from_ast(db, ast.with_value(fd.visibility())),\n                     },\n                 );\n             }"}, {"sha": "fc3a028e0da25a1428c492c808689c009673c8ee", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -543,7 +543,10 @@ where\n             };\n             self.body.item_scope.define_def(def);\n             if let Some(name) = name {\n-                self.body.item_scope.push_res(name.as_name(), def.into());\n+                let vis = crate::visibility::Visibility::Public; // FIXME determine correctly\n+                self.body\n+                    .item_scope\n+                    .push_res(name.as_name(), crate::per_ns::PerNs::from_def(def, vis));\n             }\n         }\n     }"}, {"sha": "fe7bb9779c8a2b36ca62f87e2d53081021267d0f", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -5,7 +5,10 @@ use hir_expand::name::Name;\n use once_cell::sync::Lazy;\n use rustc_hash::FxHashMap;\n \n-use crate::{per_ns::PerNs, AdtId, BuiltinType, ImplId, MacroDefId, ModuleDefId, TraitId};\n+use crate::{\n+    per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType, ImplId, MacroDefId, ModuleDefId,\n+    TraitId,\n+};\n \n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct ItemScope {\n@@ -30,7 +33,7 @@ pub struct ItemScope {\n static BUILTIN_SCOPE: Lazy<FxHashMap<Name, PerNs>> = Lazy::new(|| {\n     BuiltinType::ALL\n         .iter()\n-        .map(|(name, ty)| (name.clone(), PerNs::types(ty.clone().into())))\n+        .map(|(name, ty)| (name.clone(), PerNs::types(ty.clone().into(), Visibility::Public)))\n         .collect()\n });\n \n@@ -144,29 +147,29 @@ impl ItemScope {\n         changed\n     }\n \n-    pub(crate) fn collect_resolutions(&self) -> Vec<(Name, PerNs)> {\n-        self.visible.iter().map(|(name, res)| (name.clone(), res.clone())).collect()\n+    pub(crate) fn resolutions<'a>(&'a self) -> impl Iterator<Item = (Name, PerNs)> + 'a {\n+        self.visible.iter().map(|(name, res)| (name.clone(), res.clone()))\n     }\n \n     pub(crate) fn collect_legacy_macros(&self) -> FxHashMap<Name, MacroDefId> {\n         self.legacy_macros.clone()\n     }\n }\n \n-impl From<ModuleDefId> for PerNs {\n-    fn from(def: ModuleDefId) -> PerNs {\n+impl PerNs {\n+    pub(crate) fn from_def(def: ModuleDefId, v: Visibility) -> PerNs {\n         match def {\n-            ModuleDefId::ModuleId(_) => PerNs::types(def),\n-            ModuleDefId::FunctionId(_) => PerNs::values(def),\n+            ModuleDefId::ModuleId(_) => PerNs::types(def, v),\n+            ModuleDefId::FunctionId(_) => PerNs::values(def, v),\n             ModuleDefId::AdtId(adt) => match adt {\n-                AdtId::StructId(_) | AdtId::UnionId(_) => PerNs::both(def, def),\n-                AdtId::EnumId(_) => PerNs::types(def),\n+                AdtId::StructId(_) | AdtId::UnionId(_) => PerNs::both(def, def, v),\n+                AdtId::EnumId(_) => PerNs::types(def, v),\n             },\n-            ModuleDefId::EnumVariantId(_) => PerNs::both(def, def),\n-            ModuleDefId::ConstId(_) | ModuleDefId::StaticId(_) => PerNs::values(def),\n-            ModuleDefId::TraitId(_) => PerNs::types(def),\n-            ModuleDefId::TypeAliasId(_) => PerNs::types(def),\n-            ModuleDefId::BuiltinType(_) => PerNs::types(def),\n+            ModuleDefId::EnumVariantId(_) => PerNs::both(def, def, v),\n+            ModuleDefId::ConstId(_) | ModuleDefId::StaticId(_) => PerNs::values(def, v),\n+            ModuleDefId::TraitId(_) => PerNs::types(def, v),\n+            ModuleDefId::TypeAliasId(_) => PerNs::types(def, v),\n+            ModuleDefId::BuiltinType(_) => PerNs::types(def, v),\n         }\n     }\n }"}, {"sha": "61f044ecf0b4170712437d83fe9d45ec1fe9892e", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -36,6 +36,8 @@ pub mod nameres;\n pub mod src;\n pub mod child_by_source;\n \n+pub mod visibility;\n+\n #[cfg(test)]\n mod test_db;\n #[cfg(test)]"}, {"sha": "8a22b0585910c80ccba35bf6ac4e07364fa63227", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 82, "deletions": 27, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -24,6 +24,7 @@ use crate::{\n     },\n     path::{ModPath, PathKind},\n     per_ns::PerNs,\n+    visibility::Visibility,\n     AdtId, AstId, ConstLoc, ContainerId, EnumLoc, EnumVariantId, FunctionLoc, ImplLoc, Intern,\n     LocalModuleId, ModuleDefId, ModuleId, StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc,\n };\n@@ -108,7 +109,7 @@ struct MacroDirective {\n struct DefCollector<'a, DB> {\n     db: &'a DB,\n     def_map: CrateDefMap,\n-    glob_imports: FxHashMap<LocalModuleId, Vec<(LocalModuleId, raw::Import)>>,\n+    glob_imports: FxHashMap<LocalModuleId, Vec<(LocalModuleId, Visibility)>>,\n     unresolved_imports: Vec<ImportDirective>,\n     resolved_imports: Vec<ImportDirective>,\n     unexpanded_macros: Vec<MacroDirective>,\n@@ -214,7 +215,11 @@ where\n         // In Rust, `#[macro_export]` macros are unconditionally visible at the\n         // crate root, even if the parent modules is **not** visible.\n         if export {\n-            self.update(self.def_map.root, &[(name, PerNs::macros(macro_))]);\n+            self.update(\n+                self.def_map.root,\n+                &[(name, PerNs::macros(macro_, Visibility::Public))],\n+                Visibility::Public,\n+            );\n         }\n     }\n \n@@ -348,9 +353,12 @@ where\n \n     fn record_resolved_import(&mut self, directive: &ImportDirective) {\n         let module_id = directive.module_id;\n-        let import_id = directive.import_id;\n         let import = &directive.import;\n         let def = directive.status.namespaces();\n+        let vis = self\n+            .def_map\n+            .resolve_visibility(self.db, module_id, &directive.import.visibility)\n+            .unwrap_or(Visibility::Public);\n \n         if import.is_glob {\n             log::debug!(\"glob import: {:?}\", import);\n@@ -366,23 +374,42 @@ where\n                         let scope = &item_map[m.local_id].scope;\n \n                         // Module scoped macros is included\n-                        let items = scope.collect_resolutions();\n-\n-                        self.update(module_id, &items);\n+                        let items = scope\n+                            .resolutions()\n+                            // only keep visible names...\n+                            .map(|(n, res)| {\n+                                (n, res.filter_visibility(|v| v.is_visible_from_other_crate()))\n+                            })\n+                            .filter(|(_, res)| !res.is_none())\n+                            .collect::<Vec<_>>();\n+\n+                        self.update(module_id, &items, vis);\n                     } else {\n                         // glob import from same crate => we do an initial\n                         // import, and then need to propagate any further\n                         // additions\n                         let scope = &self.def_map[m.local_id].scope;\n \n                         // Module scoped macros is included\n-                        let items = scope.collect_resolutions();\n-\n-                        self.update(module_id, &items);\n+                        let items = scope\n+                            .resolutions()\n+                            // only keep visible names...\n+                            .map(|(n, res)| {\n+                                (\n+                                    n,\n+                                    res.filter_visibility(|v| {\n+                                        v.is_visible_from_def_map(&self.def_map, module_id)\n+                                    }),\n+                                )\n+                            })\n+                            .filter(|(_, res)| !res.is_none())\n+                            .collect::<Vec<_>>();\n+\n+                        self.update(module_id, &items, vis);\n                         // record the glob import in case we add further items\n                         let glob = self.glob_imports.entry(m.local_id).or_default();\n-                        if !glob.iter().any(|it| *it == (module_id, import_id)) {\n-                            glob.push((module_id, import_id));\n+                        if !glob.iter().any(|(mid, _)| *mid == module_id) {\n+                            glob.push((module_id, vis));\n                         }\n                     }\n                 }\n@@ -396,11 +423,11 @@ where\n                         .map(|(local_id, variant_data)| {\n                             let name = variant_data.name.clone();\n                             let variant = EnumVariantId { parent: e, local_id };\n-                            let res = PerNs::both(variant.into(), variant.into());\n+                            let res = PerNs::both(variant.into(), variant.into(), vis);\n                             (name, res)\n                         })\n                         .collect::<Vec<_>>();\n-                    self.update(module_id, &resolutions);\n+                    self.update(module_id, &resolutions, vis);\n                 }\n                 Some(d) => {\n                     log::debug!(\"glob import {:?} from non-module/enum {:?}\", import, d);\n@@ -422,21 +449,24 @@ where\n                         }\n                     }\n \n-                    self.update(module_id, &[(name, def)]);\n+                    self.update(module_id, &[(name, def)], vis);\n                 }\n                 None => tested_by!(bogus_paths),\n             }\n         }\n     }\n \n-    fn update(&mut self, module_id: LocalModuleId, resolutions: &[(Name, PerNs)]) {\n-        self.update_recursive(module_id, resolutions, 0)\n+    fn update(&mut self, module_id: LocalModuleId, resolutions: &[(Name, PerNs)], vis: Visibility) {\n+        self.update_recursive(module_id, resolutions, vis, 0)\n     }\n \n     fn update_recursive(\n         &mut self,\n         module_id: LocalModuleId,\n         resolutions: &[(Name, PerNs)],\n+        // All resolutions are imported with this visibility; the visibilies in\n+        // the `PerNs` values are ignored and overwritten\n+        vis: Visibility,\n         depth: usize,\n     ) {\n         if depth > 100 {\n@@ -446,7 +476,7 @@ where\n         let scope = &mut self.def_map.modules[module_id].scope;\n         let mut changed = false;\n         for (name, res) in resolutions {\n-            changed |= scope.push_res(name.clone(), *res);\n+            changed |= scope.push_res(name.clone(), res.with_visibility(vis));\n         }\n \n         if !changed {\n@@ -459,9 +489,13 @@ where\n             .flat_map(|v| v.iter())\n             .cloned()\n             .collect::<Vec<_>>();\n-        for (glob_importing_module, _glob_import) in glob_imports {\n-            // We pass the glob import so that the tracked import in those modules is that glob import\n-            self.update_recursive(glob_importing_module, resolutions, depth + 1);\n+        for (glob_importing_module, glob_import_vis) in glob_imports {\n+            // we know all resolutions have the same visibility (`vis`), so we\n+            // just need to check that once\n+            if !vis.is_visible_from_def_map(&self.def_map, glob_importing_module) {\n+                continue;\n+            }\n+            self.update_recursive(glob_importing_module, resolutions, glob_import_vis, depth + 1);\n         }\n     }\n \n@@ -633,9 +667,13 @@ where\n         let is_macro_use = attrs.by_key(\"macro_use\").exists();\n         match module {\n             // inline module, just recurse\n-            raw::ModuleData::Definition { name, items, ast_id } => {\n-                let module_id =\n-                    self.push_child_module(name.clone(), AstId::new(self.file_id, *ast_id), None);\n+            raw::ModuleData::Definition { name, visibility, items, ast_id } => {\n+                let module_id = self.push_child_module(\n+                    name.clone(),\n+                    AstId::new(self.file_id, *ast_id),\n+                    None,\n+                    &visibility,\n+                );\n \n                 ModCollector {\n                     def_collector: &mut *self.def_collector,\n@@ -650,7 +688,7 @@ where\n                 }\n             }\n             // out of line module, resolve, parse and recurse\n-            raw::ModuleData::Declaration { name, ast_id } => {\n+            raw::ModuleData::Declaration { name, visibility, ast_id } => {\n                 let ast_id = AstId::new(self.file_id, *ast_id);\n                 match self.mod_dir.resolve_declaration(\n                     self.def_collector.db,\n@@ -659,7 +697,12 @@ where\n                     path_attr,\n                 ) {\n                     Ok((file_id, mod_dir)) => {\n-                        let module_id = self.push_child_module(name.clone(), ast_id, Some(file_id));\n+                        let module_id = self.push_child_module(\n+                            name.clone(),\n+                            ast_id,\n+                            Some(file_id),\n+                            &visibility,\n+                        );\n                         let raw_items = self.def_collector.db.raw_items(file_id.into());\n                         ModCollector {\n                             def_collector: &mut *self.def_collector,\n@@ -690,7 +733,13 @@ where\n         name: Name,\n         declaration: AstId<ast::Module>,\n         definition: Option<FileId>,\n+        visibility: &crate::visibility::RawVisibility,\n     ) -> LocalModuleId {\n+        let vis = self\n+            .def_collector\n+            .def_map\n+            .resolve_visibility(self.def_collector.db, self.module_id, visibility)\n+            .unwrap_or(Visibility::Public);\n         let modules = &mut self.def_collector.def_map.modules;\n         let res = modules.alloc(ModuleData::default());\n         modules[res].parent = Some(self.module_id);\n@@ -702,7 +751,7 @@ where\n         let module = ModuleId { krate: self.def_collector.def_map.krate, local_id: res };\n         let def: ModuleDefId = module.into();\n         self.def_collector.def_map.modules[self.module_id].scope.define_def(def);\n-        self.def_collector.update(self.module_id, &[(name, def.into())]);\n+        self.def_collector.update(self.module_id, &[(name, PerNs::from_def(def, vis))], vis);\n         res\n     }\n \n@@ -716,6 +765,7 @@ where\n \n         let name = def.name.clone();\n         let container = ContainerId::ModuleId(module);\n+        let vis = &def.visibility;\n         let def: ModuleDefId = match def.kind {\n             raw::DefKind::Function(ast_id) => FunctionLoc {\n                 container: container.into(),\n@@ -761,7 +811,12 @@ where\n             .into(),\n         };\n         self.def_collector.def_map.modules[self.module_id].scope.define_def(def);\n-        self.def_collector.update(self.module_id, &[(name, def.into())])\n+        let vis = self\n+            .def_collector\n+            .def_map\n+            .resolve_visibility(self.def_collector.db, self.module_id, vis)\n+            .unwrap_or(Visibility::Public);\n+        self.def_collector.update(self.module_id, &[(name, PerNs::from_def(def, vis))], vis)\n     }\n \n     fn collect_derives(&mut self, attrs: &Attrs, def: &raw::DefData) {"}, {"sha": "fd6422d60e0fc224fb69a6c5ce4f5b3b9f399598", "filename": "crates/ra_hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 56, "deletions": 16, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -21,6 +21,7 @@ use crate::{\n     nameres::{BuiltinShadowMode, CrateDefMap},\n     path::{ModPath, PathKind},\n     per_ns::PerNs,\n+    visibility::{RawVisibility, Visibility},\n     AdtId, CrateId, EnumVariantId, LocalModuleId, ModuleDefId, ModuleId,\n };\n \n@@ -61,7 +62,35 @@ impl ResolvePathResult {\n \n impl CrateDefMap {\n     pub(super) fn resolve_name_in_extern_prelude(&self, name: &Name) -> PerNs {\n-        self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it))\n+        self.extern_prelude\n+            .get(name)\n+            .map_or(PerNs::none(), |&it| PerNs::types(it, Visibility::Public))\n+    }\n+\n+    pub(crate) fn resolve_visibility(\n+        &self,\n+        db: &impl DefDatabase,\n+        original_module: LocalModuleId,\n+        visibility: &RawVisibility,\n+    ) -> Option<Visibility> {\n+        match visibility {\n+            RawVisibility::Module(path) => {\n+                let (result, remaining) =\n+                    self.resolve_path(db, original_module, &path, BuiltinShadowMode::Module);\n+                if remaining.is_some() {\n+                    return None;\n+                }\n+                let types = result.take_types()?;\n+                match types {\n+                    ModuleDefId::ModuleId(m) => Some(Visibility::Module(m)),\n+                    _ => {\n+                        // error: visibility needs to refer to module\n+                        None\n+                    }\n+                }\n+            }\n+            RawVisibility::Public => Some(Visibility::Public),\n+        }\n     }\n \n     // Returns Yes if we are sure that additions to `ItemMap` wouldn't change\n@@ -88,17 +117,21 @@ impl CrateDefMap {\n             PathKind::DollarCrate(krate) => {\n                 if krate == self.krate {\n                     tested_by!(macro_dollar_crate_self);\n-                    PerNs::types(ModuleId { krate: self.krate, local_id: self.root }.into())\n+                    PerNs::types(\n+                        ModuleId { krate: self.krate, local_id: self.root }.into(),\n+                        Visibility::Public,\n+                    )\n                 } else {\n                     let def_map = db.crate_def_map(krate);\n                     let module = ModuleId { krate, local_id: def_map.root };\n                     tested_by!(macro_dollar_crate_other);\n-                    PerNs::types(module.into())\n+                    PerNs::types(module.into(), Visibility::Public)\n                 }\n             }\n-            PathKind::Crate => {\n-                PerNs::types(ModuleId { krate: self.krate, local_id: self.root }.into())\n-            }\n+            PathKind::Crate => PerNs::types(\n+                ModuleId { krate: self.krate, local_id: self.root }.into(),\n+                Visibility::Public,\n+            ),\n             // plain import or absolute path in 2015: crate-relative with\n             // fallback to extern prelude (with the simplification in\n             // rust-lang/rust#57745)\n@@ -126,7 +159,10 @@ impl CrateDefMap {\n                 let m = successors(Some(original_module), |m| self.modules[*m].parent)\n                     .nth(lvl as usize);\n                 if let Some(local_id) = m {\n-                    PerNs::types(ModuleId { krate: self.krate, local_id }.into())\n+                    PerNs::types(\n+                        ModuleId { krate: self.krate, local_id }.into(),\n+                        Visibility::Public,\n+                    )\n                 } else {\n                     log::debug!(\"super path in root module\");\n                     return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n@@ -140,15 +176,15 @@ impl CrateDefMap {\n                 };\n                 if let Some(def) = self.extern_prelude.get(&segment) {\n                     log::debug!(\"absolute path {:?} resolved to crate {:?}\", path, def);\n-                    PerNs::types(*def)\n+                    PerNs::types(*def, Visibility::Public)\n                 } else {\n                     return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n                 }\n             }\n         };\n \n         for (i, segment) in segments {\n-            let curr = match curr_per_ns.take_types() {\n+            let (curr, vis) = match curr_per_ns.take_types_vis() {\n                 Some(r) => r,\n                 None => {\n                     // we still have path segments left, but the path so far\n@@ -189,11 +225,11 @@ impl CrateDefMap {\n                     match enum_data.variant(&segment) {\n                         Some(local_id) => {\n                             let variant = EnumVariantId { parent: e, local_id };\n-                            PerNs::both(variant.into(), variant.into())\n+                            PerNs::both(variant.into(), variant.into(), Visibility::Public)\n                         }\n                         None => {\n                             return ResolvePathResult::with(\n-                                PerNs::types(e.into()),\n+                                PerNs::types(e.into(), vis),\n                                 ReachedFixedPoint::Yes,\n                                 Some(i),\n                                 Some(self.krate),\n@@ -211,7 +247,7 @@ impl CrateDefMap {\n                     );\n \n                     return ResolvePathResult::with(\n-                        PerNs::types(s),\n+                        PerNs::types(s, vis),\n                         ReachedFixedPoint::Yes,\n                         Some(i),\n                         Some(self.krate),\n@@ -235,11 +271,15 @@ impl CrateDefMap {\n         //  - current module / scope\n         //  - extern prelude\n         //  - std prelude\n-        let from_legacy_macro =\n-            self[module].scope.get_legacy_macro(name).map_or_else(PerNs::none, PerNs::macros);\n+        let from_legacy_macro = self[module]\n+            .scope\n+            .get_legacy_macro(name)\n+            .map_or_else(PerNs::none, |m| PerNs::macros(m, Visibility::Public));\n         let from_scope = self[module].scope.get(name, shadow);\n-        let from_extern_prelude =\n-            self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n+        let from_extern_prelude = self\n+            .extern_prelude\n+            .get(name)\n+            .map_or(PerNs::none(), |&it| PerNs::types(it, Visibility::Public));\n         let from_prelude = self.resolve_in_prelude(db, name, shadow);\n \n         from_legacy_macro.or(from_scope).or(from_extern_prelude).or(from_prelude)"}, {"sha": "fac1169efacf24315a99b8795658dfd4740697ff", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -16,12 +16,15 @@ use hir_expand::{\n use ra_arena::{impl_arena_id, Arena, RawId};\n use ra_prof::profile;\n use ra_syntax::{\n-    ast::{self, AttrsOwner, NameOwner},\n+    ast::{self, AttrsOwner, NameOwner, VisibilityOwner},\n     AstNode,\n };\n use test_utils::tested_by;\n \n-use crate::{attr::Attrs, db::DefDatabase, path::ModPath, FileAstId, HirFileId, InFile};\n+use crate::{\n+    attr::Attrs, db::DefDatabase, path::ModPath, visibility::RawVisibility, FileAstId, HirFileId,\n+    InFile,\n+};\n \n /// `RawItems` is a set of top-level items in a file (except for impls).\n ///\n@@ -122,8 +125,17 @@ impl_arena_id!(Module);\n \n #[derive(Debug, PartialEq, Eq)]\n pub(super) enum ModuleData {\n-    Declaration { name: Name, ast_id: FileAstId<ast::Module> },\n-    Definition { name: Name, ast_id: FileAstId<ast::Module>, items: Vec<RawItem> },\n+    Declaration {\n+        name: Name,\n+        visibility: RawVisibility,\n+        ast_id: FileAstId<ast::Module>,\n+    },\n+    Definition {\n+        name: Name,\n+        visibility: RawVisibility,\n+        ast_id: FileAstId<ast::Module>,\n+        items: Vec<RawItem>,\n+    },\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -138,6 +150,7 @@ pub struct ImportData {\n     pub(super) is_prelude: bool,\n     pub(super) is_extern_crate: bool,\n     pub(super) is_macro_use: bool,\n+    pub(super) visibility: RawVisibility,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -148,6 +161,7 @@ impl_arena_id!(Def);\n pub(super) struct DefData {\n     pub(super) name: Name,\n     pub(super) kind: DefKind,\n+    pub(super) visibility: RawVisibility,\n }\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n@@ -218,6 +232,7 @@ impl RawItemsCollector {\n \n     fn add_item(&mut self, current_module: Option<Module>, item: ast::ModuleItem) {\n         let attrs = self.parse_attrs(&item);\n+        let visibility = RawVisibility::from_ast_with_hygiene(item.visibility(), &self.hygiene);\n         let (kind, name) = match item {\n             ast::ModuleItem::Module(module) => {\n                 self.add_module(current_module, module);\n@@ -266,7 +281,7 @@ impl RawItemsCollector {\n         };\n         if let Some(name) = name {\n             let name = name.as_name();\n-            let def = self.raw_items.defs.alloc(DefData { name, kind });\n+            let def = self.raw_items.defs.alloc(DefData { name, kind, visibility });\n             self.push_item(current_module, attrs, RawItemKind::Def(def));\n         }\n     }\n@@ -277,17 +292,20 @@ impl RawItemsCollector {\n             None => return,\n         };\n         let attrs = self.parse_attrs(&module);\n+        let visibility = RawVisibility::from_ast_with_hygiene(module.visibility(), &self.hygiene);\n \n         let ast_id = self.source_ast_id_map.ast_id(&module);\n         if module.has_semi() {\n-            let item = self.raw_items.modules.alloc(ModuleData::Declaration { name, ast_id });\n+            let item =\n+                self.raw_items.modules.alloc(ModuleData::Declaration { name, visibility, ast_id });\n             self.push_item(current_module, attrs, RawItemKind::Module(item));\n             return;\n         }\n \n         if let Some(item_list) = module.item_list() {\n             let item = self.raw_items.modules.alloc(ModuleData::Definition {\n                 name,\n+                visibility,\n                 ast_id,\n                 items: Vec::new(),\n             });\n@@ -302,6 +320,7 @@ impl RawItemsCollector {\n         // FIXME: cfg_attr\n         let is_prelude = use_item.has_atom_attr(\"prelude_import\");\n         let attrs = self.parse_attrs(&use_item);\n+        let visibility = RawVisibility::from_ast_with_hygiene(use_item.visibility(), &self.hygiene);\n \n         let mut buf = Vec::new();\n         ModPath::expand_use_item(\n@@ -315,6 +334,7 @@ impl RawItemsCollector {\n                     is_prelude,\n                     is_extern_crate: false,\n                     is_macro_use: false,\n+                    visibility: visibility.clone(),\n                 };\n                 buf.push(import_data);\n             },\n@@ -331,6 +351,8 @@ impl RawItemsCollector {\n     ) {\n         if let Some(name_ref) = extern_crate.name_ref() {\n             let path = ModPath::from_name_ref(&name_ref);\n+            let visibility =\n+                RawVisibility::from_ast_with_hygiene(extern_crate.visibility(), &self.hygiene);\n             let alias = extern_crate.alias().and_then(|a| a.name()).map(|it| it.as_name());\n             let attrs = self.parse_attrs(&extern_crate);\n             // FIXME: cfg_attr\n@@ -342,6 +364,7 @@ impl RawItemsCollector {\n                 is_prelude: false,\n                 is_extern_crate: true,\n                 is_macro_use,\n+                visibility,\n             };\n             self.push_import(current_module, attrs, import_data);\n         }"}, {"sha": "78bcdc850bf02eb866976e1b5b42f7f98faba24c", "filename": "crates/ra_hir_def/src/nameres/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -12,8 +12,8 @@ use test_utils::covers;\n \n use crate::{db::DefDatabase, nameres::*, test_db::TestDB, LocalModuleId};\n \n-fn def_map(fixtute: &str) -> String {\n-    let dm = compute_crate_def_map(fixtute);\n+fn def_map(fixture: &str) -> String {\n+    let dm = compute_crate_def_map(fixture);\n     render_crate_def_map(&dm)\n }\n \n@@ -32,7 +32,7 @@ fn render_crate_def_map(map: &CrateDefMap) -> String {\n         *buf += path;\n         *buf += \"\\n\";\n \n-        let mut entries = map.modules[module].scope.collect_resolutions();\n+        let mut entries: Vec<_> = map.modules[module].scope.resolutions().collect();\n         entries.sort_by_key(|(name, _)| name.clone());\n \n         for (name, def) in entries {"}, {"sha": "71fa0abe8a3bedb8bf2d8c9b97c5208b8f1aaa7d", "filename": "crates/ra_hir_def/src/nameres/tests/globs.rs", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -73,6 +73,83 @@ fn glob_2() {\n     );\n }\n \n+#[test]\n+fn glob_privacy_1() {\n+    let map = def_map(\n+        \"\n+        //- /lib.rs\n+        mod foo;\n+        use foo::*;\n+\n+        //- /foo/mod.rs\n+        pub mod bar;\n+        pub use self::bar::*;\n+        struct PrivateStructFoo;\n+\n+        //- /foo/bar.rs\n+        pub struct Baz;\n+        struct PrivateStructBar;\n+        pub use super::*;\n+        \",\n+    );\n+    assert_snapshot!(map, @r###\"\n+    crate\n+    Baz: t v\n+    bar: t\n+    foo: t\n+    \n+    crate::foo\n+    Baz: t v\n+    PrivateStructFoo: t v\n+    bar: t\n+    \n+    crate::foo::bar\n+    Baz: t v\n+    PrivateStructBar: t v\n+    PrivateStructFoo: t v\n+    bar: t\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn glob_privacy_2() {\n+    let map = def_map(\n+        \"\n+        //- /lib.rs\n+        mod foo;\n+        use foo::*;\n+        use foo::bar::*;\n+\n+        //- /foo/mod.rs\n+        mod bar;\n+        fn Foo() {};\n+        pub struct Foo {};\n+\n+        //- /foo/bar.rs\n+        pub(super) struct PrivateBaz;\n+        struct PrivateBar;\n+        pub(crate) struct PubCrateStruct;\n+        \",\n+    );\n+    assert_snapshot!(map, @r###\"\n+    crate\n+    Foo: t\n+    PubCrateStruct: t v\n+    foo: t\n+    \n+    crate::foo\n+    Foo: t v\n+    bar: t\n+    \n+    crate::foo::bar\n+    PrivateBar: t v\n+    PrivateBaz: t v\n+    PubCrateStruct: t v\n+    \"###\n+    );\n+}\n+\n #[test]\n fn glob_across_crates() {\n     covers!(glob_across_crates);\n@@ -92,6 +169,26 @@ fn glob_across_crates() {\n     );\n }\n \n+#[test]\n+fn glob_privacy_across_crates() {\n+    covers!(glob_across_crates);\n+    let map = def_map(\n+        \"\n+        //- /main.rs crate:main deps:test_crate\n+        use test_crate::*;\n+\n+        //- /lib.rs crate:test_crate\n+        pub struct Baz;\n+        struct Foo;\n+        \",\n+    );\n+    assert_snapshot!(map, @r###\"\n+   \u22eecrate\n+   \u22eeBaz: t v\n+    \"###\n+    );\n+}\n+\n #[test]\n fn glob_enum() {\n     covers!(glob_enum);"}, {"sha": "faeb7aa4dd811ed55650c30b0b80850b11d42e70", "filename": "crates/ra_hir_def/src/nameres/tests/incremental.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -116,7 +116,7 @@ fn typing_inside_a_macro_should_not_invalidate_def_map() {\n         let events = db.log_executed(|| {\n             let crate_def_map = db.crate_def_map(krate);\n             let (_, module_data) = crate_def_map.modules.iter().last().unwrap();\n-            assert_eq!(module_data.scope.collect_resolutions().len(), 1);\n+            assert_eq!(module_data.scope.resolutions().collect::<Vec<_>>().len(), 1);\n         });\n         assert!(format!(\"{:?}\", events).contains(\"crate_def_map\"), \"{:#?}\", events)\n     }\n@@ -126,7 +126,7 @@ fn typing_inside_a_macro_should_not_invalidate_def_map() {\n         let events = db.log_executed(|| {\n             let crate_def_map = db.crate_def_map(krate);\n             let (_, module_data) = crate_def_map.modules.iter().last().unwrap();\n-            assert_eq!(module_data.scope.collect_resolutions().len(), 1);\n+            assert_eq!(module_data.scope.resolutions().collect::<Vec<_>>().len(), 1);\n         });\n         assert!(!format!(\"{:?}\", events).contains(\"crate_def_map\"), \"{:#?}\", events)\n     }"}, {"sha": "6e435c8c12a7c28e1352389dc8d9c4149c7e3ebc", "filename": "crates/ra_hir_def/src/per_ns.rs", "status": "modified", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -5,13 +5,13 @@\n \n use hir_expand::MacroDefId;\n \n-use crate::ModuleDefId;\n+use crate::{visibility::Visibility, ModuleDefId};\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub struct PerNs {\n-    pub types: Option<ModuleDefId>,\n-    pub values: Option<ModuleDefId>,\n-    pub macros: Option<MacroDefId>,\n+    pub types: Option<(ModuleDefId, Visibility)>,\n+    pub values: Option<(ModuleDefId, Visibility)>,\n+    pub macros: Option<(MacroDefId, Visibility)>,\n }\n \n impl Default for PerNs {\n@@ -25,36 +25,56 @@ impl PerNs {\n         PerNs { types: None, values: None, macros: None }\n     }\n \n-    pub fn values(t: ModuleDefId) -> PerNs {\n-        PerNs { types: None, values: Some(t), macros: None }\n+    pub fn values(t: ModuleDefId, v: Visibility) -> PerNs {\n+        PerNs { types: None, values: Some((t, v)), macros: None }\n     }\n \n-    pub fn types(t: ModuleDefId) -> PerNs {\n-        PerNs { types: Some(t), values: None, macros: None }\n+    pub fn types(t: ModuleDefId, v: Visibility) -> PerNs {\n+        PerNs { types: Some((t, v)), values: None, macros: None }\n     }\n \n-    pub fn both(types: ModuleDefId, values: ModuleDefId) -> PerNs {\n-        PerNs { types: Some(types), values: Some(values), macros: None }\n+    pub fn both(types: ModuleDefId, values: ModuleDefId, v: Visibility) -> PerNs {\n+        PerNs { types: Some((types, v)), values: Some((values, v)), macros: None }\n     }\n \n-    pub fn macros(macro_: MacroDefId) -> PerNs {\n-        PerNs { types: None, values: None, macros: Some(macro_) }\n+    pub fn macros(macro_: MacroDefId, v: Visibility) -> PerNs {\n+        PerNs { types: None, values: None, macros: Some((macro_, v)) }\n     }\n \n     pub fn is_none(&self) -> bool {\n         self.types.is_none() && self.values.is_none() && self.macros.is_none()\n     }\n \n     pub fn take_types(self) -> Option<ModuleDefId> {\n+        self.types.map(|it| it.0)\n+    }\n+\n+    pub fn take_types_vis(self) -> Option<(ModuleDefId, Visibility)> {\n         self.types\n     }\n \n     pub fn take_values(self) -> Option<ModuleDefId> {\n-        self.values\n+        self.values.map(|it| it.0)\n     }\n \n     pub fn take_macros(self) -> Option<MacroDefId> {\n-        self.macros\n+        self.macros.map(|it| it.0)\n+    }\n+\n+    pub fn filter_visibility(self, mut f: impl FnMut(Visibility) -> bool) -> PerNs {\n+        PerNs {\n+            types: self.types.filter(|(_, v)| f(*v)),\n+            values: self.values.filter(|(_, v)| f(*v)),\n+            macros: self.macros.filter(|(_, v)| f(*v)),\n+        }\n+    }\n+\n+    pub fn with_visibility(self, vis: Visibility) -> PerNs {\n+        PerNs {\n+            types: self.types.map(|(it, _)| (it, vis)),\n+            values: self.values.map(|(it, _)| (it, vis)),\n+            macros: self.macros.map(|(it, _)| (it, vis)),\n+        }\n     }\n \n     pub fn or(self, other: PerNs) -> PerNs {"}, {"sha": "43dc751d97d3ca20ee80127310775001be2632e5", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -19,6 +19,7 @@ use crate::{\n     nameres::CrateDefMap,\n     path::{ModPath, PathKind},\n     per_ns::PerNs,\n+    visibility::{RawVisibility, Visibility},\n     AdtId, AssocContainerId, ConstId, ContainerId, DefWithBodyId, EnumId, EnumVariantId,\n     FunctionId, GenericDefId, HasModule, ImplId, LocalModuleId, Lookup, ModuleDefId, ModuleId,\n     StaticId, StructId, TraitId, TypeAliasId, TypeParamId, VariantId,\n@@ -231,6 +232,23 @@ impl Resolver {\n         Some(res)\n     }\n \n+    pub fn resolve_visibility(\n+        &self,\n+        db: &impl DefDatabase,\n+        visibility: &RawVisibility,\n+    ) -> Option<Visibility> {\n+        match visibility {\n+            RawVisibility::Module(_) => {\n+                let (item_map, module) = match self.module() {\n+                    Some(it) => it,\n+                    None => return None,\n+                };\n+                item_map.resolve_visibility(db, module, visibility)\n+            }\n+            RawVisibility::Public => Some(Visibility::Public),\n+        }\n+    }\n+\n     pub fn resolve_path_in_value_ns(\n         &self,\n         db: &impl DefDatabase,\n@@ -448,10 +466,10 @@ impl Scope {\n                     f(name.clone(), ScopeDef::PerNs(def));\n                 });\n                 m.crate_def_map[m.module_id].scope.legacy_macros().for_each(|(name, macro_)| {\n-                    f(name.clone(), ScopeDef::PerNs(PerNs::macros(macro_)));\n+                    f(name.clone(), ScopeDef::PerNs(PerNs::macros(macro_, Visibility::Public)));\n                 });\n                 m.crate_def_map.extern_prelude.iter().for_each(|(name, &def)| {\n-                    f(name.clone(), ScopeDef::PerNs(PerNs::types(def.into())));\n+                    f(name.clone(), ScopeDef::PerNs(PerNs::types(def.into(), Visibility::Public)));\n                 });\n                 if let Some(prelude) = m.crate_def_map.prelude {\n                     let prelude_def_map = db.crate_def_map(prelude.krate);"}, {"sha": "d8296da4b60b2a8a60d742c465ea8a52144764e2", "filename": "crates/ra_hir_def/src/visibility.rs", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -0,0 +1,120 @@\n+//! Defines hir-level representation of visibility (e.g. `pub` and `pub(crate)`).\n+\n+use hir_expand::{hygiene::Hygiene, InFile};\n+use ra_syntax::ast;\n+\n+use crate::{\n+    db::DefDatabase,\n+    path::{ModPath, PathKind},\n+    ModuleId,\n+};\n+\n+/// Visibility of an item, not yet resolved.\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum RawVisibility {\n+    /// `pub(in module)`, `pub(crate)` or `pub(super)`. Also private, which is\n+    /// equivalent to `pub(self)`.\n+    Module(ModPath),\n+    /// `pub`.\n+    Public,\n+}\n+\n+impl RawVisibility {\n+    const fn private() -> RawVisibility {\n+        let path = ModPath { kind: PathKind::Super(0), segments: Vec::new() };\n+        RawVisibility::Module(path)\n+    }\n+\n+    pub(crate) fn from_ast(\n+        db: &impl DefDatabase,\n+        node: InFile<Option<ast::Visibility>>,\n+    ) -> RawVisibility {\n+        Self::from_ast_with_hygiene(node.value, &Hygiene::new(db, node.file_id))\n+    }\n+\n+    pub(crate) fn from_ast_with_hygiene(\n+        node: Option<ast::Visibility>,\n+        hygiene: &Hygiene,\n+    ) -> RawVisibility {\n+        let node = match node {\n+            None => return RawVisibility::private(),\n+            Some(node) => node,\n+        };\n+        match node.kind() {\n+            ast::VisibilityKind::In(path) => {\n+                let path = ModPath::from_src(path, hygiene);\n+                let path = match path {\n+                    None => return RawVisibility::private(),\n+                    Some(path) => path,\n+                };\n+                RawVisibility::Module(path)\n+            }\n+            ast::VisibilityKind::PubCrate => {\n+                let path = ModPath { kind: PathKind::Crate, segments: Vec::new() };\n+                RawVisibility::Module(path)\n+            }\n+            ast::VisibilityKind::PubSuper => {\n+                let path = ModPath { kind: PathKind::Super(1), segments: Vec::new() };\n+                RawVisibility::Module(path)\n+            }\n+            ast::VisibilityKind::Pub => RawVisibility::Public,\n+        }\n+    }\n+\n+    pub fn resolve(\n+        &self,\n+        db: &impl DefDatabase,\n+        resolver: &crate::resolver::Resolver,\n+    ) -> Visibility {\n+        // we fall back to public visibility (i.e. fail open) if the path can't be resolved\n+        resolver.resolve_visibility(db, self).unwrap_or(Visibility::Public)\n+    }\n+}\n+\n+/// Visibility of an item, with the path resolved.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub enum Visibility {\n+    /// Visibility is restricted to a certain module.\n+    Module(ModuleId),\n+    /// Visibility is unrestricted.\n+    Public,\n+}\n+\n+impl Visibility {\n+    pub fn is_visible_from(self, db: &impl DefDatabase, from_module: ModuleId) -> bool {\n+        let to_module = match self {\n+            Visibility::Module(m) => m,\n+            Visibility::Public => return true,\n+        };\n+        // if they're not in the same crate, it can't be visible\n+        if from_module.krate != to_module.krate {\n+            return false;\n+        }\n+        let def_map = db.crate_def_map(from_module.krate);\n+        self.is_visible_from_def_map(&def_map, from_module.local_id)\n+    }\n+\n+    pub(crate) fn is_visible_from_other_crate(self) -> bool {\n+        match self {\n+            Visibility::Module(_) => false,\n+            Visibility::Public => true,\n+        }\n+    }\n+\n+    pub(crate) fn is_visible_from_def_map(\n+        self,\n+        def_map: &crate::nameres::CrateDefMap,\n+        from_module: crate::LocalModuleId,\n+    ) -> bool {\n+        let to_module = match self {\n+            Visibility::Module(m) => m,\n+            Visibility::Public => return true,\n+        };\n+        // from_module needs to be a descendant of to_module\n+        let mut ancestors = std::iter::successors(Some(from_module), |m| {\n+            let parent_id = def_map[*m].parent?;\n+            Some(parent_id)\n+        });\n+        ancestors.any(|m| m == to_module.local_id)\n+    }\n+}"}, {"sha": "210a685e408ff4ceac98e8acf4b6c3d6ee72bbfc", "filename": "crates/ra_ide/src/completion/complete_dot.rs", "status": "modified", "additions": 56, "deletions": 1, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use hir::Type;\n+use hir::{HasVisibility, Type};\n \n use crate::completion::completion_item::CompletionKind;\n use crate::{\n@@ -38,9 +38,15 @@ pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: &Type) {\n     for receiver in receiver.autoderef(ctx.db) {\n         for (field, ty) in receiver.fields(ctx.db) {\n+            if ctx.module.map_or(false, |m| !field.is_visible_from(ctx.db, m)) {\n+                // Skip private field. FIXME: If the definition location of the\n+                // field is editable, we should show the completion\n+                continue;\n+            }\n             acc.add_field(ctx, field, &ty);\n         }\n         for (i, ty) in receiver.tuple_fields(ctx.db).into_iter().enumerate() {\n+            // FIXME: Handle visibility\n             acc.add_tuple_field(ctx, i, &ty);\n         }\n     }\n@@ -186,6 +192,55 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_struct_field_visibility_private() {\n+        assert_debug_snapshot!(\n+            do_ref_completion(\n+                r\"\n+            mod inner {\n+                struct A {\n+                    private_field: u32,\n+                    pub pub_field: u32,\n+                    pub(crate) crate_field: u32,\n+                    pub(super) super_field: u32,\n+                }\n+            }\n+            fn foo(a: inner::A) {\n+               a.<|>\n+            }\n+            \",\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"crate_field\",\n+                source_range: [313; 313),\n+                delete: [313; 313),\n+                insert: \"crate_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+            CompletionItem {\n+                label: \"pub_field\",\n+                source_range: [313; 313),\n+                delete: [313; 313),\n+                insert: \"pub_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+            CompletionItem {\n+                label: \"super_field\",\n+                source_range: [313; 313),\n+                delete: [313; 313),\n+                insert: \"super_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n     #[test]\n     fn test_method_completion() {\n         assert_debug_snapshot!("}, {"sha": "89cb9a9f39433438b835dc98386d833b33819083", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -17,7 +17,9 @@ use crate::{\n \n pub use self::{\n     expr_extensions::{ArrayExprKind, BinOp, ElseBranch, LiteralKind, PrefixOp, RangeOp},\n-    extensions::{FieldKind, PathSegmentKind, SelfParamKind, StructKind, TypeBoundKind},\n+    extensions::{\n+        FieldKind, PathSegmentKind, SelfParamKind, StructKind, TypeBoundKind, VisibilityKind,\n+    },\n     generated::*,\n     tokens::*,\n     traits::*,"}, {"sha": "d9666cdca1dbc9b13a8afd38e341f268cf1737dc", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -413,3 +413,32 @@ impl ast::TraitDef {\n         self.syntax().children_with_tokens().any(|t| t.kind() == T![auto])\n     }\n }\n+\n+pub enum VisibilityKind {\n+    In(ast::Path),\n+    PubCrate,\n+    PubSuper,\n+    Pub,\n+}\n+\n+impl ast::Visibility {\n+    pub fn kind(&self) -> VisibilityKind {\n+        if let Some(path) = children(self).next() {\n+            VisibilityKind::In(path)\n+        } else if self.is_pub_crate() {\n+            VisibilityKind::PubCrate\n+        } else if self.is_pub_super() {\n+            VisibilityKind::PubSuper\n+        } else {\n+            VisibilityKind::Pub\n+        }\n+    }\n+\n+    fn is_pub_crate(&self) -> bool {\n+        self.syntax().children_with_tokens().any(|it| it.kind() == T![crate])\n+    }\n+\n+    fn is_pub_super(&self) -> bool {\n+        self.syntax().children_with_tokens().any(|it| it.kind() == T![super])\n+    }\n+}"}, {"sha": "e64c83d3352b6da513994668a30d1fb49f193b75", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -1064,6 +1064,7 @@ impl AstNode for ExternCrateItem {\n     }\n }\n impl ast::AttrsOwner for ExternCrateItem {}\n+impl ast::VisibilityOwner for ExternCrateItem {}\n impl ExternCrateItem {\n     pub fn name_ref(&self) -> Option<NameRef> {\n         AstChildren::new(&self.syntax).next()\n@@ -2006,6 +2007,7 @@ impl AstNode for ModuleItem {\n     }\n }\n impl ast::AttrsOwner for ModuleItem {}\n+impl ast::VisibilityOwner for ModuleItem {}\n impl ModuleItem {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Name {\n@@ -3893,6 +3895,7 @@ impl AstNode for UseItem {\n     }\n }\n impl ast::AttrsOwner for UseItem {}\n+impl ast::VisibilityOwner for UseItem {}\n impl UseItem {\n     pub fn use_tree(&self) -> Option<UseTree> {\n         AstChildren::new(&self.syntax).next()"}, {"sha": "e43a724f0bc7b4992392074556a2d4d175c2cec8", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -412,7 +412,7 @@ Grammar(\n         \"ModuleItem\": (\n             enum: [\"StructDef\", \"UnionDef\", \"EnumDef\", \"FnDef\", \"TraitDef\", \"TypeAliasDef\", \"ImplBlock\",\n                    \"UseItem\", \"ExternCrateItem\", \"ConstDef\", \"StaticDef\", \"Module\" ],\n-            traits: [\"AttrsOwner\"],\n+            traits: [\"AttrsOwner\", \"VisibilityOwner\"],\n         ),\n         \"ImplItem\": (\n             enum: [\"FnDef\", \"TypeAliasDef\", \"ConstDef\"],\n@@ -683,7 +683,7 @@ Grammar(\n             ]\n         ),\n         \"UseItem\": (\n-            traits: [\"AttrsOwner\"],\n+            traits: [\"AttrsOwner\", \"VisibilityOwner\"],\n             options: [ \"UseTree\" ],\n         ),\n         \"UseTree\": (\n@@ -696,7 +696,7 @@ Grammar(\n             collections: [(\"use_trees\", \"UseTree\")]\n         ),\n         \"ExternCrateItem\": (\n-            traits: [\"AttrsOwner\"],\n+            traits: [\"AttrsOwner\", \"VisibilityOwner\"],\n             options: [\"NameRef\", \"Alias\"],\n         ),\n         \"ArgList\": ("}, {"sha": "f9ca45292db18752a508da18eef87d18ef6f8ccb", "filename": "xtask/tests/tidy-tests/cli.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/xtask%2Ftests%2Ftidy-tests%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea/xtask%2Ftests%2Ftidy-tests%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy-tests%2Fcli.rs?ref=cdcb3d3833d3d5b37b2cd4dac91a6e9366f20aea", "patch": "@@ -43,7 +43,7 @@ fn no_todo() {\n             return;\n         }\n         let text = std::fs::read_to_string(e.path()).unwrap();\n-        if text.contains(\"TODO\") || text.contains(\"TOOD\") {\n+        if text.contains(\"TODO\") || text.contains(\"TOOD\") || text.contains(\"todo!\") {\n             panic!(\n                 \"\\nTODO markers should not be committed to the master branch,\\n\\\n                  use FIXME instead\\n\\"}]}