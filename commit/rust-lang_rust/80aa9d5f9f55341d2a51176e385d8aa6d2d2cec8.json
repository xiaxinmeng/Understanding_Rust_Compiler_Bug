{"sha": "80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwYWE5ZDVmOWY1NTM0MWQyYTUxMTc2ZTM4NWQ4YWE2ZDJkMmNlYzg=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-06-11T15:29:42Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-06-11T15:29:42Z"}, "message": "Merge #1395\n\n1395: move docs under code model r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "b6fee9faf5f82ba6ee063667605e39ac3bcbe37c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6fee9faf5f82ba6ee063667605e39ac3bcbe37c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "html_url": "https://github.com/rust-lang/rust/commit/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "e505fe9d7b96f3454711e923c70d763c5cee5f47", "url": "https://api.github.com/repos/rust-lang/rust/commits/e505fe9d7b96f3454711e923c70d763c5cee5f47", "html_url": "https://github.com/rust-lang/rust/commit/e505fe9d7b96f3454711e923c70d763c5cee5f47"}, {"sha": "ff6f6b3a5223ddab81c7357a3c59bdb09936a552", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff6f6b3a5223ddab81c7357a3c59bdb09936a552", "html_url": "https://github.com/rust-lang/rust/commit/ff6f6b3a5223ddab81c7357a3c59bdb09936a552"}], "stats": {"total": 773, "additions": 324, "deletions": 449}, "files": [{"sha": "0e49b040144f575a24720906cdf91c4afeb52b8b", "filename": "crates/ra_assists/src/add_missing_impl_members.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs?ref=80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "patch": "@@ -1,6 +1,6 @@\n use crate::{Assist, AssistId, AssistCtx, ast_editor::{AstEditor, AstBuilder}};\n \n-use hir::db::HirDatabase;\n+use hir::{HasSource, db::HirDatabase};\n use ra_syntax::{SmolStr, TreeArc};\n use ra_syntax::ast::{self, AstNode, FnDef, ImplItem, ImplItemKind, NameOwner};\n use ra_db::FilePosition;\n@@ -110,7 +110,7 @@ fn resolve_target_trait_def(\n         impl_block.target_trait().map(AstNode::syntax).and_then(ast::PathType::cast)?.path()?;\n \n     match analyzer.resolve_path(db, &ast_path) {\n-        Some(hir::PathResolution::Def(hir::ModuleDef::Trait(def))) => Some(def.source(db).1),\n+        Some(hir::PathResolution::Def(hir::ModuleDef::Trait(def))) => Some(def.source(db).ast),\n         _ => None,\n     }\n }"}, {"sha": "a7de6ae9f5dbbc5d38ac6d2d4c4129ca0b3a862e", "filename": "crates/ra_assists/src/fill_match_arms.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs?ref=80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "patch": "@@ -1,7 +1,7 @@\n use std::fmt::Write;\n \n use hir::{\n-    AdtDef, FieldSource,\n+    AdtDef, FieldSource, HasSource,\n     db::HirDatabase,\n };\n use ra_syntax::ast::{self, AstNode};\n@@ -44,8 +44,8 @@ pub(crate) fn fill_match_arms(mut ctx: AssistCtx<impl HirDatabase>) -> Option<As\n                 .into_iter()\n                 .map(|field| {\n                     let name = field.name(db).to_string();\n-                    let (_, source) = field.source(db);\n-                    match source {\n+                    let src = field.source(db);\n+                    match src.ast {\n                         FieldSource::Named(_) => name,\n                         FieldSource::Pos(_) => \"_\".to_string(),\n                     }"}, {"sha": "c19976bd266e71f50e95db52dfa06731e51cc9c6", "filename": "crates/ra_cli/src/analysis_stats.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs?ref=80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "patch": "@@ -2,7 +2,7 @@ use std::{collections::HashSet, time::Instant, fmt::Write};\n \n use ra_db::SourceDatabase;\n use ra_batch::BatchDatabase;\n-use ra_hir::{Crate, ModuleDef, Ty, ImplItem};\n+use ra_hir::{Crate, ModuleDef, Ty, ImplItem, HasSource};\n use ra_syntax::AstNode;\n \n use crate::Result;\n@@ -64,10 +64,10 @@ pub fn run(verbose: bool, path: &str, only: Option<&str>) -> Result<()> {\n         let name = f.name(&db);\n         let mut msg = format!(\"processing: {}\", name);\n         if verbose {\n-            let (file_id, source) = f.source(&db);\n-            let original_file = file_id.original_file(&db);\n+            let src = f.source(&db);\n+            let original_file = src.file_id.original_file(&db);\n             let path = db.file_relative_path(original_file);\n-            let syntax_range = source.syntax().range();\n+            let syntax_range = src.ast.syntax().range();\n             write!(msg, \" ({:?} {})\", path, syntax_range).unwrap();\n         }\n         bar.set_message(&msg);"}, {"sha": "b3843b35c2a9dd5187afd45e6f035cb1f5959cb4", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "patch": "@@ -11,7 +11,7 @@ use ra_syntax::{\n \n use crate::{\n     Name, AsName, Struct, Union, Enum, EnumVariant, Crate, AstDatabase,\n-    HirDatabase, HirFileId, StructField, FieldSource,\n+    HirDatabase, StructField, FieldSource, Source, HasSource,\n     type_ref::TypeRef, DefDatabase,\n };\n \n@@ -59,8 +59,8 @@ impl StructData {\n         db: &(impl DefDatabase + AstDatabase),\n         struct_: Struct,\n     ) -> Arc<StructData> {\n-        let (_, struct_def) = struct_.source(db);\n-        Arc::new(StructData::new(&*struct_def))\n+        let src = struct_.source(db);\n+        Arc::new(StructData::new(&*src.ast))\n     }\n }\n \n@@ -72,15 +72,15 @@ impl EnumVariant {\n     pub(crate) fn source_impl(\n         &self,\n         db: &(impl DefDatabase + AstDatabase),\n-    ) -> (HirFileId, TreeArc<ast::EnumVariant>) {\n-        let (file_id, enum_def) = self.parent.source(db);\n-        let var = variants(&*enum_def)\n+    ) -> Source<TreeArc<ast::EnumVariant>> {\n+        let src = self.parent.source(db);\n+        let ast = variants(&*src.ast)\n             .zip(db.enum_data(self.parent).variants.iter())\n             .find(|(_syntax, (id, _))| *id == self.id)\n             .unwrap()\n             .0\n             .to_owned();\n-        (file_id, var)\n+        Source { file_id: src.file_id, ast }\n     }\n     pub(crate) fn variant_data(&self, db: &impl DefDatabase) -> Arc<VariantData> {\n         db.enum_data(self.parent).variants[self.id].variant_data.clone()\n@@ -95,9 +95,9 @@ pub struct EnumData {\n \n impl EnumData {\n     pub(crate) fn enum_data_query(db: &(impl DefDatabase + AstDatabase), e: Enum) -> Arc<EnumData> {\n-        let (_file_id, enum_def) = e.source(db);\n-        let name = enum_def.name().map(|n| n.as_name());\n-        let variants = variants(&*enum_def)\n+        let src = e.source(db);\n+        let name = src.ast.name().map(|n| n.as_name());\n+        let variants = variants(&*src.ast)\n             .map(|var| EnumVariantData {\n                 name: var.name().map(|it| it.as_name()),\n                 variant_data: Arc::new(VariantData::new(var.kind())),\n@@ -201,24 +201,19 @@ impl VariantDef {\n }\n \n impl StructField {\n-    pub(crate) fn source_impl(\n-        &self,\n-        db: &(impl DefDatabase + AstDatabase),\n-    ) -> (HirFileId, FieldSource) {\n+    pub(crate) fn source_impl(&self, db: &(impl DefDatabase + AstDatabase)) -> Source<FieldSource> {\n         let var_data = self.parent.variant_data(db);\n         let fields = var_data.fields().unwrap();\n         let ss;\n         let es;\n         let (file_id, struct_kind) = match self.parent {\n             VariantDef::Struct(s) => {\n-                let (file_id, source) = s.source(db);\n-                ss = source;\n-                (file_id, ss.kind())\n+                ss = s.source(db);\n+                (ss.file_id, ss.ast.kind())\n             }\n             VariantDef::EnumVariant(e) => {\n-                let (file_id, source) = e.source(db);\n-                es = source;\n-                (file_id, es.kind())\n+                es = e.source(db);\n+                (es.file_id, es.ast.kind())\n             }\n         };\n \n@@ -231,12 +226,12 @@ impl StructField {\n             }\n             ast::StructKind::Unit => Vec::new(),\n         };\n-        let field = field_sources\n+        let ast = field_sources\n             .into_iter()\n             .zip(fields.iter())\n             .find(|(_syntax, (id, _))| *id == self.id)\n             .unwrap()\n             .0;\n-        (file_id, field)\n+        Source { file_id, ast }\n     }\n }"}, {"sha": "830aea1f3375a4b014baf5d5dd1c24f4f1f78447", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 14, "deletions": 106, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "patch": "@@ -1,10 +1,13 @@\n+pub(crate) mod src;\n+pub(crate) mod docs;\n+\n use std::sync::Arc;\n \n use ra_db::{CrateId, SourceRootId, Edition, FileId};\n use ra_syntax::{ast::{self, NameOwner, TypeAscriptionOwner}, TreeArc};\n \n use crate::{\n-    Name, AsName, AstId, Ty, HirFileId, Either, KnownName,\n+    Name, AsName, AstId, Ty, Either, KnownName, HasSource,\n     HirDatabase, DefDatabase, AstDatabase,\n     type_ref::TypeRef,\n     nameres::{ModuleScope, Namespace, ImportId, CrateModuleId},\n@@ -179,40 +182,15 @@ impl Module {\n         })\n     }\n \n-    /// Returns a node which defines this module. That is, a file or a `mod foo {}` with items.\n-    pub fn definition_source(\n-        self,\n-        db: &(impl DefDatabase + AstDatabase),\n-    ) -> (HirFileId, ModuleSource) {\n-        let def_map = db.crate_def_map(self.krate);\n-        let decl_id = def_map[self.module_id].declaration;\n-        let file_id = def_map[self.module_id].definition;\n-        let module_source = ModuleSource::new(db, file_id, decl_id);\n-        let file_id = file_id.map(HirFileId::from).unwrap_or_else(|| decl_id.unwrap().file_id());\n-        (file_id, module_source)\n-    }\n-\n-    /// Returns a node which declares this module, either a `mod foo;` or a `mod foo {}`.\n-    /// `None` for the crate root.\n-    pub fn declaration_source(\n-        self,\n-        db: &(impl DefDatabase + AstDatabase),\n-    ) -> Option<(HirFileId, TreeArc<ast::Module>)> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let decl = def_map[self.module_id].declaration?;\n-        let ast = decl.to_node(db);\n-        Some((decl.file_id(), ast))\n-    }\n-\n     /// Returns the syntax of the last path segment corresponding to this import\n     pub fn import_source(\n         self,\n         db: &impl HirDatabase,\n         import: ImportId,\n     ) -> Either<TreeArc<ast::UseTree>, TreeArc<ast::ExternCrateItem>> {\n-        let (file_id, source) = self.definition_source(db);\n-        let (_, source_map) = db.raw_items_with_source_map(file_id);\n-        source_map.get(&source, import)\n+        let src = self.definition_source(db);\n+        let (_, source_map) = db.raw_items_with_source_map(src.file_id);\n+        source_map.get(&src.ast, import)\n     }\n \n     /// Returns the crate this module is part of.\n@@ -335,10 +313,6 @@ impl StructField {\n         self.parent.variant_data(db).fields().unwrap()[self.id].name.clone()\n     }\n \n-    pub fn source(&self, db: &(impl DefDatabase + AstDatabase)) -> (HirFileId, FieldSource) {\n-        self.source_impl(db)\n-    }\n-\n     pub fn ty(&self, db: &impl HirDatabase) -> Ty {\n         db.type_for_field(*self)\n     }\n@@ -354,13 +328,6 @@ pub struct Struct {\n }\n \n impl Struct {\n-    pub fn source(\n-        self,\n-        db: &(impl DefDatabase + AstDatabase),\n-    ) -> (HirFileId, TreeArc<ast::StructDef>) {\n-        self.id.source(db)\n-    }\n-\n     pub fn module(self, db: &impl HirDatabase) -> Module {\n         self.id.module(db)\n     }\n@@ -415,13 +382,6 @@ pub struct Union {\n }\n \n impl Union {\n-    pub fn source(\n-        self,\n-        db: &(impl DefDatabase + AstDatabase),\n-    ) -> (HirFileId, TreeArc<ast::StructDef>) {\n-        self.id.source(db)\n-    }\n-\n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n         db.struct_data(Struct { id: self.id }).name.clone()\n     }\n@@ -448,13 +408,6 @@ pub struct Enum {\n }\n \n impl Enum {\n-    pub fn source(\n-        self,\n-        db: &(impl DefDatabase + AstDatabase),\n-    ) -> (HirFileId, TreeArc<ast::EnumDef>) {\n-        self.id.source(db)\n-    }\n-\n     pub fn module(self, db: &impl HirDatabase) -> Module {\n         self.id.module(db)\n     }\n@@ -498,12 +451,6 @@ pub struct EnumVariant {\n }\n \n impl EnumVariant {\n-    pub fn source(\n-        &self,\n-        db: &(impl DefDatabase + AstDatabase),\n-    ) -> (HirFileId, TreeArc<ast::EnumVariant>) {\n-        self.source_impl(db)\n-    }\n     pub fn module(&self, db: &impl HirDatabase) -> Module {\n         self.parent.module(db)\n     }\n@@ -588,11 +535,11 @@ impl FnSignature {\n         db: &(impl DefDatabase + AstDatabase),\n         func: Function,\n     ) -> Arc<FnSignature> {\n-        let (_, node) = func.source(db);\n-        let name = node.name().map(|n| n.as_name()).unwrap_or_else(Name::missing);\n+        let src = func.source(db);\n+        let name = src.ast.name().map(|n| n.as_name()).unwrap_or_else(Name::missing);\n         let mut params = Vec::new();\n         let mut has_self_param = false;\n-        if let Some(param_list) = node.param_list() {\n+        if let Some(param_list) = src.ast.param_list() {\n             if let Some(self_param) = param_list.self_param() {\n                 let self_type = if let Some(type_ref) = self_param.ascribed_type() {\n                     TypeRef::from_ast(type_ref)\n@@ -616,7 +563,7 @@ impl FnSignature {\n                 params.push(type_ref);\n             }\n         }\n-        let ret_type = if let Some(type_ref) = node.ret_type().and_then(|rt| rt.type_ref()) {\n+        let ret_type = if let Some(type_ref) = src.ast.ret_type().and_then(|rt| rt.type_ref()) {\n             TypeRef::from_ast(type_ref)\n         } else {\n             TypeRef::unit()\n@@ -645,10 +592,6 @@ impl FnSignature {\n }\n \n impl Function {\n-    pub fn source(self, db: &(impl DefDatabase + AstDatabase)) -> (HirFileId, TreeArc<ast::FnDef>) {\n-        self.id.source(db)\n-    }\n-\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n         self.id.module(db)\n     }\n@@ -723,13 +666,6 @@ pub struct Const {\n }\n \n impl Const {\n-    pub fn source(\n-        self,\n-        db: &(impl DefDatabase + AstDatabase),\n-    ) -> (HirFileId, TreeArc<ast::ConstDef>) {\n-        self.id.source(db)\n-    }\n-\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n         self.id.module(db)\n     }\n@@ -780,15 +716,15 @@ impl ConstSignature {\n         db: &(impl DefDatabase + AstDatabase),\n         konst: Const,\n     ) -> Arc<ConstSignature> {\n-        let (_, node) = konst.source(db);\n+        let node = konst.source(db).ast;\n         const_signature_for(&*node)\n     }\n \n     pub(crate) fn static_signature_query(\n         db: &(impl DefDatabase + AstDatabase),\n         konst: Static,\n     ) -> Arc<ConstSignature> {\n-        let (_, node) = konst.source(db);\n+        let node = konst.source(db).ast;\n         const_signature_for(&*node)\n     }\n }\n@@ -806,13 +742,6 @@ pub struct Static {\n }\n \n impl Static {\n-    pub fn source(\n-        self,\n-        db: &(impl DefDatabase + AstDatabase),\n-    ) -> (HirFileId, TreeArc<ast::StaticDef>) {\n-        self.id.source(db)\n-    }\n-\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n         self.id.module(db)\n     }\n@@ -838,13 +767,6 @@ pub struct Trait {\n }\n \n impl Trait {\n-    pub fn source(\n-        self,\n-        db: &(impl DefDatabase + AstDatabase),\n-    ) -> (HirFileId, TreeArc<ast::TraitDef>) {\n-        self.id.source(db)\n-    }\n-\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n         self.id.module(db)\n     }\n@@ -884,13 +806,6 @@ pub struct TypeAlias {\n }\n \n impl TypeAlias {\n-    pub fn source(\n-        self,\n-        db: &(impl DefDatabase + AstDatabase),\n-    ) -> (HirFileId, TreeArc<ast::TypeAliasDef>) {\n-        self.id.source(db)\n-    }\n-\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n         self.id.module(db)\n     }\n@@ -939,14 +854,7 @@ pub struct MacroDef {\n     pub(crate) id: MacroDefId,\n }\n \n-impl MacroDef {\n-    pub fn source(\n-        &self,\n-        db: &(impl DefDatabase + AstDatabase),\n-    ) -> (HirFileId, TreeArc<ast::MacroCall>) {\n-        (self.id.0.file_id(), self.id.0.to_node(db))\n-    }\n-}\n+impl MacroDef {}\n \n pub enum Container {\n     Trait(Trait),"}, {"sha": "da2b9b85479ebb4bd3c5141ac72424e0685b5467", "filename": "crates/ra_hir/src/code_model/docs.rs", "status": "renamed", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fdocs.rs?ref=80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "patch": "@@ -3,7 +3,7 @@ use std::sync::Arc;\n use ra_syntax::ast;\n \n use crate::{\n-    HirDatabase, DefDatabase, AstDatabase,\n+    HirDatabase, DefDatabase, AstDatabase, HasSource,\n     Module, StructField, Struct, Enum, EnumVariant, Static, Const, Function, Union, Trait, TypeAlias, FieldSource, MacroDef,\n };\n \n@@ -71,21 +71,21 @@ pub(crate) fn documentation_query(\n     def: DocDef,\n ) -> Option<Documentation> {\n     match def {\n-        DocDef::Module(it) => docs_from_ast(&*it.declaration_source(db)?.1),\n-        DocDef::StructField(it) => match it.source(db).1 {\n+        DocDef::Module(it) => docs_from_ast(&*it.declaration_source(db)?.ast),\n+        DocDef::StructField(it) => match it.source(db).ast {\n             FieldSource::Named(named) => docs_from_ast(&*named),\n             FieldSource::Pos(..) => return None,\n         },\n-        DocDef::Struct(it) => docs_from_ast(&*it.source(db).1),\n-        DocDef::Enum(it) => docs_from_ast(&*it.source(db).1),\n-        DocDef::EnumVariant(it) => docs_from_ast(&*it.source(db).1),\n-        DocDef::Static(it) => docs_from_ast(&*it.source(db).1),\n-        DocDef::Const(it) => docs_from_ast(&*it.source(db).1),\n-        DocDef::Function(it) => docs_from_ast(&*it.source(db).1),\n-        DocDef::Union(it) => docs_from_ast(&*it.source(db).1),\n-        DocDef::Trait(it) => docs_from_ast(&*it.source(db).1),\n-        DocDef::TypeAlias(it) => docs_from_ast(&*it.source(db).1),\n-        DocDef::MacroDef(it) => docs_from_ast(&*it.source(db).1),\n+        DocDef::Struct(it) => docs_from_ast(&*it.source(db).ast),\n+        DocDef::Enum(it) => docs_from_ast(&*it.source(db).ast),\n+        DocDef::EnumVariant(it) => docs_from_ast(&*it.source(db).ast),\n+        DocDef::Static(it) => docs_from_ast(&*it.source(db).ast),\n+        DocDef::Const(it) => docs_from_ast(&*it.source(db).ast),\n+        DocDef::Function(it) => docs_from_ast(&*it.source(db).ast),\n+        DocDef::Union(it) => docs_from_ast(&*it.source(db).ast),\n+        DocDef::Trait(it) => docs_from_ast(&*it.source(db).ast),\n+        DocDef::TypeAlias(it) => docs_from_ast(&*it.source(db).ast),\n+        DocDef::MacroDef(it) => docs_from_ast(&*it.source(db).ast),\n     }\n }\n ", "previous_filename": "crates/ra_hir/src/docs.rs"}, {"sha": "5785d3b266f5c20d86e30ca5737a63b23d783fa7", "filename": "crates/ra_hir/src/code_model/src.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs?ref=80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "patch": "@@ -0,0 +1,110 @@\n+use ra_syntax::{TreeArc, ast};\n+\n+use crate::{\n+    HirFileId, DefDatabase, AstDatabase, Module, ModuleSource,\n+    StructField, Struct, Enum, Union, EnumVariant, Function, Static, Trait, Const, TypeAlias,\n+    FieldSource, MacroDef, ids::AstItemDef,\n+};\n+\n+pub struct Source<T> {\n+    pub file_id: HirFileId,\n+    pub ast: T,\n+}\n+\n+pub trait HasSource {\n+    type Ast;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<Self::Ast>;\n+}\n+\n+/// NB: Module is !HasSource, because it has two source nodes at the same time:\n+/// definition and declaration.\n+impl Module {\n+    /// Returns a node which defines this module. That is, a file or a `mod foo {}` with items.\n+    pub fn definition_source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ModuleSource> {\n+        let def_map = db.crate_def_map(self.krate);\n+        let decl_id = def_map[self.module_id].declaration;\n+        let file_id = def_map[self.module_id].definition;\n+        let ast = ModuleSource::new(db, file_id, decl_id);\n+        let file_id = file_id.map(HirFileId::from).unwrap_or_else(|| decl_id.unwrap().file_id());\n+        Source { file_id, ast }\n+    }\n+\n+    /// Returns a node which declares this module, either a `mod foo;` or a `mod foo {}`.\n+    /// `None` for the crate root.\n+    pub fn declaration_source(\n+        self,\n+        db: &(impl DefDatabase + AstDatabase),\n+    ) -> Option<Source<TreeArc<ast::Module>>> {\n+        let def_map = db.crate_def_map(self.krate);\n+        let decl = def_map[self.module_id].declaration?;\n+        let ast = decl.to_node(db);\n+        Some(Source { file_id: decl.file_id(), ast })\n+    }\n+}\n+\n+impl HasSource for StructField {\n+    type Ast = FieldSource;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<FieldSource> {\n+        self.source_impl(db)\n+    }\n+}\n+impl HasSource for Struct {\n+    type Ast = TreeArc<ast::StructDef>;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::StructDef>> {\n+        self.id.source(db)\n+    }\n+}\n+impl HasSource for Union {\n+    type Ast = TreeArc<ast::StructDef>;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::StructDef>> {\n+        self.id.source(db)\n+    }\n+}\n+impl HasSource for Enum {\n+    type Ast = TreeArc<ast::EnumDef>;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::EnumDef>> {\n+        self.id.source(db)\n+    }\n+}\n+impl HasSource for EnumVariant {\n+    type Ast = TreeArc<ast::EnumVariant>;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::EnumVariant>> {\n+        self.source_impl(db)\n+    }\n+}\n+impl HasSource for Function {\n+    type Ast = TreeArc<ast::FnDef>;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::FnDef>> {\n+        self.id.source(db)\n+    }\n+}\n+impl HasSource for Const {\n+    type Ast = TreeArc<ast::ConstDef>;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::ConstDef>> {\n+        self.id.source(db)\n+    }\n+}\n+impl HasSource for Static {\n+    type Ast = TreeArc<ast::StaticDef>;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::StaticDef>> {\n+        self.id.source(db)\n+    }\n+}\n+impl HasSource for Trait {\n+    type Ast = TreeArc<ast::TraitDef>;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::TraitDef>> {\n+        self.id.source(db)\n+    }\n+}\n+impl HasSource for TypeAlias {\n+    type Ast = TreeArc<ast::TypeAliasDef>;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::TypeAliasDef>> {\n+        self.id.source(db)\n+    }\n+}\n+impl HasSource for MacroDef {\n+    type Ast = TreeArc<ast::MacroCall>;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::MacroCall>> {\n+        Source { file_id: self.id.0.file_id(), ast: self.id.0.to_node(db) }\n+    }\n+}"}, {"sha": "d2d6f95b73fd8d7061c42224628fd31c9a5c0631", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "patch": "@@ -128,8 +128,8 @@ pub trait DefDatabase: SourceDatabase {\n     #[salsa::invoke(crate::lang_item::LangItems::lang_item_query)]\n     fn lang_item(&self, start_crate: Crate, item: SmolStr) -> Option<LangItemTarget>;\n \n-    #[salsa::invoke(crate::docs::documentation_query)]\n-    fn documentation(&self, def: crate::docs::DocDef) -> Option<crate::docs::Documentation>;\n+    #[salsa::invoke(crate::code_model::docs::documentation_query)]\n+    fn documentation(&self, def: crate::DocDef) -> Option<crate::Documentation>;\n }\n \n #[salsa::query_group(HirDatabaseStorage)]"}, {"sha": "b1973d19d4d96f8f3d53523274122bf19d0c1408", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "patch": "@@ -11,6 +11,7 @@ use ra_syntax::{\n \n use crate::{\n     Path, Name, HirDatabase, Resolver,DefWithBody, Either, HirFileId, MacroCallLoc, MacroFileKind,\n+    HasSource,\n     name::AsName,\n     type_ref::{Mutability, TypeRef},\n };\n@@ -1018,19 +1019,19 @@ pub(crate) fn body_with_source_map_query(\n \n     match def {\n         DefWithBody::Const(ref c) => {\n-            let (file_id, src) = c.source(db);\n-            collector = ExprCollector::new(def, file_id, def.resolver(db), db);\n-            collector.collect_const_body(&src)\n+            let src = c.source(db);\n+            collector = ExprCollector::new(def, src.file_id, def.resolver(db), db);\n+            collector.collect_const_body(&src.ast)\n         }\n         DefWithBody::Function(ref f) => {\n-            let (file_id, src) = f.source(db);\n-            collector = ExprCollector::new(def, file_id, def.resolver(db), db);\n-            collector.collect_fn_body(&src)\n+            let src = f.source(db);\n+            collector = ExprCollector::new(def, src.file_id, def.resolver(db), db);\n+            collector.collect_fn_body(&src.ast)\n         }\n         DefWithBody::Static(ref s) => {\n-            let (file_id, src) = s.source(db);\n-            collector = ExprCollector::new(def, file_id, def.resolver(db), db);\n-            collector.collect_static_body(&src)\n+            let src = s.source(db);\n+            collector = ExprCollector::new(def, src.file_id, def.resolver(db), db);\n+            collector.collect_static_body(&src.ast)\n         }\n     }\n "}, {"sha": "534fd482b4be29e4bbd6b8f9577ba0d97bc31096", "filename": "crates/ra_hir/src/expr/validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs?ref=80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::ast::{AstNode, StructLit};\n \n use crate::{\n     expr::AstPtr,\n-    HirDatabase, Function, Name,\n+    HirDatabase, Function, Name, HasSource,\n     diagnostics::{DiagnosticSink, MissingFields},\n     adt::AdtDef,\n     Path,\n@@ -71,7 +71,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             return;\n         }\n         let source_map = self.func.body_source_map(db);\n-        let file_id = self.func.source(db).0;\n+        let file_id = self.func.source(db).file_id;\n         let source_file = db.parse(file_id.original_file(db)).tree;\n         if let Some(field_list_node) = source_map\n             .expr_syntax(id)"}, {"sha": "462b136b7fe3d3c14ccb3a9e482745aa735da3aa", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "patch": "@@ -8,8 +8,10 @@ use std::sync::Arc;\n use ra_syntax::ast::{self, NameOwner, TypeParamsOwner, TypeBoundsOwner, DefaultTypeParamOwner};\n \n use crate::{\n+    HasSource,\n+    Name, AsName, Function, Struct, Union, Enum, Trait, TypeAlias, ImplBlock, Container, AdtDef,\n     db::{HirDatabase, DefDatabase, AstDatabase},\n-    Name, AsName, Function, Struct, Union, Enum, Trait, TypeAlias, ImplBlock, Container, path::Path, type_ref::TypeRef, AdtDef\n+    path::Path, type_ref::TypeRef,\n };\n \n /// Data about a generic parameter (to a function, struct, impl, ...).\n@@ -68,21 +70,21 @@ impl GenericParams {\n         generics.parent_params = parent.map(|p| db.generic_params(p));\n         let start = generics.parent_params.as_ref().map(|p| p.params.len()).unwrap_or(0) as u32;\n         match def {\n-            GenericDef::Function(it) => generics.fill(&*it.source(db).1, start),\n-            GenericDef::Struct(it) => generics.fill(&*it.source(db).1, start),\n-            GenericDef::Union(it) => generics.fill(&*it.source(db).1, start),\n-            GenericDef::Enum(it) => generics.fill(&*it.source(db).1, start),\n+            GenericDef::Function(it) => generics.fill(&*it.source(db).ast, start),\n+            GenericDef::Struct(it) => generics.fill(&*it.source(db).ast, start),\n+            GenericDef::Union(it) => generics.fill(&*it.source(db).ast, start),\n+            GenericDef::Enum(it) => generics.fill(&*it.source(db).ast, start),\n             GenericDef::Trait(it) => {\n                 // traits get the Self type as an implicit first type parameter\n                 generics.params.push(GenericParam {\n                     idx: start,\n                     name: Name::self_type(),\n                     default: None,\n                 });\n-                generics.fill(&*it.source(db).1, start + 1);\n+                generics.fill(&*it.source(db).ast, start + 1);\n             }\n-            GenericDef::TypeAlias(it) => generics.fill(&*it.source(db).1, start),\n-            GenericDef::ImplBlock(it) => generics.fill(&*it.source(db).1, start),\n+            GenericDef::TypeAlias(it) => generics.fill(&*it.source(db).ast, start),\n+            GenericDef::ImplBlock(it) => generics.fill(&*it.source(db).ast, start),\n         }\n \n         Arc::new(generics)"}, {"sha": "352f9ffd93ccac4840a8bffddc20a4c8cf09b007", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "patch": "@@ -9,7 +9,7 @@ use ra_prof::profile;\n use mbe::MacroRules;\n \n use crate::{\n-    Module, DefDatabase, AstId, FileAstId, AstDatabase,\n+    Module, DefDatabase, AstId, FileAstId, AstDatabase, Source,\n };\n \n /// hir makes heavy use of ids: integer (u32) handlers to various things. You\n@@ -265,10 +265,10 @@ pub(crate) trait AstItemDef<N: AstNode>: salsa::InternKey + Clone {\n         let loc = ItemLoc { module: ctx.module, ast_id: ast_id.with_file_id(ctx.file_id) };\n         Self::intern(ctx.db, loc)\n     }\n-    fn source(self, db: &(impl AstDatabase + DefDatabase)) -> (HirFileId, TreeArc<N>) {\n+    fn source(self, db: &(impl AstDatabase + DefDatabase)) -> Source<TreeArc<N>> {\n         let loc = self.lookup_intern(db);\n         let ast = loc.ast_id.to_node(db);\n-        (loc.ast_id.file_id(), ast)\n+        Source { file_id: loc.ast_id.file_id(), ast }\n     }\n     fn module(self, db: &impl DefDatabase) -> Module {\n         let loc = self.lookup_intern(db);"}, {"sha": "fb9daf1bf97faee3f43b0c6f401a891b8969d9ac", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "patch": "@@ -8,7 +8,7 @@ use ra_syntax::{\n };\n \n use crate::{\n-    Const, TypeAlias, Function, HirFileId, AstDatabase,\n+    Const, TypeAlias, Function, HirFileId, AstDatabase, HasSource, Source,\n     HirDatabase, DefDatabase, TraitRef,\n     type_ref::TypeRef,\n     ids::LocationCtx,\n@@ -44,6 +44,15 @@ pub struct ImplBlock {\n     impl_id: ImplId,\n }\n \n+impl HasSource for ImplBlock {\n+    type Ast = TreeArc<ast::ImplBlock>;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::ImplBlock>> {\n+        let source_map = db.impls_in_module_with_source_map(self.module).1;\n+        let src = self.module.definition_source(db);\n+        Source { file_id: src.file_id, ast: source_map.get(&src.ast, self.impl_id) }\n+    }\n+}\n+\n impl ImplBlock {\n     pub(crate) fn containing(\n         module_impl_blocks: Arc<ModuleImplBlocks>,\n@@ -57,16 +66,6 @@ impl ImplBlock {\n         ImplBlock { module, impl_id }\n     }\n \n-    /// Returns the syntax of the impl block\n-    pub fn source(\n-        &self,\n-        db: &(impl DefDatabase + AstDatabase),\n-    ) -> (HirFileId, TreeArc<ast::ImplBlock>) {\n-        let source_map = db.impls_in_module_with_source_map(self.module).1;\n-        let (file_id, source) = self.module.definition_source(db);\n-        (file_id, source_map.get(&source, self.impl_id))\n-    }\n-\n     pub fn id(&self) -> ImplId {\n         self.impl_id\n     }\n@@ -201,16 +200,16 @@ impl ModuleImplBlocks {\n             impls_by_def: FxHashMap::default(),\n         };\n \n-        let (file_id, module_source) = m.module.definition_source(db);\n-        let node = match &module_source {\n+        let src = m.module.definition_source(db);\n+        let node = match &src.ast {\n             ModuleSource::SourceFile(node) => node.syntax(),\n             ModuleSource::Module(node) => {\n                 node.item_list().expect(\"inline module should have item list\").syntax()\n             }\n         };\n \n         for impl_block_ast in node.children().filter_map(ast::ImplBlock::cast) {\n-            let impl_block = ImplData::from_ast(db, file_id, m.module, impl_block_ast);\n+            let impl_block = ImplData::from_ast(db, src.file_id, m.module, impl_block_ast);\n             let id = m.impls.alloc(impl_block);\n             for &impl_item in &m.impls[id].items {\n                 m.impls_by_def.insert(impl_item, id);"}, {"sha": "cdc9182d6b8776329f67a6c45b910c6cb25165df", "filename": "crates/ra_hir/src/lang_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flang_item.rs?ref=80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "patch": "@@ -84,7 +84,7 @@ impl LangItems {\n     ) {\n         // Look for impl targets\n         let (impl_blocks, source_map) = db.impls_in_module_with_source_map(module.clone());\n-        let source = module.definition_source(db).1;\n+        let source = module.definition_source(db).ast;\n         for (impl_id, _) in impl_blocks.impls.iter() {\n             let impl_block = source_map.get(&source, impl_id);\n             let lang_item_name = impl_block"}, {"sha": "2e99bdac839e08017530483a513c2a046f181977", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "patch": "@@ -38,7 +38,6 @@ mod impl_block;\n mod expr;\n mod lang_item;\n mod generics;\n-mod docs;\n mod resolve;\n pub mod diagnostics;\n \n@@ -64,7 +63,6 @@ pub use self::{\n     nameres::{PerNs, Namespace, ImportId},\n     ty::{Ty, ApplicationTy, TypeCtor, TraitRef, Substs, display::HirDisplay, CallableDef},\n     impl_block::{ImplBlock, ImplItem},\n-    docs::{Docs, Documentation},\n     adt::AdtDef,\n     expr::ExprScopes,\n     resolve::Resolution,\n@@ -82,4 +80,6 @@ pub use self::code_model::{\n     Static, Const, ConstSignature,\n     Trait, TypeAlias, MacroDef, Container,\n     BuiltinType,\n+    src::{Source, HasSource},\n+    docs::{Docs, Documentation, DocDef},\n };"}, {"sha": "4f9e8c5a9e76c02ca92c9b5022cc1aea18dd6992", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "patch": "@@ -97,13 +97,13 @@ pub fn struct_from_module(\n     module: Module,\n     struct_def: &ast::StructDef,\n ) -> Struct {\n-    let (file_id, _) = module.definition_source(db);\n+    let file_id = module.definition_source(db).file_id;\n     let ctx = LocationCtx::new(db, module, file_id);\n     Struct { id: ctx.to_def(struct_def) }\n }\n \n pub fn enum_from_module(db: &impl HirDatabase, module: Module, enum_def: &ast::EnumDef) -> Enum {\n-    let (file_id, _) = module.definition_source(db);\n+    let file_id = module.definition_source(db).file_id;\n     let ctx = LocationCtx::new(db, module, file_id);\n     Enum { id: ctx.to_def(enum_def) }\n }\n@@ -113,7 +113,7 @@ pub fn trait_from_module(\n     module: Module,\n     trait_def: &ast::TraitDef,\n ) -> Trait {\n-    let (file_id, _) = module.definition_source(db);\n+    let file_id = module.definition_source(db).file_id;\n     let ctx = LocationCtx::new(db, module, file_id);\n     Trait { id: ctx.to_def(trait_def) }\n }"}, {"sha": "f2950e1b2904fc76d6c49143725453902aad020a", "filename": "crates/ra_hir/src/traits.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftraits.rs?ref=80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "patch": "@@ -6,7 +6,7 @@ use rustc_hash::FxHashMap;\n use ra_syntax::ast::{self, NameOwner};\n \n use crate::{\n-    Function, Const, TypeAlias, Name, DefDatabase, Trait, AstDatabase, Module,\n+    Function, Const, TypeAlias, Name, DefDatabase, Trait, AstDatabase, Module, HasSource,\n     ids::LocationCtx, name::AsName,\n };\n \n@@ -22,12 +22,12 @@ impl TraitData {\n         db: &(impl DefDatabase + AstDatabase),\n         tr: Trait,\n     ) -> Arc<TraitData> {\n-        let (file_id, node) = tr.source(db);\n-        let name = node.name().map(|n| n.as_name());\n+        let src = tr.source(db);\n+        let name = src.ast.name().map(|n| n.as_name());\n         let module = tr.module(db);\n-        let ctx = LocationCtx::new(db, module, file_id);\n-        let auto = node.is_auto();\n-        let items = if let Some(item_list) = node.item_list() {\n+        let ctx = LocationCtx::new(db, module, src.file_id);\n+        let auto = src.ast.is_auto();\n+        let items = if let Some(item_list) = src.ast.item_list() {\n             item_list\n                 .impl_items()\n                 .map(|item_node| match item_node.kind() {"}, {"sha": "fef0f1d244c338354590c1d3250d921f2639c235", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "patch": "@@ -1415,7 +1415,7 @@ mod diagnostics {\n     use crate::{\n         expr::ExprId,\n         diagnostics::{DiagnosticSink, NoSuchField},\n-        HirDatabase, Function,\n+        HirDatabase, Function, HasSource,\n };\n \n     #[derive(Debug, PartialEq, Eq, Clone)]\n@@ -1432,7 +1432,7 @@ mod diagnostics {\n         ) {\n             match self {\n                 InferenceDiagnostic::NoSuchField { expr, field } => {\n-                    let (file, _) = owner.source(db);\n+                    let file = owner.source(db).file_id;\n                     let field = owner.body_source_map(db).field_syntax(*expr, *field);\n                     sink.push(NoSuchField { file, field })\n                 }"}, {"sha": "87b9caa8aa6833ae70fa1cb1caa32b80ef99ab5d", "filename": "crates/ra_hir/src/type_alias.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Ftype_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_hir%2Fsrc%2Ftype_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftype_alias.rs?ref=80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "patch": "@@ -2,12 +2,12 @@\n \n use std::sync::Arc;\n \n-use crate::{TypeAlias, DefDatabase, AstDatabase, type_ref::TypeRef};\n+use crate::{TypeAlias, DefDatabase, AstDatabase, HasSource, type_ref::TypeRef};\n \n pub(crate) fn type_alias_ref_query(\n     db: &(impl DefDatabase + AstDatabase),\n     typ: TypeAlias,\n ) -> Arc<TypeRef> {\n-    let (_, node) = typ.source(db);\n+    let node = typ.source(db).ast;\n     Arc::new(TypeRef::from_ast_opt(node.type_ref()))\n }"}, {"sha": "f4ff4404b142182964f3534f77b540cf15d6797f", "filename": "crates/ra_ide_api/src/completion/presentation.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "patch": "@@ -1,7 +1,7 @@\n //! This modules takes care of rendering various defenitions as completion items.\n use join_to_string::join;\n use test_utils::tested_by;\n-use hir::{Docs, PerNs, Resolution, HirDisplay};\n+use hir::{Docs, PerNs, Resolution, HirDisplay, HasSource};\n use ra_syntax::ast::NameOwner;\n \n use crate::completion::{\n@@ -100,7 +100,7 @@ impl Completions {\n     ) {\n         let sig = func.signature(ctx.db);\n         let name = name.unwrap_or_else(|| sig.name().to_string());\n-        let (_, ast_node) = func.source(ctx.db);\n+        let ast_node = func.source(ctx.db).ast;\n         let detail = function_label(&ast_node);\n \n         let mut builder = CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name)\n@@ -126,12 +126,11 @@ impl Completions {\n     }\n \n     pub(crate) fn add_const(&mut self, ctx: &CompletionContext, constant: hir::Const) {\n-        let (_file_id, ast_node) = constant.source(ctx.db);\n+        let ast_node = constant.source(ctx.db).ast;\n         let name = match ast_node.name() {\n             Some(name) => name,\n             _ => return,\n         };\n-        let (_, ast_node) = constant.source(ctx.db);\n         let detail = const_label(&ast_node);\n \n         CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.text().to_string())\n@@ -142,13 +141,12 @@ impl Completions {\n     }\n \n     pub(crate) fn add_type_alias(&mut self, ctx: &CompletionContext, type_alias: hir::TypeAlias) {\n-        let (_file_id, type_def) = type_alias.source(ctx.db);\n+        let type_def = type_alias.source(ctx.db).ast;\n         let name = match type_def.name() {\n             Some(name) => name,\n             _ => return,\n         };\n-        let (_, ast_node) = type_alias.source(ctx.db);\n-        let detail = type_label(&ast_node);\n+        let detail = type_label(&type_def);\n \n         CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.text().to_string())\n             .kind(CompletionItemKind::TypeAlias)"}, {"sha": "b0b0c71227f55bb74a346a67333738e84a3aefce", "filename": "crates/ra_ide_api/src/display/function_signature.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "patch": "@@ -1,10 +1,11 @@\n-use super::{where_predicates, generic_parameters};\n-use crate::db;\n use std::fmt::{self, Display};\n+\n use join_to_string::join;\n use ra_syntax::ast::{self, AstNode, NameOwner, VisibilityOwner};\n use std::convert::From;\n-use hir::{Docs, Documentation};\n+use hir::{Docs, Documentation, HasSource};\n+\n+use crate::{db, display::{where_predicates, generic_parameters}};\n \n /// Contains information about a function signature\n #[derive(Debug)]\n@@ -33,7 +34,7 @@ impl FunctionSignature {\n \n     pub(crate) fn from_hir(db: &db::RootDatabase, function: hir::Function) -> Self {\n         let doc = function.docs(db);\n-        let (_, ast_node) = function.source(db);\n+        let ast_node = function.source(db).ast;\n         FunctionSignature::from(&*ast_node).with_doc_opt(doc)\n     }\n }"}, {"sha": "823cdaaf3cb80dd0496d9223c3ea0aaf8ab4bc79", "filename": "crates/ra_ide_api/src/display/navigation_target.rs", "status": "modified", "additions": 50, "deletions": 150, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "patch": "@@ -1,11 +1,11 @@\n use ra_db::{FileId, SourceDatabase};\n use ra_syntax::{\n-    SyntaxNode, AstNode, SmolStr, TextRange, AstPtr,\n+    SyntaxNode, AstNode, SmolStr, TextRange, AstPtr, TreeArc,\n     SyntaxKind::{self, NAME},\n     ast::{self, DocCommentsOwner},\n     algo::visit::{visitor, Visitor},\n };\n-use hir::{ModuleSource, FieldSource, ImplItem};\n+use hir::{ModuleSource, FieldSource, ImplItem, HasSource};\n \n use crate::{FileSymbol, db::RootDatabase};\n use super::short_label::ShortLabel;\n@@ -129,10 +129,10 @@ impl NavigationTarget {\n     }\n \n     pub(crate) fn from_module(db: &RootDatabase, module: hir::Module) -> NavigationTarget {\n-        let (file_id, source) = module.definition_source(db);\n-        let file_id = file_id.as_original_file();\n+        let src = module.definition_source(db);\n+        let file_id = src.file_id.as_original_file();\n         let name = module.name(db).map(|it| it.to_string().into()).unwrap_or_default();\n-        match source {\n+        match src.ast {\n             ModuleSource::SourceFile(node) => {\n                 NavigationTarget::from_syntax(file_id, name, None, node.syntax(), None, None)\n             }\n@@ -149,34 +149,24 @@ impl NavigationTarget {\n \n     pub(crate) fn from_module_to_decl(db: &RootDatabase, module: hir::Module) -> NavigationTarget {\n         let name = module.name(db).map(|it| it.to_string().into()).unwrap_or_default();\n-        if let Some((file_id, source)) = module.declaration_source(db) {\n-            let file_id = file_id.as_original_file();\n+        if let Some(src) = module.declaration_source(db) {\n+            let file_id = src.file_id.as_original_file();\n             return NavigationTarget::from_syntax(\n                 file_id,\n                 name,\n                 None,\n-                source.syntax(),\n-                source.doc_comment_text(),\n-                source.short_label(),\n+                src.ast.syntax(),\n+                src.ast.doc_comment_text(),\n+                src.ast.short_label(),\n             );\n         }\n         NavigationTarget::from_module(db, module)\n     }\n \n-    pub(crate) fn from_function(db: &RootDatabase, func: hir::Function) -> NavigationTarget {\n-        let (file_id, fn_def) = func.source(db);\n-        NavigationTarget::from_named(\n-            file_id.original_file(db),\n-            &*fn_def,\n-            fn_def.doc_comment_text(),\n-            fn_def.short_label(),\n-        )\n-    }\n-\n     pub(crate) fn from_field(db: &RootDatabase, field: hir::StructField) -> NavigationTarget {\n-        let (file_id, field) = field.source(db);\n-        let file_id = file_id.original_file(db);\n-        match field {\n+        let src = field.source(db);\n+        let file_id = src.file_id.original_file(db);\n+        match src.ast {\n             FieldSource::Named(it) => {\n                 NavigationTarget::from_named(file_id, &*it, it.doc_comment_text(), it.short_label())\n             }\n@@ -186,35 +176,25 @@ impl NavigationTarget {\n         }\n     }\n \n+    pub(crate) fn from_def_source<A, D>(db: &RootDatabase, def: D) -> NavigationTarget\n+    where\n+        D: HasSource<Ast = TreeArc<A>>,\n+        A: ast::DocCommentsOwner + ast::NameOwner + ShortLabel,\n+    {\n+        let src = def.source(db);\n+        NavigationTarget::from_named(\n+            src.file_id.original_file(db),\n+            &*src.ast,\n+            src.ast.doc_comment_text(),\n+            src.ast.short_label(),\n+        )\n+    }\n+\n     pub(crate) fn from_adt_def(db: &RootDatabase, adt_def: hir::AdtDef) -> NavigationTarget {\n         match adt_def {\n-            hir::AdtDef::Struct(s) => {\n-                let (file_id, node) = s.source(db);\n-                NavigationTarget::from_named(\n-                    file_id.original_file(db),\n-                    &*node,\n-                    node.doc_comment_text(),\n-                    node.short_label(),\n-                )\n-            }\n-            hir::AdtDef::Union(s) => {\n-                let (file_id, node) = s.source(db);\n-                NavigationTarget::from_named(\n-                    file_id.original_file(db),\n-                    &*node,\n-                    node.doc_comment_text(),\n-                    node.short_label(),\n-                )\n-            }\n-            hir::AdtDef::Enum(s) => {\n-                let (file_id, node) = s.source(db);\n-                NavigationTarget::from_named(\n-                    file_id.original_file(db),\n-                    &*node,\n-                    node.doc_comment_text(),\n-                    node.short_label(),\n-                )\n-            }\n+            hir::AdtDef::Struct(it) => NavigationTarget::from_def_source(db, it),\n+            hir::AdtDef::Union(it) => NavigationTarget::from_def_source(db, it),\n+            hir::AdtDef::Enum(it) => NavigationTarget::from_def_source(db, it),\n         }\n     }\n \n@@ -224,79 +204,15 @@ impl NavigationTarget {\n     ) -> Option<NavigationTarget> {\n         let nav = match module_def {\n             hir::ModuleDef::Module(module) => NavigationTarget::from_module(db, module),\n-            hir::ModuleDef::Function(func) => NavigationTarget::from_function(db, func),\n-            hir::ModuleDef::Struct(s) => {\n-                let (file_id, node) = s.source(db);\n-                NavigationTarget::from_named(\n-                    file_id.original_file(db),\n-                    &*node,\n-                    node.doc_comment_text(),\n-                    node.short_label(),\n-                )\n-            }\n-            hir::ModuleDef::Union(s) => {\n-                let (file_id, node) = s.source(db);\n-                NavigationTarget::from_named(\n-                    file_id.original_file(db),\n-                    &*node,\n-                    node.doc_comment_text(),\n-                    node.short_label(),\n-                )\n-            }\n-            hir::ModuleDef::Const(s) => {\n-                let (file_id, node) = s.source(db);\n-                NavigationTarget::from_named(\n-                    file_id.original_file(db),\n-                    &*node,\n-                    node.doc_comment_text(),\n-                    node.short_label(),\n-                )\n-            }\n-            hir::ModuleDef::Static(s) => {\n-                let (file_id, node) = s.source(db);\n-                NavigationTarget::from_named(\n-                    file_id.original_file(db),\n-                    &*node,\n-                    node.doc_comment_text(),\n-                    node.short_label(),\n-                )\n-            }\n-            hir::ModuleDef::Enum(e) => {\n-                let (file_id, node) = e.source(db);\n-                NavigationTarget::from_named(\n-                    file_id.original_file(db),\n-                    &*node,\n-                    node.doc_comment_text(),\n-                    node.short_label(),\n-                )\n-            }\n-            hir::ModuleDef::EnumVariant(var) => {\n-                let (file_id, node) = var.source(db);\n-                NavigationTarget::from_named(\n-                    file_id.original_file(db),\n-                    &*node,\n-                    node.doc_comment_text(),\n-                    node.short_label(),\n-                )\n-            }\n-            hir::ModuleDef::Trait(e) => {\n-                let (file_id, node) = e.source(db);\n-                NavigationTarget::from_named(\n-                    file_id.original_file(db),\n-                    &*node,\n-                    node.doc_comment_text(),\n-                    node.short_label(),\n-                )\n-            }\n-            hir::ModuleDef::TypeAlias(e) => {\n-                let (file_id, node) = e.source(db);\n-                NavigationTarget::from_named(\n-                    file_id.original_file(db),\n-                    &*node,\n-                    node.doc_comment_text(),\n-                    node.short_label(),\n-                )\n-            }\n+            hir::ModuleDef::Function(func) => NavigationTarget::from_def_source(db, func),\n+            hir::ModuleDef::Struct(it) => NavigationTarget::from_adt_def(db, it.into()),\n+            hir::ModuleDef::Enum(it) => NavigationTarget::from_adt_def(db, it.into()),\n+            hir::ModuleDef::Union(it) => NavigationTarget::from_adt_def(db, it.into()),\n+            hir::ModuleDef::Const(it) => NavigationTarget::from_def_source(db, it),\n+            hir::ModuleDef::Static(it) => NavigationTarget::from_def_source(db, it),\n+            hir::ModuleDef::EnumVariant(it) => NavigationTarget::from_def_source(db, it),\n+            hir::ModuleDef::Trait(it) => NavigationTarget::from_def_source(db, it),\n+            hir::ModuleDef::TypeAlias(it) => NavigationTarget::from_def_source(db, it),\n             hir::ModuleDef::BuiltinType(..) => {\n                 return None;\n             }\n@@ -308,48 +224,32 @@ impl NavigationTarget {\n         db: &RootDatabase,\n         impl_block: hir::ImplBlock,\n     ) -> NavigationTarget {\n-        let (file_id, node) = impl_block.source(db);\n+        let src = impl_block.source(db);\n         NavigationTarget::from_syntax(\n-            file_id.as_original_file(),\n+            src.file_id.as_original_file(),\n             \"impl\".into(),\n             None,\n-            node.syntax(),\n+            src.ast.syntax(),\n             None,\n             None,\n         )\n     }\n \n     pub(crate) fn from_impl_item(db: &RootDatabase, impl_item: hir::ImplItem) -> NavigationTarget {\n         match impl_item {\n-            ImplItem::Method(f) => NavigationTarget::from_function(db, f),\n-            ImplItem::Const(c) => {\n-                let (file_id, node) = c.source(db);\n-                NavigationTarget::from_named(\n-                    file_id.original_file(db),\n-                    &*node,\n-                    node.doc_comment_text(),\n-                    node.short_label(),\n-                )\n-            }\n-            ImplItem::TypeAlias(a) => {\n-                let (file_id, node) = a.source(db);\n-                NavigationTarget::from_named(\n-                    file_id.original_file(db),\n-                    &*node,\n-                    node.doc_comment_text(),\n-                    node.short_label(),\n-                )\n-            }\n+            ImplItem::Method(it) => NavigationTarget::from_def_source(db, it),\n+            ImplItem::Const(it) => NavigationTarget::from_def_source(db, it),\n+            ImplItem::TypeAlias(it) => NavigationTarget::from_def_source(db, it),\n         }\n     }\n \n     pub(crate) fn from_macro_def(db: &RootDatabase, macro_call: hir::MacroDef) -> NavigationTarget {\n-        let (file_id, node) = macro_call.source(db);\n-        log::debug!(\"nav target {}\", node.syntax().debug_dump());\n+        let src = macro_call.source(db);\n+        log::debug!(\"nav target {}\", src.ast.syntax().debug_dump());\n         NavigationTarget::from_named(\n-            file_id.original_file(db),\n-            &*node,\n-            node.doc_comment_text(),\n+            src.file_id.original_file(db),\n+            &*src.ast,\n+            src.ast.doc_comment_text(),\n             None,\n         )\n     }"}, {"sha": "63ba6cf9d36fa0cd9b8402a4c96166f88e9a221f", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "patch": "@@ -59,10 +59,10 @@ pub(crate) fn reference_definition(\n     let analyzer = hir::SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n \n     match classify_name_ref(db, &analyzer, name_ref) {\n-        Some(Method(func)) => return Exact(NavigationTarget::from_function(db, func)),\n         Some(Macro(mac)) => return Exact(NavigationTarget::from_macro_def(db, mac)),\n         Some(FieldAccess(field)) => return Exact(NavigationTarget::from_field(db, field)),\n         Some(AssocItem(assoc)) => return Exact(NavigationTarget::from_impl_item(db, assoc)),\n+        Some(Method(func)) => return Exact(NavigationTarget::from_def_source(db, func)),\n         Some(Def(def)) => match NavigationTarget::from_def(db, def) {\n             Some(nav) => return Exact(nav),\n             None => return Approximate(vec![]),\n@@ -253,12 +253,12 @@ mod tests {\n             //- /foo/lib.rs\n             #[macro_export]\n             macro_rules! foo {\n-                () => {             \n+                () => {\n                     {}\n                 };\n-            }            \n+            }\n             \",\n-            \"foo MACRO_CALL FileId(2) [0; 79) [29; 32)\",\n+            \"foo MACRO_CALL FileId(2) [0; 66) [29; 32)\",\n         );\n     }\n "}, {"sha": "ad00abe49738c2b5d618411797395981b4d5311f", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 38, "deletions": 77, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "patch": "@@ -1,9 +1,10 @@\n use ra_db::SourceDatabase;\n use ra_syntax::{\n-    AstNode, ast::{self, DocCommentsOwner},\n+    AstNode, TreeArc,\n+    ast::{self, DocCommentsOwner},\n     algo::{find_covering_element, find_node_at_offset, ancestors_at_offset, visit::{visitor, Visitor}},\n };\n-use hir::HirDisplay;\n+use hir::{HirDisplay, HasSource};\n \n use crate::{\n     db::RootDatabase,\n@@ -95,99 +96,50 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n         let analyzer = hir::SourceAnalyzer::new(db, position.file_id, name_ref.syntax(), None);\n \n         match classify_name_ref(db, &analyzer, name_ref) {\n-            Some(Method(it)) => {\n-                let it = it.source(db).1;\n-                res.extend(hover_text(it.doc_comment_text(), it.short_label()));\n-            }\n+            Some(Method(it)) => res.extend(from_def_source(db, it)),\n             Some(Macro(it)) => {\n-                let it = it.source(db).1;\n-                res.extend(hover_text(it.doc_comment_text(), None));\n+                let src = it.source(db);\n+                res.extend(hover_text(src.ast.doc_comment_text(), None));\n             }\n             Some(FieldAccess(it)) => {\n-                let it = it.source(db).1;\n-                if let hir::FieldSource::Named(it) = it {\n+                let src = it.source(db);\n+                if let hir::FieldSource::Named(it) = src.ast {\n                     res.extend(hover_text(it.doc_comment_text(), it.short_label()));\n                 }\n             }\n-            Some(AssocItem(it)) => match it {\n-                hir::ImplItem::Method(it) => {\n-                    let it = it.source(db).1;\n-                    res.extend(hover_text(it.doc_comment_text(), it.short_label()))\n-                }\n-                hir::ImplItem::Const(it) => {\n-                    let it = it.source(db).1;\n-                    res.extend(hover_text(it.doc_comment_text(), it.short_label()))\n-                }\n-                hir::ImplItem::TypeAlias(it) => {\n-                    let it = it.source(db).1;\n-                    res.extend(hover_text(it.doc_comment_text(), it.short_label()))\n-                }\n-            },\n+            Some(AssocItem(it)) => res.extend(match it {\n+                hir::ImplItem::Method(it) => from_def_source(db, it),\n+                hir::ImplItem::Const(it) => from_def_source(db, it),\n+                hir::ImplItem::TypeAlias(it) => from_def_source(db, it),\n+            }),\n             Some(Def(it)) => {\n                 match it {\n                     hir::ModuleDef::Module(it) => {\n-                        let it = it.definition_source(db).1;\n-                        if let hir::ModuleSource::Module(it) = it {\n+                        if let hir::ModuleSource::Module(it) = it.definition_source(db).ast {\n                             res.extend(hover_text(it.doc_comment_text(), it.short_label()))\n                         }\n                     }\n-                    hir::ModuleDef::Function(it) => {\n-                        let it = it.source(db).1;\n-                        res.extend(hover_text(it.doc_comment_text(), it.short_label()))\n-                    }\n-                    hir::ModuleDef::Struct(it) => {\n-                        let it = it.source(db).1;\n-                        res.extend(hover_text(it.doc_comment_text(), it.short_label()))\n-                    }\n-                    hir::ModuleDef::Union(it) => {\n-                        let it = it.source(db).1;\n-                        res.extend(hover_text(it.doc_comment_text(), it.short_label()))\n-                    }\n-                    hir::ModuleDef::Enum(it) => {\n-                        let it = it.source(db).1;\n-                        res.extend(hover_text(it.doc_comment_text(), it.short_label()))\n-                    }\n-                    hir::ModuleDef::EnumVariant(it) => {\n-                        let it = it.source(db).1;\n-                        res.extend(hover_text(it.doc_comment_text(), it.short_label()))\n-                    }\n-                    hir::ModuleDef::Const(it) => {\n-                        let it = it.source(db).1;\n-                        res.extend(hover_text(it.doc_comment_text(), it.short_label()))\n-                    }\n-                    hir::ModuleDef::Static(it) => {\n-                        let it = it.source(db).1;\n-                        res.extend(hover_text(it.doc_comment_text(), it.short_label()))\n-                    }\n-                    hir::ModuleDef::Trait(it) => {\n-                        let it = it.source(db).1;\n-                        res.extend(hover_text(it.doc_comment_text(), it.short_label()))\n-                    }\n-                    hir::ModuleDef::TypeAlias(it) => {\n-                        let it = it.source(db).1;\n-                        res.extend(hover_text(it.doc_comment_text(), it.short_label()))\n-                    }\n+                    hir::ModuleDef::Function(it) => res.extend(from_def_source(db, it)),\n+                    hir::ModuleDef::Struct(it) => res.extend(from_def_source(db, it)),\n+                    hir::ModuleDef::Union(it) => res.extend(from_def_source(db, it)),\n+                    hir::ModuleDef::Enum(it) => res.extend(from_def_source(db, it)),\n+                    hir::ModuleDef::EnumVariant(it) => res.extend(from_def_source(db, it)),\n+                    hir::ModuleDef::Const(it) => res.extend(from_def_source(db, it)),\n+                    hir::ModuleDef::Static(it) => res.extend(from_def_source(db, it)),\n+                    hir::ModuleDef::Trait(it) => res.extend(from_def_source(db, it)),\n+                    hir::ModuleDef::TypeAlias(it) => res.extend(from_def_source(db, it)),\n                     hir::ModuleDef::BuiltinType(_) => {\n                         // FIXME: hover for builtin Type ?\n                     }\n                 }\n             }\n             Some(SelfType(ty)) => {\n                 if let Some((adt_def, _)) = ty.as_adt() {\n-                    match adt_def {\n-                        hir::AdtDef::Struct(it) => {\n-                            let it = it.source(db).1;\n-                            res.extend(hover_text(it.doc_comment_text(), it.short_label()))\n-                        }\n-                        hir::AdtDef::Union(it) => {\n-                            let it = it.source(db).1;\n-                            res.extend(hover_text(it.doc_comment_text(), it.short_label()))\n-                        }\n-                        hir::AdtDef::Enum(it) => {\n-                            let it = it.source(db).1;\n-                            res.extend(hover_text(it.doc_comment_text(), it.short_label()))\n-                        }\n-                    }\n+                    res.extend(match adt_def {\n+                        hir::AdtDef::Struct(it) => from_def_source(db, it),\n+                        hir::AdtDef::Union(it) => from_def_source(db, it),\n+                        hir::AdtDef::Enum(it) => from_def_source(db, it),\n+                    })\n                 }\n             }\n             Some(Pat(_)) => {\n@@ -270,7 +222,16 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n         return None;\n     }\n     let res = RangeInfo::new(range, res);\n-    Some(res)\n+    return Some(res);\n+\n+    fn from_def_source<A, D>(db: &RootDatabase, def: D) -> Option<String>\n+    where\n+        D: HasSource<Ast = TreeArc<A>>,\n+        A: ast::DocCommentsOwner + ast::NameOwner + ShortLabel,\n+    {\n+        let src = def.source(db);\n+        hover_text(src.ast.doc_comment_text(), src.ast.short_label())\n+    }\n }\n \n pub(crate) fn type_of(db: &RootDatabase, frange: FileRange) -> Option<String> {"}, {"sha": "12cdc6a6d162244a73631108ab87f7429c08ce0d", "filename": "crates/ra_ide_api/src/references.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences.rs?ref=80aa9d5f9f55341d2a51176e385d8aa6d2d2cec8", "patch": "@@ -148,9 +148,9 @@ fn rename_mod(\n     let mut file_system_edits = Vec::new();\n     if let Some(module) = source_binder::module_from_declaration(db, position.file_id, &ast_module)\n     {\n-        let (file_id, module_source) = module.definition_source(db);\n-        let file_id = file_id.as_original_file();\n-        match module_source {\n+        let src = module.definition_source(db);\n+        let file_id = src.file_id.as_original_file();\n+        match src.ast {\n             ModuleSource::SourceFile(..) => {\n                 let mod_path: RelativePathBuf = db.file_relative_path(file_id);\n                 // mod is defined in path/to/dir/mod.rs"}]}