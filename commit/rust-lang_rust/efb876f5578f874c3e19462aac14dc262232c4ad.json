{"sha": "efb876f5578f874c3e19462aac14dc262232c4ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmYjg3NmY1NTc4Zjg3NGMzZTE5NDYyYWFjMTRkYzI2MjIzMmM0YWQ=", "commit": {"author": {"name": "Oliver Middleton", "email": "olliemail27@gmail.com", "date": "2020-01-02T23:34:00Z"}, "committer": {"name": "Oliver Middleton", "email": "olliemail27@gmail.com", "date": "2020-01-04T18:42:06Z"}, "message": "rustdoc: Avoid panic when parsing codeblocks for playground links\n\n`make_test` is also called when parsing codeblocks for the playground links so it should handle unwinds from the parser internally.", "tree": {"sha": "43d17714d0a21b22a8c5c623a19895e81e2c856e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43d17714d0a21b22a8c5c623a19895e81e2c856e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efb876f5578f874c3e19462aac14dc262232c4ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efb876f5578f874c3e19462aac14dc262232c4ad", "html_url": "https://github.com/rust-lang/rust/commit/efb876f5578f874c3e19462aac14dc262232c4ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efb876f5578f874c3e19462aac14dc262232c4ad/comments", "author": {"login": "ollie27", "id": 7189418, "node_id": "MDQ6VXNlcjcxODk0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/7189418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ollie27", "html_url": "https://github.com/ollie27", "followers_url": "https://api.github.com/users/ollie27/followers", "following_url": "https://api.github.com/users/ollie27/following{/other_user}", "gists_url": "https://api.github.com/users/ollie27/gists{/gist_id}", "starred_url": "https://api.github.com/users/ollie27/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ollie27/subscriptions", "organizations_url": "https://api.github.com/users/ollie27/orgs", "repos_url": "https://api.github.com/users/ollie27/repos", "events_url": "https://api.github.com/users/ollie27/events{/privacy}", "received_events_url": "https://api.github.com/users/ollie27/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ollie27", "id": 7189418, "node_id": "MDQ6VXNlcjcxODk0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/7189418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ollie27", "html_url": "https://github.com/ollie27", "followers_url": "https://api.github.com/users/ollie27/followers", "following_url": "https://api.github.com/users/ollie27/following{/other_user}", "gists_url": "https://api.github.com/users/ollie27/gists{/gist_id}", "starred_url": "https://api.github.com/users/ollie27/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ollie27/subscriptions", "organizations_url": "https://api.github.com/users/ollie27/orgs", "repos_url": "https://api.github.com/users/ollie27/repos", "events_url": "https://api.github.com/users/ollie27/events{/privacy}", "received_events_url": "https://api.github.com/users/ollie27/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd8377d37e9bc47f9a5a982c41705a7800cbb51d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd8377d37e9bc47f9a5a982c41705a7800cbb51d", "html_url": "https://github.com/rust-lang/rust/commit/cd8377d37e9bc47f9a5a982c41705a7800cbb51d"}], "stats": {"total": 169, "additions": 93, "deletions": 76}, "files": [{"sha": "db66b7530b29d99f0f417141f0adb57f34c00eb2", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 72, "deletions": 76, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/efb876f5578f874c3e19462aac14dc262232c4ad/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb876f5578f874c3e19462aac14dc262232c4ad/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=efb876f5578f874c3e19462aac14dc262232c4ad", "patch": "@@ -202,17 +202,7 @@ fn run_test(\n     opts: &TestOptions,\n     edition: Edition,\n ) -> Result<(), TestFailure> {\n-    let (test, line_offset) = match panic::catch_unwind(|| {\n-        make_test(test, Some(cratename), as_test_harness, opts, edition)\n-    }) {\n-        Ok((test, line_offset)) => (test, line_offset),\n-        Err(cause) if cause.is::<errors::FatalErrorMarker>() => {\n-            // If the parser used by `make_test` panicked due to a fatal error, pass the test code\n-            // through unchanged. The error will be reported during compilation.\n-            (test.to_owned(), 0)\n-        }\n-        Err(cause) => panic::resume_unwind(cause),\n-    };\n+    let (test, line_offset) = make_test(test, Some(cratename), as_test_harness, opts, edition);\n \n     // FIXME(#44940): if doctests ever support path remapping, then this filename\n     // needs to be the result of `SourceMap::span_to_unmapped_path`.\n@@ -362,11 +352,6 @@ fn run_test(\n \n /// Transforms a test into code that can be compiled into a Rust binary, and returns the number of\n /// lines before the test code begins.\n-///\n-/// # Panics\n-///\n-/// This function uses the compiler's parser internally. The parser will panic if it encounters a\n-/// fatal error while parsing the test.\n pub fn make_test(\n     s: &str,\n     cratename: Option<&str>,\n@@ -401,83 +386,94 @@ pub fn make_test(\n \n     // Uses libsyntax to parse the doctest and find if there's a main fn and the extern\n     // crate already is included.\n-    let (already_has_main, already_has_extern_crate, found_macro) = with_globals(edition, || {\n-        use errors::emitter::EmitterWriter;\n-        use errors::Handler;\n-        use rustc_parse::maybe_new_parser_from_source_str;\n-        use rustc_span::source_map::FilePathMapping;\n-        use syntax::sess::ParseSess;\n-\n-        let filename = FileName::anon_source_code(s);\n-        let source = crates + &everything_else;\n-\n-        // Any errors in parsing should also appear when the doctest is compiled for real, so just\n-        // send all the errors that libsyntax emits directly into a `Sink` instead of stderr.\n-        let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-        let emitter = EmitterWriter::new(box io::sink(), None, false, false, false, None, false);\n-        // FIXME(misdreavus): pass `-Z treat-err-as-bug` to the doctest parser\n-        let handler = Handler::with_emitter(false, None, box emitter);\n-        let sess = ParseSess::with_span_handler(handler, cm);\n-\n-        let mut found_main = false;\n-        let mut found_extern_crate = cratename.is_none();\n-        let mut found_macro = false;\n-\n-        let mut parser = match maybe_new_parser_from_source_str(&sess, filename, source) {\n-            Ok(p) => p,\n-            Err(errs) => {\n-                for mut err in errs {\n-                    err.cancel();\n+    let result = rustc_driver::catch_fatal_errors(|| {\n+        with_globals(edition, || {\n+            use errors::emitter::EmitterWriter;\n+            use errors::Handler;\n+            use rustc_parse::maybe_new_parser_from_source_str;\n+            use rustc_span::source_map::FilePathMapping;\n+            use syntax::sess::ParseSess;\n+\n+            let filename = FileName::anon_source_code(s);\n+            let source = crates + &everything_else;\n+\n+            // Any errors in parsing should also appear when the doctest is compiled for real, so just\n+            // send all the errors that libsyntax emits directly into a `Sink` instead of stderr.\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+            let emitter =\n+                EmitterWriter::new(box io::sink(), None, false, false, false, None, false);\n+            // FIXME(misdreavus): pass `-Z treat-err-as-bug` to the doctest parser\n+            let handler = Handler::with_emitter(false, None, box emitter);\n+            let sess = ParseSess::with_span_handler(handler, cm);\n+\n+            let mut found_main = false;\n+            let mut found_extern_crate = cratename.is_none();\n+            let mut found_macro = false;\n+\n+            let mut parser = match maybe_new_parser_from_source_str(&sess, filename, source) {\n+                Ok(p) => p,\n+                Err(errs) => {\n+                    for mut err in errs {\n+                        err.cancel();\n+                    }\n+\n+                    return (found_main, found_extern_crate, found_macro);\n                 }\n+            };\n+\n+            loop {\n+                match parser.parse_item() {\n+                    Ok(Some(item)) => {\n+                        if !found_main {\n+                            if let ast::ItemKind::Fn(..) = item.kind {\n+                                if item.ident.name == sym::main {\n+                                    found_main = true;\n+                                }\n+                            }\n+                        }\n \n-                return (found_main, found_extern_crate, found_macro);\n-            }\n-        };\n+                        if !found_extern_crate {\n+                            if let ast::ItemKind::ExternCrate(original) = item.kind {\n+                                // This code will never be reached if `cratename` is none because\n+                                // `found_extern_crate` is initialized to `true` if it is none.\n+                                let cratename = cratename.unwrap();\n \n-        loop {\n-            match parser.parse_item() {\n-                Ok(Some(item)) => {\n-                    if !found_main {\n-                        if let ast::ItemKind::Fn(..) = item.kind {\n-                            if item.ident.name == sym::main {\n-                                found_main = true;\n+                                match original {\n+                                    Some(name) => found_extern_crate = name.as_str() == cratename,\n+                                    None => found_extern_crate = item.ident.as_str() == cratename,\n+                                }\n                             }\n                         }\n-                    }\n-\n-                    if !found_extern_crate {\n-                        if let ast::ItemKind::ExternCrate(original) = item.kind {\n-                            // This code will never be reached if `cratename` is none because\n-                            // `found_extern_crate` is initialized to `true` if it is none.\n-                            let cratename = cratename.unwrap();\n \n-                            match original {\n-                                Some(name) => found_extern_crate = name.as_str() == cratename,\n-                                None => found_extern_crate = item.ident.as_str() == cratename,\n+                        if !found_macro {\n+                            if let ast::ItemKind::Mac(..) = item.kind {\n+                                found_macro = true;\n                             }\n                         }\n-                    }\n \n-                    if !found_macro {\n-                        if let ast::ItemKind::Mac(..) = item.kind {\n-                            found_macro = true;\n+                        if found_main && found_extern_crate {\n+                            break;\n                         }\n                     }\n-\n-                    if found_main && found_extern_crate {\n+                    Ok(None) => break,\n+                    Err(mut e) => {\n+                        e.cancel();\n                         break;\n                     }\n                 }\n-                Ok(None) => break,\n-                Err(mut e) => {\n-                    e.cancel();\n-                    break;\n-                }\n             }\n-        }\n \n-        (found_main, found_extern_crate, found_macro)\n+            (found_main, found_extern_crate, found_macro)\n+        })\n     });\n+    let (already_has_main, already_has_extern_crate, found_macro) = match result {\n+        Ok(result) => result,\n+        Err(ErrorReported) => {\n+            // If the parser panicked due to a fatal error, pass the test code through unchanged.\n+            // The error will be reported during compilation.\n+            return (s.to_owned(), 0);\n+        }\n+    };\n \n     // If a doctest's `fn main` is being masked by a wrapper macro, the parsing loop above won't\n     // see it. In that case, run the old text-based scan to see if they at least have a main"}, {"sha": "8918ae874f89801939325e3cda0235d12a73643b", "filename": "src/test/rustdoc/playground-syntax-error.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/efb876f5578f874c3e19462aac14dc262232c4ad/src%2Ftest%2Frustdoc%2Fplayground-syntax-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb876f5578f874c3e19462aac14dc262232c4ad/src%2Ftest%2Frustdoc%2Fplayground-syntax-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fplayground-syntax-error.rs?ref=efb876f5578f874c3e19462aac14dc262232c4ad", "patch": "@@ -0,0 +1,21 @@\n+#![crate_name = \"foo\"]\n+#![doc(html_playground_url = \"https://play.rust-lang.org/\")]\n+\n+/// bar docs\n+///\n+/// ```edition2015\n+/// use std::future::Future;\n+/// use std::pin::Pin;\n+/// fn foo_recursive(n: usize) -> Pin<Box<dyn Future<Output = ()>>> {\n+///     Box::pin(async move {\n+///         if n > 0 {\n+///             foo_recursive(n - 1).await;\n+///         }\n+///     })\n+/// }\n+/// ```\n+pub fn bar() {}\n+\n+// @has foo/fn.bar.html\n+// @has - '//a[@class=\"test-arrow\"]' \"Run\"\n+// @has - '//*[@class=\"docblock\"]' 'foo_recursive'"}]}