{"sha": "72417d84fb51495a4f1d007fb2397a0b2609ab63", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyNDE3ZDg0ZmI1MTQ5NWE0ZjFkMDA3ZmIyMzk3YTBiMjYwOWFiNjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-19T12:30:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-19T12:30:20Z"}, "message": "Auto merge of #73504 - RalfJung:rollup-iy8hsvl, r=RalfJung\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #72280 (Fix up autoderef when reborrowing)\n - #72785 (linker: MSVC supports linking static libraries as a whole archive)\n - #73011 (first stage of implementing LLVM code coverage)\n - #73044 (compiletest: Add directives to detect sanitizer support)\n - #73054 (memory access sanity checks: abort instead of panic)\n - #73136 (Change how compiler-builtins gets many CGUs)\n - #73280 (Add E0763)\n - #73317 (bootstrap: read config from $RUST_BOOTSTRAP_CONFIG)\n - #73350 (bootstrap/install.rs: support a nonexistent `prefix` in `x.py install`)\n - #73352 (Speed up bootstrap a little.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "227579b6a22580e046493bb93b2adb946f9db021", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/227579b6a22580e046493bb93b2adb946f9db021"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72417d84fb51495a4f1d007fb2397a0b2609ab63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72417d84fb51495a4f1d007fb2397a0b2609ab63", "html_url": "https://github.com/rust-lang/rust/commit/72417d84fb51495a4f1d007fb2397a0b2609ab63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72417d84fb51495a4f1d007fb2397a0b2609ab63/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63b441aafbf52d6ba789ecc478455800c1a48df9", "url": "https://api.github.com/repos/rust-lang/rust/commits/63b441aafbf52d6ba789ecc478455800c1a48df9", "html_url": "https://github.com/rust-lang/rust/commit/63b441aafbf52d6ba789ecc478455800c1a48df9"}, {"sha": "61c8925310f5a8eb5b0faaf582c435de326a8e7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/61c8925310f5a8eb5b0faaf582c435de326a8e7f", "html_url": "https://github.com/rust-lang/rust/commit/61c8925310f5a8eb5b0faaf582c435de326a8e7f"}], "stats": {"total": 1690, "additions": 1086, "deletions": 604}, "files": [{"sha": "f10d539d8296ba9cabffdf88cee33f47fecf1118", "filename": "Cargo.toml", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -42,6 +42,19 @@ debug-assertions = false\n debug = false\n debug-assertions = false\n \n+[profile.release.package.compiler_builtins]\n+# For compiler-builtins we always use a high number of codegen units.\n+# The goal here is to place every single intrinsic into its own object\n+# file to avoid symbol clashes with the system libgcc if possible. Note\n+# that this number doesn't actually produce this many object files, we\n+# just don't create more than this number of object files.\n+#\n+# It's a bit of a bummer that we have to pass this here, unfortunately.\n+# Ideally this would be specified through an env var to Cargo so Cargo\n+# knows how many CGUs are for this specific crate, but for now\n+# per-crate configuration isn't specifiable in the environment.\n+codegen-units = 10000\n+\n # We want the RLS to use the version of Cargo that we've got vendored in this\n # repository to ensure that the same exact version of Cargo is used by both the\n # RLS and the Cargo binary itself. The RLS depends on Cargo as a git repository"}, {"sha": "bc6760334170b5bd1bc63cdb1f507e2ab1acb5bb", "filename": "config.toml.example", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -209,7 +209,8 @@\n # Build the sanitizer runtimes\n #sanitizers = false\n \n-# Build the profiler runtime\n+# Build the profiler runtime (required when compiling with options that depend\n+# on this runtime, such as `-C profile-generate` or `-Z instrument-coverage`).\n #profiler = false\n \n # Indicates whether the native libraries linked into Cargo will be statically"}, {"sha": "969d16d11e81b7a578bbbcb769bf412a36da18ec", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -894,7 +894,7 @@ def bootstrap(help_triggered):\n     build.clean = args.clean\n \n     try:\n-        toml_path = args.config or 'config.toml'\n+        toml_path = os.getenv('RUST_BOOTSTRAP_CONFIG') or args.config or 'config.toml'\n         if not os.path.exists(toml_path):\n             toml_path = os.path.join(build.rust_root, toml_path)\n \n@@ -947,6 +947,7 @@ def bootstrap(help_triggered):\n     env[\"SRC\"] = build.rust_root\n     env[\"BOOTSTRAP_PARENT_ID\"] = str(os.getpid())\n     env[\"BOOTSTRAP_PYTHON\"] = sys.executable\n+    env[\"BOOTSTRAP_CONFIG\"] = toml_path\n     env[\"BUILD_DIR\"] = build.build_dir\n     env[\"RUSTC_BOOTSTRAP\"] = '1'\n     env[\"CARGO\"] = build.cargo()"}, {"sha": "58e4bef677efb56426746477c06c796606fda7b6", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -99,9 +99,21 @@ struct StepDescription {\n     name: &'static str,\n }\n \n+/// Collection of paths used to match a task rule.\n #[derive(Debug, Clone, PartialOrd, Ord, PartialEq, Eq)]\n pub enum PathSet {\n+    /// A collection of individual paths.\n+    ///\n+    /// These are generally matched as a path suffix. For example, a\n+    /// command-line value of `libstd` will match if `src/libstd` is in the\n+    /// set.\n     Set(BTreeSet<PathBuf>),\n+    /// A \"suite\" of paths.\n+    ///\n+    /// These can match as a path suffix (like `Set`), or as a prefix. For\n+    /// example, a command-line value of `src/test/ui/abi/variadic-ffi.rs`\n+    /// will match `src/test/ui`. A command-line value of `ui` would also\n+    /// match `src/test/ui`.\n     Suite(PathBuf),\n }\n \n@@ -251,21 +263,33 @@ impl<'a> ShouldRun<'a> {\n         self\n     }\n \n-    // Unlike `krate` this will create just one pathset. As such, it probably shouldn't actually\n-    // ever be used, but as we transition to having all rules properly handle passing krate(...) by\n-    // actually doing something different for every crate passed.\n+    /// Indicates it should run if the command-line selects the given crate or\n+    /// any of its (local) dependencies.\n+    ///\n+    /// Compared to `krate`, this treats the dependencies as aliases for the\n+    /// same job. Generally it is preferred to use `krate`, and treat each\n+    /// individual path separately. For example `./x.py test src/liballoc`\n+    /// (which uses `krate`) will test just `liballoc`. However, `./x.py check\n+    /// src/liballoc` (which uses `all_krates`) will check all of `libtest`.\n+    /// `all_krates` should probably be removed at some point.\n     pub fn all_krates(mut self, name: &str) -> Self {\n         let mut set = BTreeSet::new();\n         for krate in self.builder.in_tree_crates(name) {\n-            set.insert(PathBuf::from(&krate.path));\n+            let path = krate.local_path(self.builder);\n+            set.insert(path);\n         }\n         self.paths.insert(PathSet::Set(set));\n         self\n     }\n \n+    /// Indicates it should run if the command-line selects the given crate or\n+    /// any of its (local) dependencies.\n+    ///\n+    /// `make_run` will be called separately for each matching command-line path.\n     pub fn krate(mut self, name: &str) -> Self {\n         for krate in self.builder.in_tree_crates(name) {\n-            self.paths.insert(PathSet::one(&krate.path));\n+            let path = krate.local_path(self.builder);\n+            self.paths.insert(PathSet::one(path));\n         }\n         self\n     }\n@@ -488,13 +512,19 @@ impl<'a> Builder<'a> {\n             should_run = (desc.should_run)(should_run);\n         }\n         let mut help = String::from(\"Available paths:\\n\");\n+        let mut add_path = |path: &Path| {\n+            help.push_str(&format!(\"    ./x.py {} {}\\n\", subcommand, path.display()));\n+        };\n         for pathset in should_run.paths {\n-            if let PathSet::Set(set) = pathset {\n-                set.iter().for_each(|path| {\n-                    help.push_str(\n-                        format!(\"    ./x.py {} {}\\n\", subcommand, path.display()).as_str(),\n-                    )\n-                })\n+            match pathset {\n+                PathSet::Set(set) => {\n+                    for path in set {\n+                        add_path(&path);\n+                    }\n+                }\n+                PathSet::Suite(path) => {\n+                    add_path(&path.join(\"...\"));\n+                }\n             }\n         }\n         Some(help)"}, {"sha": "6d7fb7acfcb04defd4be6336b5cb44839804d29f", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -548,8 +548,8 @@ impl Step for Rustc {\n         // Find dependencies for top level crates.\n         let mut compiler_crates = HashSet::new();\n         for root_crate in &[\"rustc_driver\", \"rustc_codegen_llvm\", \"rustc_codegen_ssa\"] {\n-            let interned_root_crate = INTERNER.intern_str(root_crate);\n-            find_compiler_crates(builder, &interned_root_crate, &mut compiler_crates);\n+            compiler_crates\n+                .extend(builder.in_tree_crates(root_crate).into_iter().map(|krate| krate.name));\n         }\n \n         for krate in &compiler_crates {\n@@ -564,22 +564,6 @@ impl Step for Rustc {\n     }\n }\n \n-fn find_compiler_crates(\n-    builder: &Builder<'_>,\n-    name: &Interned<String>,\n-    crates: &mut HashSet<Interned<String>>,\n-) {\n-    // Add current crate.\n-    crates.insert(*name);\n-\n-    // Look for dependencies.\n-    for dep in builder.crates.get(name).unwrap().deps.iter() {\n-        if builder.crates.get(dep).unwrap().is_local(builder) {\n-            find_compiler_crates(builder, dep, crates);\n-        }\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustdoc {\n     stage: u32,"}, {"sha": "f477c752933856e0ffd07747f963dcf20fff026c", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -3,19 +3,17 @@\n //! This module implements the command-line parsing of the build system which\n //! has various flags to configure how it's run.\n \n-use std::fs;\n+use std::env;\n use std::path::PathBuf;\n use std::process;\n \n use getopts::Options;\n \n use crate::builder::Builder;\n+use crate::cache::{Interned, INTERNER};\n use crate::config::Config;\n-use crate::metadata;\n use crate::{Build, DocTests};\n \n-use crate::cache::{Interned, INTERNER};\n-\n /// Deserialized version of all flags for this compile.\n pub struct Flags {\n     pub verbose: usize, // number of -v args; each extra -v after the first is passed to Cargo\n@@ -438,19 +436,12 @@ Arguments:\n         // Get any optional paths which occur after the subcommand\n         let paths = matches.free[1..].iter().map(|p| p.into()).collect::<Vec<PathBuf>>();\n \n-        let cfg_file = matches.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n-            if fs::metadata(\"config.toml\").is_ok() {\n-                Some(PathBuf::from(\"config.toml\"))\n-            } else {\n-                None\n-            }\n-        });\n+        let cfg_file = env::var_os(\"BOOTSTRAP_CONFIG\").map(PathBuf::from);\n \n         // All subcommands except `clean` can have an optional \"Available paths\" section\n         if matches.opt_present(\"verbose\") {\n             let config = Config::parse(&[\"build\".to_string()]);\n-            let mut build = Build::new(config);\n-            metadata::build(&mut build);\n+            let build = Build::new(config);\n \n             let maybe_rules_help = Builder::get_help(&build, subcommand.as_str());\n             extra_help.push_str(maybe_rules_help.unwrap_or_default().as_str());"}, {"sha": "fbdef9d8272f7686f61187dbed6330896eedbf6b", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -70,7 +70,10 @@ fn install_sh(\n     let libdir_default = PathBuf::from(\"lib\");\n     let mandir_default = datadir_default.join(\"man\");\n     let prefix = builder.config.prefix.as_ref().map_or(prefix_default, |p| {\n-        fs::canonicalize(p).unwrap_or_else(|_| panic!(\"could not canonicalize {}\", p.display()))\n+        fs::create_dir_all(p)\n+            .unwrap_or_else(|err| panic!(\"could not create {}: {}\", p.display(), err));\n+        fs::canonicalize(p)\n+            .unwrap_or_else(|err| panic!(\"could not canonicalize {}: {}\", p.display(), err))\n     });\n     let sysconfdir = builder.config.sysconfdir.as_ref().unwrap_or(&sysconfdir_default);\n     let datadir = builder.config.datadir.as_ref().unwrap_or(&datadir_default);"}, {"sha": "e7aeb08643c297c4c89d8b6c5ed2bb6f0abe5215", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -270,12 +270,7 @@ struct Crate {\n }\n \n impl Crate {\n-    fn is_local(&self, build: &Build) -> bool {\n-        self.path.starts_with(&build.config.src) && !self.path.to_string_lossy().ends_with(\"_shim\")\n-    }\n-\n     fn local_path(&self, build: &Build) -> PathBuf {\n-        assert!(self.is_local(build));\n         self.path.strip_prefix(&build.config.src).unwrap().into()\n     }\n }\n@@ -1090,17 +1085,29 @@ impl Build {\n         }\n     }\n \n+    /// Returns a Vec of all the dependencies of the given root crate,\n+    /// including transitive dependencies and the root itself. Only includes\n+    /// \"local\" crates (those in the local source tree, not from a registry).\n     fn in_tree_crates(&self, root: &str) -> Vec<&Crate> {\n         let mut ret = Vec::new();\n         let mut list = vec![INTERNER.intern_str(root)];\n         let mut visited = HashSet::new();\n         while let Some(krate) = list.pop() {\n             let krate = &self.crates[&krate];\n-            if krate.is_local(self) {\n-                ret.push(krate);\n-            }\n+            ret.push(krate);\n             for dep in &krate.deps {\n-                if visited.insert(dep) && dep != \"build_helper\" {\n+                // Don't include optional deps if their features are not\n+                // enabled. Ideally this would be computed from `cargo\n+                // metadata --features \u2026`, but that is somewhat slow. Just\n+                // skip `build_helper` since there aren't any operations we\n+                // want to perform on it. In the future, we may want to\n+                // consider just filtering all build and dev dependencies in\n+                // metadata::build.\n+                if visited.insert(dep)\n+                    && dep != \"build_helper\"\n+                    && (dep != \"profiler_builtins\" || self.config.profiler)\n+                    && (dep != \"rustc_codegen_llvm\" || self.config.llvm_enabled())\n+                {\n                     list.push(*dep);\n                 }\n             }"}, {"sha": "a38391c7b88f28f31125681682e41bc4441e1d76", "filename": "src/bootstrap/metadata.rs", "status": "modified", "additions": 13, "deletions": 49, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Fbootstrap%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Fbootstrap%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetadata.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -1,5 +1,3 @@\n-use std::collections::HashMap;\n-use std::collections::HashSet;\n use std::path::PathBuf;\n use std::process::Command;\n \n@@ -12,7 +10,6 @@ use crate::{Build, Crate};\n #[derive(Deserialize)]\n struct Output {\n     packages: Vec<Package>,\n-    resolve: Resolve,\n }\n \n #[derive(Deserialize)]\n@@ -21,72 +18,39 @@ struct Package {\n     name: String,\n     source: Option<String>,\n     manifest_path: String,\n+    dependencies: Vec<Dependency>,\n }\n \n #[derive(Deserialize)]\n-struct Resolve {\n-    nodes: Vec<ResolveNode>,\n-}\n-\n-#[derive(Deserialize)]\n-struct ResolveNode {\n-    id: String,\n-    dependencies: Vec<String>,\n+struct Dependency {\n+    name: String,\n+    source: Option<String>,\n }\n \n pub fn build(build: &mut Build) {\n-    let mut resolves = Vec::new();\n-    build_krate(&build.std_features(), build, &mut resolves, \"src/libstd\");\n-    build_krate(\"\", build, &mut resolves, \"src/libtest\");\n-    build_krate(&build.rustc_features(), build, &mut resolves, \"src/rustc\");\n-\n-    let mut id2name = HashMap::with_capacity(build.crates.len());\n-    for (name, krate) in build.crates.iter() {\n-        id2name.insert(krate.id.clone(), name.clone());\n-    }\n-\n-    for node in resolves {\n-        let name = match id2name.get(&node.id) {\n-            Some(name) => name,\n-            None => continue,\n-        };\n-\n-        let krate = build.crates.get_mut(name).unwrap();\n-        for dep in node.dependencies.iter() {\n-            let dep = match id2name.get(dep) {\n-                Some(dep) => dep,\n-                None => continue,\n-            };\n-            krate.deps.insert(*dep);\n-        }\n-    }\n-}\n-\n-fn build_krate(features: &str, build: &mut Build, resolves: &mut Vec<ResolveNode>, krate: &str) {\n     // Run `cargo metadata` to figure out what crates we're testing.\n-    //\n-    // Down below we're going to call `cargo test`, but to test the right set\n-    // of packages we're going to have to know what `-p` arguments to pass it\n-    // to know what crates to test. Here we run `cargo metadata` to learn about\n-    // the dependency graph and what `-p` arguments there are.\n     let mut cargo = Command::new(&build.initial_cargo);\n     cargo\n         .arg(\"metadata\")\n         .arg(\"--format-version\")\n         .arg(\"1\")\n-        .arg(\"--features\")\n-        .arg(features)\n+        .arg(\"--no-deps\")\n         .arg(\"--manifest-path\")\n-        .arg(build.src.join(krate).join(\"Cargo.toml\"));\n+        .arg(build.src.join(\"Cargo.toml\"));\n     let output = output(&mut cargo);\n     let output: Output = serde_json::from_str(&output).unwrap();\n     for package in output.packages {\n         if package.source.is_none() {\n             let name = INTERNER.intern_string(package.name);\n             let mut path = PathBuf::from(package.manifest_path);\n             path.pop();\n-            build.crates.insert(name, Crate { name, id: package.id, deps: HashSet::new(), path });\n+            let deps = package\n+                .dependencies\n+                .into_iter()\n+                .filter(|dep| dep.source.is_none())\n+                .map(|dep| INTERNER.intern_string(dep.name))\n+                .collect();\n+            build.crates.insert(name, Crate { name, id: package.id, deps, path });\n         }\n     }\n-    resolves.extend(output.resolve.nodes);\n }"}, {"sha": "8a37a70d60d9a4fffa35f0a7fa3ea7261f1e7a27", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -1648,14 +1648,8 @@ impl Step for Crate {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(mut run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        let builder = run.builder;\n-        for krate in run.builder.in_tree_crates(\"test\") {\n-            if !(krate.name.starts_with(\"rustc_\") && krate.name.ends_with(\"san\")) {\n-                run = run.path(krate.local_path(&builder).to_str().unwrap());\n-            }\n-        }\n-        run\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.krate(\"test\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {"}, {"sha": "9061145a695f8ba1280a48ce850f7f0163380e99", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -1941,6 +1941,13 @@ extern \"rust-intrinsic\" {\n     ///\n     /// Perma-unstable: do not use.\n     pub fn miri_start_panic(payload: *mut u8) -> !;\n+\n+    /// Internal placeholder for injecting code coverage counters when the \"instrument-coverage\"\n+    /// option is enabled. The placeholder is replaced with `llvm.instrprof.increment` during code\n+    /// generation.\n+    #[cfg(not(bootstrap))]\n+    #[lang = \"count_code_region\"]\n+    pub fn count_code_region(index: u32);\n }\n \n // Some functions are defined here because they accidentally got made\n@@ -2057,9 +2064,14 @@ pub unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n         fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n     }\n \n-    debug_assert!(is_aligned_and_not_null(src), \"attempt to copy from unaligned or null pointer\");\n-    debug_assert!(is_aligned_and_not_null(dst), \"attempt to copy to unaligned or null pointer\");\n-    debug_assert!(is_nonoverlapping(src, dst, count), \"attempt to copy to overlapping memory\");\n+    if cfg!(debug_assertions)\n+        && !(is_aligned_and_not_null(src)\n+            && is_aligned_and_not_null(dst)\n+            && is_nonoverlapping(src, dst, count))\n+    {\n+        // Not panicking to keep codegen impact smaller.\n+        abort();\n+    }\n     copy_nonoverlapping(src, dst, count)\n }\n \n@@ -2122,8 +2134,10 @@ pub unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n         fn copy<T>(src: *const T, dst: *mut T, count: usize);\n     }\n \n-    debug_assert!(is_aligned_and_not_null(src), \"attempt to copy from unaligned or null pointer\");\n-    debug_assert!(is_aligned_and_not_null(dst), \"attempt to copy to unaligned or null pointer\");\n+    if cfg!(debug_assertions) && !(is_aligned_and_not_null(src) && is_aligned_and_not_null(dst)) {\n+        // Not panicking to keep codegen impact smaller.\n+        abort();\n+    }\n     copy(src, dst, count)\n }\n "}, {"sha": "ca2b0c85ec12172e72fdca0680e1d4cb1337e918", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -70,7 +70,7 @@\n use crate::cmp::Ordering;\n use crate::fmt;\n use crate::hash;\n-use crate::intrinsics::{self, is_aligned_and_not_null, is_nonoverlapping};\n+use crate::intrinsics::{self, abort, is_aligned_and_not_null, is_nonoverlapping};\n use crate::mem::{self, MaybeUninit};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -420,9 +420,14 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n #[inline]\n #[stable(feature = \"swap_nonoverlapping\", since = \"1.27.0\")]\n pub unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n-    debug_assert!(is_aligned_and_not_null(x), \"attempt to swap unaligned or null pointer\");\n-    debug_assert!(is_aligned_and_not_null(y), \"attempt to swap unaligned or null pointer\");\n-    debug_assert!(is_nonoverlapping(x, y, count), \"attempt to swap overlapping memory\");\n+    if cfg!(debug_assertions)\n+        && !(is_aligned_and_not_null(x)\n+            && is_aligned_and_not_null(y)\n+            && is_nonoverlapping(x, y, count))\n+    {\n+        // Not panicking to keep codegen impact smaller.\n+        abort();\n+    }\n \n     let x = x as *mut u8;\n     let y = y as *mut u8;\n@@ -838,7 +843,10 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn write<T>(dst: *mut T, src: T) {\n-    debug_assert!(is_aligned_and_not_null(dst), \"attempt to write to unaligned or null pointer\");\n+    if cfg!(debug_assertions) && !is_aligned_and_not_null(dst) {\n+        // Not panicking to keep codegen impact smaller.\n+        abort();\n+    }\n     intrinsics::move_val_init(&mut *dst, src)\n }\n \n@@ -1003,7 +1011,10 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n #[inline]\n #[stable(feature = \"volatile\", since = \"1.9.0\")]\n pub unsafe fn read_volatile<T>(src: *const T) -> T {\n-    debug_assert!(is_aligned_and_not_null(src), \"attempt to read from unaligned or null pointer\");\n+    if cfg!(debug_assertions) && !is_aligned_and_not_null(src) {\n+        // Not panicking to keep codegen impact smaller.\n+        abort();\n+    }\n     intrinsics::volatile_load(src)\n }\n \n@@ -1072,7 +1083,10 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n #[inline]\n #[stable(feature = \"volatile\", since = \"1.9.0\")]\n pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n-    debug_assert!(is_aligned_and_not_null(dst), \"attempt to write to unaligned or null pointer\");\n+    if cfg!(debug_assertions) && !is_aligned_and_not_null(dst) {\n+        // Not panicking to keep codegen impact smaller.\n+        abort();\n+    }\n     intrinsics::volatile_store(dst, src);\n }\n "}, {"sha": "ba285b5ef38d12efa9c72d75794080ef9848fa49", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -997,6 +997,33 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         self.call_lifetime_intrinsic(\"llvm.lifetime.end.p0i8\", ptr, size);\n     }\n \n+    fn instrprof_increment(\n+        &mut self,\n+        fn_name: &'ll Value,\n+        hash: &'ll Value,\n+        num_counters: &'ll Value,\n+        index: &'ll Value,\n+    ) -> &'ll Value {\n+        debug!(\n+            \"instrprof_increment() with args ({:?}, {:?}, {:?}, {:?})\",\n+            fn_name, hash, num_counters, index\n+        );\n+\n+        let llfn = unsafe { llvm::LLVMRustGetInstrprofIncrementIntrinsic(self.cx().llmod) };\n+        let args = &[fn_name, hash, num_counters, index];\n+        let args = self.check_call(\"call\", llfn, args);\n+\n+        unsafe {\n+            llvm::LLVMRustBuildCall(\n+                self.llbuilder,\n+                llfn,\n+                args.as_ptr() as *const &llvm::Value,\n+                args.len() as c_uint,\n+                None,\n+            )\n+        }\n+    }\n+\n     fn call(\n         &mut self,\n         llfn: &'ll Value,"}, {"sha": "7ff5ac5cbdc10082bbdc7b54d1115784fd20addf", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -749,6 +749,8 @@ impl CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.lifetime.start.p0i8\", fn(t_i64, i8p) -> void);\n         ifn!(\"llvm.lifetime.end.p0i8\", fn(t_i64, i8p) -> void);\n \n+        ifn!(\"llvm.instrprof.increment\", fn(i8p, t_i64, t_i32, t_i32) -> void);\n+\n         ifn!(\"llvm.expect.i1\", fn(i1, i1) -> i1);\n         ifn!(\"llvm.eh.typeid.for\", fn(i8p) -> t_i32);\n         ifn!(\"llvm.localescape\", fn(...) -> void);"}, {"sha": "95465939070a0e62a6e8a9749df0386fa67fc890", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -7,6 +7,8 @@ use crate::type_of::LayoutLlvmExt;\n use crate::va_arg::emit_va_arg;\n use crate::value::Value;\n \n+use log::debug;\n+\n use rustc_ast::ast;\n use rustc_codegen_ssa::base::{compare_simd_types, to_immediate, wants_msvc_seh};\n use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n@@ -21,6 +23,7 @@ use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n use rustc_middle::ty::{self, Ty};\n use rustc_middle::{bug, span_bug};\n use rustc_span::Span;\n+use rustc_span::Symbol;\n use rustc_target::abi::{self, HasDataLayout, LayoutOf, Primitive};\n use rustc_target::spec::PanicStrategy;\n \n@@ -86,6 +89,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         args: &[OperandRef<'tcx, &'ll Value>],\n         llresult: &'ll Value,\n         span: Span,\n+        caller_instance: ty::Instance<'tcx>,\n     ) {\n         let tcx = self.tcx;\n         let callee_ty = instance.monomorphic_ty(tcx);\n@@ -136,6 +140,28 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 let llfn = self.get_intrinsic(&(\"llvm.debugtrap\"));\n                 self.call(llfn, &[], None)\n             }\n+            \"count_code_region\" => {\n+                if let ty::InstanceDef::Item(fn_def_id) = caller_instance.def {\n+                    let caller_fn_path = tcx.def_path_str(fn_def_id);\n+                    debug!(\n+                        \"count_code_region to llvm.instrprof.increment(fn_name={})\",\n+                        caller_fn_path\n+                    );\n+\n+                    // FIXME(richkadel): (1) Replace raw function name with mangled function name;\n+                    // (2) Replace hardcoded `1234` in `hash` with a computed hash (as discussed in)\n+                    // the MCP (compiler-team/issues/278); and replace the hardcoded `1` for\n+                    // `num_counters` with the actual number of counters per function (when the\n+                    // changes are made to inject more than one counter per function).\n+                    let (fn_name, _len_val) = self.const_str(Symbol::intern(&caller_fn_path));\n+                    let index = args[0].immediate();\n+                    let hash = self.const_u64(1234);\n+                    let num_counters = self.const_u32(1);\n+                    self.instrprof_increment(fn_name, hash, num_counters, index)\n+                } else {\n+                    bug!(\"intrinsic count_code_region: no src.instance\");\n+                }\n+            }\n             \"va_start\" => self.va_start(args[0].immediate()),\n             \"va_end\" => self.va_end(args[0].immediate()),\n             \"va_copy\" => {"}, {"sha": "372fb17573a4bd8069cb6577980168226e7a5efa", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -1360,6 +1360,7 @@ extern \"C\" {\n \n     // Miscellaneous instructions\n     pub fn LLVMBuildPhi(B: &Builder<'a>, Ty: &'a Type, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMRustGetInstrprofIncrementIntrinsic(M: &Module) -> &'a Value;\n     pub fn LLVMRustBuildCall(\n         B: &Builder<'a>,\n         Fn: &'a Value,"}, {"sha": "6011d422ca682c174549f72432a485e6e97f676a", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -721,12 +721,14 @@ impl<'a> Linker for MsvcLinker<'a> {\n     }\n \n     fn link_whole_staticlib(&mut self, lib: Symbol, _search_path: &[PathBuf]) {\n-        // not supported?\n         self.link_staticlib(lib);\n+        self.cmd.arg(format!(\"/WHOLEARCHIVE:{}.lib\", lib));\n     }\n     fn link_whole_rlib(&mut self, path: &Path) {\n-        // not supported?\n         self.link_rlib(path);\n+        let mut arg = OsString::from(\"/WHOLEARCHIVE:\");\n+        arg.push(path);\n+        self.cmd.arg(arg);\n     }\n     fn optimize(&mut self) {\n         // Needs more investigation of `/OPT` arguments"}, {"sha": "49054765b9dae73e92aabe78e976b50cd98f41a4", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -175,6 +175,12 @@ impl ModuleConfig {\n                     if sess.opts.debugging_opts.profile && !is_compiler_builtins {\n                         passes.push(\"insert-gcov-profiling\".to_owned());\n                     }\n+\n+                    // The rustc option `-Zinstrument_coverage` injects intrinsic calls to\n+                    // `llvm.instrprof.increment()`, which requires the LLVM `instrprof` pass.\n+                    if sess.opts.debugging_opts.instrument_coverage {\n+                        passes.push(\"instrprof\".to_owned());\n+                    }\n                     passes\n                 },\n                 vec![]"}, {"sha": "d56c816811b3c46d68056e7b662ddba6c08724db", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -693,6 +693,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 &args,\n                 dest,\n                 terminator.source_info.span,\n+                self.instance,\n             );\n \n             if let ReturnDest::IndirectOperand(dst, _) = ret_dest {"}, {"sha": "7ffc9f15bffdc59fb6d529834ab7244b1fee5c06", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -260,6 +260,14 @@ pub trait BuilderMethods<'a, 'tcx>:\n     /// Called for `StorageDead`\n     fn lifetime_end(&mut self, ptr: Self::Value, size: Size);\n \n+    fn instrprof_increment(\n+        &mut self,\n+        fn_name: Self::Value,\n+        hash: Self::Value,\n+        num_counters: Self::Value,\n+        index: Self::Value,\n+    ) -> Self::Value;\n+\n     fn call(\n         &mut self,\n         llfn: Self::Value,"}, {"sha": "f62019498511c48c166b9280c277948444965811", "filename": "src/librustc_codegen_ssa/traits/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -15,6 +15,7 @@ pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n         args: &[OperandRef<'tcx, Self::Value>],\n         llresult: Self::Value,\n         span: Span,\n+        caller_instance: ty::Instance<'tcx>,\n     );\n \n     fn abort(&mut self);"}, {"sha": "997762efcb3e5f3dd0314c5ece1d0ccc5b8d4178", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -443,6 +443,7 @@ E0759: include_str!(\"./error_codes/E0759.md\"),\n E0760: include_str!(\"./error_codes/E0760.md\"),\n E0761: include_str!(\"./error_codes/E0761.md\"),\n E0762: include_str!(\"./error_codes/E0762.md\"),\n+E0763: include_str!(\"./error_codes/E0763.md\"),\n ;\n //  E0006, // merged with E0005\n //  E0008, // cannot bind by-move into a pattern guard"}, {"sha": "095b779f3e78afdf50a425e1fa914896e76fae36", "filename": "src/librustc_error_codes/error_codes/E0763.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_error_codes%2Ferror_codes%2FE0763.md", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_error_codes%2Ferror_codes%2FE0763.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0763.md?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -0,0 +1,13 @@\n+A byte constant wasn't correctly ended.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0763\n+let c = b'a; // error!\n+```\n+\n+To fix this error, add the missing quote:\n+\n+```\n+let c = b'a'; // ok!\n+```"}, {"sha": "091ded6d74d0feb291a9a06bdb03f894cac21fc3", "filename": "src/librustc_hir/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_hir%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_hir%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flang_items.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -242,6 +242,8 @@ language_item_table! {\n \n     StartFnLangItem,             \"start\",              start_fn,                Target::Fn;\n \n+    CountCodeRegionFnLangItem,   \"count_code_region\",  count_code_region_fn,    Target::Fn;\n+\n     EhPersonalityLangItem,       \"eh_personality\",     eh_personality,          Target::Fn;\n     EhCatchTypeinfoLangItem,     \"eh_catch_typeinfo\",  eh_catch_typeinfo,       Target::Static;\n "}, {"sha": "c2a7d1a4a6102739589de9e3921dc4c277df6c72", "filename": "src/librustc_interface/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_interface%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_interface%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Ftests.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -548,6 +548,7 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(human_readable_cgu_names, true);\n     tracked!(inline_in_all_cgus, Some(true));\n     tracked!(insert_sideeffect, true);\n+    tracked!(instrument_coverage, true);\n     tracked!(instrument_mcount, true);\n     tracked!(link_only, true);\n     tracked!(merge_functions, Some(MergeFunctions::Disabled));"}, {"sha": "0dc007bbfd72f8db4fa5acdea855178381a6cd7d", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -706,7 +706,9 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn inject_profiler_runtime(&mut self) {\n-        if (self.sess.opts.debugging_opts.profile || self.sess.opts.cg.profile_generate.enabled())\n+        if (self.sess.opts.debugging_opts.instrument_coverage\n+            || self.sess.opts.debugging_opts.profile\n+            || self.sess.opts.cg.profile_generate.enabled())\n             && !self.sess.opts.debugging_opts.no_profiler_runtime\n         {\n             info!(\"loading profiler\");"}, {"sha": "3381b95c2a38e1fd9946c29d088ae2c1a6a06a5a", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -29,6 +29,7 @@ use rustc_macros::HashStable;\n use rustc_serialize::{Decodable, Encodable};\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n+use rustc_target::abi;\n use rustc_target::asm::InlineAsmRegOrRegClass;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Display, Formatter, Write};\n@@ -2218,6 +2219,33 @@ impl<'tcx> Operand<'tcx> {\n         })\n     }\n \n+    /// Convenience helper to make a literal-like constant from a given scalar value.\n+    /// Since this is used to synthesize MIR, assumes `user_ty` is None.\n+    pub fn const_from_scalar(\n+        tcx: TyCtxt<'tcx>,\n+        ty: Ty<'tcx>,\n+        val: Scalar,\n+        span: Span,\n+    ) -> Operand<'tcx> {\n+        debug_assert!({\n+            let param_env_and_ty = ty::ParamEnv::empty().and(ty);\n+            let type_size = tcx\n+                .layout_of(param_env_and_ty)\n+                .unwrap_or_else(|e| panic!(\"could not compute layout for {:?}: {:?}\", ty, e))\n+                .size;\n+            let scalar_size = abi::Size::from_bytes(match val {\n+                Scalar::Raw { size, .. } => size,\n+                _ => panic!(\"Invalid scalar type {:?}\", val),\n+            });\n+            scalar_size == type_size\n+        });\n+        Operand::Constant(box Constant {\n+            span,\n+            user_ty: None,\n+            literal: ty::Const::from_scalar(tcx, val, ty),\n+        })\n+    }\n+\n     pub fn to_copy(&self) -> Self {\n         match *self {\n             Operand::Copy(_) | Operand::Constant(_) => self.clone(),"}, {"sha": "ac28ccd181520f7092cb546e3fb83b014ef5f39e", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -389,6 +389,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 );\n                 self.copy_op(self.operand_index(args[0], index)?, dest)?;\n             }\n+            // FIXME(#73156): Handle source code coverage in const eval\n+            sym::count_code_region => (),\n             _ => return Ok(false),\n         }\n "}, {"sha": "a945c1d626a9a63849c17386ac2c1dd656781e59", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -454,18 +454,11 @@ fn default_visibility(tcx: TyCtxt<'_>, id: DefId, is_generic: bool) -> Visibilit\n fn merge_codegen_units<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n-    mut target_cgu_count: usize,\n+    target_cgu_count: usize,\n ) {\n     assert!(target_cgu_count >= 1);\n     let codegen_units = &mut initial_partitioning.codegen_units;\n \n-    if tcx.is_compiler_builtins(LOCAL_CRATE) {\n-        // Compiler builtins require some degree of control over how mono items\n-        // are partitioned into compilation units. Provide it by keeping the\n-        // original partitioning when compiling the compiler builtins crate.\n-        target_cgu_count = codegen_units.len();\n-    }\n-\n     // Note that at this point in time the `codegen_units` here may not be in a\n     // deterministic order (but we know they're deterministically the same set).\n     // We want this merging to produce a deterministic ordering of codegen units"}, {"sha": "c36614938e10f9ab8b9a006faae3becece49105b", "filename": "src/librustc_mir/transform/instrument_coverage.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -0,0 +1,92 @@\n+use crate::transform::{MirPass, MirSource};\n+use crate::util::patch::MirPatch;\n+use rustc_hir::lang_items;\n+use rustc_middle::mir::interpret::Scalar;\n+use rustc_middle::mir::*;\n+use rustc_middle::ty;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_span::def_id::DefId;\n+use rustc_span::Span;\n+\n+/// Inserts call to count_code_region() as a placeholder to be replaced during code generation with\n+/// the intrinsic llvm.instrprof.increment.\n+pub struct InstrumentCoverage;\n+\n+impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+        if tcx.sess.opts.debugging_opts.instrument_coverage {\n+            debug!(\"instrumenting {:?}\", src.def_id());\n+            instrument_coverage(tcx, body);\n+        }\n+    }\n+}\n+\n+// The first counter (start of the function) is index zero.\n+const INIT_FUNCTION_COUNTER: u32 = 0;\n+\n+/// Injects calls to placeholder function `count_code_region()`.\n+// FIXME(richkadel): As a first step, counters are only injected at the top of each function.\n+// The complete solution will inject counters at each conditional code branch.\n+pub fn instrument_coverage<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+    let span = body.span.shrink_to_lo();\n+\n+    let count_code_region_fn = function_handle(\n+        tcx,\n+        tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None),\n+        span,\n+    );\n+    let counter_index = Operand::const_from_scalar(\n+        tcx,\n+        tcx.types.u32,\n+        Scalar::from_u32(INIT_FUNCTION_COUNTER),\n+        span,\n+    );\n+\n+    let mut patch = MirPatch::new(body);\n+\n+    let new_block = patch.new_block(placeholder_block(SourceInfo::outermost(body.span)));\n+    let next_block = START_BLOCK;\n+\n+    let temp = patch.new_temp(tcx.mk_unit(), body.span);\n+    patch.patch_terminator(\n+        new_block,\n+        TerminatorKind::Call {\n+            func: count_code_region_fn,\n+            args: vec![counter_index],\n+            // new_block will swapped with the next_block, after applying patch\n+            destination: Some((Place::from(temp), new_block)),\n+            cleanup: None,\n+            from_hir_call: false,\n+            fn_span: span,\n+        },\n+    );\n+\n+    patch.add_statement(new_block.start_location(), StatementKind::StorageLive(temp));\n+    patch.add_statement(next_block.start_location(), StatementKind::StorageDead(temp));\n+\n+    patch.apply(body);\n+\n+    // To insert the `new_block` in front of the first block in the counted branch (for example,\n+    // the START_BLOCK, at the top of the function), just swap the indexes, leaving the rest of the\n+    // graph unchanged.\n+    body.basic_blocks_mut().swap(next_block, new_block);\n+}\n+\n+fn function_handle<'tcx>(tcx: TyCtxt<'tcx>, fn_def_id: DefId, span: Span) -> Operand<'tcx> {\n+    let ret_ty = tcx.fn_sig(fn_def_id).output();\n+    let ret_ty = ret_ty.no_bound_vars().unwrap();\n+    let substs = tcx.mk_substs(::std::iter::once(ty::subst::GenericArg::from(ret_ty)));\n+    Operand::function_handle(tcx, fn_def_id, substs, span)\n+}\n+\n+fn placeholder_block<'tcx>(source_info: SourceInfo) -> BasicBlockData<'tcx> {\n+    BasicBlockData {\n+        statements: vec![],\n+        terminator: Some(Terminator {\n+            source_info,\n+            // this gets overwritten by the counter Call\n+            kind: TerminatorKind::Unreachable,\n+        }),\n+        is_cleanup: false,\n+    }\n+}"}, {"sha": "846ed1f86d8d6ab996bd664edc191aaa460331f9", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -28,6 +28,7 @@ pub mod elaborate_drops;\n pub mod generator;\n pub mod inline;\n pub mod instcombine;\n+pub mod instrument_coverage;\n pub mod no_landing_pads;\n pub mod nrvo;\n pub mod promote_consts;\n@@ -288,6 +289,10 @@ fn mir_validated(\n             // What we need to run borrowck etc.\n             &promote_pass,\n             &simplify::SimplifyCfg::new(\"qualify-consts\"),\n+            // If the `instrument-coverage` option is enabled, analyze the CFG, identify each\n+            // conditional branch, construct a coverage map to be passed to LLVM, and inject counters\n+            // where needed.\n+            &instrument_coverage::InstrumentCoverage,\n         ]],\n     );\n "}, {"sha": "2e3cf4e746ae959778a5a2df14b1794288814a7f", "filename": "src/librustc_parse/lexer/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Fmod.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -339,8 +339,15 @@ impl<'a> StringReader<'a> {\n             }\n             rustc_lexer::LiteralKind::Byte { terminated } => {\n                 if !terminated {\n-                    self.fatal_span_(start + BytePos(1), suffix_start, \"unterminated byte constant\")\n-                        .raise()\n+                    self.sess\n+                        .span_diagnostic\n+                        .struct_span_fatal_with_code(\n+                            self.mk_sp(start + BytePos(1), suffix_start),\n+                            \"unterminated byte constant\",\n+                            error_code!(E0763),\n+                        )\n+                        .emit();\n+                    FatalError.raise();\n                 }\n                 (token::Byte, Mode::Byte, 2, 1) // b' '\n             }"}, {"sha": "f2f07b5d4fb26fba2d7a8acf877d2136f734b2ff", "filename": "src/librustc_passes/weak_lang_items.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_passes%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_passes%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fweak_lang_items.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -5,10 +5,12 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::lang_items;\n+use rustc_hir::lang_items::ITEM_REFS;\n use rustc_hir::weak_lang_items::WEAK_ITEMS_REFS;\n use rustc_middle::middle::lang_items::whitelisted;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::CrateType;\n+use rustc_span::symbol::sym;\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n \n@@ -70,11 +72,21 @@ fn verify<'tcx>(tcx: TyCtxt<'tcx>, items: &lang_items::LanguageItems) {\n }\n \n impl<'a, 'tcx> Context<'a, 'tcx> {\n-    fn register(&mut self, name: Symbol, span: Span) {\n+    fn register(&mut self, name: Symbol, span: Span, hir_id: hir::HirId) {\n         if let Some(&item) = WEAK_ITEMS_REFS.get(&name) {\n             if self.items.require(item).is_err() {\n                 self.items.missing.push(item);\n             }\n+        } else if name == sym::count_code_region {\n+            // `core::intrinsics::code_count_region()` is (currently) the only `extern` lang item\n+            // that is never actually linked. It is not a `weak_lang_item` that can be registered\n+            // when used, and should be registered here instead.\n+            if let Some((item_index, _)) = ITEM_REFS.get(&*name.as_str()).cloned() {\n+                if self.items.items[item_index].is_none() {\n+                    let item_def_id = self.tcx.hir().local_def_id(hir_id).to_def_id();\n+                    self.items.items[item_index] = Some(item_def_id);\n+                }\n+            }\n         } else {\n             struct_span_err!(self.tcx.sess, span, E0264, \"unknown external lang item: `{}`\", name)\n                 .emit();\n@@ -91,7 +103,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, i: &hir::ForeignItem<'_>) {\n         if let Some((lang_item, _)) = hir::lang_items::extract(&i.attrs) {\n-            self.register(lang_item, i.span);\n+            self.register(lang_item, i.span, i.hir_id);\n         }\n         intravisit::walk_foreign_item(self, i)\n     }"}, {"sha": "2d231359057fd1669603e11f5337f6c21e74ba84", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -876,6 +876,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"fix undefined behavior when a thread doesn't eventually make progress \\\n         (such as entering an empty infinite loop) by inserting llvm.sideeffect \\\n         (default: no)\"),\n+    instrument_coverage: bool = (false, parse_bool, [TRACKED],\n+        \"instrument the generated code with LLVM code region counters to \\\n+        (in the future) generate coverage reports (experimental; default: no)\"),\n     instrument_mcount: bool = (false, parse_bool, [TRACKED],\n         \"insert function instrument code for mcount-based tracing (default: no)\"),\n     keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "970a26325926cc13a5cdd391ada1b5fa1d3882c6", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -240,6 +240,7 @@ symbols! {\n         copy_closures,\n         core,\n         core_intrinsics,\n+        count_code_region,\n         crate_id,\n         crate_in_paths,\n         crate_local,"}, {"sha": "2570025959cb4f7320010f63837a7444209bd402", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -1,5 +1,5 @@\n use super::method::MethodCallee;\n-use super::{FnCtxt, Needs, PlaceOp};\n+use super::{FnCtxt, PlaceOp};\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n@@ -170,14 +170,13 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n     }\n \n     /// Returns the adjustment steps.\n-    pub fn adjust_steps(&self, fcx: &FnCtxt<'a, 'tcx>, needs: Needs) -> Vec<Adjustment<'tcx>> {\n-        fcx.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(fcx, needs))\n+    pub fn adjust_steps(&self, fcx: &FnCtxt<'a, 'tcx>) -> Vec<Adjustment<'tcx>> {\n+        fcx.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(fcx))\n     }\n \n     pub fn adjust_steps_as_infer_ok(\n         &self,\n         fcx: &FnCtxt<'a, 'tcx>,\n-        needs: Needs,\n     ) -> InferOk<'tcx, Vec<Adjustment<'tcx>>> {\n         let mut obligations = vec![];\n         let targets = self.steps.iter().skip(1).map(|&(ty, _)| ty).chain(iter::once(self.cur_ty));\n@@ -186,7 +185,7 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n             .iter()\n             .map(|&(source, kind)| {\n                 if let AutoderefKind::Overloaded = kind {\n-                    fcx.try_overloaded_deref(self.span, source, needs).and_then(\n+                    fcx.try_overloaded_deref(self.span, source).and_then(\n                         |InferOk { value: method, obligations: o }| {\n                             obligations.extend(o);\n                             if let ty::Ref(region, _, mutbl) = method.sig.output().kind {\n@@ -266,8 +265,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         span: Span,\n         base_ty: Ty<'tcx>,\n-        needs: Needs,\n     ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n-        self.try_overloaded_place_op(span, base_ty, &[], needs, PlaceOp::Deref)\n+        self.try_overloaded_place_op(span, base_ty, &[], PlaceOp::Deref)\n     }\n }"}, {"sha": "fe200a0ad2a1c09423999f77a1daa5a7a7aabe24", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -1,6 +1,6 @@\n use super::autoderef::Autoderef;\n use super::method::MethodCallee;\n-use super::{Expectation, FnCtxt, Needs, TupleArgumentsFlag};\n+use super::{Expectation, FnCtxt, TupleArgumentsFlag};\n use crate::type_error_struct;\n \n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n@@ -115,7 +115,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // If the callee is a bare function or a closure, then we're all set.\n         match adjusted_ty.kind {\n             ty::FnDef(..) | ty::FnPtr(_) => {\n-                let adjustments = autoderef.adjust_steps(self, Needs::None);\n+                let adjustments = autoderef.adjust_steps(self);\n                 self.apply_adjustments(callee_expr, adjustments);\n                 return Some(CallStep::Builtin(adjusted_ty));\n             }\n@@ -135,7 +135,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             &closure_sig,\n                         )\n                         .0;\n-                    let adjustments = autoderef.adjust_steps(self, Needs::None);\n+                    let adjustments = autoderef.adjust_steps(self);\n                     self.record_deferred_call_resolution(\n                         def_id,\n                         DeferredCallResolution {\n@@ -176,7 +176,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.try_overloaded_call_traits(call_expr, adjusted_ty, Some(arg_exprs))\n             .or_else(|| self.try_overloaded_call_traits(call_expr, adjusted_ty, None))\n             .map(|(autoref, method)| {\n-                let mut adjustments = autoderef.adjust_steps(self, Needs::None);\n+                let mut adjustments = autoderef.adjust_steps(self);\n                 adjustments.extend(autoref);\n                 self.apply_adjustments(callee_expr, adjustments);\n                 CallStep::Overloaded(method)\n@@ -220,21 +220,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let method = self.register_infer_ok_obligations(ok);\n                 let mut autoref = None;\n                 if borrow {\n-                    if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind {\n-                        let mutbl = match mutbl {\n-                            hir::Mutability::Not => AutoBorrowMutability::Not,\n-                            hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                                // For initial two-phase borrow\n-                                // deployment, conservatively omit\n-                                // overloaded function call ops.\n-                                allow_two_phase_borrow: AllowTwoPhase::No,\n-                            },\n-                        };\n-                        autoref = Some(Adjustment {\n-                            kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n-                            target: method.sig.inputs()[0],\n-                        });\n-                    }\n+                    // Check for &self vs &mut self in the method signature. Since this is either\n+                    // the Fn or FnMut trait, it should be one of those.\n+                    let (region, mutbl) = if let ty::Ref(r, _, mutbl) = method.sig.inputs()[0].kind\n+                    {\n+                        (r, mutbl)\n+                    } else {\n+                        span_bug!(call_expr.span, \"input to call/call_mut is not a ref?\");\n+                    };\n+\n+                    let mutbl = match mutbl {\n+                        hir::Mutability::Not => AutoBorrowMutability::Not,\n+                        hir::Mutability::Mut => AutoBorrowMutability::Mut {\n+                            // For initial two-phase borrow\n+                            // deployment, conservatively omit\n+                            // overloaded function call ops.\n+                            allow_two_phase_borrow: AllowTwoPhase::No,\n+                        },\n+                    };\n+                    autoref = Some(Adjustment {\n+                        kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n+                        target: method.sig.inputs()[0],\n+                    });\n                 }\n                 return Some((autoref, method));\n             }"}, {"sha": "1c34d71ee31847dcdb7cff52e53c319aac472ce4", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -51,7 +51,7 @@\n //! we may want to adjust precisely when coercions occur.\n \n use crate::astconv::AstConv;\n-use crate::check::{FnCtxt, Needs};\n+use crate::check::FnCtxt;\n use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -421,9 +421,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             return success(vec![], ty, obligations);\n         }\n \n-        let needs = Needs::maybe_mut_place(mutbl_b);\n         let InferOk { value: mut adjustments, obligations: o } =\n-            autoderef.adjust_steps_as_infer_ok(self, needs);\n+            autoderef.adjust_steps_as_infer_ok(self);\n         obligations.extend(o);\n         obligations.extend(autoderef.into_obligations());\n "}, {"sha": "188f4a9401422fe65dff2048295808f09219a2f4", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 30, "deletions": 57, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -29,9 +29,7 @@ use rustc_hir::{ExprKind, QPath};\n use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::ty;\n-use rustc_middle::ty::adjustment::{\n-    Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n-};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase};\n use rustc_middle::ty::Ty;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{AdtKind, Visibility};\n@@ -113,12 +111,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.check_expr_with_expectation(expr, ExpectHasType(expected))\n     }\n \n-    pub(super) fn check_expr_with_expectation(\n+    fn check_expr_with_expectation_and_needs(\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n+        needs: Needs,\n     ) -> Ty<'tcx> {\n-        self.check_expr_with_expectation_and_needs(expr, expected, Needs::None)\n+        let ty = self.check_expr_with_expectation(expr, expected);\n+\n+        // If the expression is used in a place whether mutable place is required\n+        // e.g. LHS of assignment, perform the conversion.\n+        if let Needs::MutPlace = needs {\n+            self.convert_place_derefs_to_mutable(expr);\n+        }\n+\n+        ty\n     }\n \n     pub(super) fn check_expr(&self, expr: &'tcx hir::Expr<'tcx>) -> Ty<'tcx> {\n@@ -143,11 +150,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Note that inspecting a type's structure *directly* may expose the fact\n     /// that there are actually multiple representations for `Error`, so avoid\n     /// that when err needs to be handled differently.\n-    fn check_expr_with_expectation_and_needs(\n+    pub(super) fn check_expr_with_expectation(\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n-        needs: Needs,\n     ) -> Ty<'tcx> {\n         debug!(\">> type-checking: expr={:?} expected={:?}\", expr, expected);\n \n@@ -171,7 +177,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let old_diverges = self.diverges.replace(Diverges::Maybe);\n         let old_has_errors = self.has_errors.replace(false);\n \n-        let ty = self.check_expr_kind(expr, expected, needs);\n+        let ty = self.check_expr_kind(expr, expected);\n \n         // Warn for non-block expressions with diverging children.\n         match expr.kind {\n@@ -213,9 +219,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n-        needs: Needs,\n     ) -> Ty<'tcx> {\n-        debug!(\"check_expr_kind(expr={:?}, expected={:?}, needs={:?})\", expr, expected, needs,);\n+        debug!(\"check_expr_kind(expr={:?}, expected={:?})\", expr, expected);\n \n         let tcx = self.tcx;\n         match expr.kind {\n@@ -226,9 +231,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_expr_assign(expr, expected, lhs, rhs, span)\n             }\n             ExprKind::AssignOp(op, ref lhs, ref rhs) => self.check_binop_assign(expr, op, lhs, rhs),\n-            ExprKind::Unary(unop, ref oprnd) => {\n-                self.check_expr_unary(unop, oprnd, expected, needs, expr)\n-            }\n+            ExprKind::Unary(unop, ref oprnd) => self.check_expr_unary(unop, oprnd, expected, expr),\n             ExprKind::AddrOf(kind, mutbl, ref oprnd) => {\n                 self.check_expr_addr_of(kind, mutbl, oprnd, expected, expr)\n             }\n@@ -264,7 +267,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Block(ref body, _) => self.check_block_with_expected(&body, expected),\n             ExprKind::Call(ref callee, ref args) => self.check_call(expr, &callee, args, expected),\n             ExprKind::MethodCall(ref segment, span, ref args, _) => {\n-                self.check_method_call(expr, segment, span, args, expected, needs)\n+                self.check_method_call(expr, segment, span, args, expected)\n             }\n             ExprKind::Cast(ref e, ref t) => self.check_expr_cast(e, t, expr),\n             ExprKind::Type(ref e, ref t) => {\n@@ -281,8 +284,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Struct(ref qpath, fields, ref base_expr) => {\n                 self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n             }\n-            ExprKind::Field(ref base, field) => self.check_field(expr, needs, &base, field),\n-            ExprKind::Index(ref base, ref idx) => self.check_expr_index(base, idx, needs, expr),\n+            ExprKind::Field(ref base, field) => self.check_field(expr, &base, field),\n+            ExprKind::Index(ref base, ref idx) => self.check_expr_index(base, idx, expr),\n             ExprKind::Yield(ref value, ref src) => self.check_expr_yield(value, expr, src),\n             hir::ExprKind::Err => tcx.ty_error(),\n         }\n@@ -302,48 +305,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         unop: hir::UnOp,\n         oprnd: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n-        needs: Needs,\n         expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let expected_inner = match unop {\n             hir::UnOp::UnNot | hir::UnOp::UnNeg => expected,\n             hir::UnOp::UnDeref => NoExpectation,\n         };\n-        let needs = match unop {\n-            hir::UnOp::UnDeref => needs,\n-            _ => Needs::None,\n-        };\n-        let mut oprnd_t = self.check_expr_with_expectation_and_needs(&oprnd, expected_inner, needs);\n+        let mut oprnd_t = self.check_expr_with_expectation(&oprnd, expected_inner);\n \n         if !oprnd_t.references_error() {\n             oprnd_t = self.structurally_resolved_type(expr.span, oprnd_t);\n             match unop {\n                 hir::UnOp::UnDeref => {\n-                    if let Some(mt) = oprnd_t.builtin_deref(true) {\n-                        oprnd_t = mt.ty;\n-                    } else if let Some(ok) = self.try_overloaded_deref(expr.span, oprnd_t, needs) {\n-                        let method = self.register_infer_ok_obligations(ok);\n-                        if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind {\n-                            let mutbl = match mutbl {\n-                                hir::Mutability::Not => AutoBorrowMutability::Not,\n-                                hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                                    // (It shouldn't actually matter for unary ops whether\n-                                    // we enable two-phase borrows or not, since a unary\n-                                    // op has no additional operands.)\n-                                    allow_two_phase_borrow: AllowTwoPhase::No,\n-                                },\n-                            };\n-                            self.apply_adjustments(\n-                                oprnd,\n-                                vec![Adjustment {\n-                                    kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n-                                    target: method.sig.inputs()[0],\n-                                }],\n-                            );\n-                        }\n-                        oprnd_t = self.make_overloaded_place_return_type(method).ty;\n-                        self.write_method_call(expr.hir_id, method);\n+                    if let Some(ty) = self.lookup_derefing(expr, oprnd, oprnd_t) {\n+                        oprnd_t = ty;\n                     } else {\n                         let mut err = type_error_struct!(\n                             tcx.sess,\n@@ -405,8 +381,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 _ => NoExpectation,\n             }\n         });\n-        let needs = Needs::maybe_mut_place(mutbl);\n-        let ty = self.check_expr_with_expectation_and_needs(&oprnd, hint, needs);\n+        let ty =\n+            self.check_expr_with_expectation_and_needs(&oprnd, hint, Needs::maybe_mut_place(mutbl));\n \n         let tm = ty::TypeAndMut { ty, mutbl };\n         match kind {\n@@ -861,10 +837,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         args: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n-        needs: Needs,\n     ) -> Ty<'tcx> {\n         let rcvr = &args[0];\n-        let rcvr_t = self.check_expr_with_needs(&rcvr, needs);\n+        let rcvr_t = self.check_expr(&rcvr);\n         // no need to check for bot/err -- callee does that\n         let rcvr_t = self.structurally_resolved_type(args[0].span, rcvr_t);\n \n@@ -1443,11 +1418,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_field(\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n-        needs: Needs,\n         base: &'tcx hir::Expr<'tcx>,\n         field: Ident,\n     ) -> Ty<'tcx> {\n-        let expr_t = self.check_expr_with_needs(base, needs);\n+        let expr_t = self.check_expr(base);\n         let expr_t = self.structurally_resolved_type(base.span, expr_t);\n         let mut private_candidate = None;\n         let mut autoderef = self.autoderef(expr.span, expr_t);\n@@ -1467,7 +1441,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // of error recovery.\n                         self.write_field_index(expr.hir_id, index);\n                         if field.vis.is_accessible_from(def_scope, self.tcx) {\n-                            let adjustments = autoderef.adjust_steps(self, needs);\n+                            let adjustments = autoderef.adjust_steps(self);\n                             self.apply_adjustments(base, adjustments);\n                             autoderef.finalize(self);\n \n@@ -1482,7 +1456,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if let Ok(index) = fstr.parse::<usize>() {\n                         if fstr == index.to_string() {\n                             if let Some(field_ty) = tys.get(index) {\n-                                let adjustments = autoderef.adjust_steps(self, needs);\n+                                let adjustments = autoderef.adjust_steps(self);\n                                 self.apply_adjustments(base, adjustments);\n                                 autoderef.finalize(self);\n \n@@ -1721,10 +1695,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         base: &'tcx hir::Expr<'tcx>,\n         idx: &'tcx hir::Expr<'tcx>,\n-        needs: Needs,\n         expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n-        let base_t = self.check_expr_with_needs(&base, needs);\n+        let base_t = self.check_expr(&base);\n         let idx_t = self.check_expr(&idx);\n \n         if base_t.references_error() {\n@@ -1733,7 +1706,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             idx_t\n         } else {\n             let base_t = self.structurally_resolved_type(base.span, base_t);\n-            match self.lookup_indexing(expr, base, base_t, idx_t, needs) {\n+            match self.lookup_indexing(expr, base, base_t, idx_t) {\n                 Some((index_ty, element_ty)) => {\n                     // two-phase not needed because index_ty is never mutable\n                     self.demand_coerce(idx, idx_t, index_ty, None, AllowTwoPhase::No);"}, {"sha": "3ec6973a17d567fb704eb158d5605ce28d682c00", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -347,6 +347,8 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 return;\n             }\n \n+            \"count_code_region\" => (0, vec![tcx.types.u32], tcx.mk_unit()),\n+\n             ref other => {\n                 struct_span_err!(\n                     tcx.sess,"}, {"sha": "6844c9416af8a7a1a6a9c5b37a14afe11cb1ef4a", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 3, "deletions": 153, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -1,12 +1,12 @@\n use super::{probe, MethodCallee};\n \n use crate::astconv::AstConv;\n-use crate::check::{callee, FnCtxt, Needs, PlaceOp};\n+use crate::check::{callee, FnCtxt};\n use crate::hir::def_id::DefId;\n use crate::hir::GenericArg;\n use rustc_hir as hir;\n use rustc_infer::infer::{self, InferOk};\n-use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref, PointerCast};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, PointerCast};\n use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n@@ -119,11 +119,6 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n \n         // Create the final `MethodCallee`.\n         let callee = MethodCallee { def_id: pick.item.def_id, substs: all_substs, sig: method_sig };\n-\n-        if let Some(hir::Mutability::Mut) = pick.autoref {\n-            self.convert_place_derefs_to_mutable();\n-        }\n-\n         ConfirmResult { callee, illegal_sized_bound }\n     }\n \n@@ -149,7 +144,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         };\n         assert_eq!(n, pick.autoderefs);\n \n-        let mut adjustments = autoderef.adjust_steps(self, Needs::None);\n+        let mut adjustments = autoderef.adjust_steps(self);\n \n         let mut target = autoderef.unambiguous_final_ty(self);\n \n@@ -415,151 +410,6 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         self.register_wf_obligation(fty.into(), self.span, traits::MiscObligation);\n     }\n \n-    ///////////////////////////////////////////////////////////////////////////\n-    // RECONCILIATION\n-\n-    /// When we select a method with a mutable autoref, we have to go convert any\n-    /// auto-derefs, indices, etc from `Deref` and `Index` into `DerefMut` and `IndexMut`\n-    /// respectively.\n-    fn convert_place_derefs_to_mutable(&self) {\n-        // Gather up expressions we want to munge.\n-        let mut exprs = vec![self.self_expr];\n-\n-        loop {\n-            match exprs.last().unwrap().kind {\n-                hir::ExprKind::Field(ref expr, _)\n-                | hir::ExprKind::Index(ref expr, _)\n-                | hir::ExprKind::Unary(hir::UnOp::UnDeref, ref expr) => exprs.push(&expr),\n-                _ => break,\n-            }\n-        }\n-\n-        debug!(\"convert_place_derefs_to_mutable: exprs={:?}\", exprs);\n-\n-        // Fix up autoderefs and derefs.\n-        for (i, &expr) in exprs.iter().rev().enumerate() {\n-            debug!(\"convert_place_derefs_to_mutable: i={} expr={:?}\", i, expr);\n-\n-            // Fix up the autoderefs. Autorefs can only occur immediately preceding\n-            // overloaded place ops, and will be fixed by them in order to get\n-            // the correct region.\n-            let mut source = self.node_ty(expr.hir_id);\n-            // Do not mutate adjustments in place, but rather take them,\n-            // and replace them after mutating them, to avoid having the\n-            // tables borrowed during (`deref_mut`) method resolution.\n-            let previous_adjustments =\n-                self.tables.borrow_mut().adjustments_mut().remove(expr.hir_id);\n-            if let Some(mut adjustments) = previous_adjustments {\n-                let needs = Needs::MutPlace;\n-                for adjustment in &mut adjustments {\n-                    if let Adjust::Deref(Some(ref mut deref)) = adjustment.kind {\n-                        if let Some(ok) = self.try_overloaded_deref(expr.span, source, needs) {\n-                            let method = self.register_infer_ok_obligations(ok);\n-                            if let ty::Ref(region, _, mutbl) = method.sig.output().kind {\n-                                *deref = OverloadedDeref { region, mutbl };\n-                            }\n-                        }\n-                    }\n-                    source = adjustment.target;\n-                }\n-                self.tables.borrow_mut().adjustments_mut().insert(expr.hir_id, adjustments);\n-            }\n-\n-            match expr.kind {\n-                hir::ExprKind::Index(ref base_expr, ref index_expr) => {\n-                    // We need to get the final type in case dereferences were needed for the trait\n-                    // to apply (#72002).\n-                    let index_expr_ty = self.tables.borrow().expr_ty_adjusted(index_expr);\n-                    self.convert_place_op_to_mutable(\n-                        PlaceOp::Index,\n-                        expr,\n-                        base_expr,\n-                        &[index_expr_ty],\n-                    );\n-                }\n-                hir::ExprKind::Unary(hir::UnOp::UnDeref, ref base_expr) => {\n-                    self.convert_place_op_to_mutable(PlaceOp::Deref, expr, base_expr, &[]);\n-                }\n-                _ => {}\n-            }\n-        }\n-    }\n-\n-    fn convert_place_op_to_mutable(\n-        &self,\n-        op: PlaceOp,\n-        expr: &hir::Expr<'_>,\n-        base_expr: &hir::Expr<'_>,\n-        arg_tys: &[Ty<'tcx>],\n-    ) {\n-        debug!(\"convert_place_op_to_mutable({:?}, {:?}, {:?}, {:?})\", op, expr, base_expr, arg_tys);\n-        if !self.tables.borrow().is_method_call(expr) {\n-            debug!(\"convert_place_op_to_mutable - builtin, nothing to do\");\n-            return;\n-        }\n-\n-        let base_ty = self\n-            .tables\n-            .borrow()\n-            .expr_adjustments(base_expr)\n-            .last()\n-            .map_or_else(|| self.node_ty(expr.hir_id), |adj| adj.target);\n-        let base_ty = self.resolve_vars_if_possible(&base_ty);\n-\n-        // Need to deref because overloaded place ops take self by-reference.\n-        let base_ty =\n-            base_ty.builtin_deref(false).expect(\"place op takes something that is not a ref\").ty;\n-\n-        let method = self.try_overloaded_place_op(expr.span, base_ty, arg_tys, Needs::MutPlace, op);\n-        let method = match method {\n-            Some(ok) => self.register_infer_ok_obligations(ok),\n-            None => return self.tcx.sess.delay_span_bug(expr.span, \"re-trying op failed\"),\n-        };\n-        debug!(\"convert_place_op_to_mutable: method={:?}\", method);\n-        self.write_method_call(expr.hir_id, method);\n-\n-        let (region, mutbl) = if let ty::Ref(r, _, mutbl) = method.sig.inputs()[0].kind {\n-            (r, mutbl)\n-        } else {\n-            span_bug!(expr.span, \"input to place op is not a ref?\");\n-        };\n-\n-        // Convert the autoref in the base expr to mutable with the correct\n-        // region and mutability.\n-        let base_expr_ty = self.node_ty(base_expr.hir_id);\n-        if let Some(adjustments) =\n-            self.tables.borrow_mut().adjustments_mut().get_mut(base_expr.hir_id)\n-        {\n-            let mut source = base_expr_ty;\n-            for adjustment in &mut adjustments[..] {\n-                if let Adjust::Borrow(AutoBorrow::Ref(..)) = adjustment.kind {\n-                    debug!(\"convert_place_op_to_mutable: converting autoref {:?}\", adjustment);\n-                    let mutbl = match mutbl {\n-                        hir::Mutability::Not => AutoBorrowMutability::Not,\n-                        hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                            // For initial two-phase borrow\n-                            // deployment, conservatively omit\n-                            // overloaded operators.\n-                            allow_two_phase_borrow: AllowTwoPhase::No,\n-                        },\n-                    };\n-                    adjustment.kind = Adjust::Borrow(AutoBorrow::Ref(region, mutbl));\n-                    adjustment.target =\n-                        self.tcx.mk_ref(region, ty::TypeAndMut { ty: source, mutbl: mutbl.into() });\n-                }\n-                source = adjustment.target;\n-            }\n-\n-            // If we have an autoref followed by unsizing at the end, fix the unsize target.\n-\n-            if let [.., Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(..)), .. }, Adjustment { kind: Adjust::Pointer(PointerCast::Unsize), ref mut target }] =\n-                adjustments[..]\n-            {\n-                *target = method.sig.inputs()[0];\n-            }\n-        }\n-    }\n-\n     ///////////////////////////////////////////////////////////////////////////\n     // MISCELLANY\n "}, {"sha": "2ece8e8c2842369a8c7fe0ea88413700eab89560", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 150, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -79,6 +79,7 @@ pub mod intrinsic;\n pub mod method;\n mod op;\n mod pat;\n+mod place_op;\n mod regionck;\n mod upvar;\n mod wfcheck;\n@@ -114,7 +115,7 @@ use rustc_infer::infer::{InferCtxt, InferOk, InferResult, RegionVariableOrigin,\n use rustc_middle::hir::map::blocks::FnLikeNode;\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::adjustment::{\n-    Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability, PointerCast,\n+    Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::query::Providers;\n@@ -156,7 +157,6 @@ use std::slice;\n use crate::require_c_abi_if_c_variadic;\n use crate::util::common::indenter;\n \n-use self::autoderef::Autoderef;\n use self::callee::DeferredCallResolution;\n use self::coercion::{CoerceMany, DynamicCoerceMany};\n use self::compare_method::{compare_const_impl, compare_impl_method, compare_ty_impl};\n@@ -3333,6 +3333,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return;\n         }\n \n+        let autoborrow_mut = adj.iter().any(|adj| {\n+            matches!(adj, &Adjustment {\n+                kind: Adjust::Borrow(AutoBorrow::Ref(_, AutoBorrowMutability::Mut { .. })),\n+                ..\n+            })\n+        });\n+\n         match self.tables.borrow_mut().adjustments_mut().entry(expr.hir_id) {\n             Entry::Vacant(entry) => {\n                 entry.insert(adj);\n@@ -3362,6 +3369,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 *entry.get_mut() = adj;\n             }\n         }\n+\n+        // If there is an mutable auto-borrow, it is equivalent to `&mut <expr>`.\n+        // In this case implicit use of `Deref` and `Index` within `<expr>` should\n+        // instead be `DerefMut` and `IndexMut`, so fix those up.\n+        if autoborrow_mut {\n+            self.convert_place_derefs_to_mutable(expr);\n+        }\n     }\n \n     /// Basically whenever we are converting from a type scheme into\n@@ -3753,154 +3767,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ret_ty.builtin_deref(true).unwrap()\n     }\n \n-    fn lookup_indexing(\n-        &self,\n-        expr: &hir::Expr<'_>,\n-        base_expr: &'tcx hir::Expr<'tcx>,\n-        base_ty: Ty<'tcx>,\n-        idx_ty: Ty<'tcx>,\n-        needs: Needs,\n-    ) -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)> {\n-        // FIXME(#18741) -- this is almost but not quite the same as the\n-        // autoderef that normal method probing does. They could likely be\n-        // consolidated.\n-\n-        let mut autoderef = self.autoderef(base_expr.span, base_ty);\n-        let mut result = None;\n-        while result.is_none() && autoderef.next().is_some() {\n-            result = self.try_index_step(expr, base_expr, &autoderef, needs, idx_ty);\n-        }\n-        autoderef.finalize(self);\n-        result\n-    }\n-\n-    /// To type-check `base_expr[index_expr]`, we progressively autoderef\n-    /// (and otherwise adjust) `base_expr`, looking for a type which either\n-    /// supports builtin indexing or overloaded indexing.\n-    /// This loop implements one step in that search; the autoderef loop\n-    /// is implemented by `lookup_indexing`.\n-    fn try_index_step(\n-        &self,\n-        expr: &hir::Expr<'_>,\n-        base_expr: &hir::Expr<'_>,\n-        autoderef: &Autoderef<'a, 'tcx>,\n-        needs: Needs,\n-        index_ty: Ty<'tcx>,\n-    ) -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)> {\n-        let adjusted_ty = autoderef.unambiguous_final_ty(self);\n-        debug!(\n-            \"try_index_step(expr={:?}, base_expr={:?}, adjusted_ty={:?}, \\\n-             index_ty={:?})\",\n-            expr, base_expr, adjusted_ty, index_ty\n-        );\n-\n-        for &unsize in &[false, true] {\n-            let mut self_ty = adjusted_ty;\n-            if unsize {\n-                // We only unsize arrays here.\n-                if let ty::Array(element_ty, _) = adjusted_ty.kind {\n-                    self_ty = self.tcx.mk_slice(element_ty);\n-                } else {\n-                    continue;\n-                }\n-            }\n-\n-            // If some lookup succeeds, write callee into table and extract index/element\n-            // type from the method signature.\n-            // If some lookup succeeded, install method in table\n-            let input_ty = self.next_ty_var(TypeVariableOrigin {\n-                kind: TypeVariableOriginKind::AutoDeref,\n-                span: base_expr.span,\n-            });\n-            let method = self.try_overloaded_place_op(\n-                expr.span,\n-                self_ty,\n-                &[input_ty],\n-                needs,\n-                PlaceOp::Index,\n-            );\n-\n-            let result = method.map(|ok| {\n-                debug!(\"try_index_step: success, using overloaded indexing\");\n-                let method = self.register_infer_ok_obligations(ok);\n-\n-                let mut adjustments = autoderef.adjust_steps(self, needs);\n-                if let ty::Ref(region, _, r_mutbl) = method.sig.inputs()[0].kind {\n-                    let mutbl = match r_mutbl {\n-                        hir::Mutability::Not => AutoBorrowMutability::Not,\n-                        hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                            // Indexing can be desugared to a method call,\n-                            // so maybe we could use two-phase here.\n-                            // See the documentation of AllowTwoPhase for why that's\n-                            // not the case today.\n-                            allow_two_phase_borrow: AllowTwoPhase::No,\n-                        },\n-                    };\n-                    adjustments.push(Adjustment {\n-                        kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n-                        target: self\n-                            .tcx\n-                            .mk_ref(region, ty::TypeAndMut { mutbl: r_mutbl, ty: adjusted_ty }),\n-                    });\n-                }\n-                if unsize {\n-                    adjustments.push(Adjustment {\n-                        kind: Adjust::Pointer(PointerCast::Unsize),\n-                        target: method.sig.inputs()[0],\n-                    });\n-                }\n-                self.apply_adjustments(base_expr, adjustments);\n-\n-                self.write_method_call(expr.hir_id, method);\n-                (input_ty, self.make_overloaded_place_return_type(method).ty)\n-            });\n-            if result.is_some() {\n-                return result;\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    fn resolve_place_op(&self, op: PlaceOp, is_mut: bool) -> (Option<DefId>, Ident) {\n-        let (tr, name) = match (op, is_mut) {\n-            (PlaceOp::Deref, false) => (self.tcx.lang_items().deref_trait(), sym::deref),\n-            (PlaceOp::Deref, true) => (self.tcx.lang_items().deref_mut_trait(), sym::deref_mut),\n-            (PlaceOp::Index, false) => (self.tcx.lang_items().index_trait(), sym::index),\n-            (PlaceOp::Index, true) => (self.tcx.lang_items().index_mut_trait(), sym::index_mut),\n-        };\n-        (tr, Ident::with_dummy_span(name))\n-    }\n-\n-    fn try_overloaded_place_op(\n-        &self,\n-        span: Span,\n-        base_ty: Ty<'tcx>,\n-        arg_tys: &[Ty<'tcx>],\n-        needs: Needs,\n-        op: PlaceOp,\n-    ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n-        debug!(\"try_overloaded_place_op({:?},{:?},{:?},{:?})\", span, base_ty, needs, op);\n-\n-        // Try Mut first, if needed.\n-        let (mut_tr, mut_op) = self.resolve_place_op(op, true);\n-        let method = match (needs, mut_tr) {\n-            (Needs::MutPlace, Some(trait_did)) => {\n-                self.lookup_method_in_trait(span, mut_op, trait_did, base_ty, Some(arg_tys))\n-            }\n-            _ => None,\n-        };\n-\n-        // Otherwise, fall back to the immutable version.\n-        let (imm_tr, imm_op) = self.resolve_place_op(op, false);\n-        match (method, imm_tr) {\n-            (None, Some(trait_did)) => {\n-                self.lookup_method_in_trait(span, imm_op, trait_did, base_ty, Some(arg_tys))\n-            }\n-            (method, _) => method,\n-        }\n-    }\n-\n     fn check_method_argument_types(\n         &self,\n         sp: Span,"}, {"sha": "56804792b19442a04481e078866ac341fb5f2a69", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -1,7 +1,7 @@\n //! Code related to processing overloaded binary and unary operators.\n \n use super::method::MethodCallee;\n-use super::{FnCtxt, Needs};\n+use super::FnCtxt;\n use rustc_errors::{self, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -165,7 +165,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // trait matching creating lifetime constraints that are too strict.\n                 // e.g., adding `&'a T` and `&'b T`, given `&'x T: Add<&'x T>`, will result\n                 // in `&'a T <: &'x T` and `&'b T <: &'x T`, instead of `'a = 'b = 'x`.\n-                let lhs_ty = self.check_expr_with_needs(lhs_expr, Needs::None);\n+                let lhs_ty = self.check_expr(lhs_expr);\n                 let fresh_var = self.next_ty_var(TypeVariableOrigin {\n                     kind: TypeVariableOriginKind::MiscVariable,\n                     span: lhs_expr.span,\n@@ -177,7 +177,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // equivalence on the LHS of an assign-op like `+=`;\n                 // overwritten or mutably-borrowed places cannot be\n                 // coerced to a supertype.\n-                self.check_expr_with_needs(lhs_expr, Needs::MutPlace)\n+                self.check_expr(lhs_expr)\n             }\n         };\n         let lhs_ty = self.resolve_vars_with_obligations(lhs_ty);"}, {"sha": "d1c22cd1ac03ebe0d18747d73f5a0b6e38198517", "filename": "src/librustc_typeck/check/place_op.rs", "status": "added", "additions": 336, "deletions": 0, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -0,0 +1,336 @@\n+use crate::check::autoderef::Autoderef;\n+use crate::check::method::MethodCallee;\n+use crate::check::{FnCtxt, PlaceOp};\n+use rustc_hir as hir;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::InferOk;\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref, PointerCast};\n+use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::symbol::{sym, Ident};\n+use rustc_span::Span;\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    /// Type-check `*oprnd_expr` with `oprnd_expr` type-checked already.\n+    pub(super) fn lookup_derefing(\n+        &self,\n+        expr: &hir::Expr<'_>,\n+        oprnd_expr: &'tcx hir::Expr<'tcx>,\n+        oprnd_ty: Ty<'tcx>,\n+    ) -> Option<Ty<'tcx>> {\n+        if let Some(mt) = oprnd_ty.builtin_deref(true) {\n+            return Some(mt.ty);\n+        }\n+\n+        let ok = self.try_overloaded_deref(expr.span, oprnd_ty)?;\n+        let method = self.register_infer_ok_obligations(ok);\n+        if let ty::Ref(region, _, hir::Mutability::Not) = method.sig.inputs()[0].kind {\n+            self.apply_adjustments(\n+                oprnd_expr,\n+                vec![Adjustment {\n+                    kind: Adjust::Borrow(AutoBorrow::Ref(region, AutoBorrowMutability::Not)),\n+                    target: method.sig.inputs()[0],\n+                }],\n+            );\n+        } else {\n+            span_bug!(expr.span, \"input to deref is not a ref?\");\n+        }\n+        let ty = self.make_overloaded_place_return_type(method).ty;\n+        self.write_method_call(expr.hir_id, method);\n+        Some(ty)\n+    }\n+\n+    /// Type-check `*base_expr[index_expr]` with `base_expr` and `index_expr` type-checked already.\n+    pub(super) fn lookup_indexing(\n+        &self,\n+        expr: &hir::Expr<'_>,\n+        base_expr: &'tcx hir::Expr<'tcx>,\n+        base_ty: Ty<'tcx>,\n+        idx_ty: Ty<'tcx>,\n+    ) -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)> {\n+        // FIXME(#18741) -- this is almost but not quite the same as the\n+        // autoderef that normal method probing does. They could likely be\n+        // consolidated.\n+\n+        let mut autoderef = self.autoderef(base_expr.span, base_ty);\n+        let mut result = None;\n+        while result.is_none() && autoderef.next().is_some() {\n+            result = self.try_index_step(expr, base_expr, &autoderef, idx_ty);\n+        }\n+        autoderef.finalize(self);\n+        result\n+    }\n+\n+    /// To type-check `base_expr[index_expr]`, we progressively autoderef\n+    /// (and otherwise adjust) `base_expr`, looking for a type which either\n+    /// supports builtin indexing or overloaded indexing.\n+    /// This loop implements one step in that search; the autoderef loop\n+    /// is implemented by `lookup_indexing`.\n+    fn try_index_step(\n+        &self,\n+        expr: &hir::Expr<'_>,\n+        base_expr: &hir::Expr<'_>,\n+        autoderef: &Autoderef<'a, 'tcx>,\n+        index_ty: Ty<'tcx>,\n+    ) -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)> {\n+        let adjusted_ty = autoderef.unambiguous_final_ty(self);\n+        debug!(\n+            \"try_index_step(expr={:?}, base_expr={:?}, adjusted_ty={:?}, \\\n+             index_ty={:?})\",\n+            expr, base_expr, adjusted_ty, index_ty\n+        );\n+\n+        for &unsize in &[false, true] {\n+            let mut self_ty = adjusted_ty;\n+            if unsize {\n+                // We only unsize arrays here.\n+                if let ty::Array(element_ty, _) = adjusted_ty.kind {\n+                    self_ty = self.tcx.mk_slice(element_ty);\n+                } else {\n+                    continue;\n+                }\n+            }\n+\n+            // If some lookup succeeds, write callee into table and extract index/element\n+            // type from the method signature.\n+            // If some lookup succeeded, install method in table\n+            let input_ty = self.next_ty_var(TypeVariableOrigin {\n+                kind: TypeVariableOriginKind::AutoDeref,\n+                span: base_expr.span,\n+            });\n+            let method =\n+                self.try_overloaded_place_op(expr.span, self_ty, &[input_ty], PlaceOp::Index);\n+\n+            let result = method.map(|ok| {\n+                debug!(\"try_index_step: success, using overloaded indexing\");\n+                let method = self.register_infer_ok_obligations(ok);\n+\n+                let mut adjustments = autoderef.adjust_steps(self);\n+                if let ty::Ref(region, _, hir::Mutability::Not) = method.sig.inputs()[0].kind {\n+                    adjustments.push(Adjustment {\n+                        kind: Adjust::Borrow(AutoBorrow::Ref(region, AutoBorrowMutability::Not)),\n+                        target: self.tcx.mk_ref(\n+                            region,\n+                            ty::TypeAndMut { mutbl: hir::Mutability::Not, ty: adjusted_ty },\n+                        ),\n+                    });\n+                } else {\n+                    span_bug!(expr.span, \"input to index is not a ref?\");\n+                }\n+                if unsize {\n+                    adjustments.push(Adjustment {\n+                        kind: Adjust::Pointer(PointerCast::Unsize),\n+                        target: method.sig.inputs()[0],\n+                    });\n+                }\n+                self.apply_adjustments(base_expr, adjustments);\n+\n+                self.write_method_call(expr.hir_id, method);\n+                (input_ty, self.make_overloaded_place_return_type(method).ty)\n+            });\n+            if result.is_some() {\n+                return result;\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    /// Try to resolve an overloaded place op. We only deal with the immutable\n+    /// variant here (Deref/Index). In some contexts we would need the mutable\n+    /// variant (DerefMut/IndexMut); those would be later converted by\n+    /// `convert_place_derefs_to_mutable`.\n+    pub(super) fn try_overloaded_place_op(\n+        &self,\n+        span: Span,\n+        base_ty: Ty<'tcx>,\n+        arg_tys: &[Ty<'tcx>],\n+        op: PlaceOp,\n+    ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n+        debug!(\"try_overloaded_place_op({:?},{:?},{:?})\", span, base_ty, op);\n+\n+        let (imm_tr, imm_op) = match op {\n+            PlaceOp::Deref => (self.tcx.lang_items().deref_trait(), sym::deref),\n+            PlaceOp::Index => (self.tcx.lang_items().index_trait(), sym::index),\n+        };\n+        imm_tr.and_then(|trait_did| {\n+            self.lookup_method_in_trait(\n+                span,\n+                Ident::with_dummy_span(imm_op),\n+                trait_did,\n+                base_ty,\n+                Some(arg_tys),\n+            )\n+        })\n+    }\n+\n+    fn try_mutable_overloaded_place_op(\n+        &self,\n+        span: Span,\n+        base_ty: Ty<'tcx>,\n+        arg_tys: &[Ty<'tcx>],\n+        op: PlaceOp,\n+    ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n+        debug!(\"try_mutable_overloaded_place_op({:?},{:?},{:?})\", span, base_ty, op);\n+\n+        let (mut_tr, mut_op) = match op {\n+            PlaceOp::Deref => (self.tcx.lang_items().deref_mut_trait(), sym::deref_mut),\n+            PlaceOp::Index => (self.tcx.lang_items().index_mut_trait(), sym::index_mut),\n+        };\n+        mut_tr.and_then(|trait_did| {\n+            self.lookup_method_in_trait(\n+                span,\n+                Ident::with_dummy_span(mut_op),\n+                trait_did,\n+                base_ty,\n+                Some(arg_tys),\n+            )\n+        })\n+    }\n+\n+    /// Convert auto-derefs, indices, etc of an expression from `Deref` and `Index`\n+    /// into `DerefMut` and `IndexMut` respectively.\n+    ///\n+    /// This is a second pass of typechecking derefs/indices. We need this we do not\n+    /// always know whether a place needs to be mutable or not in the first pass.\n+    /// This happens whether there is an implicit mutable reborrow, e.g. when the type\n+    /// is used as the receiver of a method call.\n+    pub fn convert_place_derefs_to_mutable(&self, expr: &hir::Expr<'_>) {\n+        // Gather up expressions we want to munge.\n+        let mut exprs = vec![expr];\n+\n+        loop {\n+            match exprs.last().unwrap().kind {\n+                hir::ExprKind::Field(ref expr, _)\n+                | hir::ExprKind::Index(ref expr, _)\n+                | hir::ExprKind::Unary(hir::UnOp::UnDeref, ref expr) => exprs.push(&expr),\n+                _ => break,\n+            }\n+        }\n+\n+        debug!(\"convert_place_derefs_to_mutable: exprs={:?}\", exprs);\n+\n+        // Fix up autoderefs and derefs.\n+        for (i, &expr) in exprs.iter().rev().enumerate() {\n+            debug!(\"convert_place_derefs_to_mutable: i={} expr={:?}\", i, expr);\n+\n+            // Fix up the autoderefs. Autorefs can only occur immediately preceding\n+            // overloaded place ops, and will be fixed by them in order to get\n+            // the correct region.\n+            let mut source = self.node_ty(expr.hir_id);\n+            // Do not mutate adjustments in place, but rather take them,\n+            // and replace them after mutating them, to avoid having the\n+            // tables borrowed during (`deref_mut`) method resolution.\n+            let previous_adjustments =\n+                self.tables.borrow_mut().adjustments_mut().remove(expr.hir_id);\n+            if let Some(mut adjustments) = previous_adjustments {\n+                for adjustment in &mut adjustments {\n+                    if let Adjust::Deref(Some(ref mut deref)) = adjustment.kind {\n+                        if let Some(ok) = self.try_mutable_overloaded_place_op(\n+                            expr.span,\n+                            source,\n+                            &[],\n+                            PlaceOp::Deref,\n+                        ) {\n+                            let method = self.register_infer_ok_obligations(ok);\n+                            if let ty::Ref(region, _, mutbl) = method.sig.output().kind {\n+                                *deref = OverloadedDeref { region, mutbl };\n+                            }\n+                        }\n+                    }\n+                    source = adjustment.target;\n+                }\n+                self.tables.borrow_mut().adjustments_mut().insert(expr.hir_id, adjustments);\n+            }\n+\n+            match expr.kind {\n+                hir::ExprKind::Index(ref base_expr, ref index_expr) => {\n+                    // We need to get the final type in case dereferences were needed for the trait\n+                    // to apply (#72002).\n+                    let index_expr_ty = self.tables.borrow().expr_ty_adjusted(index_expr);\n+                    self.convert_place_op_to_mutable(\n+                        PlaceOp::Index,\n+                        expr,\n+                        base_expr,\n+                        &[index_expr_ty],\n+                    );\n+                }\n+                hir::ExprKind::Unary(hir::UnOp::UnDeref, ref base_expr) => {\n+                    self.convert_place_op_to_mutable(PlaceOp::Deref, expr, base_expr, &[]);\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+\n+    fn convert_place_op_to_mutable(\n+        &self,\n+        op: PlaceOp,\n+        expr: &hir::Expr<'_>,\n+        base_expr: &hir::Expr<'_>,\n+        arg_tys: &[Ty<'tcx>],\n+    ) {\n+        debug!(\"convert_place_op_to_mutable({:?}, {:?}, {:?}, {:?})\", op, expr, base_expr, arg_tys);\n+        if !self.tables.borrow().is_method_call(expr) {\n+            debug!(\"convert_place_op_to_mutable - builtin, nothing to do\");\n+            return;\n+        }\n+\n+        // Need to deref because overloaded place ops take self by-reference.\n+        let base_ty = self\n+            .tables\n+            .borrow()\n+            .expr_ty_adjusted(base_expr)\n+            .builtin_deref(false)\n+            .expect(\"place op takes something that is not a ref\")\n+            .ty;\n+\n+        let method = self.try_mutable_overloaded_place_op(expr.span, base_ty, arg_tys, op);\n+        let method = match method {\n+            Some(ok) => self.register_infer_ok_obligations(ok),\n+            // Couldn't find the mutable variant of the place op, keep the\n+            // current, immutable version.\n+            None => return,\n+        };\n+        debug!(\"convert_place_op_to_mutable: method={:?}\", method);\n+        self.write_method_call(expr.hir_id, method);\n+\n+        let region = if let ty::Ref(r, _, hir::Mutability::Mut) = method.sig.inputs()[0].kind {\n+            r\n+        } else {\n+            span_bug!(expr.span, \"input to mutable place op is not a mut ref?\");\n+        };\n+\n+        // Convert the autoref in the base expr to mutable with the correct\n+        // region and mutability.\n+        let base_expr_ty = self.node_ty(base_expr.hir_id);\n+        if let Some(adjustments) =\n+            self.tables.borrow_mut().adjustments_mut().get_mut(base_expr.hir_id)\n+        {\n+            let mut source = base_expr_ty;\n+            for adjustment in &mut adjustments[..] {\n+                if let Adjust::Borrow(AutoBorrow::Ref(..)) = adjustment.kind {\n+                    debug!(\"convert_place_op_to_mutable: converting autoref {:?}\", adjustment);\n+                    let mutbl = AutoBorrowMutability::Mut {\n+                        // Deref/indexing can be desugared to a method call,\n+                        // so maybe we could use two-phase here.\n+                        // See the documentation of AllowTwoPhase for why that's\n+                        // not the case today.\n+                        allow_two_phase_borrow: AllowTwoPhase::No,\n+                    };\n+                    adjustment.kind = Adjust::Borrow(AutoBorrow::Ref(region, mutbl));\n+                    adjustment.target =\n+                        self.tcx.mk_ref(region, ty::TypeAndMut { ty: source, mutbl: mutbl.into() });\n+                }\n+                source = adjustment.target;\n+            }\n+\n+            // If we have an autoref followed by unsizing at the end, fix the unsize target.\n+            if let [.., Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(..)), .. }, Adjustment { kind: Adjust::Pointer(PointerCast::Unsize), ref mut target }] =\n+                adjustments[..]\n+            {\n+                *target = method.sig.inputs()[0];\n+            }\n+        }\n+    }\n+}"}, {"sha": "cdb3a157eab97bc408dceb86f44d79d923025db1", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -5,6 +5,7 @@\n #include \"llvm/IR/DiagnosticPrinter.h\"\n #include \"llvm/IR/GlobalVariable.h\"\n #include \"llvm/IR/Instructions.h\"\n+#include \"llvm/IR/Intrinsics.h\"\n #include \"llvm/Object/Archive.h\"\n #include \"llvm/Object/ObjectFile.h\"\n #include \"llvm/Bitcode/BitcodeWriterPass.h\"\n@@ -1364,6 +1365,11 @@ extern \"C\" LLVMValueRef LLVMRustBuildCall(LLVMBuilderRef B, LLVMValueRef Fn,\n       unwrap(Fn), makeArrayRef(unwrap(Args), NumArgs), Bundles));\n }\n \n+extern \"C\" LLVMValueRef LLVMRustGetInstrprofIncrementIntrinsic(LLVMModuleRef M) {\n+  return wrap(llvm::Intrinsic::getDeclaration(unwrap(M),\n+              (llvm::Intrinsic::ID)llvm::Intrinsic::instrprof_increment));\n+}\n+\n extern \"C\" LLVMValueRef LLVMRustBuildMemCpy(LLVMBuilderRef B,\n                                             LLVMValueRef Dst, unsigned DstAlign,\n                                             LLVMValueRef Src, unsigned SrcAlign,"}, {"sha": "25195743b04007360ab92f5e8cf6d337ee021333", "filename": "src/test/codegen-units/partitioning/compiler-builtins.rs", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fcompiler-builtins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fcompiler-builtins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fcompiler-builtins.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -1,40 +0,0 @@\n-// Verifies that during compiler_builtins compilation the codegen units are kept\n-// unmerged. Even when only a single codegen unit is requested with -Ccodegen-units=1.\n-//\n-// compile-flags: -Zprint-mono-items=eager -Ccodegen-units=1\n-\n-#![compiler_builtins]\n-#![crate_type=\"lib\"]\n-#![feature(compiler_builtins)]\n-\n-mod atomics {\n-    //~ MONO_ITEM fn compiler_builtins::atomics[0]::sync_1[0] @@ compiler_builtins-cgu.0[External]\n-    #[no_mangle]\n-    pub extern \"C\" fn sync_1() {}\n-\n-    //~ MONO_ITEM fn compiler_builtins::atomics[0]::sync_2[0] @@ compiler_builtins-cgu.0[External]\n-    #[no_mangle]\n-    pub extern \"C\" fn sync_2() {}\n-\n-    //~ MONO_ITEM fn compiler_builtins::atomics[0]::sync_3[0] @@ compiler_builtins-cgu.0[External]\n-    #[no_mangle]\n-    pub extern \"C\" fn sync_3() {}\n-}\n-\n-mod x {\n-    //~ MONO_ITEM fn compiler_builtins::x[0]::x[0] @@ compiler_builtins-cgu.1[External]\n-    #[no_mangle]\n-    pub extern \"C\" fn x() {}\n-}\n-\n-mod y {\n-    //~ MONO_ITEM fn compiler_builtins::y[0]::y[0] @@ compiler_builtins-cgu.2[External]\n-    #[no_mangle]\n-    pub extern \"C\" fn y() {}\n-}\n-\n-mod z {\n-    //~ MONO_ITEM fn compiler_builtins::z[0]::z[0] @@ compiler_builtins-cgu.3[External]\n-    #[no_mangle]\n-    pub extern \"C\" fn z() {}\n-}"}, {"sha": "4bd50508d152056e13f7ecc21d80055ab00a6a45", "filename": "src/test/codegen/sanitizer-memory-track-orgins.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fcodegen%2Fsanitizer-memory-track-orgins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fcodegen%2Fsanitizer-memory-track-orgins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-memory-track-orgins.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -1,9 +1,7 @@\n // Verifies that MemorySanitizer track-origins level can be controlled\n // with -Zsanitizer-memory-track-origins option.\n //\n-// needs-sanitizer-support\n-// only-linux\n-// only-x86_64\n+// needs-sanitizer-memory\n // revisions:MSAN-0 MSAN-1 MSAN-2 MSAN-1-LTO MSAN-2-LTO\n //\n //[MSAN-0] compile-flags: -Zsanitizer=memory"}, {"sha": "be0547afa4cd5059432123f54ab40db0549d9e94", "filename": "src/test/codegen/sanitizer-no-sanitize-inlining.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize-inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize-inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize-inlining.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -1,11 +1,9 @@\n // Verifies that no_sanitize attribute prevents inlining when\n // given sanitizer is enabled, but has no effect on inlining otherwise.\n //\n-// needs-sanitizer-support\n-// only-x86_64\n-//\n+// needs-sanitizer-address\n+// needs-sanitizer-leak\n // revisions: ASAN LSAN\n-//\n //[ASAN] compile-flags: -Zsanitizer=address -C opt-level=3 -Z mir-opt-level=3\n //[LSAN] compile-flags: -Zsanitizer=leak    -C opt-level=3 -Z mir-opt-level=3\n "}, {"sha": "1b2b18822e63e8a8c673166bcb92bd0fdb99ac2f", "filename": "src/test/codegen/sanitizer-no-sanitize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -1,7 +1,7 @@\n // Verifies that no_sanitze attribute can be used to\n // selectively disable sanitizer instrumentation.\n //\n-// needs-sanitizer-support\n+// needs-sanitizer-address\n // compile-flags: -Zsanitizer=address\n \n #![crate_type=\"lib\"]"}, {"sha": "719f219ce4ef1b9fe8cc0c1830309d352b9f142b", "filename": "src/test/codegen/sanitizer-recover.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fcodegen%2Fsanitizer-recover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fcodegen%2Fsanitizer-recover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-recover.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -1,9 +1,8 @@\n // Verifies that AddressSanitizer and MemorySanitizer\n // recovery mode can be enabled with -Zsanitizer-recover.\n //\n-// needs-sanitizer-support\n-// only-linux\n-// only-x86_64\n+// needs-sanitizer-address\n+// needs-sanitizer-memory\n // revisions:ASAN ASAN-RECOVER MSAN MSAN-RECOVER MSAN-RECOVER-LTO\n // no-prefer-dynamic\n //"}, {"sha": "15bfe421e9d35911d8e1f4ad05e3187e4fb644bd", "filename": "src/test/codegen/vec-clear.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fcodegen%2Fvec-clear.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fcodegen%2Fvec-clear.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fvec-clear.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -1,4 +1,3 @@\n-// ignore-debug: the debug assertions get in the way\n // compile-flags: -O\n \n #![crate_type = \"lib\"]"}, {"sha": "9143fad23408749b278aef4eb428397195a4db1d", "filename": "src/test/codegen/vec-optimizes-away.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fcodegen%2Fvec-optimizes-away.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fcodegen%2Fvec-optimizes-away.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fvec-optimizes-away.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -1,4 +1,3 @@\n-//\n // ignore-debug: the debug assertions get in the way\n // no-system-llvm\n // compile-flags: -O"}, {"sha": "3fe010ef68fc351abe2709c2560fdcb5ddf5e3c3", "filename": "src/test/mir-opt/instrument_coverage.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fmir-opt%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fmir-opt%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -0,0 +1,20 @@\n+// Test that the initial version of Rust coverage injects count_code_region() placeholder calls,\n+// at the top of each function. The placeholders are later converted into LLVM instrprof.increment\n+// intrinsics, during codegen.\n+\n+// needs-profiler-support\n+// compile-flags: -Zinstrument-coverage\n+// EMIT_MIR rustc.main.InstrumentCoverage.diff\n+// EMIT_MIR rustc.bar.InstrumentCoverage.diff\n+fn main() {\n+    loop {\n+        if bar() {\n+            break;\n+        }\n+    }\n+}\n+\n+#[inline(never)]\n+fn bar() -> bool {\n+    true\n+}"}, {"sha": "1e64379aa0e4b6a311e2a3aed3bd63de11cacde0", "filename": "src/test/mir-opt/instrument_coverage/rustc.bar.InstrumentCoverage.diff", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.bar.InstrumentCoverage.diff", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.bar.InstrumentCoverage.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.bar.InstrumentCoverage.diff?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -0,0 +1,41 @@\n+- // MIR for `bar` before InstrumentCoverage\n++ // MIR for `bar` after InstrumentCoverage\n+  \n+  fn bar() -> bool {\n+      let mut _0: bool;                    // return place in scope 0 at $DIR/instrument_coverage.rs:18:13: 18:17\n++     let mut _1: ();                      // in scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n+  \n+      bb0: {\n++         StorageLive(_1);                 // scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n++         _1 = const std::intrinsics::count_code_region(const 0u32) -> bb2; // scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n++                                          // ty::Const\n++                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u32) {std::intrinsics::count_code_region}\n++                                          // + val: Value(Scalar(<ZST>))\n++                                          // mir::Constant\n++                                          // + span: $DIR/instrument_coverage.rs:18:1: 18:1\n++                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n++                                          // ty::Const\n++                                          // + ty: u32\n++                                          // + val: Value(Scalar(0x00000000))\n++                                          // mir::Constant\n++                                          // + span: $DIR/instrument_coverage.rs:18:1: 18:1\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000000)) }\n++     }\n++ \n++     bb1 (cleanup): {\n++         resume;                          // scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n++     }\n++ \n++     bb2: {\n++         StorageDead(_1);                 // scope 0 at $DIR/instrument_coverage.rs:19:5: 19:9\n+          _0 = const true;                 // scope 0 at $DIR/instrument_coverage.rs:19:5: 19:9\n+                                           // ty::Const\n+                                           // + ty: bool\n+                                           // + val: Value(Scalar(0x01))\n+                                           // mir::Constant\n+                                           // + span: $DIR/instrument_coverage.rs:19:5: 19:9\n+                                           // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n+          return;                          // scope 0 at $DIR/instrument_coverage.rs:20:2: 20:2\n+      }\n+  }\n+  "}, {"sha": "82d21467827ebbcb1f35adbf7a2e57b11b3caf39", "filename": "src/test/mir-opt/instrument_coverage/rustc.main.InstrumentCoverage.diff", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.main.InstrumentCoverage.diff", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.main.InstrumentCoverage.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.main.InstrumentCoverage.diff?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -0,0 +1,82 @@\n+- // MIR for `main` before InstrumentCoverage\n++ // MIR for `main` after InstrumentCoverage\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/instrument_coverage.rs:9:11: 9:11\n+      let mut _1: ();                      // in scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n+      let mut _2: bool;                    // in scope 0 at $DIR/instrument_coverage.rs:11:12: 11:17\n+      let mut _3: !;                       // in scope 0 at $DIR/instrument_coverage.rs:11:18: 13:10\n++     let mut _4: ();                      // in scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n+  \n+      bb0: {\n+-         falseUnwind -> [real: bb1, cleanup: bb2]; // scope 0 at $DIR/instrument_coverage.rs:10:5: 14:6\n++         StorageLive(_4);                 // scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n++         _4 = const std::intrinsics::count_code_region(const 0u32) -> bb7; // scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n++                                          // ty::Const\n++                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u32) {std::intrinsics::count_code_region}\n++                                          // + val: Value(Scalar(<ZST>))\n++                                          // mir::Constant\n++                                          // + span: $DIR/instrument_coverage.rs:9:1: 9:1\n++                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n++                                          // ty::Const\n++                                          // + ty: u32\n++                                          // + val: Value(Scalar(0x00000000))\n++                                          // mir::Constant\n++                                          // + span: $DIR/instrument_coverage.rs:9:1: 9:1\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000000)) }\n+      }\n+  \n+      bb1: {\n+          StorageLive(_2);                 // scope 0 at $DIR/instrument_coverage.rs:11:12: 11:17\n+          _2 = const bar() -> [return: bb3, unwind: bb2]; // scope 0 at $DIR/instrument_coverage.rs:11:12: 11:17\n+                                           // ty::Const\n+                                           // + ty: fn() -> bool {bar}\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/instrument_coverage.rs:11:12: 11:15\n+                                           // + literal: Const { ty: fn() -> bool {bar}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb2 (cleanup): {\n+          resume;                          // scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n+      }\n+  \n+      bb3: {\n+          FakeRead(ForMatchedPlace, _2);   // scope 0 at $DIR/instrument_coverage.rs:11:12: 11:17\n+          switchInt(_2) -> [false: bb5, otherwise: bb4]; // scope 0 at $DIR/instrument_coverage.rs:11:9: 13:10\n+      }\n+  \n+      bb4: {\n+          falseEdge -> [real: bb6, imaginary: bb5]; // scope 0 at $DIR/instrument_coverage.rs:11:9: 13:10\n+      }\n+  \n+      bb5: {\n+          _1 = const ();                   // scope 0 at $DIR/instrument_coverage.rs:11:9: 13:10\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/instrument_coverage.rs:11:9: 13:10\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_2);                 // scope 0 at $DIR/instrument_coverage.rs:14:5: 14:6\n+          goto -> bb0;                     // scope 0 at $DIR/instrument_coverage.rs:10:5: 14:6\n+      }\n+  \n+      bb6: {\n+          _0 = const ();                   // scope 0 at $DIR/instrument_coverage.rs:12:13: 12:18\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/instrument_coverage.rs:12:13: 12:18\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_2);                 // scope 0 at $DIR/instrument_coverage.rs:14:5: 14:6\n+          return;                          // scope 0 at $DIR/instrument_coverage.rs:15:2: 15:2\n++     }\n++ \n++     bb7: {\n++         StorageDead(_4);                 // scope 0 at $DIR/instrument_coverage.rs:10:5: 14:6\n++         falseUnwind -> [real: bb1, cleanup: bb2]; // scope 0 at $DIR/instrument_coverage.rs:10:5: 14:6\n+      }\n+  }\n+  "}, {"sha": "b11d4c4cab7cf54c5f1f5de18a50cf3b15372149", "filename": "src/test/run-make-fulldeps/sanitizer-cdylib-link/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-cdylib-link%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-cdylib-link%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-cdylib-link%2FMakefile?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -1,5 +1,5 @@\n # needs-sanitizer-support\n-# only-x86_64\n+# needs-sanitizer-address\n # only-linux\n \n -include ../tools.mk"}, {"sha": "c2ebd2a6d8cacbf49ad9c02f92ec1f3e8252b448", "filename": "src/test/run-make-fulldeps/sanitizer-dylib-link/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-dylib-link%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-dylib-link%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-dylib-link%2FMakefile?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -1,5 +1,5 @@\n # needs-sanitizer-support\n-# only-x86_64\n+# needs-sanitizer-address\n # only-linux\n \n -include ../tools.mk"}, {"sha": "5ceff16471cee99fde034adabf0d53e8fadd9eeb", "filename": "src/test/run-make-fulldeps/sanitizer-staticlib-link/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-staticlib-link%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-staticlib-link%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-staticlib-link%2FMakefile?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -1,5 +1,5 @@\n # needs-sanitizer-support\n-# only-x86_64\n+# needs-sanitizer-address\n # only-linux\n \n -include ../tools.mk"}, {"sha": "a79b37ee08210717c27c9f278f7aac0402992e09", "filename": "src/test/rustdoc/sanitizer-option.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Frustdoc%2Fsanitizer-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Frustdoc%2Fsanitizer-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsanitizer-option.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -1,4 +1,5 @@\n // needs-sanitizer-support\n+// needs-sanitizer-address\n // compile-flags: --test -Z sanitizer=address\n //\n // #43031: Verify that rustdoc passes `-Z` options to rustc. Use an extern"}, {"sha": "9683a83e72095b09ecdc07abad6385811d48ccde", "filename": "src/test/ui/parser/byte-literals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -8,5 +8,5 @@ pub fn main() {\n     b'\t';  //~ ERROR byte constant must be escaped\n     b''';  //~ ERROR byte constant must be escaped\n     b'\u00e9';  //~ ERROR byte constant must be ASCII\n-    b'a  //~ ERROR unterminated byte constant\n+    b'a  //~ ERROR unterminated byte constant [E0763]\n }"}, {"sha": "7bbdc07cd835fa02c70a119c299e5a0a53056128", "filename": "src/test/ui/parser/byte-literals.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.stderr?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -34,11 +34,12 @@ error: byte constant must be ASCII. Use a \\xHH escape for a non-ASCII byte\n LL |     b'\u00e9';\n    |       ^\n \n-error: unterminated byte constant\n+error[E0763]: unterminated byte constant\n   --> $DIR/byte-literals.rs:11:6\n    |\n LL |     b'a\n    |      ^^^^\n \n error: aborting due to 7 previous errors\n \n+For more information about this error, try `rustc --explain E0763`."}, {"sha": "cee73b0425ad52210f7032b7e6b9262babad2b51", "filename": "src/test/ui/sanitize/address.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Fsanitize%2Faddress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Fsanitize%2Faddress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Faddress.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -1,5 +1,5 @@\n // needs-sanitizer-support\n-// only-x86_64\n+// needs-sanitizer-address\n //\n // compile-flags: -Z sanitizer=address -O -g\n //"}, {"sha": "095a6f4697b1c15a35a1e5139531b3ec5b4bfa46", "filename": "src/test/ui/sanitize/badfree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Fsanitize%2Fbadfree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Fsanitize%2Fbadfree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Fbadfree.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -1,5 +1,5 @@\n // needs-sanitizer-support\n-// only-x86_64\n+// needs-sanitizer-address\n //\n // compile-flags: -Z sanitizer=address -O\n //"}, {"sha": "79dfe58f04d0b48274bac1512000aec19a327098", "filename": "src/test/ui/sanitize/cfg.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Fsanitize%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Fsanitize%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Fcfg.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -2,8 +2,10 @@\n // the `#[cfg(sanitize = \"option\")]` attribute is configured.\n \n // needs-sanitizer-support\n-// only-linux\n-// only-x86_64\n+// needs-sanitizer-address\n+// needs-sanitizer-leak\n+// needs-sanitizer-memory\n+// needs-sanitizer-thread\n // check-pass\n // revisions: address leak memory thread\n //[address]compile-flags: -Zsanitizer=address --cfg address"}, {"sha": "b2e182238ce288803b0cd9116c8be6d8fb939d01", "filename": "src/test/ui/sanitize/issue-72154-lifetime-markers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Fsanitize%2Fissue-72154-lifetime-markers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Fsanitize%2Fissue-72154-lifetime-markers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Fissue-72154-lifetime-markers.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -4,7 +4,7 @@\n // miscompilation which was subsequently detected by AddressSanitizer as UB.\n //\n // needs-sanitizer-support\n-// only-x86_64\n+// needs-sanitizer-address\n //\n // compile-flags: -Copt-level=0 -Zsanitizer=address\n // run-pass"}, {"sha": "c9f10fe4f467ed73c8bdc7a4a92944bcf49c788e", "filename": "src/test/ui/sanitize/leak.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Fsanitize%2Fleak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Fsanitize%2Fleak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Fleak.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -1,5 +1,5 @@\n // needs-sanitizer-support\n-// only-x86_64\n+// needs-sanitizer-leak\n //\n // compile-flags: -Z sanitizer=leak -O\n //"}, {"sha": "a26649a5800131e20a6820ec72a123263552a84a", "filename": "src/test/ui/sanitize/memory.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Fsanitize%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Fsanitize%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Fmemory.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -1,6 +1,5 @@\n // needs-sanitizer-support\n-// only-linux\n-// only-x86_64\n+// needs-sanitizer-memory\n //\n // compile-flags: -Z sanitizer=memory -Zsanitizer-memory-track-origins -O\n //"}, {"sha": "64d6ccf34091681d386c7c3f746c7e529e2d15fb", "filename": "src/test/ui/sanitize/new-llvm-pass-manager-thin-lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Fsanitize%2Fnew-llvm-pass-manager-thin-lto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Fsanitize%2Fnew-llvm-pass-manager-thin-lto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Fnew-llvm-pass-manager-thin-lto.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -4,7 +4,7 @@\n //\n // min-llvm-version 9.0\n // needs-sanitizer-support\n-// only-x86_64\n+// needs-sanitizer-address\n //\n // no-prefer-dynamic\n // revisions: opt0 opt1"}, {"sha": "c70cf5accc0776611cf557a43178b708e002708e", "filename": "src/test/ui/sanitize/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Fsanitize%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Fsanitize%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Fthread.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -11,7 +11,7 @@\n // would occasionally fail, making test flaky.\n //\n // needs-sanitizer-support\n-// only-x86_64\n+// needs-sanitizer-thread\n //\n // compile-flags: -Z sanitizer=thread -O\n //"}, {"sha": "30be2ae6f090641e4bdacb7374f0940b521370fd", "filename": "src/test/ui/sanitize/use-after-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Fsanitize%2Fuse-after-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Fsanitize%2Fuse-after-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Fuse-after-scope.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -1,5 +1,5 @@\n // needs-sanitizer-support\n-// only-x86_64\n+// needs-sanitizer-address\n //\n // compile-flags: -Zsanitizer=address\n // run-fail"}, {"sha": "e4436260e70a07ac26d90c715b3995087ec58379", "filename": "src/test/ui/typeck/issue-68590-reborrow-through-derefmut.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Ftypeck%2Fissue-68590-reborrow-through-derefmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Ftypeck%2Fissue-68590-reborrow-through-derefmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-68590-reborrow-through-derefmut.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -0,0 +1,25 @@\n+// check-pass\n+\n+// rust-lang/rust#68590: confusing diagnostics when reborrowing through DerefMut.\n+\n+use std::cell::RefCell;\n+\n+struct A;\n+\n+struct S<'a> {\n+    a: &'a mut A,\n+}\n+\n+fn take_a(_: &mut A) {}\n+\n+fn test<'a>(s: &RefCell<S<'a>>) {\n+    let mut guard = s.borrow_mut();\n+    take_a(guard.a);\n+    let _s2 = S { a: guard.a };\n+}\n+\n+fn main() {\n+    let a = &mut A;\n+    let s = RefCell::new(S { a });\n+    test(&s);\n+}"}, {"sha": "3ea05389f04a0b7ae8c2fdd3c8f31f34e37b1178", "filename": "src/test/ui/typeck/issue-72225-call-fnmut-through-derefmut.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Ftypeck%2Fissue-72225-call-fnmut-through-derefmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftest%2Fui%2Ftypeck%2Fissue-72225-call-fnmut-through-derefmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-72225-call-fnmut-through-derefmut.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -0,0 +1,21 @@\n+// check-pass\n+\n+// rust-lang/rust#72225: confusing diagnostics when calling FnMut through DerefMut.\n+\n+use std::cell::RefCell;\n+\n+struct S {\n+    f: Box<dyn FnMut()>\n+}\n+\n+fn test(s: &RefCell<S>) {\n+    let mut guard = s.borrow_mut();\n+    (guard.f)();\n+}\n+\n+fn main() {\n+    let s = RefCell::new(S {\n+        f: Box::new(|| ())\n+    });\n+    test(&s);\n+}"}, {"sha": "9614707433e13af4a0111db8a271c7aa8f9547c7", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -43,6 +43,10 @@ impl EarlyProps {\n         let mut props = EarlyProps::default();\n         let rustc_has_profiler_support = env::var_os(\"RUSTC_PROFILER_SUPPORT\").is_some();\n         let rustc_has_sanitizer_support = env::var_os(\"RUSTC_SANITIZER_SUPPORT\").is_some();\n+        let has_asan = util::ASAN_SUPPORTED_TARGETS.contains(&&*config.target);\n+        let has_lsan = util::LSAN_SUPPORTED_TARGETS.contains(&&*config.target);\n+        let has_msan = util::MSAN_SUPPORTED_TARGETS.contains(&&*config.target);\n+        let has_tsan = util::TSAN_SUPPORTED_TARGETS.contains(&&*config.target);\n \n         iter_header(testfile, None, rdr, &mut |ln| {\n             // we should check if any only-<platform> exists and if it exists\n@@ -74,7 +78,25 @@ impl EarlyProps {\n                     props.ignore = true;\n                 }\n \n-                if !rustc_has_sanitizer_support && config.parse_needs_sanitizer_support(ln) {\n+                if !rustc_has_sanitizer_support\n+                    && config.parse_name_directive(ln, \"needs-sanitizer-support\")\n+                {\n+                    props.ignore = true;\n+                }\n+\n+                if !has_asan && config.parse_name_directive(ln, \"needs-sanitizer-address\") {\n+                    props.ignore = true;\n+                }\n+\n+                if !has_lsan && config.parse_name_directive(ln, \"needs-sanitizer-leak\") {\n+                    props.ignore = true;\n+                }\n+\n+                if !has_msan && config.parse_name_directive(ln, \"needs-sanitizer-memory\") {\n+                    props.ignore = true;\n+                }\n+\n+                if !has_tsan && config.parse_name_directive(ln, \"needs-sanitizer-thread\") {\n                     props.ignore = true;\n                 }\n \n@@ -829,10 +851,6 @@ impl Config {\n         self.parse_name_directive(line, \"needs-profiler-support\")\n     }\n \n-    fn parse_needs_sanitizer_support(&self, line: &str) -> bool {\n-        self.parse_name_directive(line, \"needs-sanitizer-support\")\n-    }\n-\n     /// Parses a name-value directive which contains config-specific information, e.g., `ignore-x86`\n     /// or `normalize-stderr-32bit`.\n     fn parse_cfg_name_directive(&self, line: &str, prefix: &str) -> ParsedNameDirective {"}, {"sha": "72af34d78260ba6007a385300ba0c8be2aeb8622", "filename": "src/tools/compiletest/src/header/tests.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -201,3 +201,22 @@ fn debugger() {\n     config.debugger = Some(Debugger::Lldb);\n     assert!(parse_rs(&config, \"// ignore-lldb\").ignore);\n }\n+\n+#[test]\n+fn sanitizers() {\n+    let mut config = config();\n+\n+    // Target that supports all sanitizers:\n+    config.target = \"x86_64-unknown-linux-gnu\".to_owned();\n+    assert!(!parse_rs(&config, \"// needs-sanitizer-address\").ignore);\n+    assert!(!parse_rs(&config, \"// needs-sanitizer-leak\").ignore);\n+    assert!(!parse_rs(&config, \"// needs-sanitizer-memory\").ignore);\n+    assert!(!parse_rs(&config, \"// needs-sanitizer-thread\").ignore);\n+\n+    // Target that doesn't support sanitizers:\n+    config.target = \"wasm32-unknown-emscripten\".to_owned();\n+    assert!(parse_rs(&config, \"// needs-sanitizer-address\").ignore);\n+    assert!(parse_rs(&config, \"// needs-sanitizer-leak\").ignore);\n+    assert!(parse_rs(&config, \"// needs-sanitizer-memory\").ignore);\n+    assert!(parse_rs(&config, \"// needs-sanitizer-thread\").ignore);\n+}"}, {"sha": "0d56bf2d20fcbf8441da21523ced18faa79332d0", "filename": "src/tools/compiletest/src/util.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72417d84fb51495a4f1d007fb2397a0b2609ab63/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs?ref=72417d84fb51495a4f1d007fb2397a0b2609ab63", "patch": "@@ -82,6 +82,17 @@ const ARCH_TABLE: &'static [(&'static str, &'static str)] = &[\n     (\"xcore\", \"xcore\"),\n ];\n \n+pub const ASAN_SUPPORTED_TARGETS: &'static [&'static str] =\n+    &[\"aarch64-fuchsia\", \"x86_64-apple-darwin\", \"x86_64-fuchsia\", \"x86_64-unknown-linux-gnu\"];\n+\n+pub const LSAN_SUPPORTED_TARGETS: &'static [&'static str] =\n+    &[\"x86_64-apple-darwin\", \"x86_64-unknown-linux-gnu\"];\n+\n+pub const MSAN_SUPPORTED_TARGETS: &'static [&'static str] = &[\"x86_64-unknown-linux-gnu\"];\n+\n+pub const TSAN_SUPPORTED_TARGETS: &'static [&'static str] =\n+    &[\"x86_64-apple-darwin\", \"x86_64-unknown-linux-gnu\"];\n+\n pub fn matches_os(triple: &str, name: &str) -> bool {\n     // For the wasm32 bare target we ignore anything also ignored on emscripten\n     // and then we also recognize `wasm32-bare` as the os for the target"}]}