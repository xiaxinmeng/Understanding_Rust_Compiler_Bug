{"sha": "90cb25d3f687a2b888174e604f48d6807a6d036c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwY2IyNWQzZjY4N2EyYjg4ODE3NGU2MDRmNDhkNjgwN2E2ZDAzNmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-25T10:35:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-25T10:35:46Z"}, "message": "Auto merge of #6177 - rust-lang:manual-range-contains, r=flip1995\n\nNew lint: manual-range-contains\n\nThis fixes #1110, at least for the contains-suggesting part.\n\n- \\[x] Followed [lint naming conventions][lint_naming]\n- \\[x] Added passing UI tests (including committed `.stderr` file)\n- \\[x] `cargo test` passes locally\n- \\[x] Executed `cargo dev update_lints`\n- \\[x] Added lint documentation\n- \\[x] Run `cargo dev fmt`\n---\n\nchangelog: new lint: manual-range-contains", "tree": {"sha": "2bd73a06cbffc8ffac0278fa25f2ad828744f9a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2bd73a06cbffc8ffac0278fa25f2ad828744f9a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90cb25d3f687a2b888174e604f48d6807a6d036c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90cb25d3f687a2b888174e604f48d6807a6d036c", "html_url": "https://github.com/rust-lang/rust/commit/90cb25d3f687a2b888174e604f48d6807a6d036c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90cb25d3f687a2b888174e604f48d6807a6d036c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "399732bf797000b46bbe3e01f52ae3f64255d217", "url": "https://api.github.com/repos/rust-lang/rust/commits/399732bf797000b46bbe3e01f52ae3f64255d217", "html_url": "https://github.com/rust-lang/rust/commit/399732bf797000b46bbe3e01f52ae3f64255d217"}, {"sha": "c693de350aff4a3930e66bccf65caf79b390dca2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c693de350aff4a3930e66bccf65caf79b390dca2", "html_url": "https://github.com/rust-lang/rust/commit/c693de350aff4a3930e66bccf65caf79b390dca2"}], "stats": {"total": 385, "additions": 354, "deletions": 31}, "files": [{"sha": "7fd79deb56c60670df690c9a4ae5857ba26891c9", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90cb25d3f687a2b888174e604f48d6807a6d036c/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/90cb25d3f687a2b888174e604f48d6807a6d036c/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=90cb25d3f687a2b888174e604f48d6807a6d036c", "patch": "@@ -1795,6 +1795,7 @@ Released 2018-09-13\n [`manual_async_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_async_fn\n [`manual_memcpy`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_memcpy\n [`manual_non_exhaustive`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_non_exhaustive\n+[`manual_range_contains`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains\n [`manual_saturating_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_saturating_arithmetic\n [`manual_strip`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_strip\n [`manual_swap`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_swap"}, {"sha": "b330b66776c1ce97ddb2f405f7d526c62ae5505c", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/90cb25d3f687a2b888174e604f48d6807a6d036c/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90cb25d3f687a2b888174e604f48d6807a6d036c/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=90cb25d3f687a2b888174e604f48d6807a6d036c", "patch": "@@ -792,6 +792,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &ptr_eq::PTR_EQ,\n         &ptr_offset_with_cast::PTR_OFFSET_WITH_CAST,\n         &question_mark::QUESTION_MARK,\n+        &ranges::MANUAL_RANGE_CONTAINS,\n         &ranges::RANGE_MINUS_ONE,\n         &ranges::RANGE_PLUS_ONE,\n         &ranges::RANGE_ZIP_WITH_LEN,\n@@ -1483,6 +1484,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&ptr_eq::PTR_EQ),\n         LintId::of(&ptr_offset_with_cast::PTR_OFFSET_WITH_CAST),\n         LintId::of(&question_mark::QUESTION_MARK),\n+        LintId::of(&ranges::MANUAL_RANGE_CONTAINS),\n         LintId::of(&ranges::RANGE_ZIP_WITH_LEN),\n         LintId::of(&ranges::REVERSED_EMPTY_RANGES),\n         LintId::of(&redundant_clone::REDUNDANT_CLONE),\n@@ -1640,6 +1642,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&ptr::PTR_ARG),\n         LintId::of(&ptr_eq::PTR_EQ),\n         LintId::of(&question_mark::QUESTION_MARK),\n+        LintId::of(&ranges::MANUAL_RANGE_CONTAINS),\n         LintId::of(&redundant_field_names::REDUNDANT_FIELD_NAMES),\n         LintId::of(&redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES),\n         LintId::of(&regex::TRIVIAL_REGEX),"}, {"sha": "de54711d8511b6998238d5787b95e8acbb1f042a", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 185, "deletions": 31, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/90cb25d3f687a2b888174e604f48d6807a6d036c/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90cb25d3f687a2b888174e604f48d6807a6d036c/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=90cb25d3f687a2b888174e604f48d6807a6d036c", "patch": "@@ -2,15 +2,19 @@ use crate::consts::{constant, Constant};\n use if_chain::if_chain;\n use rustc_ast::ast::RangeLimits;\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Expr, ExprKind, QPath};\n+use rustc_hir::{BinOpKind, Expr, ExprKind, PathSegment, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Spanned;\n+use rustc_span::source_map::{Span, Spanned};\n+use rustc_span::symbol::Ident;\n use std::cmp::Ordering;\n \n use crate::utils::sugg::Sugg;\n-use crate::utils::{get_parent_expr, is_integer_const, snippet, snippet_opt, span_lint, span_lint_and_then};\n+use crate::utils::{\n+    get_parent_expr, is_integer_const, single_segment_path, snippet, snippet_opt, snippet_with_applicability,\n+    span_lint, span_lint_and_sugg, span_lint_and_then,\n+};\n use crate::utils::{higher, SpanlessEq};\n \n declare_clippy_lint! {\n@@ -128,43 +132,51 @@ declare_clippy_lint! {\n     \"reversing the limits of range expressions, resulting in empty ranges\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for expressions like `x >= 3 && x < 8` that could\n+    /// be more readably expressed as `(3..8).contains(x)`.\n+    ///\n+    /// **Why is this bad?** `contains` expresses the intent better and has less\n+    /// failure modes (such as fencepost errors or using `||` instead of `&&`).\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// // given\n+    /// let x = 6;\n+    ///\n+    /// assert!(x >= 3 && x < 8);\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    ///# let x = 6;\n+    /// assert!((3..8).contains(&x));\n+    /// ```\n+    pub MANUAL_RANGE_CONTAINS,\n+    style,\n+    \"manually reimplementing {`Range`, `RangeInclusive`}`::contains`\"\n+}\n+\n declare_lint_pass!(Ranges => [\n     RANGE_ZIP_WITH_LEN,\n     RANGE_PLUS_ONE,\n     RANGE_MINUS_ONE,\n     REVERSED_EMPTY_RANGES,\n+    MANUAL_RANGE_CONTAINS,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Ranges {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind {\n-            let name = path.ident.as_str();\n-            if name == \"zip\" && args.len() == 2 {\n-                let iter = &args[0].kind;\n-                let zip_arg = &args[1];\n-                if_chain! {\n-                    // `.iter()` call\n-                    if let ExprKind::MethodCall(ref iter_path, _, ref iter_args , _) = *iter;\n-                    if iter_path.ident.name == sym!(iter);\n-                    // range expression in `.zip()` call: `0..x.len()`\n-                    if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(zip_arg);\n-                    if is_integer_const(cx, start, 0);\n-                    // `.len()` call\n-                    if let ExprKind::MethodCall(ref len_path, _, ref len_args, _) = end.kind;\n-                    if len_path.ident.name == sym!(len) && len_args.len() == 1;\n-                    // `.iter()` and `.len()` called on same `Path`\n-                    if let ExprKind::Path(QPath::Resolved(_, ref iter_path)) = iter_args[0].kind;\n-                    if let ExprKind::Path(QPath::Resolved(_, ref len_path)) = len_args[0].kind;\n-                    if SpanlessEq::new(cx).eq_path_segments(&iter_path.segments, &len_path.segments);\n-                     then {\n-                         span_lint(cx,\n-                                   RANGE_ZIP_WITH_LEN,\n-                                   expr.span,\n-                                   &format!(\"it is more idiomatic to use `{}.iter().enumerate()`\",\n-                                            snippet(cx, iter_args[0].span, \"_\")));\n-                    }\n-                }\n-            }\n+        match expr.kind {\n+            ExprKind::MethodCall(ref path, _, ref args, _) => {\n+                check_range_zip_with_len(cx, path, args, expr.span);\n+            },\n+            ExprKind::Binary(ref op, ref l, ref r) => {\n+                check_possible_range_contains(cx, op.node, l, r, expr.span);\n+            },\n+            _ => {},\n         }\n \n         check_exclusive_range_plus_one(cx, expr);\n@@ -173,6 +185,148 @@ impl<'tcx> LateLintPass<'tcx> for Ranges {\n     }\n }\n \n+fn check_possible_range_contains(cx: &LateContext<'_>, op: BinOpKind, l: &Expr<'_>, r: &Expr<'_>, span: Span) {\n+    let combine_and = match op {\n+        BinOpKind::And | BinOpKind::BitAnd => true,\n+        BinOpKind::Or | BinOpKind::BitOr => false,\n+        _ => return,\n+    };\n+    // value, name, order (higher/lower), inclusiveness\n+    if let (Some((lval, lname, name_span, lval_span, lord, linc)), Some((rval, rname, _, rval_span, rord, rinc))) =\n+        (check_range_bounds(cx, l), check_range_bounds(cx, r))\n+    {\n+        // we only lint comparisons on the same name and with different\n+        // direction\n+        if lname != rname || lord == rord {\n+            return;\n+        }\n+        let ord = Constant::partial_cmp(cx.tcx, cx.typeck_results().expr_ty(l), &lval, &rval);\n+        if combine_and && ord == Some(rord) {\n+            // order lower bound and upper bound\n+            let (l_span, u_span, l_inc, u_inc) = if rord == Ordering::Less {\n+                (lval_span, rval_span, linc, rinc)\n+            } else {\n+                (rval_span, lval_span, rinc, linc)\n+            };\n+            // we only lint inclusive lower bounds\n+            if !l_inc {\n+                return;\n+            }\n+            let (range_type, range_op) = if u_inc {\n+                (\"RangeInclusive\", \"..=\")\n+            } else {\n+                (\"Range\", \"..\")\n+            };\n+            let mut applicability = Applicability::MachineApplicable;\n+            let name = snippet_with_applicability(cx, name_span, \"_\", &mut applicability);\n+            let lo = snippet_with_applicability(cx, l_span, \"_\", &mut applicability);\n+            let hi = snippet_with_applicability(cx, u_span, \"_\", &mut applicability);\n+            span_lint_and_sugg(\n+                cx,\n+                MANUAL_RANGE_CONTAINS,\n+                span,\n+                &format!(\"manual `{}::contains` implementation\", range_type),\n+                \"use\",\n+                format!(\"({}{}{}).contains(&{})\", lo, range_op, hi, name),\n+                applicability,\n+            );\n+        } else if !combine_and && ord == Some(lord) {\n+            // `!_.contains(_)`\n+            // order lower bound and upper bound\n+            let (l_span, u_span, l_inc, u_inc) = if lord == Ordering::Less {\n+                (lval_span, rval_span, linc, rinc)\n+            } else {\n+                (rval_span, lval_span, rinc, linc)\n+            };\n+            if l_inc {\n+                return;\n+            }\n+            let (range_type, range_op) = if u_inc {\n+                (\"Range\", \"..\")\n+            } else {\n+                (\"RangeInclusive\", \"..=\")\n+            };\n+            let mut applicability = Applicability::MachineApplicable;\n+            let name = snippet_with_applicability(cx, name_span, \"_\", &mut applicability);\n+            let lo = snippet_with_applicability(cx, l_span, \"_\", &mut applicability);\n+            let hi = snippet_with_applicability(cx, u_span, \"_\", &mut applicability);\n+            span_lint_and_sugg(\n+                cx,\n+                MANUAL_RANGE_CONTAINS,\n+                span,\n+                &format!(\"manual `!{}::contains` implementation\", range_type),\n+                \"use\",\n+                format!(\"!({}{}{}).contains(&{})\", lo, range_op, hi, name),\n+                applicability,\n+            );\n+        }\n+    }\n+}\n+\n+fn check_range_bounds(cx: &LateContext<'_>, ex: &Expr<'_>) -> Option<(Constant, Ident, Span, Span, Ordering, bool)> {\n+    if let ExprKind::Binary(ref op, ref l, ref r) = ex.kind {\n+        let (inclusive, ordering) = match op.node {\n+            BinOpKind::Gt => (false, Ordering::Greater),\n+            BinOpKind::Ge => (true, Ordering::Greater),\n+            BinOpKind::Lt => (false, Ordering::Less),\n+            BinOpKind::Le => (true, Ordering::Less),\n+            _ => return None,\n+        };\n+        if let Some(id) = match_ident(l) {\n+            if let Some((c, _)) = constant(cx, cx.typeck_results(), r) {\n+                return Some((c, id, l.span, r.span, ordering, inclusive));\n+            }\n+        } else if let Some(id) = match_ident(r) {\n+            if let Some((c, _)) = constant(cx, cx.typeck_results(), l) {\n+                return Some((c, id, r.span, l.span, ordering.reverse(), inclusive));\n+            }\n+        }\n+    }\n+    None\n+}\n+\n+fn match_ident(e: &Expr<'_>) -> Option<Ident> {\n+    if let ExprKind::Path(ref qpath) = e.kind {\n+        if let Some(seg) = single_segment_path(qpath) {\n+            if seg.args.is_none() {\n+                return Some(seg.ident);\n+            }\n+        }\n+    }\n+    None\n+}\n+\n+fn check_range_zip_with_len(cx: &LateContext<'_>, path: &PathSegment<'_>, args: &[Expr<'_>], span: Span) {\n+    let name = path.ident.as_str();\n+    if name == \"zip\" && args.len() == 2 {\n+        let iter = &args[0].kind;\n+        let zip_arg = &args[1];\n+        if_chain! {\n+            // `.iter()` call\n+            if let ExprKind::MethodCall(ref iter_path, _, ref iter_args, _) = *iter;\n+            if iter_path.ident.name == sym!(iter);\n+            // range expression in `.zip()` call: `0..x.len()`\n+            if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(zip_arg);\n+            if is_integer_const(cx, start, 0);\n+            // `.len()` call\n+            if let ExprKind::MethodCall(ref len_path, _, ref len_args, _) = end.kind;\n+            if len_path.ident.name == sym!(len) && len_args.len() == 1;\n+            // `.iter()` and `.len()` called on same `Path`\n+            if let ExprKind::Path(QPath::Resolved(_, ref iter_path)) = iter_args[0].kind;\n+            if let ExprKind::Path(QPath::Resolved(_, ref len_path)) = len_args[0].kind;\n+            if SpanlessEq::new(cx).eq_path_segments(&iter_path.segments, &len_path.segments);\n+            then {\n+                span_lint(cx,\n+                    RANGE_ZIP_WITH_LEN,\n+                    span,\n+                    &format!(\"it is more idiomatic to use `{}.iter().enumerate()`\",\n+                        snippet(cx, iter_args[0].span, \"_\"))\n+                );\n+            }\n+        }\n+    }\n+}\n+\n // exclusive range plus one: `x..(y+1)`\n fn check_exclusive_range_plus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {"}, {"sha": "4bf77dae6377097d2186756af597cb73f9749488", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/90cb25d3f687a2b888174e604f48d6807a6d036c/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90cb25d3f687a2b888174e604f48d6807a6d036c/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=90cb25d3f687a2b888174e604f48d6807a6d036c", "patch": "@@ -1173,6 +1173,13 @@ vec![\n         deprecation: None,\n         module: \"manual_non_exhaustive\",\n     },\n+    Lint {\n+        name: \"manual_range_contains\",\n+        group: \"style\",\n+        desc: \"manually reimplementing {`Range`, `RangeInclusive`}`::contains`\",\n+        deprecation: None,\n+        module: \"ranges\",\n+    },\n     Lint {\n         name: \"manual_saturating_arithmetic\",\n         group: \"style\","}, {"sha": "632a6592a28b84b6831c29dd4e65bb90143d0dbb", "filename": "tests/ui/range_contains.fixed", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/90cb25d3f687a2b888174e604f48d6807a6d036c/tests%2Fui%2Frange_contains.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/90cb25d3f687a2b888174e604f48d6807a6d036c/tests%2Fui%2Frange_contains.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frange_contains.fixed?ref=90cb25d3f687a2b888174e604f48d6807a6d036c", "patch": "@@ -0,0 +1,41 @@\n+// run-rustfix\n+\n+#[warn(clippy::manual_range_contains)]\n+#[allow(unused)]\n+#[allow(clippy::no_effect)]\n+#[allow(clippy::short_circuit_statement)]\n+#[allow(clippy::unnecessary_operation)]\n+fn main() {\n+    let x = 9_u32;\n+\n+    // order shouldn't matter\n+    (8..12).contains(&x);\n+    (21..42).contains(&x);\n+    (1..100).contains(&x);\n+\n+    // also with inclusive ranges\n+    (9..=99).contains(&x);\n+    (1..=33).contains(&x);\n+    (1..=999).contains(&x);\n+\n+    // and the outside\n+    !(8..12).contains(&x);\n+    !(21..42).contains(&x);\n+    !(1..100).contains(&x);\n+\n+    // also with the outside of inclusive ranges\n+    !(9..=99).contains(&x);\n+    !(1..=33).contains(&x);\n+    !(1..=999).contains(&x);\n+\n+    // not a range.contains\n+    x > 8 && x < 12; // lower bound not inclusive\n+    x < 8 && x <= 12; // same direction\n+    x >= 12 && 12 >= x; // same bounds\n+    x < 8 && x > 12; // wrong direction\n+\n+    x <= 8 || x >= 12;\n+    x >= 8 || x >= 12;\n+    x < 12 || 12 < x;\n+    x >= 8 || x <= 12;\n+}"}, {"sha": "6af0d034ef617b25576507cf407b79a59879ba70", "filename": "tests/ui/range_contains.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/90cb25d3f687a2b888174e604f48d6807a6d036c/tests%2Fui%2Frange_contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90cb25d3f687a2b888174e604f48d6807a6d036c/tests%2Fui%2Frange_contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frange_contains.rs?ref=90cb25d3f687a2b888174e604f48d6807a6d036c", "patch": "@@ -0,0 +1,41 @@\n+// run-rustfix\n+\n+#[warn(clippy::manual_range_contains)]\n+#[allow(unused)]\n+#[allow(clippy::no_effect)]\n+#[allow(clippy::short_circuit_statement)]\n+#[allow(clippy::unnecessary_operation)]\n+fn main() {\n+    let x = 9_u32;\n+\n+    // order shouldn't matter\n+    x >= 8 && x < 12;\n+    x < 42 && x >= 21;\n+    100 > x && 1 <= x;\n+\n+    // also with inclusive ranges\n+    x >= 9 && x <= 99;\n+    x <= 33 && x >= 1;\n+    999 >= x && 1 <= x;\n+\n+    // and the outside\n+    x < 8 || x >= 12;\n+    x >= 42 || x < 21;\n+    100 <= x || 1 > x;\n+\n+    // also with the outside of inclusive ranges\n+    x < 9 || x > 99;\n+    x > 33 || x < 1;\n+    999 < x || 1 > x;\n+\n+    // not a range.contains\n+    x > 8 && x < 12; // lower bound not inclusive\n+    x < 8 && x <= 12; // same direction\n+    x >= 12 && 12 >= x; // same bounds\n+    x < 8 && x > 12; // wrong direction\n+\n+    x <= 8 || x >= 12;\n+    x >= 8 || x >= 12;\n+    x < 12 || 12 < x;\n+    x >= 8 || x <= 12;\n+}"}, {"sha": "69b009eafc30ab589f603f5d9c166072e560d173", "filename": "tests/ui/range_contains.stderr", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/90cb25d3f687a2b888174e604f48d6807a6d036c/tests%2Fui%2Frange_contains.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/90cb25d3f687a2b888174e604f48d6807a6d036c/tests%2Fui%2Frange_contains.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frange_contains.stderr?ref=90cb25d3f687a2b888174e604f48d6807a6d036c", "patch": "@@ -0,0 +1,76 @@\n+error: manual `Range::contains` implementation\n+  --> $DIR/range_contains.rs:12:5\n+   |\n+LL |     x >= 8 && x < 12;\n+   |     ^^^^^^^^^^^^^^^^ help: use: `(8..12).contains(&x)`\n+   |\n+   = note: `-D clippy::manual-range-contains` implied by `-D warnings`\n+\n+error: manual `Range::contains` implementation\n+  --> $DIR/range_contains.rs:13:5\n+   |\n+LL |     x < 42 && x >= 21;\n+   |     ^^^^^^^^^^^^^^^^^ help: use: `(21..42).contains(&x)`\n+\n+error: manual `Range::contains` implementation\n+  --> $DIR/range_contains.rs:14:5\n+   |\n+LL |     100 > x && 1 <= x;\n+   |     ^^^^^^^^^^^^^^^^^ help: use: `(1..100).contains(&x)`\n+\n+error: manual `RangeInclusive::contains` implementation\n+  --> $DIR/range_contains.rs:17:5\n+   |\n+LL |     x >= 9 && x <= 99;\n+   |     ^^^^^^^^^^^^^^^^^ help: use: `(9..=99).contains(&x)`\n+\n+error: manual `RangeInclusive::contains` implementation\n+  --> $DIR/range_contains.rs:18:5\n+   |\n+LL |     x <= 33 && x >= 1;\n+   |     ^^^^^^^^^^^^^^^^^ help: use: `(1..=33).contains(&x)`\n+\n+error: manual `RangeInclusive::contains` implementation\n+  --> $DIR/range_contains.rs:19:5\n+   |\n+LL |     999 >= x && 1 <= x;\n+   |     ^^^^^^^^^^^^^^^^^^ help: use: `(1..=999).contains(&x)`\n+\n+error: manual `!Range::contains` implementation\n+  --> $DIR/range_contains.rs:22:5\n+   |\n+LL |     x < 8 || x >= 12;\n+   |     ^^^^^^^^^^^^^^^^ help: use: `!(8..12).contains(&x)`\n+\n+error: manual `!Range::contains` implementation\n+  --> $DIR/range_contains.rs:23:5\n+   |\n+LL |     x >= 42 || x < 21;\n+   |     ^^^^^^^^^^^^^^^^^ help: use: `!(21..42).contains(&x)`\n+\n+error: manual `!Range::contains` implementation\n+  --> $DIR/range_contains.rs:24:5\n+   |\n+LL |     100 <= x || 1 > x;\n+   |     ^^^^^^^^^^^^^^^^^ help: use: `!(1..100).contains(&x)`\n+\n+error: manual `!RangeInclusive::contains` implementation\n+  --> $DIR/range_contains.rs:27:5\n+   |\n+LL |     x < 9 || x > 99;\n+   |     ^^^^^^^^^^^^^^^ help: use: `!(9..=99).contains(&x)`\n+\n+error: manual `!RangeInclusive::contains` implementation\n+  --> $DIR/range_contains.rs:28:5\n+   |\n+LL |     x > 33 || x < 1;\n+   |     ^^^^^^^^^^^^^^^ help: use: `!(1..=33).contains(&x)`\n+\n+error: manual `!RangeInclusive::contains` implementation\n+  --> $DIR/range_contains.rs:29:5\n+   |\n+LL |     999 < x || 1 > x;\n+   |     ^^^^^^^^^^^^^^^^ help: use: `!(1..=999).contains(&x)`\n+\n+error: aborting due to 12 previous errors\n+"}]}