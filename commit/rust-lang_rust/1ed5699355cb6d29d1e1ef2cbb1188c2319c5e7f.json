{"sha": "1ed5699355cb6d29d1e1ef2cbb1188c2319c5e7f", "node_id": "C_kwDOAAsO6NoAKDFlZDU2OTkzNTVjYjZkMjlkMWUxZWYyY2JiMTE4OGMyMzE5YzVlN2Y", "commit": {"author": {"name": "Jake Heinz", "email": "jh@discordapp.com", "date": "2021-11-29T05:22:30Z"}, "committer": {"name": "Jake Heinz", "email": "jh@discordapp.com", "date": "2021-11-29T05:22:30Z"}, "message": "collect macros", "tree": {"sha": "766be0d1783f724cc00b0317def52f3e365cb3a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/766be0d1783f724cc00b0317def52f3e365cb3a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ed5699355cb6d29d1e1ef2cbb1188c2319c5e7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ed5699355cb6d29d1e1ef2cbb1188c2319c5e7f", "html_url": "https://github.com/rust-lang/rust/commit/1ed5699355cb6d29d1e1ef2cbb1188c2319c5e7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ed5699355cb6d29d1e1ef2cbb1188c2319c5e7f/comments", "author": {"login": "jhgg", "id": 5489149, "node_id": "MDQ6VXNlcjU0ODkxNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5489149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jhgg", "html_url": "https://github.com/jhgg", "followers_url": "https://api.github.com/users/jhgg/followers", "following_url": "https://api.github.com/users/jhgg/following{/other_user}", "gists_url": "https://api.github.com/users/jhgg/gists{/gist_id}", "starred_url": "https://api.github.com/users/jhgg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jhgg/subscriptions", "organizations_url": "https://api.github.com/users/jhgg/orgs", "repos_url": "https://api.github.com/users/jhgg/repos", "events_url": "https://api.github.com/users/jhgg/events{/privacy}", "received_events_url": "https://api.github.com/users/jhgg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jhgg", "id": 5489149, "node_id": "MDQ6VXNlcjU0ODkxNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5489149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jhgg", "html_url": "https://github.com/jhgg", "followers_url": "https://api.github.com/users/jhgg/followers", "following_url": "https://api.github.com/users/jhgg/following{/other_user}", "gists_url": "https://api.github.com/users/jhgg/gists{/gist_id}", "starred_url": "https://api.github.com/users/jhgg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jhgg/subscriptions", "organizations_url": "https://api.github.com/users/jhgg/orgs", "repos_url": "https://api.github.com/users/jhgg/repos", "events_url": "https://api.github.com/users/jhgg/events{/privacy}", "received_events_url": "https://api.github.com/users/jhgg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d69e0dab5626d7ef7751951c2d0cc5cb9ef2499f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d69e0dab5626d7ef7751951c2d0cc5cb9ef2499f", "html_url": "https://github.com/rust-lang/rust/commit/d69e0dab5626d7ef7751951c2d0cc5cb9ef2499f"}], "stats": {"total": 114, "additions": 81, "deletions": 33}, "files": [{"sha": "becef49564c4dc45fc3ab4b72eb4b2073f3178b6", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1ed5699355cb6d29d1e1ef2cbb1188c2319c5e7f/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ed5699355cb6d29d1e1ef2cbb1188c2319c5e7f/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=1ed5699355cb6d29d1e1ef2cbb1188c2319c5e7f", "patch": "@@ -47,7 +47,7 @@ use hir_def::{\n     AttrDefId, ConstId, ConstParamId, EnumId, FunctionId, GenericDefId, HasModule, LifetimeParamId,\n     LocalEnumVariantId, LocalFieldId, StaticId, StructId, TypeAliasId, TypeParamId, UnionId,\n };\n-use hir_expand::{name::name, MacroCallKind, MacroDefId, MacroDefKind};\n+use hir_expand::{name::name, MacroCallKind, MacroDefKind};\n use hir_ty::{\n     autoderef,\n     consteval::ConstExt,\n@@ -126,7 +126,7 @@ pub use {\n     },\n     hir_expand::{\n         name::{known, Name},\n-        ExpandResult, HirFileId, InFile, MacroFile, Origin,\n+        ExpandResult, HirFileId, InFile, MacroDefId, MacroFile, Origin,\n     },\n     hir_ty::display::HirDisplay,\n };"}, {"sha": "8b5984bf1233d2ac8570beab4cb5d936ae6fa419", "filename": "crates/hir_def/src/item_scope.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1ed5699355cb6d29d1e1ef2cbb1188c2319c5e7f/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ed5699355cb6d29d1e1ef2cbb1188c2319c5e7f/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs?ref=1ed5699355cb6d29d1e1ef2cbb1188c2319c5e7f", "patch": "@@ -44,6 +44,8 @@ pub struct ItemScope {\n     /// The defs declared in this scope. Each def has a single scope where it is\n     /// declared.\n     declarations: Vec<ModuleDefId>,\n+    macro_declarations: Vec<MacroDefId>,\n+\n     impls: Vec<ImplId>,\n     unnamed_consts: Vec<ConstId>,\n     /// Traits imported via `use Trait as _;`.\n@@ -101,6 +103,10 @@ impl ItemScope {\n         self.declarations.iter().copied()\n     }\n \n+    pub fn macro_declarations(&self) -> impl Iterator<Item = MacroDefId> + '_ {\n+        self.macro_declarations.iter().copied()\n+    }\n+\n     pub fn impls(&self) -> impl Iterator<Item = ImplId> + ExactSizeIterator + '_ {\n         self.impls.iter().copied()\n     }\n@@ -121,7 +127,7 @@ impl ItemScope {\n     }\n \n     /// Iterate over all legacy textual scoped macros visible at the end of the module\n-    pub(crate) fn legacy_macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n+    pub fn legacy_macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n         self.legacy_macros.iter().map(|(name, def)| (name, *def))\n     }\n \n@@ -163,6 +169,10 @@ impl ItemScope {\n         self.declarations.push(def)\n     }\n \n+    pub(crate) fn declare_macro(&mut self, def: MacroDefId) {\n+        self.macro_declarations.push(def);\n+    }\n+\n     pub(crate) fn get_legacy_macro(&self, name: &Name) -> Option<MacroDefId> {\n         self.legacy_macros.get(name).copied()\n     }\n@@ -336,7 +346,8 @@ impl ItemScope {\n             values,\n             macros,\n             unresolved,\n-            declarations: defs,\n+            declarations,\n+            macro_declarations,\n             impls,\n             unnamed_consts,\n             unnamed_trait_imports,\n@@ -348,7 +359,8 @@ impl ItemScope {\n         values.shrink_to_fit();\n         macros.shrink_to_fit();\n         unresolved.shrink_to_fit();\n-        defs.shrink_to_fit();\n+        declarations.shrink_to_fit();\n+        macro_declarations.shrink_to_fit();\n         impls.shrink_to_fit();\n         unnamed_consts.shrink_to_fit();\n         unnamed_trait_imports.shrink_to_fit();"}, {"sha": "49d2a7866a3683b6713c86b35cf00ff9f4089b00", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ed5699355cb6d29d1e1ef2cbb1188c2319c5e7f/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ed5699355cb6d29d1e1ef2cbb1188c2319c5e7f/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=1ed5699355cb6d29d1e1ef2cbb1188c2319c5e7f", "patch": "@@ -632,6 +632,7 @@ impl DefCollector<'_> {\n     ) {\n         let vis =\n             self.def_map.resolve_visibility(self.db, module_id, vis).unwrap_or(Visibility::Public);\n+        self.def_map.modules[module_id].scope.declare_macro(macro_);\n         self.update(module_id, &[(Some(name), PerNs::macros(macro_, vis))], vis, ImportType::Named);\n     }\n \n@@ -640,6 +641,7 @@ impl DefCollector<'_> {\n     /// A proc macro is similar to normal macro scope, but it would not visible in legacy textual scoped.\n     /// And unconditionally exported.\n     fn define_proc_macro(&mut self, name: Name, macro_: MacroDefId) {\n+        self.def_map.modules[self.def_map.root].scope.declare_macro(macro_);\n         self.update(\n             self.def_map.root,\n             &[(Some(name), PerNs::macros(macro_, Visibility::Public))],"}, {"sha": "53fa3f0881ffba8895a00bd71a7463d23214c046", "filename": "crates/ide_db/src/symbol_index.rs", "status": "modified", "additions": 62, "deletions": 28, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/1ed5699355cb6d29d1e1ef2cbb1188c2319c5e7f/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ed5699355cb6d29d1e1ef2cbb1188c2319c5e7f/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs?ref=1ed5699355cb6d29d1e1ef2cbb1188c2319c5e7f", "patch": "@@ -32,10 +32,12 @@ use base_db::{\n     salsa::{self, ParallelDatabase},\n     CrateId, FileId, FileRange, SourceDatabaseExt, SourceRootId, Upcast,\n };\n+use either::Either;\n use fst::{self, Streamer};\n use hir::{\n-    db::DefDatabase, AdtId, AssocContainerId, AssocItemId, AssocItemLoc, DefHasSource,\n-    DefWithBodyId, HirFileId, ImplId, InFile, ItemLoc, ItemTreeNode, Lookup, ModuleDefId, ModuleId,\n+    db::{DefDatabase, HirDatabase},\n+    AdtId, AssocContainerId, AssocItemId, AssocItemLoc, DefHasSource, DefWithBodyId, HasSource,\n+    HirFileId, ImplId, InFile, ItemLoc, ItemTreeNode, Lookup, MacroDef, ModuleDefId, ModuleId,\n     Semantics, TraitId,\n };\n use rayon::prelude::*;\n@@ -94,7 +96,7 @@ impl Query {\n }\n \n #[salsa::query_group(SymbolsDatabaseStorage)]\n-pub trait SymbolsDatabase: hir::db::HirDatabase + SourceDatabaseExt {\n+pub trait SymbolsDatabase: HirDatabase + SourceDatabaseExt + Upcast<dyn HirDatabase> {\n     fn module_symbols(&self, module_id: ModuleId) -> Arc<SymbolIndex>;\n     fn library_symbols(&self) -> Arc<FxHashMap<SourceRootId, SymbolIndex>>;\n     /// The set of \"local\" (that is, from the current workspace) roots.\n@@ -129,7 +131,7 @@ fn library_symbols(db: &dyn SymbolsDatabase) -> Arc<FxHashMap<SourceRootId, Symb\n }\n \n fn module_symbols(db: &dyn SymbolsDatabase, module_id: ModuleId) -> Arc<SymbolIndex> {\n-    let symbols = SymbolCollector::collect(db.upcast(), module_id);\n+    let symbols = SymbolCollector::collect(db, module_id);\n     Arc::new(SymbolIndex::new(symbols))\n }\n \n@@ -205,10 +207,6 @@ pub fn crate_symbols(db: &RootDatabase, krate: CrateId, query: Query) -> Vec<Fil\n         .map_with(snap, |snap, &module_id| snap.0.module_symbols(module_id))\n         .collect();\n \n-    for i in &buf {\n-        dbg!(&i.symbols);\n-    }\n-\n     let buf = buf.iter().map(|it| &**it).collect::<Vec<_>>();\n     query.search(&buf)\n }\n@@ -446,14 +444,16 @@ enum SymbolCollectorWorkItem {\n }\n \n struct SymbolCollector<'a> {\n-    db: &'a dyn DefDatabase,\n+    db: &'a dyn SymbolsDatabase,\n     symbols: Vec<FileSymbol>,\n     work: Vec<SymbolCollectorWorkItem>,\n     container_name_stack: Vec<SmolStr>,\n }\n \n+/// Given a [`ModuleId`] and a [`SymbolsDatabase`], use the DefMap for the module's crate to collect all symbols that should be\n+/// indexed for the given module.\n impl<'a> SymbolCollector<'a> {\n-    fn collect(db: &dyn DefDatabase, module_id: ModuleId) -> Vec<FileSymbol> {\n+    fn collect(db: &dyn SymbolsDatabase, module_id: ModuleId) -> Vec<FileSymbol> {\n         let mut symbol_collector = SymbolCollector {\n             db,\n             symbols: Default::default(),\n@@ -486,10 +486,12 @@ impl<'a> SymbolCollector<'a> {\n     }\n \n     fn collect_from_module(&mut self, module_id: ModuleId) {\n-        let def_map = module_id.def_map(self.db);\n+        let def_map = module_id.def_map(self.db.upcast());\n         let module_data = &def_map[module_id.local_id];\n         let scope = &module_data.scope;\n \n+        dbg!(scope);\n+\n         for module_def_id in scope.declarations() {\n             match module_def_id {\n                 ModuleDefId::ModuleId(id) => self.push_module(id),\n@@ -531,14 +533,23 @@ impl<'a> SymbolCollector<'a> {\n             self.work.push(SymbolCollectorWorkItem::Body { body: const_id.into() })\n         }\n \n-        // todo: collect macros.\n+        // Collect legacy macros from the root module only:\n+        if module_data.parent.is_none() {\n+            for (_, macro_def_id) in scope.legacy_macros() {\n+                self.push_decl_macro(macro_def_id.into());\n+            }\n+        }\n+\n+        for macro_def_id in scope.macro_declarations() {\n+            self.push_decl_macro(macro_def_id.into());\n+        }\n     }\n \n     fn collect_from_body(&mut self, body_id: DefWithBodyId) {\n         let body = self.db.body(body_id);\n \n         // Descend into the blocks and enqueue collection of all modules within.\n-        for (_, def_map) in body.blocks(self.db) {\n+        for (_, def_map) in body.blocks(self.db.upcast()) {\n             for (id, _) in def_map.modules() {\n                 self.work.push(SymbolCollectorWorkItem::Module {\n                     module_id: def_map.module_id(id),\n@@ -578,15 +589,15 @@ impl<'a> SymbolCollector<'a> {\n \n     fn def_with_body_id_name(&self, body_id: DefWithBodyId) -> Option<SmolStr> {\n         match body_id {\n-            DefWithBodyId::FunctionId(id) => {\n-                Some(id.lookup(self.db).source(self.db).value.name()?.text().into())\n-            }\n-            DefWithBodyId::StaticId(id) => {\n-                Some(id.lookup(self.db).source(self.db).value.name()?.text().into())\n-            }\n-            DefWithBodyId::ConstId(id) => {\n-                Some(id.lookup(self.db).source(self.db).value.name()?.text().into())\n-            }\n+            DefWithBodyId::FunctionId(id) => Some(\n+                id.lookup(self.db.upcast()).source(self.db.upcast()).value.name()?.text().into(),\n+            ),\n+            DefWithBodyId::StaticId(id) => Some(\n+                id.lookup(self.db.upcast()).source(self.db.upcast()).value.name()?.text().into(),\n+            ),\n+            DefWithBodyId::ConstId(id) => Some(\n+                id.lookup(self.db.upcast()).source(self.db.upcast()).value.name()?.text().into(),\n+            ),\n         }\n     }\n \n@@ -624,11 +635,11 @@ impl<'a> SymbolCollector<'a> {\n         }\n \n         self.push_file_symbol(|s| {\n-            let loc = id.lookup(s.db);\n-            let source = loc.source(s.db);\n+            let loc = id.lookup(s.db.upcast());\n+            let source = loc.source(s.db.upcast());\n             let name_node = source.value.name()?;\n             let container_name =\n-                container_name(s.db, loc.container).or_else(|| s.current_container_name());\n+                container_name(s.db.upcast(), loc.container).or_else(|| s.current_container_name());\n \n             Some(FileSymbol {\n                 name: name_node.text().into(),\n@@ -650,8 +661,8 @@ impl<'a> SymbolCollector<'a> {\n         <T as ItemTreeNode>::Source: HasName,\n     {\n         self.push_file_symbol(|s| {\n-            let loc = id.lookup(s.db);\n-            let source = loc.source(s.db);\n+            let loc = id.lookup(s.db.upcast());\n+            let source = loc.source(s.db.upcast());\n             let name_node = source.value.name()?;\n \n             Some(FileSymbol {\n@@ -669,7 +680,7 @@ impl<'a> SymbolCollector<'a> {\n \n     fn push_module(&mut self, module_id: ModuleId) {\n         self.push_file_symbol(|s| {\n-            let def_map = module_id.def_map(s.db);\n+            let def_map = module_id.def_map(s.db.upcast());\n             let module_data = &def_map[module_id.local_id];\n             let declaration = module_data.origin.declaration()?;\n             let module = declaration.to_node(s.db.upcast());\n@@ -688,6 +699,29 @@ impl<'a> SymbolCollector<'a> {\n         })\n     }\n \n+    pub(crate) fn push_decl_macro(&mut self, macro_def: MacroDef) {\n+        self.push_file_symbol(|s| {\n+            let name = macro_def.name(s.db.upcast())?.as_text()?;\n+            let source = macro_def.source(s.db.upcast())?;\n+\n+            let (ptr, name_ptr) = match source.value {\n+                Either::Left(m) => {\n+                    (SyntaxNodePtr::new(m.syntax()), SyntaxNodePtr::new(m.name()?.syntax()))\n+                }\n+                Either::Right(f) => {\n+                    (SyntaxNodePtr::new(f.syntax()), SyntaxNodePtr::new(f.name()?.syntax()))\n+                }\n+            };\n+\n+            Some(FileSymbol {\n+                name,\n+                kind: FileSymbolKind::Macro,\n+                container_name: s.current_container_name(),\n+                loc: DeclarationLocation { hir_file_id: source.file_id, name_ptr, ptr },\n+            })\n+        })\n+    }\n+\n     fn push_file_symbol(&mut self, f: impl FnOnce(&Self) -> Option<FileSymbol>) {\n         if let Some(file_symbol) = f(self) {\n             self.symbols.push(file_symbol);"}]}