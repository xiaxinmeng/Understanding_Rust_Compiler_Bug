{"sha": "43fd619819b334b8548dca98797bd4c8078636cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzZmQ2MTk4MTliMzM0Yjg1NDhkY2E5ODc5N2JkNGM4MDc4NjM2Y2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-22T23:50:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-22T23:50:30Z"}, "message": "auto merge of #17286 : vberger/rust/deprecated_in_macros, r=aturon\n\nCloses #17185.\r\n\r\nThe stability lint will now check code generated by macro expansion. It will allow to detect :\r\n- arguments passed to macros using deprecated (and others) items\r\n- macro expansion generating code using deprecated items due to its arguments (hence the second commit, fixing such issue found in libcollections)\r\n\r\nChecking is still done at expansion, but it will also detect a macro explicitly using a deprecated item in its definition.", "tree": {"sha": "5d0942d04d12717768a4bab5a2b608a53bf25e69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d0942d04d12717768a4bab5a2b608a53bf25e69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43fd619819b334b8548dca98797bd4c8078636cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43fd619819b334b8548dca98797bd4c8078636cb", "html_url": "https://github.com/rust-lang/rust/commit/43fd619819b334b8548dca98797bd4c8078636cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43fd619819b334b8548dca98797bd4c8078636cb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b5f4563bff67e2727befdb235314726849331a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b5f4563bff67e2727befdb235314726849331a7", "html_url": "https://github.com/rust-lang/rust/commit/4b5f4563bff67e2727befdb235314726849331a7"}, {"sha": "d845857fd915a2044f74711db3b7e71146b35200", "url": "https://api.github.com/repos/rust-lang/rust/commits/d845857fd915a2044f74711db3b7e71146b35200", "html_url": "https://github.com/rust-lang/rust/commit/d845857fd915a2044f74711db3b7e71146b35200"}], "stats": {"total": 136, "additions": 94, "deletions": 42}, "files": [{"sha": "39524ed547d532bfe802d0e3bae15ede41b9fbb7", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43fd619819b334b8548dca98797bd4c8078636cb/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43fd619819b334b8548dca98797bd4c8078636cb/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=43fd619819b334b8548dca98797bd4c8078636cb", "patch": "@@ -311,13 +311,13 @@ mod tests {\n \n         task::spawn(proc() {\n             let arc_v: Arc<Vec<int>> = rx.recv();\n-            assert_eq!(*arc_v.get(3), 4);\n+            assert_eq!((*arc_v)[3], 4);\n         });\n \n         tx.send(arc_v.clone());\n \n-        assert_eq!(*arc_v.get(2), 3);\n-        assert_eq!(*arc_v.get(4), 5);\n+        assert_eq!((*arc_v)[2], 3);\n+        assert_eq!((*arc_v)[4], 5);\n \n         info!(\"{:?}\", arc_v);\n     }"}, {"sha": "9d3be0d14d38599da327571d24269fed0f05205c", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=43fd619819b334b8548dca98797bd4c8078636cb", "patch": "@@ -131,7 +131,7 @@ pub trait MutableMap<K, V>: Map<K, V> + Mutable {\n     /// let mut map = HashMap::new();\n     /// assert_eq!(map.insert(\"key\", 2i), true);\n     /// assert_eq!(map.insert(\"key\", 9i), false);\n-    /// assert_eq!(map.get(&\"key\"), &9i);\n+    /// assert_eq!(map[\"key\"], 9i);\n     /// ```\n     #[inline]\n     fn insert(&mut self, key: K, value: V) -> bool {\n@@ -171,7 +171,7 @@ pub trait MutableMap<K, V>: Map<K, V> + Mutable {\n     ///\n     /// map.insert(\"a\", 1i);\n     /// assert_eq!(map.swap(\"a\", 37i), Some(1i));\n-    /// assert_eq!(map.get(&\"a\"), &37i);\n+    /// assert_eq!(map[\"a\"], 37i);\n     /// ```\n     fn swap(&mut self, k: K, v: V) -> Option<V>;\n \n@@ -203,7 +203,7 @@ pub trait MutableMap<K, V>: Map<K, V> + Mutable {\n     ///     Some(x) => *x = 7i,\n     ///     None => (),\n     /// }\n-    /// assert_eq!(map.get(&\"a\"), &7i);\n+    /// assert_eq!(map[\"a\"], 7i);\n     /// ```\n     fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V>;\n }"}, {"sha": "02c8af2c470f3f3cb5c7905c2dfa234f03d80ea4", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=43fd619819b334b8548dca98797bd4c8078636cb", "patch": "@@ -542,6 +542,7 @@ mod tests {\n     use vec::Vec;\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_simple() {\n         let mut d = RingBuf::new();\n         assert_eq!(d.len(), 0u);\n@@ -587,6 +588,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_boxes() {\n         let a: Gc<int> = box(GC) 5;\n         let b: Gc<int> = box(GC) 72;"}, {"sha": "525dc9cbe805e568c4f532c8ffd1e8b72281803d", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=43fd619819b334b8548dca98797bd4c8078636cb", "patch": "@@ -904,6 +904,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_initn() {\n         let mut a = vec![11i, 12, 13];\n         let b: &[int] = &[11, 12, 13];\n@@ -1303,6 +1304,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_bsearch_elem() {\n         assert_eq!([1i,2,3,4,5].bsearch_elem(&5), Some(4));\n         assert_eq!([1i,2,3,4,5].bsearch_elem(&4), Some(3));\n@@ -1350,11 +1352,11 @@ mod tests {\n     #[test]\n     fn test_reverse() {\n         let mut v: Vec<int> = vec![10i, 20];\n-        assert_eq!(*v.get(0), 10);\n-        assert_eq!(*v.get(1), 20);\n+        assert_eq!(v[0], 10);\n+        assert_eq!(v[1], 20);\n         v.reverse();\n-        assert_eq!(*v.get(0), 20);\n-        assert_eq!(*v.get(1), 10);\n+        assert_eq!(v[0], 20);\n+        assert_eq!(v[1], 10);\n \n         let mut v3: Vec<int> = vec![];\n         v3.reverse();\n@@ -1462,6 +1464,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_shift() {\n         let mut x = vec![1i, 2, 3];\n         assert_eq!(x.shift(), Some(1));\n@@ -1901,6 +1904,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_copy_from() {\n         let mut a = [1i,2,3,4,5];\n         let b = [6i,7,8];"}, {"sha": "94dbf84a4b4b947b88a4b0651b4ed42c5ee23c89", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=43fd619819b334b8548dca98797bd4c8078636cb", "patch": "@@ -348,11 +348,11 @@ impl<V:Clone> SmallIntMap<V> {\n     /// let mut map = SmallIntMap::new();\n     ///\n     /// // Key does not exist, will do a simple insert\n-    /// assert!(map.update(1, vec![1i, 2], |old, new| old.append(new.as_slice())));\n+    /// assert!(map.update(1, vec![1i, 2], |mut old, new| { old.extend(new.into_iter()); old }));\n     /// assert_eq!(map[1], vec![1i, 2]);\n     ///\n     /// // Key exists, update the value\n-    /// assert!(!map.update(1, vec![3i, 4], |old, new| old.append(new.as_slice())));\n+    /// assert!(!map.update(1, vec![3i, 4], |mut old, new| { old.extend(new.into_iter()); old }));\n     /// assert_eq!(map[1], vec![1i, 2, 3, 4]);\n     /// ```\n     pub fn update(&mut self, key: uint, newval: V, ff: |V, V| -> V) -> bool {\n@@ -452,7 +452,7 @@ impl<V> Index<uint, V> for SmallIntMap<V> {\n }*/\n \n macro_rules! iterator {\n-    (impl $name:ident -> $elem:ty, $getter:ident) => {\n+    (impl $name:ident -> $elem:ty, $($getter:ident),+) => {\n         impl<'a, T> Iterator<$elem> for $name<'a, T> {\n             #[inline]\n             fn next(&mut self) -> Option<$elem> {\n@@ -462,7 +462,7 @@ macro_rules! iterator {\n                             if elem.is_some() {\n                                 let index = self.front;\n                                 self.front += 1;\n-                                return Some((index, elem. $getter ()));\n+                                return Some((index, elem $(. $getter ())+));\n                             }\n                         }\n                         _ => ()\n@@ -481,7 +481,7 @@ macro_rules! iterator {\n }\n \n macro_rules! double_ended_iterator {\n-    (impl $name:ident -> $elem:ty, $getter:ident) => {\n+    (impl $name:ident -> $elem:ty, $($getter:ident),+) => {\n         impl<'a, T> DoubleEndedIterator<$elem> for $name<'a, T> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n@@ -490,7 +490,7 @@ macro_rules! double_ended_iterator {\n                         Some(elem) => {\n                             if elem.is_some() {\n                                 self.back -= 1;\n-                                return Some((self.back, elem. $getter ()));\n+                                return Some((self.back, elem$(. $getter ())+));\n                             }\n                         }\n                         _ => ()\n@@ -510,8 +510,8 @@ pub struct Entries<'a, T:'a> {\n     iter: slice::Items<'a, Option<T>>\n }\n \n-iterator!(impl Entries -> (uint, &'a T), get_ref)\n-double_ended_iterator!(impl Entries -> (uint, &'a T), get_ref)\n+iterator!(impl Entries -> (uint, &'a T), as_ref, unwrap)\n+double_ended_iterator!(impl Entries -> (uint, &'a T), as_ref, unwrap)\n \n /// Forward iterator over the key-value pairs of a map, with the\n /// values being mutable.\n@@ -521,8 +521,8 @@ pub struct MutEntries<'a, T:'a> {\n     iter: slice::MutItems<'a, Option<T>>\n }\n \n-iterator!(impl MutEntries -> (uint, &'a mut T), get_mut_ref)\n-double_ended_iterator!(impl MutEntries -> (uint, &'a mut T), get_mut_ref)\n+iterator!(impl MutEntries -> (uint, &'a mut T), as_mut, unwrap)\n+double_ended_iterator!(impl MutEntries -> (uint, &'a mut T), as_mut, unwrap)\n \n /// Forward iterator over the keys of a map\n pub type Keys<'a, T> ="}, {"sha": "e9981790f7dc08689b7e4c13f1ceba4499df7725", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=43fd619819b334b8548dca98797bd4c8078636cb", "patch": "@@ -434,7 +434,7 @@ impl<T> TrieMap<T> {\n     fn bound_mut<'a>(&'a mut self, key: uint, upper: bool) -> MutEntries<'a, T> {\n         bound!(MutEntries, self = self,\n                key = key, is_upper = upper,\n-               slice_from = mut_slice_from, iter = mut_iter,\n+               slice_from = slice_from_mut, iter = iter_mut,\n                mutability = mut)\n     }\n \n@@ -1020,7 +1020,7 @@ macro_rules! iterator_impl {\n }\n \n iterator_impl! { Entries, iter = iter, mutability = }\n-iterator_impl! { MutEntries, iter = mut_iter, mutability = mut }\n+iterator_impl! { MutEntries, iter = iter_mut, mutability = mut }\n \n /// A forward iterator over a set.\n pub struct SetItems<'a> {"}, {"sha": "479a4c3045a6a8b9ffffced13321a054806b846e", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=43fd619819b334b8548dca98797bd4c8078636cb", "patch": "@@ -960,6 +960,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```\n+    /// #![allow(deprecated)]\n     /// let vec = vec![1i, 2, 3, 4];\n     /// assert!(vec.tailn(2) == [3, 4]);\n     /// ```\n@@ -1065,6 +1066,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```\n+    /// #![allow(deprecated)]\n     /// let mut vec = vec![1i, 2, 3];\n     /// assert!(vec.shift() == Some(1));\n     /// assert_eq!(vec, vec![2, 3]);"}, {"sha": "e53f354a97eba864e3da780689390d062ab358bd", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=43fd619819b334b8548dca98797bd4c8078636cb", "patch": "@@ -1062,11 +1062,11 @@ pub trait MutableCloneableSlice<T> {\n     /// let mut dst = [0i, 0, 0];\n     /// let src = [1i, 2];\n     ///\n-    /// assert!(dst.copy_from(src) == 2);\n+    /// assert!(dst.clone_from_slice(src) == 2);\n     /// assert!(dst == [1, 2, 0]);\n     ///\n     /// let src2 = [3i, 4, 5, 6];\n-    /// assert!(dst.copy_from(src2) == 3);\n+    /// assert!(dst.clone_from_slice(src2) == 3);\n     /// assert!(dst == [3i, 4, 5]);\n     /// ```\n     fn clone_from_slice(self, &[T]) -> uint;"}, {"sha": "a25d205e225ecb7d3090106c4783312b7f6e8269", "filename": "src/libcoretest/cmp.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibcoretest%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibcoretest%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcmp.rs?ref=43fd619819b334b8548dca98797bd4c8078636cb", "patch": "@@ -42,6 +42,7 @@ fn test_ordering_order() {\n }\n \n #[test]\n+#[allow(deprecated)]\n fn test_lexical_ordering() {\n     fn t(o1: Ordering, o2: Ordering, e: Ordering) {\n         assert_eq!(lexical_ordering(o1, o2), e);"}, {"sha": "3f150b3d13695ac97dda323ba1c1191556bfbaab", "filename": "src/libcoretest/option.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibcoretest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibcoretest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Foption.rs?ref=43fd619819b334b8548dca98797bd4c8078636cb", "patch": "@@ -244,6 +244,7 @@ fn test_ord() {\n }\n \n #[test]\n+#[allow(deprecated)]\n fn test_mutate() {\n     let mut x = Some(3i);\n     assert!(x.mutate(|i| i+1));"}, {"sha": "31a1bf048ceee516f6d90a24e4647c35a6880f2f", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=43fd619819b334b8548dca98797bd4c8078636cb", "patch": "@@ -1142,7 +1142,7 @@ mod tests {\n           Ok(ref m) => {\n             // The next variable after the flag is just a free argument\n \n-            assert!(*m.free.get(0) == \"20\".to_string());\n+            assert!(m.free[0] == \"20\".to_string());\n           }\n           _ => fail!()\n         }\n@@ -1298,8 +1298,8 @@ mod tests {\n               assert!(m.opt_present(\"t\"));\n               assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_string());\n               let pair = m.opt_strs(\"test\");\n-              assert!(*pair.get(0) == \"20\".to_string());\n-              assert!(*pair.get(1) == \"30\".to_string());\n+              assert!(pair[0] == \"20\".to_string());\n+              assert!(pair[1] == \"30\".to_string());\n           }\n           _ => fail!()\n         }\n@@ -1351,19 +1351,19 @@ mod tests {\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n-            assert!(*m.free.get(0) == \"prog\".to_string());\n-            assert!(*m.free.get(1) == \"free1\".to_string());\n+            assert!(m.free[0] == \"prog\".to_string());\n+            assert!(m.free[1] == \"free1\".to_string());\n             assert_eq!(m.opt_str(\"s\").unwrap(), \"20\".to_string());\n-            assert!(*m.free.get(2) == \"free2\".to_string());\n+            assert!(m.free[2] == \"free2\".to_string());\n             assert!((m.opt_present(\"flag\")));\n             assert_eq!(m.opt_str(\"long\").unwrap(), \"30\".to_string());\n             assert!((m.opt_present(\"f\")));\n             let pair = m.opt_strs(\"m\");\n-            assert!(*pair.get(0) == \"40\".to_string());\n-            assert!(*pair.get(1) == \"50\".to_string());\n+            assert!(pair[0] == \"40\".to_string());\n+            assert!(pair[1] == \"50\".to_string());\n             let pair = m.opt_strs(\"n\");\n-            assert!(*pair.get(0) == \"-A B\".to_string());\n-            assert!(*pair.get(1) == \"-60 70\".to_string());\n+            assert!(pair[0] == \"-A B\".to_string());\n+            assert!(pair[1] == \"-60 70\".to_string());\n             assert!((!m.opt_present(\"notpresent\")));\n           }\n           _ => fail!()"}, {"sha": "596e7e5d931a8d246d2cd3c897269ac185ecb73b", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=43fd619819b334b8548dca98797bd4c8078636cb", "patch": "@@ -336,6 +336,7 @@ impl Pattern {\n      * # Example\n      *\n      * ```rust\n+     * #![allow(deprecated)]\n      * use glob::Pattern;\n      *\n      * assert!(Pattern::new(\"c?t\").matches(\"cat\"));"}, {"sha": "7c786976699468f7c8f2a2aade1da015e2a7ae7c", "filename": "src/libnum/integer.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibnum%2Finteger.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibnum%2Finteger.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Finteger.rs?ref=43fd619819b334b8548dca98797bd4c8078636cb", "patch": "@@ -18,6 +18,7 @@ pub trait Integer: Num + PartialOrd\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// # use num::Integer;\n     /// assert!(( 8i).div_floor(& 3) ==  2);\n     /// assert!(( 8i).div_floor(&-3) == -3);\n@@ -34,6 +35,7 @@ pub trait Integer: Num + PartialOrd\n     /// Floored integer modulo, satisfying:\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// # use num::Integer;\n     /// # let n = 1i; let d = 1i;\n     /// assert!(n.div_floor(&d) * d + n.mod_floor(&d) == n)\n@@ -42,6 +44,7 @@ pub trait Integer: Num + PartialOrd\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// # use num::Integer;\n     /// assert!(( 8i).mod_floor(& 3) ==  2);\n     /// assert!(( 8i).mod_floor(&-3) == -1);\n@@ -60,6 +63,7 @@ pub trait Integer: Num + PartialOrd\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// # use num::Integer;\n     /// assert_eq!(6i.gcd(&8), 2);\n     /// assert_eq!(7i.gcd(&3), 1);\n@@ -71,6 +75,7 @@ pub trait Integer: Num + PartialOrd\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// # use num::Integer;\n     /// assert_eq!(7i.lcm(&3), 21);\n     /// assert_eq!(2i.lcm(&4), 4);\n@@ -86,6 +91,7 @@ pub trait Integer: Num + PartialOrd\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// # use num::Integer;\n     /// assert_eq!(9i.is_multiple_of(&3), true);\n     /// assert_eq!(3i.is_multiple_of(&9), false);\n@@ -97,6 +103,7 @@ pub trait Integer: Num + PartialOrd\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// # use num::Integer;\n     /// assert_eq!(3i.is_even(), false);\n     /// assert_eq!(4i.is_even(), true);\n@@ -108,6 +115,7 @@ pub trait Integer: Num + PartialOrd\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// # use num::Integer;\n     /// assert_eq!(3i.is_odd(), true);\n     /// assert_eq!(4i.is_odd(), false);\n@@ -120,6 +128,7 @@ pub trait Integer: Num + PartialOrd\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// # use num::Integer;\n     /// assert_eq!(( 8i).div_rem( &3), ( 2,  2));\n     /// assert_eq!(( 8i).div_rem(&-3), (-2,  2));\n@@ -142,6 +151,7 @@ pub trait Integer: Num + PartialOrd\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// # use num::Integer;\n     /// assert_eq!(( 8i).div_mod_floor( &3), ( 2,  2));\n     /// assert_eq!(( 8i).div_mod_floor(&-3), (-3, -1));"}, {"sha": "6c3f96bbec64b84125e3a0cd1b73e879081d6e9c", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=43fd619819b334b8548dca98797bd4c8078636cb", "patch": "@@ -1490,8 +1490,27 @@ impl LintPass for Stability {\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        // if the expression was produced by a macro expansion,\n-        if e.span.expn_id != NO_EXPANSION { return }\n+        // skip if `e` is not from macro arguments\n+        let skip = cx.tcx.sess.codemap().with_expn_info(e.span.expn_id, |expninfo| {\n+            match expninfo {\n+                Some(ref info) => {\n+                    if info.call_site.expn_id != NO_EXPANSION ||\n+                       !( e.span.lo > info.call_site.lo && e.span.hi < info.call_site.hi ) {\n+                        // This code is not from the arguments,\n+                        // or this macro call was generated by an other macro\n+                        // We can't handle it.\n+                        true\n+                    } else if info.callee.span.is_none() {\n+                        // We don't want to mess with compiler builtins.\n+                        true\n+                    } else {\n+                        false\n+                    }\n+                },\n+                _ => { false }\n+            }\n+        });\n+        if skip { return; }\n \n         let id = match e.node {\n             ast::ExprPath(..) | ast::ExprStruct(..) => {"}, {"sha": "e7ce5b7dca8cb05f616441053e3efc6c27b4c8db", "filename": "src/librustrt/local_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibrustrt%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibrustrt%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_data.rs?ref=43fd619819b334b8548dca98797bd4c8078636cb", "patch": "@@ -423,7 +423,7 @@ mod tests {\n             // TLD shouldn't carry over.\n             assert!(my_key.get().is_none());\n             my_key.replace(Some(\"child data\".to_string()));\n-            assert!(my_key.get().get_ref().as_slice() == \"child data\");\n+            assert!(my_key.get().as_ref().unwrap().as_slice() == \"child data\");\n             // should be cleaned up for us\n         });\n "}, {"sha": "43a1899f45e0861285431e437212ac19d7dc6890", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43fd619819b334b8548dca98797bd4c8078636cb/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=43fd619819b334b8548dca98797bd4c8078636cb", "patch": "@@ -1519,9 +1519,9 @@ mod tests {\n         let filtered = filter_tests(&opts, tests);\n \n         assert_eq!(filtered.len(), 1);\n-        assert_eq!(filtered.get(0).desc.name.to_string(),\n+        assert_eq!(filtered[0].desc.name.to_string(),\n                    \"1\".to_string());\n-        assert!(filtered.get(0).desc.ignore == false);\n+        assert!(filtered[0].desc.ignore == false);\n     }\n \n     #[test]"}, {"sha": "bae86f04b23b6c243f2732c479ebff2d940b360a", "filename": "src/test/auxiliary/lint_stability.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43fd619819b334b8548dca98797bd4c8078636cb/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43fd619819b334b8548dca98797bd4c8078636cb/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability.rs?ref=43fd619819b334b8548dca98797bd4c8078636cb", "patch": "@@ -181,3 +181,13 @@ pub struct LockedTupleStruct(pub int);\n macro_rules! macro_test(\n     () => (deprecated());\n )\n+\n+#[macro_export]\n+macro_rules! macro_test_arg(\n+    ($func:expr) => ($func);\n+)\n+\n+#[macro_export]\n+macro_rules! macro_test_arg_nested(\n+    ($func:ident) => (macro_test_arg!($func()));\n+)"}, {"sha": "6a36e2707404785a7983567abf2c1eb844fa8bad", "filename": "src/test/compile-fail/lint-stability.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43fd619819b334b8548dca98797bd4c8078636cb/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43fd619819b334b8548dca98797bd4c8078636cb/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability.rs?ref=43fd619819b334b8548dca98797bd4c8078636cb", "patch": "@@ -109,12 +109,14 @@ mod cross_crate {\n         let _ = FrozenTupleStruct (1);\n         let _ = LockedTupleStruct (1);\n \n-        // At the moment, the following just checks that the stability\n-        // level of expanded code does not trigger the\n-        // lint. Eventually, we will want to lint the contents of the\n+        // At the moment, the lint checker only checks stability in\n+        // in the arguments of macros.\n+        // Eventually, we will want to lint the contents of the\n         // macro in the module *defining* it. Also, stability levels\n         // on macros themselves are not yet linted.\n         macro_test!();\n+        macro_test_arg!(deprecated_text()); //~ ERROR use of deprecated item: text\n+        macro_test_arg_nested!(deprecated_text);\n     }\n \n     fn test_method_param<F: Trait>(foo: F) {"}]}