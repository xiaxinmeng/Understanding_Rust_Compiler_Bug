{"sha": "9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljMTg1MTAxOWYxZWY5NTExZmE4NzMxYjhmMWFjYjA3OTZkMWU5N2Y=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-26T00:04:37Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-03T23:15:42Z"}, "message": "Remove all blocking std::os blocking functions\n\nThis commit moves all thread-blocking I/O functions from the std::os module.\nTheir replacements can be found in either std::rt::io::file or in a hidden\n\"old_os\" module inside of native::file. I didn't want to outright delete these\nfunctions because they have a lot of special casing learned over time for each\nOS/platform, and I imagine that these will someday get integrated into a\nblocking implementation of IoFactory. For now, they're moved to a private module\nto prevent bitrot and still have tests to ensure that they work.\n\nI've also expanded the extensions to a few more methods defined on Path, most of\nwhich were previously defined in std::os but now have non-thread-blocking\nimplementations as part of using the current IoFactory.\n\nThe api of io::file is in flux, but I plan on changing it in the next commit as\nwell.\n\nCloses #10057", "tree": {"sha": "0cd6d600bfc077e1d19722afdb042c9c016db621", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cd6d600bfc077e1d19722afdb042c9c016db621"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "html_url": "https://github.com/rust-lang/rust/commit/9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bf58c2baaac3f7cb3c8e8d735b27ac9e7d3cd78", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bf58c2baaac3f7cb3c8e8d735b27ac9e7d3cd78", "html_url": "https://github.com/rust-lang/rust/commit/7bf58c2baaac3f7cb3c8e8d735b27ac9e7d3cd78"}], "stats": {"total": 2855, "additions": 1363, "deletions": 1492}, "files": [{"sha": "a24791d76af975d8a54c26d161fdba7be6aa58f7", "filename": "mk/tests.mk", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -517,8 +517,8 @@ CTEST_BUILD_BASE_rpass = run-pass\n CTEST_MODE_rpass = run-pass\n CTEST_RUNTOOL_rpass = $(CTEST_RUNTOOL)\n \n-CTEST_SRC_BASE_rpass-full = run-pass-full\n-CTEST_BUILD_BASE_rpass-full = run-pass-full\n+CTEST_SRC_BASE_rpass-full = run-pass-fulldeps\n+CTEST_BUILD_BASE_rpass-full = run-pass-fulldeps\n CTEST_MODE_rpass-full = run-pass\n CTEST_RUNTOOL_rpass-full = $(CTEST_RUNTOOL)\n \n@@ -673,7 +673,7 @@ PRETTY_DEPS_pretty-rfail = $(RFAIL_TESTS)\n PRETTY_DEPS_pretty-bench = $(BENCH_TESTS)\n PRETTY_DEPS_pretty-pretty = $(PRETTY_TESTS)\n PRETTY_DIRNAME_pretty-rpass = run-pass\n-PRETTY_DIRNAME_pretty-rpass-full = run-pass-full\n+PRETTY_DIRNAME_pretty-rpass-full = run-pass-fulldeps\n PRETTY_DIRNAME_pretty-rfail = run-fail\n PRETTY_DIRNAME_pretty-bench = bench\n PRETTY_DIRNAME_pretty-pretty = pretty"}, {"sha": "a354bc84e52b5920bcfc0daf99d1d812890c6b55", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -17,6 +17,7 @@ extern mod extra;\n \n use std::os;\n use std::rt;\n+use std::rt::io::file;\n \n use extra::getopts;\n use extra::getopts::groups::{optopt, optflag, reqopt};\n@@ -247,7 +248,7 @@ pub fn make_tests(config: &config) -> ~[test::TestDescAndFn] {\n     debug!(\"making tests from {}\",\n            config.src_base.display());\n     let mut tests = ~[];\n-    let dirs = os::list_dir_path(&config.src_base);\n+    let dirs = file::readdir(&config.src_base);\n     for file in dirs.iter() {\n         let file = file.clone();\n         debug!(\"inspecting file {}\", file.display());"}, {"sha": "dfadea37cd0d34175eb62aa32e806b37acda2ad3", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -8,16 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::rt::io::buffered::BufferedReader;\n+use std::rt::io::file;\n+\n pub struct ExpectedError { line: uint, kind: ~str, msg: ~str }\n \n // Load any test directives embedded in the file\n pub fn load_errors(testfile: &Path) -> ~[ExpectedError] {\n-    use std::rt::io::Open;\n-    use std::rt::io::file::FileInfo;\n-    use std::rt::io::buffered::BufferedReader;\n \n     let mut error_patterns = ~[];\n-    let mut rdr = BufferedReader::new(testfile.open_reader(Open).unwrap());\n+    let mut rdr = BufferedReader::new(file::open(testfile).unwrap());\n     let mut line_num = 1u;\n     loop {\n         let ln = match rdr.read_line() {"}, {"sha": "68e8fd76735424179ad497a039e67fb83b7f2cfe", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -103,11 +103,10 @@ pub fn is_test_ignored(config: &config, testfile: &Path) -> bool {\n }\n \n fn iter_header(testfile: &Path, it: &fn(&str) -> bool) -> bool {\n-    use std::rt::io::Open;\n-    use std::rt::io::file::FileInfo;\n     use std::rt::io::buffered::BufferedReader;\n+    use std::rt::io::file;\n \n-    let mut rdr = BufferedReader::new(testfile.open_reader(Open).unwrap());\n+    let mut rdr = BufferedReader::new(file::open(testfile).unwrap());\n     loop {\n         let ln = match rdr.read_line() {\n             Some(ln) => ln, None => break"}, {"sha": "7fc13467217fba94c60593e56e951a81c4fbc306", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -22,9 +22,7 @@ use util::logv;\n \n use std::cell::Cell;\n use std::rt::io;\n-use std::rt::io::Writer;\n-use std::rt::io::Reader;\n-use std::rt::io::file::FileInfo;\n+use std::rt::io::file;\n use std::os;\n use std::str;\n use std::task::{spawn_sched, SingleThreaded};\n@@ -173,7 +171,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     let rounds =\n         match props.pp_exact { Some(_) => 1, None => 2 };\n \n-    let src = testfile.open_reader(io::Open).read_to_end();\n+    let src = file::open(testfile).read_to_end();\n     let src = str::from_utf8_owned(src);\n     let mut srcs = ~[src];\n \n@@ -195,7 +193,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     let mut expected = match props.pp_exact {\n         Some(ref file) => {\n             let filepath = testfile.dir_path().join(file);\n-            let s = filepath.open_reader(io::Open).read_to_end();\n+            let s = file::open(&filepath).read_to_end();\n             str::from_utf8_owned(s)\n           }\n           None => { srcs[srcs.len() - 2u].clone() }\n@@ -651,10 +649,8 @@ fn compose_and_run_compiler(\n }\n \n fn ensure_dir(path: &Path) {\n-    if os::path_is_dir(path) { return; }\n-    if !os::make_dir(path, 0x1c0i32) {\n-        fail!(\"can't make dir {}\", path.display());\n-    }\n+    if path.is_dir() { return; }\n+    file::mkdir(path, io::UserRWX);\n }\n \n fn compose_and_run(config: &config, testfile: &Path,\n@@ -768,7 +764,7 @@ fn dump_output(config: &config, testfile: &Path, out: &str, err: &str) {\n fn dump_output_file(config: &config, testfile: &Path,\n                     out: &str, extension: &str) {\n     let outfile = make_out_name(config, testfile, extension);\n-    outfile.open_writer(io::CreateOrTruncate).write(out.as_bytes());\n+    file::create(&outfile).write(out.as_bytes());\n }\n \n fn make_out_name(config: &config, testfile: &Path, extension: &str) -> Path {\n@@ -924,7 +920,7 @@ fn _dummy_exec_compiled_test(config: &config, props: &TestProps,\n fn _arm_push_aux_shared_library(config: &config, testfile: &Path) {\n     let tdir = aux_output_dir_name(config, testfile);\n \n-    let dirs = os::list_dir_path(&tdir);\n+    let dirs = file::readdir(&tdir);\n     for file in dirs.iter() {\n         if file.extension_str() == Some(\"so\") {\n             // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -1019,7 +1015,7 @@ fn disassemble_extract(config: &config, _props: &TestProps,\n \n \n fn count_extracted_lines(p: &Path) -> uint {\n-    let x = p.with_extension(\"ll\").open_reader(io::Open).read_to_end();\n+    let x = file::open(&p.with_extension(\"ll\")).read_to_end();\n     let x = str::from_utf8_owned(x);\n     x.line_iter().len()\n }"}, {"sha": "a7742f771da3cbdc0411ca27088f7b30f11ad435", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -24,6 +24,8 @@\n  */\n \n use std::{os, path};\n+use std::rt::io;\n+use std::rt::io::file;\n use std::path::is_sep;\n \n use sort;\n@@ -146,9 +148,14 @@ impl Iterator<Path> for GlobIterator {\n }\n \n fn list_dir_sorted(path: &Path) -> ~[Path] {\n-    let mut children = os::list_dir_path(path);\n-    sort::quick_sort(children, |p1, p2| p2.filename().unwrap() <= p1.filename().unwrap());\n-    children\n+    match io::result(|| file::readdir(path)) {\n+        Ok(children) => {\n+            let mut children = children;\n+            sort::quick_sort(children, |p1, p2| p2.filename() <= p1.filename());\n+            children\n+        }\n+        Err(*) => ~[]\n+    }\n }\n \n /**"}, {"sha": "4affe7c1cde8ac3d8939d4f5c12e853ef26341a8", "filename": "src/libextra/tempfile.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibextra%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibextra%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftempfile.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -14,6 +14,8 @@\n use std::os;\n use std::rand::Rng;\n use std::rand;\n+use std::rt::io;\n+use std::rt::io::file;\n \n /// A wrapper for a path to temporary directory implementing automatic\n /// scope-pased deletion.\n@@ -36,8 +38,9 @@ impl TempDir {\n         let mut r = rand::rng();\n         for _ in range(0u, 1000) {\n             let p = tmpdir.join(r.gen_ascii_str(16) + suffix);\n-            if os::make_dir(&p, 0x1c0) { // 700\n-                return Some(TempDir { path: Some(p) });\n+            match io::result(|| file::mkdir(&p, io::UserRWX)) {\n+                Err(*) => {}\n+                Ok(()) => return Some(TempDir { path: Some(p) })\n             }\n         }\n         None\n@@ -69,7 +72,9 @@ impl TempDir {\n impl Drop for TempDir {\n     fn drop(&mut self) {\n         for path in self.path.iter() {\n-            os::remove_dir_recursive(path);\n+            if path.exists() {\n+                file::rmdir_recursive(path);\n+            }\n         }\n     }\n }"}, {"sha": "c5509f8aec7d7058b78810e4c6578ca508576fa3", "filename": "src/libextra/terminfo/searcher.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fsearcher.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -14,7 +14,7 @@\n use std::{os, str};\n use std::os::getenv;\n use std::rt::io;\n-use std::rt::io::file::FileInfo;\n+use std::rt::io::file;\n \n /// Return path to database entry for `term`\n pub fn get_dbpath_for_term(term: &str) -> Option<~Path> {\n@@ -56,16 +56,16 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~Path> {\n \n     // Look for the terminal in all of the search directories\n     for p in dirs_to_search.iter() {\n-        if os::path_exists(p) {\n+        if p.exists() {\n             let f = str::from_char(first_char);\n             let newp = p.join_many([f.as_slice(), term]);\n-            if os::path_exists(&newp) {\n+            if newp.exists() {\n                 return Some(~newp);\n             }\n             // on some installations the dir is named after the hex of the char (e.g. OS X)\n             let f = format!(\"{:x}\", first_char as uint);\n             let newp = p.join_many([f.as_slice(), term]);\n-            if os::path_exists(&newp) {\n+            if newp.exists() {\n                 return Some(~newp);\n             }\n         }\n@@ -76,7 +76,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~Path> {\n /// Return open file for `term`\n pub fn open(term: &str) -> Result<@mut io::Reader, ~str> {\n     match get_dbpath_for_term(term) {\n-        Some(x) => Ok(@mut x.open_reader(io::Open).unwrap() as @mut io::Reader),\n+        Some(x) => Ok(@mut file::open(x) as @mut io::Reader),\n         None => Err(format!(\"could not find terminfo entry for {}\", term))\n     }\n }"}, {"sha": "497d4206fe327932a20c5a395adf2f403b3b7f2a", "filename": "src/libextra/test.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -31,7 +31,7 @@ use treemap::TreeMap;\n use std::clone::Clone;\n use std::comm::{stream, SharedChan, GenericPort, GenericChan};\n use std::rt::io;\n-use std::rt::io::file::FileInfo;\n+use std::rt::io::file;\n use std::task;\n use std::to_str::ToStr;\n use std::f64;\n@@ -353,10 +353,7 @@ struct ConsoleTestState {\n impl ConsoleTestState {\n     pub fn new(opts: &TestOpts) -> ConsoleTestState {\n         let log_out = match opts.logfile {\n-            Some(ref path) => {\n-                let out = path.open_writer(io::CreateOrTruncate);\n-                Some(@mut out as @mut io::Writer)\n-            },\n+            Some(ref path) => Some(@mut file::create(path) as @mut io::Writer),\n             None => None\n         };\n         let out = @mut io::stdio::stdout() as @mut io::Writer;\n@@ -938,16 +935,15 @@ impl MetricMap {\n \n     /// Load MetricDiff from a file.\n     pub fn load(p: &Path) -> MetricMap {\n-        assert!(os::path_exists(p));\n-        let f = @mut p.open_reader(io::Open) as @mut io::Reader;\n+        assert!(p.exists());\n+        let f = @mut file::open(p) as @mut io::Reader;\n         let mut decoder = json::Decoder(json::from_reader(f).unwrap());\n         MetricMap(Decodable::decode(&mut decoder))\n     }\n \n     /// Write MetricDiff to a file.\n     pub fn save(&self, p: &Path) {\n-        let f = @mut p.open_writer(io::CreateOrTruncate);\n-        self.to_json().to_pretty_writer(f as @mut io::Writer);\n+        self.to_json().to_pretty_writer(@mut file::create(p) as @mut io::Writer);\n     }\n \n     /// Compare against another MetricMap. Optionally compare all\n@@ -1032,7 +1028,7 @@ impl MetricMap {\n     /// `MetricChange`s are `Regression`. Returns the diff as well\n     /// as a boolean indicating whether the ratchet succeeded.\n     pub fn ratchet(&self, p: &Path, pct: Option<f64>) -> (MetricDiff, bool) {\n-        let old = if os::path_exists(p) {\n+        let old = if p.exists() {\n             MetricMap::load(p)\n         } else {\n             MetricMap::new()"}, {"sha": "54ce349a0b484dd722cb9ada18f891ea47de9129", "filename": "src/libextra/uuid.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibextra%2Fuuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibextra%2Fuuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuuid.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -792,7 +792,6 @@ mod test {\n \n     #[test]\n     fn test_serialize_round_trip() {\n-        use std;\n         use ebml;\n         use serialize::{Encodable, Decodable};\n "}, {"sha": "b2be4cf811b3272220af20356c3dcc018f2c5a85", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -17,13 +17,11 @@ use arc::{Arc,RWArc};\n use treemap::TreeMap;\n use std::cell::Cell;\n use std::comm::{PortOne, oneshot};\n-use std::{os, str, task};\n+use std::{str, task};\n use std::rt::io;\n-use std::rt::io::Writer;\n-use std::rt::io::Reader;\n+use std::rt::io::file;\n use std::rt::io::Decorator;\n use std::rt::io::mem::MemWriter;\n-use std::rt::io::file::FileInfo;\n \n /**\n *\n@@ -145,7 +143,7 @@ impl Database {\n             db_cache: TreeMap::new(),\n             db_dirty: false\n         };\n-        if os::path_exists(&rslt.db_filename) {\n+        if rslt.db_filename.exists() {\n             rslt.load();\n         }\n         rslt\n@@ -178,19 +176,19 @@ impl Database {\n \n     // FIXME #4330: This should have &mut self and should set self.db_dirty to false.\n     fn save(&self) {\n-        let f = @mut self.db_filename.open_writer(io::CreateOrTruncate);\n+        let f = @mut file::create(&self.db_filename);\n         self.db_cache.to_json().to_pretty_writer(f as @mut io::Writer);\n     }\n \n     fn load(&mut self) {\n         assert!(!self.db_dirty);\n-        assert!(os::path_exists(&self.db_filename));\n-        let f = self.db_filename.open_reader(io::Open);\n-        match f {\n-            None => fail!(\"Couldn't load workcache database {}\",\n-                          self.db_filename.display()),\n-            Some(r) =>\n-                match json::from_reader(@mut r as @mut io::Reader) {\n+        assert!(self.db_filename.exists());\n+        match io::result(|| file::open(&self.db_filename)) {\n+            Err(e) => fail!(\"Couldn't load workcache database {}: {}\",\n+                            self.db_filename.display(),\n+                            e.desc),\n+            Ok(r) =>\n+                match json::from_reader(@mut r.unwrap() as @mut io::Reader) {\n                     Err(e) => fail!(\"Couldn't parse workcache database (from file {}): {}\",\n                                     self.db_filename.display(), e.to_str()),\n                     Ok(r) => {\n@@ -482,23 +480,21 @@ impl<'self, T:Send +\n #[test]\n fn test() {\n     use std::{os, run};\n-    use std::rt::io::Reader;\n+    use std::rt::io::file;\n     use std::str::from_utf8_owned;\n \n     // Create a path to a new file 'filename' in the directory in which\n     // this test is running.\n     fn make_path(filename: ~str) -> Path {\n         let pth = os::self_exe_path().expect(\"workcache::test failed\").with_filename(filename);\n-        if os::path_exists(&pth) {\n-            os::remove_file(&pth);\n+        if pth.exists() {\n+            file::unlink(&pth);\n         }\n         return pth;\n     }\n \n     let pth = make_path(~\"foo.c\");\n-    {\n-        pth.open_writer(io::Create).write(bytes!(\"int main() { return 0; }\"));\n-    }\n+    file::create(&pth).write(bytes!(\"int main() { return 0; }\"));\n \n     let db_path = make_path(~\"db.json\");\n \n@@ -511,7 +507,7 @@ fn test() {\n         let subcx = cx.clone();\n         let pth = pth.clone();\n \n-        let file_content = from_utf8_owned(pth.open_reader(io::Open).read_to_end());\n+        let file_content = from_utf8_owned(file::open(&pth).read_to_end());\n \n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prep.declare_input(\"file\", pth.as_str().unwrap(), file_content);"}, {"sha": "7d044ba998fdbdaa4d3c97c2e875632432e1f004", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -27,12 +27,11 @@ use std::char;\n use std::hash::Streaming;\n use std::hash;\n use std::os::consts::{macos, freebsd, linux, android, win32};\n-use std::os;\n use std::ptr;\n-use std::rt::io::Writer;\n use std::run;\n use std::str;\n use std::vec;\n+use std::rt::io::file;\n use syntax::ast;\n use syntax::ast_map::{path, path_mod, path_name, path_pretty_name};\n use syntax::attr;\n@@ -951,20 +950,18 @@ pub fn link_binary(sess: Session,\n \n     // Remove the temporary object file if we aren't saving temps\n     if !sess.opts.save_temps {\n-        if ! os::remove_file(obj_filename) {\n-            sess.warn(format!(\"failed to delete object file `{}`\",\n-                           obj_filename.display()));\n-        }\n+        file::unlink(obj_filename);\n     }\n }\n \n fn is_writeable(p: &Path) -> bool {\n+    use std::rt::io;\n     use std::libc::consts::os::posix88::S_IWUSR;\n \n-    !os::path_exists(p) ||\n-        (match p.get_mode() {\n-            None => false,\n-            Some(m) => m & S_IWUSR as uint == S_IWUSR as uint\n+    !p.exists() ||\n+        (match io::result(|| p.stat()) {\n+            Err(*) => false,\n+            Ok(m) => (m.mode as uint) & S_IWUSR as uint == S_IWUSR as uint\n         })\n }\n "}, {"sha": "1526b5ad9c66a74dddcc08737f4df20a0a26ab80", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -27,6 +27,7 @@ use util::ppaux;\n \n use std::hashmap::{HashMap,HashSet};\n use std::rt::io;\n+use std::rt::io::file;\n use std::rt::io::mem::MemReader;\n use std::os;\n use std::vec;\n@@ -369,7 +370,7 @@ pub fn phase_5_run_llvm_passes(sess: Session,\n \n         // Remove assembly source unless --save-temps was specified\n         if !sess.opts.save_temps {\n-            os::remove_file(&asm_filename);\n+            file::unlink(&asm_filename);\n         }\n     } else {\n         time(sess.time_passes(), \"LLVM passes\", (), |_|"}, {"sha": "44e43bd4ef3a6d6adc086da73936bbfbafab4166", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -11,6 +11,8 @@\n \n use std::option;\n use std::os;\n+use std::rt::io;\n+use std::rt::io::file;\n use std::hashmap::HashSet;\n \n pub enum FileMatch { FileMatches, FileDoesntMatch }\n@@ -117,22 +119,26 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n pub fn search(filesearch: @FileSearch, pick: pick) {\n     do filesearch.for_each_lib_search_path() |lib_search_path| {\n         debug!(\"searching {}\", lib_search_path.display());\n-        let r = os::list_dir_path(lib_search_path);\n-        let mut rslt = FileDoesntMatch;\n-        for path in r.iter() {\n-            debug!(\"testing {}\", path.display());\n-            let maybe_picked = pick(path);\n-            match maybe_picked {\n-                FileMatches => {\n-                    debug!(\"picked {}\", path.display());\n-                    rslt = FileMatches;\n-                }\n-                FileDoesntMatch => {\n-                    debug!(\"rejected {}\", path.display());\n+        match io::result(|| file::readdir(lib_search_path)) {\n+            Ok(files) => {\n+                let mut rslt = FileDoesntMatch;\n+                for path in files.iter() {\n+                    debug!(\"testing {}\", path.display());\n+                    let maybe_picked = pick(path);\n+                    match maybe_picked {\n+                        FileMatches => {\n+                            debug!(\"picked {}\", path.display());\n+                            rslt = FileMatches;\n+                        }\n+                        FileDoesntMatch => {\n+                            debug!(\"rejected {}\", path.display());\n+                        }\n+                    }\n                 }\n+                rslt\n             }\n+            Err(*) => FileDoesntMatch,\n         }\n-        rslt\n     };\n }\n \n@@ -210,15 +216,15 @@ pub fn rust_path() -> ~[Path] {\n             break\n         }\n         cwd.set_filename(\".rust\");\n-        if !env_rust_path.contains(&cwd) && os::path_exists(&cwd) {\n+        if !env_rust_path.contains(&cwd) && cwd.exists() {\n             env_rust_path.push(cwd.clone());\n         }\n         cwd.pop();\n     }\n     let h = os::homedir();\n     for h in h.iter() {\n         let p = h.join(\".rust\");\n-        if !env_rust_path.contains(&p) && os::path_exists(&p) {\n+        if !env_rust_path.contains(&p) && p.exists() {\n             env_rust_path.push(p);\n         }\n     }"}, {"sha": "fd7ba7c04527719172528786912c74fc4031c9e6", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 29, "deletions": 38, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -40,10 +40,8 @@ use std::fmt;\n use std::hashmap::{HashMap, HashSet};\n use std::local_data;\n use std::rt::io::buffered::BufferedWriter;\n-use std::rt::io::file::{FileInfo, DirectoryInfo};\n-use std::rt::io::file;\n use std::rt::io;\n-use std::rt::io::Reader;\n+use std::rt::io::file;\n use std::os;\n use std::str;\n use std::task;\n@@ -265,8 +263,8 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n     // Publish the search index\n     {\n         dst.push(\"search-index.js\");\n-        let mut w = BufferedWriter::new(dst.open_writer(io::CreateOrTruncate));\n-        let w = &mut w as &mut io::Writer;\n+        let mut w = BufferedWriter::new(file::create(&dst).unwrap());\n+        let w = &mut w as &mut Writer;\n         write!(w, \"var searchIndex = [\");\n         for (i, item) in cache.search_index.iter().enumerate() {\n             if i > 0 { write!(w, \",\"); }\n@@ -315,8 +313,7 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n /// Writes the entire contents of a string to a destination, not attempting to\n /// catch any errors.\n fn write(dst: Path, contents: &str) {\n-    let mut w = dst.open_writer(io::CreateOrTruncate);\n-    w.write(contents.as_bytes());\n+    file::create(&dst).write(contents.as_bytes());\n }\n \n /// Makes a directory on the filesystem, failing the task if an error occurs and\n@@ -328,7 +325,7 @@ fn mkdir(path: &Path) {\n         fail!()\n     }).inside {\n         if !path.is_dir() {\n-            file::mkdir(path);\n+            file::mkdir(path, io::UserRWX);\n         }\n     }\n }\n@@ -419,16 +416,13 @@ impl<'self> SourceCollector<'self> {\n         let mut contents = ~[];\n         {\n             let mut buf = [0, ..1024];\n-            let r = do io::io_error::cond.trap(|_| {}).inside {\n-                p.open_reader(io::Open)\n-            };\n             // If we couldn't open this file, then just returns because it\n             // probably means that it's some standard library macro thing and we\n             // can't have the source to it anyway.\n-            let mut r = match r {\n-                Some(r) => r,\n+            let mut r = match io::result(|| file::open(&p)) {\n+                Ok(r) => r,\n                 // eew macro hacks\n-                None => return filename == \"<std-macros>\"\n+                Err(*) => return filename == \"<std-macros>\"\n             };\n \n             // read everything\n@@ -451,16 +445,15 @@ impl<'self> SourceCollector<'self> {\n         }\n \n         cur.push(p.filename().expect(\"source has no filename\") + bytes!(\".html\"));\n-        let w = cur.open_writer(io::CreateOrTruncate);\n-        let mut w = BufferedWriter::new(w);\n+        let mut w = BufferedWriter::new(file::create(&cur).unwrap());\n \n         let title = cur.filename_display().with_str(|s| format!(\"{} -- source\", s));\n         let page = layout::Page {\n             title: title,\n             ty: \"source\",\n             root_path: root_path,\n         };\n-        layout::render(&mut w as &mut io::Writer, &self.cx.layout,\n+        layout::render(&mut w as &mut Writer, &self.cx.layout,\n                        &page, &(\"\"), &Source(contents.as_slice()));\n         w.flush();\n         return true;\n@@ -774,7 +767,7 @@ impl Context {\n     ///\n     /// The rendering driver uses this closure to queue up more work.\n     fn item(&mut self, item: clean::Item, f: &fn(&mut Context, clean::Item)) {\n-        fn render(w: io::file::FileWriter, cx: &mut Context, it: &clean::Item,\n+        fn render(w: file::FileWriter, cx: &mut Context, it: &clean::Item,\n                   pushname: bool) {\n             // A little unfortunate that this is done like this, but it sure\n             // does make formatting *a lot* nicer.\n@@ -796,7 +789,7 @@ impl Context {\n             // of the pain by using a buffered writer instead of invoking the\n             // write sycall all the time.\n             let mut writer = BufferedWriter::new(w);\n-            layout::render(&mut writer as &mut io::Writer, &cx.layout, &page,\n+            layout::render(&mut writer as &mut Writer, &cx.layout, &page,\n                            &Sidebar{ cx: cx, item: it },\n                            &Item{ cx: cx, item: it });\n             writer.flush();\n@@ -811,8 +804,7 @@ impl Context {\n                 do self.recurse(name) |this| {\n                     let item = item.take();\n                     let dst = this.dst.join(\"index.html\");\n-                    let writer = dst.open_writer(io::CreateOrTruncate);\n-                    render(writer.unwrap(), this, &item, false);\n+                    render(file::create(&dst).unwrap(), this, &item, false);\n \n                     let m = match item.inner {\n                         clean::ModuleItem(m) => m,\n@@ -829,8 +821,7 @@ impl Context {\n             // pages dedicated to them.\n             _ if item.name.is_some() => {\n                 let dst = self.dst.join(item_path(&item));\n-                let writer = dst.open_writer(io::CreateOrTruncate);\n-                render(writer.unwrap(), self, &item, true);\n+                render(file::create(&dst).unwrap(), self, &item, true);\n             }\n \n             _ => {}\n@@ -967,7 +958,7 @@ fn shorter<'a>(s: Option<&'a str>) -> &'a str {\n     }\n }\n \n-fn document(w: &mut io::Writer, item: &clean::Item) {\n+fn document(w: &mut Writer, item: &clean::Item) {\n     match item.doc_value() {\n         Some(s) => {\n             write!(w, \"<div class='docblock'>{}</div>\", Markdown(s));\n@@ -976,7 +967,7 @@ fn document(w: &mut io::Writer, item: &clean::Item) {\n     }\n }\n \n-fn item_module(w: &mut io::Writer, cx: &Context,\n+fn item_module(w: &mut Writer, cx: &Context,\n                item: &clean::Item, items: &[clean::Item]) {\n     document(w, item);\n     debug!(\"{:?}\", items);\n@@ -1123,7 +1114,7 @@ fn item_module(w: &mut io::Writer, cx: &Context,\n     write!(w, \"</table>\");\n }\n \n-fn item_function(w: &mut io::Writer, it: &clean::Item, f: &clean::Function) {\n+fn item_function(w: &mut Writer, it: &clean::Item, f: &clean::Function) {\n     write!(w, \"<pre class='fn'>{vis}{purity}fn {name}{generics}{decl}</pre>\",\n            vis = VisSpace(it.visibility),\n            purity = PuritySpace(f.purity),\n@@ -1133,7 +1124,7 @@ fn item_function(w: &mut io::Writer, it: &clean::Item, f: &clean::Function) {\n     document(w, it);\n }\n \n-fn item_trait(w: &mut io::Writer, it: &clean::Item, t: &clean::Trait) {\n+fn item_trait(w: &mut Writer, it: &clean::Item, t: &clean::Trait) {\n     let mut parents = ~\"\";\n     if t.parents.len() > 0 {\n         parents.push_str(\": \");\n@@ -1176,7 +1167,7 @@ fn item_trait(w: &mut io::Writer, it: &clean::Item, t: &clean::Trait) {\n     // Trait documentation\n     document(w, it);\n \n-    fn meth(w: &mut io::Writer, m: &clean::TraitMethod) {\n+    fn meth(w: &mut Writer, m: &clean::TraitMethod) {\n         write!(w, \"<h3 id='{}.{}' class='method'><code>\",\n                shortty(m.item()),\n                *m.item().name.get_ref());\n@@ -1234,8 +1225,8 @@ fn item_trait(w: &mut io::Writer, it: &clean::Item, t: &clean::Trait) {\n     }\n }\n \n-fn render_method(w: &mut io::Writer, meth: &clean::Item, withlink: bool) {\n-    fn fun(w: &mut io::Writer, it: &clean::Item, purity: ast::purity,\n+fn render_method(w: &mut Writer, meth: &clean::Item, withlink: bool) {\n+    fn fun(w: &mut Writer, it: &clean::Item, purity: ast::purity,\n            g: &clean::Generics, selfty: &clean::SelfTy, d: &clean::FnDecl,\n            withlink: bool) {\n         write!(w, \"{}fn {withlink, select,\n@@ -1264,7 +1255,7 @@ fn render_method(w: &mut io::Writer, meth: &clean::Item, withlink: bool) {\n     }\n }\n \n-fn item_struct(w: &mut io::Writer, it: &clean::Item, s: &clean::Struct) {\n+fn item_struct(w: &mut Writer, it: &clean::Item, s: &clean::Struct) {\n     write!(w, \"<pre class='struct'>\");\n     render_struct(w, it, Some(&s.generics), s.struct_type, s.fields,\n                   s.fields_stripped, \"\", true);\n@@ -1288,7 +1279,7 @@ fn item_struct(w: &mut io::Writer, it: &clean::Item, s: &clean::Struct) {\n     render_methods(w, it);\n }\n \n-fn item_enum(w: &mut io::Writer, it: &clean::Item, e: &clean::Enum) {\n+fn item_enum(w: &mut Writer, it: &clean::Item, e: &clean::Enum) {\n     write!(w, \"<pre class='enum'>{}enum {}{}\",\n            VisSpace(it.visibility),\n            it.name.get_ref().as_slice(),\n@@ -1365,7 +1356,7 @@ fn item_enum(w: &mut io::Writer, it: &clean::Item, e: &clean::Enum) {\n     render_methods(w, it);\n }\n \n-fn render_struct(w: &mut io::Writer, it: &clean::Item,\n+fn render_struct(w: &mut Writer, it: &clean::Item,\n                  g: Option<&clean::Generics>,\n                  ty: doctree::StructType,\n                  fields: &[clean::Item],\n@@ -1418,7 +1409,7 @@ fn render_struct(w: &mut io::Writer, it: &clean::Item,\n     }\n }\n \n-fn render_methods(w: &mut io::Writer, it: &clean::Item) {\n+fn render_methods(w: &mut Writer, it: &clean::Item) {\n     do local_data::get(cache_key) |cache| {\n         let cache = cache.unwrap();\n         do cache.read |c| {\n@@ -1453,7 +1444,7 @@ fn render_methods(w: &mut io::Writer, it: &clean::Item) {\n     }\n }\n \n-fn render_impl(w: &mut io::Writer, i: &clean::Impl, dox: &Option<~str>) {\n+fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n     write!(w, \"<h3 class='impl'><code>impl{} \", i.generics);\n     let trait_id = match i.trait_ {\n         Some(ref ty) => {\n@@ -1474,7 +1465,7 @@ fn render_impl(w: &mut io::Writer, i: &clean::Impl, dox: &Option<~str>) {\n         None => {}\n     }\n \n-    fn docmeth(w: &mut io::Writer, item: &clean::Item) -> bool {\n+    fn docmeth(w: &mut Writer, item: &clean::Item) -> bool {\n         write!(w, \"<h4 id='method.{}' class='method'><code>\",\n                *item.name.get_ref());\n         render_method(w, item, false);\n@@ -1552,7 +1543,7 @@ fn render_impl(w: &mut io::Writer, i: &clean::Impl, dox: &Option<~str>) {\n     write!(w, \"</div>\");\n }\n \n-fn item_typedef(w: &mut io::Writer, it: &clean::Item, t: &clean::Typedef) {\n+fn item_typedef(w: &mut Writer, it: &clean::Item, t: &clean::Typedef) {\n     write!(w, \"<pre class='typedef'>type {}{} = {};</pre>\",\n            it.name.get_ref().as_slice(),\n            t.generics,\n@@ -1574,7 +1565,7 @@ impl<'self> fmt::Default for Sidebar<'self> {\n         }\n         write!(fmt.buf, \"</p>\");\n \n-        fn block(w: &mut io::Writer, short: &str, longty: &str,\n+        fn block(w: &mut Writer, short: &str, longty: &str,\n                  cur: &clean::Item, cx: &Context) {\n             let items = match cx.sidebar.find_equiv(&short) {\n                 Some(items) => items.as_slice(),"}, {"sha": "7a64ca6d6fc2a0c2cb3f1ab911eb01bc99df0183", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -25,9 +25,8 @@ extern mod extra;\n \n use std::cell::Cell;\n use std::local_data;\n-use std::rt::io::Writer;\n-use std::rt::io::file::FileInfo;\n use std::rt::io;\n+use std::rt::io::file;\n use std::rt::io::mem::MemWriter;\n use std::rt::io::Decorator;\n use std::str;\n@@ -260,7 +259,7 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n /// This input format purely deserializes the json output file. No passes are\n /// run over the deserialized output.\n fn json_input(input: &str) -> Result<Output, ~str> {\n-    let input = match Path::new(input).open_reader(io::Open) {\n+    let input = match file::open(&Path::new(input)) {\n         Some(f) => f,\n         None => return Err(format!(\"couldn't open {} for reading\", input)),\n     };\n@@ -322,7 +321,7 @@ fn json_output(crate: clean::Crate, res: ~[plugins::PluginJson], dst: Path) {\n     json.insert(~\"crate\", crate_json);\n     json.insert(~\"plugins\", json::Object(plugins_json));\n \n-    let mut file = dst.open_writer(io::Create).unwrap();\n+    let mut file = file::create(&dst).unwrap();\n     let output = json::Object(json).to_str();\n     file.write(output.as_bytes());\n }"}, {"sha": "c0ffd66d22e43e72d86f8a66dd7cb6c78637442f", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -21,7 +21,7 @@ pub use path_util::default_workspace;\n \n pub use source_control::{safe_git_clone, git_clone_url};\n \n-use std::{os, run};\n+use std::run;\n use extra::arc::{Arc,RWArc};\n use extra::workcache;\n use extra::workcache::{Database, Logger, FreshnessMap};\n@@ -57,12 +57,12 @@ pub fn new_default_context(c: workcache::Context, p: Path) -> BuildContext {\n \n fn file_is_fresh(path: &str, in_hash: &str) -> bool {\n     let path = Path::new(path);\n-    os::path_exists(&path) && in_hash == digest_file_with_date(&path)\n+    path.exists() && in_hash == digest_file_with_date(&path)\n }\n \n fn binary_is_fresh(path: &str, in_hash: &str) -> bool {\n     let path = Path::new(path);\n-    os::path_exists(&path) && in_hash == digest_only_date(&path)\n+    path.exists() && in_hash == digest_only_date(&path)\n }\n \n pub fn new_workcache_context(p: &Path) -> workcache::Context {"}, {"sha": "0ae08731546f13f69ea0db9c719ff524deb5c041", "filename": "src/librustpkg/context.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcontext.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -14,7 +14,6 @@ use extra::workcache;\n use rustc::driver::session::{OptLevel, No};\n \n use std::hashmap::HashSet;\n-use std::os;\n \n #[deriving(Clone)]\n pub struct Context {\n@@ -176,7 +175,7 @@ pub fn in_target(sysroot: &Path) -> bool {\n     debug!(\"Checking whether {} is in target\", sysroot.display());\n     let mut p = sysroot.dir_path();\n     p.set_filename(\"rustc\");\n-    os::path_is_dir(&p)\n+    p.is_dir()\n }\n \n impl RustcFlags {"}, {"sha": "09b58e6e94cce83b2ee1821332a705ba6f87da0e", "filename": "src/librustpkg/installed_packages.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Finstalled_packages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Finstalled_packages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Finstalled_packages.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -13,11 +13,13 @@\n use rustc::metadata::filesearch::rust_path;\n use path_util::*;\n use std::os;\n+use std::rt::io;\n+use std::rt::io::file;\n \n pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n     let workspaces = rust_path();\n     for p in workspaces.iter() {\n-        let binfiles = os::list_dir(&p.join(\"bin\"));\n+        let binfiles = do io::ignore_io_error { file::readdir(&p.join(\"bin\")) };\n         for exec in binfiles.iter() {\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             match exec.filestem_str() {\n@@ -29,7 +31,7 @@ pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n                 }\n             }\n         }\n-        let libfiles = os::list_dir(&p.join(\"lib\"));\n+        let libfiles = do io::ignore_io_error { file::readdir(&p.join(\"lib\")) };\n         for lib in libfiles.iter() {\n             debug!(\"Full name: {}\", lib.display());\n             match has_library(lib) {\n@@ -53,7 +55,7 @@ pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n }\n \n pub fn has_library(p: &Path) -> Option<~str> {\n-    let files = os::list_dir(p);\n+    let files = do io::ignore_io_error { file::readdir(p) };\n     for path in files.iter() {\n         if path.extension_str() == Some(os::consts::DLL_EXTENSION) {\n             let stuff : &str = path.filestem_str().expect(\"has_library: weird path\");"}, {"sha": "bb6088adee18e7966074ab399258fc6ef2afefa8", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -26,6 +26,8 @@ extern mod syntax;\n \n use std::{os, result, run, str, task};\n use std::hashmap::HashSet;\n+use std::rt::io;\n+use std::rt::io::file;\n pub use std::path::Path;\n \n use extra::workcache;\n@@ -36,7 +38,7 @@ use extra::{getopts};\n use syntax::{ast, diagnostic};\n use messages::{error, warn, note};\n use path_util::{build_pkg_id_in_workspace, built_test_in_workspace};\n-use path_util::{U_RWX, in_rust_path};\n+use path_util::in_rust_path;\n use path_util::{built_executable_in_workspace, built_library_in_workspace, default_workspace};\n use path_util::{target_executable_in_workspace, target_library_in_workspace, dir_has_crate_file};\n use source_control::{CheckedOutSources, is_git_dir, make_read_only};\n@@ -513,7 +515,7 @@ impl CtxMethods for BuildContext {\n                     // We expect that p is relative to the package source's start directory,\n                     // so check that assumption\n                     debug!(\"JustOne: p = {}\", p.display());\n-                    assert!(os::path_exists(&pkg_src.start_dir.join(p)));\n+                    assert!(pkg_src.start_dir.join(p).exists());\n                     if is_lib(p) {\n                         PkgSrc::push_crate(&mut pkg_src.libs, 0, p);\n                     } else if is_main(p) {\n@@ -541,8 +543,8 @@ impl CtxMethods for BuildContext {\n         let dir = build_pkg_id_in_workspace(id, workspace);\n         note(format!(\"Cleaning package {} (removing directory {})\",\n                         id.to_str(), dir.display()));\n-        if os::path_exists(&dir) {\n-            os::remove_dir_recursive(&dir);\n+        if dir.exists() {\n+            file::rmdir_recursive(&dir);\n             note(format!(\"Removed directory {}\", dir.display()));\n         }\n \n@@ -600,7 +602,6 @@ impl CtxMethods for BuildContext {\n                         build_inputs: &[Path],\n                         target_workspace: &Path,\n                         id: &PkgId) -> ~[~str] {\n-        use conditions::copy_failed::cond;\n \n         debug!(\"install_no_build: assuming {} comes from {} with target {}\",\n                id.to_str(), build_workspace.display(), target_workspace.display());\n@@ -659,10 +660,8 @@ impl CtxMethods for BuildContext {\n \n                 for exec in subex.iter() {\n                     debug!(\"Copying: {} -> {}\", exec.display(), sub_target_ex.display());\n-                    if !(os::mkdir_recursive(&sub_target_ex.dir_path(), U_RWX) &&\n-                         os::copy_file(exec, &sub_target_ex)) {\n-                        cond.raise(((*exec).clone(), sub_target_ex.clone()));\n-                    }\n+                    file::mkdir_recursive(&sub_target_ex.dir_path(), io::UserRWX);\n+                    file::copy(exec, &sub_target_ex);\n                     // FIXME (#9639): This needs to handle non-utf8 paths\n                     exe_thing.discover_output(\"binary\",\n                         sub_target_ex.as_str().unwrap(),\n@@ -674,10 +673,8 @@ impl CtxMethods for BuildContext {\n                         .clone().expect(format!(\"I built {} but apparently \\\n                                              didn't install it!\", lib.display()));\n                     target_lib.set_filename(lib.filename().expect(\"weird target lib\"));\n-                    if !(os::mkdir_recursive(&target_lib.dir_path(), U_RWX) &&\n-                         os::copy_file(lib, &target_lib)) {\n-                        cond.raise(((*lib).clone(), target_lib.clone()));\n-                    }\n+                    file::mkdir_recursive(&target_lib.dir_path(), io::UserRWX);\n+                    file::copy(lib, &target_lib);\n                     debug!(\"3. discovering output {}\", target_lib.display());\n                     exe_thing.discover_output(\"binary\",\n                                               target_lib.as_str().unwrap(),\n@@ -710,10 +707,10 @@ impl CtxMethods for BuildContext {\n     }\n \n     fn init(&self) {\n-        os::mkdir_recursive(&Path::new(\"src\"),   U_RWX);\n-        os::mkdir_recursive(&Path::new(\"lib\"),   U_RWX);\n-        os::mkdir_recursive(&Path::new(\"bin\"),   U_RWX);\n-        os::mkdir_recursive(&Path::new(\"build\"), U_RWX);\n+        file::mkdir_recursive(&Path::new(\"src\"), io::UserRWX);\n+        file::mkdir_recursive(&Path::new(\"bin\"), io::UserRWX);\n+        file::mkdir_recursive(&Path::new(\"lib\"), io::UserRWX);\n+        file::mkdir_recursive(&Path::new(\"build\"), io::UserRWX);\n     }\n \n     fn uninstall(&self, _id: &str, _vers: Option<~str>)  {"}, {"sha": "0da343a27bfcafccf0710e55715e1796642d3b1b", "filename": "src/librustpkg/package_id.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Fpackage_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Fpackage_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_id.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -10,7 +10,6 @@\n \n use version::{try_getting_version, try_getting_local_version,\n               Version, NoVersion, split_version};\n-use std::rt::io::Writer;\n use std::hash::Streaming;\n use std::hash;\n "}, {"sha": "a52aa68e1e4716448b498f6c6e32165e0fd25ef5", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -12,7 +12,8 @@ extern mod extra;\n \n use target::*;\n use package_id::PkgId;\n-use std::path::Path;\n+use std::rt::io;\n+use std::rt::io::file;\n use std::os;\n use context::*;\n use crate::Crate;\n@@ -117,7 +118,7 @@ impl PkgSrc {\n \n         debug!(\"Checking dirs: {:?}\", to_try.map(|p| p.display().to_str()).connect(\":\"));\n \n-        let path = to_try.iter().find(|&d| os::path_exists(d));\n+        let path = to_try.iter().find(|&d| d.exists());\n \n         // See the comments on the definition of PkgSrc\n         let mut build_in_destination = use_rust_path_hack;\n@@ -132,7 +133,7 @@ impl PkgSrc {\n                     let package_id = PkgId::new(prefix.as_str().unwrap());\n                     let path = build_dir.join(&package_id.path);\n                     debug!(\"in loop: checking if {} is a directory\", path.display());\n-                    if os::path_is_dir(&path) {\n+                    if path.is_dir() {\n                         let ps = PkgSrc::new(source_workspace,\n                                              destination_workspace,\n                                              use_rust_path_hack,\n@@ -237,7 +238,7 @@ impl PkgSrc {\n \n         debug!(\"For package id {}, returning {}\", id.to_str(), dir.display());\n \n-        if !os::path_is_dir(&dir) {\n+        if !dir.is_dir() {\n             cond.raise((id.clone(), ~\"supplied path for package dir is a \\\n                                         non-directory\"));\n         }\n@@ -267,7 +268,7 @@ impl PkgSrc {\n         debug!(\"Checking whether {} (path = {}) exists locally. Cwd = {}, does it? {:?}\",\n                 pkgid.to_str(), pkgid.path.display(),\n                 cwd.display(),\n-                os::path_exists(&pkgid.path));\n+                pkgid.path.exists());\n \n         match safe_git_clone(&pkgid.path, &pkgid.version, local) {\n             CheckedOutSources => {\n@@ -300,7 +301,7 @@ impl PkgSrc {\n                 // Move clone_target to local.\n                 // First, create all ancestor directories.\n                 let moved = make_dir_rwx_recursive(&local.dir_path())\n-                    && os::rename_file(&clone_target, local);\n+                    && io::result(|| file::rename(&clone_target, local)).is_ok();\n                 if moved { Some(local.clone()) }\n                     else { None }\n             }\n@@ -312,7 +313,7 @@ impl PkgSrc {\n     pub fn package_script_option(&self) -> Option<Path> {\n         let maybe_path = self.start_dir.join(\"pkg.rs\");\n         debug!(\"package_script_option: checking whether {} exists\", maybe_path.display());\n-        if os::path_exists(&maybe_path) {\n+        if maybe_path.exists() {\n             Some(maybe_path)\n         } else {\n             None\n@@ -349,7 +350,7 @@ impl PkgSrc {\n \n         let prefix = self.start_dir.component_iter().len();\n         debug!(\"Matching against {}\", self.id.short_name);\n-        do os::walk_dir(&self.start_dir) |pth| {\n+        do file::walk_dir(&self.start_dir) |pth| {\n             let maybe_known_crate_set = match pth.filename_str() {\n                 Some(filename) if filter(filename) => match filename {\n                     \"lib.rs\" => Some(&mut self.libs),"}, {"sha": "75f03533d583c00df70e3ec2edece436361a8693", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -18,8 +18,9 @@ use rustc::driver::driver::host_triple;\n \n use std::libc;\n use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n-use std::os::mkdir_recursive;\n use std::os;\n+use std::rt::io;\n+use std::rt::io::file;\n use messages::*;\n \n pub fn default_workspace() -> Path {\n@@ -28,8 +29,8 @@ pub fn default_workspace() -> Path {\n         fail!(\"Empty RUST_PATH\");\n     }\n     let result = p[0];\n-    if !os::path_is_dir(&result) {\n-        os::mkdir_recursive(&result, U_RWX);\n+    if !result.is_dir() {\n+        file::mkdir_recursive(&result, io::UserRWX);\n     }\n     result\n }\n@@ -43,9 +44,13 @@ pub static U_RWX: i32 = (S_IRUSR | S_IWUSR | S_IXUSR) as i32;\n /// Creates a directory that is readable, writeable,\n /// and executable by the user. Returns true iff creation\n /// succeeded.\n-pub fn make_dir_rwx(p: &Path) -> bool { os::make_dir(p, U_RWX) }\n+pub fn make_dir_rwx(p: &Path) -> bool {\n+    io::result(|| file::mkdir(p, io::UserRWX)).is_ok()\n+}\n \n-pub fn make_dir_rwx_recursive(p: &Path) -> bool { os::mkdir_recursive(p, U_RWX) }\n+pub fn make_dir_rwx_recursive(p: &Path) -> bool {\n+    io::result(|| file::mkdir_recursive(p, io::UserRWX)).is_ok()\n+}\n \n // n.b. The next three functions ignore the package version right\n // now. Should fix that.\n@@ -59,15 +64,16 @@ pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n // Returns the directory it was actually found in\n              workspace_to_src_dir: &fn(&Path) -> Path) -> Option<Path> {\n-    if !os::path_is_dir(workspace) {\n+    if !workspace.is_dir() {\n         return None;\n     }\n \n     let src_dir = workspace_to_src_dir(workspace);\n+    if !src_dir.is_dir() { return None }\n \n     let mut found = None;\n-    do os::walk_dir(&src_dir) |p| {\n-        if os::path_is_dir(p) {\n+    do file::walk_dir(&src_dir) |p| {\n+        if p.is_dir() {\n             if *p == src_dir.join(&pkgid.path) || {\n                 let pf = p.filename_str();\n                 do pf.iter().any |&g| {\n@@ -125,7 +131,7 @@ pub fn built_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<\n     result = mk_output_path(Main, Build, pkgid, result);\n     debug!(\"built_executable_in_workspace: checking whether {} exists\",\n            result.display());\n-    if os::path_exists(&result) {\n+    if result.exists() {\n         Some(result)\n     }\n     else {\n@@ -152,7 +158,7 @@ fn output_in_workspace(pkgid: &PkgId, workspace: &Path, what: OutputType) -> Opt\n     result = mk_output_path(what, Build, pkgid, result);\n     debug!(\"output_in_workspace: checking whether {} exists\",\n            result.display());\n-    if os::path_exists(&result) {\n+    if result.exists() {\n         Some(result)\n     }\n     else {\n@@ -210,7 +216,7 @@ pub fn system_library(sysroot: &Path, lib_name: &str) -> Option<Path> {\n \n fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Option<Path> {\n     debug!(\"Listing directory {}\", dir_to_search.display());\n-    let dir_contents = os::list_dir(dir_to_search);\n+    let dir_contents = do io::ignore_io_error { file::readdir(dir_to_search) };\n     debug!(\"dir has {:?} entries\", dir_contents.len());\n \n     let lib_prefix = format!(\"{}{}\", os::consts::DLL_PREFIX, short_name);\n@@ -294,7 +300,7 @@ pub fn target_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n /// As a side effect, creates the lib-dir if it doesn't exist\n pub fn target_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     use conditions::bad_path::cond;\n-    if !os::path_is_dir(workspace) {\n+    if !workspace.is_dir() {\n         cond.raise(((*workspace).clone(),\n                     format!(\"Workspace supplied to target_library_in_workspace \\\n                              is not a directory! {}\", workspace.display())));\n@@ -333,7 +339,7 @@ fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n                 (Install, Lib)  => target_lib_dir(workspace),\n                 (Install, _)    => target_bin_dir(workspace)\n     };\n-    if !os::path_exists(&result) && !mkdir_recursive(&result, U_RWX) {\n+    if io::result(|| file::mkdir_recursive(&result, io::UserRWX)).is_err() {\n         cond.raise((result.clone(), format!(\"target_file_in_workspace couldn't \\\n             create the {} dir (pkgid={}, workspace={}, what={:?}, where={:?}\",\n             subdir, pkgid.to_str(), workspace.display(), what, where)));\n@@ -344,18 +350,12 @@ fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n /// Return the directory for <pkgid>'s build artifacts in <workspace>.\n /// Creates it if it doesn't exist.\n pub fn build_pkg_id_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n-    use conditions::bad_path::cond;\n-\n     let mut result = target_build_dir(workspace);\n     result.push(&pkgid.path);\n     debug!(\"Creating build dir {} for package id {}\", result.display(),\n            pkgid.to_str());\n-    if os::path_exists(&result) || os::mkdir_recursive(&result, U_RWX) {\n-        result\n-    }\n-    else {\n-        cond.raise((result, format!(\"Could not create directory for package {}\", pkgid.to_str())))\n-    }\n+    file::mkdir_recursive(&result, io::UserRWX);\n+    return result;\n }\n \n /// Return the output file for a given directory name,\n@@ -398,13 +398,13 @@ pub fn mk_output_path(what: OutputType, where: Target,\n pub fn uninstall_package_from(workspace: &Path, pkgid: &PkgId) {\n     let mut did_something = false;\n     let installed_bin = target_executable_in_workspace(pkgid, workspace);\n-    if os::path_exists(&installed_bin) {\n-        os::remove_file(&installed_bin);\n+    if installed_bin.exists() {\n+        file::unlink(&installed_bin);\n         did_something = true;\n     }\n     let installed_lib = target_library_in_workspace(pkgid, workspace);\n-    if os::path_exists(&installed_lib) {\n-        os::remove_file(&installed_lib);\n+    if installed_lib.exists() {\n+        file::unlink(&installed_lib);\n         did_something = true;\n     }\n     if !did_something {\n@@ -421,7 +421,7 @@ pub fn dir_has_crate_file(dir: &Path) -> bool {\n \n fn dir_has_file(dir: &Path, file: &str) -> bool {\n     assert!(dir.is_absolute());\n-    os::path_exists(&dir.join(file))\n+    dir.join(file).exists()\n }\n \n pub fn find_dir_using_rust_path_hack(p: &PkgId) -> Option<Path> {"}, {"sha": "a0e50ff0f9ef7696b06028aeb7f3eebc8f9ddc75", "filename": "src/librustpkg/source_control.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -10,8 +10,9 @@\n \n // Utils for working with version control repositories. Just git right now.\n \n-use std::{os, run, str};\n+use std::{run, str};\n use std::run::{ProcessOutput, ProcessOptions, Process};\n+use std::rt::io::file;\n use extra::tempfile::TempDir;\n use version::*;\n use path_util::chmod_read_only;\n@@ -22,14 +23,14 @@ use path_util::chmod_read_only;\n /// directory (that the callee may use, for example, to check out remote sources into).\n /// Returns `CheckedOutSources` if the clone succeeded.\n pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult {\n-    if os::path_exists(source) {\n+    if source.exists() {\n         debug!(\"{} exists locally! Cloning it into {}\",\n                 source.display(), target.display());\n         // Ok to use target here; we know it will succeed\n-        assert!(os::path_is_dir(source));\n+        assert!(source.is_dir());\n         assert!(is_git_dir(source));\n \n-        if !os::path_exists(target) {\n+        if !target.exists() {\n             debug!(\"Running: git clone {} {}\", source.display(), target.display());\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             let outp = run::process_output(\"git\", [~\"clone\",\n@@ -95,8 +96,8 @@ pub enum CloneResult {\n \n pub fn make_read_only(target: &Path) {\n     // Now, make all the files in the target dir read-only\n-    do os::walk_dir(target) |p| {\n-        if !os::path_is_dir(p) {\n+    do file::walk_dir(target) |p| {\n+        if !p.is_dir() {\n             assert!(chmod_read_only(p));\n         };\n         true\n@@ -138,5 +139,5 @@ fn process_output_in_cwd(prog: &str, args: &[~str], cwd: &Path) -> ProcessOutput\n }\n \n pub fn is_git_dir(p: &Path) -> bool {\n-    os::path_is_dir(&p.join(\".git\"))\n+    p.join(\".git\").is_dir()\n }"}, {"sha": "60e99f242ef1422077bd2d6595e491ca348cd1a0", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 108, "deletions": 123, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -13,8 +13,7 @@\n use context::{BuildContext, Context, RustcFlags};\n use std::{os, run, str, task};\n use std::rt::io;\n-use std::rt::io::Writer;\n-use std::rt::io::file::FileInfo;\n+use std::rt::io::file;\n use extra::arc::Arc;\n use extra::arc::RWArc;\n use extra::tempfile::TempDir;\n@@ -27,7 +26,7 @@ use installed_packages::list_installed_packages;\n use package_id::{PkgId};\n use version::{ExactRevision, NoVersion, Version, Tagged};\n use path_util::{target_executable_in_workspace, target_test_in_workspace,\n-               target_bench_in_workspace, make_dir_rwx, U_RWX,\n+               target_bench_in_workspace, make_dir_rwx,\n                library_in_workspace, installed_library_in_workspace,\n                built_bench_in_workspace, built_test_in_workspace,\n                built_library_in_workspace, built_executable_in_workspace, target_build_dir,\n@@ -84,15 +83,15 @@ fn git_repo_pkg_with_tag(a_tag: ~str) -> PkgId {\n }\n \n fn writeFile(file_path: &Path, contents: &str) {\n-    let mut out = file_path.open_writer(io::CreateOrTruncate);\n+    let mut out = file::create(file_path);\n     out.write(contents.as_bytes());\n     out.write(['\\n' as u8]);\n }\n \n fn mk_emptier_workspace(tag: &str) -> TempDir {\n     let workspace = TempDir::new(tag).expect(\"couldn't create temp dir\");\n     let package_dir = workspace.path().join(\"src\");\n-    assert!(os::mkdir_recursive(&package_dir, U_RWX));\n+    file::mkdir_recursive(&package_dir, io::UserRWX);\n     workspace\n }\n \n@@ -107,7 +106,7 @@ fn mk_workspace(workspace: &Path, short_name: &Path, version: &Version) -> Path\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let package_dir = workspace.join_many([~\"src\", format!(\"{}-{}\",\n                                            short_name.as_str().unwrap(), version.to_str())]);\n-    assert!(os::mkdir_recursive(&package_dir, U_RWX));\n+    file::mkdir_recursive(&package_dir, io::UserRWX);\n     package_dir\n }\n \n@@ -120,12 +119,12 @@ fn mk_temp_workspace(short_name: &Path, version: &Version) -> (TempDir, Path) {\n                                                               version.to_str())]);\n \n     debug!(\"Created {} and does it exist? {:?}\", package_dir.display(),\n-          os::path_is_dir(&package_dir));\n+           package_dir.is_dir());\n     // Create main, lib, test, and bench files\n     debug!(\"mk_workspace: creating {}\", package_dir.display());\n-    assert!(os::mkdir_recursive(&package_dir, U_RWX));\n+    file::mkdir_recursive(&package_dir, io::UserRWX);\n     debug!(\"Created {} and does it exist? {:?}\", package_dir.display(),\n-          os::path_is_dir(&package_dir));\n+           package_dir.is_dir());\n     // Create main, lib, test, and bench files\n \n     writeFile(&package_dir.join(\"main.rs\"),\n@@ -162,7 +161,7 @@ fn init_git_repo(p: &Path) -> TempDir {\n     let tmp = TempDir::new(\"git_local\").expect(\"couldn't create temp dir\");\n     let work_dir = tmp.path().join(p);\n     let work_dir_for_opts = work_dir.clone();\n-    assert!(os::mkdir_recursive(&work_dir, U_RWX));\n+    file::mkdir_recursive(&work_dir, io::UserRWX);\n     debug!(\"Running: git init in {}\", work_dir.display());\n     run_git([~\"init\"], None, &work_dir_for_opts,\n         format!(\"Couldn't initialize git repository in {}\", work_dir.display()));\n@@ -199,25 +198,21 @@ fn add_git_tag(repo: &Path, tag: ~str) {\n fn is_rwx(p: &Path) -> bool {\n     use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n \n-    match p.get_mode() {\n-        None => return false,\n-        Some(m) =>\n-            ((m & S_IRUSR as uint) == S_IRUSR as uint\n-            && (m & S_IWUSR as uint) == S_IWUSR as uint\n-            && (m & S_IXUSR as uint) == S_IXUSR as uint)\n-    }\n+    if !p.exists() { return false }\n+    let m = p.stat().mode;\n+    (m & S_IRUSR as u64) == S_IRUSR as u64\n+     && (m & S_IWUSR as u64) == S_IWUSR as u64\n+     && (m & S_IXUSR as u64) == S_IXUSR as u64\n }\n \n fn is_read_only(p: &Path) -> bool {\n     use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n \n-    match p.get_mode() {\n-        None => return false,\n-        Some(m) =>\n-            ((m & S_IRUSR as uint) == S_IRUSR as uint\n-            && (m & S_IWUSR as uint) == 0 as uint\n-            && (m & S_IXUSR as uint) == 0 as uint)\n-    }\n+    if !p.exists() { return false }\n+    let m = p.stat().mode;\n+    (m & S_IRUSR as u64) == S_IRUSR as u64\n+     && (m & S_IWUSR as u64) == 0 as u64\n+     && (m & S_IXUSR as u64) == 0 as u64\n }\n \n fn test_sysroot() -> Path {\n@@ -289,7 +284,7 @@ fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~s\n         None        => ~\"\"\n     };\n     debug!(\"{} cd {}; {} {}\", env_str, cwd.display(), cmd, args.connect(\" \"));\n-    assert!(os::path_is_dir(&*cwd));\n+    assert!(cwd.is_dir());\n     let cwd = (*cwd).clone();\n     let mut prog = run::Process::new(cmd, args, run::ProcessOptions {\n         env: env.map(|e| e + os::env()),\n@@ -325,9 +320,9 @@ fn create_local_package_in(pkgid: &PkgId, pkgdir: &Path) -> Path {\n     let package_dir = pkgdir.join_many([~\"src\", pkgid.to_str()]);\n \n     // Create main, lib, test, and bench files\n-    assert!(os::mkdir_recursive(&package_dir, U_RWX));\n+    file::mkdir_recursive(&package_dir, io::UserRWX);\n     debug!(\"Created {} and does it exist? {:?}\", package_dir.display(),\n-          os::path_is_dir(&package_dir));\n+           package_dir.is_dir());\n     // Create main, lib, test, and bench files\n \n     writeFile(&package_dir.join(\"main.rs\"),\n@@ -378,7 +373,7 @@ fn lib_exists(repo: &Path, pkg_path: &Path, _v: Version) -> bool { // ??? versio\n     debug!(\"assert_lib_exists: checking whether {:?} exists\", lib);\n     lib.is_some() && {\n         let libname = lib.get_ref();\n-        os::path_exists(libname) && is_rwx(libname)\n+        libname.exists() && is_rwx(libname)\n     }\n }\n \n@@ -389,21 +384,21 @@ fn assert_executable_exists(repo: &Path, short_name: &str) {\n fn executable_exists(repo: &Path, short_name: &str) -> bool {\n     debug!(\"executable_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n     let exec = target_executable_in_workspace(&PkgId::new(short_name), repo);\n-    os::path_exists(&exec) && is_rwx(&exec)\n+    exec.exists() && is_rwx(&exec)\n }\n \n fn test_executable_exists(repo: &Path, short_name: &str) -> bool {\n     debug!(\"test_executable_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n     let exec = built_test_in_workspace(&PkgId::new(short_name), repo);\n     do exec.map_default(false) |exec| {\n-        os::path_exists(&exec) && is_rwx(&exec)\n+        exec.exists() && is_rwx(&exec)\n     }\n }\n \n fn remove_executable_file(p: &PkgId, workspace: &Path) {\n     let exec = target_executable_in_workspace(&PkgId::new(p.short_name), workspace);\n-    if os::path_exists(&exec) {\n-        assert!(os::remove_file(&exec));\n+    if exec.exists() {\n+        file::unlink(&exec);\n     }\n }\n \n@@ -417,14 +412,14 @@ fn built_executable_exists(repo: &Path, short_name: &str) -> bool {\n     let exec = built_executable_in_workspace(&PkgId::new(short_name), repo);\n     exec.is_some() && {\n        let execname = exec.get_ref();\n-       os::path_exists(execname) && is_rwx(execname)\n+       execname.exists() && is_rwx(execname)\n     }\n }\n \n fn remove_built_executable_file(p: &PkgId, workspace: &Path) {\n     let exec = built_executable_in_workspace(&PkgId::new(p.short_name), workspace);\n     match exec {\n-        Some(r) => assert!(os::remove_file(&r)),\n+        Some(r) => file::unlink(&r),\n         None    => ()\n     }\n }\n@@ -446,8 +441,9 @@ fn llvm_bitcode_file_exists(repo: &Path, short_name: &str) -> bool {\n }\n \n fn file_exists(repo: &Path, short_name: &str, extension: &str) -> bool {\n-    os::path_exists(&target_build_dir(repo).join_many([short_name.to_owned(),\n-                                     format!(\"{}.{}\", short_name, extension)]))\n+    target_build_dir(repo).join_many([short_name.to_owned(),\n+                                     format!(\"{}.{}\", short_name, extension)])\n+                          .exists()\n }\n \n fn assert_built_library_exists(repo: &Path, short_name: &str) {\n@@ -459,7 +455,7 @@ fn built_library_exists(repo: &Path, short_name: &str) -> bool {\n     let lib = built_library_in_workspace(&PkgId::new(short_name), repo);\n     lib.is_some() && {\n         let libname = lib.get_ref();\n-        os::path_exists(libname) && is_rwx(libname)\n+        libname.exists() && is_rwx(libname)\n     }\n }\n \n@@ -508,7 +504,7 @@ fn output_file_name(workspace: &Path, short_name: ~str) -> Path {\n fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n     use conditions::bad_path::cond;\n     let pkg_src_dir = workspace.join_many([~\"src\", pkgid.to_str()]);\n-    let contents = os::list_dir_path(&pkg_src_dir);\n+    let contents = file::readdir(&pkg_src_dir);\n     for p in contents.iter() {\n         if p.extension_str() == Some(\"rs\") {\n             // should be able to do this w/o a process\n@@ -527,7 +523,7 @@ fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n     use conditions::bad_path::cond;\n     let pkg_src_dir = workspace.join_many([~\"src\", pkgid.to_str()]);\n-    let contents = os::list_dir_path(&pkg_src_dir);\n+    let contents = file::readdir(&pkg_src_dir);\n     for p in contents.iter() {\n         if p.extension_str() == Some(\"rs\") {\n             // should be able to do this w/o a process\n@@ -548,7 +544,7 @@ fn frob_source_file(workspace: &Path, pkgid: &PkgId, filename: &str) {\n     let mut maybe_p = None;\n     let maybe_file = pkg_src_dir.join(filename);\n     debug!(\"Trying to frob {} -- {}\", pkg_src_dir.display(), filename);\n-    if os::path_exists(&maybe_file) {\n+    if maybe_file.exists() {\n         maybe_p = Some(maybe_file);\n     }\n     debug!(\"Frobbed? {:?}\", maybe_p);\n@@ -557,7 +553,7 @@ fn frob_source_file(workspace: &Path, pkgid: &PkgId, filename: &str) {\n             do io::io_error::cond.trap(|e| {\n                 cond.raise((p.clone(), format!(\"Bad path: {}\", e.desc)));\n             }).inside {\n-                let mut w = p.open_writer(io::Append);\n+                let mut w = file::open_stream(p, io::Append, io::Write);\n                 w.write(bytes!(\"/* hi */\\n\"));\n             }\n         }\n@@ -570,13 +566,14 @@ fn frob_source_file(workspace: &Path, pkgid: &PkgId, filename: &str) {\n fn test_make_dir_rwx() {\n     let temp = &os::tmpdir();\n     let dir = temp.join(\"quux\");\n-    assert!(!os::path_exists(&dir) ||\n-            os::remove_dir_recursive(&dir));\n+    if dir.exists() {\n+        file::rmdir_recursive(&dir);\n+    }\n     debug!(\"Trying to make {}\", dir.display());\n     assert!(make_dir_rwx(&dir));\n-    assert!(os::path_is_dir(&dir));\n+    assert!(dir.is_dir());\n     assert!(is_rwx(&dir));\n-    assert!(os::remove_dir_recursive(&dir));\n+    file::rmdir_recursive(&dir);\n }\n \n // n.b. I ignored the next two tests for now because something funny happens on linux\n@@ -603,19 +600,19 @@ fn test_install_valid() {\n     // Check that all files exist\n     let exec = target_executable_in_workspace(&temp_pkg_id, temp_workspace);\n     debug!(\"exec = {}\", exec.display());\n-    assert!(os::path_exists(&exec));\n+    assert!(exec.exists());\n     assert!(is_rwx(&exec));\n \n     let lib = installed_library_in_workspace(&temp_pkg_id.path, temp_workspace);\n     debug!(\"lib = {:?}\", lib);\n-    assert!(lib.as_ref().map_default(false, |l| os::path_exists(l)));\n+    assert!(lib.as_ref().map_default(false, |l| l.exists()));\n     assert!(lib.as_ref().map_default(false, |l| is_rwx(l)));\n \n     // And that the test and bench executables aren't installed\n-    assert!(!os::path_exists(&target_test_in_workspace(&temp_pkg_id, temp_workspace)));\n+    assert!(!target_test_in_workspace(&temp_pkg_id, temp_workspace).exists());\n     let bench = target_bench_in_workspace(&temp_pkg_id, temp_workspace);\n     debug!(\"bench = {}\", bench.display());\n-    assert!(!os::path_exists(&bench));\n+    assert!(!bench.exists());\n \n     // Make sure the db isn't dirty, so that it doesn't try to save()\n     // asynchronously after the temporary directory that it wants to save\n@@ -655,19 +652,19 @@ fn test_install_valid_external() {\n     // Check that all files exist\n     let exec = target_executable_in_workspace(&temp_pkg_id, temp_workspace);\n     debug!(\"exec = {}\", exec.display());\n-    assert!(os::path_exists(&exec));\n+    assert!(exec.exists());\n     assert!(is_rwx(&exec));\n \n     let lib = installed_library_in_workspace(&temp_pkg_id.path, temp_workspace);\n     debug!(\"lib = {:?}\", lib);\n-    assert!(lib.as_ref().map_default(false, |l| os::path_exists(l)));\n+    assert!(lib.as_ref().map_default(false, |l| l.exists()));\n     assert!(lib.as_ref().map_default(false, |l| is_rwx(l)));\n \n     // And that the test and bench executables aren't installed\n-    assert!(!os::path_exists(&target_test_in_workspace(&temp_pkg_id, temp_workspace)));\n+    assert!(!target_test_in_workspace(&temp_pkg_id, temp_workspace).exists());\n     let bench = target_bench_in_workspace(&temp_pkg_id, temp_workspace);\n     debug!(\"bench = {}\", bench.display());\n-    assert!(!os::path_exists(&bench));\n+    assert!(!bench.exists());\n \n }\n \n@@ -711,25 +708,25 @@ fn test_install_git() {\n     debug!(\"Checking for files in {}\", ws.display());\n     let exec = target_executable_in_workspace(&temp_pkg_id, &ws);\n     debug!(\"exec = {}\", exec.display());\n-    assert!(os::path_exists(&exec));\n+    assert!(exec.exists());\n     assert!(is_rwx(&exec));\n     let _built_lib =\n         built_library_in_workspace(&temp_pkg_id,\n                                    &ws).expect(\"test_install_git: built lib should exist\");\n     assert_lib_exists(&ws, &temp_pkg_id.path, temp_pkg_id.version.clone());\n     let built_test = built_test_in_workspace(&temp_pkg_id,\n                          &ws).expect(\"test_install_git: built test should exist\");\n-    assert!(os::path_exists(&built_test));\n+    assert!(built_test.exists());\n     let built_bench = built_bench_in_workspace(&temp_pkg_id,\n                           &ws).expect(\"test_install_git: built bench should exist\");\n-    assert!(os::path_exists(&built_bench));\n+    assert!(built_bench.exists());\n     // And that the test and bench executables aren't installed\n     let test = target_test_in_workspace(&temp_pkg_id, &ws);\n-    assert!(!os::path_exists(&test));\n+    assert!(!test.exists());\n     debug!(\"test = {}\", test.display());\n     let bench = target_bench_in_workspace(&temp_pkg_id, &ws);\n     debug!(\"bench = {}\", bench.display());\n-    assert!(!os::path_exists(&bench));\n+    assert!(!bench.exists());\n }\n \n #[test]\n@@ -783,6 +780,7 @@ fn test_package_version() {\n     let repo = repo.path();\n     let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test_pkg_version\"]);\n     debug!(\"Writing files in: {}\", repo_subdir.display());\n+    file::mkdir_recursive(&repo_subdir, io::UserRWX);\n     writeFile(&repo_subdir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n     writeFile(&repo_subdir.join(\"lib.rs\"),\n@@ -853,9 +851,9 @@ fn test_package_request_version() {\n     let mut dir = target_build_dir(&repo.join(\".rust\"));\n     dir.push(&Path::new(\"src/mockgithub.com/catamorphism/test_pkg_version-0.3\"));\n     debug!(\"dir = {}\", dir.display());\n-    assert!(os::path_is_dir(&dir));\n-    assert!(os::path_exists(&dir.join(\"version-0.3-file.txt\")));\n-    assert!(!os::path_exists(&dir.join(\"version-0.4-file.txt\")));\n+    assert!(dir.is_dir());\n+    assert!(dir.join(\"version-0.3-file.txt\").exists());\n+    assert!(!dir.join(\"version-0.4-file.txt\").exists());\n }\n \n #[test]\n@@ -904,24 +902,21 @@ fn package_script_with_default_build() {\n     let source = Path::new(file!()).dir_path().join_many(\n         [~\"testsuite\", ~\"pass\", ~\"src\", ~\"fancy-lib\", ~\"pkg.rs\"]);\n     debug!(\"package_script_with_default_build: {}\", source.display());\n-    if !os::copy_file(&source,\n-                      &dir.join_many([\"src\", \"fancy-lib-0.1\", \"pkg.rs\"])) {\n-        fail!(\"Couldn't copy file\");\n-    }\n+    file::copy(&source, &dir.join_many([\"src\", \"fancy-lib-0.1\", \"pkg.rs\"]));\n     command_line_test([~\"install\", ~\"fancy-lib\"], dir);\n     assert_lib_exists(dir, &Path::new(\"fancy-lib\"), NoVersion);\n-    assert!(os::path_exists(&target_build_dir(dir).join_many([~\"fancy-lib\", ~\"generated.rs\"])));\n+    assert!(target_build_dir(dir).join_many([~\"fancy-lib\", ~\"generated.rs\"]).exists());\n     let generated_path = target_build_dir(dir).join_many([~\"fancy-lib\", ~\"generated.rs\"]);\n     debug!(\"generated path = {}\", generated_path.display());\n-    assert!(os::path_exists(&generated_path));\n+    assert!(generated_path.exists());\n }\n \n #[test]\n fn rustpkg_build_no_arg() {\n     let tmp = TempDir::new(\"rustpkg_build_no_arg\").expect(\"rustpkg_build_no_arg failed\");\n     let tmp = tmp.path().join(\".rust\");\n     let package_dir = tmp.join_many([\"src\", \"foo\"]);\n-    assert!(os::mkdir_recursive(&package_dir, U_RWX));\n+    file::mkdir_recursive(&package_dir, io::UserRWX);\n \n     writeFile(&package_dir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n@@ -935,7 +930,7 @@ fn rustpkg_install_no_arg() {\n     let tmp = TempDir::new(\"rustpkg_install_no_arg\").expect(\"rustpkg_install_no_arg failed\");\n     let tmp = tmp.path().join(\".rust\");\n     let package_dir = tmp.join_many([\"src\", \"foo\"]);\n-    assert!(os::mkdir_recursive(&package_dir, U_RWX));\n+    file::mkdir_recursive(&package_dir, io::UserRWX);\n     writeFile(&package_dir.join(\"lib.rs\"),\n               \"fn main() { let _x = (); }\");\n     debug!(\"install_no_arg: dir = {}\", package_dir.display());\n@@ -948,7 +943,7 @@ fn rustpkg_clean_no_arg() {\n     let tmp = TempDir::new(\"rustpkg_clean_no_arg\").expect(\"rustpkg_clean_no_arg failed\");\n     let tmp = tmp.path().join(\".rust\");\n     let package_dir = tmp.join_many([\"src\", \"foo\"]);\n-    assert!(os::mkdir_recursive(&package_dir, U_RWX));\n+    file::mkdir_recursive(&package_dir, io::UserRWX);\n \n     writeFile(&package_dir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n@@ -957,7 +952,7 @@ fn rustpkg_clean_no_arg() {\n     assert_built_executable_exists(&tmp, \"foo\");\n     command_line_test([~\"clean\"], &package_dir);\n     let res = built_executable_in_workspace(&PkgId::new(\"foo\"), &tmp);\n-    assert!(!res.as_ref().map_default(false, |m| { os::path_exists(m) }));\n+    assert!(!res.as_ref().map_default(false, |m| m.exists()));\n }\n \n #[test]\n@@ -983,9 +978,9 @@ fn rust_path_test() {\n fn rust_path_contents() {\n     let dir = TempDir::new(\"rust_path\").expect(\"rust_path_contents failed\");\n     let abc = &dir.path().join_many([\"A\", \"B\", \"C\"]);\n-    assert!(os::mkdir_recursive(&abc.join(\".rust\"), U_RWX));\n-    assert!(os::mkdir_recursive(&abc.with_filename(\".rust\"), U_RWX));\n-    assert!(os::mkdir_recursive(&abc.dir_path().with_filename(\".rust\"), U_RWX));\n+    file::mkdir_recursive(&abc.join(\".rust\"), io::UserRWX);\n+    file::mkdir_recursive(&abc.with_filename(\".rust\"), io::UserRWX);\n+    file::mkdir_recursive(&abc.dir_path().with_filename(\".rust\"), io::UserRWX);\n     assert!(os::change_dir(abc));\n \n     let p = rust_path();\n@@ -1225,8 +1220,8 @@ fn test_non_numeric_tag() {\n                                            temp_pkg_id.path.as_str().unwrap())], repo);\n     let file1 = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\", \"testbranch_only\"]);\n     let file2 = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\", \"master_only\"]);\n-    assert!(os::path_exists(&file1));\n-    assert!(!os::path_exists(&file2));\n+    assert!(file1.exists());\n+    assert!(!file2.exists());\n }\n \n #[test]\n@@ -1237,11 +1232,11 @@ fn test_extern_mod() {\n     let lib_depend_dir = TempDir::new(\"foo\").expect(\"test_extern_mod\");\n     let lib_depend_dir = lib_depend_dir.path();\n     let aux_dir = lib_depend_dir.join_many([\"src\", \"mockgithub.com\", \"catamorphism\", \"test_pkg\"]);\n-    assert!(os::mkdir_recursive(&aux_dir, U_RWX));\n+    file::mkdir_recursive(&aux_dir, io::UserRWX);\n     let aux_pkg_file = aux_dir.join(\"lib.rs\");\n \n     writeFile(&aux_pkg_file, \"pub mod bar { pub fn assert_true() {  assert!(true); } }\\n\");\n-    assert!(os::path_exists(&aux_pkg_file));\n+    assert!(aux_pkg_file.exists());\n \n     writeFile(&main_file,\n               \"extern mod test = \\\"mockgithub.com/catamorphism/test_pkg\\\";\\nuse test::bar;\\\n@@ -1275,7 +1270,7 @@ fn test_extern_mod() {\n               str::from_utf8(outp.output),\n               str::from_utf8(outp.error));\n     }\n-    assert!(os::path_exists(&exec_file) && is_executable(&exec_file));\n+    assert!(exec_file.exists() && is_executable(&exec_file));\n }\n \n #[test]\n@@ -1286,11 +1281,11 @@ fn test_extern_mod_simpler() {\n     let lib_depend_dir = TempDir::new(\"foo\").expect(\"test_extern_mod_simpler\");\n     let lib_depend_dir = lib_depend_dir.path();\n     let aux_dir = lib_depend_dir.join_many([\"src\", \"rust-awesomeness\"]);\n-    assert!(os::mkdir_recursive(&aux_dir, U_RWX));\n+    file::mkdir_recursive(&aux_dir, io::UserRWX);\n     let aux_pkg_file = aux_dir.join(\"lib.rs\");\n \n     writeFile(&aux_pkg_file, \"pub mod bar { pub fn assert_true() {  assert!(true); } }\\n\");\n-    assert!(os::path_exists(&aux_pkg_file));\n+    assert!(aux_pkg_file.exists());\n \n     writeFile(&main_file,\n               \"extern mod test = \\\"rust-awesomeness\\\";\\nuse test::bar;\\\n@@ -1330,7 +1325,7 @@ fn test_extern_mod_simpler() {\n               str::from_utf8(outp.output),\n               str::from_utf8(outp.error));\n     }\n-    assert!(os::path_exists(&exec_file) && is_executable(&exec_file));\n+    assert!(exec_file.exists() && is_executable(&exec_file));\n }\n \n #[test]\n@@ -1342,8 +1337,8 @@ fn test_import_rustpkg() {\n               \"extern mod rustpkg; fn main() {}\");\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n     debug!(\"workspace = {}\", workspace.display());\n-    assert!(os::path_exists(&target_build_dir(workspace).join(\"foo\").join(format!(\"pkg{}\",\n-        os::EXE_SUFFIX))));\n+    assert!(target_build_dir(workspace).join(\"foo\").join(format!(\"pkg{}\",\n+        os::EXE_SUFFIX)).exists());\n }\n \n #[test]\n@@ -1355,8 +1350,8 @@ fn test_macro_pkg_script() {\n               \"extern mod rustpkg; fn main() { debug!(\\\"Hi\\\"); }\");\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n     debug!(\"workspace = {}\", workspace.display());\n-    assert!(os::path_exists(&target_build_dir(workspace).join(\"foo\").join(format!(\"pkg{}\",\n-        os::EXE_SUFFIX))));\n+    assert!(target_build_dir(workspace).join(\"foo\").join(format!(\"pkg{}\",\n+        os::EXE_SUFFIX)).exists());\n }\n \n #[test]\n@@ -1436,7 +1431,7 @@ fn rust_path_hack_cwd() {\n    // Same as rust_path_hack_test, but the CWD is the dir to build out of\n    let cwd = TempDir::new(\"foo\").expect(\"rust_path_hack_cwd\");\n    let cwd = cwd.path().join(\"foo\");\n-   assert!(os::mkdir_recursive(&cwd, U_RWX));\n+   file::mkdir_recursive(&cwd, io::UserRWX);\n    writeFile(&cwd.join(\"lib.rs\"), \"pub fn f() { }\");\n \n    let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n@@ -1456,7 +1451,7 @@ fn rust_path_hack_multi_path() {\n    // Same as rust_path_hack_test, but with a more complex package ID\n    let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_cwd\");\n    let subdir = cwd.path().join_many([\"foo\", \"bar\", \"quux\"]);\n-   assert!(os::mkdir_recursive(&subdir, U_RWX));\n+   file::mkdir_recursive(&subdir, io::UserRWX);\n    writeFile(&subdir.join(\"lib.rs\"), \"pub fn f() { }\");\n    let name = ~\"foo/bar/quux\";\n \n@@ -1870,21 +1865,22 @@ fn pkgid_pointing_to_subdir() {\n     // rustpkg should recognize that and treat the part after some_repo/ as a subdir\n     let workspace = TempDir::new(\"parent_repo\").expect(\"Couldn't create temp dir\");\n     let workspace = workspace.path();\n-    assert!(os::mkdir_recursive(&workspace.join_many([\"src\", \"mockgithub.com\",\n-                                                      \"mozilla\", \"some_repo\"]), U_RWX));\n+    file::mkdir_recursive(&workspace.join_many([\"src\", \"mockgithub.com\",\n+                                                \"mozilla\", \"some_repo\"]),\n+                          io::UserRWX);\n \n     let foo_dir = workspace.join_many([\"src\", \"mockgithub.com\", \"mozilla\", \"some_repo\",\n                                        \"extras\", \"foo\"]);\n     let bar_dir = workspace.join_many([\"src\", \"mockgithub.com\", \"mozilla\", \"some_repo\",\n                                        \"extras\", \"bar\"]);\n-    assert!(os::mkdir_recursive(&foo_dir, U_RWX));\n-    assert!(os::mkdir_recursive(&bar_dir, U_RWX));\n+    file::mkdir_recursive(&foo_dir, io::UserRWX);\n+    file::mkdir_recursive(&bar_dir, io::UserRWX);\n     writeFile(&foo_dir.join(\"lib.rs\"), \"pub fn f() {}\");\n     writeFile(&bar_dir.join(\"lib.rs\"), \"pub fn g() {}\");\n \n     debug!(\"Creating a file in {}\", workspace.display());\n     let testpkg_dir = workspace.join_many([\"src\", \"testpkg-0.1\"]);\n-    assert!(os::mkdir_recursive(&testpkg_dir, U_RWX));\n+    file::mkdir_recursive(&testpkg_dir, io::UserRWX);\n \n     writeFile(&testpkg_dir.join(\"main.rs\"),\n               \"extern mod foo = \\\"mockgithub.com/mozilla/some_repo/extras/foo\\\";\\n\n@@ -1957,9 +1953,9 @@ fn test_target_specific_build_dir() {\n                        ~\"build\",\n                        ~\"foo\"],\n                       workspace);\n-    assert!(os::path_is_dir(&target_build_dir(workspace)));\n+    assert!(target_build_dir(workspace).is_dir());\n     assert!(built_executable_exists(workspace, \"foo\"));\n-    assert!(os::list_dir(&workspace.join(\"build\")).len() == 1);\n+    assert!(file::readdir(&workspace.join(\"build\")).len() == 1);\n }\n \n #[test]\n@@ -1973,10 +1969,10 @@ fn test_target_specific_install_dir() {\n                        ~\"install\",\n                        ~\"foo\"],\n                       workspace);\n-    assert!(os::path_is_dir(&workspace.join_many([~\"lib\", host_triple()])));\n+    assert!(workspace.join_many([~\"lib\", host_triple()]).is_dir());\n     assert_lib_exists(workspace, &Path::new(\"foo\"), NoVersion);\n-    assert!(os::list_dir(&workspace.join(\"lib\")).len() == 1);\n-    assert!(os::path_is_dir(&workspace.join(\"bin\")));\n+    assert!(file::readdir(&workspace.join(\"lib\")).len() == 1);\n+    assert!(workspace.join(\"bin\").is_dir());\n     assert_executable_exists(workspace, \"foo\");\n }\n \n@@ -1988,7 +1984,7 @@ fn test_dependencies_terminate() {\n     let workspace = workspace.path();\n     let b_dir = workspace.join_many([\"src\", \"b-0.1\"]);\n     let b_subdir = b_dir.join(\"test\");\n-    assert!(os::mkdir_recursive(&b_subdir, U_RWX));\n+    file::mkdir_recursive(&b_subdir, io::UserRWX);\n     writeFile(&b_subdir.join(\"test.rs\"),\n               \"extern mod b; use b::f; #[test] fn g() { f() }\");\n     command_line_test([~\"install\", ~\"b\"], workspace);\n@@ -2161,19 +2157,19 @@ fn test_installed_read_only() {\n     debug!(\"Checking for files in {}\", ws.display());\n     let exec = target_executable_in_workspace(&temp_pkg_id, &ws);\n     debug!(\"exec = {}\", exec.display());\n-    assert!(os::path_exists(&exec));\n+    assert!(exec.exists());\n     assert!(is_rwx(&exec));\n     let built_lib =\n         built_library_in_workspace(&temp_pkg_id,\n                                    &ws).expect(\"test_install_git: built lib should exist\");\n-    assert!(os::path_exists(&built_lib));\n+    assert!(built_lib.exists());\n     assert!(is_rwx(&built_lib));\n \n     // Make sure sources are (a) under \"build\" and (b) read-only\n     let src1 = target_build_dir(&ws).join_many([~\"src\", temp_pkg_id.to_str(), ~\"main.rs\"]);\n     let src2 = target_build_dir(&ws).join_many([~\"src\", temp_pkg_id.to_str(), ~\"lib.rs\"]);\n-    assert!(os::path_exists(&src1));\n-    assert!(os::path_exists(&src2));\n+    assert!(src1.exists());\n+    assert!(src2.exists());\n     assert!(is_read_only(&src1));\n     assert!(is_read_only(&src2));\n }\n@@ -2186,7 +2182,7 @@ fn test_installed_local_changes() {\n     debug!(\"repo = {}\", repo.display());\n     let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n     debug!(\"repo_subdir = {}\", repo_subdir.display());\n-    assert!(os::mkdir_recursive(&repo.join_many([\".rust\", \"src\"]), U_RWX));\n+    file::mkdir_recursive(&repo.join_many([\".rust\", \"src\"]), io::UserRWX);\n \n     writeFile(&repo_subdir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n@@ -2269,7 +2265,7 @@ fn find_sources_in_cwd() {\n     let temp_dir = TempDir::new(\"sources\").expect(\"find_sources_in_cwd failed\");\n     let temp_dir = temp_dir.path();\n     let source_dir = temp_dir.join(\"foo\");\n-    os::mkdir_recursive(&source_dir, U_RWX);\n+    file::mkdir_recursive(&source_dir, io::UserRWX);\n     writeFile(&source_dir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n     command_line_test([~\"install\", ~\"foo\"], &source_dir);\n@@ -2292,16 +2288,13 @@ fn test_c_dependency_ok() {\n     debug!(\"dir = {}\", dir.display());\n     let source = Path::new(file!()).dir_path().join_many(\n         [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n-    if !os::copy_file(&source,\n-                      &dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"])) {\n-        fail!(\"Couldn't copy file\");\n-    }\n+    file::copy(&source, &dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"]));\n     command_line_test([~\"build\", ~\"cdep\"], dir);\n     assert_executable_exists(dir, \"cdep\");\n     let out_dir = target_build_dir(dir).join(\"cdep\");\n     let c_library_path = out_dir.join(platform_library_name(\"foo\"));\n     debug!(\"c library path: {}\", c_library_path.display());\n-    assert!(os::path_exists(&c_library_path));\n+    assert!(c_library_path.exists());\n }\n \n #[test]\n@@ -2316,16 +2309,13 @@ fn test_c_dependency_no_rebuilding() {\n     debug!(\"dir = {}\", dir.display());\n     let source = Path::new(file!()).dir_path().join_many(\n         [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n-    if !os::copy_file(&source,\n-                      &dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"])) {\n-        fail!(\"Couldn't copy file\");\n-    }\n+    file::copy(&source, &dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"]));\n     command_line_test([~\"build\", ~\"cdep\"], dir);\n     assert_executable_exists(dir, \"cdep\");\n     let out_dir = target_build_dir(dir).join(\"cdep\");\n     let c_library_path = out_dir.join(platform_library_name(\"foo\"));\n     debug!(\"c library path: {}\", c_library_path.display());\n-    assert!(os::path_exists(&c_library_path));\n+    assert!(c_library_path.exists());\n \n     // Now, make it read-only so rebuilding will fail\n     assert!(chmod_read_only(&c_library_path));\n@@ -2352,15 +2342,13 @@ fn test_c_dependency_yes_rebuilding() {\n         [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n     let target = dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"]);\n     debug!(\"Copying {} -> {}\", source.display(), target.display());\n-    if !os::copy_file(&source, &target) {\n-        fail!(\"Couldn't copy file\");\n-    }\n+    file::copy(&source, &target);\n     command_line_test([~\"build\", ~\"cdep\"], dir);\n     assert_executable_exists(dir, \"cdep\");\n     let out_dir = target_build_dir(dir).join(\"cdep\");\n     let c_library_path = out_dir.join(platform_library_name(\"foo\"));\n     debug!(\"c library path: {}\", c_library_path.display());\n-    assert!(os::path_exists(&c_library_path));\n+    assert!(c_library_path.exists());\n \n     // Now, make the Rust library read-only so rebuilding will fail\n     match built_library_in_workspace(&PkgId::new(\"cdep\"), dir) {\n@@ -2380,8 +2368,5 @@ fn test_c_dependency_yes_rebuilding() {\n fn is_executable(p: &Path) -> bool {\n     use std::libc::consts::os::posix88::{S_IXUSR};\n \n-    match p.get_mode() {\n-        None => false,\n-        Some(mode) => mode & S_IXUSR as uint == S_IXUSR as uint\n-    }\n+    p.exists() && p.stat().mode & S_IXUSR as u64 == S_IXUSR as u64\n }"}, {"sha": "f5d6317e7a68f9567ef43e41025b37998bb3a671", "filename": "src/librustpkg/testsuite/pass/src/c-dependencies/pkg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -31,7 +31,7 @@ pub fn main() {\n \n     let sysroot_arg = args[1].clone();\n     let sysroot = Path::new(sysroot_arg);\n-    if !os::path_exists(&sysroot) {\n+    if !sysroot.exists() {\n         fail!(\"Package script requires a sysroot that exists; {} doesn't\", sysroot.display());\n     }\n "}, {"sha": "e5fb6889ae09b83caf95e5d42dab6b5b997a8e68", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/pkg.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -12,9 +12,7 @@ extern mod rustpkg;\n extern mod rustc;\n \n use std::os;\n-use std::rt::io;\n-use std::rt::io::Writer;\n-use std::rt::io::file::FileInfo;\n+use std::rt::io::file;\n use rustpkg::api;\n use rustpkg::version::NoVersion;\n \n@@ -30,7 +28,7 @@ pub fn main() {\n \n     let sysroot_arg = args[1].clone();\n     let sysroot = Path::new(sysroot_arg);\n-    if !os::path_exists(&sysroot) {\n+    if !sysroot.exists() {\n         debug!(\"Failing, sysroot\");\n         fail!(\"Package script requires a sysroot that exists;{} doesn't\", sysroot.display());\n     }\n@@ -45,7 +43,7 @@ pub fn main() {\n     let out_path = os::self_exe_path().expect(\"Couldn't get self_exe path\");\n \n     debug!(\"Writing file\");\n-    let mut file = out_path.join(\"generated.rs\").open_writer(io::Create);\n+    let mut file = file::create(&out_path.join(\"generated.rs\"));\n     file.write(\"pub fn wheeeee() { let xs = [1, 2, 3]; \\\n                 for _ in xs.iter() { assert!(true); } }\".as_bytes());\n "}, {"sha": "d0ba5ce368fcd9bb734479fcfded6af7a668092a", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -10,6 +10,8 @@\n \n use std::libc;\n use std::os;\n+use std::rt::io;\n+use std::rt::io::file;\n use extra::workcache;\n use rustc::driver::{driver, session};\n use extra::getopts::groups::getopts;\n@@ -32,7 +34,6 @@ use path_util::{default_workspace, built_library_in_workspace};\n pub use target::{OutputType, Main, Lib, Bench, Test, JustOne, lib_name_of, lib_crate_filename};\n pub use target::{Target, Build, Install};\n use extra::treemap::TreeMap;\n-use path_util::U_RWX;\n pub use target::{lib_name_of, lib_crate_filename, WhatToBuild, MaybeCustom, Inferred};\n use workcache_support::{digest_file_with_date, digest_only_date};\n \n@@ -184,7 +185,7 @@ pub fn compile_input(context: &BuildContext,\n     let mut out_dir = target_build_dir(workspace);\n     out_dir.push(&pkg_id.path);\n     // Make the output directory if it doesn't exist already\n-    assert!(os::mkdir_recursive(&out_dir, U_RWX));\n+    file::mkdir_recursive(&out_dir, io::UserRWX);\n \n     let binary = os::args()[0].to_managed();\n \n@@ -256,11 +257,11 @@ pub fn compile_input(context: &BuildContext,\n     // Make sure all the library directories actually exist, since the linker will complain\n     // otherwise\n     for p in addl_lib_search_paths.iter() {\n-        if os::path_exists(p) {\n-            assert!(os::path_is_dir(p));\n+        if p.exists() {\n+            assert!(p.is_dir())\n         }\n         else {\n-            assert!(os::mkdir_recursive(p, U_RWX));\n+            file::mkdir_recursive(p, io::UserRWX);\n         }\n     }\n \n@@ -324,7 +325,7 @@ pub fn compile_input(context: &BuildContext,\n     };\n     for p in discovered_output.iter() {\n         debug!(\"About to discover output {}\", p.display());\n-        if os::path_exists(p) {\n+        if p.exists() {\n             debug!(\"4. discovering output {}\", p.display());\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             exec.discover_output(\"binary\", p.as_str().unwrap(), digest_only_date(p));\n@@ -629,10 +630,16 @@ fn debug_flags() -> ~[~str] { ~[] }\n \n /// Returns the last-modified date as an Option\n pub fn datestamp(p: &Path) -> Option<libc::time_t> {\n-    debug!(\"Scrutinizing datestamp for {} - does it exist? {:?}\", p.display(), os::path_exists(p));\n-    let out = p.stat().map(|stat| stat.modified);\n-    debug!(\"Date = {:?}\", out);\n-    out.map(|t| { t as libc::time_t })\n+    debug!(\"Scrutinizing datestamp for {} - does it exist? {:?}\", p.display(),\n+           p.exists());\n+    match io::result(|| p.stat()) {\n+        Ok(s) => {\n+            let out = s.modified;\n+            debug!(\"Date = {:?}\", out);\n+            Some(out as libc::time_t)\n+        }\n+        Err(*) => None,\n+    }\n }\n \n pub type DepMap = TreeMap<~str, ~[(~str, ~str)]>;"}, {"sha": "eff16cb99968c6a3e860462eba90d4eae7f45b35", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -14,7 +14,7 @@\n extern mod std;\n \n use extra::semver;\n-use std::{char, os, result, run, str};\n+use std::{char, result, run, str};\n use extra::tempfile::TempDir;\n use path_util::rust_path;\n \n@@ -100,7 +100,7 @@ pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n     for rp in rustpath.iter() {\n         let local_path = rp.join(local_path);\n         let git_dir = local_path.join(\".git\");\n-        if !os::path_is_dir(&git_dir) {\n+        if !git_dir.is_dir() {\n             continue;\n         }\n         // FIXME (#9639): This needs to handle non-utf8 paths"}, {"sha": "c16224afbf4c815a0d131c7cff319dd54bdbc3a2", "filename": "src/librustpkg/workcache_support.rs", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Fworkcache_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Fworkcache_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkcache_support.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -9,32 +9,23 @@\n // except according to those terms.\n \n use std::rt::io;\n-use std::rt::io::Reader;\n-use std::rt::io::file::FileInfo;\n+use std::rt::io::file;\n use extra::workcache;\n use sha1::{Digest, Sha1};\n \n /// Hashes the file contents along with the last-modified time\n pub fn digest_file_with_date(path: &Path) -> ~str {\n     use conditions::bad_path::cond;\n-    use cond1 = conditions::bad_stat::cond;\n \n-    let mut err = None;\n-    let bytes = do io::io_error::cond.trap(|e| err = Some(e)).inside {\n-        path.open_reader(io::Open).read_to_end()\n-    };\n-    match err {\n-        None => {\n+    match io::result(|| file::open(path).read_to_end()) {\n+        Ok(bytes) => {\n             let mut sha = Sha1::new();\n             sha.input(bytes);\n-            let st = match path.stat() {\n-                Some(st) => st,\n-                None => cond1.raise((path.clone(), format!(\"Couldn't get file access time\")))\n-            };\n+            let st = path.stat();\n             sha.input_str(st.modified.to_str());\n             sha.result_str()\n         }\n-        Some(e) => {\n+        Err(e) => {\n             cond.raise((path.clone(), format!(\"Couldn't read file: {}\", e.desc)));\n             ~\"\"\n         }\n@@ -43,13 +34,8 @@ pub fn digest_file_with_date(path: &Path) -> ~str {\n \n /// Hashes only the last-modified time\n pub fn digest_only_date(path: &Path) -> ~str {\n-    use cond = conditions::bad_stat::cond;\n-\n     let mut sha = Sha1::new();\n-    let st = match path.stat() {\n-                Some(st) => st,\n-                None => cond.raise((path.clone(), format!(\"Couldn't get file access time\")))\n-    };\n+    let st = path.stat();\n     sha.input_str(st.modified.to_str());\n     sha.result_str()\n }"}, {"sha": "e65f3ce5bb6ab0b81f7a89abf7c0437e3f5c8fe9", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -52,7 +52,7 @@ pub fn pkg_parent_workspaces(cx: &Context, pkgid: &PkgId) -> ~[Path] {\n }\n \n pub fn is_workspace(p: &Path) -> bool {\n-    os::path_is_dir(&p.join(\"src\"))\n+    p.join(\"src\").is_dir()\n }\n \n /// Construct a workspace and package-ID name based on the current directory."}, {"sha": "15df189edcdd4f7d211f359bcb9194d0c7a8013b", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -182,7 +182,7 @@ impl FsRequest {\n         self.sync_cleanup(result)\n     }\n \n-    pub fn mkdir(self, loop_: &Loop, path: &CString, mode: int, cb: FsCallback) {\n+    pub fn mkdir(self, loop_: &Loop, path: &CString, mode: c_int, cb: FsCallback) {\n         let complete_cb_ptr = {\n             let mut me = self;\n             me.req_boilerplate(Some(cb))\n@@ -221,6 +221,18 @@ impl FsRequest {\n         assert_eq!(ret, 0);\n     }\n \n+    pub fn chmod(self, loop_: &Loop, path: &CString, mode: c_int, cb: FsCallback) {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(Some(cb))\n+        };\n+        let ret = path.with_ref(|p| unsafe {\n+            uvll::fs_chmod(loop_.native_handle(), self.native_handle(), p, mode,\n+                           complete_cb_ptr)\n+        });\n+        assert_eq!(ret, 0);\n+    }\n+\n     pub fn readdir(self, loop_: &Loop, path: &CString,\n                    flags: c_int, cb: FsCallback) {\n         let complete_cb_ptr = {\n@@ -593,7 +605,7 @@ mod test {\n                 S_IRUSR;\n             let mkdir_req = FsRequest::new();\n             do mkdir_req.mkdir(&loop_, &path.to_c_str(),\n-                               mode as int) |req,uverr| {\n+                               mode as c_int) |req,uverr| {\n                 assert!(uverr.is_none());\n                 let loop_ = req.get_loop();\n                 let stat_req = FsRequest::new();\n@@ -626,12 +638,12 @@ mod test {\n             let mode = S_IWUSR |\n                 S_IRUSR;\n             let mkdir_req = FsRequest::new();\n-            do mkdir_req.mkdir(&loop_, &path.to_c_str(), mode as int) |req,uverr| {\n+            do mkdir_req.mkdir(&loop_, &path.to_c_str(), mode as c_int) |req,uverr| {\n                 assert!(uverr.is_none());\n                 let loop_ = req.get_loop();\n                 let mkdir_req = FsRequest::new();\n                 do mkdir_req.mkdir(&loop_, &path.to_c_str(),\n-                                   mode as int) |req,uverr| {\n+                                   mode as c_int) |req,uverr| {\n                     assert!(uverr.is_some());\n                     let loop_ = req.get_loop();\n                     let _stat = req.get_stat();"}, {"sha": "ae8546af4b40efe8a3da75e0e2c8cea6b66e8969", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -20,6 +20,7 @@ use std::option::*;\n use std::ptr;\n use std::str;\n use std::result::*;\n+use std::rt::io;\n use std::rt::io::IoError;\n use std::rt::io::net::ip::{SocketAddr, IpAddr};\n use std::rt::io::{standard_error, OtherIoError, SeekStyle, SeekSet, SeekCur,\n@@ -34,7 +35,7 @@ use std::rt::task::Task;\n use std::unstable::sync::Exclusive;\n use std::path::{GenericPath, Path};\n use std::libc::{lseek, off_t, O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY,\n-                O_WRONLY, S_IRUSR, S_IWUSR, S_IRWXU};\n+                O_WRONLY, S_IRUSR, S_IWUSR};\n use std::rt::io::{FileMode, FileAccess, OpenOrCreate, Open, Create,\n                   CreateOrTruncate, Append, Truncate, Read, Write, ReadWrite,\n                   FileStat};\n@@ -699,9 +700,10 @@ impl IoFactory for UvIoFactory {\n         assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n-    fn fs_mkdir(&mut self, path: &CString, mode: int) -> Result<(), IoError> {\n+    fn fs_mkdir(&mut self, path: &CString,\n+                perm: io::FilePermission) -> Result<(), IoError> {\n         do uv_fs_helper(self.uv_loop(), path) |mkdir_req, l, p, cb| {\n-            do mkdir_req.mkdir(l, p, mode) |req, err| {\n+            do mkdir_req.mkdir(l, p, perm as c_int) |req, err| {\n                 cb(req, err)\n             };\n         }\n@@ -722,6 +724,15 @@ impl IoFactory for UvIoFactory {\n             };\n         }\n     }\n+    fn fs_chmod(&mut self, path: &CString,\n+                perm: io::FilePermission) -> Result<(), IoError> {\n+        do uv_fs_helper(self.uv_loop(), path) |chmod_req, l, p, cb| {\n+            do chmod_req.chmod(l, p, perm as c_int) |req, err| {\n+                cb(req, err)\n+            };\n+        }\n+    }\n+>>>>>>> Remove all blocking std::os blocking functions\n     fn fs_readdir(&mut self, path: &CString, flags: c_int) ->\n         Result<~[Path], IoError> {\n         use str::StrSlice;"}, {"sha": "a2047ef98fa834b9db743710ebd480f4373ac7f5", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -795,8 +795,8 @@ pub unsafe fn fs_fstat(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int, cb: *u8)\n \n     rust_uv_fs_fstat(loop_ptr, req, fd, cb)\n }\n-pub unsafe fn fs_mkdir(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char, mode: int,\n-                cb: *u8) -> c_int {\n+pub unsafe fn fs_mkdir(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                       mode: c_int, cb: *u8) -> c_int {\n     #[fixed_stack_segment]; #[inline(never)];\n \n     rust_uv_fs_mkdir(loop_ptr, req, path, mode as c_int, cb)\n@@ -813,6 +813,12 @@ pub unsafe fn fs_rename(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n \n     rust_uv_fs_rename(loop_ptr, req, path, to, cb)\n }\n+pub unsafe fn fs_chmod(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                       mode: c_int, cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_chmod(loop_ptr, req, path, mode as c_int, cb)\n+}\n pub unsafe fn fs_readdir(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n                 flags: c_int, cb: *u8) -> c_int {\n     #[fixed_stack_segment]; #[inline(never)];\n@@ -1115,6 +1121,8 @@ extern {\n                         cb: *u8) -> c_int;\n     fn rust_uv_fs_rename(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n                          to: *c_char, cb: *u8) -> c_int;\n+    fn rust_uv_fs_chmod(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n+                        mode: c_int, cb: *u8) -> c_int;\n     fn rust_uv_fs_readdir(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n                         flags: c_int, cb: *u8) -> c_int;\n     fn rust_uv_fs_req_cleanup(req: *uv_fs_t);"}, {"sha": "7f91c5e4f9054e88e1534cb48c1dd6fb132451e6", "filename": "src/libstd/bool.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbool.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -317,8 +317,11 @@ impl Zero for bool {\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n-    use prelude::*;\n+    use cmp::{Equal, Greater, Less, Eq, TotalOrd};\n+    use ops::{BitAnd, BitXor, BitOr};\n+    use from_str::{FromStr, from_str};\n+    use option::{Some, None};\n+    use super::all_values;\n \n     #[test]\n     fn test_bool() {"}, {"sha": "12281f06005a78883f3c54732ad6d0f41aec65eb", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 546, "changes": 549, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -35,7 +35,6 @@ use container::Container;\n use iter::range;\n use libc;\n use libc::{c_char, c_void, c_int, size_t};\n-use libc::FILE;\n use option::{Some, None};\n use os;\n use prelude::*;\n@@ -45,7 +44,6 @@ use to_str;\n use unstable::finally::Finally;\n use vec;\n \n-pub use libc::fclose;\n pub use os::consts::*;\n \n /// Delegates to the libc close() function, returning the same return value.\n@@ -56,28 +54,6 @@ pub fn close(fd: c_int) -> c_int {\n     }\n }\n \n-// On Windows, wide character version of function must be used to support\n-// unicode, so functions should be split into at least two versions,\n-// which are for Windows and for non-Windows, if necessary.\n-// See https://github.com/mozilla/rust/issues/9822 for more information.\n-\n-mod rustrt {\n-    use libc::{c_char, c_int};\n-    use libc;\n-\n-    extern {\n-        pub fn rust_path_is_dir(path: *libc::c_char) -> c_int;\n-        pub fn rust_path_exists(path: *libc::c_char) -> c_int;\n-    }\n-\n-    // Uses _wstat instead of stat.\n-    #[cfg(windows)]\n-    extern {\n-        pub fn rust_path_is_dir_u16(path: *u16) -> c_int;\n-        pub fn rust_path_exists_u16(path: *u16) -> c_int;\n-    }\n-}\n-\n pub static TMPBUF_SZ : uint = 1000u;\n static BUF_BYTES : uint = 2048u;\n \n@@ -348,15 +324,6 @@ pub fn unsetenv(n: &str) {\n     _unsetenv(n);\n }\n \n-pub fn fdopen(fd: c_int) -> *FILE {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    do \"r\".with_c_str |modebuf| {\n-        unsafe {\n-            libc::fdopen(fd, modebuf)\n-        }\n-    }\n-}\n-\n pub struct Pipe {\n     input: c_int,\n     out: c_int\n@@ -373,8 +340,6 @@ pub fn pipe() -> Pipe {\n     }\n }\n \n-\n-\n #[cfg(windows)]\n pub fn pipe() -> Pipe {\n     #[fixed_stack_segment]; #[inline(never)];\n@@ -574,58 +539,6 @@ pub fn tmpdir() -> Path {\n     }\n }\n \n-/// Recursively walk a directory structure\n-pub fn walk_dir(p: &Path, f: &fn(&Path) -> bool) -> bool {\n-    let r = list_dir(p);\n-    r.iter().advance(|q| {\n-        let path = &p.join(q);\n-        f(path) && (!path_is_dir(path) || walk_dir(path, |p| f(p)))\n-    })\n-}\n-\n-#[cfg(unix)]\n-/// Indicates whether a path represents a directory\n-pub fn path_is_dir(p: &Path) -> bool {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    unsafe {\n-        do p.with_c_str |buf| {\n-            rustrt::rust_path_is_dir(buf) != 0 as c_int\n-        }\n-    }\n-}\n-\n-\n-#[cfg(windows)]\n-pub fn path_is_dir(p: &Path) -> bool {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    unsafe {\n-        do os::win32::as_utf16_p(p.as_str().unwrap()) |buf| {\n-            rustrt::rust_path_is_dir_u16(buf) != 0 as c_int\n-        }\n-    }\n-}\n-\n-#[cfg(unix)]\n-/// Indicates whether a path exists\n-pub fn path_exists(p: &Path) -> bool {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    unsafe {\n-        do p.with_c_str |buf| {\n-            rustrt::rust_path_exists(buf) != 0 as c_int\n-        }\n-    }\n-}\n-\n-#[cfg(windows)]\n-pub fn path_exists(p: &Path) -> bool {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    unsafe {\n-        do os::win32::as_utf16_p(p.as_str().unwrap()) |buf| {\n-            rustrt::rust_path_exists_u16(buf) != 0 as c_int\n-        }\n-    }\n-}\n-\n /**\n  * Convert a relative path to an absolute path\n  *\n@@ -646,206 +559,6 @@ pub fn make_absolute(p: &Path) -> Path {\n     }\n }\n \n-\n-/// Creates a directory at the specified path\n-pub fn make_dir(p: &Path, mode: c_int) -> bool {\n-    return mkdir(p, mode);\n-\n-    #[cfg(windows)]\n-    fn mkdir(p: &Path, _mode: c_int) -> bool {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        unsafe {\n-            use os::win32::as_utf16_p;\n-            // FIXME: turn mode into something useful? #2623\n-            do as_utf16_p(p.as_str().unwrap()) |buf| {\n-                libc::CreateDirectoryW(buf, ptr::mut_null())\n-                    != (0 as libc::BOOL)\n-            }\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    fn mkdir(p: &Path, mode: c_int) -> bool {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        do p.with_c_str |buf| {\n-            unsafe {\n-                libc::mkdir(buf, mode as libc::mode_t) == (0 as c_int)\n-            }\n-        }\n-    }\n-}\n-\n-/// Creates a directory with a given mode.\n-/// Returns true iff creation\n-/// succeeded. Also creates all intermediate subdirectories\n-/// if they don't already exist, giving all of them the same mode.\n-\n-// tjc: if directory exists but with different permissions,\n-// should we return false?\n-pub fn mkdir_recursive(p: &Path, mode: c_int) -> bool {\n-    if path_is_dir(p) {\n-        return true;\n-    }\n-    if p.filename().is_some() {\n-        let mut p_ = p.clone();\n-        p_.pop();\n-        if !mkdir_recursive(&p_, mode) {\n-            return false;\n-        }\n-    }\n-    return make_dir(p, mode);\n-}\n-\n-/// Lists the contents of a directory\n-///\n-/// Each resulting Path is a relative path with no directory component.\n-pub fn list_dir(p: &Path) -> ~[Path] {\n-    unsafe {\n-        #[cfg(target_os = \"linux\")]\n-        #[cfg(target_os = \"android\")]\n-        #[cfg(target_os = \"freebsd\")]\n-        #[cfg(target_os = \"macos\")]\n-        unsafe fn get_list(p: &Path) -> ~[Path] {\n-            #[fixed_stack_segment]; #[inline(never)];\n-            use libc::{dirent_t};\n-            use libc::{opendir, readdir, closedir};\n-            extern {\n-                fn rust_list_dir_val(ptr: *dirent_t) -> *libc::c_char;\n-            }\n-            let mut paths = ~[];\n-            debug!(\"os::list_dir -- BEFORE OPENDIR\");\n-\n-            let dir_ptr = do p.with_c_str |buf| {\n-                opendir(buf)\n-            };\n-\n-            if (dir_ptr as uint != 0) {\n-                debug!(\"os::list_dir -- opendir() SUCCESS\");\n-                let mut entry_ptr = readdir(dir_ptr);\n-                while (entry_ptr as uint != 0) {\n-                    let cstr = CString::new(rust_list_dir_val(entry_ptr), false);\n-                    paths.push(Path::new(cstr));\n-                    entry_ptr = readdir(dir_ptr);\n-                }\n-                closedir(dir_ptr);\n-            }\n-            else {\n-                debug!(\"os::list_dir -- opendir() FAILURE\");\n-            }\n-            debug!(\"os::list_dir -- AFTER -- \\\\#: {}\", paths.len());\n-            paths\n-        }\n-        #[cfg(windows)]\n-        unsafe fn get_list(p: &Path) -> ~[Path] {\n-            #[fixed_stack_segment]; #[inline(never)];\n-            use libc::consts::os::extra::INVALID_HANDLE_VALUE;\n-            use libc::{wcslen, free};\n-            use libc::funcs::extra::kernel32::{\n-                FindFirstFileW,\n-                FindNextFileW,\n-                FindClose,\n-            };\n-            use libc::types::os::arch::extra::HANDLE;\n-            use os::win32::{\n-                as_utf16_p\n-            };\n-            use rt::global_heap::malloc_raw;\n-\n-            #[nolink]\n-            extern {\n-                fn rust_list_dir_wfd_size() -> libc::size_t;\n-                fn rust_list_dir_wfd_fp_buf(wfd: *libc::c_void) -> *u16;\n-            }\n-            let star = p.join(\"*\");\n-            do as_utf16_p(star.as_str().unwrap()) |path_ptr| {\n-                let mut paths = ~[];\n-                let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint);\n-                let find_handle = FindFirstFileW(path_ptr, wfd_ptr as HANDLE);\n-                if find_handle as libc::c_int != INVALID_HANDLE_VALUE {\n-                    let mut more_files = 1 as libc::c_int;\n-                    while more_files != 0 {\n-                        let fp_buf = rust_list_dir_wfd_fp_buf(wfd_ptr);\n-                        if fp_buf as uint == 0 {\n-                            fail!(\"os::list_dir() failure: got null ptr from wfd\");\n-                        }\n-                        else {\n-                            let fp_vec = vec::from_buf(\n-                                fp_buf, wcslen(fp_buf) as uint);\n-                            let fp_str = str::from_utf16(fp_vec);\n-                            paths.push(Path::new(fp_str));\n-                        }\n-                        more_files = FindNextFileW(find_handle, wfd_ptr as HANDLE);\n-                    }\n-                    FindClose(find_handle);\n-                    free(wfd_ptr)\n-                }\n-                paths\n-            }\n-        }\n-        do get_list(p).move_iter().filter |path| {\n-            path.as_vec() != bytes!(\".\") && path.as_vec() != bytes!(\"..\")\n-        }.collect()\n-    }\n-}\n-\n-/**\n- * Lists the contents of a directory\n- *\n- * This version prepends each entry with the directory.\n- */\n-pub fn list_dir_path(p: &Path) -> ~[Path] {\n-    list_dir(p).map(|f| p.join(f))\n-}\n-\n-/// Removes a directory at the specified path, after removing\n-/// all its contents. Use carefully!\n-pub fn remove_dir_recursive(p: &Path) -> bool {\n-    let mut error_happened = false;\n-    do walk_dir(p) |inner| {\n-        if !error_happened {\n-            if path_is_dir(inner) {\n-                if !remove_dir_recursive(inner) {\n-                    error_happened = true;\n-                }\n-            }\n-            else {\n-                if !remove_file(inner) {\n-                    error_happened = true;\n-                }\n-            }\n-        }\n-        true\n-    };\n-    // Directory should now be empty\n-    !error_happened && remove_dir(p)\n-}\n-\n-/// Removes a directory at the specified path\n-pub fn remove_dir(p: &Path) -> bool {\n-   return rmdir(p);\n-\n-    #[cfg(windows)]\n-    fn rmdir(p: &Path) -> bool {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        unsafe {\n-            use os::win32::as_utf16_p;\n-            return do as_utf16_p(p.as_str().unwrap()) |buf| {\n-                libc::RemoveDirectoryW(buf) != (0 as libc::BOOL)\n-            };\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    fn rmdir(p: &Path) -> bool {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        do p.with_c_str |buf| {\n-            unsafe {\n-                libc::rmdir(buf) == (0 as c_int)\n-            }\n-        }\n-    }\n-}\n-\n /// Changes the current working directory to the specified path, returning\n /// whether the change was completed successfully or not.\n pub fn change_dir(p: &Path) -> bool {\n@@ -873,121 +586,6 @@ pub fn change_dir(p: &Path) -> bool {\n     }\n }\n \n-/// Copies a file from one location to another\n-pub fn copy_file(from: &Path, to: &Path) -> bool {\n-    return do_copy_file(from, to);\n-\n-    #[cfg(windows)]\n-    fn do_copy_file(from: &Path, to: &Path) -> bool {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        unsafe {\n-            use os::win32::as_utf16_p;\n-            return do as_utf16_p(from.as_str().unwrap()) |fromp| {\n-                do as_utf16_p(to.as_str().unwrap()) |top| {\n-                    libc::CopyFileW(fromp, top, (0 as libc::BOOL)) !=\n-                        (0 as libc::BOOL)\n-                }\n-            }\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    fn do_copy_file(from: &Path, to: &Path) -> bool {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        unsafe {\n-            let istream = do from.with_c_str |fromp| {\n-                do \"rb\".with_c_str |modebuf| {\n-                    libc::fopen(fromp, modebuf)\n-                }\n-            };\n-            if istream as uint == 0u {\n-                return false;\n-            }\n-            // Preserve permissions\n-            let from_mode = from.get_mode().expect(\"copy_file: couldn't get permissions \\\n-                                                    for source file\");\n-\n-            let ostream = do to.with_c_str |top| {\n-                do \"w+b\".with_c_str |modebuf| {\n-                    libc::fopen(top, modebuf)\n-                }\n-            };\n-            if ostream as uint == 0u {\n-                fclose(istream);\n-                return false;\n-            }\n-            let bufsize = 8192u;\n-            let mut buf = vec::with_capacity::<u8>(bufsize);\n-            let mut done = false;\n-            let mut ok = true;\n-            while !done {\n-                do buf.as_mut_buf |b, _sz| {\n-                  let nread = libc::fread(b as *mut c_void, 1u as size_t,\n-                                          bufsize as size_t,\n-                                          istream);\n-                  if nread > 0 as size_t {\n-                      if libc::fwrite(b as *c_void, 1u as size_t, nread,\n-                                      ostream) != nread {\n-                          ok = false;\n-                          done = true;\n-                      }\n-                  } else {\n-                      done = true;\n-                  }\n-              }\n-            }\n-            fclose(istream);\n-            fclose(ostream);\n-\n-            // Give the new file the old file's permissions\n-            if do to.with_c_str |to_buf| {\n-                libc::chmod(to_buf, from_mode as libc::mode_t)\n-            } != 0 {\n-                return false; // should be a condition...\n-            }\n-            return ok;\n-        }\n-    }\n-}\n-\n-/// Deletes an existing file\n-pub fn remove_file(p: &Path) -> bool {\n-    return unlink(p);\n-\n-    #[cfg(windows)]\n-    fn unlink(p: &Path) -> bool {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        unsafe {\n-            use os::win32::as_utf16_p;\n-            return do as_utf16_p(p.as_str().unwrap()) |buf| {\n-                libc::DeleteFileW(buf) != (0 as libc::BOOL)\n-            };\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    fn unlink(p: &Path) -> bool {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        unsafe {\n-            do p.with_c_str |buf| {\n-                libc::unlink(buf) == (0 as c_int)\n-            }\n-        }\n-    }\n-}\n-\n-/// Renames an existing file or directory\n-pub fn rename_file(old: &Path, new: &Path) -> bool {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    unsafe {\n-       do old.with_c_str |old_buf| {\n-            do new.with_c_str |new_buf| {\n-                libc::rename(old_buf, new_buf) == (0 as c_int)\n-            }\n-       }\n-    }\n-}\n-\n #[cfg(unix)]\n /// Returns the platform-specific value of errno\n pub fn errno() -> int {\n@@ -1707,19 +1305,15 @@ pub mod consts {\n #[cfg(test)]\n mod tests {\n     use c_str::ToCStr;\n-    use libc::{c_int, c_void, size_t};\n-    use libc;\n     use option::Some;\n     use option;\n     use os::{env, getcwd, getenv, make_absolute, args};\n-    use os::{remove_file, setenv, unsetenv};\n+    use os::{setenv, unsetenv};\n     use os;\n     use path::Path;\n     use rand::Rng;\n     use rand;\n-    use run;\n     use str::StrSlice;\n-    use libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n \n \n     #[test]\n@@ -1875,144 +1469,6 @@ mod tests {\n         for s in olduserprofile.iter() { setenv(\"USERPROFILE\", *s) }\n     }\n \n-    #[test]\n-    fn tmpdir() {\n-        let p = os::tmpdir();\n-        let s = p.as_str();\n-        assert!(s.is_some() && s.unwrap() != \".\");\n-    }\n-\n-    // Issue #712\n-    #[test]\n-    fn test_list_dir_no_invalid_memory_access() {\n-        os::list_dir(&Path::new(\".\"));\n-    }\n-\n-    #[test]\n-    fn list_dir() {\n-        let dirs = os::list_dir(&Path::new(\".\"));\n-        // Just assuming that we've got some contents in the current directory\n-        assert!(dirs.len() > 0u);\n-\n-        for dir in dirs.iter() {\n-            debug!(\"{:?}\", (*dir).clone());\n-        }\n-    }\n-\n-    #[test]\n-    #[cfg(not(windows))]\n-    fn list_dir_root() {\n-        let dirs = os::list_dir(&Path::new(\"/\"));\n-        assert!(dirs.len() > 1);\n-    }\n-    #[test]\n-    #[cfg(windows)]\n-    fn list_dir_root() {\n-        let dirs = os::list_dir(&Path::new(\"C:\\\\\"));\n-        assert!(dirs.len() > 1);\n-    }\n-\n-\n-    #[test]\n-    fn path_is_dir() {\n-        use rt::io::file::open;\n-        use rt::io::{OpenOrCreate, Read};\n-\n-        assert!((os::path_is_dir(&Path::new(\".\"))));\n-        assert!((!os::path_is_dir(&Path::new(\"test/stdtest/fs.rs\"))));\n-\n-        let mut dirpath = os::tmpdir();\n-        dirpath.push(format!(\"rust-test-{}/test-\\uac00\\u4e00\\u30fc\\u4f60\\u597d\",\n-            rand::random::<u32>())); // \uac00\u4e00\u30fc\u4f60\u597d\n-        debug!(\"path_is_dir dirpath: {}\", dirpath.display());\n-\n-        let mkdir_result = os::mkdir_recursive(&dirpath, (S_IRUSR | S_IWUSR | S_IXUSR) as i32);\n-        debug!(\"path_is_dir mkdir_result: {}\", mkdir_result);\n-\n-        assert!((os::path_is_dir(&dirpath)));\n-\n-        let mut filepath = dirpath;\n-        filepath.push(\"unicode-file-\\uac00\\u4e00\\u30fc\\u4f60\\u597d.rs\");\n-        debug!(\"path_is_dir filepath: {}\", filepath.display());\n-\n-        open(&filepath, OpenOrCreate, Read); // ignore return; touch only\n-        assert!((!os::path_is_dir(&filepath)));\n-\n-        assert!((!os::path_is_dir(&Path::new(\n-                     \"test/unicode-bogus-dir-\\uac00\\u4e00\\u30fc\\u4f60\\u597d\"))));\n-    }\n-\n-    #[test]\n-    fn path_exists() {\n-        assert!((os::path_exists(&Path::new(\".\"))));\n-        assert!((!os::path_exists(&Path::new(\n-                     \"test/nonexistent-bogus-path\"))));\n-\n-        let mut dirpath = os::tmpdir();\n-        dirpath.push(format!(\"rust-test-{}/test-\\uac01\\u4e01\\u30fc\\u518d\\u89c1\",\n-            rand::random::<u32>())); // \uac01\u4e01\u30fc\u518d\u89c1\n-\n-        os::mkdir_recursive(&dirpath, (S_IRUSR | S_IWUSR | S_IXUSR) as i32);\n-        assert!((os::path_exists(&dirpath)));\n-        assert!((!os::path_exists(&Path::new(\n-                     \"test/unicode-bogus-path-\\uac01\\u4e01\\u30fc\\u518d\\u89c1\"))));\n-    }\n-\n-    #[test]\n-    fn copy_file_does_not_exist() {\n-      assert!(!os::copy_file(&Path::new(\"test/nonexistent-bogus-path\"),\n-                            &Path::new(\"test/other-bogus-path\")));\n-      assert!(!os::path_exists(&Path::new(\"test/other-bogus-path\")));\n-    }\n-\n-    #[test]\n-    fn copy_file_ok() {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            let tempdir = getcwd(); // would like to use $TMPDIR,\n-                                    // doesn't seem to work on Linux\n-            let input = tempdir.join(\"in.txt\");\n-            let out = tempdir.join(\"out.txt\");\n-\n-            /* Write the temp input file */\n-            let ostream = do input.with_c_str |fromp| {\n-                do \"w+b\".with_c_str |modebuf| {\n-                    libc::fopen(fromp, modebuf)\n-                }\n-            };\n-            assert!((ostream as uint != 0u));\n-            let s = ~\"hello\";\n-            do \"hello\".with_c_str |buf| {\n-                let write_len = libc::fwrite(buf as *c_void,\n-                                             1u as size_t,\n-                                             (s.len() + 1u) as size_t,\n-                                             ostream);\n-                assert_eq!(write_len, (s.len() + 1) as size_t)\n-            }\n-            assert_eq!(libc::fclose(ostream), (0u as c_int));\n-            let in_mode = input.get_mode();\n-            let rs = os::copy_file(&input, &out);\n-            if (!os::path_exists(&input)) {\n-                fail!(\"{} doesn't exist\", input.display());\n-            }\n-            assert!((rs));\n-            // FIXME (#9639): This needs to handle non-utf8 paths\n-            let rslt = run::process_status(\"diff\", [input.as_str().unwrap().to_owned(),\n-                                                    out.as_str().unwrap().to_owned()]);\n-            assert_eq!(rslt, 0);\n-            assert_eq!(out.get_mode(), in_mode);\n-            assert!((remove_file(&input)));\n-            assert!((remove_file(&out)));\n-        }\n-    }\n-\n-    #[test]\n-    fn recursive_mkdir_slash() {\n-        let path = Path::new(\"/\");\n-        assert!(os::mkdir_recursive(&path,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-    }\n-\n     #[test]\n     fn memory_map_rw() {\n         use result::{Ok, Err};\n@@ -2039,6 +1495,7 @@ mod tests {\n         use result::{Ok, Err};\n         use os::*;\n         use libc::*;\n+        use rt::io::file;\n \n         #[cfg(unix)]\n         #[fixed_stack_segment]\n@@ -2060,7 +1517,6 @@ mod tests {\n         let mut path = tmpdir();\n         path.push(\"mmap_file.tmp\");\n         let size = MemoryMap::granularity() * 2;\n-        remove_file(&path);\n \n         let fd = unsafe {\n             let fd = do path.with_c_str |path| {\n@@ -2088,6 +1544,7 @@ mod tests {\n             assert!(*chunk.data == 0xbe);\n             close(fd);\n         }\n+        file::unlink(&path);\n     }\n \n     // More recursive_mkdir tests are in extra::tempfile"}, {"sha": "f14f100de73c96c688f3080c3878a430da981b1b", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -24,9 +24,6 @@ use vec;\n use vec::{CopyableVector, RSplitIterator, SplitIterator, Vector, VectorVector};\n use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n \n-#[cfg(not(target_os = \"win32\"))]\n-use rt::io::{FileStat, file, io_error};\n-\n /// Iterator that yields successive components of a Path as &[u8]\n pub type ComponentIter<'self> = SplitIterator<'self, u8>;\n /// Iterator that yields components of a Path in reverse as &[u8]\n@@ -442,72 +439,6 @@ fn normalize_helper<'a>(v: &'a [u8], is_abs: bool) -> Option<~[&'a [u8]]> {\n static dot_static: &'static [u8] = bytes!(\".\");\n static dot_dot_static: &'static [u8] = bytes!(\"..\");\n \n-// Stat support\n-#[cfg(not(target_os = \"win32\"))]\n-impl Path {\n-    /// Calls stat() on the represented file and returns the resulting rt::io::FileStat\n-    pub fn stat(&self) -> Option<FileStat> {\n-        let mut file_stat: Option<FileStat> = None;\n-        do io_error::cond.trap(|_| { /* Ignore error, will return None */ }).inside {\n-            file_stat = file::stat(self);\n-        }\n-        file_stat\n-    }\n-\n-    /// Returns whether the represented file exists\n-    pub fn exists(&self) -> bool {\n-        match self.stat() {\n-            None => false,\n-            Some(_) => true\n-        }\n-    }\n-\n-    /// Returns the filesize of the represented file\n-    pub fn get_size(&self) -> Option<u64> {\n-        match self.stat() {\n-            None => None,\n-            Some(st) => Some(st.size)\n-        }\n-    }\n-\n-    /// Returns the mode of the represented file\n-    pub fn get_mode(&self) -> Option<uint> {\n-        match self.stat() {\n-            None => None,\n-            Some(st) => Some(st.mode as uint)\n-        }\n-    }\n-}\n-\n-#[cfg(target_os = \"freebsd\")]\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"macos\")]\n-impl Path {\n-    /// Returns the atime of the represented file, as msecs\n-    pub fn get_atime(&self) -> Option<u64> {\n-        match self.stat() {\n-            None => None,\n-            Some(st) => Some(st.accessed)\n-        }\n-    }\n-\n-    /// Returns the mtime of the represented file, as msecs\n-    pub fn get_mtime(&self) -> Option<u64> {\n-        match self.stat() {\n-            None => None,\n-            Some(st) => Some(st.modified)\n-        }\n-    }\n-\n-    /// Returns the ctime of the represented file, as msecs\n-    pub fn get_ctime(&self) -> Option<u64> {\n-        match self.stat() {\n-            None => None,\n-            Some(st) => Some(st.created)\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "c9499bb4aa8e604f2f5a064cc1d79a30f56e9340", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -13,11 +13,12 @@\n \n use rand::Rng;\n use ops::Drop;\n+use path::Path;\n \n #[cfg(unix)]\n use rand::reader::ReaderRng;\n #[cfg(unix)]\n-use rt::io::{file, Open, Read};\n+use rt::io::file;\n \n #[cfg(windows)]\n use cast;\n@@ -40,7 +41,7 @@ type HCRYPTPROV = c_long;\n /// This does not block.\n #[cfg(unix)]\n pub struct OSRng {\n-    priv inner: ReaderRng<file::FileStream>\n+    priv inner: ReaderRng<file::FileReader>\n }\n /// A random number generator that retrieves randomness straight from\n /// the operating system. Platform sources:\n@@ -60,7 +61,8 @@ impl OSRng {\n     /// Create a new `OSRng`.\n     #[cfg(unix)]\n     pub fn new() -> OSRng {\n-        let reader = file::open(& &\"/dev/urandom\", Open, Read).expect(\"Error opening /dev/urandom\");\n+        let reader = file::open(&Path::new(\"/dev/urandom\"));\n+        let reader = reader.expect(\"Error opening /dev/urandom\");\n         let reader_rng = ReaderRng::new(reader);\n \n         OSRng { inner: reader_rng }"}, {"sha": "b6c0b58434f1ab958e5fad102db517f9f7f9443d", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 386, "deletions": 407, "changes": 793, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -13,50 +13,43 @@\n This module provides a set of functions and traits for working\n with regular files & directories on a filesystem.\n \n-At the top-level of the module are a set of freestanding functions,\n-associated with various filesystem operations. They all operate\n-on a `ToCStr` object. This trait is already defined for common\n-objects such as strings and `Path` instances.\n+At the top-level of the module are a set of freestanding functions, associated\n+with various filesystem operations. They all operate on a `Path` object.\n \n All operations in this module, including those as part of `FileStream` et al\n block the task during execution. Most will raise `std::rt::io::io_error`\n conditions in the event of failure.\n \n-Also included in this module are the `FileInfo` and `DirectoryInfo` traits. When\n-`use`'d alongside a value whose type implements them (A `std::path::Path` impl is\n-a part of this module), they expose a set of functions for operations against\n-a given file location, depending on whether the path already exists. Whenever\n-possible, the `{FileInfo, DirectoryInfo}` preserve the same semantics as their\n-free function counterparts.\n+Also included in this module is an implementation block on the `Path` object\n+defined in `std::path::Path`. The impl adds useful methods about inspecting the\n+metadata of a file. This includes getting the `stat` information, reading off\n+particular bits of it, etc.\n+\n */\n \n-use prelude::*;\n use c_str::ToCStr;\n use super::{Reader, Writer, Seek};\n-use super::{SeekStyle, Read, Write};\n+use super::{SeekStyle, Read, Write, Open, CreateOrTruncate,\n+            FileMode, FileAccess, FileStat, io_error, FilePermission};\n use rt::rtio::{RtioFileStream, IoFactory, with_local_io};\n-use rt::io::{io_error, EndOfFile,\n-            FileMode, FileAccess, FileStat, IoError,\n-            PathAlreadyExists, PathDoesntExist,\n-            MismatchedFileTypeForOperation, ignore_io_error};\n-use option::{Some, None};\n-use path::Path;\n+use rt::io;\n+use option::{Some, None, Option};\n+use result::{Ok, Err};\n+use path;\n+use path::{Path, GenericPath};\n \n /// Open a file for reading/writing, as indicated by `path`.\n ///\n /// # Example\n ///\n-///     use std;\n-///     use std::path::Path;\n-///     use std::rt::io::file::open;\n-///     use std::rt::io::{FileMode, FileAccess};\n+///     use std::rt::{io, file, io_error};\n ///\n-///     let p = &Path(\"/some/file/path.txt\");\n+///     let p = Path::new(\"/some/file/path.txt\");\n ///\n ///     do io_error::cond.trap(|_| {\n ///         // hoo-boy...\n ///     }).inside {\n-///         let stream = match open(p, Create, ReadWrite) {\n+///         let stream = match file::open_stream(&p, io::Create, io::ReadWrite) {\n ///             Some(s) => s,\n ///             None => fail!(\"whoops! I'm sure this raised, anyways..\")\n ///         };\n@@ -72,24 +65,23 @@ use path::Path;\n ///\n /// Note that, with this function, a `FileStream` is returned regardless of\n /// the access-limitations indicated by `FileAccess` (e.g. calling `write` on a\n-/// `FileStream` opened as `ReadOnly` will raise an `io_error` condition at runtime). If you\n-/// desire a more-correctly-constrained interface to files, use the\n-/// `{open_stream, open_reader, open_writer}` methods that are a part of `FileInfo`\n+/// `FileStream` opened as `ReadOnly` will raise an `io_error` condition at\n+/// runtime). If you desire a more-correctly-constrained interface to files,\n+/// use the `{open_stream, open, create}` methods that are a part of `Path`.\n ///\n /// # Errors\n ///\n-/// This function will raise an `io_error` condition under a number of different circumstances,\n-/// to include but not limited to:\n+/// This function will raise an `io_error` condition under a number of different\n+/// circumstances, to include but not limited to:\n ///\n-/// * Opening a file that already exists with `FileMode` of `Create` or vice versa (e.g.\n-///   opening a non-existant file with `FileMode` or `Open`)\n-/// * Attempting to open a file with a `FileAccess` that the user lacks permissions\n-///   for\n+/// * Opening a file that already exists with `FileMode` of `Create` or vice\n+///   versa (e.g.  opening a non-existant file with `FileMode` or `Open`)\n+/// * Attempting to open a file with a `FileAccess` that the user lacks\n+///   permissions for\n /// * Filesystem-level errors (full disk, etc)\n-pub fn open<P: ToCStr>(path: &P,\n-                       mode: FileMode,\n-                       access: FileAccess\n-                      ) -> Option<FileStream> {\n+pub fn open_stream(path: &Path,\n+                   mode: FileMode,\n+                   access: FileAccess) -> Option<FileStream> {\n     do with_local_io |io| {\n         match io.fs_open(&path.to_c_str(), mode, access) {\n             Ok(fd) => Some(FileStream {\n@@ -104,16 +96,32 @@ pub fn open<P: ToCStr>(path: &P,\n     }\n }\n \n+/// Attempts to open a file in read-only mode. This function is equivalent to\n+/// `open_stream(path, Open, Read)`, and will raise all of the same errors that\n+/// `open_stream` does.\n+///\n+/// For more information, see the `open_stream` function.\n+pub fn open(path: &Path) -> Option<FileReader> {\n+    open_stream(path, Open, Read).map(|s| FileReader { stream: s })\n+}\n+\n+/// Attempts to create a file in write-only mode. This function is equivalent to\n+/// `open_stream(path, CreateOrTruncate, Write)`, and will raise all of the\n+/// same errors that `open_stream` does.\n+///\n+/// For more information, see the `open_stream` function.\n+pub fn create(path: &Path) -> Option<FileWriter> {\n+    open_stream(path, CreateOrTruncate, Write).map(|s| FileWriter { stream: s })\n+}\n+\n /// Unlink a file from the underlying filesystem.\n ///\n /// # Example\n ///\n-///     use std;\n-///     use std::path::Path;\n-///     use std::rt::io::file::unlink;\n+///     use std::rt::io::file;\n ///\n-///     let p = &Path(\"/some/file/path.txt\");\n-///     unlink(p);\n+///     let p = Path::new(\"/some/file/path.txt\");\n+///     file::unlink(&p);\n ///     // if we made it here without failing, then the\n ///     // unlink operation was successful\n ///\n@@ -123,12 +131,13 @@ pub fn open<P: ToCStr>(path: &P,\n ///\n /// # Errors\n ///\n-/// This function will raise an `io_error` condition if the user lacks permissions to\n-/// remove the file or if some other filesystem-level error occurs\n-pub fn unlink<P: ToCStr>(path: &P) {\n+/// This function will raise an `io_error` condition if the path points to a\n+/// directory, the user lacks permissions to remove the file, or if some other\n+/// filesystem-level error occurs.\n+pub fn unlink(path: &Path) {\n     do with_local_io |io| {\n         match io.fs_unlink(&path.to_c_str()) {\n-            Ok(_) => Some(()),\n+            Ok(()) => Some(()),\n             Err(ioerr) => {\n                 io_error::cond.raise(ioerr);\n                 None\n@@ -141,21 +150,21 @@ pub fn unlink<P: ToCStr>(path: &P) {\n ///\n /// # Example\n ///\n-///     use std;\n-///     use std::path::Path;\n-///     use std::rt::io::file::mkdir;\n+///     use std::libc::S_IRWXU;\n+///     use std::rt::io::file;\n ///\n-///     let p = &Path(\"/some/dir\");\n-///     mkdir(p);\n+///     let p = Path::new(\"/some/dir\");\n+///     file::mkdir(&p, S_IRWXU as int);\n ///     // If we got here, our directory exists! Horray!\n ///\n /// # Errors\n ///\n-/// This call will raise an `io_error` condition if the user lacks permissions to make a\n-/// new directory at the provided path, or if the directory already exists\n-pub fn mkdir<P: ToCStr>(path: &P) {\n+/// This call will raise an `io_error` condition if the user lacks permissions\n+/// to make a new directory at the provided path, or if the directory already\n+/// exists.\n+pub fn mkdir(path: &Path, mode: FilePermission) {\n     do with_local_io |io| {\n-        match io.fs_mkdir(&path.to_c_str()) {\n+        match io.fs_mkdir(&path.to_c_str(), mode) {\n             Ok(_) => Some(()),\n             Err(ioerr) => {\n                 io_error::cond.raise(ioerr);\n@@ -169,19 +178,18 @@ pub fn mkdir<P: ToCStr>(path: &P) {\n ///\n /// # Example\n ///\n-///     use std;\n-///     use std::path::Path;\n-///     use std::rt::io::file::rmdir;\n+///     use std::rt::io::file;\n ///\n-///     let p = &Path(\"/some/dir\");\n-///     rmdir(p);\n+///     let p = Path::new(\"/some/dir\");\n+///     file::rmdir(&p);\n ///     // good riddance, you mean ol' directory\n ///\n /// # Errors\n ///\n-/// This call will raise an `io_error` condition if the user lacks permissions to remove the\n-/// directory at the provided path, or if the directory isn't empty\n-pub fn rmdir<P: ToCStr>(path: &P) {\n+/// This call will raise an `io_error` condition if the user lacks permissions\n+/// to remove the directory at the provided path, or if the directory isn't\n+/// empty.\n+pub fn rmdir(path: &Path) {\n     do with_local_io |io| {\n         match io.fs_rmdir(&path.to_c_str()) {\n             Ok(_) => Some(()),\n@@ -198,37 +206,31 @@ pub fn rmdir<P: ToCStr>(path: &P) {\n /// Given a path, query the file system to get information about a file,\n /// directory, etc.\n ///\n-/// Returns a `Some(std::rt::io::PathInfo)` on success\n+/// Returns a fully-filled out stat structure on succes, and on failure it will\n+/// return a dummy stat structure (it is expected that the condition raised is\n+/// handled as well).\n ///\n /// # Example\n ///\n-///     use std;\n-///     use std::path::Path;\n-///     use std::rt::io::file::stat;\n+///     use std::rt::io::{file, io_error};\n ///\n-///     let p = &Path(\"/some/file/path.txt\");\n+///     let p = Path::new(\"/some/file/path.txt\");\n ///\n ///     do io_error::cond.trap(|_| {\n ///         // hoo-boy...\n ///     }).inside {\n-///         let info = match stat(p) {\n-///             Some(s) => s,\n-///             None => fail!(\"whoops! I'm sure this raised, anyways..\");\n-///         }\n-///         if stat.is_file {\n+///         let info = file::stat(p);\n+///         if info.is_file {\n ///             // just imagine the possibilities ...\n ///         }\n-///\n-///         // the file stream will be closed at the end of this block\n ///     }\n-///     // ..\n ///\n /// # Errors\n ///\n /// This call will raise an `io_error` condition if the user lacks the requisite\n /// permissions to perform a `stat` call on the given path or if there is no\n /// entry in the filesystem at the provided path.\n-pub fn stat<P: ToCStr>(path: &P) -> Option<FileStat> {\n+pub fn stat(path: &Path) -> FileStat {\n     do with_local_io |io| {\n         match io.fs_stat(&path.to_c_str()) {\n             Ok(p) => Some(p),\n@@ -237,20 +239,31 @@ pub fn stat<P: ToCStr>(path: &P) -> Option<FileStat> {\n                 None\n             }\n         }\n-    }\n+    }.unwrap_or_else(|| {\n+        FileStat {\n+            path: Path::new(path.to_c_str()),\n+            is_file: false,\n+            is_dir: false,\n+            device: 0,\n+            mode: 0,\n+            inode: 0,\n+            size: 0,\n+            created: 0,\n+            modified: 0,\n+            accessed: 0,\n+        }\n+    })\n }\n \n /// Retrieve a vector containing all entries within a provided directory\n ///\n /// # Example\n ///\n-///     use std;\n-///     use std::path::Path;\n-///     use std::rt::io::file::readdir;\n+///     use std::rt::io::file;\n ///\n ///     fn visit_dirs(dir: &Path, cb: &fn(&Path)) {\n ///         if dir.is_dir() {\n-///             let contents = dir.readdir();\n+///             let contents = file::readdir(dir).unwrap();\n ///             for entry in contents.iter() {\n ///                 if entry.is_dir() { visit_dirs(entry, cb); }\n ///                 else { cb(entry); }\n@@ -261,10 +274,10 @@ pub fn stat<P: ToCStr>(path: &P) -> Option<FileStat> {\n ///\n /// # Errors\n ///\n-/// Will raise an `io_error` condition if the provided `path` doesn't exist,\n+/// Will raise an `io_error` condition if the provided `from` doesn't exist,\n /// the process lacks permissions to view the contents or if the `path` points\n /// at a non-directory file\n-pub fn readdir<P: ToCStr>(path: &P) -> Option<~[Path]> {\n+pub fn readdir(path: &Path) -> ~[Path] {\n     do with_local_io |io| {\n         match io.fs_readdir(&path.to_c_str(), 0) {\n             Ok(p) => Some(p),\n@@ -273,66 +286,169 @@ pub fn readdir<P: ToCStr>(path: &P) -> Option<~[Path]> {\n                 None\n             }\n         }\n-    }\n+    }.unwrap_or_else(|| ~[])\n }\n \n-/// Constrained version of `FileStream` that only exposes read-specific operations.\n+/// Rename a file or directory to a new name.\n ///\n-/// Can be retreived via `FileInfo.open_reader()`.\n-pub struct FileReader { priv stream: FileStream }\n+/// # Example\n+///\n+///     use std::rt::io::file;\n+///\n+///     file::rename(Path::new(\"foo\"), Path::new(\"bar\"));\n+///     // Oh boy, nothing was raised!\n+///\n+/// # Errors\n+///\n+/// Will raise an `io_error` condition if the provided `path` doesn't exist,\n+/// the process lacks permissions to view the contents, or if some other\n+/// intermittent I/O error occurs.\n+pub fn rename(from: &Path, to: &Path) {\n+    do with_local_io |io| {\n+        match io.fs_rename(&from.to_c_str(), &to.to_c_str()) {\n+            Ok(()) => Some(()),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n+        }\n+    };\n+}\n \n-/// a `std::rt::io::Reader` trait impl for file I/O.\n-impl Reader for FileReader {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        self.stream.read(buf)\n+/// Copies the contents of one file to another.\n+///\n+/// # Example\n+///\n+///     use std::rt::io::file;\n+///\n+///     file::copy(Path::new(\"foo.txt\"), Path::new(\"bar.txt\"));\n+///     // Oh boy, nothing was raised!\n+///\n+/// # Errors\n+///\n+/// Will raise an `io_error` condition if the provided `from` doesn't exist,\n+/// the process lacks permissions to view the contents, or if some other\n+/// intermittent I/O error occurs (such as `to` couldn't be created).\n+pub fn copy(from: &Path, to: &Path) {\n+    let mut reader = match open(from) { Some(f) => f, None => return };\n+    let mut writer = match create(to) { Some(f) => f, None => return };\n+    let mut buf = [0, ..io::DEFAULT_BUF_SIZE];\n+\n+    loop {\n+        match reader.read(buf) {\n+            Some(amt) => writer.write(buf.slice_to(amt)),\n+            None => break\n+        }\n     }\n \n-    fn eof(&mut self) -> bool {\n-        self.stream.eof()\n-    }\n+    // FIXME(#10131) this is an awful way to pull out the permission bits.\n+    //               If this comment is removed, then there should be a test\n+    //               asserting that permission bits are maintained using the\n+    //               permission interface created.\n+    chmod(to, (from.stat().mode & 0xfff) as u32);\n }\n \n-/// a `std::rt::io::Seek` trait impl for file I/O.\n-impl Seek for FileReader {\n-    fn tell(&self) -> u64 {\n-        self.stream.tell()\n-    }\n+// This function is not public because it's got a terrible interface for `mode`\n+// FIXME(#10131)\n+fn chmod(path: &Path, mode: u32) {\n+    do with_local_io |io| {\n+        match io.fs_chmod(&path.to_c_str(), mode) {\n+            Ok(()) => Some(()),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n+        }\n+    };\n+}\n \n-    fn seek(&mut self, pos: i64, style: SeekStyle) {\n-        self.stream.seek(pos, style);\n+/// Recursively walk a directory structure. This function will call the\n+/// provided closure on all directories and files found inside the path\n+/// pointed to by `self`. If the closure returns `false`, then the iteration\n+/// will be short-circuited.\n+pub fn walk_dir(path: &Path, f: &fn(&Path) -> bool) -> bool {\n+    let files = readdir(path);\n+    files.iter().advance(|q| {\n+        f(q) && (!q.is_dir() || walk_dir(q, |p| f(p)))\n+    })\n+}\n+\n+/// Recursively create a directory and all of its parent components if they\n+/// are missing.\n+///\n+/// # Failure\n+///\n+/// This function will raise on the `io_error` condition if an error\n+/// happens, see `file::mkdir` for more information about error conditions\n+/// and performance.\n+pub fn mkdir_recursive(path: &Path, mode: FilePermission) {\n+    // tjc: if directory exists but with different permissions,\n+    // should we return false?\n+    if path.is_dir() {\n+        return\n+    }\n+    if path.filename().is_some() {\n+        mkdir_recursive(&path.dir_path(), mode);\n     }\n+    mkdir(path, mode)\n }\n \n-/// Constrained version of `FileStream` that only exposes write-specific operations.\n+/// Removes a directory at this path, after removing all its contents. Use\n+/// carefully!\n ///\n-/// Can be retreived via `FileInfo.open_writer()`.\n+/// # Failure\n+///\n+/// This function will raise on the `io_error` condition if an error\n+/// happens. See `file::unlink` and `file::readdir` for possible error\n+/// conditions.\n+pub fn rmdir_recursive(path: &Path) {\n+    do walk_dir(path) |inner| {\n+        if inner.is_dir() {\n+            rmdir_recursive(inner);\n+        } else {\n+            unlink(inner);\n+        }\n+        true\n+    };\n+    // Directory should now be empty\n+    rmdir(path);\n+}\n+\n+/// Constrained version of `FileStream` that only exposes read-specific\n+/// operations.\n+///\n+/// Can be retreived via `Path.open()` or `file::open`.\n+pub struct FileReader { priv stream: FileStream }\n+\n+impl Reader for FileReader {\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.stream.read(buf) }\n+    fn eof(&mut self) -> bool { self.stream.eof() }\n+}\n+\n+impl Seek for FileReader {\n+    fn tell(&self) -> u64 { self.stream.tell() }\n+    fn seek(&mut self, p: i64, s: SeekStyle) { self.stream.seek(p, s) }\n+}\n+\n+/// Constrained version of `FileStream` that only exposes write-specific\n+/// operations.\n+///\n+/// Can be retreived via `Path.create()` or `file::create`.\n pub struct FileWriter { priv stream: FileStream }\n \n-/// a `std::rt::io::Writer` trait impl for file I/O.\n impl Writer for FileWriter {\n-    fn write(&mut self, buf: &[u8]) {\n-        self.stream.write(buf);\n-    }\n-\n-    fn flush(&mut self) {\n-        self.stream.flush();\n-    }\n+    fn write(&mut self, buf: &[u8]) { self.stream.write(buf); }\n+    fn flush(&mut self) { self.stream.flush(); }\n }\n \n-/// a `std::rt::io::Seek` trait impl for file I/O.\n impl Seek for FileWriter {\n-    fn tell(&self) -> u64 {\n-        self.stream.tell()\n-    }\n-\n-    fn seek(&mut self, pos: i64, style: SeekStyle) {\n-        self.stream.seek(pos, style);\n-    }\n+    fn tell(&self) -> u64 { self.stream.tell() }\n+    fn seek(&mut self, p: i64, s: SeekStyle) { self.stream.seek(p, s); }\n }\n \n /// Unconstrained file access type that exposes read and write operations\n ///\n-/// Can be retreived via `file::open()` and `FileInfo.open_stream()`.\n+/// Can be retreived via `file::open()` and `Path.open_stream()`.\n ///\n /// # Errors\n ///\n@@ -341,13 +457,12 @@ impl Seek for FileWriter {\n /// time, via the `FileAccess` parameter to `file::open()`.\n ///\n /// For this reason, it is best to use the access-constrained wrappers that are\n-/// exposed via `FileInfo.open_reader()` and `FileInfo.open_writer()`.\n+/// exposed via `Path.open()` and `Path.create()`.\n pub struct FileStream {\n     priv fd: ~RtioFileStream,\n     priv last_nread: int,\n }\n \n-/// a `std::rt::io::Reader` trait impl for file I/O.\n impl Reader for FileStream {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n         match self.fd.read(buf) {\n@@ -360,20 +475,17 @@ impl Reader for FileStream {\n             },\n             Err(ioerr) => {\n                 // EOF is indicated by returning None\n-                if ioerr.kind != EndOfFile {\n+                if ioerr.kind != io::EndOfFile {\n                     io_error::cond.raise(ioerr);\n                 }\n                 return None;\n             }\n         }\n     }\n \n-    fn eof(&mut self) -> bool {\n-        self.last_nread == 0\n-    }\n+    fn eof(&mut self) -> bool { self.last_nread == 0 }\n }\n \n-/// a `std::rt::io::Writer` trait impl for file I/O.\n impl Writer for FileStream {\n     fn write(&mut self, buf: &[u8]) {\n         match self.fd.write(buf) {\n@@ -385,7 +497,6 @@ impl Writer for FileStream {\n     }\n }\n \n-/// a `std::rt::io:Seek` trait impl for file I/O.\n impl Seek for FileStream {\n     fn tell(&self) -> u64 {\n         let res = self.fd.tell();\n@@ -412,166 +523,40 @@ impl Seek for FileStream {\n     }\n }\n \n-/// Shared functionality between `FileInfo` and `DirectoryInfo`\n-pub trait FileSystemInfo {\n-    /// Get the filesystem path that this instance points at,\n-    /// whether it is valid or not. In this way, it can be used to\n-    /// to specify a path of a non-existent file which it\n-    /// later creates\n-    fn get_path<'a>(&'a self) -> &'a Path;\n-\n-    /// Get information on the file, directory, etc at the provided path\n+impl path::Path {\n+    /// Get information on the file, directory, etc at this path.\n     ///\n     /// Consult the `file::stat` documentation for more info.\n     ///\n-    /// This call preserves identical runtime/error semantics with `file::stat`\n-    fn stat(&self) -> Option<FileStat> {\n-        stat(self.get_path())\n-    }\n+    /// This call preserves identical runtime/error semantics with `file::stat`.\n+    pub fn stat(&self) -> FileStat { stat(self) }\n \n-    /// Boolean value indicator whether the underlying file exists on the filesystem\n+    /// Boolean value indicator whether the underlying file exists on the local\n+    /// filesystem. This will return true if the path points to either a\n+    /// directory or a file.\n     ///\n     /// # Errors\n     ///\n     /// Will not raise a condition\n-    fn exists(&self) -> bool {\n-        match ignore_io_error(|| self.stat()) {\n-            Some(_) => true,\n-            None => false\n-        }\n+    pub fn exists(&self) -> bool {\n+        io::result(|| self.stat()).is_ok()\n     }\n \n-}\n-\n-/// Represents a file, whose underlying path may or may not be valid\n-///\n-/// # Example\n-///\n-/// * Check if a file exists, reading from it if so\n-///\n-/// ```rust\n-/// use std;\n-/// use std::path::Path;\n-/// use std::rt::io::file::{FileInfo, FileReader};\n-///\n-/// let f = &Path(\"/some/file/path.txt\");\n-/// if f.exists() {\n-///     let reader = f.open_reader(Open);\n-///     let mut mem = [0u8, 8*64000];\n-///     reader.read(mem);\n-///     // ...\n-/// }\n-/// ```\n-///\n-/// * Is the given path a file?\n-///\n-/// ```rust\n-/// let f = get_file_path_from_wherever();\n-/// match f.is_file() {\n-///    true => doing_something_with_a_file(f),\n-///    _ => {}\n-/// }\n-/// ```\n-pub trait FileInfo : FileSystemInfo {\n-    /// Whether the underlying implemention (be it a file path,\n-    /// or something else) points at a \"regular file\" on the FS. Will return\n-    /// false for paths to non-existent locations or directories or\n-    /// other non-regular files (named pipes, etc).\n+    /// Whether the underlying implemention (be it a file path, or something\n+    /// else) points at a \"regular file\" on the FS. Will return false for paths\n+    /// to non-existent locations or directories or other non-regular files\n+    /// (named pipes, etc).\n     ///\n     /// # Errors\n     ///\n     /// Will not raise a condition\n-    fn is_file(&self) -> bool {\n-        match ignore_io_error(|| self.stat()) {\n-            Some(s) => s.is_file,\n-            None => false\n-        }\n-    }\n-\n-    /// Attempts to open a regular file for reading/writing based\n-    /// on provided inputs\n-    ///\n-    /// See `file::open` for more information on runtime semantics and error conditions\n-    fn open_stream(&self, mode: FileMode, access: FileAccess) -> Option<FileStream> {\n-        match ignore_io_error(|| self.stat()) {\n-            Some(s) => match s.is_file {\n-                true => open(self.get_path(), mode, access),\n-                false => None\n-            },\n-            None => open(self.get_path(), mode, access)\n+    pub fn is_file(&self) -> bool {\n+        match io::result(|| self.stat()) {\n+            Ok(s) => s.is_file,\n+            Err(*) => false\n         }\n     }\n \n-    /// Attempts to open a regular file in read-only mode, based\n-    /// on provided inputs\n-    ///\n-    /// See `file::open` for more information on runtime semantics and error conditions\n-    fn open_reader(&self, mode: FileMode) -> Option<FileReader> {\n-        match self.open_stream(mode, Read) {\n-            Some(s) => Some(FileReader { stream: s}),\n-            None => None\n-        }\n-    }\n-\n-    /// Attempts to open a regular file in write-only mode, based\n-    /// on provided inputs\n-    ///\n-    /// See `file::open` for more information on runtime semantics and error conditions\n-    fn open_writer(&self, mode: FileMode) -> Option<FileWriter> {\n-        match self.open_stream(mode, Write) {\n-            Some(s) => Some(FileWriter { stream: s}),\n-            None => None\n-        }\n-    }\n-\n-    /// Attempt to remove a file from the filesystem\n-    ///\n-    /// See `file::unlink` for more information on runtime semantics and error conditions\n-    fn unlink(&self) {\n-        unlink(self.get_path());\n-    }\n-}\n-\n-/// `FileSystemInfo` implementation for `Path`s\n-impl FileSystemInfo for Path {\n-    fn get_path<'a>(&'a self) -> &'a Path { self }\n-}\n-\n-/// `FileInfo` implementation for `Path`s\n-impl FileInfo for Path { }\n-\n-/// Represents a directory, whose underlying path may or may not be valid\n-///\n-/// # Example\n-///\n-/// * Check if a directory exists, `mkdir`'ing it if not\n-///\n-/// ```rust\n-/// use std;\n-/// use std::path::Path;\n-/// use std::rt::io::file::{DirectoryInfo};\n-///\n-/// let dir = &Path(\"/some/dir\");\n-/// if !dir.exists() {\n-///     dir.mkdir();\n-/// }\n-/// ```\n-///\n-/// * Is the given path a directory? If so, iterate on its contents\n-///\n-/// ```rust\n-/// fn visit_dirs(dir: &Path, cb: &fn(&Path)) {\n-///     if dir.is_dir() {\n-///         let contents = dir.readdir();\n-///         for entry in contents.iter() {\n-///             if entry.is_dir() { visit_dirs(entry, cb); }\n-///             else { cb(entry); }\n-///         }\n-///     }\n-///     else { fail!(\"nope\"); }\n-/// }\n-/// ```\n-pub trait DirectoryInfo : FileSystemInfo {\n     /// Whether the underlying implemention (be it a file path,\n     /// or something else) is pointing at a directory in the underlying FS.\n     /// Will return false for paths to non-existent locations or if the item is\n@@ -580,109 +565,50 @@ pub trait DirectoryInfo : FileSystemInfo {\n     /// # Errors\n     ///\n     /// Will not raise a condition\n-    fn is_dir(&self) -> bool {\n-        match ignore_io_error(|| self.stat()) {\n-            Some(s) => s.is_dir,\n-            None => false\n+    pub fn is_dir(&self) -> bool {\n+        match io::result(|| self.stat()) {\n+            Ok(s) => s.is_dir,\n+            Err(*) => false\n         }\n     }\n-\n-    /// Create a directory at the location pointed to by the\n-    /// type underlying the given `DirectoryInfo`.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This method will raise a `PathAlreadyExists` kind of `io_error` condition\n-    /// if the provided path exists\n-    ///\n-    /// See `file::mkdir` for more information on runtime semantics and error conditions\n-    fn mkdir(&self) {\n-        match ignore_io_error(|| self.stat()) {\n-            Some(_) => {\n-                let path = self.get_path();\n-                io_error::cond.raise(IoError {\n-                    kind: PathAlreadyExists,\n-                    desc: \"Path already exists\",\n-                    detail:\n-                        Some(format!(\"{} already exists; can't mkdir it\",\n-                                     path.display()))\n-                })\n-            },\n-            None => mkdir(self.get_path())\n-        }\n-    }\n-\n-    /// Remove a directory at the given location.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This method will raise a `PathDoesntExist` kind of `io_error` condition\n-    /// if the provided path exists. It will raise a `MismatchedFileTypeForOperation`\n-    /// kind of `io_error` condition if the provided path points at any\n-    /// non-directory file type\n-    ///\n-    /// See `file::rmdir` for more information on runtime semantics and error conditions\n-    fn rmdir(&self) {\n-        match ignore_io_error(|| self.stat()) {\n-            Some(s) => {\n-                match s.is_dir {\n-                    true => rmdir(self.get_path()),\n-                    false => {\n-                        let path = self.get_path();\n-                        let ioerr = IoError {\n-                            kind: MismatchedFileTypeForOperation,\n-                            desc: \"Cannot do rmdir() on a non-directory\",\n-                            detail: Some(format!(\n-                                \"{} is a non-directory; can't rmdir it\",\n-                                path.display()))\n-                        };\n-                        io_error::cond.raise(ioerr);\n-                    }\n-                }\n-            },\n-            None => {\n-                let path = self.get_path();\n-                io_error::cond.raise(IoError {\n-                    kind: PathDoesntExist,\n-                    desc: \"Path doesn't exist\",\n-                    detail: Some(format!(\"{} doesn't exist; can't rmdir it\",\n-                                         path.display()))\n-                })\n-            }\n-        }\n-    }\n-\n-    // Get a collection of all entries at the given\n-    // directory\n-    fn readdir(&self) -> Option<~[Path]> {\n-        readdir(self.get_path())\n-    }\n }\n \n-/// `DirectoryInfo` impl for `path::Path`\n-impl DirectoryInfo for Path { }\n-\n #[cfg(test)]\n mod test {\n-    use super::super::{SeekSet, SeekCur, SeekEnd,\n-                       io_error, Read, Create, Open, ReadWrite};\n-    use super::super::super::test::*;\n+    use path::{Path, GenericPath};\n+    use result::{Ok, Err};\n     use option::{Some, None};\n-    use path::Path;\n-    use super::*;\n     use iter::range;\n+    use rt::test::run_in_mt_newsched_task;\n+    use super::{open_stream, unlink, stat, copy, rmdir, mkdir, readdir,\n+                open, create, rmdir_recursive, mkdir_recursive};\n+\n+    use rt::io;\n+    use rt::io::Reader;\n+    use super::super::{SeekSet, SeekCur, SeekEnd,\n+                       io_error, Read, Create, Open, ReadWrite};\n+    use vec::Vector;\n+\n+    fn tmpdir() -> Path {\n+        use os;\n+        use rand;\n+        let ret = os::tmpdir().join(format!(\"rust-{}\", rand::random::<u32>()));\n+        mkdir(&ret, io::UserRWX);\n+        ret\n+    }\n+\n     #[test]\n     fn file_test_io_smoke_test() {\n         do run_in_mt_newsched_task {\n             let message = \"it's alright. have a good time\";\n             let filename = &Path::new(\"./tmp/file_rt_io_file_test.txt\");\n             {\n-                let mut write_stream = open(filename, Create, ReadWrite).unwrap();\n+                let mut write_stream = open_stream(filename, Create, ReadWrite);\n                 write_stream.write(message.as_bytes());\n             }\n             {\n                 use str;\n-                let mut read_stream = open(filename, Open, Read).unwrap();\n+                let mut read_stream = open_stream(filename, Open, Read);\n                 let mut read_buf = [0, .. 1028];\n                 let read_str = match read_stream.read(read_buf).unwrap() {\n                     -1|0 => fail!(\"shouldn't happen\"),\n@@ -702,7 +628,7 @@ mod test {\n             do io_error::cond.trap(|_| {\n                 called = true;\n             }).inside {\n-                let result = open(filename, Open, Read);\n+                let result = open_stream(filename, Open, Read);\n                 assert!(result.is_none());\n             }\n             assert!(called);\n@@ -731,11 +657,11 @@ mod test {\n             let mut read_mem = [0, .. 8];\n             let filename = &Path::new(\"./tmp/file_rt_io_file_test_positional.txt\");\n             {\n-                let mut rw_stream = open(filename, Create, ReadWrite).unwrap();\n+                let mut rw_stream = open_stream(filename, Create, ReadWrite);\n                 rw_stream.write(message.as_bytes());\n             }\n             {\n-                let mut read_stream = open(filename, Open, Read).unwrap();\n+                let mut read_stream = open_stream(filename, Open, Read);\n                 {\n                     let read_buf = read_mem.mut_slice(0, 4);\n                     read_stream.read(read_buf);\n@@ -762,11 +688,11 @@ mod test {\n             let mut tell_pos_post_read;\n             let filename = &Path::new(\"./tmp/file_rt_io_file_test_seeking.txt\");\n             {\n-                let mut rw_stream = open(filename, Create, ReadWrite).unwrap();\n+                let mut rw_stream = open_stream(filename, Create, ReadWrite);\n                 rw_stream.write(message.as_bytes());\n             }\n             {\n-                let mut read_stream = open(filename, Open, Read).unwrap();\n+                let mut read_stream = open_stream(filename, Open, Read);\n                 read_stream.seek(set_cursor as i64, SeekSet);\n                 tell_pos_pre_read = read_stream.tell();\n                 read_stream.read(read_mem);\n@@ -791,13 +717,13 @@ mod test {\n             let mut read_mem = [0, .. 13];\n             let filename = &Path::new(\"./tmp/file_rt_io_file_test_seek_and_write.txt\");\n             {\n-                let mut rw_stream = open(filename, Create, ReadWrite).unwrap();\n+                let mut rw_stream = open_stream(filename, Create, ReadWrite);\n                 rw_stream.write(initial_msg.as_bytes());\n                 rw_stream.seek(seek_idx as i64, SeekSet);\n                 rw_stream.write(overwrite_msg.as_bytes());\n             }\n             {\n-                let mut read_stream = open(filename, Open, Read).unwrap();\n+                let mut read_stream = open_stream(filename, Open, Read);\n                 read_stream.read(read_mem);\n             }\n             unlink(filename);\n@@ -817,11 +743,11 @@ mod test {\n             let mut read_mem = [0, .. 4];\n             let filename = &Path::new(\"./tmp/file_rt_io_file_test_seek_shakedown.txt\");\n             {\n-                let mut rw_stream = open(filename, Create, ReadWrite).unwrap();\n+                let mut rw_stream = open_stream(filename, Create, ReadWrite);\n                 rw_stream.write(initial_msg.as_bytes());\n             }\n             {\n-                let mut read_stream = open(filename, Open, Read).unwrap();\n+                let mut read_stream = open_stream(filename, Open, Read);\n \n                 read_stream.seek(-4, SeekEnd);\n                 read_stream.read(read_mem);\n@@ -847,14 +773,11 @@ mod test {\n         do run_in_mt_newsched_task {\n             let filename = &Path::new(\"./tmp/file_stat_correct_on_is_file.txt\");\n             {\n-                let mut fs = open(filename, Create, ReadWrite).unwrap();\n+                let mut fs = open_stream(filename, Create, ReadWrite);\n                 let msg = \"hw\";\n                 fs.write(msg.as_bytes());\n             }\n-            let stat_res = match stat(filename) {\n-                Some(s) => s,\n-                None => fail!(\"shouldn't happen\")\n-            };\n+            let stat_res = stat(filename);\n             assert!(stat_res.is_file);\n             unlink(filename);\n         }\n@@ -864,11 +787,8 @@ mod test {\n     fn file_test_stat_is_correct_on_is_dir() {\n         do run_in_mt_newsched_task {\n             let filename = &Path::new(\"./tmp/file_stat_correct_on_is_dir\");\n-            mkdir(filename);\n-            let stat_res = match stat(filename) {\n-                Some(s) => s,\n-                None => fail!(\"shouldn't happen\")\n-            };\n+            mkdir(filename, io::UserRWX);\n+            let stat_res = filename.stat();\n             assert!(stat_res.is_dir);\n             rmdir(filename);\n         }\n@@ -878,7 +798,7 @@ mod test {\n     fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n         do run_in_mt_newsched_task {\n             let dir = &Path::new(\"./tmp/fileinfo_false_on_dir\");\n-            mkdir(dir);\n+            mkdir(dir, io::UserRWX);\n             assert!(dir.is_file() == false);\n             rmdir(dir);\n         }\n@@ -888,13 +808,9 @@ mod test {\n     fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n         do run_in_mt_newsched_task {\n             let file = &Path::new(\"./tmp/fileinfo_check_exists_b_and_a.txt\");\n-            {\n-                let msg = \"foo\".as_bytes();\n-                let mut w = file.open_writer(Create);\n-                w.write(msg);\n-            }\n+            create(file).write(bytes!(\"foo\"));\n             assert!(file.exists());\n-            file.unlink();\n+            unlink(file);\n             assert!(!file.exists());\n         }\n     }\n@@ -904,10 +820,10 @@ mod test {\n         do run_in_mt_newsched_task {\n             let dir = &Path::new(\"./tmp/before_and_after_dir\");\n             assert!(!dir.exists());\n-            dir.mkdir();\n+            mkdir(dir, io::UserRWX);\n             assert!(dir.exists());\n             assert!(dir.is_dir());\n-            dir.rmdir();\n+            rmdir(dir);\n             assert!(!dir.exists());\n         }\n     }\n@@ -917,36 +833,99 @@ mod test {\n         use str;\n         do run_in_mt_newsched_task {\n             let dir = &Path::new(\"./tmp/di_readdir\");\n-            dir.mkdir();\n+            mkdir(dir, io::UserRWX);\n             let prefix = \"foo\";\n             for n in range(0,3) {\n                 let f = dir.join(format!(\"{}.txt\", n));\n-                let mut w = f.open_writer(Create);\n+                let mut w = create(&f);\n                 let msg_str = (prefix + n.to_str().to_owned()).to_owned();\n                 let msg = msg_str.as_bytes();\n                 w.write(msg);\n             }\n-            match dir.readdir() {\n-                Some(files) => {\n-                    let mut mem = [0u8, .. 4];\n-                    for f in files.iter() {\n-                        {\n-                            let n = f.filestem_str();\n-                            let mut r = f.open_reader(Open);\n-                            r.read(mem);\n-                            let read_str = str::from_utf8(mem);\n-                            let expected = match n {\n-                                None|Some(\"\") => fail!(\"really shouldn't happen..\"),\n-                                Some(n) => prefix+n\n-                            };\n-                            assert!(expected == read_str);\n-                        }\n-                        f.unlink();\n-                    }\n-                },\n-                None => fail!(\"shouldn't happen\")\n+            let files = readdir(dir);\n+            let mut mem = [0u8, .. 4];\n+            for f in files.iter() {\n+                {\n+                    let n = f.filestem_str();\n+                    open(f).read(mem);\n+                    let read_str = str::from_utf8(mem);\n+                    let expected = match n {\n+                        None|Some(\"\") => fail!(\"really shouldn't happen..\"),\n+                        Some(n) => prefix+n\n+                    };\n+                    assert!(expected == read_str);\n+                }\n+                unlink(f);\n             }\n-            dir.rmdir();\n+            rmdir(dir);\n         }\n     }\n+\n+    #[test]\n+    fn recursive_mkdir_slash() {\n+        mkdir_recursive(&Path::new(\"/\"), io::UserRWX);\n+    }\n+\n+    #[test]\n+    fn unicode_path_is_dir() {\n+        assert!(Path::new(\".\").is_dir());\n+        assert!(!Path::new(\"test/stdtest/fs.rs\").is_dir());\n+\n+        let tmpdir = tmpdir();\n+\n+        let mut dirpath = tmpdir.clone();\n+        dirpath.push(format!(\"test-\uac00\u4e00\u30fc\u4f60\u597d\"));\n+        mkdir(&dirpath, io::UserRWX);\n+        assert!(dirpath.is_dir());\n+\n+        let mut filepath = dirpath;\n+        filepath.push(\"unicode-file-\\uac00\\u4e00\\u30fc\\u4f60\\u597d.rs\");\n+        create(&filepath); // ignore return; touch only\n+        assert!(!filepath.is_dir());\n+        assert!(filepath.exists());\n+\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    fn unicode_path_exists() {\n+        assert!(Path::new(\".\").exists());\n+        assert!(!Path::new(\"test/nonexistent-bogus-path\").exists());\n+\n+        let tmpdir = tmpdir();\n+        let unicode = tmpdir.clone();\n+        let unicode = unicode.join(format!(\"test-\uac01\u4e01\u30fc\u518d\u89c1\"));\n+        mkdir(&unicode, io::UserRWX);\n+        assert!(unicode.exists());\n+        assert!(!Path::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    fn copy_file_does_not_exist() {\n+        let from = Path::new(\"test/nonexistent-bogus-path\");\n+        let to = Path::new(\"test/other-bogus-path\");\n+        match io::result(|| copy(&from, &to)) {\n+            Ok(*) => fail!(),\n+            Err(*) => {\n+                assert!(!from.exists());\n+                assert!(!to.exists());\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn copy_file_ok() {\n+        let tmpdir = tmpdir();\n+        let input = tmpdir.join(\"in.txt\");\n+        let out = tmpdir.join(\"out.txt\");\n+\n+        create(&input).write(bytes!(\"hello\"));\n+        copy(&input, &out);\n+        let contents = open(&out).read_to_end();\n+        assert_eq!(contents.as_slice(), bytes!(\"hello\"));\n+\n+        assert_eq!(input.stat().mode, out.stat().mode);\n+        rmdir_recursive(&tmpdir);\n+    }\n }"}, {"sha": "51204ca73b94bbe45225d52f00e5f3666ac28af7", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -244,9 +244,12 @@ Out of scope\n \n use cast;\n use int;\n+use libc;\n use path::Path;\n-use prelude::*;\n use str::{StrSlice, OwnedStr};\n+use option::{Option, Some, None};\n+use result::{Ok, Err, Result};\n+use iter::Iterator;\n use to_str::ToStr;\n use uint;\n use unstable::finally::Finally;\n@@ -418,6 +421,18 @@ pub fn ignore_io_error<T>(cb: &fn() -> T) -> T {\n     }\n }\n \n+/// Helper for catching an I/O error and wrapping it in a Result object. The\n+/// return result will be the last I/O error that happened or the result of the\n+/// closure if no error occurred.\n+pub fn result<T>(cb: &fn() -> T) -> Result<T, IoError> {\n+    let mut err = None;\n+    let ret = io_error::cond.trap(|e| err = Some(e)).inside(cb);\n+    match err {\n+        Some(e) => Err(e),\n+        None => Ok(ret),\n+    }\n+}\n+\n pub trait Reader {\n \n     // Only two methods which need to get implemented for this trait\n@@ -1137,3 +1152,7 @@ pub struct FileStat {\n     /// platform-dependent msecs\n     accessed: u64,\n }\n+\n+// FIXME(#10131): this needs to get designed for real\n+pub type FilePermission = u32;\n+pub static UserRWX: FilePermission = libc::S_IRWXU as FilePermission;"}, {"sha": "e26cc166c8da4c6a070a5558b7ac7a6fec9f27ca", "filename": "src/libstd/rt/io/native/file.rs", "status": "modified", "additions": 483, "deletions": 0, "changes": 483, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -297,3 +297,486 @@ mod tests {\n         }\n     }\n }\n+\n+// n.b. these functions were all part of the old `std::os` module. There's lots\n+//      of fun little nuances that were taken care of by these functions, but\n+//      they are all thread-blocking versions that are no longer desired (we now\n+//      use a non-blocking event loop implementation backed by libuv).\n+//\n+//      In theory we will have a thread-blocking version of the event loop (if\n+//      desired), so these functions may just need to get adapted to work in\n+//      those situtations. For now, I'm leaving the code around so it doesn't\n+//      get bitrotted instantaneously.\n+mod old_os {\n+    use prelude::*;\n+    use c_str::CString;\n+    use libc::fclose;\n+    use libc::{size_t, c_void, c_int};\n+    use libc;\n+    use vec;\n+\n+    #[cfg(test)] use os;\n+    #[cfg(test)] use rand;\n+\n+    // On Windows, wide character version of function must be used to support\n+    // unicode, so functions should be split into at least two versions,\n+    // which are for Windows and for non-Windows, if necessary.\n+    // See https://github.com/mozilla/rust/issues/9822 for more information.\n+\n+    mod rustrt {\n+        use libc::{c_char, c_int};\n+        use libc;\n+\n+        extern {\n+            pub fn rust_path_is_dir(path: *libc::c_char) -> c_int;\n+            pub fn rust_path_exists(path: *libc::c_char) -> c_int;\n+        }\n+\n+        // Uses _wstat instead of stat.\n+        #[cfg(windows)]\n+        extern {\n+            pub fn rust_path_is_dir_u16(path: *u16) -> c_int;\n+            pub fn rust_path_exists_u16(path: *u16) -> c_int;\n+        }\n+    }\n+\n+    /// Recursively walk a directory structure\n+    pub fn walk_dir(p: &Path, f: &fn(&Path) -> bool) -> bool {\n+        let r = list_dir(p);\n+        r.iter().advance(|q| {\n+            let path = &p.join(q);\n+            f(path) && (!path_is_dir(path) || walk_dir(path, |p| f(p)))\n+        })\n+    }\n+\n+    #[cfg(unix)]\n+    /// Indicates whether a path represents a directory\n+    pub fn path_is_dir(p: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n+        unsafe {\n+            do p.with_c_str |buf| {\n+                rustrt::rust_path_is_dir(buf) != 0 as c_int\n+            }\n+        }\n+    }\n+\n+\n+    #[cfg(windows)]\n+    pub fn path_is_dir(p: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n+        unsafe {\n+            do os::win32::as_utf16_p(p.as_str().unwrap()) |buf| {\n+                rustrt::rust_path_is_dir_u16(buf) != 0 as c_int\n+            }\n+        }\n+    }\n+\n+    #[cfg(unix)]\n+    /// Indicates whether a path exists\n+    pub fn path_exists(p: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n+        unsafe {\n+            do p.with_c_str |buf| {\n+                rustrt::rust_path_exists(buf) != 0 as c_int\n+            }\n+        }\n+    }\n+\n+    #[cfg(windows)]\n+    pub fn path_exists(p: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n+        unsafe {\n+            do os::win32::as_utf16_p(p.as_str().unwrap()) |buf| {\n+                rustrt::rust_path_exists_u16(buf) != 0 as c_int\n+            }\n+        }\n+    }\n+\n+    /// Creates a directory at the specified path\n+    pub fn make_dir(p: &Path, mode: c_int) -> bool {\n+        return mkdir(p, mode);\n+\n+        #[cfg(windows)]\n+        fn mkdir(p: &Path, _mode: c_int) -> bool {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            unsafe {\n+                use os::win32::as_utf16_p;\n+                // FIXME: turn mode into something useful? #2623\n+                do as_utf16_p(p.as_str().unwrap()) |buf| {\n+                    libc::CreateDirectoryW(buf, ptr::mut_null())\n+                        != (0 as libc::BOOL)\n+                }\n+            }\n+        }\n+\n+        #[cfg(unix)]\n+        fn mkdir(p: &Path, mode: c_int) -> bool {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            do p.with_c_str |buf| {\n+                unsafe {\n+                    libc::mkdir(buf, mode as libc::mode_t) == (0 as c_int)\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Creates a directory with a given mode.\n+    /// Returns true iff creation\n+    /// succeeded. Also creates all intermediate subdirectories\n+    /// if they don't already exist, giving all of them the same mode.\n+\n+    // tjc: if directory exists but with different permissions,\n+    // should we return false?\n+    pub fn mkdir_recursive(p: &Path, mode: c_int) -> bool {\n+        if path_is_dir(p) {\n+            return true;\n+        }\n+        if p.filename().is_some() {\n+            let mut p_ = p.clone();\n+            p_.pop();\n+            if !mkdir_recursive(&p_, mode) {\n+                return false;\n+            }\n+        }\n+        return make_dir(p, mode);\n+    }\n+\n+    /// Lists the contents of a directory\n+    ///\n+    /// Each resulting Path is a relative path with no directory component.\n+    pub fn list_dir(p: &Path) -> ~[Path] {\n+        unsafe {\n+            #[cfg(target_os = \"linux\")]\n+            #[cfg(target_os = \"android\")]\n+            #[cfg(target_os = \"freebsd\")]\n+            #[cfg(target_os = \"macos\")]\n+            unsafe fn get_list(p: &Path) -> ~[Path] {\n+                #[fixed_stack_segment]; #[inline(never)];\n+                use libc::{dirent_t};\n+                use libc::{opendir, readdir, closedir};\n+                extern {\n+                    fn rust_list_dir_val(ptr: *dirent_t) -> *libc::c_char;\n+                }\n+                let mut paths = ~[];\n+                debug!(\"os::list_dir -- BEFORE OPENDIR\");\n+\n+                let dir_ptr = do p.with_c_str |buf| {\n+                    opendir(buf)\n+                };\n+\n+                if (dir_ptr as uint != 0) {\n+                    debug!(\"os::list_dir -- opendir() SUCCESS\");\n+                    let mut entry_ptr = readdir(dir_ptr);\n+                    while (entry_ptr as uint != 0) {\n+                        let cstr = CString::new(rust_list_dir_val(entry_ptr), false);\n+                        paths.push(Path::new(cstr));\n+                        entry_ptr = readdir(dir_ptr);\n+                    }\n+                    closedir(dir_ptr);\n+                }\n+                else {\n+                    debug!(\"os::list_dir -- opendir() FAILURE\");\n+                }\n+                debug!(\"os::list_dir -- AFTER -- \\\\#: {}\", paths.len());\n+                paths\n+            }\n+            #[cfg(windows)]\n+            unsafe fn get_list(p: &Path) -> ~[Path] {\n+                #[fixed_stack_segment]; #[inline(never)];\n+                use libc::consts::os::extra::INVALID_HANDLE_VALUE;\n+                use libc::{wcslen, free};\n+                use libc::funcs::extra::kernel32::{\n+                    FindFirstFileW,\n+                    FindNextFileW,\n+                    FindClose,\n+                };\n+                use libc::types::os::arch::extra::HANDLE;\n+                use os::win32::{\n+                    as_utf16_p\n+                };\n+                use rt::global_heap::malloc_raw;\n+\n+                #[nolink]\n+                extern {\n+                    fn rust_list_dir_wfd_size() -> libc::size_t;\n+                    fn rust_list_dir_wfd_fp_buf(wfd: *libc::c_void) -> *u16;\n+                }\n+                let star = p.join(\"*\");\n+                do as_utf16_p(star.as_str().unwrap()) |path_ptr| {\n+                    let mut paths = ~[];\n+                    let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint);\n+                    let find_handle = FindFirstFileW(path_ptr, wfd_ptr as HANDLE);\n+                    if find_handle as libc::c_int != INVALID_HANDLE_VALUE {\n+                        let mut more_files = 1 as libc::c_int;\n+                        while more_files != 0 {\n+                            let fp_buf = rust_list_dir_wfd_fp_buf(wfd_ptr);\n+                            if fp_buf as uint == 0 {\n+                                fail!(\"os::list_dir() failure: got null ptr from wfd\");\n+                            }\n+                            else {\n+                                let fp_vec = vec::from_buf(\n+                                    fp_buf, wcslen(fp_buf) as uint);\n+                                let fp_str = str::from_utf16(fp_vec);\n+                                paths.push(Path::new(fp_str));\n+                            }\n+                            more_files = FindNextFileW(find_handle, wfd_ptr as HANDLE);\n+                        }\n+                        FindClose(find_handle);\n+                        free(wfd_ptr)\n+                    }\n+                    paths\n+                }\n+            }\n+            do get_list(p).move_iter().filter |path| {\n+                path.as_vec() != bytes!(\".\") && path.as_vec() != bytes!(\"..\")\n+            }.collect()\n+        }\n+    }\n+\n+    /// Removes a directory at the specified path, after removing\n+    /// all its contents. Use carefully!\n+    pub fn remove_dir_recursive(p: &Path) -> bool {\n+        let mut error_happened = false;\n+        do walk_dir(p) |inner| {\n+            if !error_happened {\n+                if path_is_dir(inner) {\n+                    if !remove_dir_recursive(inner) {\n+                        error_happened = true;\n+                    }\n+                }\n+                else {\n+                    if !remove_file(inner) {\n+                        error_happened = true;\n+                    }\n+                }\n+            }\n+            true\n+        };\n+        // Directory should now be empty\n+        !error_happened && remove_dir(p)\n+    }\n+\n+    /// Removes a directory at the specified path\n+    pub fn remove_dir(p: &Path) -> bool {\n+       return rmdir(p);\n+\n+        #[cfg(windows)]\n+        fn rmdir(p: &Path) -> bool {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            unsafe {\n+                use os::win32::as_utf16_p;\n+                return do as_utf16_p(p.as_str().unwrap()) |buf| {\n+                    libc::RemoveDirectoryW(buf) != (0 as libc::BOOL)\n+                };\n+            }\n+        }\n+\n+        #[cfg(unix)]\n+        fn rmdir(p: &Path) -> bool {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            do p.with_c_str |buf| {\n+                unsafe {\n+                    libc::rmdir(buf) == (0 as c_int)\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Deletes an existing file\n+    pub fn remove_file(p: &Path) -> bool {\n+        return unlink(p);\n+\n+        #[cfg(windows)]\n+        fn unlink(p: &Path) -> bool {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            unsafe {\n+                use os::win32::as_utf16_p;\n+                return do as_utf16_p(p.as_str().unwrap()) |buf| {\n+                    libc::DeleteFileW(buf) != (0 as libc::BOOL)\n+                };\n+            }\n+        }\n+\n+        #[cfg(unix)]\n+        fn unlink(p: &Path) -> bool {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            unsafe {\n+                do p.with_c_str |buf| {\n+                    libc::unlink(buf) == (0 as c_int)\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Renames an existing file or directory\n+    pub fn rename_file(old: &Path, new: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n+        unsafe {\n+           do old.with_c_str |old_buf| {\n+                do new.with_c_str |new_buf| {\n+                    libc::rename(old_buf, new_buf) == (0 as c_int)\n+                }\n+           }\n+        }\n+    }\n+\n+    /// Copies a file from one location to another\n+    pub fn copy_file(from: &Path, to: &Path) -> bool {\n+        return do_copy_file(from, to);\n+\n+        #[cfg(windows)]\n+        fn do_copy_file(from: &Path, to: &Path) -> bool {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            unsafe {\n+                use os::win32::as_utf16_p;\n+                return do as_utf16_p(from.as_str().unwrap()) |fromp| {\n+                    do as_utf16_p(to.as_str().unwrap()) |top| {\n+                        libc::CopyFileW(fromp, top, (0 as libc::BOOL)) !=\n+                            (0 as libc::BOOL)\n+                    }\n+                }\n+            }\n+        }\n+\n+        #[cfg(unix)]\n+        fn do_copy_file(from: &Path, to: &Path) -> bool {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            unsafe {\n+                let istream = do from.with_c_str |fromp| {\n+                    do \"rb\".with_c_str |modebuf| {\n+                        libc::fopen(fromp, modebuf)\n+                    }\n+                };\n+                if istream as uint == 0u {\n+                    return false;\n+                }\n+                // Preserve permissions\n+                let from_mode = from.stat().mode;\n+\n+                let ostream = do to.with_c_str |top| {\n+                    do \"w+b\".with_c_str |modebuf| {\n+                        libc::fopen(top, modebuf)\n+                    }\n+                };\n+                if ostream as uint == 0u {\n+                    fclose(istream);\n+                    return false;\n+                }\n+                let bufsize = 8192u;\n+                let mut buf = vec::with_capacity::<u8>(bufsize);\n+                let mut done = false;\n+                let mut ok = true;\n+                while !done {\n+                    do buf.as_mut_buf |b, _sz| {\n+                      let nread = libc::fread(b as *mut c_void, 1u as size_t,\n+                                              bufsize as size_t,\n+                                              istream);\n+                      if nread > 0 as size_t {\n+                          if libc::fwrite(b as *c_void, 1u as size_t, nread,\n+                                          ostream) != nread {\n+                              ok = false;\n+                              done = true;\n+                          }\n+                      } else {\n+                          done = true;\n+                      }\n+                  }\n+                }\n+                fclose(istream);\n+                fclose(ostream);\n+\n+                // Give the new file the old file's permissions\n+                if do to.with_c_str |to_buf| {\n+                    libc::chmod(to_buf, from_mode as libc::mode_t)\n+                } != 0 {\n+                    return false; // should be a condition...\n+                }\n+                return ok;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn tmpdir() {\n+        let p = os::tmpdir();\n+        let s = p.as_str();\n+        assert!(s.is_some() && s.unwrap() != \".\");\n+    }\n+\n+    // Issue #712\n+    #[test]\n+    fn test_list_dir_no_invalid_memory_access() {\n+        list_dir(&Path::new(\".\"));\n+    }\n+\n+    #[test]\n+    fn test_list_dir() {\n+        let dirs = list_dir(&Path::new(\".\"));\n+        // Just assuming that we've got some contents in the current directory\n+        assert!(dirs.len() > 0u);\n+\n+        for dir in dirs.iter() {\n+            debug!(\"{:?}\", (*dir).clone());\n+        }\n+    }\n+\n+    #[test]\n+    #[cfg(not(windows))]\n+    fn test_list_dir_root() {\n+        let dirs = list_dir(&Path::new(\"/\"));\n+        assert!(dirs.len() > 1);\n+    }\n+    #[test]\n+    #[cfg(windows)]\n+    fn test_list_dir_root() {\n+        let dirs = list_dir(&Path::new(\"C:\\\\\"));\n+        assert!(dirs.len() > 1);\n+    }\n+\n+    #[test]\n+    fn test_path_is_dir() {\n+        use rt::io::file::{open_stream, mkdir_recursive};\n+        use rt::io::{OpenOrCreate, Read, UserRWX};\n+\n+        assert!((path_is_dir(&Path::new(\".\"))));\n+        assert!((!path_is_dir(&Path::new(\"test/stdtest/fs.rs\"))));\n+\n+        let mut dirpath = os::tmpdir();\n+        dirpath.push(format!(\"rust-test-{}/test-\\uac00\\u4e00\\u30fc\\u4f60\\u597d\",\n+            rand::random::<u32>())); // \uac00\u4e00\u30fc\u4f60\u597d\n+        debug!(\"path_is_dir dirpath: {}\", dirpath.display());\n+\n+        mkdir_recursive(&dirpath, UserRWX);\n+\n+        assert!((path_is_dir(&dirpath)));\n+\n+        let mut filepath = dirpath;\n+        filepath.push(\"unicode-file-\\uac00\\u4e00\\u30fc\\u4f60\\u597d.rs\");\n+        debug!(\"path_is_dir filepath: {}\", filepath.display());\n+\n+        open_stream(&filepath, OpenOrCreate, Read); // ignore return; touch only\n+        assert!((!path_is_dir(&filepath)));\n+\n+        assert!((!path_is_dir(&Path::new(\n+                     \"test/unicode-bogus-dir-\\uac00\\u4e00\\u30fc\\u4f60\\u597d\"))));\n+    }\n+\n+    #[test]\n+    fn test_path_exists() {\n+        use rt::io::file::mkdir_recursive;\n+        use rt::io::UserRWX;\n+\n+        assert!((path_exists(&Path::new(\".\"))));\n+        assert!((!path_exists(&Path::new(\n+                     \"test/nonexistent-bogus-path\"))));\n+\n+        let mut dirpath = os::tmpdir();\n+        dirpath.push(format!(\"rust-test-{}/test-\\uac01\\u4e01\\u30fc\\u518d\\u89c1\",\n+            rand::random::<u32>())); // \uac01\u4e01\u30fc\u518d\u89c1\n+\n+        mkdir_recursive(&dirpath, UserRWX);\n+        assert!((path_exists(&dirpath)));\n+        assert!((!path_exists(&Path::new(\n+                     \"test/unicode-bogus-path-\\uac01\\u4e01\\u30fc\\u518d\\u89c1\"))));\n+    }\n+}"}, {"sha": "dd8a999c6de07570a70e6b730bd450bc88d44abc", "filename": "src/libstd/rt/io/net/unix.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -156,7 +156,6 @@ mod tests {\n     use rt::test::*;\n     use rt::io::*;\n     use rt::comm::oneshot;\n-    use os;\n \n     fn smalltest(server: ~fn(UnixStream), client: ~fn(UnixStream)) {\n         let server = Cell::new(server);\n@@ -290,7 +289,7 @@ mod tests {\n         do run_in_mt_newsched_task {\n             let path = next_test_unix();\n             let _acceptor = UnixListener::bind(&path).listen();\n-            assert!(os::path_exists(&path));\n+            assert!(path.exists());\n         }\n     }\n }"}, {"sha": "1b856ab07550cbde9aa11426031496e3aa0a5149", "filename": "src/libstd/rt/io/signal.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibstd%2Frt%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibstd%2Frt%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fsignal.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -19,6 +19,7 @@ definitions for a number of signals.\n \n */\n \n+use container::{Map, MutableMap};\n use comm::{Port, SharedChan, stream};\n use hashmap;\n use option::{Some, None};\n@@ -146,10 +147,10 @@ impl Listener {\n \n #[cfg(test)]\n mod test {\n-    use super::*;\n-\n     use libc;\n     use rt::io::timer;\n+    use super::{Listener, Interrupt};\n+    use comm::{GenericPort, Peekable};\n \n     // kill is only available on Unixes\n     #[cfg(unix)]\n@@ -207,7 +208,7 @@ mod test {\n     #[cfg(windows)]\n     #[test]\n     fn test_io_signal_invalid_signum() {\n-        use rt::io;\n+        use super::User1;\n         let mut s = Listener::new();\n         let mut called = false;\n         do io::io_error::cond.trap(|_| {"}, {"sha": "36092dfbe34e666a7675412fe7b0b9e70b543e14", "filename": "src/libstd/rt/io/timer.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ftimer.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -108,6 +108,7 @@ impl Timer {\n \n #[cfg(test)]\n mod test {\n+    use prelude::*;\n     use super::*;\n     use rt::test::*;\n     use cell::Cell;"}, {"sha": "a0db1f1df000ca6c16605c1cd3b4ee2ec27a8f1c", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -22,7 +22,7 @@ use super::io::process::ProcessConfig;\n use super::io::net::ip::{IpAddr, SocketAddr};\n use path::Path;\n use super::io::{SeekStyle};\n-use super::io::{FileMode, FileAccess, FileStat};\n+use super::io::{FileMode, FileAccess, FileStat, FilePermission};\n \n pub trait EventLoop {\n     fn run(&mut self);\n@@ -102,7 +102,10 @@ pub trait IoFactory {\n         -> Result<~RtioFileStream, IoError>;\n     fn fs_unlink(&mut self, path: &CString) -> Result<(), IoError>;\n     fn fs_stat(&mut self, path: &CString) -> Result<FileStat, IoError>;\n-    fn fs_mkdir(&mut self, path: &CString, mode: int) -> Result<(), IoError>;\n+    fn fs_mkdir(&mut self, path: &CString,\n+                mode: FilePermission) -> Result<(), IoError>;\n+    fn fs_chmod(&mut self, path: &CString,\n+                mode: FilePermission) -> Result<(), IoError>;\n     fn fs_rmdir(&mut self, path: &CString) -> Result<(), IoError>;\n     fn fs_rename(&mut self, path: &CString, to: &CString) -> Result<(), IoError>;\n     fn fs_readdir(&mut self, path: &CString, flags: c_int) ->"}, {"sha": "89784acec8ebb275b787f7bb45ebc57568290ca8", "filename": "src/libstd/run.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -604,8 +604,8 @@ mod tests {\n         let parent_dir = os::getcwd();\n         let child_dir = Path::new(output.trim());\n \n-        let parent_stat = parent_dir.stat().unwrap();\n-        let child_stat = child_dir.stat().unwrap();\n+        let parent_stat = parent_dir.stat();\n+        let child_stat = child_dir.stat();\n \n         assert_eq!(parent_stat.device, child_stat.device);\n         assert_eq!(parent_stat.inode, child_stat.inode);\n@@ -621,8 +621,8 @@ mod tests {\n         let output = str::from_utf8(prog.finish_with_output().output);\n         let child_dir = Path::new(output.trim());\n \n-        let parent_stat = parent_dir.stat().unwrap();\n-        let child_stat = child_dir.stat().unwrap();\n+        let parent_stat = parent_dir.stat();\n+        let child_stat = child_dir.stat();\n \n         assert_eq!(parent_stat.device, child_stat.device);\n         assert_eq!(parent_stat.inode, child_stat.inode);"}, {"sha": "876adf401862f7b27433b72c8393c4ea56ccd8fd", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -21,7 +21,7 @@ use print::pprust;\n \n use std::rt::io;\n use std::rt::io::Reader;\n-use std::rt::io::file::FileInfo;\n+use std::rt::io::file;\n use std::str;\n \n // These macros all relate to the file system; they either return\n@@ -92,17 +92,13 @@ pub fn expand_include_str(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_str!\");\n     let file = res_rel_file(cx, sp, &Path::new(file));\n-    let mut error = None;\n-    let bytes = do io::io_error::cond.trap(|e| error = Some(e)).inside {\n-        file.open_reader(io::Open).read_to_end()\n-    };\n-    match error {\n-        Some(e) => {\n+    let bytes = match io::result(|| file::open(&file).read_to_end()) {\n+        Err(e) => {\n             cx.span_fatal(sp, format!(\"couldn't read {}: {}\",\n                                       file.display(), e.desc));\n         }\n-        None => {}\n-    }\n+        Ok(bytes) => bytes,\n+    };\n     match str::from_utf8_owned_opt(bytes) {\n         Some(s) => base::MRExpr(cx.expr_str(sp, s.to_managed())),\n         None => {\n@@ -118,17 +114,12 @@ pub fn expand_include_bin(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n \n     let file = get_single_str_from_tts(cx, sp, tts, \"include_bin!\");\n     let file = res_rel_file(cx, sp, &Path::new(file));\n-\n-    let mut error = None;\n-    let bytes = do io::io_error::cond.trap(|e| error = Some(e)).inside {\n-        file.open_reader(io::Open).read_to_end()\n-    };\n-    match error {\n-        Some(e) => {\n+    match io::result(|| file::open(&file).read_to_end()) {\n+        Err(e) => {\n             cx.span_fatal(sp, format!(\"couldn't read {}: {}\",\n                                       file.display(), e.desc));\n         }\n-        None => {\n+        Ok(bytes) => {\n             let bytes = at_vec::to_managed_move(bytes);\n             base::MRExpr(cx.expr_lit(sp, ast::lit_binary(bytes)))\n         }"}, {"sha": "cd1be9a3c1615ff695fbbb8049020dfb05ab4066", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -21,8 +21,7 @@ use parse::parser::Parser;\n \n use std::path::Path;\n use std::rt::io;\n-use std::rt::io::Reader;\n-use std::rt::io::file::FileInfo;\n+use std::rt::io::file;\n use std::str;\n \n pub mod lexer;\n@@ -269,16 +268,13 @@ pub fn file_to_filemap(sess: @mut ParseSess, path: &Path, spanopt: Option<Span>)\n             None => sess.span_diagnostic.handler().fatal(msg),\n         }\n     };\n-    let mut error = None;\n-    let bytes = do io::io_error::cond.trap(|e| error = Some(e)).inside {\n-        path.open_reader(io::Open).read_to_end()\n-    };\n-    match error {\n-        Some(e) => {\n+    let bytes = match io::result(|| file::open(path).read_to_end()) {\n+        Ok(bytes) => bytes,\n+        Err(e) => {\n             err(format!(\"couldn't read {}: {}\", path.display(), e.desc));\n+            unreachable!()\n         }\n-        None => {}\n-    }\n+    };\n     match str::from_utf8_owned_opt(bytes) {\n         Some(s) => {\n             return string_to_filemap(sess, s.to_managed(),"}, {"sha": "2b63325f931e7949eedfa944d2cf2ac6fcebd69f", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -597,6 +597,10 @@ rust_uv_fs_rename(uv_loop_t *loop, uv_fs_t* req, const char *path,\n                   const char *to, uv_fs_cb cb) {\n     return uv_fs_rename(loop, req, path, to, cb);\n }\n+extern \"C\" int\n+rust_uv_fs_chmod(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode, uv_fs_cb cb) {\n+  return uv_fs_chmod(loop, req, path, mode, cb);\n+}\n \n extern \"C\" int\n rust_uv_spawn(uv_loop_t *loop, uv_process_t *p, uv_process_options_t options) {"}, {"sha": "531f01c199562ce6c1cdd32e17bb25136ae9c484", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -21,6 +21,7 @@ use std::rand;\n use std::str;\n use std::util;\n use std::vec;\n+use std::rt::io::file;\n \n macro_rules! bench (\n     ($argv:expr, $id:ident) => (maybe_run_test($argv, stringify!($id).to_owned(), $id))\n@@ -69,15 +70,13 @@ fn shift_push() {\n }\n \n fn read_line() {\n-    use std::rt::io::{Reader, Open};\n-    use std::rt::io::file::FileInfo;\n     use std::rt::io::buffered::BufferedReader;\n \n     let mut path = Path::new(env!(\"CFG_SRC_DIR\"));\n     path.push(\"src/test/bench/shootout-k-nucleotide.data\");\n \n     for _ in range(0, 3) {\n-        let mut reader = BufferedReader::new(path.open_reader(Open).unwrap());\n+        let mut reader = BufferedReader::new(file::open(&path).unwrap());\n         while !reader.eof() {\n             reader.read_line();\n         }"}, {"sha": "7d3fa6104e5c38e650cd79b9afb85281af89887b", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -19,6 +19,7 @@ extern mod extra;\n \n use std::int;\n use std::rt::io;\n+use std::rt::io::file;\n use std::os;\n use std::rand::Rng;\n use std::rand;\n@@ -111,7 +112,6 @@ fn acid(ch: char, prob: u32) -> AminoAcids {\n }\n \n fn main() {\n-    use std::rt::io::file::FileInfo;\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n         // alioth tests k-nucleotide with this data at 25,000,000\n@@ -123,7 +123,7 @@ fn main() {\n     };\n \n     let writer = if os::getenv(\"RUST_BENCH\").is_some() {\n-        let file = Path::new(\"./shootout-fasta.data\").open_writer(io::CreateOrTruncate);\n+        let file = file::create(&Path::new(\"./shootout-fasta.data\"));\n         @mut file as @mut io::Writer\n     } else {\n         @mut io::stdout() as @mut io::Writer"}, {"sha": "c7c8e3a19a6cd0734100691fb4a26ea2dda7c675", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // xfail-pretty\n+// xfail-test\n \n extern mod extra;\n extern mod syntax;"}, {"sha": "2e426c0413e7418d50ee6dc824b24470ee7e05d1", "filename": "src/test/run-pass-fulldeps/quote-tokens.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -8,6 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-test\n+\n+#[feature(managed_boxes)];\n+\n extern mod syntax;\n \n use syntax::ext::base::ExtCtxt;\n@@ -16,11 +20,11 @@ fn syntax_extension(cx: @ExtCtxt) {\n     let e_toks : ~[syntax::ast::token_tree] = quote_tokens!(cx, 1 + 2);\n     let p_toks : ~[syntax::ast::token_tree] = quote_tokens!(cx, (x, 1 .. 4, *));\n \n-    let a: @syntax::ast::expr = quote_expr!(cx, 1 + 2);\n+    let a: @syntax::ast::Expr = quote_expr!(cx, 1 + 2);\n     let _b: Option<@syntax::ast::item> = quote_item!(cx, static foo : int = $e_toks; );\n-    let _c: @syntax::ast::pat = quote_pat!(cx, (x, 1 .. 4, *) );\n-    let _d: @syntax::ast::stmt = quote_stmt!(cx, let x = $a; );\n-    let _e: @syntax::ast::expr = quote_expr!(cx, match foo { $p_toks => 10 } );\n+    let _c: @syntax::ast::Pat = quote_pat!(cx, (x, 1 .. 4, *) );\n+    let _d: @syntax::ast::Stmt = quote_stmt!(cx, let x = $a; );\n+    let _e: @syntax::ast::Expr = quote_expr!(cx, match foo { $p_toks => 10 } );\n }\n \n fn main() {"}, {"sha": "56bcd24f1cb4e9c0505a8336a15398d2d5d063ad", "filename": "src/test/run-pass/glob-std.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Ftest%2Frun-pass%2Fglob-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Ftest%2Frun-pass%2Fglob-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fglob-std.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -17,14 +17,13 @@ use extra::tempfile::TempDir;\n use std::unstable::finally::Finally;\n use std::{os, unstable};\n use std::rt::io;\n-use std::rt::io::file::FileInfo;\n \n pub fn main() {\n     fn mk_file(path: &str, directory: bool) {\n         if directory {\n-            os::make_dir(&Path::new(path), 0xFFFF);\n+            io::file::mkdir(&Path::new(path), io::UserRWX);\n         } else {\n-            Path::new(path).open_writer(io::Create);\n+            io::file::create(&Path::new(path));\n         }\n     }\n "}, {"sha": "2f6de7e4472bdaf93ddd6cb566f6e5e6bc8d5245", "filename": "src/test/run-pass/rename-directory.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Ftest%2Frun-pass%2Frename-directory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Ftest%2Frun-pass%2Frename-directory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frename-directory.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -17,6 +17,8 @@ extern mod extra;\n use extra::tempfile::TempDir;\n use std::os;\n use std::libc;\n+use std::rt::io;\n+use std::rt::io::file;\n \n fn rename_directory() {\n     #[fixed_stack_segment];\n@@ -26,7 +28,7 @@ fn rename_directory() {\n         let tmpdir = TempDir::new(\"rename_directory\").expect(\"rename_directory failed\");\n         let tmpdir = tmpdir.path();\n         let old_path = tmpdir.join_many([\"foo\", \"bar\", \"baz\"]);\n-        assert!(os::mkdir_recursive(&old_path, U_RWX));\n+        file::mkdir_recursive(&old_path, io::UserRWX);\n         let test_file = &old_path.join(\"temp.txt\");\n \n         /* Write the temp input file */\n@@ -47,10 +49,10 @@ fn rename_directory() {\n         assert_eq!(libc::fclose(ostream), (0u as libc::c_int));\n \n         let new_path = tmpdir.join_many([\"quux\", \"blat\"]);\n-        assert!(os::mkdir_recursive(&new_path, U_RWX));\n-        assert!(os::rename_file(&old_path, &new_path.join(\"newdir\")));\n-        assert!(os::path_is_dir(&new_path.join(\"newdir\")));\n-        assert!(os::path_exists(&new_path.join_many([\"newdir\", \"temp.txt\"])));\n+        file::mkdir_recursive(&new_path, io::UserRWX);\n+        file::rename(&old_path, &new_path.join(\"newdir\"));\n+        assert!(new_path.join(\"newdir\").is_dir());\n+        assert!(new_path.join_many([\"newdir\", \"temp.txt\"]).exists());\n     }\n }\n "}, {"sha": "d46c8a64f5a4e3cf595423ea0d1871448aea29f7", "filename": "src/test/run-pass/stat.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Ftest%2Frun-pass%2Fstat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Ftest%2Frun-pass%2Fstat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstat.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -13,17 +13,14 @@\n extern mod extra;\n \n use extra::tempfile;\n-use std::rt::io;\n-use std::rt::io::Writer;\n-use std::rt::io::file::FileInfo;\n-use std::os;\n+use std::rt::io::file;\n \n pub fn main() {\n     let dir = tempfile::TempDir::new_in(&Path::new(\".\"), \"\").unwrap();\n     let path = dir.path().join(\"file\");\n \n     {\n-        match path.open_writer(io::CreateOrTruncate) {\n+        match file::create(&path) {\n             None => unreachable!(),\n             Some(f) => {\n                 let mut f = f;\n@@ -35,5 +32,5 @@ pub fn main() {\n     }\n \n     assert!(path.exists());\n-    assert_eq!(path.get_size(), Some(1000));\n+    assert_eq!(path.stat().size, 1000);\n }"}, {"sha": "9ac144f5fb5e5972948f3fc4cf8bf378efff5a3c", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1851019f1ef9511fa8731b8f1acb0796d1e97f/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "patch": "@@ -22,9 +22,10 @@ extern mod extra;\n \n use extra::tempfile::TempDir;\n use std::os;\n-use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n use std::task;\n use std::cell::Cell;\n+use std::rt::io;\n+use std::rt::io::file;\n \n fn test_tempdir() {\n     let path = {\n@@ -33,7 +34,7 @@ fn test_tempdir() {\n         assert!(p.as_vec().ends_with(bytes!(\"foobar\")));\n         p.clone()\n     };\n-    assert!(!os::path_exists(&path));\n+    assert!(!path.exists());\n }\n \n fn test_rm_tempdir() {\n@@ -45,7 +46,7 @@ fn test_rm_tempdir() {\n     };\n     task::try(f);\n     let path = rd.recv();\n-    assert!(!os::path_exists(&path));\n+    assert!(!path.exists());\n \n     let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n     let path = tmp.path().clone();\n@@ -55,7 +56,7 @@ fn test_rm_tempdir() {\n         fail!(\"fail to unwind past `tmp`\");\n     };\n     task::try(f);\n-    assert!(!os::path_exists(&path));\n+    assert!(!path.exists());\n \n     let path;\n     {\n@@ -64,18 +65,18 @@ fn test_rm_tempdir() {\n         };\n         let tmp = task::try(f).expect(\"test_rm_tmdir\");\n         path = tmp.path().clone();\n-        assert!(os::path_exists(&path));\n+        assert!(path.exists());\n     }\n-    assert!(!os::path_exists(&path));\n+    assert!(!path.exists());\n \n     let path;\n     {\n         let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n         path = tmp.unwrap();\n     }\n-    assert!(os::path_exists(&path));\n-    os::remove_dir_recursive(&path);\n-    assert!(!os::path_exists(&path));\n+    assert!(path.exists());\n+    file::rmdir_recursive(&path);\n+    assert!(!path.exists());\n }\n \n // Ideally these would be in std::os but then core would need\n@@ -84,54 +85,54 @@ fn recursive_mkdir_rel() {\n     let path = Path::new(\"frob\");\n     let cwd = os::getcwd();\n     debug!(\"recursive_mkdir_rel: Making: {} in cwd {} [{:?}]\", path.display(),\n-           cwd.display(), os::path_exists(&path));\n-    assert!(os::mkdir_recursive(&path,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-    assert!(os::path_is_dir(&path));\n-    assert!(os::mkdir_recursive(&path,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-    assert!(os::path_is_dir(&path));\n+           cwd.display(), path.exists());\n+    file::mkdir_recursive(&path, io::UserRWX);\n+    assert!(path.is_dir());\n+    file::mkdir_recursive(&path, io::UserRWX);\n+    assert!(path.is_dir());\n }\n \n fn recursive_mkdir_dot() {\n     let dot = Path::new(\".\");\n-    assert!(os::mkdir_recursive(&dot,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n+    file::mkdir_recursive(&dot, io::UserRWX);\n     let dotdot = Path::new(\"..\");\n-    assert!(os::mkdir_recursive(&dotdot,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n+    file::mkdir_recursive(&dotdot, io::UserRWX);\n }\n \n fn recursive_mkdir_rel_2() {\n     let path = Path::new(\"./frob/baz\");\n     let cwd = os::getcwd();\n     debug!(\"recursive_mkdir_rel_2: Making: {} in cwd {} [{:?}]\", path.display(),\n-           cwd.display(), os::path_exists(&path));\n-    assert!(os::mkdir_recursive(&path, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-        assert!(os::path_is_dir(&path));\n-    assert!(os::path_is_dir(&path.dir_path()));\n+           cwd.display(), path.exists());\n+    file::mkdir_recursive(&path, io::UserRWX);\n+    assert!(path.is_dir());\n+    assert!(path.dir_path().is_dir());\n     let path2 = Path::new(\"quux/blat\");\n     debug!(\"recursive_mkdir_rel_2: Making: {} in cwd {}\", path2.display(),\n            cwd.display());\n-    assert!(os::mkdir_recursive(&path2, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-        assert!(os::path_is_dir(&path2));\n-    assert!(os::path_is_dir(&path2.dir_path()));\n+    file::mkdir_recursive(&path2, io::UserRWX);\n+    assert!(path2.is_dir());\n+    assert!(path2.dir_path().is_dir());\n }\n \n // Ideally this would be in core, but needs TempFile\n pub fn test_rmdir_recursive_ok() {\n-    let rwx = (S_IRUSR | S_IWUSR | S_IXUSR) as i32;\n+    let rwx = io::UserRWX;\n \n     let tmpdir = TempDir::new(\"test\").expect(\"test_rmdir_recursive_ok: \\\n                                               couldn't create temp dir\");\n     let tmpdir = tmpdir.path();\n     let root = tmpdir.join(\"foo\");\n \n     debug!(\"making {}\", root.display());\n-    assert!(os::make_dir(&root, rwx));\n-    assert!(os::make_dir(&root.join(\"foo\"), rwx));\n-    assert!(os::make_dir(&root.join(\"foo\").join(\"bar\"), rwx));\n-    assert!(os::make_dir(&root.join(\"foo\").join(\"bar\").join(\"blat\"), rwx));\n-    assert!(os::remove_dir_recursive(&root));\n-    assert!(!os::path_exists(&root));\n-    assert!(!os::path_exists(&root.join(\"bar\")));\n-    assert!(!os::path_exists(&root.join(\"bar\").join(\"blat\")));\n+    file::mkdir(&root, rwx);\n+    file::mkdir(&root.join(\"foo\"), rwx);\n+    file::mkdir(&root.join(\"foo\").join(\"bar\"), rwx);\n+    file::mkdir(&root.join(\"foo\").join(\"bar\").join(\"blat\"), rwx);\n+    file::rmdir_recursive(&root);\n+    assert!(!root.exists());\n+    assert!(!root.join(\"bar\").exists());\n+    assert!(!root.join(\"bar\").join(\"blat\").exists());\n }\n \n fn in_tmpdir(f: &fn()) {"}]}