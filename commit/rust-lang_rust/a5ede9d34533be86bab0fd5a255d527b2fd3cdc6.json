{"sha": "a5ede9d34533be86bab0fd5a255d527b2fd3cdc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ZWRlOWQzNDUzM2JlODZiYWIwZmQ1YTI1NWQ1MjdiMmZkM2NkYzY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-17T22:15:09Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-18T00:00:39Z"}, "message": "rustdoc: Resolve imports and reexports", "tree": {"sha": "a3cd32118644e16698c988d4e093a673dd9eda93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3cd32118644e16698c988d4e093a673dd9eda93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5ede9d34533be86bab0fd5a255d527b2fd3cdc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5ede9d34533be86bab0fd5a255d527b2fd3cdc6", "html_url": "https://github.com/rust-lang/rust/commit/a5ede9d34533be86bab0fd5a255d527b2fd3cdc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5ede9d34533be86bab0fd5a255d527b2fd3cdc6/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7f73c79ec0cca88fc6e3657f955307049cb5801", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7f73c79ec0cca88fc6e3657f955307049cb5801", "html_url": "https://github.com/rust-lang/rust/commit/f7f73c79ec0cca88fc6e3657f955307049cb5801"}], "stats": {"total": 184, "additions": 148, "deletions": 36}, "files": [{"sha": "40cf4e5047267995f9d37e2665ad938c4ad12329", "filename": "src/comp/driver/driver.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a5ede9d34533be86bab0fd5a255d527b2fd3cdc6/src%2Fcomp%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ede9d34533be86bab0fd5a255d527b2fd3cdc6/src%2Fcomp%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fdriver.rs?ref=a5ede9d34533be86bab0fd5a255d527b2fd3cdc6", "patch": "@@ -440,17 +440,27 @@ fn build_session_options(match: getopts::match,\n \n fn build_session(sopts: @session::options, input: str,\n                  demitter: diagnostic::emitter) -> session {\n+    let codemap = codemap::new_codemap();\n+    let diagnostic_handler =\n+        diagnostic::mk_handler(some(demitter));\n+    let span_diagnostic_handler =\n+        diagnostic::mk_span_handler(diagnostic_handler, codemap);\n+    build_session_(sopts, input, codemap, demitter,\n+                   span_diagnostic_handler)\n+}\n+\n+fn build_session_(\n+    sopts: @session::options, input: str,\n+    codemap: codemap::codemap,\n+    demitter: diagnostic::emitter,\n+    span_diagnostic_handler: diagnostic::span_handler\n+) -> session {\n     let target_cfg = build_target_config(sopts, demitter);\n     let cstore = cstore::mk_cstore();\n     let filesearch = filesearch::mk_filesearch(\n         sopts.maybe_sysroot,\n         sopts.target_triple,\n         sopts.addl_lib_search_paths);\n-    let codemap = codemap::new_codemap();\n-    let diagnostic_handler =\n-        diagnostic::mk_handler(some(demitter));\n-    let span_diagnostic_handler =\n-        diagnostic::mk_span_handler(diagnostic_handler, codemap);\n     @{targ_cfg: target_cfg,\n       opts: sopts,\n       cstore: cstore,"}, {"sha": "c4e1923fc29443c1e2a728a7ba7d3da85f5cd689", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 32, "deletions": 19, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a5ede9d34533be86bab0fd5a255d527b2fd3cdc6/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ede9d34533be86bab0fd5a255d527b2fd3cdc6/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=a5ede9d34533be86bab0fd5a255d527b2fd3cdc6", "patch": "@@ -19,7 +19,7 @@ import std::list::{list, nil, cons};\n import option::{is_none, is_some};\n import syntax::print::pprust::*;\n \n-export resolve_crate;\n+export resolve_crate, resolve_crate_reexports;\n export def_map, ext_map, exp_map, impl_map;\n export _impl, iscopes, method_info;\n \n@@ -155,24 +155,7 @@ enum ns_value_type { ns_a_enum, ns_any_value, }\n \n fn resolve_crate(sess: session, amap: ast_map::map, crate: @ast::crate) ->\n    {def_map: def_map, exp_map: exp_map, impl_map: impl_map} {\n-    let e =\n-        @{cstore: sess.cstore,\n-          def_map: new_int_hash(),\n-          ast_map: amap,\n-          imports: new_int_hash(),\n-          exp_map: new_str_hash(),\n-          mod_map: new_int_hash(),\n-          block_map: new_int_hash(),\n-          ext_map: new_def_hash(),\n-          impl_map: new_int_hash(),\n-          impl_cache: new_def_hash(),\n-          ext_cache: new_ext_hash(),\n-          used_imports: {mutable track: false, mutable data:  []},\n-          mutable reported: [],\n-          mutable ignored_imports: [],\n-          mutable current_tp: none,\n-          mutable resolve_unexported: false,\n-          sess: sess};\n+    let e = create_env(sess, amap);\n     map_crate(e, crate);\n     resolve_imports(*e);\n     check_exports(e);\n@@ -187,6 +170,36 @@ fn resolve_crate(sess: session, amap: ast_map::map, crate: @ast::crate) ->\n     ret {def_map: e.def_map, exp_map: e.exp_map, impl_map: e.impl_map};\n }\n \n+// Used by rustdoc\n+fn resolve_crate_reexports(sess: session, amap: ast_map::map,\n+                           crate: @ast::crate) -> exp_map {\n+    let e = create_env(sess, amap);\n+    map_crate(e, crate);\n+    resolve_imports(*e);\n+    check_exports(e);\n+    ret e.exp_map;\n+}\n+\n+fn create_env(sess: session, amap: ast_map::map) -> @env {\n+    @{cstore: sess.cstore,\n+      def_map: new_int_hash(),\n+      ast_map: amap,\n+      imports: new_int_hash(),\n+      exp_map: new_str_hash(),\n+      mod_map: new_int_hash(),\n+      block_map: new_int_hash(),\n+      ext_map: new_def_hash(),\n+      impl_map: new_int_hash(),\n+      impl_cache: new_def_hash(),\n+      ext_cache: new_ext_hash(),\n+      used_imports: {mutable track: false, mutable data:  []},\n+      mutable reported: [],\n+      mutable ignored_imports: [],\n+      mutable current_tp: none,\n+      mutable resolve_unexported: false,\n+      sess: sess}\n+}\n+\n // Locate all modules and imports and index them, so that the next passes can\n // resolve through them.\n fn map_crate(e: @env, c: @ast::crate) {"}, {"sha": "3c6405d08c6d2e235a78861addff377c857fc5f7", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 101, "deletions": 12, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/a5ede9d34533be86bab0fd5a255d527b2fd3cdc6/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ede9d34533be86bab0fd5a255d527b2fd3cdc6/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=a5ede9d34533be86bab0fd5a255d527b2fd3cdc6", "patch": "@@ -10,11 +10,14 @@\n import rustc::driver::session;\n import rustc::driver::driver;\n import rustc::driver::diagnostic;\n+import rustc::driver::diagnostic::handler;\n import rustc::syntax::ast;\n+import rustc::syntax::codemap;\n import rustc::middle::ast_map;\n import rustc::back::link;\n import rustc::util::filesearch;\n import rustc::front;\n+import rustc::middle::resolve;\n \n export ctxt;\n export ctxt_handler;\n@@ -25,7 +28,8 @@ export exec;\n \n type ctxt = {\n     ast: @ast::crate,\n-    ast_map: ast_map::map\n+    ast_map: ast_map::map,\n+    exp_map: resolve::exp_map\n };\n \n type ctxt_handler<T> = fn~(ctxt: ctxt) -> T;\n@@ -35,36 +39,43 @@ type srv = {\n };\n \n fn mk_srv_from_str(source: str) -> srv {\n-    let sess = build_session();\n+    let (sess, ignore_errors) = build_session();\n     {\n-        ctxt: build_ctxt(sess, parse::from_str_sess(sess, source))\n+        ctxt: build_ctxt(sess, parse::from_str_sess(sess, source),\n+                         ignore_errors)\n     }\n }\n \n fn mk_srv_from_file(file: str) -> srv {\n-    let sess = build_session();\n+    let (sess, ignore_errors) = build_session();\n     {\n-        ctxt: build_ctxt(sess, parse::from_file_sess(sess, file))\n+        ctxt: build_ctxt(sess, parse::from_file_sess(sess, file),\n+                         ignore_errors)\n     }\n }\n \n-fn build_ctxt(sess: session::session, ast: @ast::crate) -> ctxt {\n+fn build_ctxt(sess: session::session, ast: @ast::crate,\n+              ignore_errors: @mutable bool) -> ctxt {\n \n     import rustc::front::config;\n \n     let ast = config::strip_unconfigured_items(ast);\n     let ast = front::test::modify_for_testing(sess, ast);\n     let ast_map = ast_map::map_crate(*ast);\n+    *ignore_errors = true;\n+    let exp_map = resolve::resolve_crate_reexports(sess, ast_map, ast);\n+    *ignore_errors = false;\n \n     {\n         ast: ast,\n         ast_map: ast_map,\n+        exp_map: exp_map\n     }\n }\n \n // FIXME: this whole structure should not be duplicated here. makes it\n // painful to add or remove options.\n-fn build_session() -> session::session {\n+fn build_session() -> (session::session, @mutable bool) {\n     let sopts: @session::options = @{\n         crate_type: session::lib_crate,\n         static: false,\n@@ -89,7 +100,73 @@ fn build_session() -> session::session {\n         monomorphize: false,\n         warn_unused_imports: false\n     };\n-    driver::build_session(sopts, \".\", diagnostic::emit)\n+\n+    let codemap = codemap::new_codemap();\n+    let error_handlers = build_error_handlers(codemap);\n+    let {emitter, span_handler, ignore_errors} = error_handlers;\n+\n+    let session = driver::build_session_(sopts, \".\", codemap, emitter,\n+                                         span_handler);\n+    (session, ignore_errors)\n+}\n+\n+type error_handlers = {\n+    emitter: diagnostic::emitter,\n+    span_handler: diagnostic::span_handler,\n+    ignore_errors: @mutable bool\n+};\n+\n+// Build a custom error handler that will allow us to ignore non-fatal\n+// errors\n+fn build_error_handlers(\n+    codemap: codemap::codemap\n+) -> error_handlers {\n+\n+    type diagnostic_handler = {\n+        inner: diagnostic::handler,\n+        ignore_errors: @mutable bool\n+    };\n+\n+    impl of diagnostic::handler for diagnostic_handler {\n+        fn fatal(msg: str) -> ! { self.inner.fatal(msg) }\n+        fn err(msg: str) { self.inner.err(msg) }\n+        fn bump_err_count() {\n+            if !(*self.ignore_errors) {\n+                self.inner.bump_err_count();\n+            }\n+        }\n+        fn has_errors() -> bool { self.inner.has_errors() }\n+        fn abort_if_errors() { self.inner.abort_if_errors() }\n+        fn warn(msg: str) { self.inner.warn(msg) }\n+        fn note(msg: str) { self.inner.note(msg) }\n+        fn bug(msg: str) -> ! { self.inner.bug(msg) }\n+        fn unimpl(msg: str) -> ! { self.inner.unimpl(msg) }\n+        fn emit(cmsp: option<(codemap::codemap, codemap::span)>,\n+                msg: str, lvl: diagnostic::level) {\n+            self.inner.emit(cmsp, msg, lvl)\n+        }\n+    }\n+\n+    let ignore_errors = @mutable false;\n+    let emitter = fn@(cmsp: option<(codemap::codemap, codemap::span)>,\n+                       msg: str, lvl: diagnostic::level) {\n+        if !(*ignore_errors) {\n+            diagnostic::emit(cmsp, msg, lvl);\n+        }\n+    };\n+    let inner_handler = diagnostic::mk_handler(some(emitter));\n+    let handler = {\n+        inner: inner_handler,\n+        ignore_errors: ignore_errors\n+    };\n+    let span_handler = diagnostic::mk_span_handler(\n+        handler as diagnostic::handler, codemap);\n+\n+    {\n+        emitter: emitter,\n+        span_handler: span_handler,\n+        ignore_errors: ignore_errors\n+    }\n }\n \n #[test]\n@@ -111,14 +188,12 @@ fn srv_should_build_ast_map() {\n }\n \n #[test]\n-#[ignore]\n fn srv_should_build_reexport_map() {\n-    // FIXME\n-    /*let source = \"import a::b; export b; mod a { mod b { } }\";\n+    let source = \"import a::b; export b; mod a { mod b { } }\";\n     let srv = mk_srv_from_str(source);\n     exec(srv) {|ctxt|\n         assert ctxt.exp_map.size() != 0u\n-    };*/\n+    };\n }\n \n #[test]\n@@ -137,6 +212,20 @@ fn srv_should_resolve_core_crate() {\n     mk_srv_from_str(source);\n }\n \n+#[test]\n+fn srv_should_resolve_non_existant_imports() {\n+    // We want to ignore things we can't resolve. Shouldn't\n+    // need to be able to find external crates to create docs.\n+    let source = \"import wooboo; fn a() { }\";\n+    mk_srv_from_str(source);\n+}\n+\n+#[test]\n+fn srv_sholud_resolve_non_existant_uses() {\n+    let source = \"use forble; fn a() { }\";\n+    mk_srv_from_str(source);\n+}\n+\n fn exec<T>(\n     srv: srv,\n     f: fn~(ctxt: ctxt) -> T"}]}