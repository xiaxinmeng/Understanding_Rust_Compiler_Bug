{"sha": "f729f289255bcc8d1bfad614ac74bc51d411826a", "node_id": "C_kwDOAAsO6NoAKGY3MjlmMjg5MjU1YmNjOGQxYmZhZDYxNGFjNzRiYzUxZDQxMTgyNmE", "commit": {"author": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-05-07T16:34:18Z"}, "committer": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-06-06T18:15:23Z"}, "message": "Move cpp20_rwc_syncs into compile-fail", "tree": {"sha": "bae0071c913682f71840de6d93160c3cfa878850", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bae0071c913682f71840de6d93160c3cfa878850"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f729f289255bcc8d1bfad614ac74bc51d411826a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE7dcbcBMl24/h63ldGBtJ+fOPM3QFAmKeRDsACgkQGBtJ+fOP\nM3R2Wgv/Ym2Wn44nXsKRyRk7cuObyh4ZW7eEg5KBsJH+CxL2fX7ov1ZvnO5I/z/g\nsRRWVQbtEY1skFygIxsDpj2OySa8UrayLt8WPhO97bO1ocJbjaB5VdqIk5IZ+9Zf\n7wpi9Twn6MMQaR0KZHx1juOQwBiV/7gMywC8Dz3ZPm8BtKSLj4AcfOQsk8zCp58w\n/g7jxd0jDoAt7vERtEhVnz3JpRHVoiSnj5sqQP86zqXXUzd0r4BL4jYhihs38ZA6\n2r0gQvxlIkx45F2ryDCUyAEGnV+r/J2/Hv8Q5XETBtbKrnmK5Hx5+ggZ3xyQfjBV\nLDEIAvcTN5E5dTLMYIU0qrvXdH9KSC4KWYSV0QkiXBPt5HKLqDEpL2KYklL5/nCj\nznxI7QAmg3q8MSpuseIFQqN0jE5alXdWJPHhRxbsVs8F93x1VXacoZAFGNhrHFT2\nS7RPDt6gcBHBvZNT+CUxobvS9jL7fKYFVkppZONAZXdLgS1Nh+fKWYX+C37qufpb\nZnG8Kry5\n=EW+u\n-----END PGP SIGNATURE-----", "payload": "tree bae0071c913682f71840de6d93160c3cfa878850\nparent 32627d5abb8791d2de10199964128ea8238d5c2b\nauthor Andy Wang <cbeuw.andy@gmail.com> 1651941258 +0100\ncommitter Andy Wang <cbeuw.andy@gmail.com> 1654539323 +0100\n\nMove cpp20_rwc_syncs into compile-fail\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f729f289255bcc8d1bfad614ac74bc51d411826a", "html_url": "https://github.com/rust-lang/rust/commit/f729f289255bcc8d1bfad614ac74bc51d411826a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f729f289255bcc8d1bfad614ac74bc51d411826a/comments", "author": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32627d5abb8791d2de10199964128ea8238d5c2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/32627d5abb8791d2de10199964128ea8238d5c2b", "html_url": "https://github.com/rust-lang/rust/commit/32627d5abb8791d2de10199964128ea8238d5c2b"}], "stats": {"total": 143, "additions": 86, "deletions": 57}, "files": [{"sha": "b9e395fd7741f9f7321415cceeaf94a153747664", "filename": "tests/compile-fail/weak_memory/cpp20_rwc_syncs.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/f729f289255bcc8d1bfad614ac74bc51d411826a/tests%2Fcompile-fail%2Fweak_memory%2Fcpp20_rwc_syncs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f729f289255bcc8d1bfad614ac74bc51d411826a/tests%2Fcompile-fail%2Fweak_memory%2Fcpp20_rwc_syncs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fweak_memory%2Fcpp20_rwc_syncs.rs?ref=f729f289255bcc8d1bfad614ac74bc51d411826a", "patch": "@@ -0,0 +1,85 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-ignore-leaks\n+\n+// https://plv.mpi-sws.org/scfix/paper.pdf\n+// 2.2 Second Problem: SC Fences are Too Weak\n+// This test should pass under the C++20 model Rust is using.\n+// Unfortunately, Miri's weak memory emulation only follows C++11 model\n+// as we don't know how to correctly emulate C++20's revised SC semantics,\n+// so we have to stick to C++11 emulation from exiting research.\n+\n+use std::sync::atomic::Ordering::*;\n+use std::thread::{spawn, yield_now};\n+use std::sync::atomic::{fence, AtomicUsize};\n+\n+// Spins and yields until until it reads value\n+fn reads_value(loc: &AtomicUsize, val: usize) -> usize {\n+    while loc.load(Relaxed) != val {\n+        yield_now();\n+    }\n+    val\n+}\n+\n+// We can't create static items because we need to run each test\n+// multiple tests\n+fn static_atomic(val: usize) -> &'static AtomicUsize {\n+    let ret = Box::leak(Box::new(AtomicUsize::new(val)));\n+    // A workaround to put the initialisation value in the store buffer\n+    ret.store(val, Relaxed);\n+    ret\n+}\n+\n+fn test_cpp20_rwc_syncs() {\n+    /*\n+    int main() {\n+        atomic_int x = 0;\n+        atomic_int y = 0;\n+\n+        {{{ x.store(1,mo_relaxed);\n+        ||| { r1=x.load(mo_relaxed).readsvalue(1);\n+              fence(mo_seq_cst);\n+              r2=y.load(mo_relaxed); }\n+        ||| { y.store(1,mo_relaxed);\n+              fence(mo_seq_cst);\n+              r3=x.load(mo_relaxed); }\n+        }}}\n+        return 0;\n+    }\n+    */\n+    let x = static_atomic(0);\n+    let y = static_atomic(0);\n+\n+    let j1 = spawn(move || {\n+        x.store(1, Relaxed);\n+    });\n+\n+    let j2 = spawn(move || {\n+        reads_value(&x, 1);\n+        fence(SeqCst);\n+        y.load(Relaxed)\n+    });\n+\n+    let j3 = spawn(move || {\n+        y.store(1, Relaxed);\n+        fence(SeqCst);\n+        x.load(Relaxed)\n+    });\n+\n+    j1.join().unwrap();\n+    let b = j2.join().unwrap();\n+    let c = j3.join().unwrap();\n+\n+    if (b, c) == (0, 0) {\n+        // FIXME: the standalone compiletest-rs needs to support\n+        // failure-status header to allow us to write assert_ne!((b, c), (0, 0))\n+        // https://rustc-dev-guide.rust-lang.org/tests/headers.html#miscellaneous-headers\n+        // because panic exits with 101 but compile-rs expects 1\n+        let _ = unsafe { std::mem::MaybeUninit::<*const u32>::uninit().assume_init() }; //~ ERROR uninitialized\n+    }\n+}\n+\n+pub fn main() {\n+    for _ in 0..500 {\n+        test_cpp20_rwc_syncs();\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "e85c2d1960c4a62f4f4b5c582757d4f9531978f3", "filename": "tests/run-pass/concurrency/weak_memory.rs", "status": "modified", "additions": 1, "deletions": 57, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f729f289255bcc8d1bfad614ac74bc51d411826a/tests%2Frun-pass%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f729f289255bcc8d1bfad614ac74bc51d411826a/tests%2Frun-pass%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fweak_memory.rs?ref=f729f289255bcc8d1bfad614ac74bc51d411826a", "patch": "@@ -31,7 +31,7 @@\n #![feature(atomic_from_mut)]\n \n use std::sync::atomic::Ordering::*;\n-use std::sync::atomic::{fence, AtomicU16, AtomicU32, AtomicUsize};\n+use std::sync::atomic::{AtomicU16, AtomicU32, AtomicUsize};\n use std::thread::{spawn, yield_now};\n \n #[derive(Copy, Clone)]\n@@ -57,13 +57,6 @@ fn acquires_value(loc: &AtomicUsize, val: usize) -> usize {\n     val\n }\n \n-fn reads_value(loc: &AtomicUsize, val: usize) -> usize {\n-    while loc.load(Relaxed) != val {\n-        yield_now();\n-    }\n-    val\n-}\n-\n fn test_corr() {\n     let x = static_atomic(0);\n     let y = static_atomic(0);\n@@ -242,54 +235,6 @@ fn test_sc_store_buffering() {\n     assert_ne!((a, b), (0, 0));\n }\n \n-// 2.2 Second Problem: SC Fences are Too Weak\n-// This test should pass under the C++20 model Rust is using.\n-// Unfortunately, Miri's weak memory emulation only follows C++11 model\n-// as we don't know how to correctly emulate C++20's revised SC semantics\n-#[allow(dead_code)]\n-fn test_cpp20_rwc_syncs() {\n-    /*\n-    int main() {\n-        atomic_int x = 0;\n-        atomic_int y = 0;\n-\n-        {{{ x.store(1,mo_relaxed);\n-        ||| { r1=x.load(mo_relaxed).readsvalue(1);\n-              fence(mo_seq_cst);\n-              r2=y.load(mo_relaxed); }\n-        ||| { y.store(1,mo_relaxed);\n-              fence(mo_seq_cst);\n-              r3=x.load(mo_relaxed); }\n-        }}}\n-        return 0;\n-    }\n-    */\n-    let x = static_atomic(0);\n-    let y = static_atomic(0);\n-\n-    let j1 = spawn(move || {\n-        x.store(1, Relaxed);\n-    });\n-\n-    let j2 = spawn(move || {\n-        reads_value(&x, 1);\n-        fence(SeqCst);\n-        y.load(Relaxed)\n-    });\n-\n-    let j3 = spawn(move || {\n-        y.store(1, Relaxed);\n-        fence(SeqCst);\n-        x.load(Relaxed)\n-    });\n-\n-    j1.join().unwrap();\n-    let b = j2.join().unwrap();\n-    let c = j3.join().unwrap();\n-\n-    assert_ne!((b, c), (0, 0));\n-}\n-\n pub fn main() {\n     test_imperfectly_overlapping_access();\n     // TODO: does this make chances of spurious success\n@@ -303,6 +248,5 @@ pub fn main() {\n         test_wrc();\n         test_corr();\n         test_sc_store_buffering();\n-        // test_cpp20_rwc_syncs();\n     }\n }"}]}