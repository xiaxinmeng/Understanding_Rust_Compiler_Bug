{"sha": "1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhOWM4Y2MxMjgzNjc1ZGZjMWI4NWRiZjgwYTllYTA3YTJiOGIzMzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-27T21:16:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-27T21:16:45Z"}, "message": "auto merge of #11156 : luqmana/rust/trait-object-coercion, r=pcwalton\n\nThis ports over @pcwalton's old pull that bitrotted (#5597). Fixes #10039.\r\n\r\nr? @pcwalton / @nikomatsakis", "tree": {"sha": "24b4d7140a3f92fbdaf1c785f917d61246ce0061", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24b4d7140a3f92fbdaf1c785f917d61246ce0061"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "html_url": "https://github.com/rust-lang/rust/commit/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc1b93e4254b241aae337a02c4bdb2d8fa4c7777", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc1b93e4254b241aae337a02c4bdb2d8fa4c7777", "html_url": "https://github.com/rust-lang/rust/commit/cc1b93e4254b241aae337a02c4bdb2d8fa4c7777"}, {"sha": "981c6b12fad24ef28998668e515e62976f72b3bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/981c6b12fad24ef28998668e515e62976f72b3bf", "html_url": "https://github.com/rust-lang/rust/commit/981c6b12fad24ef28998668e515e62976f72b3bf"}], "stats": {"total": 748, "additions": 604, "deletions": 144}, "files": [{"sha": "6fd42f74a767ff7bf22414e22f6d86025cdc6c17", "filename": "src/libextra/enum_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibextra%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibextra%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fenum_set.rs?ref=1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "patch": "@@ -13,7 +13,7 @@\n //! This module defines a container which uses an efficient bit mask\n //! representation to hold C-like enum variants.\n \n-#[deriving(Clone, Eq, IterBytes, ToStr)]\n+#[deriving(Clone, Eq, IterBytes, ToStr, Encodable, Decodable)]\n /// A specialized Set implementation to use enum types.\n pub struct EnumSet<E> {\n     // We must maintain the invariant that no bits are set"}, {"sha": "22fc7f4b3ea6ff101b89a59aa73252370907858f", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "patch": "@@ -129,6 +129,12 @@ pub fn parse_trait_ref_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tc\n     parse_trait_ref(&mut st, conv)\n }\n \n+pub fn parse_substs_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: ty::ctxt,\n+                         conv: conv_did) -> ty::substs {\n+    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n+    parse_substs(&mut st, conv)\n+}\n+\n fn parse_sigil(st: &mut PState) -> ast::Sigil {\n     match next(st) {\n         '@' => ast::ManagedSigil,"}, {"sha": "1f9f1e1856537573bfa2e462cbd17f491ca925b5", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "patch": "@@ -140,7 +140,7 @@ fn enc_opt<T>(w: &mut MemWriter, t: Option<T>, enc_f: |&mut MemWriter, T|) {\n     }\n }\n \n-fn enc_substs(w: &mut MemWriter, cx: @ctxt, substs: &ty::substs) {\n+pub fn enc_substs(w: &mut MemWriter, cx: @ctxt, substs: &ty::substs) {\n     enc_region_substs(w, cx, &substs.regions);\n     enc_opt(w, substs.self_ty, |w, t| enc_ty(w, cx, t));\n     mywrite!(w, \"[\");"}, {"sha": "3560a930237b9aeb12ad821d07fa2713cc8f96ef", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 102, "deletions": 12, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "patch": "@@ -450,15 +450,13 @@ impl tr for ast::Def {\n // ______________________________________________________________________\n // Encoding and decoding of adjustment information\n \n-impl tr for ty::AutoAdjustment {\n-    fn tr(&self, xcx: @ExtendedDecodeContext) -> ty::AutoAdjustment {\n-        match *self {\n-            ty::AutoAddEnv(r, s) => ty::AutoAddEnv(r.tr(xcx), s),\n-            ty::AutoDerefRef(ref adr) => {\n-                ty::AutoDerefRef(ty::AutoDerefRef {\n-                    autoderefs: adr.autoderefs,\n-                    autoref: adr.autoref.map(|ar| ar.tr(xcx)),\n-                })\n+impl tr for ty::AutoDerefRef {\n+    fn tr(&self, xcx: @ExtendedDecodeContext) -> ty::AutoDerefRef {\n+        ty::AutoDerefRef {\n+            autoderefs: self.autoderefs,\n+            autoref: match self.autoref {\n+                Some(ref autoref) => Some(autoref.tr(xcx)),\n+                None => None\n             }\n         }\n     }\n@@ -786,6 +784,8 @@ trait ebml_writer_helpers {\n     fn emit_tpbt(&mut self,\n                  ecx: &e::EncodeContext,\n                  tpbt: ty::ty_param_bounds_and_ty);\n+    fn emit_substs(&mut self, ecx: &e::EncodeContext, substs: &ty::substs);\n+    fn emit_auto_adjustment(&mut self, ecx: &e::EncodeContext, adj: &ty::AutoAdjustment);\n }\n \n impl<'a> ebml_writer_helpers for writer::Encoder<'a> {\n@@ -833,6 +833,40 @@ impl<'a> ebml_writer_helpers for writer::Encoder<'a> {\n             })\n         })\n     }\n+\n+    fn emit_substs(&mut self, ecx: &e::EncodeContext, substs: &ty::substs) {\n+        self.emit_opaque(|this| tyencode::enc_substs(this.writer, ecx.ty_str_ctxt(), substs))\n+    }\n+\n+    fn emit_auto_adjustment(&mut self, ecx: &e::EncodeContext, adj: &ty::AutoAdjustment) {\n+        self.emit_enum(\"AutoAdjustment\", |this| {\n+            match *adj {\n+                ty::AutoAddEnv(region, sigil) => {\n+                    this.emit_enum_variant(\"AutoAddEnv\", 0, 2, |this| {\n+                        this.emit_enum_variant_arg(0, |this| region.encode(this));\n+                        this.emit_enum_variant_arg(1, |this| sigil.encode(this));\n+                    });\n+                }\n+\n+                ty::AutoDerefRef(ref auto_deref_ref) => {\n+                    this.emit_enum_variant(\"AutoDerefRef\", 1, 1, |this| {\n+                        this.emit_enum_variant_arg(0, |this| auto_deref_ref.encode(this));\n+                    });\n+                }\n+\n+                ty::AutoObject(sigil, region, m, b, def_id, ref substs) => {\n+                    this.emit_enum_variant(\"AutoObject\", 2, 6, |this| {\n+                        this.emit_enum_variant_arg(0, |this| sigil.encode(this));\n+                        this.emit_enum_variant_arg(1, |this| region.encode(this));\n+                        this.emit_enum_variant_arg(2, |this| m.encode(this));\n+                        this.emit_enum_variant_arg(3, |this| b.encode(this));\n+                        this.emit_enum_variant_arg(4, |this| def_id.encode(this));\n+                        this.emit_enum_variant_arg(5, |this| this.emit_substs(ecx, substs));\n+                    });\n+                }\n+            }\n+        });\n+    }\n }\n \n trait write_tag_and_id {\n@@ -1023,7 +1057,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             ebml_w.tag(c::tag_table_adjustments, |ebml_w| {\n                 ebml_w.id(id);\n                 ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                    (**adj).encode(ebml_w)\n+                    ebml_w.emit_auto_adjustment(ecx, **adj);\n                 })\n             })\n         }\n@@ -1064,6 +1098,8 @@ trait ebml_decoder_decoder_helpers {\n                            -> ty::TypeParameterDef;\n     fn read_ty_param_bounds_and_ty(&mut self, xcx: @ExtendedDecodeContext)\n                                 -> ty::ty_param_bounds_and_ty;\n+    fn read_substs(&mut self, xcx: @ExtendedDecodeContext) -> ty::substs;\n+    fn read_auto_adjustment(&mut self, xcx: @ExtendedDecodeContext) -> ty::AutoAdjustment;\n     fn convert_def_id(&mut self,\n                       xcx: @ExtendedDecodeContext,\n                       source: DefIdSource,\n@@ -1172,6 +1208,61 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n         })\n     }\n \n+    fn read_substs(&mut self, xcx: @ExtendedDecodeContext) -> ty::substs {\n+        self.read_opaque(|this, doc| {\n+            tydecode::parse_substs_data(doc.data,\n+                                        xcx.dcx.cdata.cnum,\n+                                        doc.start,\n+                                        xcx.dcx.tcx,\n+                                        |s, a| this.convert_def_id(xcx, s, a))\n+        })\n+    }\n+\n+    fn read_auto_adjustment(&mut self, xcx: @ExtendedDecodeContext) -> ty::AutoAdjustment {\n+        self.read_enum(\"AutoAdjustment\", |this| {\n+            let variants = [\"AutoAddEnv\", \"AutoDerefRef\", \"AutoObject\"];\n+            this.read_enum_variant(variants, |this, i| {\n+                match i {\n+                    0 => {\n+                        let region: ty::Region =\n+                            this.read_enum_variant_arg(0, |this| Decodable::decode(this));\n+                        let sigil: ast::Sigil =\n+                            this.read_enum_variant_arg(1, |this| Decodable::decode(this));\n+\n+                        ty:: AutoAddEnv(region.tr(xcx), sigil)\n+                    }\n+                    1 => {\n+                        let auto_deref_ref: ty::AutoDerefRef =\n+                            this.read_enum_variant_arg(0, |this| Decodable::decode(this));\n+\n+                        ty::AutoDerefRef(auto_deref_ref.tr(xcx))\n+                    }\n+                    2 => {\n+                        let sigil: ast::Sigil =\n+                            this.read_enum_variant_arg(0, |this| Decodable::decode(this));\n+                        let region: Option<ty::Region> =\n+                            this.read_enum_variant_arg(1, |this| Decodable::decode(this));\n+                        let m: ast::Mutability =\n+                            this.read_enum_variant_arg(2, |this| Decodable::decode(this));\n+                        let b: ty::BuiltinBounds =\n+                            this.read_enum_variant_arg(3, |this| Decodable::decode(this));\n+                        let def_id: ast::DefId =\n+                            this.read_enum_variant_arg(4, |this| Decodable::decode(this));\n+                        let substs = this.read_enum_variant_arg(5, |this| this.read_substs(xcx));\n+\n+                        let region = match region {\n+                            Some(r) => Some(r.tr(xcx)),\n+                            None => None\n+                        };\n+\n+                        ty::AutoObject(sigil, region, m, b, def_id.tr(xcx), substs)\n+                    }\n+                    _ => fail!(\"bad enum variant for ty::AutoAdjustment\")\n+                }\n+            })\n+        })\n+    }\n+\n     fn convert_def_id(&mut self,\n                       xcx: @ExtendedDecodeContext,\n                       source: tydecode::DefIdSource,\n@@ -1289,8 +1380,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                         vtable_map.get().insert(id, vtable_res);\n                     }\n                     c::tag_table_adjustments => {\n-                        let adj: @ty::AutoAdjustment = @Decodable::decode(val_dsr);\n-                        adj.tr(xcx);\n+                        let adj: @ty::AutoAdjustment = @val_dsr.read_auto_adjustment(xcx);\n                         let mut adjustments = dcx.tcx\n                                                  .adjustments\n                                                  .borrow_mut();"}, {"sha": "86ccfda90c909e6273b604e03225e5bc3320df4d", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "patch": "@@ -419,6 +419,10 @@ impl<'a> GatherLoanCtxt<'a> {\n                     ty::AutoUnsafe(_) => {}\n                 }\n             }\n+\n+            ty::AutoObject(..) => {\n+                // XXX: Handle @Trait to &Trait casts here?\n+            }\n         }\n     }\n "}, {"sha": "ddc31598d674064bbfc31ecc6ad41d3745c97109", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "patch": "@@ -490,7 +490,7 @@ impl BorrowckCtxt {\n                                adj: @ty::AutoAdjustment)\n                                -> mc::cmt {\n         match *adj {\n-            ty::AutoAddEnv(..) => {\n+            ty::AutoAddEnv(..) | ty::AutoObject(..) => {\n                 // no autoderefs\n                 mc::cat_expr_unadjusted(self.tcx, self.method_map, expr)\n             }"}, {"sha": "70abd94ea31fb69acc8f69b57af6524b514887db", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "patch": "@@ -311,14 +311,9 @@ pub fn check_expr(cx: &mut Context, e: @Expr) {\n             let _ = check_durable(cx.tcx, interior_type, interior.span);\n         }\n         ExprCast(source, _) => {\n-            check_cast_for_escaping_regions(cx, source, e);\n-            match ty::get(ty::expr_ty(cx.tcx, e)).sty {\n-                ty::ty_trait(_, _, _, _, bounds) => {\n-                    let source_ty = ty::expr_ty(cx.tcx, source);\n-                    check_trait_cast_bounds(cx, e.span, source_ty, bounds)\n-                }\n-                _ => { }\n-            }\n+            let source_ty = ty::expr_ty(cx.tcx, source);\n+            let target_ty = ty::expr_ty(cx.tcx, e);\n+            check_trait_cast(cx, source_ty, target_ty, source.span);\n         }\n         ExprRepeat(element, count_expr, _) => {\n             let count = ty::eval_repeat_count(&cx.tcx, count_expr);\n@@ -330,9 +325,31 @@ pub fn check_expr(cx: &mut Context, e: @Expr) {\n         }\n         _ => {}\n     }\n+\n+    // Search for auto-adjustments to find trait coercions.\n+    let adjustments = cx.tcx.adjustments.borrow();\n+    match adjustments.get().find(&e.id) {\n+        Some(&@ty::AutoObject(..)) => {\n+            let source_ty = ty::expr_ty(cx.tcx, e);\n+            let target_ty = ty::expr_ty_adjusted(cx.tcx, e);\n+            check_trait_cast(cx, source_ty, target_ty, e.span);\n+        }\n+        Some(&@ty::AutoAddEnv(..)) | Some(&@ty::AutoDerefRef(..)) | None => {}\n+    }\n+\n     visit::walk_expr(cx, e, ());\n }\n \n+fn check_trait_cast(cx: &mut Context, source_ty: ty::t, target_ty: ty::t, span: Span) {\n+    check_cast_for_escaping_regions(cx, source_ty, target_ty, span);\n+    match ty::get(target_ty).sty {\n+        ty::ty_trait(_, _, _, _, bounds) => {\n+            check_trait_cast_bounds(cx, span, source_ty, bounds);\n+        }\n+        _ => {}\n+    }\n+}\n+\n fn check_ty(cx: &mut Context, aty: &Ty) {\n     match aty.node {\n       ty_path(_, _, id) => {\n@@ -510,12 +527,12 @@ pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: Span) -> bool {\n /// FIXME(#5723)---This code should probably move into regionck.\n pub fn check_cast_for_escaping_regions(\n     cx: &Context,\n-    source: &Expr,\n-    target: &Expr)\n+    source_ty: ty::t,\n+    target_ty: ty::t,\n+    source_span: Span)\n {\n     // Determine what type we are casting to; if it is not an trait, then no\n     // worries.\n-    let target_ty = ty::expr_ty(cx.tcx, target);\n     match ty::get(target_ty).sty {\n         ty::ty_trait(..) => {}\n         _ => { return; }\n@@ -545,7 +562,6 @@ pub fn check_cast_for_escaping_regions(\n     // Assuming the trait instance can escape, then ensure that each parameter\n     // either appears in the trait type or is sendable.\n     let target_params = ty::param_tys_in_type(target_ty);\n-    let source_ty = ty::expr_ty(cx.tcx, source);\n     ty::walk_regions_and_ty(\n         cx.tcx,\n         source_ty,\n@@ -555,7 +571,7 @@ pub fn check_cast_for_escaping_regions(\n             //\n             // if !target_regions.iter().any(|t_r| is_subregion_of(cx, *t_r, r)) {\n             //     cx.tcx.sess.span_err(\n-            //         source.span,\n+            //         source_span,\n             //         format!(\"source contains borrowed pointer with lifetime \\\n             //               not found in the target type `{}`\",\n             //              ty_to_str(cx.tcx, target_ty)));\n@@ -570,7 +586,7 @@ pub fn check_cast_for_escaping_regions(\n                     if target_params.iter().any(|x| x == &source_param) {\n                         /* case (2) */\n                     } else {\n-                        check_durable(cx.tcx, ty, source.span); /* case (3) */\n+                        check_durable(cx.tcx, ty, source_span); /* case (3) */\n                     }\n                 }\n                 _ => {}"}, {"sha": "2349b5f4dd3ffe14535c4c255f151aa275a8dea2", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "patch": "@@ -347,6 +347,13 @@ impl mem_categorization_ctxt {\n                 self.cat_expr_unadjusted(expr)\n             }\n \n+            Some(&@ty::AutoObject(..)) => {\n+                // Implicity casts a concrete object to trait object\n+                // Result is an rvalue\n+                let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n+                self.cat_rvalue_node(expr, expr_ty)\n+            }\n+\n             Some(&@ty::AutoAddEnv(..)) => {\n                 // Convert a bare fn to a closure by adding NULL env.\n                 // Result is an rvalue."}, {"sha": "c9d30ec19945d44c9d7c6db1121cba124cbe30d8", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "patch": "@@ -199,6 +199,9 @@ pub fn const_expr(cx: @CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n             cx.sess.span_bug(e.span, format!(\"unexpected static function: \\\n                                            region {:?} sigil {:?}\", *r, *s))\n         }\n+        Some(@ty::AutoObject(..)) => {\n+            cx.sess.span_unimpl(e.span, \"unimplemented const coercion to trait object\");\n+        }\n         Some(@ty::AutoDerefRef(ref adj)) => {\n             let mut ty = ety;\n             let mut maybe_ptr = None;"}, {"sha": "bf7a0d6039bdc92c51561428ca7a6fd56960fdba", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "patch": "@@ -139,7 +139,7 @@ use middle::trans::inline;\n use middle::trans::tvec;\n use middle::trans::type_of;\n use middle::ty::struct_fields;\n-use middle::ty::{AutoBorrowObj, AutoDerefRef, AutoAddEnv, AutoUnsafe};\n+use middle::ty::{AutoBorrowObj, AutoDerefRef, AutoAddEnv, AutoObject, AutoUnsafe};\n use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn};\n use middle::ty;\n use util::common::indenter;\n@@ -228,6 +228,23 @@ pub fn trans_to_datum(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n                 }\n             };\n         }\n+        AutoObject(ref sigil, ref region, _, _, _, _) => {\n+\n+            let adjusted_ty = ty::expr_ty_adjusted(bcx.tcx(), expr);\n+            let scratch = scratch_datum(bcx, adjusted_ty, \"__adjust\", false);\n+\n+            let trait_store = match *sigil {\n+                ast::BorrowedSigil => ty::RegionTraitStore(region.expect(\"expected valid region\")),\n+                ast::OwnedSigil => ty::UniqTraitStore,\n+                ast::ManagedSigil => ty::BoxTraitStore\n+            };\n+\n+            bcx = meth::trans_trait_cast(bcx, expr, expr.id, SaveIn(scratch.val),\n+                                         trait_store, false /* no adjustments */);\n+\n+            datum = scratch.to_appropriate_datum(bcx);\n+            datum.add_clean(bcx);\n+        }\n     }\n     debug!(\"after adjustments, datum={}\", datum.to_str(bcx.ccx()));\n     return DatumBlock {bcx: bcx, datum: datum};\n@@ -432,6 +449,10 @@ pub fn trans_into(bcx: @Block, expr: &ast::Expr, dest: Dest) -> @Block {\n         };\n     }\n \n+    trans_into_unadjusted(bcx, expr, dest)\n+}\n+\n+pub fn trans_into_unadjusted(bcx: @Block, expr: &ast::Expr, dest: Dest) -> @Block {\n     let ty = expr_ty(bcx, expr);\n \n     debug!(\"trans_into_unadjusted(expr={}, dest={})\",\n@@ -778,8 +799,8 @@ fn trans_rvalue_dps_unadjusted(bcx: @Block, expr: &ast::Expr,\n         ast::ExprCast(val, _) => {\n             match ty::get(node_id_type(bcx, expr.id)).sty {\n                 ty::ty_trait(_, _, store, _, _) => {\n-                    return meth::trans_trait_cast(bcx, val, expr.id, dest,\n-                                                  store);\n+                    return meth::trans_trait_cast(bcx, val, expr.id,\n+                                                  dest, store, true /* adjustments */);\n                 }\n                 _ => {\n                     bcx.tcx().sess.span_bug(expr.span,"}, {"sha": "d16cf6f1c3b275c412b78583957a2d94c6b28b2d", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "patch": "@@ -646,14 +646,22 @@ pub fn trans_trait_cast(bcx: @Block,\n                         val: &ast::Expr,\n                         id: ast::NodeId,\n                         dest: expr::Dest,\n-                        _store: ty::TraitStore)\n+                        _store: ty::TraitStore,\n+                        do_adjustments: bool)\n                      -> @Block {\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"impl::trans_cast\");\n \n+    // Pick the right trans function\n+    let trans_into = if do_adjustments {\n+        expr::trans_into\n+    } else {\n+        expr::trans_into_unadjusted\n+    };\n+\n     let lldest = match dest {\n         Ignore => {\n-            return expr::trans_into(bcx, val, Ignore);\n+            return trans_into(bcx, val, Ignore);\n         }\n         SaveIn(dest) => dest\n     };\n@@ -668,7 +676,7 @@ pub fn trans_trait_cast(bcx: @Block,\n     llboxdest = PointerCast(bcx,\n                             llboxdest,\n                             type_of(bcx.ccx(), v_ty).ptr_to());\n-    bcx = expr::trans_into(bcx, val, SaveIn(llboxdest));\n+    bcx = trans_into(bcx, val, SaveIn(llboxdest));\n \n     // Store the vtable into the pair or triple.\n     // This is structured a bit funny because of dynamic borrow failures."}, {"sha": "a3c2e2a4404aff44d89d8fea247e96a0ff39b51c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "patch": "@@ -224,10 +224,14 @@ pub enum Variance {\n     Bivariant,      // T<A> <: T<B>            -- e.g., unused type parameter\n }\n \n-#[deriving(Decodable, Encodable)]\n pub enum AutoAdjustment {\n     AutoAddEnv(ty::Region, ast::Sigil),\n-    AutoDerefRef(AutoDerefRef)\n+    AutoDerefRef(AutoDerefRef),\n+    AutoObject(ast::Sigil, Option<ty::Region>,\n+               ast::Mutability,\n+               ty::BuiltinBounds,\n+               ast::DefId, /* Trait ID */\n+               ty::substs /* Trait substitutions */)\n }\n \n #[deriving(Decodable, Encodable)]\n@@ -730,7 +734,7 @@ pub struct ParamBounds {\n \n pub type BuiltinBounds = EnumSet<BuiltinBound>;\n \n-#[deriving(Clone, Eq, IterBytes, ToStr)]\n+#[deriving(Clone, Encodable, Eq, Decodable, IterBytes, ToStr)]\n #[repr(uint)]\n pub enum BuiltinBound {\n     BoundStatic,\n@@ -2955,6 +2959,10 @@ pub fn adjust_ty(cx: ctxt,\n                 }\n             }\n         }\n+\n+        Some(@AutoObject(ref sigil, ref region, m, b, def_id, ref substs)) => {\n+            trait_adjustment_to_ty(cx, sigil, region, def_id, substs, m, b)\n+        }\n     };\n \n     fn borrow_vec(cx: ctxt, span: Span,\n@@ -3014,6 +3022,19 @@ pub fn adjust_ty(cx: ctxt,\n     }\n }\n \n+pub fn trait_adjustment_to_ty(cx: ctxt, sigil: &ast::Sigil, region: &Option<Region>,\n+                              def_id: ast::DefId, substs: &substs, m: ast::Mutability,\n+                              bounds: BuiltinBounds) -> t {\n+\n+    let trait_store = match *sigil {\n+        BorrowedSigil => RegionTraitStore(region.expect(\"expected valid region\")),\n+        OwnedSigil => UniqTraitStore,\n+        ManagedSigil => BoxTraitStore\n+    };\n+\n+    mk_trait(cx, def_id, substs.clone(), trait_store, m, bounds)\n+}\n+\n impl AutoRef {\n     pub fn map_region(&self, f: |Region| -> Region) -> AutoRef {\n         match *self {"}, {"sha": "03fe9dc41b8b78942df0a1dce8f4145cefae66cc", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "patch": "@@ -327,6 +327,25 @@ fn visit_expr(rcx: &mut Rcx, expr: @ast::Expr) {\n                             infer::AutoBorrow(expr.span));\n                     }\n                 }\n+                @ty::AutoObject(ast::BorrowedSigil, Some(trait_region), _, _, _, _) => {\n+                    // Determine if we are casting `expr` to an trait\n+                    // instance.  If so, we have to be sure that the type of\n+                    // the source obeys the trait's region bound.\n+                    //\n+                    // Note: there is a subtle point here concerning type\n+                    // parameters.  It is possible that the type of `source`\n+                    // contains type parameters, which in turn may contain\n+                    // regions that are not visible to us (only the caller\n+                    // knows about them).  The kind checker is ultimately\n+                    // responsible for guaranteeing region safety in that\n+                    // particular case.  There is an extensive comment on the\n+                    // function check_cast_for_escaping_regions() in kind.rs\n+                    // explaining how it goes about doing that.\n+\n+                    let source_ty = rcx.fcx.expr_ty(expr);\n+                    constrain_regions_in_type(rcx, trait_region,\n+                                              infer::RelateObjectBound(expr.span), source_ty);\n+                }\n                 _ => {}\n             }\n         }\n@@ -1075,6 +1094,27 @@ pub mod guarantor {\n                 };\n             }\n \n+            Some(&@ty::AutoObject(ast::BorrowedSigil, Some(region), _, _, _, _)) => {\n+                expr_ct.cat = ExprCategorization {\n+                    guarantor: None,\n+                    pointer: BorrowedPointer(region)\n+                };\n+            }\n+\n+            Some(&@ty::AutoObject(ast::OwnedSigil, _, _, _, _, _)) => {\n+                expr_ct.cat = ExprCategorization {\n+                    guarantor: None,\n+                    pointer: OwnedPointer\n+                };\n+            }\n+\n+            Some(&@ty::AutoObject(ast::ManagedSigil, _, _, _, _, _)) => {\n+                expr_ct.cat = ExprCategorization {\n+                    guarantor: None,\n+                    pointer: OtherPointer\n+                };\n+            }\n+\n             Some(&@ty::AutoDerefRef(ref adjustment)) => {\n                 debug!(\"adjustment={:?}\", adjustment);\n \n@@ -1103,6 +1143,8 @@ pub mod guarantor {\n                 }\n             }\n \n+            Some(..) => fail!(\"invalid or unhandled adjustment\"),\n+\n             None => {}\n         }\n "}, {"sha": "35501e5d5ebf291845b932d0cae0856c865b802e", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 116, "deletions": 99, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n \n-use middle::ty::param_ty;\n use middle::ty;\n+use middle::ty::{AutoAddEnv, AutoDerefRef, AutoObject, param_ty};\n use middle::ty_fold::TypeFolder;\n use middle::typeck::check::{FnCtxt, impl_self_ty};\n use middle::typeck::check::{structurally_resolved_type};\n@@ -565,6 +565,106 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n     let _indent = indenter();\n \n     let cx = fcx.ccx;\n+    let resolve_object_cast = |src: @ast::Expr, target_ty: ty::t| {\n+      match ty::get(target_ty).sty {\n+          // Bounds of type's contents are not checked here, but in kind.rs.\n+          ty::ty_trait(target_def_id, ref target_substs, store,\n+                       target_mutbl, _bounds) => {\n+              fn mutability_allowed(a_mutbl: ast::Mutability,\n+                                    b_mutbl: ast::Mutability) -> bool {\n+                  a_mutbl == b_mutbl ||\n+                  (a_mutbl == ast::MutMutable && b_mutbl == ast::MutImmutable)\n+              }\n+              // Look up vtables for the type we're casting to,\n+              // passing in the source and target type.  The source\n+              // must be a pointer type suitable to the object sigil,\n+              // e.g.: `@x as @Trait`, `&x as &Trait` or `~x as ~Trait`\n+              let ty = structurally_resolved_type(fcx, ex.span,\n+                                                  fcx.expr_ty(src));\n+              match (&ty::get(ty).sty, store) {\n+                  (&ty::ty_box(mt), ty::BoxTraitStore) |\n+                  (&ty::ty_uniq(mt), ty::UniqTraitStore) |\n+                  (&ty::ty_rptr(_, mt), ty::RegionTraitStore(..))\n+                    if !mutability_allowed(mt.mutbl, target_mutbl) => {\n+                      fcx.tcx().sess.span_err(ex.span,\n+                                              format!(\"types differ in mutability\"));\n+                  }\n+\n+                  (&ty::ty_box(mt), ty::BoxTraitStore) |\n+                  (&ty::ty_uniq(mt), ty::UniqTraitStore) |\n+                  (&ty::ty_rptr(_, mt), ty::RegionTraitStore(..)) => {\n+                      let location_info =\n+                          &location_info_for_expr(ex);\n+                      let vcx = fcx.vtable_context();\n+                      let target_trait_ref = @ty::TraitRef {\n+                          def_id: target_def_id,\n+                          substs: ty::substs {\n+                              tps: target_substs.tps.clone(),\n+                              regions: target_substs.regions.clone(),\n+                              self_ty: Some(mt.ty)\n+                          }\n+                      };\n+\n+                      let param_bounds = ty::ParamBounds {\n+                          builtin_bounds: ty::EmptyBuiltinBounds(),\n+                          trait_bounds: ~[target_trait_ref]\n+                      };\n+                      let vtables =\n+                            lookup_vtables_for_param(&vcx,\n+                                                     location_info,\n+                                                     None,\n+                                                     &param_bounds,\n+                                                     mt.ty,\n+                                                     is_early);\n+\n+                      if !is_early {\n+                          insert_vtables(fcx, ex.id, @~[vtables]);\n+                      }\n+\n+                      // Now, if this is &trait, we need to link the\n+                      // regions.\n+                      match (&ty::get(ty).sty, store) {\n+                          (&ty::ty_rptr(ra, _),\n+                           ty::RegionTraitStore(rb)) => {\n+                              infer::mk_subr(fcx.infcx(),\n+                                             false,\n+                                             infer::RelateObjectBound(\n+                                                 ex.span),\n+                                             rb,\n+                                             ra);\n+                          }\n+                          _ => {}\n+                      }\n+                  }\n+\n+                  (_, ty::UniqTraitStore) => {\n+                      fcx.ccx.tcx.sess.span_err(\n+                          ex.span,\n+                          format!(\"can only cast an ~-pointer \\\n+                                to a ~-object, not a {}\",\n+                               ty::ty_sort_str(fcx.tcx(), ty)));\n+                  }\n+\n+                  (_, ty::BoxTraitStore) => {\n+                      fcx.ccx.tcx.sess.span_err(\n+                          ex.span,\n+                          format!(\"can only cast an @-pointer \\\n+                                to an @-object, not a {}\",\n+                               ty::ty_sort_str(fcx.tcx(), ty)));\n+                  }\n+\n+                  (_, ty::RegionTraitStore(_)) => {\n+                      fcx.ccx.tcx.sess.span_err(\n+                          ex.span,\n+                          format!(\"can only cast an &-pointer \\\n+                                to an &-object, not a {}\",\n+                               ty::ty_sort_str(fcx.tcx(), ty)));\n+                  }\n+              }\n+          }\n+          _ => { /* not a cast to a trait; ignore */ }\n+      }\n+    };\n     match ex.node {\n       ast::ExprPath(..) => {\n         fcx.opt_node_ty_substs(ex.id, |substs| {\n@@ -621,107 +721,24 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n       ast::ExprCast(src, _) => {\n           debug!(\"vtable resolution on expr {}\", ex.repr(fcx.tcx()));\n           let target_ty = fcx.expr_ty(ex);\n-          match ty::get(target_ty).sty {\n-              // Bounds of type's contents are not checked here, but in kind.rs.\n-              ty::ty_trait(target_def_id, ref target_substs, store,\n-                           target_mutbl, _bounds) => {\n-                  fn mutability_allowed(a_mutbl: ast::Mutability,\n-                                        b_mutbl: ast::Mutability) -> bool {\n-                      a_mutbl == b_mutbl ||\n-                      (a_mutbl == ast::MutMutable && b_mutbl == ast::MutImmutable)\n-                  }\n-                  // Look up vtables for the type we're casting to,\n-                  // passing in the source and target type.  The source\n-                  // must be a pointer type suitable to the object sigil,\n-                  // e.g.: `@x as @Trait`, `&x as &Trait` or `~x as ~Trait`\n-                  let ty = structurally_resolved_type(fcx, ex.span,\n-                                                      fcx.expr_ty(src));\n-                  match (&ty::get(ty).sty, store) {\n-                      (&ty::ty_box(mt), ty::BoxTraitStore) |\n-                      (&ty::ty_uniq(mt), ty::UniqTraitStore) |\n-                      (&ty::ty_rptr(_, mt), ty::RegionTraitStore(..))\n-                        if !mutability_allowed(mt.mutbl, target_mutbl) => {\n-                          fcx.tcx().sess.span_err(ex.span,\n-                                                  format!(\"types differ in mutability\"));\n-                      }\n-\n-                      (&ty::ty_box(mt), ty::BoxTraitStore) |\n-                      (&ty::ty_uniq(mt), ty::UniqTraitStore) |\n-                      (&ty::ty_rptr(_, mt), ty::RegionTraitStore(..)) => {\n-                          let location_info =\n-                              &location_info_for_expr(ex);\n-                          let vcx = fcx.vtable_context();\n-                          let target_trait_ref = @ty::TraitRef {\n-                              def_id: target_def_id,\n-                              substs: ty::substs {\n-                                  tps: target_substs.tps.clone(),\n-                                  regions: target_substs.regions.clone(),\n-                                  self_ty: Some(mt.ty)\n-                              }\n-                          };\n-\n-                          let param_bounds = ty::ParamBounds {\n-                              builtin_bounds: ty::EmptyBuiltinBounds(),\n-                              trait_bounds: ~[target_trait_ref]\n-                          };\n-                          let vtables =\n-                                lookup_vtables_for_param(&vcx,\n-                                                         location_info,\n-                                                         None,\n-                                                         &param_bounds,\n-                                                         mt.ty,\n-                                                         is_early);\n-\n-                          if !is_early {\n-                              insert_vtables(fcx, ex.id, @~[vtables]);\n-                          }\n-\n-                          // Now, if this is &trait, we need to link the\n-                          // regions.\n-                          match (&ty::get(ty).sty, store) {\n-                              (&ty::ty_rptr(ra, _),\n-                               ty::RegionTraitStore(rb)) => {\n-                                  infer::mk_subr(fcx.infcx(),\n-                                                 false,\n-                                                 infer::RelateObjectBound(\n-                                                     ex.span),\n-                                                 rb,\n-                                                 ra);\n-                              }\n-                              _ => {}\n-                          }\n-                      }\n-\n-                      (_, ty::UniqTraitStore) => {\n-                          fcx.ccx.tcx.sess.span_err(\n-                              ex.span,\n-                              format!(\"can only cast an ~-pointer \\\n-                                    to a ~-object, not a {}\",\n-                                   ty::ty_sort_str(fcx.tcx(), ty)));\n-                      }\n-\n-                      (_, ty::BoxTraitStore) => {\n-                          fcx.ccx.tcx.sess.span_err(\n-                              ex.span,\n-                              format!(\"can only cast an @-pointer \\\n-                                    to an @-object, not a {}\",\n-                                   ty::ty_sort_str(fcx.tcx(), ty)));\n-                      }\n-\n-                      (_, ty::RegionTraitStore(_)) => {\n-                          fcx.ccx.tcx.sess.span_err(\n-                              ex.span,\n-                              format!(\"can only cast an &-pointer \\\n-                                    to an &-object, not a {}\",\n-                                   ty::ty_sort_str(fcx.tcx(), ty)));\n-                      }\n-                  }\n-              }\n-              _ => { /* not a cast to a trait; ignore */ }\n-          }\n+          resolve_object_cast(src, target_ty);\n       }\n       _ => ()\n     }\n+\n+    // Search for auto-adjustments to find trait coercions\n+    let adjustments = fcx.inh.adjustments.borrow();\n+    match adjustments.get().find(&ex.id) {\n+        Some(&@AutoObject(ref sigil, ref region, m, b, def_id, ref substs)) => {\n+            debug!(\"doing trait adjustment for expr {} {} (early? {})\",\n+                   ex.id, ex.repr(fcx.tcx()), is_early);\n+\n+            let object_ty = ty::trait_adjustment_to_ty(cx.tcx, sigil, region,\n+                                                       def_id, substs, m, b);\n+            resolve_object_cast(ex, object_ty);\n+        }\n+        Some(&@AutoAddEnv(..)) | Some(&@AutoDerefRef(..)) | None => {}\n+    }\n }\n \n fn resolve_expr(fcx: @FnCtxt,"}, {"sha": "f84220da8e75cdb04f2c8ddb5aca9de4ce754a47", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "patch": "@@ -182,6 +182,12 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n             let mut adjustments = fcx.tcx().adjustments.borrow_mut();\n             adjustments.get().insert(id, resolved_adj);\n         }\n+\n+        Some(adjustment @ @ty::AutoObject(..)) => {\n+            debug!(\"Adjustments for node {}: {:?}\", id, adjustment);\n+            let mut adjustments = fcx.tcx().adjustments.borrow_mut();\n+            adjustments.get().insert(id, adjustment);\n+        }\n     }\n \n     // Resolve the type of the node with id `id`"}, {"sha": "0d4c3ef52d3d5e40b27cd0977861b2577b99e58c", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 76, "deletions": 5, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "patch": "@@ -121,16 +121,61 @@ impl Coerce {\n                 });\n             }\n \n-            ty::ty_trait(_, _, ty::RegionTraitStore(..), m, _) => {\n+            ty::ty_ptr(mt_b) => {\n                 return self.unpack_actual_value(a, |sty_a| {\n-                    self.coerce_borrowed_object(a, sty_a, b, m)\n+                    self.coerce_unsafe_ptr(a, sty_a, b, mt_b)\n                 });\n             }\n \n-            ty::ty_ptr(mt_b) => {\n-                return self.unpack_actual_value(a, |sty_a| {\n-                    self.coerce_unsafe_ptr(a, sty_a, b, mt_b)\n+            ty::ty_trait(def_id, ref substs, ty::BoxTraitStore, m, bounds) => {\n+                let result = self.unpack_actual_value(a, |sty_a| {\n+                    match *sty_a {\n+                        ty::ty_box(..) => {\n+                            self.coerce_object(a, sty_a, b, def_id, substs,\n+                                               ty::BoxTraitStore, m, bounds)\n+                        }\n+                        _ => Err(ty::terr_mismatch)\n+                    }\n                 });\n+\n+                match result {\n+                    Ok(t) => return Ok(t),\n+                    Err(..) => {}\n+                }\n+            }\n+\n+            ty::ty_trait(def_id, ref substs, ty::UniqTraitStore, m, bounds) => {\n+                let result = self.unpack_actual_value(a, |sty_a| {\n+                    match *sty_a {\n+                        ty::ty_uniq(..) => {\n+                            self.coerce_object(a, sty_a, b, def_id, substs,\n+                                               ty::UniqTraitStore, m, bounds)\n+                        }\n+                        _ => Err(ty::terr_mismatch)\n+                    }\n+                });\n+\n+                match result {\n+                    Ok(t) => return Ok(t),\n+                    Err(..) => {}\n+                }\n+            }\n+\n+            ty::ty_trait(def_id, ref substs, ty::RegionTraitStore(region), m, bounds) => {\n+                let result = self.unpack_actual_value(a, |sty_a| {\n+                    match *sty_a {\n+                        ty::ty_rptr(..) => {\n+                            self.coerce_object(a, sty_a, b, def_id, substs,\n+                                               ty::RegionTraitStore(region), m, bounds)\n+                        }\n+                        _ => self.coerce_borrowed_object(a, sty_a, b, m)\n+                    }\n+                });\n+\n+                match result {\n+                    Ok(t) => return Ok(t),\n+                    Err(..) => {}\n+                }\n             }\n \n             _ => {}\n@@ -410,4 +455,30 @@ impl Coerce {\n             autoref: Some(ty::AutoUnsafe(mt_b.mutbl))\n         })))\n     }\n+\n+    pub fn coerce_object(&self,\n+                         a: ty::t,\n+                         sty_a: &ty::sty,\n+                         b: ty::t,\n+                         trait_def_id: ast::DefId,\n+                         trait_substs: &ty::substs,\n+                         trait_store: ty::TraitStore,\n+                         m: ast::Mutability,\n+                         bounds: ty::BuiltinBounds) -> CoerceResult {\n+\n+        debug!(\"coerce_object(a={}, sty_a={:?}, b={})\",\n+               a.inf_str(self.infcx), sty_a,\n+               b.inf_str(self.infcx));\n+\n+        let (sigil, region) = match trait_store {\n+            ty::BoxTraitStore => (ast::ManagedSigil, None),\n+            ty::UniqTraitStore => (ast::OwnedSigil, None),\n+            ty::RegionTraitStore(region) => (ast::BorrowedSigil, Some(region))\n+        };\n+\n+        let adjustment = @ty::AutoObject(sigil, region, m, bounds,\n+                                         trait_def_id, trait_substs.clone());\n+\n+        Ok(Some(adjustment))\n+    }\n }"}, {"sha": "0a1eab913be199c0ae53a5291ff6800cb863cdb7", "filename": "src/test/compile-fail/map-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmap-types.rs?ref=1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "patch": "@@ -17,7 +17,7 @@ use std::hashmap::HashMap;\n \n fn main() {\n     let x: @HashMap<~str, ~str> = @HashMap::new();\n-    let x: @Map<~str, ~str> = x as @Map<~str, ~str>;\n+    let x: @Map<~str, ~str> = x;\n     let y: @Map<uint, ~str> = @x;\n-    //~^ ERROR expected trait std::container::Map but found @-ptr\n+    //~^ ERROR failed to find an implementation of trait std::container::Map<uint,~str> for @std::container::Map<~str,~str>:'static\n }"}, {"sha": "2d73158add2e14176f99033d21643d957a6737b9", "filename": "src/test/compile-fail/trait-coercion-generic-bad.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-bad.rs?ref=1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[feature(managed_boxes)];\n+\n+struct Struct {\n+    person: &'static str\n+}\n+\n+trait Trait<T> {\n+    fn f(&self, x: T);\n+}\n+\n+impl Trait<&'static str> for Struct {\n+    fn f(&self, x: &'static str) {\n+        println!(\"Hello, {}!\", x);\n+    }\n+}\n+\n+fn main() {\n+    let s: @Trait<int> = @Struct { person: \"Fred\" };    //~ ERROR expected Trait<int>, but found Trait<&'static str>\n+    //~^ ERROR expected Trait<int>, but found Trait<&'static str>\n+    s.f(1);\n+}\n+"}, {"sha": "1ea18a7c75b4d1c8fdbed3f5584adc5350507f01", "filename": "src/test/compile-fail/trait-coercion-generic-regions.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs?ref=1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[feature(managed_boxes)];\n+\n+struct Struct {\n+    person: &'static str\n+}\n+\n+trait Trait<T> {\n+    fn f(&self, x: T);\n+}\n+\n+impl Trait<&'static str> for Struct {\n+    fn f(&self, x: &'static str) {\n+        println!(\"Hello, {}!\", x);\n+    }\n+}\n+\n+fn main() {\n+    let person = ~\"Fred\";\n+    let person: &str = person;  //~ ERROR borrowed value does not live long enough\n+    let s: @Trait<&'static str> = @Struct { person: person };\n+}\n+"}, {"sha": "415f7baf3d9cc2c46af99232e263210b71ab2d32", "filename": "src/test/run-pass/trait-coercion-generic.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Ftest%2Frun-pass%2Ftrait-coercion-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Ftest%2Frun-pass%2Ftrait-coercion-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-coercion-generic.rs?ref=1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[feature(managed_boxes)];\n+\n+trait Trait<T> {\n+    fn f(&self, x: T);\n+}\n+\n+struct Struct {\n+    x: int,\n+    y: int,\n+}\n+\n+impl Trait<&'static str> for Struct {\n+    fn f(&self, x: &'static str) {\n+        println(~\"Hi, \" + x + ~\"!\");\n+    }\n+}\n+\n+fn f(x: @Trait<&'static str>) {\n+    x.f(\"Sue\");\n+}\n+\n+pub fn main() {\n+    let a = Struct { x: 1, y: 2 };\n+    let b: @Trait<&'static str> = @a;\n+    b.f(\"Fred\");\n+    let c: ~Trait<&'static str> = ~a;\n+    c.f(\"Mary\");\n+    let d: &Trait<&'static str> = &a;\n+    d.f(\"Joe\");\n+    f(@a);\n+}\n+"}, {"sha": "1c6968266e18dadbffd676007c00f835d6a8b02e", "filename": "src/test/run-pass/trait-coercion.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Ftest%2Frun-pass%2Ftrait-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335/src%2Ftest%2Frun-pass%2Ftrait-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-coercion.rs?ref=1a9c8cc1283675dfc1b85dbf80a9ea07a2b8b335", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[feature(managed_boxes)];\n+\n+trait Trait {\n+    fn f(&self);\n+}\n+\n+struct Struct {\n+    x: int,\n+    y: int,\n+}\n+\n+impl Trait for Struct {\n+    fn f(&self) {\n+        println(\"Hi!\");\n+    }\n+}\n+\n+fn f(x: @Trait) {\n+    x.f();\n+}\n+\n+pub fn main() {\n+    let a = Struct { x: 1, y: 2 };\n+    let b: @Trait = @a;\n+    b.f();\n+    let c: ~Trait = ~a;\n+    c.f();\n+    let d: &Trait = &a;\n+    d.f();\n+    f(@a);\n+}\n+"}]}