{"sha": "38fa676330eb938ca9e8f36397a9003509e8be07", "node_id": "C_kwDOAAsO6NoAKDM4ZmE2NzYzMzBlYjkzOGNhOWU4ZjM2Mzk3YTkwMDM1MDllOGJlMDc", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-04-23T18:02:05Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-05-09T17:27:58Z"}, "message": "Precompute values to flood.", "tree": {"sha": "f2561d514bb0601ca97ebbebdbbddcdc6498e2b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2561d514bb0601ca97ebbebdbbddcdc6498e2b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38fa676330eb938ca9e8f36397a9003509e8be07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38fa676330eb938ca9e8f36397a9003509e8be07", "html_url": "https://github.com/rust-lang/rust/commit/38fa676330eb938ca9e8f36397a9003509e8be07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38fa676330eb938ca9e8f36397a9003509e8be07/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c3d55150dc09494fda56814ff1bd529d72b6afb", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c3d55150dc09494fda56814ff1bd529d72b6afb", "html_url": "https://github.com/rust-lang/rust/commit/7c3d55150dc09494fda56814ff1bd529d72b6afb"}], "stats": {"total": 70, "additions": 51, "deletions": 19}, "files": [{"sha": "882f9dc11a127da2bb7d71196377a72ab450eef3", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 51, "deletions": 19, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/38fa676330eb938ca9e8f36397a9003509e8be07/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38fa676330eb938ca9e8f36397a9003509e8be07/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=38fa676330eb938ca9e8f36397a9003509e8be07", "patch": "@@ -34,6 +34,7 @@\n \n use std::collections::VecDeque;\n use std::fmt::{Debug, Formatter};\n+use std::ops::Range;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::bit_set::BitSet;\n@@ -448,10 +449,8 @@ impl<V: Clone + HasTop + HasBottom> State<V> {\n \n     pub fn flood_with(&mut self, place: PlaceRef<'_>, map: &Map, value: V) {\n         let StateData::Reachable(values) = &mut self.0 else { return };\n-        map.for_each_aliasing_place(place, None, &mut |place| {\n-            if let Some(vi) = map.places[place].value_index {\n-                values[vi] = value.clone();\n-            }\n+        map.for_each_aliasing_place(place, None, &mut |vi| {\n+            values[vi] = value.clone();\n         });\n     }\n \n@@ -461,10 +460,8 @@ impl<V: Clone + HasTop + HasBottom> State<V> {\n \n     pub fn flood_discr_with(&mut self, place: PlaceRef<'_>, map: &Map, value: V) {\n         let StateData::Reachable(values) = &mut self.0 else { return };\n-        map.for_each_aliasing_place(place, Some(TrackElem::Discriminant), &mut |place| {\n-            if let Some(vi) = map.places[place].value_index {\n-                values[vi] = value.clone();\n-            }\n+        map.for_each_aliasing_place(place, Some(TrackElem::Discriminant), &mut |vi| {\n+            values[vi] = value.clone();\n         });\n     }\n \n@@ -589,6 +586,9 @@ pub struct Map {\n     projections: FxHashMap<(PlaceIndex, TrackElem), PlaceIndex>,\n     places: IndexVec<PlaceIndex, PlaceInfo>,\n     value_count: usize,\n+    // The Range corresponds to a slice into `inner_values_buffer`.\n+    inner_values: IndexVec<PlaceIndex, Range<usize>>,\n+    inner_values_buffer: Vec<ValueIndex>,\n }\n \n impl Map {\n@@ -598,6 +598,8 @@ impl Map {\n             projections: FxHashMap::default(),\n             places: IndexVec::new(),\n             value_count: 0,\n+            inner_values: IndexVec::new(),\n+            inner_values_buffer: Vec::new(),\n         }\n     }\n \n@@ -665,6 +667,14 @@ impl Map {\n             // And push the eventual children places to the worklist.\n             self.register_children(tcx, place, ty, &filter, &mut worklist);\n         }\n+\n+        self.inner_values_buffer = Vec::with_capacity(self.value_count);\n+        self.inner_values = IndexVec::from_elem(0..0, &self.places);\n+        for local in body.local_decls.indices() {\n+            if let Some(place) = self.locals[local] {\n+                self.cache_preorder_invoke(place);\n+            }\n+        }\n     }\n \n     /// Potentially register the (local, projection) place and its fields, recursively.\n@@ -718,6 +728,25 @@ impl Map {\n         });\n     }\n \n+    /// Precompute the list of values inside `root` and store it inside\n+    /// as a slice within `inner_values_buffer`.\n+    fn cache_preorder_invoke(&mut self, root: PlaceIndex) {\n+        let start = self.inner_values_buffer.len();\n+        if let Some(vi) = self.places[root].value_index {\n+            self.inner_values_buffer.push(vi);\n+        }\n+\n+        // We manually iterate instead of using `children` as we need to mutate `self`.\n+        let mut next_child = self.places[root].first_child;\n+        while let Some(child) = next_child {\n+            self.cache_preorder_invoke(child);\n+            next_child = self.places[child].next_sibling;\n+        }\n+\n+        let end = self.inner_values_buffer.len();\n+        self.inner_values[root] = start..end;\n+    }\n+\n     /// Returns the number of tracked places, i.e., those for which a value can be stored.\n     pub fn tracked_places(&self) -> usize {\n         self.value_count\n@@ -768,11 +797,11 @@ impl Map {\n     ///\n     /// `tail_elem` allows to support discriminants that are not a place in MIR, but that we track\n     /// as such.\n-    pub fn for_each_aliasing_place(\n+    fn for_each_aliasing_place(\n         &self,\n         place: PlaceRef<'_>,\n         tail_elem: Option<TrackElem>,\n-        f: &mut impl FnMut(PlaceIndex),\n+        f: &mut impl FnMut(ValueIndex),\n     ) {\n         if place.is_indirect() {\n             // We do not track indirect places.\n@@ -789,7 +818,9 @@ impl Map {\n             .chain(tail_elem.map(Ok).into_iter());\n         for elem in elems {\n             // A field aliases the parent place.\n-            f(index);\n+            if let Some(vi) = self.places[index].value_index {\n+                f(vi);\n+            }\n \n             let Ok(elem) = elem else { return };\n             let sub = self.apply(index, elem);\n@@ -803,15 +834,15 @@ impl Map {\n                 return;\n             }\n         }\n-        self.preorder_invoke(index, f);\n+        self.for_each_value_inside(index, f);\n     }\n \n     /// Invoke the given function on all the descendants of the given place, except one branch.\n     fn for_each_variant_sibling(\n         &self,\n         parent: PlaceIndex,\n         preserved_child: Option<PlaceIndex>,\n-        f: &mut impl FnMut(PlaceIndex),\n+        f: &mut impl FnMut(ValueIndex),\n     ) {\n         for sibling in self.children(parent) {\n             let elem = self.places[sibling].proj_elem;\n@@ -821,16 +852,17 @@ impl Map {\n                 // Only invalidate the other variants, the current one is fine.\n                 && Some(sibling) != preserved_child\n             {\n-                self.preorder_invoke(sibling, f);\n+                self.for_each_value_inside(sibling, f);\n             }\n         }\n     }\n \n-    /// Invoke a function on the given place and all descendants.\n-    fn preorder_invoke(&self, root: PlaceIndex, f: &mut impl FnMut(PlaceIndex)) {\n-        f(root);\n-        for child in self.children(root) {\n-            self.preorder_invoke(child, f);\n+    /// Invoke a function on each value in the given place and all descendants.\n+    fn for_each_value_inside(&self, root: PlaceIndex, f: &mut impl FnMut(ValueIndex)) {\n+        let range = self.inner_values[root].clone();\n+        let values = &self.inner_values_buffer[range];\n+        for &v in values {\n+            f(v)\n         }\n     }\n }"}]}