{"sha": "5292d48b85482bd3edc430e1933f5bc51eafbff4", "node_id": "C_kwDOAAsO6NoAKDUyOTJkNDhiODU0ODJiZDNlZGM0MzBlMTkzM2Y1YmM1MWVhZmJmZjQ", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-04-30T06:32:40Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-05-01T05:33:04Z"}, "message": "Codegen fewer instructions in `mem::replace`", "tree": {"sha": "397a91daa526a8e5333624e347162ecd707b398c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/397a91daa526a8e5333624e347162ecd707b398c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5292d48b85482bd3edc430e1933f5bc51eafbff4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5292d48b85482bd3edc430e1933f5bc51eafbff4", "html_url": "https://github.com/rust-lang/rust/commit/5292d48b85482bd3edc430e1933f5bc51eafbff4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5292d48b85482bd3edc430e1933f5bc51eafbff4/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca3f742ff6fe12b6bb247546189d44718f679799", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca3f742ff6fe12b6bb247546189d44718f679799", "html_url": "https://github.com/rust-lang/rust/commit/ca3f742ff6fe12b6bb247546189d44718f679799"}], "stats": {"total": 232, "additions": 154, "deletions": 78}, "files": [{"sha": "6a10b50aa16eaa8a46f7128d9970d13001381cda", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5292d48b85482bd3edc430e1933f5bc51eafbff4/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5292d48b85482bd3edc430e1933f5bc51eafbff4/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=5292d48b85482bd3edc430e1933f5bc51eafbff4", "patch": "@@ -381,6 +381,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             sym::unlikely => (0, vec![tcx.types.bool], tcx.types.bool),\n \n             sym::read_via_copy => (1, vec![tcx.mk_imm_ptr(param(0))], param(0)),\n+            sym::write_via_move => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], tcx.mk_unit()),\n \n             sym::discriminant_value => {\n                 let assoc_items = tcx.associated_item_def_ids("}, {"sha": "69ba4840146ea795e56b53c2a38f09b5f15e52c3", "filename": "compiler/rustc_mir_transform/src/lower_intrinsics.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5292d48b85482bd3edc430e1933f5bc51eafbff4/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5292d48b85482bd3edc430e1933f5bc51eafbff4/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs?ref=5292d48b85482bd3edc430e1933f5bc51eafbff4", "patch": "@@ -179,6 +179,29 @@ impl<'tcx> MirPass<'tcx> for LowerIntrinsics {\n                             }\n                         }\n                     }\n+                    sym::write_via_move => {\n+                        let target = target.unwrap();\n+                        let Ok([ptr, val]) = <[_; 2]>::try_from(std::mem::take(args)) else {\n+                            span_bug!(\n+                                terminator.source_info.span,\n+                                \"Wrong number of arguments for write_via_move intrinsic\",\n+                            );\n+                        };\n+                        let derefed_place =\n+                            if let Some(place) = ptr.place() && let Some(local) = place.as_local() {\n+                                tcx.mk_place_deref(local.into())\n+                            } else {\n+                                span_bug!(terminator.source_info.span, \"Only passing a local is supported\");\n+                            };\n+                        block.statements.push(Statement {\n+                            source_info: terminator.source_info,\n+                            kind: StatementKind::Assign(Box::new((\n+                                derefed_place,\n+                                Rvalue::Use(val),\n+                            ))),\n+                        });\n+                        terminator.kind = TerminatorKind::Goto { target };\n+                    }\n                     sym::discriminant_value => {\n                         if let (Some(target), Some(arg)) = (*target, args[0].place()) {\n                             let arg = tcx.mk_place_deref(arg);"}, {"sha": "e7c8a08f2a17c4744efdef65e57a2f3603893ff4", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5292d48b85482bd3edc430e1933f5bc51eafbff4/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5292d48b85482bd3edc430e1933f5bc51eafbff4/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=5292d48b85482bd3edc430e1933f5bc51eafbff4", "patch": "@@ -1635,6 +1635,7 @@ symbols! {\n         write_bytes,\n         write_macro,\n         write_str,\n+        write_via_move,\n         writeln_macro,\n         x87_reg,\n         xer,"}, {"sha": "077c0fdc380bc14fee87b93d2102568d03a7ddd4", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5292d48b85482bd3edc430e1933f5bc51eafbff4/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5292d48b85482bd3edc430e1933f5bc51eafbff4/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=5292d48b85482bd3edc430e1933f5bc51eafbff4", "patch": "@@ -2257,12 +2257,23 @@ extern \"rust-intrinsic\" {\n     /// This is an implementation detail of [`crate::ptr::read`] and should\n     /// not be used anywhere else.  See its comments for why this exists.\n     ///\n-    /// This intrinsic can *only* be called where the argument is a local without\n-    /// projections (`read_via_copy(p)`, not `read_via_copy(*p)`) so that it\n+    /// This intrinsic can *only* be called where the pointer is a local without\n+    /// projections (`read_via_copy(ptr)`, not `read_via_copy(*ptr)`) so that it\n     /// trivially obeys runtime-MIR rules about derefs in operands.\n     #[rustc_const_unstable(feature = \"const_ptr_read\", issue = \"80377\")]\n     #[rustc_nounwind]\n-    pub fn read_via_copy<T>(p: *const T) -> T;\n+    pub fn read_via_copy<T>(ptr: *const T) -> T;\n+\n+    /// This is an implementation detail of [`crate::ptr::write`] and should\n+    /// not be used anywhere else.  See its comments for why this exists.\n+    ///\n+    /// This intrinsic can *only* be called where the pointer is a local without\n+    /// projections (`write_via_move(ptr, x)`, not `write_via_move(*ptr, x)`) so\n+    /// that it trivially obeys runtime-MIR rules about derefs in operands.\n+    #[cfg(not(bootstrap))]\n+    #[rustc_const_unstable(feature = \"const_ptr_write\", issue = \"86302\")]\n+    #[rustc_nounwind]\n+    pub fn write_via_move<T>(ptr: *mut T, value: T);\n \n     /// Returns the value of the discriminant for the variant in 'v';\n     /// if `T` has no discriminant, returns `0`.\n@@ -2828,3 +2839,16 @@ pub const unsafe fn transmute_unchecked<Src, Dst>(src: Src) -> Dst {\n     // SAFETY: It's a transmute -- the caller promised it's fine.\n     unsafe { transmute_copy(&ManuallyDrop::new(src)) }\n }\n+\n+/// Polyfill for bootstrap\n+#[cfg(bootstrap)]\n+pub const unsafe fn write_via_move<T>(ptr: *mut T, value: T) {\n+    use crate::mem::*;\n+    // SAFETY: the caller must guarantee that `dst` is valid for writes.\n+    // `dst` cannot overlap `src` because the caller has mutable access\n+    // to `dst` while `src` is owned by this function.\n+    unsafe {\n+        copy_nonoverlapping::<T>(&value, ptr, 1);\n+        forget(value);\n+    }\n+}"}, {"sha": "5f55f762ad555c7df6bd04afd216496113103d7a", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5292d48b85482bd3edc430e1933f5bc51eafbff4/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5292d48b85482bd3edc430e1933f5bc51eafbff4/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=5292d48b85482bd3edc430e1933f5bc51eafbff4", "patch": "@@ -1349,13 +1349,13 @@ pub const unsafe fn read_unaligned<T>(src: *const T) -> T {\n #[rustc_const_unstable(feature = \"const_ptr_write\", issue = \"86302\")]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n pub const unsafe fn write<T>(dst: *mut T, src: T) {\n-    // We are calling the intrinsics directly to avoid function calls in the generated code\n-    // as `intrinsics::copy_nonoverlapping` is a wrapper function.\n-    extern \"rust-intrinsic\" {\n-        #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n-        #[rustc_nounwind]\n-        fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n-    }\n+    // Semantically, it would be fine for this to be implemented as a\n+    // `copy_nonoverlapping` and appropriate drop suppression of `src`.\n+\n+    // However, implementing via that currently produces more MIR than is ideal.\n+    // Using an intrinsic keeps it down to just the simple `*dst = move src` in\n+    // MIR (11 statements shorter, at the time of writing), and also allows\n+    // `src` to stay an SSA value in codegen_ssa, rather than a memory one.\n \n     // SAFETY: the caller must guarantee that `dst` is valid for writes.\n     // `dst` cannot overlap `src` because the caller has mutable access\n@@ -1365,8 +1365,7 @@ pub const unsafe fn write<T>(dst: *mut T, src: T) {\n             \"ptr::write requires that the pointer argument is aligned and non-null\",\n             [T](dst: *mut T) => is_aligned_and_not_null(dst)\n         );\n-        copy_nonoverlapping(&src as *const T, dst, 1);\n-        intrinsics::forget(src);\n+        intrinsics::write_via_move(dst, src)\n     }\n }\n "}, {"sha": "81e56b5490d642183e21dda39eae1252b84f44d8", "filename": "tests/codegen/mem-replace-big-type.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5292d48b85482bd3edc430e1933f5bc51eafbff4/tests%2Fcodegen%2Fmem-replace-big-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5292d48b85482bd3edc430e1933f5bc51eafbff4/tests%2Fcodegen%2Fmem-replace-big-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fmem-replace-big-type.rs?ref=5292d48b85482bd3edc430e1933f5bc51eafbff4", "patch": "@@ -11,7 +11,9 @@\n #[repr(C, align(8))]\n pub struct Big([u64; 7]);\n pub fn replace_big(dst: &mut Big, src: Big) -> Big {\n-    // Before the `read_via_copy` intrinsic, this emitted six `memcpy`s.\n+    // Back in 1.68, this emitted six `memcpy`s.\n+    // `read_via_copy` in 1.69 got that down to three.\n+    // `write_via_move` has it down to just the two essential ones.\n     std::mem::replace(dst, src)\n }\n \n@@ -20,17 +22,13 @@ pub fn replace_big(dst: &mut Big, src: Big) -> Big {\n \n // CHECK-NOT: call void @llvm.memcpy\n \n-// For a large type, we expect exactly three `memcpy`s\n+// For a large type, we expect exactly two `memcpy`s\n // CHECK-LABEL: define internal void @{{.+}}mem{{.+}}replace{{.+}}sret(%Big)\n     // CHECK-NOT: alloca\n-    // CHECK: alloca %Big\n-    // CHECK-NOT: alloca\n-    // CHECK-NOT: call void @llvm.memcpy\n-    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 8 %{{.*}}, {{i8\\*|ptr}} align 8 %{{.*}}, i{{.*}} 56, i1 false)\n     // CHECK-NOT: call void @llvm.memcpy\n-    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 8 %{{.*}}, {{i8\\*|ptr}} align 8 %{{.*}}, i{{.*}} 56, i1 false)\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 8 %0, {{i8\\*|ptr}} align 8 %dest, i{{.*}} 56, i1 false)\n     // CHECK-NOT: call void @llvm.memcpy\n-    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 8 %{{.*}}, {{i8\\*|ptr}} align 8 %{{.*}}, i{{.*}} 56, i1 false)\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 8 %dest, {{i8\\*|ptr}} align 8 %src, i{{.*}} 56, i1 false)\n     // CHECK-NOT: call void @llvm.memcpy\n \n // CHECK-NOT: call void @llvm.memcpy"}, {"sha": "83babab4f847b150dc4d0e8301b13c7298e49e3a", "filename": "tests/codegen/mem-replace-direct-memcpy.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ca3f742ff6fe12b6bb247546189d44718f679799/tests%2Fcodegen%2Fmem-replace-direct-memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3f742ff6fe12b6bb247546189d44718f679799/tests%2Fcodegen%2Fmem-replace-direct-memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fmem-replace-direct-memcpy.rs?ref=ca3f742ff6fe12b6bb247546189d44718f679799", "patch": "@@ -1,33 +0,0 @@\n-// This test ensures that `mem::replace::<T>` only ever calls `@llvm.memcpy`\n-// with `size_of::<T>()` as the size, and never goes through any wrapper that\n-// may e.g. multiply `size_of::<T>()` with a variable \"count\" (which is only\n-// known to be `1` after inlining).\n-\n-// compile-flags: -C no-prepopulate-passes -Zinline-mir=no\n-// ignore-debug: the debug assertions get in the way\n-\n-#![crate_type = \"lib\"]\n-\n-pub fn replace_byte(dst: &mut u8, src: u8) -> u8 {\n-    std::mem::replace(dst, src)\n-}\n-\n-// NOTE(eddyb) the `CHECK-NOT`s ensure that the only calls of `@llvm.memcpy` in\n-// the entire output, are the direct calls we want, from `ptr::replace`.\n-\n-// CHECK-NOT: call void @llvm.memcpy\n-\n-// For a small type, we expect one each of `load`/`store`/`memcpy` instead\n-// CHECK-LABEL: define internal noundef i8 @{{.+}}mem{{.+}}replace\n-    // CHECK-NOT: alloca\n-    // CHECK: alloca i8\n-    // CHECK-NOT: alloca\n-    // CHECK-NOT: call void @llvm.memcpy\n-    // CHECK: load i8\n-    // CHECK-NOT: call void @llvm.memcpy\n-    // CHECK: store i8\n-    // CHECK-NOT: call void @llvm.memcpy\n-    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 1 %{{.*}}, {{i8\\*|ptr}} align 1 %{{.*}}, i{{.*}} 1, i1 false)\n-    // CHECK-NOT: call void @llvm.memcpy\n-\n-// CHECK-NOT: call void @llvm.memcpy"}, {"sha": "4253ef1366604a48c72cf2b6ca9d09d2f6b8f6c2", "filename": "tests/codegen/mem-replace-simple-type.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5292d48b85482bd3edc430e1933f5bc51eafbff4/tests%2Fcodegen%2Fmem-replace-simple-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5292d48b85482bd3edc430e1933f5bc51eafbff4/tests%2Fcodegen%2Fmem-replace-simple-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fmem-replace-simple-type.rs?ref=5292d48b85482bd3edc430e1933f5bc51eafbff4", "patch": "@@ -0,0 +1,34 @@\n+// compile-flags: -O -C no-prepopulate-passes\n+// min-llvm-version: 15.0 (for opaque pointers)\n+// only-x86_64 (to not worry about usize differing)\n+// ignore-debug (the debug assertions get in the way)\n+\n+#![crate_type = \"lib\"]\n+\n+#[no_mangle]\n+// CHECK-LABEL: @replace_usize(\n+pub fn replace_usize(r: &mut usize, v: usize) -> usize {\n+    // CHECK-NOT: alloca\n+    // CHECK: %[[R:.+]] = load i64, ptr %r\n+    // CHECK: store i64 %v, ptr %r\n+    // CHECK: ret i64 %[[R]]\n+    std::mem::replace(r, v)\n+}\n+\n+#[no_mangle]\n+// CHECK-LABEL: @replace_ref_str(\n+pub fn replace_ref_str<'a>(r: &mut &'a str, v: &'a str) -> &'a str {\n+    // CHECK-NOT: alloca\n+    // CHECK: %[[A:.+]] = load ptr\n+    // CHECK: %[[B:.+]] = load i64\n+    // CHECK-NOT: store\n+    // CHECK-NOT: load\n+    // CHECK: store ptr\n+    // CHECK: store i64\n+    // CHECK-NOT: load\n+    // CHECK-NOT: store\n+    // CHECK: %[[P1:.+]] = insertvalue { ptr, i64 } poison, ptr %[[A]], 0\n+    // CHECK: %[[P2:.+]] = insertvalue { ptr, i64 } %[[P1]], i64 %[[B]], 1\n+    // CHECK: ret { ptr, i64 } %[[P2]]\n+    std::mem::replace(r, v)\n+}"}, {"sha": "b022e2ba42bb8fb22ff2405be11f71e161c16dbd", "filename": "tests/mir-opt/lower_intrinsics.option_payload.LowerIntrinsics.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5292d48b85482bd3edc430e1933f5bc51eafbff4/tests%2Fmir-opt%2Flower_intrinsics.option_payload.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5292d48b85482bd3edc430e1933f5bc51eafbff4/tests%2Fmir-opt%2Flower_intrinsics.option_payload.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.option_payload.LowerIntrinsics.diff?ref=5292d48b85482bd3edc430e1933f5bc51eafbff4", "patch": "@@ -24,7 +24,7 @@\n           _4 = &raw const (*_1);           // scope 1 at $DIR/lower_intrinsics.rs:+2:55: +2:56\n -         _3 = option_payload_ptr::<usize>(move _4) -> [return: bb1, unwind unreachable]; // scope 1 at $DIR/lower_intrinsics.rs:+2:18: +2:57\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:132:18: 132:54\n+-                                          // + span: $DIR/lower_intrinsics.rs:137:18: 137:54\n -                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const Option<usize>) -> *const usize {option_payload_ptr::<usize>}, val: Value(<ZST>) }\n +         _3 = &raw const (((*_4) as Some).0: usize); // scope 1 at $DIR/lower_intrinsics.rs:+2:18: +2:57\n +         goto -> bb1;                     // scope 1 at $DIR/lower_intrinsics.rs:+2:18: +2:57\n@@ -37,7 +37,7 @@\n           _6 = &raw const (*_2);           // scope 2 at $DIR/lower_intrinsics.rs:+3:55: +3:56\n -         _5 = option_payload_ptr::<String>(move _6) -> [return: bb2, unwind unreachable]; // scope 2 at $DIR/lower_intrinsics.rs:+3:18: +3:57\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:133:18: 133:54\n+-                                          // + span: $DIR/lower_intrinsics.rs:138:18: 138:54\n -                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const Option<String>) -> *const String {option_payload_ptr::<String>}, val: Value(<ZST>) }\n +         _5 = &raw const (((*_6) as Some).0: std::string::String); // scope 2 at $DIR/lower_intrinsics.rs:+3:18: +3:57\n +         goto -> bb2;                     // scope 2 at $DIR/lower_intrinsics.rs:+3:18: +3:57"}, {"sha": "60a1dd0ba7d09e4757e1861fdadbec56c0d02262", "filename": "tests/mir-opt/lower_intrinsics.ptr_offset.LowerIntrinsics.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5292d48b85482bd3edc430e1933f5bc51eafbff4/tests%2Fmir-opt%2Flower_intrinsics.ptr_offset.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5292d48b85482bd3edc430e1933f5bc51eafbff4/tests%2Fmir-opt%2Flower_intrinsics.ptr_offset.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.ptr_offset.LowerIntrinsics.diff?ref=5292d48b85482bd3edc430e1933f5bc51eafbff4", "patch": "@@ -15,7 +15,7 @@\n           _4 = _2;                         // scope 0 at $DIR/lower_intrinsics.rs:+1:33: +1:34\n -         _0 = offset::<*const i32, isize>(move _3, move _4) -> [return: bb1, unwind unreachable]; // scope 0 at $DIR/lower_intrinsics.rs:+1:5: +1:35\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:139:5: 139:29\n+-                                          // + span: $DIR/lower_intrinsics.rs:144:5: 144:29\n -                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const i32, isize) -> *const i32 {offset::<*const i32, isize>}, val: Value(<ZST>) }\n +         _0 = Offset(move _3, move _4);   // scope 0 at $DIR/lower_intrinsics.rs:+1:5: +1:35\n +         goto -> bb1;                     // scope 0 at $DIR/lower_intrinsics.rs:+1:5: +1:35"}, {"sha": "0ca88a42e3fd05fef10c281bd6d618dd9cdf8ed1", "filename": "tests/mir-opt/lower_intrinsics.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5292d48b85482bd3edc430e1933f5bc51eafbff4/tests%2Fmir-opt%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5292d48b85482bd3edc430e1933f5bc51eafbff4/tests%2Fmir-opt%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.rs?ref=5292d48b85482bd3edc430e1933f5bc51eafbff4", "patch": "@@ -124,6 +124,11 @@ pub fn read_via_copy_uninhabited(r: &Never) -> Never {\n     unsafe { core::intrinsics::read_via_copy(r) }\n }\n \n+// EMIT_MIR lower_intrinsics.write_via_move_string.LowerIntrinsics.diff\n+pub fn write_via_move_string(r: &mut String, v: String) {\n+    unsafe { core::intrinsics::write_via_move(r, v) }\n+}\n+\n pub enum Never {}\n \n // EMIT_MIR lower_intrinsics.option_payload.LowerIntrinsics.diff"}, {"sha": "38d99f661dc648337c8d94bee234dbb5f21451fc", "filename": "tests/mir-opt/lower_intrinsics.write_via_move_string.LowerIntrinsics.diff", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5292d48b85482bd3edc430e1933f5bc51eafbff4/tests%2Fmir-opt%2Flower_intrinsics.write_via_move_string.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5292d48b85482bd3edc430e1933f5bc51eafbff4/tests%2Fmir-opt%2Flower_intrinsics.write_via_move_string.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.write_via_move_string.LowerIntrinsics.diff?ref=5292d48b85482bd3edc430e1933f5bc51eafbff4", "patch": "@@ -0,0 +1,36 @@\n+- // MIR for `write_via_move_string` before LowerIntrinsics\n++ // MIR for `write_via_move_string` after LowerIntrinsics\n+  \n+  fn write_via_move_string(_1: &mut String, _2: String) -> () {\n+      debug r => _1;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:30: +0:31\n+      debug v => _2;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:46: +0:47\n+      let mut _0: ();                      // return place in scope 0 at $DIR/lower_intrinsics.rs:+0:57: +0:57\n+      let mut _3: *mut std::string::String; // in scope 0 at $DIR/lower_intrinsics.rs:+1:47: +1:48\n+      let mut _4: std::string::String;     // in scope 0 at $DIR/lower_intrinsics.rs:+1:50: +1:51\n+      scope 1 {\n+      }\n+  \n+      bb0: {\n+          StorageLive(_3);                 // scope 1 at $DIR/lower_intrinsics.rs:+1:47: +1:48\n+          _3 = &raw mut (*_1);             // scope 1 at $DIR/lower_intrinsics.rs:+1:47: +1:48\n+          StorageLive(_4);                 // scope 1 at $DIR/lower_intrinsics.rs:+1:50: +1:51\n+          _4 = move _2;                    // scope 1 at $DIR/lower_intrinsics.rs:+1:50: +1:51\n+-         _0 = write_via_move::<String>(move _3, move _4) -> [return: bb1, unwind unreachable]; // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:52\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:129:14: 129:46\n+-                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*mut String, String) {write_via_move::<String>}, val: Value(<ZST>) }\n++         (*_3) = move _4;                 // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:52\n++         goto -> bb1;                     // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:52\n+      }\n+  \n+      bb1: {\n+          StorageDead(_4);                 // scope 1 at $DIR/lower_intrinsics.rs:+1:51: +1:52\n+          StorageDead(_3);                 // scope 1 at $DIR/lower_intrinsics.rs:+1:51: +1:52\n+          goto -> bb2;                     // scope 0 at $DIR/lower_intrinsics.rs:+2:1: +2:2\n+      }\n+  \n+      bb2: {\n+          return;                          // scope 0 at $DIR/lower_intrinsics.rs:+2:2: +2:2\n+      }\n+  }\n+  "}, {"sha": "50e0538c133684a4dddf1f59d0fe9d1f873f1afd", "filename": "tests/mir-opt/pre-codegen/mem_replace.mem_replace.PreCodegen.after.mir", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5292d48b85482bd3edc430e1933f5bc51eafbff4/tests%2Fmir-opt%2Fpre-codegen%2Fmem_replace.mem_replace.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/5292d48b85482bd3edc430e1933f5bc51eafbff4/tests%2Fmir-opt%2Fpre-codegen%2Fmem_replace.mem_replace.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fmem_replace.mem_replace.PreCodegen.after.mir?ref=5292d48b85482bd3edc430e1933f5bc51eafbff4", "patch": "@@ -9,29 +9,26 @@ fn mem_replace(_1: &mut u32, _2: u32) -> u32 {\n         debug src => _2;                 // in scope 1 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n         let mut _3: *const u32;          // in scope 1 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n         let mut _4: *mut u32;            // in scope 1 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n-        let mut _5: u32;                 // in scope 1 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n         scope 2 {\n             scope 3 {\n                 debug result => _0;      // in scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n                 scope 7 (inlined std::ptr::write::<u32>) { // at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n                     debug dst => _4;     // in scope 7 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-                    debug src => _5;     // in scope 7 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-                    let mut _7: *const u32; // in scope 7 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-                    let _8: &u32;        // in scope 7 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-                    let mut _9: *mut u32; // in scope 7 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                    debug src => _2;     // in scope 7 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+                    let mut _6: *mut u32; // in scope 7 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n                     scope 8 {\n                         scope 9 (inlined std::ptr::write::runtime::<u32>) { // at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-                            debug dst => _9; // in scope 9 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                            debug dst => _6; // in scope 9 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n                         }\n                     }\n                 }\n             }\n             scope 4 (inlined std::ptr::read::<u32>) { // at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n                 debug src => _3;         // in scope 4 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-                let mut _6: *const u32;  // in scope 4 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                let mut _5: *const u32;  // in scope 4 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n                 scope 5 {\n                     scope 6 (inlined std::ptr::read::runtime::<u32>) { // at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-                        debug src => _6; // in scope 6 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                        debug src => _5; // in scope 6 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n                     }\n                 }\n             }\n@@ -41,24 +38,15 @@ fn mem_replace(_1: &mut u32, _2: u32) -> u32 {\n     bb0: {\n         StorageLive(_3);                 // scope 2 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n         _3 = &raw const (*_1);           // scope 2 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n-        StorageLive(_6);                 // scope 2 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+        StorageLive(_5);                 // scope 2 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n         _0 = (*_3);                      // scope 5 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-        StorageDead(_6);                 // scope 2 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+        StorageDead(_5);                 // scope 2 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n         StorageDead(_3);                 // scope 2 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n         StorageLive(_4);                 // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n         _4 = &raw mut (*_1);             // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n-        StorageLive(_5);                 // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n-        _5 = _2;                         // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n-        StorageLive(_9);                 // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n-        StorageLive(_7);                 // scope 8 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-        StorageLive(_8);                 // scope 8 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-        _8 = &_5;                        // scope 8 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-        _7 = &raw const (*_8);           // scope 8 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-        copy_nonoverlapping(dst = _4, src = move _7, count = const 1_usize); // scope 8 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-        StorageDead(_7);                 // scope 8 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-        StorageDead(_8);                 // scope 8 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-        StorageDead(_9);                 // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n-        StorageDead(_5);                 // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+        StorageLive(_6);                 // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+        (*_4) = _2;                      // scope 8 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+        StorageDead(_6);                 // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n         StorageDead(_4);                 // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n         return;                          // scope 0 at $DIR/mem_replace.rs:+2:2: +2:2\n     }"}]}