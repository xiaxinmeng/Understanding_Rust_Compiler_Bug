{"sha": "44ce38ac9bc014df43167697ee55acf13e0ff149", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0Y2UzOGFjOWJjMDE0ZGY0MzE2NzY5N2VlNTVhY2YxM2UwZmYxNDk=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-10-04T02:44:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-04T02:44:59Z"}, "message": "Rollup merge of #77190 - jakevossen5:master, r=eddyb\n\nupdated p! macro to accept literals\n\nCloses #70948\n\nHuge thanks @eddyb for helping me out!", "tree": {"sha": "111d6f9ea8ca7a75b0a2f5c16ba259d647f3b42d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/111d6f9ea8ca7a75b0a2f5c16ba259d647f3b42d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44ce38ac9bc014df43167697ee55acf13e0ff149", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfeTcrCRBK7hj4Ov3rIwAAdHIIAIL8ndxXMC7Us19xTJMKSgkf\neqbUggNMbiehf0W/xkma5wFd/6WXoY2JBYfJLXxt8rxV5E9FE1rtUWlPz+SLWBII\n9GwewUiCgi69eAUAdRmrbDXAVyPqeqr2Ckmfod8PGKkPeDE2NTHHelQyRy3GApYe\ntLP74VdVwwa4UqW4ij8vkXdJ3+bPbM8al5szrDsGb+iIVCvNr7BoN26Cw9s4obNL\nMHUw0+9GhZ9zjcofZqz+vG+vPJgFmK8nubnXUArpzt9Hwit3IH91Wj+PFkDoyCMz\n+lN5IwQyUTzUcvbgJy+YpFPMq+D1OUILFu0Rgw0kbCedGkYMY0rVHpQMf+xmuIk=\n=eeGb\n-----END PGP SIGNATURE-----\n", "payload": "tree 111d6f9ea8ca7a75b0a2f5c16ba259d647f3b42d\nparent 65e448885b7cb208941722553bcba33b3a7f705a\nparent 018d587bc1dcd39701c12c4baefc709987f68c70\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1601779499 +0900\ncommitter GitHub <noreply@github.com> 1601779499 +0900\n\nRollup merge of #77190 - jakevossen5:master, r=eddyb\n\nupdated p! macro to accept literals\n\nCloses #70948\n\nHuge thanks @eddyb for helping me out!\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44ce38ac9bc014df43167697ee55acf13e0ff149", "html_url": "https://github.com/rust-lang/rust/commit/44ce38ac9bc014df43167697ee55acf13e0ff149", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44ce38ac9bc014df43167697ee55acf13e0ff149/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65e448885b7cb208941722553bcba33b3a7f705a", "url": "https://api.github.com/repos/rust-lang/rust/commits/65e448885b7cb208941722553bcba33b3a7f705a", "html_url": "https://github.com/rust-lang/rust/commit/65e448885b7cb208941722553bcba33b3a7f705a"}, {"sha": "018d587bc1dcd39701c12c4baefc709987f68c70", "url": "https://api.github.com/repos/rust-lang/rust/commits/018d587bc1dcd39701c12c4baefc709987f68c70", "html_url": "https://github.com/rust-lang/rust/commit/018d587bc1dcd39701c12c4baefc709987f68c70"}], "stats": {"total": 185, "additions": 89, "deletions": 96}, "files": [{"sha": "238bce94cf50529bdd5ae2f38a144d6749c2bfbc", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 89, "deletions": 96, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/44ce38ac9bc014df43167697ee55acf13e0ff149/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ce38ac9bc014df43167697ee55acf13e0ff149/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=44ce38ac9bc014df43167697ee55acf13e0ff149", "patch": "@@ -28,6 +28,9 @@ use std::ops::{Deref, DerefMut};\n use super::*;\n \n macro_rules! p {\n+    (@$lit:literal) => {\n+        write!(scoped_cx!(), $lit)?\n+    };\n     (@write($($data:expr),+)) => {\n         write!(scoped_cx!(), $($data),+)?\n     };\n@@ -37,8 +40,8 @@ macro_rules! p {\n     (@$method:ident($($arg:expr),*)) => {\n         scoped_cx!() = scoped_cx!().$method($($arg),*)?\n     };\n-    ($($kind:ident $data:tt),+) => {{\n-        $(p!(@$kind $data);)+\n+    ($($elem:tt $(($($args:tt)*))?),+) => {{\n+        $(p!(@ $elem $(($($args)*))?);)+\n     }};\n }\n macro_rules! define_scoped_cx {\n@@ -478,7 +481,7 @@ pub trait PrettyPrinter<'tcx>:\n \n             p!(print(self_ty));\n             if let Some(trait_ref) = trait_ref {\n-                p!(write(\" as \"), print(trait_ref.print_only_trait_path()));\n+                p!(\" as \", print(trait_ref.print_only_trait_path()));\n             }\n             Ok(cx)\n         })\n@@ -495,9 +498,9 @@ pub trait PrettyPrinter<'tcx>:\n         self.generic_delimiters(|mut cx| {\n             define_scoped_cx!(cx);\n \n-            p!(write(\"impl \"));\n+            p!(\"impl \");\n             if let Some(trait_ref) = trait_ref {\n-                p!(print(trait_ref.print_only_trait_path()), write(\" for \"));\n+                p!(print(trait_ref.print_only_trait_path()), \" for \");\n             }\n             p!(print(self_ty));\n \n@@ -509,8 +512,8 @@ pub trait PrettyPrinter<'tcx>:\n         define_scoped_cx!(self);\n \n         match *ty.kind() {\n-            ty::Bool => p!(write(\"bool\")),\n-            ty::Char => p!(write(\"char\")),\n+            ty::Bool => p!(\"bool\"),\n+            ty::Char => p!(\"char\"),\n             ty::Int(t) => p!(write(\"{}\", t.name_str())),\n             ty::Uint(t) => p!(write(\"{}\", t.name_str())),\n             ty::Float(t) => p!(write(\"{}\", t.name_str())),\n@@ -525,23 +528,23 @@ pub trait PrettyPrinter<'tcx>:\n                 p!(print(tm.ty))\n             }\n             ty::Ref(r, ty, mutbl) => {\n-                p!(write(\"&\"));\n+                p!(\"&\");\n                 if self.region_should_not_be_omitted(r) {\n-                    p!(print(r), write(\" \"));\n+                    p!(print(r), \" \");\n                 }\n                 p!(print(ty::TypeAndMut { ty, mutbl }))\n             }\n-            ty::Never => p!(write(\"!\")),\n+            ty::Never => p!(\"!\"),\n             ty::Tuple(ref tys) => {\n-                p!(write(\"(\"), comma_sep(tys.iter()));\n+                p!(\"(\", comma_sep(tys.iter()));\n                 if tys.len() == 1 {\n-                    p!(write(\",\"));\n+                    p!(\",\");\n                 }\n-                p!(write(\")\"))\n+                p!(\")\")\n             }\n             ty::FnDef(def_id, substs) => {\n                 let sig = self.tcx().fn_sig(def_id).subst(self.tcx(), substs);\n-                p!(print(sig), write(\" {{\"), print_value_path(def_id, substs), write(\"}}\"));\n+                p!(print(sig), \" {{\", print_value_path(def_id, substs), \"}}\");\n             }\n             ty::FnPtr(ref bare_fn) => p!(print(bare_fn)),\n             ty::Infer(infer_ty) => {\n@@ -555,7 +558,7 @@ pub trait PrettyPrinter<'tcx>:\n                     p!(write(\"{}\", infer_ty))\n                 }\n             }\n-            ty::Error(_) => p!(write(\"[type error]\")),\n+            ty::Error(_) => p!(\"[type error]\"),\n             ty::Param(ref param_ty) => p!(write(\"{}\", param_ty)),\n             ty::Bound(debruijn, bound_ty) => match bound_ty.kind {\n                 ty::BoundTyKind::Anon => self.pretty_print_bound_var(debruijn, bound_ty.var)?,\n@@ -567,11 +570,11 @@ pub trait PrettyPrinter<'tcx>:\n             ty::Dynamic(data, r) => {\n                 let print_r = self.region_should_not_be_omitted(r);\n                 if print_r {\n-                    p!(write(\"(\"));\n+                    p!(\"(\");\n                 }\n-                p!(write(\"dyn \"), print(data));\n+                p!(\"dyn \", print(data));\n                 if print_r {\n-                    p!(write(\" + \"), print(r), write(\")\"));\n+                    p!(\" + \", print(r), \")\");\n                 }\n             }\n             ty::Foreign(def_id) => {\n@@ -597,7 +600,7 @@ pub trait PrettyPrinter<'tcx>:\n                         p!(write(\"{}\", name));\n                         // FIXME(eddyb) print this with `print_def_path`.\n                         if !substs.is_empty() {\n-                            p!(write(\"::\"));\n+                            p!(\"::\");\n                             p!(generic_delimiters(|cx| cx.comma_sep(substs.iter())));\n                         }\n                         return Ok(self);\n@@ -608,7 +611,7 @@ pub trait PrettyPrinter<'tcx>:\n \n                     let mut first = true;\n                     let mut is_sized = false;\n-                    p!(write(\"impl\"));\n+                    p!(\"impl\");\n                     for predicate in bounds.predicates {\n                         // Note: We can't use `to_opt_poly_trait_ref` here as `predicate`\n                         // may contain unbound variables. We therefore do this manually.\n@@ -634,21 +637,21 @@ pub trait PrettyPrinter<'tcx>:\n                     if !is_sized {\n                         p!(write(\"{}?Sized\", if first { \" \" } else { \"+\" }));\n                     } else if first {\n-                        p!(write(\" Sized\"));\n+                        p!(\" Sized\");\n                     }\n                     Ok(self)\n                 })?);\n             }\n-            ty::Str => p!(write(\"str\")),\n+            ty::Str => p!(\"str\"),\n             ty::Generator(did, substs, movability) => {\n                 p!(write(\"[\"));\n                 match movability {\n                     hir::Movability::Movable => {}\n-                    hir::Movability::Static => p!(write(\"static \")),\n+                    hir::Movability::Static => p!(\"static \"),\n                 }\n \n                 if !self.tcx().sess.verbose() {\n-                    p!(write(\"generator\"));\n+                    p!(\"generator\");\n                     // FIXME(eddyb) should use `def_span`.\n                     if let Some(did) = did.as_local() {\n                         let hir_id = self.tcx().hir().local_def_id_to_hir_id(did);\n@@ -661,23 +664,23 @@ pub trait PrettyPrinter<'tcx>:\n                     p!(print_def_path(did, substs));\n                     if substs.as_generator().is_valid() {\n                         // Search for the first inference variable\n-                        p!(write(\" upvar_tys=(\"));\n+                        p!(\" upvar_tys=(\");\n                         let mut uninferred_ty =\n                             substs.as_generator().upvar_tys().filter(|ty| ty.is_ty_infer());\n                         if uninferred_ty.next().is_some() {\n                             p!(write(\"unavailable\"));\n                         } else {\n                             self = self.comma_sep(substs.as_generator().upvar_tys())?;\n                         }\n-                        p!(write(\")\"));\n+                        p!(\")\");\n                     }\n                 }\n \n                 if substs.as_generator().is_valid() {\n-                    p!(write(\" \"), print(substs.as_generator().witness()));\n+                    p!(\" \", print(substs.as_generator().witness()));\n                 }\n \n-                p!(write(\"]\"));\n+                p!(\"]\")\n             }\n             ty::GeneratorWitness(types) => {\n                 p!(in_binder(&types));\n@@ -690,7 +693,7 @@ pub trait PrettyPrinter<'tcx>:\n                     if let Some(did) = did.as_local() {\n                         let hir_id = self.tcx().hir().local_def_id_to_hir_id(did);\n                         if self.tcx().sess.opts.debugging_opts.span_free_formats {\n-                            p!(write(\"@\"), print_def_path(did.to_def_id(), substs));\n+                            p!(\"@\", print_def_path(did.to_def_id(), substs));\n                         } else {\n                             let span = self.tcx().hir().span(hir_id);\n                             p!(write(\"@{}\", self.tcx().sess.source_map().span_to_string(span)));\n@@ -707,40 +710,40 @@ pub trait PrettyPrinter<'tcx>:\n                         if uninferred_ty.next().is_some() {\n                             // If the upvar substs contain an inference variable we haven't\n                             // finished capture analysis.\n-                            p!(write(\" closure_substs=(unavailable)\"));\n+                            p!(\" closure_substs=(unavailable)\");\n                         } else {\n-                            p!(write(\" closure_kind_ty=\"), print(substs.as_closure().kind_ty()));\n+                            p!(\" closure_kind_ty=\", print(substs.as_closure().kind_ty()));\n                             p!(\n-                                write(\" closure_sig_as_fn_ptr_ty=\"),\n+                                \" closure_sig_as_fn_ptr_ty=\",\n                                 print(substs.as_closure().sig_as_fn_ptr_ty())\n                             );\n-                            p!(write(\" upvar_tys=(\"));\n+                            p!(\" upvar_tys=(\");\n                             self = self.comma_sep(substs.as_closure().upvar_tys())?;\n-                            p!(write(\")\"));\n+                            p!(\")\");\n                         }\n                     }\n                 }\n-                p!(write(\"]\"));\n+                p!(\"]\");\n             }\n             ty::Array(ty, sz) => {\n-                p!(write(\"[\"), print(ty), write(\"; \"));\n+                p!(\"[\", print(ty), \"; \");\n                 if self.tcx().sess.verbose() {\n                     p!(write(\"{:?}\", sz));\n                 } else if let ty::ConstKind::Unevaluated(..) = sz.val {\n                     // Do not try to evaluate unevaluated constants. If we are const evaluating an\n                     // array length anon const, rustc will (with debug assertions) print the\n                     // constant's path. Which will end up here again.\n-                    p!(write(\"_\"));\n+                    p!(\"_\");\n                 } else if let Some(n) = sz.val.try_to_bits(self.tcx().data_layout.pointer_size) {\n                     p!(write(\"{}\", n));\n                 } else if let ty::ConstKind::Param(param) = sz.val {\n                     p!(write(\"{}\", param));\n                 } else {\n-                    p!(write(\"_\"));\n+                    p!(\"_\");\n                 }\n-                p!(write(\"]\"))\n+                p!(\"]\")\n             }\n-            ty::Slice(ty) => p!(write(\"[\"), print(ty), write(\"]\")),\n+            ty::Slice(ty) => p!(\"[\", print(ty), \"]\"),\n         }\n \n         Ok(self)\n@@ -847,7 +850,7 @@ pub trait PrettyPrinter<'tcx>:\n \n         for (_, def_id) in auto_traits {\n             if !first {\n-                p!(write(\" + \"));\n+                p!(\" + \");\n             }\n             first = false;\n \n@@ -865,16 +868,16 @@ pub trait PrettyPrinter<'tcx>:\n     ) -> Result<Self, Self::Error> {\n         define_scoped_cx!(self);\n \n-        p!(write(\"(\"), comma_sep(inputs.iter().copied()));\n+        p!(\"(\", comma_sep(inputs.iter().copied()));\n         if c_variadic {\n             if !inputs.is_empty() {\n-                p!(write(\", \"));\n+                p!(\", \");\n             }\n-            p!(write(\"...\"));\n+            p!(\"...\");\n         }\n-        p!(write(\")\"));\n+        p!(\")\");\n         if !output.is_unit() {\n-            p!(write(\" -> \"), print(output));\n+            p!(\" -> \", print(output));\n         }\n \n         Ok(self)\n@@ -945,7 +948,7 @@ pub trait PrettyPrinter<'tcx>:\n                 self.pretty_print_bound_var(debruijn, bound_var)?\n             }\n             ty::ConstKind::Placeholder(placeholder) => p!(write(\"Placeholder({:?})\", placeholder)),\n-            ty::ConstKind::Error(_) => p!(write(\"[const error]\")),\n+            ty::ConstKind::Error(_) => p!(\"[const error]\"),\n         };\n         Ok(self)\n     }\n@@ -987,17 +990,17 @@ pub trait PrettyPrinter<'tcx>:\n                     {\n                         p!(pretty_print_byte_str(byte_str))\n                     } else {\n-                        p!(write(\"<too short allocation>\"))\n+                        p!(\"<too short allocation>\")\n                     }\n                 }\n                 // FIXME: for statics and functions, we could in principle print more detail.\n                 Some(GlobalAlloc::Static(def_id)) => p!(write(\"<static({:?})>\", def_id)),\n-                Some(GlobalAlloc::Function(_)) => p!(write(\"<function>\")),\n-                None => p!(write(\"<dangling pointer>\")),\n+                Some(GlobalAlloc::Function(_)) => p!(\"<function>\"),\n+                None => p!(\"<dangling pointer>\"),\n             },\n             // Bool\n-            (Scalar::Raw { data: 0, .. }, ty::Bool) => p!(write(\"false\")),\n-            (Scalar::Raw { data: 1, .. }, ty::Bool) => p!(write(\"true\")),\n+            (Scalar::Raw { data: 0, .. }, ty::Bool) => p!(\"false\"),\n+            (Scalar::Raw { data: 1, .. }, ty::Bool) => p!(\"true\"),\n             // Float\n             (Scalar::Raw { data, .. }, ty::Float(ast::FloatTy::F32)) => {\n                 p!(write(\"{}f32\", Single::from_bits(data)))\n@@ -1093,13 +1096,13 @@ pub trait PrettyPrinter<'tcx>:\n \n     fn pretty_print_byte_str(mut self, byte_str: &'tcx [u8]) -> Result<Self::Const, Self::Error> {\n         define_scoped_cx!(self);\n-        p!(write(\"b\\\"\"));\n+        p!(\"b\\\"\");\n         for &c in byte_str {\n             for e in std::ascii::escape_default(c) {\n                 self.write_char(e as char)?;\n             }\n         }\n-        p!(write(\"\\\"\"));\n+        p!(\"\\\"\");\n         Ok(self)\n     }\n \n@@ -1112,7 +1115,7 @@ pub trait PrettyPrinter<'tcx>:\n         define_scoped_cx!(self);\n \n         if self.tcx().sess.verbose() {\n-            p!(write(\"ConstValue({:?}: \", ct), print(ty), write(\")\"));\n+            p!(write(\"ConstValue({:?}: \", ct), print(ty), \")\");\n             return Ok(self);\n         }\n \n@@ -1149,7 +1152,7 @@ pub trait PrettyPrinter<'tcx>:\n                 let ptr = Pointer::new(AllocId(0), offset);\n \n                 let byte_str = alloc.get_bytes(&self.tcx(), ptr, n).unwrap();\n-                p!(write(\"*\"));\n+                p!(\"*\");\n                 p!(pretty_print_byte_str(byte_str));\n                 Ok(self)\n             }\n@@ -1173,14 +1176,14 @@ pub trait PrettyPrinter<'tcx>:\n \n                 match *ty.kind() {\n                     ty::Array(..) => {\n-                        p!(write(\"[\"), comma_sep(fields), write(\"]\"));\n+                        p!(\"[\", comma_sep(fields), \"]\");\n                     }\n                     ty::Tuple(..) => {\n-                        p!(write(\"(\"), comma_sep(fields));\n+                        p!(\"(\", comma_sep(fields));\n                         if contents.fields.len() == 1 {\n-                            p!(write(\",\"));\n+                            p!(\",\");\n                         }\n-                        p!(write(\")\"));\n+                        p!(\")\");\n                     }\n                     ty::Adt(def, substs) if def.variants.is_empty() => {\n                         p!(print_value_path(def.did, substs));\n@@ -1194,19 +1197,19 @@ pub trait PrettyPrinter<'tcx>:\n                         match variant_def.ctor_kind {\n                             CtorKind::Const => {}\n                             CtorKind::Fn => {\n-                                p!(write(\"(\"), comma_sep(fields), write(\")\"));\n+                                p!(\"(\", comma_sep(fields), \")\");\n                             }\n                             CtorKind::Fictive => {\n-                                p!(write(\" {{ \"));\n+                                p!(\" {{ \");\n                                 let mut first = true;\n                                 for (field_def, field) in variant_def.fields.iter().zip(fields) {\n                                     if !first {\n-                                        p!(write(\", \"));\n+                                        p!(\", \");\n                                     }\n                                     p!(write(\"{}: \", field_def.ident), print(field));\n                                     first = false;\n                                 }\n-                                p!(write(\" }}\"));\n+                                p!(\" }}\");\n                             }\n                         }\n                     }\n@@ -1224,7 +1227,7 @@ pub trait PrettyPrinter<'tcx>:\n                 // fallback\n                 p!(write(\"{:?}\", ct));\n                 if print_ty {\n-                    p!(write(\": \"), print(ty));\n+                    p!(\": \", print(ty));\n                 }\n                 Ok(self)\n             }\n@@ -1637,7 +1640,7 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n             if this.print_alloc_ids {\n                 p!(write(\"{:?}\", p));\n             } else {\n-                p!(write(\"&_\"));\n+                p!(\"&_\");\n             }\n             Ok(this)\n         };\n@@ -1703,11 +1706,11 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n             ty::ReVar(_) => {}\n             ty::ReErased => {}\n             ty::ReStatic => {\n-                p!(write(\"'static\"));\n+                p!(\"'static\");\n                 return Ok(self);\n             }\n             ty::ReEmpty(ty::UniverseIndex::ROOT) => {\n-                p!(write(\"'<empty>\"));\n+                p!(\"'<empty>\");\n                 return Ok(self);\n             }\n             ty::ReEmpty(ui) => {\n@@ -1716,7 +1719,7 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n             }\n         }\n \n-        p!(write(\"'_\"));\n+        p!(\"'_\");\n \n         Ok(self)\n     }\n@@ -1847,7 +1850,7 @@ where\n     type Error = P::Error;\n     fn print(&self, mut cx: P) -> Result<Self::Output, Self::Error> {\n         define_scoped_cx!(cx);\n-        p!(print(self.0), write(\": \"), print(self.1));\n+        p!(print(self.0), \": \", print(self.1));\n         Ok(cx)\n     }\n }\n@@ -1945,7 +1948,7 @@ define_print_and_forward_display! {\n     (self, cx):\n \n     &'tcx ty::List<Ty<'tcx>> {\n-        p!(write(\"{{\"), comma_sep(self.iter()), write(\"}}\"))\n+        p!(\"{{\", comma_sep(self.iter()), \"}}\")\n     }\n \n     ty::TypeAndMut<'tcx> {\n@@ -1981,7 +1984,7 @@ define_print_and_forward_display! {\n             p!(write(\"extern {} \", self.abi));\n         }\n \n-        p!(write(\"fn\"), pretty_fn_sig(self.inputs(), self.c_variadic, self.output()));\n+        p!(\"fn\", pretty_fn_sig(self.inputs(), self.c_variadic, self.output()));\n     }\n \n     ty::InferTy {\n@@ -1990,7 +1993,7 @@ define_print_and_forward_display! {\n             return Ok(cx);\n         }\n         match *self {\n-            ty::TyVar(_) => p!(write(\"_\")),\n+            ty::TyVar(_) => p!(\"_\"),\n             ty::IntVar(_) => p!(write(\"{}\", \"{integer}\")),\n             ty::FloatVar(_) => p!(write(\"{}\", \"{float}\")),\n             ty::FreshTy(v) => p!(write(\"FreshTy({})\", v)),\n@@ -2016,16 +2019,16 @@ define_print_and_forward_display! {\n     }\n \n     ty::SubtypePredicate<'tcx> {\n-        p!(print(self.a), write(\" <: \"), print(self.b))\n+        p!(print(self.a), \" <: \", print(self.b))\n     }\n \n     ty::TraitPredicate<'tcx> {\n-        p!(print(self.trait_ref.self_ty()), write(\": \"),\n+        p!(print(self.trait_ref.self_ty()), \": \",\n            print(self.trait_ref.print_only_trait_path()))\n     }\n \n     ty::ProjectionPredicate<'tcx> {\n-        p!(print(self.projection_ty), write(\" == \"), print(self.ty))\n+        p!(print(self.projection_ty), \" == \", print(self.ty))\n     }\n \n     ty::ProjectionTy<'tcx> {\n@@ -2034,9 +2037,9 @@ define_print_and_forward_display! {\n \n     ty::ClosureKind {\n         match *self {\n-            ty::ClosureKind::Fn => p!(write(\"Fn\")),\n-            ty::ClosureKind::FnMut => p!(write(\"FnMut\")),\n-            ty::ClosureKind::FnOnce => p!(write(\"FnOnce\")),\n+            ty::ClosureKind::Fn => p!(\"Fn\"),\n+            ty::ClosureKind::FnMut => p!(\"FnMut\"),\n+            ty::ClosureKind::FnOnce => p!(\"FnOnce\"),\n         }\n     }\n \n@@ -2051,41 +2054,31 @@ define_print_and_forward_display! {\n         match *self {\n             ty::PredicateAtom::Trait(ref data, constness) => {\n                 if let hir::Constness::Const = constness {\n-                    p!(write(\"const \"));\n+                    p!(\"const \");\n                 }\n                 p!(print(data))\n             }\n             ty::PredicateAtom::Subtype(predicate) => p!(print(predicate)),\n             ty::PredicateAtom::RegionOutlives(predicate) => p!(print(predicate)),\n             ty::PredicateAtom::TypeOutlives(predicate) => p!(print(predicate)),\n             ty::PredicateAtom::Projection(predicate) => p!(print(predicate)),\n-            ty::PredicateAtom::WellFormed(arg) => p!(print(arg), write(\" well-formed\")),\n+            ty::PredicateAtom::WellFormed(arg) => p!(print(arg), \" well-formed\"),\n             ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n-                p!(write(\"the trait `\"),\n-                print_def_path(trait_def_id, &[]),\n-                write(\"` is object-safe\"))\n+                p!(\"the trait `\", print_def_path(trait_def_id, &[]), \"` is object-safe\")\n             }\n             ty::PredicateAtom::ClosureKind(closure_def_id, _closure_substs, kind) => {\n-                p!(write(\"the closure `\"),\n+                p!(\"the closure `\",\n                 print_value_path(closure_def_id, &[]),\n                 write(\"` implements the trait `{}`\", kind))\n             }\n             ty::PredicateAtom::ConstEvaluatable(def, substs) => {\n-                p!(write(\"the constant `\"),\n-                print_value_path(def.did, substs),\n-                write(\"` can be evaluated\"))\n+                p!(\"the constant `\", print_value_path(def.did, substs), \"` can be evaluated\")\n             }\n             ty::PredicateAtom::ConstEquate(c1, c2) => {\n-                p!(write(\"the constant `\"),\n-                print(c1),\n-                write(\"` equals `\"),\n-                print(c2),\n-                write(\"`\"))\n+                p!(\"the constant `\", print(c1), \"` equals `\", print(c2), \"`\")\n             }\n             ty::PredicateAtom::TypeWellFormedFromEnv(ty) => {\n-                p!(write(\"the type `\"),\n-                print(ty),\n-                write(\"` is found in the environment\"))\n+                p!(\"the type `\", print(ty), \"` is found in the environment\")\n             }\n         }\n     }"}]}