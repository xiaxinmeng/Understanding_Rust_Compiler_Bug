{"sha": "0c5930ef256131f8d0e4f020a5029a89944cf250", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjNTkzMGVmMjU2MTMxZjhkMGU0ZjAyMGE1MDI5YTg5OTQ0Y2YyNTA=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-06-07T16:21:56Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-06-07T16:21:56Z"}, "message": "mir: group span + visibility scope under a new SourceInfo type.", "tree": {"sha": "f5b4fcf59d7493a2efb1a7ec80bd03b1f05a3c58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5b4fcf59d7493a2efb1a7ec80bd03b1f05a3c58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c5930ef256131f8d0e4f020a5029a89944cf250", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c5930ef256131f8d0e4f020a5029a89944cf250", "html_url": "https://github.com/rust-lang/rust/commit/0c5930ef256131f8d0e4f020a5029a89944cf250", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c5930ef256131f8d0e4f020a5029a89944cf250/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "719a5916303704792b02304333195b69a03cfff2", "url": "https://api.github.com/repos/rust-lang/rust/commits/719a5916303704792b02304333195b69a03cfff2", "html_url": "https://github.com/rust-lang/rust/commit/719a5916303704792b02304333195b69a03cfff2"}], "stats": {"total": 527, "additions": 255, "deletions": 272}, "files": [{"sha": "e6c22d0ea3446076fe097d915197d34694068bac", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -100,6 +100,18 @@ impl<'tcx> IndexMut<BasicBlock> for Mir<'tcx> {\n     }\n }\n \n+/// Grouped information about the source code origin of a MIR entity.\n+/// Intended to be inspected by diagnostics and debuginfo.\n+/// Most passes can work with it as a whole, within a single function.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+pub struct SourceInfo {\n+    /// Source span for the AST pertaining to this MIR entity.\n+    pub span: Span,\n+\n+    /// The lexical visibility scope, i.e. which bindings can be seen.\n+    pub scope: VisibilityScope\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Mutability and borrow kinds\n \n@@ -172,11 +184,8 @@ pub struct VarDecl<'tcx> {\n     /// type inferred for this variable (`let x: ty = ...`)\n     pub ty: Ty<'tcx>,\n \n-    /// scope in which variable was declared\n-    pub scope: VisibilityScope,\n-\n-    /// span where variable was declared\n-    pub span: Span,\n+    /// source information (span, scope, etc.) for the declaration\n+    pub source_info: SourceInfo,\n }\n \n /// A \"temp\" is a temporary that we place on the stack. They are\n@@ -275,8 +284,7 @@ pub struct BasicBlockData<'tcx> {\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct Terminator<'tcx> {\n-    pub span: Span,\n-    pub scope: VisibilityScope,\n+    pub source_info: SourceInfo,\n     pub kind: TerminatorKind<'tcx>\n }\n \n@@ -587,8 +595,7 @@ pub enum AssertMessage<'tcx> {\n \n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Statement<'tcx> {\n-    pub span: Span,\n-    pub scope: VisibilityScope,\n+    pub source_info: SourceInfo,\n     pub kind: StatementKind<'tcx>,\n }\n "}, {"sha": "dbe48d6b09447735b02605c44ef9e4871184d060", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -186,6 +186,11 @@ macro_rules! make_mir_visitor {\n                 self.super_span(span);\n             }\n \n+            fn visit_source_info(&mut self,\n+                                 source_info: & $($mutability)* SourceInfo) {\n+                self.super_source_info(source_info);\n+            }\n+\n             fn visit_fn_output(&mut self,\n                                fn_output: & $($mutability)* FnOutput<'tcx>) {\n                 self.super_fn_output(fn_output);\n@@ -319,13 +324,11 @@ macro_rules! make_mir_visitor {\n                                block: BasicBlock,\n                                statement: & $($mutability)* Statement<'tcx>) {\n                 let Statement {\n-                    ref $($mutability)* span,\n-                    ref $($mutability)* scope,\n+                    ref $($mutability)* source_info,\n                     ref $($mutability)* kind,\n                 } = *statement;\n \n-                self.visit_span(span);\n-                self.visit_visibility_scope(scope);\n+                self.visit_source_info(source_info);\n                 match *kind {\n                     StatementKind::Assign(ref $($mutability)* lvalue,\n                                           ref $($mutability)* rvalue) => {\n@@ -346,13 +349,11 @@ macro_rules! make_mir_visitor {\n                                 block: BasicBlock,\n                                 terminator: &$($mutability)* Terminator<'tcx>) {\n                 let Terminator {\n-                    ref $($mutability)* span,\n-                    ref $($mutability)* scope,\n+                    ref $($mutability)* source_info,\n                     ref $($mutability)* kind,\n                 } = *terminator;\n \n-                self.visit_span(span);\n-                self.visit_visibility_scope(scope);\n+                self.visit_source_info(source_info);\n                 self.visit_terminator_kind(block, kind);\n             }\n \n@@ -622,13 +623,11 @@ macro_rules! make_mir_visitor {\n                     mutability: _,\n                     name: _,\n                     ref $($mutability)* ty,\n-                    ref $($mutability)* scope,\n-                    ref $($mutability)* span,\n+                    ref $($mutability)* source_info,\n                 } = *var_decl;\n \n                 self.visit_ty(ty);\n-                self.visit_visibility_scope(scope);\n-                self.visit_span(span);\n+                self.visit_source_info(source_info);\n             }\n \n             fn super_temp_decl(&mut self,\n@@ -707,6 +706,16 @@ macro_rules! make_mir_visitor {\n             fn super_span(&mut self, _span: & $($mutability)* Span) {\n             }\n \n+            fn super_source_info(&mut self, source_info: & $($mutability)* SourceInfo) {\n+                let SourceInfo {\n+                    ref $($mutability)* span,\n+                    ref $($mutability)* scope,\n+                } = *source_info;\n+\n+                self.visit_span(span);\n+                self.visit_visibility_scope(scope);\n+            }\n+\n             fn super_fn_output(&mut self, fn_output: & $($mutability)* FnOutput<'tcx>) {\n                 match *fn_output {\n                     FnOutput::FnConverging(ref $($mutability)* ty) => {"}, {"sha": "8c528f10b57ba205e4e65a2661d69d971f232125", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -151,7 +151,7 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn is_rustc_peek<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            terminator: &'a Option<repr::Terminator<'tcx>>)\n                            -> Option<(&'a [repr::Operand<'tcx>], Span)> {\n-    if let Some(repr::Terminator { ref kind, span, .. }) = *terminator {\n+    if let Some(repr::Terminator { ref kind, source_info, .. }) = *terminator {\n         if let repr::TerminatorKind::Call { func: ref oper, ref args, .. } = *kind\n         {\n             if let repr::Operand::Constant(ref func) = *oper\n@@ -161,7 +161,7 @@ fn is_rustc_peek<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     let name = tcx.item_name(def_id);\n                     if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n                         if name.as_str() == \"rustc_peek\" {\n-                            return Some((args, span));\n+                            return Some((args, source_info.span));\n                         }\n                     }\n                 }"}, {"sha": "b09db70e7b88aa391a3aac8032bbe7aaa0e79b17", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -124,8 +124,7 @@ struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n \n #[derive(Copy, Clone, Debug)]\n struct DropCtxt<'a, 'tcx: 'a> {\n-    span: Span,\n-    scope: ScopeId,\n+    source_info: SourceInfo,\n     is_cleanup: bool,\n \n     init_data: &'a InitializationData,\n@@ -273,8 +272,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                     let init_data = self.initialization_data_at(loc);\n                     let path = self.move_data().rev_lookup.find(location);\n                     self.elaborate_drop(&DropCtxt {\n-                        span: terminator.span,\n-                        scope: terminator.scope,\n+                        source_info: terminator.source_info,\n                         is_cleanup: data.is_cleanup,\n                         init_data: &init_data,\n                         lvalue: location,\n@@ -329,8 +327,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n         let assign = Statement {\n             kind: StatementKind::Assign(location.clone(), Rvalue::Use(value.clone())),\n-            span: terminator.span,\n-            scope: terminator.scope\n+            source_info: terminator.source_info\n         };\n \n         let unwind = unwind.unwrap_or(self.patch.resume_block());\n@@ -367,8 +364,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             let path = self.move_data().rev_lookup.find(location);\n \n             self.elaborate_drop(&DropCtxt {\n-                span: terminator.span,\n-                scope: terminator.scope,\n+                source_info: terminator.source_info,\n                 is_cleanup: data.is_cleanup,\n                 init_data: &init_data,\n                 lvalue: location,\n@@ -513,8 +509,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                     debug!(\"drop_ladder: for std field {} ({:?})\", i, lv);\n \n                     self.elaborated_drop_block(&DropCtxt {\n-                        span: c.span,\n-                        scope: c.scope,\n+                        source_info: c.source_info,\n                         is_cleanup: is_cleanup,\n                         init_data: c.init_data,\n                         lvalue: lv,\n@@ -527,8 +522,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                     debug!(\"drop_ladder: for rest field {} ({:?})\", i, lv);\n \n                     let blk = self.complete_drop(&DropCtxt {\n-                        span: c.span,\n-                        scope: c.scope,\n+                        source_info: c.source_info,\n                         is_cleanup: is_cleanup,\n                         init_data: c.init_data,\n                         lvalue: lv,\n@@ -785,7 +779,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         self.patch.new_block(BasicBlockData {\n             statements: vec![],\n             terminator: Some(Terminator {\n-                scope: c.scope, span: c.span, kind: k\n+                source_info: c.source_info, kind: k\n             }),\n             is_cleanup: is_cleanup\n         })\n@@ -858,11 +852,10 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         let mut statements = vec![];\n         if let Some(&flag) = self.drop_flags.get(&c.path) {\n             statements.push(Statement {\n-                span: c.span,\n-                scope: c.scope,\n+                source_info: c.source_info,\n                 kind: StatementKind::Assign(\n                     Lvalue::Temp(flag),\n-                    self.constant_bool(c.span, false)\n+                    self.constant_bool(c.source_info.span, false)\n                 )\n             });\n         }\n@@ -880,9 +873,9 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         self.patch.new_block(BasicBlockData {\n             statements: statements,\n             terminator: Some(Terminator {\n-                scope: c.scope, span: c.span, kind: TerminatorKind::Call {\n+                source_info: c.source_info, kind: TerminatorKind::Call {\n                     func: Operand::Constant(Constant {\n-                        span: c.span,\n+                        span: c.source_info.span,\n                         ty: fty,\n                         literal: Literal::Item {\n                             def_id: free_func,\n@@ -910,7 +903,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             ty::TyStruct(def, _) | ty::TyEnum(def, _) => {\n                 if def.has_dtor() {\n                     self.tcx.sess.span_warn(\n-                        c.span,\n+                        c.source_info.span,\n                         &format!(\"dataflow bug??? moving out of type with dtor {:?}\",\n                                  c));\n                     true\n@@ -932,15 +925,15 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n     fn set_drop_flag(&mut self, loc: Location, path: MovePathIndex, val: DropFlagState) {\n         if let Some(&flag) = self.drop_flags.get(&path) {\n-            let span = self.patch.context_for_location(self.mir, loc).0;\n+            let span = self.patch.source_info_for_location(self.mir, loc).span;\n             let val = self.constant_bool(span, val.value());\n             self.patch.add_assign(loc, Lvalue::Temp(flag), val);\n         }\n     }\n \n     fn drop_flags_on_init(&mut self) {\n         let loc = Location { block: START_BLOCK, index: 0 };\n-        let span = self.patch.context_for_location(self.mir, loc).0;\n+        let span = self.patch.source_info_for_location(self.mir, loc).span;\n         let false_ = self.constant_bool(span, false);\n         for flag in self.drop_flags.values() {\n             self.patch.add_assign(loc, Lvalue::Temp(*flag), false_.clone());"}, {"sha": "b838881251da320fee3586c1e1e1a0d6f4e89c6f", "filename": "src/librustc_borrowck/borrowck/mir/patch.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -11,7 +11,6 @@\n use super::gather_moves::Location;\n use rustc::ty::Ty;\n use rustc::mir::repr::*;\n-use syntax::codemap::Span;\n \n use std::iter;\n use std::u32;\n@@ -62,8 +61,10 @@ impl<'tcx> MirPatch<'tcx> {\n             result.new_block(BasicBlockData {\n                 statements: vec![],\n                 terminator: Some(Terminator {\n-                    span: mir.span,\n-                    scope: ScopeId::new(0),\n+                    source_info: SourceInfo {\n+                        span: mir.span,\n+                        scope: ARGUMENT_VISIBILITY_SCOPE\n+                    },\n                     kind: TerminatorKind::Resume\n                 }),\n                 is_cleanup: true\n@@ -154,31 +155,30 @@ impl<'tcx> MirPatch<'tcx> {\n             debug!(\"MirPatch: adding statement {:?} at loc {:?}+{}\",\n                    stmt, loc, delta);\n             loc.index += delta;\n-            let (span, scope) = Self::context_for_index(\n+            let source_info = Self::source_info_for_index(\n                 mir.basic_block_data(loc.block), loc\n             );\n             mir.basic_block_data_mut(loc.block).statements.insert(\n                 loc.index, Statement {\n-                    span: span,\n-                    scope: scope,\n+                    source_info: source_info,\n                     kind: stmt\n                 });\n             delta += 1;\n         }\n     }\n \n-    pub fn context_for_index(data: &BasicBlockData, loc: Location) -> (Span, ScopeId) {\n+    pub fn source_info_for_index(data: &BasicBlockData, loc: Location) -> SourceInfo {\n         match data.statements.get(loc.index) {\n-            Some(stmt) => (stmt.span, stmt.scope),\n-            None => (data.terminator().span, data.terminator().scope)\n+            Some(stmt) => stmt.source_info,\n+            None => data.terminator().source_info\n         }\n     }\n \n-    pub fn context_for_location(&self, mir: &Mir, loc: Location) -> (Span, ScopeId) {\n+    pub fn source_info_for_location(&self, mir: &Mir, loc: Location) -> SourceInfo {\n         let data = match loc.block.index().checked_sub(mir.basic_blocks.len()) {\n             Some(new) => &self.new_blocks[new],\n             None => mir.basic_block_data(loc.block)\n         };\n-        Self::context_for_index(data, loc)\n+        Self::source_info_for_index(data, loc)\n     }\n }"}, {"sha": "7e650c5bd3d06c03f34c3f9494ff1e8ec4df2a8f", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -83,8 +83,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 unpack!(block = this.into(destination, block, expr));\n             } else if dest_is_unit {\n                 // FIXME(#31472)\n-                let scope_id = this.innermost_scope_id();\n-                this.cfg.push_assign_unit(block, scope_id, span, destination);\n+                let source_info = this.source_info(span);\n+                this.cfg.push_assign_unit(block, source_info, destination);\n             }\n             // Finally, we pop all the let scopes before exiting out from the scope of block\n             // itself."}, {"sha": "95f87bf83261400414835ec98c9c6937ee1160c7", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -15,7 +15,6 @@\n \n use build::{CFG, Location};\n use rustc::mir::repr::*;\n-use syntax::codemap::Span;\n \n impl<'tcx> CFG<'tcx> {\n     pub fn block_data(&self, blk: BasicBlock) -> &BasicBlockData<'tcx> {\n@@ -50,47 +49,41 @@ impl<'tcx> CFG<'tcx> {\n \n     pub fn push_assign(&mut self,\n                        block: BasicBlock,\n-                       scope: VisibilityScope,\n-                       span: Span,\n+                       source_info: SourceInfo,\n                        lvalue: &Lvalue<'tcx>,\n                        rvalue: Rvalue<'tcx>) {\n         self.push(block, Statement {\n-            scope: scope,\n-            span: span,\n+            source_info: source_info,\n             kind: StatementKind::Assign(lvalue.clone(), rvalue)\n         });\n     }\n \n     pub fn push_assign_constant(&mut self,\n                                 block: BasicBlock,\n-                                scope: VisibilityScope,\n-                                span: Span,\n+                                source_info: SourceInfo,\n                                 temp: &Lvalue<'tcx>,\n                                 constant: Constant<'tcx>) {\n-        self.push_assign(block, scope, span, temp,\n+        self.push_assign(block, source_info, temp,\n                          Rvalue::Use(Operand::Constant(constant)));\n     }\n \n     pub fn push_assign_unit(&mut self,\n                             block: BasicBlock,\n-                            scope: VisibilityScope,\n-                            span: Span,\n+                            source_info: SourceInfo,\n                             lvalue: &Lvalue<'tcx>) {\n-        self.push_assign(block, scope, span, lvalue, Rvalue::Aggregate(\n+        self.push_assign(block, source_info, lvalue, Rvalue::Aggregate(\n             AggregateKind::Tuple, vec![]\n         ));\n     }\n \n     pub fn terminate(&mut self,\n                      block: BasicBlock,\n-                     scope: VisibilityScope,\n-                     span: Span,\n+                     source_info: SourceInfo,\n                      kind: TerminatorKind<'tcx>) {\n         debug_assert!(self.block_data(block).terminator.is_none(),\n                       \"terminate: block {:?} already has a terminator set\", block);\n         self.block_data_mut(block).terminator = Some(Terminator {\n-            span: span,\n-            scope: scope,\n+            source_info: source_info,\n             kind: kind,\n         });\n     }"}, {"sha": "8e33cfa9b0b52241e4f1db275f96aa3af855bc67", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -34,8 +34,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         debug!(\"expr_as_lvalue(block={:?}, expr={:?})\", block, expr);\n \n         let this = self;\n-        let scope_id = this.innermost_scope_id();\n         let expr_span = expr.span;\n+        let source_info = this.source_info(expr_span);\n         match expr.kind {\n             ExprKind::Scope { extent, value } => {\n                 this.in_scope(extent, block, |this| this.as_lvalue(block, value))\n@@ -59,9 +59,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 // bounds check:\n                 let (len, lt) = (this.temp(usize_ty.clone()), this.temp(bool_ty));\n-                this.cfg.push_assign(block, scope_id, expr_span, // len = len(slice)\n+                this.cfg.push_assign(block, source_info, // len = len(slice)\n                                      &len, Rvalue::Len(slice.clone()));\n-                this.cfg.push_assign(block, scope_id, expr_span, // lt = idx < len\n+                this.cfg.push_assign(block, source_info, // lt = idx < len\n                                      &lt, Rvalue::BinaryOp(BinOp::Lt,\n                                                            idx.clone(),\n                                                            Operand::Consume(len.clone())));"}, {"sha": "6524124c13b06a6abd771deba8e13d94376958a8", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -41,8 +41,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         debug!(\"expr_as_rvalue(block={:?}, expr={:?})\", block, expr);\n \n         let this = self;\n-        let scope_id = this.innermost_scope_id();\n         let expr_span = expr.span;\n+        let source_info = this.source_info(expr_span);\n \n         match expr.kind {\n             ExprKind::Scope { extent, value } => {\n@@ -86,7 +86,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let minval = this.minval_literal(expr_span, expr.ty);\n                     let is_min = this.temp(bool_ty);\n \n-                    this.cfg.push_assign(block, scope_id, expr_span, &is_min,\n+                    this.cfg.push_assign(block, source_info, &is_min,\n                                          Rvalue::BinaryOp(BinOp::Eq, arg.clone(), minval));\n \n                     let err = ConstMathErr::Overflow(Op::Neg);\n@@ -99,7 +99,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let value = this.hir.mirror(value);\n                 let result = this.temp(expr.ty);\n                 // to start, malloc some memory of suitable type (thus far, uninitialized):\n-                this.cfg.push_assign(block, scope_id, expr_span, &result, Rvalue::Box(value.ty));\n+                this.cfg.push_assign(block, source_info, &result, Rvalue::Box(value.ty));\n                 this.in_scope(value_extents, block, |this| {\n                     // schedule a shallow free of that memory, lest we unwind:\n                     this.schedule_box_free(expr_span, value_extents, &result, value.ty);\n@@ -245,13 +245,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn build_binary_op(&mut self, mut block: BasicBlock,\n                            op: BinOp, span: Span, ty: ty::Ty<'tcx>,\n                            lhs: Operand<'tcx>, rhs: Operand<'tcx>) -> BlockAnd<Rvalue<'tcx>> {\n-        let scope_id = self.innermost_scope_id();\n+        let source_info = self.source_info(span);\n         let bool_ty = self.hir.bool_ty();\n         if self.hir.check_overflow() && op.is_checkable() && ty.is_integral() {\n             let result_tup = self.hir.tcx().mk_tup(vec![ty, bool_ty]);\n             let result_value = self.temp(result_tup);\n \n-            self.cfg.push_assign(block, scope_id, span,\n+            self.cfg.push_assign(block, source_info,\n                                  &result_value, Rvalue::CheckedBinaryOp(op,\n                                                                         lhs,\n                                                                         rhs));\n@@ -292,7 +292,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // Check for / 0\n                 let is_zero = self.temp(bool_ty);\n                 let zero = self.zero_literal(span, ty);\n-                self.cfg.push_assign(block, scope_id, span, &is_zero,\n+                self.cfg.push_assign(block, source_info, &is_zero,\n                                      Rvalue::BinaryOp(BinOp::Eq, rhs.clone(), zero));\n \n                 block = self.assert(block, Operand::Consume(is_zero), false,\n@@ -310,14 +310,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                     // this does (rhs == -1) & (lhs == MIN). It could short-circuit instead\n \n-                    self.cfg.push_assign(block, scope_id, span, &is_neg_1,\n+                    self.cfg.push_assign(block, source_info, &is_neg_1,\n                                          Rvalue::BinaryOp(BinOp::Eq, rhs.clone(), neg_1));\n-                    self.cfg.push_assign(block, scope_id, span, &is_min,\n+                    self.cfg.push_assign(block, source_info, &is_min,\n                                          Rvalue::BinaryOp(BinOp::Eq, lhs.clone(), min));\n \n                     let is_neg_1 = Operand::Consume(is_neg_1);\n                     let is_min = Operand::Consume(is_min);\n-                    self.cfg.push_assign(block, scope_id, span, &of,\n+                    self.cfg.push_assign(block, source_info, &of,\n                                          Rvalue::BinaryOp(BinOp::BitAnd, is_neg_1, is_min));\n \n                     block = self.assert(block, Operand::Consume(of), false,"}, {"sha": "da128b8dd56266ada2214ddb9c5241505d11643d", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -49,8 +49,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             Category::Lvalue => {\n                 let lvalue = unpack!(block = this.as_lvalue(block, expr));\n                 let rvalue = Rvalue::Use(Operand::Consume(lvalue));\n-                let scope_id = this.innermost_scope_id();\n-                this.cfg.push_assign(block, scope_id, expr_span, &temp, rvalue);\n+                let source_info = this.source_info(expr_span);\n+                this.cfg.push_assign(block, source_info, &temp, rvalue);\n             }\n             _ => {\n                 unpack!(block = this.into(&temp, block, expr));"}, {"sha": "fd9ddc05ab5c4cfb3533fc42aadc4b2fce37d07d", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 17, "deletions": 34, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -33,7 +33,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // just use the name `this` uniformly\n         let this = self;\n         let expr_span = expr.span;\n-        let scope_id = this.innermost_scope_id();\n+        let source_info = this.source_info(expr_span);\n \n         match expr.kind {\n             ExprKind::Scope { extent, value } => {\n@@ -50,7 +50,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 let mut then_block = this.cfg.start_new_block();\n                 let mut else_block = this.cfg.start_new_block();\n-                this.cfg.terminate(block, scope_id, expr_span, TerminatorKind::If {\n+                this.cfg.terminate(block, source_info, TerminatorKind::If {\n                     cond: operand,\n                     targets: (then_block, else_block)\n                 });\n@@ -61,19 +61,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 } else {\n                     // Body of the `if` expression without an `else` clause must return `()`, thus\n                     // we implicitly generate a `else {}` if it is not specified.\n-                    let scope_id = this.innermost_scope_id();\n-                    this.cfg.push_assign_unit(else_block, scope_id, expr_span, destination);\n+                    this.cfg.push_assign_unit(else_block, source_info, destination);\n                     else_block\n                 };\n \n                 let join_block = this.cfg.start_new_block();\n-                this.cfg.terminate(then_block,\n-                                   scope_id,\n-                                   expr_span,\n+                this.cfg.terminate(then_block, source_info,\n                                    TerminatorKind::Goto { target: join_block });\n-                this.cfg.terminate(else_block,\n-                                   scope_id,\n-                                   expr_span,\n+                this.cfg.terminate(else_block, source_info,\n                                    TerminatorKind::Goto { target: join_block });\n \n                 join_block.unit()\n@@ -100,40 +95,34 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     LogicalOp::And => (else_block, false_block),\n                     LogicalOp::Or => (true_block, else_block),\n                 };\n-                this.cfg.terminate(block,\n-                                   scope_id,\n-                                   expr_span,\n+                this.cfg.terminate(block, source_info,\n                                    TerminatorKind::If { cond: lhs, targets: blocks });\n \n                 let rhs = unpack!(else_block = this.as_operand(else_block, rhs));\n-                this.cfg.terminate(else_block, scope_id, expr_span, TerminatorKind::If {\n+                this.cfg.terminate(else_block, source_info, TerminatorKind::If {\n                     cond: rhs,\n                     targets: (true_block, false_block)\n                 });\n \n                 this.cfg.push_assign_constant(\n-                    true_block, scope_id, expr_span, destination,\n+                    true_block, source_info, destination,\n                     Constant {\n                         span: expr_span,\n                         ty: this.hir.bool_ty(),\n                         literal: this.hir.true_literal(),\n                     });\n \n                 this.cfg.push_assign_constant(\n-                    false_block, scope_id, expr_span, destination,\n+                    false_block, source_info, destination,\n                     Constant {\n                         span: expr_span,\n                         ty: this.hir.bool_ty(),\n                         literal: this.hir.false_literal(),\n                     });\n \n-                this.cfg.terminate(true_block,\n-                                   scope_id,\n-                                   expr_span,\n+                this.cfg.terminate(true_block, source_info,\n                                    TerminatorKind::Goto { target: join_block });\n-                this.cfg.terminate(false_block,\n-                                   scope_id,\n-                                   expr_span,\n+                this.cfg.terminate(false_block, source_info,\n                                    TerminatorKind::Goto { target: join_block });\n \n                 join_block.unit()\n@@ -158,9 +147,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let exit_block = this.cfg.start_new_block();\n \n                 // start the loop\n-                this.cfg.terminate(block,\n-                                   scope_id,\n-                                   expr_span,\n+                this.cfg.terminate(block, source_info,\n                                    TerminatorKind::Goto { target: loop_block });\n \n                 let might_break = this.in_loop_scope(loop_block, exit_block, move |this| {\n@@ -173,9 +160,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         let loop_block_end;\n                         let cond = unpack!(loop_block_end = this.as_operand(loop_block, cond_expr));\n                         body_block = this.cfg.start_new_block();\n-                        this.cfg.terminate(loop_block_end,\n-                                           scope_id,\n-                                           expr_span,\n+                        this.cfg.terminate(loop_block_end, source_info,\n                                            TerminatorKind::If {\n                                                cond: cond,\n                                                targets: (body_block, exit_block)\n@@ -192,15 +177,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let tmp = this.get_unit_temp();\n                     // Execute the body, branching back to the test.\n                     let body_block_end = unpack!(this.into(&tmp, body_block, body));\n-                    this.cfg.terminate(body_block_end,\n-                                       scope_id,\n-                                       expr_span,\n+                    this.cfg.terminate(body_block_end, source_info,\n                                        TerminatorKind::Goto { target: loop_block });\n                 });\n                 // If the loop may reach its exit_block, we assign an empty tuple to the\n                 // destination to keep the MIR well-formed.\n                 if might_break {\n-                    this.cfg.push_assign_unit(exit_block, scope_id, expr_span, destination);\n+                    this.cfg.push_assign_unit(exit_block, source_info, destination);\n                 }\n                 exit_block.unit()\n             }\n@@ -219,7 +202,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 let success = this.cfg.start_new_block();\n                 let cleanup = this.diverge_cleanup();\n-                this.cfg.terminate(block, scope_id, expr_span, TerminatorKind::Call {\n+                this.cfg.terminate(block, source_info, TerminatorKind::Call {\n                     func: fun,\n                     args: args,\n                     cleanup: cleanup,\n@@ -269,7 +252,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 });\n \n                 let rvalue = unpack!(block = this.as_rvalue(block, expr));\n-                this.cfg.push_assign(block, scope_id, expr_span, destination, rvalue);\n+                this.cfg.push_assign(block, source_info, destination, rvalue);\n                 block.unit()\n             }\n         }"}, {"sha": "ad55a3d8b73f268572cf19dd3cd3e877ad243493", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -20,7 +20,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn stmt_expr(&mut self, mut block: BasicBlock, expr: Expr<'tcx>) -> BlockAnd<()> {\n         let this = self;\n         let expr_span = expr.span;\n-        let scope_id = this.innermost_scope_id();\n+        let source_info = this.source_info(expr.span);\n         // Handle a number of expressions that don't need a destination at all. This\n         // avoids needing a mountain of temporary `()` variables.\n         match expr.kind {\n@@ -31,7 +31,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Assign { lhs, rhs } => {\n                 let lhs = this.hir.mirror(lhs);\n                 let rhs = this.hir.mirror(rhs);\n-                let scope_id = this.innermost_scope_id();\n                 let lhs_span = lhs.span;\n \n                 // Note: we evaluate assignments right-to-left. This\n@@ -50,7 +49,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 } else {\n                     let rhs = unpack!(block = this.as_rvalue(block, rhs));\n                     let lhs = unpack!(block = this.as_lvalue(block, lhs));\n-                    this.cfg.push_assign(block, scope_id, expr_span, &lhs, rhs);\n+                    this.cfg.push_assign(block, source_info, &lhs, rhs);\n                     block.unit()\n                 }\n             }\n@@ -75,7 +74,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // (overloaded ops should be desugared into a call).\n                 let result = unpack!(block = this.build_binary_op(block, op, expr_span, lhs_ty,\n                                                   Operand::Consume(lhs.clone()), rhs));\n-                this.cfg.push_assign(block, scope_id, expr_span, &lhs, result);\n+                this.cfg.push_assign(block, source_info, &lhs, result);\n \n                 block.unit()\n             }\n@@ -93,8 +92,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block = match value {\n                     Some(value) => unpack!(this.into(&Lvalue::ReturnPointer, block, value)),\n                     None => {\n-                        this.cfg.push_assign_unit(block, scope_id,\n-                                                  expr_span, &Lvalue::ReturnPointer);\n+                        this.cfg.push_assign_unit(block, source_info, &Lvalue::ReturnPointer);\n                         block\n                     }\n                 };\n@@ -104,7 +102,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 this.cfg.start_new_block().unit()\n             }\n             _ => {\n-                let expr_span = expr.span;\n                 let expr_ty = expr.ty;\n                 let temp = this.temp(expr.ty.clone());\n                 unpack!(block = this.into(&temp, block, expr));"}, {"sha": "6104679d6500f376f010f4503d6712d6e1f1745b", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -89,18 +89,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // all the arm blocks will rejoin here\n         let end_block = self.cfg.start_new_block();\n \n-        let outer_visibility_scope = self.innermost_scope_id();\n+        let outer_source_info = self.source_info(span);\n         for (arm_index, (body, visibility_scope)) in arm_bodies.into_iter().enumerate() {\n             let mut arm_block = arm_blocks.blocks[arm_index];\n             // Re-enter the visibility scope we created the bindings in.\n             self.visibility_scope = visibility_scope;\n             unpack!(arm_block = self.into(destination, arm_block, body));\n-            self.cfg.terminate(arm_block,\n-                               outer_visibility_scope,\n-                               span,\n+            self.cfg.terminate(arm_block, outer_source_info,\n                                TerminatorKind::Goto { target: end_block });\n         }\n-        self.visibility_scope = outer_visibility_scope;\n+        self.visibility_scope = outer_source_info.scope;\n \n         end_block.unit()\n     }\n@@ -170,7 +168,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 if var_scope.is_none() {\n                     var_scope = Some(self.new_visibility_scope(scope_span));\n                 }\n-                self.declare_binding(var_scope.unwrap(), mutability, name, var, ty, pattern.span);\n+                let source_info = SourceInfo {\n+                    span: pattern.span,\n+                    scope: var_scope.unwrap()\n+                };\n+                self.declare_binding(source_info, mutability, name, var, ty);\n                 if let Some(subpattern) = subpattern.as_ref() {\n                     var_scope = self.declare_bindings(var_scope, scope_span, subpattern);\n                 }\n@@ -382,17 +384,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                              mut otherwise: Vec<BasicBlock>)\n                              -> BasicBlock\n     {\n+        let source_info = self.source_info(span);\n         otherwise.sort();\n         otherwise.dedup(); // variant switches can introduce duplicate target blocks\n-        let scope_id = self.innermost_scope_id();\n         if otherwise.len() == 1 {\n             otherwise[0]\n         } else {\n             let join_block = self.cfg.start_new_block();\n             for block in otherwise {\n-                self.cfg.terminate(block,\n-                                   scope_id,\n-                                   span,\n+                self.cfg.terminate(block, source_info,\n                                    TerminatorKind::Goto { target: join_block });\n             }\n             join_block\n@@ -571,24 +571,20 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         let arm_block = arm_blocks.blocks[candidate.arm_index];\n \n-        let scope_id = self.innermost_scope_id();\n         if let Some(guard) = candidate.guard {\n             // the block to branch to if the guard fails; if there is no\n             // guard, this block is simply unreachable\n             let guard = self.hir.mirror(guard);\n-            let guard_span = guard.span;\n+            let source_info = self.source_info(guard.span);\n             let cond = unpack!(block = self.as_operand(block, guard));\n             let otherwise = self.cfg.start_new_block();\n-            self.cfg.terminate(block,\n-                               scope_id,\n-                               guard_span,\n+            self.cfg.terminate(block, source_info,\n                                TerminatorKind::If { cond: cond,\n                                                     targets: (arm_block, otherwise)});\n             Some(otherwise)\n         } else {\n-            self.cfg.terminate(block,\n-                               scope_id,\n-                               candidate.span,\n+            let source_info = self.source_info(candidate.span);\n+            self.cfg.terminate(block, source_info,\n                                TerminatorKind::Goto { target: arm_block });\n             None\n         }\n@@ -614,35 +610,33 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     Rvalue::Ref(region, borrow_kind, binding.source),\n             };\n \n-            let scope_id = self.innermost_scope_id();\n-            self.cfg.push_assign(block, scope_id, binding.span,\n+            let source_info = self.source_info(binding.span);\n+            self.cfg.push_assign(block, source_info,\n                                  &Lvalue::Var(var_index), rvalue);\n         }\n     }\n \n     fn declare_binding(&mut self,\n-                       var_scope_id: VisibilityScope,\n+                       source_info: SourceInfo,\n                        mutability: Mutability,\n                        name: Name,\n                        var_id: NodeId,\n-                       var_ty: Ty<'tcx>,\n-                       span: Span)\n+                       var_ty: Ty<'tcx>)\n                        -> u32\n     {\n-        debug!(\"declare_binding(var_id={:?}, name={:?}, var_ty={:?}, var_scope_id={:?}, span={:?})\",\n-               var_id, name, var_ty, var_scope_id, span);\n+        debug!(\"declare_binding(var_id={:?}, name={:?}, var_ty={:?}, source_info={:?})\",\n+               var_id, name, var_ty, source_info);\n \n         let index = self.var_decls.len();\n         self.var_decls.push(VarDecl::<'tcx> {\n-            scope: var_scope_id,\n+            source_info: source_info,\n             mutability: mutability,\n             name: name,\n             ty: var_ty.clone(),\n-            span: span,\n         });\n         let index = index as u32;\n         let extent = self.extent_of_innermost_scope();\n-        self.schedule_drop(span, extent, &Lvalue::Var(index), var_ty);\n+        self.schedule_drop(source_info.span, extent, &Lvalue::Var(index), var_ty);\n         self.var_indices.insert(var_id, index);\n \n         debug!(\"declare_binding: index={:?}\", index);"}, {"sha": "1f0c4bd9e0dd6e911ead8a22302a6f2bf46d893b", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -176,7 +176,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         lvalue: &Lvalue<'tcx>,\n                         test: &Test<'tcx>)\n                         -> Vec<BasicBlock> {\n-        let scope_id = self.innermost_scope_id();\n+        let source_info = self.source_info(test.span);\n         match test.kind {\n             TestKind::Switch { adt_def, ref variants } => {\n                 let num_enum_variants = self.hir.num_variants(adt_def);\n@@ -193,7 +193,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }).collect();\n                 debug!(\"num_enum_variants: {}, num tested variants: {}, variants: {:?}\",\n                        num_enum_variants, variants.iter().count(), variants);\n-                self.cfg.terminate(block, scope_id, test.span, TerminatorKind::Switch {\n+                self.cfg.terminate(block, source_info, TerminatorKind::Switch {\n                     discr: lvalue.clone(),\n                     adt_def: adt_def,\n                     targets: target_blocks.clone()\n@@ -245,10 +245,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     }\n                 };\n \n-                self.cfg.terminate(block,\n-                                   scope_id,\n-                                   test.span,\n-                                   term);\n+                self.cfg.terminate(block, source_info, term);\n                 targets\n             }\n \n@@ -265,7 +262,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         if let ty::TyArray(_, _) = mt.ty.sty {\n                             ty = tcx.mk_imm_ref(region, tcx.mk_slice(tcx.types.u8));\n                             let val_slice = self.temp(ty);\n-                            self.cfg.push_assign(block, scope_id, test.span, &val_slice,\n+                            self.cfg.push_assign(block, source_info, &val_slice,\n                                                  Rvalue::Cast(CastKind::Unsize, val, ty));\n                             val = Operand::Consume(val_slice);\n                         }\n@@ -280,7 +277,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     });\n \n                     let slice = self.temp(ty);\n-                    self.cfg.push_assign(block, scope_id, test.span, &slice,\n+                    self.cfg.push_assign(block, source_info, &slice,\n                                          Rvalue::Cast(CastKind::Unsize, array, ty));\n                     Operand::Consume(slice)\n                 } else {\n@@ -301,7 +298,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let eq_result = self.temp(bool_ty);\n                     let eq_block = self.cfg.start_new_block();\n                     let cleanup = self.diverge_cleanup();\n-                    self.cfg.terminate(block, scope_id, test.span, TerminatorKind::Call {\n+                    self.cfg.terminate(block, source_info, TerminatorKind::Call {\n                         func: Operand::Constant(Constant {\n                             span: test.span,\n                             ty: mty,\n@@ -314,7 +311,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                     // check the result\n                     let block = self.cfg.start_new_block();\n-                    self.cfg.terminate(eq_block, scope_id, test.span, TerminatorKind::If {\n+                    self.cfg.terminate(eq_block, source_info, TerminatorKind::If {\n                         cond: Operand::Consume(eq_result),\n                         targets: (block, fail),\n                     });\n@@ -344,25 +341,22 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let (actual, result) = (self.temp(usize_ty), self.temp(bool_ty));\n \n                 // actual = len(lvalue)\n-                self.cfg.push_assign(block, scope_id, test.span,\n+                self.cfg.push_assign(block, source_info,\n                                      &actual, Rvalue::Len(lvalue.clone()));\n \n                 // expected = <N>\n-                let expected = self.push_usize(block, scope_id, test.span, len);\n+                let expected = self.push_usize(block, source_info, len);\n \n                 // result = actual == expected OR result = actual < expected\n-                self.cfg.push_assign(block,\n-                                     scope_id,\n-                                     test.span,\n-                                     &result,\n+                self.cfg.push_assign(block, source_info, &result,\n                                      Rvalue::BinaryOp(op,\n                                                       Operand::Consume(actual),\n                                                       Operand::Consume(expected)));\n \n                 // branch based on result\n                 let target_blocks: Vec<_> = vec![self.cfg.start_new_block(),\n                                                  self.cfg.start_new_block()];\n-                self.cfg.terminate(block, scope_id, test.span, TerminatorKind::If {\n+                self.cfg.terminate(block, source_info, TerminatorKind::If {\n                     cond: Operand::Consume(result),\n                     targets: (target_blocks[0], target_blocks[1])\n                 });\n@@ -383,13 +377,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let result = self.temp(bool_ty);\n \n         // result = op(left, right)\n-        let scope_id = self.innermost_scope_id();\n-        self.cfg.push_assign(block, scope_id, span, &result,\n+        let source_info = self.source_info(span);\n+        self.cfg.push_assign(block, source_info, &result,\n                              Rvalue::BinaryOp(op, left, right));\n \n         // branch based on result\n         let target_block = self.cfg.start_new_block();\n-        self.cfg.terminate(block, scope_id, span, TerminatorKind::If {\n+        self.cfg.terminate(block, source_info, TerminatorKind::If {\n             cond: Operand::Consume(result),\n             targets: (target_block, fail_block)\n         });"}, {"sha": "2e9cc96c046817d2a4f4fbd6330f3cc243c21926", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -65,8 +65,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 from_end: suffix_len,\n             };\n             let temp = self.temp(slice.ty.clone()); // no need to schedule drop, temp is always copy\n-            let scope_id = self.innermost_scope_id();\n-            self.cfg.push_assign(block, scope_id, slice.span, &temp, rvalue);\n+            let source_info = self.source_info(slice.span);\n+            self.cfg.push_assign(block, source_info, &temp, rvalue);\n             match_pairs.push(MatchPair::new(temp, slice));\n         }\n "}, {"sha": "a9d5c0c4f85c39314b86d0ff985b589b745f42a1", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -103,16 +103,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     pub fn push_usize(&mut self,\n                       block: BasicBlock,\n-                      scope_id: VisibilityScope,\n-                      span: Span,\n+                      source_info: SourceInfo,\n                       value: u64)\n                       -> Lvalue<'tcx> {\n         let usize_ty = self.hir.usize_ty();\n         let temp = self.temp(usize_ty);\n         self.cfg.push_assign_constant(\n-            block, scope_id, span, &temp,\n+            block, source_info, &temp,\n             Constant {\n-                span: span,\n+                span: source_info.span,\n                 ty: self.hir.usize_ty(),\n                 literal: self.hir.usize_literal(value),\n             });"}, {"sha": "9c1b9fa4437e01110826ea8e525f42c509f9b673", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -200,11 +200,11 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n             builder.args_and_body(block, return_ty, arguments, arg_extent, ast_block)\n         }));\n \n-        let visibility_scope = builder.visibility_scope;\n+        let source_info = builder.source_info(span);\n         let return_block = builder.return_block();\n-        builder.cfg.terminate(block, visibility_scope, span,\n+        builder.cfg.terminate(block, source_info,\n                               TerminatorKind::Goto { target: return_block });\n-        builder.cfg.terminate(return_block, visibility_scope, span,\n+        builder.cfg.terminate(return_block, source_info,\n                               TerminatorKind::Return);\n         return_block.and(arg_decls)\n     }));\n@@ -260,11 +260,11 @@ pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n         let expr = builder.hir.mirror(ast_expr);\n         unpack!(block = builder.into(&Lvalue::ReturnPointer, block, expr));\n \n-        let visibility_scope = builder.visibility_scope;\n+        let source_info = builder.source_info(span);\n         let return_block = builder.return_block();\n-        builder.cfg.terminate(block, visibility_scope, span,\n+        builder.cfg.terminate(block, source_info,\n                               TerminatorKind::Goto { target: return_block });\n-        builder.cfg.terminate(return_block, visibility_scope, span,\n+        builder.cfg.terminate(return_block, source_info,\n                               TerminatorKind::Return);\n \n         return_block.unit()"}, {"sha": "2b7efa52cbd054c8131dfaed4e997e751aa8642f", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -207,6 +207,14 @@ impl<'tcx> Scope<'tcx> {\n             None\n         }\n     }\n+\n+    /// Given a span and this scope's visibility scope, make a SourceInfo.\n+    fn source_info(&self, span: Span) -> SourceInfo {\n+        SourceInfo {\n+            span: span,\n+            scope: self.visibility_scope\n+        }\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n@@ -318,7 +326,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             if let Some(ref free_data) = scope.free {\n                 let next = self.cfg.start_new_block();\n                 let free = build_free(self.hir.tcx(), &tmp, free_data, next);\n-                self.cfg.terminate(block, scope.visibility_scope, span, free);\n+                self.cfg.terminate(block, scope.source_info(span), free);\n                 block = next;\n             }\n             self.scope_auxiliary[scope.id]\n@@ -332,8 +340,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                             .next()\n                                             .unwrap();\n         self.cfg.terminate(block,\n-                           scope.visibility_scope,\n-                           span,\n+                           scope.source_info(span),\n                            TerminatorKind::Goto { target: target });\n     }\n \n@@ -372,8 +379,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }.unwrap_or_else(|| span_bug!(span, \"no enclosing loop scope found?\"))\n     }\n \n-    pub fn innermost_scope_id(&self) -> VisibilityScope {\n-        self.visibility_scope\n+    /// Given a span and the current visibility scope, make a SourceInfo.\n+    pub fn source_info(&self, span: Span) -> SourceInfo {\n+        SourceInfo {\n+            span: span,\n+            scope: self.visibility_scope\n+        }\n     }\n \n     pub fn extent_of_innermost_scope(&self) -> CodeExtent {\n@@ -491,8 +502,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         } else {\n             let resumeblk = cfg.start_new_cleanup_block();\n             cfg.terminate(resumeblk,\n-                          scopes[0].visibility_scope,\n-                          self.fn_span,\n+                          scopes[0].source_info(self.fn_span),\n                           TerminatorKind::Resume);\n             *cached_resume_block = Some(resumeblk);\n             resumeblk\n@@ -514,12 +524,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         if !self.hir.needs_drop(ty) {\n             return block.unit();\n         }\n-        let scope_id = self.innermost_scope_id();\n+        let source_info = self.source_info(span);\n         let next_target = self.cfg.start_new_block();\n         let diverge_target = self.diverge_cleanup();\n-        self.cfg.terminate(block,\n-                           scope_id,\n-                           span,\n+        self.cfg.terminate(block, source_info,\n                            TerminatorKind::Drop {\n                                location: location,\n                                target: next_target,\n@@ -534,12 +542,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                   span: Span,\n                                   location: Lvalue<'tcx>,\n                                   value: Operand<'tcx>) -> BlockAnd<()> {\n-        let scope_id = self.innermost_scope_id();\n+        let source_info = self.source_info(span);\n         let next_target = self.cfg.start_new_block();\n         let diverge_target = self.diverge_cleanup();\n-        self.cfg.terminate(block,\n-                           scope_id,\n-                           span,\n+        self.cfg.terminate(block, source_info,\n                            TerminatorKind::DropAndReplace {\n                                location: location,\n                                value: value,\n@@ -574,18 +580,18 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let elems = vec![Operand::Constant(message),\n                          Operand::Constant(file),\n                          Operand::Constant(line)];\n-        let scope_id = self.innermost_scope_id();\n+        let source_info = self.source_info(span);\n         // FIXME: We should have this as a constant, rather than a stack variable (to not pollute\n         // icache with cold branch code), however to achieve that we either have to rely on rvalue\n         // promotion or have some way, in MIR, to create constants.\n-        self.cfg.push_assign(block, scope_id, span, &tuple, // [1]\n+        self.cfg.push_assign(block, source_info, &tuple, // [1]\n                              Rvalue::Aggregate(AggregateKind::Tuple, elems));\n         // [1] tuple = (message_arg, file_arg, line_arg);\n         // FIXME: is this region really correct here?\n-        self.cfg.push_assign(block, scope_id, span, &tuple_ref, // tuple_ref = &tuple;\n+        self.cfg.push_assign(block, source_info, &tuple_ref, // tuple_ref = &tuple;\n                              Rvalue::Ref(region, BorrowKind::Shared, tuple));\n         let cleanup = self.diverge_cleanup();\n-        self.cfg.terminate(block, scope_id, span, TerminatorKind::Call {\n+        self.cfg.terminate(block, source_info, TerminatorKind::Call {\n             func: Operand::Constant(func),\n             args: vec![Operand::Consume(tuple_ref)],\n             cleanup: cleanup,\n@@ -602,12 +608,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                   msg: AssertMessage<'tcx>,\n                   span: Span)\n                   -> BasicBlock {\n-        let scope_id = self.innermost_scope_id();\n+        let source_info = self.source_info(span);\n \n         let success_block = self.cfg.start_new_block();\n         let cleanup = self.diverge_cleanup();\n \n-        self.cfg.terminate(block, scope_id, span,\n+        self.cfg.terminate(block, source_info,\n                            TerminatorKind::Assert {\n                                cond: cond,\n                                expected: expected,\n@@ -670,7 +676,7 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n             earlier_scopes.iter().rev().flat_map(|s| s.cached_block()).next()\n         });\n         let next = cfg.start_new_block();\n-        cfg.terminate(block, scope.visibility_scope, drop_data.span, TerminatorKind::Drop {\n+        cfg.terminate(block, scope.source_info(drop_data.span), TerminatorKind::Drop {\n             location: drop_data.location.clone(),\n             target: next,\n             unwind: on_diverge\n@@ -700,15 +706,19 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     // remainder. If everything is cached, we'll just walk right to\n     // left reading the cached results but never created anything.\n \n+    let visibility_scope = scope.visibility_scope;\n+    let source_info = |span| SourceInfo {\n+        span: span,\n+        scope: visibility_scope\n+    };\n+\n     // Next, build up any free.\n     if let Some(ref mut free_data) = scope.free {\n         target = if let Some(cached_block) = free_data.cached_block {\n             cached_block\n         } else {\n             let into = cfg.start_new_cleanup_block();\n-            cfg.terminate(into,\n-                          scope.visibility_scope,\n-                          free_data.span,\n+            cfg.terminate(into, source_info(free_data.span),\n                           build_free(tcx, unit_temp, free_data, target));\n             free_data.cached_block = Some(into);\n             into\n@@ -723,9 +733,7 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             cached_block\n         } else {\n             let block = cfg.start_new_cleanup_block();\n-            cfg.terminate(block,\n-                          scope.visibility_scope,\n-                          drop_data.span,\n+            cfg.terminate(block, source_info(drop_data.span),\n                           TerminatorKind::Drop {\n                               location: drop_data.location.clone(),\n                               target: target,"}, {"sha": "8c21928c2513b9869f2f2195526c4d729cec9c4b", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -18,7 +18,6 @@ use std::fmt::Display;\n use std::fs;\n use std::io::{self, Write};\n use syntax::ast::NodeId;\n-use syntax::codemap::Span;\n \n const INDENT: &'static str = \"    \";\n /// Alignment for lining up comments following MIR statements\n@@ -180,7 +179,7 @@ fn write_basic_block(tcx: TyCtxt,\n         writeln!(w, \"{0:1$} // {2}\",\n                  indented_mir,\n                  ALIGN,\n-                 comment(tcx, statement.scope, statement.span))?;\n+                 comment(tcx, statement.source_info))?;\n \n         current_location.statement_index += 1;\n     }\n@@ -190,12 +189,12 @@ fn write_basic_block(tcx: TyCtxt,\n     writeln!(w, \"{0:1$} // {2}\",\n              indented_terminator,\n              ALIGN,\n-             comment(tcx, data.terminator().scope, data.terminator().span))?;\n+             comment(tcx, data.terminator().source_info))?;\n \n     writeln!(w, \"{}}}\\n\", INDENT)\n }\n \n-fn comment(tcx: TyCtxt, scope: VisibilityScope, span: Span) -> String {\n+fn comment(tcx: TyCtxt, SourceInfo { span, scope }: SourceInfo) -> String {\n     format!(\"scope {} at {}\", scope.index(), tcx.sess.codemap().span_to_string(span))\n }\n \n@@ -221,7 +220,7 @@ fn write_scope_tree(tcx: TyCtxt,\n         // User variable types (including the user's name in a comment).\n         for (i, var) in mir.var_decls.iter().enumerate() {\n             // Skip if not declared in this scope.\n-            if var.scope != child {\n+            if var.source_info.scope != child {\n                 continue;\n             }\n \n@@ -242,7 +241,7 @@ fn write_scope_tree(tcx: TyCtxt,\n                      indented_var,\n                      ALIGN,\n                      var.name,\n-                     comment(tcx, var.scope, var.span))?;\n+                     comment(tcx, var.source_info))?;\n         }\n \n         write_scope_tree(tcx, mir, scope_tree, w, child, depth + 1)?;"}, {"sha": "a90d8e93a50e627069727fd296ff1eaa5f0efe6a", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -66,15 +66,14 @@ impl<'tcx> MirPass<'tcx> for AddCallGuards {\n                         destination: Some((_, ref mut destination)),\n                         cleanup: Some(_),\n                         ..\n-                    }, span, scope\n+                    }, source_info\n                 }) if pred_count[destination.index()] > 1 => {\n                     // It's a critical edge, break it\n                     let call_guard = BasicBlockData {\n                         statements: vec![],\n                         is_cleanup: data.is_cleanup,\n                         terminator: Some(Terminator {\n-                            span: span,\n-                            scope: scope,\n+                            source_info: source_info,\n                             kind: TerminatorKind::Goto { target: *destination }\n                         })\n                     };"}, {"sha": "c9c574966c767f01703ec3602ff81ae0dcabe2c1", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -117,18 +117,16 @@ impl<'tcx> Visitor<'tcx> for TempCollector {\n         }\n     }\n \n+    fn visit_source_info(&mut self, source_info: &SourceInfo) {\n+        self.span = source_info.span;\n+    }\n+\n     fn visit_statement(&mut self, bb: BasicBlock, statement: &Statement<'tcx>) {\n         assert_eq!(self.location.block, bb);\n-        self.span = statement.span;\n         self.super_statement(bb, statement);\n         self.location.statement_index += 1;\n     }\n \n-    fn visit_terminator(&mut self, bb: BasicBlock, terminator: &Terminator<'tcx>) {\n-        self.span = terminator.span;\n-        self.super_terminator(bb, terminator);\n-    }\n-\n     fn visit_basic_block_data(&mut self, bb: BasicBlock, data: &BasicBlockData<'tcx>) {\n         self.location.statement_index = 0;\n         self.location.block = bb;\n@@ -167,8 +165,10 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         self.promoted.basic_blocks.push(BasicBlockData {\n             statements: vec![],\n             terminator: Some(Terminator {\n-                span: self.promoted.span,\n-                scope: VisibilityScope::new(0),\n+                source_info: SourceInfo {\n+                    span: self.promoted.span,\n+                    scope: ARGUMENT_VISIBILITY_SCOPE\n+                },\n                 kind: TerminatorKind::Return\n             }),\n             is_cleanup: false\n@@ -179,8 +179,10 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     fn assign(&mut self, dest: Lvalue<'tcx>, rvalue: Rvalue<'tcx>, span: Span) {\n         let data = self.promoted.basic_blocks.last_mut().unwrap();\n         data.statements.push(Statement {\n-            span: span,\n-            scope: VisibilityScope::new(0),\n+            source_info: SourceInfo {\n+                span: span,\n+                scope: ARGUMENT_VISIBILITY_SCOPE\n+            },\n             kind: StatementKind::Assign(dest, rvalue)\n         });\n     }\n@@ -214,7 +216,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         // First, take the Rvalue or Call out of the source MIR,\n         // or duplicate it, depending on keep_original.\n         let (mut rvalue, mut call) = (None, None);\n-        let span = if stmt_idx < no_stmts {\n+        let source_info = if stmt_idx < no_stmts {\n             let statement = &mut self.source[bb].statements[stmt_idx];\n             let StatementKind::Assign(_, ref mut rhs) = statement.kind;\n             if self.keep_original {\n@@ -223,11 +225,11 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 let unit = Rvalue::Aggregate(AggregateKind::Tuple, vec![]);\n                 rvalue = Some(mem::replace(rhs, unit));\n             }\n-            statement.span\n+            statement.source_info\n         } else if self.keep_original {\n             let terminator = self.source[bb].terminator().clone();\n             call = Some(terminator.kind);\n-            terminator.span\n+            terminator.source_info\n         } else {\n             let terminator = self.source[bb].terminator_mut();\n             let target = match terminator.kind {\n@@ -242,13 +244,13 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                     dest.take().unwrap().1\n                 }\n                 ref kind => {\n-                    span_bug!(terminator.span, \"{:?} not promotable\", kind);\n+                    span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n                 }\n             };\n             call = Some(mem::replace(&mut terminator.kind, TerminatorKind::Goto {\n                 target: target\n             }));\n-            terminator.span\n+            terminator.source_info\n         };\n \n         // Then, recurse for components in the Rvalue or Call.\n@@ -266,7 +268,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n \n         // Inject the Rvalue or Call into the promoted MIR.\n         if stmt_idx < no_stmts {\n-            self.assign(new_temp, rvalue.unwrap(), span);\n+            self.assign(new_temp, rvalue.unwrap(), source_info.span);\n         } else {\n             let last = self.promoted.basic_blocks.len() - 1;\n             let new_target = self.new_block();\n@@ -278,7 +280,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 _ => bug!()\n             }\n             let terminator = &mut self.promoted.basic_blocks[last].terminator_mut();\n-            terminator.span = span;\n+            terminator.source_info.span = source_info.span;\n             terminator.kind = call;\n         }\n \n@@ -346,7 +348,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                         continue;\n                     }\n                 }\n-                (statement.span, mir.lvalue_ty(tcx, dest).to_ty(tcx))\n+                (statement.source_info.span, mir.lvalue_ty(tcx, dest).to_ty(tcx))\n             }\n             Candidate::ShuffleIndices(bb) => {\n                 let terminator = mir[bb].terminator();\n@@ -355,11 +357,11 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                         mir.operand_ty(tcx, &args[2])\n                     }\n                     _ => {\n-                        span_bug!(terminator.span,\n+                        span_bug!(terminator.source_info.span,\n                                   \"expected simd_shuffleN call to promote\");\n                     }\n                 };\n-                (terminator.span, ty)\n+                (terminator.source_info.span, ty)\n             }\n         };\n "}, {"sha": "92ac9b049f1276203f8da77d0cc62d90f76368e4", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -377,11 +377,12 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                             let stmt_idx = location.statement_index;\n \n                             // Get the span for the initialization.\n-                            if stmt_idx < data.statements.len() {\n-                                self.span = data.statements[stmt_idx].span;\n+                            let source_info = if stmt_idx < data.statements.len() {\n+                                data.statements[stmt_idx].source_info\n                             } else {\n-                                self.span = data.terminator().span;\n-                            }\n+                                data.terminator().source_info\n+                            };\n+                            self.span = source_info.span;\n \n                             // Treat this as a statement in the AST.\n                             self.statement_like();\n@@ -830,7 +831,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 // Avoid a generic error for other uses of arguments.\n                 if self.qualif.intersects(Qualif::FN_ARGUMENT) {\n                     let decl = &self.mir.var_decls[index as usize];\n-                    span_err!(self.tcx.sess, decl.span, E0022,\n+                    span_err!(self.tcx.sess, decl.source_info.span, E0022,\n                               \"arguments of constant functions can only \\\n                                be immutable by-value bindings\");\n                     return;\n@@ -841,16 +842,18 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n         self.assign(dest);\n     }\n \n+    fn visit_source_info(&mut self, source_info: &SourceInfo) {\n+        self.span = source_info.span;\n+    }\n+\n     fn visit_statement(&mut self, bb: BasicBlock, statement: &Statement<'tcx>) {\n         assert_eq!(self.location.block, bb);\n-        self.span = statement.span;\n         self.nest(|this| this.super_statement(bb, statement));\n         self.location.statement_index += 1;\n     }\n \n     fn visit_terminator(&mut self, bb: BasicBlock, terminator: &Terminator<'tcx>) {\n         assert_eq!(self.location.block, bb);\n-        self.span = terminator.span;\n         self.nest(|this| this.super_terminator(bb, terminator));\n     }\n "}, {"sha": "4bfa3b16efa16124400b319de13a9940eb69f7a9", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -551,7 +551,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     fn check_iscleanup(&mut self, mir: &Mir<'tcx>, block: &BasicBlockData<'tcx>)\n     {\n         let is_cleanup = block.is_cleanup;\n-        self.last_span = block.terminator().span;\n+        self.last_span = block.terminator().source_info.span;\n         match block.terminator().kind {\n             TerminatorKind::Goto { target } =>\n                 self.assert_iscleanup(mir, block, target, is_cleanup),\n@@ -617,8 +617,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         debug!(\"run_on_mir: {:?}\", mir.span);\n         for block in &mir.basic_blocks {\n             for stmt in &block.statements {\n-                if stmt.span != DUMMY_SP {\n-                    self.last_span = stmt.span;\n+                if stmt.source_info.span != DUMMY_SP {\n+                    self.last_span = stmt.source_info.span;\n                 }\n                 self.check_stmt(mir, stmt);\n             }"}, {"sha": "f75f973f68aabd4932621a520ced6c8d2fd3be24", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -84,7 +84,7 @@ pub fn create_mir_scopes(fcx: &FunctionContext) -> Vec<DIScope> {\n     // Find all the scopes with variables defined in them.\n     let mut has_variables = BitVector::new(mir.visibility_scopes.len());\n     for var in &mir.var_decls {\n-        has_variables.insert(var.scope.index());\n+        has_variables.insert(var.source_info.scope.index());\n     }\n \n     // Instantiate all scopes."}, {"sha": "e19f20bba1d2db6b10834468241b13ab004c5c8d", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -108,8 +108,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         let terminator = data.terminator();\n         debug!(\"trans_block: terminator: {:?}\", terminator);\n \n-        let debug_loc = DebugLoc::ScopeAt(self.scopes[terminator.scope.index()],\n-                                          terminator.span);\n+        let span = terminator.source_info.span;\n+        let debug_loc = self.debug_loc(terminator.source_info);\n         debug_loc.apply_to_bcx(&bcx);\n         debug_loc.apply(bcx.fcx());\n         match terminator.kind {\n@@ -247,7 +247,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 bcx = panic_block.build();\n \n                 // Get the location information.\n-                let loc = bcx.sess().codemap().lookup_char_pos(terminator.span.lo);\n+                let loc = bcx.sess().codemap().lookup_char_pos(span.lo);\n                 let filename = token::intern_and_get_ident(&loc.file.name);\n                 let filename = C_str_slice(bcx.ccx(), filename);\n                 let line = C_u32(bcx.ccx(), loc.line as u32);\n@@ -298,15 +298,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 // is also constant, then we can produce a warning.\n                 if const_cond == Some(!expected) {\n                     if let Some(err) = const_err {\n-                        let _ = consts::const_err(bcx.ccx(),\n-                                                  terminator.span,\n+                        let _ = consts::const_err(bcx.ccx(), span,\n                                                   Err::<(), _>(err),\n                                                   consts::TrueConst::No);\n                     }\n                 }\n \n                 // Obtain the panic entry point.\n-                let def_id = common::langcall(bcx.tcx(), Some(terminator.span), \"\", lang_item);\n+                let def_id = common::langcall(bcx.tcx(), Some(span), \"\", lang_item);\n                 let callee = Callee::def(bcx.ccx(), def_id,\n                     bcx.ccx().empty_substs_for_def_id(def_id));\n                 let llfn = callee.reify(bcx.ccx()).val;\n@@ -419,8 +418,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     if is_shuffle && idx == 2 {\n                         match *arg {\n                             mir::Operand::Consume(_) => {\n-                                span_bug!(terminator.span,\n-                                          \"shuffle indices must be constant\");\n+                                span_bug!(span, \"shuffle indices must be constant\");\n                             }\n                             mir::Operand::Constant(ref constant) => {\n                                 let val = self.trans_constant(&bcx, constant);"}, {"sha": "4aa6aadb2706e1c6b53a169163db9eb42cfb062e", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -281,20 +281,21 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n         loop {\n             let data = self.mir.basic_block_data(bb);\n             for statement in &data.statements {\n+                let span = statement.source_info.span;\n                 match statement.kind {\n                     mir::StatementKind::Assign(ref dest, ref rvalue) => {\n                         let ty = self.mir.lvalue_ty(tcx, dest);\n                         let ty = self.monomorphize(&ty).to_ty(tcx);\n-                        match self.const_rvalue(rvalue, ty, statement.span) {\n-                            Ok(value) => self.store(dest, value, statement.span),\n+                        match self.const_rvalue(rvalue, ty, span) {\n+                            Ok(value) => self.store(dest, value, span),\n                             Err(err) => if failure.is_ok() { failure = Err(err); }\n                         }\n                     }\n                 }\n             }\n \n             let terminator = data.terminator();\n-            let span = terminator.span;\n+            let span = terminator.source_info.span;\n             bb = match terminator.kind {\n                 mir::TerminatorKind::Drop { target, .. } | // No dropping.\n                 mir::TerminatorKind::Goto { target } => target,"}, {"sha": "4520bc6137cc0cabc8ccd65ca8d1272b58cf3336", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -112,6 +112,12 @@ pub struct MirContext<'bcx, 'tcx:'bcx> {\n     scopes: Vec<DIScope>\n }\n \n+impl<'blk, 'tcx> MirContext<'blk, 'tcx> {\n+    pub fn debug_loc(&self, source_info: mir::SourceInfo) -> DebugLoc {\n+        DebugLoc::ScopeAt(self.scopes[source_info.scope.index()], source_info.span)\n+    }\n+}\n+\n enum TempRef<'tcx> {\n     Lvalue(LvalueRef<'tcx>),\n     Operand(Option<OperandRef<'tcx>>),\n@@ -161,12 +167,12 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n                             .map(|(mty, decl)| {\n         let lvalue = LvalueRef::alloca(&bcx, mty, &decl.name.as_str());\n \n-        let scope = scopes[decl.scope.index()];\n+        let scope = scopes[decl.source_info.scope.index()];\n         if !scope.is_null() && bcx.sess().opts.debuginfo == FullDebugInfo {\n             bcx.with_block(|bcx| {\n                 declare_local(bcx, decl.name, mty, scope,\n                               VariableAccess::DirectVariable { alloca: lvalue.llval },\n-                              VariableKind::LocalVariable, decl.span);\n+                              VariableKind::LocalVariable, decl.source_info.span);\n             });\n         }\n "}, {"sha": "544c47e471fd3666eb45ac3e3dfe4c17546bebbe", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5930ef256131f8d0e4f020a5029a89944cf250/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=0c5930ef256131f8d0e4f020a5029a89944cf250", "patch": "@@ -10,7 +10,6 @@\n \n use rustc::mir::repr as mir;\n use common::{self, BlockAndBuilder};\n-use debuginfo::DebugLoc;\n \n use super::MirContext;\n use super::TempRef;\n@@ -22,8 +21,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                            -> BlockAndBuilder<'bcx, 'tcx> {\n         debug!(\"trans_statement(statement={:?})\", statement);\n \n-        let debug_loc = DebugLoc::ScopeAt(self.scopes[statement.scope.index()],\n-                                          statement.span);\n+        let debug_loc = self.debug_loc(statement.source_info);\n         debug_loc.apply_to_bcx(&bcx);\n         debug_loc.apply(bcx.fcx());\n         match statement.kind {\n@@ -46,7 +44,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 let ty = bcx.monomorphize(&ty.to_ty(bcx.tcx()));\n \n                                 if !common::type_is_zero_size(bcx.ccx(), ty) {\n-                                    span_bug!(statement.span,\n+                                    span_bug!(statement.source_info.span,\n                                               \"operand {:?} already assigned\",\n                                               rvalue);\n                                 } else {"}]}