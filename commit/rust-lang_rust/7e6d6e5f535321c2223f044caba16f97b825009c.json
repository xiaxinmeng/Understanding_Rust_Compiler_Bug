{"sha": "7e6d6e5f535321c2223f044caba16f97b825009c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlNmQ2ZTVmNTM1MzIxYzIyMjNmMDQ0Y2FiYTE2Zjk3YjgyNTAwOWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-16T22:00:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-16T22:00:29Z"}, "message": "Auto merge of #75609 - tmandry:rollup-yrcmgke, r=tmandry\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #74204 (Don't visit foreign function bodies when lowering ast to hir)\n - #74314 (rustc_typeck: construct {Closure,Generator}Substs more directly.)\n - #74346 (Use LocalDefId instead of HirId for reachable_set elements.)\n - #74399 (Move DelaySpanBugEmitted to ty::context)\n - #75177 (Add regression test for issue-66768)\n - #75223 (Add #[track_caller] to `Session::delay_span_bug`)\n - #75423 (Move to intra-doc links for /library/core/src/hint.rs)\n - #75485 (pin docs: add some forward references)\n - #75569 (Bump minor version of emsdk to 1.38.47)\n - #75596 (Switch to intra-doc links in /sys/windows/ext/{ffi,fs,process}.rs)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "2543a4394a25a4fe49011ab4f6fefb32bff84449", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2543a4394a25a4fe49011ab4f6fefb32bff84449"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e6d6e5f535321c2223f044caba16f97b825009c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e6d6e5f535321c2223f044caba16f97b825009c", "html_url": "https://github.com/rust-lang/rust/commit/7e6d6e5f535321c2223f044caba16f97b825009c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e6d6e5f535321c2223f044caba16f97b825009c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b4db695b0ab13885a61deb1b2e4d6599b8c5bbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b4db695b0ab13885a61deb1b2e4d6599b8c5bbc", "html_url": "https://github.com/rust-lang/rust/commit/9b4db695b0ab13885a61deb1b2e4d6599b8c5bbc"}, {"sha": "e46b1efd39849196471c18a5b66d60bfc8ca20a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e46b1efd39849196471c18a5b66d60bfc8ca20a0", "html_url": "https://github.com/rust-lang/rust/commit/e46b1efd39849196471c18a5b66d60bfc8ca20a0"}], "stats": {"total": 651, "additions": 455, "deletions": 196}, "files": [{"sha": "461b4c79a1d1c12b8faf03978f2619d19b91f50b", "filename": "library/core/src/hint.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e6d6e5f535321c2223f044caba16f97b825009c/library%2Fcore%2Fsrc%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e6d6e5f535321c2223f044caba16f97b825009c/library%2Fcore%2Fsrc%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhint.rs?ref=7e6d6e5f535321c2223f044caba16f97b825009c", "patch": "@@ -24,7 +24,6 @@ use crate::intrinsics;\n /// Otherwise, consider using the [`unreachable!`] macro, which does not allow\n /// optimizations but will panic when executed.\n ///\n-/// [`unreachable!`]: ../macro.unreachable.html\n ///\n /// # Example\n ///\n@@ -61,7 +60,7 @@ pub const unsafe fn unreachable_unchecked() -> ! {\n /// **Note**: On platforms that do not support receiving spin-loop hints this function does not\n /// do anything at all.\n ///\n-/// [`core::sync::atomic::spin_loop_hint`]: ../sync/atomic/fn.spin_loop_hint.html\n+/// [`core::sync::atomic::spin_loop_hint`]: crate::sync::atomic::spin_loop_hint\n #[inline]\n #[unstable(feature = \"renamed_spin_loop\", issue = \"55002\")]\n pub fn spin_loop() {"}, {"sha": "960cccc0fb21147ee2cf9c0019f5b08c6359e763", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7e6d6e5f535321c2223f044caba16f97b825009c/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e6d6e5f535321c2223f044caba16f97b825009c/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=7e6d6e5f535321c2223f044caba16f97b825009c", "patch": "@@ -6,9 +6,12 @@\n //! as moving an object with pointers to itself will invalidate them, which could cause undefined\n //! behavior.\n //!\n-//! A [`Pin<P>`] ensures that the pointee of any pointer type `P` has a stable location in memory,\n-//! meaning it cannot be moved elsewhere and its memory cannot be deallocated\n-//! until it gets dropped. We say that the pointee is \"pinned\".\n+//! At a high level, a [`Pin<P>`] ensures that the pointee of any pointer type\n+//! `P` has a stable location in memory, meaning it cannot be moved elsewhere\n+//! and its memory cannot be deallocated until it gets dropped. We say that the\n+//! pointee is \"pinned\". Things get more subtle when discussing types that\n+//! combine pinned with non-pinned data; [see below](#projections-and-structural-pinning)\n+//! for more details.\n //!\n //! By default, all types in Rust are movable. Rust allows passing all types by-value,\n //! and common smart-pointer types such as [`Box<T>`] and `&mut T` allow replacing and\n@@ -61,6 +64,10 @@\n //!\n //! # Example: self-referential struct\n //!\n+//! Before we go into more details to explain the guarantees and choices\n+//! associated with `Pin<T>`, we discuss some examples for how it might be used.\n+//! Feel free to [skip to where the theoretical discussion continues](#drop-guarantee).\n+//!\n //! ```rust\n //! use std::pin::Pin;\n //! use std::marker::PhantomPinned;"}, {"sha": "1df2a0df143b3c4436bcf75924a6869b0bfb0356", "filename": "library/std/src/sys/windows/ext/ffi.rs", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7e6d6e5f535321c2223f044caba16f97b825009c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fext%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e6d6e5f535321c2223f044caba16f97b825009c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fext%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fext%2Fffi.rs?ref=7e6d6e5f535321c2223f044caba16f97b825009c", "patch": "@@ -30,13 +30,13 @@\n //! [`OsString`] is the Rust wrapper for owned strings in the\n //! preferred representation of the operating system. On Windows,\n //! this struct gets augmented with an implementation of the\n-//! [`OsStringExt`] trait, which has a [`from_wide`] method. This\n+//! [`OsStringExt`] trait, which has a [`OsStringExt::from_wide`] method. This\n //! lets you create an [`OsString`] from a `&[u16]` slice; presumably\n //! you get such a slice out of a `WCHAR` Windows API.\n //!\n //! Similarly, [`OsStr`] is the Rust wrapper for borrowed strings from\n //! preferred representation of the operating system. On Windows, the\n-//! [`OsStrExt`] trait provides the [`encode_wide`] method, which\n+//! [`OsStrExt`] trait provides the [`OsStrExt::encode_wide`] method, which\n //! outputs an [`EncodeWide`] iterator. You can [`collect`] this\n //! iterator, for example, to obtain a `Vec<u16>`; you can later get a\n //! pointer to this vector's contents and feed it to Windows APIs.\n@@ -47,15 +47,8 @@\n //! ill-formed UTF-16.\n //!\n //! [ill-formed-utf-16]: https://simonsapin.github.io/wtf-8/#ill-formed-utf-16\n-//! [`OsString`]: ../../../ffi/struct.OsString.html\n-//! [`OsStr`]: ../../../ffi/struct.OsStr.html\n-//! [`OsStringExt`]: trait.OsStringExt.html\n-//! [`OsStrExt`]: trait.OsStrExt.html\n-//! [`EncodeWide`]: struct.EncodeWide.html\n-//! [`from_wide`]: trait.OsStringExt.html#tymethod.from_wide\n-//! [`encode_wide`]: trait.OsStrExt.html#tymethod.encode_wide\n-//! [`collect`]: ../../../iter/trait.Iterator.html#method.collect\n-//! [U+FFFD]: ../../../char/constant.REPLACEMENT_CHARACTER.html\n+//! [`collect`]: crate::iter::Iterator::collect\n+//! [U+FFFD]: crate::char::REPLACEMENT_CHARACTER\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -68,14 +61,12 @@ use crate::sys_common::{AsInner, FromInner};\n pub use crate::sys_common::wtf8::EncodeWide;\n \n /// Windows-specific extensions to [`OsString`].\n-///\n-/// [`OsString`]: ../../../../std/ffi/struct.OsString.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait OsStringExt {\n     /// Creates an `OsString` from a potentially ill-formed UTF-16 slice of\n     /// 16-bit code units.\n     ///\n-    /// This is lossless: calling [`encode_wide`] on the resulting string\n+    /// This is lossless: calling [`OsStrExt::encode_wide`] on the resulting string\n     /// will always return the original code units.\n     ///\n     /// # Examples\n@@ -89,8 +80,6 @@ pub trait OsStringExt {\n     ///\n     /// let string = OsString::from_wide(&source[..]);\n     /// ```\n-    ///\n-    /// [`encode_wide`]: ./trait.OsStrExt.html#tymethod.encode_wide\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn from_wide(wide: &[u16]) -> Self;\n }\n@@ -103,14 +92,12 @@ impl OsStringExt for OsString {\n }\n \n /// Windows-specific extensions to [`OsStr`].\n-///\n-/// [`OsStr`]: ../../../../std/ffi/struct.OsStr.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait OsStrExt {\n     /// Re-encodes an `OsStr` as a wide character sequence, i.e., potentially\n     /// ill-formed UTF-16.\n     ///\n-    /// This is lossless: calling [`OsString::from_wide`] and then\n+    /// This is lossless: calling [`OsStringExt::from_wide`] and then\n     /// `encode_wide` on the result will yield the original code units.\n     /// Note that the encoding does not add a final null terminator.\n     ///\n@@ -128,8 +115,6 @@ pub trait OsStrExt {\n     /// let result: Vec<u16> = string.encode_wide().collect();\n     /// assert_eq!(&source[..], &result[..]);\n     /// ```\n-    ///\n-    /// [`OsString::from_wide`]: ./trait.OsStringExt.html#tymethod.from_wide\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn encode_wide(&self) -> EncodeWide<'_>;\n }"}, {"sha": "e0615f2d33431953283a15a23a7b8ab135bb3647", "filename": "library/std/src/sys/windows/ext/fs.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e6d6e5f535321c2223f044caba16f97b825009c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e6d6e5f535321c2223f044caba16f97b825009c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fext%2Ffs.rs?ref=7e6d6e5f535321c2223f044caba16f97b825009c", "patch": "@@ -8,9 +8,7 @@ use crate::path::Path;\n use crate::sys;\n use crate::sys_common::{AsInner, AsInnerMut};\n \n-/// Windows-specific extensions to [`File`].\n-///\n-/// [`File`]: ../../../fs/struct.File.html\n+/// Windows-specific extensions to [`fs::File`].\n #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n pub trait FileExt {\n     /// Seeks to a given position and reads a number of bytes.\n@@ -94,8 +92,6 @@ impl FileExt for fs::File {\n }\n \n /// Windows-specific extensions to [`fs::OpenOptions`].\n-///\n-/// [`fs::OpenOptions`]: ../../../../std/fs/struct.OpenOptions.html\n #[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n pub trait OpenOptionsExt {\n     /// Overrides the `dwDesiredAccess` argument to the call to [`CreateFile`]\n@@ -295,7 +291,6 @@ impl OpenOptionsExt for OpenOptions {\n /// The data members that this trait exposes correspond to the members\n /// of the [`BY_HANDLE_FILE_INFORMATION`] structure.\n ///\n-/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n /// [`BY_HANDLE_FILE_INFORMATION`]:\n ///     https://docs.microsoft.com/en-us/windows/win32/api/fileapi/ns-fileapi-by_handle_file_information\n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n@@ -499,11 +494,9 @@ impl MetadataExt for Metadata {\n     }\n }\n \n-/// Windows-specific extensions to [`FileType`].\n+/// Windows-specific extensions to [`fs::FileType`].\n ///\n /// On Windows, a symbolic link knows whether it is a file or directory.\n-///\n-/// [`FileType`]: ../../../../std/fs/struct.FileType.html\n #[unstable(feature = \"windows_file_type_ext\", issue = \"none\")]\n pub trait FileTypeExt {\n     /// Returns `true` if this file type is a symbolic link that is also a directory."}, {"sha": "61e4c6a1d1718d6a44a82cf6a17ae0ed94a95120", "filename": "library/std/src/sys/windows/ext/process.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e6d6e5f535321c2223f044caba16f97b825009c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e6d6e5f535321c2223f044caba16f97b825009c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fext%2Fprocess.rs?ref=7e6d6e5f535321c2223f044caba16f97b825009c", "patch": "@@ -73,8 +73,6 @@ impl IntoRawHandle for process::ChildStderr {\n }\n \n /// Windows-specific extensions to [`process::ExitStatus`].\n-///\n-/// [`process::ExitStatus`]: ../../../../std/process/struct.ExitStatus.html\n #[stable(feature = \"exit_status_from\", since = \"1.12.0\")]\n pub trait ExitStatusExt {\n     /// Creates a new `ExitStatus` from the raw underlying `u32` return value of\n@@ -91,8 +89,6 @@ impl ExitStatusExt for process::ExitStatus {\n }\n \n /// Windows-specific extensions to the [`process::Command`] builder.\n-///\n-/// [`process::Command`]: ../../../../std/process/struct.Command.html\n #[stable(feature = \"windows_process_extensions\", since = \"1.16.0\")]\n pub trait CommandExt {\n     /// Sets the [process creation flags][1] to be passed to `CreateProcess`."}, {"sha": "9f6a7f2e5db449e27827646d6f2b672c319957da", "filename": "src/ci/docker/scripts/emscripten.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Fci%2Fdocker%2Fscripts%2Femscripten.sh", "raw_url": "https://github.com/rust-lang/rust/raw/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Fci%2Fdocker%2Fscripts%2Femscripten.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Femscripten.sh?ref=7e6d6e5f535321c2223f044caba16f97b825009c", "patch": "@@ -19,5 +19,5 @@ exit 1\n \n git clone https://github.com/emscripten-core/emsdk.git /emsdk-portable\n cd /emsdk-portable\n-hide_output ./emsdk install 1.38.46-upstream\n-./emsdk activate 1.38.46-upstream\n+hide_output ./emsdk install 1.38.47-upstream\n+./emsdk activate 1.38.47-upstream"}, {"sha": "699f5c9778a2f4338dcfd323470b5bab1303a947", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=7e6d6e5f535321c2223f044caba16f97b825009c", "patch": "@@ -5,7 +5,7 @@ use crate::Arena;\n use rustc_ast::ast::*;\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::ptr::P;\n-use rustc_ast::visit::{self, AssocCtxt, Visitor};\n+use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n@@ -75,6 +75,18 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n         }\n     }\n \n+    fn visit_fn(&mut self, fk: FnKind<'a>, sp: Span, _: NodeId) {\n+        match fk {\n+            FnKind::Fn(FnCtxt::Foreign, _, sig, _, _) => {\n+                self.visit_fn_header(&sig.header);\n+                visit::walk_fn_decl(self, &sig.decl);\n+                // Don't visit the foreign function body even if it has one, since lowering the\n+                // body would have no meaning and will have already been caught as a parse error.\n+            }\n+            _ => visit::walk_fn(self, fk, sp),\n+        }\n+    }\n+\n     fn visit_assoc_item(&mut self, item: &'a AssocItem, ctxt: AssocCtxt) {\n         self.lctx.with_hir_id_owner(item.id, |lctx| match ctxt {\n             AssocCtxt::Trait => {"}, {"sha": "51cc1ada432dc7bf9b47c29bf4086db92a5544be", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=7e6d6e5f535321c2223f044caba16f97b825009c", "patch": "@@ -61,7 +61,7 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n     let mut reachable_non_generics: DefIdMap<_> = tcx\n         .reachable_set(LOCAL_CRATE)\n         .iter()\n-        .filter_map(|&hir_id| {\n+        .filter_map(|&def_id| {\n             // We want to ignore some FFI functions that are not exposed from\n             // this crate. Reachable FFI functions can be lumped into two\n             // categories:\n@@ -75,9 +75,8 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n             //\n             // As a result, if this id is an FFI item (foreign item) then we only\n             // let it through if it's included statically.\n-            match tcx.hir().get(hir_id) {\n+            match tcx.hir().get(tcx.hir().local_def_id_to_hir_id(def_id)) {\n                 Node::ForeignItem(..) => {\n-                    let def_id = tcx.hir().local_def_id(hir_id);\n                     tcx.is_statically_included_foreign_item(def_id).then_some(def_id)\n                 }\n \n@@ -87,7 +86,6 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n                     ..\n                 })\n                 | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }) => {\n-                    let def_id = tcx.hir().local_def_id(hir_id);\n                     let generics = tcx.generics_of(def_id);\n                     if !generics.requires_monomorphization(tcx)\n                         // Functions marked with #[inline] are codegened with \"internal\"\n@@ -361,7 +359,7 @@ fn upstream_drop_glue_for_provider<'tcx>(\n \n fn is_unreachable_local_definition_provider(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     if let Some(def_id) = def_id.as_local() {\n-        !tcx.reachable_set(LOCAL_CRATE).contains(&tcx.hir().local_def_id_to_hir_id(def_id))\n+        !tcx.reachable_set(LOCAL_CRATE).contains(&def_id)\n     } else {\n         bug!(\"is_unreachable_local_definition called with non-local DefId: {:?}\", def_id)\n     }"}, {"sha": "d874edf627472362fd7740a067c0c278405a3a60", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=7e6d6e5f535321c2223f044caba16f97b825009c", "patch": "@@ -740,7 +740,8 @@ rustc_queries! {\n     }\n \n     Other {\n-        query reachable_set(_: CrateNum) -> &'tcx HirIdSet {\n+        query reachable_set(_: CrateNum) -> FxHashSet<LocalDefId> {\n+            storage(ArenaCacheSelector<'tcx>)\n             desc { \"reachability\" }\n         }\n "}, {"sha": "ede28522000afcde48b0b1d645b2db3737845030", "filename": "src/librustc_middle/ty/consts/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Flibrustc_middle%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Flibrustc_middle%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fconsts%2Fkind.rs?ref=7e6d6e5f535321c2223f044caba16f97b825009c", "patch": "@@ -34,7 +34,7 @@ pub enum ConstKind<'tcx> {\n \n     /// A placeholder for a const which could not be computed; this is\n     /// propagated to avoid useless error messages.\n-    Error(ty::sty::DelaySpanBugEmitted),\n+    Error(ty::DelaySpanBugEmitted),\n }\n \n #[cfg(target_arch = \"x86_64\")]"}, {"sha": "d7eeaafbf46bfb467ce4aad3f8992b897ab15265", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=7e6d6e5f535321c2223f044caba16f97b825009c", "patch": "@@ -65,6 +65,12 @@ use std::mem;\n use std::ops::{Bound, Deref};\n use std::sync::Arc;\n \n+/// A type that is not publicly constructable. This prevents people from making `TyKind::Error`\n+/// except through `tcx.err*()`, which are in this module.\n+#[derive(Copy, Clone, Debug, Eq, Hash, PartialEq, PartialOrd, Ord)]\n+#[derive(TyEncodable, TyDecodable, HashStable)]\n+pub struct DelaySpanBugEmitted(());\n+\n type InternedSet<'tcx, T> = ShardedHashMap<Interned<'tcx, T>, ()>;\n \n pub struct CtxtInterners<'tcx> {\n@@ -1171,18 +1177,15 @@ impl<'tcx> TyCtxt<'tcx> {\n     #[track_caller]\n     pub fn ty_error_with_message<S: Into<MultiSpan>>(self, span: S, msg: &str) -> Ty<'tcx> {\n         self.sess.delay_span_bug(span, msg);\n-        self.mk_ty(Error(super::sty::DelaySpanBugEmitted(())))\n+        self.mk_ty(Error(DelaySpanBugEmitted(())))\n     }\n \n     /// Like `err` but for constants.\n     #[track_caller]\n     pub fn const_error(self, ty: Ty<'tcx>) -> &'tcx Const<'tcx> {\n         self.sess\n             .delay_span_bug(DUMMY_SP, \"ty::ConstKind::Error constructed but no error reported.\");\n-        self.mk_const(ty::Const {\n-            val: ty::ConstKind::Error(super::sty::DelaySpanBugEmitted(())),\n-            ty,\n-        })\n+        self.mk_const(ty::Const { val: ty::ConstKind::Error(DelaySpanBugEmitted(())), ty })\n     }\n \n     pub fn consider_optimizing<T: Fn() -> String>(&self, msg: T) -> bool {"}, {"sha": "3c79fe12255799fc581a5ebdfb78ca9eb3482aab", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=7e6d6e5f535321c2223f044caba16f97b825009c", "patch": "@@ -60,6 +60,7 @@ pub use self::sty::{Binder, BoundTy, BoundTyKind, BoundVar, DebruijnIndex, INNER\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n pub use self::sty::{CanonicalPolyFnSig, FnSig, GenSig, PolyFnSig, PolyGenSig};\n pub use self::sty::{ClosureSubsts, GeneratorSubsts, TypeAndMut, UpvarSubsts};\n+pub use self::sty::{ClosureSubstsParts, GeneratorSubstsParts};\n pub use self::sty::{ConstVid, FloatVid, IntVid, RegionVid, TyVid};\n pub use self::sty::{ExistentialPredicate, InferTy, ParamConst, ParamTy, ProjectionTy};\n pub use self::sty::{ExistentialProjection, PolyExistentialProjection};\n@@ -72,8 +73,8 @@ pub use self::binding::BindingMode::*;\n \n pub use self::context::{tls, FreeRegionInfo, TyCtxt};\n pub use self::context::{\n-    CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, ResolvedOpaqueTy,\n-    UserType, UserTypeAnnotationIndex,\n+    CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n+    DelaySpanBugEmitted, ResolvedOpaqueTy, UserType, UserTypeAnnotationIndex,\n };\n pub use self::context::{\n     CtxtInterners, GeneratorInteriorTypeCause, GlobalCtxt, Lift, TypeckResults,"}, {"sha": "4d820f75c56c457da3cb5a12e1c30cf5df6f1202", "filename": "src/librustc_middle/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs?ref=7e6d6e5f535321c2223f044caba16f97b825009c", "patch": "@@ -43,7 +43,7 @@ use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId};\n use rustc_hir::lang_items::{LangItem, LanguageItems};\n-use rustc_hir::{Crate, HirIdSet, ItemLocalId, TraitCandidate};\n+use rustc_hir::{Crate, ItemLocalId, TraitCandidate};\n use rustc_index::{bit_set::FiniteBitSet, vec::IndexVec};\n use rustc_session::config::{EntryFnType, OptLevel, OutputFilenames, SymbolManglingVersion};\n use rustc_session::utils::NativeLibKind;"}, {"sha": "82160681ee8cf374f40d2abcb6e211a645cc4fa4", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 68, "deletions": 34, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=7e6d6e5f535321c2223f044caba16f97b825009c", "patch": "@@ -10,7 +10,7 @@ use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n use crate::ty::{\n     self, AdtDef, DefIdTree, Discr, Ty, TyCtxt, TypeFlags, TypeFoldable, WithConstness,\n };\n-use crate::ty::{List, ParamEnv, TyS};\n+use crate::ty::{DelaySpanBugEmitted, List, ParamEnv, TyS};\n use polonius_engine::Atom;\n use rustc_ast::ast;\n use rustc_data_structures::captures::Captures;\n@@ -212,12 +212,6 @@ impl TyKind<'tcx> {\n     }\n }\n \n-/// A type that is not publicly constructable. This prevents people from making `TyKind::Error`\n-/// except through `tcx.err*()`.\n-#[derive(Copy, Clone, Debug, Eq, Hash, PartialEq, PartialOrd, Ord)]\n-#[derive(TyEncodable, TyDecodable, HashStable)]\n-pub struct DelaySpanBugEmitted(pub(super) ());\n-\n // `TyKind` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(TyKind<'_>, 24);\n@@ -325,24 +319,39 @@ pub struct ClosureSubsts<'tcx> {\n     pub substs: SubstsRef<'tcx>,\n }\n \n-/// Struct returned by `split()`. Note that these are subslices of the\n-/// parent slice and not canonical substs themselves.\n-struct SplitClosureSubsts<'tcx> {\n-    parent: &'tcx [GenericArg<'tcx>],\n-    closure_kind_ty: GenericArg<'tcx>,\n-    closure_sig_as_fn_ptr_ty: GenericArg<'tcx>,\n-    tupled_upvars_ty: GenericArg<'tcx>,\n+/// Struct returned by `split()`.\n+pub struct ClosureSubstsParts<'tcx, T> {\n+    pub parent_substs: &'tcx [GenericArg<'tcx>],\n+    pub closure_kind_ty: T,\n+    pub closure_sig_as_fn_ptr_ty: T,\n+    pub tupled_upvars_ty: T,\n }\n \n impl<'tcx> ClosureSubsts<'tcx> {\n-    /// Divides the closure substs into their respective\n-    /// components. Single source of truth with respect to the\n-    /// ordering.\n-    fn split(self) -> SplitClosureSubsts<'tcx> {\n+    /// Construct `ClosureSubsts` from `ClosureSubstsParts`, containing `Substs`\n+    /// for the closure parent, alongside additional closure-specific components.\n+    pub fn new(\n+        tcx: TyCtxt<'tcx>,\n+        parts: ClosureSubstsParts<'tcx, Ty<'tcx>>,\n+    ) -> ClosureSubsts<'tcx> {\n+        ClosureSubsts {\n+            substs: tcx.mk_substs(\n+                parts.parent_substs.iter().copied().chain(\n+                    [parts.closure_kind_ty, parts.closure_sig_as_fn_ptr_ty, parts.tupled_upvars_ty]\n+                        .iter()\n+                        .map(|&ty| ty.into()),\n+                ),\n+            ),\n+        }\n+    }\n+\n+    /// Divides the closure substs into their respective components.\n+    /// The ordering assumed here must match that used by `ClosureSubsts::new` above.\n+    fn split(self) -> ClosureSubstsParts<'tcx, GenericArg<'tcx>> {\n         match self.substs[..] {\n-            [ref parent @ .., closure_kind_ty, closure_sig_as_fn_ptr_ty, tupled_upvars_ty] => {\n-                SplitClosureSubsts {\n-                    parent,\n+            [ref parent_substs @ .., closure_kind_ty, closure_sig_as_fn_ptr_ty, tupled_upvars_ty] => {\n+                ClosureSubstsParts {\n+                    parent_substs,\n                     closure_kind_ty,\n                     closure_sig_as_fn_ptr_ty,\n                     tupled_upvars_ty,\n@@ -363,7 +372,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n \n     /// Returns the substitutions of the closure's parent.\n     pub fn parent_substs(self) -> &'tcx [GenericArg<'tcx>] {\n-        self.split().parent\n+        self.split().parent_substs\n     }\n \n     #[inline]\n@@ -418,21 +427,46 @@ pub struct GeneratorSubsts<'tcx> {\n     pub substs: SubstsRef<'tcx>,\n }\n \n-struct SplitGeneratorSubsts<'tcx> {\n-    parent: &'tcx [GenericArg<'tcx>],\n-    resume_ty: GenericArg<'tcx>,\n-    yield_ty: GenericArg<'tcx>,\n-    return_ty: GenericArg<'tcx>,\n-    witness: GenericArg<'tcx>,\n-    tupled_upvars_ty: GenericArg<'tcx>,\n+pub struct GeneratorSubstsParts<'tcx, T> {\n+    pub parent_substs: &'tcx [GenericArg<'tcx>],\n+    pub resume_ty: T,\n+    pub yield_ty: T,\n+    pub return_ty: T,\n+    pub witness: T,\n+    pub tupled_upvars_ty: T,\n }\n \n impl<'tcx> GeneratorSubsts<'tcx> {\n-    fn split(self) -> SplitGeneratorSubsts<'tcx> {\n+    /// Construct `GeneratorSubsts` from `GeneratorSubstsParts`, containing `Substs`\n+    /// for the generator parent, alongside additional generator-specific components.\n+    pub fn new(\n+        tcx: TyCtxt<'tcx>,\n+        parts: GeneratorSubstsParts<'tcx, Ty<'tcx>>,\n+    ) -> GeneratorSubsts<'tcx> {\n+        GeneratorSubsts {\n+            substs: tcx.mk_substs(\n+                parts.parent_substs.iter().copied().chain(\n+                    [\n+                        parts.resume_ty,\n+                        parts.yield_ty,\n+                        parts.return_ty,\n+                        parts.witness,\n+                        parts.tupled_upvars_ty,\n+                    ]\n+                    .iter()\n+                    .map(|&ty| ty.into()),\n+                ),\n+            ),\n+        }\n+    }\n+\n+    /// Divides the generator substs into their respective components.\n+    /// The ordering assumed here must match that used by `GeneratorSubsts::new` above.\n+    fn split(self) -> GeneratorSubstsParts<'tcx, GenericArg<'tcx>> {\n         match self.substs[..] {\n-            [ref parent @ .., resume_ty, yield_ty, return_ty, witness, tupled_upvars_ty] => {\n-                SplitGeneratorSubsts {\n-                    parent,\n+            [ref parent_substs @ .., resume_ty, yield_ty, return_ty, witness, tupled_upvars_ty] => {\n+                GeneratorSubstsParts {\n+                    parent_substs,\n                     resume_ty,\n                     yield_ty,\n                     return_ty,\n@@ -455,7 +489,7 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n \n     /// Returns the substitutions of the generator's parent.\n     pub fn parent_substs(self) -> &'tcx [GenericArg<'tcx>] {\n-        self.split().parent\n+        self.split().parent_substs\n     }\n \n     /// This describes the types that can be contained in a generator."}, {"sha": "8d5c980609cd9a99c7d921e1ce4acf19bfadd8ce", "filename": "src/librustc_passes/reachable.rs", "status": "modified", "additions": 49, "deletions": 50, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Flibrustc_passes%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Flibrustc_passes%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Freachable.rs?ref=7e6d6e5f535321c2223f044caba16f97b825009c", "patch": "@@ -12,11 +12,11 @@ use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_hir::{HirIdSet, Node};\n+use rustc_hir::Node;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::middle::privacy;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, TyCtxt};\n+use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n use rustc_session::config::CrateType;\n use rustc_target::spec::abi::Abi;\n \n@@ -65,10 +65,11 @@ struct ReachableContext<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     maybe_typeck_results: Option<&'tcx ty::TypeckResults<'tcx>>,\n     // The set of items which must be exported in the linkage sense.\n-    reachable_symbols: HirIdSet,\n+    reachable_symbols: FxHashSet<LocalDefId>,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n     // and will be scanned for further references.\n-    worklist: Vec<hir::HirId>,\n+    // FIXME(eddyb) benchmark if this would be faster as a `VecDeque`.\n+    worklist: Vec<LocalDefId>,\n     // Whether any output of this compilation is a library\n     any_library: bool,\n }\n@@ -100,37 +101,27 @@ impl<'tcx> Visitor<'tcx> for ReachableContext<'tcx> {\n             _ => None,\n         };\n \n-        match res {\n-            Some(Res::Local(hir_id)) => {\n-                self.reachable_symbols.insert(hir_id);\n-            }\n-            Some(res) => {\n-                if let Some((hir_id, def_id)) = res.opt_def_id().and_then(|def_id| {\n-                    def_id\n-                        .as_local()\n-                        .map(|def_id| (self.tcx.hir().local_def_id_to_hir_id(def_id), def_id))\n-                }) {\n-                    if self.def_id_represents_local_inlined_item(def_id.to_def_id()) {\n-                        self.worklist.push(hir_id);\n-                    } else {\n-                        match res {\n-                            // If this path leads to a constant, then we need to\n-                            // recurse into the constant to continue finding\n-                            // items that are reachable.\n-                            Res::Def(DefKind::Const | DefKind::AssocConst, _) => {\n-                                self.worklist.push(hir_id);\n-                            }\n+        if let Some(res) = res {\n+            if let Some(def_id) = res.opt_def_id().and_then(|def_id| def_id.as_local()) {\n+                if self.def_id_represents_local_inlined_item(def_id.to_def_id()) {\n+                    self.worklist.push(def_id);\n+                } else {\n+                    match res {\n+                        // If this path leads to a constant, then we need to\n+                        // recurse into the constant to continue finding\n+                        // items that are reachable.\n+                        Res::Def(DefKind::Const | DefKind::AssocConst, _) => {\n+                            self.worklist.push(def_id);\n+                        }\n \n-                            // If this wasn't a static, then the destination is\n-                            // surely reachable.\n-                            _ => {\n-                                self.reachable_symbols.insert(hir_id);\n-                            }\n+                        // If this wasn't a static, then the destination is\n+                        // surely reachable.\n+                        _ => {\n+                            self.reachable_symbols.insert(def_id);\n                         }\n                     }\n                 }\n             }\n-            _ => {}\n         }\n \n         intravisit::walk_expr(self, expr)\n@@ -209,13 +200,15 @@ impl<'tcx> ReachableContext<'tcx> {\n                 continue;\n             }\n \n-            if let Some(ref item) = self.tcx.hir().find(search_item) {\n+            if let Some(ref item) =\n+                self.tcx.hir().find(self.tcx.hir().local_def_id_to_hir_id(search_item))\n+            {\n                 self.propagate_node(item, search_item);\n             }\n         }\n     }\n \n-    fn propagate_node(&mut self, node: &Node<'tcx>, search_item: hir::HirId) {\n+    fn propagate_node(&mut self, node: &Node<'tcx>, search_item: LocalDefId) {\n         if !self.any_library {\n             // If we are building an executable, only explicitly extern\n             // types need to be exported.\n@@ -297,8 +290,9 @@ impl<'tcx> ReachableContext<'tcx> {\n                     self.visit_nested_body(body);\n                 }\n                 hir::ImplItemKind::Fn(_, body) => {\n-                    let did = self.tcx.hir().get_parent_did(search_item);\n-                    if method_might_be_inlined(self.tcx, impl_item, did) {\n+                    let impl_def_id =\n+                        self.tcx.parent(search_item.to_def_id()).unwrap().expect_local();\n+                    if method_might_be_inlined(self.tcx, impl_item, impl_def_id) {\n                         self.visit_nested_body(body)\n                     }\n                 }\n@@ -317,7 +311,9 @@ impl<'tcx> ReachableContext<'tcx> {\n             _ => {\n                 bug!(\n                     \"found unexpected node kind in worklist: {} ({:?})\",\n-                    self.tcx.hir().node_to_string(search_item),\n+                    self.tcx\n+                        .hir()\n+                        .node_to_string(self.tcx.hir().local_def_id_to_hir_id(search_item)),\n                     node,\n                 );\n             }\n@@ -336,7 +332,7 @@ impl<'tcx> ReachableContext<'tcx> {\n struct CollectPrivateImplItemsVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     access_levels: &'a privacy::AccessLevels,\n-    worklist: &'a mut Vec<hir::HirId>,\n+    worklist: &'a mut Vec<LocalDefId>,\n }\n \n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx> {\n@@ -349,13 +345,16 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx\n         if codegen_attrs.contains_extern_indicator()\n             || codegen_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL)\n         {\n-            self.worklist.push(item.hir_id);\n+            self.worklist.push(def_id);\n         }\n \n         // We need only trait impls here, not inherent impls, and only non-exported ones\n         if let hir::ItemKind::Impl { of_trait: Some(ref trait_ref), ref items, .. } = item.kind {\n             if !self.access_levels.is_reachable(item.hir_id) {\n-                self.worklist.extend(items.iter().map(|ii_ref| ii_ref.id.hir_id));\n+                // FIXME(#53488) remove `let`\n+                let tcx = self.tcx;\n+                self.worklist\n+                    .extend(items.iter().map(|ii_ref| tcx.hir().local_def_id(ii_ref.id.hir_id)));\n \n                 let trait_def_id = match trait_ref.path.res {\n                     Res::Def(DefKind::Trait, def_id) => def_id,\n@@ -366,12 +365,10 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx\n                     return;\n                 }\n \n-                // FIXME(#53488) remove `let`\n-                let tcx = self.tcx;\n-                self.worklist\n-                    .extend(tcx.provided_trait_methods(trait_def_id).map(|assoc| {\n-                        tcx.hir().local_def_id_to_hir_id(assoc.def_id.expect_local())\n-                    }));\n+                self.worklist.extend(\n+                    tcx.provided_trait_methods(trait_def_id)\n+                        .map(|assoc| assoc.def_id.expect_local()),\n+                );\n             }\n         }\n     }\n@@ -383,7 +380,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx\n     }\n }\n \n-fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> &'tcx HirIdSet {\n+fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> FxHashSet<LocalDefId> {\n     debug_assert!(crate_num == LOCAL_CRATE);\n \n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n@@ -405,11 +402,13 @@ fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> &'tcx HirIdSet\n     //         If other crates link to us, they're going to expect to be able to\n     //         use the lang items, so we need to be sure to mark them as\n     //         exported.\n-    reachable_context.worklist.extend(access_levels.map.iter().map(|(id, _)| *id));\n+    reachable_context\n+        .worklist\n+        .extend(access_levels.map.iter().map(|(id, _)| tcx.hir().local_def_id(*id)));\n     for item in tcx.lang_items().items().iter() {\n-        if let Some(did) = *item {\n-            if let Some(hir_id) = did.as_local().map(|did| tcx.hir().local_def_id_to_hir_id(did)) {\n-                reachable_context.worklist.push(hir_id);\n+        if let Some(def_id) = *item {\n+            if let Some(def_id) = def_id.as_local() {\n+                reachable_context.worklist.push(def_id);\n             }\n         }\n     }\n@@ -428,7 +427,7 @@ fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> &'tcx HirIdSet\n     debug!(\"Inline reachability shows: {:?}\", reachable_context.reachable_symbols);\n \n     // Return the set of reachable symbols.\n-    tcx.arena.alloc(reachable_context.reachable_symbols)\n+    reachable_context.reachable_symbols\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "f10f9b2ce93c5bb35fe74b1771bbae3204e235bf", "filename": "src/librustc_session/session.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Flibrustc_session%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Flibrustc_session%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsession.rs?ref=7e6d6e5f535321c2223f044caba16f97b825009c", "patch": "@@ -437,6 +437,7 @@ impl Session {\n         }\n     }\n     /// Delay a span_bug() call until abort_if_errors()\n+    #[track_caller]\n     pub fn delay_span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.diagnostic().delay_span_bug(sp, msg)\n     }"}, {"sha": "c7f9e9d63e03c576a21a595dd72144437b5d5040", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 50, "deletions": 55, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=7e6d6e5f535321c2223f044caba16f97b825009c", "patch": "@@ -11,7 +11,7 @@ use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_infer::infer::{InferOk, InferResult};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::InternalSubsts;\n-use rustc_middle::ty::{self, GenericParamDefKind, Ty};\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::source_map::Span;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::ArgKind;\n@@ -76,60 +76,44 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let generator_types =\n             check_fn(self, self.param_env, liberated_sig, decl, expr.hir_id, body, gen).1;\n \n-        let base_substs = InternalSubsts::identity_for_item(\n+        let parent_substs = InternalSubsts::identity_for_item(\n             self.tcx,\n             self.tcx.closure_base_def_id(expr_def_id.to_def_id()),\n         );\n-        // HACK(eddyb) this hardcodes indices into substs but it should rely on\n-        // `ClosureSubsts` and `GeneratorSubsts` providing constructors, instead.\n-        // That would also remove the need for most of the inference variables,\n-        // as they immediately unified with the actual type below, including\n-        // the `InferCtxt::closure_sig` and `ClosureSubsts::sig_ty` methods.\n-        let tupled_upvars_idx = base_substs.len() + if generator_types.is_some() { 4 } else { 2 };\n-        let substs =\n-            base_substs.extend_to(self.tcx, expr_def_id.to_def_id(), |param, _| match param.kind {\n-                GenericParamDefKind::Lifetime => span_bug!(expr.span, \"closure has lifetime param\"),\n-                GenericParamDefKind::Type { .. } => if param.index as usize == tupled_upvars_idx {\n-                    self.tcx.mk_tup(self.tcx.upvars_mentioned(expr_def_id).iter().flat_map(\n-                        |upvars| {\n-                            upvars.iter().map(|(&var_hir_id, _)| {\n-                                // Create type variables (for now) to represent the transformed\n-                                // types of upvars. These will be unified during the upvar\n-                                // inference phase (`upvar.rs`).\n-                                self.infcx.next_ty_var(TypeVariableOrigin {\n-                                    // FIXME(eddyb) distinguish upvar inference variables from the rest.\n-                                    kind: TypeVariableOriginKind::ClosureSynthetic,\n-                                    span: self.tcx.hir().span(var_hir_id),\n-                                })\n-                            })\n-                        },\n-                    ))\n-                } else {\n-                    // Create type variables (for now) to represent the various\n-                    // pieces of information kept in `{Closure,Generic}Substs`.\n-                    // They will either be unified below, or later during the upvar\n-                    // inference phase (`upvar.rs`)\n+\n+        let tupled_upvars_ty =\n+            self.tcx.mk_tup(self.tcx.upvars_mentioned(expr_def_id).iter().flat_map(|upvars| {\n+                upvars.iter().map(|(&var_hir_id, _)| {\n+                    // Create type variables (for now) to represent the transformed\n+                    // types of upvars. These will be unified during the upvar\n+                    // inference phase (`upvar.rs`).\n                     self.infcx.next_ty_var(TypeVariableOrigin {\n+                        // FIXME(eddyb) distinguish upvar inference variables from the rest.\n                         kind: TypeVariableOriginKind::ClosureSynthetic,\n-                        span: expr.span,\n+                        span: self.tcx.hir().span(var_hir_id),\n                     })\n-                }\n-                .into(),\n-                GenericParamDefKind::Const => span_bug!(expr.span, \"closure has const param\"),\n-            });\n+                })\n+            }));\n+\n         if let Some(GeneratorTypes { resume_ty, yield_ty, interior, movability }) = generator_types\n         {\n-            let generator_substs = substs.as_generator();\n-            self.demand_eqtype(expr.span, resume_ty, generator_substs.resume_ty());\n-            self.demand_eqtype(expr.span, yield_ty, generator_substs.yield_ty());\n-            self.demand_eqtype(expr.span, liberated_sig.output(), generator_substs.return_ty());\n-            self.demand_eqtype(expr.span, interior, generator_substs.witness());\n-\n-            // HACK(eddyb) this forces the types equated above into `substs` but\n-            // it should rely on `GeneratorSubsts` providing a constructor, instead.\n-            let substs = self.resolve_vars_if_possible(&substs);\n+            let generator_substs = ty::GeneratorSubsts::new(\n+                self.tcx,\n+                ty::GeneratorSubstsParts {\n+                    parent_substs,\n+                    resume_ty,\n+                    yield_ty,\n+                    return_ty: liberated_sig.output(),\n+                    witness: interior,\n+                    tupled_upvars_ty,\n+                },\n+            );\n \n-            return self.tcx.mk_generator(expr_def_id.to_def_id(), substs, movability);\n+            return self.tcx.mk_generator(\n+                expr_def_id.to_def_id(),\n+                generator_substs.substs,\n+                movability,\n+            );\n         }\n \n         // Tuple up the arguments and insert the resulting function type into\n@@ -149,18 +133,29 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             expr_def_id, sig, opt_kind\n         );\n \n-        let sig_fn_ptr_ty = self.tcx.mk_fn_ptr(sig);\n-        self.demand_eqtype(expr.span, sig_fn_ptr_ty, substs.as_closure().sig_as_fn_ptr_ty());\n+        let closure_kind_ty = match opt_kind {\n+            Some(kind) => kind.to_ty(self.tcx),\n \n-        if let Some(kind) = opt_kind {\n-            self.demand_eqtype(expr.span, kind.to_ty(self.tcx), substs.as_closure().kind_ty());\n-        }\n+            // Create a type variable (for now) to represent the closure kind.\n+            // It will be unified during the upvar inference phase (`upvar.rs`)\n+            None => self.infcx.next_ty_var(TypeVariableOrigin {\n+                // FIXME(eddyb) distinguish closure kind inference variables from the rest.\n+                kind: TypeVariableOriginKind::ClosureSynthetic,\n+                span: expr.span,\n+            }),\n+        };\n \n-        // HACK(eddyb) this forces the types equated above into `substs` but\n-        // it should rely on `ClosureSubsts` providing a constructor, instead.\n-        let substs = self.resolve_vars_if_possible(&substs);\n+        let closure_substs = ty::ClosureSubsts::new(\n+            self.tcx,\n+            ty::ClosureSubstsParts {\n+                parent_substs,\n+                closure_kind_ty,\n+                closure_sig_as_fn_ptr_ty: self.tcx.mk_fn_ptr(sig),\n+                tupled_upvars_ty,\n+            },\n+        );\n \n-        let closure_type = self.tcx.mk_closure(expr_def_id.to_def_id(), substs);\n+        let closure_type = self.tcx.mk_closure(expr_def_id.to_def_id(), closure_substs.substs);\n \n         debug!(\"check_closure: expr.hir_id={:?} closure_type={:?}\", expr.hir_id, closure_type);\n "}, {"sha": "a84065e02186855cbb0f6e4241eb0576638b005f", "filename": "src/test/ui/foreign/issue-74120-lowering-of-ffi-block-bodies.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Ftest%2Fui%2Fforeign%2Fissue-74120-lowering-of-ffi-block-bodies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Ftest%2Fui%2Fforeign%2Fissue-74120-lowering-of-ffi-block-bodies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fforeign%2Fissue-74120-lowering-of-ffi-block-bodies.rs?ref=7e6d6e5f535321c2223f044caba16f97b825009c", "patch": "@@ -0,0 +1,11 @@\n+// Previously this ICE'd because `fn g()` would be lowered, but the block associated with `fn f()`\n+// wasn't.\n+\n+// compile-flags: --crate-type=lib\n+\n+extern \"C\" {\n+    fn f() {\n+    //~^ incorrect function inside `extern` block\n+        fn g() {}\n+    }\n+}"}, {"sha": "d4a9ca3e7c66ef8d9362cd3fd6279b47dc64c8f6", "filename": "src/test/ui/foreign/issue-74120-lowering-of-ffi-block-bodies.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Ftest%2Fui%2Fforeign%2Fissue-74120-lowering-of-ffi-block-bodies.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Ftest%2Fui%2Fforeign%2Fissue-74120-lowering-of-ffi-block-bodies.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fforeign%2Fissue-74120-lowering-of-ffi-block-bodies.stderr?ref=7e6d6e5f535321c2223f044caba16f97b825009c", "patch": "@@ -0,0 +1,19 @@\n+error: incorrect function inside `extern` block\n+  --> $DIR/issue-74120-lowering-of-ffi-block-bodies.rs:7:8\n+   |\n+LL |   extern \"C\" {\n+   |   ---------- `extern` blocks define existing foreign functions and functions inside of them cannot have a body\n+LL |       fn f() {\n+   |  ________^___-\n+   | |        |\n+   | |        cannot have a body\n+LL | |\n+LL | |         fn g() {}\n+LL | |     }\n+   | |_____- help: remove the invalid body: `;`\n+   |\n+   = help: you might have meant to write a function accessible through FFI, which can be done by writing `extern fn` outside of the `extern` block\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: aborting due to previous error\n+"}, {"sha": "ce42c8b01cc322a3ea536bb4d47b2788f1a92255", "filename": "src/test/ui/issues/issue-66768.rs", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Ftest%2Fui%2Fissues%2Fissue-66768.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e6d6e5f535321c2223f044caba16f97b825009c/src%2Ftest%2Fui%2Fissues%2Fissue-66768.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-66768.rs?ref=7e6d6e5f535321c2223f044caba16f97b825009c", "patch": "@@ -0,0 +1,205 @@\n+// Regression test for #66768.\n+// check-pass\n+#![allow(dead_code)]\n+//-^ \"dead code\" is needed to reproduce the issue.\n+\n+use std::marker::PhantomData;\n+use std::ops::{Add, Mul};\n+\n+fn problematic_function<Space>(material_surface_element: Edge2dElement)\n+where\n+    DefaultAllocator: FiniteElementAllocator<DimU1, Space>,\n+{\n+    let _: Point2<f64> = material_surface_element.map_reference_coords().into();\n+}\n+\n+impl<T> ArrayLength<T> for UTerm {\n+    type ArrayType = ();\n+}\n+impl<T, N: ArrayLength<T>> ArrayLength<T> for UInt<N, B0> {\n+    type ArrayType = GenericArrayImplEven<T, N>;\n+}\n+impl<T, N: ArrayLength<T>> ArrayLength<T> for UInt<N, B1> {\n+    type ArrayType = GenericArrayImplOdd<T, N>;\n+}\n+impl<U> Add<U> for UTerm {\n+    type Output = U;\n+    fn add(self, _: U) -> Self::Output {\n+        unimplemented!()\n+    }\n+}\n+impl<Ul, Ur> Add<UInt<Ur, B1>> for UInt<Ul, B0>\n+where\n+    Ul: Add<Ur>,\n+{\n+    type Output = UInt<Sum<Ul, Ur>, B1>;\n+    fn add(self, _: UInt<Ur, B1>) -> Self::Output {\n+        unimplemented!()\n+    }\n+}\n+impl<U> Mul<U> for UTerm {\n+    type Output = UTerm;\n+    fn mul(self, _: U) -> Self {\n+        unimplemented!()\n+    }\n+}\n+impl<Ul, B, Ur> Mul<UInt<Ur, B>> for UInt<Ul, B0>\n+where\n+    Ul: Mul<UInt<Ur, B>>,\n+{\n+    type Output = UInt<Prod<Ul, UInt<Ur, B>>, B0>;\n+    fn mul(self, _: UInt<Ur, B>) -> Self::Output {\n+        unimplemented!()\n+    }\n+}\n+impl<Ul, B, Ur> Mul<UInt<Ur, B>> for UInt<Ul, B1>\n+where\n+    Ul: Mul<UInt<Ur, B>>,\n+    UInt<Prod<Ul, UInt<Ur, B>>, B0>: Add<UInt<Ur, B>>,\n+{\n+    type Output = Sum<UInt<Prod<Ul, UInt<Ur, B>>, B0>, UInt<Ur, B>>;\n+    fn mul(self, _: UInt<Ur, B>) -> Self::Output {\n+        unimplemented!()\n+    }\n+}\n+impl<N, R, C> Allocator<N, R, C> for DefaultAllocator\n+where\n+    R: DimName,\n+    C: DimName,\n+    R::Value: Mul<C::Value>,\n+    Prod<R::Value, C::Value>: ArrayLength<N>,\n+{\n+    type Buffer = ArrayStorage<N, R, C>;\n+    fn allocate_uninitialized(_: R, _: C) -> Self::Buffer {\n+        unimplemented!()\n+    }\n+    fn allocate_from_iterator<I>(_: R, _: C, _: I) -> Self::Buffer {\n+        unimplemented!()\n+    }\n+}\n+impl<N, C> Allocator<N, Dynamic, C> for DefaultAllocator {\n+    type Buffer = VecStorage<N, Dynamic, C>;\n+    fn allocate_uninitialized(_: Dynamic, _: C) -> Self::Buffer {\n+        unimplemented!()\n+    }\n+    fn allocate_from_iterator<I>(_: Dynamic, _: C, _: I) -> Self::Buffer {\n+        unimplemented!()\n+    }\n+}\n+impl DimName for DimU1 {\n+    type Value = U1;\n+    fn name() -> Self {\n+        unimplemented!()\n+    }\n+}\n+impl DimName for DimU2 {\n+    type Value = U2;\n+    fn name() -> Self {\n+        unimplemented!()\n+    }\n+}\n+impl<N, D> From<VectorN<N, D>> for Point<N, D>\n+where\n+    DefaultAllocator: Allocator<N, D>,\n+{\n+    fn from(_: VectorN<N, D>) -> Self {\n+        unimplemented!()\n+    }\n+}\n+impl<GeometryDim, NodalDim> FiniteElementAllocator<GeometryDim, NodalDim> for DefaultAllocator where\n+    DefaultAllocator: Allocator<f64, GeometryDim> + Allocator<f64, NodalDim>\n+{\n+}\n+impl ReferenceFiniteElement for Edge2dElement {\n+    type NodalDim = DimU1;\n+}\n+impl FiniteElement<DimU2> for Edge2dElement {\n+    fn map_reference_coords(&self) -> Vector2<f64> {\n+        unimplemented!()\n+    }\n+}\n+\n+type Owned<N, R, C> = <DefaultAllocator as Allocator<N, R, C>>::Buffer;\n+type MatrixMN<N, R, C> = Matrix<N, R, C, Owned<N, R, C>>;\n+type VectorN<N, D> = MatrixMN<N, D, DimU1>;\n+type Vector2<N> = VectorN<N, DimU2>;\n+type Point2<N> = Point<N, DimU2>;\n+type U1 = UInt<UTerm, B1>;\n+type U2 = UInt<UInt<UTerm, B1>, B0>;\n+type Sum<A, B> = <A as Add<B>>::Output;\n+type Prod<A, B> = <A as Mul<B>>::Output;\n+\n+struct GenericArray<T, U: ArrayLength<T>> {\n+    _data: U::ArrayType,\n+}\n+struct GenericArrayImplEven<T, U> {\n+    _parent2: U,\n+    _marker: T,\n+}\n+struct GenericArrayImplOdd<T, U> {\n+    _parent2: U,\n+    _data: T,\n+}\n+struct B0;\n+struct B1;\n+struct UTerm;\n+struct UInt<U, B> {\n+    _marker: PhantomData<(U, B)>,\n+}\n+struct DefaultAllocator;\n+struct Dynamic;\n+struct DimU1;\n+struct DimU2;\n+struct Matrix<N, R, C, S> {\n+    _data: S,\n+    _phantoms: PhantomData<(N, R, C)>,\n+}\n+struct ArrayStorage<N, R, C>\n+where\n+    R: DimName,\n+    C: DimName,\n+    R::Value: Mul<C::Value>,\n+    Prod<R::Value, C::Value>: ArrayLength<N>,\n+{\n+    _data: GenericArray<N, Prod<R::Value, C::Value>>,\n+}\n+struct VecStorage<N, R, C> {\n+    _data: N,\n+    _nrows: R,\n+    _ncols: C,\n+}\n+struct Point<N, D>\n+where\n+    DefaultAllocator: Allocator<N, D>,\n+{\n+    _coords: VectorN<N, D>,\n+}\n+struct Edge2dElement;\n+\n+trait ArrayLength<T> {\n+    type ArrayType;\n+}\n+trait Allocator<Scalar, R, C = DimU1> {\n+    type Buffer;\n+    fn allocate_uninitialized(nrows: R, ncols: C) -> Self::Buffer;\n+    fn allocate_from_iterator<I>(nrows: R, ncols: C, iter: I) -> Self::Buffer;\n+}\n+trait DimName {\n+    type Value;\n+    fn name() -> Self;\n+}\n+trait FiniteElementAllocator<GeometryDim, NodalDim>:\n+    Allocator<f64, GeometryDim> + Allocator<f64, NodalDim>\n+{\n+}\n+trait ReferenceFiniteElement {\n+    type NodalDim;\n+}\n+trait FiniteElement<GeometryDim>: ReferenceFiniteElement\n+where\n+    DefaultAllocator: FiniteElementAllocator<GeometryDim, Self::NodalDim>,\n+{\n+    fn map_reference_coords(&self) -> VectorN<f64, GeometryDim>;\n+}\n+\n+fn main() {}"}]}