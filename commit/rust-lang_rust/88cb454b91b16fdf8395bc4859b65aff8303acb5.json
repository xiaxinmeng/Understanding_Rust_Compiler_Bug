{"sha": "88cb454b91b16fdf8395bc4859b65aff8303acb5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4Y2I0NTRiOTFiMTZmZGY4Mzk1YmM0ODU5YjY1YWZmODMwM2FjYjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-17T05:56:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-17T05:56:15Z"}, "message": "auto merge of #17160 : nick29581/rust/front, r=pcwalton\n\nr?", "tree": {"sha": "35f84503624d7c0973be64e046552c1c2a03ae2d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35f84503624d7c0973be64e046552c1c2a03ae2d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88cb454b91b16fdf8395bc4859b65aff8303acb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88cb454b91b16fdf8395bc4859b65aff8303acb5", "html_url": "https://github.com/rust-lang/rust/commit/88cb454b91b16fdf8395bc4859b65aff8303acb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88cb454b91b16fdf8395bc4859b65aff8303acb5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff613abaa2bbd7b443b17059b4927d8b4b1e82ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff613abaa2bbd7b443b17059b4927d8b4b1e82ff", "html_url": "https://github.com/rust-lang/rust/commit/ff613abaa2bbd7b443b17059b4927d8b4b1e82ff"}, {"sha": "3a01d0f1e3ab88a8b891a5cfeb552a78cbf69670", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a01d0f1e3ab88a8b891a5cfeb552a78cbf69670", "html_url": "https://github.com/rust-lang/rust/commit/3a01d0f1e3ab88a8b891a5cfeb552a78cbf69670"}], "stats": {"total": 353, "additions": 189, "deletions": 164}, "files": [{"sha": "20371f63a3427d7fe9e45dc35b1bbf86a7bccfee", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=88cb454b91b16fdf8395bc4859b65aff8303acb5", "patch": "@@ -13,7 +13,6 @@ use back::link;\n use back::write;\n use driver::session::Session;\n use driver::config;\n-use front;\n use lint;\n use llvm::{ContextRef, ModuleRef};\n use metadata::common::LinkMeta;\n@@ -166,7 +165,7 @@ pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n     }\n \n     if sess.show_span() {\n-        front::show_span::run(sess, &krate);\n+        syntax::show_span::run(sess.diagnostic(), &krate);\n     }\n \n     krate\n@@ -194,11 +193,29 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     *sess.crate_metadata.borrow_mut() =\n         collect_crate_metadata(sess, krate.attrs.as_slice());\n \n-    time(time_passes, \"gated feature checking\", (), |_|\n-         front::feature_gate::check_crate(sess, &krate));\n+    time(time_passes, \"gated feature checking\", (), |_| {\n+        let (features, unknown_features) =\n+            syntax::feature_gate::check_crate(&sess.parse_sess.span_diagnostic, &krate);\n+\n+        for uf in unknown_features.iter() {\n+            sess.add_lint(lint::builtin::UNKNOWN_FEATURES,\n+                          ast::CRATE_NODE_ID,\n+                          *uf,\n+                          \"unknown feature\".to_string());\n+        }\n+\n+        sess.abort_if_errors();\n+        *sess.features.borrow_mut() = features;\n+    });\n+\n+    let any_exe = sess.crate_types.borrow().iter().any(|ty| {\n+        *ty == config::CrateTypeExecutable\n+    });\n \n     krate = time(time_passes, \"crate injection\", krate, |krate|\n-                 front::std_inject::maybe_inject_crates_ref(sess, krate));\n+                 syntax::std_inject::maybe_inject_crates_ref(krate,\n+                                                             sess.opts.alt_std_name.clone(),\n+                                                             any_exe));\n \n     // strip before expansion to allow macros to depend on\n     // configuration variables e.g/ in\n@@ -209,7 +226,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     // baz! should not use this definition unless foo is enabled.\n \n     krate = time(time_passes, \"configuration 1\", krate, |krate|\n-                 front::config::strip_unconfigured_items(krate));\n+                 syntax::config::strip_unconfigured_items(krate));\n \n     let mut addl_plugins = Some(addl_plugins);\n     let Plugins { macros, registrars }\n@@ -219,7 +236,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     let mut registry = Registry::new(&krate);\n \n     time(time_passes, \"plugin registration\", (), |_| {\n-        if sess.features.rustc_diagnostic_macros.get() {\n+        if sess.features.borrow().rustc_diagnostic_macros {\n             registry.register_macro(\"__diagnostic_used\",\n                 diagnostics::plugin::expand_diagnostic_used);\n             registry.register_macro(\"__register_diagnostic\",\n@@ -271,7 +288,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n                 os::setenv(\"PATH\", os::join_paths(new_path.as_slice()).unwrap());\n             }\n             let cfg = syntax::ext::expand::ExpansionConfig {\n-                deriving_hash_type_parameter: sess.features.default_type_params.get(),\n+                deriving_hash_type_parameter: sess.features.borrow().default_type_params,\n                 crate_name: crate_name.to_string(),\n             };\n             let ret = syntax::ext::expand::expand_crate(&sess.parse_sess,\n@@ -290,13 +307,16 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n \n     // strip again, in case expansion added anything with a #[cfg].\n     krate = time(time_passes, \"configuration 2\", krate, |krate|\n-                 front::config::strip_unconfigured_items(krate));\n+                 syntax::config::strip_unconfigured_items(krate));\n \n     krate = time(time_passes, \"maybe building test harness\", krate, |krate|\n-                 front::test::modify_for_testing(sess, krate));\n+                 syntax::test::modify_for_testing(&sess.parse_sess,\n+                                                  &sess.opts.cfg,\n+                                                  krate,\n+                                                  sess.diagnostic()));\n \n     krate = time(time_passes, \"prelude injection\", krate, |krate|\n-                 front::std_inject::maybe_inject_prelude(sess, krate));\n+                 syntax::std_inject::maybe_inject_prelude(krate));\n \n     time(time_passes, \"checking that all macro invocations are gone\", &krate, |krate|\n          syntax::ext::expand::check_for_macros(&sess.parse_sess, krate));"}, {"sha": "d7ed5d3e1ffa446f005d46bf201a5083640b0061", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=88cb454b91b16fdf8395bc4859b65aff8303acb5", "patch": "@@ -11,7 +11,6 @@\n \n use driver::config;\n use driver::driver;\n-use front;\n use metadata::cstore::CStore;\n use metadata::filesearch;\n use lint;\n@@ -21,6 +20,7 @@ use syntax::ast::NodeId;\n use syntax::codemap::Span;\n use syntax::diagnostic;\n use syntax::diagnostics;\n+use syntax::feature_gate;\n use syntax::parse;\n use syntax::parse::token;\n use syntax::parse::ParseSess;\n@@ -47,10 +47,9 @@ pub struct Session {\n     pub working_dir: Path,\n     pub lint_store: RefCell<lint::LintStore>,\n     pub lints: RefCell<NodeMap<Vec<(lint::LintId, codemap::Span, String)>>>,\n-    pub node_id: Cell<ast::NodeId>,\n     pub crate_types: RefCell<Vec<config::CrateType>>,\n     pub crate_metadata: RefCell<Vec<String>>,\n-    pub features: front::feature_gate::Features,\n+    pub features: RefCell<feature_gate::Features>,\n \n     /// The maximum recursion limit for potentially infinitely recursive\n     /// operations such as auto-dereference and monomorphization.\n@@ -129,17 +128,10 @@ impl Session {\n         lints.insert(id, vec!((lint_id, sp, msg)));\n     }\n     pub fn next_node_id(&self) -> ast::NodeId {\n-        self.reserve_node_ids(1)\n+        self.parse_sess.next_node_id()\n     }\n     pub fn reserve_node_ids(&self, count: ast::NodeId) -> ast::NodeId {\n-        let v = self.node_id.get();\n-\n-        match v.checked_add(&count) {\n-            Some(next) => { self.node_id.set(next); }\n-            None => self.bug(\"Input too large, ran out of node ids!\")\n-        }\n-\n-        v\n+        self.parse_sess.reserve_node_ids(count)\n     }\n     pub fn diagnostic<'a>(&'a self) -> &'a diagnostic::SpanHandler {\n         &self.parse_sess.span_diagnostic\n@@ -251,10 +243,9 @@ pub fn build_session_(sopts: config::Options,\n         working_dir: os::getcwd(),\n         lint_store: RefCell::new(lint::LintStore::new()),\n         lints: RefCell::new(NodeMap::new()),\n-        node_id: Cell::new(1),\n         crate_types: RefCell::new(Vec::new()),\n         crate_metadata: RefCell::new(Vec::new()),\n-        features: front::feature_gate::Features::new(),\n+        features: RefCell::new(feature_gate::Features::new()),\n         recursion_limit: Cell::new(64),\n     };\n "}, {"sha": "81234f36ade50b32b375fa0d3e1694322e7c7ea6", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=88cb454b91b16fdf8395bc4859b65aff8303acb5", "patch": "@@ -116,14 +116,6 @@ pub mod middle {\n     pub mod weak_lang_items;\n }\n \n-pub mod front {\n-    pub mod config;\n-    pub mod test;\n-    pub mod std_inject;\n-    pub mod feature_gate;\n-    pub mod show_span;\n-}\n-\n pub mod metadata;\n \n pub mod driver;"}, {"sha": "d4fe3c265f518dd92a69b3f7acbfbba3566d2386", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=88cb454b91b16fdf8395bc4859b65aff8303acb5", "patch": "@@ -2811,7 +2811,7 @@ impl<'a> Resolver<'a> {\n                                     import_span: Span,\n                                     name: Name,\n                                     namespace: Namespace) {\n-        if self.session.features.import_shadowing.get() {\n+        if self.session.features.borrow().import_shadowing {\n             return\n         }\n \n@@ -2837,7 +2837,7 @@ impl<'a> Resolver<'a> {\n                                                      &mut ImportResolution,\n                                                      import_span: Span,\n                                                      name: Name) {\n-        if self.session.features.import_shadowing.get() {\n+        if self.session.features.borrow().import_shadowing {\n             return\n         }\n \n@@ -2919,7 +2919,7 @@ impl<'a> Resolver<'a> {\n                                                    module: &Module,\n                                                    name: Name,\n                                                    span: Span) {\n-        if self.session.features.import_shadowing.get() {\n+        if self.session.features.borrow().import_shadowing {\n             return\n         }\n \n@@ -2937,7 +2937,7 @@ impl<'a> Resolver<'a> {\n                                                              module: &Module,\n                                                              name: Name,\n                                                              span: Span) {\n-        if self.session.features.import_shadowing.get() {\n+        if self.session.features.borrow().import_shadowing {\n             return\n         }\n "}, {"sha": "c46e95cf045f5eab247e77a88bc27b2e5431e6b0", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=88cb454b91b16fdf8395bc4859b65aff8303acb5", "patch": "@@ -235,7 +235,7 @@ fn ast_path_substs<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     }\n \n     if supplied_ty_param_count > required_ty_param_count\n-        && !this.tcx().sess.features.default_type_params.get() {\n+        && !this.tcx().sess.features.borrow().default_type_params {\n         span_err!(this.tcx().sess, path.span, E0108,\n             \"default type parameters are experimental and possibly buggy\");\n         span_note!(this.tcx().sess, path.span,"}, {"sha": "12905763f522b442c0bee6350cbf62d43f15c725", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=88cb454b91b16fdf8395bc4859b65aff8303acb5", "patch": "@@ -2131,7 +2131,7 @@ fn try_overloaded_call(fcx: &FnCtxt,\n         fcx.inh.method_map.borrow_mut().insert(method_call, method_callee);\n         write_call(fcx, call_expression, output_type);\n \n-        if !fcx.tcx().sess.features.overloaded_calls.get() {\n+        if !fcx.tcx().sess.features.borrow().overloaded_calls {\n             span_err!(fcx.tcx().sess, call_expression.span, E0056,\n                 \"overloaded calls are experimental\");\n             span_note!(fcx.tcx().sess, call_expression.span,"}, {"sha": "cb96cd911b5c68a1dd6d92e94ee78b68ea1517e4", "filename": "src/libsyntax/config.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=88cb454b91b16fdf8395bc4859b65aff8303acb5", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syntax::fold::Folder;\n-use syntax::{ast, fold, attr};\n-use syntax::codemap::Spanned;\n-use syntax::ptr::P;\n+use fold::Folder;\n+use {ast, fold, attr};\n+use codemap::Spanned;\n+use ptr::P;\n \n /// A folder that strips out items that do not belong in the current\n /// configuration.", "previous_filename": "src/librustc/front/config.rs"}, {"sha": "e22e55193fca3565d8d1867bc64409dbf2e89172", "filename": "src/libsyntax/feature_gate.rs", "status": "renamed", "additions": 43, "deletions": 47, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=88cb454b91b16fdf8395bc4859b65aff8303acb5", "patch": "@@ -18,21 +18,17 @@\n //! Features are enabled in programs via the crate-level attributes of\n //! `#![feature(...)]` with a comma-separated list of features.\n \n-use lint;\n+use abi::RustIntrinsic;\n+use ast::NodeId;\n+use ast;\n+use attr;\n+use attr::AttrMetaMethods;\n+use codemap::Span;\n+use diagnostic::SpanHandler;\n+use visit;\n+use visit::Visitor;\n+use parse::token;\n \n-use syntax::abi::RustIntrinsic;\n-use syntax::ast::NodeId;\n-use syntax::ast;\n-use syntax::attr;\n-use syntax::attr::AttrMetaMethods;\n-use syntax::codemap::Span;\n-use syntax::visit;\n-use syntax::visit::Visitor;\n-use syntax::parse::token;\n-\n-use driver::session::Session;\n-\n-use std::cell::Cell;\n use std::slice;\n \n /// This is a list of all known features since the beginning of time. This list\n@@ -99,35 +95,35 @@ enum Status {\n \n /// A set of features to be used by later passes.\n pub struct Features {\n-    pub default_type_params: Cell<bool>,\n-    pub overloaded_calls: Cell<bool>,\n-    pub rustc_diagnostic_macros: Cell<bool>,\n-    pub import_shadowing: Cell<bool>,\n+    pub default_type_params: bool,\n+    pub overloaded_calls: bool,\n+    pub rustc_diagnostic_macros: bool,\n+    pub import_shadowing: bool,\n }\n \n impl Features {\n     pub fn new() -> Features {\n         Features {\n-            default_type_params: Cell::new(false),\n-            overloaded_calls: Cell::new(false),\n-            rustc_diagnostic_macros: Cell::new(false),\n-            import_shadowing: Cell::new(false),\n+            default_type_params: false,\n+            overloaded_calls: false,\n+            rustc_diagnostic_macros: false,\n+            import_shadowing: false,\n         }\n     }\n }\n \n struct Context<'a> {\n     features: Vec<&'static str>,\n-    sess: &'a Session,\n+    span_handler: &'a SpanHandler,\n }\n \n impl<'a> Context<'a> {\n     fn gate_feature(&self, feature: &str, span: Span, explain: &str) {\n         if !self.has_feature(feature) {\n-            self.sess.span_err(span, explain);\n-            self.sess.span_note(span, format!(\"add #![feature({})] to the \\\n-                                               crate attributes to enable\",\n-                                              feature).as_slice());\n+            self.span_handler.span_err(span, explain);\n+            self.span_handler.span_note(span, format!(\"add #![feature({})] to the \\\n+                                                       crate attributes to enable\",\n+                                                      feature).as_slice());\n         }\n     }\n \n@@ -404,48 +400,47 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n     }\n }\n \n-pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n+pub fn check_crate(span_handler: &SpanHandler, krate: &ast::Crate) -> (Features, Vec<Span>) {\n     let mut cx = Context {\n         features: Vec::new(),\n-        sess: sess,\n+        span_handler: span_handler,\n     };\n \n+    let mut unknown_features = Vec::new();\n+\n     for attr in krate.attrs.iter() {\n         if !attr.check_name(\"feature\") {\n             continue\n         }\n \n         match attr.meta_item_list() {\n             None => {\n-                sess.span_err(attr.span, \"malformed feature attribute, \\\n-                                          expected #![feature(...)]\");\n+                span_handler.span_err(attr.span, \"malformed feature attribute, \\\n+                                                  expected #![feature(...)]\");\n             }\n             Some(list) => {\n                 for mi in list.iter() {\n                     let name = match mi.node {\n                         ast::MetaWord(ref word) => (*word).clone(),\n                         _ => {\n-                            sess.span_err(mi.span,\n-                                          \"malformed feature, expected just \\\n-                                           one word\");\n+                            span_handler.span_err(mi.span,\n+                                                  \"malformed feature, expected just \\\n+                                                   one word\");\n                             continue\n                         }\n                     };\n                     match KNOWN_FEATURES.iter()\n                                         .find(|& &(n, _)| name.equiv(&n)) {\n                         Some(&(name, Active)) => { cx.features.push(name); }\n                         Some(&(_, Removed)) => {\n-                            sess.span_err(mi.span, \"feature has been removed\");\n+                            span_handler.span_err(mi.span, \"feature has been removed\");\n                         }\n                         Some(&(_, Accepted)) => {\n-                            sess.span_warn(mi.span, \"feature has been added to Rust, \\\n-                                                     directive not necessary\");\n+                            span_handler.span_warn(mi.span, \"feature has been added to Rust, \\\n+                                                             directive not necessary\");\n                         }\n                         None => {\n-                            sess.add_lint(lint::builtin::UNKNOWN_FEATURES,\n-                                          ast::CRATE_NODE_ID,\n-                                          mi.span,\n-                                          \"unknown feature\".to_string());\n+                            unknown_features.push(mi.span);\n                         }\n                     }\n                 }\n@@ -455,11 +450,12 @@ pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n \n     visit::walk_crate(&mut cx, krate);\n \n-    sess.abort_if_errors();\n-\n-    sess.features.default_type_params.set(cx.has_feature(\"default_type_params\"));\n-    sess.features.overloaded_calls.set(cx.has_feature(\"overloaded_calls\"));\n-    sess.features.rustc_diagnostic_macros.set(cx.has_feature(\"rustc_diagnostic_macros\"));\n-    sess.features.import_shadowing.set(cx.has_feature(\"import_shadowing\"));\n+    (Features {\n+        default_type_params: cx.has_feature(\"default_type_params\"),\n+        overloaded_calls: cx.has_feature(\"overloaded_calls\"),\n+        rustc_diagnostic_macros: cx.has_feature(\"rustc_diagnostic_macros\"),\n+        import_shadowing: cx.has_feature(\"import_shadowing\"),\n+    },\n+    unknown_features)\n }\n ", "previous_filename": "src/librustc/front/feature_gate.rs"}, {"sha": "457d77efb708e2846d2ac5c8af602046650aee79", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=88cb454b91b16fdf8395bc4859b65aff8303acb5", "patch": "@@ -59,12 +59,17 @@ pub mod ast_map;\n pub mod ast_util;\n pub mod attr;\n pub mod codemap;\n+pub mod config;\n pub mod crateid;\n pub mod diagnostic;\n+pub mod feature_gate;\n pub mod fold;\n pub mod owned_slice;\n pub mod parse;\n pub mod ptr;\n+pub mod show_span;\n+pub mod std_inject;\n+pub mod test;\n pub mod visit;\n \n pub mod print {"}, {"sha": "d73cb2116941a4e2151d4aba256585bb9c1a038f", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=88cb454b91b16fdf8395bc4859b65aff8303acb5", "patch": "@@ -17,7 +17,7 @@ use parse::attr::ParserAttr;\n use parse::parser::Parser;\n use ptr::P;\n \n-use std::cell::RefCell;\n+use std::cell::{Cell, RefCell};\n use std::io::File;\n use std::rc::Rc;\n use std::str;\n@@ -37,19 +37,38 @@ pub struct ParseSess {\n     pub span_diagnostic: SpanHandler, // better be the same as the one in the reader!\n     /// Used to determine and report recursive mod inclusions\n     included_mod_stack: RefCell<Vec<Path>>,\n+    pub node_id: Cell<ast::NodeId>,\n }\n \n pub fn new_parse_sess() -> ParseSess {\n     ParseSess {\n         span_diagnostic: mk_span_handler(default_handler(Auto, None), CodeMap::new()),\n         included_mod_stack: RefCell::new(Vec::new()),\n+        node_id: Cell::new(1),\n     }\n }\n \n pub fn new_parse_sess_special_handler(sh: SpanHandler) -> ParseSess {\n     ParseSess {\n         span_diagnostic: sh,\n         included_mod_stack: RefCell::new(Vec::new()),\n+        node_id: Cell::new(1),\n+    }\n+}\n+\n+impl ParseSess {\n+    pub fn next_node_id(&self) -> ast::NodeId {\n+        self.reserve_node_ids(1)\n+    }\n+    pub fn reserve_node_ids(&self, count: ast::NodeId) -> ast::NodeId {\n+        let v = self.node_id.get();\n+\n+        match v.checked_add(&count) {\n+            Some(next) => { self.node_id.set(next); }\n+            None => fail!(\"Input too large, ran out of node ids!\")\n+        }\n+\n+        v\n     }\n }\n "}, {"sha": "354ba854b101aa7906f2d9131d8aa3c9a4134ba3", "filename": "src/libsyntax/show_span.rs", "status": "renamed", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibsyntax%2Fshow_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibsyntax%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fshow_span.rs?ref=88cb454b91b16fdf8395bc4859b65aff8303acb5", "patch": "@@ -13,19 +13,18 @@\n //! This module shows spans for all expressions in the crate\n //! to help with compiler debugging.\n \n-use syntax::ast;\n-use syntax::visit;\n-use syntax::visit::Visitor;\n-\n-use driver::session::Session;\n+use ast;\n+use diagnostic;\n+use visit;\n+use visit::Visitor;\n \n struct ShowSpanVisitor<'a> {\n-    sess: &'a Session\n+    span_diagnostic: &'a diagnostic::SpanHandler,\n }\n \n impl<'a, 'v> Visitor<'v> for ShowSpanVisitor<'a> {\n     fn visit_expr(&mut self, e: &ast::Expr) {\n-        self.sess.span_note(e.span, \"expression\");\n+        self.span_diagnostic.span_note(e.span, \"expression\");\n         visit::walk_expr(self, e);\n     }\n \n@@ -34,7 +33,7 @@ impl<'a, 'v> Visitor<'v> for ShowSpanVisitor<'a> {\n     }\n }\n \n-pub fn run(sess: &Session, krate: &ast::Crate) {\n-    let mut v = ShowSpanVisitor { sess: sess };\n+pub fn run(span_diagnostic: &diagnostic::SpanHandler, krate: &ast::Crate) {\n+    let mut v = ShowSpanVisitor { span_diagnostic: span_diagnostic };\n     visit::walk_crate(&mut v, krate);\n }", "previous_filename": "src/librustc/front/show_span.rs"}, {"sha": "8a7e14643c1a7a1bcdb7e1e680a0db02bae090df", "filename": "src/libsyntax/std_inject.rs", "status": "renamed", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=88cb454b91b16fdf8395bc4859b65aff8303acb5", "patch": "@@ -8,36 +8,33 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use driver::config;\n-use driver::session::Session;\n-\n-use syntax::ast;\n-use syntax::attr;\n-use syntax::codemap::DUMMY_SP;\n-use syntax::codemap;\n-use syntax::fold::Folder;\n-use syntax::fold;\n-use syntax::owned_slice::OwnedSlice;\n-use syntax::parse::token::InternedString;\n-use syntax::parse::token::special_idents;\n-use syntax::parse::token;\n-use syntax::ptr::P;\n-use syntax::util::small_vector::SmallVector;\n+use ast;\n+use attr;\n+use codemap::DUMMY_SP;\n+use codemap;\n+use fold::Folder;\n+use fold;\n+use owned_slice::OwnedSlice;\n+use parse::token::InternedString;\n+use parse::token::special_idents;\n+use parse::token;\n+use ptr::P;\n+use util::small_vector::SmallVector;\n \n use std::mem;\n \n-pub fn maybe_inject_crates_ref(sess: &Session, krate: ast::Crate)\n+pub fn maybe_inject_crates_ref(krate: ast::Crate, alt_std_name: Option<String>, any_exe: bool)\n                                -> ast::Crate {\n     if use_std(&krate) {\n-        inject_crates_ref(sess, krate)\n+        inject_crates_ref(krate, alt_std_name, any_exe)\n     } else {\n         krate\n     }\n }\n \n-pub fn maybe_inject_prelude(sess: &Session, krate: ast::Crate) -> ast::Crate {\n+pub fn maybe_inject_prelude(krate: ast::Crate) -> ast::Crate {\n     if use_std(&krate) {\n-        inject_prelude(sess, krate)\n+        inject_prelude(krate)\n     } else {\n         krate\n     }\n@@ -56,14 +53,15 @@ fn no_prelude(attrs: &[ast::Attribute]) -> bool {\n }\n \n struct StandardLibraryInjector<'a> {\n-    sess: &'a Session,\n+    alt_std_name: Option<String>,\n+    any_exe: bool,\n }\n \n impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n     fn fold_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n \n         // The name to use in `extern crate \"name\" as std;`\n-        let actual_crate_name = match self.sess.opts.alt_std_name {\n+        let actual_crate_name = match self.alt_std_name {\n             Some(ref s) => token::intern_and_get_ident(s.as_slice()),\n             None => token::intern_and_get_ident(\"std\"),\n         };\n@@ -83,10 +81,7 @@ impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n             span: DUMMY_SP\n         });\n \n-        let any_exe = self.sess.crate_types.borrow().iter().any(|ty| {\n-            *ty == config::CrateTypeExecutable\n-        });\n-        if use_start(&krate) && any_exe {\n+        if use_start(&krate) && self.any_exe {\n             let visible_rt_name = \"rt\";\n             let actual_rt_name = \"native\";\n             // Gensym the ident so it can't be named\n@@ -124,9 +119,12 @@ impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n     }\n }\n \n-fn inject_crates_ref(sess: &Session, krate: ast::Crate) -> ast::Crate {\n+fn inject_crates_ref(krate: ast::Crate,\n+                     alt_std_name: Option<String>,\n+                     any_exe: bool) -> ast::Crate {\n     let mut fold = StandardLibraryInjector {\n-        sess: sess,\n+        alt_std_name: alt_std_name,\n+        any_exe: any_exe,\n     };\n     fold.fold_crate(krate)\n }\n@@ -231,7 +229,7 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n     }\n }\n \n-fn inject_prelude(_: &Session, krate: ast::Crate) -> ast::Crate {\n+fn inject_prelude(krate: ast::Crate) -> ast::Crate {\n     let mut fold = PreludeInjector;\n     fold.fold_crate(krate)\n }", "previous_filename": "src/librustc/front/std_inject.rs"}, {"sha": "f0e697127149f3ab924631837432d2f663df94ce", "filename": "src/libsyntax/test.rs", "status": "renamed", "additions": 41, "deletions": 36, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb454b91b16fdf8395bc4859b65aff8303acb5/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=88cb454b91b16fdf8395bc4859b65aff8303acb5", "patch": "@@ -13,29 +13,29 @@\n #![allow(dead_code)]\n #![allow(unused_imports)]\n \n-use driver::session::Session;\n-use front::config;\n-\n+use std::gc::{Gc, GC};\n use std::slice;\n use std::mem;\n use std::vec;\n-use syntax::{ast, ast_util};\n-use syntax::ast_util::*;\n-use syntax::attr::AttrMetaMethods;\n-use syntax::attr;\n-use syntax::codemap::{DUMMY_SP, Span, ExpnInfo, NameAndSpan, MacroAttribute};\n-use syntax::codemap;\n-use syntax::ext::base::ExtCtxt;\n-use syntax::ext::build::AstBuilder;\n-use syntax::ext::expand::ExpansionConfig;\n-use syntax::fold::{Folder, MoveMap};\n-use syntax::fold;\n-use syntax::owned_slice::OwnedSlice;\n-use syntax::parse::token::InternedString;\n-use syntax::parse::token;\n-use syntax::print::pprust;\n-use syntax::ptr::P;\n-use syntax::util::small_vector::SmallVector;\n+use ast_util::*;\n+use attr::AttrMetaMethods;\n+use attr;\n+use codemap::{DUMMY_SP, Span, ExpnInfo, NameAndSpan, MacroAttribute};\n+use codemap;\n+use diagnostic;\n+use config;\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n+use ext::expand::ExpansionConfig;\n+use fold::{Folder, MoveMap};\n+use fold;\n+use owned_slice::OwnedSlice;\n+use parse::token::InternedString;\n+use parse::{token, ParseSess};\n+use print::pprust;\n+use {ast, ast_util};\n+use ptr::P;\n+use util::small_vector::SmallVector;\n \n struct Test {\n     span: Span,\n@@ -46,7 +46,8 @@ struct Test {\n }\n \n struct TestCtxt<'a> {\n-    sess: &'a Session,\n+    sess: &'a ParseSess,\n+    span_diagnostic: &'a diagnostic::SpanHandler,\n     path: Vec<ast::Ident>,\n     ext_cx: ExtCtxt<'a>,\n     testfns: Vec<Test>,\n@@ -60,8 +61,10 @@ struct TestCtxt<'a> {\n \n // Traverse the crate, collecting all the test functions, eliding any\n // existing main functions, and synthesizing a main test harness\n-pub fn modify_for_testing(sess: &Session,\n-                          krate: ast::Crate) -> ast::Crate {\n+pub fn modify_for_testing(sess: &ParseSess,\n+                          cfg: &ast::CrateConfig,\n+                          krate: ast::Crate,\n+                          span_diagnostic: &diagnostic::SpanHandler) -> ast::Crate {\n     // We generate the test harness when building in the 'test'\n     // configuration, either with the '--test' or '--cfg test'\n     // command line options.\n@@ -76,7 +79,7 @@ pub fn modify_for_testing(sess: &Session,\n                                            \"reexport_test_harness_main\");\n \n     if should_test {\n-        generate_test_harness(sess, reexport_test_harness_main, krate)\n+        generate_test_harness(sess, reexport_test_harness_main, krate, cfg, span_diagnostic)\n     } else {\n         strip_test_functions(krate)\n     }\n@@ -113,8 +116,8 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         if is_test_fn(&self.cx, &*i) || is_bench_fn(&self.cx, &*i) {\n             match i.node {\n                 ast::ItemFn(_, ast::UnsafeFn, _, _, _) => {\n-                    let sess = self.cx.sess;\n-                    sess.span_fatal(i.span,\n+                    let diag = self.cx.span_diagnostic;\n+                    diag.span_fatal(i.span,\n                                     \"unsafe functions cannot be used for \\\n                                      tests\");\n                 }\n@@ -223,12 +226,15 @@ fn mk_reexport_mod(cx: &mut TestCtxt, tests: Vec<ast::Ident>,\n     (it, sym)\n }\n \n-fn generate_test_harness(sess: &Session,\n+fn generate_test_harness(sess: &ParseSess,\n                          reexport_test_harness_main: Option<InternedString>,\n-                         krate: ast::Crate) -> ast::Crate {\n+                         krate: ast::Crate,\n+                         cfg: &ast::CrateConfig,\n+                         sd: &diagnostic::SpanHandler) -> ast::Crate {\n     let mut cx: TestCtxt = TestCtxt {\n         sess: sess,\n-        ext_cx: ExtCtxt::new(&sess.parse_sess, sess.opts.cfg.clone(),\n+        span_diagnostic: sd,\n+        ext_cx: ExtCtxt::new(sess, cfg.clone(),\n                              ExpansionConfig {\n                                  deriving_hash_type_parameter: false,\n                                  crate_name: \"test\".to_string(),\n@@ -288,8 +294,8 @@ fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n     }\n \n     if has_test_attr && !has_test_signature(i) {\n-        let sess = cx.sess;\n-        sess.span_err(\n+        let diag = cx.span_diagnostic;\n+        diag.span_err(\n             i.span,\n             \"functions used as tests must have signature fn() -> ().\"\n         );\n@@ -320,8 +326,8 @@ fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n     }\n \n     if has_bench_attr && !has_test_signature(i) {\n-        let sess = cx.sess;\n-        sess.span_err(i.span, \"functions used as benches must have signature \\\n+        let diag = cx.span_diagnostic;\n+        diag.span_err(i.span, \"functions used as benches must have signature \\\n                       `fn(&mut Bencher) -> ()`\");\n     }\n \n@@ -547,9 +553,8 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n     let mut visible_path = match cx.toplevel_reexport {\n         Some(id) => vec![id],\n         None => {\n-            cx.sess.bug(\n-                \"expected to find top-level re-export name, but found None\"\n-            );\n+            let diag = cx.span_diagnostic;\n+            diag.handler.bug(\"expected to find top-level re-export name, but found None\");\n         }\n     };\n     visible_path.extend(path.into_iter());", "previous_filename": "src/librustc/front/test.rs"}]}