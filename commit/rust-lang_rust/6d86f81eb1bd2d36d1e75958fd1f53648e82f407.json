{"sha": "6d86f81eb1bd2d36d1e75958fd1f53648e82f407", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkODZmODFlYjFiZDJkMzZkMWU3NTk1OGZkMWY1MzY0OGU4MmY0MDc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-22T01:02:14Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-22T01:02:14Z"}, "message": "move the uses of the trans caches into rustc::traits\n\nThis makes these routines more readily available for other bits of\ncode. It also will help when refactoring.", "tree": {"sha": "322740c562e1cda76a44803e9cb02e4e73e25f61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/322740c562e1cda76a44803e9cb02e4e73e25f61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d86f81eb1bd2d36d1e75958fd1f53648e82f407", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d86f81eb1bd2d36d1e75958fd1f53648e82f407", "html_url": "https://github.com/rust-lang/rust/commit/6d86f81eb1bd2d36d1e75958fd1f53648e82f407", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d86f81eb1bd2d36d1e75958fd1f53648e82f407/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85527456e8375e9a2236c2cd7b3a7e043b70f75e", "url": "https://api.github.com/repos/rust-lang/rust/commits/85527456e8375e9a2236c2cd7b3a7e043b70f75e", "html_url": "https://github.com/rust-lang/rust/commit/85527456e8375e9a2236c2cd7b3a7e043b70f75e"}], "stats": {"total": 318, "additions": 164, "deletions": 154}, "files": [{"sha": "e38306aed2a91b9e7a0ffeac8bbe57bf32547ef1", "filename": "src/librustc/traits/trans/mod.rs", "status": "modified", "additions": 143, "deletions": 4, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/6d86f81eb1bd2d36d1e75958fd1f53648e82f407/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d86f81eb1bd2d36d1e75958fd1f53648e82f407/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=6d86f81eb1bd2d36d1e75958fd1f53648e82f407", "patch": "@@ -1,15 +1,154 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file contains various trait resolution methods used by trans.\n+// They all assume regions can be erased and monomorphic types.  It\n+// seems likely that they should eventually be merged into more\n+// general routines.\n+\n use dep_graph::{DepGraph, DepNode, DepTrackingMap, DepTrackingMapConfig};\n use hir::def_id::DefId;\n+use infer::TransNormalize;\n use std::cell::RefCell;\n use std::marker::PhantomData;\n-use traits::Vtable;\n-use ty::{self, Ty};\n+use syntax::ast;\n+use syntax_pos::Span;\n+use traits::{FulfillmentContext, Obligation, ObligationCause, Reveal, SelectionContext, Vtable};\n+use ty::{self, Ty, TyCtxt};\n+use ty::subst::{Subst, Substs};\n+use ty::fold::{TypeFoldable, TypeFolder};\n+use util::common::MemoizationMap;\n+\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+    /// Attempts to resolve an obligation to a vtable.. The result is\n+    /// a shallow vtable resolution -- meaning that we do not\n+    /// (necessarily) resolve all nested obligations on the impl. Note\n+    /// that type check should guarantee to us that all nested\n+    /// obligations *could be* resolved if we wanted to.\n+    pub fn trans_fulfill_obligation(self,\n+                                    span: Span,\n+                                    trait_ref: ty::PolyTraitRef<'tcx>)\n+                                    -> Vtable<'tcx, ()>\n+    {\n+        // Remove any references to regions; this helps improve caching.\n+        let trait_ref = self.erase_regions(&trait_ref);\n+\n+        self.trans_trait_caches.trait_cache.memoize(trait_ref, || {\n+            debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n+                   trait_ref, trait_ref.def_id());\n+\n+            // Do the initial selection for the obligation. This yields the\n+            // shallow result we are looking for -- that is, what specific impl.\n+            self.infer_ctxt((), Reveal::All).enter(|infcx| {\n+                let mut selcx = SelectionContext::new(&infcx);\n+\n+                let obligation_cause = ObligationCause::misc(span,\n+                                                             ast::DUMMY_NODE_ID);\n+                let obligation = Obligation::new(obligation_cause,\n+                                                 trait_ref.to_poly_trait_predicate());\n+\n+                let selection = match selcx.select(&obligation) {\n+                    Ok(Some(selection)) => selection,\n+                    Ok(None) => {\n+                        // Ambiguity can happen when monomorphizing during trans\n+                        // expands to some humongo type that never occurred\n+                        // statically -- this humongo type can then overflow,\n+                        // leading to an ambiguous result. So report this as an\n+                        // overflow bug, since I believe this is the only case\n+                        // where ambiguity can result.\n+                        debug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n+                                presuming due to overflow\",\n+                               trait_ref);\n+                        self.sess.span_fatal(span,\n+                                            \"reached the recursion limit during monomorphization \\\n+                                             (selection ambiguity)\");\n+                    }\n+                    Err(e) => {\n+                        span_bug!(span, \"Encountered error `{:?}` selecting `{:?}` during trans\",\n+                                  e, trait_ref)\n+                    }\n+                };\n+\n+                debug!(\"fulfill_obligation: selection={:?}\", selection);\n+\n+                // Currently, we use a fulfillment context to completely resolve\n+                // all nested obligations. This is because they can inform the\n+                // inference of the impl's type parameters.\n+                let mut fulfill_cx = FulfillmentContext::new();\n+                let vtable = selection.map(|predicate| {\n+                    debug!(\"fulfill_obligation: register_predicate_obligation {:?}\", predicate);\n+                    fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+                });\n+                let vtable = infcx.drain_fulfillment_cx_or_panic(span, &mut fulfill_cx, &vtable);\n+\n+                info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n+                vtable\n+            })\n+        })\n+    }\n+\n+    /// Monomorphizes a type from the AST by first applying the in-scope\n+    /// substitutions and then normalizing any associated types.\n+    pub fn trans_apply_param_substs<T>(self,\n+                                       param_substs: &Substs<'tcx>,\n+                                       value: &T)\n+                                       -> T\n+        where T: TransNormalize<'tcx>\n+    {\n+        debug!(\"apply_param_substs(param_substs={:?}, value={:?})\", param_substs, value);\n+        let substituted = value.subst(self, param_substs);\n+        let substituted = self.erase_regions(&substituted);\n+        AssociatedTypeNormalizer::new(self).fold(&substituted)\n+    }\n+}\n+\n+struct AssociatedTypeNormalizer<'a, 'gcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+}\n+\n+impl<'a, 'gcx> AssociatedTypeNormalizer<'a, 'gcx> {\n+    fn new(tcx: TyCtxt<'a, 'gcx, 'gcx>) -> Self {\n+        AssociatedTypeNormalizer { tcx }\n+    }\n+\n+    fn fold<T:TypeFoldable<'gcx>>(&mut self, value: &T) -> T {\n+        if !value.has_projection_types() {\n+            value.clone()\n+        } else {\n+            value.fold_with(self)\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx> TypeFolder<'gcx, 'gcx> for AssociatedTypeNormalizer<'a, 'gcx> {\n+    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'gcx, 'gcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'gcx>) -> Ty<'gcx> {\n+        if !ty.has_projection_types() {\n+            ty\n+        } else {\n+            self.tcx.trans_trait_caches.project_cache.memoize(ty, || {\n+                debug!(\"AssociatedTypeNormalizer: ty={:?}\", ty);\n+                self.tcx.normalize_associated_type(&ty)\n+            })\n+        }\n+    }\n+}\n \n /// Specializes caches used in trans -- in particular, they assume all\n /// types are fully monomorphized and that free regions can be erased.\n pub struct TransTraitCaches<'tcx> {\n-    pub trait_cache: RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>>,\n-    pub project_cache: RefCell<DepTrackingMap<ProjectionCache<'tcx>>>,\n+    trait_cache: RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>>,\n+    project_cache: RefCell<DepTrackingMap<ProjectionCache<'tcx>>>,\n }\n \n impl<'tcx> TransTraitCaches<'tcx> {"}, {"sha": "13bb0d371250f98b5490b9c0696db0cc2548adff", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6d86f81eb1bd2d36d1e75958fd1f53648e82f407/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d86f81eb1bd2d36d1e75958fd1f53648e82f407/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=6d86f81eb1bd2d36d1e75958fd1f53648e82f407", "patch": "@@ -467,13 +467,11 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             // have to instantiate all methods of the trait being cast to, so we\n             // can build the appropriate vtable.\n             mir::Rvalue::Cast(mir::CastKind::Unsize, ref operand, target_ty) => {\n-                let target_ty = monomorphize::apply_param_substs(self.scx,\n-                                                                 self.param_substs,\n-                                                                 &target_ty);\n+                let target_ty = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n+                                                                        &target_ty);\n                 let source_ty = operand.ty(self.mir, self.scx.tcx());\n-                let source_ty = monomorphize::apply_param_substs(self.scx,\n-                                                                 self.param_substs,\n-                                                                 &source_ty);\n+                let source_ty = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n+                                                                        &source_ty);\n                 let (source_ty, target_ty) = find_vtable_types_for_unsizing(self.scx,\n                                                                             source_ty,\n                                                                             target_ty);\n@@ -489,10 +487,8 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             }\n             mir::Rvalue::Cast(mir::CastKind::ReifyFnPointer, ref operand, _) => {\n                 let fn_ty = operand.ty(self.mir, self.scx.tcx());\n-                let fn_ty = monomorphize::apply_param_substs(\n-                    self.scx,\n-                    self.param_substs,\n-                    &fn_ty);\n+                let fn_ty = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n+                                                                    &fn_ty);\n                 visit_fn_use(self.scx, fn_ty, false, &mut self.output);\n             }\n             mir::Rvalue::Cast(mir::CastKind::ClosureFnPointer, ref operand, _) => {\n@@ -534,9 +530,8 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         }\n \n         if let mir::Literal::Item { def_id, substs } = constant.literal {\n-            let substs = monomorphize::apply_param_substs(self.scx,\n-                                                          self.param_substs,\n-                                                          &substs);\n+            let substs = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n+                                                                 &substs);\n             let instance = monomorphize::resolve(self.scx, def_id, substs);\n             collect_neighbours(self.scx, instance, self.output);\n         }\n@@ -552,17 +547,14 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         match *kind {\n             mir::TerminatorKind::Call { ref func, .. } => {\n                 let callee_ty = func.ty(self.mir, tcx);\n-                let callee_ty = monomorphize::apply_param_substs(\n-                    self.scx, self.param_substs, &callee_ty);\n+                let callee_ty = tcx.trans_apply_param_substs(self.param_substs, &callee_ty);\n                 visit_fn_use(self.scx, callee_ty, true, &mut self.output);\n             }\n             mir::TerminatorKind::Drop { ref location, .. } |\n             mir::TerminatorKind::DropAndReplace { ref location, .. } => {\n                 let ty = location.ty(self.mir, self.scx.tcx())\n                     .to_ty(self.scx.tcx());\n-                let ty = monomorphize::apply_param_substs(self.scx,\n-                                                          self.param_substs,\n-                                                          &ty);\n+                let ty = tcx.trans_apply_param_substs(self.param_substs, &ty);\n                 visit_drop_use(self.scx, ty, true, self.output);\n             }\n             mir::TerminatorKind::Goto { .. } |"}, {"sha": "648ea92c8437601d22f7dd62d6c068dc1adea136", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d86f81eb1bd2d36d1e75958fd1f53648e82f407/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d86f81eb1bd2d36d1e75958fd1f53648e82f407/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=6d86f81eb1bd2d36d1e75958fd1f53648e82f407", "patch": "@@ -564,7 +564,7 @@ pub fn def_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n                         -> Ty<'tcx>\n {\n     let ty = shared.tcx().item_type(def_id);\n-    monomorphize::apply_param_substs(shared, substs, &ty)\n+    shared.tcx().trans_apply_param_substs(substs, &ty)\n }\n \n /// Return the substituted type of an instance.\n@@ -573,5 +573,5 @@ pub fn instance_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n                              -> Ty<'tcx>\n {\n     let ty = instance.def.def_ty(shared.tcx());\n-    monomorphize::apply_param_substs(shared, instance.substs, &ty)\n+    shared.tcx().trans_apply_param_substs(instance.substs, &ty)\n }"}, {"sha": "dbae79e034daa7a5ef343e17deb83005ff810402", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d86f81eb1bd2d36d1e75958fd1f53648e82f407/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d86f81eb1bd2d36d1e75958fd1f53648e82f407/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=6d86f81eb1bd2d36d1e75958fd1f53648e82f407", "patch": "@@ -260,9 +260,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     fn monomorphize<T>(&self, value: &T) -> T\n         where T: TransNormalize<'tcx>\n     {\n-        monomorphize::apply_param_substs(self.ccx.shared(),\n-                                         self.substs,\n-                                         value)\n+        self.ccx.tcx().trans_apply_param_substs(self.substs, value)\n     }\n \n     fn trans(&mut self) -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {"}, {"sha": "2669f722f9c16d89838cd64f2106144d599f3e19", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6d86f81eb1bd2d36d1e75958fd1f53648e82f407/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d86f81eb1bd2d36d1e75958fd1f53648e82f407/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=6d86f81eb1bd2d36d1e75958fd1f53648e82f407", "patch": "@@ -22,7 +22,7 @@ use base;\n use builder::Builder;\n use common::{self, CrateContext, Funclet};\n use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebugContext};\n-use monomorphize::{self, Instance};\n+use monomorphize::Instance;\n use abi::FnType;\n use type_of;\n \n@@ -102,8 +102,9 @@ pub struct MirContext<'a, 'tcx:'a> {\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T: TransNormalize<'tcx> {\n-        monomorphize::apply_param_substs(self.ccx.shared(), self.param_substs, value)\n+        where T: TransNormalize<'tcx>\n+    {\n+        self.ccx.tcx().trans_apply_param_substs(self.param_substs, value)\n     }\n \n     pub fn set_debug_loc(&mut self, bcx: &Builder, source_info: mir::SourceInfo) {"}, {"sha": "d27eeb2b64667b712d8f1939cae832eb3a828dab", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 124, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/6d86f81eb1bd2d36d1e75958fd1f53648e82f407/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d86f81eb1bd2d36d1e75958fd1f53648e82f407/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=6d86f81eb1bd2d36d1e75958fd1f53648e82f407", "patch": "@@ -13,17 +13,13 @@ use common::*;\n use glue;\n \n use rustc::hir::def_id::DefId;\n-use rustc::infer::TransNormalize;\n use rustc::middle::lang_items::DropInPlaceFnLangItem;\n-use rustc::traits::{self, SelectionContext, Reveal};\n+use rustc::traits;\n use rustc::ty::adjustment::CustomCoerceUnsized;\n-use rustc::ty::fold::{TypeFolder, TypeFoldable};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::util::common::MemoizationMap;\n \n-use syntax::ast;\n-use syntax::codemap::{Span, DUMMY_SP};\n+use syntax::codemap::DUMMY_SP;\n \n pub use rustc::ty::Instance;\n \n@@ -104,73 +100,6 @@ pub fn resolve_closure<'a, 'tcx> (\n     }\n }\n \n-/// Attempts to resolve an obligation. The result is a shallow vtable resolution -- meaning that we\n-/// do not (necessarily) resolve all nested obligations on the impl. Note that type check should\n-/// guarantee to us that all nested obligations *could be* resolved if we wanted to.\n-fn fulfill_obligation<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                span: Span,\n-                                trait_ref: ty::PolyTraitRef<'tcx>)\n-                                -> traits::Vtable<'tcx, ()>\n-{\n-    let tcx = scx.tcx();\n-\n-    // Remove any references to regions; this helps improve caching.\n-    let trait_ref = tcx.erase_regions(&trait_ref);\n-\n-    tcx.trans_trait_caches.trait_cache.memoize(trait_ref, || {\n-        debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n-               trait_ref, trait_ref.def_id());\n-\n-        // Do the initial selection for the obligation. This yields the\n-        // shallow result we are looking for -- that is, what specific impl.\n-        tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n-            let mut selcx = SelectionContext::new(&infcx);\n-\n-            let obligation_cause = traits::ObligationCause::misc(span,\n-                                                             ast::DUMMY_NODE_ID);\n-            let obligation = traits::Obligation::new(obligation_cause,\n-                                                     trait_ref.to_poly_trait_predicate());\n-\n-            let selection = match selcx.select(&obligation) {\n-                Ok(Some(selection)) => selection,\n-                Ok(None) => {\n-                    // Ambiguity can happen when monomorphizing during trans\n-                    // expands to some humongo type that never occurred\n-                    // statically -- this humongo type can then overflow,\n-                    // leading to an ambiguous result. So report this as an\n-                    // overflow bug, since I believe this is the only case\n-                    // where ambiguity can result.\n-                    debug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n-                            presuming due to overflow\",\n-                           trait_ref);\n-                    tcx.sess.span_fatal(span,\n-                        \"reached the recursion limit during monomorphization \\\n-                         (selection ambiguity)\");\n-                }\n-                Err(e) => {\n-                    span_bug!(span, \"Encountered error `{:?}` selecting `{:?}` during trans\",\n-                              e, trait_ref)\n-                }\n-            };\n-\n-            debug!(\"fulfill_obligation: selection={:?}\", selection);\n-\n-            // Currently, we use a fulfillment context to completely resolve\n-            // all nested obligations. This is because they can inform the\n-            // inference of the impl's type parameters.\n-            let mut fulfill_cx = traits::FulfillmentContext::new();\n-            let vtable = selection.map(|predicate| {\n-                debug!(\"fulfill_obligation: register_predicate_obligation {:?}\", predicate);\n-                fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-            });\n-            let vtable = infcx.drain_fulfillment_cx_or_panic(span, &mut fulfill_cx, &vtable);\n-\n-            info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n-            vtable\n-        })\n-    })\n-}\n-\n fn resolve_associated_item<'a, 'tcx>(\n     scx: &SharedCrateContext<'a, 'tcx>,\n     trait_item: &ty::AssociatedItem,\n@@ -185,7 +114,7 @@ fn resolve_associated_item<'a, 'tcx>(\n            def_id, trait_id, rcvr_substs);\n \n     let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n-    let vtbl = fulfill_obligation(scx, DUMMY_SP, ty::Binder(trait_ref));\n+    let vtbl = tcx.trans_fulfill_obligation(DUMMY_SP, ty::Binder(trait_ref));\n \n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:\n@@ -285,7 +214,7 @@ pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx\n         substs: scx.tcx().mk_substs_trait(source_ty, &[target_ty])\n     });\n \n-    match fulfill_obligation(scx, DUMMY_SP, trait_ref) {\n+    match scx.tcx().trans_fulfill_obligation(DUMMY_SP, trait_ref) {\n         traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {\n             scx.tcx().coerce_unsized_info(impl_def_id).custom_kind.unwrap()\n         }\n@@ -295,21 +224,6 @@ pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx\n     }\n }\n \n-/// Monomorphizes a type from the AST by first applying the in-scope\n-/// substitutions and then normalizing any associated types.\n-pub fn apply_param_substs<'a, 'tcx, T>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                       param_substs: &Substs<'tcx>,\n-                                       value: &T)\n-                                       -> T\n-    where T: TransNormalize<'tcx>\n-{\n-    let tcx = scx.tcx();\n-    debug!(\"apply_param_substs(param_substs={:?}, value={:?})\", param_substs, value);\n-    let substituted = value.subst(tcx, param_substs);\n-    let substituted = scx.tcx().erase_regions(&substituted);\n-    AssociatedTypeNormalizer::new(tcx).fold(&substituted)\n-}\n-\n /// Returns the normalized type of a struct field\n pub fn field_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           param_substs: &Substs<'tcx>,\n@@ -319,37 +233,3 @@ pub fn field_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tcx.normalize_associated_type(&f.ty(tcx, param_substs))\n }\n \n-struct AssociatedTypeNormalizer<'a, 'gcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n-}\n-\n-impl<'a, 'gcx> AssociatedTypeNormalizer<'a, 'gcx> {\n-    fn new(tcx: TyCtxt<'a, 'gcx, 'gcx>) -> Self {\n-        AssociatedTypeNormalizer { tcx }\n-    }\n-\n-    fn fold<T:TypeFoldable<'gcx>>(&mut self, value: &T) -> T {\n-        if !value.has_projection_types() {\n-            value.clone()\n-        } else {\n-            value.fold_with(self)\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx> TypeFolder<'gcx, 'gcx> for AssociatedTypeNormalizer<'a, 'gcx> {\n-    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'gcx, 'gcx> {\n-        self.tcx\n-    }\n-\n-    fn fold_ty(&mut self, ty: Ty<'gcx>) -> Ty<'gcx> {\n-        if !ty.has_projection_types() {\n-            ty\n-        } else {\n-            self.tcx.trans_trait_caches.project_cache.memoize(ty, || {\n-                debug!(\"AssociatedTypeNormalizer: ty={:?}\", ty);\n-                self.tcx.normalize_associated_type(&ty)\n-            })\n-        }\n-    }\n-}"}]}