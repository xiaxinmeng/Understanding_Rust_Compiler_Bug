{"sha": "8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiOTRlOWU5MTg4YjY1ZGYzOGE1ZjFhZTcyMzYxN2RjMmRmYjMxNTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-29T00:12:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-29T00:12:12Z"}, "message": "Auto merge of #63094 - Centril:rollup-lm7peuh, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #62809 (rustc: Update wasm32 support for LLVM 9)\n - #63055 (Various cleanups to save analysis)\n - #63076 (Miri: fix determining size of an \"extra function\" allocation)\n - #63077 (cleanup: Remove some language features related to built-in macros)\n - #63086 (Ignore test cases that are not supported by vxWorks)\n - #63092 (Update `impl Trait` gate issues)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "365c90767ab79c5839c267ea78dd834bfeb81dd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/365c90767ab79c5839c267ea78dd834bfeb81dd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "html_url": "https://github.com/rust-lang/rust/commit/8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7312fe4ff85ada30103cea58db25d83e0bec4b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7312fe4ff85ada30103cea58db25d83e0bec4b0", "html_url": "https://github.com/rust-lang/rust/commit/c7312fe4ff85ada30103cea58db25d83e0bec4b0"}, {"sha": "f8321d0d97495212f8247fcd620398721638ba0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8321d0d97495212f8247fcd620398721638ba0c", "html_url": "https://github.com/rust-lang/rust/commit/f8321d0d97495212f8247fcd620398721638ba0c"}], "stats": {"total": 725, "additions": 240, "deletions": 485}, "files": [{"sha": "2a1b6397781f95fc9a98fbb620c6e5b2dd29aae8", "filename": "src/doc/unstable-book/src/library-features/asm.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "previous_filename": "src/doc/unstable-book/src/language-features/asm.md"}, {"sha": "ecfd34a22e5ccbd39794a260879eb88317088e09", "filename": "src/doc/unstable-book/src/library-features/concat-idents.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fconcat-idents.md", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fconcat-idents.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fconcat-idents.md?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "previous_filename": "src/doc/unstable-book/src/language-features/concat-idents.md"}, {"sha": "bc55fe80fa64c599f954ebdedd613ebba60465e1", "filename": "src/doc/unstable-book/src/library-features/global-asm.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fglobal-asm.md", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fglobal-asm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fglobal-asm.md?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "previous_filename": "src/doc/unstable-book/src/language-features/global-asm.md"}, {"sha": "41aa286e69bfb320a0467ce4659e506093257807", "filename": "src/doc/unstable-book/src/library-features/trace-macros.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ftrace-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ftrace-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ftrace-macros.md?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "previous_filename": "src/doc/unstable-book/src/language-features/trace-macros.md"}, {"sha": "f0bdb0018efe7f71fc415390eb4c7a6697640edd", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -913,9 +913,12 @@ pub fn compile_unit_metadata(\n     }\n \n     debug!(\"compile_unit_metadata: {:?}\", name_in_debuginfo);\n+    let rustc_producer = format!(\n+        \"rustc version {}\",\n+        option_env!(\"CFG_VERSION\").expect(\"CFG_VERSION\"),\n+    );\n     // FIXME(#41252) Remove \"clang LLVM\" if we can get GDB and LLVM to play nice.\n-    let producer = format!(\"clang LLVM (rustc version {})\",\n-                           (option_env!(\"CFG_VERSION\")).expect(\"CFG_VERSION\"));\n+    let producer = format!(\"clang LLVM ({})\", rustc_producer);\n \n     let name_in_debuginfo = name_in_debuginfo.to_string_lossy();\n     let name_in_debuginfo = SmallCStr::new(&name_in_debuginfo);\n@@ -980,6 +983,21 @@ pub fn compile_unit_metadata(\n                                               gcov_metadata);\n         }\n \n+        // Insert `llvm.ident` metadata on the wasm32 targets since that will\n+        // get hooked up to the \"producer\" sections `processed-by` information.\n+        if tcx.sess.opts.target_triple.triple().starts_with(\"wasm32\") {\n+            let name_metadata = llvm::LLVMMDStringInContext(\n+                debug_context.llcontext,\n+                rustc_producer.as_ptr() as *const _,\n+                rustc_producer.as_bytes().len() as c_uint,\n+            );\n+            llvm::LLVMAddNamedMetadataOperand(\n+                debug_context.llmod,\n+                const_cstr!(\"llvm.ident\").as_ptr(),\n+                llvm::LLVMMDNodeInContext(debug_context.llcontext, &name_metadata, 1),\n+            );\n+        }\n+\n         return unit_metadata;\n     };\n "}, {"sha": "3f6a1a72ea61ebb674fe212b29665e2520ab5ec2", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -678,14 +678,6 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n             sess.fatal(&format!(\"failed to run dsymutil: {}\", e))\n         }\n     }\n-\n-    if sess.opts.target_triple.triple() == \"wasm32-unknown-unknown\" {\n-        super::wasm::add_producer_section(\n-            &out_filename,\n-            &sess.edition().to_string(),\n-            option_env!(\"CFG_VERSION\").unwrap_or(\"unknown\"),\n-        );\n-    }\n }\n \n /// Returns a boolean indicating whether the specified crate should be ignored"}, {"sha": "26091005f25aa72fca26efa45df8de1367482442", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -901,7 +901,45 @@ pub struct WasmLd<'a> {\n }\n \n impl<'a> WasmLd<'a> {\n-    fn new(cmd: Command, sess: &'a Session, info: &'a LinkerInfo) -> WasmLd<'a> {\n+    fn new(mut cmd: Command, sess: &'a Session, info: &'a LinkerInfo) -> WasmLd<'a> {\n+        // If the atomics feature is enabled for wasm then we need a whole bunch\n+        // of flags:\n+        //\n+        // * `--shared-memory` - the link won't even succeed without this, flags\n+        //   the one linear memory as `shared`\n+        //\n+        // * `--max-memory=1G` - when specifying a shared memory this must also\n+        //   be specified. We conservatively choose 1GB but users should be able\n+        //   to override this with `-C link-arg`.\n+        //\n+        // * `--import-memory` - it doesn't make much sense for memory to be\n+        //   exported in a threaded module because typically you're\n+        //   sharing memory and instantiating the module multiple times. As a\n+        //   result if it were exported then we'd just have no sharing.\n+        //\n+        // * `--passive-segments` - all memory segments should be passive to\n+        //   prevent each module instantiation from reinitializing memory.\n+        //\n+        // * `--export=__wasm_init_memory` - when using `--passive-segments` the\n+        //   linker will synthesize this function, and so we need to make sure\n+        //   that our usage of `--export` below won't accidentally cause this\n+        //   function to get deleted.\n+        //\n+        // * `--export=*tls*` - when `#[thread_local]` symbols are used these\n+        //   symbols are how the TLS segments are initialized and configured.\n+        let atomics = sess.opts.cg.target_feature.contains(\"+atomics\") ||\n+            sess.target.target.options.features.contains(\"+atomics\");\n+        if atomics {\n+            cmd.arg(\"--shared-memory\");\n+            cmd.arg(\"--max-memory=1073741824\");\n+            cmd.arg(\"--import-memory\");\n+            cmd.arg(\"--passive-segments\");\n+            cmd.arg(\"--export=__wasm_init_memory\");\n+            cmd.arg(\"--export=__wasm_init_tls\");\n+            cmd.arg(\"--export=__tls_size\");\n+            cmd.arg(\"--export=__tls_align\");\n+            cmd.arg(\"--export=__tls_base\");\n+        }\n         WasmLd { cmd, sess, info }\n     }\n }\n@@ -1004,6 +1042,13 @@ impl<'a> Linker for WasmLd<'a> {\n         for sym in self.info.exports[&crate_type].iter() {\n             self.cmd.arg(\"--export\").arg(&sym);\n         }\n+\n+        // LLD will hide these otherwise-internal symbols since our `--export`\n+        // list above is a whitelist of what to export. Various bits and pieces\n+        // of tooling use this, so be sure these symbols make their way out of\n+        // the linker as well.\n+        self.cmd.arg(\"--export=__heap_base\");\n+        self.cmd.arg(\"--export=__data_end\");\n     }\n \n     fn subsystem(&mut self, _subsystem: &str) {"}, {"sha": "901891d85a465f397b921c2332a59fe218e53260", "filename": "src/librustc_codegen_ssa/back/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibrustc_codegen_ssa%2Fback%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibrustc_codegen_ssa%2Fback%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fmod.rs?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -6,4 +6,3 @@ pub mod command;\n pub mod symbol_export;\n pub mod archive;\n pub mod rpath;\n-pub mod wasm;"}, {"sha": "2a9e81a788e52fad48c3d9a107283cffd17240b6", "filename": "src/librustc_codegen_ssa/back/wasm.rs", "status": "removed", "additions": 0, "deletions": 191, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc_codegen_ssa%2Fback%2Fwasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibrustc_codegen_ssa%2Fback%2Fwasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwasm.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -1,191 +0,0 @@\n-use std::fs;\n-use std::path::Path;\n-use std::str;\n-\n-use rustc_serialize::leb128;\n-\n-// https://webassembly.github.io/spec/core/binary/modules.html#binary-importsec\n-const WASM_CUSTOM_SECTION_ID: u8 = 0;\n-\n-/// Adds or augment the existing `producers` section to encode information about\n-/// the Rust compiler used to produce the wasm file.\n-pub fn add_producer_section(\n-    path: &Path,\n-    rust_version: &str,\n-    rustc_version: &str,\n-) {\n-    struct Field<'a> {\n-        name: &'a str,\n-        values: Vec<FieldValue<'a>>,\n-    }\n-\n-    #[derive(Copy, Clone)]\n-    struct FieldValue<'a> {\n-        name: &'a str,\n-        version: &'a str,\n-    }\n-\n-    let wasm = fs::read(path).expect(\"failed to read wasm output\");\n-    let mut ret = WasmEncoder::new();\n-    ret.data.extend(&wasm[..8]);\n-\n-    // skip the 8 byte wasm/version header\n-    let rustc_value = FieldValue {\n-        name: \"rustc\",\n-        version: rustc_version,\n-    };\n-    let rust_value = FieldValue {\n-        name: \"Rust\",\n-        version: rust_version,\n-    };\n-    let mut fields = Vec::new();\n-    let mut wrote_rustc = false;\n-    let mut wrote_rust = false;\n-\n-    // Move all sections from the original wasm file to our output, skipping\n-    // everything except the producers section\n-    for (id, raw) in WasmSections(WasmDecoder::new(&wasm[8..])) {\n-        if id != WASM_CUSTOM_SECTION_ID {\n-            ret.byte(id);\n-            ret.bytes(raw);\n-            continue\n-        }\n-        let mut decoder = WasmDecoder::new(raw);\n-        if decoder.str() != \"producers\" {\n-            ret.byte(id);\n-            ret.bytes(raw);\n-            continue\n-        }\n-\n-        // Read off the producers section into our fields outside the loop,\n-        // we'll re-encode the producers section when we're done (to handle an\n-        // entirely missing producers section as well).\n-        info!(\"rewriting existing producers section\");\n-\n-        for _ in 0..decoder.u32() {\n-            let name = decoder.str();\n-            let mut values = Vec::new();\n-            for _ in 0..decoder.u32() {\n-                let name = decoder.str();\n-                let version = decoder.str();\n-                values.push(FieldValue { name, version });\n-            }\n-\n-            if name == \"language\" {\n-                values.push(rust_value);\n-                wrote_rust = true;\n-            } else if name == \"processed-by\" {\n-                values.push(rustc_value);\n-                wrote_rustc = true;\n-            }\n-            fields.push(Field { name, values });\n-        }\n-    }\n-\n-    if !wrote_rust {\n-        fields.push(Field {\n-            name: \"language\",\n-            values: vec![rust_value],\n-        });\n-    }\n-    if !wrote_rustc {\n-        fields.push(Field {\n-            name: \"processed-by\",\n-            values: vec![rustc_value],\n-        });\n-    }\n-\n-    // Append the producers section to the end of the wasm file.\n-    let mut section = WasmEncoder::new();\n-    section.str(\"producers\");\n-    section.u32(fields.len() as u32);\n-    for field in fields {\n-        section.str(field.name);\n-        section.u32(field.values.len() as u32);\n-        for value in field.values {\n-            section.str(value.name);\n-            section.str(value.version);\n-        }\n-    }\n-    ret.byte(WASM_CUSTOM_SECTION_ID);\n-    ret.bytes(&section.data);\n-\n-    fs::write(path, &ret.data).expect(\"failed to write wasm output\");\n-}\n-\n-struct WasmSections<'a>(WasmDecoder<'a>);\n-\n-impl<'a> Iterator for WasmSections<'a> {\n-    type Item = (u8, &'a [u8]);\n-\n-    fn next(&mut self) -> Option<(u8, &'a [u8])> {\n-        if self.0.data.is_empty() {\n-            return None\n-        }\n-\n-        // see https://webassembly.github.io/spec/core/binary/modules.html#sections\n-        let id = self.0.byte();\n-        let section_len = self.0.u32();\n-        info!(\"new section {} / {} bytes\", id, section_len);\n-        let section = self.0.skip(section_len as usize);\n-        Some((id, section))\n-    }\n-}\n-\n-struct WasmDecoder<'a> {\n-    data: &'a [u8],\n-}\n-\n-impl<'a> WasmDecoder<'a> {\n-    fn new(data: &'a [u8]) -> WasmDecoder<'a> {\n-        WasmDecoder { data }\n-    }\n-\n-    fn byte(&mut self) -> u8 {\n-        self.skip(1)[0]\n-    }\n-\n-    fn u32(&mut self) -> u32 {\n-        let (n, l1) = leb128::read_u32_leb128(self.data);\n-        self.data = &self.data[l1..];\n-        return n\n-    }\n-\n-    fn skip(&mut self, amt: usize) -> &'a [u8] {\n-        let (data, rest) = self.data.split_at(amt);\n-        self.data = rest;\n-        data\n-    }\n-\n-    fn str(&mut self) -> &'a str {\n-        let len = self.u32();\n-        str::from_utf8(self.skip(len as usize)).unwrap()\n-    }\n-}\n-\n-struct WasmEncoder {\n-    data: Vec<u8>,\n-}\n-\n-impl WasmEncoder {\n-    fn new() -> WasmEncoder {\n-        WasmEncoder { data: Vec::new() }\n-    }\n-\n-    fn u32(&mut self, val: u32) {\n-        leb128::write_u32_leb128(&mut self.data, val);\n-    }\n-\n-    fn byte(&mut self, val: u8) {\n-        self.data.push(val);\n-    }\n-\n-    fn bytes(&mut self, val: &[u8]) {\n-        self.u32(val.len() as u32);\n-        self.data.extend_from_slice(val);\n-    }\n-\n-    fn str(&mut self, val: &str) {\n-        self.bytes(val.as_bytes())\n-    }\n-}"}, {"sha": "e3f16a3c9ea452432b33ed47ebd2b70b0c8e6dcf", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -54,6 +54,16 @@ pub trait AllocMap<K: Hash + Eq, V> {\n         k: K,\n         vacant: impl FnOnce() -> Result<V, E>\n     ) -> Result<&mut V, E>;\n+\n+    /// Read-only lookup.\n+    fn get(&self, k: K) -> Option<&V> {\n+        self.get_or(k, || Err(())).ok()\n+    }\n+\n+    /// Mutable lookup.\n+    fn get_mut(&mut self, k: K) -> Option<&mut V> {\n+        self.get_mut_or(k, || Err(())).ok()\n+    }\n }\n \n /// Methods of this trait signifies a point where CTFE evaluation would fail"}, {"sha": "87dd7738410ee8f4d054c51d3bc9c60be9de6ba0", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 43, "deletions": 39, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -535,48 +535,52 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         id: AllocId,\n         liveness: AllocCheck,\n     ) -> InterpResult<'static, (Size, Align)> {\n+        // # Regular allocations\n         // Don't use `self.get` here as that will\n         // a) cause cycles in case `id` refers to a static\n         // b) duplicate a static's allocation in miri\n-        match self.alloc_map.get_or(id, || Err(())) {\n-            Ok((_, alloc)) => Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align)),\n-            Err(()) => {\n-                // Not a local allocation, check the global `tcx.alloc_map`.\n-\n-                // Can't do this in the match argument, we may get cycle errors since the lock would\n-                // be held throughout the match.\n-                let alloc = self.tcx.alloc_map.lock().get(id);\n-                match alloc {\n-                    Some(GlobalAlloc::Static(did)) => {\n-                        // Use size and align of the type.\n-                        let ty = self.tcx.type_of(did);\n-                        let layout = self.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n-                        Ok((layout.size, layout.align.abi))\n-                    },\n-                    Some(GlobalAlloc::Memory(alloc)) =>\n-                        // Need to duplicate the logic here, because the global allocations have\n-                        // different associated types than the interpreter-local ones.\n-                        Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align)),\n-                    Some(GlobalAlloc::Function(_)) => {\n-                        if let AllocCheck::Dereferencable = liveness {\n-                            // The caller requested no function pointers.\n-                            err!(DerefFunctionPointer)\n-                        } else {\n-                            Ok((Size::ZERO, Align::from_bytes(1).unwrap()))\n-                        }\n-                    },\n-                    // The rest must be dead.\n-                    None => if let AllocCheck::MaybeDead = liveness {\n-                        // Deallocated pointers are allowed, we should be able to find\n-                        // them in the map.\n-                        Ok(*self.dead_alloc_map.get(&id)\n-                            .expect(\"deallocated pointers should all be recorded in \\\n-                                    `dead_alloc_map`\"))\n-                    } else {\n-                        err!(DanglingPointerDeref)\n-                    },\n-                }\n-            }\n+        if let Some((_, alloc)) = self.alloc_map.get(id) {\n+            return Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align));\n+        }\n+\n+        // # Function pointers\n+        // (both global from `alloc_map` and local from `extra_fn_ptr_map`)\n+        if let Ok(_) = self.get_fn_alloc(id) {\n+            return if let AllocCheck::Dereferencable = liveness {\n+                // The caller requested no function pointers.\n+                err!(DerefFunctionPointer)\n+            } else {\n+                Ok((Size::ZERO, Align::from_bytes(1).unwrap()))\n+            };\n+        }\n+\n+        // # Statics\n+        // Can't do this in the match argument, we may get cycle errors since the lock would\n+        // be held throughout the match.\n+        let alloc = self.tcx.alloc_map.lock().get(id);\n+        match alloc {\n+            Some(GlobalAlloc::Static(did)) => {\n+                // Use size and align of the type.\n+                let ty = self.tcx.type_of(did);\n+                let layout = self.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n+                Ok((layout.size, layout.align.abi))\n+            },\n+            Some(GlobalAlloc::Memory(alloc)) =>\n+                // Need to duplicate the logic here, because the global allocations have\n+                // different associated types than the interpreter-local ones.\n+                Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align)),\n+            Some(GlobalAlloc::Function(_)) =>\n+                bug!(\"We already checked function pointers above\"),\n+            // The rest must be dead.\n+            None => if let AllocCheck::MaybeDead = liveness {\n+                // Deallocated pointers are allowed, we should be able to find\n+                // them in the map.\n+                Ok(*self.dead_alloc_map.get(&id)\n+                    .expect(\"deallocated pointers should all be recorded in \\\n+                            `dead_alloc_map`\"))\n+            } else {\n+                err!(DanglingPointerDeref)\n+            },\n         }\n     }\n "}, {"sha": "6fce7ca1f33fbcc8a77d075197b9211ff1c54f71", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -23,7 +23,7 @@ use rustc_data_structures::fx::FxHashSet;\n use std::path::Path;\n use std::env;\n \n-use syntax::ast::{self, Attribute, NodeId, PatKind, CRATE_NODE_ID};\n+use syntax::ast::{self, Attribute, NodeId, PatKind};\n use syntax::parse::token;\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{\n@@ -75,15 +75,13 @@ macro_rules! access_from_vis {\n     };\n }\n \n-pub struct DumpVisitor<'l, 'tcx, 'll> {\n-    save_ctxt: SaveContext<'l, 'tcx>,\n+pub struct DumpVisitor<'l, 'tcx> {\n+    pub save_ctxt: SaveContext<'l, 'tcx>,\n     tcx: TyCtxt<'tcx>,\n-    dumper: &'ll mut Dumper,\n+    dumper: Dumper,\n \n     span: SpanUtils<'l>,\n \n-    cur_scope: NodeId,\n-\n     // Set of macro definition (callee) spans, and the set\n     // of macro use (callsite) spans. We store these to ensure\n     // we only write one macro def per unique macro definition, and\n@@ -92,36 +90,29 @@ pub struct DumpVisitor<'l, 'tcx, 'll> {\n     // macro_calls: FxHashSet<Span>,\n }\n \n-impl<'l, 'tcx, 'll> DumpVisitor<'l, 'tcx, 'll> {\n+impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     pub fn new(\n         save_ctxt: SaveContext<'l, 'tcx>,\n-        dumper: &'ll mut Dumper,\n-    ) -> DumpVisitor<'l, 'tcx, 'll> {\n+    ) -> DumpVisitor<'l, 'tcx> {\n         let span_utils = SpanUtils::new(&save_ctxt.tcx.sess);\n+        let dumper = Dumper::new(save_ctxt.config.clone());\n         DumpVisitor {\n             tcx: save_ctxt.tcx,\n             save_ctxt,\n             dumper,\n             span: span_utils,\n-            cur_scope: CRATE_NODE_ID,\n             // mac_defs: FxHashSet::default(),\n             // macro_calls: FxHashSet::default(),\n         }\n     }\n \n-    fn nest_scope<F>(&mut self, scope_id: NodeId, f: F)\n-    where\n-        F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll>),\n-    {\n-        let parent_scope = self.cur_scope;\n-        self.cur_scope = scope_id;\n-        f(self);\n-        self.cur_scope = parent_scope;\n+    pub fn analysis(&self) -> &rls_data::Analysis {\n+        self.dumper.analysis()\n     }\n \n     fn nest_tables<F>(&mut self, item_id: NodeId, f: F)\n     where\n-        F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll>),\n+        F: FnOnce(&mut Self),\n     {\n         let item_def_id = self.tcx.hir().local_def_id_from_node_id(item_id);\n         if self.tcx.has_typeck_tables(item_def_id) {\n@@ -320,7 +311,7 @@ impl<'l, 'tcx, 'll> DumpVisitor<'l, 'tcx, 'll> {\n \n         // walk the fn body\n         if let Some(body) = body {\n-            self.nest_tables(id, |v| v.nest_scope(id, |v| v.visit_block(body)));\n+            self.nest_tables(id, |v| v.visit_block(body));\n         }\n     }\n \n@@ -405,7 +396,7 @@ impl<'l, 'tcx, 'll> DumpVisitor<'l, 'tcx, 'll> {\n             self.visit_ty(&ret_ty);\n         }\n \n-        self.nest_tables(item.id, |v| v.nest_scope(item.id, |v| v.visit_block(&body)));\n+        self.nest_tables(item.id, |v| v.visit_block(&body));\n     }\n \n     fn process_static_or_const_item(\n@@ -1311,7 +1302,7 @@ impl<'l, 'tcx, 'll> DumpVisitor<'l, 'tcx, 'll> {\n     }\n }\n \n-impl<'l, 'tcx, 'll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll> {\n+impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n     fn visit_mod(&mut self, m: &'l ast::Mod, span: Span, attrs: &[ast::Attribute], id: NodeId) {\n         // Since we handle explicit modules ourselves in visit_item, this should\n         // only get called for the root module of a crate.\n@@ -1349,7 +1340,7 @@ impl<'l, 'tcx, 'll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll> {\n                 attributes: lower_attributes(attrs.to_owned(), &self.save_ctxt),\n             },\n         );\n-        self.nest_scope(id, |v| visit::walk_mod(v, m));\n+        visit::walk_mod(self, m);\n     }\n \n     fn visit_item(&mut self, item: &'l ast::Item) {\n@@ -1404,7 +1395,7 @@ impl<'l, 'tcx, 'll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll> {\n             }\n             Mod(ref m) => {\n                 self.process_mod(item);\n-                self.nest_scope(item.id, |v| visit::walk_mod(v, m));\n+                visit::walk_mod(self, m);\n             }\n             Ty(ref ty, ref ty_params) => {\n                 let qualname = format!(\"::{}\",\n@@ -1570,7 +1561,7 @@ impl<'l, 'tcx, 'll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll> {\n                 // walk the body\n                 self.nest_tables(ex.id, |v| {\n                     v.process_formals(&decl.inputs, &id);\n-                    v.nest_scope(ex.id, |v| v.visit_expr(body))\n+                    v.visit_expr(body)\n                 });\n             }\n             ast::ExprKind::ForLoop(ref pattern, ref subexpression, ref block, _) => {"}, {"sha": "b80778c8fec7ec5f37c5e71f16add9508ca2dfed", "filename": "src/librustc_save_analysis/dumper.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibrustc_save_analysis%2Fdumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibrustc_save_analysis%2Fdumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdumper.rs?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -22,8 +22,8 @@ impl Dumper {\n         }\n     }\n \n-    pub fn to_output(self, f: impl FnOnce(&Analysis)) {\n-        f(&self.result)\n+    pub fn analysis(&self) -> &Analysis {\n+        &self.result\n     }\n }\n "}, {"sha": "25dcd4664a624590fe9ff3f267906e1d1e009776", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 23, "deletions": 45, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -35,12 +35,11 @@ use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{arg_to_string, ty_to_string};\n use syntax_pos::*;\n \n-use dumper::Dumper;\n use dump_visitor::DumpVisitor;\n use span_utils::SpanUtils;\n \n use rls_data::{Def, DefKind, ExternalCrateData, GlobalCrateId, MacroRef, Ref, RefKind, Relation,\n-               RelationKind, SpanData, Impl, ImplKind};\n+               RelationKind, SpanData, Impl, ImplKind, Analysis};\n use rls_data::config::Config;\n \n use log::{debug, error, info};\n@@ -997,12 +996,10 @@ impl<'l> Visitor<'l> for PathCollector<'l> {\n \n /// Defines what to do with the results of saving the analysis.\n pub trait SaveHandler {\n-    fn save<'l, 'tcx>(\n+    fn save(\n         &mut self,\n-        save_ctxt: SaveContext<'l, 'tcx>,\n-        krate: &ast::Crate,\n-        cratename: &str,\n-        input: &'l Input,\n+        save_ctxt: &SaveContext<'_, '_>,\n+        analysis: &Analysis,\n     );\n }\n \n@@ -1062,28 +1059,17 @@ impl<'a> DumpHandler<'a> {\n     }\n }\n \n-impl<'a> SaveHandler for DumpHandler<'a> {\n-    fn save<'l, 'tcx>(\n+impl SaveHandler for DumpHandler<'_> {\n+    fn save(\n         &mut self,\n-        save_ctxt: SaveContext<'l, 'tcx>,\n-        krate: &ast::Crate,\n-        cratename: &str,\n-        input: &'l Input,\n+        save_ctxt: &SaveContext<'_, '_>,\n+        analysis: &Analysis,\n     ) {\n         let sess = &save_ctxt.tcx.sess;\n         let (output, file_name) = self.output_file(&save_ctxt);\n-        let mut dumper = Dumper::new(save_ctxt.config.clone());\n-        let mut visitor = DumpVisitor::new(save_ctxt, &mut dumper);\n-\n-        visitor.dump_crate_info(cratename, krate);\n-        visitor.dump_compilation_options(input, cratename);\n-        visit::walk_crate(&mut visitor, krate);\n-\n-        dumper.to_output(|analysis| {\n-            if let Err(e) = serde_json::to_writer(output, analysis) {\n-                error!(\"Can't serialize save-analysis: {:?}\", e);\n-            }\n-        });\n+        if let Err(e) = serde_json::to_writer(output, &analysis) {\n+            error!(\"Can't serialize save-analysis: {:?}\", e);\n+        }\n \n         if sess.opts.debugging_opts.emit_artifact_notifications {\n             sess.parse_sess.span_diagnostic\n@@ -1097,27 +1083,13 @@ pub struct CallbackHandler<'b> {\n     pub callback: &'b mut dyn FnMut(&rls_data::Analysis),\n }\n \n-impl<'b> SaveHandler for CallbackHandler<'b> {\n-    fn save<'l, 'tcx>(\n+impl SaveHandler for CallbackHandler<'_> {\n+    fn save(\n         &mut self,\n-        save_ctxt: SaveContext<'l, 'tcx>,\n-        krate: &ast::Crate,\n-        cratename: &str,\n-        input: &'l Input,\n+        _: &SaveContext<'_, '_>,\n+        analysis: &Analysis,\n     ) {\n-        // We're using the Dumper here because it has the format of the\n-        // save-analysis results that we will pass to the callback. IOW, we are\n-        // using the Dumper to collect the save-analysis results, but not\n-        // actually to dump them to a file. This is all a bit convoluted and\n-        // there is certainly a simpler design here trying to get out (FIXME).\n-        let mut dumper = Dumper::new(save_ctxt.config.clone());\n-        let mut visitor = DumpVisitor::new(save_ctxt, &mut dumper);\n-\n-        visitor.dump_crate_info(cratename, krate);\n-        visitor.dump_compilation_options(input, cratename);\n-        visit::walk_crate(&mut visitor, krate);\n-\n-        dumper.to_output(|a| (self.callback)(a))\n+        (self.callback)(analysis)\n     }\n }\n \n@@ -1148,7 +1120,13 @@ pub fn process_crate<'l, 'tcx, H: SaveHandler>(\n             impl_counter: Cell::new(0),\n         };\n \n-        handler.save(save_ctxt, krate, cratename, input)\n+        let mut visitor = DumpVisitor::new(save_ctxt);\n+\n+        visitor.dump_crate_info(cratename, krate);\n+        visitor.dump_compilation_options(input, cratename);\n+        visit::walk_crate(&mut visitor, krate);\n+\n+        handler.save(&visitor.save_ctxt, &visitor.analysis())\n     })\n }\n "}, {"sha": "6f00245b009411e738c31a597efa6483ce025d06", "filename": "src/librustc_target/spec/wasm32_base.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibrustc_target%2Fspec%2Fwasm32_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibrustc_target%2Fspec%2Fwasm32_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwasm32_base.rs?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -132,6 +132,14 @@ pub fn options() -> TargetOptions {\n         // non-relative calls and such later on).\n         relocation_model: \"static\".to_string(),\n \n+        // When the atomics feature is activated then these two keys matter,\n+        // otherwise they're basically ignored by the standard library. In this\n+        // mode, however, the `#[thread_local]` attribute works (i.e.\n+        // `has_elf_tls`) and we need to get it to work by specifying\n+        // `local-exec` as that's all that's implemented in LLVM today for wasm.\n+        has_elf_tls: true,\n+        tls_model: \"local-exec\".to_string(),\n+\n         .. Default::default()\n     }\n }"}, {"sha": "2e0da0409eb09766c9594455fb7a51484ec8ef73", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -75,11 +75,6 @@ panic_immediate_abort = [\"core/panic_immediate_abort\"]\n # requires rebuilding the standard library to use it.\n wasm_syscall = []\n \n-# An off-by-default features to enable libstd to assume that wasm-bindgen is in\n-# the environment for hooking up some thread-related information like the\n-# current thread id and accessing/getting the current thread's TCB\n-wasm-bindgen-threads = []\n-\n # Enable std_detect default features for stdarch/crates/std_detect:\n # https://github.com/rust-lang/stdarch/blob/master/crates/std_detect/Cargo.toml\n std_detect_file_io = []"}, {"sha": "f842869e08ee69e0c628a99dccceb7f662e5df38", "filename": "src/libstd/sys/wasi/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -47,6 +47,8 @@ pub mod stdio;\n pub mod thread;\n #[path = \"../wasm/thread_local.rs\"]\n pub mod thread_local;\n+#[path = \"../wasm/fast_thread_local.rs\"]\n+pub mod fast_thread_local;\n pub mod time;\n pub mod ext;\n "}, {"sha": "ff2198175f0a9682b7c6d6c9773aa9e1e4dbc8e2", "filename": "src/libstd/sys/wasm/fast_thread_local.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibstd%2Fsys%2Fwasm%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibstd%2Fsys%2Fwasm%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Ffast_thread_local.rs?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -0,0 +1,9 @@\n+#![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n+\n+pub unsafe fn register_dtor(_t: *mut u8, _dtor: unsafe extern fn(*mut u8)) {\n+    // FIXME: right now there is no concept of \"thread exit\", but this is likely\n+    // going to show up at some point in the form of an exported symbol that the\n+    // wasm runtime is oging to be expected to call. For now we basically just\n+    // ignore the arguments, but if such a function starts to exist it will\n+    // likely look like the OSX implementation in `unix/fast_thread_local.rs`\n+}"}, {"sha": "56cbafcfdb8a2af1196c8d38ae24c61ce695d646", "filename": "src/libstd/sys/wasm/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -37,6 +37,8 @@ pub mod stack_overflow;\n pub mod thread;\n pub mod time;\n pub mod stdio;\n+pub mod thread_local;\n+pub mod fast_thread_local;\n \n pub use crate::sys_common::os_str_bytes as os_str;\n \n@@ -48,13 +50,10 @@ cfg_if::cfg_if! {\n         pub mod mutex;\n         #[path = \"rwlock_atomics.rs\"]\n         pub mod rwlock;\n-        #[path = \"thread_local_atomics.rs\"]\n-        pub mod thread_local;\n     } else {\n         pub mod condvar;\n         pub mod mutex;\n         pub mod rwlock;\n-        pub mod thread_local;\n     }\n }\n "}, {"sha": "d06965f3278498eda3a5924a0cb3e60251855a3e", "filename": "src/libstd/sys/wasm/thread.rs", "status": "modified", "additions": 34, "deletions": 42, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -59,48 +59,40 @@ pub mod guard {\n     pub unsafe fn init() -> Option<Guard> { None }\n }\n \n-cfg_if::cfg_if! {\n-    if #[cfg(all(target_feature = \"atomics\", feature = \"wasm-bindgen-threads\"))] {\n-        #[link(wasm_import_module = \"__wbindgen_thread_xform__\")]\n-        extern {\n-            fn __wbindgen_current_id() -> u32;\n-            fn __wbindgen_tcb_get() -> u32;\n-            fn __wbindgen_tcb_set(ptr: u32);\n+// This is only used by atomics primitives when the `atomics` feature is\n+// enabled. In that mode we currently just use our own thread-local to store our\n+// current thread's ID, and then we lazily initialize it to something allocated\n+// from a global counter.\n+#[cfg(target_feature = \"atomics\")]\n+pub fn my_id() -> u32 {\n+    use crate::sync::atomic::{AtomicU32, Ordering::SeqCst};\n+\n+    static NEXT_ID: AtomicU32 = AtomicU32::new(0);\n+\n+    #[thread_local]\n+    static mut MY_ID: u32 = 0;\n+\n+    unsafe {\n+        // If our thread ID isn't set yet then we need to allocate one. Do so\n+        // with with a simple \"atomically add to a global counter\" strategy.\n+        // This strategy doesn't handled what happens when the counter\n+        // overflows, however, so just abort everything once the counter\n+        // overflows and eventually we could have some sort of recycling scheme\n+        // (or maybe this is all totally irrelevant by that point!). In any case\n+        // though we're using a CAS loop instead of a `fetch_add` to ensure that\n+        // the global counter never overflows.\n+        if MY_ID == 0 {\n+            let mut cur = NEXT_ID.load(SeqCst);\n+            MY_ID = loop {\n+                let next = cur.checked_add(1).unwrap_or_else(|| {\n+                    crate::arch::wasm32::unreachable()\n+                });\n+                match NEXT_ID.compare_exchange(cur, next, SeqCst, SeqCst) {\n+                    Ok(_) => break next,\n+                    Err(i) => cur = i,\n+                }\n+            };\n         }\n-        pub fn my_id() -> u32 {\n-            unsafe { __wbindgen_current_id() }\n-        }\n-\n-        // These are currently only ever used in `thread_local_atomics.rs`, if\n-        // you'd like to use them be sure to update that and make sure everyone\n-        // agrees what's what.\n-        pub fn tcb_get() -> *mut u8 {\n-            use crate::mem;\n-            assert_eq!(mem::size_of::<*mut u8>(), mem::size_of::<u32>());\n-            unsafe { __wbindgen_tcb_get() as *mut u8 }\n-        }\n-\n-        pub fn tcb_set(ptr: *mut u8) {\n-            unsafe { __wbindgen_tcb_set(ptr as u32); }\n-        }\n-\n-        // FIXME: still need something for hooking exiting a thread to free\n-        // data...\n-\n-    } else if #[cfg(target_feature = \"atomics\")] {\n-        pub fn my_id() -> u32 {\n-            panic!(\"thread ids not implemented on wasm with atomics yet\")\n-        }\n-\n-        pub fn tcb_get() -> *mut u8 {\n-            panic!(\"thread local data not implemented on wasm with atomics yet\")\n-        }\n-\n-        pub fn tcb_set(_ptr: *mut u8) {\n-            panic!(\"thread local data not implemented on wasm with atomics yet\")\n-        }\n-    } else {\n-        // stubbed out because no functions actually access these intrinsics\n-        // unless atomics are enabled\n+        MY_ID\n     }\n }"}, {"sha": "8a0ca6f3d25a8f47cf88ab90c19d9a04a2d42037", "filename": "src/libstd/sys/wasm/thread_local.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local.rs?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -1,40 +1,26 @@\n-use crate::boxed::Box;\n-use crate::ptr;\n-\n pub type Key = usize;\n \n-struct Allocated {\n-    value: *mut u8,\n-    dtor: Option<unsafe extern fn(*mut u8)>,\n-}\n-\n #[inline]\n-pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n-    Box::into_raw(Box::new(Allocated {\n-        value: ptr::null_mut(),\n-        dtor,\n-    })) as usize\n+pub unsafe fn create(_dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+    panic!(\"should not be used on the wasm target\");\n }\n \n #[inline]\n-pub unsafe fn set(key: Key, value: *mut u8) {\n-    (*(key as *mut Allocated)).value = value;\n+pub unsafe fn set(_key: Key, _value: *mut u8) {\n+    panic!(\"should not be used on the wasm target\");\n }\n \n #[inline]\n-pub unsafe fn get(key: Key) -> *mut u8 {\n-    (*(key as *mut Allocated)).value\n+pub unsafe fn get(_key: Key) -> *mut u8 {\n+    panic!(\"should not be used on the wasm target\");\n }\n \n #[inline]\n-pub unsafe fn destroy(key: Key) {\n-    let key = Box::from_raw(key as *mut Allocated);\n-    if let Some(f) = key.dtor {\n-        f(key.value);\n-    }\n+pub unsafe fn destroy(_key: Key) {\n+    panic!(\"should not be used on the wasm target\");\n }\n \n #[inline]\n pub fn requires_synchronized_create() -> bool {\n-    false\n+    panic!(\"should not be used on the wasm target\");\n }"}, {"sha": "3dc0bb24553fd644450b36c29a148d26a30fdbad", "filename": "src/libstd/sys/wasm/thread_local_atomics.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7312fe4ff85ada30103cea58db25d83e0bec4b0/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local_atomics.rs?ref=c7312fe4ff85ada30103cea58db25d83e0bec4b0", "patch": "@@ -1,61 +0,0 @@\n-use crate::sys::thread;\n-use crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n-\n-const MAX_KEYS: usize = 128;\n-static NEXT_KEY: AtomicUsize = AtomicUsize::new(0);\n-\n-struct ThreadControlBlock {\n-    keys: [*mut u8; MAX_KEYS],\n-}\n-\n-impl ThreadControlBlock {\n-    fn new() -> ThreadControlBlock {\n-        ThreadControlBlock {\n-            keys: [core::ptr::null_mut(); MAX_KEYS],\n-        }\n-    }\n-\n-    fn get() -> *mut ThreadControlBlock {\n-        let ptr = thread::tcb_get();\n-        if !ptr.is_null() {\n-            return ptr as *mut ThreadControlBlock\n-        }\n-        let tcb = Box::into_raw(Box::new(ThreadControlBlock::new()));\n-        thread::tcb_set(tcb as *mut u8);\n-        tcb\n-    }\n-}\n-\n-pub type Key = usize;\n-\n-pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n-    drop(dtor); // FIXME: need to figure out how to hook thread exit to run this\n-    let key = NEXT_KEY.fetch_add(1, SeqCst);\n-    if key >= MAX_KEYS {\n-        NEXT_KEY.store(MAX_KEYS, SeqCst);\n-        panic!(\"cannot allocate space for more TLS keys\");\n-    }\n-    // offset by 1 so we never hand out 0. This is currently required by\n-    // `sys_common/thread_local.rs` where it can't cope with keys of value 0\n-    // because it messes up the atomic management.\n-    return key + 1\n-}\n-\n-pub unsafe fn set(key: Key, value: *mut u8) {\n-    (*ThreadControlBlock::get()).keys[key - 1] = value;\n-}\n-\n-pub unsafe fn get(key: Key) -> *mut u8 {\n-    (*ThreadControlBlock::get()).keys[key - 1]\n-}\n-\n-pub unsafe fn destroy(_key: Key) {\n-    // FIXME: should implement this somehow, this isn't typically called but it\n-    // can be called if two threads race to initialize a TLS slot and one ends\n-    // up not being needed.\n-}\n-\n-#[inline]\n-pub fn requires_synchronized_create() -> bool {\n-    false\n-}"}, {"sha": "34e4d7d5a1993d2bfabc0c8444dce4c43d77cc54", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -243,9 +243,6 @@ declare_features! (\n     // Allows using `#![needs_allocator]`, an implementation detail of `#[global_allocator]`.\n     (active, allocator_internals, \"1.20.0\", None, None),\n \n-    // Allows using the `format_args_nl` macro.\n-    (active, format_args_nl, \"1.29.0\", Some(0), None),\n-\n     // no-tracking-issue-end\n \n     // Added for testing E0705; perma-unstable.\n@@ -286,12 +283,6 @@ declare_features! (\n     // feature-group-start: actual feature gates\n     // -------------------------------------------------------------------------\n \n-    // Allows using `asm!` macro with which inline assembly can be embedded.\n-    (active, asm, \"1.0.0\", Some(29722), None),\n-\n-    // Allows using the `concat_idents!` macro with which identifiers can be concatenated.\n-    (active, concat_idents, \"1.0.0\", Some(29599), None),\n-\n     // Allows using the `#[link_args]` attribute.\n     (active, link_args, \"1.0.0\", Some(29596), None),\n \n@@ -307,12 +298,6 @@ declare_features! (\n     // Allows using `#[thread_local]` on `static` items.\n     (active, thread_local, \"1.0.0\", Some(29594), None),\n \n-    // Allows using the `log_syntax!` macro.\n-    (active, log_syntax, \"1.0.0\", Some(29598), None),\n-\n-    // Allows using the `trace_macros!` macro.\n-    (active, trace_macros, \"1.0.0\", Some(29598), None),\n-\n     // Allows the use of SIMD types in functions declared in `extern` blocks.\n     (active, simd_ffi, \"1.0.0\", Some(27731), None),\n \n@@ -402,9 +387,6 @@ declare_features! (\n     // Allows `extern \"x86-interrupt\" fn()`.\n     (active, abi_x86_interrupt, \"1.17.0\", Some(40180), None),\n \n-    // Allows module-level inline assembly by way of `global_asm!()`.\n-    (active, global_asm, \"1.18.0\", Some(35119), None),\n-\n     // Allows overlapping impls of marker traits.\n     (active, overlapping_marker_traits, \"1.18.0\", Some(29864), None),\n \n@@ -472,7 +454,7 @@ declare_features! (\n     (active, doc_alias, \"1.27.0\", Some(50146), None),\n \n     // Allows defining `existential type`s.\n-    (active, existential_type, \"1.28.0\", Some(34511), None),\n+    (active, existential_type, \"1.28.0\", Some(63063), None),\n \n     // Allows inconsistent bounds in where clauses.\n     (active, trivial_bounds, \"1.28.0\", Some(48214), None),\n@@ -525,7 +507,7 @@ declare_features! (\n     (active, bind_by_move_pattern_guards, \"1.30.0\", Some(15287), None),\n \n     // Allows `impl Trait` in bindings (`let`, `const`, `static`).\n-    (active, impl_trait_in_bindings, \"1.30.0\", Some(34511), None),\n+    (active, impl_trait_in_bindings, \"1.30.0\", Some(63065), None),\n \n     // Allows using `reason` in lint attributes and the `#[expect(lint)]` lint check.\n     (active, lint_reasons, \"1.31.0\", Some(54503), None),"}, {"sha": "9b64ca5b7e1e3583978f9ac8af6d93b220a13d90", "filename": "src/llvm-project", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm-project?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -1 +1 @@\n-Subproject commit f6446fa8e9629ffb1861303f17930c3aa83ef660\n+Subproject commit 9b64ca5b7e1e3583978f9ac8af6d93b220a13d90"}, {"sha": "b3614bfd5b6e5a08a7878cdc4ea980f88abe429f", "filename": "src/test/ui/core-run-destroy.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcore-run-destroy.rs?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -8,6 +8,7 @@\n // ignore-cloudabi no processes\n // ignore-emscripten no processes\n // ignore-sgx no processes\n+// ignore-vxworks no 'cat' and 'sleep'\n \n // N.B., these tests kill child processes. Valgrind sees these children as leaking\n // memory, which makes for some *confusing* logs. That's why these are here"}, {"sha": "092cb31f97d5bba93313458a1dbda32a65c72000", "filename": "src/test/ui/existential-type/issue-60371.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Fexistential-type%2Fissue-60371.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Fexistential-type%2Fissue-60371.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential-type%2Fissue-60371.stderr?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -4,7 +4,7 @@ error[E0658]: existential types are unstable\n LL |     existential type Item: Bug;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/34511\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/63063\n    = help: add `#![feature(existential_type)]` to the crate attributes to enable\n \n error[E0277]: the trait bound `(): Bug` is not satisfied"}, {"sha": "4f56aa7234464f18ec6ad6da441baf004f1a2e17", "filename": "src/test/ui/feature-gates/feature-gate-asm2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm2.rs?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -1,4 +1,3 @@\n-// gate-test-asm\n // ignore-emscripten\n \n fn main() {"}, {"sha": "7519cad9a96ad770b2a2e0bb515618396edadff4", "filename": "src/test/ui/feature-gates/feature-gate-asm2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm2.stderr?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: use of unstable library feature 'asm': inline assembly is not stable enough for use and is subject to change\n-  --> $DIR/feature-gate-asm2.rs:6:26\n+  --> $DIR/feature-gate-asm2.rs:5:26\n    |\n LL |         println!(\"{:?}\", asm!(\"\"));\n    |                          ^^^"}, {"sha": "9660ffeafa5188e9531b10a3fe6daaafb315488f", "filename": "src/test/ui/feature-gates/feature-gate-concat_idents2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-concat_idents2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-concat_idents2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-concat_idents2.rs?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -1,5 +1,3 @@\n-// gate-test-concat_idents\n-\n fn main() {\n     concat_idents!(a, b); //~ ERROR `concat_idents` is not stable enough\n                           //~| ERROR cannot find value `ab` in this scope"}, {"sha": "14519622c05ad263a80198e3fd8f36363e6ab9d5", "filename": "src/test/ui/feature-gates/feature-gate-concat_idents2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-concat_idents2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-concat_idents2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-concat_idents2.stderr?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: use of unstable library feature 'concat_idents': `concat_idents` is not stable enough for use and is subject to change\n-  --> $DIR/feature-gate-concat_idents2.rs:4:5\n+  --> $DIR/feature-gate-concat_idents2.rs:2:5\n    |\n LL |     concat_idents!(a, b);\n    |     ^^^^^^^^^^^^^\n@@ -8,7 +8,7 @@ LL |     concat_idents!(a, b);\n    = help: add `#![feature(concat_idents)]` to the crate attributes to enable\n \n error[E0425]: cannot find value `ab` in this scope\n-  --> $DIR/feature-gate-concat_idents2.rs:4:5\n+  --> $DIR/feature-gate-concat_idents2.rs:2:5\n    |\n LL |     concat_idents!(a, b);\n    |     ^^^^^^^^^^^^^^^^^^^^^ not found in this scope"}, {"sha": "81710fd9fb041cea9006d91dcf3000095a38279d", "filename": "src/test/ui/feature-gates/feature-gate-concat_idents3.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-concat_idents3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-concat_idents3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-concat_idents3.rs?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -1,5 +1,3 @@\n-// gate-test-concat_idents\n-\n const XY_1: i32 = 10;\n \n fn main() {"}, {"sha": "afe6acb25359435895336b275840f7e328f911a8", "filename": "src/test/ui/feature-gates/feature-gate-concat_idents3.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-concat_idents3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-concat_idents3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-concat_idents3.stderr?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: use of unstable library feature 'concat_idents': `concat_idents` is not stable enough for use and is subject to change\n-  --> $DIR/feature-gate-concat_idents3.rs:7:20\n+  --> $DIR/feature-gate-concat_idents3.rs:5:20\n    |\n LL |     assert_eq!(10, concat_idents!(X, Y_1));\n    |                    ^^^^^^^^^^^^^\n@@ -8,7 +8,7 @@ LL |     assert_eq!(10, concat_idents!(X, Y_1));\n    = help: add `#![feature(concat_idents)]` to the crate attributes to enable\n \n error[E0658]: use of unstable library feature 'concat_idents': `concat_idents` is not stable enough for use and is subject to change\n-  --> $DIR/feature-gate-concat_idents3.rs:8:20\n+  --> $DIR/feature-gate-concat_idents3.rs:6:20\n    |\n LL |     assert_eq!(20, concat_idents!(X, Y_2));\n    |                    ^^^^^^^^^^^^^"}, {"sha": "30e25e55aff12ecb07ac19d16a2f9122146a1bcd", "filename": "src/test/ui/feature-gates/feature-gate-existential-type.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-existential-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-existential-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-existential-type.stderr?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -4,7 +4,7 @@ error[E0658]: existential types are unstable\n LL | existential type Foo: std::fmt::Debug;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/34511\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/63063\n    = help: add `#![feature(existential_type)]` to the crate attributes to enable\n \n error[E0658]: existential types are unstable\n@@ -13,7 +13,7 @@ error[E0658]: existential types are unstable\n LL |     existential type Baa: std::fmt::Debug;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/34511\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/63063\n    = help: add `#![feature(existential_type)]` to the crate attributes to enable\n \n error: aborting due to 2 previous errors"}, {"sha": "db1a96f1f23eaecd8b1ff42432b7c1d81db4511b", "filename": "src/test/ui/feature-gates/feature-gate-log_syntax2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-log_syntax2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-log_syntax2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-log_syntax2.rs?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -1,5 +1,3 @@\n-// gate-test-log_syntax\n-\n fn main() {\n     println!(\"{:?}\", log_syntax!()); //~ ERROR `log_syntax!` is not stable\n }"}, {"sha": "81daee0b49f34e434db41de432d6f27c20b03bfc", "filename": "src/test/ui/feature-gates/feature-gate-log_syntax2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-log_syntax2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-log_syntax2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-log_syntax2.stderr?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: use of unstable library feature 'log_syntax': `log_syntax!` is not stable enough for use and is subject to change\n-  --> $DIR/feature-gate-log_syntax2.rs:4:22\n+  --> $DIR/feature-gate-log_syntax2.rs:2:22\n    |\n LL |     println!(\"{:?}\", log_syntax!());\n    |                      ^^^^^^^^^^"}, {"sha": "36303440ee9d0277bae2f4417678f020d7170b70", "filename": "src/test/ui/process/process-sigpipe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Fprocess%2Fprocess-sigpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Fprocess%2Fprocess-sigpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprocess%2Fprocess-sigpipe.rs?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -14,6 +14,7 @@\n \n // ignore-cloudabi no subprocesses support\n // ignore-emscripten no threads support\n+// ignore-vxworks no 'sh'\n \n use std::process;\n use std::thread;"}, {"sha": "08b16c0e9ca3e144fb766eb4978b60784910c20f", "filename": "src/test/ui/wait-forked-but-failed-child.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Fwait-forked-but-failed-child.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Fwait-forked-but-failed-child.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwait-forked-but-failed-child.rs?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -2,6 +2,7 @@\n // ignore-cloudabi no processes\n // ignore-emscripten no processes\n // ignore-sgx no processes\n+// ignore-vxworks no 'ps'\n \n #![feature(rustc_private)]\n "}, {"sha": "32a4df87fbe1215ee588869aed38e3a04e869c3a", "filename": "src/test/ui/x86stdcall.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Fx86stdcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b94e9e9188b65df38a5f1ae723617dc2dfb3155/src%2Ftest%2Fui%2Fx86stdcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fx86stdcall.rs?ref=8b94e9e9188b65df38a5f1ae723617dc2dfb3155", "patch": "@@ -32,5 +32,6 @@ pub fn main() {\n           target_os = \"macos\",\n           target_os = \"netbsd\",\n           target_os = \"openbsd\",\n+          target_os = \"vxworks\",\n           target_os = \"solaris\"))]\n pub fn main() { }"}]}