{"sha": "f813f519a5cecfd988cf238277021662afaff34a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4MTNmNTE5YTVjZWNmZDk4OGNmMjM4Mjc3MDIxNjYyYWZhZmYzNGE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-25T19:13:20Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-25T19:13:20Z"}, "message": "rt: Remove the cycle collector", "tree": {"sha": "ee4a83ac7db42b86dd1d1530e8d339651762f727", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee4a83ac7db42b86dd1d1530e8d339651762f727"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f813f519a5cecfd988cf238277021662afaff34a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f813f519a5cecfd988cf238277021662afaff34a", "html_url": "https://github.com/rust-lang/rust/commit/f813f519a5cecfd988cf238277021662afaff34a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f813f519a5cecfd988cf238277021662afaff34a/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac822a52be47579ffa59d5ca3e125680a79545d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac822a52be47579ffa59d5ca3e125680a79545d0", "html_url": "https://github.com/rust-lang/rust/commit/ac822a52be47579ffa59d5ca3e125680a79545d0"}], "stats": {"total": 610, "additions": 0, "deletions": 610}, "files": [{"sha": "2304bcbf9d2f99c554fc6562562655f068004a83", "filename": "mk/rt.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f813f519a5cecfd988cf238277021662afaff34a/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f813f519a5cecfd988cf238277021662afaff34a/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=f813f519a5cecfd988cf238277021662afaff34a", "patch": "@@ -71,7 +71,6 @@ RUNTIME_CS_$(1) := \\\n               rt/rust_kernel.cpp \\\n               rt/rust_shape.cpp \\\n               rt/rust_abi.cpp \\\n-              rt/rust_cc.cpp \\\n               rt/rust_debug.cpp \\\n               rt/rust_box_annihilator.cpp \\\n               rt/memory_region.cpp \\"}, {"sha": "0106b468c907b44d9fd7b68d4881245791df4a71", "filename": "src/rt/rust_cc.cpp", "status": "removed", "additions": 0, "deletions": 572, "changes": 572, "blob_url": "https://github.com/rust-lang/rust/blob/ac822a52be47579ffa59d5ca3e125680a79545d0/src%2Frt%2Frust_cc.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ac822a52be47579ffa59d5ca3e125680a79545d0/src%2Frt%2Frust_cc.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_cc.cpp?ref=ac822a52be47579ffa59d5ca3e125680a79545d0", "patch": "@@ -1,572 +0,0 @@\n-// Rust cycle collector. Temporary, but will probably stick around for some\n-// time until LLVM's GC infrastructure is more mature.\n-\n-#include <map>\n-#include <set>\n-#include <vector>\n-#include <ios>\n-\n-#include \"rust_globals.h\"\n-#include \"rust_cc.h\"\n-#include \"rust_debug.h\"\n-#include \"rust_shape.h\"\n-#include \"rust_task.h\"\n-\n-// The number of allocations Rust code performs before performing cycle\n-// collection.\n-#define RUST_CC_FREQUENCY   5000\n-\n-using namespace std;\n-\n-void\n-annihilate_box(rust_task *task, rust_opaque_box *box);\n-\n-namespace cc {\n-\n-// Internal reference count computation\n-\n-typedef std::map<rust_opaque_box*,uintptr_t> irc_map;\n-\n-class irc : public shape::data<irc,shape::ptr> {\n-    friend class shape::data<irc,shape::ptr>;\n-\n-    irc_map &ircs;\n-\n-    irc(const irc &other, const shape::ptr &in_dp)\n-    : shape::data<irc,shape::ptr>(other.task, other.align, other.sp,\n-                                  other.tables, in_dp),\n-      ircs(other.ircs) {}\n-\n-    irc(const irc &other,\n-        const uint8_t *in_sp,\n-        const rust_shape_tables *in_tables = NULL)\n-    : shape::data<irc,shape::ptr>(other.task,\n-                                  other.align,\n-                                  in_sp,\n-                                  in_tables ? in_tables : other.tables,\n-                                  other.dp),\n-      ircs(other.ircs) {}\n-\n-    irc(const irc &other,\n-        const uint8_t *in_sp,\n-        const rust_shape_tables *in_tables,\n-        shape::ptr in_dp)\n-    : shape::data<irc,shape::ptr>(other.task,\n-                                  other.align,\n-                                  in_sp,\n-                                  in_tables,\n-                                  in_dp),\n-      ircs(other.ircs) {}\n-\n-    irc(rust_task *in_task,\n-        bool in_align,\n-        const uint8_t *in_sp,\n-        const rust_shape_tables *in_tables,\n-        uint8_t *in_data,\n-        irc_map &in_ircs)\n-        : shape::data<irc,shape::ptr>(in_task, in_align, in_sp,\n-                                      in_tables, shape::ptr(in_data)),\n-          ircs(in_ircs) {}\n-\n-\n-    void walk_vec2(bool is_pod, std::pair<uint8_t *,uint8_t *> data_range) {\n-\n-        // There can't be any outbound pointers from pod.\n-        if (is_pod)\n-            return;\n-\n-        irc sub(*this, shape::ptr(data_range.first));\n-        shape::ptr data_end = sub.end_dp = shape::ptr(data_range.second);\n-        while (sub.dp < data_end) {\n-            sub.walk_reset();\n-            // FIXME (#2669): shouldn't this be 'sub.align = true;'?\n-            align = true;\n-        }\n-    }\n-\n-    void walk_vec2(bool is_pod) {\n-        if (shape::get_dp<void *>(dp) == NULL)\n-            return;\n-\n-        walk_vec2(is_pod, get_vec_data_range(dp));\n-    }\n-\n-    void walk_unboxed_vec2(bool is_pod) {\n-        walk_vec2(is_pod, get_unboxed_vec_data_range(dp));\n-    }\n-\n-    void walk_slice2(bool is_pod, bool is_str) {\n-        walk_vec2(is_pod, get_slice_data_range(is_str, dp));\n-    }\n-\n-    void walk_fixedvec2(uint16_t n_elts, size_t elt_sz, bool is_pod) {\n-        walk_vec2(is_pod, get_fixedvec_data_range(n_elts, elt_sz, dp));\n-    }\n-\n-    void walk_tag2(shape::tag_info &tinfo, uint32_t tag_variant) {\n-        shape::data<irc,shape::ptr>::walk_variant1(tinfo, tag_variant);\n-    }\n-\n-    void walk_box2() {\n-        // the box ptr can be NULL for env ptrs in closures and data\n-        // not fully initialized\n-        rust_opaque_box *box = *(rust_opaque_box**)dp;\n-        if (box)\n-            shape::data<irc,shape::ptr>::walk_box_contents1();\n-    }\n-\n-    void walk_uniq2() {\n-        rust_opaque_box *box = *(rust_opaque_box**)dp;\n-        if (box)\n-            shape::data<irc,shape::ptr>::walk_uniq_contents1();\n-    }\n-\n-    void walk_rptr2() {\n-        shape::data<irc,shape::ptr>::walk_rptr_contents1();\n-    }\n-\n-    void walk_fn2(char code) {\n-        switch (code) {\n-          case shape::SHAPE_BOX_FN: {\n-              shape::bump_dp<void*>(dp); // skip over the code ptr\n-              walk_box2();               // walk over the environment ptr\n-              break;\n-          }\n-          case shape::SHAPE_BARE_FN:        // Does not close over data.\n-          case shape::SHAPE_STACK_FN:       // Not reachable from heap.\n-          case shape::SHAPE_UNIQ_FN: break; /* Can only close over sendable\n-                                             * (and hence acyclic) data */\n-          default: abort();\n-        }\n-    }\n-\n-    void walk_trait2() {\n-        walk_box2();\n-    }\n-\n-    void walk_tydesc2(char) {\n-    }\n-\n-    void walk_res2(const shape::rust_fn *dtor, const uint8_t *end_sp) {\n-        while (this->sp != end_sp) {\n-            this->walk();\n-            align = true;\n-        }\n-    }\n-\n-    void walk_subcontext2(irc &sub) { sub.walk(); }\n-\n-    void walk_uniq_contents2(irc &sub) { sub.walk(); }\n-\n-    void walk_rptr_contents2(irc &sub) { sub.walk(); }\n-\n-    void walk_box_contents2(irc &sub) {\n-        maybe_record_irc();\n-\n-        // Do not traverse the contents of this box; it's in the allocation\n-        // somewhere, so we're guaranteed to come back to it (if we haven't\n-        // traversed it already).\n-    }\n-\n-    void maybe_record_irc() {\n-        rust_opaque_box *box_ptr = *(rust_opaque_box **) dp;\n-\n-        if (!box_ptr)\n-            return;\n-\n-        // Bump the internal reference count of the box.\n-        if (ircs.find(box_ptr) == ircs.end()) {\n-          LOG(task, gc,\n-              \"setting internal reference count for %p to 1\",\n-              box_ptr);\n-          ircs[box_ptr] = 1;\n-        } else {\n-          uintptr_t newcount = ircs[box_ptr] + 1;\n-          LOG(task, gc,\n-              \"bumping internal reference count for %p to %lu\",\n-              box_ptr, newcount);\n-          ircs[box_ptr] = newcount;\n-        }\n-    }\n-\n-    void walk_struct2(const uint8_t *end_sp) {\n-        while (this->sp != end_sp) {\n-            this->walk();\n-            align = true;\n-        }\n-    }\n-\n-    void walk_variant2(shape::tag_info &tinfo, uint32_t variant_id,\n-                      const std::pair<const uint8_t *,const uint8_t *>\n-                      variant_ptr_and_end);\n-\n-    template<typename T>\n-    inline void walk_number2() { /* no-op */ }\n-\n-public:\n-    static void compute_ircs(rust_task *task, irc_map &ircs);\n-};\n-\n-void\n-irc::walk_variant2(shape::tag_info &tinfo, uint32_t variant_id,\n-                   const std::pair<const uint8_t *,const uint8_t *>\n-                   variant_ptr_and_end) {\n-    irc sub(*this, variant_ptr_and_end.first);\n-\n-    assert(variant_id < 256);   // FIXME (#2666): Temporary sanity check.\n-\n-    const uint8_t *variant_end = variant_ptr_and_end.second;\n-    while (sub.sp < variant_end) {\n-        sub.walk();\n-        align = true;\n-    }\n-}\n-\n-void\n-irc::compute_ircs(rust_task *task, irc_map &ircs) {\n-    boxed_region *boxed = &task->boxed;\n-    for (rust_opaque_box *box = boxed->first_live_alloc();\n-         box != NULL;\n-         box = box->next) {\n-        type_desc *tydesc = box->td;\n-        uint8_t *body = (uint8_t*) box_body(box);\n-\n-        LOG(task, gc,\n-            \"determining internal ref counts: \"\n-            \"box=%p tydesc=%p body=%p\",\n-            box, tydesc, body);\n-\n-        shape::arena arena;\n-\n-        irc irc(task, true, tydesc->shape, tydesc->shape_tables,\n-                body, ircs);\n-        irc.walk();\n-    }\n-}\n-\n-\n-// Root finding\n-\n-void\n-find_roots(rust_task *task, irc_map &ircs,\n-           std::vector<rust_opaque_box *> &roots) {\n-    boxed_region *boxed = &task->boxed;\n-    for (rust_opaque_box *box = boxed->first_live_alloc();\n-         box != NULL;\n-         box = box->next) {\n-        uintptr_t ref_count = box->ref_count;\n-\n-        uintptr_t irc;\n-        if (ircs.find(box) != ircs.end())\n-            irc = ircs[box];\n-        else\n-            irc = 0;\n-\n-        if (irc < ref_count) {\n-            // This allocation must be a root, because the internal reference\n-            // count is smaller than the total reference count.\n-            LOG(task, gc,\"root found: %p, irc %lu, ref count %lu\",\n-                box, irc, ref_count);\n-            roots.push_back(box);\n-        } else {\n-            LOG(task, gc, \"nonroot found: %p, irc %lu, ref count %lu\",\n-                box, irc, ref_count);\n-            assert(irc == ref_count && \"Internal reference count must be \"\n-                   \"less than or equal to the total reference count!\");\n-        }\n-    }\n-}\n-\n-\n-// Marking\n-\n-class mark : public shape::data<mark,shape::ptr> {\n-    friend class shape::data<mark,shape::ptr>;\n-\n-    std::set<rust_opaque_box *> &marked;\n-\n-    mark(const mark &other, const shape::ptr &in_dp)\n-    : shape::data<mark,shape::ptr>(other.task, other.align, other.sp,\n-                                    other.tables, in_dp),\n-      marked(other.marked) {}\n-\n-    mark(const mark &other,\n-         const uint8_t *in_sp,\n-         const rust_shape_tables *in_tables = NULL)\n-    : shape::data<mark,shape::ptr>(other.task,\n-                                   other.align,\n-                                   in_sp,\n-                                   in_tables ? in_tables : other.tables,\n-                                   other.dp),\n-      marked(other.marked) {}\n-\n-    mark(const mark &other,\n-         const uint8_t *in_sp,\n-         const rust_shape_tables *in_tables,\n-         shape::ptr in_dp)\n-    : shape::data<mark,shape::ptr>(other.task,\n-                                   other.align,\n-                                   in_sp,\n-                                   in_tables,\n-                                   in_dp),\n-      marked(other.marked) {}\n-\n-    mark(rust_task *in_task,\n-         bool in_align,\n-         const uint8_t *in_sp,\n-         const rust_shape_tables *in_tables,\n-         uint8_t *in_data,\n-         std::set<rust_opaque_box*> &in_marked)\n-        : shape::data<mark,shape::ptr>(in_task, in_align, in_sp,\n-                                       in_tables, shape::ptr(in_data)),\n-      marked(in_marked) {}\n-\n-    void walk_vec2(bool is_pod, std::pair<uint8_t *,uint8_t *> data_range) {\n-\n-        // There can't be any outbound pointers from pod.\n-        if (is_pod)\n-            return;\n-\n-        if (data_range.second - data_range.first > 100000)\n-            abort();    // FIXME (#2666): Temporary sanity check.\n-\n-        mark sub(*this, shape::ptr(data_range.first));\n-        shape::ptr data_end = sub.end_dp = shape::ptr(data_range.second);\n-        while (sub.dp < data_end) {\n-            sub.walk_reset();\n-            align = true;\n-        }\n-    }\n-\n-    void walk_vec2(bool is_pod) {\n-        if (shape::get_dp<void *>(dp) == NULL)\n-            return;\n-        walk_vec2(is_pod, get_vec_data_range(dp));\n-    }\n-\n-    void walk_unboxed_vec2(bool is_pod) {\n-        walk_vec2(is_pod, get_unboxed_vec_data_range(dp));\n-    }\n-\n-    void walk_slice2(bool is_pod, bool is_str) {\n-        walk_vec2(is_pod, get_slice_data_range(is_str, dp));\n-    }\n-\n-    void walk_fixedvec2(uint16_t n_elts, size_t elt_sz, bool is_pod) {\n-        walk_vec2(is_pod, get_fixedvec_data_range(n_elts, elt_sz, dp));\n-    }\n-\n-    void walk_tag2(shape::tag_info &tinfo, uint32_t tag_variant) {\n-        shape::data<mark,shape::ptr>::walk_variant1(tinfo, tag_variant);\n-    }\n-\n-    void walk_box2() {\n-        // the box ptr can be NULL for env ptrs in closures and data\n-        // not fully initialized\n-        rust_opaque_box *box = *(rust_opaque_box**)dp;\n-        if (box)\n-            shape::data<mark,shape::ptr>::walk_box_contents1();\n-    }\n-\n-    void walk_uniq2() {\n-        rust_opaque_box *box = *(rust_opaque_box**)dp;\n-        if (box)\n-            shape::data<mark,shape::ptr>::walk_uniq_contents1();\n-    }\n-\n-    void walk_rptr2() {\n-        shape::data<mark,shape::ptr>::walk_rptr_contents1();\n-    }\n-\n-    void walk_fn2(char code) {\n-        switch (code) {\n-          case shape::SHAPE_BOX_FN: {\n-              shape::bump_dp<void*>(dp); // skip over the code ptr\n-              walk_box2();               // walk over the environment ptr\n-              break;\n-          }\n-          case shape::SHAPE_BARE_FN:        // Does not close over data.\n-          case shape::SHAPE_STACK_FN:       // Not reachable from heap.\n-          case shape::SHAPE_UNIQ_FN: break; /* Can only close over sendable\n-                                             * (and hence acyclic) data */\n-          default: abort();\n-        }\n-    }\n-\n-    void walk_res2(const shape::rust_fn *dtor, const uint8_t *end_sp) {\n-        while (this->sp != end_sp) {\n-            this->walk();\n-            align = true;\n-        }\n-    }\n-\n-    void walk_trait2() {\n-        walk_box2();\n-    }\n-\n-    void walk_tydesc2(char) {\n-    }\n-\n-    void walk_subcontext2(mark &sub) { sub.walk(); }\n-\n-    void walk_uniq_contents2(mark &sub) { sub.walk(); }\n-\n-    void walk_rptr_contents2(mark &sub) { sub.walk(); }\n-\n-    void walk_box_contents2(mark &sub) {\n-        rust_opaque_box *box_ptr = *(rust_opaque_box **) dp;\n-\n-        if (!box_ptr)\n-            return;\n-\n-        if (marked.find(box_ptr) != marked.end())\n-            return; // Skip to avoid chasing cycles.\n-\n-        marked.insert(box_ptr);\n-        sub.walk();\n-    }\n-\n-    void walk_struct2(const uint8_t *end_sp) {\n-        while (this->sp != end_sp) {\n-            this->walk();\n-            align = true;\n-        }\n-    }\n-\n-    void walk_variant2(shape::tag_info &tinfo, uint32_t variant_id,\n-                      const std::pair<const uint8_t *,const uint8_t *>\n-                      variant_ptr_and_end);\n-\n-    template<typename T>\n-    inline void walk_number2() { /* no-op */ }\n-\n-public:\n-    static void do_mark(rust_task *task,\n-                        const std::vector<rust_opaque_box *> &roots,\n-                        std::set<rust_opaque_box*> &marked);\n-};\n-\n-void\n-mark::walk_variant2(shape::tag_info &tinfo, uint32_t variant_id,\n-                   const std::pair<const uint8_t *,const uint8_t *>\n-                   variant_ptr_and_end) {\n-    mark sub(*this, variant_ptr_and_end.first);\n-\n-    assert(variant_id < 256);   // FIXME (#2666): Temporary sanity check.\n-\n-    const uint8_t *variant_end = variant_ptr_and_end.second;\n-    while (sub.sp < variant_end) {\n-        sub.walk();\n-        align = true;\n-    }\n-}\n-\n-void\n-mark::do_mark(rust_task *task,\n-              const std::vector<rust_opaque_box *> &roots,\n-              std::set<rust_opaque_box *> &marked) {\n-    std::vector<rust_opaque_box *>::const_iterator\n-      begin(roots.begin()),\n-      end(roots.end());\n-    while (begin != end) {\n-        rust_opaque_box *box = *begin;\n-        if (marked.find(box) == marked.end()) {\n-            marked.insert(box);\n-\n-            const type_desc *tydesc = box->td;\n-\n-            LOG(task, gc, \"marking: %p, tydesc=%p\", box, tydesc);\n-\n-            uint8_t *p = (uint8_t*) box_body(box);\n-            shape::arena arena;\n-\n-            mark mark(task, true, tydesc->shape, tydesc->shape_tables,\n-                      p, marked);\n-            mark.walk();\n-        }\n-\n-        ++begin;\n-    }\n-}\n-\n-void\n-do_sweep(rust_task *task,\n-         const std::set<rust_opaque_box*> &marked) {\n-    boxed_region *boxed = &task->boxed;\n-    rust_opaque_box *box = boxed->first_live_alloc();\n-    while (box != NULL) {\n-        // save next ptr as we may be freeing box\n-        rust_opaque_box *box_next = box->next;\n-        if (marked.find(box) == marked.end()) {\n-            LOG(task, gc, \"object is part of a cycle: %p\", box);\n-            annihilate_box(task, box);\n-        }\n-        box = box_next;\n-    }\n-}\n-\n-\n-void\n-do_cc(rust_task *task) {\n-    LOG(task, gc, \"cc\");\n-\n-    irc_map ircs;\n-    irc::compute_ircs(task, ircs);\n-\n-    std::vector<rust_opaque_box*> roots;\n-    find_roots(task, ircs, roots);\n-\n-    std::set<rust_opaque_box*> marked;\n-    mark::do_mark(task, roots, marked);\n-\n-    do_sweep(task, marked);\n-}\n-\n-void\n-do_final_cc(rust_task *task) {\n-    do_cc(task);\n-\n-    boxed_region *boxed = &task->boxed;\n-    for (rust_opaque_box *box = boxed->first_live_alloc();\n-         box != NULL;\n-         box = box->next) {\n-        cerr << \"Unreclaimed object found at \" << (void*) box << \": \";\n-        const type_desc *td = box->td;\n-        shape::arena arena;\n-        shape::log log(task, true, td->shape, td->shape_tables,\n-                       (uint8_t*)box_body(box), cerr);\n-        log.walk();\n-        cerr << \"\\n\";\n-    }\n-}\n-\n-void\n-maybe_cc(rust_task *task) {\n-    static debug::flag zeal(\"RUST_CC_ZEAL\");\n-    if (*zeal) {\n-        do_cc(task);\n-        return;\n-    }\n-\n-    // FIXME (#1498): depressingly, due to alignment bugs the whole file is\n-    // disabled presently unless you're doing testing. Remove the whole thing\n-    // when we transition to using a visitor for GC/CC.\n-#if 0\n-    if (task->cc_counter++ > RUST_CC_FREQUENCY) {\n-        task->cc_counter = 0;\n-        do_cc(task);\n-    }\n-#endif\n-}\n-\n-}   // end namespace cc\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "70c3a07d019114b15fb47cde8f97c9e1acfb0ca4", "filename": "src/rt/rust_cc.h", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ac822a52be47579ffa59d5ca3e125680a79545d0/src%2Frt%2Frust_cc.h", "raw_url": "https://github.com/rust-lang/rust/raw/ac822a52be47579ffa59d5ca3e125680a79545d0/src%2Frt%2Frust_cc.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_cc.h?ref=ac822a52be47579ffa59d5ca3e125680a79545d0", "patch": "@@ -1,30 +0,0 @@\n-// Rust cycle collector. Temporary, but will probably stick around for some\n-// time until LLVM's GC infrastructure is more mature.\n-\n-#ifndef RUST_CC_H\n-#define RUST_CC_H\n-\n-struct rust_task;\n-\n-namespace cc {\n-\n-void do_cc(rust_task *task);\n-\n-// performs a cycle coll then asserts that there is nothing left\n-void do_final_cc(rust_task *task);\n-\n-void maybe_cc(rust_task *task);\n-\n-}   // end namespace cc\n-\n-#endif\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "2f275bb3222001eb236721c0183d754f5b8fc94d", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f813f519a5cecfd988cf238277021662afaff34a/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f813f519a5cecfd988cf238277021662afaff34a/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=f813f519a5cecfd988cf238277021662afaff34a", "patch": "@@ -6,7 +6,6 @@\n #include <algorithm>\n \n #include \"rust_task.h\"\n-#include \"rust_cc.h\"\n #include \"rust_env.h\"\n #include \"rust_port.h\"\n #include \"rust_globals.h\"\n@@ -28,7 +27,6 @@ rust_task::rust_task(rust_sched_loop *sched_loop, rust_task_state state,\n     boxed(sched_loop->kernel->env, &local_region),\n     local_region(&sched_loop->local_region),\n     unwinding(false),\n-    cc_counter(0),\n     total_stack_sz(0),\n     task_local_data(NULL),\n     task_local_data_cleanup(NULL),"}, {"sha": "e71e1b3707a85d4cc5825d8acbf58b869dad62bd", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f813f519a5cecfd988cf238277021662afaff34a/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/f813f519a5cecfd988cf238277021662afaff34a/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=f813f519a5cecfd988cf238277021662afaff34a", "patch": "@@ -223,8 +223,6 @@ rust_task : public kernel_owned<rust_task>\n \n     bool propagate_failure;\n \n-    uint32_t cc_counter;\n-\n     debug::task_debug_info debug;\n \n     // The amount of stack we're using, excluding red zones"}, {"sha": "58887a3afe9fdb635d152a55bce10ae089e33643", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f813f519a5cecfd988cf238277021662afaff34a/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f813f519a5cecfd988cf238277021662afaff34a/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=f813f519a5cecfd988cf238277021662afaff34a", "patch": "@@ -8,7 +8,6 @@\n \n #include \"rust_globals.h\"\n #include \"rust_task.h\"\n-#include \"rust_cc.h\"\n #include \"rust_sched_loop.h\"\n #include \"rust_unwind.h\"\n #include \"rust_upcall.h\"\n@@ -225,8 +224,6 @@ upcall_s_malloc(s_malloc_args *args) {\n     LOG_UPCALL_ENTRY(task);\n     LOG(task, mem, \"upcall malloc(0x%\" PRIxPTR \")\", args->td);\n \n-    cc::maybe_cc(task);\n-\n     // FIXME--does this have to be calloc? (Issue #2682)\n     rust_opaque_box *box = task->boxed.calloc(args->td, args->size);\n     void *body = box_body(box);"}]}