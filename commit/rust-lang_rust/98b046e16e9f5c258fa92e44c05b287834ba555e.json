{"sha": "98b046e16e9f5c258fa92e44c05b287834ba555e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4YjA0NmUxNmU5ZjVjMjU4ZmE5MmU0NGMwNWIyODc4MzRiYTU1NWU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-17T23:56:13Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-19T00:23:29Z"}, "message": "Various straight-forward ports that override `visit_nested_items`\nto do \"in-situ\" visits.", "tree": {"sha": "7b09387867114adb3ab6e3816d850481c35c98f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b09387867114adb3ab6e3816d850481c35c98f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98b046e16e9f5c258fa92e44c05b287834ba555e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98b046e16e9f5c258fa92e44c05b287834ba555e", "html_url": "https://github.com/rust-lang/rust/commit/98b046e16e9f5c258fa92e44c05b287834ba555e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98b046e16e9f5c258fa92e44c05b287834ba555e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac38021da14cb22f95e63b41dea2d5f1967f34d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac38021da14cb22f95e63b41dea2d5f1967f34d6", "html_url": "https://github.com/rust-lang/rust/commit/ac38021da14cb22f95e63b41dea2d5f1967f34d6"}], "stats": {"total": 391, "additions": 229, "deletions": 162}, "files": [{"sha": "798f4866d346c8edac3b82bff5c3e49f5b38f22e", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98b046e16e9f5c258fa92e44c05b287834ba555e/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98b046e16e9f5c258fa92e44c05b287834ba555e/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=98b046e16e9f5c258fa92e44c05b287834ba555e", "patch": "@@ -44,7 +44,7 @@ use syntax::parse::token::InternedString;\n use syntax::ast;\n use rustc_front::hir;\n use rustc_front::util;\n-use rustc_front::visit as hir_visit;\n+use rustc_front::intravisit as hir_visit;\n use syntax::visit as ast_visit;\n use syntax::diagnostic;\n \n@@ -606,10 +606,12 @@ impl<'a, 'tcx> LintContext for LateContext<'a, 'tcx> {\n     }\n \n     fn enter_attrs(&mut self, attrs: &[ast::Attribute]) {\n+        debug!(\"late context: enter_attrs({:?})\", attrs);\n         run_lints!(self, enter_lint_attrs, late_passes, attrs);\n     }\n \n     fn exit_attrs(&mut self, attrs: &[ast::Attribute]) {\n+        debug!(\"late context: exit_attrs({:?})\", attrs);\n         run_lints!(self, exit_lint_attrs, late_passes, attrs);\n     }\n }\n@@ -633,15 +635,24 @@ impl<'a> LintContext for EarlyContext<'a> {\n     }\n \n     fn enter_attrs(&mut self, attrs: &[ast::Attribute]) {\n+        debug!(\"early context: exit_attrs({:?})\", attrs);\n         run_lints!(self, enter_lint_attrs, early_passes, attrs);\n     }\n \n     fn exit_attrs(&mut self, attrs: &[ast::Attribute]) {\n+        debug!(\"early context: exit_attrs({:?})\", attrs);\n         run_lints!(self, exit_lint_attrs, early_passes, attrs);\n     }\n }\n \n impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n+    /// Because lints are scoped lexically, we want to walk nested\n+    /// items in the context of the outer item, so enable\n+    /// deep-walking.\n+    fn visit_nested_item(&mut self, item: hir::ItemId) {\n+        self.visit_item(self.tcx.map.expect_item(item.id))\n+    }\n+\n     fn visit_item(&mut self, it: &hir::Item) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_item, late_passes, it);\n@@ -947,6 +958,7 @@ impl<'a, 'tcx> IdVisitingOperation for LateContext<'a, 'tcx> {\n         match self.sess().lints.borrow_mut().remove(&id) {\n             None => {}\n             Some(lints) => {\n+                debug!(\"LateContext::visit_id: id={:?} lints={:?}\", id, lints);\n                 for (lint_id, span, msg) in lints {\n                     self.span_lint(lint_id.lint, span, &msg[..])\n                 }\n@@ -1003,16 +1015,14 @@ impl LateLintPass for GatherNodeLevels {\n ///\n /// Consumes the `lint_store` field of the `Session`.\n pub fn check_crate(tcx: &ty::ctxt,\n-                   krate: &hir::Crate,\n                    exported_items: &ExportedItems) {\n-\n+    let krate = tcx.map.krate();\n     let mut cx = LateContext::new(tcx, krate, exported_items);\n \n     // Visit the whole crate.\n     cx.with_lint_attrs(&krate.attrs, |cx| {\n         cx.visit_id(ast::CRATE_NODE_ID);\n         cx.visit_ids(|v| {\n-            v.visited_outermost = true;\n             hir_visit::walk_crate(v, krate);\n         });\n "}, {"sha": "23be6117f190f51376c31aee808d994756fd9c93", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98b046e16e9f5c258fa92e44c05b287834ba555e/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98b046e16e9f5c258fa92e44c05b287834ba555e/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=98b046e16e9f5c258fa92e44c05b287834ba555e", "patch": "@@ -34,7 +34,7 @@ pub use self::LintSource::*;\n use std::hash;\n use std::ascii::AsciiExt;\n use syntax::codemap::Span;\n-use rustc_front::visit::FnKind;\n+use rustc_front::intravisit::FnKind;\n use syntax::visit as ast_visit;\n use syntax::ast;\n use rustc_front::hir;\n@@ -218,7 +218,7 @@ pub type EarlyLintPassObject = Box<EarlyLintPass + 'static>;\n pub type LateLintPassObject = Box<LateLintPass + 'static>;\n \n /// Identifies a lint known to the compiler.\n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, Debug)]\n pub struct LintId {\n     // Identity is based on pointer equality of this field.\n     lint: &'static Lint,"}, {"sha": "6dfddce9bfed89cb4bb5a8fec963c0dab58786f1", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/98b046e16e9f5c258fa92e44c05b287834ba555e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98b046e16e9f5c258fa92e44c05b287834ba555e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=98b046e16e9f5c258fa92e44c05b287834ba555e", "patch": "@@ -14,7 +14,7 @@\n \n use front::map as ast_map;\n use rustc_front::hir;\n-use rustc_front::visit::{self, Visitor};\n+use rustc_front::intravisit::{self, Visitor};\n \n use middle::{def, pat_util, privacy, ty};\n use middle::def_id::{DefId};\n@@ -182,29 +182,29 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                                 .contains(&attr::ReprExtern)\n                         });\n \n-                        visit::walk_item(self, &*item);\n+                        intravisit::walk_item(self, &*item);\n                     }\n                     hir::ItemEnum(..) => {\n                         self.inherited_pub_visibility = item.vis == hir::Public;\n-                        visit::walk_item(self, &*item);\n+                        intravisit::walk_item(self, &*item);\n                     }\n                     hir::ItemFn(..)\n                     | hir::ItemTy(..)\n                     | hir::ItemStatic(..)\n                     | hir::ItemConst(..) => {\n-                        visit::walk_item(self, &*item);\n+                        intravisit::walk_item(self, &*item);\n                     }\n                     _ => ()\n                 }\n             }\n             ast_map::NodeTraitItem(trait_item) => {\n-                visit::walk_trait_item(self, trait_item);\n+                intravisit::walk_trait_item(self, trait_item);\n             }\n             ast_map::NodeImplItem(impl_item) => {\n-                visit::walk_impl_item(self, impl_item);\n+                intravisit::walk_impl_item(self, impl_item);\n             }\n             ast_map::NodeForeignItem(foreign_item) => {\n-                visit::walk_foreign_item(self, &*foreign_item);\n+                intravisit::walk_foreign_item(self, &*foreign_item);\n             }\n             _ => ()\n         }\n@@ -227,7 +227,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n         });\n         self.live_symbols.extend(live_fields.map(|f| f.node.id));\n \n-        visit::walk_struct_def(self, def);\n+        intravisit::walk_struct_def(self, def);\n     }\n \n     fn visit_expr(&mut self, expr: &hir::Expr) {\n@@ -244,7 +244,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n             _ => ()\n         }\n \n-        visit::walk_expr(self, expr);\n+        intravisit::walk_expr(self, expr);\n     }\n \n     fn visit_arm(&mut self, arm: &hir::Arm) {\n@@ -257,10 +257,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n             // can't be reached unless the variant is constructed elsewhere.\n             let len = self.ignore_variant_stack.len();\n             self.ignore_variant_stack.push_all(&*variants);\n-            visit::walk_arm(self, arm);\n+            intravisit::walk_arm(self, arm);\n             self.ignore_variant_stack.truncate(len);\n         } else {\n-            visit::walk_arm(self, arm);\n+            intravisit::walk_arm(self, arm);\n         }\n     }\n \n@@ -278,23 +278,18 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n         }\n \n         self.ignore_non_const_paths = true;\n-        visit::walk_pat(self, pat);\n+        intravisit::walk_pat(self, pat);\n         self.ignore_non_const_paths = false;\n     }\n \n     fn visit_path(&mut self, path: &hir::Path, id: ast::NodeId) {\n         self.lookup_and_handle_definition(&id);\n-        visit::walk_path(self, path);\n+        intravisit::walk_path(self, path);\n     }\n \n     fn visit_path_list_item(&mut self, path: &hir::Path, item: &hir::PathListItem) {\n         self.lookup_and_handle_definition(&item.node.id());\n-        visit::walk_path_list_item(self, path, item);\n-    }\n-\n-    fn visit_item(&mut self, _: &hir::Item) {\n-        // Do not recurse into items. These items will be added to the\n-        // worklist and recursed into manually if necessary.\n+        intravisit::walk_path_list_item(self, path, item);\n     }\n }\n \n@@ -371,7 +366,6 @@ impl<'v> Visitor<'v> for LifeSeeder {\n             }\n             _ => ()\n         }\n-        visit::walk_item(self, item);\n     }\n }\n \n@@ -408,7 +402,7 @@ fn create_and_seed_worklist(tcx: &ty::ctxt,\n     let mut life_seeder = LifeSeeder {\n         worklist: worklist\n     };\n-    visit::walk_crate(&mut life_seeder, krate);\n+    krate.visit_all_items(&mut life_seeder);\n \n     return life_seeder.worklist;\n }\n@@ -530,6 +524,14 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n+    /// Walk nested items in place so that we don't report dead-code\n+    /// on inner functions when the outer function is already getting\n+    /// an error. We could do this also by checking the parents, but\n+    /// this is how the code is setup and it seems harmless enough.\n+    fn visit_nested_item(&mut self, item: hir::ItemId) {\n+        self.visit_item(self.tcx.map.expect_item(item.id))\n+    }\n+\n     fn visit_item(&mut self, item: &hir::Item) {\n         if self.should_warn_about_item(item) {\n             self.warn_dead_code(\n@@ -540,7 +542,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n             );\n         } else {\n             // Only continue if we didn't warn\n-            visit::walk_item(self, item);\n+            intravisit::walk_item(self, item);\n         }\n     }\n \n@@ -549,15 +551,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n             self.warn_dead_code(variant.node.data.id(), variant.span,\n                                 variant.node.name, \"variant\");\n         } else {\n-            visit::walk_variant(self, variant, g, id);\n+            intravisit::walk_variant(self, variant, g, id);\n         }\n     }\n \n     fn visit_foreign_item(&mut self, fi: &hir::ForeignItem) {\n         if !self.symbol_is_live(fi.id, None) {\n             self.warn_dead_code(fi.id, fi.span, fi.name, fi.node.descriptive_variant());\n         }\n-        visit::walk_foreign_item(self, fi);\n+        intravisit::walk_foreign_item(self, fi);\n     }\n \n     fn visit_struct_field(&mut self, field: &hir::StructField) {\n@@ -566,7 +568,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n                                 field.node.name().unwrap(), \"struct field\");\n         }\n \n-        visit::walk_struct_field(self, field);\n+        intravisit::walk_struct_field(self, field);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n@@ -576,14 +578,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n                     self.warn_dead_code(impl_item.id, impl_item.span,\n                                         impl_item.name, \"associated const\");\n                 }\n-                visit::walk_expr(self, expr)\n+                intravisit::walk_expr(self, expr)\n             }\n             hir::ImplItemKind::Method(_, ref body) => {\n                 if !self.symbol_is_live(impl_item.id, None) {\n                     self.warn_dead_code(impl_item.id, impl_item.span,\n                                         impl_item.name, \"method\");\n                 }\n-                visit::walk_block(self, body)\n+                intravisit::walk_block(self, body)\n             }\n             hir::ImplItemKind::Type(..) => {}\n         }\n@@ -593,10 +595,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n     fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n         match trait_item.node {\n             hir::ConstTraitItem(_, Some(ref expr)) => {\n-                visit::walk_expr(self, expr)\n+                intravisit::walk_expr(self, expr)\n             }\n             hir::MethodTraitItem(_, Some(ref body)) => {\n-                visit::walk_block(self, body)\n+                intravisit::walk_block(self, body)\n             }\n             hir::ConstTraitItem(_, None) |\n             hir::MethodTraitItem(_, None) |\n@@ -612,5 +614,5 @@ pub fn check_crate(tcx: &ty::ctxt,\n     let live_symbols = find_live(tcx, exported_items,\n                                  reachable_symbols, krate);\n     let mut visitor = DeadVisitor { tcx: tcx, live_symbols: live_symbols };\n-    visit::walk_crate(&mut visitor, krate);\n+    intravisit::walk_crate(&mut visitor, krate);\n }"}, {"sha": "2ba66807d4ecc5b7e9079cb883bd59778de83346", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/98b046e16e9f5c258fa92e44c05b287834ba555e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98b046e16e9f5c258fa92e44c05b287834ba555e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=98b046e16e9f5c258fa92e44c05b287834ba555e", "patch": "@@ -31,7 +31,7 @@ use util::nodemap::{DefIdMap, FnvHashSet, FnvHashMap};\n \n use rustc_front::hir;\n use rustc_front::hir::{Block, Crate, Item, Generics, StructField, Variant};\n-use rustc_front::visit::{self, Visitor};\n+use rustc_front::intravisit::{self, Visitor};\n \n use std::mem::replace;\n use std::cmp::Ordering;\n@@ -174,6 +174,13 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n+    /// Because stability levels are scoped lexically, we want to walk\n+    /// nested items in the context of the outer item, so enable\n+    /// deep-walking.\n+    fn visit_nested_item(&mut self, item: hir::ItemId) {\n+        self.visit_item(self.tcx.map.expect_item(item.id))\n+    }\n+\n     fn visit_item(&mut self, i: &Item) {\n         let orig_in_trait_impl = self.in_trait_impl;\n         let orig_in_enum = self.in_enum;\n@@ -203,15 +210,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n         }\n \n         self.annotate(i.id, &i.attrs, i.span, kind, |v| {\n-            visit::walk_item(v, i)\n+            intravisit::walk_item(v, i)\n         });\n         self.in_trait_impl = orig_in_trait_impl;\n         self.in_enum = orig_in_enum;\n     }\n \n     fn visit_trait_item(&mut self, ti: &hir::TraitItem) {\n         self.annotate(ti.id, &ti.attrs, ti.span, AnnotationKind::Required, |v| {\n-            visit::walk_trait_item(v, ti);\n+            intravisit::walk_trait_item(v, ti);\n         });\n     }\n \n@@ -222,13 +229,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n             AnnotationKind::Required\n         };\n         self.annotate(ii.id, &ii.attrs, ii.span, kind, |v| {\n-            visit::walk_impl_item(v, ii);\n+            intravisit::walk_impl_item(v, ii);\n         });\n     }\n \n     fn visit_variant(&mut self, var: &Variant, g: &'v Generics, item_id: NodeId) {\n         self.annotate(var.node.data.id(), &var.node.attrs, var.span, AnnotationKind::Required, |v| {\n-            visit::walk_variant(v, var, g, item_id);\n+            intravisit::walk_variant(v, var, g, item_id);\n         })\n     }\n \n@@ -240,13 +247,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n             AnnotationKind::Required\n         };\n         self.annotate(s.node.id, &s.node.attrs, s.span, kind, |v| {\n-            visit::walk_struct_field(v, s);\n+            intravisit::walk_struct_field(v, s);\n         });\n     }\n \n     fn visit_foreign_item(&mut self, i: &hir::ForeignItem) {\n         self.annotate(i.id, &i.attrs, i.span, AnnotationKind::Required, |v| {\n-            visit::walk_foreign_item(v, i);\n+            intravisit::walk_foreign_item(v, i);\n         });\n     }\n \n@@ -259,7 +266,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n \n impl<'tcx> Index<'tcx> {\n     /// Construct the stability index for a crate being compiled.\n-    pub fn build(&mut self, tcx: &ty::ctxt<'tcx>, krate: &Crate, export_map: &PublicItems) {\n+    pub fn build(&mut self, tcx: &ty::ctxt<'tcx>, krate: &'tcx Crate, export_map: &PublicItems) {\n         let mut annotator = Annotator {\n             tcx: tcx,\n             index: self,\n@@ -269,7 +276,7 @@ impl<'tcx> Index<'tcx> {\n             in_enum: false,\n         };\n         annotator.annotate(ast::CRATE_NODE_ID, &krate.attrs, krate.span, AnnotationKind::Required,\n-                           |v| visit::walk_crate(v, krate));\n+                           |v| intravisit::walk_crate(v, krate));\n     }\n \n     pub fn new(krate: &Crate) -> Index {\n@@ -308,9 +315,7 @@ pub fn check_unstable_api_usage(tcx: &ty::ctxt)\n         used_features: FnvHashMap(),\n         in_skip_block: 0,\n     };\n-\n-    let krate = tcx.map.krate();\n-    visit::walk_crate(&mut checker, krate);\n+    intravisit::walk_crate(&mut checker, tcx.map.krate());\n \n     let used_features = checker.used_features;\n     return used_features;\n@@ -379,6 +384,13 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n }\n \n impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n+    /// Because stability levels are scoped lexically, we want to walk\n+    /// nested items in the context of the outer item, so enable\n+    /// deep-walking.\n+    fn visit_nested_item(&mut self, item: hir::ItemId) {\n+        self.visit_item(self.tcx.map.expect_item(item.id))\n+    }\n+\n     fn visit_item(&mut self, item: &hir::Item) {\n         // When compiling with --test we don't enforce stability on the\n         // compiler-generated test module, demarcated with `DUMMY_SP` plus the\n@@ -387,31 +399,31 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n \n         check_item(self.tcx, item, true,\n                    &mut |id, sp, stab| self.check(id, sp, stab));\n-        visit::walk_item(self, item);\n+        intravisit::walk_item(self, item);\n     }\n \n     fn visit_expr(&mut self, ex: &hir::Expr) {\n         check_expr(self.tcx, ex,\n                    &mut |id, sp, stab| self.check(id, sp, stab));\n-        visit::walk_expr(self, ex);\n+        intravisit::walk_expr(self, ex);\n     }\n \n     fn visit_path(&mut self, path: &hir::Path, id: ast::NodeId) {\n         check_path(self.tcx, path, id,\n                    &mut |id, sp, stab| self.check(id, sp, stab));\n-        visit::walk_path(self, path)\n+        intravisit::walk_path(self, path)\n     }\n \n     fn visit_path_list_item(&mut self, prefix: &hir::Path, item: &hir::PathListItem) {\n         check_path_list_item(self.tcx, item,\n                    &mut |id, sp, stab| self.check(id, sp, stab));\n-        visit::walk_path_list_item(self, prefix, item)\n+        intravisit::walk_path_list_item(self, prefix, item)\n     }\n \n     fn visit_pat(&mut self, pat: &hir::Pat) {\n         check_pat(self.tcx, pat,\n                   &mut |id, sp, stab| self.check(id, sp, stab));\n-        visit::walk_pat(self, pat)\n+        intravisit::walk_pat(self, pat)\n     }\n \n     fn visit_block(&mut self, b: &hir::Block) {\n@@ -425,7 +437,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n             }\n             _ => {}\n         }\n-        visit::walk_block(self, b);\n+        intravisit::walk_block(self, b);\n         self.in_skip_block = old_skip_count;\n     }\n }"}, {"sha": "a5df0b94b337400334ac91578659f89d157e794c", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/98b046e16e9f5c258fa92e44c05b287834ba555e/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98b046e16e9f5c258fa92e44c05b287834ba555e/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=98b046e16e9f5c258fa92e44c05b287834ba555e", "patch": "@@ -49,7 +49,7 @@\n use std::fmt;\n use std::hash::{Hash, SipHasher, Hasher};\n use rustc_front::hir;\n-use rustc_front::visit;\n+use rustc_front::intravisit as visit;\n \n #[derive(Clone, PartialEq, Debug)]\n pub struct Svh {\n@@ -83,7 +83,7 @@ impl Svh {\n         }\n \n         {\n-            let mut visit = svh_visitor::make(&mut state);\n+            let mut visit = svh_visitor::make(&mut state, krate);\n             visit::walk_crate(&mut visit, krate);\n         }\n \n@@ -134,19 +134,20 @@ mod svh_visitor {\n     use syntax::ast::{self, Name, NodeId};\n     use syntax::codemap::Span;\n     use syntax::parse::token;\n-    use rustc_front::visit;\n-    use rustc_front::visit::{Visitor, FnKind};\n+    use rustc_front::intravisit as visit;\n+    use rustc_front::intravisit::{Visitor, FnKind};\n     use rustc_front::hir::*;\n     use rustc_front::hir;\n \n     use std::hash::{Hash, SipHasher};\n \n     pub struct StrictVersionHashVisitor<'a> {\n+        pub krate: &'a Crate,\n         pub st: &'a mut SipHasher,\n     }\n \n-    pub fn make<'a>(st: &'a mut SipHasher) -> StrictVersionHashVisitor<'a> {\n-        StrictVersionHashVisitor { st: st }\n+    pub fn make<'a>(st: &'a mut SipHasher, krate: &'a Crate) -> StrictVersionHashVisitor<'a> {\n+        StrictVersionHashVisitor { st: st, krate: krate }\n     }\n \n     // To off-load the bulk of the hash-computation on #[derive(Hash)],\n@@ -300,15 +301,19 @@ mod svh_visitor {\n         }\n     }\n \n-    impl<'a, 'v> Visitor<'v> for StrictVersionHashVisitor<'a> {\n-        fn visit_variant_data(&mut self, s: &VariantData, name: Name,\n-                            g: &Generics, _: NodeId, _: Span) {\n+    impl<'a> Visitor<'a> for StrictVersionHashVisitor<'a> {\n+        fn visit_nested_item(&mut self, item: ItemId) {\n+            self.visit_item(self.krate.item(item.id))\n+        }\n+\n+        fn visit_variant_data(&mut self, s: &'a VariantData, name: Name,\n+                              g: &'a Generics, _: NodeId, _: Span) {\n             SawStructDef(name.as_str()).hash(self.st);\n             visit::walk_generics(self, g);\n             visit::walk_struct_def(self, s)\n         }\n \n-        fn visit_variant(&mut self, v: &Variant, g: &Generics, item_id: NodeId) {\n+        fn visit_variant(&mut self, v: &'a Variant, g: &'a Generics, item_id: NodeId) {\n             SawVariant.hash(self.st);\n             // walk_variant does not call walk_generics, so do it here.\n             visit::walk_generics(self, g);\n@@ -333,11 +338,11 @@ mod svh_visitor {\n             SawIdent(name.as_str()).hash(self.st);\n         }\n \n-        fn visit_lifetime(&mut self, l: &Lifetime) {\n+        fn visit_lifetime(&mut self, l: &'a Lifetime) {\n             SawLifetime(l.name.as_str()).hash(self.st);\n         }\n \n-        fn visit_lifetime_def(&mut self, l: &LifetimeDef) {\n+        fn visit_lifetime_def(&mut self, l: &'a LifetimeDef) {\n             SawLifetimeDef(l.lifetime.name.as_str()).hash(self.st);\n         }\n \n@@ -346,88 +351,88 @@ mod svh_visitor {\n         // monomorphization and cross-crate inlining generally implies\n         // that a change to a crate body will require downstream\n         // crates to be recompiled.\n-        fn visit_expr(&mut self, ex: &Expr) {\n+        fn visit_expr(&mut self, ex: &'a Expr) {\n             SawExpr(saw_expr(&ex.node)).hash(self.st); visit::walk_expr(self, ex)\n         }\n \n-        fn visit_stmt(&mut self, s: &Stmt) {\n+        fn visit_stmt(&mut self, s: &'a Stmt) {\n             SawStmt(saw_stmt(&s.node)).hash(self.st); visit::walk_stmt(self, s)\n         }\n \n-        fn visit_foreign_item(&mut self, i: &ForeignItem) {\n+        fn visit_foreign_item(&mut self, i: &'a ForeignItem) {\n             // FIXME (#14132) ideally we would incorporate privacy (or\n             // perhaps reachability) somewhere here, so foreign items\n             // that do not leak into downstream crates would not be\n             // part of the ABI.\n             SawForeignItem.hash(self.st); visit::walk_foreign_item(self, i)\n         }\n \n-        fn visit_item(&mut self, i: &Item) {\n+        fn visit_item(&mut self, i: &'a Item) {\n             // FIXME (#14132) ideally would incorporate reachability\n             // analysis somewhere here, so items that never leak into\n             // downstream crates (e.g. via monomorphisation or\n             // inlining) would not be part of the ABI.\n             SawItem.hash(self.st); visit::walk_item(self, i)\n         }\n \n-        fn visit_mod(&mut self, m: &Mod, _s: Span, _n: NodeId) {\n+        fn visit_mod(&mut self, m: &'a Mod, _s: Span, _n: NodeId) {\n             SawMod.hash(self.st); visit::walk_mod(self, m)\n         }\n \n-        fn visit_decl(&mut self, d: &Decl) {\n+        fn visit_decl(&mut self, d: &'a Decl) {\n             SawDecl.hash(self.st); visit::walk_decl(self, d)\n         }\n \n-        fn visit_ty(&mut self, t: &Ty) {\n+        fn visit_ty(&mut self, t: &'a Ty) {\n             SawTy.hash(self.st); visit::walk_ty(self, t)\n         }\n \n-        fn visit_generics(&mut self, g: &Generics) {\n+        fn visit_generics(&mut self, g: &'a Generics) {\n             SawGenerics.hash(self.st); visit::walk_generics(self, g)\n         }\n \n-        fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl,\n-                    b: &'v Block, s: Span, _: NodeId) {\n+        fn visit_fn(&mut self, fk: FnKind<'a>, fd: &'a FnDecl,\n+                    b: &'a Block, s: Span, _: NodeId) {\n             SawFn.hash(self.st); visit::walk_fn(self, fk, fd, b, s)\n         }\n \n-        fn visit_trait_item(&mut self, ti: &TraitItem) {\n+        fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n             SawTraitItem.hash(self.st); visit::walk_trait_item(self, ti)\n         }\n \n-        fn visit_impl_item(&mut self, ii: &ImplItem) {\n+        fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n             SawImplItem.hash(self.st); visit::walk_impl_item(self, ii)\n         }\n \n-        fn visit_struct_field(&mut self, s: &StructField) {\n+        fn visit_struct_field(&mut self, s: &'a StructField) {\n             SawStructField.hash(self.st); visit::walk_struct_field(self, s)\n         }\n \n-        fn visit_explicit_self(&mut self, es: &ExplicitSelf) {\n+        fn visit_explicit_self(&mut self, es: &'a ExplicitSelf) {\n             SawExplicitSelf.hash(self.st); visit::walk_explicit_self(self, es)\n         }\n \n-        fn visit_path(&mut self, path: &Path, _: ast::NodeId) {\n+        fn visit_path(&mut self, path: &'a Path, _: ast::NodeId) {\n             SawPath.hash(self.st); visit::walk_path(self, path)\n         }\n \n-        fn visit_path_list_item(&mut self, prefix: &Path, item: &'v PathListItem) {\n+        fn visit_path_list_item(&mut self, prefix: &'a Path, item: &'a PathListItem) {\n             SawPath.hash(self.st); visit::walk_path_list_item(self, prefix, item)\n         }\n \n-        fn visit_block(&mut self, b: &Block) {\n+        fn visit_block(&mut self, b: &'a Block) {\n             SawBlock.hash(self.st); visit::walk_block(self, b)\n         }\n \n-        fn visit_pat(&mut self, p: &Pat) {\n+        fn visit_pat(&mut self, p: &'a Pat) {\n             SawPat.hash(self.st); visit::walk_pat(self, p)\n         }\n \n-        fn visit_local(&mut self, l: &Local) {\n+        fn visit_local(&mut self, l: &'a Local) {\n             SawLocal.hash(self.st); visit::walk_local(self, l)\n         }\n \n-        fn visit_arm(&mut self, a: &Arm) {\n+        fn visit_arm(&mut self, a: &'a Arm) {\n             SawArm.hash(self.st); visit::walk_arm(self, a)\n         }\n     }"}, {"sha": "d11880ecca19b0884837fa1141e865012224e9b7", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 68, "deletions": 38, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/98b046e16e9f5c258fa92e44c05b287834ba555e/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98b046e16e9f5c258fa92e44c05b287834ba555e/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=98b046e16e9f5c258fa92e44c05b287834ba555e", "patch": "@@ -35,7 +35,7 @@ use self::FieldName::*;\n use std::mem::replace;\n \n use rustc_front::hir;\n-use rustc_front::visit::{self, Visitor};\n+use rustc_front::intravisit::{self, Visitor};\n \n use rustc::middle::def;\n use rustc::middle::def_id::DefId;\n@@ -63,12 +63,18 @@ type CheckResult = Option<(Span, String, Option<(Span, String)>)>;\n /// The parent visitor, used to determine what's the parent of what (node-wise)\n ////////////////////////////////////////////////////////////////////////////////\n \n-struct ParentVisitor {\n+struct ParentVisitor<'a, 'tcx:'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     parents: NodeMap<ast::NodeId>,\n     curparent: ast::NodeId,\n }\n \n-impl<'v> Visitor<'v> for ParentVisitor {\n+impl<'a, 'tcx, 'v> Visitor<'v> for ParentVisitor<'a, 'tcx> {\n+    /// We want to visit items in the context of their containing\n+    /// module and so forth, so supply a crate for doing a deep walk.\n+    fn visit_nested_item(&mut self, item: hir::ItemId) {\n+        self.visit_item(self.tcx.map.expect_item(item.id))\n+    }\n     fn visit_item(&mut self, item: &hir::Item) {\n         self.parents.insert(item.id, self.curparent);\n \n@@ -99,24 +105,24 @@ impl<'v> Visitor<'v> for ParentVisitor {\n \n             _ => {}\n         }\n-        visit::walk_item(self, item);\n+        intravisit::walk_item(self, item);\n         self.curparent = prev;\n     }\n \n     fn visit_foreign_item(&mut self, a: &hir::ForeignItem) {\n         self.parents.insert(a.id, self.curparent);\n-        visit::walk_foreign_item(self, a);\n+        intravisit::walk_foreign_item(self, a);\n     }\n \n-    fn visit_fn(&mut self, a: visit::FnKind<'v>, b: &'v hir::FnDecl,\n+    fn visit_fn(&mut self, a: intravisit::FnKind<'v>, b: &'v hir::FnDecl,\n                 c: &'v hir::Block, d: Span, id: ast::NodeId) {\n         // We already took care of some trait methods above, otherwise things\n         // like impl methods and pub trait methods are parented to the\n         // containing module, not the containing trait.\n         if !self.parents.contains_key(&id) {\n             self.parents.insert(id, self.curparent);\n         }\n-        visit::walk_fn(self, a, b, c, d);\n+        intravisit::walk_fn(self, a, b, c, d);\n     }\n \n     fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n@@ -125,7 +131,7 @@ impl<'v> Visitor<'v> for ParentVisitor {\n         if !self.parents.contains_key(&ii.id) {\n             self.parents.insert(ii.id, self.curparent);\n         }\n-        visit::walk_impl_item(self, ii);\n+        intravisit::walk_impl_item(self, ii);\n     }\n \n     fn visit_variant_data(&mut self, s: &hir::VariantData, _: ast::Name,\n@@ -141,7 +147,7 @@ impl<'v> Visitor<'v> for ParentVisitor {\n         for field in s.fields() {\n             self.parents.insert(field.node.id, self.curparent);\n         }\n-        visit::walk_struct_def(self, s)\n+        intravisit::walk_struct_def(self, s)\n     }\n }\n \n@@ -216,6 +222,11 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n+    /// We want to visit items in the context of their containing\n+    /// module and so forth, so supply a crate for doing a deep walk.\n+    fn visit_nested_item(&mut self, item: hir::ItemId) {\n+        self.visit_item(self.tcx.map.expect_item(item.id))\n+    }\n     fn visit_item(&mut self, item: &hir::Item) {\n         let orig_all_public = self.prev_public;\n         let orig_all_exported = self.prev_exported;\n@@ -362,7 +373,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             _ => {}\n         }\n \n-        visit::walk_item(self, item);\n+        intravisit::walk_item(self, item);\n \n         self.prev_public = orig_all_public;\n         self.prev_exported = orig_all_exported;\n@@ -375,7 +386,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         // Blocks can have exported and public items, for example impls, but they always\n         // start as non-public and non-exported regardless of publicity of a function,\n         // constant, type, field, etc. in which this block resides\n-        visit::walk_block(self, b);\n+        intravisit::walk_block(self, b);\n \n         self.prev_public = orig_all_public;\n         self.prev_exported = orig_all_exported;\n@@ -392,7 +403,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                 }\n             }\n         }\n-        visit::walk_mod(self, m)\n+        intravisit::walk_mod(self, m)\n     }\n \n     fn visit_macro_def(&mut self, md: &'v hir::MacroDef) {\n@@ -895,9 +906,15 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n+    /// We want to visit items in the context of their containing\n+    /// module and so forth, so supply a crate for doing a deep walk.\n+    fn visit_nested_item(&mut self, item: hir::ItemId) {\n+        self.visit_item(self.tcx.map.expect_item(item.id))\n+    }\n+\n     fn visit_item(&mut self, item: &hir::Item) {\n         let orig_curitem = replace(&mut self.curitem, item.id);\n-        visit::walk_item(self, item);\n+        intravisit::walk_item(self, item);\n         self.curitem = orig_curitem;\n     }\n \n@@ -958,7 +975,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             _ => {}\n         }\n \n-        visit::walk_expr(self, expr);\n+        intravisit::walk_expr(self, expr);\n     }\n \n     fn visit_pat(&mut self, pattern: &hir::Pat) {\n@@ -1004,19 +1021,19 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             _ => {}\n         }\n \n-        visit::walk_pat(self, pattern);\n+        intravisit::walk_pat(self, pattern);\n     }\n \n     fn visit_foreign_item(&mut self, fi: &hir::ForeignItem) {\n         self.in_foreign = true;\n-        visit::walk_foreign_item(self, fi);\n+        intravisit::walk_foreign_item(self, fi);\n         self.in_foreign = false;\n     }\n \n     fn visit_path(&mut self, path: &hir::Path, id: ast::NodeId) {\n         if !path.segments.is_empty() {\n             self.check_path(path.span, id, path.segments.last().unwrap().identifier.name);\n-            visit::walk_path(self, path);\n+            intravisit::walk_path(self, path);\n         }\n     }\n \n@@ -1029,7 +1046,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             self.tcx.sess.bug(\"`self` import in an import list with empty prefix\");\n         };\n         self.check_path(item.span, item.node.id(), name);\n-        visit::walk_path_list_item(self, prefix, item);\n+        intravisit::walk_path_list_item(self, prefix, item);\n     }\n }\n \n@@ -1043,6 +1060,12 @@ struct SanePrivacyVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for SanePrivacyVisitor<'a, 'tcx> {\n+    /// We want to visit items in the context of their containing\n+    /// module and so forth, so supply a crate for doing a deep walk.\n+    fn visit_nested_item(&mut self, item: hir::ItemId) {\n+        self.visit_item(self.tcx.map.expect_item(item.id))\n+    }\n+\n     fn visit_item(&mut self, item: &hir::Item) {\n         self.check_sane_privacy(item);\n         if self.in_block {\n@@ -1054,13 +1077,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for SanePrivacyVisitor<'a, 'tcx> {\n         // Modules turn privacy back on, otherwise we inherit\n         self.in_block = if let hir::ItemMod(..) = item.node { false } else { orig_in_block };\n \n-        visit::walk_item(self, item);\n+        intravisit::walk_item(self, item);\n         self.in_block = orig_in_block;\n     }\n \n     fn visit_block(&mut self, b: &'v hir::Block) {\n         let orig_in_block = replace(&mut self.in_block, true);\n-        visit::walk_block(self, b);\n+        intravisit::walk_block(self, b);\n         self.in_block = orig_in_block;\n     }\n }\n@@ -1220,14 +1243,20 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for CheckTypeForPrivatenessVisitor<'a, 'b, 't\n             }\n         }\n         self.at_outer_type = false;\n-        visit::walk_ty(self, ty)\n+        intravisit::walk_ty(self, ty)\n     }\n \n     // don't want to recurse into [, .. expr]\n     fn visit_expr(&mut self, _: &hir::Expr) {}\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n+    /// We want to visit items in the context of their containing\n+    /// module and so forth, so supply a crate for doing a deep walk.\n+    fn visit_nested_item(&mut self, item: hir::ItemId) {\n+        self.visit_item(self.tcx.map.expect_item(item.id))\n+    }\n+\n     fn visit_item(&mut self, item: &hir::Item) {\n         match item.node {\n             // contents of a private mod can be reexported, so we need\n@@ -1313,7 +1342,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                         not_private_trait &&\n                         trait_or_some_public_method {\n \n-                    visit::walk_generics(self, g);\n+                    intravisit::walk_generics(self, g);\n \n                     match *trait_ref {\n                         None => {\n@@ -1328,10 +1357,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                                     hir::ImplItemKind::Method(..)\n                                         if self.item_is_public(&impl_item.id, impl_item.vis) =>\n                                     {\n-                                        visit::walk_impl_item(self, impl_item)\n+                                        intravisit::walk_impl_item(self, impl_item)\n                                     }\n                                     hir::ImplItemKind::Type(..) => {\n-                                        visit::walk_impl_item(self, impl_item)\n+                                        intravisit::walk_impl_item(self, impl_item)\n                                     }\n                                     _ => {}\n                                 }\n@@ -1351,7 +1380,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                             //\n                             // Those in 2. are warned via walk_generics and this\n                             // call here.\n-                            visit::walk_path(self, &tr.path);\n+                            intravisit::walk_path(self, &tr.path);\n \n                             // Those in 3. are warned with this call.\n                             for impl_item in impl_items {\n@@ -1370,21 +1399,21 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                             hir::ImplItemKind::Const(..) => {\n                                 if self.item_is_public(&impl_item.id, impl_item.vis) {\n                                     found_pub_static = true;\n-                                    visit::walk_impl_item(self, impl_item);\n+                                    intravisit::walk_impl_item(self, impl_item);\n                                 }\n                             }\n                             hir::ImplItemKind::Method(ref sig, _) => {\n                                 if sig.explicit_self.node == hir::SelfStatic &&\n                                       self.item_is_public(&impl_item.id, impl_item.vis) {\n                                     found_pub_static = true;\n-                                    visit::walk_impl_item(self, impl_item);\n+                                    intravisit::walk_impl_item(self, impl_item);\n                                 }\n                             }\n                             _ => {}\n                         }\n                     }\n                     if found_pub_static {\n-                        visit::walk_generics(self, g)\n+                        intravisit::walk_generics(self, g)\n                     }\n                 }\n                 return\n@@ -1407,7 +1436,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n         // public signatures, i.e. things that we're interested in for\n         // this visitor.\n         debug!(\"VisiblePrivateTypesVisitor entering item {:?}\", item);\n-        visit::walk_item(self, item);\n+        intravisit::walk_item(self, item);\n     }\n \n     fn visit_generics(&mut self, generics: &hir::Generics) {\n@@ -1433,7 +1462,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, item: &hir::ForeignItem) {\n         if self.exported_items.contains(&item.id) {\n-            visit::walk_foreign_item(self, item)\n+            intravisit::walk_foreign_item(self, item)\n         }\n     }\n \n@@ -1446,13 +1475,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                           \"private type in exported type signature\");\n             }\n         }\n-        visit::walk_ty(self, t)\n+        intravisit::walk_ty(self, t)\n     }\n \n     fn visit_variant(&mut self, v: &hir::Variant, g: &hir::Generics, item_id: ast::NodeId) {\n         if self.exported_items.contains(&v.node.data.id()) {\n             self.in_variant = true;\n-            visit::walk_variant(self, v, g, item_id);\n+            intravisit::walk_variant(self, v, g, item_id);\n             self.in_variant = false;\n         }\n     }\n@@ -1462,7 +1491,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n             hir::NamedField(_, vis) | hir::UnnamedField(vis) => vis\n         };\n         if vis == hir::Public || self.in_variant {\n-            visit::walk_struct_field(self, s);\n+            intravisit::walk_struct_field(self, s);\n         }\n     }\n \n@@ -1489,14 +1518,15 @@ pub fn check_crate(tcx: &ty::ctxt,\n         tcx: tcx,\n         in_block: false,\n     };\n-    visit::walk_crate(&mut visitor, krate);\n+    intravisit::walk_crate(&mut visitor, krate);\n \n     // Figure out who everyone's parent is\n     let mut visitor = ParentVisitor {\n+        tcx: tcx,\n         parents: NodeMap(),\n         curparent: ast::DUMMY_NODE_ID,\n     };\n-    visit::walk_crate(&mut visitor, krate);\n+    intravisit::walk_crate(&mut visitor, krate);\n \n     // Use the parent map to check the privacy of everything\n     let mut visitor = PrivacyVisitor {\n@@ -1506,7 +1536,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n         parents: visitor.parents,\n         external_exports: external_exports,\n     };\n-    visit::walk_crate(&mut visitor, krate);\n+    intravisit::walk_crate(&mut visitor, krate);\n \n     tcx.sess.abort_if_errors();\n \n@@ -1524,7 +1554,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n     visitor.public_items.insert(ast::CRATE_NODE_ID);\n     loop {\n         let before = (visitor.exported_items.len(), visitor.public_items.len());\n-        visit::walk_crate(&mut visitor, krate);\n+        intravisit::walk_crate(&mut visitor, krate);\n         let after = (visitor.exported_items.len(), visitor.public_items.len());\n         if after == before {\n             break\n@@ -1540,7 +1570,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n             public_items: &public_items,\n             in_variant: false,\n         };\n-        visit::walk_crate(&mut visitor, krate);\n+        intravisit::walk_crate(&mut visitor, krate);\n     }\n     return (exported_items, public_items);\n }"}, {"sha": "4ea120724a7cad63d8bec12f02bc87053f17a0b4", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/98b046e16e9f5c258fa92e44c05b287834ba555e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98b046e16e9f5c258fa92e44c05b287834ba555e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=98b046e16e9f5c258fa92e44c05b287834ba555e", "patch": "@@ -52,7 +52,7 @@ use rustc_front::hir::StmtDecl;\n use rustc_front::hir::UnnamedField;\n use rustc_front::hir::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use rustc_front::hir::Visibility;\n-use rustc_front::visit::{self, Visitor};\n+use rustc_front::intravisit::{self, Visitor};\n \n use std::mem::replace;\n use std::ops::{Deref, DerefMut};\n@@ -111,7 +111,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             builder: self,\n             parent: parent,\n         };\n-        visit::walk_crate(&mut visitor, krate);\n+        intravisit::walk_crate(&mut visitor, krate);\n     }\n \n     /// Adds a new child item to the module definition of the parent node and\n@@ -1051,10 +1051,14 @@ struct BuildReducedGraphVisitor<'a, 'b: 'a, 'tcx: 'b> {\n }\n \n impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n+    fn visit_nested_item(&mut self, item: hir::ItemId) {\n+        self.visit_item(self.builder.resolver.ast_map.expect_item(item.id))\n+    }\n+\n     fn visit_item(&mut self, item: &Item) {\n         let p = self.builder.build_reduced_graph_for_item(item, &self.parent);\n         let old_parent = replace(&mut self.parent, p);\n-        visit::walk_item(self, item);\n+        intravisit::walk_item(self, item);\n         self.parent = old_parent;\n     }\n \n@@ -1065,7 +1069,7 @@ impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n     fn visit_block(&mut self, block: &Block) {\n         let np = self.builder.build_reduced_graph_for_block(block, &self.parent);\n         let old_parent = replace(&mut self.parent, np);\n-        visit::walk_block(self, block);\n+        intravisit::walk_block(self, block);\n         self.parent = old_parent;\n     }\n }"}, {"sha": "8776ee2d83141a4a5a778f9d8e1e621e35ac1d93", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 38, "deletions": 34, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/98b046e16e9f5c258fa92e44c05b287834ba555e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98b046e16e9f5c258fa92e44c05b287834ba555e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=98b046e16e9f5c258fa92e44c05b287834ba555e", "patch": "@@ -76,7 +76,7 @@ use syntax::parse::token::{self, special_names, special_idents};\n use syntax::ptr::P;\n use syntax::codemap::{self, Span, Pos};\n \n-use rustc_front::visit::{self, FnKind, Visitor};\n+use rustc_front::intravisit::{self, FnKind, Visitor};\n use rustc_front::hir;\n use rustc_front::hir::{Arm, BindByRef, BindByValue, BindingMode, Block};\n use rustc_front::hir::Crate;\n@@ -541,6 +541,9 @@ enum NameDefinition {\n }\n \n impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n+    fn visit_nested_item(&mut self, item: hir::ItemId) {\n+        self.visit_item(self.ast_map.expect_item(item.id))\n+    }\n     fn visit_item(&mut self, item: &Item) {\n         execute_callback!(hir_map::Node::NodeItem(item), self);\n         self.resolve_item(item);\n@@ -573,7 +576,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n                 // error already reported\n             }\n         }\n-        visit::walk_poly_trait_ref(self, tref, m);\n+        intravisit::walk_poly_trait_ref(self, tref, m);\n     }\n     fn visit_variant(&mut self,\n                      variant: &hir::Variant,\n@@ -583,11 +586,11 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n         if let Some(ref dis_expr) = variant.node.disr_expr {\n             // resolve the discriminator expr as a constant\n             self.with_constant_rib(|this| {\n-                this.visit_expr(&**dis_expr);\n+                this.visit_expr(dis_expr);\n             });\n         }\n \n-        // `visit::walk_variant` without the discriminant expression.\n+        // `intravisit::walk_variant` without the discriminant expression.\n         self.visit_variant_data(&variant.node.data,\n                                 variant.node.name,\n                                 generics,\n@@ -603,7 +606,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n             ForeignItemStatic(..) => NoTypeParameters,\n         };\n         self.with_type_parameter_rib(type_parameters, |this| {\n-            visit::walk_foreign_item(this, foreign_item);\n+            intravisit::walk_foreign_item(this, foreign_item);\n         });\n     }\n     fn visit_fn(&mut self,\n@@ -2047,7 +2050,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn resolve_crate(&mut self, krate: &hir::Crate) {\n         debug!(\"(resolving crate) starting\");\n \n-        visit::walk_crate(self, krate);\n+        intravisit::walk_crate(self, krate);\n     }\n \n     fn check_if_primitive_type_name(&self, name: Name, span: Span) {\n@@ -2071,11 +2074,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 self.check_if_primitive_type_name(name, item.span);\n \n                 self.with_type_parameter_rib(HasTypeParameters(generics, TypeSpace, ItemRibKind),\n-                                             |this| visit::walk_item(this, item));\n+                                             |this| intravisit::walk_item(this, item));\n             }\n             ItemFn(_, _, _, _, ref generics, _) => {\n                 self.with_type_parameter_rib(HasTypeParameters(generics, FnSpace, ItemRibKind),\n-                                             |this| visit::walk_item(this, item));\n+                                             |this| intravisit::walk_item(this, item));\n             }\n \n             ItemDefaultImpl(_, ref trait_ref) => {\n@@ -2110,10 +2113,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     // expression in a provided default.\n                                     if default.is_some() {\n                                         this.with_constant_rib(|this| {\n-                                            visit::walk_trait_item(this, trait_item)\n+                                            intravisit::walk_trait_item(this, trait_item)\n                                         });\n                                     } else {\n-                                        visit::walk_trait_item(this, trait_item)\n+                                        intravisit::walk_trait_item(this, trait_item)\n                                     }\n                                 }\n                                 hir::MethodTraitItem(ref sig, _) => {\n@@ -2122,14 +2125,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                           FnSpace,\n                                                           MethodRibKind);\n                                     this.with_type_parameter_rib(type_parameters, |this| {\n-                                        visit::walk_trait_item(this, trait_item)\n+                                        intravisit::walk_trait_item(this, trait_item)\n                                     });\n                                 }\n                                 hir::TypeTraitItem(..) => {\n                                     this.check_if_primitive_type_name(trait_item.name,\n                                                                       trait_item.span);\n                                     this.with_type_parameter_rib(NoTypeParameters, |this| {\n-                                        visit::walk_trait_item(this, trait_item)\n+                                        intravisit::walk_trait_item(this, trait_item)\n                                     });\n                                 }\n                             };\n@@ -2140,13 +2143,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             ItemMod(_) | ItemForeignMod(_) => {\n                 self.with_scope(Some(name), |this| {\n-                    visit::walk_item(this, item);\n+                    intravisit::walk_item(this, item);\n                 });\n             }\n \n             ItemConst(..) | ItemStatic(..) => {\n                 self.with_constant_rib(|this| {\n-                    visit::walk_item(this, item);\n+                    intravisit::walk_item(this, item);\n                 });\n             }\n \n@@ -2283,10 +2286,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             debug!(\"(resolving function) recorded argument\");\n         }\n-        visit::walk_fn_ret_ty(self, &declaration.output);\n+        intravisit::walk_fn_ret_ty(self, &declaration.output);\n \n         // Resolve the function body.\n-        self.visit_block(&*block);\n+        self.visit_block(block);\n \n         debug!(\"(resolving function) leaving function\");\n \n@@ -2347,7 +2350,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             }\n         }\n-        visit::walk_generics(self, generics);\n+        intravisit::walk_generics(self, generics);\n     }\n \n     fn with_current_self_type<T, F>(&mut self, self_type: &Ty, f: F) -> T\n@@ -2374,7 +2377,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 new_val = Some((path_res.base_def.def_id(), trait_ref.clone()));\n                 new_id = Some(path_res.base_def.def_id());\n             }\n-            visit::walk_trait_ref(self, trait_ref);\n+            intravisit::walk_trait_ref(self, trait_ref);\n         }\n         let original_trait_ref = replace(&mut self.current_trait_ref, new_val);\n         let result = f(self, new_id);\n@@ -2427,7 +2430,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                           impl_item.span,\n                                         |n, s| ResolutionError::ConstNotMemberOfTrait(n, s));\n                                     this.with_constant_rib(|this| {\n-                                        visit::walk_impl_item(this, impl_item);\n+                                        intravisit::walk_impl_item(this, impl_item);\n                                     });\n                                 }\n                                 hir::ImplItemKind::Method(ref sig, _) => {\n@@ -2444,7 +2447,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                           FnSpace,\n                                                           MethodRibKind);\n                                     this.with_type_parameter_rib(type_parameters, |this| {\n-                                        visit::walk_impl_item(this, impl_item);\n+                                        intravisit::walk_impl_item(this, impl_item);\n                                     });\n                                 }\n                                 hir::ImplItemKind::Type(ref ty) => {\n@@ -2583,7 +2586,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mut found_non_item = false;\n         for statement in &block.stmts {\n             if let hir::StmtDecl(ref declaration, _) = statement.node {\n-                if let hir::DeclItem(ref i) = declaration.node {\n+                if let hir::DeclItem(i) = declaration.node {\n+                    let i = self.ast_map.expect_item(i.id);\n                     match i.node {\n                         ItemExternCrate(_) | ItemUse(_) if found_non_item => {\n                             span_err!(self.session,\n@@ -2602,7 +2606,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         // Descend into the block.\n-        visit::walk_block(self, block);\n+        intravisit::walk_block(self, block);\n \n         // Move back up.\n         if !self.resolved {\n@@ -2623,7 +2627,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // `<T>::a::b::c` is resolved by typeck alone.\n                     TypecheckRequired => {\n                         // Resolve embedded types.\n-                        visit::walk_ty(self, ty);\n+                        intravisit::walk_ty(self, ty);\n                         return;\n                     }\n                     ResolveAttempt(resolution) => resolution,\n@@ -2674,7 +2678,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             _ => {}\n         }\n         // Resolve embedded types.\n-        visit::walk_ty(self, ty);\n+        intravisit::walk_ty(self, ty);\n     }\n \n     fn resolve_pattern(&mut self,\n@@ -2862,7 +2866,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 &path.segments.last().unwrap().identifier.name.as_str())\n                         );\n                     }\n-                    visit::walk_path(self, path);\n+                    intravisit::walk_path(self, path);\n                 }\n \n                 PatQPath(ref qself, ref path) => {\n@@ -2883,7 +2887,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                  .name;\n                             let traits = self.get_traits_containing_item(const_name);\n                             self.trait_map.insert(pattern.id, traits);\n-                            visit::walk_pat(self, pattern);\n+                            intravisit::walk_pat(self, pattern);\n                             return true;\n                         }\n                         ResolveAttempt(resolution) => resolution,\n@@ -2915,7 +2919,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                                                       .name\n                                                                                       .as_str()));\n                     }\n-                    visit::walk_pat(self, pattern);\n+                    intravisit::walk_pat(self, pattern);\n                 }\n \n                 PatStruct(ref path, _, _) => {\n@@ -2933,11 +2937,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             );\n                         }\n                     }\n-                    visit::walk_path(self, path);\n+                    intravisit::walk_path(self, path);\n                 }\n \n                 PatLit(_) | PatRange(..) => {\n-                    visit::walk_pat(self, pattern);\n+                    intravisit::walk_pat(self, pattern);\n                 }\n \n                 _ => {\n@@ -3665,7 +3669,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         let method_name = path.segments.last().unwrap().identifier.name;\n                         let traits = self.get_traits_containing_item(method_name);\n                         self.trait_map.insert(expr.id, traits);\n-                        visit::walk_expr(self, expr);\n+                        intravisit::walk_expr(self, expr);\n                         return;\n                     }\n                     ResolveAttempt(resolution) => resolution,\n@@ -3777,7 +3781,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 }\n \n-                visit::walk_expr(self, expr);\n+                intravisit::walk_expr(self, expr);\n             }\n \n             ExprStruct(ref path, _, _) => {\n@@ -3797,7 +3801,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 }\n \n-                visit::walk_expr(self, expr);\n+                intravisit::walk_expr(self, expr);\n             }\n \n             ExprLoop(_, Some(label)) | ExprWhile(_, _, Some(label)) => {\n@@ -3810,7 +3814,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         rib.bindings.insert(renamed, def_like);\n                     }\n \n-                    visit::walk_expr(this, expr);\n+                    intravisit::walk_expr(this, expr);\n                 })\n             }\n \n@@ -3838,7 +3842,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             _ => {\n-                visit::walk_expr(self, expr);\n+                intravisit::walk_expr(self, expr);\n             }\n         }\n     }"}]}