{"sha": "152cbaade7bc2ec36546554eb2d2090a9833bfff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1MmNiYWFkZTdiYzJlYzM2NTQ2NTU0ZWIyZDIwOTBhOTgzM2JmZmY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-22T04:44:41Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-22T17:44:04Z"}, "message": "Move functions from syntax::ast to syntax::ast_util\n\nThis leaves syntax::ast just defining the AST, which strikes me as somewhat\nnicer", "tree": {"sha": "d6bb39fcdcce9f67cc97f97a6259e85cbf315650", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6bb39fcdcce9f67cc97f97a6259e85cbf315650"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/152cbaade7bc2ec36546554eb2d2090a9833bfff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/152cbaade7bc2ec36546554eb2d2090a9833bfff", "html_url": "https://github.com/rust-lang/rust/commit/152cbaade7bc2ec36546554eb2d2090a9833bfff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/152cbaade7bc2ec36546554eb2d2090a9833bfff/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3affaa20fcd718080951d5be2da3f578c960664", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3affaa20fcd718080951d5be2da3f578c960664", "html_url": "https://github.com/rust-lang/rust/commit/a3affaa20fcd718080951d5be2da3f578c960664"}], "stats": {"total": 672, "additions": 358, "deletions": 314}, "files": [{"sha": "e199d10fbd18c9c3f6da5db6331528e5bc3fb4a0", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -5,6 +5,7 @@ import std::str;\n import std::map;\n import std::option;\n import syntax::ast;\n+import syntax::ast_util;\n import util::common;\n import driver::session;\n \n@@ -189,7 +190,7 @@ fn require_unique_names(sess: &session::session, metas: &[@ast::meta_item]) {\n }\n \n fn span<T>(item: &T) -> ast::spanned<T> {\n-    ret {node: item, span: ast::mk_sp(0u, 0u)};\n+    ret {node: item, span: ast_util::dummy_sp()};\n }\n \n fn mk_name_value_item_str(name: ast::ident, value: str) -> @ast::meta_item {"}, {"sha": "d9cda6e601ad9bd27744c1d4e06e0c5a38e14d7d", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -3,6 +3,8 @@\n import std::option;\n import std::vec;\n import syntax::ast;\n+import syntax::ast_util;\n+import syntax::ast_util::dummy_sp;\n import syntax::fold;\n import syntax::print::pprust;\n import front::attr;\n@@ -88,7 +90,7 @@ fn fold_item(cx: &test_ctxt, i: &@ast::item, fld: fold::ast_fold) ->\n    @ast::item {\n \n     cx.path += [i.ident];\n-    log #fmt[\"current path: %s\", ast::path_name_i(cx.path)];\n+    log #fmt[\"current path: %s\", ast_util::path_name_i(cx.path)];\n \n     if is_test_fn(i) {\n         log \"this is a test function\";\n@@ -161,15 +163,15 @@ fn mk_test_module(cx: &test_ctxt) -> @ast::item {\n          attrs: [],\n          id: cx.next_node_id(),\n          node: item_,\n-         span: ast::dummy_sp()};\n+         span: dummy_sp()};\n \n     log #fmt[\"Synthetic test module:\\n%s\\n\", pprust::item_to_str(@item)];\n \n     ret @item;\n }\n \n fn nospan<T>(t: &T) -> ast::spanned<T> {\n-    ret {node: t, span: ast::dummy_sp()};\n+    ret {node: t, span: dummy_sp()};\n }\n \n fn mk_tests(cx: &test_ctxt) -> @ast::item {\n@@ -199,7 +201,7 @@ fn mk_tests(cx: &test_ctxt) -> @ast::item {\n          attrs: [],\n          id: cx.next_node_id(),\n          node: item_,\n-         span: ast::dummy_sp()};\n+         span: dummy_sp()};\n     ret @item;\n }\n \n@@ -237,20 +239,20 @@ fn mk_test_desc_vec(cx: &test_ctxt) -> @ast::expr {\n \n     ret @{id: cx.next_node_id(),\n           node: ast::expr_vec(descs, ast::imm),\n-          span: ast::dummy_sp()};\n+          span: dummy_sp()};\n }\n \n fn mk_test_desc_rec(cx: &test_ctxt, test: test) -> @ast::expr {\n     let path = test.path;\n \n-    log #fmt[\"encoding %s\", ast::path_name_i(path)];\n+    log #fmt[\"encoding %s\", ast_util::path_name_i(path)];\n \n     let name_lit: ast::lit =\n-        nospan(ast::lit_str(ast::path_name_i(path), ast::sk_rc));\n+        nospan(ast::lit_str(ast_util::path_name_i(path), ast::sk_rc));\n     let name_expr: ast::expr =\n         {id: cx.next_node_id(),\n          node: ast::expr_lit(@name_lit),\n-         span: ast::dummy_sp()};\n+         span: dummy_sp()};\n \n     let name_field: ast::field =\n         nospan({mut: ast::imm, ident: \"name\", expr: @name_expr});\n@@ -260,7 +262,7 @@ fn mk_test_desc_rec(cx: &test_ctxt, test: test) -> @ast::expr {\n     let fn_expr: ast::expr =\n         {id: cx.next_node_id(),\n          node: ast::expr_path(fn_path),\n-         span: ast::dummy_sp()};\n+         span: dummy_sp()};\n \n     let fn_field: ast::field =\n         nospan({mut: ast::imm, ident: \"fn\", expr: @fn_expr});\n@@ -270,15 +272,15 @@ fn mk_test_desc_rec(cx: &test_ctxt, test: test) -> @ast::expr {\n     let ignore_expr: ast::expr =\n         {id: cx.next_node_id(),\n          node: ast::expr_lit(@ignore_lit),\n-         span: ast::dummy_sp()};\n+         span: dummy_sp()};\n \n     let ignore_field: ast::field =\n         nospan({mut: ast::imm, ident: \"ignore\", expr: @ignore_expr});\n \n     let desc_rec_: ast::expr_ =\n         ast::expr_rec([name_field, fn_field, ignore_field], option::none);\n     let desc_rec: ast::expr =\n-        {id: cx.next_node_id(), node: desc_rec_, span: ast::dummy_sp()};\n+        {id: cx.next_node_id(), node: desc_rec_, span: dummy_sp()};\n     ret @desc_rec;\n }\n \n@@ -307,7 +309,7 @@ fn mk_main(cx: &test_ctxt) -> @ast::item {\n         {stmts: [],\n          expr: option::some(test_main_call_expr),\n          id: cx.next_node_id()};\n-    let body = {node: body_, span: ast::dummy_sp()};\n+    let body = {node: body_, span: dummy_sp()};\n \n     let fn_ = {decl: decl, proto: proto, body: body};\n \n@@ -317,7 +319,7 @@ fn mk_main(cx: &test_ctxt) -> @ast::item {\n          attrs: [],\n          id: cx.next_node_id(),\n          node: item_,\n-         span: ast::dummy_sp()};\n+         span: dummy_sp()};\n     ret @item;\n }\n \n@@ -330,7 +332,7 @@ fn mk_test_main_call(cx: &test_ctxt) -> @ast::expr {\n     let args_path_expr_: ast::expr_ = ast::expr_path(args_path);\n \n     let args_path_expr: ast::expr =\n-        {id: cx.next_node_id(), node: args_path_expr_, span: ast::dummy_sp()};\n+        {id: cx.next_node_id(), node: args_path_expr_, span: dummy_sp()};\n \n     // Call __test::test to generate the vector of test_descs\n     let test_path: ast::path =\n@@ -339,12 +341,12 @@ fn mk_test_main_call(cx: &test_ctxt) -> @ast::expr {\n     let test_path_expr_: ast::expr_ = ast::expr_path(test_path);\n \n     let test_path_expr: ast::expr =\n-        {id: cx.next_node_id(), node: test_path_expr_, span: ast::dummy_sp()};\n+        {id: cx.next_node_id(), node: test_path_expr_, span: dummy_sp()};\n \n     let test_call_expr_: ast::expr_ = ast::expr_call(@test_path_expr, []);\n \n     let test_call_expr: ast::expr =\n-        {id: cx.next_node_id(), node: test_call_expr_, span: ast::dummy_sp()};\n+        {id: cx.next_node_id(), node: test_call_expr_, span: dummy_sp()};\n \n     // Call std::test::test_main\n     let test_main_path: ast::path =\n@@ -357,7 +359,7 @@ fn mk_test_main_call(cx: &test_ctxt) -> @ast::expr {\n     let test_main_path_expr: ast::expr =\n         {id: cx.next_node_id(),\n          node: test_main_path_expr_,\n-         span: ast::dummy_sp()};\n+         span: dummy_sp()};\n \n     let test_main_call_expr_: ast::expr_ =\n         ast::expr_call(@test_main_path_expr,\n@@ -366,7 +368,7 @@ fn mk_test_main_call(cx: &test_ctxt) -> @ast::expr {\n     let test_main_call_expr: ast::expr =\n         {id: cx.next_node_id(),\n          node: test_main_call_expr_,\n-         span: ast::dummy_sp()};\n+         span: dummy_sp()};\n \n     ret @test_main_call_expr;\n }"}, {"sha": "b2570e41148e4f3f579c9a9f86455a078c1b8896", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -2,6 +2,7 @@\n \n import driver::session;\n import syntax::ast;\n+import syntax::ast_util;\n import lib::llvm::False;\n import lib::llvm::llvm;\n import lib::llvm::mk_object_file;\n@@ -262,7 +263,7 @@ fn resolve_crate_deps(e: env, cdata: &@[u8]) -> cstore::cnum_map {\n             log \"need to load it\";\n             // This is a new one so we've got to load it\n             // FIXME: Need better error reporting than just a bogus span\n-            let fake_span = ast::dummy_sp();\n+            let fake_span = ast_util::dummy_sp();\n             let local_cnum = resolve_crate(e, cname, [], fake_span);\n             cnum_map.insert(extrn_cnum, local_cnum);\n         }"}, {"sha": "fc2f3a00a9bd6e3bb2e331bceef3b78406cd3cdf", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -7,6 +7,7 @@ import std::str;\n import std::io;\n import std::map::hashmap;\n import syntax::ast;\n+import syntax::ast_util;\n import front::attr;\n import middle::ty;\n import common::*;\n@@ -335,7 +336,7 @@ fn get_attributes(md: &ebml::doc) -> [ast::attribute] {\n             let meta_item = meta_items[0];\n             attrs +=\n                 [{node: {style: ast::attr_outer, value: *meta_item},\n-                  span: ast::dummy_sp()}];\n+                  span: ast_util::dummy_sp()}];\n         }\n       }\n       option::none. { }"}, {"sha": "6ecd8c21f7a64162485189681406b2108e414438", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -10,6 +10,8 @@ import std::option::none;\n import std::ebml;\n import std::map;\n import syntax::ast::*;\n+import syntax::ast_util;\n+import syntax::ast_util::local_def;\n import common::*;\n import middle::trans_common::crate_ctxt;\n import middle::ty;\n@@ -71,7 +73,7 @@ fn encode_native_module_item_paths(ebml_w: &ebml::writer, nmod: &native_mod,\n fn encode_module_item_paths(ebml_w: &ebml::writer, module: &_mod,\n                             path: &[str], index: &mutable [entry<str>]) {\n     for it: @item in module.items {\n-        if !is_exported(it.ident, module) { cont; }\n+        if !ast_util::is_exported(it.ident, module) { cont; }\n         alt it.node {\n           item_const(_, _) {\n             add_to_index(ebml_w, path, index, it.ident);"}, {"sha": "f632e5ed28bc83086219e6cdaf99359e714ca689", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -8,7 +8,8 @@ import std::option::none;\n import std::option::some;\n import syntax::ast;\n import syntax::ast::*;\n-import ast::respan;\n+import syntax::ast_util;\n+import syntax::ast_util::respan;\n import middle::ty;\n \n export parse_def_id;\n@@ -106,7 +107,7 @@ fn parse_path(st: @pstate, sd: str_def) -> ast::path {\n           ':' { next(st); next(st); }\n           c {\n             if c == '(' {\n-                ret respan(ast::dummy_sp(),\n+                ret respan(ast_util::dummy_sp(),\n                            {global: false, idents: idents, types: []});\n             } else { idents += [parse_ident_(st, sd, is_last)]; }\n           }\n@@ -152,7 +153,7 @@ fn parse_ty_constr_arg(st: @pstate, sd: str_def) ->\n \n fn parse_constr<@T>(st: @pstate, sd: str_def, pser: arg_parser<T>) ->\n    @ty::constr_general<T> {\n-    let sp = ast::dummy_sp(); // FIXME: use a real span\n+    let sp = ast_util::dummy_sp(); // FIXME: use a real span\n     let args: [@sp_constr_arg<T>] = [];\n     let pth: path = parse_path(st, sd);\n     let ignore: char = next(st) as char;"}, {"sha": "03fcb283621891380d905ed514bcafb3021ed706", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -1,5 +1,6 @@\n \n import syntax::ast;\n+import syntax::ast_util;\n import ast::ident;\n import ast::fn_ident;\n import ast::node_id;\n@@ -195,7 +196,7 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope) ->\n             if arg_t.mode == ty::mo_alias(true) {\n                 alt path_def(cx, arg) {\n                   some(def) {\n-                    let dnum = ast::def_id_of_def(def).node;\n+                    let dnum = ast_util::def_id_of_def(def).node;\n                     if def_is_local(def, true) {\n                         if is_immutable_alias(cx, sc, dnum) {\n                             cx.tcx.sess.span_err(\n@@ -302,7 +303,7 @@ fn check_tail_call(cx: &ctx, call: &@ast::expr) {\n             alt args[i].node {\n               ast::expr_path(_) {\n                 let def = cx.tcx.def_map.get(args[i].id);\n-                let dnum = ast::def_id_of_def(def).node;\n+                let dnum = ast_util::def_id_of_def(def).node;\n                 alt cx.local_map.find(dnum) {\n                   some(arg(ast::alias(mut))) {\n                     if mut_a && !mut {\n@@ -352,7 +353,7 @@ fn check_alt(cx: &ctx, input: &@ast::expr, arms: &[ast::arm], sc: &scope,\n }\n \n fn arm_defnums(arm: &ast::arm) -> [node_id] {\n-    ret ast::pat_binding_ids(arm.pats[0]);\n+    ret ast_util::pat_binding_ids(arm.pats[0]);\n }\n \n fn check_for_each(cx: &ctx, local: &@ast::local, call: &@ast::expr,\n@@ -361,7 +362,7 @@ fn check_for_each(cx: &ctx, local: &@ast::local, call: &@ast::expr,\n     alt call.node {\n       ast::expr_call(f, args) {\n         let data = check_call(cx, f, args, sc);\n-        let bindings = ast::pat_binding_ids(local.node.pat);\n+        let bindings = ast_util::pat_binding_ids(local.node.pat);\n         let new_sc =\n             @{root_vars: data.root_vars,\n               block_defnum: bindings[vec::len(bindings) - 1u],\n@@ -393,7 +394,7 @@ fn check_for(cx: &ctx, local: &@ast::local, seq: &@ast::expr, blk: &ast::blk,\n                                     util::ppaux::ty_to_str(cx.tcx, seq_t));\n       }\n     }\n-    let bindings = ast::pat_binding_ids(local.node.pat);\n+    let bindings = ast_util::pat_binding_ids(local.node.pat);\n     let new_sc =\n         @{root_vars: root_def,\n           block_defnum: bindings[vec::len(bindings) - 1u],\n@@ -408,7 +409,7 @@ fn check_var(cx: &ctx, ex: &@ast::expr, p: &ast::path, id: ast::node_id,\n              assign: bool, sc: &scope) {\n     let def = cx.tcx.def_map.get(id);\n     if !def_is_local(def, true) { ret; }\n-    let my_defnum = ast::def_id_of_def(def).node;\n+    let my_defnum = ast_util::def_id_of_def(def).node;\n     let var_t = ty::expr_ty(cx.tcx, ex);\n     for r: restrict in *sc {\n \n@@ -429,7 +430,7 @@ fn check_var(cx: &ctx, ex: &@ast::expr, p: &ast::path, id: ast::node_id,\n fn check_lval(cx: &@ctx, dest: &@ast::expr, sc: &scope, v: &vt<scope>) {\n     alt dest.node {\n       ast::expr_path(p) {\n-        let dnum = ast::def_id_of_def(cx.tcx.def_map.get(dest.id)).node;\n+        let dnum = ast_util::def_id_of_def(cx.tcx.def_map.get(dest.id)).node;\n         cx.mut_map.insert(dnum, ());\n         if is_immutable_alias(*cx, sc, dnum) {\n             cx.tcx.sess.span_err(dest.span, \"assigning to immutable alias\");\n@@ -515,15 +516,17 @@ fn test_scope(cx: &ctx, sc: &scope, r: &restrict, p: &ast::path) {\n         let msg =\n             alt prob {\n               overwritten(sp, wpt) {\n-                {span: sp, msg: \"overwriting \" + ast::path_name(wpt)}\n+                {span: sp, msg: \"overwriting \" + ast_util::path_name(wpt)}\n               }\n               val_taken(sp, vpt) {\n-                {span: sp, msg: \"taking the value of \" + ast::path_name(vpt)}\n+                {span: sp,\n+                 msg: \"taking the value of \" + ast_util::path_name(vpt)}\n               }\n             };\n         cx.tcx.sess.span_err(msg.span,\n                              msg.msg + \" will invalidate alias \" +\n-                                 ast::path_name(p) + \", which is still used\");\n+                             ast_util::path_name(p) +\n+                             \", which is still used\");\n     }\n }\n \n@@ -660,7 +663,7 @@ fn path_def(cx: &ctx, ex: &@ast::expr) -> option::t<ast::def> {\n fn path_def_id(cx: &ctx, ex: &@ast::expr) -> option::t<ast::def_id> {\n     alt ex.node {\n       ast::expr_path(_) {\n-        ret some(ast::def_id_of_def(cx.tcx.def_map.get(ex.id)));\n+        ret some(ast_util::def_id_of_def(cx.tcx.def_map.get(ex.id)));\n       }\n       _ { ret none; }\n     }"}, {"sha": "356d2b46b8cfe03bf5b709670dfd00156e3d842a", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -125,9 +125,11 @@ fn node_span(node: &ast_node) -> codemap::span {\n \n #[cfg(test)]\n mod test {\n+    import syntax::ast_util;\n+\n     #[test]\n     fn test_node_span_item() {\n-        let expected: codemap::span = mk_sp(20u, 30u);\n+        let expected: codemap::span = ast_util::mk_sp(20u, 30u);\n         let node =\n             node_item(@{ident: \"test\",\n                         attrs: [],\n@@ -139,7 +141,7 @@ mod test {\n \n     #[test]\n     fn test_node_span_obj_ctor() {\n-        let expected: codemap::span = mk_sp(20u, 30u);\n+        let expected: codemap::span = ast_util::mk_sp(20u, 30u);\n         let node =\n             node_obj_ctor(@{ident: \"test\",\n                             attrs: [],\n@@ -151,7 +153,7 @@ mod test {\n \n     #[test]\n     fn test_node_span_native_item() {\n-        let expected: codemap::span = mk_sp(20u, 30u);\n+        let expected: codemap::span = ast_util::mk_sp(20u, 30u);\n         let node =\n             node_native_item(@{ident: \"test\",\n                                attrs: [],\n@@ -163,7 +165,7 @@ mod test {\n \n     #[test]\n     fn test_node_span_expr() {\n-        let expected: codemap::span = mk_sp(20u, 30u);\n+        let expected: codemap::span = ast_util::mk_sp(20u, 30u);\n         let node = node_expr(@{id: 0, node: expr_break, span: expected});\n         assert (node_span(node) == expected);\n     }"}, {"sha": "ce5e937cf69abc5decf56ea892db5add5cdd23c8", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -1,4 +1,6 @@\n import syntax::ast::*;\n+import syntax::ast_util::variant_def_ids;\n+import syntax::ast_util::dummy_sp;\n import syntax::visit;\n \n fn check_crate(tcx: &ty::ctxt, crate: &@crate) {"}, {"sha": "e8c146c5a851e165e717924004ba414337f5d3c9", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -7,6 +7,7 @@ import std::option;\n import std::int;\n import std::option::*;\n import syntax::ast;\n+import syntax::ast_util;\n import syntax::visit;\n import driver::session;\n import middle::resolve;\n@@ -69,7 +70,7 @@ fn collect_freevars(def_map: &resolve::def_map, sess: &session::session,\n         };\n     let walk_local =\n         lambda (local: &@ast::local) {\n-            for each b: @ast::pat in ast::pat_bindings(local.node.pat) {\n+            for each b: @ast::pat in ast_util::pat_bindings(local.node.pat) {\n                 set_add(decls, b.id);\n             }\n         };\n@@ -91,7 +92,7 @@ fn collect_freevars(def_map: &resolve::def_map, sess: &session::session,\n     let defs = new_int_hash();\n     for ref_id_: ast::node_id in *refs {\n         let ref_id = ref_id_;\n-        let def_id = ast::def_id_of_def(def_map.get(ref_id)).node;\n+        let def_id = ast_util::def_id_of_def(def_map.get(ref_id)).node;\n         if !decls.contains_key(def_id) && !defs.contains_key(def_id) {\n             canonical_refs += [ref_id];\n             set_add(defs, def_id);\n@@ -127,7 +128,7 @@ fn annotate_freevars(sess: &session::session, def_map: &resolve::def_map,\n                     lambda (v: &visit::vt<()>) {\n                         v.visit_block(body, (), v);\n                     };\n-                let bound = ast::pat_binding_ids(local.node.pat);\n+                let bound = ast_util::pat_binding_ids(local.node.pat);\n                 let vars = collect_freevars(def_map, sess, start_walk, bound);\n                 freevars.insert(body.node.id, vars);\n               }\n@@ -166,7 +167,7 @@ fn def_lookup(tcx: &ty::ctxt, f: ast::node_id, id: ast::node_id) ->\n     alt tcx.def_map.find(id) {\n       none. { ret none; }\n       some(d) {\n-        let did = ast::def_id_of_def(d);\n+        let did = ast_util::def_id_of_def(d);\n         if f != -1 && is_freevar_of(tcx, did.node, f) {\n             ret some(ast::def_upvar(did, @d));\n         } else { ret some(d); }"}, {"sha": "4ffdcc95ff3fd4bffa4d18d647224684d25fc86f", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -72,6 +72,7 @@\n \n \n import syntax::ast;\n+import syntax::ast_util;\n import syntax::visit;\n \n import std::vec;\n@@ -142,7 +143,8 @@ fn check_expr(tcx: &ty::ctxt, e: &@ast::expr) {\n         // that all the types we're supplying as typarams conform to the\n         // typaram kind constraints on that item.\n         if vec::len(tpt.params) != 0u {\n-            let callee_def = ast::def_id_of_def(tcx.def_map.get(callee.id));\n+            let callee_def = ast_util::def_id_of_def(\n+                tcx.def_map.get(callee.id));\n             let item_tk = ty::lookup_item_type(tcx, callee_def);\n             let i = 0;\n             assert (vec::len(item_tk.kinds) == vec::len(tpt.params));"}, {"sha": "d3712f90da23f1c659a9235f23556e2cfc0d3775", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -1,13 +1,14 @@\n \n import syntax::ast;\n import syntax::ast::*;\n+import syntax::ast_util;\n import syntax::codemap;\n import ast::ident;\n import ast::fn_ident;\n import ast::def;\n import ast::def_id;\n import ast::node_id;\n-import ast::local_def;\n+import syntax::ast_util::local_def;\n \n import metadata::csearch;\n import metadata::cstore;\n@@ -16,7 +17,7 @@ import util::common::*;\n import std::map::new_int_hash;\n import std::map::new_str_hash;\n import syntax::codemap::span;\n-import syntax::ast::respan;\n+import syntax::ast_util::respan;\n import middle::ty::constr_table;\n import syntax::visit;\n import visit::vt;\n@@ -321,7 +322,8 @@ fn resolve_names(e: &@env, c: &@ast::crate) {\n               }\n               _ {\n                 e.sess.span_err(p.span,\n-                                \"not a tag variant: \" + ast::path_name(p));\n+                                \"not a tag variant: \" +\n+                                ast_util::path_name(p));\n               }\n             }\n           }\n@@ -739,7 +741,7 @@ fn lookup_in_ty_params(name: &ident, ty_params: &[ast::ty_param]) ->\n \n fn lookup_in_pat(name: &ident, pat: &@ast::pat) -> option::t<def_id> {\n     let found = none;\n-    for each bound in ast::pat_bindings(pat) {\n+    for each bound in ast_util::pat_bindings(pat) {\n         let p_name = alt bound.node { ast::pat_bind(n) { n } };\n         if str::eq(p_name, name) { found = some(local_def(bound.id)); }\n     }\n@@ -891,7 +893,7 @@ fn lookup_in_mod_strict(e: &env, sc: &scopes, m: def, sp: &span, name: &ident,\n \n fn lookup_in_mod(e: &env, m: &def, sp: &span, name: &ident, ns: namespace,\n                  dr: dir) -> option::t<def> {\n-    let defid = ast::def_id_of_def(m);\n+    let defid = ast_util::def_id_of_def(m);\n     if defid.crate != ast::local_crate {\n         // examining a module in an external crate\n \n@@ -946,7 +948,7 @@ fn lookup_in_local_native_mod(e: &env, node_id: node_id, sp: &span,\n fn lookup_in_local_mod(e: &env, node_id: node_id, sp: &span, id: &ident,\n                        ns: namespace, dr: dir) -> option::t<def> {\n     let info = e.mod_map.get(node_id);\n-    if dr == outside && !ast::is_exported(id, option::get(info.m)) {\n+    if dr == outside && !ast_util::is_exported(id, option::get(info.m)) {\n         // if we're in a native mod, then dr==inside, so info.m is some _mod\n \n         ret none::<def>; // name is not visible\n@@ -1173,7 +1175,7 @@ fn ns_for_def(d: def) -> namespace {\n fn lookup_external(e: &env, cnum: int, ids: &[ident], ns: namespace) ->\n    option::t<def> {\n     for d: def in csearch::lookup_defs(e.sess.get_cstore(), cnum, ids) {\n-        e.ext_map.insert(ast::def_id_of_def(d), ids);\n+        e.ext_map.insert(ast_util::def_id_of_def(d), ids);\n         if ns == ns_for_def(d) { ret some(d); }\n     }\n     ret none::<def>;\n@@ -1273,7 +1275,7 @@ fn check_item(e: &@env, i: &@ast::item, x: &(), v: &vt<()>) {\n }\n \n fn check_pat(ch: checker, p: &@ast::pat) {\n-    for each p in ast::pat_bindings(p) {\n+    for each p in ast_util::pat_bindings(p) {\n         let ident = alt p.node { pat_bind(n) { n } };\n         add_name(ch, p.span, ident);\n     }\n@@ -1321,7 +1323,7 @@ fn check_block(e: &@env, b: &ast::blk, x: &(), v: &vt<()>) {\n               ast::decl_local(locs) {\n                 let local_values = checker(*e, \"value\");\n                 for loc in locs {\n-                    for each p in ast::pat_bindings(loc.node.pat) {\n+                    for each p in ast_util::pat_bindings(loc.node.pat) {\n                         let ident = alt p.node { pat_bind(n) { n } };\n                         add_name(local_values, p.span, ident);\n                         check_name(values, p.span, ident);"}, {"sha": "f3ada9b7ca494fe9001c06cd3d0be3ddfb1feac7", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -21,7 +21,7 @@ import middle::ty;\n import middle::ty::field;\n import middle::ty::mt;\n import syntax::ast;\n-import syntax::ast::dummy_sp;\n+import syntax::ast_util::dummy_sp;\n import syntax::codemap::span;\n import syntax::util::interner;\n import util::common;"}, {"sha": "8fd45fff56b41cb38ece42fb6224abc254214291", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -25,6 +25,7 @@ import std::fs;\n import std::time;\n import std::vec;\n import syntax::ast;\n+import syntax::ast_util;\n import driver::session;\n import middle::ty;\n import middle::freevars::*;\n@@ -3478,7 +3479,7 @@ fn trans_if(cx: &@block_ctxt, cond: &@ast::expr, thn: &ast::blk,\n           some(elexpr) {\n             alt elexpr.node {\n               ast::expr_if(_, _, _) {\n-                let elseif_blk = ast::block_from_expr(elexpr);\n+                let elseif_blk = ast_util::block_from_expr(elexpr);\n                 trans_block(else_cx, elseif_blk, output)\n               }\n               ast::expr_block(blk) { trans_block(else_cx, blk, output) }\n@@ -3722,7 +3723,8 @@ fn load_environment(enclosing_cx: &@block_ctxt, fcx: &@fn_ctxt, envty: ty::t,\n         bcx = upvarptr.bcx;\n         let llupvarptr = upvarptr.val;\n         if !copying { llupvarptr = bcx.build.Load(llupvarptr); }\n-        let def_id = ast::def_id_of_def(bcx_tcx(bcx).def_map.get(upvar_id));\n+        let def_id = ast_util::def_id_of_def(bcx_tcx(bcx).\n+                                             def_map.get(upvar_id));\n         fcx.llupvars.insert(def_id.node, llupvarptr);\n         i += 1u;\n     }\n@@ -4980,7 +4982,7 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n                             output);\n       }\n       ast::expr_ternary(_, _, _) {\n-        ret trans_expr_out(cx, ast::ternary_to_if(e), output);\n+        ret trans_expr_out(cx, ast_util::ternary_to_if(e), output);\n       }\n       ast::expr_for(decl, seq, body) { ret trans_for(cx, decl, seq, body); }\n       ast::expr_for_each(decl, seq, body) {\n@@ -5463,7 +5465,7 @@ fn build_return(bcx: &@block_ctxt) { bcx.build.Br(bcx_fcx(bcx).llreturn); }\n fn trans_be(cx: &@block_ctxt, e: &@ast::expr) -> result {\n     // FIXME: This should be a typestate precondition\n \n-    assert (ast::is_call_expr(e));\n+    assert (ast_util::is_call_expr(e));\n     // FIXME: Turn this into a real tail call once\n     // calling convention issues are settled\n \n@@ -6208,8 +6210,8 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n     i = 0u;\n     for va: ast::variant_arg in variant.node.args {\n         let rslt =\n-            GEP_tag(bcx, llblobptr, ast::local_def(tag_id),\n-                    ast::local_def(variant.node.id), ty_param_substs,\n+            GEP_tag(bcx, llblobptr, ast_util::local_def(tag_id),\n+                    ast_util::local_def(variant.node.id), ty_param_substs,\n                     i as int);\n         bcx = rslt.bcx;\n         let lldestptr = rslt.val;"}, {"sha": "56948101f860af7e2da2613a465c96314a1e030a", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -14,7 +14,8 @@ import trans::new_scope_block_ctxt;\n import trans::load_if_immediate;\n import ty::pat_ty;\n import syntax::ast;\n-import syntax::ast::dummy_sp;\n+import syntax::ast_util;\n+import syntax::ast_util::dummy_sp;\n import syntax::ast::def_id;\n import syntax::codemap::span;\n import util::common::lit_eq;\n@@ -44,7 +45,7 @@ fn trans_opt(bcx: &@block_ctxt, o: &opt) -> result {\n }\n \n fn variant_opt(ccx: &@crate_ctxt, pat_id: ast::node_id) -> opt {\n-    let vdef = ast::variant_def_ids(ccx.tcx.def_map.get(pat_id));\n+    let vdef = ast_util::variant_def_ids(ccx.tcx.def_map.get(pat_id));\n     let variants = ty::tag_variants(ccx.tcx, vdef.tg);\n     let i = 0u;\n     for v: ty::variant_info in variants {\n@@ -500,7 +501,7 @@ fn trans_alt(cx: &@block_ctxt, expr: &@ast::expr, arms: &[ast::arm],\n \n     for a: ast::arm in arms {\n         let body = new_scope_block_ctxt(cx, \"case_body\");\n-        let id_map = ast::pat_id_map(a.pats[0]);\n+        let id_map = ast_util::pat_id_map(a.pats[0]);\n         bodies += [body];\n         for p: @ast::pat in a.pats {\n             match += [@{pats: [p],\n@@ -532,7 +533,8 @@ fn trans_alt(cx: &@block_ctxt, expr: &@ast::expr, arms: &[ast::arm],\n     let arm_results = [];\n     for a: ast::arm in arms {\n         let body_cx = bodies[i];\n-        if make_phi_bindings(body_cx, exit_map, ast::pat_id_map(a.pats[0])) {\n+        if make_phi_bindings(body_cx, exit_map,\n+                             ast_util::pat_id_map(a.pats[0])) {\n             let block_res = trans::trans_block(body_cx, a.body, output);\n             arm_results += [block_res];\n         } else { // Unreachable\n@@ -562,7 +564,7 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: &@ast::pat, val: ValueRef,\n       }\n       ast::pat_tag(_, sub) {\n         if vec::len(sub) == 0u { ret bcx; }\n-        let vdefs = ast::variant_def_ids(ccx.tcx.def_map.get(pat.id));\n+        let vdefs = ast_util::variant_def_ids(ccx.tcx.def_map.get(pat.id));\n         let args = extract_variant_args(bcx, pat.id, vdefs, val);\n         let i = 0;\n         for argval: ValueRef in args.vals {"}, {"sha": "c5a23309f7569f9cd139f9c9031f5e1dcf39945c", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -15,6 +15,7 @@ import back::abi;\n import back::link::mangle_internal_name_by_path;\n import back::link::mangle_internal_name_by_path_and_seq;\n import syntax::ast;\n+import syntax::ast_util;\n import syntax::codemap::span;\n \n import trans_common::*;\n@@ -231,7 +232,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n     // methods, not inner ones.\n     let wrapper_obj: ast::_obj =\n         {fields:\n-             std::vec::map(ast::obj_field_from_anon_obj_field,\n+             std::vec::map(ast_util::obj_field_from_anon_obj_field,\n                            additional_fields),\n          methods: anon_obj.methods};\n "}, {"sha": "bb288cb18c7f773d2dffade9ac8fdc4e974ddb77", "filename": "src/comp/middle/tstate/annotate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -5,6 +5,7 @@ import std::option::none;\n import std::int;\n import std::uint;\n import syntax::ast::*;\n+import syntax::ast_util::pat_binding_ids;\n import syntax::visit;\n import syntax::codemap::span;\n import std::map::new_str_hash;"}, {"sha": "6aab9e5aed4e7907b6937f85594e3cf0914dc009", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -6,6 +6,7 @@ import std::option::*;\n import std::int;\n import std::uint;\n import syntax::ast::*;\n+import syntax::ast_util::*;\n import syntax::codemap::span;\n import syntax::visit;\n import util::common;"}, {"sha": "070417e64012a7c090d65a1a5f224cbd2cb9a877", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -11,7 +11,7 @@ import ast::ident;\n import ast::fn_ident;\n import ast::node_id;\n import ast::def_id;\n-import ast::local_def;\n+import syntax::ast_util::local_def;\n import ast::ty_param;\n import ast::crate;\n import ast::return;"}, {"sha": "0065fcaf41df7745229b80ca7b495f11ef56b542", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -2,14 +2,15 @@ import std::uint;\n import std::int;\n import std::vec;\n import syntax::ast::*;\n+import syntax::ast_util::*;\n import util::ppaux::fn_ident_to_string;\n import std::option::*;\n import syntax::visit;\n import aux::*;\n import std::map::new_int_hash;\n import util::common::new_def_hash;\n import syntax::codemap::span;\n-import syntax::ast::respan;\n+import syntax::ast_util::respan;\n \n type ctxt = {cs: @mutable [sp_constr], tcx: ty::ctxt};\n "}, {"sha": "c1d81d4d277ae3237b72812621a29ba1f35ce233", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -17,6 +17,7 @@ import bitvectors::relax_precond_block;\n import bitvectors::gen;\n import tritv::*;\n import syntax::ast::*;\n+import syntax::ast_util::*;\n import syntax::visit;\n import std::map::new_int_hash;\n import util::common::new_def_hash;"}, {"sha": "75f6172711c3f9aa5396466a591fc0ffd7744651", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -15,6 +15,7 @@ import tritv::ttrue;\n \n import bitvectors::*;\n import syntax::ast::*;\n+import syntax::ast_util::*;\n import middle::ty::expr_ty;\n import middle::ty::type_is_nil;\n import middle::ty::type_is_bot;"}, {"sha": "5d448825b890b3d33a5a2518fcd2889a14c285ec", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -13,6 +13,7 @@ import std::smallintmap;\n import driver::session;\n import syntax::ast;\n import syntax::ast::*;\n+import syntax::ast_util;\n import syntax::codemap::span;\n import metadata::csearch;\n import util::common::*;\n@@ -416,7 +417,8 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map,\n           has_pointer_cache: map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n           kind_cache: map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n           owns_heap_mem_cache: map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n-          ast_ty_to_ty_cache: map::mk_hashmap(ast::hash_ty, ast::eq_ty)};\n+          ast_ty_to_ty_cache: map::mk_hashmap(ast_util::hash_ty,\n+                                              ast_util::eq_ty)};\n     populate_type_store(cx);\n     ret cx;\n }\n@@ -2716,7 +2718,7 @@ fn tag_variants(cx: &ctxt, id: &ast::def_id) -> [variant_info] {\n                 result +=\n                     [{args: arg_tys,\n                       ctor_ty: ctor_ty,\n-                      id: ast::local_def(did)}];\n+                      id: ast_util::local_def(did)}];\n             }\n             ret result;\n           }\n@@ -2873,8 +2875,10 @@ fn ast_constr_to_constr<T>(tcx: ty::ctxt, c: &@ast::constr_general<T>) ->\n    @ty::constr_general<T> {\n     alt tcx.def_map.find(c.node.id) {\n       some(ast::def_fn(pred_id, ast::pure_fn.)) {\n-        ret @respan(c.span,\n-                    {path: c.node.path, args: c.node.args, id: pred_id});\n+        ret @ast_util::respan(c.span,\n+                              {path: c.node.path,\n+                               args: c.node.args,\n+                               id: pred_id});\n       }\n       _ {\n         tcx.sess.span_fatal(c.span,"}, {"sha": "859e169b44f10858b14e27cc8497a5f44ad9c437", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -1,7 +1,8 @@\n import syntax::ast;\n+import syntax::ast_util;\n import ast::mutability;\n-import ast::local_def;\n-import ast::respan;\n+import syntax::ast_util::local_def;\n+import syntax::ast_util::respan;\n import ast::spanned;\n import syntax::visit;\n import metadata::csearch;\n@@ -708,14 +709,14 @@ mod collect {\n             let convert = bind ast_ty_to_ty(cx.tcx, get, _);\n             let f = bind ty_of_arg(cx, _);\n             ret ty_of_native_fn_decl(cx, convert, f, fn_decl, abi, params,\n-                                     ast::local_def(it.id));\n+                                     ast_util::local_def(it.id));\n           }\n           ast::native_item_ty. {\n             alt cx.tcx.tcache.find(local_def(it.id)) {\n               some(tpt) { ret tpt; }\n               none. { }\n             }\n-            let t = ty::mk_native(cx.tcx, ast::local_def(it.id));\n+            let t = ty::mk_native(cx.tcx, ast_util::local_def(it.id));\n             let tpt = {kinds: no_kinds, ty: t};\n             cx.tcx.tcache.insert(local_def(it.id), tpt);\n             ret tpt;\n@@ -1329,7 +1330,7 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast::pat_id_map, pat: &@ast::pat,\n       ast::pat_tag(path, subpats) {\n         // Typecheck the path.\n         let v_def = lookup_def(fcx, path.span, pat.id);\n-        let v_def_ids = ast::variant_def_ids(v_def);\n+        let v_def_ids = ast_util::variant_def_ids(v_def);\n         let tag_tpt = ty::lookup_item_type(fcx.ccx.tcx, v_def_ids.tg);\n         let path_tpot = instantiate_path(fcx, path, tag_tpt, pat.span);\n \n@@ -1727,7 +1728,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                   }\n                 }\n                 for operand: @ast::expr in operands {\n-                    if !ast::is_constraint_arg(operand) {\n+                    if !ast_util::is_constraint_arg(operand) {\n                         let s =\n                             \"Constraint args must be \\\n                                               slot variables or literals\";\n@@ -1776,7 +1777,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                                binop: ast::binop) {\n         let resolved_t = resolve_type_vars_if_possible(fcx, ty);\n         if !ty::is_binopable(fcx.ccx.tcx, resolved_t, binop) {\n-            let binopstr = ast::binop_to_str(binop);\n+            let binopstr = ast_util::binop_to_str(binop);\n             let t_str = ty_to_str(fcx.ccx.tcx, resolved_t);\n             let errmsg =\n                 \"binary operation \" + binopstr +\n@@ -1798,7 +1799,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n         bot = check_expr_with(fcx, lhs, lhs_t);\n \n         let rhs_bot = check_expr_with(fcx, rhs, lhs_t);\n-        if !ast::lazy_binop(binop) { bot |= rhs_bot; }\n+        if !ast_util::lazy_binop(binop) { bot |= rhs_bot; }\n \n         check_binop_type_compat(fcx, expr.span, lhs_t, binop);\n \n@@ -1928,7 +1929,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n       }\n       ast::expr_be(e) {\n         // FIXME: prove instead of assert\n-        assert (ast::is_call_expr(e));\n+        assert (ast_util::is_call_expr(e));\n         check_expr_with(fcx, e, fcx.ret_ty);\n         bot = true;\n         write::nil_ty(tcx, id);\n@@ -1947,7 +1948,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                 check_then_else(fcx, thn, elsopt, id, expr.span);\n       }\n       ast::expr_ternary(_, _, _) {\n-        bot = check_expr(fcx, ast::ternary_to_if(expr));\n+        bot = check_expr(fcx, ast_util::ternary_to_if(expr));\n       }\n       ast::expr_assert(e) {\n         bot = check_expr_with(fcx, e, ty::mk_bool(tcx));\n@@ -2029,7 +2030,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n         // bindings.\n         let pattern_ty = ty::expr_ty(tcx, expr);\n         for arm: ast::arm in arms {\n-            let id_map = ast::pat_id_map(arm.pats[0]);\n+            let id_map = ast_util::pat_id_map(arm.pats[0]);\n             for p: @ast::pat in arm.pats {\n                 check_pat(fcx, id_map, p, pattern_ty);\n             }\n@@ -2392,7 +2393,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n             }\n \n             fcx.ccx.obj_infos +=\n-                [anon_obj(vec::map(ast::obj_field_from_anon_obj_field,\n+                [anon_obj(vec::map(ast_util::obj_field_from_anon_obj_field,\n                                    fields), inner_obj_sty)];\n \n             // Whenever an outer method overrides an inner, we need to remove\n@@ -2499,7 +2500,7 @@ fn check_decl_local(fcx: &@fn_ctxt, local: &@ast::local) -> bool {\n           }\n           _ {/* fall through */ }\n         }\n-        let id_map = ast::pat_id_map(local.node.pat);\n+        let id_map = ast_util::pat_id_map(local.node.pat);\n         check_pat(fcx, id_map, local.node.pat, t);\n       }\n     }"}, {"sha": "1cba8c469a88a471451c50ac9f302ac4aba8bb59", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -45,6 +45,7 @@ mod middle {\n \n mod syntax {\n     mod ast;\n+    mod ast_util;\n \n     mod fold;\n     mod visit;"}, {"sha": "ec38c349ce3e2bd8a26cf027b1760ab4238c65f2", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -6,15 +6,6 @@ import codemap::span;\n import codemap::filename;\n \n type spanned<T> = {node: T, span: span};\n-fn respan<T>(sp: &span, t: &T) -> spanned<T> { ret {node: t, span: sp}; }\n-\n-/* assuming that we're not in macro expansion */\n-fn mk_sp(lo: uint, hi: uint) -> span {\n-    ret {lo: lo, hi: hi, expanded_from: codemap::os_none};\n-}\n-\n-// make this a const, once the compiler supports it\n-fn dummy_sp() -> span { ret mk_sp(0u, 0u); }\n \n type ident = str;\n // Functions may or may not have names.\n@@ -27,16 +18,11 @@ type path_ = {global: bool, idents: [ident], types: [@ty]};\n \n type path = spanned<path_>;\n \n-fn path_name(p: &path) -> str { path_name_i(p.node.idents) }\n-\n-fn path_name_i(idents: &[ident]) -> str { str::connect(idents, \"::\") }\n-\n type crate_num = int;\n type node_id = int;\n type def_id = {crate: crate_num, node: node_id};\n \n const local_crate: crate_num = 0;\n-fn local_def(id: node_id) -> def_id { ret {crate: local_crate, node: id}; }\n \n type ty_param = {ident: ident, kind: kind};\n \n@@ -64,30 +50,6 @@ tag def {\n     def_upvar(def_id, @def);\n }\n \n-fn variant_def_ids(d: &def) -> {tg: def_id, var: def_id} {\n-    alt d { def_variant(tag_id, var_id) { ret {tg: tag_id, var: var_id}; } }\n-}\n-\n-fn def_id_of_def(d: def) -> def_id {\n-    alt d {\n-      def_fn(id, _) { ret id; }\n-      def_obj_field(id) { ret id; }\n-      def_mod(id) { ret id; }\n-      def_native_mod(id) { ret id; }\n-      def_const(id) { ret id; }\n-      def_arg(id) { ret id; }\n-      def_local(id) { ret id; }\n-      def_variant(_, id) { ret id; }\n-      def_ty(id) { ret id; }\n-      def_ty_arg(_, _) { fail; }\n-      def_binding(id) { ret id; }\n-      def_use(id) { ret id; }\n-      def_native_ty(id) { ret id; }\n-      def_native_fn(id) { ret id; }\n-      def_upvar(id, _) { ret id; }\n-    }\n-}\n-\n // The set of meta_items that define the compilation environment of the crate,\n // used to drive conditional compilation\n type crate_cfg = [@meta_item];\n@@ -138,41 +100,6 @@ tag pat_ {\n \n type pat_id_map = std::map::hashmap<str, ast::node_id>;\n \n-// This is used because same-named variables in alternative patterns need to\n-// use the node_id of their namesake in the first pattern.\n-fn pat_id_map(pat: &@pat) -> pat_id_map {\n-    let map = std::map::new_str_hash::<node_id>();\n-    for each bound in pat_bindings(pat) {\n-        let name = alt bound.node { pat_bind(n) { n } };\n-        map.insert(name, bound.id);\n-    }\n-    ret map;\n-}\n-\n-// FIXME: could return a constrained type\n-iter pat_bindings(pat: &@pat) -> @pat {\n-    alt pat.node {\n-      pat_bind(_) { put pat; }\n-      pat_tag(_, sub) {\n-        for p in sub { for each b in pat_bindings(p) { put b; } }\n-      }\n-      pat_rec(fields, _) {\n-        for f in fields { for each b in pat_bindings(f.pat) { put b; } }\n-      }\n-      pat_tup(elts) {\n-        for elt in elts { for each b in pat_bindings(elt) { put b; } }\n-      }\n-      pat_box(sub) { for each b in pat_bindings(sub) { put b; } }\n-      pat_wild. | pat_lit(_) { }\n-    }\n-}\n-\n-fn pat_binding_ids(pat: &@pat) -> [node_id] {\n-    let found = [];\n-    for each b in pat_bindings(pat) { found += [b.id]; }\n-    ret found;\n-}\n-\n tag mutability { mut; imm; maybe_mut; }\n \n tag kind { kind_pinned; kind_shared; kind_unique; }\n@@ -203,45 +130,8 @@ tag binop {\n     gt;\n }\n \n-fn binop_to_str(op: binop) -> str {\n-    alt op {\n-      add. { ret \"+\"; }\n-      sub. { ret \"-\"; }\n-      mul. { ret \"*\"; }\n-      div. { ret \"/\"; }\n-      rem. { ret \"%\"; }\n-      and. { ret \"&&\"; }\n-      or. { ret \"||\"; }\n-      bitxor. { ret \"^\"; }\n-      bitand. { ret \"&\"; }\n-      bitor. { ret \"|\"; }\n-      lsl. { ret \"<<\"; }\n-      lsr. { ret \">>\"; }\n-      asr. { ret \">>>\"; }\n-      eq. { ret \"==\"; }\n-      lt. { ret \"<\"; }\n-      le. { ret \"<=\"; }\n-      ne. { ret \"!=\"; }\n-      ge. { ret \">=\"; }\n-      gt. { ret \">\"; }\n-    }\n-}\n-\n-pred lazy_binop(b: binop) -> bool {\n-    alt b { and. { true } or. { true } _ { false } }\n-}\n-\n tag unop { box(mutability); deref; not; neg; }\n \n-fn unop_to_str(op: unop) -> str {\n-    alt op {\n-      box(mt) { if mt == mut { ret \"@mutable \"; } ret \"@\"; }\n-      deref. { ret \"*\"; }\n-      not. { ret \"!\"; }\n-      neg. { ret \"-\"; }\n-    }\n-}\n-\n tag mode { val; alias(bool); move; }\n \n type stmt = spanned<stmt_>;\n@@ -358,11 +248,6 @@ tag lit_ {\n     lit_bool(bool);\n }\n \n-fn is_path(e: &@expr) -> bool {\n-    ret alt e.node { expr_path(_) { true } _ { false } };\n-}\n-\n-\n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n type mt = {ty: @ty, mut: mutability};\n@@ -398,21 +283,6 @@ tag ty_mach {\n     ty_f64;\n }\n \n-fn ty_mach_to_str(tm: ty_mach) -> str {\n-    alt tm {\n-      ty_u8. { ret \"u8\"; }\n-      ty_u16. { ret \"u16\"; }\n-      ty_u32. { ret \"u32\"; }\n-      ty_u64. { ret \"u64\"; }\n-      ty_i8. { ret \"i8\"; }\n-      ty_i16. { ret \"i16\"; }\n-      ty_i32. { ret \"i32\"; }\n-      ty_i64. { ret \"i64\"; }\n-      ty_f32. { ret \"f32\"; }\n-      ty_f64. { ret \"f64\"; }\n-    }\n-}\n-\n type ty = spanned<ty_>;\n \n tag ty_ {\n@@ -618,79 +488,6 @@ tag native_item_ {\n     native_item_fn(option::t<str>, fn_decl, [ty_param]);\n }\n \n-fn is_exported(i: ident, m: _mod) -> bool {\n-    let nonlocal = true;\n-    for it: @ast::item in m.items {\n-        if it.ident == i { nonlocal = false; }\n-        alt it.node {\n-          item_tag(variants, _) {\n-            for v: variant in variants {\n-                if v.node.name == i { nonlocal = false; }\n-            }\n-          }\n-          _ { }\n-        }\n-        if !nonlocal { break; }\n-    }\n-    let count = 0u;\n-    for vi: @ast::view_item in m.view_items {\n-        alt vi.node {\n-          ast::view_item_export(ids, _) {\n-            for id in ids { if str::eq(i, id) { ret true; } }\n-            count += 1u;\n-          }\n-          _ {/* fall through */ }\n-        }\n-    }\n-    // If there are no declared exports then\n-    // everything not imported is exported\n-    // even if it's nonlocal (since it's explicit)\n-    ret count == 0u && !nonlocal;\n-}\n-\n-fn is_call_expr(e: @expr) -> bool {\n-    alt e.node { expr_call(_, _) { ret true; } _ { ret false; } }\n-}\n-\n-fn is_constraint_arg(e: @expr) -> bool {\n-    alt e.node {\n-      expr_lit(_) { ret true; }\n-      expr_path(_) { ret true; }\n-      _ { ret false; }\n-    }\n-}\n-\n-fn eq_ty(a: &@ty, b: &@ty) -> bool { ret std::box::ptr_eq(a, b); }\n-\n-fn hash_ty(t: &@ty) -> uint { ret t.span.lo << 16u + t.span.hi; }\n-\n-fn block_from_expr(e: @expr) -> blk {\n-    let blk_ = {stmts: [], expr: option::some::<@expr>(e), id: e.id};\n-    ret {node: blk_, span: e.span};\n-}\n-\n-\n-fn obj_field_from_anon_obj_field(f: &anon_obj_field) -> obj_field {\n-    ret {mut: f.mut, ty: f.ty, ident: f.ident, id: f.id};\n-}\n-\n-// This is a convenience function to transfor ternary expressions to if\n-// expressions so that they can be treated the same\n-fn ternary_to_if(e: &@expr) -> @ast::expr {\n-    alt e.node {\n-      expr_ternary(cond, then, els) {\n-        let then_blk = block_from_expr(then);\n-        let els_blk = block_from_expr(els);\n-        let els_expr =\n-            @{id: els.id, node: expr_block(els_blk), span: els.span};\n-        ret @{id: e.id,\n-              node: expr_if(cond, then_blk, option::some(els_expr)),\n-              span: e.span};\n-      }\n-      _ { fail; }\n-    }\n-}\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "e3b16702b7624f7a7992527aba03a253f0bba14e", "filename": "src/comp/syntax/ast_util.rs", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -0,0 +1,209 @@\n+import std::str;\n+import std::option;\n+import codemap::span;\n+import ast::*;\n+\n+fn respan<T>(sp: &span, t: &T) -> spanned<T> { ret {node: t, span: sp}; }\n+\n+/* assuming that we're not in macro expansion */\n+fn mk_sp(lo: uint, hi: uint) -> span {\n+    ret {lo: lo, hi: hi, expanded_from: codemap::os_none};\n+}\n+\n+// make this a const, once the compiler supports it\n+fn dummy_sp() -> span { ret mk_sp(0u, 0u); }\n+\n+fn path_name(p: &path) -> str { path_name_i(p.node.idents) }\n+\n+fn path_name_i(idents: &[ident]) -> str { str::connect(idents, \"::\") }\n+\n+fn local_def(id: node_id) -> def_id { ret {crate: local_crate, node: id}; }\n+\n+fn variant_def_ids(d: &def) -> {tg: def_id, var: def_id} {\n+    alt d { def_variant(tag_id, var_id) { ret {tg: tag_id, var: var_id}; } }\n+}\n+\n+fn def_id_of_def(d: def) -> def_id {\n+    alt d {\n+      def_fn(id, _) { ret id; }\n+      def_obj_field(id) { ret id; }\n+      def_mod(id) { ret id; }\n+      def_native_mod(id) { ret id; }\n+      def_const(id) { ret id; }\n+      def_arg(id) { ret id; }\n+      def_local(id) { ret id; }\n+      def_variant(_, id) { ret id; }\n+      def_ty(id) { ret id; }\n+      def_ty_arg(_, _) { fail; }\n+      def_binding(id) { ret id; }\n+      def_use(id) { ret id; }\n+      def_native_ty(id) { ret id; }\n+      def_native_fn(id) { ret id; }\n+      def_upvar(id, _) { ret id; }\n+    }\n+}\n+\n+// This is used because same-named variables in alternative patterns need to\n+// use the node_id of their namesake in the first pattern.\n+fn pat_id_map(pat: &@pat) -> pat_id_map {\n+    let map = std::map::new_str_hash::<node_id>();\n+    for each bound in pat_bindings(pat) {\n+        let name = alt bound.node { pat_bind(n) { n } };\n+        map.insert(name, bound.id);\n+    }\n+    ret map;\n+}\n+\n+// FIXME: could return a constrained type\n+iter pat_bindings(pat: &@pat) -> @pat {\n+    alt pat.node {\n+      pat_bind(_) { put pat; }\n+      pat_tag(_, sub) {\n+        for p in sub { for each b in pat_bindings(p) { put b; } }\n+      }\n+      pat_rec(fields, _) {\n+        for f in fields { for each b in pat_bindings(f.pat) { put b; } }\n+      }\n+      pat_tup(elts) {\n+        for elt in elts { for each b in pat_bindings(elt) { put b; } }\n+      }\n+      pat_box(sub) { for each b in pat_bindings(sub) { put b; } }\n+      pat_wild. | pat_lit(_) { }\n+    }\n+}\n+\n+fn pat_binding_ids(pat: &@pat) -> [node_id] {\n+    let found = [];\n+    for each b in pat_bindings(pat) { found += [b.id]; }\n+    ret found;\n+}\n+\n+fn binop_to_str(op: binop) -> str {\n+    alt op {\n+      add. { ret \"+\"; }\n+      sub. { ret \"-\"; }\n+      mul. { ret \"*\"; }\n+      div. { ret \"/\"; }\n+      rem. { ret \"%\"; }\n+      and. { ret \"&&\"; }\n+      or. { ret \"||\"; }\n+      bitxor. { ret \"^\"; }\n+      bitand. { ret \"&\"; }\n+      bitor. { ret \"|\"; }\n+      lsl. { ret \"<<\"; }\n+      lsr. { ret \">>\"; }\n+      asr. { ret \">>>\"; }\n+      eq. { ret \"==\"; }\n+      lt. { ret \"<\"; }\n+      le. { ret \"<=\"; }\n+      ne. { ret \"!=\"; }\n+      ge. { ret \">=\"; }\n+      gt. { ret \">\"; }\n+    }\n+}\n+\n+pred lazy_binop(b: binop) -> bool {\n+    alt b { and. { true } or. { true } _ { false } }\n+}\n+\n+fn unop_to_str(op: unop) -> str {\n+    alt op {\n+      box(mt) { if mt == mut { ret \"@mutable \"; } ret \"@\"; }\n+      deref. { ret \"*\"; }\n+      not. { ret \"!\"; }\n+      neg. { ret \"-\"; }\n+    }\n+}\n+\n+fn is_path(e: &@expr) -> bool {\n+    ret alt e.node { expr_path(_) { true } _ { false } };\n+}\n+\n+fn ty_mach_to_str(tm: ty_mach) -> str {\n+    alt tm {\n+      ty_u8. { ret \"u8\"; }\n+      ty_u16. { ret \"u16\"; }\n+      ty_u32. { ret \"u32\"; }\n+      ty_u64. { ret \"u64\"; }\n+      ty_i8. { ret \"i8\"; }\n+      ty_i16. { ret \"i16\"; }\n+      ty_i32. { ret \"i32\"; }\n+      ty_i64. { ret \"i64\"; }\n+      ty_f32. { ret \"f32\"; }\n+      ty_f64. { ret \"f64\"; }\n+    }\n+}\n+\n+\n+fn is_exported(i: ident, m: _mod) -> bool {\n+    let nonlocal = true;\n+    for it: @ast::item in m.items {\n+        if it.ident == i { nonlocal = false; }\n+        alt it.node {\n+          item_tag(variants, _) {\n+            for v: variant in variants {\n+                if v.node.name == i { nonlocal = false; }\n+            }\n+          }\n+          _ { }\n+        }\n+        if !nonlocal { break; }\n+    }\n+    let count = 0u;\n+    for vi: @ast::view_item in m.view_items {\n+        alt vi.node {\n+          ast::view_item_export(ids, _) {\n+            for id in ids { if str::eq(i, id) { ret true; } }\n+            count += 1u;\n+          }\n+          _ {/* fall through */ }\n+        }\n+    }\n+    // If there are no declared exports then\n+    // everything not imported is exported\n+    // even if it's nonlocal (since it's explicit)\n+    ret count == 0u && !nonlocal;\n+}\n+\n+fn is_call_expr(e: @expr) -> bool {\n+    alt e.node { expr_call(_, _) { ret true; } _ { ret false; } }\n+}\n+\n+fn is_constraint_arg(e: @expr) -> bool {\n+    alt e.node {\n+      expr_lit(_) { ret true; }\n+      expr_path(_) { ret true; }\n+      _ { ret false; }\n+    }\n+}\n+\n+fn eq_ty(a: &@ty, b: &@ty) -> bool { ret std::box::ptr_eq(a, b); }\n+\n+fn hash_ty(t: &@ty) -> uint { ret t.span.lo << 16u + t.span.hi; }\n+\n+fn block_from_expr(e: @expr) -> blk {\n+    let blk_ = {stmts: [], expr: option::some::<@expr>(e), id: e.id};\n+    ret {node: blk_, span: e.span};\n+}\n+\n+\n+fn obj_field_from_anon_obj_field(f: &anon_obj_field) -> obj_field {\n+    ret {mut: f.mut, ty: f.ty, ident: f.ident, id: f.id};\n+}\n+\n+// This is a convenience function to transfor ternary expressions to if\n+// expressions so that they can be treated the same\n+fn ternary_to_if(e: &@expr) -> @ast::expr {\n+    alt e.node {\n+      expr_ternary(cond, then, els) {\n+        let then_blk = block_from_expr(then);\n+        let els_blk = block_from_expr(els);\n+        let els_expr =\n+            @{id: els.id, node: expr_block(els_blk), span: els.span};\n+        ret @{id: e.id,\n+              node: expr_if(cond, then_blk, option::some(els_expr)),\n+              span: e.span};\n+      }\n+      _ { fail; }\n+    }\n+}"}, {"sha": "fb4402732ae02a50a29ffd1fa5652696413918f7", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -16,7 +16,7 @@ import base::expr_to_ident;\n \n import fold::*;\n import ast::node_id;\n-import ast::respan;\n+import ast_util::respan;\n import ast::ident;\n import ast::path;\n import ast::ty;"}, {"sha": "c39cd75db3be74737b8c38181e20d2260a9ed2fd", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -78,7 +78,7 @@ fn new_reader(cm: &codemap::codemap, src: str, filemap: codemap::filemap,\n         fn get_col() -> uint { ret col; }\n         fn get_filemap() -> codemap::filemap { ret fm; }\n         fn err(m: str) {\n-            codemap::emit_error(some(ast::mk_sp(chpos, chpos)), m, cm);\n+            codemap::emit_error(some(ast_util::mk_sp(chpos, chpos)), m, cm);\n         }\n     }\n     let strs: [str] = [];"}, {"sha": "527f69270104a602459ed129ee189c47abd3ee69", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -90,7 +90,7 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n             if vec::len(buffer) == 0u {\n                 let next = lexer::next_token(rdr);\n                 tok = next.tok;\n-                tok_span = ast::mk_sp(next.chpos, rdr.get_chpos());\n+                tok_span = ast_util::mk_sp(next.chpos, rdr.get_chpos());\n             } else {\n                 let next = vec::pop(buffer);\n                 tok = next.tok;\n@@ -99,12 +99,12 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n         }\n         fn swap(next: token::token, lo: uint, hi: uint) {\n             tok = next;\n-            tok_span = ast::mk_sp(lo, hi);\n+            tok_span = ast_util::mk_sp(lo, hi);\n         }\n         fn look_ahead(distance: uint) -> token::token {\n             while vec::len(buffer) < distance {\n                 let next = lexer::next_token(rdr);\n-                let sp = ast::mk_sp(next.chpos, rdr.get_chpos());\n+                let sp = ast_util::mk_sp(next.chpos, rdr.get_chpos());\n                 buffer = [{tok: next.tok, span: sp}] + buffer;\n             }\n             ret buffer[distance - 1u].tok;\n@@ -139,7 +139,7 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n     }\n \n     let tok0 = lexer::next_token(rdr);\n-    let span0 = ast::mk_sp(tok0.chpos, rdr.get_chpos());\n+    let span0 = ast_util::mk_sp(tok0.chpos, rdr.get_chpos());\n     ret stdio_parser(sess, cfg, ftype, tok0.tok, span0, span0, [],\n                      UNRESTRICTED, rdr, prec_table(), bad_expr_word_table());\n }\n@@ -223,7 +223,7 @@ fn expect_gt(p: &parser) {\n }\n \n fn spanned<T>(lo: uint, hi: uint, node: &T) -> spanned<T> {\n-    ret {node: node, span: ast::mk_sp(lo, hi)};\n+    ret {node: node, span: ast_util::mk_sp(lo, hi)};\n }\n \n fn parse_ident(p: &parser) -> ast::ident {\n@@ -792,13 +792,13 @@ fn parse_field(p: &parser, sep: &token::token) -> ast::field {\n }\n \n fn mk_expr(p: &parser, lo: uint, hi: uint, node: &ast::expr_) -> @ast::expr {\n-    ret @{id: p.get_id(), node: node, span: ast::mk_sp(lo, hi)};\n+    ret @{id: p.get_id(), node: node, span: ast_util::mk_sp(lo, hi)};\n }\n \n fn mk_mac_expr(p: &parser, lo: uint, hi: uint, m: &ast::mac_) -> @ast::expr {\n     ret @{id: p.get_id(),\n-          node: ast::expr_mac({node: m, span: ast::mk_sp(lo, hi)}),\n-          span: ast::mk_sp(lo, hi)};\n+          node: ast::expr_mac({node: m, span: ast_util::mk_sp(lo, hi)}),\n+          span: ast_util::mk_sp(lo, hi)};\n }\n \n fn parse_bottom_expr(p: &parser) -> @ast::expr {\n@@ -999,7 +999,7 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n         let e = parse_expr(p);\n \n         // FIXME: Is this the right place for this check?\n-        if /*check*/ast::is_call_expr(e) {\n+        if /*check*/ast_util::is_call_expr(e) {\n             hi = e.span.hi;\n             ex = ast::expr_be(e);\n         } else { p.fatal(\"Non-call expression in tail call\"); }\n@@ -1460,7 +1460,7 @@ fn parse_pat(p: &parser) -> @ast::pat {\n                 subpat =\n                     @{id: p.get_id(),\n                       node: ast::pat_bind(fieldname),\n-                      span: ast::mk_sp(lo, hi)};\n+                      span: ast_util::mk_sp(lo, hi)};\n             }\n             fields += [{ident: fieldname, pat: subpat}];\n         }\n@@ -1474,7 +1474,8 @@ fn parse_pat(p: &parser) -> @ast::pat {\n             hi = p.get_hi_pos();\n             p.bump();\n             pat =\n-                ast::pat_lit(@{node: ast::lit_nil, span: ast::mk_sp(lo, hi)});\n+                ast::pat_lit(@{node: ast::lit_nil,\n+                               span: ast_util::mk_sp(lo, hi)});\n         } else {\n             let fields = [parse_pat(p)];\n             while p.peek() == token::COMMA {\n@@ -1520,7 +1521,7 @@ fn parse_pat(p: &parser) -> @ast::pat {\n         }\n       }\n     }\n-    ret @{id: p.get_id(), node: pat, span: ast::mk_sp(lo, hi)};\n+    ret @{id: p.get_id(), node: pat, span: ast_util::mk_sp(lo, hi)};\n }\n \n fn parse_local(p: &parser, allow_init: bool) -> @ast::local {\n@@ -1808,7 +1809,7 @@ fn mk_item(p: &parser, lo: uint, hi: uint, ident: &ast::ident,\n           attrs: attrs,\n           id: p.get_id(),\n           node: node,\n-          span: ast::mk_sp(lo, hi)};\n+          span: ast_util::mk_sp(lo, hi)};\n }\n \n fn parse_item_fn_or_iter(p: &parser, purity: ast::purity, proto: ast::proto,\n@@ -1945,7 +1946,7 @@ fn parse_item_native_type(p: &parser, attrs: &[ast::attribute]) ->\n           attrs: attrs,\n           node: ast::native_item_ty,\n           id: p.get_id(),\n-          span: ast::mk_sp(t.lo, hi)};\n+          span: ast_util::mk_sp(t.lo, hi)};\n }\n \n fn parse_item_native_fn(p: &parser, attrs: &[ast::attribute]) ->\n@@ -1961,7 +1962,7 @@ fn parse_item_native_fn(p: &parser, attrs: &[ast::attribute]) ->\n           attrs: attrs,\n           node: ast::native_item_fn(link_name, decl, t.tps),\n           id: p.get_id(),\n-          span: ast::mk_sp(lo, hi)};\n+          span: ast_util::mk_sp(lo, hi)};\n }\n \n fn parse_native_item(p: &parser, attrs: &[ast::attribute]) ->"}, {"sha": "cf20e0a328e6262cb1542ec3babd3d4cdd71069c", "filename": "src/comp/syntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -1,6 +1,6 @@\n \n import ast::ty_mach;\n-import ast::ty_mach_to_str;\n+import ast_util::ty_mach_to_str;\n import std::map::new_str_hash;\n import util::interner;\n import std::int;"}, {"sha": "f0848fbdce5142fda10053890a5f385f99c27cd4", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -9,6 +9,7 @@ import parse::lexer;\n import syntax::codemap::codemap;\n import syntax::visit;\n import ast;\n+import ast_util;\n import option::some;\n import option::none;\n import pp::printer;\n@@ -271,7 +272,7 @@ fn print_type(s: &ps, ty: &@ast::ty) {\n       ast::ty_int. { word(s.s, \"int\"); }\n       ast::ty_uint. { word(s.s, \"uint\"); }\n       ast::ty_float. { word(s.s, \"float\"); }\n-      ast::ty_machine(tm) { word(s.s, ast::ty_mach_to_str(tm)); }\n+      ast::ty_machine(tm) { word(s.s, ast_util::ty_mach_to_str(tm)); }\n       ast::ty_char. { word(s.s, \"char\"); }\n       ast::ty_str. { word(s.s, \"str\"); }\n       ast::ty_istr. { word(s.s, \"istr\"); }\n@@ -831,11 +832,11 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n         let prec = operator_prec(op);\n         print_maybe_parens(s, lhs, prec);\n         space(s.s);\n-        word_space(s, ast::binop_to_str(op));\n+        word_space(s, ast_util::binop_to_str(op));\n         print_maybe_parens(s, rhs, prec + 1);\n       }\n       ast::expr_unary(op, expr) {\n-        word(s.s, ast::unop_to_str(op));\n+        word(s.s, ast_util::unop_to_str(op));\n         print_maybe_parens(s, expr, parse::parser::unop_prec);\n       }\n       ast::expr_lit(lit) { print_literal(s, lit); }\n@@ -967,7 +968,7 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n       ast::expr_assign_op(op, lhs, rhs) {\n         print_expr(s, lhs);\n         space(s.s);\n-        word(s.s, ast::binop_to_str(op));\n+        word(s.s, ast_util::binop_to_str(op));\n         word_space(s, \"=\");\n         print_expr(s, rhs);\n       }\n@@ -1486,12 +1487,12 @@ fn print_literal(s: &ps, lit: &@ast::lit) {\n       ast::lit_float(fstr) { word(s.s, fstr); }\n       ast::lit_mach_int(mach, val) {\n         word(s.s, int::str(val as int));\n-        word(s.s, ast::ty_mach_to_str(mach));\n+        word(s.s, ast_util::ty_mach_to_str(mach));\n       }\n       ast::lit_mach_float(mach, val) {\n         // val is already a str\n         word(s.s, val);\n-        word(s.s, ast::ty_mach_to_str(mach));\n+        word(s.s, ast_util::ty_mach_to_str(mach));\n       }\n       ast::lit_nil. { word(s.s, \"()\"); }\n       ast::lit_bool(val) {"}, {"sha": "a37e64cfb0a307a22fb6bb87fb88432032162593", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/152cbaade7bc2ec36546554eb2d2090a9833bfff/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=152cbaade7bc2ec36546554eb2d2090a9833bfff", "patch": "@@ -16,7 +16,7 @@ import pp::word;\n import pp::eof;\n import pp::zerobreak;\n import pp::hardbreak;\n-import ast::ty_mach_to_str;\n+import syntax::ast_util::ty_mach_to_str;\n import syntax::ast;\n import middle::ast_map;\n import metadata::csearch;"}]}