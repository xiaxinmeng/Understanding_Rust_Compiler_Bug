{"sha": "608b5e1c209ffb4d6d0cf83817c823b12bbb7659", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwOGI1ZTFjMjA5ZmZiNGQ2ZDBjZjgzODE3YzgyM2IxMmJiYjc2NTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-01T06:13:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-01T06:13:15Z"}, "message": "Auto merge of #88272 - willcrichton:mutable-sparse-matrix, r=ecstatic-morse\n\nAdd bit removal methods to SparseBitMatrix and factor *BitSet relational methods into more extensible trait\n\nI need the ability to clear the bits out of a row from `SparseBitMatrix`. Currently, all the mutating methods only allow insertion of bits, and there is no way to get access to the underlying data.\n\nOne approach is simply to make `ensure_row` public, since it grants `&mut` access to the underlying `HybridBitSet`. This PR adds the `pub` modifier. However, presumably this method was private for a reason, so I'm open to other designs. I would prefer general mutable access to the rows, because that way I can add many mutating operations (`clear`, `intersect`, etc.) without filing a PR each time :-)\n\nr? `@ecstatic-morse`", "tree": {"sha": "ca7f8941b59b8cec5b0ff28af68f7b581ea8cdd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca7f8941b59b8cec5b0ff28af68f7b581ea8cdd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/608b5e1c209ffb4d6d0cf83817c823b12bbb7659", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/608b5e1c209ffb4d6d0cf83817c823b12bbb7659", "html_url": "https://github.com/rust-lang/rust/commit/608b5e1c209ffb4d6d0cf83817c823b12bbb7659", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/608b5e1c209ffb4d6d0cf83817c823b12bbb7659/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4f26b15e37101c54829efab456922a53e3103ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4f26b15e37101c54829efab456922a53e3103ad", "html_url": "https://github.com/rust-lang/rust/commit/c4f26b15e37101c54829efab456922a53e3103ad"}, {"sha": "e340a0e249c2efc069235c9db47e47c3e136570c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e340a0e249c2efc069235c9db47e47c3e136570c", "html_url": "https://github.com/rust-lang/rust/commit/e340a0e249c2efc069235c9db47e47c3e136570c"}], "stats": {"total": 515, "additions": 386, "deletions": 129}, "files": [{"sha": "aeb3f9970ab9e6a0cda3cb926d1dc54117c30818", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 291, "deletions": 122, "changes": 413, "blob_url": "https://github.com/rust-lang/rust/blob/608b5e1c209ffb4d6d0cf83817c823b12bbb7659/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608b5e1c209ffb4d6d0cf83817c823b12bbb7659/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=608b5e1c209ffb4d6d0cf83817c823b12bbb7659", "patch": "@@ -16,6 +16,43 @@ pub type Word = u64;\n pub const WORD_BYTES: usize = mem::size_of::<Word>();\n pub const WORD_BITS: usize = WORD_BYTES * 8;\n \n+pub trait BitRelations<Rhs> {\n+    fn union(&mut self, other: &Rhs) -> bool;\n+    fn subtract(&mut self, other: &Rhs) -> bool;\n+    fn intersect(&mut self, other: &Rhs) -> bool;\n+}\n+\n+macro_rules! bit_relations_inherent_impls {\n+    () => {\n+        /// Sets `self = self | other` and returns `true` if `self` changed\n+        /// (i.e., if new bits were added).\n+        pub fn union<Rhs>(&mut self, other: &Rhs) -> bool\n+        where\n+            Self: BitRelations<Rhs>,\n+        {\n+            <Self as BitRelations<Rhs>>::union(self, other)\n+        }\n+\n+        /// Sets `self = self - other` and returns `true` if `self` changed.\n+        /// (i.e., if any bits were removed).\n+        pub fn subtract<Rhs>(&mut self, other: &Rhs) -> bool\n+        where\n+            Self: BitRelations<Rhs>,\n+        {\n+            <Self as BitRelations<Rhs>>::subtract(self, other)\n+        }\n+\n+        /// Sets `self = self & other` and return `true` if `self` changed.\n+        /// (i.e., if any bits were removed).\n+        pub fn intersect<Rhs>(&mut self, other: &Rhs) -> bool\n+        where\n+            Self: BitRelations<Rhs>,\n+        {\n+            <Self as BitRelations<Rhs>>::intersect(self, other)\n+        }\n+    };\n+}\n+\n /// A fixed-size bitset type with a dense representation.\n ///\n /// NOTE: Use [`GrowableBitSet`] if you need support for resizing after creation.\n@@ -134,25 +171,6 @@ impl<T: Idx> BitSet<T> {\n         new_word != word\n     }\n \n-    /// Sets `self = self | other` and returns `true` if `self` changed\n-    /// (i.e., if new bits were added).\n-    pub fn union(&mut self, other: &impl UnionIntoBitSet<T>) -> bool {\n-        other.union_into(self)\n-    }\n-\n-    /// Sets `self = self - other` and returns `true` if `self` changed.\n-    /// (i.e., if any bits were removed).\n-    pub fn subtract(&mut self, other: &impl SubtractFromBitSet<T>) -> bool {\n-        other.subtract_from(self)\n-    }\n-\n-    /// Sets `self = self & other` and return `true` if `self` changed.\n-    /// (i.e., if any bits were removed).\n-    pub fn intersect(&mut self, other: &BitSet<T>) -> bool {\n-        assert_eq!(self.domain_size, other.domain_size);\n-        bitwise(&mut self.words, &other.words, |a, b| a & b)\n-    }\n-\n     /// Gets a slice of the underlying words.\n     pub fn words(&self) -> &[Word] {\n         &self.words\n@@ -208,33 +226,208 @@ impl<T: Idx> BitSet<T> {\n \n         not_already\n     }\n+\n+    bit_relations_inherent_impls! {}\n }\n \n-/// This is implemented by all the bitsets so that BitSet::union() can be\n-/// passed any type of bitset.\n-pub trait UnionIntoBitSet<T: Idx> {\n-    // Performs `other = other | self`.\n-    fn union_into(&self, other: &mut BitSet<T>) -> bool;\n+// dense REL dense\n+impl<T: Idx> BitRelations<BitSet<T>> for BitSet<T> {\n+    fn union(&mut self, other: &BitSet<T>) -> bool {\n+        assert_eq!(self.domain_size, other.domain_size);\n+        bitwise(&mut self.words, &other.words, |a, b| a | b)\n+    }\n+\n+    fn subtract(&mut self, other: &BitSet<T>) -> bool {\n+        assert_eq!(self.domain_size, other.domain_size);\n+        bitwise(&mut self.words, &other.words, |a, b| a & !b)\n+    }\n+\n+    fn intersect(&mut self, other: &BitSet<T>) -> bool {\n+        assert_eq!(self.domain_size, other.domain_size);\n+        bitwise(&mut self.words, &other.words, |a, b| a & b)\n+    }\n }\n \n-/// This is implemented by all the bitsets so that BitSet::subtract() can be\n-/// passed any type of bitset.\n-pub trait SubtractFromBitSet<T: Idx> {\n-    // Performs `other = other - self`.\n-    fn subtract_from(&self, other: &mut BitSet<T>) -> bool;\n+// Applies a function to mutate a bitset, and returns true if any\n+// of the applications return true\n+fn sequential_update<T: Idx>(\n+    mut self_update: impl FnMut(T) -> bool,\n+    it: impl Iterator<Item = T>,\n+) -> bool {\n+    let mut changed = false;\n+    for elem in it {\n+        changed |= self_update(elem);\n+    }\n+    changed\n }\n \n-impl<T: Idx> UnionIntoBitSet<T> for BitSet<T> {\n-    fn union_into(&self, other: &mut BitSet<T>) -> bool {\n-        assert_eq!(self.domain_size, other.domain_size);\n-        bitwise(&mut other.words, &self.words, |a, b| a | b)\n+// Optimization of intersection for SparseBitSet that's generic\n+// over the RHS\n+fn sparse_intersect<T: Idx>(\n+    set: &mut SparseBitSet<T>,\n+    other_contains: impl Fn(&T) -> bool,\n+) -> bool {\n+    let size = set.elems.len();\n+    set.elems.retain(|elem| other_contains(elem));\n+    set.elems.len() != size\n+}\n+\n+// Optimization of dense/sparse intersection. The resulting set is\n+// guaranteed to be at most the size of the sparse set, and hence can be\n+// represented as a sparse set. Therefore the sparse set is copied and filtered,\n+// then returned as the new set.\n+fn dense_sparse_intersect<T: Idx>(\n+    dense: &BitSet<T>,\n+    sparse: &SparseBitSet<T>,\n+) -> (SparseBitSet<T>, bool) {\n+    let mut sparse_copy = sparse.clone();\n+    sparse_intersect(&mut sparse_copy, |el| dense.contains(*el));\n+    let n = sparse_copy.len();\n+    (sparse_copy, n != dense.count())\n+}\n+\n+// hybrid REL dense\n+impl<T: Idx> BitRelations<BitSet<T>> for HybridBitSet<T> {\n+    fn union(&mut self, other: &BitSet<T>) -> bool {\n+        assert_eq!(self.domain_size(), other.domain_size);\n+        match self {\n+            HybridBitSet::Sparse(sparse) => {\n+                // `self` is sparse and `other` is dense. To\n+                // merge them, we have two available strategies:\n+                // * Densify `self` then merge other\n+                // * Clone other then integrate bits from `self`\n+                // The second strategy requires dedicated method\n+                // since the usual `union` returns the wrong\n+                // result. In the dedicated case the computation\n+                // is slightly faster if the bits of the sparse\n+                // bitset map to only few words of the dense\n+                // representation, i.e. indices are near each\n+                // other.\n+                //\n+                // Benchmarking seems to suggest that the second\n+                // option is worth it.\n+                let mut new_dense = other.clone();\n+                let changed = new_dense.reverse_union_sparse(sparse);\n+                *self = HybridBitSet::Dense(new_dense);\n+                changed\n+            }\n+\n+            HybridBitSet::Dense(dense) => dense.union(other),\n+        }\n+    }\n+\n+    fn subtract(&mut self, other: &BitSet<T>) -> bool {\n+        assert_eq!(self.domain_size(), other.domain_size);\n+        match self {\n+            HybridBitSet::Sparse(sparse) => {\n+                sequential_update(|elem| sparse.remove(elem), other.iter())\n+            }\n+            HybridBitSet::Dense(dense) => dense.subtract(other),\n+        }\n+    }\n+\n+    fn intersect(&mut self, other: &BitSet<T>) -> bool {\n+        assert_eq!(self.domain_size(), other.domain_size);\n+        match self {\n+            HybridBitSet::Sparse(sparse) => sparse_intersect(sparse, |elem| other.contains(*elem)),\n+            HybridBitSet::Dense(dense) => dense.intersect(other),\n+        }\n     }\n }\n \n-impl<T: Idx> SubtractFromBitSet<T> for BitSet<T> {\n-    fn subtract_from(&self, other: &mut BitSet<T>) -> bool {\n-        assert_eq!(self.domain_size, other.domain_size);\n-        bitwise(&mut other.words, &self.words, |a, b| a & !b)\n+// dense REL hybrid\n+impl<T: Idx> BitRelations<HybridBitSet<T>> for BitSet<T> {\n+    fn union(&mut self, other: &HybridBitSet<T>) -> bool {\n+        assert_eq!(self.domain_size, other.domain_size());\n+        match other {\n+            HybridBitSet::Sparse(sparse) => {\n+                sequential_update(|elem| self.insert(elem), sparse.iter().cloned())\n+            }\n+            HybridBitSet::Dense(dense) => self.union(dense),\n+        }\n+    }\n+\n+    fn subtract(&mut self, other: &HybridBitSet<T>) -> bool {\n+        assert_eq!(self.domain_size, other.domain_size());\n+        match other {\n+            HybridBitSet::Sparse(sparse) => {\n+                sequential_update(|elem| self.remove(elem), sparse.iter().cloned())\n+            }\n+            HybridBitSet::Dense(dense) => self.subtract(dense),\n+        }\n+    }\n+\n+    fn intersect(&mut self, other: &HybridBitSet<T>) -> bool {\n+        assert_eq!(self.domain_size, other.domain_size());\n+        match other {\n+            HybridBitSet::Sparse(sparse) => {\n+                let (updated, changed) = dense_sparse_intersect(self, sparse);\n+\n+                // We can't directly assign the SparseBitSet to the BitSet, and\n+                // doing `*self = updated.to_dense()` would cause a drop / reallocation. Instead,\n+                // the BitSet is cleared and `updated` is copied into `self`.\n+                self.clear();\n+                for elem in updated.iter() {\n+                    self.insert(*elem);\n+                }\n+                changed\n+            }\n+            HybridBitSet::Dense(dense) => self.intersect(dense),\n+        }\n+    }\n+}\n+\n+// hybrid REL hybrid\n+impl<T: Idx> BitRelations<HybridBitSet<T>> for HybridBitSet<T> {\n+    fn union(&mut self, other: &HybridBitSet<T>) -> bool {\n+        assert_eq!(self.domain_size(), other.domain_size());\n+        match self {\n+            HybridBitSet::Sparse(_) => {\n+                match other {\n+                    HybridBitSet::Sparse(other_sparse) => {\n+                        // Both sets are sparse. Add the elements in\n+                        // `other_sparse` to `self` one at a time. This\n+                        // may or may not cause `self` to be densified.\n+                        let mut changed = false;\n+                        for elem in other_sparse.iter() {\n+                            changed |= self.insert(*elem);\n+                        }\n+                        changed\n+                    }\n+\n+                    HybridBitSet::Dense(other_dense) => self.union(other_dense),\n+                }\n+            }\n+\n+            HybridBitSet::Dense(self_dense) => self_dense.union(other),\n+        }\n+    }\n+\n+    fn subtract(&mut self, other: &HybridBitSet<T>) -> bool {\n+        assert_eq!(self.domain_size(), other.domain_size());\n+        match self {\n+            HybridBitSet::Sparse(self_sparse) => {\n+                sequential_update(|elem| self_sparse.remove(elem), other.iter())\n+            }\n+            HybridBitSet::Dense(self_dense) => self_dense.subtract(other),\n+        }\n+    }\n+\n+    fn intersect(&mut self, other: &HybridBitSet<T>) -> bool {\n+        assert_eq!(self.domain_size(), other.domain_size());\n+        match self {\n+            HybridBitSet::Sparse(self_sparse) => {\n+                sparse_intersect(self_sparse, |elem| other.contains(*elem))\n+            }\n+            HybridBitSet::Dense(self_dense) => match other {\n+                HybridBitSet::Sparse(other_sparse) => {\n+                    let (updated, changed) = dense_sparse_intersect(self_dense, other_sparse);\n+                    *self = HybridBitSet::Sparse(updated);\n+                    changed\n+                }\n+                HybridBitSet::Dense(other_dense) => self_dense.intersect(other_dense),\n+            },\n+        }\n     }\n }\n \n@@ -441,28 +634,8 @@ impl<T: Idx> SparseBitSet<T> {\n     fn iter(&self) -> slice::Iter<'_, T> {\n         self.elems.iter()\n     }\n-}\n \n-impl<T: Idx> UnionIntoBitSet<T> for SparseBitSet<T> {\n-    fn union_into(&self, other: &mut BitSet<T>) -> bool {\n-        assert_eq!(self.domain_size, other.domain_size);\n-        let mut changed = false;\n-        for elem in self.iter() {\n-            changed |= other.insert(*elem);\n-        }\n-        changed\n-    }\n-}\n-\n-impl<T: Idx> SubtractFromBitSet<T> for SparseBitSet<T> {\n-    fn subtract_from(&self, other: &mut BitSet<T>) -> bool {\n-        assert_eq!(self.domain_size, other.domain_size);\n-        let mut changed = false;\n-        for elem in self.iter() {\n-            changed |= other.remove(*elem);\n-        }\n-        changed\n-    }\n+    bit_relations_inherent_impls! {}\n }\n \n /// A fixed-size bitset type with a hybrid representation: sparse when there\n@@ -579,48 +752,6 @@ impl<T: Idx> HybridBitSet<T> {\n         }\n     }\n \n-    pub fn union(&mut self, other: &HybridBitSet<T>) -> bool {\n-        match self {\n-            HybridBitSet::Sparse(self_sparse) => {\n-                match other {\n-                    HybridBitSet::Sparse(other_sparse) => {\n-                        // Both sets are sparse. Add the elements in\n-                        // `other_sparse` to `self` one at a time. This\n-                        // may or may not cause `self` to be densified.\n-                        assert_eq!(self.domain_size(), other.domain_size());\n-                        let mut changed = false;\n-                        for elem in other_sparse.iter() {\n-                            changed |= self.insert(*elem);\n-                        }\n-                        changed\n-                    }\n-                    HybridBitSet::Dense(other_dense) => {\n-                        // `self` is sparse and `other` is dense. To\n-                        // merge them, we have two available strategies:\n-                        // * Densify `self` then merge other\n-                        // * Clone other then integrate bits from `self`\n-                        // The second strategy requires dedicated method\n-                        // since the usual `union` returns the wrong\n-                        // result. In the dedicated case the computation\n-                        // is slightly faster if the bits of the sparse\n-                        // bitset map to only few words of the dense\n-                        // representation, i.e. indices are near each\n-                        // other.\n-                        //\n-                        // Benchmarking seems to suggest that the second\n-                        // option is worth it.\n-                        let mut new_dense = other_dense.clone();\n-                        let changed = new_dense.reverse_union_sparse(self_sparse);\n-                        *self = HybridBitSet::Dense(new_dense);\n-                        changed\n-                    }\n-                }\n-            }\n-\n-            HybridBitSet::Dense(self_dense) => self_dense.union(other),\n-        }\n-    }\n-\n     /// Converts to a dense set, consuming itself in the process.\n     pub fn to_dense(self) -> BitSet<T> {\n         match self {\n@@ -635,24 +766,8 @@ impl<T: Idx> HybridBitSet<T> {\n             HybridBitSet::Dense(dense) => HybridIter::Dense(dense.iter()),\n         }\n     }\n-}\n-\n-impl<T: Idx> UnionIntoBitSet<T> for HybridBitSet<T> {\n-    fn union_into(&self, other: &mut BitSet<T>) -> bool {\n-        match self {\n-            HybridBitSet::Sparse(sparse) => sparse.union_into(other),\n-            HybridBitSet::Dense(dense) => dense.union_into(other),\n-        }\n-    }\n-}\n \n-impl<T: Idx> SubtractFromBitSet<T> for HybridBitSet<T> {\n-    fn subtract_from(&self, other: &mut BitSet<T>) -> bool {\n-        match self {\n-            HybridBitSet::Sparse(sparse) => sparse.subtract_from(other),\n-            HybridBitSet::Dense(dense) => dense.subtract_from(other),\n-        }\n-    }\n+    bit_relations_inherent_impls! {}\n }\n \n pub enum HybridIter<'a, T: Idx> {\n@@ -974,6 +1089,26 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n         self.ensure_row(row).insert(column)\n     }\n \n+    /// Sets the cell at `(row, column)` to false. Put another way, delete\n+    /// `column` from the bitset for `row`. Has no effect if `row` does not\n+    /// exist.\n+    ///\n+    /// Returns `true` if this changed the matrix.\n+    pub fn remove(&mut self, row: R, column: C) -> bool {\n+        match self.rows.get_mut(row) {\n+            Some(Some(row)) => row.remove(column),\n+            _ => false,\n+        }\n+    }\n+\n+    /// Sets all columns at `row` to false. Has no effect if `row` does\n+    /// not exist.\n+    pub fn clear(&mut self, row: R) {\n+        if let Some(Some(row)) = self.rows.get_mut(row) {\n+            row.clear();\n+        }\n+    }\n+\n     /// Do the bits from `row` contain `column`? Put another way, is\n     /// the matrix cell at `(row, column)` true?  Put yet another way,\n     /// if the matrix represents (transitive) reachability, can\n@@ -1002,11 +1137,6 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n         }\n     }\n \n-    /// Union a row, `from`, into the `into` row.\n-    pub fn union_into_row(&mut self, into: R, from: &HybridBitSet<C>) -> bool {\n-        self.ensure_row(into).union(from)\n-    }\n-\n     /// Insert all bits in the given row.\n     pub fn insert_all_into_row(&mut self, row: R) {\n         self.ensure_row(row).insert_all();\n@@ -1025,6 +1155,45 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     pub fn row(&self, row: R) -> Option<&HybridBitSet<C>> {\n         if let Some(Some(row)) = self.rows.get(row) { Some(row) } else { None }\n     }\n+\n+    /// Interescts `row` with `set`. `set` can be either `BitSet` or\n+    /// `HybridBitSet`. Has no effect if `row` does not exist.\n+    ///\n+    /// Returns true if the row was changed.\n+    pub fn intersect_row<Set>(&mut self, row: R, set: &Set) -> bool\n+    where\n+        HybridBitSet<C>: BitRelations<Set>,\n+    {\n+        match self.rows.get_mut(row) {\n+            Some(Some(row)) => row.intersect(set),\n+            _ => false,\n+        }\n+    }\n+\n+    /// Subtracts `set from `row`. `set` can be either `BitSet` or\n+    /// `HybridBitSet`. Has no effect if `row` does not exist.\n+    ///\n+    /// Returns true if the row was changed.\n+    pub fn subtract_row<Set>(&mut self, row: R, set: &Set) -> bool\n+    where\n+        HybridBitSet<C>: BitRelations<Set>,\n+    {\n+        match self.rows.get_mut(row) {\n+            Some(Some(row)) => row.subtract(set),\n+            _ => false,\n+        }\n+    }\n+\n+    /// Unions `row` with `set`. `set` can be either `BitSet` or\n+    /// `HybridBitSet`.\n+    ///\n+    /// Returns true if the row was changed.\n+    pub fn union_row<Set>(&mut self, row: R, set: &Set) -> bool\n+    where\n+        HybridBitSet<C>: BitRelations<Set>,\n+    {\n+        self.ensure_row(row).union(set)\n+    }\n }\n \n #[inline]"}, {"sha": "aebc6d0ddd84ca9e5cd1efa4d2376e6236cffe4f", "filename": "compiler/rustc_index/src/bit_set/tests.rs", "status": "modified", "additions": 91, "deletions": 3, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/608b5e1c209ffb4d6d0cf83817c823b12bbb7659/compiler%2Frustc_index%2Fsrc%2Fbit_set%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608b5e1c209ffb4d6d0cf83817c823b12bbb7659/compiler%2Frustc_index%2Fsrc%2Fbit_set%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set%2Ftests.rs?ref=608b5e1c209ffb4d6d0cf83817c823b12bbb7659", "patch": "@@ -104,18 +104,40 @@ fn hybrid_bitset() {\n     assert!(dense10.superset(&dense10)); // dense + dense (self)\n     assert!(dense256.superset(&dense10)); // dense + dense\n \n-    let mut hybrid = sparse038;\n+    let mut hybrid = sparse038.clone();\n     assert!(!sparse01358.union(&hybrid)); // no change\n     assert!(hybrid.union(&sparse01358));\n     assert!(hybrid.superset(&sparse01358) && sparse01358.superset(&hybrid));\n-    assert!(!dense10.union(&sparse01358));\n     assert!(!dense256.union(&dense10));\n-    let mut dense = dense10;\n+\n+    // dense / sparse where dense superset sparse\n+    assert!(!dense10.clone().union(&sparse01358));\n+    assert!(sparse01358.clone().union(&dense10));\n+    assert!(dense10.clone().intersect(&sparse01358));\n+    assert!(!sparse01358.clone().intersect(&dense10));\n+    assert!(dense10.clone().subtract(&sparse01358));\n+    assert!(sparse01358.clone().subtract(&dense10));\n+\n+    // dense / sparse where sparse superset dense\n+    let dense038 = sparse038.to_dense();\n+    assert!(!sparse01358.clone().union(&dense038));\n+    assert!(dense038.clone().union(&sparse01358));\n+    assert!(sparse01358.clone().intersect(&dense038));\n+    assert!(!dense038.clone().intersect(&sparse01358));\n+    assert!(sparse01358.clone().subtract(&dense038));\n+    assert!(dense038.clone().subtract(&sparse01358));\n+\n+    let mut dense = dense10.clone();\n     assert!(dense.union(&dense256));\n     assert!(dense.superset(&dense256) && dense256.superset(&dense));\n     assert!(hybrid.union(&dense256));\n     assert!(hybrid.superset(&dense256) && dense256.superset(&hybrid));\n \n+    assert!(!dense10.clone().intersect(&dense256));\n+    assert!(dense256.clone().intersect(&dense10));\n+    assert!(dense10.clone().subtract(&dense256));\n+    assert!(dense256.clone().subtract(&dense10));\n+\n     assert_eq!(dense256.iter().count(), 256);\n     let mut dense0 = dense256;\n     for i in 0..256 {\n@@ -282,6 +304,72 @@ fn sparse_matrix_iter() {\n     assert!(iter.next().is_none());\n }\n \n+#[test]\n+fn sparse_matrix_operations() {\n+    let mut matrix: SparseBitMatrix<usize, usize> = SparseBitMatrix::new(100);\n+    matrix.insert(3, 22);\n+    matrix.insert(3, 75);\n+    matrix.insert(2, 99);\n+    matrix.insert(4, 0);\n+\n+    let mut disjoint: HybridBitSet<usize> = HybridBitSet::new_empty(100);\n+    disjoint.insert(33);\n+\n+    let mut superset = HybridBitSet::new_empty(100);\n+    superset.insert(22);\n+    superset.insert(75);\n+    superset.insert(33);\n+\n+    let mut subset = HybridBitSet::new_empty(100);\n+    subset.insert(22);\n+\n+    // SparseBitMatrix::remove\n+    {\n+        let mut matrix = matrix.clone();\n+        matrix.remove(3, 22);\n+        assert!(!matrix.row(3).unwrap().contains(22));\n+        matrix.remove(0, 0);\n+        assert!(matrix.row(0).is_none());\n+    }\n+\n+    // SparseBitMatrix::clear\n+    {\n+        let mut matrix = matrix.clone();\n+        matrix.clear(3);\n+        assert!(!matrix.row(3).unwrap().contains(75));\n+        matrix.clear(0);\n+        assert!(matrix.row(0).is_none());\n+    }\n+\n+    // SparseBitMatrix::intersect_row\n+    {\n+        let mut matrix = matrix.clone();\n+        assert!(!matrix.intersect_row(3, &superset));\n+        assert!(matrix.intersect_row(3, &subset));\n+        matrix.intersect_row(0, &disjoint);\n+        assert!(matrix.row(0).is_none());\n+    }\n+\n+    // SparseBitMatrix::subtract_row\n+    {\n+        let mut matrix = matrix.clone();\n+        assert!(!matrix.subtract_row(3, &disjoint));\n+        assert!(matrix.subtract_row(3, &subset));\n+        assert!(matrix.subtract_row(3, &superset));\n+        matrix.intersect_row(0, &disjoint);\n+        assert!(matrix.row(0).is_none());\n+    }\n+\n+    // SparseBitMatrix::union_row\n+    {\n+        let mut matrix = matrix.clone();\n+        assert!(!matrix.union_row(3, &subset));\n+        assert!(matrix.union_row(3, &disjoint));\n+        matrix.union_row(0, &disjoint);\n+        assert!(matrix.row(0).is_some());\n+    }\n+}\n+\n /// Merge dense hybrid set into empty sparse hybrid set.\n #[bench]\n fn union_hybrid_sparse_empty_to_dense(b: &mut Bencher) {"}, {"sha": "2864abde0022c15e2c54e60ce4d80e9bcfd66699", "filename": "compiler/rustc_mir/src/borrow_check/region_infer/values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/608b5e1c209ffb4d6d0cf83817c823b12bbb7659/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608b5e1c209ffb4d6d0cf83817c823b12bbb7659/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fvalues.rs?ref=608b5e1c209ffb4d6d0cf83817c823b12bbb7659", "patch": "@@ -160,7 +160,7 @@ impl<N: Idx> LivenessValues<N> {\n     /// region. Returns whether any of them are newly added.\n     crate fn add_elements(&mut self, row: N, locations: &HybridBitSet<PointIndex>) -> bool {\n         debug!(\"LivenessValues::add_elements(row={:?}, locations={:?})\", row, locations);\n-        self.points.union_into_row(row, locations)\n+        self.points.union_row(row, locations)\n     }\n \n     /// Adds all the control-flow points to the values for `r`.\n@@ -294,7 +294,7 @@ impl<N: Idx> RegionValues<N> {\n     /// the region `to` in `self`.\n     crate fn merge_liveness<M: Idx>(&mut self, to: N, from: M, values: &LivenessValues<M>) {\n         if let Some(set) = values.points.row(from) {\n-            self.points.union_into_row(to, set);\n+            self.points.union_row(to, set);\n         }\n     }\n "}, {"sha": "acdaa5b456857becc07abb70e482f0440a711b32", "filename": "compiler/rustc_mir/src/transform/generator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/608b5e1c209ffb4d6d0cf83817c823b12bbb7659/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608b5e1c209ffb4d6d0cf83817c823b12bbb7659/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs?ref=608b5e1c209ffb4d6d0cf83817c823b12bbb7659", "patch": "@@ -626,7 +626,7 @@ fn compute_storage_conflicts(\n     // Locals that are always live or ones that need to be stored across\n     // suspension points are not eligible for overlap.\n     let mut ineligible_locals = always_live_locals.into_inner();\n-    ineligible_locals.intersect(saved_locals);\n+    ineligible_locals.intersect(&**saved_locals);\n \n     // Compute the storage conflicts for all eligible locals.\n     let mut visitor = StorageConflictVisitor {\n@@ -701,7 +701,7 @@ impl<'body, 'tcx, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n         }\n \n         let mut eligible_storage_live = flow_state.clone();\n-        eligible_storage_live.intersect(&self.saved_locals);\n+        eligible_storage_live.intersect(&**self.saved_locals);\n \n         for local in eligible_storage_live.iter() {\n             self.local_conflicts.union_row_with(&eligible_storage_live, local);"}]}