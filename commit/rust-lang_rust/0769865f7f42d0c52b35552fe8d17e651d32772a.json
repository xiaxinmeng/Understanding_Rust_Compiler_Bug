{"sha": "0769865f7f42d0c52b35552fe8d17e651d32772a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3Njk4NjVmN2Y0MmQwYzUyYjM1NTUyZmU4ZDE3ZTY1MWQzMjc3MmE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-24T00:46:38Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-24T00:46:38Z"}, "message": "rewrite scope drop to be iterative\n\nwhile I'm at it, remove the \"extra caching\" that I was doing for no good\nreason except laziness. Basically before I was caching at each scope in\nthe chain, but there's not really a reason to do that, since the cached\nentry point at level N is always equal to the last cached exit point\nfrom level N-1.", "tree": {"sha": "28db3425e1ebbfeb9212c9d11eb4b610521c60f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28db3425e1ebbfeb9212c9d11eb4b610521c60f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0769865f7f42d0c52b35552fe8d17e651d32772a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0769865f7f42d0c52b35552fe8d17e651d32772a", "html_url": "https://github.com/rust-lang/rust/commit/0769865f7f42d0c52b35552fe8d17e651d32772a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0769865f7f42d0c52b35552fe8d17e651d32772a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a276e755e7e272e7bbd95eb3f82f2fcc946825a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a276e755e7e272e7bbd95eb3f82f2fcc946825a5", "html_url": "https://github.com/rust-lang/rust/commit/a276e755e7e272e7bbd95eb3f82f2fcc946825a5"}], "stats": {"total": 71, "additions": 39, "deletions": 32}, "files": [{"sha": "b79f492179fb9363cbdd583f4a472ea75bf911b8", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0769865f7f42d0c52b35552fe8d17e651d32772a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0769865f7f42d0c52b35552fe8d17e651d32772a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=0769865f7f42d0c52b35552fe8d17e651d32772a", "patch": "@@ -47,6 +47,10 @@ pub struct Builder<'a, 'tcx: 'a> {\n     var_indices: FnvHashMap<ast::NodeId, u32>,\n     temp_decls: Vec<TempDecl<'tcx>>,\n     unit_temp: Option<Lvalue<'tcx>>,\n+\n+    // cached block with a RESUME terminator; we create this at the\n+    // first panic\n+    cached_resume_block: Option<BasicBlock>,\n }\n \n struct CFG<'tcx> {\n@@ -175,6 +179,7 @@ pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n         var_decls: vec![],\n         var_indices: FnvHashMap(),\n         unit_temp: None,\n+        cached_resume_block: None,\n     };\n \n     assert_eq!(builder.cfg.start_new_block(), START_BLOCK);"}, {"sha": "f5f6f409eaba4d6ab2725685f8b26ede4a1d4422", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0769865f7f42d0c52b35552fe8d17e651d32772a/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0769865f7f42d0c52b35552fe8d17e651d32772a/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=0769865f7f42d0c52b35552fe8d17e651d32772a", "patch": "@@ -456,21 +456,41 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// See module comment for more details. None indicates there\u2019s no\n     /// cleanup to do at this point.\n     pub fn diverge_cleanup(&mut self) -> Option<BasicBlock> {\n-        if self.scopes.is_empty() {\n+        if self.scopes.iter().all(|scope| scope.drops.is_empty() && scope.free.is_none()) {\n             return None;\n         }\n+        assert!(!self.scopes.is_empty()); // or `all` above would be true\n+\n         let unit_temp = self.get_unit_temp();\n-        let Builder { ref mut hir, ref mut cfg, ref mut scopes, .. } = *self;\n-\n-        // Given an array of scopes, we generate these from the outermost scope to the innermost\n-        // one. Thus for array [S0, S1, S2] with corresponding cleanup blocks [B0, B1, B2], we will\n-        // generate B0 <- B1 <- B2 in left-to-right order. Control flow of the generated blocks\n-        // always ends up at a block with the Resume terminator.\n-        if scopes.iter().any(|scope| !scope.drops.is_empty() || scope.free.is_some()) {\n-            Some(build_diverge_scope(hir.tcx(), self.fn_span, cfg, &unit_temp, scopes))\n+        let Builder { ref mut hir, ref mut cfg, ref mut scopes,\n+                      ref mut cached_resume_block, .. } = *self;\n+\n+        // Build up the drops in **reverse** order. The end result will\n+        // look like:\n+        //\n+        //    scopes[n] -> scopes[n-1] -> ... -> scopes[0]\n+        //\n+        // However, we build this in **reverse order**. That is, we\n+        // process scopes[0], then scopes[1], etc, pointing each one at\n+        // the result generates from the one before. Along the way, we\n+        // store caches. If everything is cached, we'll just walk right\n+        // to left reading the cached results but never created anything.\n+\n+        // To start, create the resume terminator.\n+        let mut target = if let Some(target) = *cached_resume_block {\n+            target\n         } else {\n-            None\n+            let resumeblk = cfg.start_new_cleanup_block();\n+            cfg.terminate(resumeblk, scopes[0].id, self.fn_span, TerminatorKind::Resume);\n+            *cached_resume_block = Some(resumeblk);\n+            resumeblk\n+        };\n+\n+        for scope in scopes {\n+            target = build_diverge_scope(hir.tcx(), cfg, &unit_temp, scope, target);\n         }\n+\n+        Some(target)\n     }\n \n     /// Utility function for *non*-scope code to build their own drops\n@@ -640,43 +660,25 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n }\n \n fn build_diverge_scope<'tcx>(tcx: &TyCtxt<'tcx>,\n-                             fn_span: Span,\n                              cfg: &mut CFG<'tcx>,\n                              unit_temp: &Lvalue<'tcx>,\n-                             scopes: &mut [Scope<'tcx>])\n+                             scope: &mut Scope<'tcx>,\n+                             mut target: BasicBlock)\n                              -> BasicBlock\n {\n-    assert!(scopes.len() >= 1);\n-\n     // Build up the drops in **reverse** order. The end result will\n     // look like:\n     //\n-    //    [drops[n]] -...-> [drops[0]] -> [Free] -> [scopes[..n-1]]\n+    //    [drops[n]] -...-> [drops[0]] -> [Free] -> [target]\n     //    |                                    |\n     //    +------------------------------------+\n-    //     code for scopes[n]\n+    //     code for scope\n     //\n     // The code in this function reads from right to left. At each\n     // point, we check for cached blocks representing the\n     // remainder. If everything is cached, we'll just walk right to\n     // left reading the cached results but never created anything.\n \n-    // To start, translate scopes[1..].\n-    let (scope, earlier_scopes) = scopes.split_last_mut().unwrap();\n-    let mut target = if let Some(cached_block) = scope.cached_block {\n-        cached_block\n-    } else if earlier_scopes.is_empty() {\n-        // Diverging from the root scope creates a RESUME terminator.\n-        // FIXME what span to use here?\n-        let resumeblk = cfg.start_new_cleanup_block();\n-        cfg.terminate(resumeblk, scope.id, fn_span, TerminatorKind::Resume);\n-        resumeblk\n-    } else {\n-        // Diverging from any other scope chains up to the previous scope.\n-        build_diverge_scope(tcx, fn_span, cfg, unit_temp, earlier_scopes)\n-    };\n-    scope.cached_block = Some(target);\n-\n     // Next, build up any free.\n     if let Some(ref mut free_data) = scope.free {\n         target = if let Some(cached_block) = free_data.cached_block {"}]}