{"sha": "5915309645988a001101621423912d2e32c90523", "node_id": "C_kwDOAAsO6NoAKDU5MTUzMDk2NDU5ODhhMDAxMTAxNjIxNDIzOTEyZDJlMzJjOTA1MjM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-02-13T22:25:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-13T22:25:13Z"}, "message": "Rollup merge of #107971 - saethlin:mir-opt-ub, r=cjgillot\n\nClearly document intentional UB in mir-opt tests\n\nAll of the changed mir-opt test input files did not pass Miri. Now they do.\n\nr? `@cjgillot` because there's a CopyProp test in here that I do not fully understand", "tree": {"sha": "b81ac0b139adecf7a2d3f65e9926936bd73b9e0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b81ac0b139adecf7a2d3f65e9926936bd73b9e0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5915309645988a001101621423912d2e32c90523", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj6rjJCRBK7hj4Ov3rIwAA6KEIAB6IL49RTddeNMiAtL3RFTwi\nZxtvSYuOzJGEoTwMM4V1Pp1KbQ32le9nOUgW1ej3RSJ5Is4KdXxWiq3SoKMIVbG0\nW4guaRfyTd/41rGf/i/6C1iUgusrNm/qdVYA8PTzOsAWEN6thrdiTRBDhF7m/AYu\n0HBJe9yCbIwfGKOjYijumxa8MioI7FGMPkjOzNQOn8rOcuwpPqOz2NIeSO6vvI/U\nrd99D6C8xstWNC+b4bZREGmDCgqMNvD8aa/CuWqkygpM4mmpLdUQCz3/dM+95Qqf\nrIU9w50vImcKZwEgI3/nMWM4jQCdbtpMWigVoU9qMGLuUkYgcUnQum02rHemP7o=\n=yUFR\n-----END PGP SIGNATURE-----\n", "payload": "tree b81ac0b139adecf7a2d3f65e9926936bd73b9e0b\nparent 7efb884b9c1e112503a77ccb013bdb8feb1adc81\nparent 614df3fd5eb83163b0cac65dc16eba35b7afe210\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1676327113 +0100\ncommitter GitHub <noreply@github.com> 1676327113 +0100\n\nRollup merge of #107971 - saethlin:mir-opt-ub, r=cjgillot\n\nClearly document intentional UB in mir-opt tests\n\nAll of the changed mir-opt test input files did not pass Miri. Now they do.\n\nr? `@cjgillot` because there's a CopyProp test in here that I do not fully understand\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5915309645988a001101621423912d2e32c90523", "html_url": "https://github.com/rust-lang/rust/commit/5915309645988a001101621423912d2e32c90523", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5915309645988a001101621423912d2e32c90523/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7efb884b9c1e112503a77ccb013bdb8feb1adc81", "url": "https://api.github.com/repos/rust-lang/rust/commits/7efb884b9c1e112503a77ccb013bdb8feb1adc81", "html_url": "https://github.com/rust-lang/rust/commit/7efb884b9c1e112503a77ccb013bdb8feb1adc81"}, {"sha": "614df3fd5eb83163b0cac65dc16eba35b7afe210", "url": "https://api.github.com/repos/rust-lang/rust/commits/614df3fd5eb83163b0cac65dc16eba35b7afe210", "html_url": "https://github.com/rust-lang/rust/commit/614df3fd5eb83163b0cac65dc16eba35b7afe210"}], "stats": {"total": 76, "additions": 49, "deletions": 27}, "files": [{"sha": "da142e33948effff594ef7bab10d357a605e092f", "filename": "tests/mir-opt/copy-prop/mutate_through_pointer.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5915309645988a001101621423912d2e32c90523/tests%2Fmir-opt%2Fcopy-prop%2Fmutate_through_pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5915309645988a001101621423912d2e32c90523/tests%2Fmir-opt%2Fcopy-prop%2Fmutate_through_pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcopy-prop%2Fmutate_through_pointer.rs?ref=5915309645988a001101621423912d2e32c90523", "patch": "@@ -1,3 +1,13 @@\n+// This attempts to mutate `a` via a pointer derived from `addr_of!(a)`. That is UB\n+// according to Miri. However, the decision to make this UB - and to allow\n+// rustc to rely on that fact for the purpose of optimizations - has not been\n+// finalized.\n+//\n+// As such, we include this test to ensure that copy prop does not rely on that\n+// fact. Specifically, if `addr_of!(a)` could not be used to modify a, it would\n+// be correct for CopyProp to replace all occurrences of `a` with `c` - but that\n+// would cause `f(true)` to output `false` instead of `true`.\n+\n #![feature(custom_mir, core_intrinsics)]\n #![allow(unused_assignments)]\n extern crate core;"}, {"sha": "004643e36f1396d06964acbf6c1fde40165cd724", "filename": "tests/mir-opt/dataflow-const-prop/sibling_ptr.main.DataflowConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5915309645988a001101621423912d2e32c90523/tests%2Fmir-opt%2Fdataflow-const-prop%2Fsibling_ptr.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5915309645988a001101621423912d2e32c90523/tests%2Fmir-opt%2Fdataflow-const-prop%2Fsibling_ptr.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Fsibling_ptr.main.DataflowConstProp.diff?ref=5915309645988a001101621423912d2e32c90523", "patch": "@@ -32,7 +32,7 @@\n           _5 = _3;                         // scope 3 at $DIR/sibling_ptr.rs:+4:10: +4:11\n           _4 = ptr::mut_ptr::<impl *mut u8>::add(move _5, const 1_usize) -> bb1; // scope 3 at $DIR/sibling_ptr.rs:+4:10: +4:18\n                                            // mir::Constant\n-                                           // + span: $DIR/sibling_ptr.rs:8:12: 8:15\n+                                           // + span: $DIR/sibling_ptr.rs:15:12: 15:15\n                                            // + literal: Const { ty: unsafe fn(*mut u8, usize) -> *mut u8 {ptr::mut_ptr::<impl *mut u8>::add}, val: Value(<ZST>) }\n       }\n   "}, {"sha": "6dfb3a4ed30995b1806f85cb874822fb74e382ab", "filename": "tests/mir-opt/dataflow-const-prop/sibling_ptr.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5915309645988a001101621423912d2e32c90523/tests%2Fmir-opt%2Fdataflow-const-prop%2Fsibling_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5915309645988a001101621423912d2e32c90523/tests%2Fmir-opt%2Fdataflow-const-prop%2Fsibling_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Fsibling_ptr.rs?ref=5915309645988a001101621423912d2e32c90523", "patch": "@@ -1,3 +1,10 @@\n+// This attempts to modify `x.1` via a pointer derived from `addr_of_mut!(x.0)`.\n+// According to Miri, that is UB. However, T-opsem has not finalized that\n+// decision and as such we cannot rely on it in optimizations. Consequently,\n+// DataflowConstProp must treat the `addr_of_mut!(x.0)` as potentially being\n+// used to modify `x.1` - if it did not, then it might incorrectly assume that it\n+// can infer the value of `x.1` at the end of this function.\n+\n // unit-test: DataflowConstProp\n \n // EMIT_MIR sibling_ptr.main.DataflowConstProp.diff\n@@ -7,5 +14,5 @@ fn main() {\n         let p = std::ptr::addr_of_mut!(x.0);\n         *p.add(1) = 1;\n     }\n-    let x1 = x.1;  // should not be propagated\n+    let x1 = x.1; // should not be propagated\n }"}, {"sha": "fd691fdd153327d7a12bf5ad4f65d7d673b06d32", "filename": "tests/mir-opt/sroa.escaping.ScalarReplacementOfAggregates.diff", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5915309645988a001101621423912d2e32c90523/tests%2Fmir-opt%2Fsroa.escaping.ScalarReplacementOfAggregates.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5915309645988a001101621423912d2e32c90523/tests%2Fmir-opt%2Fsroa.escaping.ScalarReplacementOfAggregates.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fsroa.escaping.ScalarReplacementOfAggregates.diff?ref=5915309645988a001101621423912d2e32c90523", "patch": "@@ -3,42 +3,42 @@\n   \n   fn escaping() -> () {\n       let mut _0: ();                      // return place in scope 0 at $DIR/sroa.rs:+0:19: +0:19\n-      let _1: ();                          // in scope 0 at $DIR/sroa.rs:+2:5: +2:42\n-      let mut _2: *const u32;              // in scope 0 at $DIR/sroa.rs:+2:7: +2:41\n-      let _3: &u32;                        // in scope 0 at $DIR/sroa.rs:+2:7: +2:41\n-      let _4: Escaping;                    // in scope 0 at $DIR/sroa.rs:+2:8: +2:39\n-      let mut _5: u32;                     // in scope 0 at $DIR/sroa.rs:+2:34: +2:37\n+      let _1: ();                          // in scope 0 at $DIR/sroa.rs:+1:5: +1:42\n+      let mut _2: *const u32;              // in scope 0 at $DIR/sroa.rs:+1:7: +1:41\n+      let _3: &u32;                        // in scope 0 at $DIR/sroa.rs:+1:7: +1:41\n+      let _4: Escaping;                    // in scope 0 at $DIR/sroa.rs:+1:8: +1:39\n+      let mut _5: u32;                     // in scope 0 at $DIR/sroa.rs:+1:34: +1:37\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/sroa.rs:+2:5: +2:42\n-          StorageLive(_2);                 // scope 0 at $DIR/sroa.rs:+2:7: +2:41\n-          StorageLive(_3);                 // scope 0 at $DIR/sroa.rs:+2:7: +2:41\n-          StorageLive(_4);                 // scope 0 at $DIR/sroa.rs:+2:8: +2:39\n-          StorageLive(_5);                 // scope 0 at $DIR/sroa.rs:+2:34: +2:37\n-          _5 = g() -> bb1;                 // scope 0 at $DIR/sroa.rs:+2:34: +2:37\n+          StorageLive(_1);                 // scope 0 at $DIR/sroa.rs:+1:5: +1:42\n+          StorageLive(_2);                 // scope 0 at $DIR/sroa.rs:+1:7: +1:41\n+          StorageLive(_3);                 // scope 0 at $DIR/sroa.rs:+1:7: +1:41\n+          StorageLive(_4);                 // scope 0 at $DIR/sroa.rs:+1:8: +1:39\n+          StorageLive(_5);                 // scope 0 at $DIR/sroa.rs:+1:34: +1:37\n+          _5 = g() -> bb1;                 // scope 0 at $DIR/sroa.rs:+1:34: +1:37\n                                            // mir::Constant\n-                                           // + span: $DIR/sroa.rs:73:34: 73:35\n+                                           // + span: $DIR/sroa.rs:78:34: 78:35\n                                            // + literal: Const { ty: fn() -> u32 {g}, val: Value(<ZST>) }\n       }\n   \n       bb1: {\n-          _4 = Escaping { a: const 1_u32, b: const 2_u32, c: move _5 }; // scope 0 at $DIR/sroa.rs:+2:8: +2:39\n-          StorageDead(_5);                 // scope 0 at $DIR/sroa.rs:+2:38: +2:39\n-          _3 = &(_4.0: u32);               // scope 0 at $DIR/sroa.rs:+2:7: +2:41\n-          _2 = &raw const (*_3);           // scope 0 at $DIR/sroa.rs:+2:7: +2:41\n-          _1 = f(move _2) -> bb2;          // scope 0 at $DIR/sroa.rs:+2:5: +2:42\n+          _4 = Escaping { a: const 1_u32, b: const 2_u32, c: move _5 }; // scope 0 at $DIR/sroa.rs:+1:8: +1:39\n+          StorageDead(_5);                 // scope 0 at $DIR/sroa.rs:+1:38: +1:39\n+          _3 = &(_4.0: u32);               // scope 0 at $DIR/sroa.rs:+1:7: +1:41\n+          _2 = &raw const (*_3);           // scope 0 at $DIR/sroa.rs:+1:7: +1:41\n+          _1 = f(move _2) -> bb2;          // scope 0 at $DIR/sroa.rs:+1:5: +1:42\n                                            // mir::Constant\n-                                           // + span: $DIR/sroa.rs:73:5: 73:6\n+                                           // + span: $DIR/sroa.rs:78:5: 78:6\n                                            // + literal: Const { ty: fn(*const u32) {f}, val: Value(<ZST>) }\n       }\n   \n       bb2: {\n-          StorageDead(_2);                 // scope 0 at $DIR/sroa.rs:+2:41: +2:42\n-          StorageDead(_4);                 // scope 0 at $DIR/sroa.rs:+2:42: +2:43\n-          StorageDead(_3);                 // scope 0 at $DIR/sroa.rs:+2:42: +2:43\n-          StorageDead(_1);                 // scope 0 at $DIR/sroa.rs:+2:42: +2:43\n-          _0 = const ();                   // scope 0 at $DIR/sroa.rs:+0:19: +3:2\n-          return;                          // scope 0 at $DIR/sroa.rs:+3:2: +3:2\n+          StorageDead(_2);                 // scope 0 at $DIR/sroa.rs:+1:41: +1:42\n+          StorageDead(_4);                 // scope 0 at $DIR/sroa.rs:+1:42: +1:43\n+          StorageDead(_3);                 // scope 0 at $DIR/sroa.rs:+1:42: +1:43\n+          StorageDead(_1);                 // scope 0 at $DIR/sroa.rs:+1:42: +1:43\n+          _0 = const ();                   // scope 0 at $DIR/sroa.rs:+0:19: +2:2\n+          return;                          // scope 0 at $DIR/sroa.rs:+2:2: +2:2\n       }\n   }\n   "}, {"sha": "fff92cf8d9fd6a9b1c1413aa975a83b0d4b00682", "filename": "tests/mir-opt/sroa.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5915309645988a001101621423912d2e32c90523/tests%2Fmir-opt%2Fsroa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5915309645988a001101621423912d2e32c90523/tests%2Fmir-opt%2Fsroa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fsroa.rs?ref=5915309645988a001101621423912d2e32c90523", "patch": "@@ -68,8 +68,13 @@ fn f(a: *const u32) {\n     println!(\"{}\", unsafe { *a.add(2) });\n }\n \n+// `f` uses the `&e.a` to access `e.c`. This is UB according to Miri today; however,\n+// T-opsem has not finalized that decision and as such rustc should not rely on\n+// it. If SROA were to rely on it, it would be (almost) correct to turn `e` into\n+// three distinct locals - one for each field - and pass a reference to only one\n+// of them to `f`. However, this would lead to a miscompilation because `b` and `c`\n+// might no longer appear right after `a` in memory.\n pub fn escaping() {\n-    // Verify this struct is not flattened.\n     f(&Escaping { a: 1, b: 2, c: g() }.a);\n }\n "}]}