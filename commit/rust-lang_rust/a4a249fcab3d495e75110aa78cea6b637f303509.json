{"sha": "a4a249fcab3d495e75110aa78cea6b637f303509", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0YTI0OWZjYWIzZDQ5NWU3NTExMGFhNzhjZWE2YjYzN2YzMDM1MDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-02T01:35:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-02T01:35:39Z"}, "message": "Auto merge of #31279 - DanielJCampbell:MacroReferencing, r=nrc\n\nr? @nrc", "tree": {"sha": "57cefec8d3b2bcfaac133560f5fd1a7135ca3415", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57cefec8d3b2bcfaac133560f5fd1a7135ca3415"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4a249fcab3d495e75110aa78cea6b637f303509", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4a249fcab3d495e75110aa78cea6b637f303509", "html_url": "https://github.com/rust-lang/rust/commit/a4a249fcab3d495e75110aa78cea6b637f303509", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4a249fcab3d495e75110aa78cea6b637f303509/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b94cd7a5bd488324e39047682e1e4dad9c08fa93", "url": "https://api.github.com/repos/rust-lang/rust/commits/b94cd7a5bd488324e39047682e1e4dad9c08fa93", "html_url": "https://github.com/rust-lang/rust/commit/b94cd7a5bd488324e39047682e1e4dad9c08fa93"}, {"sha": "1d326419a13edf205f905be4de9c699207777934", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d326419a13edf205f905be4de9c699207777934", "html_url": "https://github.com/rust-lang/rust/commit/1d326419a13edf205f905be4de9c699207777934"}], "stats": {"total": 232, "additions": 221, "deletions": 11}, "files": [{"sha": "f0c71825942405bcc983fbf122ab23fdb9a3caba", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a4a249fcab3d495e75110aa78cea6b637f303509/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a249fcab3d495e75110aa78cea6b637f303509/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=a4a249fcab3d495e75110aa78cea6b637f303509", "patch": "@@ -30,7 +30,7 @@ use rustc_back::target::Target;\n \n use std::path::{Path, PathBuf};\n use std::cell::{Cell, RefCell};\n-use std::collections::HashSet;\n+use std::collections::{HashMap, HashSet};\n use std::env;\n use std::rc::Rc;\n \n@@ -77,6 +77,11 @@ pub struct Session {\n     /// available in this crate\n     pub available_macros: RefCell<HashSet<Name>>,\n \n+    /// Map from imported macro spans (which consist of\n+    /// the localized span for the macro body) to the\n+    /// macro name and defintion span in the source crate.\n+    pub imported_macro_spans: RefCell<HashMap<Span, (String, Span)>>,\n+\n     next_node_id: Cell<ast::NodeId>,\n }\n \n@@ -479,6 +484,7 @@ pub fn build_session_(sopts: config::Options,\n         next_node_id: Cell::new(1),\n         injected_allocator: Cell::new(None),\n         available_macros: RefCell::new(HashSet::new()),\n+        imported_macro_spans: RefCell::new(HashMap::new()),\n     };\n \n     sess"}, {"sha": "991cbe137ecf91cf41aaa670d1aee666a0642757", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4a249fcab3d495e75110aa78cea6b637f303509/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a249fcab3d495e75110aa78cea6b637f303509/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=a4a249fcab3d495e75110aa78cea6b637f303509", "patch": "@@ -223,6 +223,8 @@ pub const tag_polarity: usize = 0x9d;\n pub const tag_macro_defs: usize = 0x10e; // top-level only\n pub const tag_macro_def: usize = 0x9e;\n pub const tag_macro_def_body: usize = 0x9f;\n+pub const tag_macro_def_span_lo: usize = 0xa8;\n+pub const tag_macro_def_span_hi: usize = 0xa9;\n \n pub const tag_paren_sugar: usize = 0xa0;\n "}, {"sha": "b569739c40cb9fb84990ac42757a5f4a610510a7", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a4a249fcab3d495e75110aa78cea6b637f303509/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a249fcab3d495e75110aa78cea6b637f303509/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=a4a249fcab3d495e75110aa78cea6b637f303509", "patch": "@@ -494,7 +494,7 @@ impl<'a> CrateReader<'a> {\n         let mut macros = vec![];\n         decoder::each_exported_macro(ekrate.metadata.as_slice(),\n                                      &*self.cstore.intr,\n-            |name, attrs, body| {\n+            |name, attrs, span, body| {\n                 // NB: Don't use parse::parse_tts_from_source_str because it parses with\n                 // quote_depth > 0.\n                 let mut p = parse::new_parser_from_source_str(&self.sess.parse_sess,\n@@ -509,7 +509,7 @@ impl<'a> CrateReader<'a> {\n                         panic!(FatalError);\n                     }\n                 };\n-                let span = mk_sp(lo, p.last_span.hi);\n+                let local_span = mk_sp(lo, p.last_span.hi);\n \n                 // Mark the attrs as used\n                 for attr in &attrs {\n@@ -520,7 +520,7 @@ impl<'a> CrateReader<'a> {\n                     ident: ast::Ident::with_empty_ctxt(name),\n                     attrs: attrs,\n                     id: ast::DUMMY_NODE_ID,\n-                    span: span,\n+                    span: local_span,\n                     imported_from: Some(item.ident),\n                     // overridden in plugin/load.rs\n                     export: false,\n@@ -529,6 +529,8 @@ impl<'a> CrateReader<'a> {\n \n                     body: body,\n                 });\n+                self.sess.imported_macro_spans.borrow_mut()\n+                    .insert(local_span, (name.as_str().to_string(), span));\n                 true\n             }\n         );"}, {"sha": "2cdce7ae784c9e98f156ca640537221ad8737116", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a4a249fcab3d495e75110aa78cea6b637f303509/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a249fcab3d495e75110aa78cea6b637f303509/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=a4a249fcab3d495e75110aa78cea6b637f303509", "patch": "@@ -52,7 +52,7 @@ use syntax::parse::token::{IdentInterner, special_idents};\n use syntax::parse::token;\n use syntax::ast;\n use syntax::abi;\n-use syntax::codemap::{self, Span};\n+use syntax::codemap::{self, Span, BytePos, NO_EXPANSION};\n use syntax::print::pprust;\n use syntax::ptr::P;\n \n@@ -1471,19 +1471,28 @@ pub fn get_plugin_registrar_fn(data: &[u8]) -> Option<DefIndex> {\n }\n \n pub fn each_exported_macro<F>(data: &[u8], intr: &IdentInterner, mut f: F) where\n-    F: FnMut(ast::Name, Vec<ast::Attribute>, String) -> bool,\n+    F: FnMut(ast::Name, Vec<ast::Attribute>, Span, String) -> bool,\n {\n     let macros = reader::get_doc(rbml::Doc::new(data), tag_macro_defs);\n     for macro_doc in reader::tagged_docs(macros, tag_macro_def) {\n         let name = item_name(intr, macro_doc);\n         let attrs = get_attributes(macro_doc);\n+        let span = get_macro_span(macro_doc);\n         let body = reader::get_doc(macro_doc, tag_macro_def_body);\n-        if !f(name, attrs, body.as_str().to_string()) {\n+        if !f(name, attrs, span, body.as_str().to_string()) {\n             break;\n         }\n     }\n }\n \n+pub fn get_macro_span(doc: rbml::Doc) -> Span {\n+    let lo_doc = reader::get_doc(doc, tag_macro_def_span_lo);\n+    let lo = BytePos(reader::doc_as_u32(lo_doc));\n+    let hi_doc = reader::get_doc(doc, tag_macro_def_span_hi);\n+    let hi = BytePos(reader::doc_as_u32(hi_doc));\n+    return Span { lo: lo, hi: hi, expn_id: NO_EXPANSION };\n+}\n+\n pub fn get_dylib_dependency_formats(cdata: Cmd)\n     -> Vec<(ast::CrateNum, LinkagePreference)>\n {"}, {"sha": "1e50868f664eeda6b5bc6281c4085c23e0af2c34", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a4a249fcab3d495e75110aa78cea6b637f303509/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a249fcab3d495e75110aa78cea6b637f303509/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=a4a249fcab3d495e75110aa78cea6b637f303509", "patch": "@@ -42,6 +42,7 @@ use std::rc::Rc;\n use std::u32;\n use syntax::abi;\n use syntax::ast::{self, NodeId, Name, CRATE_NODE_ID, CrateNum};\n+use syntax::codemap::BytePos;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::errors::Handler;\n@@ -1727,6 +1728,10 @@ fn encode_macro_defs(rbml_w: &mut Encoder,\n \n         encode_name(rbml_w, def.name);\n         encode_attributes(rbml_w, &def.attrs);\n+        let &BytePos(lo) = &def.span.lo;\n+        let &BytePos(hi) = &def.span.hi;\n+        rbml_w.wr_tagged_u32(tag_macro_def_span_lo, lo);\n+        rbml_w.wr_tagged_u32(tag_macro_def_span_hi, hi);\n \n         rbml_w.wr_tagged_str(tag_macro_def_body,\n                              &::syntax::print::pprust::tts_to_string(&def.body));"}, {"sha": "2b866eeaa9f9c71b0d0388d710c98dd1d73ea2c8", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a4a249fcab3d495e75110aa78cea6b637f303509/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a249fcab3d495e75110aa78cea6b637f303509/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=a4a249fcab3d495e75110aa78cea6b637f303509", "patch": "@@ -37,6 +37,8 @@ use middle::def_id::DefId;\n use middle::ty;\n \n use std::fs::File;\n+use std::hash::*;\n+use std::collections::HashSet;\n \n use syntax::ast::{self, NodeId};\n use syntax::codemap::*;\n@@ -70,6 +72,14 @@ pub struct DumpCsvVisitor<'l, 'tcx: 'l> {\n     fmt: FmtStrs<'l, 'tcx>,\n \n     cur_scope: NodeId,\n+\n+    // Set of macro definition (callee) spans, and the set\n+    // of macro use (callsite) spans. We store these to ensure\n+    // we only write one macro def per unique macro definition, and\n+    // one macro use per unique callsite span.\n+    mac_defs: HashSet<Span>,\n+    mac_uses: HashSet<Span>,\n+\n }\n \n impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n@@ -92,6 +102,8 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                               span_utils,\n                               tcx),\n             cur_scope: 0,\n+            mac_defs: HashSet::new(),\n+            mac_uses: HashSet::new(),\n         }\n     }\n \n@@ -814,10 +826,41 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                   &typ);\n         }\n     }\n+\n+    /// Extract macro use and definition information from the AST node defined\n+    /// by the given NodeId, using the expansion information from the node's\n+    /// span.\n+    ///\n+    /// If the span is not macro-generated, do nothing, else use callee and\n+    /// callsite spans to record macro definition and use data, using the\n+    /// mac_uses and mac_defs sets to prevent multiples.\n+    fn process_macro_use(&mut self, span: Span, id: NodeId) {\n+        let data = match self.save_ctxt.get_macro_use_data(span, id) {\n+            None => return,\n+            Some(data) => data,\n+        };\n+        let mut hasher = SipHasher::new();\n+        data.callee_span.hash(&mut hasher);\n+        let hash = hasher.finish();\n+        let qualname = format!(\"{}::{}\", data.name, hash);\n+        // Don't write macro definition for imported macros\n+        if !self.mac_defs.contains(&data.callee_span)\n+            && !data.imported {\n+            self.mac_defs.insert(data.callee_span);\n+            self.fmt.macro_str(data.callee_span, data.callee_span,\n+                               data.name.clone(), qualname.clone());\n+        }\n+        if !self.mac_uses.contains(&data.span) {\n+             self.mac_uses.insert(data.span);\n+             self.fmt.macro_use_str(data.span, data.span, data.name,\n+                                   qualname, data.scope);\n+        }\n+    }\n }\n \n impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n+        self.process_macro_use(item.span, item.id);\n         match item.node {\n             ast::ItemUse(ref use_item) => {\n                 match use_item.node {\n@@ -970,6 +1013,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n+        self.process_macro_use(trait_item.span, trait_item.id);\n         match trait_item.node {\n             ast::ConstTraitItem(ref ty, Some(ref expr)) => {\n                 self.process_const(trait_item.id,\n@@ -991,6 +1035,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n+        self.process_macro_use(impl_item.span, impl_item.id);\n         match impl_item.node {\n             ast::ImplItemKind::Const(ref ty, ref expr) => {\n                 self.process_const(impl_item.id,\n@@ -1012,6 +1057,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, t: &ast::Ty) {\n+        self.process_macro_use(t.span, t.id);\n         match t.node {\n             ast::TyPath(_, ref path) => {\n                 match self.lookup_type_ref(t.id) {\n@@ -1031,6 +1077,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, ex: &ast::Expr) {\n+        self.process_macro_use(ex.span, ex.id);\n         match ex.node {\n             ast::ExprCall(ref _f, ref _args) => {\n                 // Don't need to do anything for function calls,\n@@ -1117,11 +1164,13 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn visit_mac(&mut self, _: &ast::Mac) {\n-        // Just stop, macros are poison to us.\n+    fn visit_mac(&mut self, mac: &ast::Mac) {\n+        // These shouldn't exist in the AST at this point, log a span bug.\n+        self.sess.span_bug(mac.span, \"macro invocation should have been expanded out of AST\");\n     }\n \n     fn visit_pat(&mut self, p: &ast::Pat) {\n+        self.process_macro_use(p.span, p.id);\n         self.process_pat(p);\n     }\n \n@@ -1177,10 +1226,13 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n     }\n \n     fn visit_stmt(&mut self, s: &ast::Stmt) {\n+        let id = s.node.id();\n+        self.process_macro_use(s.span, id.unwrap());\n         visit::walk_stmt(self, s)\n     }\n \n     fn visit_local(&mut self, l: &ast::Local) {\n+        self.process_macro_use(l.span, l.id);\n         let value = self.span.snippet(l.span);\n         self.process_var_decl(&l.pat, value);\n "}, {"sha": "11c82d302467c3239cdaa4cac84bab52df240e92", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a4a249fcab3d495e75110aa78cea6b637f303509/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a249fcab3d495e75110aa78cea6b637f303509/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=a4a249fcab3d495e75110aa78cea6b637f303509", "patch": "@@ -73,6 +73,8 @@ pub enum Data {\n     FunctionCallData(FunctionCallData),\n     /// Data about a method call.\n     MethodCallData(MethodCallData),\n+    /// Data about a macro use.\n+    MacroUseData(MacroUseData),\n }\n \n /// Data for all kinds of functions and methods.\n@@ -174,6 +176,22 @@ pub struct MethodCallData {\n     pub decl_id: Option<DefId>,\n }\n \n+/// Data about a macro use.\n+#[derive(Debug)]\n+pub struct MacroUseData {\n+    pub span: Span,\n+    pub name: String,\n+    // Because macro expansion happens before ref-ids are determined,\n+    // we use the callee span to reference the associated macro definition.\n+    pub callee_span: Span,\n+    pub scope: NodeId,\n+    pub imported: bool,\n+}\n+\n+macro_rules! option_try(\n+    ($e:expr) => (match $e { Some(e) => e, None => return None })\n+);\n+\n \n \n impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n@@ -655,6 +673,51 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         })\n     }\n \n+    /// Attempt to return MacroUseData for any AST node.\n+    ///\n+    /// For a given piece of AST defined by the supplied Span and NodeId,\n+    /// returns None if the node is not macro-generated or the span is malformed,\n+    /// else uses the expansion callsite and callee to return some MacroUseData.\n+    pub fn get_macro_use_data(&self, span: Span, id: NodeId) -> Option<MacroUseData> {\n+        if !generated_code(span) {\n+            return None;\n+        }\n+        // Note we take care to use the source callsite/callee, to handle\n+        // nested expansions and ensure we only generate data for source-visible\n+        // macro uses.\n+        let callsite = self.tcx.sess.codemap().source_callsite(span);\n+        let callee = self.tcx.sess.codemap().source_callee(span);\n+        let callee = option_try!(callee);\n+        let callee_span = option_try!(callee.span);\n+\n+        // Ignore attribute macros, their spans are usually mangled\n+        if let MacroAttribute(_) = callee.format {\n+            return None;\n+        }\n+\n+        // If the callee is an imported macro from an external crate, need to get\n+        // the source span and name from the session, as their spans are localized\n+        // when read in, and no longer correspond to the source.\n+        if let Some(mac) = self.tcx.sess.imported_macro_spans.borrow().get(&callee_span) {\n+            let &(ref mac_name, mac_span) = mac;\n+            return Some(MacroUseData {\n+                                        span: callsite,\n+                                        name: mac_name.clone(),\n+                                        callee_span: mac_span,\n+                                        scope: self.enclosing_scope(id),\n+                                        imported: true,\n+                                    });\n+        }\n+\n+        Some(MacroUseData {\n+            span: callsite,\n+            name: callee.name().to_string(),\n+            callee_span: callee_span,\n+            scope: self.enclosing_scope(id),\n+            imported: false,\n+        })\n+    }\n+\n     pub fn get_data_for_id(&self, _id: &NodeId) -> Data {\n         // FIXME\n         unimplemented!();"}, {"sha": "c0083bb9480d9f5c3b258b77e63efb558ed238d5", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a4a249fcab3d495e75110aa78cea6b637f303509/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a249fcab3d495e75110aa78cea6b637f303509/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=a4a249fcab3d495e75110aa78cea6b637f303509", "patch": "@@ -96,6 +96,8 @@ pub enum Row {\n     VarRef,\n     TypeRef,\n     FnRef,\n+    Macro,\n+    MacroUse,\n }\n \n impl<'a, 'tcx: 'a> FmtStrs<'a, 'tcx> {\n@@ -219,6 +221,14 @@ impl<'a, 'tcx: 'a> FmtStrs<'a, 'tcx> {\n                       vec!(\"refid\", \"refidcrate\", \"qualname\", \"scopeid\"),\n                       true,\n                       true),\n+            Macro => (\"macro\",\n+                         vec!(\"name\", \"qualname\"),\n+                         true,\n+                         true),\n+            MacroUse => (\"macro_use\",\n+                         vec!(\"callee_name\", \"qualname\", \"scopeid\"),\n+                         true,\n+                         true),\n         }\n     }\n \n@@ -686,4 +696,19 @@ impl<'a, 'tcx: 'a> FmtStrs<'a, 'tcx> {\n                               sub_span,\n                               svec!(id.index.as_usize(), id.krate, \"\", scope_id));\n     }\n+\n+    pub fn macro_str(&mut self, span: Span, sub_span: Span, name: String, qualname: String) {\n+        self.record_with_span(Macro, span, sub_span, svec!(name, qualname));\n+    }\n+\n+    pub fn macro_use_str(&mut self,\n+                         span: Span,\n+                         sub_span: Span,\n+                         name: String,\n+                         qualname: String,\n+                         scope_id: NodeId) {\n+        let scope_id = self.normalize_node_id(scope_id);\n+        self.record_with_span(MacroUse, span, sub_span,\n+                              svec!(name, qualname, scope_id));\n+    }\n }"}, {"sha": "95c1d7bd031b5ab4193b94e83522b6c79a72d3ba", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a4a249fcab3d495e75110aa78cea6b637f303509/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a249fcab3d495e75110aa78cea6b637f303509/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=a4a249fcab3d495e75110aa78cea6b637f303509", "patch": "@@ -378,6 +378,25 @@ impl<'a> SpanUtils<'a> {\n         }\n     }\n \n+    // Given a macro_rules definition span, return the span of the macro's name.\n+    pub fn span_for_macro_name(&self, span: Span) -> Option<Span> {\n+        let mut toks = self.retokenise_span(span);\n+        loop {\n+            let ts = toks.real_token();\n+            if ts.tok == token::Eof {\n+                return None;\n+            }\n+            if ts.tok == token::Not {\n+                let ts = toks.real_token();\n+                if ts.tok.is_ident() {\n+                    return self.make_sub_span(span, Some(ts.sp));\n+                } else {\n+                    return None;\n+                }\n+            }\n+        }\n+    }\n+\n     /// Return true if the span is generated code, and\n     /// it is not a subspan of the root callsite.\n     ///\n@@ -395,10 +414,16 @@ impl<'a> SpanUtils<'a> {\n         if sub_span.is_none() {\n             return true;\n         }\n-        // A generated span is deemed invalid if it is not a sub-span of the root\n+\n+        //If the span comes from a fake filemap, filter it.\n+        if !self.sess.codemap().lookup_char_pos(parent.lo).file.is_real_file() {\n+            return true;\n+        }\n+\n+        // Otherwise, a generated span is deemed invalid if it is not a sub-span of the root\n         // callsite. This filters out macro internal variables and most malformed spans.\n         let span = self.sess.codemap().source_callsite(parent);\n-        !(parent.lo >= span.lo && parent.hi <= span.hi)\n+        !(span.contains(parent))\n     }\n }\n "}, {"sha": "9da5e1e3881a916d727323378c5b27c706a47a01", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a4a249fcab3d495e75110aa78cea6b637f303509/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a249fcab3d495e75110aa78cea6b637f303509/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=a4a249fcab3d495e75110aa78cea6b637f303509", "patch": "@@ -1064,6 +1064,27 @@ impl CodeMap {\n         span\n     }\n \n+    /// Return the source callee.\n+    ///\n+    /// Returns None if the supplied span has no expansion trace,\n+    /// else returns the NameAndSpan for the macro definition\n+    /// corresponding to the source callsite.\n+    pub fn source_callee(&self, sp: Span) -> Option<NameAndSpan> {\n+        let mut span = sp;\n+        while let Some(callsite) = self.with_expn_info(span.expn_id,\n+                                            |ei| ei.map(|ei| ei.call_site.clone())) {\n+            if let Some(_) = self.with_expn_info(callsite.expn_id,\n+                                                |ei| ei.map(|ei| ei.call_site.clone())) {\n+                span = callsite;\n+            }\n+            else {\n+                return self.with_expn_info(span.expn_id,\n+                                           |ei| ei.map(|ei| ei.callee.clone()));\n+            }\n+        }\n+        None\n+    }\n+\n     pub fn span_to_filename(&self, sp: Span) -> FileName {\n         self.lookup_char_pos(sp.lo).file.name.to_string()\n     }"}]}