{"sha": "e2ecf279b6795d0a86a964fdc7a31c1f3981456f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyZWNmMjc5YjY3OTVkMGE4NmE5NjRmZGM3YTMxYzFmMzk4MTQ1NmY=", "commit": {"author": {"name": "Irving A.J. Rivas Z", "email": "axel.rivas@gmail.com", "date": "2015-10-19T14:02:46Z"}, "committer": {"name": "Irving A.J. Rivas Z", "email": "axel.rivas@gmail.com", "date": "2015-10-19T14:02:46Z"}, "message": "Made the example capable of consistent deadlocking\n\nTo augment the didactic effect, made placed the thread::sleep_ms call in the last example, so that there will be time for the other locks to happen; without this, I was unable to observe the deadlock in over 1,000 runs when there was no left-handed philosopher.", "tree": {"sha": "ae5fd23ca2acbd29a182143cd7cd5d7ab2673577", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae5fd23ca2acbd29a182143cd7cd5d7ab2673577"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2ecf279b6795d0a86a964fdc7a31c1f3981456f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2ecf279b6795d0a86a964fdc7a31c1f3981456f", "html_url": "https://github.com/rust-lang/rust/commit/e2ecf279b6795d0a86a964fdc7a31c1f3981456f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2ecf279b6795d0a86a964fdc7a31c1f3981456f/comments", "author": {"login": "iajrz", "id": 4443604, "node_id": "MDQ6VXNlcjQ0NDM2MDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4443604?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iajrz", "html_url": "https://github.com/iajrz", "followers_url": "https://api.github.com/users/iajrz/followers", "following_url": "https://api.github.com/users/iajrz/following{/other_user}", "gists_url": "https://api.github.com/users/iajrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/iajrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iajrz/subscriptions", "organizations_url": "https://api.github.com/users/iajrz/orgs", "repos_url": "https://api.github.com/users/iajrz/repos", "events_url": "https://api.github.com/users/iajrz/events{/privacy}", "received_events_url": "https://api.github.com/users/iajrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iajrz", "id": 4443604, "node_id": "MDQ6VXNlcjQ0NDM2MDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4443604?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iajrz", "html_url": "https://github.com/iajrz", "followers_url": "https://api.github.com/users/iajrz/followers", "following_url": "https://api.github.com/users/iajrz/following{/other_user}", "gists_url": "https://api.github.com/users/iajrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/iajrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iajrz/subscriptions", "organizations_url": "https://api.github.com/users/iajrz/orgs", "repos_url": "https://api.github.com/users/iajrz/repos", "events_url": "https://api.github.com/users/iajrz/events{/privacy}", "received_events_url": "https://api.github.com/users/iajrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e268f2fbafca7e0a59bf77e17985a27c61d5a11", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e268f2fbafca7e0a59bf77e17985a27c61d5a11", "html_url": "https://github.com/rust-lang/rust/commit/3e268f2fbafca7e0a59bf77e17985a27c61d5a11"}], "stats": {"total": 13, "additions": 10, "deletions": 3}, "files": [{"sha": "e81ae4648ad4323c9daa1f0631b25bd7c4dc62d1", "filename": "src/doc/trpl/dining-philosophers.md", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e2ecf279b6795d0a86a964fdc7a31c1f3981456f/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md", "raw_url": "https://github.com/rust-lang/rust/raw/e2ecf279b6795d0a86a964fdc7a31c1f3981456f/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md?ref=e2ecf279b6795d0a86a964fdc7a31c1f3981456f", "patch": "@@ -512,6 +512,7 @@ impl Philosopher {\n \n     fn eat(&self, table: &Table) {\n         let _left = table.forks[self.left].lock().unwrap();\n+        thread::sleep_ms(150);\n         let _right = table.forks[self.right].lock().unwrap();\n \n         println!(\"{} is eating.\", self.name);\n@@ -597,6 +598,7 @@ We now need to construct those `left` and `right` values, so we add them to\n ```rust,ignore\n fn eat(&self, table: &Table) {\n     let _left = table.forks[self.left].lock().unwrap();\n+    thread::sleep_ms(150);\n     let _right = table.forks[self.right].lock().unwrap();\n \n     println!(\"{} is eating.\", self.name);\n@@ -607,11 +609,14 @@ fn eat(&self, table: &Table) {\n }\n ```\n \n-We have two new lines. We\u2019ve also added an argument, `table`. We access the\n+We have three new lines. We\u2019ve added an argument, `table`. We access the\n `Table`\u2019s list of forks, and then use `self.left` and `self.right` to access\n the fork at that particular index. That gives us access to the `Mutex` at that\n index, and we call `lock()` on it. If the mutex is currently being accessed by\n-someone else, we\u2019ll block until it becomes available.\n+someone else, we\u2019ll block until it becomes available. We have also a call to\n+`thread::sleep_ms` between the moment first fork is picked and the moment the\n+second forked is picked, as the process  of picking up the fork is not\n+immediate.\n \n The call to `lock()` might fail, and if it does, we want to crash. In this\n case, the error that could happen is that the mutex is [\u2018poisoned\u2019][poison],\n@@ -660,7 +665,9 @@ We need to pass in our `left` and `right` values to the constructors for our\n you look at the pattern, it\u2019s all consistent until the very end. Monsieur\n Foucault should have `4, 0` as arguments, but instead, has `0, 4`. This is what\n prevents deadlock, actually: one of our philosophers is left handed! This is\n-one way to solve the problem, and in my opinion, it\u2019s the simplest.\n+one way to solve the problem, and in my opinion, it\u2019s the simplest. If you\n+change the order of the parameters, you will be able to observe the deadlock\n+taking place.\n \n ```rust,ignore\n let handles: Vec<_> = philosophers.into_iter().map(|p| {"}]}