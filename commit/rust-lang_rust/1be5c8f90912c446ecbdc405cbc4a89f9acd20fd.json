{"sha": "1be5c8f90912c446ecbdc405cbc4a89f9acd20fd", "node_id": "C_kwDOAAsO6NoAKDFiZTVjOGY5MDkxMmM0NDZlY2JkYzQwNWNiYzRhODlmOWFjZDIwZmQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-03T01:08:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-03T01:08:45Z"}, "message": "Auto merge of #93432 - Kobzol:stable-hash-isize-hash-compression, r=the8472\n\nCompress amount of hashed bytes for `isize` values in StableHasher\n\nThis is another attempt to land https://github.com/rust-lang/rust/pull/92103, this time hopefully with a correct implementation w.r.t. stable hashing guarantees. The previous PR was [reverted](https://github.com/rust-lang/rust/pull/93014) because it could produce the [same hash](https://github.com/rust-lang/rust/pull/92103#issuecomment-1014625442) for different values even in quite simple situations. I have since added a basic [test](https://github.com/rust-lang/rust/pull/93193) that should guard against that situation, I also added a new test in this PR, specialised for this optimization.\n\n## Why this optimization helps\nSince the original PR, I have tried to analyze why this optimization even helps (and why it especially helps for `clap`). I found that the vast majority of stable-hashing `i64` actually comes from hashing `isize` (which is converted to `i64` in the stable hasher). I only found a single place where is this datatype used directly in the compiler, and this place has also been showing up in traces that I used to find out when is `isize` being hashed. This place is `rustc_span::FileName::DocTest`, however, I suppose that isizes also come from other places, but they might not be so easy to find (there were some other entries in the trace). `clap` hashes about 8.5 million `isize`s, and all of them fit into a single byte, which is why this optimization has helped it [quite a lot](https://github.com/rust-lang/rust/pull/92103#issuecomment-1005711861).\n\nNow, I'm not sure if special casing `isize` is the correct solution here, maybe something could be done with that `isize` inside `DocTest` or in other places, but that's for another discussion I suppose. In this PR, instead of hardcoding a special case inside `SipHasher128`, I instead put it into `StableHasher`, and only used it for `isize` (I tested that for `i64` it doesn't help, or at least not for `clap` and other few benchmarks that I was testing).\n\n## New approach\nSince the most common case is a single byte, I added a fast path for hashing `isize` values which positive value fits within a single byte, and a cold path for the rest of the values.\n\nTo avoid the previous correctness problem, we need to make sure that each unique `isize` value will produce a unique hash stream to the hasher. By hash stream I mean a sequence of bytes that will be hashed (a different sequence should produce a different hash, but that is of course not guaranteed).\n\nWe have to distinguish different values that produce the same bit pattern when we combine them. For example, if we just simply skipped the leading zero bytes for values that fit within a single byte, `(0xFF, 0xFFFFFFFFFFFFFFFF)` and `(0xFFFFFFFFFFFFFFFF, 0xFF)` would send the same hash stream to the hasher, which must not happen.\n\nTo avoid this situation, values `[0, 0xFE]` are hashed as a single byte. When we hash a larger (treating `isize` as `u64`) value, we first hash an additional byte `0xFF`. Since `0xFF` cannot occur when we apply the single byte optimization, we guarantee that the hash streams will be unique when hashing two values `(a, b)` and `(b, a)` if `a != b`:\n1) When both `a` and `b` are within `[0, 0xFE]`, their hash streams will be different.\n2) When neither `a` and `b` are within `[0, 0xFE]`, their hash streams will be different.\n3) When `a` is within `[0, 0xFE]` and `b` isn't, when we hash `(a, b)`, the hash stream will definitely not begin with `0xFF`. When we hash `(b, a)`, the hash stream will definitely begin with `0xFF`. Therefore the hash streams will be different.\n\nr? `@the8472`", "tree": {"sha": "a6bbf76a65d1cbe55c5ed47b89e639e81884dd17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6bbf76a65d1cbe55c5ed47b89e639e81884dd17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1be5c8f90912c446ecbdc405cbc4a89f9acd20fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1be5c8f90912c446ecbdc405cbc4a89f9acd20fd", "html_url": "https://github.com/rust-lang/rust/commit/1be5c8f90912c446ecbdc405cbc4a89f9acd20fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1be5c8f90912c446ecbdc405cbc4a89f9acd20fd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3800860e123443ffada615538926beed6bc4f85", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3800860e123443ffada615538926beed6bc4f85", "html_url": "https://github.com/rust-lang/rust/commit/b3800860e123443ffada615538926beed6bc4f85"}, {"sha": "8de59be93302781390491666409c35e60664c3fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/8de59be93302781390491666409c35e60664c3fd", "html_url": "https://github.com/rust-lang/rust/commit/8de59be93302781390491666409c35e60664c3fd"}], "stats": {"total": 66, "additions": 57, "deletions": 9}, "files": [{"sha": "1495521ddbb5433967bdba3c79f06511e09d86c2", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1be5c8f90912c446ecbdc405cbc4a89f9acd20fd/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be5c8f90912c446ecbdc405cbc4a89f9acd20fd/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=1be5c8f90912c446ecbdc405cbc4a89f9acd20fd", "patch": "@@ -137,7 +137,35 @@ impl Hasher for StableHasher {\n         // platforms. This is important for symbol hashes when cross compiling,\n         // for example. Sign extending here is preferable as it means that the\n         // same negative number hashes the same on both 32 and 64 bit platforms.\n-        self.state.write_i64((i as i64).to_le());\n+        let value = (i as i64).to_le() as u64;\n+\n+        // Cold path\n+        #[cold]\n+        #[inline(never)]\n+        fn hash_value(state: &mut SipHasher128, value: u64) {\n+            state.write_u8(0xFF);\n+            state.write_u64(value);\n+        }\n+\n+        // `isize` values often seem to have a small (positive) numeric value in practice.\n+        // To exploit this, if the value is small, we will hash a smaller amount of bytes.\n+        // However, we cannot just skip the leading zero bytes, as that would produce the same hash\n+        // e.g. if you hash two values that have the same bit pattern when they are swapped.\n+        // See https://github.com/rust-lang/rust/pull/93014 for context.\n+        //\n+        // Therefore, we employ the following strategy:\n+        // 1) When we encounter a value that fits within a single byte (the most common case), we\n+        // hash just that byte. This is the most common case that is being optimized. However, we do\n+        // not do this for the value 0xFF, as that is a reserved prefix (a bit like in UTF-8).\n+        // 2) When we encounter a larger value, we hash a \"marker\" 0xFF and then the corresponding\n+        // 8 bytes. Since this prefix cannot occur when we hash a single byte, when we hash two\n+        // `isize`s that fit within a different amount of bytes, they should always produce a different\n+        // byte stream for the hasher.\n+        if value < 0xFF {\n+            self.state.write_u8(value as u8);\n+        } else {\n+            hash_value(&mut self.state, value);\n+        }\n     }\n }\n "}, {"sha": "a84ee3da438c7635697657b83e8fbc573114fd8a", "filename": "compiler/rustc_data_structures/src/stable_hasher/tests.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1be5c8f90912c446ecbdc405cbc4a89f9acd20fd/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be5c8f90912c446ecbdc405cbc4a89f9acd20fd/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs?ref=1be5c8f90912c446ecbdc405cbc4a89f9acd20fd", "patch": "@@ -39,7 +39,7 @@ fn test_hash_integers() {\n     test_isize.hash(&mut h);\n \n     // This depends on the hashing algorithm. See note at top of file.\n-    let expected = (2736651863462566372, 8121090595289675650);\n+    let expected = (1784307454142909076, 11471672289340283879);\n \n     assert_eq!(h.finalize(), expected);\n }\n@@ -67,7 +67,7 @@ fn test_hash_isize() {\n     test_isize.hash(&mut h);\n \n     // This depends on the hashing algorithm. See note at top of file.\n-    let expected = (14721296605626097289, 11385941877786388409);\n+    let expected = (2789913510339652884, 674280939192711005);\n \n     assert_eq!(h.finalize(), expected);\n }\n@@ -140,3 +140,23 @@ fn test_attribute_permutation() {\n     test_type!(i64);\n     test_type!(i128);\n }\n+\n+// Check that the `isize` hashing optimization does not produce the same hash when permuting two\n+// values.\n+#[test]\n+fn test_isize_compression() {\n+    fn check_hash(a: u64, b: u64) {\n+        let hash_a = hash(&(a as isize, b as isize));\n+        let hash_b = hash(&(b as isize, a as isize));\n+        assert_ne!(\n+            hash_a, hash_b,\n+            \"The hash stayed the same when permuting values `{a}` and `{b}!\",\n+        );\n+    }\n+\n+    check_hash(0xAA, 0xAAAA);\n+    check_hash(0xFF, 0xFFFF);\n+    check_hash(0xAAAA, 0xAAAAAA);\n+    check_hash(0xAAAAAA, 0xAAAAAAAA);\n+    check_hash(0xFF, 0xFFFFFFFFFFFFFFFF);\n+}"}, {"sha": "73e34d4bb32115ece94e185e26772cac7844cc62", "filename": "src/test/debuginfo/function-names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1be5c8f90912c446ecbdc405cbc4a89f9acd20fd/src%2Ftest%2Fdebuginfo%2Ffunction-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be5c8f90912c446ecbdc405cbc4a89f9acd20fd/src%2Ftest%2Fdebuginfo%2Ffunction-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-names.rs?ref=1be5c8f90912c446ecbdc405cbc4a89f9acd20fd", "patch": "@@ -37,7 +37,7 @@\n // Const generic parameter\n // gdb-command:info functions -q function_names::const_generic_fn.*\n // gdb-check:[...]static fn function_names::const_generic_fn_bool<false>();\n-// gdb-check:[...]static fn function_names::const_generic_fn_non_int<{CONST#fe3cfa0214ac55c7}>();\n+// gdb-check:[...]static fn function_names::const_generic_fn_non_int<{CONST#3fcd7c34c1555be6}>();\n // gdb-check:[...]static fn function_names::const_generic_fn_signed_int<-7>();\n // gdb-check:[...]static fn function_names::const_generic_fn_unsigned_int<14>();\n \n@@ -76,7 +76,7 @@\n // Const generic parameter\n // cdb-command:x a!function_names::const_generic_fn*\n // cdb-check:[...] a!function_names::const_generic_fn_bool<false> (void)\n-// cdb-check:[...] a!function_names::const_generic_fn_non_int<CONST$fe3cfa0214ac55c7> (void)\n+// cdb-check:[...] a!function_names::const_generic_fn_non_int<CONST$3fcd7c34c1555be6> (void)\n // cdb-check:[...] a!function_names::const_generic_fn_unsigned_int<14> (void)\n // cdb-check:[...] a!function_names::const_generic_fn_signed_int<-7> (void)\n "}, {"sha": "429e28e5241dc3f3f5b9873b0be323e049d49049", "filename": "src/test/ui/symbol-names/basic.legacy.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1be5c8f90912c446ecbdc405cbc4a89f9acd20fd/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.legacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1be5c8f90912c446ecbdc405cbc4a89f9acd20fd/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.legacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.legacy.stderr?ref=1be5c8f90912c446ecbdc405cbc4a89f9acd20fd", "patch": "@@ -1,10 +1,10 @@\n-error: symbol-name(_ZN5basic4main17h7c2c715a9b77648bE)\n+error: symbol-name(_ZN5basic4main17h611df9c6948c15f7E)\n   --> $DIR/basic.rs:8:1\n    |\n LL | #[rustc_symbol_name]\n    | ^^^^^^^^^^^^^^^^^^^^\n \n-error: demangling(basic::main::h7c2c715a9b77648b)\n+error: demangling(basic::main::h611df9c6948c15f7)\n   --> $DIR/basic.rs:8:1\n    |\n LL | #[rustc_symbol_name]"}, {"sha": "0e36747fb8071e81507a6be8b7461de34af8d547", "filename": "src/test/ui/symbol-names/issue-60925.legacy.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1be5c8f90912c446ecbdc405cbc4a89f9acd20fd/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.legacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1be5c8f90912c446ecbdc405cbc4a89f9acd20fd/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.legacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.legacy.stderr?ref=1be5c8f90912c446ecbdc405cbc4a89f9acd20fd", "patch": "@@ -1,10 +1,10 @@\n-error: symbol-name(_ZN11issue_609253foo37Foo$LT$issue_60925..llv$u6d$..Foo$GT$3foo17h419983d0842a72aeE)\n+error: symbol-name(_ZN11issue_609253foo37Foo$LT$issue_60925..llv$u6d$..Foo$GT$3foo17h5425dadb5b1e5fb6E)\n   --> $DIR/issue-60925.rs:21:9\n    |\n LL |         #[rustc_symbol_name]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: demangling(issue_60925::foo::Foo<issue_60925::llvm::Foo>::foo::h419983d0842a72ae)\n+error: demangling(issue_60925::foo::Foo<issue_60925::llvm::Foo>::foo::h5425dadb5b1e5fb6)\n   --> $DIR/issue-60925.rs:21:9\n    |\n LL |         #[rustc_symbol_name]"}]}