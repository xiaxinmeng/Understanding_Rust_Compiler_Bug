{"sha": "e8a76d8accf04047a938ba43b32d5ff9ab581715", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4YTc2ZDhhY2NmMDQwNDdhOTM4YmE0M2IzMmQ1ZmY5YWI1ODE3MTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-17T22:05:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-17T22:05:31Z"}, "message": "Auto merge of #44529 - alexcrichton:trans-query, r=michaelwoerister\n\nRefactor translation unit partitioning/collection as a query\n\nThis commit is targeted at #44486 with the ultimate goal of making the `collect_and_partition_translation_items` function a query. This mostly just involved query-ifying a few other systems along with plumbing the tcx instead of `SharedCrateContext` in a few locations.\n\nCurrently this only tackles the first bullet of #44486 and doesn't add a dedicated query for a particular codegen unit. I wasn't quite sure how to do that yet but figured this was good to put up.\n\nCloses #44486", "tree": {"sha": "9c8a37e523ef8300f9600dd73a84018f742bca85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c8a37e523ef8300f9600dd73a84018f742bca85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8a76d8accf04047a938ba43b32d5ff9ab581715", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8a76d8accf04047a938ba43b32d5ff9ab581715", "html_url": "https://github.com/rust-lang/rust/commit/e8a76d8accf04047a938ba43b32d5ff9ab581715", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8a76d8accf04047a938ba43b32d5ff9ab581715/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfcac37204c8dbdde192c1c9387cdbe663fe5ed5", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfcac37204c8dbdde192c1c9387cdbe663fe5ed5", "html_url": "https://github.com/rust-lang/rust/commit/cfcac37204c8dbdde192c1c9387cdbe663fe5ed5"}, {"sha": "6d614ddc2ebc25d3987b1efc84c0c7fea00ce325", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d614ddc2ebc25d3987b1efc84c0c7fea00ce325", "html_url": "https://github.com/rust-lang/rust/commit/6d614ddc2ebc25d3987b1efc84c0c7fea00ce325"}], "stats": {"total": 2699, "additions": 1452, "deletions": 1247}, "files": [{"sha": "06469c16bc22e214f15aa926ba826f1b0e016acd", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -71,6 +71,7 @@ use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use ich::StableHashingContext;\n use std::fmt;\n use std::hash::Hash;\n+use syntax_pos::symbol::InternedString;\n \n // erase!() just makes tokens go away. It's used to specify which macro argument\n // is repeated (i.e. which sub-expression of the macro we are in) but don't need\n@@ -535,7 +536,7 @@ define_dep_nodes!( <'tcx>\n     [] GetPanicStrategy(CrateNum),\n     [] IsNoBuiltins(CrateNum),\n     [] ImplDefaultness(DefId),\n-    [] ExportedSymbols(CrateNum),\n+    [] ExportedSymbolIds(CrateNum),\n     [] NativeLibraries(CrateNum),\n     [] PluginRegistrarFn(CrateNum),\n     [] DeriveRegistrarFn(CrateNum),\n@@ -575,6 +576,14 @@ define_dep_nodes!( <'tcx>\n     [] MaybeUnusedExternCrates,\n     [] StabilityIndex,\n     [] AllCrateNums,\n+    [] ExportedSymbols(CrateNum),\n+    [] CollectAndPartitionTranslationItems,\n+    [] ExportName(DefId),\n+    [] ContainsExternIndicator(DefId),\n+    [] IsTranslatedFunction(DefId),\n+    [] CodegenUnit(InternedString),\n+    [] CompileCodegenUnit(InternedString),\n+    [] OutputFilenames,\n );\n \n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {"}, {"sha": "f7b1d2d92f717fef2739841be82755e6fb9ccbd9", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -92,6 +92,7 @@ pub mod middle {\n     pub mod dependency_format;\n     pub mod effect;\n     pub mod entry;\n+    pub mod exported_symbols;\n     pub mod free_region;\n     pub mod intrinsicck;\n     pub mod lang_items;\n@@ -103,6 +104,7 @@ pub mod middle {\n     pub mod recursion_limit;\n     pub mod resolve_lifetime;\n     pub mod stability;\n+    pub mod trans;\n     pub mod weak_lang_items;\n }\n "}, {"sha": "bea6ef4dc11ce6d850f93e5e98445794397d1d88", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -366,8 +366,9 @@ pub trait CrateLoader {\n // In order to get this left-to-right dependency ordering, we perform a\n // topological sort of all crates putting the leaves at the right-most\n // positions.\n-pub fn used_crates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)> {\n+pub fn used_crates(tcx: TyCtxt, prefer: LinkagePreference)\n+    -> Vec<(CrateNum, LibSource)>\n+{\n     let mut libs = tcx.crates()\n         .iter()\n         .cloned()"}, {"sha": "230878f8545950c34428c6d650ab1866a3dec9f7", "filename": "src/librustc/middle/exported_symbols.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The SymbolExportLevel of a symbols specifies from which kinds of crates\n+/// the symbol will be exported. `C` symbols will be exported from any\n+/// kind of crate, including cdylibs which export very few things.\n+/// `Rust` will only be exported if the crate produced is a Rust\n+/// dylib.\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+pub enum SymbolExportLevel {\n+    C,\n+    Rust,\n+}\n+\n+impl SymbolExportLevel {\n+    pub fn is_below_threshold(self, threshold: SymbolExportLevel) -> bool {\n+        if threshold == SymbolExportLevel::Rust {\n+            // We export everything from Rust dylibs\n+            true\n+        } else {\n+            self == SymbolExportLevel::C\n+        }\n+    }\n+}"}, {"sha": "7c4424509019705b0ca921e78fb2a4548efb37d8", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -233,8 +233,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 } else {\n                     false\n                 };\n-                let is_extern = attr::contains_extern_indicator(&self.tcx.sess.diagnostic(),\n-                                                                &item.attrs);\n+                let def_id = self.tcx.hir.local_def_id(item.id);\n+                let is_extern = self.tcx.contains_extern_indicator(def_id);\n                 if reachable || is_extern {\n                     self.reachable_symbols.insert(search_item);\n                 }\n@@ -369,10 +369,6 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n     }\n }\n \n-pub fn find_reachable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Rc<NodeSet> {\n-    tcx.reachable_set(LOCAL_CRATE)\n-}\n-\n fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) -> Rc<NodeSet> {\n     debug_assert!(crate_num == LOCAL_CRATE);\n "}, {"sha": "9a50125754846f2ba017360929460db7f6de319c", "filename": "src/librustc/middle/trans.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -0,0 +1,110 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::ast::NodeId;\n+use syntax::symbol::InternedString;\n+use ty::Instance;\n+use util::nodemap::FxHashMap;\n+\n+#[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n+pub enum TransItem<'tcx> {\n+    Fn(Instance<'tcx>),\n+    Static(NodeId),\n+    GlobalAsm(NodeId),\n+}\n+\n+pub struct CodegenUnit<'tcx> {\n+    /// A name for this CGU. Incremental compilation requires that\n+    /// name be unique amongst **all** crates.  Therefore, it should\n+    /// contain something unique to this crate (e.g., a module path)\n+    /// as well as the crate name and disambiguator.\n+    name: InternedString,\n+    items: FxHashMap<TransItem<'tcx>, (Linkage, Visibility)>,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum Linkage {\n+    External,\n+    AvailableExternally,\n+    LinkOnceAny,\n+    LinkOnceODR,\n+    WeakAny,\n+    WeakODR,\n+    Appending,\n+    Internal,\n+    Private,\n+    ExternalWeak,\n+    Common,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum Visibility {\n+    Default,\n+    Hidden,\n+    Protected,\n+}\n+\n+impl<'tcx> CodegenUnit<'tcx> {\n+    pub fn new(name: InternedString) -> CodegenUnit<'tcx> {\n+        CodegenUnit {\n+            name: name,\n+            items: FxHashMap(),\n+        }\n+    }\n+\n+    pub fn name(&self) -> &InternedString {\n+        &self.name\n+    }\n+\n+    pub fn set_name(&mut self, name: InternedString) {\n+        self.name = name;\n+    }\n+\n+    pub fn items(&self) -> &FxHashMap<TransItem<'tcx>, (Linkage, Visibility)> {\n+        &self.items\n+    }\n+\n+    pub fn items_mut(&mut self)\n+        -> &mut FxHashMap<TransItem<'tcx>, (Linkage, Visibility)>\n+    {\n+        &mut self.items\n+    }\n+}\n+\n+#[derive(Clone, Default)]\n+pub struct Stats {\n+    pub n_glues_created: usize,\n+    pub n_null_glues: usize,\n+    pub n_real_glues: usize,\n+    pub n_fns: usize,\n+    pub n_inlines: usize,\n+    pub n_closures: usize,\n+    pub n_llvm_insns: usize,\n+    pub llvm_insns: FxHashMap<String, usize>,\n+    // (ident, llvm-instructions)\n+    pub fn_stats: Vec<(String, usize)>,\n+}\n+\n+impl Stats {\n+    pub fn extend(&mut self, stats: Stats) {\n+        self.n_glues_created += stats.n_glues_created;\n+        self.n_null_glues += stats.n_null_glues;\n+        self.n_real_glues += stats.n_real_glues;\n+        self.n_fns += stats.n_fns;\n+        self.n_inlines += stats.n_inlines;\n+        self.n_closures += stats.n_closures;\n+        self.n_llvm_insns += stats.n_llvm_insns;\n+\n+        for (k, v) in stats.llvm_insns {\n+            *self.llvm_insns.entry(k).or_insert(0) += v;\n+        }\n+        self.fn_stats.extend(stats.fn_stats);\n+    }\n+}"}, {"sha": "945a08144275015aff769ed66a265f76eb3f387d", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -13,6 +13,7 @@\n use dep_graph::DepGraph;\n use errors::DiagnosticBuilder;\n use session::Session;\n+use session::config::OutputFilenames;\n use middle;\n use hir::{TraitCandidate, HirId, ItemLocalId};\n use hir::def::{Def, Export};\n@@ -64,6 +65,8 @@ use std::mem;\n use std::ops::Deref;\n use std::iter;\n use std::rc::Rc;\n+use std::sync::mpsc;\n+use std::sync::Arc;\n use syntax::abi;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n@@ -901,6 +904,16 @@ pub struct GlobalCtxt<'tcx> {\n     /// error reporting, and so is lazily initialized and generally\n     /// shouldn't taint the common path (hence the RefCell).\n     pub all_traits: RefCell<Option<Vec<DefId>>>,\n+\n+    /// A general purpose channel to throw data out the back towards LLVM worker\n+    /// threads.\n+    ///\n+    /// This is intended to only get used during the trans phase of the compiler\n+    /// when satisfying the query for a particular codegen unit. Internally in\n+    /// the query it'll send data along this channel to get processed later.\n+    pub tx_to_llvm_workers: mpsc::Sender<Box<Any + Send>>,\n+\n+    output_filenames: Arc<OutputFilenames>,\n }\n \n impl<'tcx> GlobalCtxt<'tcx> {\n@@ -1025,6 +1038,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                   named_region_map: resolve_lifetime::NamedRegionMap,\n                                   hir: hir_map::Map<'tcx>,\n                                   crate_name: &str,\n+                                  tx: mpsc::Sender<Box<Any + Send>>,\n+                                  output_filenames: &OutputFilenames,\n                                   f: F) -> R\n                                   where F: for<'b> FnOnce(TyCtxt<'b, 'tcx, 'tcx>) -> R\n     {\n@@ -1145,6 +1160,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             derive_macros: RefCell::new(NodeMap()),\n             stability_interner: RefCell::new(FxHashSet()),\n             all_traits: RefCell::new(None),\n+            tx_to_llvm_workers: tx,\n+            output_filenames: Arc::new(output_filenames.clone()),\n        }, f)\n     }\n \n@@ -2218,4 +2235,8 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         assert_eq!(cnum, LOCAL_CRATE);\n         Rc::new(tcx.cstore.postorder_cnums_untracked())\n     };\n+    providers.output_filenames = |tcx, cnum| {\n+        assert_eq!(cnum, LOCAL_CRATE);\n+        tcx.output_filenames.clone()\n+    };\n }"}, {"sha": "bf17b82535cc1491d71e2800fe732ddebccfaa41", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 67, "deletions": 2, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -23,9 +23,12 @@ use middle::region;\n use middle::resolve_lifetime::{Region, ObjectLifetimeDefault};\n use middle::stability::{self, DeprecationEntry};\n use middle::lang_items::{LanguageItems, LangItem};\n+use middle::exported_symbols::SymbolExportLevel;\n+use middle::trans::{CodegenUnit, Stats};\n use mir;\n use mir::transform::{MirSuite, MirPassIndex};\n use session::CompileResult;\n+use session::config::OutputFilenames;\n use traits::specialization_graph;\n use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n use ty::layout::{Layout, LayoutError};\n@@ -48,7 +51,9 @@ use std::mem;\n use std::collections::BTreeMap;\n use std::ops::Deref;\n use std::rc::Rc;\n+use std::sync::Arc;\n use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::symbol::InternedString;\n use syntax::attr;\n use syntax::ast;\n use syntax::symbol::Symbol;\n@@ -177,6 +182,15 @@ impl<'tcx, T: Key> Key for ty::ParamEnvAnd<'tcx, T> {\n     }\n }\n \n+impl Key for InternedString {\n+    fn map_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+    fn default_span(&self, _tcx: TyCtxt) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n trait Value<'tcx>: Sized {\n     fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self;\n }\n@@ -595,7 +609,7 @@ impl<'tcx> QueryDescription for queries::is_sanitizer_runtime<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::exported_symbols<'tcx> {\n+impl<'tcx> QueryDescription for queries::exported_symbol_ids<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"looking up the exported symbols of a crate\")\n     }\n@@ -745,6 +759,36 @@ impl<'tcx> QueryDescription for queries::all_crate_nums<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::exported_symbols<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"exported_symbols\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::collect_and_partition_translation_items<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"collect_and_partition_translation_items\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::codegen_unit<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: InternedString) -> String {\n+        format!(\"codegen_unit\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::compile_codegen_unit<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: InternedString) -> String {\n+        format!(\"compile_codegen_unit\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::output_filenames<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"output_filenames\")\n+    }\n+}\n+\n // If enabled, send a message to the profile-queries thread\n macro_rules! profq_msg {\n     ($tcx:expr, $msg:expr) => {\n@@ -1322,7 +1366,7 @@ define_maps! { <'tcx>\n     [] fn lint_levels: lint_levels_node(CrateNum) -> Rc<lint::LintLevelMap>,\n \n     [] fn impl_defaultness: ImplDefaultness(DefId) -> hir::Defaultness,\n-    [] fn exported_symbols: ExportedSymbols(CrateNum) -> Rc<Vec<DefId>>,\n+    [] fn exported_symbol_ids: ExportedSymbolIds(CrateNum) -> Rc<DefIdSet>,\n     [] fn native_libraries: NativeLibraries(CrateNum) -> Rc<Vec<NativeLibrary>>,\n     [] fn plugin_registrar_fn: PluginRegistrarFn(CrateNum) -> Option<DefId>,\n     [] fn derive_registrar_fn: DeriveRegistrarFn(CrateNum) -> Option<DefId>,\n@@ -1371,6 +1415,19 @@ define_maps! { <'tcx>\n \n     [] fn stability_index: stability_index_node(CrateNum) -> Rc<stability::Index<'tcx>>,\n     [] fn all_crate_nums: all_crate_nums_node(CrateNum) -> Rc<Vec<CrateNum>>,\n+\n+    [] fn exported_symbols: ExportedSymbols(CrateNum)\n+        -> Arc<Vec<(String, DefId, SymbolExportLevel)>>,\n+    [] fn collect_and_partition_translation_items:\n+        collect_and_partition_translation_items_node(CrateNum)\n+        -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>),\n+    [] fn export_name: ExportName(DefId) -> Option<Symbol>,\n+    [] fn contains_extern_indicator: ContainsExternIndicator(DefId) -> bool,\n+    [] fn is_translated_function: IsTranslatedFunction(DefId) -> bool,\n+    [] fn codegen_unit: CodegenUnit(InternedString) -> Arc<CodegenUnit<'tcx>>,\n+    [] fn compile_codegen_unit: CompileCodegenUnit(InternedString) -> Stats,\n+    [] fn output_filenames: output_filenames_node(CrateNum)\n+        -> Arc<OutputFilenames>,\n }\n \n fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstructor<'tcx> {\n@@ -1484,3 +1541,11 @@ fn stability_index_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n fn all_crate_nums_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::AllCrateNums\n }\n+\n+fn collect_and_partition_translation_items_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::CollectAndPartitionTranslationItems\n+}\n+\n+fn output_filenames_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::OutputFilenames\n+}"}, {"sha": "e2df963f80fad9c085a10f78a9a61413c27e1767", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -121,7 +121,6 @@ mod sty;\n #[derive(Clone)]\n pub struct CrateAnalysis {\n     pub access_levels: Rc<AccessLevels>,\n-    pub reachable: Rc<NodeSet>,\n     pub name: String,\n     pub glob_map: Option<hir::GlobMap>,\n }"}, {"sha": "32a160bcffcef21c66285350061f883ed1b31f5b", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -28,7 +28,6 @@ use rustc::mir::transform::{MIR_CONST, MIR_VALIDATED, MIR_OPTIMIZED, Passes};\n use rustc::ty::{self, TyCtxt, Resolutions, GlobalArenas};\n use rustc::traits;\n use rustc::util::common::{ErrorReported, time};\n-use rustc::util::nodemap::NodeSet;\n use rustc_allocator as allocator;\n use rustc_borrowck as borrowck;\n use rustc_incremental::{self, IncrementalHashesMap};\n@@ -47,13 +46,15 @@ use super::Compilation;\n \n use serialize::json;\n \n+use std::any::Any;\n use std::env;\n use std::ffi::{OsString, OsStr};\n use std::fs;\n use std::io::{self, Write};\n use std::iter;\n use std::path::{Path, PathBuf};\n use std::rc::Rc;\n+use std::sync::mpsc;\n use syntax::{ast, diagnostics, visit};\n use syntax::attr;\n use syntax::ext::base::ExtCtxt;\n@@ -192,6 +193,7 @@ pub fn compile_input(sess: &Session,\n                                                                   &resolutions,\n                                                                   &expanded_crate,\n                                                                   &hir_map.krate(),\n+                                                                  &outputs,\n                                                                   &crate_name),\n                                     Ok(()));\n         }\n@@ -215,7 +217,8 @@ pub fn compile_input(sess: &Session,\n                                     &arena,\n                                     &arenas,\n                                     &crate_name,\n-                                    |tcx, analysis, incremental_hashes_map, result| {\n+                                    &outputs,\n+                                    |tcx, analysis, incremental_hashes_map, rx, result| {\n             {\n                 // Eventually, we will want to track plugins.\n                 let _ignore = tcx.dep_graph.in_ignore();\n@@ -243,8 +246,9 @@ pub fn compile_input(sess: &Session,\n                 tcx.print_debug_stats();\n             }\n \n-            let trans = phase_4_translate_to_llvm(tcx, analysis, incremental_hashes_map,\n-                                                  &outputs);\n+            let trans = phase_4_translate_to_llvm(tcx,\n+                                                  incremental_hashes_map,\n+                                                  rx);\n \n             if log_enabled!(::log::LogLevel::Info) {\n                 println!(\"Post-trans\");\n@@ -258,7 +262,7 @@ pub fn compile_input(sess: &Session,\n                 }\n             }\n \n-            Ok((outputs, trans, tcx.dep_graph.clone()))\n+            Ok((outputs.clone(), trans, tcx.dep_graph.clone()))\n         })??\n     };\n \n@@ -483,6 +487,7 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n                                 resolutions: &'a Resolutions,\n                                 krate: &'a ast::Crate,\n                                 hir_crate: &'a hir::Crate,\n+                                output_filenames: &'a OutputFilenames,\n                                 crate_name: &'a str)\n                                 -> Self {\n         CompileState {\n@@ -495,6 +500,7 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n             resolutions: Some(resolutions),\n             expanded_crate: Some(krate),\n             hir_crate: Some(hir_crate),\n+            output_filenames: Some(output_filenames),\n             out_file: out_file.as_ref().map(|s| &**s),\n             ..CompileState::empty(input, session, out_dir)\n         }\n@@ -885,7 +891,6 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         defs: resolver.definitions,\n         analysis: ty::CrateAnalysis {\n             access_levels: Rc::new(AccessLevels::default()),\n-            reachable: Rc::new(NodeSet()),\n             name: crate_name.to_string(),\n             glob_map: if resolver.make_glob_map { Some(resolver.glob_map) } else { None },\n         },\n@@ -911,19 +916,21 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                arena: &'tcx DroplessArena,\n                                                arenas: &'tcx GlobalArenas<'tcx>,\n                                                name: &str,\n+                                               output_filenames: &OutputFilenames,\n                                                f: F)\n                                                -> Result<R, CompileIncomplete>\n     where F: for<'a> FnOnce(TyCtxt<'a, 'tcx, 'tcx>,\n                             ty::CrateAnalysis,\n                             IncrementalHashesMap,\n+                            mpsc::Receiver<Box<Any + Send>>,\n                             CompileResult) -> R\n {\n     macro_rules! try_with_f {\n-        ($e: expr, ($t: expr, $a: expr, $h: expr)) => {\n+        ($e: expr, ($($t:tt)*)) => {\n             match $e {\n                 Ok(x) => x,\n                 Err(x) => {\n-                    f($t, $a, $h, Err(x));\n+                    f($($t)*, Err(x));\n                     return Err(x);\n                 }\n             }\n@@ -958,7 +965,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     mir::provide(&mut local_providers);\n     reachable::provide(&mut local_providers);\n     rustc_privacy::provide(&mut local_providers);\n-    trans::provide(&mut local_providers);\n+    trans::provide_local(&mut local_providers);\n     typeck::provide(&mut local_providers);\n     ty::provide(&mut local_providers);\n     traits::provide(&mut local_providers);\n@@ -970,7 +977,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     let mut extern_providers = ty::maps::Providers::default();\n     cstore::provide(&mut extern_providers);\n-    trans::provide(&mut extern_providers);\n+    trans::provide_extern(&mut extern_providers);\n     ty::provide_extern(&mut extern_providers);\n     traits::provide_extern(&mut extern_providers);\n     // FIXME(eddyb) get rid of this once we replace const_eval with miri.\n@@ -1030,6 +1037,8 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::add_call_guards::CriticalCallEdges);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::dump_mir::Marker(\"PreTrans\"));\n \n+    let (tx, rx) = mpsc::channel();\n+\n     TyCtxt::create_and_enter(sess,\n                              cstore,\n                              local_providers,\n@@ -1041,6 +1050,8 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                              named_region_map,\n                              hir_map,\n                              name,\n+                             tx,\n+                             output_filenames,\n                              |tcx| {\n         let incremental_hashes_map =\n             time(time_passes,\n@@ -1056,7 +1067,8 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              || stability::check_unstable_api_usage(tcx));\n \n         // passes are timed inside typeck\n-        try_with_f!(typeck::check_crate(tcx), (tcx, analysis, incremental_hashes_map));\n+        try_with_f!(typeck::check_crate(tcx),\n+                    (tcx, analysis, incremental_hashes_map, rx));\n \n         time(time_passes,\n              \"const checking\",\n@@ -1100,14 +1112,9 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n         // lint warnings and so on -- kindck used to do this abort, but\n         // kindck is gone now). -nmatsakis\n         if sess.err_count() > 0 {\n-            return Ok(f(tcx, analysis, incremental_hashes_map, sess.compile_status()));\n+            return Ok(f(tcx, analysis, incremental_hashes_map, rx, sess.compile_status()));\n         }\n \n-        analysis.reachable =\n-            time(time_passes,\n-                 \"reachability checking\",\n-                 || reachable::find_reachable(tcx));\n-\n         time(time_passes, \"death checking\", || middle::dead::check_crate(tcx));\n \n         time(time_passes, \"unused lib feature checking\", || {\n@@ -1116,16 +1123,15 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n         time(time_passes, \"lint checking\", || lint::check_crate(tcx));\n \n-        return Ok(f(tcx, analysis, incremental_hashes_map, tcx.sess.compile_status()));\n+        return Ok(f(tcx, analysis, incremental_hashes_map, rx, tcx.sess.compile_status()));\n     })\n }\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n /// be discarded.\n pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                           analysis: ty::CrateAnalysis,\n                                            incremental_hashes_map: IncrementalHashesMap,\n-                                           output_filenames: &OutputFilenames)\n+                                           rx: mpsc::Receiver<Box<Any + Send>>)\n                                            -> write::OngoingCrateTranslation {\n     let time_passes = tcx.sess.time_passes();\n \n@@ -1134,9 +1140,9 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n          || ::rustc::middle::dependency_format::calculate(tcx));\n \n     let translation =\n-        time(time_passes,\n-             \"translation\",\n-             move || trans::trans_crate(tcx, analysis, incremental_hashes_map, output_filenames));\n+        time(time_passes, \"translation\", move || {\n+            trans::trans_crate(tcx, incremental_hashes_map, rx)\n+        });\n \n     if tcx.sess.profile_queries() {\n         profile::dump(\"profile_queries\".to_string())"}, {"sha": "044f4a5eaf512bec0ff28ccb98aa4e3ef190a943", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -645,6 +645,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                                                      ppm,\n                                                      state.arena.unwrap(),\n                                                      state.arenas.unwrap(),\n+                                                     state.output_filenames.unwrap(),\n                                                      opt_uii.clone(),\n                                                      state.out_file);\n                 };"}, {"sha": "cd153b820776e97e9f1a9827572e7d713d1b26cb", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -23,7 +23,7 @@ use rustc::cfg::graphviz::LabelledCFG;\n use rustc::dep_graph::DepGraph;\n use rustc::middle::cstore::CrateStore;\n use rustc::session::Session;\n-use rustc::session::config::Input;\n+use rustc::session::config::{Input, OutputFilenames};\n use rustc_borrowck as borrowck;\n use rustc_borrowck::graphviz as borrowck_dot;\n \n@@ -205,6 +205,7 @@ impl PpSourceMode {\n                                                resolutions: &Resolutions,\n                                                arena: &'tcx DroplessArena,\n                                                arenas: &'tcx GlobalArenas<'tcx>,\n+                                               output_filenames: &OutputFilenames,\n                                                id: &str,\n                                                f: F)\n                                                -> A\n@@ -235,7 +236,8 @@ impl PpSourceMode {\n                                                                  arena,\n                                                                  arenas,\n                                                                  id,\n-                                                                 |tcx, _, _, _| {\n+                                                                 output_filenames,\n+                                                                 |tcx, _, _, _, _| {\n                     let empty_tables = ty::TypeckTables::empty(None);\n                     let annotation = TypedAnnotation {\n                         tcx,\n@@ -888,6 +890,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                                 ppm: PpMode,\n                                                 arena: &'tcx DroplessArena,\n                                                 arenas: &'tcx GlobalArenas<'tcx>,\n+                                                output_filenames: &OutputFilenames,\n                                                 opt_uii: Option<UserIdentifiedItem>,\n                                                 ofile: Option<&Path>) {\n     let dep_graph = DepGraph::new(false);\n@@ -902,6 +905,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                             crate_name,\n                             arena,\n                             arenas,\n+                            output_filenames,\n                             ppm,\n                             opt_uii,\n                             ofile);\n@@ -940,6 +944,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                            resolutions,\n                                            arena,\n                                            arenas,\n+                                           output_filenames,\n                                            crate_name,\n                                            move |annotation, krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n@@ -964,6 +969,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                            resolutions,\n                                            arena,\n                                            arenas,\n+                                           output_filenames,\n                                            crate_name,\n                                            move |annotation, _| {\n                     debug!(\"pretty printing source code {:?}\", s);\n@@ -1007,6 +1013,7 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                        crate_name: &str,\n                                        arena: &'tcx DroplessArena,\n                                        arenas: &'tcx GlobalArenas<'tcx>,\n+                                       output_filenames: &OutputFilenames,\n                                        ppm: PpMode,\n                                        uii: Option<UserIdentifiedItem>,\n                                        ofile: Option<&Path>) {\n@@ -1028,7 +1035,8 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                                      arena,\n                                                      arenas,\n                                                      crate_name,\n-                                                     |tcx, _, _, _| {\n+                                                     output_filenames,\n+                                                     |tcx, _, _, _, _| {\n         match ppm {\n             PpmMir | PpmMirCFG => {\n                 if let Some(nodeid) = nodeid {"}, {"sha": "34f4e0e7b0c959f6e3dfaadb688fdca2ad2c7c17", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -10,6 +10,9 @@\n \n //! # Standalone Tests for the Inference Module\n \n+use std::path::PathBuf;\n+use std::sync::mpsc;\n+\n use driver;\n use rustc_lint;\n use rustc_resolve::MakeGlobMap;\n@@ -26,6 +29,7 @@ use rustc_metadata::cstore::CStore;\n use rustc::hir::map as hir_map;\n use rustc::mir::transform::Passes;\n use rustc::session::{self, config};\n+use rustc::session::config::{OutputFilenames, OutputTypes};\n use std::rc::Rc;\n use syntax::ast;\n use syntax::abi::Abi;\n@@ -133,6 +137,14 @@ fn test_env<F>(source_string: &str,\n \n     // run just enough stuff to build a tcx:\n     let named_region_map = resolve_lifetime::krate(&sess, &*cstore, &hir_map);\n+    let (tx, _rx) = mpsc::channel();\n+    let outputs = OutputFilenames {\n+        out_directory: PathBuf::new(),\n+        out_filestem: String::new(),\n+        single_output_file: None,\n+        extra: String::new(),\n+        outputs: OutputTypes::new(&[]),\n+    };\n     TyCtxt::create_and_enter(&sess,\n                              &*cstore,\n                              ty::maps::Providers::default(),\n@@ -144,6 +156,8 @@ fn test_env<F>(source_string: &str,\n                              named_region_map.unwrap(),\n                              hir_map,\n                              \"test_crate\",\n+                             tx,\n+                             &outputs,\n                              |tcx| {\n         tcx.infer_ctxt().enter(|infcx| {\n             let mut region_scope_tree = region::ScopeTree::default();"}, {"sha": "3a116160bcab2daa3ea734b444a15616f098bc7d", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -175,7 +175,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     extern_crate => { Rc::new(cdata.extern_crate.get()) }\n     is_no_builtins => { cdata.is_no_builtins() }\n     impl_defaultness => { cdata.get_impl_defaultness(def_id.index) }\n-    exported_symbols => { Rc::new(cdata.get_exported_symbols()) }\n+    exported_symbol_ids => { Rc::new(cdata.get_exported_symbols()) }\n     native_libraries => { Rc::new(cdata.get_native_libraries()) }\n     plugin_registrar_fn => {\n         cdata.root.plugin_registrar_fn.map(|index| {"}, {"sha": "1c4f1c6348689146aff5fdb0c4747389d2b57a5a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -24,6 +24,7 @@ use rustc::middle::lang_items;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n+use rustc::util::nodemap::DefIdSet;\n \n use rustc::mir::Mir;\n \n@@ -1017,7 +1018,7 @@ impl<'a, 'tcx> CrateMetadata {\n         arg_names.decode(self).collect()\n     }\n \n-    pub fn get_exported_symbols(&self) -> Vec<DefId> {\n+    pub fn get_exported_symbols(&self) -> DefIdSet {\n         self.exported_symbols\n             .iter()\n             .map(|&index| self.local_def_id(index))"}, {"sha": "8e933d5ac88749ea0c964219b0b4fe440f6b1363", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -612,7 +612,7 @@ pub struct FnType<'tcx> {\n impl<'a, 'tcx> FnType<'tcx> {\n     pub fn of_instance(ccx: &CrateContext<'a, 'tcx>, instance: &ty::Instance<'tcx>)\n                        -> Self {\n-        let fn_ty = instance_ty(ccx.shared(), &instance);\n+        let fn_ty = instance_ty(ccx.tcx(), &instance);\n         let sig = ty_fn_sig(ccx, fn_ty);\n         let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n         Self::new(ccx, sig, &[])"}, {"sha": "239b488fabe0f1b6dc9e1032249ec4043b76096a", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -15,16 +15,15 @@ use std::io::prelude::*;\n use std::io::{self, BufWriter};\n use std::path::{Path, PathBuf};\n \n-use context::SharedCrateContext;\n-\n use back::archive;\n use back::command::Command;\n-use back::symbol_export::ExportedSymbols;\n-use rustc::middle::dependency_format::Linkage;\n+use back::symbol_export;\n use rustc::hir::def_id::{LOCAL_CRATE, CrateNum};\n-use rustc_back::LinkerFlavor;\n+use rustc::middle::dependency_format::Linkage;\n use rustc::session::Session;\n use rustc::session::config::{self, CrateType, OptLevel, DebugInfoLevel};\n+use rustc::ty::TyCtxt;\n+use rustc_back::LinkerFlavor;\n use serialize::{json, Encoder};\n \n /// For all the linkers we support, and information they might\n@@ -33,19 +32,18 @@ pub struct LinkerInfo {\n     exports: HashMap<CrateType, Vec<String>>,\n }\n \n-impl<'a, 'tcx> LinkerInfo {\n-    pub fn new(scx: &SharedCrateContext<'a, 'tcx>,\n-               exports: &ExportedSymbols) -> LinkerInfo {\n+impl LinkerInfo {\n+    pub fn new(tcx: TyCtxt) -> LinkerInfo {\n         LinkerInfo {\n-            exports: scx.sess().crate_types.borrow().iter().map(|&c| {\n-                (c, exported_symbols(scx, exports, c))\n+            exports: tcx.sess.crate_types.borrow().iter().map(|&c| {\n+                (c, exported_symbols(tcx, c))\n             }).collect(),\n         }\n     }\n \n-    pub fn to_linker(&'a self,\n-                     cmd: Command,\n-                     sess: &'a Session) -> Box<Linker+'a> {\n+    pub fn to_linker<'a>(&'a self,\n+                         cmd: Command,\n+                         sess: &'a Session) -> Box<Linker+'a> {\n         match sess.linker_flavor() {\n             LinkerFlavor::Msvc => {\n                 Box::new(MsvcLinker {\n@@ -734,26 +732,29 @@ impl<'a> Linker for EmLinker<'a> {\n     }\n }\n \n-fn exported_symbols(scx: &SharedCrateContext,\n-                    exported_symbols: &ExportedSymbols,\n-                    crate_type: CrateType)\n-                    -> Vec<String> {\n+fn exported_symbols(tcx: TyCtxt, crate_type: CrateType) -> Vec<String> {\n     let mut symbols = Vec::new();\n-    exported_symbols.for_each_exported_symbol(LOCAL_CRATE, |name, _, _| {\n-        symbols.push(name.to_owned());\n-    });\n \n-    let formats = scx.sess().dependency_formats.borrow();\n+    let export_threshold = symbol_export::threshold(tcx);\n+    for &(ref name, _, level) in tcx.exported_symbols(LOCAL_CRATE).iter() {\n+        if level.is_below_threshold(export_threshold) {\n+            symbols.push(name.clone());\n+        }\n+    }\n+\n+    let formats = tcx.sess.dependency_formats.borrow();\n     let deps = formats[&crate_type].iter();\n \n     for (index, dep_format) in deps.enumerate() {\n         let cnum = CrateNum::new(index + 1);\n         // For each dependency that we are linking to statically ...\n         if *dep_format == Linkage::Static {\n             // ... we add its symbol list to our export list.\n-            exported_symbols.for_each_exported_symbol(cnum, |name, _, _| {\n-                symbols.push(name.to_owned());\n-            })\n+            for &(ref name, _, level) in tcx.exported_symbols(cnum).iter() {\n+                if level.is_below_threshold(export_threshold) {\n+                    symbols.push(name.clone());\n+                }\n+            }\n         }\n     }\n "}, {"sha": "aa13e4aa196eecdf74526aa0c54fa2428dc44b71", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -16,6 +16,7 @@ use errors::{FatalError, Handler};\n use llvm;\n use llvm::archive_ro::ArchiveRO;\n use llvm::{ModuleRef, TargetMachineRef, True, False};\n+use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::util::common::time;\n use rustc::util::common::path2cstr;\n use rustc::hir::def_id::LOCAL_CRATE;\n@@ -67,8 +68,8 @@ pub fn run(cgcx: &CodegenContext,\n     let export_threshold =\n         symbol_export::crates_export_threshold(&cgcx.crate_types);\n \n-    let symbol_filter = &|&(ref name, _, level): &(String, _, _)| {\n-        if symbol_export::is_below_threshold(level, export_threshold) {\n+    let symbol_filter = &|&(ref name, _, level): &(String, _, SymbolExportLevel)| {\n+        if level.is_below_threshold(export_threshold) {\n             let mut bytes = Vec::with_capacity(name.len() + 1);\n             bytes.extend(name.bytes());\n             Some(CString::new(bytes).unwrap())\n@@ -77,8 +78,7 @@ pub fn run(cgcx: &CodegenContext,\n         }\n     };\n \n-    let mut symbol_white_list: Vec<CString> = cgcx.exported_symbols\n-        .exported_symbols(LOCAL_CRATE)\n+    let mut symbol_white_list: Vec<CString> = cgcx.exported_symbols[&LOCAL_CRATE]\n         .iter()\n         .filter_map(symbol_filter)\n         .collect();\n@@ -88,9 +88,9 @@ pub fn run(cgcx: &CodegenContext,\n     // module that we've got.\n     for &(cnum, ref path) in cgcx.each_linked_rlib_for_lto.iter() {\n         symbol_white_list.extend(\n-            cgcx.exported_symbols.exported_symbols(cnum)\n-                                 .iter()\n-                                 .filter_map(symbol_filter));\n+            cgcx.exported_symbols[&cnum]\n+                .iter()\n+                .filter_map(symbol_filter));\n \n         let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n         let bytecodes = archive.iter().filter_map(|child| {"}, {"sha": "844442edbc8721880b25db58d034a501ff05a4ff", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 119, "deletions": 170, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -8,46 +8,83 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+use base;\n use monomorphize::Instance;\n-use rustc::util::nodemap::{FxHashMap, NodeSet};\n-use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE, INVALID_CRATE, CRATE_DEF_INDEX};\n+use rustc::hir::def_id::CrateNum;\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE, INVALID_CRATE, CRATE_DEF_INDEX};\n+use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::session::config;\n use rustc::ty::TyCtxt;\n+use rustc::ty::maps::Providers;\n+use rustc::util::nodemap::FxHashMap;\n use rustc_allocator::ALLOCATOR_METHODS;\n-use syntax::attr;\n-\n-/// The SymbolExportLevel of a symbols specifies from which kinds of crates\n-/// the symbol will be exported. `C` symbols will be exported from any\n-/// kind of crate, including cdylibs which export very few things.\n-/// `Rust` will only be exported if the crate produced is a Rust\n-/// dylib.\n-#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n-pub enum SymbolExportLevel {\n-    C,\n-    Rust,\n+\n+pub type ExportedSymbols = FxHashMap<\n+    CrateNum,\n+    Arc<Vec<(String, DefId, SymbolExportLevel)>>,\n+>;\n+\n+pub fn threshold(tcx: TyCtxt) -> SymbolExportLevel {\n+    crates_export_threshold(&tcx.sess.crate_types.borrow())\n }\n \n-/// The set of symbols exported from each crate in the crate graph.\n-#[derive(Debug)]\n-pub struct ExportedSymbols {\n-    pub export_threshold: SymbolExportLevel,\n-    exports: FxHashMap<CrateNum, Vec<(String, DefId, SymbolExportLevel)>>,\n-    local_exports: NodeSet,\n+pub fn metadata_symbol_name(tcx: TyCtxt) -> String {\n+    format!(\"rust_metadata_{}_{}\",\n+            tcx.crate_name(LOCAL_CRATE),\n+            tcx.crate_disambiguator(LOCAL_CRATE))\n }\n \n-impl ExportedSymbols {\n-    pub fn empty() -> ExportedSymbols {\n-        ExportedSymbols {\n-            export_threshold: SymbolExportLevel::C,\n-            exports: FxHashMap(),\n-            local_exports: NodeSet(),\n-        }\n+fn crate_export_threshold(crate_type: config::CrateType) -> SymbolExportLevel {\n+    match crate_type {\n+        config::CrateTypeExecutable |\n+        config::CrateTypeStaticlib  |\n+        config::CrateTypeProcMacro  |\n+        config::CrateTypeCdylib     => SymbolExportLevel::C,\n+        config::CrateTypeRlib       |\n+        config::CrateTypeDylib      => SymbolExportLevel::Rust,\n     }\n+}\n \n-    pub fn compute<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             local_exported_symbols: &NodeSet)\n-                             -> ExportedSymbols {\n-        let export_threshold = crates_export_threshold(&tcx.sess.crate_types.borrow());\n+pub fn crates_export_threshold(crate_types: &[config::CrateType])\n+                                      -> SymbolExportLevel {\n+    if crate_types.iter().any(|&crate_type| {\n+        crate_export_threshold(crate_type) == SymbolExportLevel::Rust\n+    }) {\n+        SymbolExportLevel::Rust\n+    } else {\n+        SymbolExportLevel::C\n+    }\n+}\n+\n+pub fn provide_local(providers: &mut Providers) {\n+    providers.exported_symbol_ids = |tcx, cnum| {\n+        let export_threshold = threshold(tcx);\n+        Rc::new(tcx.exported_symbols(cnum)\n+            .iter()\n+            .filter_map(|&(_, id, level)| {\n+                if level.is_below_threshold(export_threshold) {\n+                    Some(id)\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect())\n+    };\n+\n+    providers.is_exported_symbol = |tcx, id| {\n+        // FIXME(#42293) needs red/green to not break a bunch of incremental\n+        // tests\n+        tcx.dep_graph.with_ignore(|| {\n+            tcx.exported_symbol_ids(id.krate).contains(&id)\n+        })\n+    };\n+\n+    providers.exported_symbols = |tcx, cnum| {\n+        assert_eq!(cnum, LOCAL_CRATE);\n+        let local_exported_symbols = base::find_exported_symbols(tcx);\n \n         let mut local_crate: Vec<_> = local_exported_symbols\n             .iter()\n@@ -62,17 +99,6 @@ impl ExportedSymbols {\n             })\n             .collect();\n \n-        let mut local_exports = local_crate\n-            .iter()\n-            .filter_map(|&(_, def_id, level)| {\n-                if is_below_threshold(level, export_threshold) {\n-                    tcx.hir.as_local_node_id(def_id)\n-                } else {\n-                    None\n-                }\n-            })\n-            .collect::<NodeSet>();\n-\n         const INVALID_DEF_ID: DefId = DefId {\n             krate: INVALID_CRATE,\n             index: CRATE_DEF_INDEX,\n@@ -98,149 +124,72 @@ impl ExportedSymbols {\n             let disambiguator = tcx.sess.local_crate_disambiguator();\n             let registrar = tcx.sess.generate_derive_registrar_symbol(disambiguator, idx);\n             local_crate.push((registrar, def_id, SymbolExportLevel::C));\n-            local_exports.insert(id);\n         }\n \n         if tcx.sess.crate_types.borrow().contains(&config::CrateTypeDylib) {\n             local_crate.push((metadata_symbol_name(tcx),\n                               INVALID_DEF_ID,\n                               SymbolExportLevel::Rust));\n         }\n+        Arc::new(local_crate)\n+    };\n+}\n \n-        let mut exports = FxHashMap();\n-        exports.insert(LOCAL_CRATE, local_crate);\n-\n-        for &cnum in tcx.crates().iter() {\n-            debug_assert!(cnum != LOCAL_CRATE);\n-\n-            // If this crate is a plugin and/or a custom derive crate, then\n-            // we're not even going to link those in so we skip those crates.\n-            if tcx.plugin_registrar_fn(cnum).is_some() ||\n-               tcx.derive_registrar_fn(cnum).is_some() {\n-                continue;\n-            }\n-\n-            // Check to see if this crate is a \"special runtime crate\". These\n-            // crates, implementation details of the standard library, typically\n-            // have a bunch of `pub extern` and `#[no_mangle]` functions as the\n-            // ABI between them. We don't want their symbols to have a `C`\n-            // export level, however, as they're just implementation details.\n-            // Down below we'll hardwire all of the symbols to the `Rust` export\n-            // level instead.\n-            let special_runtime_crate =\n-                tcx.is_panic_runtime(cnum) || tcx.is_compiler_builtins(cnum);\n-\n-            let crate_exports = tcx\n-                .exported_symbols(cnum)\n-                .iter()\n-                .map(|&def_id| {\n-                    let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n-                    let export_level = if special_runtime_crate {\n-                        // We can probably do better here by just ensuring that\n-                        // it has hidden visibility rather than public\n-                        // visibility, as this is primarily here to ensure it's\n-                        // not stripped during LTO.\n-                        //\n-                        // In general though we won't link right if these\n-                        // symbols are stripped, and LTO currently strips them.\n-                        if &*name == \"rust_eh_personality\" ||\n-                           &*name == \"rust_eh_register_frames\" ||\n-                           &*name == \"rust_eh_unregister_frames\" {\n-                            SymbolExportLevel::C\n-                        } else {\n-                            SymbolExportLevel::Rust\n-                        }\n-                    } else {\n-                        export_level(tcx, def_id)\n-                    };\n-                    debug!(\"EXPORTED SYMBOL (re-export): {} ({:?})\", name, export_level);\n-                    (str::to_owned(&name), def_id, export_level)\n-                })\n-                .collect();\n-\n-            exports.insert(cnum, crate_exports);\n-        }\n-\n-        return ExportedSymbols {\n-            export_threshold,\n-            exports,\n-            local_exports,\n-        };\n-\n-        fn export_level(tcx: TyCtxt,\n-                        sym_def_id: DefId)\n-                        -> SymbolExportLevel {\n-            let attrs = tcx.get_attrs(sym_def_id);\n-            if attr::contains_extern_indicator(tcx.sess.diagnostic(), &attrs) {\n-                SymbolExportLevel::C\n-            } else {\n-                SymbolExportLevel::Rust\n-            }\n-        }\n-    }\n-\n-    pub fn local_exports(&self) -> &NodeSet {\n-        &self.local_exports\n-    }\n-\n-    pub fn exported_symbols(&self,\n-                            cnum: CrateNum)\n-                            -> &[(String, DefId, SymbolExportLevel)] {\n-        match self.exports.get(&cnum) {\n-            Some(exports) => exports,\n-            None => &[]\n+pub fn provide_extern(providers: &mut Providers) {\n+    providers.exported_symbols = |tcx, cnum| {\n+        // If this crate is a plugin and/or a custom derive crate, then\n+        // we're not even going to link those in so we skip those crates.\n+        if tcx.plugin_registrar_fn(cnum).is_some() ||\n+           tcx.derive_registrar_fn(cnum).is_some() {\n+            return Arc::new(Vec::new())\n         }\n-    }\n \n-    pub fn for_each_exported_symbol<F>(&self,\n-                                       cnum: CrateNum,\n-                                       mut f: F)\n-        where F: FnMut(&str, DefId, SymbolExportLevel)\n-    {\n-        for &(ref name, def_id, export_level) in self.exported_symbols(cnum) {\n-            if is_below_threshold(export_level, self.export_threshold) {\n-                f(&name, def_id, export_level)\n-            }\n-        }\n-    }\n-}\n-\n-pub fn metadata_symbol_name(tcx: TyCtxt) -> String {\n-    format!(\"rust_metadata_{}_{}\",\n-            tcx.crate_name(LOCAL_CRATE),\n-            tcx.crate_disambiguator(LOCAL_CRATE))\n-}\n+        // Check to see if this crate is a \"special runtime crate\". These\n+        // crates, implementation details of the standard library, typically\n+        // have a bunch of `pub extern` and `#[no_mangle]` functions as the\n+        // ABI between them. We don't want their symbols to have a `C`\n+        // export level, however, as they're just implementation details.\n+        // Down below we'll hardwire all of the symbols to the `Rust` export\n+        // level instead.\n+        let special_runtime_crate =\n+            tcx.is_panic_runtime(cnum) || tcx.is_compiler_builtins(cnum);\n+\n+        let crate_exports = tcx\n+            .exported_symbol_ids(cnum)\n+            .iter()\n+            .map(|&def_id| {\n+                let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n+                let export_level = if special_runtime_crate {\n+                    // We can probably do better here by just ensuring that\n+                    // it has hidden visibility rather than public\n+                    // visibility, as this is primarily here to ensure it's\n+                    // not stripped during LTO.\n+                    //\n+                    // In general though we won't link right if these\n+                    // symbols are stripped, and LTO currently strips them.\n+                    if &*name == \"rust_eh_personality\" ||\n+                       &*name == \"rust_eh_register_frames\" ||\n+                       &*name == \"rust_eh_unregister_frames\" {\n+                        SymbolExportLevel::C\n+                    } else {\n+                        SymbolExportLevel::Rust\n+                    }\n+                } else {\n+                    export_level(tcx, def_id)\n+                };\n+                debug!(\"EXPORTED SYMBOL (re-export): {} ({:?})\", name, export_level);\n+                (str::to_owned(&name), def_id, export_level)\n+            })\n+            .collect();\n \n-pub fn crate_export_threshold(crate_type: config::CrateType)\n-                                     -> SymbolExportLevel {\n-    match crate_type {\n-        config::CrateTypeExecutable |\n-        config::CrateTypeStaticlib  |\n-        config::CrateTypeProcMacro  |\n-        config::CrateTypeCdylib     => SymbolExportLevel::C,\n-        config::CrateTypeRlib       |\n-        config::CrateTypeDylib      => SymbolExportLevel::Rust,\n-    }\n+        Arc::new(crate_exports)\n+    };\n }\n \n-pub fn crates_export_threshold(crate_types: &[config::CrateType])\n-                                      -> SymbolExportLevel {\n-    if crate_types.iter().any(|&crate_type| {\n-        crate_export_threshold(crate_type) == SymbolExportLevel::Rust\n-    }) {\n-        SymbolExportLevel::Rust\n-    } else {\n+fn export_level(tcx: TyCtxt, sym_def_id: DefId) -> SymbolExportLevel {\n+    if tcx.contains_extern_indicator(sym_def_id) {\n         SymbolExportLevel::C\n-    }\n-}\n-\n-pub fn is_below_threshold(level: SymbolExportLevel,\n-                          threshold: SymbolExportLevel)\n-                          -> bool {\n-    if threshold == SymbolExportLevel::Rust {\n-        // We export everything from Rust dylibs\n-        true\n     } else {\n-        level == SymbolExportLevel::C\n+        SymbolExportLevel::Rust\n     }\n }"}, {"sha": "306071223fc2c1d532459869174bc22c064f2ab0", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -119,6 +119,30 @@ pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         def_symbol_name,\n         symbol_name,\n+\n+        export_name: |tcx, id| {\n+            tcx.get_attrs(id).iter().fold(None, |ia, attr| {\n+                if attr.check_name(\"export_name\") {\n+                    if let s @ Some(_) = attr.value_str() {\n+                        s\n+                    } else {\n+                        struct_span_err!(tcx.sess, attr.span, E0558,\n+                                         \"export_name attribute has invalid format\")\n+                            .span_label(attr.span, \"did you mean #[export_name=\\\"*\\\"]?\")\n+                            .emit();\n+                        None\n+                    }\n+                } else {\n+                    ia\n+                }\n+            })\n+        },\n+\n+        contains_extern_indicator: |tcx, id| {\n+            attr::contains_name(&tcx.get_attrs(id), \"no_mangle\") ||\n+                tcx.export_name(id).is_some()\n+        },\n+\n         ..*providers\n     };\n }\n@@ -245,7 +269,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n         return tcx.item_name(def_id).to_string();\n     }\n \n-    if let Some(name) = attr::find_export_name_attr(tcx.sess.diagnostic(), &attrs) {\n+    if let Some(name) = tcx.export_name(def_id) {\n         // Use provided name\n         return name.to_string();\n     }"}, {"sha": "ef6bf2504f3121ba65dbba1a9b28e5679ec59767", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 147, "deletions": 151, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -18,24 +18,28 @@ use rustc::middle::cstore::{LinkMeta, EncodedMetadata};\n use rustc::session::config::{self, OutputFilenames, OutputType, OutputTypes, Passes, SomePasses,\n                              AllPasses, Sanitizer};\n use rustc::session::Session;\n+use rustc::util::nodemap::FxHashMap;\n use time_graph::{self, TimeGraph};\n use llvm;\n use llvm::{ModuleRef, TargetMachineRef, PassManagerRef, DiagnosticInfoRef};\n use llvm::SMDiagnosticRef;\n use {CrateTranslation, ModuleSource, ModuleTranslation, CompiledModule, ModuleKind};\n use CrateInfo;\n-use rustc::hir::def_id::CrateNum;\n+use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n+use rustc::ty::TyCtxt;\n use rustc::util::common::{time, time_depth, set_time_depth, path2cstr, print_time_passes_entry};\n use rustc::util::fs::{link_or_copy, rename_or_copy_remove};\n use errors::{self, Handler, Level, DiagnosticBuilder, FatalError};\n use errors::emitter::{Emitter};\n+use syntax::attr;\n use syntax::ext::hygiene::Mark;\n use syntax_pos::MultiSpan;\n use syntax_pos::symbol::Symbol;\n use context::{is_pie_binary, get_reloc_model};\n use jobserver::{Client, Acquired};\n use rustc_demangle;\n \n+use std::any::Any;\n use std::ffi::CString;\n use std::fmt;\n use std::fs;\n@@ -199,8 +203,6 @@ pub fn create_target_machine(sess: &Session) -> TargetMachineRef {\n \n /// Module-specific configuration for `optimize_and_codegen`.\n pub struct ModuleConfig {\n-    /// LLVM TargetMachine to use for codegen.\n-    tm: TargetMachineRef,\n     /// Names of additional optimization passes to run.\n     passes: Vec<String>,\n     /// Some(level) to optimize at a certain level, or None to run\n@@ -233,12 +235,9 @@ pub struct ModuleConfig {\n     obj_is_bitcode: bool,\n }\n \n-unsafe impl Send for ModuleConfig { }\n-\n impl ModuleConfig {\n-    fn new(sess: &Session, passes: Vec<String>) -> ModuleConfig {\n+    fn new(passes: Vec<String>) -> ModuleConfig {\n         ModuleConfig {\n-            tm: create_target_machine(sess),\n             passes,\n             opt_level: None,\n             opt_size: None,\n@@ -286,40 +285,6 @@ impl ModuleConfig {\n         self.merge_functions = sess.opts.optimize == config::OptLevel::Default ||\n                                sess.opts.optimize == config::OptLevel::Aggressive;\n     }\n-\n-    fn clone(&self, sess: &Session) -> ModuleConfig {\n-        ModuleConfig {\n-            tm: create_target_machine(sess),\n-            passes: self.passes.clone(),\n-            opt_level: self.opt_level,\n-            opt_size: self.opt_size,\n-\n-            emit_no_opt_bc: self.emit_no_opt_bc,\n-            emit_bc: self.emit_bc,\n-            emit_lto_bc: self.emit_lto_bc,\n-            emit_ir: self.emit_ir,\n-            emit_asm: self.emit_asm,\n-            emit_obj: self.emit_obj,\n-            obj_is_bitcode: self.obj_is_bitcode,\n-\n-            no_verify: self.no_verify,\n-            no_prepopulate_passes: self.no_prepopulate_passes,\n-            no_builtins: self.no_builtins,\n-            time_passes: self.time_passes,\n-            vectorize_loop: self.vectorize_loop,\n-            vectorize_slp: self.vectorize_slp,\n-            merge_functions: self.merge_functions,\n-            inline_threshold: self.inline_threshold,\n-        }\n-    }\n-}\n-\n-impl Drop for ModuleConfig {\n-    fn drop(&mut self) {\n-        unsafe {\n-            llvm::LLVMRustDisposeTargetMachine(self.tm);\n-        }\n-    }\n }\n \n /// Additional resources used by optimize_and_codegen (not module specific)\n@@ -333,6 +298,11 @@ pub struct CodegenContext {\n     pub opts: Arc<config::Options>,\n     pub crate_types: Vec<config::CrateType>,\n     pub each_linked_rlib_for_lto: Vec<(CrateNum, PathBuf)>,\n+    output_filenames: Arc<OutputFilenames>,\n+    regular_module_config: Arc<ModuleConfig>,\n+    metadata_module_config: Arc<ModuleConfig>,\n+    allocator_module_config: Arc<ModuleConfig>,\n+\n     // Handler to use for diagnostics produced during codegen.\n     pub diag_emitter: SharedEmitter,\n     // LLVM passes added by plugins.\n@@ -345,7 +315,7 @@ pub struct CodegenContext {\n     // compiling incrementally\n     pub incr_comp_session_dir: Option<PathBuf>,\n     // Channel back to the main control thread to send messages to\n-    coordinator_send: Sender<Message>,\n+    coordinator_send: Sender<Box<Any + Send>>,\n     // A reference to the TimeGraph so we can register timings. None means that\n     // measuring is disabled.\n     time_graph: Option<TimeGraph>,\n@@ -355,6 +325,14 @@ impl CodegenContext {\n     fn create_diag_handler(&self) -> Handler {\n         Handler::with_emitter(true, false, Box::new(self.diag_emitter.clone()))\n     }\n+\n+    fn config(&self, kind: ModuleKind) -> &ModuleConfig {\n+        match kind {\n+            ModuleKind::Regular => &self.regular_module_config,\n+            ModuleKind::Metadata => &self.metadata_module_config,\n+            ModuleKind::Allocator => &self.allocator_module_config,\n+        }\n+    }\n }\n \n struct HandlerFreeVars<'a> {\n@@ -414,8 +392,8 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                                diag_handler: &Handler,\n                                mtrans: ModuleTranslation,\n-                               config: ModuleConfig,\n-                               output_names: OutputFilenames)\n+                               tm: TargetMachineRef,\n+                               config: &ModuleConfig)\n     -> Result<CompiledModule, FatalError>\n {\n     let (llmod, llcx) = match mtrans.source {\n@@ -425,8 +403,6 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         }\n     };\n \n-    let tm = config.tm;\n-\n     let fv = HandlerFreeVars {\n         cgcx,\n         diag_handler,\n@@ -440,7 +416,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     let module_name = Some(&module_name[..]);\n \n     if config.emit_no_opt_bc {\n-        let out = output_names.temp_path_ext(\"no-opt.bc\", module_name);\n+        let out = cgcx.output_filenames.temp_path_ext(\"no-opt.bc\", module_name);\n         let out = path2cstr(&out);\n         llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n     }\n@@ -513,7 +489,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         if cgcx.lto {\n             time(cgcx.time_passes, \"all lto passes\", || {\n                 let temp_no_opt_bc_filename =\n-                    output_names.temp_path_ext(\"no-opt.lto.bc\", module_name);\n+                    cgcx.output_filenames.temp_path_ext(\"no-opt.lto.bc\", module_name);\n                 lto::run(cgcx,\n                          diag_handler,\n                          llmod,\n@@ -522,7 +498,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                          &temp_no_opt_bc_filename)\n             })?;\n             if config.emit_lto_bc {\n-                let out = output_names.temp_path_ext(\"lto.bc\", module_name);\n+                let out = cgcx.output_filenames.temp_path_ext(\"lto.bc\", module_name);\n                 let out = path2cstr(&out);\n                 llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n             }\n@@ -558,8 +534,8 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     let write_obj = config.emit_obj && !config.obj_is_bitcode;\n     let copy_bc_to_obj = config.emit_obj && config.obj_is_bitcode;\n \n-    let bc_out = output_names.temp_path(OutputType::Bitcode, module_name);\n-    let obj_out = output_names.temp_path(OutputType::Object, module_name);\n+    let bc_out = cgcx.output_filenames.temp_path(OutputType::Bitcode, module_name);\n+    let obj_out = cgcx.output_filenames.temp_path(OutputType::Object, module_name);\n \n     if write_bc {\n         let bc_out_c = path2cstr(&bc_out);\n@@ -569,7 +545,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     time(config.time_passes, &format!(\"codegen passes [{}]\", module_name.unwrap()),\n          || -> Result<(), FatalError> {\n         if config.emit_ir {\n-            let out = output_names.temp_path(OutputType::LlvmAssembly, module_name);\n+            let out = cgcx.output_filenames.temp_path(OutputType::LlvmAssembly, module_name);\n             let out = path2cstr(&out);\n \n             extern \"C\" fn demangle_callback(input_ptr: *const c_char,\n@@ -610,7 +586,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         }\n \n         if config.emit_asm {\n-            let path = output_names.temp_path(OutputType::Assembly, module_name);\n+            let path = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n \n             // We can't use the same module for asm and binary output, because that triggers\n             // various errors like invalid IR or broken binaries, so we might have to clone the\n@@ -667,29 +643,44 @@ fn need_crate_bitcode_for_rlib(sess: &Session) -> bool {\n     sess.opts.output_types.contains_key(&OutputType::Exe)\n }\n \n-pub fn start_async_translation(sess: &Session,\n-                               crate_output: &OutputFilenames,\n+pub fn start_async_translation(tcx: TyCtxt,\n                                time_graph: Option<TimeGraph>,\n-                               crate_name: Symbol,\n                                link: LinkMeta,\n                                metadata: EncodedMetadata,\n-                               exported_symbols: Arc<ExportedSymbols>,\n-                               no_builtins: bool,\n-                               windows_subsystem: Option<String>,\n-                               linker_info: LinkerInfo,\n-                               crate_info: CrateInfo,\n-                               no_integrated_as: bool)\n+                               coordinator_receive: Receiver<Box<Any + Send>>)\n                                -> OngoingCrateTranslation {\n+    let sess = tcx.sess;\n+    let crate_output = tcx.output_filenames(LOCAL_CRATE);\n+    let crate_name = tcx.crate_name(LOCAL_CRATE);\n+    let no_builtins = attr::contains_name(&tcx.hir.krate().attrs, \"no_builtins\");\n+    let subsystem = attr::first_attr_value_str_by_name(&tcx.hir.krate().attrs,\n+                                                       \"windows_subsystem\");\n+    let windows_subsystem = subsystem.map(|subsystem| {\n+        if subsystem != \"windows\" && subsystem != \"console\" {\n+            tcx.sess.fatal(&format!(\"invalid windows subsystem `{}`, only \\\n+                                     `windows` and `console` are allowed\",\n+                                    subsystem));\n+        }\n+        subsystem.to_string()\n+    });\n+\n+    let no_integrated_as = tcx.sess.opts.cg.no_integrated_as ||\n+        (tcx.sess.target.target.options.no_integrated_as &&\n+         (crate_output.outputs.contains_key(&OutputType::Object) ||\n+          crate_output.outputs.contains_key(&OutputType::Exe)));\n+    let linker_info = LinkerInfo::new(tcx);\n+    let crate_info = CrateInfo::new(tcx);\n+\n     let output_types_override = if no_integrated_as {\n         OutputTypes::new(&[(OutputType::Assembly, None)])\n     } else {\n         sess.opts.output_types.clone()\n     };\n \n     // Figure out what we actually need to build.\n-    let mut modules_config = ModuleConfig::new(sess, sess.opts.cg.passes.clone());\n-    let mut metadata_config = ModuleConfig::new(sess, vec![]);\n-    let mut allocator_config = ModuleConfig::new(sess, vec![]);\n+    let mut modules_config = ModuleConfig::new(sess.opts.cg.passes.clone());\n+    let mut metadata_config = ModuleConfig::new(vec![]);\n+    let mut allocator_config = ModuleConfig::new(vec![]);\n \n     if let Some(ref sanitizer) = sess.opts.debugging_opts.sanitizer {\n         match *sanitizer {\n@@ -774,17 +765,18 @@ pub fn start_async_translation(sess: &Session,\n \n     let (shared_emitter, shared_emitter_main) = SharedEmitter::new();\n     let (trans_worker_send, trans_worker_receive) = channel();\n-    let (coordinator_send, coordinator_receive) = channel();\n \n-    let coordinator_thread = start_executing_work(sess,\n+    let coordinator_thread = start_executing_work(tcx,\n                                                   &crate_info,\n                                                   shared_emitter,\n                                                   trans_worker_send,\n-                                                  coordinator_send.clone(),\n                                                   coordinator_receive,\n                                                   client,\n                                                   time_graph.clone(),\n-                                                  exported_symbols.clone());\n+                                                  Arc::new(modules_config),\n+                                                  Arc::new(metadata_config),\n+                                                  Arc::new(allocator_config));\n+\n     OngoingCrateTranslation {\n         crate_name,\n         link,\n@@ -794,16 +786,12 @@ pub fn start_async_translation(sess: &Session,\n         no_integrated_as,\n         crate_info,\n \n-        regular_module_config: modules_config,\n-        metadata_module_config: metadata_config,\n-        allocator_module_config: allocator_config,\n-\n         time_graph,\n-        output_filenames: crate_output.clone(),\n-        coordinator_send,\n+        coordinator_send: tcx.tx_to_llvm_workers.clone(),\n         trans_worker_receive,\n         shared_emitter_main,\n-        future: coordinator_thread\n+        future: coordinator_thread,\n+        output_filenames: tcx.output_filenames(LOCAL_CRATE),\n     }\n }\n \n@@ -1004,8 +992,7 @@ pub fn dump_incremental_data(trans: &CrateTranslation) {\n \n struct WorkItem {\n     mtrans: ModuleTranslation,\n-    config: ModuleConfig,\n-    output_names: OutputFilenames\n+    tm: TargetMachine,\n }\n \n impl fmt::Debug for WorkItem {\n@@ -1014,15 +1001,15 @@ impl fmt::Debug for WorkItem {\n     }\n }\n \n-fn build_work_item(mtrans: ModuleTranslation,\n-                   config: ModuleConfig,\n-                   output_names: OutputFilenames)\n-                   -> WorkItem\n-{\n-    WorkItem {\n-        mtrans,\n-        config,\n-        output_names,\n+struct TargetMachine(TargetMachineRef);\n+\n+unsafe impl Send for TargetMachine {}\n+\n+impl Drop for TargetMachine {\n+    fn drop(&mut self) {\n+        unsafe {\n+            llvm::LLVMRustDisposeTargetMachine(self.0);\n+        }\n     }\n }\n \n@@ -1031,6 +1018,7 @@ fn execute_work_item(cgcx: &CodegenContext, work_item: WorkItem)\n {\n     let diag_handler = cgcx.create_diag_handler();\n     let module_name = work_item.mtrans.name.clone();\n+    let config = cgcx.config(work_item.mtrans.kind);\n \n     let pre_existing = match work_item.mtrans.source {\n         ModuleSource::Translated(_) => None,\n@@ -1043,7 +1031,7 @@ fn execute_work_item(cgcx: &CodegenContext, work_item: WorkItem)\n                                         .unwrap();\n         let name = &work_item.mtrans.name;\n         for (kind, saved_file) in wp.saved_files {\n-            let obj_out = work_item.output_names.temp_path(kind, Some(name));\n+            let obj_out = cgcx.output_filenames.temp_path(kind, Some(name));\n             let source_file = in_incr_comp_dir(&incr_comp_session_dir,\n                                                &saved_file);\n             debug!(\"copying pre-existing module `{}` from {:?} to {}\",\n@@ -1066,8 +1054,8 @@ fn execute_work_item(cgcx: &CodegenContext, work_item: WorkItem)\n             kind: ModuleKind::Regular,\n             pre_existing: true,\n             symbol_name_hash: work_item.mtrans.symbol_name_hash,\n-            emit_bc: work_item.config.emit_bc,\n-            emit_obj: work_item.config.emit_obj,\n+            emit_bc: config.emit_bc,\n+            emit_obj: config.emit_obj,\n         })\n     } else {\n         debug!(\"llvm-optimizing {:?}\", module_name);\n@@ -1076,8 +1064,8 @@ fn execute_work_item(cgcx: &CodegenContext, work_item: WorkItem)\n             optimize_and_codegen(cgcx,\n                                  &diag_handler,\n                                  work_item.mtrans,\n-                                 work_item.config,\n-                                 work_item.output_names)\n+                                 work_item.tm.0,\n+                                 config)\n         }\n     }\n }\n@@ -1092,8 +1080,8 @@ enum Message {\n     TranslationDone {\n         llvm_work_item: WorkItem,\n         cost: u64,\n-        is_last: bool,\n     },\n+    TranslationComplete,\n     TranslateItem,\n }\n \n@@ -1110,16 +1098,26 @@ enum MainThreadWorkerState {\n     LLVMing,\n }\n \n-fn start_executing_work(sess: &Session,\n+fn start_executing_work(tcx: TyCtxt,\n                         crate_info: &CrateInfo,\n                         shared_emitter: SharedEmitter,\n                         trans_worker_send: Sender<Message>,\n-                        coordinator_send: Sender<Message>,\n-                        coordinator_receive: Receiver<Message>,\n+                        coordinator_receive: Receiver<Box<Any + Send>>,\n                         jobserver: Client,\n                         time_graph: Option<TimeGraph>,\n-                        exported_symbols: Arc<ExportedSymbols>)\n+                        modules_config: Arc<ModuleConfig>,\n+                        metadata_config: Arc<ModuleConfig>,\n+                        allocator_config: Arc<ModuleConfig>)\n                         -> thread::JoinHandle<CompiledModules> {\n+    let coordinator_send = tcx.tx_to_llvm_workers.clone();\n+    let mut exported_symbols = FxHashMap();\n+    exported_symbols.insert(LOCAL_CRATE, tcx.exported_symbols(LOCAL_CRATE));\n+    for &cnum in tcx.crates().iter() {\n+        exported_symbols.insert(cnum, tcx.exported_symbols(cnum));\n+    }\n+    let exported_symbols = Arc::new(exported_symbols);\n+    let sess = tcx.sess;\n+\n     // First up, convert our jobserver into a helper thread so we can use normal\n     // mpsc channels to manage our messages and such. Once we've got the helper\n     // thread then request `n-1` tokens because all of our work items are ready\n@@ -1132,7 +1130,7 @@ fn start_executing_work(sess: &Session,\n     // tokens on `rx` above which will get managed in the main loop below.\n     let coordinator_send2 = coordinator_send.clone();\n     let helper = jobserver.into_helper_thread(move |token| {\n-        drop(coordinator_send2.send(Message::Token(token)));\n+        drop(coordinator_send2.send(Box::new(Message::Token(token))));\n     }).expect(\"failed to spawn helper thread\");\n \n     let mut each_linked_rlib_for_lto = Vec::new();\n@@ -1158,6 +1156,10 @@ fn start_executing_work(sess: &Session,\n         coordinator_send,\n         diag_emitter: shared_emitter.clone(),\n         time_graph,\n+        output_filenames: tcx.output_filenames(LOCAL_CRATE),\n+        regular_module_config: modules_config,\n+        metadata_module_config: metadata_config,\n+        allocator_module_config: allocator_config,\n     };\n \n     // This is the \"main loop\" of parallel work happening for parallel codegen.\n@@ -1307,7 +1309,7 @@ fn start_executing_work(sess: &Session,\n         let mut translation_done = false;\n \n         // This is the queue of LLVM work items that still need processing.\n-        let mut work_items = Vec::new();\n+        let mut work_items = Vec::<(WorkItem, u64)>::new();\n \n         // This are the Jobserver Tokens we currently hold. Does not include\n         // the implicit Token the compiler process owns no matter what.\n@@ -1346,7 +1348,8 @@ fn start_executing_work(sess: &Session,\n                             worker: get_worker_id(&mut free_worker_ids),\n                             .. cgcx.clone()\n                         };\n-                        maybe_start_llvm_timer(&item, &mut llvm_start_time);\n+                        maybe_start_llvm_timer(cgcx.config(item.mtrans.kind),\n+                                               &mut llvm_start_time);\n                         main_thread_worker_state = MainThreadWorkerState::LLVMing;\n                         spawn_work(cgcx, item);\n                     }\n@@ -1362,7 +1365,8 @@ fn start_executing_work(sess: &Session,\n                                 worker: get_worker_id(&mut free_worker_ids),\n                                 .. cgcx.clone()\n                             };\n-                            maybe_start_llvm_timer(&item, &mut llvm_start_time);\n+                            maybe_start_llvm_timer(cgcx.config(item.mtrans.kind),\n+                                                   &mut llvm_start_time);\n                             main_thread_worker_state = MainThreadWorkerState::LLVMing;\n                             spawn_work(cgcx, item);\n                         } else {\n@@ -1392,7 +1396,8 @@ fn start_executing_work(sess: &Session,\n             while work_items.len() > 0 && running < tokens.len() {\n                 let (item, _) = work_items.pop().unwrap();\n \n-                maybe_start_llvm_timer(&item, &mut llvm_start_time);\n+                maybe_start_llvm_timer(cgcx.config(item.mtrans.kind),\n+                                       &mut llvm_start_time);\n \n                 let cgcx = CodegenContext {\n                     worker: get_worker_id(&mut free_worker_ids),\n@@ -1406,7 +1411,8 @@ fn start_executing_work(sess: &Session,\n             // Relinquish accidentally acquired extra tokens\n             tokens.truncate(running);\n \n-            match coordinator_receive.recv().unwrap() {\n+            let msg = coordinator_receive.recv().unwrap();\n+            match *msg.downcast::<Message>().ok().unwrap() {\n                 // Save the token locally and the next turn of the loop will use\n                 // this to spawn a new unit of work, or it may get dropped\n                 // immediately if we have no more work to spawn.\n@@ -1433,7 +1439,7 @@ fn start_executing_work(sess: &Session,\n                     }\n                 }\n \n-                Message::TranslationDone { llvm_work_item, cost, is_last } => {\n+                Message::TranslationDone { llvm_work_item, cost } => {\n                     // We keep the queue sorted by estimated processing cost,\n                     // so that more expensive items are processed earlier. This\n                     // is good for throughput as it gives the main thread more\n@@ -1449,15 +1455,14 @@ fn start_executing_work(sess: &Session,\n                     };\n                     work_items.insert(insertion_index, (llvm_work_item, cost));\n \n-                    if is_last {\n-                        // If this is the last, don't request a token because\n-                        // the trans worker thread will be free to handle this\n-                        // immediately.\n-                        translation_done = true;\n-                    } else {\n-                        helper.request_token();\n-                    }\n+                    helper.request_token();\n+                    assert_eq!(main_thread_worker_state,\n+                               MainThreadWorkerState::Translating);\n+                    main_thread_worker_state = MainThreadWorkerState::Idle;\n+                }\n \n+                Message::TranslationComplete => {\n+                    translation_done = true;\n                     assert_eq!(main_thread_worker_state,\n                                MainThreadWorkerState::Translating);\n                     main_thread_worker_state = MainThreadWorkerState::Idle;\n@@ -1535,11 +1540,11 @@ fn start_executing_work(sess: &Session,\n         items_in_queue >= max_workers.saturating_sub(workers_running / 2)\n     }\n \n-    fn maybe_start_llvm_timer(work_item: &WorkItem,\n+    fn maybe_start_llvm_timer(config: &ModuleConfig,\n                               llvm_start_time: &mut Option<Instant>) {\n         // We keep track of the -Ztime-passes output manually,\n         // since the closure-based interface does not fit well here.\n-        if work_item.config.time_passes {\n+        if config.time_passes {\n             if llvm_start_time.is_none() {\n                 *llvm_start_time = Some(Instant::now());\n             }\n@@ -1564,7 +1569,7 @@ fn spawn_work(cgcx: CodegenContext, work: WorkItem) {\n         // Set up a destructor which will fire off a message that we're done as\n         // we exit.\n         struct Bomb {\n-            coordinator_send: Sender<Message>,\n+            coordinator_send: Sender<Box<Any + Send>>,\n             result: Option<CompiledModule>,\n             worker_id: usize,\n         }\n@@ -1575,10 +1580,10 @@ fn spawn_work(cgcx: CodegenContext, work: WorkItem) {\n                     None => Err(())\n                 };\n \n-                drop(self.coordinator_send.send(Message::Done {\n+                drop(self.coordinator_send.send(Box::new(Message::Done {\n                     result,\n                     worker_id: self.worker_id,\n-                }));\n+                })));\n             }\n         }\n \n@@ -1814,17 +1819,12 @@ pub struct OngoingCrateTranslation {\n     linker_info: LinkerInfo,\n     no_integrated_as: bool,\n     crate_info: CrateInfo,\n-\n-    output_filenames: OutputFilenames,\n-    regular_module_config: ModuleConfig,\n-    metadata_module_config: ModuleConfig,\n-    allocator_module_config: ModuleConfig,\n-\n     time_graph: Option<TimeGraph>,\n-    coordinator_send: Sender<Message>,\n+    coordinator_send: Sender<Box<Any + Send>>,\n     trans_worker_receive: Receiver<Message>,\n     shared_emitter_main: SharedEmitterMain,\n     future: thread::JoinHandle<CompiledModules>,\n+    output_filenames: Arc<OutputFilenames>,\n }\n \n impl OngoingCrateTranslation {\n@@ -1892,38 +1892,21 @@ impl OngoingCrateTranslation {\n         trans\n     }\n \n-    pub fn submit_translated_module_to_llvm(&self,\n-                                            sess: &Session,\n-                                            mtrans: ModuleTranslation,\n-                                            cost: u64,\n-                                            is_last: bool) {\n-        let module_config = match mtrans.kind {\n-            ModuleKind::Regular => self.regular_module_config.clone(sess),\n-            ModuleKind::Metadata => self.metadata_module_config.clone(sess),\n-            ModuleKind::Allocator => self.allocator_module_config.clone(sess),\n-        };\n-\n-        let llvm_work_item = build_work_item(mtrans,\n-                                             module_config,\n-                                             self.output_filenames.clone());\n-\n-        drop(self.coordinator_send.send(Message::TranslationDone {\n-            llvm_work_item,\n-            cost,\n-            is_last\n-        }));\n-    }\n-\n     pub fn submit_pre_translated_module_to_llvm(&self,\n-                                                sess: &Session,\n-                                                mtrans: ModuleTranslation,\n-                                                is_last: bool) {\n+                                                tcx: TyCtxt,\n+                                                mtrans: ModuleTranslation) {\n         self.wait_for_signal_to_translate_item();\n-        self.check_for_errors(sess);\n+        self.check_for_errors(tcx.sess);\n \n         // These are generally cheap and won't through off scheduling.\n         let cost = 0;\n-        self.submit_translated_module_to_llvm(sess, mtrans, cost, is_last);\n+        submit_translated_module_to_llvm(tcx, mtrans, cost);\n+    }\n+\n+    pub fn translation_finished(&self, tcx: TyCtxt) {\n+        self.wait_for_signal_to_translate_item();\n+        self.check_for_errors(tcx.sess);\n+        drop(self.coordinator_send.send(Box::new(Message::TranslationComplete)));\n     }\n \n     pub fn check_for_errors(&self, sess: &Session) {\n@@ -1945,3 +1928,16 @@ impl OngoingCrateTranslation {\n         }\n     }\n }\n+\n+pub fn submit_translated_module_to_llvm(tcx: TyCtxt,\n+                                        mtrans: ModuleTranslation,\n+                                        cost: u64) {\n+    let llvm_work_item = WorkItem {\n+        mtrans,\n+        tm: TargetMachine(create_target_machine(tcx.sess)),\n+    };\n+    drop(tcx.tx_to_llvm_workers.send(Box::new(Message::TranslationDone {\n+        llvm_work_item,\n+        cost,\n+    })));\n+}"}, {"sha": "d86f88d4c7da0af8b0b73cb798737f33d358fb7d", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 341, "deletions": 322, "changes": 663, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -28,23 +28,24 @@ use super::ModuleSource;\n use super::ModuleTranslation;\n use super::ModuleKind;\n \n-use assert_module_sources;\n+use assert_module_sources::{self, Disposition};\n use back::link;\n-use back::linker::LinkerInfo;\n-use back::symbol_export::{self, ExportedSymbols};\n+use back::symbol_export;\n use back::write::{self, OngoingCrateTranslation};\n-use llvm::{ContextRef, Linkage, ModuleRef, ValueRef, Vector, get_param};\n+use llvm::{ContextRef, ModuleRef, ValueRef, Vector, get_param};\n use llvm;\n use metadata;\n-use rustc::hir::def_id::LOCAL_CRATE;\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::middle::lang_items::StartFnLangItem;\n+use rustc::middle::trans::{Linkage, Visibility, Stats};\n use rustc::middle::cstore::{EncodedMetadata, EncodedMetadataHashes};\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::maps::Providers;\n use rustc::dep_graph::AssertDepGraphSafe;\n use rustc::middle::cstore::{self, LinkMeta, LinkagePreference};\n use rustc::hir::map as hir_map;\n use rustc::util::common::{time, print_time_passes_entry};\n-use rustc::session::config::{self, NoDebugInfo, OutputFilenames, OutputType};\n+use rustc::session::config::{self, NoDebugInfo};\n use rustc::session::Session;\n use rustc_incremental::{self, IncrementalHashesMap};\n use abi;\n@@ -60,30 +61,34 @@ use common::CrateContext;\n use common::{type_is_zero_size, val_ty};\n use common;\n use consts;\n-use context::{self, LocalCrateContext, SharedCrateContext, Stats};\n+use context::{self, LocalCrateContext, SharedCrateContext};\n use debuginfo;\n use declare;\n use machine;\n use meth;\n use mir;\n use monomorphize::{self, Instance};\n-use partitioning::{self, PartitioningStrategy, CodegenUnit};\n+use partitioning::{self, PartitioningStrategy, CodegenUnit, CodegenUnitExt};\n use symbol_names_test;\n use time_graph;\n-use trans_item::{TransItem, DefPathBasedNames};\n+use trans_item::{TransItem, TransItemExt, DefPathBasedNames};\n use type_::Type;\n use type_of;\n use value::Value;\n-use rustc::util::nodemap::{NodeSet, FxHashMap, FxHashSet};\n+use rustc::util::nodemap::{NodeSet, FxHashMap, FxHashSet, DefIdSet};\n use CrateInfo;\n \n use libc::c_uint;\n+use std::any::Any;\n+use std::cell::RefCell;\n use std::ffi::{CStr, CString};\n use std::str;\n use std::sync::Arc;\n use std::time::{Instant, Duration};\n use std::i32;\n+use std::sync::mpsc;\n use syntax_pos::Span;\n+use syntax_pos::symbol::InternedString;\n use syntax::attr;\n use rustc::hir;\n use syntax::ast;\n@@ -98,7 +103,7 @@ pub struct StatRecorder<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> StatRecorder<'a, 'tcx> {\n     pub fn new(ccx: &'a CrateContext<'a, 'tcx>, name: String) -> StatRecorder<'a, 'tcx> {\n-        let istart = ccx.stats().n_llvm_insns.get();\n+        let istart = ccx.stats().borrow().n_llvm_insns;\n         StatRecorder {\n             ccx,\n             name: Some(name),\n@@ -110,12 +115,12 @@ impl<'a, 'tcx> StatRecorder<'a, 'tcx> {\n impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n     fn drop(&mut self) {\n         if self.ccx.sess().trans_stats() {\n-            let iend = self.ccx.stats().n_llvm_insns.get();\n-            self.ccx.stats().fn_stats.borrow_mut()\n-                .push((self.name.take().unwrap(), iend - self.istart));\n-            self.ccx.stats().n_fns.set(self.ccx.stats().n_fns.get() + 1);\n+            let mut stats = self.ccx.stats().borrow_mut();\n+            let iend = stats.n_llvm_insns;\n+            stats.fn_stats.push((self.name.take().unwrap(), iend - self.istart));\n+            stats.n_fns += 1;\n             // Reset LLVM insn count to avoid compound costs.\n-            self.ccx.stats().n_llvm_insns.set(self.istart);\n+            stats.n_llvm_insns = self.istart;\n         }\n     }\n }\n@@ -578,7 +583,7 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n     // release builds.\n     info!(\"trans_instance({})\", instance);\n \n-    let fn_ty = common::instance_ty(ccx.shared(), &instance);\n+    let fn_ty = common::instance_ty(ccx.tcx(), &instance);\n     let sig = common::ty_fn_sig(ccx, fn_ty);\n     let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n \n@@ -587,7 +592,7 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n         None => bug!(\"Instance `{:?}` not already declared\", instance)\n     };\n \n-    ccx.stats().n_closures.set(ccx.stats().n_closures.get() + 1);\n+    ccx.stats().borrow_mut().n_closures += 1;\n \n     // The `uwtable` attribute according to LLVM is:\n     //\n@@ -614,7 +619,9 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n     mir::trans_mir(ccx, lldecl, &mir, instance, sig);\n }\n \n-pub fn llvm_linkage_by_name(name: &str) -> Option<Linkage> {\n+pub fn linkage_by_name(name: &str) -> Option<Linkage> {\n+    use rustc::middle::trans::Linkage::*;\n+\n     // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n     // applicable to variable declarations and may not really make sense for\n     // Rust code in the first place but whitelist them anyway and trust that\n@@ -624,17 +631,17 @@ pub fn llvm_linkage_by_name(name: &str) -> Option<Linkage> {\n     // ghost, dllimport, dllexport and linkonce_odr_autohide are not supported\n     // and don't have to be, LLVM treats them as no-ops.\n     match name {\n-        \"appending\" => Some(llvm::Linkage::AppendingLinkage),\n-        \"available_externally\" => Some(llvm::Linkage::AvailableExternallyLinkage),\n-        \"common\" => Some(llvm::Linkage::CommonLinkage),\n-        \"extern_weak\" => Some(llvm::Linkage::ExternalWeakLinkage),\n-        \"external\" => Some(llvm::Linkage::ExternalLinkage),\n-        \"internal\" => Some(llvm::Linkage::InternalLinkage),\n-        \"linkonce\" => Some(llvm::Linkage::LinkOnceAnyLinkage),\n-        \"linkonce_odr\" => Some(llvm::Linkage::LinkOnceODRLinkage),\n-        \"private\" => Some(llvm::Linkage::PrivateLinkage),\n-        \"weak\" => Some(llvm::Linkage::WeakAnyLinkage),\n-        \"weak_odr\" => Some(llvm::Linkage::WeakODRLinkage),\n+        \"appending\" => Some(Appending),\n+        \"available_externally\" => Some(AvailableExternally),\n+        \"common\" => Some(Common),\n+        \"extern_weak\" => Some(ExternalWeak),\n+        \"external\" => Some(External),\n+        \"internal\" => Some(Internal),\n+        \"linkonce\" => Some(LinkOnceAny),\n+        \"linkonce_odr\" => Some(LinkOnceODR),\n+        \"private\" => Some(Private),\n+        \"weak\" => Some(WeakAny),\n+        \"weak_odr\" => Some(WeakODR),\n         _ => None,\n     }\n }\n@@ -886,8 +893,8 @@ fn iter_globals(llmod: llvm::ModuleRef) -> ValueIter {\n ///\n /// This list is later used by linkers to determine the set of symbols needed to\n /// be exposed from a dynamic library and it's also encoded into the metadata.\n-pub fn find_exported_symbols(tcx: TyCtxt, reachable: &NodeSet) -> NodeSet {\n-    reachable.iter().cloned().filter(|&id| {\n+pub fn find_exported_symbols(tcx: TyCtxt) -> NodeSet {\n+    tcx.reachable_set(LOCAL_CRATE).iter().cloned().filter(|&id| {\n         // Next, we want to ignore some FFI functions that are not exposed from\n         // this crate. Reachable FFI functions can be lumped into two\n         // categories:\n@@ -929,25 +936,15 @@ pub fn find_exported_symbols(tcx: TyCtxt, reachable: &NodeSet) -> NodeSet {\n }\n \n pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             analysis: ty::CrateAnalysis,\n                              incremental_hashes_map: IncrementalHashesMap,\n-                             output_filenames: &OutputFilenames)\n+                             rx: mpsc::Receiver<Box<Any + Send>>)\n                              -> OngoingCrateTranslation {\n     check_for_rustc_errors_attr(tcx);\n \n-    // Be careful with this krate: obviously it gives access to the\n-    // entire contents of the krate. So if you push any subtasks of\n-    // `TransCrate`, you need to be careful to register \"reads\" of the\n-    // particular items that will be processed.\n-    let krate = tcx.hir.krate();\n-    let ty::CrateAnalysis { reachable, .. } = analysis;\n-    let check_overflow = tcx.sess.overflow_checks();\n     let link_meta = link::build_link_meta(&incremental_hashes_map);\n-    let exported_symbol_node_ids = find_exported_symbols(tcx, &reachable);\n+    let exported_symbol_node_ids = find_exported_symbols(tcx);\n \n-    let shared_ccx = SharedCrateContext::new(tcx,\n-                                             check_overflow,\n-                                             output_filenames);\n+    let shared_ccx = SharedCrateContext::new(tcx);\n     // Translate the metadata.\n     let (metadata_llcx, metadata_llmod, metadata, metadata_incr_hashes) =\n         time(tcx.sess.time_passes(), \"write metadata\", || {\n@@ -964,34 +961,24 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         kind: ModuleKind::Metadata,\n     };\n \n-    let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n     let time_graph = if tcx.sess.opts.debugging_opts.trans_time_graph {\n         Some(time_graph::TimeGraph::new())\n     } else {\n         None\n     };\n-    let crate_info = CrateInfo::new(tcx);\n \n     // Skip crate items and just output metadata in -Z no-trans mode.\n     if tcx.sess.opts.debugging_opts.no_trans ||\n        !tcx.sess.opts.output_types.should_trans() {\n-        let empty_exported_symbols = ExportedSymbols::empty();\n-        let linker_info = LinkerInfo::new(&shared_ccx, &empty_exported_symbols);\n         let ongoing_translation = write::start_async_translation(\n-            tcx.sess,\n-            output_filenames,\n+            tcx,\n             time_graph.clone(),\n-            tcx.crate_name(LOCAL_CRATE),\n             link_meta,\n             metadata,\n-            Arc::new(empty_exported_symbols),\n-            no_builtins,\n-            None,\n-            linker_info,\n-            crate_info,\n-            false);\n+            rx);\n \n-        ongoing_translation.submit_pre_translated_module_to_llvm(tcx.sess, metadata_module, true);\n+        ongoing_translation.submit_pre_translated_module_to_llvm(tcx, metadata_module);\n+        ongoing_translation.translation_finished(tcx);\n \n         assert_and_save_dep_graph(tcx,\n                                   incremental_hashes_map,\n@@ -1003,46 +990,20 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return ongoing_translation;\n     }\n \n-    let exported_symbols = Arc::new(ExportedSymbols::compute(tcx,\n-                                                             &exported_symbol_node_ids));\n-\n     // Run the translation item collector and partition the collected items into\n     // codegen units.\n-    let (translation_items, codegen_units) =\n-        collect_and_partition_translation_items(&shared_ccx, &exported_symbols);\n+    let codegen_units =\n+        shared_ccx.tcx().collect_and_partition_translation_items(LOCAL_CRATE).1;\n+    let codegen_units = (*codegen_units).clone();\n \n     assert!(codegen_units.len() <= 1 || !tcx.sess.lto());\n \n-    let linker_info = LinkerInfo::new(&shared_ccx, &exported_symbols);\n-    let subsystem = attr::first_attr_value_str_by_name(&krate.attrs,\n-                                                       \"windows_subsystem\");\n-    let windows_subsystem = subsystem.map(|subsystem| {\n-        if subsystem != \"windows\" && subsystem != \"console\" {\n-            tcx.sess.fatal(&format!(\"invalid windows subsystem `{}`, only \\\n-                                     `windows` and `console` are allowed\",\n-                                    subsystem));\n-        }\n-        subsystem.to_string()\n-    });\n-\n-    let no_integrated_as = tcx.sess.opts.cg.no_integrated_as ||\n-        (tcx.sess.target.target.options.no_integrated_as &&\n-         (output_filenames.outputs.contains_key(&OutputType::Object) ||\n-          output_filenames.outputs.contains_key(&OutputType::Exe)));\n-\n     let ongoing_translation = write::start_async_translation(\n-        tcx.sess,\n-        output_filenames,\n+        tcx,\n         time_graph.clone(),\n-        tcx.crate_name(LOCAL_CRATE),\n         link_meta,\n         metadata,\n-        exported_symbols.clone(),\n-        no_builtins,\n-        windows_subsystem,\n-        linker_info,\n-        crate_info,\n-        no_integrated_as);\n+        rx);\n \n     // Translate an allocator shim, if any\n     //\n@@ -1080,18 +1041,10 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n \n     if let Some(allocator_module) = allocator_module {\n-        ongoing_translation.submit_pre_translated_module_to_llvm(tcx.sess, allocator_module, false);\n+        ongoing_translation.submit_pre_translated_module_to_llvm(tcx, allocator_module);\n     }\n \n-    let codegen_unit_count = codegen_units.len();\n-    ongoing_translation.submit_pre_translated_module_to_llvm(tcx.sess,\n-                                                             metadata_module,\n-                                                             codegen_unit_count == 0);\n-\n-    let translation_items = Arc::new(translation_items);\n-\n-    let mut all_stats = Stats::default();\n-    let mut module_dispositions = tcx.sess.opts.incremental.as_ref().map(|_| Vec::new());\n+    ongoing_translation.submit_pre_translated_module_to_llvm(tcx, metadata_module);\n \n     // We sort the codegen units by size. This way we can schedule work for LLVM\n     // a bit more efficiently. Note that \"size\" is defined rather crudely at the\n@@ -1104,221 +1057,57 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n \n     let mut total_trans_time = Duration::new(0, 0);\n+    let mut all_stats = Stats::default();\n \n-    for (cgu_index, cgu) in codegen_units.into_iter().enumerate() {\n+    for cgu in codegen_units.into_iter() {\n         ongoing_translation.wait_for_signal_to_translate_item();\n         ongoing_translation.check_for_errors(tcx.sess);\n \n+        let _timing_guard = time_graph\n+            .as_ref()\n+            .map(|time_graph| time_graph.start(write::TRANS_WORKER_TIMELINE,\n+                                               write::TRANS_WORK_PACKAGE_KIND));\n         let start_time = Instant::now();\n+        all_stats.extend(tcx.compile_codegen_unit(*cgu.name()));\n+        total_trans_time += start_time.elapsed();\n \n-        let module = {\n-            let _timing_guard = time_graph\n-                .as_ref()\n-                .map(|time_graph| time_graph.start(write::TRANS_WORKER_TIMELINE,\n-                                                   write::TRANS_WORK_PACKAGE_KIND));\n-            let dep_node = cgu.work_product_dep_node();\n-            let ((stats, module), _) =\n-                tcx.dep_graph.with_task(dep_node,\n-                                        AssertDepGraphSafe(&shared_ccx),\n-                                        AssertDepGraphSafe((cgu,\n-                                                            translation_items.clone(),\n-                                                            exported_symbols.clone())),\n-                                        module_translation);\n-            all_stats.extend(stats);\n-\n-            if let Some(ref mut module_dispositions) = module_dispositions {\n-                module_dispositions.push(module.disposition());\n-            }\n-\n-            module\n-        };\n-\n-        let time_to_translate = Instant::now().duration_since(start_time);\n-\n-        // We assume that the cost to run LLVM on a CGU is proportional to\n-        // the time we needed for translating it.\n-        let cost = time_to_translate.as_secs() * 1_000_000_000 +\n-                   time_to_translate.subsec_nanos() as u64;\n-\n-        total_trans_time += time_to_translate;\n-\n-        let is_last_cgu = (cgu_index + 1) == codegen_unit_count;\n-\n-        ongoing_translation.submit_translated_module_to_llvm(tcx.sess,\n-                                                             module,\n-                                                             cost,\n-                                                             is_last_cgu);\n         ongoing_translation.check_for_errors(tcx.sess);\n     }\n \n+    ongoing_translation.translation_finished(tcx);\n+\n     // Since the main thread is sometimes blocked during trans, we keep track\n     // -Ztime-passes output manually.\n     print_time_passes_entry(tcx.sess.time_passes(),\n                             \"translate to LLVM IR\",\n                             total_trans_time);\n \n-    if let Some(module_dispositions) = module_dispositions {\n-        assert_module_sources::assert_module_sources(tcx, &module_dispositions);\n-    }\n-\n-    fn module_translation<'a, 'tcx>(\n-        scx: AssertDepGraphSafe<&SharedCrateContext<'a, 'tcx>>,\n-        args: AssertDepGraphSafe<(CodegenUnit<'tcx>,\n-                                  Arc<FxHashSet<TransItem<'tcx>>>,\n-                                  Arc<ExportedSymbols>)>)\n-        -> (Stats, ModuleTranslation)\n-    {\n-        // FIXME(#40304): We ought to be using the id as a key and some queries, I think.\n-        let AssertDepGraphSafe(scx) = scx;\n-        let AssertDepGraphSafe((cgu, crate_trans_items, exported_symbols)) = args;\n-\n-        let cgu_name = String::from(cgu.name());\n-        let cgu_id = cgu.work_product_id();\n-        let symbol_name_hash = cgu.compute_symbol_name_hash(scx);\n-\n-        // Check whether there is a previous work-product we can\n-        // re-use.  Not only must the file exist, and the inputs not\n-        // be dirty, but the hash of the symbols we will generate must\n-        // be the same.\n-        let previous_work_product =\n-            scx.dep_graph().previous_work_product(&cgu_id).and_then(|work_product| {\n-                if work_product.input_hash == symbol_name_hash {\n-                    debug!(\"trans_reuse_previous_work_products: reusing {:?}\", work_product);\n-                    Some(work_product)\n-                } else {\n-                    if scx.sess().opts.debugging_opts.incremental_info {\n-                        eprintln!(\"incremental: CGU `{}` invalidated because of \\\n-                                   changed partitioning hash.\",\n-                                   cgu.name());\n-                    }\n-                    debug!(\"trans_reuse_previous_work_products: \\\n-                            not reusing {:?} because hash changed to {:?}\",\n-                           work_product, symbol_name_hash);\n-                    None\n-                }\n-            });\n-\n-        if let Some(buf) = previous_work_product {\n-            // Don't need to translate this module.\n-            let module = ModuleTranslation {\n-                name: cgu_name,\n-                symbol_name_hash,\n-                source: ModuleSource::Preexisting(buf.clone()),\n-                kind: ModuleKind::Regular,\n-            };\n-            return (Stats::default(), module);\n-        }\n-\n-        // Instantiate translation items without filling out definitions yet...\n-        let lcx = LocalCrateContext::new(scx, cgu, crate_trans_items, exported_symbols);\n-        let module = {\n-            let ccx = CrateContext::new(scx, &lcx);\n-            let trans_items = ccx.codegen_unit()\n-                                 .items_in_deterministic_order(ccx.tcx());\n-            for &(trans_item, (linkage, visibility)) in &trans_items {\n-                trans_item.predefine(&ccx, linkage, visibility);\n-            }\n-\n-            // ... and now that we have everything pre-defined, fill out those definitions.\n-            for &(trans_item, _) in &trans_items {\n-                trans_item.define(&ccx);\n-            }\n-\n-            // If this codegen unit contains the main function, also create the\n-            // wrapper here\n-            maybe_create_entry_wrapper(&ccx);\n-\n-            // Run replace-all-uses-with for statics that need it\n-            for &(old_g, new_g) in ccx.statics_to_rauw().borrow().iter() {\n-                unsafe {\n-                    let bitcast = llvm::LLVMConstPointerCast(new_g, llvm::LLVMTypeOf(old_g));\n-                    llvm::LLVMReplaceAllUsesWith(old_g, bitcast);\n-                    llvm::LLVMDeleteGlobal(old_g);\n-                }\n-            }\n-\n-            // Create the llvm.used variable\n-            // This variable has type [N x i8*] and is stored in the llvm.metadata section\n-            if !ccx.used_statics().borrow().is_empty() {\n-                let name = CString::new(\"llvm.used\").unwrap();\n-                let section = CString::new(\"llvm.metadata\").unwrap();\n-                let array = C_array(Type::i8(&ccx).ptr_to(), &*ccx.used_statics().borrow());\n-\n-                unsafe {\n-                    let g = llvm::LLVMAddGlobal(ccx.llmod(),\n-                                                val_ty(array).to_ref(),\n-                                                name.as_ptr());\n-                    llvm::LLVMSetInitializer(g, array);\n-                    llvm::LLVMRustSetLinkage(g, llvm::Linkage::AppendingLinkage);\n-                    llvm::LLVMSetSection(g, section.as_ptr());\n-                }\n-            }\n-\n-            // Finalize debuginfo\n-            if ccx.sess().opts.debuginfo != NoDebugInfo {\n-                debuginfo::finalize(&ccx);\n-            }\n-\n-            let llvm_module = ModuleLlvm {\n-                llcx: ccx.llcx(),\n-                llmod: ccx.llmod(),\n-            };\n-\n-            // In LTO mode we inject the allocator shim into the existing\n-            // module.\n-            if ccx.sess().lto() {\n-                if let Some(kind) = ccx.sess().allocator_kind.get() {\n-                    time(ccx.sess().time_passes(), \"write allocator module\", || {\n-                        unsafe {\n-                            allocator::trans(ccx.tcx(), &llvm_module, kind);\n-                        }\n-                    });\n-                }\n-            }\n-\n-            // Adjust exported symbols for MSVC dllimport\n-            if ccx.sess().target.target.options.is_like_msvc &&\n-               ccx.sess().crate_types.borrow().iter().any(|ct| *ct == config::CrateTypeRlib) {\n-                create_imps(ccx.sess(), &llvm_module);\n-            }\n-\n-            ModuleTranslation {\n-                name: cgu_name,\n-                symbol_name_hash,\n-                source: ModuleSource::Translated(llvm_module),\n-                kind: ModuleKind::Regular,\n-            }\n-        };\n-\n-        (lcx.into_stats(), module)\n+    if tcx.sess.opts.incremental.is_some() {\n+        DISPOSITIONS.with(|d| {\n+            assert_module_sources::assert_module_sources(tcx, &d.borrow());\n+        });\n     }\n \n     symbol_names_test::report_symbol_names(tcx);\n \n     if shared_ccx.sess().trans_stats() {\n         println!(\"--- trans stats ---\");\n-        println!(\"n_glues_created: {}\", all_stats.n_glues_created.get());\n-        println!(\"n_null_glues: {}\", all_stats.n_null_glues.get());\n-        println!(\"n_real_glues: {}\", all_stats.n_real_glues.get());\n+        println!(\"n_glues_created: {}\", all_stats.n_glues_created);\n+        println!(\"n_null_glues: {}\", all_stats.n_null_glues);\n+        println!(\"n_real_glues: {}\", all_stats.n_real_glues);\n \n-        println!(\"n_fns: {}\", all_stats.n_fns.get());\n-        println!(\"n_inlines: {}\", all_stats.n_inlines.get());\n-        println!(\"n_closures: {}\", all_stats.n_closures.get());\n+        println!(\"n_fns: {}\", all_stats.n_fns);\n+        println!(\"n_inlines: {}\", all_stats.n_inlines);\n+        println!(\"n_closures: {}\", all_stats.n_closures);\n         println!(\"fn stats:\");\n-        all_stats.fn_stats.borrow_mut().sort_by(|&(_, insns_a), &(_, insns_b)| {\n-            insns_b.cmp(&insns_a)\n-        });\n-        for tuple in all_stats.fn_stats.borrow().iter() {\n-            match *tuple {\n-                (ref name, insns) => {\n-                    println!(\"{} insns, {}\", insns, *name);\n-                }\n-            }\n+        all_stats.fn_stats.sort_by_key(|&(_, insns)| insns);\n+        for &(ref name, insns) in all_stats.fn_stats.iter() {\n+            println!(\"{} insns, {}\", insns, *name);\n         }\n     }\n \n     if shared_ccx.sess().count_llvm_insns() {\n-        for (k, v) in all_stats.llvm_insns.borrow().iter() {\n+        for (k, v) in all_stats.llvm_insns.iter() {\n             println!(\"{:7} {}\", *v, *k);\n         }\n     }\n@@ -1332,6 +1121,10 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ongoing_translation\n }\n \n+// FIXME(#42293) hopefully once red/green is enabled we're testing everything\n+// via a method that doesn't require this!\n+thread_local!(static DISPOSITIONS: RefCell<Vec<(String, Disposition)>> = Default::default());\n+\n fn assert_and_save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        incremental_hashes_map: IncrementalHashesMap,\n                                        metadata_incr_hashes: EncodedMetadataHashes,\n@@ -1396,13 +1189,15 @@ fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trans_i\n     }\n }\n \n-fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                                     exported_symbols: &ExportedSymbols)\n-                                                     -> (FxHashSet<TransItem<'tcx>>,\n-                                                         Vec<CodegenUnit<'tcx>>) {\n-    let time_passes = scx.sess().time_passes();\n+fn collect_and_partition_translation_items<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    cnum: CrateNum,\n+) -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>)\n+{\n+    assert_eq!(cnum, LOCAL_CRATE);\n+    let time_passes = tcx.sess.time_passes();\n \n-    let collection_mode = match scx.sess().opts.debugging_opts.print_trans_items {\n+    let collection_mode = match tcx.sess.opts.debugging_opts.print_trans_items {\n         Some(ref s) => {\n             let mode_string = s.to_lowercase();\n             let mode_string = mode_string.trim();\n@@ -1413,7 +1208,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n                     let message = format!(\"Unknown codegen-item collection mode '{}'. \\\n                                            Falling back to 'lazy' mode.\",\n                                            mode_string);\n-                    scx.sess().warn(&message);\n+                    tcx.sess.warn(&message);\n                 }\n \n                 TransItemCollectionMode::Lazy\n@@ -1424,33 +1219,38 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n \n     let (items, inlining_map) =\n         time(time_passes, \"translation item collection\", || {\n-            collector::collect_crate_translation_items(&scx,\n-                                                       exported_symbols,\n-                                                       collection_mode)\n+            collector::collect_crate_translation_items(tcx, collection_mode)\n     });\n \n-    assert_symbols_are_distinct(scx.tcx(), items.iter());\n+    assert_symbols_are_distinct(tcx, items.iter());\n \n-    let strategy = if scx.sess().opts.debugging_opts.incremental.is_some() {\n+    let strategy = if tcx.sess.opts.debugging_opts.incremental.is_some() {\n         PartitioningStrategy::PerModule\n     } else {\n-        PartitioningStrategy::FixedUnitCount(scx.sess().opts.cg.codegen_units)\n+        PartitioningStrategy::FixedUnitCount(tcx.sess.opts.cg.codegen_units)\n     };\n \n     let codegen_units = time(time_passes, \"codegen unit partitioning\", || {\n-        partitioning::partition(scx,\n+        partitioning::partition(tcx,\n                                 items.iter().cloned(),\n                                 strategy,\n-                                &inlining_map,\n-                                exported_symbols)\n+                                &inlining_map)\n+            .into_iter()\n+            .map(Arc::new)\n+            .collect::<Vec<_>>()\n     });\n \n-    assert!(scx.tcx().sess.opts.cg.codegen_units == codegen_units.len() ||\n-            scx.tcx().sess.opts.debugging_opts.incremental.is_some());\n+    assert!(tcx.sess.opts.cg.codegen_units == codegen_units.len() ||\n+            tcx.sess.opts.debugging_opts.incremental.is_some());\n \n-    let translation_items: FxHashSet<TransItem<'tcx>> = items.iter().cloned().collect();\n+    let translation_items: DefIdSet = items.iter().filter_map(|trans_item| {\n+        match *trans_item {\n+            TransItem::Fn(ref instance) => Some(instance.def_id()),\n+            _ => None,\n+        }\n+    }).collect();\n \n-    if scx.sess().opts.debugging_opts.print_trans_items.is_some() {\n+    if tcx.sess.opts.debugging_opts.print_trans_items.is_some() {\n         let mut item_to_cgus = FxHashMap();\n \n         for cgu in &codegen_units {\n@@ -1464,7 +1264,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         let mut item_keys: Vec<_> = items\n             .iter()\n             .map(|i| {\n-                let mut output = i.to_string(scx.tcx());\n+                let mut output = i.to_string(tcx);\n                 output.push_str(\" @@\");\n                 let mut empty = Vec::new();\n                 let cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);\n@@ -1475,17 +1275,17 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n                     output.push_str(&cgu_name);\n \n                     let linkage_abbrev = match linkage {\n-                        llvm::Linkage::ExternalLinkage => \"External\",\n-                        llvm::Linkage::AvailableExternallyLinkage => \"Available\",\n-                        llvm::Linkage::LinkOnceAnyLinkage => \"OnceAny\",\n-                        llvm::Linkage::LinkOnceODRLinkage => \"OnceODR\",\n-                        llvm::Linkage::WeakAnyLinkage => \"WeakAny\",\n-                        llvm::Linkage::WeakODRLinkage => \"WeakODR\",\n-                        llvm::Linkage::AppendingLinkage => \"Appending\",\n-                        llvm::Linkage::InternalLinkage => \"Internal\",\n-                        llvm::Linkage::PrivateLinkage => \"Private\",\n-                        llvm::Linkage::ExternalWeakLinkage => \"ExternalWeak\",\n-                        llvm::Linkage::CommonLinkage => \"Common\",\n+                        Linkage::External => \"External\",\n+                        Linkage::AvailableExternally => \"Available\",\n+                        Linkage::LinkOnceAny => \"OnceAny\",\n+                        Linkage::LinkOnceODR => \"OnceODR\",\n+                        Linkage::WeakAny => \"WeakAny\",\n+                        Linkage::WeakODR => \"WeakODR\",\n+                        Linkage::Appending => \"Appending\",\n+                        Linkage::Internal => \"Internal\",\n+                        Linkage::Private => \"Private\",\n+                        Linkage::ExternalWeak => \"ExternalWeak\",\n+                        Linkage::Common => \"Common\",\n                     };\n \n                     output.push_str(\"[\");\n@@ -1503,11 +1303,11 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         }\n     }\n \n-    (translation_items, codegen_units)\n+    (Arc::new(translation_items), Arc::new(codegen_units))\n }\n \n impl CrateInfo {\n-    pub fn new<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CrateInfo {\n+    pub fn new(tcx: TyCtxt) -> CrateInfo {\n         let mut info = CrateInfo {\n             panic_runtime: None,\n             compiler_builtins: None,\n@@ -1548,3 +1348,222 @@ impl CrateInfo {\n         return info\n     }\n }\n+\n+fn is_translated_function(tcx: TyCtxt, id: DefId) -> bool {\n+    // FIXME(#42293) needs red/green tracking to avoid failing a bunch of\n+    // existing tests\n+    tcx.dep_graph.with_ignore(|| {\n+        let (all_trans_items, _) =\n+            tcx.collect_and_partition_translation_items(LOCAL_CRATE);\n+        all_trans_items.contains(&id)\n+    })\n+}\n+\n+fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                  cgu: InternedString) -> Stats {\n+    // FIXME(#42293) needs red/green tracking to avoid failing a bunch of\n+    // existing tests\n+    let cgu = tcx.dep_graph.with_ignore(|| {\n+        tcx.codegen_unit(cgu)\n+    });\n+\n+    let start_time = Instant::now();\n+    let dep_node = cgu.work_product_dep_node();\n+    let ((stats, module), _) =\n+        tcx.dep_graph.with_task(dep_node,\n+                                AssertDepGraphSafe(tcx),\n+                                AssertDepGraphSafe(cgu),\n+                                module_translation);\n+    let time_to_translate = start_time.elapsed();\n+\n+    if tcx.sess.opts.incremental.is_some() {\n+        DISPOSITIONS.with(|d| {\n+            d.borrow_mut().push(module.disposition());\n+        });\n+    }\n+\n+    // We assume that the cost to run LLVM on a CGU is proportional to\n+    // the time we needed for translating it.\n+    let cost = time_to_translate.as_secs() * 1_000_000_000 +\n+               time_to_translate.subsec_nanos() as u64;\n+\n+    write::submit_translated_module_to_llvm(tcx,\n+                                            module,\n+                                            cost);\n+    return stats;\n+\n+    fn module_translation<'a, 'tcx>(\n+        tcx: AssertDepGraphSafe<TyCtxt<'a, 'tcx, 'tcx>>,\n+        args: AssertDepGraphSafe<Arc<CodegenUnit<'tcx>>>)\n+        -> (Stats, ModuleTranslation)\n+    {\n+        // FIXME(#40304): We ought to be using the id as a key and some queries, I think.\n+        let AssertDepGraphSafe(tcx) = tcx;\n+        let AssertDepGraphSafe(cgu) = args;\n+\n+        let cgu_name = cgu.name().to_string();\n+        let cgu_id = cgu.work_product_id();\n+        let symbol_name_hash = cgu.compute_symbol_name_hash(tcx);\n+\n+        // Check whether there is a previous work-product we can\n+        // re-use.  Not only must the file exist, and the inputs not\n+        // be dirty, but the hash of the symbols we will generate must\n+        // be the same.\n+        let previous_work_product =\n+            tcx.dep_graph.previous_work_product(&cgu_id).and_then(|work_product| {\n+                if work_product.input_hash == symbol_name_hash {\n+                    debug!(\"trans_reuse_previous_work_products: reusing {:?}\", work_product);\n+                    Some(work_product)\n+                } else {\n+                    if tcx.sess.opts.debugging_opts.incremental_info {\n+                        eprintln!(\"incremental: CGU `{}` invalidated because of \\\n+                                   changed partitioning hash.\",\n+                                   cgu.name());\n+                    }\n+                    debug!(\"trans_reuse_previous_work_products: \\\n+                            not reusing {:?} because hash changed to {:?}\",\n+                           work_product, symbol_name_hash);\n+                    None\n+                }\n+            });\n+\n+        if let Some(buf) = previous_work_product {\n+            // Don't need to translate this module.\n+            let module = ModuleTranslation {\n+                name: cgu_name,\n+                symbol_name_hash,\n+                source: ModuleSource::Preexisting(buf.clone()),\n+                kind: ModuleKind::Regular,\n+            };\n+            return (Stats::default(), module);\n+        }\n+\n+        // Instantiate translation items without filling out definitions yet...\n+        let scx = SharedCrateContext::new(tcx);\n+        let lcx = LocalCrateContext::new(&scx, cgu);\n+        let module = {\n+            let ccx = CrateContext::new(&scx, &lcx);\n+            let trans_items = ccx.codegen_unit()\n+                                 .items_in_deterministic_order(ccx.tcx());\n+            for &(trans_item, (linkage, visibility)) in &trans_items {\n+                trans_item.predefine(&ccx, linkage, visibility);\n+            }\n+\n+            // ... and now that we have everything pre-defined, fill out those definitions.\n+            for &(trans_item, _) in &trans_items {\n+                trans_item.define(&ccx);\n+            }\n+\n+            // If this codegen unit contains the main function, also create the\n+            // wrapper here\n+            maybe_create_entry_wrapper(&ccx);\n+\n+            // Run replace-all-uses-with for statics that need it\n+            for &(old_g, new_g) in ccx.statics_to_rauw().borrow().iter() {\n+                unsafe {\n+                    let bitcast = llvm::LLVMConstPointerCast(new_g, llvm::LLVMTypeOf(old_g));\n+                    llvm::LLVMReplaceAllUsesWith(old_g, bitcast);\n+                    llvm::LLVMDeleteGlobal(old_g);\n+                }\n+            }\n+\n+            // Create the llvm.used variable\n+            // This variable has type [N x i8*] and is stored in the llvm.metadata section\n+            if !ccx.used_statics().borrow().is_empty() {\n+                let name = CString::new(\"llvm.used\").unwrap();\n+                let section = CString::new(\"llvm.metadata\").unwrap();\n+                let array = C_array(Type::i8(&ccx).ptr_to(), &*ccx.used_statics().borrow());\n+\n+                unsafe {\n+                    let g = llvm::LLVMAddGlobal(ccx.llmod(),\n+                                                val_ty(array).to_ref(),\n+                                                name.as_ptr());\n+                    llvm::LLVMSetInitializer(g, array);\n+                    llvm::LLVMRustSetLinkage(g, llvm::Linkage::AppendingLinkage);\n+                    llvm::LLVMSetSection(g, section.as_ptr());\n+                }\n+            }\n+\n+            // Finalize debuginfo\n+            if ccx.sess().opts.debuginfo != NoDebugInfo {\n+                debuginfo::finalize(&ccx);\n+            }\n+\n+            let llvm_module = ModuleLlvm {\n+                llcx: ccx.llcx(),\n+                llmod: ccx.llmod(),\n+            };\n+\n+            // In LTO mode we inject the allocator shim into the existing\n+            // module.\n+            if ccx.sess().lto() {\n+                if let Some(kind) = ccx.sess().allocator_kind.get() {\n+                    time(ccx.sess().time_passes(), \"write allocator module\", || {\n+                        unsafe {\n+                            allocator::trans(ccx.tcx(), &llvm_module, kind);\n+                        }\n+                    });\n+                }\n+            }\n+\n+            // Adjust exported symbols for MSVC dllimport\n+            if ccx.sess().target.target.options.is_like_msvc &&\n+               ccx.sess().crate_types.borrow().iter().any(|ct| *ct == config::CrateTypeRlib) {\n+                create_imps(ccx.sess(), &llvm_module);\n+            }\n+\n+            ModuleTranslation {\n+                name: cgu_name,\n+                symbol_name_hash,\n+                source: ModuleSource::Translated(llvm_module),\n+                kind: ModuleKind::Regular,\n+            }\n+        };\n+\n+        (lcx.into_stats(), module)\n+    }\n+}\n+\n+pub fn provide_local(providers: &mut Providers) {\n+    providers.collect_and_partition_translation_items =\n+        collect_and_partition_translation_items;\n+\n+    providers.is_translated_function = is_translated_function;\n+\n+    providers.codegen_unit = |tcx, name| {\n+        let (_, all) = tcx.collect_and_partition_translation_items(LOCAL_CRATE);\n+        all.iter()\n+            .find(|cgu| *cgu.name() == name)\n+            .cloned()\n+            .expect(&format!(\"failed to find cgu with name {:?}\", name))\n+    };\n+    providers.compile_codegen_unit = compile_codegen_unit;\n+}\n+\n+pub fn provide_extern(providers: &mut Providers) {\n+    providers.is_translated_function = is_translated_function;\n+}\n+\n+pub fn linkage_to_llvm(linkage: Linkage) -> llvm::Linkage {\n+    match linkage {\n+        Linkage::External => llvm::Linkage::ExternalLinkage,\n+        Linkage::AvailableExternally => llvm::Linkage::AvailableExternallyLinkage,\n+        Linkage::LinkOnceAny => llvm::Linkage::LinkOnceAnyLinkage,\n+        Linkage::LinkOnceODR => llvm::Linkage::LinkOnceODRLinkage,\n+        Linkage::WeakAny => llvm::Linkage::WeakAnyLinkage,\n+        Linkage::WeakODR => llvm::Linkage::WeakODRLinkage,\n+        Linkage::Appending => llvm::Linkage::AppendingLinkage,\n+        Linkage::Internal => llvm::Linkage::InternalLinkage,\n+        Linkage::Private => llvm::Linkage::PrivateLinkage,\n+        Linkage::ExternalWeak => llvm::Linkage::ExternalWeakLinkage,\n+        Linkage::Common => llvm::Linkage::CommonLinkage,\n+    }\n+}\n+\n+pub fn visibility_to_llvm(linkage: Visibility) -> llvm::Visibility {\n+    match linkage {\n+        Visibility::Default => llvm::Visibility::Default,\n+        Visibility::Hidden => llvm::Visibility::Hidden,\n+        Visibility::Protected => llvm::Visibility::Protected,\n+    }\n+}"}, {"sha": "41a238ea8e3fae0f1b954fed5f0693b279c8fa28", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -101,11 +101,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     fn count_insn(&self, category: &str) {\n         if self.ccx.sess().trans_stats() {\n-            self.ccx.stats().n_llvm_insns.set(self.ccx.stats().n_llvm_insns.get() + 1);\n+            self.ccx.stats().borrow_mut().n_llvm_insns += 1;\n         }\n         if self.ccx.sess().count_llvm_insns() {\n-            let mut h = self.ccx.stats().llvm_insns.borrow_mut();\n-            *h.entry(category.to_string()).or_insert(0) += 1;\n+            *self.ccx.stats()\n+                .borrow_mut()\n+                .llvm_insns\n+                .entry(category.to_string())\n+                .or_insert(0) += 1;\n         }\n     }\n "}, {"sha": "52e6dce24ed929337af2a1308c37d5b0fd081e1f", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 61, "deletions": 30, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -23,7 +23,6 @@ use monomorphize::{self, Instance};\n use rustc::hir::def_id::DefId;\n use rustc::ty::TypeFoldable;\n use rustc::ty::subst::Substs;\n-use trans_item::TransItem;\n use type_of;\n \n /// Translates a reference to a fn/method item, monomorphizing and\n@@ -45,43 +44,42 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     assert!(!instance.substs.has_escaping_regions());\n     assert!(!instance.substs.has_param_types());\n \n-    let fn_ty = common::instance_ty(ccx.shared(), &instance);\n+    let fn_ty = common::instance_ty(ccx.tcx(), &instance);\n     if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n         return llfn;\n     }\n \n     let sym = tcx.symbol_name(instance);\n     debug!(\"get_fn({:?}: {:?}) => {}\", instance, fn_ty, sym);\n \n-    // This is subtle and surprising, but sometimes we have to bitcast\n-    // the resulting fn pointer.  The reason has to do with external\n-    // functions.  If you have two crates that both bind the same C\n-    // library, they may not use precisely the same types: for\n-    // example, they will probably each declare their own structs,\n-    // which are distinct types from LLVM's point of view (nominal\n-    // types).\n-    //\n-    // Now, if those two crates are linked into an application, and\n-    // they contain inlined code, you can wind up with a situation\n-    // where both of those functions wind up being loaded into this\n-    // application simultaneously. In that case, the same function\n-    // (from LLVM's point of view) requires two types. But of course\n-    // LLVM won't allow one function to have two types.\n-    //\n-    // What we currently do, therefore, is declare the function with\n-    // one of the two types (whichever happens to come first) and then\n-    // bitcast as needed when the function is referenced to make sure\n-    // it has the type we expect.\n-    //\n-    // This can occur on either a crate-local or crate-external\n-    // reference. It also occurs when testing libcore and in some\n-    // other weird situations. Annoying.\n-\n     // Create a fn pointer with the substituted signature.\n     let fn_ptr_ty = tcx.mk_fn_ptr(common::ty_fn_sig(ccx, fn_ty));\n     let llptrty = type_of::type_of(ccx, fn_ptr_ty);\n \n     let llfn = if let Some(llfn) = declare::get_declared_value(ccx, &sym) {\n+        // This is subtle and surprising, but sometimes we have to bitcast\n+        // the resulting fn pointer.  The reason has to do with external\n+        // functions.  If you have two crates that both bind the same C\n+        // library, they may not use precisely the same types: for\n+        // example, they will probably each declare their own structs,\n+        // which are distinct types from LLVM's point of view (nominal\n+        // types).\n+        //\n+        // Now, if those two crates are linked into an application, and\n+        // they contain inlined code, you can wind up with a situation\n+        // where both of those functions wind up being loaded into this\n+        // application simultaneously. In that case, the same function\n+        // (from LLVM's point of view) requires two types. But of course\n+        // LLVM won't allow one function to have two types.\n+        //\n+        // What we currently do, therefore, is declare the function with\n+        // one of the two types (whichever happens to come first) and then\n+        // bitcast as needed when the function is referenced to make sure\n+        // it has the type we expect.\n+        //\n+        // This can occur on either a crate-local or crate-external\n+        // reference. It also occurs when testing libcore and in some\n+        // other weird situations. Annoying.\n         if common::val_ty(llfn) != llptrty {\n             debug!(\"get_fn: casting {:?} to {:?}\", llfn, llptrty);\n             consts::ptrcast(llfn, llptrty)\n@@ -110,12 +108,45 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             attributes::unwind(llfn, true);\n         }\n \n+        // Apply an appropriate linkage/visibility value to our item that we\n+        // just declared.\n+        //\n+        // This is sort of subtle. Inside our codegen unit we started off\n+        // compilation by predefining all our own `TransItem` instances. That\n+        // is, everything we're translating ourselves is already defined. That\n+        // means that anything we're actually translating ourselves will have\n+        // hit the above branch in `get_declared_value`. As a result, we're\n+        // guaranteed here that we're declaring a symbol that won't get defined,\n+        // or in other words we're referencing a foreign value.\n+        //\n+        // So because this is a foreign value we blanket apply an external\n+        // linkage directive because it's coming from a different object file.\n+        // The visibility here is where it gets tricky. This symbol could be\n+        // referencing some foreign crate or foreign library (an `extern`\n+        // block) in which case we want to leave the default visibility. We may\n+        // also, though, have multiple codegen units.\n+        //\n+        // In the situation of multiple codegen units this function may be\n+        // referencing a function from another codegen unit. If we're\n+        // indeed referencing a symbol in another codegen unit then we're in one\n+        // of two cases:\n+        //\n+        //  * This is a symbol defined in a foreign crate and we're just\n+        //    monomorphizing in another codegen unit. In this case this symbols\n+        //    is for sure not exported, so both codegen units will be using\n+        //    hidden visibility. Hence, we apply a hidden visibility here.\n+        //\n+        //  * This is a symbol defined in our local crate. If the symbol in the\n+        //    other codegen unit is also not exported then like with the foreign\n+        //    case we apply a hidden visibility. If the symbol is exported from\n+        //    the foreign object file, however, then we leave this at the\n+        //    default visibility as we'll just import it naturally.\n         unsafe {\n             llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::ExternalLinkage);\n \n-            if ccx.crate_trans_items().contains(&TransItem::Fn(instance)) {\n-                if let Some(node_id) = tcx.hir.as_local_node_id(instance_def_id) {\n-                    if !ccx.exported_symbols().local_exports().contains(&node_id) {\n+            if ccx.tcx().is_translated_function(instance_def_id) {\n+                if instance_def_id.is_local() {\n+                    if !ccx.tcx().is_exported_symbol(instance_def_id) {\n                         llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n                     }\n                 } else {\n@@ -148,5 +179,5 @@ pub fn resolve_and_get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                     substs: &'tcx Substs<'tcx>)\n                                     -> ValueRef\n {\n-    get_fn(ccx, monomorphize::resolve(ccx.shared(), def_id, substs))\n+    get_fn(ccx, monomorphize::resolve(ccx.tcx(), def_id, substs))\n }"}, {"sha": "6fa69de74b0a1560b7858706401a63a5da8704f3", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 96, "deletions": 104, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -202,15 +202,13 @@ use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::mir::{self, Location};\n use rustc::mir::visit::Visitor as MirVisitor;\n \n-use context::SharedCrateContext;\n-use common::{def_ty, instance_ty};\n+use common::{def_ty, instance_ty, type_is_sized};\n use monomorphize::{self, Instance};\n use rustc::util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n \n-use trans_item::{TransItem, DefPathBasedNames, InstantiationMode};\n+use trans_item::{TransItem, TransItemExt, DefPathBasedNames, InstantiationMode};\n \n use rustc_data_structures::bitvec::BitVector;\n-use back::symbol_export::ExportedSymbols;\n \n #[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n pub enum TransItemCollectionMode {\n@@ -294,23 +292,22 @@ impl<'tcx> InliningMap<'tcx> {\n     }\n }\n \n-pub fn collect_crate_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                                 exported_symbols: &ExportedSymbols,\n+pub fn collect_crate_translation_items<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                  mode: TransItemCollectionMode)\n                                                  -> (FxHashSet<TransItem<'tcx>>,\n                                                      InliningMap<'tcx>) {\n     // We are not tracking dependencies of this pass as it has to be re-executed\n     // every time no matter what.\n-    scx.tcx().dep_graph.with_ignore(|| {\n-        let roots = collect_roots(scx, exported_symbols, mode);\n+    tcx.dep_graph.with_ignore(|| {\n+        let roots = collect_roots(tcx, mode);\n \n         debug!(\"Building translation item graph, beginning at roots\");\n         let mut visited = FxHashSet();\n         let mut recursion_depths = DefIdMap();\n         let mut inlining_map = InliningMap::new();\n \n         for root in roots {\n-            collect_items_rec(scx,\n+            collect_items_rec(tcx,\n                               root,\n                               &mut visited,\n                               &mut recursion_depths,\n@@ -323,34 +320,32 @@ pub fn collect_crate_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 't\n \n // Find all non-generic items by walking the HIR. These items serve as roots to\n // start monomorphizing from.\n-fn collect_roots<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                           exported_symbols: &ExportedSymbols,\n+fn collect_roots<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            mode: TransItemCollectionMode)\n                            -> Vec<TransItem<'tcx>> {\n     debug!(\"Collecting roots\");\n     let mut roots = Vec::new();\n \n     {\n         let mut visitor = RootCollector {\n-            scx,\n+            tcx,\n             mode,\n-            exported_symbols,\n             output: &mut roots,\n         };\n \n-        scx.tcx().hir.krate().visit_all_item_likes(&mut visitor);\n+        tcx.hir.krate().visit_all_item_likes(&mut visitor);\n     }\n \n     // We can only translate items that are instantiable - items all of\n     // whose predicates hold. Luckily, items that aren't instantiable\n     // can't actually be used, so we can just skip translating them.\n-    roots.retain(|root| root.is_instantiable(scx.tcx()));\n+    roots.retain(|root| root.is_instantiable(tcx));\n \n     roots\n }\n \n // Collect all monomorphized translation items reachable from `starting_point`\n-fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    starting_point: TransItem<'tcx>,\n                                    visited: &mut FxHashSet<TransItem<'tcx>>,\n                                    recursion_depths: &mut DefIdMap<usize>,\n@@ -359,54 +354,54 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n         // We've been here already, no need to search again.\n         return;\n     }\n-    debug!(\"BEGIN collect_items_rec({})\", starting_point.to_string(scx.tcx()));\n+    debug!(\"BEGIN collect_items_rec({})\", starting_point.to_string(tcx));\n \n     let mut neighbors = Vec::new();\n     let recursion_depth_reset;\n \n     match starting_point {\n         TransItem::Static(node_id) => {\n-            let def_id = scx.tcx().hir.local_def_id(node_id);\n-            let instance = Instance::mono(scx.tcx(), def_id);\n+            let def_id = tcx.hir.local_def_id(node_id);\n+            let instance = Instance::mono(tcx, def_id);\n \n             // Sanity check whether this ended up being collected accidentally\n-            debug_assert!(should_trans_locally(scx.tcx(), &instance));\n+            debug_assert!(should_trans_locally(tcx, &instance));\n \n-            let ty = instance_ty(scx, &instance);\n-            visit_drop_use(scx, ty, true, &mut neighbors);\n+            let ty = instance_ty(tcx, &instance);\n+            visit_drop_use(tcx, ty, true, &mut neighbors);\n \n             recursion_depth_reset = None;\n \n-            collect_neighbours(scx, instance, true, &mut neighbors);\n+            collect_neighbours(tcx, instance, true, &mut neighbors);\n         }\n         TransItem::Fn(instance) => {\n             // Sanity check whether this ended up being collected accidentally\n-            debug_assert!(should_trans_locally(scx.tcx(), &instance));\n+            debug_assert!(should_trans_locally(tcx, &instance));\n \n             // Keep track of the monomorphization recursion depth\n-            recursion_depth_reset = Some(check_recursion_limit(scx.tcx(),\n+            recursion_depth_reset = Some(check_recursion_limit(tcx,\n                                                                instance,\n                                                                recursion_depths));\n-            check_type_length_limit(scx.tcx(), instance);\n+            check_type_length_limit(tcx, instance);\n \n-            collect_neighbours(scx, instance, false, &mut neighbors);\n+            collect_neighbours(tcx, instance, false, &mut neighbors);\n         }\n         TransItem::GlobalAsm(..) => {\n             recursion_depth_reset = None;\n         }\n     }\n \n-    record_accesses(scx.tcx(), starting_point, &neighbors[..], inlining_map);\n+    record_accesses(tcx, starting_point, &neighbors[..], inlining_map);\n \n     for neighbour in neighbors {\n-        collect_items_rec(scx, neighbour, visited, recursion_depths, inlining_map);\n+        collect_items_rec(tcx, neighbour, visited, recursion_depths, inlining_map);\n     }\n \n     if let Some((def_id, depth)) = recursion_depth_reset {\n         recursion_depths.insert(def_id, depth);\n     }\n \n-    debug!(\"END collect_items_rec({})\", starting_point.to_string(scx.tcx()));\n+    debug!(\"END collect_items_rec({})\", starting_point.to_string(tcx));\n }\n \n fn record_accesses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -494,7 +489,7 @@ fn check_type_length_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n struct MirNeighborCollector<'a, 'tcx: 'a> {\n-    scx: &'a SharedCrateContext<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &'a mir::Mir<'tcx>,\n     output: &'a mut Vec<TransItem<'tcx>>,\n     param_substs: &'tcx Substs<'tcx>,\n@@ -511,49 +506,49 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             // have to instantiate all methods of the trait being cast to, so we\n             // can build the appropriate vtable.\n             mir::Rvalue::Cast(mir::CastKind::Unsize, ref operand, target_ty) => {\n-                let target_ty = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n-                                                                        &target_ty);\n-                let source_ty = operand.ty(self.mir, self.scx.tcx());\n-                let source_ty = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n-                                                                        &source_ty);\n-                let (source_ty, target_ty) = find_vtable_types_for_unsizing(self.scx,\n+                let target_ty = self.tcx.trans_apply_param_substs(self.param_substs,\n+                                                                  &target_ty);\n+                let source_ty = operand.ty(self.mir, self.tcx);\n+                let source_ty = self.tcx.trans_apply_param_substs(self.param_substs,\n+                                                                  &source_ty);\n+                let (source_ty, target_ty) = find_vtable_types_for_unsizing(self.tcx,\n                                                                             source_ty,\n                                                                             target_ty);\n                 // This could also be a different Unsize instruction, like\n                 // from a fixed sized array to a slice. But we are only\n                 // interested in things that produce a vtable.\n                 if target_ty.is_trait() && !source_ty.is_trait() {\n-                    create_trans_items_for_vtable_methods(self.scx,\n+                    create_trans_items_for_vtable_methods(self.tcx,\n                                                           target_ty,\n                                                           source_ty,\n                                                           self.output);\n                 }\n             }\n             mir::Rvalue::Cast(mir::CastKind::ReifyFnPointer, ref operand, _) => {\n-                let fn_ty = operand.ty(self.mir, self.scx.tcx());\n-                let fn_ty = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n-                                                                    &fn_ty);\n-                visit_fn_use(self.scx, fn_ty, false, &mut self.output);\n+                let fn_ty = operand.ty(self.mir, self.tcx);\n+                let fn_ty = self.tcx.trans_apply_param_substs(self.param_substs,\n+                                                              &fn_ty);\n+                visit_fn_use(self.tcx, fn_ty, false, &mut self.output);\n             }\n             mir::Rvalue::Cast(mir::CastKind::ClosureFnPointer, ref operand, _) => {\n-                let source_ty = operand.ty(self.mir, self.scx.tcx());\n-                let source_ty = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n-                                                                        &source_ty);\n+                let source_ty = operand.ty(self.mir, self.tcx);\n+                let source_ty = self.tcx.trans_apply_param_substs(self.param_substs,\n+                                                                  &source_ty);\n                 match source_ty.sty {\n                     ty::TyClosure(def_id, substs) => {\n                         let instance = monomorphize::resolve_closure(\n-                            self.scx, def_id, substs, ty::ClosureKind::FnOnce);\n+                            self.tcx, def_id, substs, ty::ClosureKind::FnOnce);\n                         self.output.push(create_fn_trans_item(instance));\n                     }\n                     _ => bug!(),\n                 }\n             }\n             mir::Rvalue::NullaryOp(mir::NullOp::Box, _) => {\n-                let tcx = self.scx.tcx();\n+                let tcx = self.tcx;\n                 let exchange_malloc_fn_def_id = tcx\n                     .lang_items()\n                     .require(ExchangeMallocFnLangItem)\n-                    .unwrap_or_else(|e| self.scx.sess().fatal(&e));\n+                    .unwrap_or_else(|e| tcx.sess.fatal(&e));\n                 let instance = Instance::mono(tcx, exchange_malloc_fn_def_id);\n                 if should_trans_locally(tcx, &instance) {\n                     self.output.push(create_fn_trans_item(instance));\n@@ -569,10 +564,10 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         debug!(\"visiting const {:?} @ {:?}\", *constant, location);\n \n         if let ConstVal::Unevaluated(def_id, substs) = constant.val {\n-            let substs = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n-                                                                 &substs);\n-            let instance = monomorphize::resolve(self.scx, def_id, substs);\n-            collect_neighbours(self.scx, instance, true, self.output);\n+            let substs = self.tcx.trans_apply_param_substs(self.param_substs,\n+                                                           &substs);\n+            let instance = monomorphize::resolve(self.tcx, def_id, substs);\n+            collect_neighbours(self.tcx, instance, true, self.output);\n         }\n \n         self.super_const(constant);\n@@ -584,15 +579,15 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                              location: Location) {\n         debug!(\"visiting terminator {:?} @ {:?}\", kind, location);\n \n-        let tcx = self.scx.tcx();\n+        let tcx = self.tcx;\n         match *kind {\n             mir::TerminatorKind::Call { ref func, .. } => {\n                 let callee_ty = func.ty(self.mir, tcx);\n                 let callee_ty = tcx.trans_apply_param_substs(self.param_substs, &callee_ty);\n \n                 let constness = match (self.const_context, &callee_ty.sty) {\n-                    (true, &ty::TyFnDef(def_id, substs)) if self.scx.tcx().is_const_fn(def_id) => {\n-                        let instance = monomorphize::resolve(self.scx, def_id, substs);\n+                    (true, &ty::TyFnDef(def_id, substs)) if self.tcx.is_const_fn(def_id) => {\n+                        let instance = monomorphize::resolve(self.tcx, def_id, substs);\n                         Some(instance)\n                     }\n                     _ => None\n@@ -602,20 +597,20 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                     // If this is a const fn, called from a const context, we\n                     // have to visit its body in order to find any fn reifications\n                     // it might contain.\n-                    collect_neighbours(self.scx,\n+                    collect_neighbours(self.tcx,\n                                        const_fn_instance,\n                                        true,\n                                        self.output);\n                 } else {\n-                    visit_fn_use(self.scx, callee_ty, true, &mut self.output);\n+                    visit_fn_use(self.tcx, callee_ty, true, &mut self.output);\n                 }\n             }\n             mir::TerminatorKind::Drop { ref location, .. } |\n             mir::TerminatorKind::DropAndReplace { ref location, .. } => {\n-                let ty = location.ty(self.mir, self.scx.tcx())\n-                    .to_ty(self.scx.tcx());\n+                let ty = location.ty(self.mir, self.tcx)\n+                    .to_ty(self.tcx);\n                 let ty = tcx.trans_apply_param_substs(self.param_substs, &ty);\n-                visit_drop_use(self.scx, ty, true, self.output);\n+                visit_drop_use(self.tcx, ty, true, self.output);\n             }\n             mir::TerminatorKind::Goto { .. } |\n             mir::TerminatorKind::SwitchInt { .. } |\n@@ -636,7 +631,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                     location: Location) {\n         debug!(\"visiting static {:?} @ {:?}\", static_.def_id, location);\n \n-        let tcx = self.scx.tcx();\n+        let tcx = self.tcx;\n         let instance = Instance::mono(tcx, static_.def_id);\n         if should_trans_locally(tcx, &instance) {\n             let node_id = tcx.hir.as_local_node_id(static_.def_id).unwrap();\n@@ -647,33 +642,33 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n     }\n }\n \n-fn visit_drop_use<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn visit_drop_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             ty: Ty<'tcx>,\n                             is_direct_call: bool,\n                             output: &mut Vec<TransItem<'tcx>>)\n {\n-    let instance = monomorphize::resolve_drop_in_place(scx, ty);\n-    visit_instance_use(scx, instance, is_direct_call, output);\n+    let instance = monomorphize::resolve_drop_in_place(tcx, ty);\n+    visit_instance_use(tcx, instance, is_direct_call, output);\n }\n \n-fn visit_fn_use<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn visit_fn_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           ty: Ty<'tcx>,\n                           is_direct_call: bool,\n                           output: &mut Vec<TransItem<'tcx>>)\n {\n     if let ty::TyFnDef(def_id, substs) = ty.sty {\n-        let instance = monomorphize::resolve(scx, def_id, substs);\n-        visit_instance_use(scx, instance, is_direct_call, output);\n+        let instance = monomorphize::resolve(tcx, def_id, substs);\n+        visit_instance_use(tcx, instance, is_direct_call, output);\n     }\n }\n \n-fn visit_instance_use<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn visit_instance_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 instance: ty::Instance<'tcx>,\n                                 is_direct_call: bool,\n                                 output: &mut Vec<TransItem<'tcx>>)\n {\n     debug!(\"visit_item_use({:?}, is_direct_call={:?})\", instance, is_direct_call);\n-    if !should_trans_locally(scx.tcx(), &instance) {\n+    if !should_trans_locally(tcx, &instance) {\n         return\n     }\n \n@@ -775,15 +770,15 @@ fn should_trans_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: &Instan\n ///\n /// Finally, there is also the case of custom unsizing coercions, e.g. for\n /// smart pointers such as `Rc` and `Arc`.\n-fn find_vtable_types_for_unsizing<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn find_vtable_types_for_unsizing<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                             source_ty: Ty<'tcx>,\n                                             target_ty: Ty<'tcx>)\n                                             -> (Ty<'tcx>, Ty<'tcx>) {\n     let ptr_vtable = |inner_source: Ty<'tcx>, inner_target: Ty<'tcx>| {\n-        if !scx.type_is_sized(inner_source) {\n+        if !type_is_sized(tcx, inner_source) {\n             (inner_source, inner_target)\n         } else {\n-            scx.tcx().struct_lockstep_tails(inner_source, inner_target)\n+            tcx.struct_lockstep_tails(inner_source, inner_target)\n         }\n     };\n     match (&source_ty.sty, &target_ty.sty) {\n@@ -804,7 +799,7 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             assert_eq!(source_adt_def, target_adt_def);\n \n             let kind =\n-                monomorphize::custom_coerce_unsize_info(scx, source_ty, target_ty);\n+                monomorphize::custom_coerce_unsize_info(tcx, source_ty, target_ty);\n \n             let coerce_index = match kind {\n                 CustomCoerceUnsized::Struct(i) => i\n@@ -816,10 +811,10 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             assert!(coerce_index < source_fields.len() &&\n                     source_fields.len() == target_fields.len());\n \n-            find_vtable_types_for_unsizing(scx,\n-                                           source_fields[coerce_index].ty(scx.tcx(),\n+            find_vtable_types_for_unsizing(tcx,\n+                                           source_fields[coerce_index].ty(tcx,\n                                                                           source_substs),\n-                                           target_fields[coerce_index].ty(scx.tcx(),\n+                                           target_fields[coerce_index].ty(tcx,\n                                                                           target_substs))\n         }\n         _ => bug!(\"find_vtable_types_for_unsizing: invalid coercion {:?} -> {:?}\",\n@@ -835,7 +830,7 @@ fn create_fn_trans_item<'a, 'tcx>(instance: Instance<'tcx>) -> TransItem<'tcx> {\n \n /// Creates a `TransItem` for each method that is referenced by the vtable for\n /// the given trait/impl pair.\n-fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn create_trans_items_for_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                    trait_ty: Ty<'tcx>,\n                                                    impl_ty: Ty<'tcx>,\n                                                    output: &mut Vec<TransItem<'tcx>>) {\n@@ -844,19 +839,19 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n \n     if let ty::TyDynamic(ref trait_ty, ..) = trait_ty.sty {\n         if let Some(principal) = trait_ty.principal() {\n-            let poly_trait_ref = principal.with_self_ty(scx.tcx(), impl_ty);\n+            let poly_trait_ref = principal.with_self_ty(tcx, impl_ty);\n             assert!(!poly_trait_ref.has_escaping_regions());\n \n             // Walk all methods of the trait, including those of its supertraits\n-            let methods = traits::get_vtable_methods(scx.tcx(), poly_trait_ref);\n+            let methods = traits::get_vtable_methods(tcx, poly_trait_ref);\n             let methods = methods.filter_map(|method| method)\n-                .map(|(def_id, substs)| monomorphize::resolve(scx, def_id, substs))\n-                .filter(|&instance| should_trans_locally(scx.tcx(), &instance))\n+                .map(|(def_id, substs)| monomorphize::resolve(tcx, def_id, substs))\n+                .filter(|&instance| should_trans_locally(tcx, &instance))\n                 .map(|instance| create_fn_trans_item(instance));\n             output.extend(methods);\n         }\n         // Also add the destructor\n-        visit_drop_use(scx, impl_ty, false, output);\n+        visit_drop_use(tcx, impl_ty, false, output);\n     }\n }\n \n@@ -865,8 +860,7 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n //=-----------------------------------------------------------------------------\n \n struct RootCollector<'b, 'a: 'b, 'tcx: 'a + 'b> {\n-    scx: &'b SharedCrateContext<'a, 'tcx>,\n-    exported_symbols: &'b ExportedSymbols,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mode: TransItemCollectionMode,\n     output: &'b mut Vec<TransItem<'tcx>>,\n }\n@@ -886,7 +880,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n \n             hir::ItemImpl(..) => {\n                 if self.mode == TransItemCollectionMode::Eager {\n-                    create_trans_items_for_default_impls(self.scx,\n+                    create_trans_items_for_default_impls(self.tcx,\n                                                          item,\n                                                          self.output);\n                 }\n@@ -897,38 +891,37 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n             hir::ItemUnion(_, ref generics) => {\n                 if !generics.is_parameterized() {\n                     if self.mode == TransItemCollectionMode::Eager {\n-                        let def_id = self.scx.tcx().hir.local_def_id(item.id);\n+                        let def_id = self.tcx.hir.local_def_id(item.id);\n                         debug!(\"RootCollector: ADT drop-glue for {}\",\n-                               def_id_to_string(self.scx.tcx(), def_id));\n+                               def_id_to_string(self.tcx, def_id));\n \n-                        let ty = def_ty(self.scx, def_id, Substs::empty());\n-                        visit_drop_use(self.scx, ty, true, self.output);\n+                        let ty = def_ty(self.tcx, def_id, Substs::empty());\n+                        visit_drop_use(self.tcx, ty, true, self.output);\n                     }\n                 }\n             }\n             hir::ItemGlobalAsm(..) => {\n                 debug!(\"RootCollector: ItemGlobalAsm({})\",\n-                       def_id_to_string(self.scx.tcx(),\n-                                        self.scx.tcx().hir.local_def_id(item.id)));\n+                       def_id_to_string(self.tcx,\n+                                        self.tcx.hir.local_def_id(item.id)));\n                 self.output.push(TransItem::GlobalAsm(item.id));\n             }\n             hir::ItemStatic(..) => {\n                 debug!(\"RootCollector: ItemStatic({})\",\n-                       def_id_to_string(self.scx.tcx(),\n-                                        self.scx.tcx().hir.local_def_id(item.id)));\n+                       def_id_to_string(self.tcx,\n+                                        self.tcx.hir.local_def_id(item.id)));\n                 self.output.push(TransItem::Static(item.id));\n             }\n             hir::ItemConst(..) => {\n                 // const items only generate translation items if they are\n                 // actually used somewhere. Just declaring them is insufficient.\n             }\n             hir::ItemFn(..) => {\n-                let tcx = self.scx.tcx();\n+                let tcx = self.tcx;\n                 let def_id = tcx.hir.local_def_id(item.id);\n \n                 if (self.mode == TransItemCollectionMode::Eager ||\n-                    !tcx.is_const_fn(def_id) ||\n-                    self.exported_symbols.local_exports().contains(&item.id)) &&\n+                    !tcx.is_const_fn(def_id) || tcx.is_exported_symbol(def_id)) &&\n                    !item_has_type_parameters(tcx, def_id) {\n \n                     debug!(\"RootCollector: ItemFn({})\",\n@@ -949,12 +942,12 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n     fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n         match ii.node {\n             hir::ImplItemKind::Method(hir::MethodSig { .. }, _) => {\n-                let tcx = self.scx.tcx();\n+                let tcx = self.tcx;\n                 let def_id = tcx.hir.local_def_id(ii.id);\n \n                 if (self.mode == TransItemCollectionMode::Eager ||\n                     !tcx.is_const_fn(def_id) ||\n-                    self.exported_symbols.local_exports().contains(&ii.id)) &&\n+                    tcx.is_exported_symbol(def_id)) &&\n                    !item_has_type_parameters(tcx, def_id) {\n                     debug!(\"RootCollector: MethodImplItem({})\",\n                            def_id_to_string(tcx, def_id));\n@@ -973,10 +966,9 @@ fn item_has_type_parameters<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId\n     generics.parent_types as usize + generics.types.len() > 0\n }\n \n-fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                   item: &'tcx hir::Item,\n                                                   output: &mut Vec<TransItem<'tcx>>) {\n-    let tcx = scx.tcx();\n     match item.node {\n         hir::ItemImpl(_,\n                       _,\n@@ -1009,7 +1001,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n                     }\n \n                     let instance =\n-                        monomorphize::resolve(scx, method.def_id, callee_substs);\n+                        monomorphize::resolve(tcx, method.def_id, callee_substs);\n \n                     let trans_item = create_fn_trans_item(instance);\n                     if trans_item.is_instantiable(tcx) && should_trans_locally(tcx, &instance) {\n@@ -1025,15 +1017,15 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n }\n \n /// Scan the MIR in order to find function calls, closures, and drop-glue\n-fn collect_neighbours<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn collect_neighbours<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 instance: Instance<'tcx>,\n                                 const_context: bool,\n                                 output: &mut Vec<TransItem<'tcx>>)\n {\n-    let mir = scx.tcx().instance_mir(instance.def);\n+    let mir = tcx.instance_mir(instance.def);\n \n     let mut visitor = MirNeighborCollector {\n-        scx,\n+        tcx,\n         mir: &mir,\n         output,\n         param_substs: instance.substs,"}, {"sha": "52607904f73c48c11ee83856fe052fa959099737", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -26,6 +26,7 @@ use machine;\n use monomorphize;\n use type_::Type;\n use value::Value;\n+use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{Layout, LayoutTyper};\n use rustc::ty::subst::{Kind, Subst, Substs};\n@@ -37,7 +38,7 @@ use std::iter;\n use syntax::abi::Abi;\n use syntax::attr;\n use syntax::symbol::InternedString;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n pub use context::{CrateContext, SharedCrateContext};\n \n@@ -140,6 +141,18 @@ pub fn type_is_zero_size<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n     !layout.is_unsized() && layout.size(ccx).bytes() == 0\n }\n \n+pub fn type_needs_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n+    ty.needs_drop(tcx, ty::ParamEnv::empty(traits::Reveal::All))\n+}\n+\n+pub fn type_is_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n+    ty.is_sized(tcx, ty::ParamEnv::empty(traits::Reveal::All), DUMMY_SP)\n+}\n+\n+pub fn type_is_freeze<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n+    ty.is_freeze(tcx, ty::ParamEnv::empty(traits::Reveal::All), DUMMY_SP)\n+}\n+\n /*\n * A note on nomenclature of linking: \"extern\", \"foreign\", and \"upcall\".\n *\n@@ -573,20 +586,20 @@ pub fn is_inline_instance<'a, 'tcx>(\n }\n \n /// Given a DefId and some Substs, produces the monomorphic item type.\n-pub fn def_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n+pub fn def_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         def_id: DefId,\n                         substs: &'tcx Substs<'tcx>)\n                         -> Ty<'tcx>\n {\n-    let ty = shared.tcx().type_of(def_id);\n-    shared.tcx().trans_apply_param_substs(substs, &ty)\n+    let ty = tcx.type_of(def_id);\n+    tcx.trans_apply_param_substs(substs, &ty)\n }\n \n /// Return the substituted type of an instance.\n-pub fn instance_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n+pub fn instance_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              instance: &ty::Instance<'tcx>)\n                              -> Ty<'tcx>\n {\n-    let ty = instance.def.def_ty(shared.tcx());\n-    shared.tcx().trans_apply_param_substs(instance.substs, &ty)\n+    let ty = instance.def.def_ty(tcx);\n+    tcx.trans_apply_param_substs(instance.substs, &ty)\n }"}, {"sha": "78ece020d1d6b8a2999c8cb6fb4283811cf07af6", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -16,7 +16,7 @@ use rustc::hir::map as hir_map;\n use rustc::middle::const_val::ConstEvalErr;\n use {debuginfo, machine};\n use base;\n-use trans_item::TransItem;\n+use trans_item::{TransItem, TransItemExt};\n use common::{self, CrateContext, val_ty};\n use declare;\n use monomorphize::Instance;\n@@ -109,7 +109,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n         return g;\n     }\n \n-    let ty = common::instance_ty(ccx.shared(), &instance);\n+    let ty = common::instance_ty(ccx.tcx(), &instance);\n     let g = if let Some(id) = ccx.tcx().hir.as_local_node_id(def_id) {\n \n         let llty = type_of::type_of(ccx, ty);\n@@ -130,7 +130,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n \n                 let g = declare::define_global(ccx, &sym[..], llty).unwrap();\n \n-                if !ccx.exported_symbols().local_exports().contains(&id) {\n+                if !ccx.tcx().is_exported_symbol(def_id) {\n                     unsafe {\n                         llvm::LLVMRustSetVisibility(g, llvm::Visibility::Hidden);\n                     }\n@@ -150,7 +150,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n                     // extern \"C\" fn() from being non-null, so we can't just declare a\n                     // static and call it a day. Some linkages (like weak) will make it such\n                     // that the static actually has a null value.\n-                    let linkage = match base::llvm_linkage_by_name(&name.as_str()) {\n+                    let linkage = match base::linkage_by_name(&name.as_str()) {\n                         Some(linkage) => linkage,\n                         None => {\n                             ccx.sess().span_fatal(span, \"invalid linkage specified\");\n@@ -165,7 +165,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n                     unsafe {\n                         // Declare a symbol `foo` with the desired linkage.\n                         let g1 = declare::declare_global(ccx, &sym, llty2);\n-                        llvm::LLVMRustSetLinkage(g1, linkage);\n+                        llvm::LLVMRustSetLinkage(g1, base::linkage_to_llvm(linkage));\n \n                         // Declare an internal global `extern_with_linkage_foo` which\n                         // is initialized with the address of `foo`.  If `foo` is\n@@ -269,7 +269,7 @@ pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         };\n \n         let instance = Instance::mono(ccx.tcx(), def_id);\n-        let ty = common::instance_ty(ccx.shared(), &instance);\n+        let ty = common::instance_ty(ccx.tcx(), &instance);\n         let llty = type_of::type_of(ccx, ty);\n         let g = if val_llty == llty {\n             g"}, {"sha": "8b18bf2e1ff1f0cb99fdc5191b80a7ec3955df0c", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 19, "deletions": 77, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use common;\n use llvm;\n use llvm::{ContextRef, ModuleRef, ValueRef};\n use rustc::dep_graph::{DepGraph, DepGraphSafe};\n@@ -16,20 +17,19 @@ use rustc::hir::def_id::DefId;\n use rustc::traits;\n use debuginfo;\n use callee;\n-use back::symbol_export::ExportedSymbols;\n use base;\n use declare;\n use monomorphize::Instance;\n \n use partitioning::CodegenUnit;\n-use trans_item::TransItem;\n use type_::Type;\n use rustc_data_structures::base_n;\n-use rustc::session::config::{self, NoDebugInfo, OutputFilenames};\n+use rustc::middle::trans::Stats;\n use rustc::session::Session;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::session::config::{self, NoDebugInfo};\n use rustc::ty::layout::{LayoutCx, LayoutError, LayoutTyper, TyLayout};\n-use rustc::util::nodemap::{FxHashMap, FxHashSet};\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::util::nodemap::FxHashMap;\n \n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n@@ -39,50 +39,16 @@ use std::str;\n use std::sync::Arc;\n use std::marker::PhantomData;\n use syntax::symbol::InternedString;\n-use syntax_pos::DUMMY_SP;\n use abi::Abi;\n \n-#[derive(Clone, Default)]\n-pub struct Stats {\n-    pub n_glues_created: Cell<usize>,\n-    pub n_null_glues: Cell<usize>,\n-    pub n_real_glues: Cell<usize>,\n-    pub n_fns: Cell<usize>,\n-    pub n_inlines: Cell<usize>,\n-    pub n_closures: Cell<usize>,\n-    pub n_llvm_insns: Cell<usize>,\n-    pub llvm_insns: RefCell<FxHashMap<String, usize>>,\n-    // (ident, llvm-instructions)\n-    pub fn_stats: RefCell<Vec<(String, usize)> >,\n-}\n-\n-impl Stats {\n-    pub fn extend(&mut self, stats: Stats) {\n-        self.n_glues_created.set(self.n_glues_created.get() + stats.n_glues_created.get());\n-        self.n_null_glues.set(self.n_null_glues.get() + stats.n_null_glues.get());\n-        self.n_real_glues.set(self.n_real_glues.get() + stats.n_real_glues.get());\n-        self.n_fns.set(self.n_fns.get() + stats.n_fns.get());\n-        self.n_inlines.set(self.n_inlines.get() + stats.n_inlines.get());\n-        self.n_closures.set(self.n_closures.get() + stats.n_closures.get());\n-        self.n_llvm_insns.set(self.n_llvm_insns.get() + stats.n_llvm_insns.get());\n-        self.llvm_insns.borrow_mut().extend(\n-            stats.llvm_insns.borrow().iter()\n-                                     .map(|(key, value)| (key.clone(), value.clone())));\n-        self.fn_stats.borrow_mut().append(&mut *stats.fn_stats.borrow_mut());\n-    }\n-}\n-\n /// The shared portion of a `CrateContext`.  There is one `SharedCrateContext`\n /// per crate.  The data here is shared between all compilation units of the\n /// crate, so it must not contain references to any LLVM data structures\n /// (aside from metadata-related ones).\n pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     check_overflow: bool,\n-\n     use_dll_storage_attrs: bool,\n-\n-    output_filenames: &'a OutputFilenames,\n }\n \n /// The local portion of a `CrateContext`.  There is one `LocalCrateContext`\n@@ -92,14 +58,8 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     llmod: ModuleRef,\n     llcx: ContextRef,\n-    stats: Stats,\n-    codegen_unit: CodegenUnit<'tcx>,\n-\n-    /// The translation items of the whole crate.\n-    crate_trans_items: Arc<FxHashSet<TransItem<'tcx>>>,\n-\n-    /// Information about which symbols are exported from the crate.\n-    exported_symbols: Arc<ExportedSymbols>,\n+    stats: RefCell<Stats>,\n+    codegen_unit: Arc<CodegenUnit<'tcx>>,\n \n     /// Cache instances of monomorphic and polymorphic items\n     instances: RefCell<FxHashMap<Instance<'tcx>, ValueRef>>,\n@@ -261,10 +221,7 @@ pub unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (Cont\n }\n \n impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-               check_overflow: bool,\n-               output_filenames: &'b OutputFilenames)\n-               -> SharedCrateContext<'b, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'b, 'tcx, 'tcx>) -> SharedCrateContext<'b, 'tcx> {\n         // An interesting part of Windows which MSVC forces our hand on (and\n         // apparently MinGW didn't) is the usage of `dllimport` and `dllexport`\n         // attributes in LLVM IR as well as native dependencies (in C these\n@@ -310,27 +267,28 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         // start) and then strongly recommending static linkage on MSVC!\n         let use_dll_storage_attrs = tcx.sess.target.target.options.is_like_msvc;\n \n+        let check_overflow = tcx.sess.overflow_checks();\n+\n         SharedCrateContext {\n             tcx,\n             check_overflow,\n             use_dll_storage_attrs,\n-            output_filenames,\n         }\n     }\n \n     pub fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n-        ty.needs_drop(self.tcx, ty::ParamEnv::empty(traits::Reveal::All))\n+        common::type_needs_drop(self.tcx, ty)\n     }\n \n     pub fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_sized(self.tcx, ty::ParamEnv::empty(traits::Reveal::All), DUMMY_SP)\n+        common::type_is_sized(self.tcx, ty)\n     }\n \n     pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_freeze(self.tcx, ty::ParamEnv::empty(traits::Reveal::All), DUMMY_SP)\n+        common::type_is_freeze(self.tcx, ty)\n     }\n \n-    pub fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'b, 'tcx, 'tcx> {\n         self.tcx\n     }\n \n@@ -345,17 +303,11 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     pub fn use_dll_storage_attrs(&self) -> bool {\n         self.use_dll_storage_attrs\n     }\n-\n-    pub fn output_filenames(&self) -> &OutputFilenames {\n-        self.output_filenames\n-    }\n }\n \n impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n     pub fn new(shared: &SharedCrateContext<'a, 'tcx>,\n-               codegen_unit: CodegenUnit<'tcx>,\n-               crate_trans_items: Arc<FxHashSet<TransItem<'tcx>>>,\n-               exported_symbols: Arc<ExportedSymbols>,)\n+               codegen_unit: Arc<CodegenUnit<'tcx>>)\n                -> LocalCrateContext<'a, 'tcx> {\n         unsafe {\n             // Append \".rs\" to LLVM module identifier.\n@@ -385,10 +337,8 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n             let local_ccx = LocalCrateContext {\n                 llmod,\n                 llcx,\n-                stats: Stats::default(),\n+                stats: RefCell::new(Stats::default()),\n                 codegen_unit,\n-                crate_trans_items,\n-                exported_symbols,\n                 instances: RefCell::new(FxHashMap()),\n                 vtables: RefCell::new(FxHashMap()),\n                 const_cstr_cache: RefCell::new(FxHashMap()),\n@@ -452,7 +402,7 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n     }\n \n     pub fn into_stats(self) -> Stats {\n-        self.stats\n+        self.stats.into_inner()\n     }\n }\n \n@@ -465,7 +415,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local_ccx\n     }\n \n-    pub fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'b, 'tcx, 'tcx> {\n         self.shared.tcx\n     }\n \n@@ -495,14 +445,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().codegen_unit\n     }\n \n-    pub fn crate_trans_items(&self) -> &FxHashSet<TransItem<'tcx>> {\n-        &self.local().crate_trans_items\n-    }\n-\n-    pub fn exported_symbols(&self) -> &ExportedSymbols {\n-        &self.local().exported_symbols\n-    }\n-\n     pub fn td(&self) -> llvm::TargetDataRef {\n         unsafe { llvm::LLVMRustGetModuleDataLayout(self.llmod()) }\n     }\n@@ -545,7 +487,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().lltypes\n     }\n \n-    pub fn stats<'a>(&'a self) -> &'a Stats {\n+    pub fn stats<'a>(&'a self) -> &'a RefCell<Stats> {\n         &self.local().stats\n     }\n "}, {"sha": "8a89bfee4ac26c43626c00b1b1aeda28db437730", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -822,9 +822,9 @@ pub fn compile_unit_metadata(scc: &SharedCrateContext,\n \n             let gcov_cu_info = [\n                 path_to_mdstring(debug_context.llcontext,\n-                                 &scc.output_filenames().with_extension(\"gcno\")),\n+                                 &scc.tcx().output_filenames(LOCAL_CRATE).with_extension(\"gcno\")),\n                 path_to_mdstring(debug_context.llcontext,\n-                                 &scc.output_filenames().with_extension(\"gcda\")),\n+                                 &scc.tcx().output_filenames(LOCAL_CRATE).with_extension(\"gcda\")),\n                 cu_desc_metadata,\n             ];\n             let gcov_metadata = llvm::LLVMMDNodeInContext(debug_context.llcontext,\n@@ -1803,7 +1803,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     };\n \n     let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n-    let variable_type = common::def_ty(cx.shared(), node_def_id, Substs::empty());\n+    let variable_type = common::def_ty(cx.tcx(), node_def_id, Substs::empty());\n     let type_metadata = type_metadata(cx, variable_type, span);\n     let var_name = tcx.item_name(node_def_id).to_string();\n     let linkage_name = mangled_name_of_item(cx, node_def_id, \"\");"}, {"sha": "7e2ac95cd845cdab9d60d40b2fca2bd57d2ba8c1", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -428,7 +428,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // If the method does *not* belong to a trait, proceed\n             if cx.tcx().trait_id_of_impl(impl_def_id).is_none() {\n                 let impl_self_ty =\n-                    common::def_ty(cx.shared(), impl_def_id, instance.substs);\n+                    common::def_ty(cx.tcx(), impl_def_id, instance.substs);\n \n                 // Only \"class\" methods are generally understood by LLVM,\n                 // so avoid methods on other types (e.g. `<*mut T>::null`)."}, {"sha": "ad4fdfca7261ff294fa46724c1fe6fb7ef8aa57e", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -37,7 +37,8 @@ pub fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n     // visible). It might better to use the `exported_items` set from\n     // `driver::CrateAnalysis` in the future, but (atm) this set is not\n     // available in the translation pass.\n-    !cx.exported_symbols().local_exports().contains(&node_id)\n+    let def_id = cx.tcx().hir.local_def_id(node_id);\n+    !cx.tcx().is_exported_symbol(def_id)\n }\n \n #[allow(non_snake_case)]"}, {"sha": "8485867689129bfa02bf64b0d6978d3161e1acd3", "filename": "src/librustc_trans/diagnostics.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdiagnostics.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -46,4 +46,28 @@ extern \"platform-intrinsic\" {\n unsafe { simd_add(i32x1(0), i32x1(1)); } // ok!\n ```\n \"##,\n+\n+E0558: r##\"\n+The `export_name` attribute was malformed.\n+\n+Erroneous code example:\n+\n+```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)\n+#[export_name] // error: export_name attribute has invalid format\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\n+The `export_name` attribute expects a string in order to determine the name of\n+the exported symbol. Example:\n+\n+```\n+#[export_name = \"some_function\"] // ok!\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\"##,\n+\n }"}, {"sha": "453b98a1d74f796f7931862fbcfd7d3e55c12abc", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -14,15 +14,15 @@\n \n use std;\n \n-use llvm;\n-use llvm::{ValueRef};\n-use rustc::ty::{self, Ty};\n-use rustc::ty::layout::LayoutTyper;\n+use builder::Builder;\n use common::*;\n+use llvm::{ValueRef};\n+use llvm;\n use meth;\n use monomorphize;\n+use rustc::ty::layout::LayoutTyper;\n+use rustc::ty::{self, Ty};\n use value::Value;\n-use builder::Builder;\n \n pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n                                        -> (ValueRef, ValueRef) {"}, {"sha": "4cbc98d26ded602bdaacf7472d41189b85f355f8", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -64,16 +64,18 @@ extern crate serialize;\n extern crate gcc; // Used to locate MSVC, not gcc :)\n \n pub use base::trans_crate;\n-pub use back::symbol_names::provide;\n \n pub use metadata::LlvmMetadataLoader;\n pub use llvm_util::{init, target_features, print_version, print_passes, print, enable_llvm_debug};\n \n use std::rc::Rc;\n \n use rustc::hir::def_id::CrateNum;\n-use rustc::util::nodemap::{FxHashSet, FxHashMap};\n use rustc::middle::cstore::{NativeLibrary, CrateSource, LibSource};\n+use rustc::ty::maps::Providers;\n+use rustc::util::nodemap::{FxHashSet, FxHashMap};\n+\n+mod diagnostics;\n \n pub mod back {\n     mod archive;\n@@ -87,8 +89,6 @@ pub mod back {\n     mod rpath;\n }\n \n-mod diagnostics;\n-\n mod abi;\n mod adt;\n mod allocator;\n@@ -247,3 +247,15 @@ pub struct CrateInfo {\n }\n \n __build_diagnostic_array! { librustc_trans, DIAGNOSTICS }\n+\n+pub fn provide_local(providers: &mut Providers) {\n+    back::symbol_names::provide(providers);\n+    back::symbol_export::provide_local(providers);\n+    base::provide_local(providers);\n+}\n+\n+pub fn provide_extern(providers: &mut Providers) {\n+    back::symbol_names::provide(providers);\n+    back::symbol_export::provide_extern(providers);\n+    base::provide_extern(providers);\n+}"}, {"sha": "88407947f0ef40cf306ccba38a61013f72bf1f4a", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -80,7 +80,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let nullptr = C_null(Type::nil(ccx).ptr_to());\n \n     let mut components: Vec<_> = [\n-        callee::get_fn(ccx, monomorphize::resolve_drop_in_place(ccx.shared(), ty)),\n+        callee::get_fn(ccx, monomorphize::resolve_drop_in_place(ccx.tcx(), ty)),\n         C_usize(ccx, ccx.size_of(ty)),\n         C_usize(ccx, ccx.align_of(ty) as u64)\n     ].iter().cloned().collect();"}, {"sha": "9246822b339202a94d3e7a97bd9fcd38dbe786da", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -265,7 +265,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::TerminatorKind::Drop { ref location, target, unwind } => {\n                 let ty = location.ty(self.mir, bcx.tcx()).to_ty(bcx.tcx());\n                 let ty = self.monomorphize(&ty);\n-                let drop_fn = monomorphize::resolve_drop_in_place(bcx.ccx.shared(), ty);\n+                let drop_fn = monomorphize::resolve_drop_in_place(bcx.ccx.tcx(), ty);\n \n                 if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n                     // we don't actually need to drop anything.\n@@ -429,7 +429,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 let (instance, mut llfn) = match callee.ty.sty {\n                     ty::TyFnDef(def_id, substs) => {\n-                        (Some(monomorphize::resolve(bcx.ccx.shared(), def_id, substs)),\n+                        (Some(monomorphize::resolve(bcx.ccx.tcx(), def_id, substs)),\n                          None)\n                     }\n                     ty::TyFnPtr(_) => {\n@@ -546,7 +546,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     };\n \n                     let callee_ty = common::instance_ty(\n-                        bcx.ccx.shared(), instance.as_ref().unwrap());\n+                        bcx.ccx.tcx(), instance.as_ref().unwrap());\n                     trans_intrinsic_call(&bcx, callee_ty, &fn_ty, &llargs, dest,\n                                          terminator.source_info.span);\n "}, {"sha": "9232d73f832e7e37cbda33cae0ea1bafb547a597", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -261,7 +261,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                  substs: &'tcx Substs<'tcx>,\n                  args: IndexVec<mir::Local, Result<Const<'tcx>, ConstEvalErr<'tcx>>>)\n                  -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n-        let instance = monomorphize::resolve(ccx.shared(), def_id, substs);\n+        let instance = monomorphize::resolve(ccx.tcx(), def_id, substs);\n         let mir = ccx.tcx().instance_mir(instance.def);\n         MirConstContext::new(ccx, &mir, instance.substs, args).trans()\n     }"}, {"sha": "822431eba42f156eb3563681350c11ac2ce518c1", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -222,7 +222,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         match operand.ty.sty {\n                             ty::TyClosure(def_id, substs) => {\n                                 let instance = monomorphize::resolve_closure(\n-                                    bcx.ccx.shared(), def_id, substs, ty::ClosureKind::FnOnce);\n+                                    bcx.ccx.tcx(), def_id, substs, ty::ClosureKind::FnOnce);\n                                 OperandValue::Immediate(callee::get_fn(bcx.ccx, instance))\n                             }\n                             _ => {"}, {"sha": "2be7a81b1cd4945af9c2a28e45ea4606503db628", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -85,27 +85,26 @@ fn needs_fn_once_adapter_shim(actual_closure_kind: ty::ClosureKind,\n }\n \n pub fn resolve_closure<'a, 'tcx> (\n-    scx: &SharedCrateContext<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n     substs: ty::ClosureSubsts<'tcx>,\n     requested_kind: ty::ClosureKind)\n     -> Instance<'tcx>\n {\n-    let actual_kind = scx.tcx().closure_kind(def_id);\n+    let actual_kind = tcx.closure_kind(def_id);\n \n     match needs_fn_once_adapter_shim(actual_kind, requested_kind) {\n-        Ok(true) => fn_once_adapter_instance(scx.tcx(), def_id, substs),\n+        Ok(true) => fn_once_adapter_instance(tcx, def_id, substs),\n         _ => Instance::new(def_id, substs.substs)\n     }\n }\n \n fn resolve_associated_item<'a, 'tcx>(\n-    scx: &SharedCrateContext<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     trait_item: &ty::AssociatedItem,\n     trait_id: DefId,\n     rcvr_substs: &'tcx Substs<'tcx>\n ) -> Instance<'tcx> {\n-    let tcx = scx.tcx();\n     let def_id = trait_item.def_id;\n     debug!(\"resolve_associated_item(trait_item={:?}, \\\n                                     trait_id={:?}, \\\n@@ -132,7 +131,7 @@ fn resolve_associated_item<'a, 'tcx>(\n         }\n         traits::VtableClosure(closure_data) => {\n             let trait_closure_kind = tcx.lang_items().fn_trait_kind(trait_id).unwrap();\n-            resolve_closure(scx, closure_data.closure_def_id, closure_data.substs,\n+            resolve_closure(tcx, closure_data.closure_def_id, closure_data.substs,\n                             trait_closure_kind)\n         }\n         traits::VtableFnPointer(ref data) => {\n@@ -163,21 +162,21 @@ fn resolve_associated_item<'a, 'tcx>(\n /// The point where linking happens. Resolve a (def_id, substs)\n /// pair to an instance.\n pub fn resolve<'a, 'tcx>(\n-    scx: &SharedCrateContext<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n     substs: &'tcx Substs<'tcx>\n ) -> Instance<'tcx> {\n     debug!(\"resolve(def_id={:?}, substs={:?})\",\n            def_id, substs);\n-    let result = if let Some(trait_def_id) = scx.tcx().trait_of_item(def_id) {\n+    let result = if let Some(trait_def_id) = tcx.trait_of_item(def_id) {\n         debug!(\" => associated item, attempting to find impl\");\n-        let item = scx.tcx().associated_item(def_id);\n-        resolve_associated_item(scx, &item, trait_def_id, substs)\n+        let item = tcx.associated_item(def_id);\n+        resolve_associated_item(tcx, &item, trait_def_id, substs)\n     } else {\n-        let item_type = def_ty(scx, def_id, substs);\n+        let item_type = def_ty(tcx, def_id, substs);\n         let def = match item_type.sty {\n             ty::TyFnDef(..) if {\n-                    let f = item_type.fn_sig(scx.tcx());\n+                    let f = item_type.fn_sig(tcx);\n                     f.abi() == Abi::RustIntrinsic ||\n                     f.abi() == Abi::PlatformIntrinsic\n                 } =>\n@@ -186,9 +185,9 @@ pub fn resolve<'a, 'tcx>(\n                 ty::InstanceDef::Intrinsic(def_id)\n             }\n             _ => {\n-                if Some(def_id) == scx.tcx().lang_items().drop_in_place_fn() {\n+                if Some(def_id) == tcx.lang_items().drop_in_place_fn() {\n                     let ty = substs.type_at(0);\n-                    if scx.type_needs_drop(ty) {\n+                    if type_needs_drop(tcx, ty) {\n                         debug!(\" => nontrivial drop glue\");\n                         ty::InstanceDef::DropGlue(def_id, Some(ty))\n                     } else {\n@@ -209,27 +208,27 @@ pub fn resolve<'a, 'tcx>(\n }\n \n pub fn resolve_drop_in_place<'a, 'tcx>(\n-    scx: &SharedCrateContext<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ty: Ty<'tcx>)\n     -> ty::Instance<'tcx>\n {\n-    let def_id = scx.tcx().require_lang_item(DropInPlaceFnLangItem);\n-    let substs = scx.tcx().intern_substs(&[Kind::from(ty)]);\n-    resolve(scx, def_id, substs)\n+    let def_id = tcx.require_lang_item(DropInPlaceFnLangItem);\n+    let substs = tcx.intern_substs(&[Kind::from(ty)]);\n+    resolve(tcx, def_id, substs)\n }\n \n-pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx>,\n-                                             source_ty: Ty<'tcx>,\n-                                             target_ty: Ty<'tcx>)\n-                                             -> CustomCoerceUnsized {\n+pub fn custom_coerce_unsize_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                           source_ty: Ty<'tcx>,\n+                                           target_ty: Ty<'tcx>)\n+                                           -> CustomCoerceUnsized {\n     let trait_ref = ty::Binder(ty::TraitRef {\n-        def_id: scx.tcx().lang_items().coerce_unsized_trait().unwrap(),\n-        substs: scx.tcx().mk_substs_trait(source_ty, &[target_ty])\n+        def_id: tcx.lang_items().coerce_unsized_trait().unwrap(),\n+        substs: tcx.mk_substs_trait(source_ty, &[target_ty])\n     });\n \n-    match scx.tcx().trans_fulfill_obligation(DUMMY_SP, trait_ref) {\n+    match tcx.trans_fulfill_obligation(DUMMY_SP, trait_ref) {\n         traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {\n-            scx.tcx().coerce_unsized_info(impl_def_id).custom_kind.unwrap()\n+            tcx.coerce_unsized_info(impl_def_id).custom_kind.unwrap()\n         }\n         vtable => {\n             bug!(\"invalid CoerceUnsized vtable: {:?}\", vtable);"}, {"sha": "9b617c35d93197f1fbfd333c57557cab146476c3", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 78, "deletions": 103, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -102,14 +102,12 @@\n //! source-level module, functions from the same module will be available for\n //! inlining, even when they are not marked #[inline].\n \n-use back::symbol_export::ExportedSymbols;\n use collector::InliningMap;\n use common;\n-use context::SharedCrateContext;\n-use llvm;\n use rustc::dep_graph::{DepNode, WorkProductId};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n+use rustc::middle::trans::{Linkage, Visibility};\n use rustc::session::config::NUMBERED_CODEGEN_UNIT_MARKER;\n use rustc::ty::{self, TyCtxt, InstanceDef};\n use rustc::ty::item_path::characteristic_def_id_of_type;\n@@ -119,7 +117,9 @@ use std::collections::hash_map::Entry;\n use std::hash::Hash;\n use syntax::ast::NodeId;\n use syntax::symbol::{Symbol, InternedString};\n-use trans_item::{TransItem, InstantiationMode};\n+use trans_item::{TransItem, TransItemExt, InstantiationMode};\n+\n+pub use rustc::middle::trans::CodegenUnit;\n \n pub enum PartitioningStrategy {\n     /// Generate one codegen unit per source-level module.\n@@ -129,57 +129,36 @@ pub enum PartitioningStrategy {\n     FixedUnitCount(usize)\n }\n \n-pub struct CodegenUnit<'tcx> {\n-    /// A name for this CGU. Incremental compilation requires that\n-    /// name be unique amongst **all** crates.  Therefore, it should\n-    /// contain something unique to this crate (e.g., a module path)\n-    /// as well as the crate name and disambiguator.\n-    name: InternedString,\n-\n-    items: FxHashMap<TransItem<'tcx>, (llvm::Linkage, llvm::Visibility)>,\n-}\n+pub trait CodegenUnitExt<'tcx> {\n+    fn as_codegen_unit(&self) -> &CodegenUnit<'tcx>;\n \n-impl<'tcx> CodegenUnit<'tcx> {\n-    pub fn new(name: InternedString,\n-               items: FxHashMap<TransItem<'tcx>, (llvm::Linkage, llvm::Visibility)>)\n-               -> Self {\n-        CodegenUnit {\n-            name,\n-            items,\n-        }\n+    fn contains_item(&self, item: &TransItem<'tcx>) -> bool {\n+        self.items().contains_key(item)\n     }\n \n-    pub fn empty(name: InternedString) -> Self {\n-        Self::new(name, FxHashMap())\n+    fn name<'a>(&'a self) -> &'a InternedString\n+        where 'tcx: 'a,\n+    {\n+        &self.as_codegen_unit().name()\n     }\n \n-    pub fn contains_item(&self, item: &TransItem<'tcx>) -> bool {\n-        self.items.contains_key(item)\n+    fn items(&self) -> &FxHashMap<TransItem<'tcx>, (Linkage, Visibility)> {\n+        &self.as_codegen_unit().items()\n     }\n \n-    pub fn name(&self) -> &str {\n-        &self.name\n-    }\n-\n-    pub fn items(&self) -> &FxHashMap<TransItem<'tcx>, (llvm::Linkage, llvm::Visibility)> {\n-        &self.items\n-    }\n-\n-    pub fn work_product_id(&self) -> WorkProductId {\n+    fn work_product_id(&self) -> WorkProductId {\n         WorkProductId::from_cgu_name(self.name())\n     }\n \n-    pub fn work_product_dep_node(&self) -> DepNode {\n+    fn work_product_dep_node(&self) -> DepNode {\n         self.work_product_id().to_dep_node()\n     }\n \n-    pub fn compute_symbol_name_hash<'a>(&self,\n-                                        scx: &SharedCrateContext<'a, 'tcx>)\n-                                        -> u64 {\n+    fn compute_symbol_name_hash<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> u64 {\n         let mut state = IchHasher::new();\n-        let all_items = self.items_in_deterministic_order(scx.tcx());\n+        let all_items = self.items_in_deterministic_order(tcx);\n         for (item, (linkage, visibility)) in all_items {\n-            let symbol_name = item.symbol_name(scx.tcx());\n+            let symbol_name = item.symbol_name(tcx);\n             symbol_name.len().hash(&mut state);\n             symbol_name.hash(&mut state);\n             linkage.hash(&mut state);\n@@ -188,10 +167,10 @@ impl<'tcx> CodegenUnit<'tcx> {\n         state.finish().to_smaller_hash()\n     }\n \n-    pub fn items_in_deterministic_order<'a>(&self,\n-                                            tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                            -> Vec<(TransItem<'tcx>,\n-                                                   (llvm::Linkage, llvm::Visibility))> {\n+    fn items_in_deterministic_order<'a>(&self,\n+                                        tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                        -> Vec<(TransItem<'tcx>,\n+                                               (Linkage, Visibility))> {\n         // The codegen tests rely on items being process in the same order as\n         // they appear in the file, so for local items, we sort by node_id first\n         #[derive(PartialEq, Eq, PartialOrd, Ord)]\n@@ -209,33 +188,34 @@ impl<'tcx> CodegenUnit<'tcx> {\n             }, item.symbol_name(tcx))\n         }\n \n-        let items: Vec<_> = self.items.iter().map(|(&i, &l)| (i, l)).collect();\n+        let items: Vec<_> = self.items().iter().map(|(&i, &l)| (i, l)).collect();\n         let mut items : Vec<_> = items.iter()\n             .map(|il| (il, item_sort_key(tcx, il.0))).collect();\n         items.sort_by(|&(_, ref key1), &(_, ref key2)| key1.cmp(key2));\n         items.into_iter().map(|(&item_linkage, _)| item_linkage).collect()\n     }\n }\n \n+impl<'tcx> CodegenUnitExt<'tcx> for CodegenUnit<'tcx> {\n+    fn as_codegen_unit(&self) -> &CodegenUnit<'tcx> {\n+        self\n+    }\n+}\n \n // Anything we can't find a proper codegen unit for goes into this.\n const FALLBACK_CODEGEN_UNIT: &'static str = \"__rustc_fallback_codegen_unit\";\n \n-pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n+pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               trans_items: I,\n                               strategy: PartitioningStrategy,\n-                              inlining_map: &InliningMap<'tcx>,\n-                              exported_symbols: &ExportedSymbols)\n+                              inlining_map: &InliningMap<'tcx>)\n                               -> Vec<CodegenUnit<'tcx>>\n     where I: Iterator<Item = TransItem<'tcx>>\n {\n-    let tcx = scx.tcx();\n-\n     // In the first step, we place all regular translation items into their\n     // respective 'home' codegen unit. Regular translation items are all\n     // functions and statics defined in the local crate.\n-    let mut initial_partitioning = place_root_translation_items(scx,\n-                                                                exported_symbols,\n+    let mut initial_partitioning = place_root_translation_items(tcx,\n                                                                 trans_items);\n \n     debug_dump(tcx, \"INITIAL PARTITIONING:\", initial_partitioning.codegen_units.iter());\n@@ -269,13 +249,13 @@ pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     } = post_inlining;\n \n     result.sort_by(|cgu1, cgu2| {\n-        (&cgu1.name[..]).cmp(&cgu2.name[..])\n+        cgu1.name().cmp(cgu2.name())\n     });\n \n-    if scx.sess().opts.enable_dep_node_debug_strs() {\n+    if tcx.sess.opts.enable_dep_node_debug_strs() {\n         for cgu in &result {\n             let dep_node = cgu.work_product_dep_node();\n-            scx.tcx().dep_graph.register_dep_node_debug_str(dep_node,\n+            tcx.dep_graph.register_dep_node_debug_str(dep_node,\n                                                             || cgu.name().to_string());\n         }\n     }\n@@ -304,15 +284,11 @@ struct PostInliningPartitioning<'tcx> {\n     internalization_candidates: FxHashSet<TransItem<'tcx>>,\n }\n \n-fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                             exported_symbols: &ExportedSymbols,\n+fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                              trans_items: I)\n                                              -> PreInliningPartitioning<'tcx>\n     where I: Iterator<Item = TransItem<'tcx>>\n {\n-    let tcx = scx.tcx();\n-    let exported_symbols = exported_symbols.local_exports();\n-\n     let mut roots = FxHashSet();\n     let mut codegen_units = FxHashMap();\n     let is_incremental_build = tcx.sess.opts.incremental.is_some();\n@@ -322,7 +298,7 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n         let is_root = trans_item.instantiation_mode(tcx) == InstantiationMode::GloballyShared;\n \n         if is_root {\n-            let characteristic_def_id = characteristic_def_id_of_trans_item(scx, trans_item);\n+            let characteristic_def_id = characteristic_def_id_of_trans_item(tcx, trans_item);\n             let is_volatile = is_incremental_build &&\n                               trans_item.is_generic_fn();\n \n@@ -332,29 +308,29 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n             };\n \n             let make_codegen_unit = || {\n-                CodegenUnit::empty(codegen_unit_name.clone())\n+                CodegenUnit::new(codegen_unit_name.clone())\n             };\n \n             let codegen_unit = codegen_units.entry(codegen_unit_name.clone())\n                                                 .or_insert_with(make_codegen_unit);\n \n             let (linkage, visibility) = match trans_item.explicit_linkage(tcx) {\n-                Some(explicit_linkage) => (explicit_linkage, llvm::Visibility::Default),\n+                Some(explicit_linkage) => (explicit_linkage, Visibility::Default),\n                 None => {\n                     match trans_item {\n                         TransItem::Fn(ref instance) => {\n                             let visibility = match instance.def {\n                                 InstanceDef::Item(def_id) => {\n-                                    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n-                                        if exported_symbols.contains(&node_id) {\n-                                            llvm::Visibility::Default\n+                                    if def_id.is_local() {\n+                                        if tcx.is_exported_symbol(def_id) {\n+                                            Visibility::Default\n                                         } else {\n                                             internalization_candidates.insert(trans_item);\n-                                            llvm::Visibility::Hidden\n+                                            Visibility::Hidden\n                                         }\n                                     } else {\n                                         internalization_candidates.insert(trans_item);\n-                                        llvm::Visibility::Hidden\n+                                        Visibility::Hidden\n                                     }\n                                 }\n                                 InstanceDef::FnPtrShim(..) |\n@@ -368,23 +344,24 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n                                           trans_item)\n                                 }\n                             };\n-                            (llvm::ExternalLinkage, visibility)\n+                            (Linkage::External, visibility)\n                         }\n                         TransItem::Static(node_id) |\n                         TransItem::GlobalAsm(node_id) => {\n-                            let visibility = if exported_symbols.contains(&node_id) {\n-                                llvm::Visibility::Default\n+                            let def_id = tcx.hir.local_def_id(node_id);\n+                            let visibility = if tcx.is_exported_symbol(def_id) {\n+                                Visibility::Default\n                             } else {\n                                 internalization_candidates.insert(trans_item);\n-                                llvm::Visibility::Hidden\n+                                Visibility::Hidden\n                             };\n-                            (llvm::ExternalLinkage, visibility)\n+                            (Linkage::External, visibility)\n                         }\n                     }\n                 }\n             };\n \n-            codegen_unit.items.insert(trans_item, (linkage, visibility));\n+            codegen_unit.items_mut().insert(trans_item, (linkage, visibility));\n             roots.insert(trans_item);\n         }\n     }\n@@ -394,7 +371,7 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     if codegen_units.is_empty() {\n         let codegen_unit_name = Symbol::intern(FALLBACK_CODEGEN_UNIT).as_str();\n         codegen_units.insert(codegen_unit_name.clone(),\n-                             CodegenUnit::empty(codegen_unit_name.clone()));\n+                             CodegenUnit::new(codegen_unit_name.clone()));\n     }\n \n     PreInliningPartitioning {\n@@ -417,26 +394,26 @@ fn merge_codegen_units<'tcx>(initial_partitioning: &mut PreInliningPartitioning<\n     // translation items in a given unit. This could be improved on.\n     while codegen_units.len() > target_cgu_count {\n         // Sort small cgus to the back\n-        codegen_units.sort_by_key(|cgu| -(cgu.items.len() as i64));\n-        let smallest = codegen_units.pop().unwrap();\n+        codegen_units.sort_by_key(|cgu| -(cgu.items().len() as i64));\n+        let mut smallest = codegen_units.pop().unwrap();\n         let second_smallest = codegen_units.last_mut().unwrap();\n \n-        for (k, v) in smallest.items.into_iter() {\n-            second_smallest.items.insert(k, v);\n+        for (k, v) in smallest.items_mut().drain() {\n+            second_smallest.items_mut().insert(k, v);\n         }\n     }\n \n     for (index, cgu) in codegen_units.iter_mut().enumerate() {\n-        cgu.name = numbered_codegen_unit_name(crate_name, index);\n+        cgu.set_name(numbered_codegen_unit_name(crate_name, index));\n     }\n \n     // If the initial partitioning contained less than target_cgu_count to begin\n     // with, we won't have enough codegen units here, so add a empty units until\n     // we reach the target count\n     while codegen_units.len() < target_cgu_count {\n         let index = codegen_units.len();\n-        codegen_units.push(\n-            CodegenUnit::empty(numbered_codegen_unit_name(crate_name, index)));\n+        let name = numbered_codegen_unit_name(crate_name, index);\n+        codegen_units.push(CodegenUnit::new(name));\n     }\n }\n \n@@ -457,29 +434,28 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n     for old_codegen_unit in initial_cgus {\n         // Collect all items that need to be available in this codegen unit\n         let mut reachable = FxHashSet();\n-        for root in old_codegen_unit.items.keys() {\n+        for root in old_codegen_unit.items().keys() {\n             follow_inlining(*root, inlining_map, &mut reachable);\n         }\n \n-        let mut new_codegen_unit = CodegenUnit {\n-            name: old_codegen_unit.name,\n-            items: FxHashMap(),\n-        };\n+        let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name().clone());\n \n         // Add all translation items that are not already there\n         for trans_item in reachable {\n-            if let Some(linkage) = old_codegen_unit.items.get(&trans_item) {\n+            if let Some(linkage) = old_codegen_unit.items().get(&trans_item) {\n                 // This is a root, just copy it over\n-                new_codegen_unit.items.insert(trans_item, *linkage);\n+                new_codegen_unit.items_mut().insert(trans_item, *linkage);\n             } else {\n                 if roots.contains(&trans_item) {\n                     bug!(\"GloballyShared trans-item inlined into other CGU: \\\n                           {:?}\", trans_item);\n                 }\n \n                 // This is a cgu-private copy\n-                new_codegen_unit.items.insert(trans_item,\n-                                              (llvm::InternalLinkage, llvm::Visibility::Default));\n+                new_codegen_unit.items_mut().insert(\n+                    trans_item,\n+                    (Linkage::Internal, Visibility::Default),\n+                );\n             }\n \n             if !single_codegen_unit {\n@@ -490,15 +466,15 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n                         let placement = e.into_mut();\n                         debug_assert!(match *placement {\n                             TransItemPlacement::SingleCgu { ref cgu_name } => {\n-                                *cgu_name != new_codegen_unit.name\n+                                *cgu_name != *new_codegen_unit.name()\n                             }\n                             TransItemPlacement::MultipleCgus => true,\n                         });\n                         *placement = TransItemPlacement::MultipleCgus;\n                     }\n                     Entry::Vacant(e) => {\n                         e.insert(TransItemPlacement::SingleCgu {\n-                            cgu_name: new_codegen_unit.name.clone()\n+                            cgu_name: new_codegen_unit.name().clone()\n                         });\n                     }\n                 }\n@@ -536,8 +512,8 @@ fn internalize_symbols<'a, 'tcx>(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // could be accessed from.\n         for cgu in &mut partitioning.codegen_units {\n             for candidate in &partitioning.internalization_candidates {\n-                cgu.items.insert(*candidate, (llvm::InternalLinkage,\n-                                              llvm::Visibility::Default));\n+                cgu.items_mut().insert(*candidate,\n+                                       (Linkage::Internal, Visibility::Default));\n             }\n         }\n \n@@ -561,10 +537,10 @@ fn internalize_symbols<'a, 'tcx>(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // accessed from outside its defining codegen unit.\n     for cgu in &mut partitioning.codegen_units {\n         let home_cgu = TransItemPlacement::SingleCgu {\n-            cgu_name: cgu.name.clone()\n+            cgu_name: cgu.name().clone()\n         };\n \n-        for (accessee, linkage_and_visibility) in &mut cgu.items {\n+        for (accessee, linkage_and_visibility) in cgu.items_mut() {\n             if !partitioning.internalization_candidates.contains(accessee) {\n                 // This item is no candidate for internalizing, so skip it.\n                 continue\n@@ -587,15 +563,14 @@ fn internalize_symbols<'a, 'tcx>(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             // If we got here, we did not find any accesses from other CGUs,\n             // so it's fine to make this translation item internal.\n-            *linkage_and_visibility = (llvm::InternalLinkage, llvm::Visibility::Default);\n+            *linkage_and_visibility = (Linkage::Internal, Visibility::Default);\n         }\n     }\n }\n \n-fn characteristic_def_id_of_trans_item<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn characteristic_def_id_of_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                  trans_item: TransItem<'tcx>)\n                                                  -> Option<DefId> {\n-    let tcx = scx.tcx();\n     match trans_item {\n         TransItem::Fn(instance) => {\n             let def_id = match instance.def {\n@@ -621,7 +596,7 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(scx: &SharedCrateContext<'a, 't\n             if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n                 // This is a method within an inherent impl, find out what the\n                 // self-type is:\n-                let impl_self_ty = common::def_ty(scx, impl_def_id, instance.substs);\n+                let impl_self_ty = common::def_ty(tcx, impl_def_id, instance.substs);\n                 if let Some(def_id) = characteristic_def_id_of_type(impl_self_ty) {\n                     return Some(def_id);\n                 }\n@@ -679,9 +654,9 @@ fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if cfg!(debug_assertions) {\n         debug!(\"{}\", label);\n         for cgu in cgus {\n-            debug!(\"CodegenUnit {}:\", cgu.name);\n+            debug!(\"CodegenUnit {}:\", cgu.name());\n \n-            for (trans_item, linkage) in &cgu.items {\n+            for (trans_item, linkage) in cgu.items() {\n                 let symbol_name = trans_item.symbol_name(tcx);\n                 let symbol_hash_start = symbol_name.rfind('h');\n                 let symbol_hash = symbol_hash_start.map(|i| &symbol_name[i ..])"}, {"sha": "526b61303e1533fd5736a8ea93d0de9c4fab1529", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 108, "deletions": 107, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -25,23 +25,19 @@ use llvm;\n use monomorphize::Instance;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n+use rustc::middle::trans::{Linkage, Visibility};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::subst::{Subst, Substs};\n-use syntax::ast::{self, NodeId};\n+use syntax::ast;\n use syntax::attr;\n use syntax_pos::Span;\n use syntax_pos::symbol::Symbol;\n use type_of;\n-use std::fmt::Write;\n+use std::fmt::{self, Write};\n use std::iter;\n \n-#[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n-pub enum TransItem<'tcx> {\n-    Fn(Instance<'tcx>),\n-    Static(NodeId),\n-    GlobalAsm(NodeId),\n-}\n+pub use rustc::middle::trans::TransItem;\n \n /// Describes how a translation item will be instantiated in object files.\n #[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n@@ -55,15 +51,16 @@ pub enum InstantiationMode {\n     LocalCopy,\n }\n \n-impl<'a, 'tcx> TransItem<'tcx> {\n+pub trait TransItemExt<'a, 'tcx>: fmt::Debug {\n+    fn as_trans_item(&self) -> &TransItem<'tcx>;\n \n-    pub fn define(&self, ccx: &CrateContext<'a, 'tcx>) {\n+    fn define(&self, ccx: &CrateContext<'a, 'tcx>) {\n         debug!(\"BEGIN IMPLEMENTING '{} ({})' in cgu {}\",\n-                  self.to_string(ccx.tcx()),\n-                  self.to_raw_string(),\n-                  ccx.codegen_unit().name());\n+               self.to_string(ccx.tcx()),\n+               self.to_raw_string(),\n+               ccx.codegen_unit().name());\n \n-        match *self {\n+        match *self.as_trans_item() {\n             TransItem::Static(node_id) => {\n                 let tcx = ccx.tcx();\n                 let item = tcx.hir.expect_item(node_id);\n@@ -97,10 +94,10 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                ccx.codegen_unit().name());\n     }\n \n-    pub fn predefine(&self,\n-                     ccx: &CrateContext<'a, 'tcx>,\n-                     linkage: llvm::Linkage,\n-                     visibility: llvm::Visibility) {\n+    fn predefine(&self,\n+                 ccx: &CrateContext<'a, 'tcx>,\n+                 linkage: Linkage,\n+                 visibility: Visibility) {\n         debug!(\"BEGIN PREDEFINING '{} ({})' in cgu {}\",\n                self.to_string(ccx.tcx()),\n                self.to_raw_string(),\n@@ -110,12 +107,12 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n         debug!(\"symbol {}\", &symbol_name);\n \n-        match *self {\n+        match *self.as_trans_item() {\n             TransItem::Static(node_id) => {\n-                TransItem::predefine_static(ccx, node_id, linkage, visibility, &symbol_name);\n+                predefine_static(ccx, node_id, linkage, visibility, &symbol_name);\n             }\n             TransItem::Fn(instance) => {\n-                TransItem::predefine_fn(ccx, instance, linkage, visibility, &symbol_name);\n+                predefine_fn(ccx, instance, linkage, visibility, &symbol_name);\n             }\n             TransItem::GlobalAsm(..) => {}\n         }\n@@ -126,75 +123,8 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                ccx.codegen_unit().name());\n     }\n \n-    fn predefine_static(ccx: &CrateContext<'a, 'tcx>,\n-                        node_id: ast::NodeId,\n-                        linkage: llvm::Linkage,\n-                        visibility: llvm::Visibility,\n-                        symbol_name: &str) {\n-        let def_id = ccx.tcx().hir.local_def_id(node_id);\n-        let instance = Instance::mono(ccx.tcx(), def_id);\n-        let ty = common::instance_ty(ccx.shared(), &instance);\n-        let llty = type_of::type_of(ccx, ty);\n-\n-        let g = declare::define_global(ccx, symbol_name, llty).unwrap_or_else(|| {\n-            ccx.sess().span_fatal(ccx.tcx().hir.span(node_id),\n-                &format!(\"symbol `{}` is already defined\", symbol_name))\n-        });\n-\n-        unsafe {\n-            llvm::LLVMRustSetLinkage(g, linkage);\n-            llvm::LLVMRustSetVisibility(g, visibility);\n-        }\n-\n-        ccx.instances().borrow_mut().insert(instance, g);\n-        ccx.statics().borrow_mut().insert(g, def_id);\n-    }\n-\n-    fn predefine_fn(ccx: &CrateContext<'a, 'tcx>,\n-                    instance: Instance<'tcx>,\n-                    linkage: llvm::Linkage,\n-                    visibility: llvm::Visibility,\n-                    symbol_name: &str) {\n-        assert!(!instance.substs.needs_infer() &&\n-                !instance.substs.has_param_types());\n-\n-        let mono_ty = common::instance_ty(ccx.shared(), &instance);\n-        let attrs = instance.def.attrs(ccx.tcx());\n-        let lldecl = declare::declare_fn(ccx, symbol_name, mono_ty);\n-        unsafe { llvm::LLVMRustSetLinkage(lldecl, linkage) };\n-        base::set_link_section(ccx, lldecl, &attrs);\n-        if linkage == llvm::Linkage::LinkOnceODRLinkage ||\n-            linkage == llvm::Linkage::WeakODRLinkage {\n-            llvm::SetUniqueComdat(ccx.llmod(), lldecl);\n-        }\n-\n-        // If we're compiling the compiler-builtins crate, e.g. the equivalent of\n-        // compiler-rt, then we want to implicitly compile everything with hidden\n-        // visibility as we're going to link this object all over the place but\n-        // don't want the symbols to get exported.\n-        if linkage != llvm::Linkage::InternalLinkage &&\n-           linkage != llvm::Linkage::PrivateLinkage &&\n-           attr::contains_name(ccx.tcx().hir.krate_attrs(), \"compiler_builtins\") {\n-            unsafe {\n-                llvm::LLVMRustSetVisibility(lldecl, llvm::Visibility::Hidden);\n-            }\n-        } else {\n-            unsafe {\n-                llvm::LLVMRustSetVisibility(lldecl, visibility);\n-            }\n-        }\n-\n-        debug!(\"predefine_fn: mono_ty = {:?} instance = {:?}\", mono_ty, instance);\n-        if common::is_inline_instance(ccx.tcx(), &instance) {\n-            attributes::inline(lldecl, attributes::InlineAttr::Hint);\n-        }\n-        attributes::from_fn_attrs(ccx, &attrs, lldecl);\n-\n-        ccx.instances().borrow_mut().insert(instance, lldecl);\n-    }\n-\n-    pub fn symbol_name(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::SymbolName {\n-        match *self {\n+    fn symbol_name(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::SymbolName {\n+        match *self.as_trans_item() {\n             TransItem::Fn(instance) => tcx.symbol_name(instance),\n             TransItem::Static(node_id) => {\n                 let def_id = tcx.hir.local_def_id(node_id);\n@@ -209,8 +139,8 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         }\n     }\n \n-    pub fn local_span(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Span> {\n-        match *self {\n+    fn local_span(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Span> {\n+        match *self.as_trans_item() {\n             TransItem::Fn(Instance { def, .. }) => {\n                 tcx.hir.as_local_node_id(def.def_id())\n             }\n@@ -221,10 +151,10 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         }.map(|node_id| tcx.hir.span(node_id))\n     }\n \n-    pub fn instantiation_mode(&self,\n-                              tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                              -> InstantiationMode {\n-        match *self {\n+    fn instantiation_mode(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                          -> InstantiationMode {\n+        match *self.as_trans_item() {\n             TransItem::Fn(ref instance) => {\n                 if self.explicit_linkage(tcx).is_none() &&\n                     common::requests_inline(tcx, instance)\n@@ -239,8 +169,8 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         }\n     }\n \n-    pub fn is_generic_fn(&self) -> bool {\n-        match *self {\n+    fn is_generic_fn(&self) -> bool {\n+        match *self.as_trans_item() {\n             TransItem::Fn(ref instance) => {\n                 instance.substs.types().next().is_some()\n             }\n@@ -249,16 +179,16 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         }\n     }\n \n-    pub fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<llvm::Linkage> {\n-        let def_id = match *self {\n+    fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Linkage> {\n+        let def_id = match *self.as_trans_item() {\n             TransItem::Fn(ref instance) => instance.def_id(),\n             TransItem::Static(node_id) => tcx.hir.local_def_id(node_id),\n             TransItem::GlobalAsm(..) => return None,\n         };\n \n         let attributes = tcx.get_attrs(def_id);\n         if let Some(name) = attr::first_attr_value_str_by_name(&attributes, \"linkage\") {\n-            if let Some(linkage) = base::llvm_linkage_by_name(&name.as_str()) {\n+            if let Some(linkage) = base::linkage_by_name(&name.as_str()) {\n                 Some(linkage)\n             } else {\n                 let span = tcx.hir.span_if_local(def_id);\n@@ -298,9 +228,9 @@ impl<'a, 'tcx> TransItem<'tcx> {\n     /// Similarly, if a vtable method has such a signature, and therefore can't\n     /// be used, we can just not emit it and have a placeholder (a null pointer,\n     /// which will never be accessed) in its place.\n-    pub fn is_instantiable(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n+    fn is_instantiable(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n         debug!(\"is_instantiable({:?})\", self);\n-        let (def_id, substs) = match *self {\n+        let (def_id, substs) = match *self.as_trans_item() {\n             TransItem::Fn(ref instance) => (instance.def_id(), instance.substs),\n             TransItem::Static(node_id) => (tcx.hir.local_def_id(node_id), Substs::empty()),\n             // global asm never has predicates\n@@ -311,10 +241,10 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         traits::normalize_and_test_predicates(tcx, predicates)\n     }\n \n-    pub fn to_string(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n+    fn to_string(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n         let hir_map = &tcx.hir;\n \n-        return match *self {\n+        return match *self.as_trans_item() {\n             TransItem::Fn(instance) => {\n                 to_string_internal(tcx, \"fn \", instance)\n             },\n@@ -340,8 +270,8 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         }\n     }\n \n-    pub fn to_raw_string(&self) -> String {\n-        match *self {\n+    fn to_raw_string(&self) -> String {\n+        match *self.as_trans_item() {\n             TransItem::Fn(instance) => {\n                 format!(\"Fn({:?}, {})\",\n                          instance.def,\n@@ -357,6 +287,77 @@ impl<'a, 'tcx> TransItem<'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> TransItemExt<'a, 'tcx> for TransItem<'tcx> {\n+    fn as_trans_item(&self) -> &TransItem<'tcx> {\n+        self\n+    }\n+}\n+\n+fn predefine_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                              node_id: ast::NodeId,\n+                              linkage: Linkage,\n+                              visibility: Visibility,\n+                              symbol_name: &str) {\n+    let def_id = ccx.tcx().hir.local_def_id(node_id);\n+    let instance = Instance::mono(ccx.tcx(), def_id);\n+    let ty = common::instance_ty(ccx.tcx(), &instance);\n+    let llty = type_of::type_of(ccx, ty);\n+\n+    let g = declare::define_global(ccx, symbol_name, llty).unwrap_or_else(|| {\n+        ccx.sess().span_fatal(ccx.tcx().hir.span(node_id),\n+            &format!(\"symbol `{}` is already defined\", symbol_name))\n+    });\n+\n+    unsafe {\n+        llvm::LLVMRustSetLinkage(g, base::linkage_to_llvm(linkage));\n+        llvm::LLVMRustSetVisibility(g, base::visibility_to_llvm(visibility));\n+    }\n+\n+    ccx.instances().borrow_mut().insert(instance, g);\n+    ccx.statics().borrow_mut().insert(g, def_id);\n+}\n+\n+fn predefine_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                          instance: Instance<'tcx>,\n+                          linkage: Linkage,\n+                          visibility: Visibility,\n+                          symbol_name: &str) {\n+    assert!(!instance.substs.needs_infer() &&\n+            !instance.substs.has_param_types());\n+\n+    let mono_ty = common::instance_ty(ccx.tcx(), &instance);\n+    let attrs = instance.def.attrs(ccx.tcx());\n+    let lldecl = declare::declare_fn(ccx, symbol_name, mono_ty);\n+    unsafe { llvm::LLVMRustSetLinkage(lldecl, base::linkage_to_llvm(linkage)) };\n+    base::set_link_section(ccx, lldecl, &attrs);\n+    if linkage == Linkage::LinkOnceODR ||\n+        linkage == Linkage::WeakODR {\n+        llvm::SetUniqueComdat(ccx.llmod(), lldecl);\n+    }\n+\n+    // If we're compiling the compiler-builtins crate, e.g. the equivalent of\n+    // compiler-rt, then we want to implicitly compile everything with hidden\n+    // visibility as we're going to link this object all over the place but\n+    // don't want the symbols to get exported.\n+    if linkage != Linkage::Internal && linkage != Linkage::Private &&\n+       attr::contains_name(ccx.tcx().hir.krate_attrs(), \"compiler_builtins\") {\n+        unsafe {\n+            llvm::LLVMRustSetVisibility(lldecl, llvm::Visibility::Hidden);\n+        }\n+    } else {\n+        unsafe {\n+            llvm::LLVMRustSetVisibility(lldecl, base::visibility_to_llvm(visibility));\n+        }\n+    }\n+\n+    debug!(\"predefine_fn: mono_ty = {:?} instance = {:?}\", mono_ty, instance);\n+    if common::is_inline_instance(ccx.tcx(), &instance) {\n+        attributes::inline(lldecl, attributes::InlineAttr::Hint);\n+    }\n+    attributes::from_fn_attrs(ccx, &attrs, lldecl);\n+\n+    ccx.instances().borrow_mut().insert(instance, lldecl);\n+}\n \n //=-----------------------------------------------------------------------------\n // TransItem String Keys"}, {"sha": "0c0748cf673c1ebc3c1e4f0c78f6b4c44f369817", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -176,6 +176,11 @@ pub fn run_core(search_paths: SearchPaths,\n     let arena = DroplessArena::new();\n     let arenas = GlobalArenas::new();\n     let hir_map = hir_map::map_crate(&mut hir_forest, defs);\n+    let output_filenames = driver::build_output_filenames(&input,\n+                                                          &None,\n+                                                          &None,\n+                                                          &[],\n+                                                          &sess);\n \n     abort_on_err(driver::phase_3_run_analysis_passes(&sess,\n                                                      &*cstore,\n@@ -185,7 +190,8 @@ pub fn run_core(search_paths: SearchPaths,\n                                                      &arena,\n                                                      &arenas,\n                                                      &name,\n-                                                     |tcx, analysis, _, result| {\n+                                                     &output_filenames,\n+                                                     |tcx, analysis, _, _, result| {\n         if let Err(_) = result {\n             sess.fatal(\"Compilation failed, aborting rustdoc\");\n         }"}, {"sha": "36ab3737f3803cb8aeaa82c7f4316ca24de443bc", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -506,30 +506,6 @@ pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {\n     first_attr_value_str_by_name(attrs, \"crate_name\")\n }\n \n-/// Find the value of #[export_name=*] attribute and check its validity.\n-pub fn find_export_name_attr(diag: &Handler, attrs: &[Attribute]) -> Option<Symbol> {\n-    attrs.iter().fold(None, |ia,attr| {\n-        if attr.check_name(\"export_name\") {\n-            if let s@Some(_) = attr.value_str() {\n-                s\n-            } else {\n-                struct_span_err!(diag, attr.span, E0558,\n-                                 \"export_name attribute has invalid format\")\n-                    .span_label(attr.span, \"did you mean #[export_name=\\\"*\\\"]?\")\n-                    .emit();\n-                None\n-            }\n-        } else {\n-            ia\n-        }\n-    })\n-}\n-\n-pub fn contains_extern_indicator(diag: &Handler, attrs: &[Attribute]) -> bool {\n-    contains_name(attrs, \"no_mangle\") ||\n-        find_export_name_attr(diag, attrs).is_some()\n-}\n-\n #[derive(Copy, Clone, PartialEq)]\n pub enum InlineAttr {\n     None,"}, {"sha": "b29883670bdeae3dfb496fd7e7c92c31dd34e8c5", "filename": "src/libsyntax/diagnostic_list.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a76d8accf04047a938ba43b32d5ff9ab581715/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=e8a76d8accf04047a938ba43b32d5ff9ab581715", "patch": "@@ -219,29 +219,6 @@ Erroneous code example:\n Delete the offending feature attribute.\n \"##,\n \n-E0558: r##\"\n-The `export_name` attribute was malformed.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0558\n-#[export_name] // error: export_name attribute has invalid format\n-pub fn something() {}\n-\n-fn main() {}\n-```\n-\n-The `export_name` attribute expects a string in order to determine the name of\n-the exported symbol. Example:\n-\n-```\n-#[export_name = \"some_function\"] // ok!\n-pub fn something() {}\n-\n-fn main() {}\n-```\n-\"##,\n-\n E0565: r##\"\n A literal was used in an attribute that doesn't support literals.\n "}]}