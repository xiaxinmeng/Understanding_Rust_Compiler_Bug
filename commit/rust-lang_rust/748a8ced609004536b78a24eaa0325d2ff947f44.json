{"sha": "748a8ced609004536b78a24eaa0325d2ff947f44", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0OGE4Y2VkNjA5MDA0NTM2Yjc4YTI0ZWFhMDMyNWQyZmY5NDdmNDQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-09-15T20:15:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-15T20:15:04Z"}, "message": "Merge #6010\n\n6010: Avoid checking all ancestors and fix mis-completion r=jonas-schievink a=oxalica\n\nRefactor the logic of `completion_match` to check deterministic number of ancestors instead of `token.ancestors().find_map()`.\r\nThis should fix wrong completions (https://github.com/rust-analyzer/rust-analyzer/pull/5976#issuecomment-692332191) and hopefully make completion to be faster (#6004).\r\n\r\nMore play and test? @jonas-schievink @hammypants \r\n\r\nIf this patch works, we can avoid the revert #6005 . :disappointed:\n\nCo-authored-by: oxalica <oxalicc@pm.me>", "tree": {"sha": "15ece122198b0db397560be997e1874a051fe075", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15ece122198b0db397560be997e1874a051fe075"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/748a8ced609004536b78a24eaa0325d2ff947f44", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfYSDICRBK7hj4Ov3rIwAAdHIIAIal1hmB2jSGvakwx28dZVdX\n3gLMes6WaZufXfpCHnXJfDXgVQ4PgR6kWVbomddBiNz5pZ2I6U2CciajAg6kDriq\nXgcDEEbBORyT4NP93n2rx+GBr0Vm98ZuRVVC0WKoRgfjnEBu19kKNlTYrR5bnR0e\nQmNEPgz6txO0buqzkJXmsFBJdyK9wwdwQYkc3GmtUF7lMBNm43Fu1DuiAQ6Hu+gB\n/aEkxjAc/F0q0eGYWdpO5egGKw1G/xYE9C+uVbCxLvtUSdvoVieJtmwvzUTrZ+qi\nbISBr6zgd5uZhSGY/q/KOyziViLFtc+nv6i69bifmPLEiIKICkZkuZaAJhs4vHw=\n=fcw/\n-----END PGP SIGNATURE-----\n", "payload": "tree 15ece122198b0db397560be997e1874a051fe075\nparent 37f3b9ca2a0252b93c5900e2104e3e954c383869\nparent d2fced1c260d976be9ccbb8b6fcbb59c786238c4\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1600200904 +0000\ncommitter GitHub <noreply@github.com> 1600200904 +0000\n\nMerge #6010\n\n6010: Avoid checking all ancestors and fix mis-completion r=jonas-schievink a=oxalica\n\nRefactor the logic of `completion_match` to check deterministic number of ancestors instead of `token.ancestors().find_map()`.\r\nThis should fix wrong completions (https://github.com/rust-analyzer/rust-analyzer/pull/5976#issuecomment-692332191) and hopefully make completion to be faster (#6004).\r\n\r\nMore play and test? @jonas-schievink @hammypants \r\n\r\nIf this patch works, we can avoid the revert #6005 . :disappointed:\n\nCo-authored-by: oxalica <oxalicc@pm.me>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/748a8ced609004536b78a24eaa0325d2ff947f44", "html_url": "https://github.com/rust-lang/rust/commit/748a8ced609004536b78a24eaa0325d2ff947f44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/748a8ced609004536b78a24eaa0325d2ff947f44/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37f3b9ca2a0252b93c5900e2104e3e954c383869", "url": "https://api.github.com/repos/rust-lang/rust/commits/37f3b9ca2a0252b93c5900e2104e3e954c383869", "html_url": "https://github.com/rust-lang/rust/commit/37f3b9ca2a0252b93c5900e2104e3e954c383869"}, {"sha": "d2fced1c260d976be9ccbb8b6fcbb59c786238c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2fced1c260d976be9ccbb8b6fcbb59c786238c4", "html_url": "https://github.com/rust-lang/rust/commit/d2fced1c260d976be9ccbb8b6fcbb59c786238c4"}], "stats": {"total": 248, "additions": 215, "deletions": 33}, "files": [{"sha": "ff115df9286945d83bacaffd458ab8803c6739cc", "filename": "crates/ide/src/completion/complete_trait_impl.rs", "status": "modified", "additions": 215, "deletions": 33, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/748a8ced609004536b78a24eaa0325d2ff947f44/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748a8ced609004536b78a24eaa0325d2ff947f44/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs?ref=748a8ced609004536b78a24eaa0325d2ff947f44", "patch": "@@ -86,36 +86,46 @@ fn completion_match(ctx: &CompletionContext) -> Option<(ImplCompletionKind, Synt\n         token = token.prev_token()?;\n     }\n \n-    let (kind, trigger, impl_def_offset) = token.ancestors().find_map(|p| match p.kind() {\n-        // `const` can be a modifier of an item, so the `const` token may be inside another item syntax node.\n-        // Eg. `impl .. { const <|> fn bar() .. }`\n-        SyntaxKind::FN | SyntaxKind::TYPE_ALIAS | SyntaxKind::CONST\n-            if token.kind() == SyntaxKind::CONST_KW =>\n-        {\n-            Some((ImplCompletionKind::Const, p, 2))\n-        }\n-        SyntaxKind::FN => Some((ImplCompletionKind::Fn, p, 2)),\n-        SyntaxKind::TYPE_ALIAS => Some((ImplCompletionKind::TypeAlias, p, 2)),\n-        SyntaxKind::CONST => Some((ImplCompletionKind::Const, p, 2)),\n-        // `impl .. { const <|> }` is parsed as:\n-        // IMPL\n-        //   ASSOC_ITEM_LIST\n-        //     ERROR\n-        //       CONST_KW <- token\n-        //     WHITESPACE <- ctx.token\n-        SyntaxKind::ERROR\n-            if p.first_token().map_or(false, |t| t.kind() == SyntaxKind::CONST_KW) =>\n-        {\n-            Some((ImplCompletionKind::Const, p, 2))\n-        }\n-        SyntaxKind::NAME_REF => Some((ImplCompletionKind::All, p, 5)),\n-        _ => None,\n-    })?;\n+    let impl_item_offset = match token.kind() {\n+        // `impl .. { const <|> }`\n+        // ERROR      0\n+        //   CONST_KW <- *\n+        SyntaxKind::CONST_KW => 0,\n+        // `impl .. { fn/type <|> }`\n+        // FN/TYPE_ALIAS  0\n+        //   FN_KW        <- *\n+        SyntaxKind::FN_KW | SyntaxKind::TYPE_KW => 0,\n+        // `impl .. { fn/type/const foo<|> }`\n+        // FN/TYPE_ALIAS/CONST  1\n+        //  NAME                0\n+        //    IDENT             <- *\n+        SyntaxKind::IDENT if token.parent().kind() == SyntaxKind::NAME => 1,\n+        // `impl .. { foo<|> }`\n+        // MACRO_CALL       3\n+        //  PATH            2\n+        //    PATH_SEGMENT  1\n+        //      NAME_REF    0\n+        //        IDENT     <- *\n+        SyntaxKind::IDENT if token.parent().kind() == SyntaxKind::NAME_REF => 3,\n+        _ => return None,\n+    };\n \n-    let impl_def = (0..impl_def_offset - 1)\n-        .try_fold(trigger.parent()?, |t, _| t.parent())\n-        .and_then(ast::Impl::cast)?;\n-    Some((kind, trigger, impl_def))\n+    let impl_item = token.ancestors().nth(impl_item_offset)?;\n+    // Must directly belong to an impl block.\n+    // IMPL\n+    //   ASSOC_ITEM_LIST\n+    //     <item>\n+    let impl_def = ast::Impl::cast(impl_item.parent()?.parent()?)?;\n+    let kind = match impl_item.kind() {\n+        // `impl ... { const <|> fn/type/const }`\n+        _ if token.kind() == SyntaxKind::CONST_KW => ImplCompletionKind::Const,\n+        SyntaxKind::CONST | SyntaxKind::ERROR => ImplCompletionKind::Const,\n+        SyntaxKind::TYPE_ALIAS => ImplCompletionKind::TypeAlias,\n+        SyntaxKind::FN => ImplCompletionKind::Fn,\n+        SyntaxKind::MACRO_CALL => ImplCompletionKind::All,\n+        _ => return None,\n+    };\n+    Some((kind, impl_item, impl_def))\n }\n \n fn add_function_impl(\n@@ -261,19 +271,191 @@ ta type TestType = \\n\\\n     }\n \n     #[test]\n-    fn no_nested_fn_completions() {\n+    fn no_completion_inside_fn() {\n         check(\n             r\"\n-trait Test {\n-    fn test();\n-    fn test2();\n+trait Test { fn test(); fn test2(); }\n+struct T;\n+\n+impl Test for T {\n+    fn test() {\n+        t<|>\n+    }\n+}\n+\",\n+            expect![[\"\"]],\n+        );\n+\n+        check(\n+            r\"\n+trait Test { fn test(); fn test2(); }\n+struct T;\n+\n+impl Test for T {\n+    fn test() {\n+        fn t<|>\n+    }\n }\n+\",\n+            expect![[\"\"]],\n+        );\n+\n+        check(\n+            r\"\n+trait Test { fn test(); fn test2(); }\n struct T;\n \n impl Test for T {\n     fn test() {\n+        fn <|>\n+    }\n+}\n+\",\n+            expect![[\"\"]],\n+        );\n+\n+        // https://github.com/rust-analyzer/rust-analyzer/pull/5976#issuecomment-692332191\n+        check(\n+            r\"\n+trait Test { fn test(); fn test2(); }\n+struct T;\n+\n+impl Test for T {\n+    fn test() {\n+        foo.<|>\n+    }\n+}\n+\",\n+            expect![[\"\"]],\n+        );\n+\n+        check(\n+            r\"\n+trait Test { fn test(_: i32); fn test2(); }\n+struct T;\n+\n+impl Test for T {\n+    fn test(t<|>)\n+}\n+\",\n+            expect![[\"\"]],\n+        );\n+\n+        check(\n+            r\"\n+trait Test { fn test(_: fn()); fn test2(); }\n+struct T;\n+\n+impl Test for T {\n+    fn test(f: fn <|>)\n+}\n+\",\n+            expect![[\"\"]],\n+        );\n+    }\n+\n+    #[test]\n+    fn no_completion_inside_const() {\n+        check(\n+            r\"\n+trait Test { const TEST: fn(); const TEST2: u32; type Test; fn test(); }\n+struct T;\n+\n+impl Test for T {\n+    const TEST: fn <|>\n+}\n+\",\n+            expect![[\"\"]],\n+        );\n+\n+        check(\n+            r\"\n+trait Test { const TEST: u32; const TEST2: u32; type Test; fn test(); }\n+struct T;\n+\n+impl Test for T {\n+    const TEST: T<|>\n+}\n+\",\n+            expect![[\"\"]],\n+        );\n+\n+        check(\n+            r\"\n+trait Test { const TEST: u32; const TEST2: u32; type Test; fn test(); }\n+struct T;\n+\n+impl Test for T {\n+    const TEST: u32 = f<|>\n+}\n+\",\n+            expect![[\"\"]],\n+        );\n+\n+        check(\n+            r\"\n+trait Test { const TEST: u32; const TEST2: u32; type Test; fn test(); }\n+struct T;\n+\n+impl Test for T {\n+    const TEST: u32 = {\n         t<|>\n+    };\n+}\n+\",\n+            expect![[\"\"]],\n+        );\n+\n+        check(\n+            r\"\n+trait Test { const TEST: u32; const TEST2: u32; type Test; fn test(); }\n+struct T;\n+\n+impl Test for T {\n+    const TEST: u32 = {\n+        fn <|>\n+    };\n+}\n+\",\n+            expect![[\"\"]],\n+        );\n+\n+        check(\n+            r\"\n+trait Test { const TEST: u32; const TEST2: u32; type Test; fn test(); }\n+struct T;\n+\n+impl Test for T {\n+    const TEST: u32 = {\n+        fn t<|>\n+    };\n+}\n+\",\n+            expect![[\"\"]],\n+        );\n     }\n+\n+    #[test]\n+    fn no_completion_inside_type() {\n+        check(\n+            r\"\n+trait Test { type Test; type Test2; fn test(); }\n+struct T;\n+\n+impl Test for T {\n+    type Test = T<|>;\n+}\n+\",\n+            expect![[\"\"]],\n+        );\n+\n+        check(\n+            r\"\n+trait Test { type Test; type Test2; fn test(); }\n+struct T;\n+\n+impl Test for T {\n+    type Test = fn <|>;\n }\n \",\n             expect![[\"\"]],"}]}