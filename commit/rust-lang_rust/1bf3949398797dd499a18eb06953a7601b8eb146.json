{"sha": "1bf3949398797dd499a18eb06953a7601b8eb146", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiZjM5NDkzOTg3OTdkZDQ5OWExOGViMDY5NTNhNzYwMWI4ZWIxNDY=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-01-05T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-01-12T20:18:39Z"}, "message": "Reorder MIR encoding checks\n\nStart from least expensive checks when deciding whether to encode MIR or not.\n\nNo functional changes intended.", "tree": {"sha": "838c1b1ba4195dde30346c33a5160e08d8b23486", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/838c1b1ba4195dde30346c33a5160e08d8b23486"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1bf3949398797dd499a18eb06953a7601b8eb146", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1bf3949398797dd499a18eb06953a7601b8eb146", "html_url": "https://github.com/rust-lang/rust/commit/1bf3949398797dd499a18eb06953a7601b8eb146", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1bf3949398797dd499a18eb06953a7601b8eb146/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "704e47f78b4c8801a3c76f235a5a152e1b60b300", "url": "https://api.github.com/repos/rust-lang/rust/commits/704e47f78b4c8801a3c76f235a5a152e1b60b300", "html_url": "https://github.com/rust-lang/rust/commit/704e47f78b4c8801a3c76f235a5a152e1b60b300"}], "stats": {"total": 45, "additions": 20, "deletions": 25}, "files": [{"sha": "fd99087710724d214cd72579fc6b9a14308492ea", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/1bf3949398797dd499a18eb06953a7601b8eb146/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bf3949398797dd499a18eb06953a7601b8eb146/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=1bf3949398797dd499a18eb06953a7601b8eb146", "patch": "@@ -66,6 +66,11 @@ pub(super) struct EncodeContext<'a, 'tcx> {\n     required_source_files: Option<GrowableBitSet<usize>>,\n     is_proc_macro: bool,\n     hygiene_ctxt: &'a HygieneEncodeContext,\n+\n+    // Determines if MIR used for code generation will be included in the crate\n+    // metadata. When emitting only metadata (e.g., cargo check), we can avoid\n+    // generating optimized MIR altogether.\n+    emit_codegen_mir: bool,\n }\n \n /// If the current crate is a proc-macro, returns early with `Lazy:empty()`.\n@@ -1032,11 +1037,6 @@ impl EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn metadata_output_only(&self) -> bool {\n-        // MIR optimisation can be skipped when we're just interested in the metadata.\n-        !self.tcx.sess.opts.output_types.should_codegen()\n-    }\n-\n     fn encode_info_for_impl_item(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_impl_item({:?})\", def_id);\n         let tcx = self.tcx;\n@@ -1105,13 +1105,12 @@ impl EncodeContext<'a, 'tcx> {\n         let (mir, mir_const) = match ast_item.kind {\n             hir::ImplItemKind::Const(..) => (false, true),\n             hir::ImplItemKind::Fn(ref sig, _) => {\n-                let generics = self.tcx.generics_of(def_id);\n-                let needs_inline = (generics.requires_monomorphization(self.tcx)\n-                    || tcx.codegen_fn_attrs(def_id).requests_inline())\n-                    && !self.metadata_output_only();\n+                let opt_mir = tcx.sess.opts.debugging_opts.always_encode_mir\n+                    || (self.emit_codegen_mir\n+                        && (tcx.generics_of(def_id).requires_monomorphization(tcx)\n+                            || tcx.codegen_fn_attrs(def_id).requests_inline()));\n                 let is_const_fn = sig.header.constness == hir::Constness::Const;\n-                let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n-                (needs_inline || always_encode_mir, is_const_fn)\n+                (opt_mir, is_const_fn)\n             }\n             hir::ImplItemKind::TyAlias(..) => (false, false),\n         };\n@@ -1433,16 +1432,13 @@ impl EncodeContext<'a, 'tcx> {\n         let (mir, const_mir) = match item.kind {\n             hir::ItemKind::Static(..) | hir::ItemKind::Const(..) => (false, true),\n             hir::ItemKind::Fn(ref sig, ..) => {\n-                let generics = tcx.generics_of(def_id);\n-                let needs_inline = (generics.requires_monomorphization(tcx)\n-                    || tcx.codegen_fn_attrs(def_id).requests_inline())\n-                    && !self.metadata_output_only();\n-\n+                let opt_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir\n+                    || (self.emit_codegen_mir\n+                        && (tcx.generics_of(def_id).requires_monomorphization(tcx)\n+                            || tcx.codegen_fn_attrs(def_id).requests_inline()));\n                 let is_const_fn = sig.header.constness == hir::Constness::Const;\n-                let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n-                let mir = needs_inline || always_encode_mir;\n                 // We don't need the optimized MIR for const fns.\n-                (mir, is_const_fn)\n+                (opt_mir, is_const_fn)\n             }\n             _ => (false, false),\n         };\n@@ -2008,10 +2004,9 @@ impl<'tcx, 'v> ParItemLikeVisitor<'v> for PrefetchVisitor<'tcx> {\n             }\n             hir::ItemKind::Fn(ref sig, ..) => {\n                 let def_id = tcx.hir().local_def_id(item.hir_id);\n-                let generics = tcx.generics_of(def_id.to_def_id());\n-                let needs_inline = generics.requires_monomorphization(tcx)\n+                let opt_mir = tcx.generics_of(def_id.to_def_id()).requires_monomorphization(tcx)\n                     || tcx.codegen_fn_attrs(def_id.to_def_id()).requests_inline();\n-                if needs_inline {\n+                if opt_mir {\n                     self.prefetch_mir(def_id)\n                 }\n                 if sig.header.constness == hir::Constness::Const {\n@@ -2045,11 +2040,10 @@ impl<'tcx, 'v> ParItemLikeVisitor<'v> for PrefetchVisitor<'tcx> {\n             }\n             hir::ImplItemKind::Fn(ref sig, _) => {\n                 let def_id = tcx.hir().local_def_id(impl_item.hir_id);\n-                let generics = tcx.generics_of(def_id.to_def_id());\n-                let needs_inline = generics.requires_monomorphization(tcx)\n+                let opt_mir = tcx.generics_of(def_id.to_def_id()).requires_monomorphization(tcx)\n                     || tcx.codegen_fn_attrs(def_id.to_def_id()).requests_inline();\n                 let is_const_fn = sig.header.constness == hir::Constness::Const;\n-                if needs_inline {\n+                if opt_mir {\n                     self.prefetch_mir(def_id)\n                 }\n                 if is_const_fn {\n@@ -2148,6 +2142,7 @@ fn encode_metadata_impl(tcx: TyCtxt<'_>) -> EncodedMetadata {\n         required_source_files,\n         is_proc_macro: tcx.sess.crate_types().contains(&CrateType::ProcMacro),\n         hygiene_ctxt: &hygiene_ctxt,\n+        emit_codegen_mir: tcx.sess.opts.output_types.should_codegen(),\n     };\n \n     // Encode the rustc version string in a predictable location."}]}