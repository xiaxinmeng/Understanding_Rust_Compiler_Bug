{"sha": "713c3ea30b38199e05e1f70094d85177f16915f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxM2MzZWEzMGIzODE5OWUwNWUxZjcwMDk0ZDg1MTc3ZjE2OTE1Zjg=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-20T14:33:54Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-20T14:33:54Z"}, "message": "Merge #234\n\n234: Global module r=matklad a=matklad\n\nThis series of commits re-introdces `ModuleDescriptor` as one stop shop for all information about a module.\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "f4f3c59a59e4a607b77321cb685bf616824dc8f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4f3c59a59e4a607b77321cb685bf616824dc8f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/713c3ea30b38199e05e1f70094d85177f16915f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/713c3ea30b38199e05e1f70094d85177f16915f8", "html_url": "https://github.com/rust-lang/rust/commit/713c3ea30b38199e05e1f70094d85177f16915f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/713c3ea30b38199e05e1f70094d85177f16915f8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "902778ccaefc7b51548cab459715aaf8653bbbc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/902778ccaefc7b51548cab459715aaf8653bbbc6", "html_url": "https://github.com/rust-lang/rust/commit/902778ccaefc7b51548cab459715aaf8653bbbc6"}, {"sha": "a2fdb41ace4de7737a3ba0e4ef5e68d0a41e924d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2fdb41ace4de7737a3ba0e4ef5e68d0a41e924d", "html_url": "https://github.com/rust-lang/rust/commit/a2fdb41ace4de7737a3ba0e4ef5e68d0a41e924d"}], "stats": {"total": 436, "additions": 233, "deletions": 203}, "files": [{"sha": "5e3ee79dd8734914907b1fe35516b477fc508e1c", "filename": "crates/ra_analysis/src/completion/mod.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/713c3ea30b38199e05e1f70094d85177f16915f8/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713c3ea30b38199e05e1f70094d85177f16915f8/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs?ref=713c3ea30b38199e05e1f70094d85177f16915f8", "patch": "@@ -2,7 +2,6 @@ mod reference_completion;\n \n use ra_editor::find_node_at_offset;\n use ra_syntax::{\n-    algo::find_leaf_at_offset,\n     algo::visit::{visitor_ctx, VisitorCtx},\n     ast,\n     AstNode, AtomEdit,\n@@ -12,8 +11,9 @@ use rustc_hash::{FxHashMap};\n \n use crate::{\n     db::{self, SyntaxDatabase},\n-    descriptors::{DescriptorDatabase, module::ModuleSource},\n-    input::{FilesDatabase},\n+    descriptors::{\n+        module::{ModuleDescriptor}\n+    },\n     Cancelable, FilePosition\n };\n \n@@ -38,14 +38,7 @@ pub(crate) fn completions(\n         original_file.reparse(&edit)\n     };\n \n-    let leaf = match find_leaf_at_offset(original_file.syntax(), position.offset).left_biased() {\n-        None => return Ok(None),\n-        Some(it) => it,\n-    };\n-    let source_root_id = db.file_source_root(position.file_id);\n-    let module_tree = db.module_tree(source_root_id)?;\n-    let module_source = ModuleSource::for_node(position.file_id, leaf);\n-    let module_id = match module_tree.any_module_for_source(module_source) {\n+    let module = match ModuleDescriptor::guess_from_position(db, position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n@@ -55,15 +48,7 @@ pub(crate) fn completions(\n     // First, let's try to complete a reference to some declaration.\n     if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), position.offset) {\n         has_completions = true;\n-        reference_completion::completions(\n-            &mut res,\n-            db,\n-            source_root_id,\n-            &module_tree,\n-            module_id,\n-            &file,\n-            name_ref,\n-        )?;\n+        reference_completion::completions(&mut res, db, &module, &file, name_ref)?;\n         // special case, `trait T { fn foo(i_am_a_name_ref) {} }`\n         if is_node::<ast::Param>(name_ref.syntax()) {\n             param_completions(name_ref.syntax(), &mut res);"}, {"sha": "c94d9af75ac157bfbe1701645318679d9c557c18", "filename": "crates/ra_analysis/src/completion/reference_completion.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/713c3ea30b38199e05e1f70094d85177f16915f8/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713c3ea30b38199e05e1f70094d85177f16915f8/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs?ref=713c3ea30b38199e05e1f70094d85177f16915f8", "patch": "@@ -9,20 +9,16 @@ use ra_syntax::{\n \n use crate::{\n     db::RootDatabase,\n-    input::{SourceRootId},\n     completion::CompletionItem,\n-    descriptors::module::{ModuleId, ModuleTree},\n+    descriptors::module::{ModuleDescriptor},\n     descriptors::function::FnScopes,\n-    descriptors::DescriptorDatabase,\n     Cancelable\n };\n \n pub(super) fn completions(\n     acc: &mut Vec<CompletionItem>,\n     db: &RootDatabase,\n-    source_root_id: SourceRootId,\n-    module_tree: &ModuleTree,\n-    module_id: ModuleId,\n+    module: &ModuleDescriptor,\n     file: &SourceFileNode,\n     name_ref: ast::NameRef,\n ) -> Cancelable<()> {\n@@ -40,7 +36,7 @@ pub(super) fn completions(\n                 complete_expr_snippets(acc);\n             }\n \n-            let module_scope = db.module_scope(source_root_id, module_id)?;\n+            let module_scope = module.scope(db)?;\n             acc.extend(\n                 module_scope\n                     .entries()\n@@ -56,9 +52,7 @@ pub(super) fn completions(\n                     }),\n             );\n         }\n-        NameRefKind::CratePath(path) => {\n-            complete_path(acc, db, source_root_id, module_tree, module_id, path)?\n-        }\n+        NameRefKind::CratePath(path) => complete_path(acc, db, module, path)?,\n         NameRefKind::BareIdentInMod => {\n             let name_range = name_ref.syntax().range();\n             let top_node = name_ref\n@@ -171,16 +165,14 @@ fn complete_fn(name_ref: ast::NameRef, scopes: &FnScopes, acc: &mut Vec<Completi\n fn complete_path(\n     acc: &mut Vec<CompletionItem>,\n     db: &RootDatabase,\n-    source_root_id: SourceRootId,\n-    module_tree: &ModuleTree,\n-    module_id: ModuleId,\n+    module: &ModuleDescriptor,\n     crate_path: Vec<ast::NameRef>,\n ) -> Cancelable<()> {\n-    let target_module_id = match find_target_module(module_tree, module_id, crate_path) {\n+    let target_module = match find_target_module(module, crate_path) {\n         None => return Ok(()),\n         Some(it) => it,\n     };\n-    let module_scope = db.module_scope(source_root_id, target_module_id)?;\n+    let module_scope = target_module.scope(db)?;\n     let completions = module_scope.entries().iter().map(|entry| CompletionItem {\n         label: entry.name().to_string(),\n         lookup: None,\n@@ -191,14 +183,13 @@ fn complete_path(\n }\n \n fn find_target_module(\n-    module_tree: &ModuleTree,\n-    module_id: ModuleId,\n+    module: &ModuleDescriptor,\n     mut crate_path: Vec<ast::NameRef>,\n-) -> Option<ModuleId> {\n+) -> Option<ModuleDescriptor> {\n     crate_path.pop();\n-    let mut target_module = module_id.root(&module_tree);\n+    let mut target_module = module.crate_root();\n     for name in crate_path {\n-        target_module = target_module.child(module_tree, name.text().as_str())?;\n+        target_module = target_module.child(name.text().as_str())?;\n     }\n     Some(target_module)\n }"}, {"sha": "8133b78753b5036e6df13175af2ec8fad986044a", "filename": "crates/ra_analysis/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/713c3ea30b38199e05e1f70094d85177f16915f8/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713c3ea30b38199e05e1f70094d85177f16915f8/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=713c3ea30b38199e05e1f70094d85177f16915f8", "patch": "@@ -85,10 +85,10 @@ salsa::database_storage! {\n         }\n         impl DescriptorDatabase {\n             fn module_tree() for ModuleTreeQuery;\n-            fn module_descriptor() for SubmodulesQuery;\n             fn module_scope() for ModuleScopeQuery;\n-            fn fn_syntax() for FnSyntaxQuery;\n             fn fn_scopes() for FnScopesQuery;\n+            fn _fn_syntax() for FnSyntaxQuery;\n+            fn _submodules() for SubmodulesQuery;\n         }\n     }\n }"}, {"sha": "e09deba0f3563f826f393e8d234e6d50422cb268", "filename": "crates/ra_analysis/src/descriptors/function/imp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/713c3ea30b38199e05e1f70094d85177f16915f8/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Ffunction%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713c3ea30b38199e05e1f70094d85177f16915f8/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Ffunction%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Ffunction%2Fimp.rs?ref=713c3ea30b38199e05e1f70094d85177f16915f8", "patch": "@@ -15,7 +15,7 @@ pub(crate) fn fn_syntax(db: &impl DescriptorDatabase, fn_id: FnId) -> FnDefNode\n }\n \n pub(crate) fn fn_scopes(db: &impl DescriptorDatabase, fn_id: FnId) -> Arc<FnScopes> {\n-    let syntax = db.fn_syntax(fn_id);\n+    let syntax = db._fn_syntax(fn_id);\n     let res = FnScopes::new(syntax.borrowed());\n     Arc::new(res)\n }"}, {"sha": "a8489f89c6a8d0be0c12f575cd1d980fb4e2b7ec", "filename": "crates/ra_analysis/src/descriptors/mod.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/713c3ea30b38199e05e1f70094d85177f16915f8/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713c3ea30b38199e05e1f70094d85177f16915f8/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs?ref=713c3ea30b38199e05e1f70094d85177f16915f8", "patch": "@@ -20,27 +20,28 @@ use crate::{\n \n salsa::query_group! {\n     pub(crate) trait DescriptorDatabase: SyntaxDatabase + IdDatabase {\n-        fn module_tree(source_root_id: SourceRootId) -> Cancelable<Arc<ModuleTree>> {\n+        fn fn_scopes(fn_id: FnId) -> Arc<FnScopes> {\n+            type FnScopesQuery;\n+            use fn function::imp::fn_scopes;\n+        }\n+\n+        fn _module_tree(source_root_id: SourceRootId) -> Cancelable<Arc<ModuleTree>> {\n             type ModuleTreeQuery;\n             use fn module::imp::module_tree;\n         }\n-        fn submodules(source: ModuleSource) -> Cancelable<Arc<Vec<module::imp::Submodule>>> {\n-            type SubmodulesQuery;\n-            use fn module::imp::submodules;\n-        }\n-        fn module_scope(source_root_id: SourceRootId, module_id: ModuleId) -> Cancelable<Arc<ModuleScope>> {\n+        fn _module_scope(source_root_id: SourceRootId, module_id: ModuleId) -> Cancelable<Arc<ModuleScope>> {\n             type ModuleScopeQuery;\n             use fn module::imp::module_scope;\n         }\n-        fn fn_syntax(fn_id: FnId) -> FnDefNode {\n+        fn _fn_syntax(fn_id: FnId) -> FnDefNode {\n             type FnSyntaxQuery;\n             // Don't retain syntax trees in memory\n             storage volatile;\n             use fn function::imp::fn_syntax;\n         }\n-        fn fn_scopes(fn_id: FnId) -> Arc<FnScopes> {\n-            type FnScopesQuery;\n-            use fn function::imp::fn_scopes;\n+        fn _submodules(source: ModuleSource) -> Cancelable<Arc<Vec<module::imp::Submodule>>> {\n+            type SubmodulesQuery;\n+            use fn module::imp::submodules;\n         }\n     }\n }"}, {"sha": "defe87216c8bba6ce590c4755953158a3fea1324", "filename": "crates/ra_analysis/src/descriptors/module/imp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/713c3ea30b38199e05e1f70094d85177f16915f8/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713c3ea30b38199e05e1f70094d85177f16915f8/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs?ref=713c3ea30b38199e05e1f70094d85177f16915f8", "patch": "@@ -86,7 +86,7 @@ pub(crate) fn module_scope(\n     source_root_id: SourceRootId,\n     module_id: ModuleId,\n ) -> Cancelable<Arc<ModuleScope>> {\n-    let tree = db.module_tree(source_root_id)?;\n+    let tree = db._module_tree(source_root_id)?;\n     let source = module_id.source(&tree).resolve(db);\n     let res = match source {\n         ModuleSourceNode::SourceFile(it) => ModuleScope::new(it.borrowed().items()),\n@@ -155,7 +155,7 @@ fn build_subtree(\n         parent,\n         children: Vec::new(),\n     });\n-    for sub in db.submodules(source)?.iter() {\n+    for sub in db._submodules(source)?.iter() {\n         let link = tree.push_link(LinkData {\n             name: sub.name().clone(),\n             owner: id,"}, {"sha": "047454cffe78388e6c57f2d287464cec7a296159", "filename": "crates/ra_analysis/src/descriptors/module/mod.rs", "status": "modified", "additions": 137, "deletions": 53, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/713c3ea30b38199e05e1f70094d85177f16915f8/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713c3ea30b38199e05e1f70094d85177f16915f8/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs?ref=713c3ea30b38199e05e1f70094d85177f16915f8", "patch": "@@ -1,16 +1,137 @@\n pub(super) mod imp;\n pub(crate) mod scope;\n \n+use std::sync::Arc;\n+\n+use ra_editor::find_node_at_offset;\n+\n use ra_syntax::{\n+    algo::generate,\n     ast::{self, AstNode, NameOwner},\n-    SmolStr, SyntaxNode, SyntaxNodeRef,\n+    SmolStr, SyntaxNode,\n };\n use relative_path::RelativePathBuf;\n \n-use crate::{db::SyntaxDatabase, syntax_ptr::SyntaxPtr, FileId};\n+use crate::{\n+    db::SyntaxDatabase, syntax_ptr::SyntaxPtr, FileId, FilePosition, Cancelable,\n+    descriptors::DescriptorDatabase,\n+    input::SourceRootId\n+};\n \n pub(crate) use self::scope::ModuleScope;\n \n+/// `ModuleDescriptor` is API entry point to get all the information\n+/// about a particular module.\n+#[derive(Debug, Clone)]\n+pub(crate) struct ModuleDescriptor {\n+    tree: Arc<ModuleTree>,\n+    source_root_id: SourceRootId,\n+    module_id: ModuleId,\n+}\n+\n+impl ModuleDescriptor {\n+    /// Lookup `ModuleDescriptor` by `FileId`. Note that this is inherently\n+    /// lossy transformation: in general, a single source might correspond to\n+    /// several modules.\n+    pub fn guess_from_file_id(\n+        db: &impl DescriptorDatabase,\n+        file_id: FileId,\n+    ) -> Cancelable<Option<ModuleDescriptor>> {\n+        ModuleDescriptor::guess_from_source(db, file_id, ModuleSource::SourceFile(file_id))\n+    }\n+\n+    /// Lookup `ModuleDescriptor` by position in the source code. Note that this\n+    /// is inherently lossy transformation: in general, a single source might\n+    /// correspond to several modules.\n+    pub fn guess_from_position(\n+        db: &impl DescriptorDatabase,\n+        position: FilePosition,\n+    ) -> Cancelable<Option<ModuleDescriptor>> {\n+        let file = db.file_syntax(position.file_id);\n+        let module_source = match find_node_at_offset::<ast::Module>(file.syntax(), position.offset)\n+        {\n+            Some(m) if !m.has_semi() => ModuleSource::new_inline(position.file_id, m),\n+            _ => ModuleSource::SourceFile(position.file_id),\n+        };\n+        ModuleDescriptor::guess_from_source(db, position.file_id, module_source)\n+    }\n+\n+    fn guess_from_source(\n+        db: &impl DescriptorDatabase,\n+        file_id: FileId,\n+        module_source: ModuleSource,\n+    ) -> Cancelable<Option<ModuleDescriptor>> {\n+        let source_root_id = db.file_source_root(file_id);\n+        let module_tree = db._module_tree(source_root_id)?;\n+\n+        let res = match module_tree.any_module_for_source(module_source) {\n+            None => None,\n+            Some(module_id) => Some(ModuleDescriptor {\n+                tree: module_tree,\n+                source_root_id,\n+                module_id,\n+            }),\n+        };\n+        Ok(res)\n+    }\n+\n+    /// Returns `mod foo;` or `mod foo {}` node whihc declared this module.\n+    /// Returns `None` for the root module\n+    pub fn parent_link_source(\n+        &self,\n+        db: &impl DescriptorDatabase,\n+    ) -> Option<(FileId, ast::ModuleNode)> {\n+        let link = self.module_id.parent_link(&self.tree)?;\n+        let file_id = link.owner(&self.tree).source(&self.tree).file_id();\n+        let src = link.bind_source(&self.tree, db);\n+        Some((file_id, src))\n+    }\n+\n+    pub fn source(&self) -> ModuleSource {\n+        self.module_id.source(&self.tree)\n+    }\n+\n+    /// Parent module. Returns `None` if this is a root module.\n+    pub fn parent(&self) -> Option<ModuleDescriptor> {\n+        let parent_id = self.module_id.parent(&self.tree)?;\n+        Some(ModuleDescriptor {\n+            module_id: parent_id,\n+            ..self.clone()\n+        })\n+    }\n+\n+    /// The root of the tree this module is part of\n+    pub fn crate_root(&self) -> ModuleDescriptor {\n+        generate(Some(self.clone()), |it| it.parent())\n+            .last()\n+            .unwrap()\n+    }\n+\n+    /// `name` is `None` for the crate's root module\n+    pub fn name(&self) -> Option<SmolStr> {\n+        let link = self.module_id.parent_link(&self.tree)?;\n+        Some(link.name(&self.tree))\n+    }\n+\n+    /// Finds a child module with the specified name.\n+    pub fn child(&self, name: &str) -> Option<ModuleDescriptor> {\n+        let child_id = self.module_id.child(&self.tree, name)?;\n+        Some(ModuleDescriptor {\n+            module_id: child_id,\n+            ..self.clone()\n+        })\n+    }\n+\n+    /// Returns a `ModuleScope`: a set of items, visible in this module.\n+    pub fn scope(&self, db: &impl DescriptorDatabase) -> Cancelable<Arc<ModuleScope>> {\n+        db._module_scope(self.source_root_id, self.module_id)\n+    }\n+\n+    pub fn problems(&self, db: &impl DescriptorDatabase) -> Vec<(SyntaxNode, Problem)> {\n+        self.module_id.problems(&self.tree, db)\n+    }\n+}\n+\n /// Phisically, rust source is organized as a set of files, but logically it is\n /// organized as a tree of modules. Usually, a single file corresponds to a\n /// single module, but it is not nessary the case.\n@@ -25,7 +146,7 @@ pub(crate) struct ModuleTree {\n }\n \n impl ModuleTree {\n-    pub(crate) fn modules_for_source(&self, source: ModuleSource) -> Vec<ModuleId> {\n+    fn modules_for_source(&self, source: ModuleSource) -> Vec<ModuleId> {\n         self.mods\n             .iter()\n             .enumerate()\n@@ -34,7 +155,7 @@ impl ModuleTree {\n             .collect()\n     }\n \n-    pub(crate) fn any_module_for_source(&self, source: ModuleSource) -> Option<ModuleId> {\n+    fn any_module_for_source(&self, source: ModuleSource) -> Option<ModuleId> {\n         self.modules_for_source(source).pop()\n     }\n }\n@@ -58,17 +179,8 @@ enum ModuleSourceNode {\n #[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, Debug)]\n pub(crate) struct ModuleId(u32);\n \n-impl crate::loc2id::NumericId for ModuleId {\n-    fn from_u32(id: u32) -> Self {\n-        ModuleId(id)\n-    }\n-    fn to_u32(self) -> u32 {\n-        self.0\n-    }\n-}\n-\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n-pub(crate) struct LinkId(u32);\n+struct LinkId(u32);\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n pub enum Problem {\n@@ -82,30 +194,17 @@ pub enum Problem {\n }\n \n impl ModuleId {\n-    pub(crate) fn source(self, tree: &ModuleTree) -> ModuleSource {\n+    fn source(self, tree: &ModuleTree) -> ModuleSource {\n         tree.module(self).source\n     }\n-    pub(crate) fn parent_link(self, tree: &ModuleTree) -> Option<LinkId> {\n+    fn parent_link(self, tree: &ModuleTree) -> Option<LinkId> {\n         tree.module(self).parent\n     }\n-    pub(crate) fn parent(self, tree: &ModuleTree) -> Option<ModuleId> {\n+    fn parent(self, tree: &ModuleTree) -> Option<ModuleId> {\n         let link = self.parent_link(tree)?;\n         Some(tree.link(link).owner)\n     }\n-    pub(crate) fn root(self, tree: &ModuleTree) -> ModuleId {\n-        let mut curr = self;\n-        let mut i = 0;\n-        while let Some(next) = curr.parent(tree) {\n-            curr = next;\n-            i += 1;\n-            // simplistic cycle detection\n-            if i > 100 {\n-                return self;\n-            }\n-        }\n-        curr\n-    }\n-    pub(crate) fn child(self, tree: &ModuleTree, name: &str) -> Option<ModuleId> {\n+    fn child(self, tree: &ModuleTree, name: &str) -> Option<ModuleId> {\n         let link = tree\n             .module(self)\n             .children\n@@ -114,11 +213,7 @@ impl ModuleId {\n             .find(|it| it.name == name)?;\n         Some(*link.points_to.first()?)\n     }\n-    pub(crate) fn problems(\n-        self,\n-        tree: &ModuleTree,\n-        db: &impl SyntaxDatabase,\n-    ) -> Vec<(SyntaxNode, Problem)> {\n+    fn problems(self, tree: &ModuleTree, db: &impl SyntaxDatabase) -> Vec<(SyntaxNode, Problem)> {\n         tree.module(self)\n             .children\n             .iter()\n@@ -133,14 +228,13 @@ impl ModuleId {\n }\n \n impl LinkId {\n-    pub(crate) fn owner(self, tree: &ModuleTree) -> ModuleId {\n+    fn owner(self, tree: &ModuleTree) -> ModuleId {\n         tree.link(self).owner\n     }\n-    pub(crate) fn bind_source<'a>(\n-        self,\n-        tree: &ModuleTree,\n-        db: &impl SyntaxDatabase,\n-    ) -> ast::ModuleNode {\n+    fn name(self, tree: &ModuleTree) -> SmolStr {\n+        tree.link(self).name.clone()\n+    }\n+    fn bind_source<'a>(self, tree: &ModuleTree, db: &impl SyntaxDatabase) -> ast::ModuleNode {\n         let owner = self.owner(tree);\n         match owner.source(tree).resolve(db) {\n             ModuleSourceNode::SourceFile(root) => {\n@@ -163,17 +257,7 @@ struct ModuleData {\n }\n \n impl ModuleSource {\n-    pub(crate) fn for_node(file_id: FileId, node: SyntaxNodeRef) -> ModuleSource {\n-        for node in node.ancestors() {\n-            if let Some(m) = ast::Module::cast(node) {\n-                if !m.has_semi() {\n-                    return ModuleSource::new_inline(file_id, m);\n-                }\n-            }\n-        }\n-        ModuleSource::SourceFile(file_id)\n-    }\n-    pub(crate) fn new_inline(file_id: FileId, module: ast::Module) -> ModuleSource {\n+    fn new_inline(file_id: FileId, module: ast::Module) -> ModuleSource {\n         assert!(!module.has_semi());\n         let ptr = SyntaxPtr::new(file_id, module.syntax());\n         ModuleSource::Module(ptr)"}, {"sha": "e1493bdaa09494aa5efbcf87560f2df99e28e7d9", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 50, "deletions": 86, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/713c3ea30b38199e05e1f70094d85177f16915f8/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713c3ea30b38199e05e1f70094d85177f16915f8/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=713c3ea30b38199e05e1f70094d85177f16915f8", "patch": "@@ -21,7 +21,7 @@ use crate::{\n     db::{self, FileSyntaxQuery, SyntaxDatabase},\n     descriptors::{\n         function::{FnDescriptor, FnId},\n-        module::{ModuleSource, ModuleTree, Problem},\n+        module::{ModuleDescriptor, Problem},\n         DeclarationDescriptor, DescriptorDatabase,\n     },\n     input::{FilesDatabase, SourceRoot, SourceRootId, WORKSPACE},\n@@ -216,52 +216,41 @@ impl AnalysisImpl {\n             .sweep(salsa::SweepStrategy::default().discard_values());\n         Ok(query.search(&buf))\n     }\n-    fn module_tree(&self, file_id: FileId) -> Cancelable<Arc<ModuleTree>> {\n-        let source_root = self.db.file_source_root(file_id);\n-        self.db.module_tree(source_root)\n-    }\n+    /// This return `Vec`: a module may be included from several places. We\n+    /// don't handle this case yet though, so the Vec has length at most one.\n     pub fn parent_module(&self, position: FilePosition) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n-        let module_tree = self.module_tree(position.file_id)?;\n-        let file = self.db.file_syntax(position.file_id);\n-        let module_source = match find_node_at_offset::<ast::Module>(file.syntax(), position.offset)\n-        {\n-            Some(m) if !m.has_semi() => ModuleSource::new_inline(position.file_id, m),\n-            _ => ModuleSource::SourceFile(position.file_id),\n+        let descr = match ModuleDescriptor::guess_from_position(&*self.db, position)? {\n+            None => return Ok(Vec::new()),\n+            Some(it) => it,\n         };\n-\n-        let res = module_tree\n-            .modules_for_source(module_source)\n-            .into_iter()\n-            .filter_map(|module_id| {\n-                let link = module_id.parent_link(&module_tree)?;\n-                let file_id = link.owner(&module_tree).source(&module_tree).file_id();\n-                let decl = link.bind_source(&module_tree, &*self.db);\n-                let decl = decl.borrowed();\n-\n-                let decl_name = decl.name().unwrap();\n-\n-                let sym = FileSymbol {\n-                    name: decl_name.text(),\n-                    node_range: decl_name.syntax().range(),\n-                    kind: MODULE,\n-                };\n-                Some((file_id, sym))\n-            })\n-            .collect();\n-        Ok(res)\n+        let (file_id, decl) = match descr.parent_link_source(&*self.db) {\n+            None => return Ok(Vec::new()),\n+            Some(it) => it,\n+        };\n+        let decl = decl.borrowed();\n+        let decl_name = decl.name().unwrap();\n+        let sym = FileSymbol {\n+            name: decl_name.text(),\n+            node_range: decl_name.syntax().range(),\n+            kind: MODULE,\n+        };\n+        Ok(vec![(file_id, sym)])\n     }\n+    /// Returns `Vec` for the same reason as `parent_module`\n     pub fn crate_for(&self, file_id: FileId) -> Cancelable<Vec<CrateId>> {\n-        let module_tree = self.module_tree(file_id)?;\n-        let crate_graph = self.db.crate_graph();\n-        let res = module_tree\n-            .modules_for_source(ModuleSource::SourceFile(file_id))\n-            .into_iter()\n-            .map(|it| it.root(&module_tree))\n-            .filter_map(|it| it.source(&module_tree).as_file())\n-            .filter_map(|it| crate_graph.crate_id_for_crate_root(it))\n-            .collect();\n+        let descr = match ModuleDescriptor::guess_from_file_id(&*self.db, file_id)? {\n+            None => return Ok(Vec::new()),\n+            Some(it) => it,\n+        };\n+        let root = descr.crate_root();\n+        let file_id = root\n+            .source()\n+            .as_file()\n+            .expect(\"root module always has a file as a source\");\n \n-        Ok(res)\n+        let crate_graph = self.db.crate_graph();\n+        let crate_id = crate_graph.crate_id_for_crate_root(file_id);\n+        Ok(crate_id.into_iter().collect())\n     }\n     pub fn crate_root(&self, crate_id: CrateId) -> FileId {\n         self.db.crate_graph().crate_roots[&crate_id]\n@@ -273,7 +262,6 @@ impl AnalysisImpl {\n         &self,\n         position: FilePosition,\n     ) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n-        let module_tree = self.module_tree(position.file_id)?;\n         let file = self.db.file_syntax(position.file_id);\n         let syntax = file.syntax();\n         if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, position.offset) {\n@@ -299,25 +287,23 @@ impl AnalysisImpl {\n         if let Some(name) = find_node_at_offset::<ast::Name>(syntax, position.offset) {\n             if let Some(module) = name.syntax().parent().and_then(ast::Module::cast) {\n                 if module.has_semi() {\n-                    let file_ids = self.resolve_module(&*module_tree, position.file_id, module);\n-\n-                    let res = file_ids\n-                        .into_iter()\n-                        .map(|id| {\n-                            let name = module\n-                                .name()\n-                                .map(|n| n.text())\n-                                .unwrap_or_else(|| SmolStr::new(\"\"));\n-                            let symbol = FileSymbol {\n-                                name,\n-                                node_range: TextRange::offset_len(0.into(), 0.into()),\n-                                kind: MODULE,\n-                            };\n-                            (id, symbol)\n-                        })\n-                        .collect();\n-\n-                    return Ok(res);\n+                    let parent_module =\n+                        ModuleDescriptor::guess_from_file_id(&*self.db, position.file_id)?;\n+                    let child_name = module.name();\n+                    match (parent_module, child_name) {\n+                        (Some(parent_module), Some(child_name)) => {\n+                            if let Some(child) = parent_module.child(&child_name.text()) {\n+                                let file_id = child.source().file_id();\n+                                let symbol = FileSymbol {\n+                                    name: child_name.text(),\n+                                    node_range: TextRange::offset_len(0.into(), 0.into()),\n+                                    kind: MODULE,\n+                                };\n+                                return Ok(vec![(file_id, symbol)]);\n+                            }\n+                        }\n+                        _ => (),\n+                    }\n                 }\n             }\n         }\n@@ -364,7 +350,6 @@ impl AnalysisImpl {\n     }\n \n     pub fn diagnostics(&self, file_id: FileId) -> Cancelable<Vec<Diagnostic>> {\n-        let module_tree = self.module_tree(file_id)?;\n         let syntax = self.db.file_syntax(file_id);\n \n         let mut res = ra_editor::diagnostics(&syntax)\n@@ -375,8 +360,8 @@ impl AnalysisImpl {\n                 fix: None,\n             })\n             .collect::<Vec<_>>();\n-        if let Some(m) = module_tree.any_module_for_source(ModuleSource::SourceFile(file_id)) {\n-            for (name_node, problem) in m.problems(&module_tree, &*self.db) {\n+        if let Some(m) = ModuleDescriptor::guess_from_file_id(&*self.db, file_id)? {\n+            for (name_node, problem) in m.problems(&*self.db) {\n                 let diag = match problem {\n                     Problem::UnresolvedModule { candidate } => {\n                         let create_file = FileSystemEdit::CreateFile {\n@@ -526,27 +511,6 @@ impl AnalysisImpl {\n         query.limit(4);\n         self.world_symbols(query)\n     }\n-\n-    fn resolve_module(\n-        &self,\n-        module_tree: &ModuleTree,\n-        file_id: FileId,\n-        module: ast::Module,\n-    ) -> Vec<FileId> {\n-        let name = match module.name() {\n-            Some(name) => name.text(),\n-            None => return Vec::new(),\n-        };\n-        let module_id = match module_tree.any_module_for_source(ModuleSource::SourceFile(file_id)) {\n-            Some(id) => id,\n-            None => return Vec::new(),\n-        };\n-        module_id\n-            .child(module_tree, name.as_str())\n-            .and_then(|it| it.source(&module_tree).as_file())\n-            .into_iter()\n-            .collect()\n-    }\n }\n \n impl SourceChange {"}, {"sha": "8c297156a6f2ca8c456517245f16a5767950038c", "filename": "crates/ra_analysis/src/loc2id.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/713c3ea30b38199e05e1f70094d85177f16915f8/crates%2Fra_analysis%2Fsrc%2Floc2id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713c3ea30b38199e05e1f70094d85177f16915f8/crates%2Fra_analysis%2Fsrc%2Floc2id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Floc2id.rs?ref=713c3ea30b38199e05e1f70094d85177f16915f8", "patch": "@@ -72,17 +72,22 @@ pub(crate) trait NumericId: Clone + Eq + Hash {\n     fn to_u32(self) -> u32;\n }\n \n+macro_rules! impl_numeric_id {\n+    ($id:ident) => {\n+        impl NumericId for $id {\n+            fn from_u32(id: u32) -> Self {\n+                $id(id)\n+            }\n+            fn to_u32(self) -> u32 {\n+                self.0\n+            }\n+        }\n+    };\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub(crate) struct FnId(u32);\n-\n-impl NumericId for FnId {\n-    fn from_u32(id: u32) -> FnId {\n-        FnId(id)\n-    }\n-    fn to_u32(self) -> u32 {\n-        self.0\n-    }\n-}\n+impl_numeric_id!(FnId);\n \n pub(crate) trait IdDatabase: salsa::Database {\n     fn id_maps(&self) -> &IdMaps;"}]}