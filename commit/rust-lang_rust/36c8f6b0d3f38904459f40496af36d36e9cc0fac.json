{"sha": "36c8f6b0d3f38904459f40496af36d36e9cc0fac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2YzhmNmIwZDNmMzg5MDQ0NTlmNDA0OTZhZjM2ZDM2ZTljYzBmYWM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-17T14:04:20Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-21T09:00:56Z"}, "message": "Cleanup `InternedString`.", "tree": {"sha": "6a5efd739f6537c308d3340b6e5495ceca17413f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a5efd739f6537c308d3340b6e5495ceca17413f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36c8f6b0d3f38904459f40496af36d36e9cc0fac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36c8f6b0d3f38904459f40496af36d36e9cc0fac", "html_url": "https://github.com/rust-lang/rust/commit/36c8f6b0d3f38904459f40496af36d36e9cc0fac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36c8f6b0d3f38904459f40496af36d36e9cc0fac/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e85a0d70b86491752eb501f73b9d2025c5991e8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e85a0d70b86491752eb501f73b9d2025c5991e8e", "html_url": "https://github.com/rust-lang/rust/commit/e85a0d70b86491752eb501f73b9d2025c5991e8e"}], "stats": {"total": 191, "additions": 63, "deletions": 128}, "files": [{"sha": "83d3627d8e61643e4b3b4f88ea56d40ef1fe0f8f", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 13, "deletions": 32, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -343,7 +343,7 @@ impl DefPathData {\n \n     pub fn as_interned_str(&self) -> InternedString {\n         use self::DefPathData::*;\n-        match *self {\n+        let s = match *self {\n             TypeNs(ref name) |\n             ValueNs(ref name) |\n             Module(ref name) |\n@@ -353,43 +353,24 @@ impl DefPathData {\n             EnumVariant(ref name) |\n             Binding(ref name) |\n             Field(ref name) => {\n-                name.clone()\n-            }\n-\n-            Impl => {\n-                InternedString::new(\"{{impl}}\")\n+                return name.clone();\n             }\n \n             // note that this does not show up in user printouts\n-            CrateRoot => {\n-                InternedString::new(\"{{root}}\")\n-            }\n+            CrateRoot => \"{{root}}\",\n \n             // note that this does not show up in user printouts\n-            InlinedRoot(_) => {\n-                InternedString::new(\"{{inlined-root}}\")\n-            }\n-\n-            Misc => {\n-                InternedString::new(\"{{?}}\")\n-            }\n-\n-            ClosureExpr => {\n-                InternedString::new(\"{{closure}}\")\n-            }\n-\n-            StructCtor => {\n-                InternedString::new(\"{{constructor}}\")\n-            }\n-\n-            Initializer => {\n-                InternedString::new(\"{{initializer}}\")\n-            }\n+            InlinedRoot(_) => \"{{inlined-root}}\",\n+\n+            Impl => \"{{impl}}\",\n+            Misc => \"{{?}}\",\n+            ClosureExpr => \"{{closure}}\",\n+            StructCtor => \"{{constructor}}\",\n+            Initializer => \"{{initializer}}\",\n+            ImplTrait => \"{{impl-Trait}}\",\n+        };\n \n-            ImplTrait => {\n-                InternedString::new(\"{{impl-Trait}}\")\n-            }\n-        }\n+        Symbol::intern(s).as_str()\n     }\n \n     pub fn to_string(&self) -> String {"}, {"sha": "a90577b34261c4e7c8338052aac83f4823511dda", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -765,7 +765,7 @@ impl<'a, 'ast> NodesMatchingSuffix<'a, 'ast> {\n                 None => return false,\n                 Some((node_id, name)) => (node_id, name),\n             };\n-            if &part[..] != mod_name.as_str() {\n+            if mod_name != &**part {\n                 return false;\n             }\n             cursor = self.map.get_parent(mod_id);\n@@ -803,8 +803,7 @@ impl<'a, 'ast> NodesMatchingSuffix<'a, 'ast> {\n     // We are looking at some node `n` with a given name and parent\n     // id; do their names match what I am seeking?\n     fn matches_names(&self, parent_of_n: NodeId, name: Name) -> bool {\n-        name.as_str() == &self.item_name[..] &&\n-            self.suffix_matches(parent_of_n)\n+        name == &**self.item_name && self.suffix_matches(parent_of_n)\n     }\n }\n "}, {"sha": "f47eab013c2b216a4789e40e54d1031c10132340", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -498,8 +498,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n                       span: syntax_pos::Span,\n                       name: ast::Name,\n                       node_type: &str) {\n-        let name = name.as_str();\n-        if !name.starts_with(\"_\") {\n+        if !name.as_str().starts_with(\"_\") {\n             self.tcx\n                 .sess\n                 .add_lint(lint::builtin::DEAD_CODE,"}, {"sha": "65aedae347a8d0cd4538f6d824f1c7d495448e35", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -92,7 +92,7 @@ fn entry_point_type(item: &Item, at_root: bool) -> EntryPointType {\n                 EntryPointType::Start\n             } else if attr::contains_name(&item.attrs, \"main\") {\n                 EntryPointType::MainAttr\n-            } else if item.name.as_str() == \"main\" {\n+            } else if item.name == \"main\" {\n                 if at_root {\n                     // This is a top-level function so can be 'main'\n                     EntryPointType::MainNamed"}, {"sha": "80cf64865abea7043ded3f20e2c5575c52a85d49", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n             ty::TyFnDef(.., ref bfty) => bfty.abi == RustIntrinsic,\n             _ => return false\n         };\n-        intrinsic && self.infcx.tcx.item_name(def_id).as_str() == \"transmute\"\n+        intrinsic && self.infcx.tcx.item_name(def_id) == \"transmute\"\n     }\n \n     fn check_transmute(&self, span: Span, from: Ty<'gcx>, to: Ty<'gcx>, id: ast::NodeId) {"}, {"sha": "86a89eff3a476a9cd5c54a8432250738ba642a2d", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -455,7 +455,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         // When compiling with --test we don't enforce stability on the\n         // compiler-generated test module, demarcated with `DUMMY_SP` plus the\n         // name `__test`\n-        if item.span == DUMMY_SP && item.name.as_str() == \"__test\" { return }\n+        if item.span == DUMMY_SP && item.name == \"__test\" { return }\n \n         check_item(self.tcx, item, true,\n                    &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));"}, {"sha": "916d17dcc91deff5b598dd9d7f5f7dab7a3c915b", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -169,7 +169,7 @@ fn is_rustc_peek<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 {\n                     let name = tcx.item_name(def_id);\n                     if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n-                        if name.as_str() == \"rustc_peek\" {\n+                        if name == \"rustc_peek\" {\n                             return Some((args, source_info.span));\n                         }\n                     }"}, {"sha": "4440cb41dc5f20051a8a4c883d4d41a1185f6bfc", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -81,19 +81,12 @@ impl NonCamelCaseTypes {\n                 .concat()\n         }\n \n-        let s = name.as_str();\n-\n         if !is_camel_case(name) {\n-            let c = to_camel_case(&s);\n+            let c = to_camel_case(&name.as_str());\n             let m = if c.is_empty() {\n-                format!(\"{} `{}` should have a camel case name such as `CamelCase`\",\n-                        sort,\n-                        s)\n+                format!(\"{} `{}` should have a camel case name such as `CamelCase`\", sort, name)\n             } else {\n-                format!(\"{} `{}` should have a camel case name such as `{}`\",\n-                        sort,\n-                        s,\n-                        c)\n+                format!(\"{} `{}` should have a camel case name such as `{}`\", sort, name, c)\n             };\n             cx.span_lint(NON_CAMEL_CASE_TYPES, span, &m[..]);\n         }\n@@ -326,21 +319,19 @@ pub struct NonUpperCaseGlobals;\n \n impl NonUpperCaseGlobals {\n     fn check_upper_case(cx: &LateContext, sort: &str, name: ast::Name, span: Span) {\n-        let s = name.as_str();\n-\n-        if s.chars().any(|c| c.is_lowercase()) {\n-            let uc = NonSnakeCase::to_snake_case(&s).to_uppercase();\n-            if uc != &s[..] {\n+        if name.as_str().chars().any(|c| c.is_lowercase()) {\n+            let uc = NonSnakeCase::to_snake_case(&name.as_str()).to_uppercase();\n+            if name != &*uc {\n                 cx.span_lint(NON_UPPER_CASE_GLOBALS,\n                              span,\n                              &format!(\"{} `{}` should have an upper case name such as `{}`\",\n                                       sort,\n-                                      s,\n+                                      name,\n                                       uc));\n             } else {\n                 cx.span_lint(NON_UPPER_CASE_GLOBALS,\n                              span,\n-                             &format!(\"{} `{}` should have an upper case name\", sort, s));\n+                             &format!(\"{} `{}` should have an upper case name\", sort, name));\n             }\n         }\n     }"}, {"sha": "0b2ae58852300806d9ec81392a42a0d183c27d53", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -1229,7 +1229,7 @@ impl LateLintPass for MutableTransmutes {\n                 ty::TyFnDef(.., ref bfty) if bfty.abi == RustIntrinsic => (),\n                 _ => return false,\n             }\n-            cx.tcx.item_name(def_id).as_str() == \"transmute\"\n+            cx.tcx.item_name(def_id) == \"transmute\"\n         }\n     }\n }"}, {"sha": "89c3efaafcdcc912af23a799d47c09b756b6eff9", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -40,7 +40,7 @@ impl<'a> AstValidator<'a> {\n         if label.name == keywords::StaticLifetime.name() {\n             self.err_handler().span_err(span, &format!(\"invalid label name `{}`\", label.name));\n         }\n-        if label.name.as_str() == \"'_\" {\n+        if label.name == \"'_\" {\n             self.session.add_lint(lint::builtin::LIFETIME_UNDERSCORE,\n                                   id,\n                                   span,\n@@ -90,7 +90,7 @@ impl<'a> AstValidator<'a> {\n \n impl<'a> Visitor for AstValidator<'a> {\n     fn visit_lifetime(&mut self, lt: &Lifetime) {\n-        if lt.name.as_str() == \"'_\" {\n+        if lt.name == \"'_\" {\n             self.session.add_lint(lint::builtin::LIFETIME_UNDERSCORE,\n                                   lt.id,\n                                   lt.span,"}, {"sha": "fe2f9713d1beb29ae0cafd35af921d9fb1711572", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -101,7 +101,7 @@ impl<'a> Registry<'a> {\n     ///\n     /// This is the most general hook into `libsyntax`'s expansion behavior.\n     pub fn register_syntax_extension(&mut self, name: ast::Name, extension: SyntaxExtension) {\n-        if name.as_str() == \"macro_rules\" {\n+        if name == \"macro_rules\" {\n             panic!(\"user-defined macros may not be named `macro_rules`\");\n         }\n         self.syntax_exts.push((name, match extension {"}, {"sha": "e988cacdce809474e4afa8d4c57773bddaa511d8", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -138,7 +138,7 @@ impl<'b> Resolver<'b> {\n                 match view_path.node {\n                     ViewPathSimple(binding, ref full_path) => {\n                         let mut source = full_path.segments.last().unwrap().identifier;\n-                        let source_name = source.name.as_str();\n+                        let source_name = source.name;\n                         if source_name == \"mod\" || source_name == \"self\" {\n                             resolve_error(self,\n                                           view_path.span,"}, {"sha": "26df986825b8452431973c911100c7cef516e854", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -1462,7 +1462,6 @@ impl<'a> Resolver<'a> {\n             let name = module_path[index].name;\n             match self.resolve_name_in_module(search_module, name, TypeNS, false, false, span) {\n                 Failed(_) => {\n-                    let segment_name = name.as_str();\n                     let module_name = module_to_string(search_module);\n                     let msg = if \"???\" == &module_name {\n                         let current_module = self.current_module;\n@@ -1480,10 +1479,10 @@ impl<'a> Resolver<'a> {\n \n                                 format!(\"Did you mean `{}{}`?\", prefix, path_str)\n                             }\n-                            None => format!(\"Maybe a missing `extern crate {};`?\", segment_name),\n+                            None => format!(\"Maybe a missing `extern crate {};`?\", name),\n                         }\n                     } else {\n-                        format!(\"Could not find `{}` in `{}`\", segment_name, module_name)\n+                        format!(\"Could not find `{}` in `{}`\", name, module_name)\n                     };\n \n                     return Failed(span.map(|span| (span, msg)));\n@@ -1651,7 +1650,7 @@ impl<'a> Resolver<'a> {\n     /// grammar: (SELF MOD_SEP ) ? (SUPER MOD_SEP) *\n     fn resolve_module_prefix(&mut self, module_path: &[Ident], span: Option<Span>)\n                              -> ResolveResult<ModulePrefixResult<'a>> {\n-        if &*module_path[0].name.as_str() == \"$crate\" {\n+        if module_path[0].name == \"$crate\" {\n             return Success(PrefixFound(self.resolve_crate_var(module_path[0].ctxt), 1));\n         }\n \n@@ -1667,7 +1666,7 @@ impl<'a> Resolver<'a> {\n             self.module_map[&self.current_module.normal_ancestor_id.unwrap()];\n \n         // Now loop through all the `super`s we find.\n-        while i < module_path.len() && \"super\" == module_path[i].name.as_str() {\n+        while i < module_path.len() && module_path[i].name == \"super\" {\n             debug!(\"(resolving module prefix) resolving `super` at {}\",\n                    module_to_string(&containing_module));\n             if let Some(parent) = containing_module.parent {\n@@ -2635,7 +2634,7 @@ impl<'a> Resolver<'a> {\n         let qualified_binding = self.resolve_module_relative_path(span, segments, namespace);\n         match (qualified_binding, unqualified_def) {\n             (Ok(binding), Some(ref ud)) if binding.def() == ud.def &&\n-                                           segments[0].identifier.name.as_str() != \"$crate\" => {\n+                                           segments[0].identifier.name != \"$crate\" => {\n                 self.session\n                     .add_lint(lint::builtin::UNUSED_QUALIFICATIONS,\n                               id,\n@@ -2881,7 +2880,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn find_best_match(&mut self, name: &str) -> SuggestionType {\n-        if let Some(macro_name) = self.macro_names.iter().find(|n| n.as_str() == name) {\n+        if let Some(macro_name) = self.macro_names.iter().find(|&n| n == &name) {\n             return SuggestionType::Macro(format!(\"{}!\", macro_name));\n         }\n \n@@ -3000,8 +2999,7 @@ impl<'a> Resolver<'a> {\n                                 false // Stop advancing\n                             });\n \n-                            if method_scope &&\n-                                    &path_name[..] == keywords::SelfValue.name().as_str() {\n+                            if method_scope && keywords::SelfValue.name() == &*path_name {\n                                 resolve_error(self,\n                                               expr.span,\n                                               ResolutionError::SelfNotAvailableInStaticMethod);"}, {"sha": "b2cc6306db9e7b4c4cbb4cd7ac798a26a0a0c5a7", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -115,7 +115,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         impl<'a, 'b> Folder for EliminateCrateVar<'a, 'b> {\n             fn fold_path(&mut self, mut path: ast::Path) -> ast::Path {\n                 let ident = path.segments[0].identifier;\n-                if &ident.name.as_str() == \"$crate\" {\n+                if ident.name == \"$crate\" {\n                     path.global = true;\n                     let module = self.0.resolve_crate_var(ident.ctxt);\n                     if module.is_local() {\n@@ -151,7 +151,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn add_macro(&mut self, scope: Mark, mut def: ast::MacroDef, export: bool) {\n-        if &def.ident.name.as_str() == \"macro_rules\" {\n+        if def.ident.name == \"macro_rules\" {\n             self.session.span_err(def.span, \"user-defined macros may not be named `macro_rules`\");\n         }\n "}, {"sha": "5c7b004375ed4b778aacf20c16d945633d061b8a", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -663,7 +663,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                                                 -> bool {\n             (bare_fn_ty.abi == Abi::RustIntrinsic ||\n              bare_fn_ty.abi == Abi::PlatformIntrinsic) &&\n-            tcx.item_name(def_id).as_str() == \"drop_in_place\"\n+            tcx.item_name(def_id) == \"drop_in_place\"\n         }\n     }\n }"}, {"sha": "016a76a72531b4c783292281927e621e605029c4", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -107,7 +107,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let sig = tcx.erase_late_bound_regions_and_normalize(&fty.sig);\n     let arg_tys = sig.inputs;\n     let ret_ty = sig.output;\n-    let name = tcx.item_name(def_id).as_str();\n+    let name = &*tcx.item_name(def_id).as_str();\n \n     let span = match call_debug_location {\n         DebugLoc::ScopeAt(_, span) => span,\n@@ -123,15 +123,15 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         Call(bcx, llfn, &[], call_debug_location);\n         Unreachable(bcx);\n         return Result::new(bcx, C_undef(Type::nil(ccx).ptr_to()));\n-    } else if &name[..] == \"unreachable\" {\n+    } else if name == \"unreachable\" {\n         Unreachable(bcx);\n         return Result::new(bcx, C_nil(ccx));\n     }\n \n     let llret_ty = type_of::type_of(ccx, ret_ty);\n \n-    let simple = get_simple_intrinsic(ccx, &name);\n-    let llval = match (simple, &name[..]) {\n+    let simple = get_simple_intrinsic(ccx, name);\n+    let llval = match (simple, name) {\n         (Some(llfn), _) => {\n             Call(bcx, llfn, &llargs, call_debug_location)\n         }\n@@ -340,7 +340,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             let sty = &arg_tys[0].sty;\n             match int_type_width_signed(sty, ccx) {\n                 Some((width, signed)) =>\n-                    match &*name {\n+                    match name {\n                         \"ctlz\" => count_zeros_intrinsic(bcx, &format!(\"llvm.ctlz.i{}\", width),\n                                                         llargs[0], call_debug_location),\n                         \"cttz\" => count_zeros_intrinsic(bcx, &format!(\"llvm.cttz.i{}\", width),\n@@ -394,7 +394,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             let sty = &arg_tys[0].sty;\n             match float_type_width(sty) {\n                 Some(_width) =>\n-                    match &*name {\n+                    match name {\n                         \"fadd_fast\" => FAddFast(bcx, llargs[0], llargs[1], call_debug_location),\n                         \"fsub_fast\" => FSubFast(bcx, llargs[0], llargs[1], call_debug_location),\n                         \"fmul_fast\" => FMulFast(bcx, llargs[0], llargs[1], call_debug_location),"}, {"sha": "a36960993e47148a13d4d2aefabda75038cd61ae", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -320,7 +320,7 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n \n             let codegen_unit_name = match characteristic_def_id {\n                 Some(def_id) => compute_codegen_unit_name(tcx, def_id, is_volatile),\n-                None => InternedString::new(FALLBACK_CODEGEN_UNIT),\n+                None => Symbol::intern(FALLBACK_CODEGEN_UNIT).as_str(),\n             };\n \n             let make_codegen_unit = || {\n@@ -365,7 +365,7 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     // always ensure we have at least one CGU; otherwise, if we have a\n     // crate with just types (for example), we could wind up with no CGU\n     if codegen_units.is_empty() {\n-        let codegen_unit_name = InternedString::new(FALLBACK_CODEGEN_UNIT);\n+        let codegen_unit_name = Symbol::intern(FALLBACK_CODEGEN_UNIT).as_str();\n         codegen_units.entry(codegen_unit_name.clone())\n                      .or_insert_with(|| CodegenUnit::empty(codegen_unit_name.clone()));\n     }"}, {"sha": "c5db8bc8cedc769d152913c6f8edc05d4348dbb5", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -1252,7 +1252,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         if bounds.len() > 1 {\n             let spans = bounds.iter().map(|b| {\n                 self.tcx().associated_items(b.def_id()).find(|item| {\n-                    item.kind == ty::AssociatedKind::Type && item.name.as_str() == assoc_name\n+                    item.kind == ty::AssociatedKind::Type && item.name == assoc_name\n                 })\n                 .and_then(|item| self.tcx().map.as_local_node_id(item.def_id))\n                 .and_then(|node_id| self.tcx().map.opt_span(node_id))"}, {"sha": "bd34e993e1e86a984a65e413a19e57a2a8d6b6e6", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -342,7 +342,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let def = pick.item.def();\n         if let probe::InherentImplPick = pick.kind {\n             if !pick.item.vis.is_accessible_from(self.body_id, &self.tcx.map) {\n-                let msg = format!(\"{} `{}` is private\", def.kind_name(), &method_name.as_str());\n+                let msg = format!(\"{} `{}` is private\", def.kind_name(), method_name);\n                 self.tcx.sess.span_err(span, &msg);\n             }\n         }"}, {"sha": "d0ebd6124f0964207e161d834ef42da23576c870", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -943,7 +943,7 @@ fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         Position::ArgumentNamed(s) if s == \"Self\" => (),\n                         // So is `{A}` if A is a type parameter\n                         Position::ArgumentNamed(s) => match types.iter().find(|t| {\n-                            t.name.as_str() == s\n+                            t.name == s\n                         }) {\n                             Some(_) => (),\n                             None => {\n@@ -3127,7 +3127,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 ty::TyAdt(adt, ..) if adt.is_enum() => {\n                     struct_span_err!(self.tcx.sess, field.name.span, E0559,\n                                     \"{} `{}::{}` has no field named `{}`\",\n-                                    kind_name, actual, variant.name.as_str(), field.name.node)\n+                                    kind_name, actual, variant.name, field.name.node)\n                 }\n                 _ => {\n                     struct_span_err!(self.tcx.sess, field.name.span, E0560,\n@@ -3147,7 +3147,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             match ty.sty {\n                 ty::TyAdt(adt, ..) if adt.is_enum() => {\n                     err.span_label(field.name.span, &format!(\"`{}::{}` does not have this field\",\n-                                                             ty, variant.name.as_str()));\n+                                                             ty, variant.name));\n                 }\n                 _ => {\n                     err.span_label(field.name.span, &format!(\"`{}` does not have this field\", ty));"}, {"sha": "bb07efdd9e7231d161d085968b02dbf38e1c199b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -373,7 +373,7 @@ impl Generics {\n     }\n     pub fn span_for_name(&self, name: &str) -> Option<Span> {\n         for t in &self.ty_params {\n-            if t.ident.name.as_str() == name {\n+            if t.ident.name == name {\n                 return Some(t.span);\n             }\n         }"}, {"sha": "93ca1948ed84b878b2e2b57b627b133d5129abeb", "filename": "src/libsyntax/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibsyntax%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibsyntax%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fentry.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -28,7 +28,7 @@ pub fn entry_point_type(item: &Item, depth: usize) -> EntryPointType {\n                 EntryPointType::Start\n             } else if attr::contains_name(&item.attrs, \"main\") {\n                 EntryPointType::MainAttr\n-            } else if item.ident.name.as_str() == \"main\" {\n+            } else if item.ident.name == \"main\" {\n                 if depth == 1 {\n                     // This is a top-level function so can be 'main'\n                     EntryPointType::MainNamed"}, {"sha": "ddf4cf11f204810ff6340d48f8c30c17235b87af", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -643,7 +643,7 @@ impl<'a> ExtCtxt<'a> {\n         loop {\n             if self.codemap().with_expn_info(expn_id, |info| {\n                 info.map_or(None, |i| {\n-                    if i.callee.name().as_str() == \"include\" {\n+                    if i.callee.name() == \"include\" {\n                         // Stop going up the backtrace once include! is encountered\n                         return None;\n                     }"}, {"sha": "59b8b50e88cb61b6b139ff9632d24049b143772b", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -791,17 +791,16 @@ fn is_in_follow(tok: &Token, frag: &str) -> Result<bool, (String, &'static str)>\n             \"pat\" => {\n                 match *tok {\n                     FatArrow | Comma | Eq | BinOp(token::Or) => Ok(true),\n-                    Ident(i) if (i.name.as_str() == \"if\" ||\n-                                 i.name.as_str() == \"in\") => Ok(true),\n+                    Ident(i) if i.name == \"if\" || i.name == \"in\" => Ok(true),\n                     _ => Ok(false)\n                 }\n             },\n             \"path\" | \"ty\" => {\n                 match *tok {\n                     OpenDelim(token::DelimToken::Brace) | OpenDelim(token::DelimToken::Bracket) |\n                     Comma | FatArrow | Colon | Eq | Gt | Semi | BinOp(token::Or) => Ok(true),\n-                    MatchNt(_, ref frag) if frag.name.as_str() == \"block\" => Ok(true),\n-                    Ident(i) if i.name.as_str() == \"as\" || i.name.as_str() == \"where\" => Ok(true),\n+                    MatchNt(_, ref frag) if frag.name == \"block\" => Ok(true),\n+                    Ident(i) if i.name == \"as\" || i.name == \"where\" => Ok(true),\n                     _ => Ok(false)\n                 }\n             },"}, {"sha": "4997e464c2bf533987d9c6ca86cb81431835279a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -2535,7 +2535,7 @@ impl<'a> Parser<'a> {\n                     let prev_span = self.prev_span;\n                     let fstr = n.as_str();\n                     let mut err = self.diagnostic().struct_span_err(prev_span,\n-                        &format!(\"unexpected token: `{}`\", n.as_str()));\n+                        &format!(\"unexpected token: `{}`\", n));\n                     if fstr.chars().all(|x| \"0123456789.\".contains(x)) {\n                         let float = match fstr.parse::<f64>().ok() {\n                             Some(f) => f,"}, {"sha": "f7217b9535fe67a365eaefc30998dc09651a45a5", "filename": "src/libsyntax/symbol.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibsyntax%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c8f6b0d3f38904459f40496af36d36e9cc0fac/src%2Flibsyntax%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsymbol.rs?ref=36c8f6b0d3f38904459f40496af36d36e9cc0fac", "patch": "@@ -244,14 +244,6 @@ pub struct InternedString {\n     string: Rc<str>,\n }\n \n-impl InternedString {\n-    pub fn new(string: &'static str) -> InternedString {\n-        InternedString {\n-            string: Rc::__from_str(string),\n-        }\n-    }\n-}\n-\n impl ::std::ops::Deref for InternedString {\n     type Target = str;\n     fn deref(&self) -> &str { &self.string }\n@@ -269,30 +261,6 @@ impl fmt::Display for InternedString {\n     }\n }\n \n-impl<'a> PartialEq<&'a str> for InternedString {\n-    fn eq(&self, other: & &'a str) -> bool {\n-        PartialEq::eq(&self.string[..], *other)\n-    }\n-}\n-\n-impl<'a> PartialEq<InternedString> for &'a str {\n-    fn eq(&self, other: &InternedString) -> bool {\n-        PartialEq::eq(*self, &other.string[..])\n-    }\n-}\n-\n-impl PartialEq<str> for InternedString {\n-    fn eq(&self, other: &str) -> bool {\n-        PartialEq::eq(&self.string[..], other)\n-    }\n-}\n-\n-impl PartialEq<InternedString> for str {\n-    fn eq(&self, other: &InternedString) -> bool {\n-        PartialEq::eq(self, &other.string[..])\n-    }\n-}\n-\n impl Decodable for InternedString {\n     fn decode<D: Decoder>(d: &mut D) -> Result<InternedString, D::Error> {\n         Ok(Symbol::intern(&d.read_str()?).as_str())"}]}