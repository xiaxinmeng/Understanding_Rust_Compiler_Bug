{"sha": "5c0577f233ee79c85c6890977f8f73ffe8a21233", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjMDU3N2YyMzNlZTc5Yzg1YzY4OTA5NzdmOGY3M2ZmZThhMjEyMzM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-05-08T14:07:32Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-05-08T14:09:40Z"}, "message": "Import ast::* in parser.rs\n\nAnd make the code look a lot less awkward.", "tree": {"sha": "e020cc9fb45272b777a02f733433302665bd77a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e020cc9fb45272b777a02f733433302665bd77a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c0577f233ee79c85c6890977f8f73ffe8a21233", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c0577f233ee79c85c6890977f8f73ffe8a21233", "html_url": "https://github.com/rust-lang/rust/commit/5c0577f233ee79c85c6890977f8f73ffe8a21233", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c0577f233ee79c85c6890977f8f73ffe8a21233/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b619954457b9790de60cb09dc3953e9a4f630bed", "url": "https://api.github.com/repos/rust-lang/rust/commits/b619954457b9790de60cb09dc3953e9a4f630bed", "html_url": "https://github.com/rust-lang/rust/commit/b619954457b9790de60cb09dc3953e9a4f630bed"}], "stats": {"total": 772, "additions": 386, "deletions": 386}, "files": [{"sha": "1bfc6b2c6c2febb3a95e33ca1c48c57cbcc553f8", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 386, "deletions": 386, "changes": 772, "blob_url": "https://github.com/rust-lang/rust/blob/5c0577f233ee79c85c6890977f8f73ffe8a21233/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c0577f233ee79c85c6890977f8f73ffe8a21233/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=5c0577f233ee79c85c6890977f8f73ffe8a21233", "patch": "@@ -5,7 +5,7 @@ import token::{can_begin_expr, is_ident, is_plain_ident};\n import codemap::{span,fss_none};\n import util::interner;\n import ast_util::{spanned, mk_sp, ident_to_path, operator_prec};\n-import ast::{node_id};\n+import ast::*;\n import lexer::reader;\n import prec::{as_prec, token_to_binop};\n import attr::{parse_outer_attrs_or_ext,\n@@ -49,7 +49,7 @@ enum file_type { CRATE_FILE, SOURCE_FILE, }\n \n type parser = @{\n     sess: parse_sess,\n-    cfg: ast::crate_cfg,\n+    cfg: crate_cfg,\n     file_type: file_type,\n     mut token: token::token,\n     mut span: span,\n@@ -104,8 +104,8 @@ impl parser for parser {\n     fn get_id() -> node_id { next_node_id(self.sess) }\n }\n \n-fn parse_ty_fn(p: parser) -> ast::fn_decl {\n-    fn parse_fn_input_ty(p: parser) -> ast::arg {\n+fn parse_ty_fn(p: parser) -> fn_decl {\n+    fn parse_fn_input_ty(p: parser) -> arg {\n         let mode = parse_arg_mode(p);\n         let name = if is_plain_ident(p.token)\n             && p.look_ahead(1u) == token::COLON {\n@@ -123,14 +123,14 @@ fn parse_ty_fn(p: parser) -> ast::fn_decl {\n     // can't have constrained types.\n     // Not sure whether that would be desirable anyway. See #34 for the\n     // story on constrained types.\n-    let constrs: [@ast::constr] = [];\n+    let constrs: [@constr] = [];\n     let (ret_style, ret_ty) = parse_ret_ty(p);\n     ret {inputs: inputs.node, output: ret_ty,\n-         purity: ast::impure_fn, cf: ret_style,\n+         purity: impure_fn, cf: ret_style,\n          constraints: constrs};\n }\n \n-fn parse_ty_methods(p: parser) -> [ast::ty_method] {\n+fn parse_ty_methods(p: parser) -> [ty_method] {\n     parse_seq(token::LBRACE, token::RBRACE, seq_sep_none(), {|p|\n         let attrs = parse_outer_attributes(p);\n         let flo = p.span.lo;\n@@ -144,13 +144,13 @@ fn parse_ty_methods(p: parser) -> [ast::ty_method] {\n     }, p).node\n }\n \n-fn parse_mt(p: parser) -> ast::mt {\n+fn parse_mt(p: parser) -> mt {\n     let mutbl = parse_mutability(p);\n     let t = parse_ty(p, false);\n     ret {ty: t, mutbl: mutbl};\n }\n \n-fn parse_ty_field(p: parser) -> ast::ty_field {\n+fn parse_ty_field(p: parser) -> ty_field {\n     let lo = p.span.lo;\n     let mutbl = parse_mutability(p);\n     let id = parse_ident(p);\n@@ -161,104 +161,104 @@ fn parse_ty_field(p: parser) -> ast::ty_field {\n \n // if i is the jth ident in args, return j\n // otherwise, fail\n-fn ident_index(p: parser, args: [ast::arg], i: ast::ident) -> uint {\n+fn ident_index(p: parser, args: [arg], i: ident) -> uint {\n     let mut j = 0u;\n     for args.each {|a| if a.ident == i { ret j; } j += 1u; }\n     p.fatal(\"unbound variable `\" + i + \"` in constraint arg\");\n }\n \n-fn parse_type_constr_arg(p: parser) -> @ast::ty_constr_arg {\n+fn parse_type_constr_arg(p: parser) -> @ty_constr_arg {\n     let sp = p.span;\n-    let mut carg = ast::carg_base;\n+    let mut carg = carg_base;\n     expect(p, token::BINOP(token::STAR));\n     if p.token == token::DOT {\n         // \"*...\" notation for record fields\n         p.bump();\n         let pth = parse_path_without_tps(p);\n-        carg = ast::carg_ident(pth);\n+        carg = carg_ident(pth);\n     }\n     // No literals yet, I guess?\n     ret @{node: carg, span: sp};\n }\n \n-fn parse_constr_arg(args: [ast::arg], p: parser) -> @ast::constr_arg {\n+fn parse_constr_arg(args: [arg], p: parser) -> @constr_arg {\n     let sp = p.span;\n-    let mut carg = ast::carg_base;\n+    let mut carg = carg_base;\n     if p.token == token::BINOP(token::STAR) {\n         p.bump();\n     } else {\n-        let i: ast::ident = parse_value_ident(p);\n-        carg = ast::carg_ident(ident_index(p, args, i));\n+        let i: ident = parse_value_ident(p);\n+        carg = carg_ident(ident_index(p, args, i));\n     }\n     ret @{node: carg, span: sp};\n }\n \n-fn parse_ty_constr(fn_args: [ast::arg], p: parser) -> @ast::constr {\n+fn parse_ty_constr(fn_args: [arg], p: parser) -> @constr {\n     let lo = p.span.lo;\n     let path = parse_path_without_tps(p);\n-    let args: {node: [@ast::constr_arg], span: span} =\n+    let args: {node: [@constr_arg], span: span} =\n         parse_seq(token::LPAREN, token::RPAREN, seq_sep(token::COMMA),\n                   {|p| parse_constr_arg(fn_args, p)}, p);\n     ret @spanned(lo, args.span.hi,\n                  {path: path, args: args.node, id: p.get_id()});\n }\n \n-fn parse_constr_in_type(p: parser) -> @ast::ty_constr {\n+fn parse_constr_in_type(p: parser) -> @ty_constr {\n     let lo = p.span.lo;\n     let path = parse_path_without_tps(p);\n-    let args: [@ast::ty_constr_arg] =\n+    let args: [@ty_constr_arg] =\n         parse_seq(token::LPAREN, token::RPAREN, seq_sep(token::COMMA),\n                   parse_type_constr_arg, p).node;\n     let hi = p.span.lo;\n-    let tc: ast::ty_constr_ = {path: path, args: args, id: p.get_id()};\n+    let tc: ty_constr_ = {path: path, args: args, id: p.get_id()};\n     ret @spanned(lo, hi, tc);\n }\n \n \n-fn parse_constrs<T: copy>(pser: fn(parser) -> @ast::constr_general<T>,\n+fn parse_constrs<T: copy>(pser: fn(parser) -> @constr_general<T>,\n                          p: parser) ->\n-   [@ast::constr_general<T>] {\n-    let mut constrs: [@ast::constr_general<T>] = [];\n+   [@constr_general<T>] {\n+    let mut constrs: [@constr_general<T>] = [];\n     loop {\n         let constr = pser(p);\n         constrs += [constr];\n         if p.token == token::COMMA { p.bump(); } else { ret constrs; }\n     };\n }\n \n-fn parse_type_constraints(p: parser) -> [@ast::ty_constr] {\n+fn parse_type_constraints(p: parser) -> [@ty_constr] {\n     ret parse_constrs(parse_constr_in_type, p);\n }\n \n-fn parse_ret_ty(p: parser) -> (ast::ret_style, @ast::ty) {\n+fn parse_ret_ty(p: parser) -> (ret_style, @ty) {\n     ret if eat(p, token::RARROW) {\n         let lo = p.span.lo;\n         if eat(p, token::NOT) {\n-            (ast::noreturn, @{id: p.get_id(),\n-                              node: ast::ty_bot,\n+            (noreturn, @{id: p.get_id(),\n+                              node: ty_bot,\n                               span: mk_sp(lo, p.last_span.hi)})\n         } else {\n-            (ast::return_val, parse_ty(p, false))\n+            (return_val, parse_ty(p, false))\n         }\n     } else {\n         let pos = p.span.lo;\n-        (ast::return_val, @{id: p.get_id(),\n-                            node: ast::ty_nil,\n+        (return_val, @{id: p.get_id(),\n+                            node: ty_nil,\n                             span: mk_sp(pos, pos)})\n     }\n }\n \n-fn region_from_name(p: parser, s: option<str>) -> @ast::region {\n+fn region_from_name(p: parser, s: option<str>) -> @region {\n     let r = alt s {\n-      some (string) { ast::re_named(string) }\n-      none { ast::re_anon }\n+      some (string) { re_named(string) }\n+      none { re_anon }\n     };\n \n     @{id: p.get_id(), node: r}\n }\n \n // Parses something like \"&x\"\n-fn parse_region(p: parser) -> @ast::region {\n+fn parse_region(p: parser) -> @region {\n     expect(p, token::BINOP(token::AND));\n     alt p.token {\n       token::IDENT(sid, _) {\n@@ -273,7 +273,7 @@ fn parse_region(p: parser) -> @ast::region {\n }\n \n // Parses something like \"&x.\" (note the trailing dot)\n-fn parse_region_dot(p: parser) -> @ast::region {\n+fn parse_region_dot(p: parser) -> @region {\n     let name =\n         alt p.token {\n           token::IDENT(sid, _) if p.look_ahead(1u) == token::DOT {\n@@ -285,13 +285,13 @@ fn parse_region_dot(p: parser) -> @ast::region {\n     region_from_name(p, name)\n }\n \n-fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n+fn parse_ty(p: parser, colons_before_params: bool) -> @ty {\n     let lo = p.span.lo;\n \n     alt maybe_parse_dollar_mac(p) {\n       some(e) {\n         ret @{id: p.get_id(),\n-              node: ast::ty_mac(spanned(lo, p.span.hi, e)),\n+              node: ty_mac(spanned(lo, p.span.hi, e)),\n               span: mk_sp(lo, p.span.hi)};\n       }\n       none {}\n@@ -301,68 +301,68 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n         p.bump();\n         if p.token == token::RPAREN {\n             p.bump();\n-            ast::ty_nil\n+            ty_nil\n         } else {\n             let mut ts = [parse_ty(p, false)];\n             while p.token == token::COMMA {\n                 p.bump();\n                 ts += [parse_ty(p, false)];\n             }\n             let t = if vec::len(ts) == 1u { ts[0].node }\n-                    else { ast::ty_tup(ts) };\n+                    else { ty_tup(ts) };\n             expect(p, token::RPAREN);\n             t\n         }\n     } else if p.token == token::AT {\n         p.bump();\n-        ast::ty_box(parse_mt(p))\n+        ty_box(parse_mt(p))\n     } else if p.token == token::TILDE {\n         p.bump();\n-        ast::ty_uniq(parse_mt(p))\n+        ty_uniq(parse_mt(p))\n     } else if p.token == token::BINOP(token::STAR) {\n         p.bump();\n-        ast::ty_ptr(parse_mt(p))\n+        ty_ptr(parse_mt(p))\n     } else if p.token == token::LBRACE {\n         let elems =\n             parse_seq(token::LBRACE, token::RBRACE, seq_sep_opt(token::COMMA),\n                       parse_ty_field, p);\n         if vec::len(elems.node) == 0u { unexpected_last(p, token::RBRACE); }\n         let hi = elems.span.hi;\n \n-        let t = ast::ty_rec(elems.node);\n+        let t = ty_rec(elems.node);\n         if p.token == token::COLON {\n             p.bump();\n-            ast::ty_constr(@{id: p.get_id(),\n+            ty_constr(@{id: p.get_id(),\n                              node: t,\n                              span: mk_sp(lo, hi)},\n                            parse_type_constraints(p))\n         } else { t }\n     } else if p.token == token::LBRACKET {\n         expect(p, token::LBRACKET);\n-        let t = ast::ty_vec(parse_mt(p));\n+        let t = ty_vec(parse_mt(p));\n         expect(p, token::RBRACKET);\n         t\n     } else if p.token == token::BINOP(token::AND) {\n         p.bump();\n         let region = parse_region_dot(p);\n         let mt = parse_mt(p);\n-        ast::ty_rptr(region, mt)\n+        ty_rptr(region, mt)\n     } else if eat_keyword(p, \"fn\") {\n         let proto = parse_fn_ty_proto(p);\n         alt proto {\n-          ast::proto_bare { p.warn(\"fn is deprecated, use native fn\"); }\n+          proto_bare { p.warn(\"fn is deprecated, use native fn\"); }\n           _ { /* fallthrough */ }\n         }\n-        ast::ty_fn(proto, parse_ty_fn(p))\n+        ty_fn(proto, parse_ty_fn(p))\n     } else if eat_keyword(p, \"native\") {\n         expect_keyword(p, \"fn\");\n-        ast::ty_fn(ast::proto_bare, parse_ty_fn(p))\n+        ty_fn(proto_bare, parse_ty_fn(p))\n     } else if p.token == token::MOD_SEP || is_ident(p.token) {\n         let path = parse_path_with_tps(p, colons_before_params);\n-        ast::ty_path(path, p.get_id())\n+        ty_path(path, p.get_id())\n     } else { p.fatal(\"expecting type\"); };\n \n-    fn mk_ty(p: parser, t: ast::ty_, lo: uint, hi: uint) -> @ast::ty {\n+    fn mk_ty(p: parser, t: ty_, lo: uint, hi: uint) -> @ty {\n         @{id: p.get_id(),\n           node: t,\n           span: mk_sp(lo, hi)}\n@@ -376,33 +376,33 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n         ret ty;\n       }\n       some(v) {\n-        let t1 = ast::ty_vstore(ty, v);\n+        let t1 = ty_vstore(ty, v);\n         ret mk_ty(p, t1, lo, p.last_span.hi);\n       }\n     }\n }\n \n-fn parse_arg_mode(p: parser) -> ast::mode {\n+fn parse_arg_mode(p: parser) -> mode {\n     if eat(p, token::BINOP(token::AND)) {\n-        ast::expl(ast::by_mutbl_ref)\n+        expl(by_mutbl_ref)\n     } else if eat(p, token::BINOP(token::MINUS)) {\n-        ast::expl(ast::by_move)\n+        expl(by_move)\n     } else if eat(p, token::ANDAND) {\n-        ast::expl(ast::by_ref)\n+        expl(by_ref)\n     } else if eat(p, token::BINOP(token::PLUS)) {\n         if eat(p, token::BINOP(token::PLUS)) {\n-            ast::expl(ast::by_val)\n+            expl(by_val)\n         } else {\n-            ast::expl(ast::by_copy)\n+            expl(by_copy)\n         }\n-    } else { ast::infer(p.get_id()) }\n+    } else { infer(p.get_id()) }\n }\n \n fn parse_capture_item_or(\n     p: parser,\n     parse_arg_fn: fn() -> arg_or_capture_item) -> arg_or_capture_item {\n \n-    fn parse_capture_item(p: parser, is_move: bool) -> ast::capture_item {\n+    fn parse_capture_item(p: parser, is_move: bool) -> capture_item {\n         let id = p.get_id();\n         let sp = mk_sp(p.span.lo, p.span.hi);\n         let ident = parse_ident(p);\n@@ -438,29 +438,29 @@ fn parse_fn_block_arg(p: parser) -> arg_or_capture_item {\n                     parse_ty(p, false)\n                 } else {\n                     @{id: p.get_id(),\n-                      node: ast::ty_infer,\n+                      node: ty_infer,\n                       span: mk_sp(p.span.lo, p.span.hi)}\n                 };\n         either::left({mode: m, ty: t, ident: i, id: p.get_id()})\n     }\n }\n \n-fn maybe_parse_dollar_mac(p: parser) -> option<ast::mac_> {\n+fn maybe_parse_dollar_mac(p: parser) -> option<mac_> {\n     alt p.token {\n       token::DOLLAR {\n         let lo = p.span.lo;\n         p.bump();\n         alt p.token {\n-          token::LIT_INT(num, ast::ty_i) {\n+          token::LIT_INT(num, ty_i) {\n             p.bump();\n-            some(ast::mac_var(num as uint))\n+            some(mac_var(num as uint))\n           }\n           token::LPAREN {\n             p.bump();\n             let e = parse_expr(p);\n             expect(p, token::RPAREN);\n             let hi = p.last_span.hi;\n-            some(ast::mac_aq(mk_sp(lo,hi), e))\n+            some(mac_aq(mk_sp(lo,hi), e))\n           }\n           _ {\n             p.fatal(\"expected `(` or integer literal\");\n@@ -471,24 +471,24 @@ fn maybe_parse_dollar_mac(p: parser) -> option<ast::mac_> {\n     }\n }\n \n-fn maybe_parse_vstore(p: parser) -> option<ast::vstore> {\n+fn maybe_parse_vstore(p: parser) -> option<vstore> {\n     if p.token == token::BINOP(token::SLASH) {\n         p.bump();\n         alt p.token {\n           token::AT {\n-            p.bump(); some(ast::vstore_box)\n+            p.bump(); some(vstore_box)\n           }\n           token::TILDE {\n-            p.bump(); some(ast::vstore_uniq)\n+            p.bump(); some(vstore_uniq)\n           }\n           token::UNDERSCORE {\n-            p.bump(); some(ast::vstore_fixed(none))\n+            p.bump(); some(vstore_fixed(none))\n           }\n-          token::LIT_INT(i, ast::ty_i) if i >= 0i64 {\n-            p.bump(); some(ast::vstore_fixed(some(i as uint)))\n+          token::LIT_INT(i, ty_i) if i >= 0i64 {\n+            p.bump(); some(vstore_fixed(some(i as uint)))\n           }\n           token::BINOP(token::AND) {\n-            some(ast::vstore_slice(parse_region(p)))\n+            some(vstore_slice(parse_region(p)))\n           }\n           _ {\n             none\n@@ -499,23 +499,23 @@ fn maybe_parse_vstore(p: parser) -> option<ast::vstore> {\n     }\n }\n \n-fn lit_from_token(p: parser, tok: token::token) -> ast::lit_ {\n+fn lit_from_token(p: parser, tok: token::token) -> lit_ {\n     alt tok {\n-      token::LIT_INT(i, it) { ast::lit_int(i, it) }\n-      token::LIT_UINT(u, ut) { ast::lit_uint(u, ut) }\n-      token::LIT_FLOAT(s, ft) { ast::lit_float(p.get_str(s), ft) }\n-      token::LIT_STR(s) { ast::lit_str(p.get_str(s)) }\n-      token::LPAREN { expect(p, token::RPAREN); ast::lit_nil }\n+      token::LIT_INT(i, it) { lit_int(i, it) }\n+      token::LIT_UINT(u, ut) { lit_uint(u, ut) }\n+      token::LIT_FLOAT(s, ft) { lit_float(p.get_str(s), ft) }\n+      token::LIT_STR(s) { lit_str(p.get_str(s)) }\n+      token::LPAREN { expect(p, token::RPAREN); lit_nil }\n       _ { unexpected_last(p, tok); }\n     }\n }\n \n-fn parse_lit(p: parser) -> ast::lit {\n+fn parse_lit(p: parser) -> lit {\n     let lo = p.span.lo;\n     let lit = if eat_keyword(p, \"true\") {\n-        ast::lit_bool(true)\n+        lit_bool(true)\n     } else if eat_keyword(p, \"false\") {\n-        ast::lit_bool(false)\n+        lit_bool(false)\n     } else {\n         let tok = p.token;\n         p.bump();\n@@ -524,13 +524,13 @@ fn parse_lit(p: parser) -> ast::lit {\n     ret {node: lit, span: mk_sp(lo, p.last_span.hi)};\n }\n \n-fn parse_path_without_tps(p: parser) -> @ast::path {\n+fn parse_path_without_tps(p: parser) -> @path {\n     parse_path_without_tps_(p, parse_ident, parse_ident)\n }\n \n fn parse_path_without_tps_(\n-    p: parser, parse_ident: fn(parser) -> ast::ident,\n-    parse_last_ident: fn(parser) -> ast::ident) -> @ast::path {\n+    p: parser, parse_ident: fn(parser) -> ident,\n+    parse_last_ident: fn(parser) -> ident) -> @path {\n \n     let lo = p.span.lo;\n     let global = eat(p, token::MOD_SEP);\n@@ -552,11 +552,11 @@ fn parse_path_without_tps_(\n       idents: ids, rp: none, types: []}\n }\n \n-fn parse_value_path(p: parser) -> @ast::path {\n+fn parse_value_path(p: parser) -> @path {\n     parse_path_without_tps_(p, parse_ident, parse_value_ident)\n }\n \n-fn parse_path_with_tps(p: parser, colons: bool) -> @ast::path {\n+fn parse_path_with_tps(p: parser, colons: bool) -> @path {\n     #debug[\"parse_path_with_tps(colons=%b)\", colons];\n \n     let lo = p.span.lo;\n@@ -597,19 +597,19 @@ fn parse_path_with_tps(p: parser, colons: bool) -> @ast::path {\n           types: tps.node with *path};\n }\n \n-fn parse_mutability(p: parser) -> ast::mutability {\n+fn parse_mutability(p: parser) -> mutability {\n     if eat_keyword(p, \"mut\") {\n-        ast::m_mutbl\n+        m_mutbl\n     } else if eat_keyword(p, \"mut\") {\n-        ast::m_mutbl\n+        m_mutbl\n     } else if eat_keyword(p, \"const\") {\n-        ast::m_const\n+        m_const\n     } else {\n-        ast::m_imm\n+        m_imm\n     }\n }\n \n-fn parse_field(p: parser, sep: token::token) -> ast::field {\n+fn parse_field(p: parser, sep: token::token) -> field {\n     let lo = p.span.lo;\n     let m = parse_mutability(p);\n     let i = parse_ident(p);\n@@ -618,42 +618,42 @@ fn parse_field(p: parser, sep: token::token) -> ast::field {\n     ret spanned(lo, e.span.hi, {mutbl: m, ident: i, expr: e});\n }\n \n-fn mk_expr(p: parser, lo: uint, hi: uint, +node: ast::expr_) -> @ast::expr {\n+fn mk_expr(p: parser, lo: uint, hi: uint, +node: expr_) -> @expr {\n     ret @{id: p.get_id(), node: node, span: mk_sp(lo, hi)};\n }\n \n-fn mk_mac_expr(p: parser, lo: uint, hi: uint, m: ast::mac_) -> @ast::expr {\n+fn mk_mac_expr(p: parser, lo: uint, hi: uint, m: mac_) -> @expr {\n     ret @{id: p.get_id(),\n-          node: ast::expr_mac({node: m, span: mk_sp(lo, hi)}),\n+          node: expr_mac({node: m, span: mk_sp(lo, hi)}),\n           span: mk_sp(lo, hi)};\n }\n \n-fn mk_lit_u32(p: parser, i: u32) -> @ast::expr {\n+fn mk_lit_u32(p: parser, i: u32) -> @expr {\n     let span = p.span;\n-    let lv_lit = @{node: ast::lit_uint(i as u64, ast::ty_u32),\n+    let lv_lit = @{node: lit_uint(i as u64, ty_u32),\n                    span: span};\n \n-    ret @{id: p.get_id(), node: ast::expr_lit(lv_lit), span: span};\n+    ret @{id: p.get_id(), node: expr_lit(lv_lit), span: span};\n }\n \n // We don't allow single-entry tuples in the true AST; that indicates a\n // parenthesized expression.  However, we preserve them temporarily while\n // parsing because `(while{...})+3` parses differently from `while{...}+3`.\n //\n-// To reflect the fact that the @ast::expr is not a true expr that should be\n+// To reflect the fact that the @expr is not a true expr that should be\n // part of the AST, we wrap such expressions in the pexpr enum.  They\n // can then be converted to true expressions by a call to `to_expr()`.\n enum pexpr {\n-    pexpr(@ast::expr),\n+    pexpr(@expr),\n }\n \n-fn mk_pexpr(p: parser, lo: uint, hi: uint, node: ast::expr_) -> pexpr {\n+fn mk_pexpr(p: parser, lo: uint, hi: uint, node: expr_) -> pexpr {\n     ret pexpr(mk_expr(p, lo, hi, node));\n }\n \n-fn to_expr(e: pexpr) -> @ast::expr {\n+fn to_expr(e: pexpr) -> @expr {\n     alt e.node {\n-      ast::expr_tup(es) if vec::len(es) == 1u { es[0u] }\n+      expr_tup(es) if vec::len(es) == 1u { es[0u] }\n       _ { *e }\n     }\n }\n@@ -662,7 +662,7 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n     let lo = p.span.lo;\n     let mut hi = p.span.hi;\n \n-    let mut ex: ast::expr_;\n+    let mut ex: expr_;\n \n     alt maybe_parse_dollar_mac(p) {\n       some(x) {ret pexpr(mk_mac_expr(p, lo, p.span.hi, x));}\n@@ -674,8 +674,8 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n         if p.token == token::RPAREN {\n             hi = p.span.hi;\n             p.bump();\n-            let lit = @spanned(lo, hi, ast::lit_nil);\n-            ret mk_pexpr(p, lo, hi, ast::expr_lit(lit));\n+            let lit = @spanned(lo, hi, lit_nil);\n+            ret mk_pexpr(p, lo, hi, expr_lit(lit));\n         }\n         let mut es = [parse_expr(p)];\n         while p.token == token::COMMA { p.bump(); es += [parse_expr(p)]; }\n@@ -687,7 +687,7 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n         // This is so that wrappers around parse_bottom_expr()\n         // can tell whether the expression was parenthesized or not,\n         // which affects expr_is_complete().\n-        ret mk_pexpr(p, lo, hi, ast::expr_tup(es));\n+        ret mk_pexpr(p, lo, hi, expr_tup(es));\n     } else if p.token == token::LBRACE {\n         p.bump();\n         if is_keyword(p, \"mut\") ||\n@@ -707,20 +707,20 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n             }\n             hi = p.span.hi;\n             expect(p, token::RBRACE);\n-            ex = ast::expr_rec(fields, base);\n+            ex = expr_rec(fields, base);\n         } else if token::is_bar(p.token) {\n             ret pexpr(parse_fn_block_expr(p));\n         } else {\n-            let blk = parse_block_tail(p, lo, ast::default_blk);\n-            ret mk_pexpr(p, blk.span.lo, blk.span.hi, ast::expr_block(blk));\n+            let blk = parse_block_tail(p, lo, default_blk);\n+            ret mk_pexpr(p, blk.span.lo, blk.span.hi, expr_block(blk));\n         }\n     } else if eat_keyword(p, \"new\") {\n         expect(p, token::LPAREN);\n         let r = parse_expr(p);\n         expect(p, token::RPAREN);\n         let v = parse_expr(p);\n         ret mk_pexpr(p, lo, p.span.hi,\n-                     ast::expr_new(r, p.get_id(), v));\n+                     expr_new(r, p.get_id(), v));\n     } else if eat_keyword(p, \"if\") {\n         ret pexpr(parse_if_expr(p));\n     } else if eat_keyword(p, \"for\") {\n@@ -736,23 +736,23 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n     } else if eat_keyword(p, \"fn\") {\n         let proto = parse_fn_ty_proto(p);\n         alt proto {\n-          ast::proto_bare { p.fatal(\"fn expr are deprecated, use fn@\"); }\n-          ast::proto_any { p.fatal(\"fn* cannot be used in an expression\"); }\n+          proto_bare { p.fatal(\"fn expr are deprecated, use fn@\"); }\n+          proto_any { p.fatal(\"fn* cannot be used in an expression\"); }\n           _ { /* fallthrough */ }\n         }\n         ret pexpr(parse_fn_expr(p, proto));\n     } else if eat_keyword(p, \"unchecked\") {\n-        ret pexpr(parse_block_expr(p, lo, ast::unchecked_blk));\n+        ret pexpr(parse_block_expr(p, lo, unchecked_blk));\n     } else if eat_keyword(p, \"unsafe\") {\n-        ret pexpr(parse_block_expr(p, lo, ast::unsafe_blk));\n+        ret pexpr(parse_block_expr(p, lo, unsafe_blk));\n     } else if p.token == token::LBRACKET {\n         p.bump();\n         let mutbl = parse_mutability(p);\n         let es =\n             parse_seq_to_end(token::RBRACKET, seq_sep(token::COMMA),\n                              parse_expr, p);\n         hi = p.span.hi;\n-        ex = ast::expr_vec(es, mutbl);\n+        ex = expr_vec(es, mutbl);\n     } else if p.token == token::POUND && p.look_ahead(1u) == token::LT {\n         p.bump();\n         p.bump();\n@@ -761,16 +761,16 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n \n         /* hack: early return to take advantage of specialized function */\n         ret pexpr(mk_mac_expr(p, lo, p.span.hi,\n-                              ast::mac_embed_type(ty)));\n+                              mac_embed_type(ty)));\n     } else if p.token == token::POUND && p.look_ahead(1u) == token::LBRACE {\n         p.bump();\n         p.bump();\n-        let blk = ast::mac_embed_block(\n-            parse_block_tail(p, lo, ast::default_blk));\n+        let blk = mac_embed_block(\n+            parse_block_tail(p, lo, default_blk));\n         ret pexpr(mk_mac_expr(p, lo, p.span.hi, blk));\n     } else if p.token == token::ELLIPSIS {\n         p.bump();\n-        ret pexpr(mk_mac_expr(p, lo, p.span.hi, ast::mac_ellipsis));\n+        ret pexpr(mk_mac_expr(p, lo, p.span.hi, mac_ellipsis));\n     } else if p.token == token::POUND {\n         let ex_ext = parse_syntax_ext(p);\n         hi = ex_ext.span.hi;\n@@ -781,82 +781,82 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n             parse_seq(token::LPAREN, token::RPAREN, seq_sep(token::COMMA),\n                       parse_expr_or_hole, p);\n         hi = es.span.hi;\n-        ex = ast::expr_bind(e, es.node);\n+        ex = expr_bind(e, es.node);\n     } else if eat_keyword(p, \"fail\") {\n         if can_begin_expr(p.token) {\n             let e = parse_expr(p);\n             hi = e.span.hi;\n-            ex = ast::expr_fail(some(e));\n-        } else { ex = ast::expr_fail(none); }\n+            ex = expr_fail(some(e));\n+        } else { ex = expr_fail(none); }\n     } else if eat_keyword(p, \"log\") {\n         expect(p, token::LPAREN);\n         let lvl = parse_expr(p);\n         expect(p, token::COMMA);\n         let e = parse_expr(p);\n-        ex = ast::expr_log(2, lvl, e);\n+        ex = expr_log(2, lvl, e);\n         hi = p.span.hi;\n         expect(p, token::RPAREN);\n     } else if eat_keyword(p, \"assert\") {\n         let e = parse_expr(p);\n-        ex = ast::expr_assert(e);\n+        ex = expr_assert(e);\n         hi = e.span.hi;\n     } else if eat_keyword(p, \"check\") {\n         /* Should be a predicate (pure boolean function) applied to\n            arguments that are all either slot variables or literals.\n            but the typechecker enforces that. */\n         let e = parse_expr(p);\n         hi = e.span.hi;\n-        ex = ast::expr_check(ast::checked_expr, e);\n+        ex = expr_check(checked_expr, e);\n     } else if eat_keyword(p, \"claim\") {\n         /* Same rules as check, except that if check-claims\n          is enabled (a command-line flag), then the parser turns\n         claims into check */\n \n         let e = parse_expr(p);\n         hi = e.span.hi;\n-        ex = ast::expr_check(ast::claimed_expr, e);\n+        ex = expr_check(claimed_expr, e);\n     } else if eat_keyword(p, \"ret\") {\n         if can_begin_expr(p.token) {\n             let e = parse_expr(p);\n             hi = e.span.hi;\n-            ex = ast::expr_ret(some(e));\n-        } else { ex = ast::expr_ret(none); }\n+            ex = expr_ret(some(e));\n+        } else { ex = expr_ret(none); }\n     } else if eat_keyword(p, \"break\") {\n-        ex = ast::expr_break;\n+        ex = expr_break;\n         hi = p.span.hi;\n     } else if eat_keyword(p, \"cont\") {\n-        ex = ast::expr_cont;\n+        ex = expr_cont;\n         hi = p.span.hi;\n     } else if eat_keyword(p, \"be\") {\n         let e = parse_expr(p);\n         hi = e.span.hi;\n-        ex = ast::expr_be(e);\n+        ex = expr_be(e);\n     } else if eat_keyword(p, \"copy\") {\n         let e = parse_expr(p);\n-        ex = ast::expr_copy(e);\n+        ex = expr_copy(e);\n         hi = e.span.hi;\n     } else if p.token == token::MOD_SEP ||\n                   is_ident(p.token) && !is_keyword(p, \"true\") &&\n                       !is_keyword(p, \"false\") {\n         let pth = parse_path_with_tps(p, true);\n         hi = pth.span.hi;\n-        ex = ast::expr_path(pth);\n+        ex = expr_path(pth);\n     } else {\n         let lit = parse_lit(p);\n         hi = lit.span.hi;\n-        ex = ast::expr_lit(@lit);\n+        ex = expr_lit(@lit);\n     }\n \n     // Vstore is legal following expr_lit(lit_str(...)) and expr_vec(...)\n     // only.\n     alt ex {\n-      ast::expr_lit(@{node: ast::lit_str(_), span: _}) |\n-      ast::expr_vec(_, _)  {\n+      expr_lit(@{node: lit_str(_), span: _}) |\n+      expr_vec(_, _)  {\n         alt maybe_parse_vstore(p) {\n           none { }\n           some(v) {\n             hi = p.span.hi;\n-            ex = ast::expr_vstore(mk_expr(p, lo, hi, ex), v);\n+            ex = expr_vstore(mk_expr(p, lo, hi, ex), v);\n           }\n         }\n       }\n@@ -868,19 +868,19 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n \n fn parse_block_expr(p: parser,\n                     lo: uint,\n-                    blk_mode: ast::blk_check_mode) -> @ast::expr {\n+                    blk_mode: blk_check_mode) -> @expr {\n     expect(p, token::LBRACE);\n     let blk = parse_block_tail(p, lo, blk_mode);\n-    ret mk_expr(p, blk.span.lo, blk.span.hi, ast::expr_block(blk));\n+    ret mk_expr(p, blk.span.lo, blk.span.hi, expr_block(blk));\n }\n \n-fn parse_syntax_ext(p: parser) -> @ast::expr {\n+fn parse_syntax_ext(p: parser) -> @expr {\n     let lo = p.span.lo;\n     expect(p, token::POUND);\n     ret parse_syntax_ext_naked(p, lo);\n }\n \n-fn parse_syntax_ext_naked(p: parser, lo: uint) -> @ast::expr {\n+fn parse_syntax_ext_naked(p: parser, lo: uint) -> @expr {\n     alt p.token {\n       token::IDENT(_, _) {}\n       _ { p.fatal(\"expected a syntax expander name\"); }\n@@ -900,7 +900,7 @@ fn parse_syntax_ext_naked(p: parser, lo: uint) -> @ast::expr {\n             };\n         let hi = es.span.hi;\n         e = some(mk_expr(p, es.span.lo, hi,\n-                         ast::expr_vec(es.node, ast::m_imm)));\n+                         expr_vec(es.node, m_imm)));\n     }\n     let mut b = none;\n     if p.token == token::LBRACE {\n@@ -919,7 +919,7 @@ fn parse_syntax_ext_naked(p: parser, lo: uint) -> @ast::expr {\n         let hi = p.last_span.lo;\n         b = some({span: mk_sp(lo,hi)});\n     }\n-    ret mk_mac_expr(p, lo, p.span.hi, ast::mac_invoc(pth, e, b));\n+    ret mk_mac_expr(p, lo, p.span.hi, mac_invoc(pth, e, b));\n }\n \n fn parse_dot_or_call_expr(p: parser) -> pexpr {\n@@ -948,7 +948,7 @@ fn parse_dot_or_call_expr_with(p: parser, e0: pexpr) -> pexpr {\n                                     {|p| parse_ty(p, false)}, p)\n                 } else { [] };\n                 e = mk_pexpr(p, lo, hi,\n-                             ast::expr_field(to_expr(e),\n+                             expr_field(to_expr(e),\n                                              p.get_str(i),\n                                              tys));\n               }\n@@ -967,10 +967,10 @@ fn parse_dot_or_call_expr_with(p: parser, e0: pexpr) -> pexpr {\n \n             let nd =\n                 if vec::any(es_opt.node, {|e| option::is_none(e) }) {\n-                    ast::expr_bind(to_expr(e), es_opt.node)\n+                    expr_bind(to_expr(e), es_opt.node)\n                 } else {\n                     let es = vec::map(es_opt.node) {|e| option::get(e) };\n-                    ast::expr_call(to_expr(e), es, false)\n+                    expr_call(to_expr(e), es, false)\n                 };\n             e = mk_pexpr(p, lo, hi, nd);\n           }\n@@ -981,13 +981,13 @@ fn parse_dot_or_call_expr_with(p: parser, e0: pexpr) -> pexpr {\n             p.bump();\n             let blk = parse_fn_block_expr(p);\n             alt e.node {\n-              ast::expr_call(f, args, false) {\n-                e = pexpr(@{node: ast::expr_call(f, args + [blk], true)\n+              expr_call(f, args, false) {\n+                e = pexpr(@{node: expr_call(f, args + [blk], true)\n                             with *to_expr(e)});\n               }\n               _ {\n                 e = mk_pexpr(p, lo, p.last_span.hi,\n-                            ast::expr_call(to_expr(e), [blk], true));\n+                            expr_call(to_expr(e), [blk], true));\n               }\n             }\n           }\n@@ -999,7 +999,7 @@ fn parse_dot_or_call_expr_with(p: parser, e0: pexpr) -> pexpr {\n             hi = ix.span.hi;\n             expect(p, token::RBRACKET);\n             p.get_id(); // see ast_util::op_expr_callee_id\n-            e = mk_pexpr(p, lo, hi, ast::expr_index(to_expr(e), ix));\n+            e = mk_pexpr(p, lo, hi, expr_index(to_expr(e), ix));\n           }\n \n           _ { ret e; }\n@@ -1019,7 +1019,7 @@ fn parse_prefix_expr(p: parser) -> pexpr {\n         let e = to_expr(parse_prefix_expr(p));\n         hi = e.span.hi;\n         p.get_id(); // see ast_util::op_expr_callee_id\n-        ex = ast::expr_unary(ast::not, e);\n+        ex = expr_unary(not, e);\n       }\n       token::BINOP(b) {\n         alt b {\n@@ -1028,20 +1028,20 @@ fn parse_prefix_expr(p: parser) -> pexpr {\n             let e = to_expr(parse_prefix_expr(p));\n             hi = e.span.hi;\n             p.get_id(); // see ast_util::op_expr_callee_id\n-            ex = ast::expr_unary(ast::neg, e);\n+            ex = expr_unary(neg, e);\n           }\n           token::STAR {\n             p.bump();\n             let e = to_expr(parse_prefix_expr(p));\n             hi = e.span.hi;\n-            ex = ast::expr_unary(ast::deref, e);\n+            ex = expr_unary(deref, e);\n           }\n           token::AND {\n             p.bump();\n             let m = parse_mutability(p);\n             let e = to_expr(parse_prefix_expr(p));\n             hi = e.span.hi;\n-            ex = ast::expr_addr_of(m, e);\n+            ex = expr_addr_of(m, e);\n           }\n           _ { ret parse_dot_or_call_expr(p); }\n         }\n@@ -1051,27 +1051,27 @@ fn parse_prefix_expr(p: parser) -> pexpr {\n         let m = parse_mutability(p);\n         let e = to_expr(parse_prefix_expr(p));\n         hi = e.span.hi;\n-        ex = ast::expr_unary(ast::box(m), e);\n+        ex = expr_unary(box(m), e);\n       }\n       token::TILDE {\n         p.bump();\n         let m = parse_mutability(p);\n         let e = to_expr(parse_prefix_expr(p));\n         hi = e.span.hi;\n-        ex = ast::expr_unary(ast::uniq(m), e);\n+        ex = expr_unary(uniq(m), e);\n       }\n       _ { ret parse_dot_or_call_expr(p); }\n     }\n     ret mk_pexpr(p, lo, hi, ex);\n }\n \n \n-fn parse_binops(p: parser) -> @ast::expr {\n+fn parse_binops(p: parser) -> @expr {\n     ret parse_more_binops(p, parse_prefix_expr(p), 0u);\n }\n \n fn parse_more_binops(p: parser, plhs: pexpr, min_prec: uint) ->\n-   @ast::expr {\n+   @expr {\n     let lhs = to_expr(plhs);\n     if expr_is_complete(p, plhs) { ret lhs; }\n     let peeked = p.token;\n@@ -1087,7 +1087,7 @@ fn parse_more_binops(p: parser, plhs: pexpr, min_prec: uint) ->\n           let rhs = parse_more_binops(p, expr, cur_prec);\n           p.get_id(); // see ast_util::op_expr_callee_id\n           let bin = mk_pexpr(p, lhs.span.lo, rhs.span.hi,\n-                            ast::expr_binary(cur_op, lhs, rhs));\n+                            expr_binary(cur_op, lhs, rhs));\n           ret parse_more_binops(p, bin, min_prec);\n        }\n      }\n@@ -1096,66 +1096,66 @@ fn parse_more_binops(p: parser, plhs: pexpr, min_prec: uint) ->\n     if as_prec > min_prec && eat_keyword(p, \"as\") {\n         let rhs = parse_ty(p, true);\n         let _as =\n-            mk_pexpr(p, lhs.span.lo, rhs.span.hi, ast::expr_cast(lhs, rhs));\n+            mk_pexpr(p, lhs.span.lo, rhs.span.hi, expr_cast(lhs, rhs));\n         ret parse_more_binops(p, _as, min_prec);\n     }\n     ret lhs;\n }\n \n-fn parse_assign_expr(p: parser) -> @ast::expr {\n+fn parse_assign_expr(p: parser) -> @expr {\n     let lo = p.span.lo;\n     let lhs = parse_binops(p);\n     alt p.token {\n       token::EQ {\n         p.bump();\n         let rhs = parse_expr(p);\n-        ret mk_expr(p, lo, rhs.span.hi, ast::expr_assign(lhs, rhs));\n+        ret mk_expr(p, lo, rhs.span.hi, expr_assign(lhs, rhs));\n       }\n       token::BINOPEQ(op) {\n         p.bump();\n         let rhs = parse_expr(p);\n         let mut aop;\n         alt op {\n-          token::PLUS { aop = ast::add; }\n-          token::MINUS { aop = ast::subtract; }\n-          token::STAR { aop = ast::mul; }\n-          token::SLASH { aop = ast::div; }\n-          token::PERCENT { aop = ast::rem; }\n-          token::CARET { aop = ast::bitxor; }\n-          token::AND { aop = ast::bitand; }\n-          token::OR { aop = ast::bitor; }\n-          token::LSL { aop = ast::lsl; }\n-          token::LSR { aop = ast::lsr; }\n-          token::ASR { aop = ast::asr; }\n+          token::PLUS { aop = add; }\n+          token::MINUS { aop = subtract; }\n+          token::STAR { aop = mul; }\n+          token::SLASH { aop = div; }\n+          token::PERCENT { aop = rem; }\n+          token::CARET { aop = bitxor; }\n+          token::AND { aop = bitand; }\n+          token::OR { aop = bitor; }\n+          token::LSL { aop = lsl; }\n+          token::LSR { aop = lsr; }\n+          token::ASR { aop = asr; }\n         }\n         p.get_id(); // see ast_util::op_expr_callee_id\n-        ret mk_expr(p, lo, rhs.span.hi, ast::expr_assign_op(aop, lhs, rhs));\n+        ret mk_expr(p, lo, rhs.span.hi, expr_assign_op(aop, lhs, rhs));\n       }\n       token::LARROW {\n         p.bump();\n         let rhs = parse_expr(p);\n-        ret mk_expr(p, lo, rhs.span.hi, ast::expr_move(lhs, rhs));\n+        ret mk_expr(p, lo, rhs.span.hi, expr_move(lhs, rhs));\n       }\n       token::DARROW {\n         p.bump();\n         let rhs = parse_expr(p);\n-        ret mk_expr(p, lo, rhs.span.hi, ast::expr_swap(lhs, rhs));\n+        ret mk_expr(p, lo, rhs.span.hi, expr_swap(lhs, rhs));\n       }\n       _ {/* fall through */ }\n     }\n     ret lhs;\n }\n \n fn parse_if_expr_1(p: parser) ->\n-   {cond: @ast::expr,\n-    then: ast::blk,\n-    els: option<@ast::expr>,\n+   {cond: @expr,\n+    then: blk,\n+    els: option<@expr>,\n     lo: uint,\n     hi: uint} {\n     let lo = p.last_span.lo;\n     let cond = parse_expr(p);\n     let thn = parse_block(p);\n-    let mut els: option<@ast::expr> = none;\n+    let mut els: option<@expr> = none;\n     let mut hi = thn.span.hi;\n     if eat_keyword(p, \"else\") {\n         let elexpr = parse_else_expr(p);\n@@ -1165,58 +1165,58 @@ fn parse_if_expr_1(p: parser) ->\n     ret {cond: cond, then: thn, els: els, lo: lo, hi: hi};\n }\n \n-fn parse_if_expr(p: parser) -> @ast::expr {\n+fn parse_if_expr(p: parser) -> @expr {\n     if eat_keyword(p, \"check\") {\n         let q = parse_if_expr_1(p);\n-        ret mk_expr(p, q.lo, q.hi, ast::expr_if_check(q.cond, q.then, q.els));\n+        ret mk_expr(p, q.lo, q.hi, expr_if_check(q.cond, q.then, q.els));\n     } else {\n         let q = parse_if_expr_1(p);\n-        ret mk_expr(p, q.lo, q.hi, ast::expr_if(q.cond, q.then, q.els));\n+        ret mk_expr(p, q.lo, q.hi, expr_if(q.cond, q.then, q.els));\n     }\n }\n \n-fn parse_fn_expr(p: parser, proto: ast::proto) -> @ast::expr {\n+fn parse_fn_expr(p: parser, proto: proto) -> @expr {\n     let lo = p.last_span.lo;\n \n     let cc_old = parse_old_skool_capture_clause(p);\n \n     // if we want to allow fn expression argument types to be inferred in the\n     // future, just have to change parse_arg to parse_fn_block_arg.\n     let (decl, capture_clause) =\n-        parse_fn_decl(p, ast::impure_fn, parse_arg_or_capture_item);\n+        parse_fn_decl(p, impure_fn, parse_arg_or_capture_item);\n \n     let body = parse_block(p);\n     ret mk_expr(p, lo, body.span.hi,\n-                ast::expr_fn(proto, decl, body,\n+                expr_fn(proto, decl, body,\n                              @(*capture_clause + cc_old)));\n }\n \n-fn parse_fn_block_expr(p: parser) -> @ast::expr {\n+fn parse_fn_block_expr(p: parser) -> @expr {\n     let lo = p.last_span.lo;\n     let (decl, captures) = parse_fn_block_decl(p);\n-    let body = parse_block_tail(p, lo, ast::default_blk);\n+    let body = parse_block_tail(p, lo, default_blk);\n     ret mk_expr(p, lo, body.span.hi,\n-                ast::expr_fn_block(decl, body, captures));\n+                expr_fn_block(decl, body, captures));\n }\n \n-fn parse_else_expr(p: parser) -> @ast::expr {\n+fn parse_else_expr(p: parser) -> @expr {\n     if eat_keyword(p, \"if\") {\n         ret parse_if_expr(p);\n     } else {\n         let blk = parse_block(p);\n-        ret mk_expr(p, blk.span.lo, blk.span.hi, ast::expr_block(blk));\n+        ret mk_expr(p, blk.span.lo, blk.span.hi, expr_block(blk));\n     }\n }\n \n-fn parse_for_expr(p: parser) -> @ast::expr {\n+fn parse_for_expr(p: parser) -> @expr {\n     let lo = p.last_span;\n     let call = parse_expr_res(p, RESTRICT_STMT_EXPR);\n     alt call.node {\n-      ast::expr_call(f, args, true) {\n+      expr_call(f, args, true) {\n         let b_arg = vec::last(args);\n         let last = mk_expr(p, b_arg.span.lo, b_arg.span.hi,\n-                           ast::expr_loop_body(b_arg));\n-        @{node: ast::expr_call(f, vec::init(args) + [last], true)\n+                           expr_loop_body(b_arg));\n+        @{node: expr_call(f, vec::init(args) + [last], true)\n           with *call}\n       }\n       _ {\n@@ -1225,37 +1225,37 @@ fn parse_for_expr(p: parser) -> @ast::expr {\n     }\n }\n \n-fn parse_while_expr(p: parser) -> @ast::expr {\n+fn parse_while_expr(p: parser) -> @expr {\n     let lo = p.last_span.lo;\n     let cond = parse_expr(p);\n     let body = parse_block_no_value(p);\n     let mut hi = body.span.hi;\n-    ret mk_expr(p, lo, hi, ast::expr_while(cond, body));\n+    ret mk_expr(p, lo, hi, expr_while(cond, body));\n }\n \n-fn parse_do_while_expr(p: parser) -> @ast::expr {\n+fn parse_do_while_expr(p: parser) -> @expr {\n     let lo = p.last_span.lo;\n     let body = parse_block_no_value(p);\n     expect_keyword(p, \"while\");\n     let cond = parse_expr(p);\n     let mut hi = cond.span.hi;\n-    ret mk_expr(p, lo, hi, ast::expr_do_while(body, cond));\n+    ret mk_expr(p, lo, hi, expr_do_while(body, cond));\n }\n \n-fn parse_loop_expr(p: parser) -> @ast::expr {\n+fn parse_loop_expr(p: parser) -> @expr {\n     let lo = p.last_span.lo;\n     let body = parse_block_no_value(p);\n     let mut hi = body.span.hi;\n-    ret mk_expr(p, lo, hi, ast::expr_loop(body));\n+    ret mk_expr(p, lo, hi, expr_loop(body));\n }\n \n-fn parse_alt_expr(p: parser) -> @ast::expr {\n+fn parse_alt_expr(p: parser) -> @expr {\n     let lo = p.last_span.lo;\n-    let mode = if eat_keyword(p, \"check\") { ast::alt_check }\n-               else { ast::alt_exhaustive };\n+    let mode = if eat_keyword(p, \"check\") { alt_check }\n+               else { alt_exhaustive };\n     let discriminant = parse_expr(p);\n     expect(p, token::LBRACE);\n-    let mut arms: [ast::arm] = [];\n+    let mut arms: [arm] = [];\n     while p.token != token::RBRACE {\n         let pats = parse_pats(p);\n         let mut guard = none;\n@@ -1265,43 +1265,43 @@ fn parse_alt_expr(p: parser) -> @ast::expr {\n     }\n     let mut hi = p.span.hi;\n     p.bump();\n-    ret mk_expr(p, lo, hi, ast::expr_alt(discriminant, arms, mode));\n+    ret mk_expr(p, lo, hi, expr_alt(discriminant, arms, mode));\n }\n \n-fn parse_expr(p: parser) -> @ast::expr {\n+fn parse_expr(p: parser) -> @expr {\n     ret parse_expr_res(p, UNRESTRICTED);\n }\n \n-fn parse_expr_or_hole(p: parser) -> option<@ast::expr> {\n+fn parse_expr_or_hole(p: parser) -> option<@expr> {\n     alt p.token {\n       token::UNDERSCORE { p.bump(); ret none; }\n       _ { ret some(parse_expr(p)); }\n     }\n }\n \n-fn parse_expr_res(p: parser, r: restriction) -> @ast::expr {\n+fn parse_expr_res(p: parser, r: restriction) -> @expr {\n     let old = p.restriction;\n     p.restriction = r;\n     let e = parse_assign_expr(p);\n     p.restriction = old;\n     ret e;\n }\n \n-fn parse_initializer(p: parser) -> option<ast::initializer> {\n+fn parse_initializer(p: parser) -> option<initializer> {\n     alt p.token {\n       token::EQ {\n         p.bump();\n-        ret some({op: ast::init_assign, expr: parse_expr(p)});\n+        ret some({op: init_assign, expr: parse_expr(p)});\n       }\n       token::LARROW {\n         p.bump();\n-        ret some({op: ast::init_move, expr: parse_expr(p)});\n+        ret some({op: init_move, expr: parse_expr(p)});\n       }\n       // Now that the the channel is the first argument to receive,\n       // combining it with an initializer doesn't really make sense.\n       // case (token::RECV) {\n       //     p.bump();\n-      //     ret some(rec(op = ast::init_recv,\n+      //     ret some(rec(op = init_recv,\n       //                  expr = parse_expr(p)));\n       // }\n       _ {\n@@ -1310,30 +1310,30 @@ fn parse_initializer(p: parser) -> option<ast::initializer> {\n     }\n }\n \n-fn parse_pats(p: parser) -> [@ast::pat] {\n+fn parse_pats(p: parser) -> [@pat] {\n     let mut pats = [];\n     loop {\n         pats += [parse_pat(p)];\n         if p.token == token::BINOP(token::OR) { p.bump(); } else { ret pats; }\n     };\n }\n \n-fn parse_pat(p: parser) -> @ast::pat {\n+fn parse_pat(p: parser) -> @pat {\n     let lo = p.span.lo;\n     let mut hi = p.span.hi;\n     let mut pat;\n     alt p.token {\n-      token::UNDERSCORE { p.bump(); pat = ast::pat_wild; }\n+      token::UNDERSCORE { p.bump(); pat = pat_wild; }\n       token::AT {\n         p.bump();\n         let sub = parse_pat(p);\n-        pat = ast::pat_box(sub);\n+        pat = pat_box(sub);\n         hi = sub.span.hi;\n       }\n       token::TILDE {\n         p.bump();\n         let sub = parse_pat(p);\n-        pat = ast::pat_uniq(sub);\n+        pat = pat_uniq(sub);\n         hi = sub.span.hi;\n       }\n       token::LBRACE {\n@@ -1369,23 +1369,23 @@ fn parse_pat(p: parser) -> @ast::pat {\n                 subpat = parse_pat(p);\n             } else {\n                 subpat = @{id: p.get_id(),\n-                           node: ast::pat_ident(fieldpath, none),\n+                           node: pat_ident(fieldpath, none),\n                            span: mk_sp(lo, hi)};\n             }\n             fields += [{ident: fieldname, pat: subpat}];\n         }\n         hi = p.span.hi;\n         p.bump();\n-        pat = ast::pat_rec(fields, etc);\n+        pat = pat_rec(fields, etc);\n       }\n       token::LPAREN {\n         p.bump();\n         if p.token == token::RPAREN {\n             hi = p.span.hi;\n             p.bump();\n-            let lit = @{node: ast::lit_nil, span: mk_sp(lo, hi)};\n-            let expr = mk_expr(p, lo, hi, ast::expr_lit(lit));\n-            pat = ast::pat_lit(expr);\n+            let lit = @{node: lit_nil, span: mk_sp(lo, hi)};\n+            let expr = mk_expr(p, lo, hi, expr_lit(lit));\n+            pat = pat_lit(expr);\n         } else {\n             let mut fields = [parse_pat(p)];\n             while p.token == token::COMMA {\n@@ -1395,7 +1395,7 @@ fn parse_pat(p: parser) -> @ast::pat {\n             if vec::len(fields) == 1u { expect(p, token::COMMA); }\n             hi = p.span.hi;\n             expect(p, token::RPAREN);\n-            pat = ast::pat_tup(fields);\n+            pat = pat_tup(fields);\n         }\n       }\n       tok {\n@@ -1404,10 +1404,10 @@ fn parse_pat(p: parser) -> @ast::pat {\n             if eat_keyword(p, \"to\") {\n                 let end = parse_expr_res(p, RESTRICT_NO_BAR_OP);\n                 hi = end.span.hi;\n-                pat = ast::pat_range(val, end);\n+                pat = pat_range(val, end);\n             } else {\n                 hi = val.span.hi;\n-                pat = ast::pat_lit(val);\n+                pat = pat_lit(val);\n             }\n         } else if is_plain_ident(p.token) &&\n             alt p.look_ahead(1u) {\n@@ -1417,11 +1417,11 @@ fn parse_pat(p: parser) -> @ast::pat {\n             let name = parse_value_path(p);\n             let sub = if eat(p, token::AT) { some(parse_pat(p)) }\n                       else { none };\n-            pat = ast::pat_ident(name, sub);\n+            pat = pat_ident(name, sub);\n         } else {\n             let enum_path = parse_path_with_tps(p, true);\n             hi = enum_path.span.hi;\n-            let mut args: [@ast::pat] = [];\n+            let mut args: [@pat] = [];\n             let mut star_pat = false;\n             alt p.token {\n               token::LPAREN {\n@@ -1445,14 +1445,14 @@ fn parse_pat(p: parser) -> @ast::pat {\n             }\n             // at this point, we're not sure whether it's a enum or a bind\n             if star_pat {\n-                 pat = ast::pat_enum(enum_path, none);\n+                 pat = pat_enum(enum_path, none);\n             }\n             else if vec::is_empty(args) &&\n                vec::len(enum_path.idents) == 1u {\n-                pat = ast::pat_ident(enum_path, none);\n+                pat = pat_ident(enum_path, none);\n             }\n             else {\n-                pat = ast::pat_enum(enum_path, some(args));\n+                pat = pat_enum(enum_path, some(args));\n             }\n         }\n       }\n@@ -1461,11 +1461,11 @@ fn parse_pat(p: parser) -> @ast::pat {\n }\n \n fn parse_local(p: parser, is_mutbl: bool,\n-               allow_init: bool) -> @ast::local {\n+               allow_init: bool) -> @local {\n     let lo = p.span.lo;\n     let pat = parse_pat(p);\n     let mut ty = @{id: p.get_id(),\n-                   node: ast::ty_infer,\n+                   node: ty_infer,\n                    span: mk_sp(lo, lo)};\n     if eat(p, token::COLON) { ty = parse_ty(p, false); }\n     let init = if allow_init { parse_initializer(p) } else { none };\n@@ -1474,35 +1474,35 @@ fn parse_local(p: parser, is_mutbl: bool,\n                   init: init, id: p.get_id()});\n }\n \n-fn parse_let(p: parser) -> @ast::decl {\n+fn parse_let(p: parser) -> @decl {\n     let is_mutbl = eat_keyword(p, \"mut\");\n     let lo = p.span.lo;\n     let mut locals = [parse_local(p, is_mutbl, true)];\n     while eat(p, token::COMMA) {\n         locals += [parse_local(p, is_mutbl, true)];\n     }\n-    ret @spanned(lo, p.last_span.hi, ast::decl_local(locals));\n+    ret @spanned(lo, p.last_span.hi, decl_local(locals));\n }\n \n /* assumes \"let\" token has already been consumed */\n-fn parse_instance_var(p:parser, pr: ast::visibility) -> @ast::class_member {\n-    let mut is_mutbl = ast::class_immutable;\n+fn parse_instance_var(p:parser, pr: visibility) -> @class_member {\n+    let mut is_mutbl = class_immutable;\n     let lo = p.span.lo;\n     if eat_keyword(p, \"mut\") {\n-        is_mutbl = ast::class_mutable;\n+        is_mutbl = class_mutable;\n     }\n     if !is_plain_ident(p.token) {\n         p.fatal(\"expecting ident\");\n     }\n     let name = parse_ident(p);\n     expect(p, token::COLON);\n     let ty = parse_ty(p, false);\n-    ret @{node: ast::instance_var(name, ty, is_mutbl, p.get_id(), pr),\n+    ret @{node: instance_var(name, ty, is_mutbl, p.get_id(), pr),\n           span: mk_sp(lo, p.last_span.hi)};\n }\n \n-fn parse_stmt(p: parser, +first_item_attrs: [ast::attribute]) -> @ast::stmt {\n-    fn check_expected_item(p: parser, current_attrs: [ast::attribute]) {\n+fn parse_stmt(p: parser, +first_item_attrs: [attribute]) -> @stmt {\n+    fn check_expected_item(p: parser, current_attrs: [attribute]) {\n         // If we have attributes then we should have an item\n         if vec::is_not_empty(current_attrs) {\n             p.fatal(\"expected item\");\n@@ -1514,24 +1514,24 @@ fn parse_stmt(p: parser, +first_item_attrs: [ast::attribute]) -> @ast::stmt {\n         check_expected_item(p, first_item_attrs);\n         expect_keyword(p, \"let\");\n         let decl = parse_let(p);\n-        ret @spanned(lo, decl.span.hi, ast::stmt_decl(decl, p.get_id()));\n+        ret @spanned(lo, decl.span.hi, stmt_decl(decl, p.get_id()));\n     } else {\n         let mut item_attrs;\n         alt parse_outer_attrs_or_ext(p, first_item_attrs) {\n           none { item_attrs = []; }\n           some(left(attrs)) { item_attrs = attrs; }\n           some(right(ext)) {\n-            ret @spanned(lo, ext.span.hi, ast::stmt_expr(ext, p.get_id()));\n+            ret @spanned(lo, ext.span.hi, stmt_expr(ext, p.get_id()));\n           }\n         }\n \n         let item_attrs = first_item_attrs + item_attrs;\n \n-        alt parse_item(p, item_attrs, ast::public) {\n+        alt parse_item(p, item_attrs, public) {\n           some(i) {\n             let mut hi = i.span.hi;\n-            let decl = @spanned(lo, hi, ast::decl_item(i));\n-            ret @spanned(lo, hi, ast::stmt_decl(decl, p.get_id()));\n+            let decl = @spanned(lo, hi, decl_item(i));\n+            ret @spanned(lo, hi, stmt_decl(decl, p.get_id()));\n           }\n           none() { /* fallthrough */ }\n         }\n@@ -1540,7 +1540,7 @@ fn parse_stmt(p: parser, +first_item_attrs: [ast::attribute]) -> @ast::stmt {\n \n         // Remainder are line-expr stmts.\n         let e = parse_expr_res(p, RESTRICT_STMT_EXPR);\n-        ret @spanned(lo, e.span.hi, ast::stmt_expr(e, p.get_id()));\n+        ret @spanned(lo, e.span.hi, stmt_expr(e, p.get_id()));\n     }\n }\n \n@@ -1552,18 +1552,18 @@ fn expr_is_complete(p: parser, e: pexpr) -> bool {\n         !classify::expr_requires_semi_to_be_stmt(*e);\n }\n \n-fn parse_block(p: parser) -> ast::blk {\n+fn parse_block(p: parser) -> blk {\n     let (attrs, blk) = parse_inner_attrs_and_block(p, false);\n     assert vec::is_empty(attrs);\n     ret blk;\n }\n \n fn parse_inner_attrs_and_block(\n-    p: parser, parse_attrs: bool) -> ([ast::attribute], ast::blk) {\n+    p: parser, parse_attrs: bool) -> ([attribute], blk) {\n \n     fn maybe_parse_inner_attrs_and_next(\n         p: parser, parse_attrs: bool) ->\n-        {inner: [ast::attribute], next: [ast::attribute]} {\n+        {inner: [attribute], next: [attribute]} {\n         if parse_attrs {\n             parse_inner_attrs_and_next(p)\n         } else {\n@@ -1575,19 +1575,19 @@ fn parse_inner_attrs_and_block(\n     if eat_keyword(p, \"unchecked\") {\n         expect(p, token::LBRACE);\n         let {inner, next} = maybe_parse_inner_attrs_and_next(p, parse_attrs);\n-        ret (inner, parse_block_tail_(p, lo, ast::unchecked_blk, next));\n+        ret (inner, parse_block_tail_(p, lo, unchecked_blk, next));\n     } else if eat_keyword(p, \"unsafe\") {\n         expect(p, token::LBRACE);\n         let {inner, next} = maybe_parse_inner_attrs_and_next(p, parse_attrs);\n-        ret (inner, parse_block_tail_(p, lo, ast::unsafe_blk, next));\n+        ret (inner, parse_block_tail_(p, lo, unsafe_blk, next));\n     } else {\n         expect(p, token::LBRACE);\n         let {inner, next} = maybe_parse_inner_attrs_and_next(p, parse_attrs);\n-        ret (inner, parse_block_tail_(p, lo, ast::default_blk, next));\n+        ret (inner, parse_block_tail_(p, lo, default_blk, next));\n     }\n }\n \n-fn parse_block_no_value(p: parser) -> ast::blk {\n+fn parse_block_no_value(p: parser) -> blk {\n     // We parse blocks that cannot have a value the same as any other block;\n     // the type checker will make sure that the tail expression (if any) has\n     // unit type.\n@@ -1598,12 +1598,12 @@ fn parse_block_no_value(p: parser) -> ast::blk {\n // I guess that also means \"already parsed the 'impure'\" if\n // necessary, and this should take a qualifier.\n // some blocks start with \"#{\"...\n-fn parse_block_tail(p: parser, lo: uint, s: ast::blk_check_mode) -> ast::blk {\n+fn parse_block_tail(p: parser, lo: uint, s: blk_check_mode) -> blk {\n     parse_block_tail_(p, lo, s, [])\n }\n \n-fn parse_block_tail_(p: parser, lo: uint, s: ast::blk_check_mode,\n-                     +first_item_attrs: [ast::attribute]) -> ast::blk {\n+fn parse_block_tail_(p: parser, lo: uint, s: blk_check_mode,\n+                     +first_item_attrs: [attribute]) -> blk {\n     let mut stmts = [];\n     let mut expr = none;\n     let view_items = maybe_parse_view_import_only(p, first_item_attrs);\n@@ -1622,11 +1622,11 @@ fn parse_block_tail_(p: parser, lo: uint, s: ast::blk_check_mode,\n             let stmt = parse_stmt(p, initial_attrs);\n             initial_attrs = [];\n             alt stmt.node {\n-              ast::stmt_expr(e, stmt_id) { // Expression without semicolon:\n+              stmt_expr(e, stmt_id) { // Expression without semicolon:\n                 alt p.token {\n                   token::SEMI {\n                     p.bump();\n-                    stmts += [@{node: ast::stmt_semi(e, stmt_id) with *stmt}];\n+                    stmts += [@{node: stmt_semi(e, stmt_id) with *stmt}];\n                   }\n                   token::RBRACE {\n                     expr = some(e);\n@@ -1660,27 +1660,27 @@ fn parse_block_tail_(p: parser, lo: uint, s: ast::blk_check_mode,\n     ret spanned(lo, hi, bloc);\n }\n \n-fn parse_ty_param(p: parser) -> ast::ty_param {\n+fn parse_ty_param(p: parser) -> ty_param {\n     let mut bounds = [];\n     let ident = parse_ident(p);\n     if eat(p, token::COLON) {\n         while p.token != token::COMMA && p.token != token::GT {\n-            if eat_keyword(p, \"send\") { bounds += [ast::bound_send]; }\n-            else if eat_keyword(p, \"copy\") { bounds += [ast::bound_copy]; }\n-            else { bounds += [ast::bound_iface(parse_ty(p, false))]; }\n+            if eat_keyword(p, \"send\") { bounds += [bound_send]; }\n+            else if eat_keyword(p, \"copy\") { bounds += [bound_copy]; }\n+            else { bounds += [bound_iface(parse_ty(p, false))]; }\n         }\n     }\n     ret {ident: ident, id: p.get_id(), bounds: @bounds};\n }\n \n-fn parse_ty_params(p: parser) -> [ast::ty_param] {\n+fn parse_ty_params(p: parser) -> [ty_param] {\n     if eat(p, token::LT) {\n         parse_seq_to_gt(some(token::COMMA), parse_ty_param, p)\n     } else { [] }\n }\n \n // FIXME Remove after snapshot\n-fn parse_old_skool_capture_clause(p: parser) -> [ast::capture_item] {\n+fn parse_old_skool_capture_clause(p: parser) -> [capture_item] {\n     fn expect_opt_trailing_semi(p: parser) {\n         if !eat(p, token::SEMI) {\n             if p.token != token::RBRACKET {\n@@ -1689,7 +1689,7 @@ fn parse_old_skool_capture_clause(p: parser) -> [ast::capture_item] {\n         }\n     }\n \n-    fn eat_ident_list(p: parser, is_move: bool) -> [ast::capture_item] {\n+    fn eat_ident_list(p: parser, is_move: bool) -> [capture_item] {\n         let mut res = [];\n         loop {\n             alt p.token {\n@@ -1728,12 +1728,12 @@ fn parse_old_skool_capture_clause(p: parser) -> [ast::capture_item] {\n     ret cap_items;\n }\n \n-type arg_or_capture_item = either<ast::arg, ast::capture_item>;\n+type arg_or_capture_item = either<arg, capture_item>;\n \n \n-fn parse_fn_decl(p: parser, purity: ast::purity,\n+fn parse_fn_decl(p: parser, purity: purity,\n                  parse_arg_fn: fn(parser) -> arg_or_capture_item)\n-    -> (ast::fn_decl, ast::capture_clause) {\n+    -> (fn_decl, capture_clause) {\n \n     let args_or_capture_items: [arg_or_capture_item] =\n         parse_seq(token::LPAREN, token::RPAREN, seq_sep(token::COMMA),\n@@ -1758,7 +1758,7 @@ fn parse_fn_decl(p: parser, purity: ast::purity,\n           constraints: constrs}, capture_clause);\n }\n \n-fn parse_fn_block_decl(p: parser) -> (ast::fn_decl, ast::capture_clause) {\n+fn parse_fn_block_decl(p: parser) -> (fn_decl, capture_clause) {\n     let inputs_captures = {\n         if eat(p, token::OROR) {\n             []\n@@ -1772,25 +1772,25 @@ fn parse_fn_block_decl(p: parser) -> (ast::fn_decl, ast::capture_clause) {\n     let output = if eat(p, token::RARROW) {\n                      parse_ty(p, false)\n                  } else {\n-                     @{id: p.get_id(), node: ast::ty_infer, span: p.span}\n+                     @{id: p.get_id(), node: ty_infer, span: p.span}\n                  };\n     ret ({inputs: either::lefts(inputs_captures),\n           output: output,\n-          purity: ast::impure_fn,\n-          cf: ast::return_val,\n+          purity: impure_fn,\n+          cf: return_val,\n           constraints: []},\n          @either::rights(inputs_captures));\n }\n \n-fn parse_fn_header(p: parser) -> {ident: ast::ident, tps: [ast::ty_param]} {\n+fn parse_fn_header(p: parser) -> {ident: ident, tps: [ty_param]} {\n     let id = parse_value_ident(p);\n     let ty_params = parse_ty_params(p);\n     ret {ident: id, tps: ty_params};\n }\n \n-fn mk_item(p: parser, lo: uint, hi: uint, +ident: ast::ident,\n-           +node: ast::item_, vis: ast::visibility,\n-           +attrs: [ast::attribute]) -> @ast::item {\n+fn mk_item(p: parser, lo: uint, hi: uint, +ident: ident,\n+           +node: item_, vis: visibility,\n+           +attrs: [attribute]) -> @item {\n     ret @{ident: ident,\n           attrs: attrs,\n           id: p.get_id(),\n@@ -1799,16 +1799,16 @@ fn mk_item(p: parser, lo: uint, hi: uint, +ident: ast::ident,\n           span: mk_sp(lo, hi)};\n }\n \n-type item_info = (ast::ident, ast::item_, option<[ast::attribute]>);\n+type item_info = (ident, item_, option<[attribute]>);\n \n-fn parse_item_fn(p: parser, purity: ast::purity) -> item_info {\n+fn parse_item_fn(p: parser, purity: purity) -> item_info {\n     let t = parse_fn_header(p);\n     let (decl, _) = parse_fn_decl(p, purity, parse_arg);\n     let (inner_attrs, body) = parse_inner_attrs_and_block(p, true);\n-    (t.ident, ast::item_fn(decl, t.tps, body), some(inner_attrs))\n+    (t.ident, item_fn(decl, t.tps, body), some(inner_attrs))\n }\n \n-fn parse_method_name(p: parser) -> ast::ident {\n+fn parse_method_name(p: parser) -> ident {\n     alt p.token {\n       token::BINOP(op) { p.bump(); token::binop_to_str(op) }\n       token::NOT { p.bump(); \"!\" }\n@@ -1821,7 +1821,7 @@ fn parse_method_name(p: parser) -> ast::ident {\n     }\n }\n \n-fn parse_method(p: parser, pr: ast::visibility) -> @ast::method {\n+fn parse_method(p: parser, pr: visibility) -> @method {\n     let attrs = parse_outer_attributes(p);\n     let lo = p.span.lo, pur = parse_fn_purity(p);\n     let ident = parse_method_name(p);\n@@ -1839,25 +1839,25 @@ fn parse_item_iface(p: parser) -> item_info {\n     let rp = parse_region_param(p);\n     let tps = parse_ty_params(p);\n     let meths = parse_ty_methods(p);\n-    (ident, ast::item_iface(tps, rp, meths), none)\n+    (ident, item_iface(tps, rp, meths), none)\n }\n \n // Parses three variants (with the region/type params always optional):\n //    impl /&<T: copy> of to_str for [T] { ... }\n //    impl name/&<T> of to_str for [T] { ... }\n //    impl name/&<T> for [T] { ... }\n fn parse_item_impl(p: parser) -> item_info {\n-    fn wrap_path(p: parser, pt: @ast::path) -> @ast::ty {\n-        @{id: p.get_id(), node: ast::ty_path(pt, p.get_id()), span: pt.span}\n+    fn wrap_path(p: parser, pt: @path) -> @ty {\n+        @{id: p.get_id(), node: ty_path(pt, p.get_id()), span: pt.span}\n     }\n     let mut (ident, rp, tps) = {\n         if p.token == token::LT {\n-            (none, ast::rp_none, parse_ty_params(p))\n+            (none, rp_none, parse_ty_params(p))\n         } else if p.token == token::BINOP(token::SLASH) {\n             (none, parse_region_param(p), parse_ty_params(p))\n         }\n         else if is_keyword(p, \"of\") {\n-            (none, ast::rp_none, [])\n+            (none, rp_none, [])\n         } else {\n             let id = parse_ident(p);\n             let rp = parse_region_param(p);\n@@ -1879,8 +1879,8 @@ fn parse_item_impl(p: parser) -> item_info {\n     let ty = parse_ty(p, false);\n     let mut meths = [];\n     expect(p, token::LBRACE);\n-    while !eat(p, token::RBRACE) { meths += [parse_method(p, ast::public)]; }\n-    (ident, ast::item_impl(tps, rp, ifce, ty, meths), none)\n+    while !eat(p, token::RBRACE) { meths += [parse_method(p, public)]; }\n+    (ident, item_impl(tps, rp, ifce, ty, meths), none)\n }\n \n fn parse_item_res(p: parser) -> item_info {\n@@ -1894,47 +1894,47 @@ fn parse_item_res(p: parser) -> item_info {\n     expect(p, token::RPAREN);\n     let dtor = parse_block_no_value(p);\n     let decl = {\n-        inputs: [{mode: ast::expl(ast::by_ref), ty: t,\n+        inputs: [{mode: expl(by_ref), ty: t,\n                   ident: arg_ident, id: p.get_id()}],\n-        output: @{id: p.get_id(), node: ast::ty_nil,\n+        output: @{id: p.get_id(), node: ty_nil,\n                   span: ast_util::dummy_sp()},\n-        purity: ast::impure_fn,\n-        cf: ast::return_val,\n+        purity: impure_fn,\n+        cf: return_val,\n         constraints: []\n     };\n-    (ident, ast::item_res(decl, ty_params, dtor,\n+    (ident, item_res(decl, ty_params, dtor,\n                           p.get_id(), p.get_id(), rp), none)\n }\n \n // Instantiates ident <i> with references to <typarams> as arguments.  Used to\n // create a path that refers to a class which will be defined as the return\n // type of the ctor function.\n-fn ident_to_path_tys(p: parser, i: ast::ident,\n-                     rp: ast::region_param,\n-                     typarams: [ast::ty_param]) -> @ast::path {\n+fn ident_to_path_tys(p: parser, i: ident,\n+                     rp: region_param,\n+                     typarams: [ty_param]) -> @path {\n     let s = p.last_span;\n \n     // Hack.  But then, this whole function is in service of a hack.\n     let a_r = alt rp {\n-      ast::rp_none { none }\n-      ast::rp_self { some(region_from_name(p, some(\"self\"))) }\n+      rp_none { none }\n+      rp_self { some(region_from_name(p, some(\"self\"))) }\n     };\n \n     @{span: s, global: false, idents: [i],\n       rp: a_r,\n       types: vec::map(typarams, {|tp|\n           @{id: p.get_id(),\n-            node: ast::ty_path(ident_to_path(s, tp.ident), p.get_id()),\n+            node: ty_path(ident_to_path(s, tp.ident), p.get_id()),\n             span: s}})\n      }\n }\n \n-fn parse_iface_ref(p:parser) -> @ast::iface_ref {\n+fn parse_iface_ref(p:parser) -> @iface_ref {\n     @{path: parse_path_with_tps(p, false),\n       id: p.get_id()}\n }\n \n-fn parse_iface_ref_list(p:parser) -> [@ast::iface_ref] {\n+fn parse_iface_ref_list(p:parser) -> [@iface_ref] {\n     parse_seq_to_before_end(token::LBRACE, seq_sep(token::COMMA),\n                             parse_iface_ref, p)\n }\n@@ -1944,13 +1944,13 @@ fn parse_item_class(p: parser) -> item_info {\n     let rp = parse_region_param(p);\n     let ty_params = parse_ty_params(p);\n     let class_path = ident_to_path_tys(p, class_name, rp, ty_params);\n-    let ifaces : [@ast::iface_ref] = if eat_keyword(p, \"implements\")\n+    let ifaces : [@iface_ref] = if eat_keyword(p, \"implements\")\n                                        { parse_iface_ref_list(p) }\n                                     else { [] };\n     expect(p, token::LBRACE);\n-    let mut ms: [@ast::class_member] = [];\n+    let mut ms: [@class_member] = [];\n     let ctor_id = p.get_id();\n-    let mut the_ctor : option<(ast::fn_decl, ast::blk, codemap::span)> = none;\n+    let mut the_ctor : option<(fn_decl, blk, codemap::span)> = none;\n     while p.token != token::RBRACE {\n         alt parse_class_item(p, class_path) {\n             ctor_decl(a_fn_decl, blk, s) {\n@@ -1963,7 +1963,7 @@ fn parse_item_class(p: parser) -> item_info {\n     alt the_ctor {\n       some((ct_d, ct_b, ct_s)) {\n         (class_name,\n-         ast::item_class(ty_params, ifaces, ms, {\n+         item_class(ty_params, ifaces, ms, {\n              node: {id: ctor_id,\n                     self_id: p.get_id(),\n                     dec: ct_d,\n@@ -1980,33 +1980,33 @@ fn parse_item_class(p: parser) -> item_info {\n     }\n }\n \n-fn parse_single_class_item(p: parser, vis: ast::visibility)\n-    -> @ast::class_member {\n+fn parse_single_class_item(p: parser, vis: visibility)\n+    -> @class_member {\n    if eat_keyword(p, \"let\") {\n       let a_var = parse_instance_var(p, vis);\n       expect(p, token::SEMI);\n       ret a_var;\n    }\n    else {\n        let m = parse_method(p, vis);\n-       ret @{node: ast::class_method(m), span: m.span};\n+       ret @{node: class_method(m), span: m.span};\n    }\n }\n \n // lets us identify the constructor declaration at\n // parse time\n-enum class_contents { ctor_decl(ast::fn_decl, ast::blk, codemap::span),\n-                      members([@ast::class_member]) }\n+enum class_contents { ctor_decl(fn_decl, blk, codemap::span),\n+                      members([@class_member]) }\n \n-fn parse_class_item(p:parser, class_name_with_tps: @ast::path)\n+fn parse_class_item(p:parser, class_name_with_tps: @path)\n     -> class_contents {\n     if eat_keyword(p, \"new\") {\n         let lo = p.last_span.lo;\n         // Can ctors have attrs?\n             // result type is always the type of the class\n-        let (decl_, _) = parse_fn_decl(p, ast::impure_fn, parse_arg);\n+        let (decl_, _) = parse_fn_decl(p, impure_fn, parse_arg);\n         let decl = {output: @{id: p.get_id(),\n-                      node: ast::ty_path(class_name_with_tps, p.get_id()),\n+                      node: ty_path(class_name_with_tps, p.get_id()),\n                       span: decl_.output.span}\n                     with decl_};\n         let body = parse_block(p);\n@@ -2016,34 +2016,34 @@ fn parse_class_item(p:parser, class_name_with_tps: @ast::path)\n             expect(p, token::LBRACE);\n             let mut results = [];\n             while p.token != token::RBRACE {\n-                    results += [parse_single_class_item(p, ast::private)];\n+                    results += [parse_single_class_item(p, private)];\n             }\n             p.bump();\n             ret members(results);\n     }\n     else {\n         // Probably need to parse attrs\n-        ret members([parse_single_class_item(p, ast::public)]);\n+        ret members([parse_single_class_item(p, public)]);\n     }\n }\n \n-fn parse_visibility(p: parser, def: ast::visibility) -> ast::visibility {\n-    if eat_keyword(p, \"pub\") { ast::public }\n-    else if eat_keyword(p, \"priv\") { ast::private }\n+fn parse_visibility(p: parser, def: visibility) -> visibility {\n+    if eat_keyword(p, \"pub\") { public }\n+    else if eat_keyword(p, \"priv\") { private }\n     else { def }\n }\n \n fn parse_mod_items(p: parser, term: token::token,\n-                   +first_item_attrs: [ast::attribute]) -> ast::_mod {\n+                   +first_item_attrs: [attribute]) -> _mod {\n     // Shouldn't be any view items since we've already parsed an item attr\n     let view_items = maybe_parse_view(p, first_item_attrs);\n-    let mut items: [@ast::item] = [];\n+    let mut items: [@item] = [];\n     let mut first = true;\n     while p.token != term {\n         let mut attrs = parse_outer_attributes(p);\n         if first { attrs = first_item_attrs + attrs; first = false; }\n         #debug[\"parse_mod_items: parse_item(attrs=%?)\", attrs];\n-        let vis = parse_visibility(p, ast::private);\n+        let vis = parse_visibility(p, private);\n         alt parse_item(p, attrs, vis) {\n           some(i) { items += [i]; }\n           _ {\n@@ -2069,7 +2069,7 @@ fn parse_item_const(p: parser) -> item_info {\n     expect(p, token::EQ);\n     let e = parse_expr(p);\n     expect(p, token::SEMI);\n-    (id, ast::item_const(ty, e), none)\n+    (id, item_const(ty, e), none)\n }\n \n fn parse_item_mod(p: parser) -> item_info {\n@@ -2078,46 +2078,46 @@ fn parse_item_mod(p: parser) -> item_info {\n     let inner_attrs = parse_inner_attrs_and_next(p);\n     let m = parse_mod_items(p, token::RBRACE, inner_attrs.next);\n     expect(p, token::RBRACE);\n-    (id, ast::item_mod(m), some(inner_attrs.inner))\n+    (id, item_mod(m), some(inner_attrs.inner))\n }\n \n-fn parse_item_native_fn(p: parser, +attrs: [ast::attribute],\n-                        purity: ast::purity) -> @ast::native_item {\n+fn parse_item_native_fn(p: parser, +attrs: [attribute],\n+                        purity: purity) -> @native_item {\n     let lo = p.last_span.lo;\n     let t = parse_fn_header(p);\n     let (decl, _) = parse_fn_decl(p, purity, parse_arg);\n     let mut hi = p.span.hi;\n     expect(p, token::SEMI);\n     ret @{ident: t.ident,\n           attrs: attrs,\n-          node: ast::native_item_fn(decl, t.tps),\n+          node: native_item_fn(decl, t.tps),\n           id: p.get_id(),\n           span: mk_sp(lo, hi)};\n }\n \n-fn parse_fn_purity(p: parser) -> ast::purity {\n-    if eat_keyword(p, \"fn\") { ast::impure_fn }\n-    else if eat_keyword(p, \"pure\") { expect_keyword(p, \"fn\"); ast::pure_fn }\n+fn parse_fn_purity(p: parser) -> purity {\n+    if eat_keyword(p, \"fn\") { impure_fn }\n+    else if eat_keyword(p, \"pure\") { expect_keyword(p, \"fn\"); pure_fn }\n     else if eat_keyword(p, \"unsafe\") {\n         expect_keyword(p, \"fn\");\n-        ast::unsafe_fn\n+        unsafe_fn\n     }\n     else { unexpected(p); }\n }\n \n-fn parse_native_item(p: parser, +attrs: [ast::attribute]) ->\n-   @ast::native_item {\n+fn parse_native_item(p: parser, +attrs: [attribute]) ->\n+   @native_item {\n     parse_item_native_fn(p, attrs, parse_fn_purity(p))\n }\n \n-fn parse_native_mod_items(p: parser, +first_item_attrs: [ast::attribute]) ->\n-   ast::native_mod {\n+fn parse_native_mod_items(p: parser, +first_item_attrs: [attribute]) ->\n+   native_mod {\n     // Shouldn't be any view items since we've already parsed an item attr\n     let view_items =\n         if vec::len(first_item_attrs) == 0u {\n             parse_native_view(p)\n         } else { [] };\n-    let mut items: [@ast::native_item] = [];\n+    let mut items: [@native_item] = [];\n     let mut initial_attrs = first_item_attrs;\n     while p.token != token::RBRACE {\n         let attrs = initial_attrs + parse_outer_attributes(p);\n@@ -2135,10 +2135,10 @@ fn parse_item_native_mod(p: parser) -> item_info {\n     let more_attrs = parse_inner_attrs_and_next(p);\n     let m = parse_native_mod_items(p, more_attrs.next);\n     expect(p, token::RBRACE);\n-    (id, ast::item_native_mod(m), some(more_attrs.inner))\n+    (id, item_native_mod(m), some(more_attrs.inner))\n }\n \n-fn parse_type_decl(p: parser) -> {lo: uint, ident: ast::ident} {\n+fn parse_type_decl(p: parser) -> {lo: uint, ident: ident} {\n     let lo = p.last_span.lo;\n     let id = parse_ident(p);\n     ret {lo: lo, ident: id};\n@@ -2151,23 +2151,23 @@ fn parse_item_type(p: parser) -> item_info {\n     expect(p, token::EQ);\n     let ty = parse_ty(p, false);\n     expect(p, token::SEMI);\n-    (t.ident, ast::item_ty(ty, tps, rp), none)\n+    (t.ident, item_ty(ty, tps, rp), none)\n }\n \n-fn parse_region_param(p: parser) -> ast::region_param {\n+fn parse_region_param(p: parser) -> region_param {\n     if eat(p, token::BINOP(token::SLASH)) {\n         expect(p, token::BINOP(token::AND));\n-        ast::rp_self\n+        rp_self\n     } else {\n-        ast::rp_none\n+        rp_none\n     }\n }\n \n-fn parse_item_enum(p: parser, default_vis: ast::visibility) -> item_info {\n+fn parse_item_enum(p: parser, default_vis: visibility) -> item_info {\n     let id = parse_ident(p);\n     let rp = parse_region_param(p);\n     let ty_params = parse_ty_params(p);\n-    let mut variants: [ast::variant] = [];\n+    let mut variants: [variant] = [];\n     // Newtype syntax\n     if p.token == token::EQ {\n         check_restricted_keywords_(p, id);\n@@ -2181,8 +2181,8 @@ fn parse_item_enum(p: parser, default_vis: ast::visibility) -> item_info {\n                      args: [{ty: ty, id: p.get_id()}],\n                      id: p.get_id(),\n                      disr_expr: none,\n-                     vis: ast::public});\n-        ret (id, ast::item_enum([variant], ty_params, rp), none);\n+                     vis: public});\n+        ret (id, item_enum([variant], ty_params, rp), none);\n     }\n     expect(p, token::LBRACE);\n \n@@ -2218,25 +2218,25 @@ fn parse_item_enum(p: parser, default_vis: ast::visibility) -> item_info {\n     if (have_disr && !all_nullary) {\n         p.fatal(\"discriminator values can only be used with a c-like enum\");\n     }\n-    (id, ast::item_enum(variants, ty_params, rp), none)\n+    (id, item_enum(variants, ty_params, rp), none)\n }\n \n-fn parse_fn_ty_proto(p: parser) -> ast::proto {\n+fn parse_fn_ty_proto(p: parser) -> proto {\n     alt p.token {\n       token::AT {\n         p.bump();\n-        ast::proto_box\n+        proto_box\n       }\n       token::TILDE {\n         p.bump();\n-        ast::proto_uniq\n+        proto_uniq\n       }\n       token::BINOP(token::AND) {\n         p.bump();\n-        ast::proto_block\n+        proto_block\n       }\n       _ {\n-        ast::proto_any\n+        proto_any\n       }\n     }\n }\n@@ -2252,24 +2252,24 @@ fn fn_expr_lookahead(tok: token::token) -> bool {\n     }\n }\n \n-fn parse_item(p: parser, +attrs: [ast::attribute], vis: ast::visibility)\n-    -> option<@ast::item> {\n+fn parse_item(p: parser, +attrs: [attribute], vis: visibility)\n+    -> option<@item> {\n     let lo = p.span.lo;\n     let (ident, item_, extra_attrs) = if eat_keyword(p, \"const\") {\n         parse_item_const(p)\n     } else if is_keyword(p, \"fn\") && !fn_expr_lookahead(p.look_ahead(1u)) {\n         p.bump();\n-        parse_item_fn(p, ast::impure_fn)\n+        parse_item_fn(p, impure_fn)\n     } else if eat_keyword(p, \"pure\") {\n         expect_keyword(p, \"fn\");\n-        parse_item_fn(p, ast::pure_fn)\n+        parse_item_fn(p, pure_fn)\n     } else if is_keyword(p, \"unsafe\") && p.look_ahead(1u) != token::LBRACE {\n         p.bump();\n         expect_keyword(p, \"fn\");\n-        parse_item_fn(p, ast::unsafe_fn)\n+        parse_item_fn(p, unsafe_fn)\n     } else if eat_keyword(p, \"crust\") {\n         expect_keyword(p, \"fn\");\n-        parse_item_fn(p, ast::crust_fn)\n+        parse_item_fn(p, crust_fn)\n     } else if eat_keyword(p, \"mod\") {\n         parse_item_mod(p)\n     } else if eat_keyword(p, \"native\") {\n@@ -2294,13 +2294,13 @@ fn parse_item(p: parser, +attrs: [ast::attribute], vis: ast::visibility)\n                  }))\n }\n \n-fn parse_use(p: parser) -> ast::view_item_ {\n+fn parse_use(p: parser) -> view_item_ {\n     let ident = parse_ident(p);\n     let metadata = parse_optional_meta(p);\n-    ret ast::view_item_use(ident, metadata, p.get_id());\n+    ret view_item_use(ident, metadata, p.get_id());\n }\n \n-fn parse_view_path(p: parser) -> @ast::view_path {\n+fn parse_view_path(p: parser) -> @view_path {\n     let lo = p.span.lo;\n     let first_ident = parse_ident(p);\n     let mut path = [first_ident];\n@@ -2318,7 +2318,7 @@ fn parse_view_path(p: parser) -> @ast::view_path {\n         let path = @{span: mk_sp(lo, p.span.hi), global: false,\n                      idents: path, rp: none, types: []};\n         ret @spanned(lo, p.span.hi,\n-                     ast::view_path_simple(first_ident, path, p.get_id()));\n+                     view_path_simple(first_ident, path, p.get_id()));\n       }\n \n       token::MOD_SEP {\n@@ -2343,7 +2343,7 @@ fn parse_view_path(p: parser) -> @ast::view_path {\n                              global: false, idents: path,\n                              rp: none, types: []};\n                 ret @spanned(lo, p.span.hi,\n-                             ast::view_path_list(path, idents, p.get_id()));\n+                             view_path_list(path, idents, p.get_id()));\n               }\n \n               // foo::bar::*\n@@ -2353,7 +2353,7 @@ fn parse_view_path(p: parser) -> @ast::view_path {\n                              global: false, idents: path,\n                              rp: none, types: []};\n                 ret @spanned(lo, p.span.hi,\n-                             ast::view_path_glob(path, p.get_id()));\n+                             view_path_glob(path, p.get_id()));\n               }\n \n               _ { break; }\n@@ -2366,10 +2366,10 @@ fn parse_view_path(p: parser) -> @ast::view_path {\n     let path = @{span: mk_sp(lo, p.span.hi), global: false,\n                  idents: path, rp: none, types: []};\n     ret @spanned(lo, p.span.hi,\n-                 ast::view_path_simple(last, path, p.get_id()));\n+                 view_path_simple(last, path, p.get_id()));\n }\n \n-fn parse_view_paths(p: parser) -> [@ast::view_path] {\n+fn parse_view_paths(p: parser) -> [@view_path] {\n     let mut vp = [parse_view_path(p)];\n     while p.token == token::COMMA {\n         p.bump();\n@@ -2378,15 +2378,15 @@ fn parse_view_paths(p: parser) -> [@ast::view_path] {\n     ret vp;\n }\n \n-fn parse_view_item(p: parser) -> @ast::view_item {\n+fn parse_view_item(p: parser) -> @view_item {\n     let lo = p.span.lo;\n     let the_item =\n         if eat_keyword(p, \"use\") {\n             parse_use(p)\n         } else if eat_keyword(p, \"import\") {\n-            ast::view_item_import(parse_view_paths(p))\n+            view_item_import(parse_view_paths(p))\n         } else if eat_keyword(p, \"export\") {\n-            ast::view_item_export(parse_view_paths(p))\n+            view_item_export(parse_view_paths(p))\n         } else {\n             fail\n     };\n@@ -2401,22 +2401,22 @@ fn is_view_item(p: parser) -> bool {\n \n fn maybe_parse_view(\n     p: parser,\n-    first_item_attrs: [ast::attribute]) -> [@ast::view_item] {\n+    first_item_attrs: [attribute]) -> [@view_item] {\n \n     maybe_parse_view_while(p, first_item_attrs, is_view_item)\n }\n \n fn maybe_parse_view_import_only(\n     p: parser,\n-    first_item_attrs: [ast::attribute]) -> [@ast::view_item] {\n+    first_item_attrs: [attribute]) -> [@view_item] {\n \n     maybe_parse_view_while(p, first_item_attrs, bind is_keyword(_, \"import\"))\n }\n \n fn maybe_parse_view_while(\n     p: parser,\n-    first_item_attrs: [ast::attribute],\n-    f: fn@(parser) -> bool) -> [@ast::view_item] {\n+    first_item_attrs: [attribute],\n+    f: fn@(parser) -> bool) -> [@view_item] {\n \n     if vec::len(first_item_attrs) == 0u {\n         let mut items = [];\n@@ -2428,12 +2428,12 @@ fn maybe_parse_view_while(\n     }\n }\n \n-fn parse_native_view(p: parser) -> [@ast::view_item] {\n+fn parse_native_view(p: parser) -> [@view_item] {\n     maybe_parse_view_while(p, [], is_view_item)\n }\n \n // Parses a source module as a crate\n-fn parse_crate_mod(p: parser, _cfg: ast::crate_cfg) -> @ast::crate {\n+fn parse_crate_mod(p: parser, _cfg: crate_cfg) -> @crate {\n     let lo = p.span.lo;\n     let crate_attrs = parse_inner_attrs_and_next(p);\n     let first_item_outer_attrs = crate_attrs.next;\n@@ -2459,8 +2459,8 @@ fn parse_str(p: parser) -> str {\n // Each crate file is a sequence of directives.\n //\n // Each directive imperatively extends its environment with 0 or more items.\n-fn parse_crate_directive(p: parser, first_outer_attr: [ast::attribute]) ->\n-   ast::crate_directive {\n+fn parse_crate_directive(p: parser, first_outer_attr: [attribute]) ->\n+   crate_directive {\n \n     // Collect the next attributes\n     let outer_attrs = first_outer_attr + parse_outer_attributes(p);\n@@ -2476,7 +2476,7 @@ fn parse_crate_directive(p: parser, first_outer_attr: [ast::attribute]) ->\n           token::SEMI {\n             let mut hi = p.span.hi;\n             p.bump();\n-            ret spanned(lo, hi, ast::cdir_src_mod(id, outer_attrs));\n+            ret spanned(lo, hi, cdir_src_mod(id, outer_attrs));\n           }\n           // mod x = \"foo_dir\" { ...directives... }\n           token::LBRACE {\n@@ -2489,19 +2489,19 @@ fn parse_crate_directive(p: parser, first_outer_attr: [ast::attribute]) ->\n             let mut hi = p.span.hi;\n             expect(p, token::RBRACE);\n             ret spanned(lo, hi,\n-                        ast::cdir_dir_mod(id, cdirs, mod_attrs));\n+                        cdir_dir_mod(id, cdirs, mod_attrs));\n           }\n           _ { unexpected(p); }\n         }\n     } else if is_view_item(p) {\n         let vi = parse_view_item(p);\n-        ret spanned(lo, vi.span.hi, ast::cdir_view_item(vi));\n+        ret spanned(lo, vi.span.hi, cdir_view_item(vi));\n     } else { ret p.fatal(\"expected crate directive\"); }\n }\n \n fn parse_crate_directives(p: parser, term: token::token,\n-                          first_outer_attr: [ast::attribute]) ->\n-   [@ast::crate_directive] {\n+                          first_outer_attr: [attribute]) ->\n+   [@crate_directive] {\n \n     // This is pretty ugly. If we have an outer attribute then we can't accept\n     // seeing the terminator next, so if we do see it then fail the same way\n@@ -2510,7 +2510,7 @@ fn parse_crate_directives(p: parser, term: token::token,\n         expect_keyword(p, \"mod\");\n     }\n \n-    let mut cdirs: [@ast::crate_directive] = [];\n+    let mut cdirs: [@crate_directive] = [];\n     let mut first_outer_attr = first_outer_attr;\n     while p.token != term {\n         let cdir = @parse_crate_directive(p, first_outer_attr);"}]}