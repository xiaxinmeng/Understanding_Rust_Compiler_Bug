{"sha": "c6d0b5bdd81a2b87351afb587e02c557e9e6355e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2ZDBiNWJkZDgxYTJiODczNTFhZmI1ODdlMDJjNTU3ZTllNjM1NWU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-05-12T12:00:36Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-05-28T07:43:24Z"}, "message": "address review comments", "tree": {"sha": "53396a59ecc04e5f1597b1e8cb1f17715b046338", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53396a59ecc04e5f1597b1e8cb1f17715b046338"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6d0b5bdd81a2b87351afb587e02c557e9e6355e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6d0b5bdd81a2b87351afb587e02c557e9e6355e", "html_url": "https://github.com/rust-lang/rust/commit/c6d0b5bdd81a2b87351afb587e02c557e9e6355e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6d0b5bdd81a2b87351afb587e02c557e9e6355e/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24c1a07c729911997397b47c7fbc3fa0a657a3aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/24c1a07c729911997397b47c7fbc3fa0a657a3aa", "html_url": "https://github.com/rust-lang/rust/commit/24c1a07c729911997397b47c7fbc3fa0a657a3aa"}], "stats": {"total": 265, "additions": 138, "deletions": 127}, "files": [{"sha": "d69494206c50503693a564ffcffdc0bbb0bb1ddf", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6d0b5bdd81a2b87351afb587e02c557e9e6355e/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d0b5bdd81a2b87351afb587e02c557e9e6355e/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=c6d0b5bdd81a2b87351afb587e02c557e9e6355e", "patch": "@@ -585,7 +585,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn const_usize(&self, val: usize) -> ConstInt {\n+    pub fn const_usize(&self, val: u16) -> ConstInt {\n         match self.sess.target.uint_type {\n             ast::UintTy::U16 => ConstInt::Usize(ConstUsize::Us16(val as u16)),\n             ast::UintTy::U32 => ConstInt::Usize(ConstUsize::Us32(val as u32)),"}, {"sha": "b03d34819f6374ce58985c1a50d9a22df141b6f7", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c6d0b5bdd81a2b87351afb587e02c557e9e6355e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d0b5bdd81a2b87351afb587e02c557e9e6355e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=c6d0b5bdd81a2b87351afb587e02c557e9e6355e", "patch": "@@ -22,7 +22,7 @@ use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_mir::util::patch::MirPatch;\n-use rustc_mir::util::elaborate_drops::{DropFlagState, elaborate_drop};\n+use rustc_mir::util::elaborate_drops::{DropFlagState, Unwind, elaborate_drop};\n use rustc_mir::util::elaborate_drops::{DropElaborator, DropStyle, DropFlagMode};\n use syntax::ast;\n use syntax_pos::Span;\n@@ -399,14 +399,13 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                                     ctxt: self\n                                 },\n                                 terminator.source_info,\n-                                data.is_cleanup,\n                                 location,\n                                 path,\n                                 target,\n                                 if data.is_cleanup {\n-                                    None\n+                                    Unwind::InCleanup\n                                 } else {\n-                                    Some(Option::unwrap_or(unwind, resume_block))\n+                                    Unwind::To(Option::unwrap_or(unwind, resume_block))\n                                 },\n                                 bb)\n                         }\n@@ -455,6 +454,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         let bb = loc.block;\n         let data = &self.mir[bb];\n         let terminator = data.terminator();\n+        assert!(!data.is_cleanup, \"DropAndReplace in unwind path not supported\");\n \n         let assign = Statement {\n             kind: StatementKind::Assign(location.clone(), Rvalue::Use(value.clone())),\n@@ -477,7 +477,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 kind: TerminatorKind::Goto { target: target },\n                 ..*terminator\n             }),\n-            is_cleanup: data.is_cleanup,\n+            is_cleanup: false,\n         });\n \n         match self.move_data().rev_lookup.find(location) {\n@@ -491,11 +491,10 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                         ctxt: self\n                     },\n                     terminator.source_info,\n-                    data.is_cleanup,\n                     location,\n                     path,\n                     target,\n-                    Some(unwind),\n+                    Unwind::To(unwind),\n                     bb);\n                 on_all_children_bits(self.tcx, self.mir, self.move_data(), path, |child| {\n                     self.set_drop_flag(Location { block: target, statement_index: 0 },"}, {"sha": "54779cbe30126c9484c1034c8f519691c66cf58d", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6d0b5bdd81a2b87351afb587e02c557e9e6355e/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d0b5bdd81a2b87351afb587e02c557e9e6355e/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=c6d0b5bdd81a2b87351afb587e02c557e9e6355e", "patch": "@@ -198,11 +198,10 @@ fn build_drop_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n             elaborate_drops::elaborate_drop(\n                 &mut elaborator,\n                 source_info,\n-                false,\n                 &dropee,\n                 (),\n                 return_block,\n-                Some(resume_block),\n+                elaborate_drops::Unwind::To(resume_block),\n                 START_BLOCK\n             );\n             elaborator.patch"}, {"sha": "afec04dafe314cb034db0f528ffe210c5547ea02", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 130, "deletions": 117, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/c6d0b5bdd81a2b87351afb587e02c557e9e6355e/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d0b5bdd81a2b87351afb587e02c557e9e6355e/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=c6d0b5bdd81a2b87351afb587e02c557e9e6355e", "patch": "@@ -50,6 +50,35 @@ pub enum DropFlagMode {\n     Deep\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub enum Unwind {\n+    To(BasicBlock),\n+    InCleanup\n+}\n+\n+impl Unwind {\n+    fn is_cleanup(self) -> bool {\n+        match self {\n+            Unwind::To(..) => false,\n+            Unwind::InCleanup => true\n+        }\n+    }\n+\n+    fn into_option(self) -> Option<BasicBlock> {\n+        match self {\n+            Unwind::To(bb) => Some(bb),\n+            Unwind::InCleanup => None,\n+        }\n+    }\n+\n+    fn map<F>(self, f: F) -> Self where F: FnOnce(BasicBlock) -> BasicBlock {\n+        match self {\n+            Unwind::To(bb) => Unwind::To(f(bb)),\n+            Unwind::InCleanup => Unwind::InCleanup\n+        }\n+    }\n+}\n+\n pub trait DropElaborator<'a, 'tcx: 'a> : fmt::Debug {\n     type Path : Copy + fmt::Debug;\n \n@@ -75,28 +104,25 @@ struct DropCtxt<'l, 'b: 'l, 'tcx: 'b, D>\n     elaborator: &'l mut D,\n \n     source_info: SourceInfo,\n-    is_cleanup: bool,\n \n     lvalue: &'l Lvalue<'tcx>,\n     path: D::Path,\n     succ: BasicBlock,\n-    unwind: Option<BasicBlock>,\n+    unwind: Unwind,\n }\n \n pub fn elaborate_drop<'b, 'tcx, D>(\n     elaborator: &mut D,\n     source_info: SourceInfo,\n-    is_cleanup: bool,\n     lvalue: &Lvalue<'tcx>,\n     path: D::Path,\n     succ: BasicBlock,\n-    unwind: Option<BasicBlock>,\n+    unwind: Unwind,\n     bb: BasicBlock)\n     where D: DropElaborator<'b, 'tcx>\n {\n-    assert_eq!(unwind.is_none(), is_cleanup);\n     DropCtxt {\n-        elaborator, source_info, is_cleanup, lvalue, path, succ, unwind\n+        elaborator, source_info, lvalue, path, succ, unwind\n     }.elaborate_drop(bb)\n }\n \n@@ -145,14 +171,13 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                 self.elaborator.patch().patch_terminator(bb, TerminatorKind::Drop {\n                     location: self.lvalue.clone(),\n                     target: self.succ,\n-                    unwind: self.unwind\n+                    unwind: self.unwind.into_option(),\n                 });\n             }\n             DropStyle::Conditional => {\n-                let is_cleanup = self.is_cleanup; // FIXME(#6393)\n+                let unwind = self.unwind; // FIXME(#6393)\n                 let succ = self.succ;\n-                let drop_bb = self.complete_drop(\n-                    is_cleanup, Some(DropFlagMode::Deep), succ);\n+                let drop_bb = self.complete_drop(Some(DropFlagMode::Deep), succ, unwind);\n                 self.elaborator.patch().patch_terminator(bb, TerminatorKind::Goto {\n                     target: drop_bb\n                 });\n@@ -189,11 +214,10 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     }\n \n     fn drop_subpath(&mut self,\n-                    is_cleanup: bool,\n                     lvalue: &Lvalue<'tcx>,\n                     path: Option<D::Path>,\n                     succ: BasicBlock,\n-                    unwind: Option<BasicBlock>)\n+                    unwind: Unwind)\n                     -> BasicBlock\n     {\n         if let Some(path) = path {\n@@ -202,44 +226,35 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             DropCtxt {\n                 elaborator: self.elaborator,\n                 source_info: self.source_info,\n-                path, lvalue, succ, unwind, is_cleanup\n+                path, lvalue, succ, unwind,\n             }.elaborated_drop_block()\n         } else {\n             debug!(\"drop_subpath: for rest field {:?}\", lvalue);\n \n             DropCtxt {\n                 elaborator: self.elaborator,\n                 source_info: self.source_info,\n-                lvalue, succ, unwind, is_cleanup,\n+                lvalue, succ, unwind,\n                 // Using `self.path` here to condition the drop on\n                 // our own drop flag.\n                 path: self.path\n-            }.complete_drop(is_cleanup, None, succ)\n+            }.complete_drop(None, succ, unwind)\n         }\n     }\n \n     /// Create one-half of the drop ladder for a list of fields, and return\n     /// the list of steps in it in reverse order.\n     ///\n     /// `unwind_ladder` is such a list of steps in reverse order,\n-    /// which is called instead of the next step if the drop unwinds\n-    /// (the first field is never reached). If it is `None`, all\n-    /// unwind targets are left blank.\n-    fn drop_halfladder<'a>(&mut self,\n-                           unwind_ladder: Option<&[BasicBlock]>,\n-                           succ: BasicBlock,\n-                           fields: &[(Lvalue<'tcx>, Option<D::Path>)],\n-                           is_cleanup: bool)\n-                           -> Vec<BasicBlock>\n+    /// which is called if the matching step of the drop glue panics.\n+    fn drop_halfladder(&mut self,\n+                       unwind_ladder: &[Unwind],\n+                       succ: BasicBlock,\n+                       fields: &[(Lvalue<'tcx>, Option<D::Path>)])\n+                       -> Vec<BasicBlock>\n     {\n-        let mut unwind_succ = if is_cleanup {\n-            None\n-        } else {\n-            self.unwind\n-        };\n-\n         let goto = TerminatorKind::Goto { target: succ };\n-        let mut succ = self.new_block(is_cleanup, goto);\n+        let mut succ = self.new_block(unwind_ladder[0], goto);\n \n         // Always clear the \"master\" drop flag at the bottom of the\n         // ladder. This is needed because the \"master\" drop flag\n@@ -248,9 +263,8 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let succ_loc = Location { block: succ, statement_index: 0 };\n         self.elaborator.clear_drop_flag(succ_loc, self.path, DropFlagMode::Shallow);\n \n-        fields.iter().rev().enumerate().map(|(i, &(ref lv, path))| {\n-            succ = self.drop_subpath(is_cleanup, lv, path, succ, unwind_succ);\n-            unwind_succ = unwind_ladder.as_ref().map(|p| p[i]);\n+        fields.iter().rev().zip(unwind_ladder).map(|(&(ref lv, path), &unwind_succ)| {\n+            succ = self.drop_subpath(lv, path, succ, unwind_succ);\n             succ\n         }).collect()\n     }\n@@ -271,7 +285,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     ///     ELAB(drop location.2 [target=`self.unwind`])\n     fn drop_ladder<'a>(&mut self,\n                        fields: Vec<(Lvalue<'tcx>, Option<D::Path>)>)\n-                       -> (BasicBlock, Option<BasicBlock>)\n+                       -> (BasicBlock, Unwind)\n     {\n         debug!(\"drop_ladder({:?}, {:?})\", self, fields);\n \n@@ -282,21 +296,21 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n         debug!(\"drop_ladder - fields needing drop: {:?}\", fields);\n \n-        let unwind_ladder = if self.is_cleanup {\n-            None\n+        let unwind_ladder = vec![Unwind::InCleanup; fields.len() + 1];\n+        let unwind_ladder: Vec<_> = if let Unwind::To(target) = self.unwind {\n+            let halfladder = self.drop_halfladder(&unwind_ladder, target, &fields);\n+            Some(self.unwind).into_iter().chain(halfladder.into_iter().map(Unwind::To))\n+                .collect()\n         } else {\n-            let unwind = self.unwind.unwrap(); // FIXME(#6393)\n-            Some(self.drop_halfladder(None, unwind, &fields, true))\n+            unwind_ladder\n         };\n \n         let succ = self.succ; // FIXME(#6393)\n-        let is_cleanup = self.is_cleanup;\n         let normal_ladder =\n-            self.drop_halfladder(unwind_ladder.as_ref().map(|x| &**x),\n-                                 succ, &fields, is_cleanup);\n+            self.drop_halfladder(&unwind_ladder, succ, &fields);\n \n         (normal_ladder.last().cloned().unwrap_or(succ),\n-         unwind_ladder.and_then(|l| l.last().cloned()).or(self.unwind))\n+         unwind_ladder.last().cloned().unwrap_or(self.unwind))\n     }\n \n     fn open_drop_for_tuple<'a>(&mut self, tys: &[Ty<'tcx>])\n@@ -320,13 +334,13 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let interior_path = self.elaborator.deref_subpath(self.path);\n \n         let succ = self.succ; // FIXME(#6393)\n-        let is_cleanup = self.is_cleanup;\n-        let succ = self.box_free_block(ty, succ, is_cleanup);\n-        let unwind_succ = self.unwind.map(|u| {\n-            self.box_free_block(ty, u, true)\n+        let unwind = self.unwind;\n+        let succ = self.box_free_block(ty, succ, unwind);\n+        let unwind_succ = self.unwind.map(|unwind| {\n+            self.box_free_block(ty, unwind, Unwind::InCleanup)\n         });\n \n-        self.drop_subpath(is_cleanup, &interior, interior_path, succ, unwind_succ)\n+        self.drop_subpath(&interior, interior_path, succ, unwind_succ)\n     }\n \n     fn open_drop_for_adt<'a>(&mut self, adt: &'tcx ty::AdtDef, substs: &'tcx Substs<'tcx>)\n@@ -339,7 +353,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                     source_info: self.source_info,\n                     kind: TerminatorKind::Unreachable\n                 }),\n-                is_cleanup: self.is_cleanup\n+                is_cleanup: self.unwind.is_cleanup()\n             });\n         }\n \n@@ -358,7 +372,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n     fn open_drop_for_adt_contents<'a>(&mut self, adt: &'tcx ty::AdtDef,\n                                       substs: &'tcx Substs<'tcx>)\n-                                      -> (BasicBlock, Option<BasicBlock>) {\n+                                      -> (BasicBlock, Unwind) {\n         match adt.variants.len() {\n             1 => {\n                 let fields = self.move_paths_for_fields(\n@@ -370,13 +384,12 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                 self.drop_ladder(fields)\n             }\n             _ => {\n-                let is_cleanup = self.is_cleanup;\n                 let succ = self.succ;\n                 let unwind = self.unwind; // FIXME(#6393)\n \n                 let mut values = Vec::with_capacity(adt.variants.len());\n                 let mut normal_blocks = Vec::with_capacity(adt.variants.len());\n-                let mut unwind_blocks = if is_cleanup {\n+                let mut unwind_blocks = if unwind.is_cleanup() {\n                     None\n                 } else {\n                     Some(Vec::with_capacity(adt.variants.len()))\n@@ -396,7 +409,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                             &adt.variants[variant_index],\n                             substs);\n                         values.push(discr);\n-                        if let Some(ref mut unwind_blocks) = unwind_blocks {\n+                        if let Unwind::To(unwind) = unwind {\n                             // We can't use the half-ladder from the original\n                             // drop ladder, because this breaks the\n                             // \"funclet can't have 2 successor funclets\"\n@@ -415,27 +428,28 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                             // I want to minimize the divergence between MSVC\n                             // and non-MSVC.\n \n-                            let unwind = unwind.unwrap();\n-                            let halfladder = self.drop_halfladder(\n-                                None, unwind, &fields, true);\n-                            unwind_blocks.push(\n-                                halfladder.last().cloned().unwrap_or(unwind)\n-                            );\n+                            let unwind_blocks = unwind_blocks.as_mut().unwrap();\n+                            let unwind_ladder = vec![Unwind::InCleanup; fields.len() + 1];\n+                            let halfladder =\n+                                self.drop_halfladder(&unwind_ladder, unwind, &fields);\n+                            unwind_blocks.push(halfladder.last().cloned().unwrap_or(unwind));\n                         }\n                         let (normal, _) = self.drop_ladder(fields);\n                         normal_blocks.push(normal);\n                     } else {\n                         // variant not found - drop the entire enum\n                         if let None = otherwise {\n                             otherwise = Some(self.complete_drop(\n-                                is_cleanup,\n-                                Some(DropFlagMode::Shallow),\n-                                succ));\n-                            unwind_otherwise = unwind.map(|unwind| self.complete_drop(\n-                                true,\n                                 Some(DropFlagMode::Shallow),\n-                                unwind\n-                            ));\n+                                succ,\n+                                unwind));\n+                            if let Unwind::To(unwind) = unwind {\n+                                unwind_otherwise = Some(self.complete_drop(\n+                                    Some(DropFlagMode::Shallow),\n+                                    unwind,\n+                                    Unwind::InCleanup\n+                                ));\n+                            }\n                         }\n                     }\n                 }\n@@ -448,22 +462,22 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                     values.pop();\n                 }\n \n-                (self.adt_switch_block(is_cleanup, adt, normal_blocks, &values, succ),\n-                 unwind_blocks.map(|unwind_blocks| {\n+                (self.adt_switch_block(adt, normal_blocks, &values, succ, unwind),\n+                 unwind.map(|unwind| {\n                      self.adt_switch_block(\n-                         is_cleanup, adt, unwind_blocks, &values, unwind.unwrap()\n+                         adt, unwind_blocks.unwrap(), &values, unwind, Unwind::InCleanup\n                      )\n                  }))\n             }\n         }\n     }\n \n     fn adt_switch_block(&mut self,\n-                        is_cleanup: bool,\n                         adt: &'tcx ty::AdtDef,\n                         blocks: Vec<BasicBlock>,\n                         values: &[ConstInt],\n-                        succ: BasicBlock)\n+                        succ: BasicBlock,\n+                        unwind: Unwind)\n                         -> BasicBlock {\n         // If there are multiple variants, then if something\n         // is present within the enum the discriminant, tracked\n@@ -491,12 +505,12 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                     targets: blocks,\n                 }\n             }),\n-            is_cleanup: is_cleanup,\n+            is_cleanup: unwind.is_cleanup(),\n         });\n-        self.drop_flag_test_block(is_cleanup, switch_block, succ)\n+        self.drop_flag_test_block(switch_block, succ, unwind)\n     }\n \n-    fn destructor_call_block<'a>(&mut self, (succ, unwind): (BasicBlock, Option<BasicBlock>))\n+    fn destructor_call_block<'a>(&mut self, (succ, unwind): (BasicBlock, Unwind))\n                                  -> BasicBlock\n     {\n         debug!(\"destructor_call_block({:?}, {:?})\", self, succ);\n@@ -527,11 +541,11 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                                                    self.source_info.span),\n                     args: vec![Operand::Consume(Lvalue::Local(ref_lvalue))],\n                     destination: Some((unit_temp, succ)),\n-                    cleanup: unwind,\n+                    cleanup: unwind.into_option(),\n                 },\n                 source_info: self.source_info\n             }),\n-            is_cleanup: self.is_cleanup,\n+            is_cleanup: unwind.is_cleanup(),\n         })\n     }\n \n@@ -541,16 +555,15 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     ///    can_go = index < len\n     ///    if can_go then drop-block else succ\n     /// drop-block:\n-    ///    ptr = &mut LV[len]\n+    ///    ptr = &mut LV[index]\n     ///    index = index + 1\n     ///    drop(ptr)\n     fn drop_loop(&mut self,\n-                 unwind: Option<BasicBlock>,\n                  succ: BasicBlock,\n                  index: &Lvalue<'tcx>,\n                  length: &Lvalue<'tcx>,\n                  ety: Ty<'tcx>,\n-                 is_cleanup: bool)\n+                 unwind: Unwind)\n                  -> BasicBlock\n     {\n         let use_ = |lv: &Lvalue<'tcx>| Operand::Consume(lv.clone());\n@@ -576,10 +589,11 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                     index.clone(), Rvalue::BinaryOp(BinOp::Add, use_(index), one)\n                 )},\n             ],\n-            is_cleanup,\n+            is_cleanup: unwind.is_cleanup(),\n             terminator: Some(Terminator {\n                 source_info: self.source_info,\n-                kind: TerminatorKind::Resume,\n+                // this gets overwritten by drop elaboration.\n+                kind: TerminatorKind::Unreachable,\n             })\n         });\n \n@@ -589,7 +603,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                     can_go.clone(), Rvalue::BinaryOp(BinOp::Lt, use_(index), use_(length))\n                 )},\n             ],\n-            is_cleanup,\n+            is_cleanup: unwind.is_cleanup(),\n             terminator: Some(Terminator {\n                 source_info: self.source_info,\n                 kind: TerminatorKind::if_(tcx, use_(can_go), drop_block, succ)\n@@ -599,7 +613,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         self.elaborator.patch().patch_terminator(drop_block, TerminatorKind::Drop {\n             location: ptr.clone().deref(),\n             target: loop_block,\n-            unwind: unwind\n+            unwind: unwind.into_option()\n         });\n \n         loop_block\n@@ -614,12 +628,11 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let length = &Lvalue::Local(self.new_temp(tcx.types.usize));\n \n         let unwind = self.unwind.map(|unwind| {\n-            self.drop_loop(None, unwind, index, length, ety, true)\n+            self.drop_loop(unwind, index, length, ety, Unwind::InCleanup)\n         });\n \n-        let is_cleanup = self.is_cleanup;\n         let succ = self.succ; // FIXME(#6393)\n-        let loop_block = self.drop_loop(unwind, succ, index, length, ety, is_cleanup);\n+        let loop_block = self.drop_loop(succ, index, length, ety, unwind);\n \n         let zero = self.constant_usize(0);\n         let drop_block = self.elaborator.patch().new_block(BasicBlockData {\n@@ -631,7 +644,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                     index.clone(), Rvalue::Use(zero),\n                 )},\n             ],\n-            is_cleanup,\n+            is_cleanup: unwind.is_cleanup(),\n             terminator: Some(Terminator {\n                 source_info: self.source_info,\n                 kind: TerminatorKind::Goto { target: loop_block }\n@@ -640,7 +653,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n         // FIXME(#34708): handle partially-dropped array/slice elements.\n         self.drop_flag_test_and_reset_block(\n-            is_cleanup, Some(DropFlagMode::Deep), drop_block, succ)\n+            Some(DropFlagMode::Deep), drop_block, succ, unwind)\n     }\n \n     /// The slow-path - create an \"open\", elaborated drop for a type\n@@ -653,8 +666,6 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     /// ADT, both in the success case or if one of the destructors fail.\n     fn open_drop<'a>(&mut self) -> BasicBlock {\n         let ty = self.lvalue_ty(self.lvalue);\n-        let is_cleanup = self.is_cleanup; // FIXME(#6393)\n-        let succ = self.succ;\n         match ty.sty {\n             ty::TyClosure(def_id, substs) => {\n                 let tys : Vec<_> = substs.upvar_tys(def_id, self.tcx()).collect();\n@@ -670,7 +681,9 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                 self.open_drop_for_adt(def, substs)\n             }\n             ty::TyDynamic(..) => {\n-                self.complete_drop(is_cleanup, Some(DropFlagMode::Deep), succ)\n+                let unwind = self.unwind; // FIXME(#6393)\n+                let succ = self.succ;\n+                self.complete_drop(Some(DropFlagMode::Deep), succ, unwind)\n             }\n             ty::TyArray(ety, _) | ty::TySlice(ety) => {\n                 self.open_drop_for_array(ety)\n@@ -687,21 +700,21 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     ///     if let Some(mode) = mode: FLAG(self.path)[mode] = false\n     ///     drop(self.lv)\n     fn complete_drop<'a>(&mut self,\n-                         is_cleanup: bool,\n                          drop_mode: Option<DropFlagMode>,\n-                         succ: BasicBlock) -> BasicBlock\n+                         succ: BasicBlock,\n+                         unwind: Unwind) -> BasicBlock\n     {\n         debug!(\"complete_drop({:?},{:?})\", self, drop_mode);\n \n-        let drop_block = self.drop_block(is_cleanup, succ);\n-        self.drop_flag_test_and_reset_block(is_cleanup, drop_mode, drop_block, succ)\n+        let drop_block = self.drop_block(succ, unwind);\n+        self.drop_flag_test_and_reset_block(drop_mode, drop_block, succ, unwind)\n     }\n \n     fn drop_flag_test_and_reset_block(&mut self,\n-                                      is_cleanup: bool,\n                                       drop_mode: Option<DropFlagMode>,\n                                       drop_block: BasicBlock,\n-                                      succ: BasicBlock) -> BasicBlock\n+                                      succ: BasicBlock,\n+                                      unwind: Unwind) -> BasicBlock\n     {\n         debug!(\"drop_flag_test_and_reset_block({:?},{:?})\", self, drop_mode);\n \n@@ -710,14 +723,14 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             self.elaborator.clear_drop_flag(block_start, self.path, mode);\n         }\n \n-        self.drop_flag_test_block(is_cleanup, drop_block, succ)\n+        self.drop_flag_test_block(drop_block, succ, unwind)\n     }\n \n     fn elaborated_drop_block<'a>(&mut self) -> BasicBlock {\n         debug!(\"elaborated_drop_block({:?})\", self);\n-        let is_cleanup = self.is_cleanup; // FIXME(#6393)\n+        let unwind = self.unwind; // FIXME(#6393)\n         let succ = self.succ;\n-        let blk = self.drop_block(is_cleanup, succ);\n+        let blk = self.drop_block(succ, unwind);\n         self.elaborate_drop(blk);\n         blk\n     }\n@@ -726,17 +739,17 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         &mut self,\n         ty: Ty<'tcx>,\n         target: BasicBlock,\n-        is_cleanup: bool\n+        unwind: Unwind,\n     ) -> BasicBlock {\n-        let block = self.unelaborated_free_block(ty, target, is_cleanup);\n-        self.drop_flag_test_block(is_cleanup, block, target)\n+        let block = self.unelaborated_free_block(ty, target, unwind);\n+        self.drop_flag_test_block(block, target, unwind)\n     }\n \n     fn unelaborated_free_block<'a>(\n         &mut self,\n         ty: Ty<'tcx>,\n         target: BasicBlock,\n-        is_cleanup: bool\n+        unwind: Unwind\n     ) -> BasicBlock {\n         let tcx = self.tcx();\n         let unit_temp = Lvalue::Local(self.new_temp(tcx.mk_nil()));\n@@ -749,45 +762,45 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             destination: Some((unit_temp, target)),\n             cleanup: None\n         }; // FIXME(#6393)\n-        let free_block = self.new_block(is_cleanup, call);\n+        let free_block = self.new_block(unwind, call);\n \n         let block_start = Location { block: free_block, statement_index: 0 };\n         self.elaborator.clear_drop_flag(block_start, self.path, DropFlagMode::Shallow);\n         free_block\n     }\n \n-    fn drop_block<'a>(&mut self, is_cleanup: bool, succ: BasicBlock) -> BasicBlock {\n+    fn drop_block<'a>(&mut self, target: BasicBlock, unwind: Unwind) -> BasicBlock {\n         let block = TerminatorKind::Drop {\n             location: self.lvalue.clone(),\n-            target: succ,\n-            unwind: if is_cleanup { None } else { self.unwind }\n+            target: target,\n+            unwind: unwind.into_option()\n         };\n-        self.new_block(is_cleanup, block)\n+        self.new_block(unwind, block)\n     }\n \n     fn drop_flag_test_block(&mut self,\n-                            is_cleanup: bool,\n                             on_set: BasicBlock,\n-                            on_unset: BasicBlock)\n+                            on_unset: BasicBlock,\n+                            unwind: Unwind)\n                             -> BasicBlock\n     {\n         let style = self.elaborator.drop_style(self.path, DropFlagMode::Shallow);\n-        debug!(\"drop_flag_test_block({:?},{:?},{:?}) - {:?}\",\n-               self, is_cleanup, on_set, style);\n+        debug!(\"drop_flag_test_block({:?},{:?},{:?},{:?}) - {:?}\",\n+               self, on_set, on_unset, unwind, style);\n \n         match style {\n             DropStyle::Dead => on_unset,\n             DropStyle::Static => on_set,\n             DropStyle::Conditional | DropStyle::Open => {\n                 let flag = self.elaborator.get_drop_flag(self.path).unwrap();\n                 let term = TerminatorKind::if_(self.tcx(), flag, on_set, on_unset);\n-                self.new_block(is_cleanup, term)\n+                self.new_block(unwind, term)\n             }\n         }\n     }\n \n     fn new_block<'a>(&mut self,\n-                     is_cleanup: bool,\n+                     unwind: Unwind,\n                      k: TerminatorKind<'tcx>)\n                      -> BasicBlock\n     {\n@@ -796,7 +809,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             terminator: Some(Terminator {\n                 source_info: self.source_info, kind: k\n             }),\n-            is_cleanup: is_cleanup\n+            is_cleanup: unwind.is_cleanup()\n         })\n     }\n \n@@ -809,7 +822,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         self.elaborator.patch().terminator_loc(mir, bb)\n     }\n \n-    fn constant_usize(&self, val: usize) -> Operand<'tcx> {\n+    fn constant_usize(&self, val: u16) -> Operand<'tcx> {\n         Operand::Constant(box Constant {\n             span: self.source_info.span,\n             ty: self.tcx().types.usize,"}]}