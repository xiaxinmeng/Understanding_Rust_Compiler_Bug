{"sha": "0f4bcadb46006bc484dad85616b484f93879ca4e", "node_id": "C_kwDOAAsO6NoAKDBmNGJjYWRiNDYwMDZiYzQ4NGRhZDg1NjE2YjQ4NGY5Mzg3OWNhNGU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-30T21:01:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-30T21:01:42Z"}, "message": "Auto merge of #99964 - matthiaskrgr:rollup-jr836e2, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #99650 (Support `x --keep-stage 0 check`)\n - #99873 (rustdoc: align invalid-html-tags lint with commonmark spec)\n - #99889 (Remove `parent_pat` from `TopInfo`)\n - #99890 (Do not allow bad projection term to leak into the type checker)\n - #99937 (Reset directory iteration in remove_dir_all)\n - #99950 (Remove more Clean trait implementations)\n - #99956 (Also gate AllocatedPointer and AllocAlign definitions by LLVM_VERSION_GE)\n - #99962 (Discover channel for LLVM download)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "24c9bc84721b216023f64394714d5ec09f24c3da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24c9bc84721b216023f64394714d5ec09f24c3da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f4bcadb46006bc484dad85616b484f93879ca4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f4bcadb46006bc484dad85616b484f93879ca4e", "html_url": "https://github.com/rust-lang/rust/commit/0f4bcadb46006bc484dad85616b484f93879ca4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f4bcadb46006bc484dad85616b484f93879ca4e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "038f9e6bef9c8fcf122d93a8a33ac546f5606eb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/038f9e6bef9c8fcf122d93a8a33ac546f5606eb3", "html_url": "https://github.com/rust-lang/rust/commit/038f9e6bef9c8fcf122d93a8a33ac546f5606eb3"}, {"sha": "f21a06f8fa6c5e0bc58c7b48817f532af62a0bc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/f21a06f8fa6c5e0bc58c7b48817f532af62a0bc3", "html_url": "https://github.com/rust-lang/rust/commit/f21a06f8fa6c5e0bc58c7b48817f532af62a0bc3"}], "stats": {"total": 251, "additions": 149, "deletions": 102}, "files": [{"sha": "015c1c52bef778a2a883121cd7e7d877e5c6d5ed", "filename": "compiler/rustc_llvm/llvm-wrapper/LLVMWrapper.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f4bcadb46006bc484dad85616b484f93879ca4e/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h", "raw_url": "https://github.com/rust-lang/rust/raw/0f4bcadb46006bc484dad85616b484f93879ca4e/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h?ref=0f4bcadb46006bc484dad85616b484f93879ca4e", "patch": "@@ -87,8 +87,10 @@ enum LLVMRustAttribute {\n   NoCfCheck = 35,\n   ShadowCallStack = 36,\n   AllocSize = 37,\n+#if LLVM_VERSION_GE(15, 0)\n   AllocatedPointer = 38,\n   AllocAlign = 39,\n+#endif\n };\n \n typedef struct OpaqueRustString *RustStringRef;"}, {"sha": "444f0fdd45a83faa289223dab995158ecc729f8c", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0f4bcadb46006bc484dad85616b484f93879ca4e/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4bcadb46006bc484dad85616b484f93879ca4e/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=0f4bcadb46006bc484dad85616b484f93879ca4e", "patch": "@@ -1234,7 +1234,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n \n         match binding.kind {\n-            ConvertedBindingKind::Equality(term) => {\n+            ConvertedBindingKind::Equality(mut term) => {\n                 // \"Desugar\" a constraint like `T: Iterator<Item = u32>` this to\n                 // the \"projection predicate\" for:\n                 //\n@@ -1245,18 +1245,28 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     (hir::def::DefKind::AssocTy, ty::Term::Ty(_))\n                     | (hir::def::DefKind::AssocConst, ty::Term::Const(_)) => (),\n                     (_, _) => {\n-                        let got = if let ty::Term::Ty(_) = term { \"type\" } else { \"const\" };\n+                        let got = if let ty::Term::Ty(_) = term { \"type\" } else { \"constant\" };\n                         let expected = def_kind.descr(assoc_item_def_id);\n                         tcx.sess\n                             .struct_span_err(\n                                 binding.span,\n-                                &format!(\"mismatch in bind of {expected}, got {got}\"),\n+                                &format!(\"expected {expected} bound, found {got}\"),\n                             )\n                             .span_note(\n                                 tcx.def_span(assoc_item_def_id),\n-                                &format!(\"{expected} defined here does not match {got}\"),\n+                                &format!(\"{expected} defined here\"),\n                             )\n                             .emit();\n+                        term = match def_kind {\n+                            hir::def::DefKind::AssocTy => tcx.ty_error().into(),\n+                            hir::def::DefKind::AssocConst => tcx\n+                                .const_error(\n+                                    tcx.bound_type_of(assoc_item_def_id)\n+                                        .subst(tcx, projection_ty.skip_binder().substs),\n+                                )\n+                                .into(),\n+                            _ => unreachable!(),\n+                        };\n                     }\n                 }\n                 bounds.projection_bounds.push(("}, {"sha": "837c323553c60e698349a6023a7162fae81824b7", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 18, "deletions": 36, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0f4bcadb46006bc484dad85616b484f93879ca4e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4bcadb46006bc484dad85616b484f93879ca4e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=0f4bcadb46006bc484dad85616b484f93879ca4e", "patch": "@@ -72,22 +72,6 @@ struct TopInfo<'tcx> {\n     ///              found type `std::result::Result<_, _>`\n     /// ```\n     span: Option<Span>,\n-    /// This refers to the parent pattern. Used to provide extra diagnostic information on errors.\n-    /// ```text\n-    /// error[E0308]: mismatched types\n-    ///   --> $DIR/const-in-struct-pat.rs:8:17\n-    ///   |\n-    /// L | struct f;\n-    ///   | --------- unit struct defined here\n-    /// ...\n-    /// L |     let Thing { f } = t;\n-    ///   |                 ^\n-    ///   |                 |\n-    ///   |                 expected struct `std::string::String`, found struct `f`\n-    ///   |                 `f` is interpreted as a unit struct, not a new binding\n-    ///   |                 help: bind the struct field to a different name instead: `f: other_f`\n-    /// ```\n-    parent_pat: Option<&'tcx Pat<'tcx>>,\n }\n \n impl<'tcx> FnCtxt<'_, 'tcx> {\n@@ -147,7 +131,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Option<Span>,\n         origin_expr: bool,\n     ) {\n-        let info = TopInfo { expected, origin_expr, span, parent_pat: None };\n+        let info = TopInfo { expected, origin_expr, span };\n         self.check_pat(pat, expected, INITIAL_BM, info);\n     }\n \n@@ -190,9 +174,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_pat_struct(pat, qpath, fields, has_rest_pat, expected, def_bm, ti)\n             }\n             PatKind::Or(pats) => {\n-                let parent_pat = Some(pat);\n                 for pat in pats {\n-                    self.check_pat(pat, expected, def_bm, TopInfo { parent_pat, ..ti });\n+                    self.check_pat(pat, expected, def_bm, ti);\n                 }\n                 expected\n             }\n@@ -621,7 +604,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         if let Some(p) = sub {\n-            self.check_pat(p, expected, def_bm, TopInfo { parent_pat: Some(pat), ..ti });\n+            self.check_pat(p, expected, def_bm, ti);\n         }\n \n         local_ty\n@@ -782,7 +765,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let Some((variant, pat_ty)) = self.check_struct_path(qpath, pat.hir_id) else {\n             let err = self.tcx.ty_error();\n             for field in fields {\n-                let ti = TopInfo { parent_pat: Some(pat), ..ti };\n+                let ti = ti;\n                 self.check_pat(field.pat, err, def_bm, ti);\n             }\n             return err;\n@@ -799,11 +782,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_pat_path<'b>(\n+    fn check_pat_path(\n         &self,\n-        pat: &Pat<'_>,\n+        pat: &Pat<'tcx>,\n         qpath: &hir::QPath<'_>,\n-        path_resolution: (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment<'b>]),\n+        path_resolution: (Res, Option<Ty<'tcx>>, &'tcx [hir::PathSegment<'tcx>]),\n         expected: Ty<'tcx>,\n         ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n@@ -837,7 +820,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let Some(err) =\n             self.demand_suptype_with_origin(&self.pattern_cause(ti, pat.span), expected, pat_ty)\n         {\n-            self.emit_bad_pat_path(err, pat.span, res, pat_res, pat_ty, segments, ti.parent_pat);\n+            self.emit_bad_pat_path(err, pat, res, pat_res, pat_ty, segments);\n         }\n         pat_ty\n     }\n@@ -876,16 +859,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         false\n     }\n \n-    fn emit_bad_pat_path<'b>(\n+    fn emit_bad_pat_path(\n         &self,\n         mut e: DiagnosticBuilder<'_, ErrorGuaranteed>,\n-        pat_span: Span,\n+        pat: &hir::Pat<'tcx>,\n         res: Res,\n         pat_res: Res,\n         pat_ty: Ty<'tcx>,\n-        segments: &'b [hir::PathSegment<'b>],\n-        parent_pat: Option<&Pat<'_>>,\n+        segments: &'tcx [hir::PathSegment<'tcx>],\n     ) {\n+        let pat_span = pat.span;\n         if let Some(span) = self.tcx.hir().res_span(pat_res) {\n             e.span_label(span, &format!(\"{} defined here\", res.descr()));\n             if let [hir::PathSegment { ident, .. }] = &*segments {\n@@ -898,8 +881,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         res.descr(),\n                     ),\n                 );\n-                match parent_pat {\n-                    Some(Pat { kind: hir::PatKind::Struct(..), .. }) => {\n+                match self.tcx.hir().get(self.tcx.hir().get_parent_node(pat.hir_id)) {\n+                    hir::Node::Pat(Pat { kind: hir::PatKind::Struct(..), .. }) => {\n                         e.span_suggestion_verbose(\n                             ident.span.shrink_to_hi(),\n                             \"bind the struct field to a different name instead\",\n@@ -960,9 +943,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let on_error = || {\n-            let parent_pat = Some(pat);\n             for pat in subpats {\n-                self.check_pat(pat, tcx.ty_error(), def_bm, TopInfo { parent_pat, ..ti });\n+                self.check_pat(pat, tcx.ty_error(), def_bm, ti);\n             }\n         };\n         let report_unexpected_res = |res: Res| {\n@@ -1046,7 +1028,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n                 let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n-                self.check_pat(subpat, field_ty, def_bm, TopInfo { parent_pat: Some(pat), ..ti });\n+                self.check_pat(subpat, field_ty, def_bm, ti);\n \n                 self.tcx.check_stability(\n                     variant.fields[i].did,\n@@ -1324,7 +1306,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             };\n \n-            self.check_pat(field.pat, field_ty, def_bm, TopInfo { parent_pat: Some(pat), ..ti });\n+            self.check_pat(field.pat, field_ty, def_bm, ti);\n         }\n \n         let mut unmentioned_fields = variant\n@@ -1936,7 +1918,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let err = tcx.ty_error();\n             (err, err)\n         };\n-        self.check_pat(inner, inner_ty, def_bm, TopInfo { parent_pat: Some(pat), ..ti });\n+        self.check_pat(inner, inner_ty, def_bm, ti);\n         rptr_ty\n     }\n "}, {"sha": "c96bcf41d51ddf349c1e9f492ad570c2a0328ccb", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f4bcadb46006bc484dad85616b484f93879ca4e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4bcadb46006bc484dad85616b484f93879ca4e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=0f4bcadb46006bc484dad85616b484f93879ca4e", "patch": "@@ -1035,11 +1035,13 @@ fn remove_dir_all_iterative(f: &File, delete: fn(&File) -> io::Result<()>) -> io\n         unsafe { mem::ManuallyDrop::new(File::from_raw_handle(f.as_raw_handle())) }\n     }\n \n+    let mut restart = true;\n     while let Some(dir) = dirlist.last() {\n         let dir = copy_handle(dir);\n \n         // Fill the buffer and iterate the entries.\n-        let more_data = dir.fill_dir_buff(&mut buffer, false)?;\n+        let more_data = dir.fill_dir_buff(&mut buffer, restart)?;\n+        restart = false;\n         for (name, is_directory) in buffer.iter() {\n             if is_directory {\n                 let child_dir = open_link_no_reparse("}, {"sha": "4325a237c69da6ec828a9fc9bedbf66ca25fc897", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f4bcadb46006bc484dad85616b484f93879ca4e/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4bcadb46006bc484dad85616b484f93879ca4e/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=0f4bcadb46006bc484dad85616b484f93879ca4e", "patch": "@@ -1312,6 +1312,13 @@ impl Config {\n         git\n     }\n \n+    pub(crate) fn artifact_channel(&self, commit: &str) -> String {\n+        let mut channel = self.git();\n+        channel.arg(\"show\").arg(format!(\"{}:src/ci/channel\", commit));\n+        let channel = output(&mut channel);\n+        channel.trim().to_owned()\n+    }\n+\n     /// Try to find the relative path of `bindir`, otherwise return it in full.\n     pub fn bindir_relative(&self) -> &Path {\n         let bindir = &self.bindir;\n@@ -1547,8 +1554,7 @@ fn maybe_download_rustfmt(builder: &Builder<'_>) -> Option<PathBuf> {\n \n fn download_ci_rustc(builder: &Builder<'_>, commit: &str) {\n     builder.verbose(&format!(\"using downloaded stage2 artifacts from CI (commit {commit})\"));\n-    // FIXME: support downloading artifacts from the beta channel\n-    const CHANNEL: &str = \"nightly\";\n+    let channel = builder.config.artifact_channel(commit);\n     let host = builder.config.build.triple;\n     let bin_root = builder.out.join(host).join(\"ci-rustc\");\n     let rustc_stamp = bin_root.join(\".rustc-stamp\");\n@@ -1557,13 +1563,13 @@ fn download_ci_rustc(builder: &Builder<'_>, commit: &str) {\n         if bin_root.exists() {\n             t!(fs::remove_dir_all(&bin_root));\n         }\n-        let filename = format!(\"rust-std-{CHANNEL}-{host}.tar.xz\");\n+        let filename = format!(\"rust-std-{channel}-{host}.tar.xz\");\n         let pattern = format!(\"rust-std-{host}\");\n         download_ci_component(builder, filename, &pattern, commit);\n-        let filename = format!(\"rustc-{CHANNEL}-{host}.tar.xz\");\n+        let filename = format!(\"rustc-{channel}-{host}.tar.xz\");\n         download_ci_component(builder, filename, \"rustc\", commit);\n         // download-rustc doesn't need its own cargo, it can just use beta's.\n-        let filename = format!(\"rustc-dev-{CHANNEL}-{host}.tar.xz\");\n+        let filename = format!(\"rustc-dev-{channel}-{host}.tar.xz\");\n         download_ci_component(builder, filename, \"rustc-dev\", commit);\n \n         builder.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustc\"));"}, {"sha": "80b3bcce860163d23eea28a976de06ac3647385c", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f4bcadb46006bc484dad85616b484f93879ca4e/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4bcadb46006bc484dad85616b484f93879ca4e/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=0f4bcadb46006bc484dad85616b484f93879ca4e", "patch": "@@ -623,15 +623,6 @@ Arguments:\n             }\n         };\n \n-        if let Subcommand::Check { .. } = &cmd {\n-            if matches.opt_str(\"keep-stage\").is_some()\n-                || matches.opt_str(\"keep-stage-std\").is_some()\n-            {\n-                eprintln!(\"--keep-stage not yet supported for x.py check\");\n-                crate::detail_exit(1);\n-            }\n-        }\n-\n         Flags {\n             verbose: matches.opt_count(\"verbose\"),\n             stage: matches.opt_str(\"stage\").map(|j| j.parse().expect(\"`stage` should be a number\")),"}, {"sha": "3347246ea8f6feb2c1c37148a60db611d6a2da92", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f4bcadb46006bc484dad85616b484f93879ca4e/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4bcadb46006bc484dad85616b484f93879ca4e/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=0f4bcadb46006bc484dad85616b484f93879ca4e", "patch": "@@ -189,7 +189,8 @@ fn download_ci_llvm(builder: &Builder<'_>, llvm_sha: &str) {\n     } else {\n         &builder.config.stage0_metadata.config.artifacts_server\n     };\n-    let filename = format!(\"rust-dev-nightly-{}.tar.xz\", builder.build.build.triple);\n+    let channel = builder.config.artifact_channel(llvm_sha);\n+    let filename = format!(\"rust-dev-{}-{}.tar.xz\", channel, builder.build.build.triple);\n     let tarball = rustc_cache.join(&filename);\n     if !tarball.exists() {\n         let help_on_error = \"error: failed to download llvm from ci"}, {"sha": "838283e32daf4db61c7721f2ac85f1feb05825ac", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f4bcadb46006bc484dad85616b484f93879ca4e/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4bcadb46006bc484dad85616b484f93879ca4e/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=0f4bcadb46006bc484dad85616b484f93879ca4e", "patch": "@@ -17,8 +17,8 @@ use rustc_span::symbol::{kw, sym, Symbol};\n \n use crate::clean::{\n     self, clean_fn_decl_from_did_and_sig, clean_middle_field, clean_middle_ty, clean_ty,\n-    clean_ty_generics, clean_visibility, utils, Attributes, AttributesExt, Clean, ImplKind, ItemId,\n-    Type, Visibility,\n+    clean_ty_generics, clean_variant_def, clean_visibility, utils, Attributes, AttributesExt,\n+    Clean, ImplKind, ItemId, Type, Visibility,\n };\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n@@ -236,7 +236,7 @@ fn build_enum(cx: &mut DocContext<'_>, did: DefId) -> clean::Enum {\n \n     clean::Enum {\n         generics: clean_ty_generics(cx, cx.tcx.generics_of(did), predicates),\n-        variants: cx.tcx.adt_def(did).variants().iter().map(|v| v.clean(cx)).collect(),\n+        variants: cx.tcx.adt_def(did).variants().iter().map(|v| clean_variant_def(v, cx)).collect(),\n     }\n }\n "}, {"sha": "4067cf8441b3d65349a7554f1d4afc36307c1dfb", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 27, "deletions": 35, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0f4bcadb46006bc484dad85616b484f93879ca4e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4bcadb46006bc484dad85616b484f93879ca4e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0f4bcadb46006bc484dad85616b484f93879ca4e", "patch": "@@ -1824,44 +1824,36 @@ pub(crate) fn clean_visibility(vis: ty::Visibility) -> Visibility {\n     }\n }\n \n+pub(crate) fn clean_variant_def<'tcx>(variant: &ty::VariantDef, cx: &mut DocContext<'tcx>) -> Item {\n+    let kind = match variant.ctor_kind {\n+        CtorKind::Const => Variant::CLike,\n+        CtorKind::Fn => Variant::Tuple(\n+            variant.fields.iter().map(|field| clean_middle_field(field, cx)).collect(),\n+        ),\n+        CtorKind::Fictive => Variant::Struct(VariantStruct {\n+            struct_type: CtorKind::Fictive,\n+            fields: variant.fields.iter().map(|field| clean_middle_field(field, cx)).collect(),\n+        }),\n+    };\n+    let what_rustc_thinks =\n+        Item::from_def_id_and_parts(variant.def_id, Some(variant.name), VariantItem(kind), cx);\n+    // don't show `pub` for variants, which always inherit visibility\n+    Item { visibility: Inherited, ..what_rustc_thinks }\n+}\n+\n fn clean_variant_data<'tcx>(\n     variant: &hir::VariantData<'tcx>,\n     cx: &mut DocContext<'tcx>,\n-) -> VariantStruct {\n-    VariantStruct {\n-        struct_type: CtorKind::from_hir(variant),\n-        fields: variant.fields().iter().map(|x| clean_field(x, cx)).collect(),\n-    }\n-}\n-\n-impl<'tcx> Clean<'tcx, Item> for ty::VariantDef {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n-        let kind = match self.ctor_kind {\n-            CtorKind::Const => Variant::CLike,\n-            CtorKind::Fn => Variant::Tuple(\n-                self.fields.iter().map(|field| clean_middle_field(field, cx)).collect(),\n-            ),\n-            CtorKind::Fictive => Variant::Struct(VariantStruct {\n-                struct_type: CtorKind::Fictive,\n-                fields: self.fields.iter().map(|field| clean_middle_field(field, cx)).collect(),\n-            }),\n-        };\n-        let what_rustc_thinks =\n-            Item::from_def_id_and_parts(self.def_id, Some(self.name), VariantItem(kind), cx);\n-        // don't show `pub` for variants, which always inherit visibility\n-        Item { visibility: Inherited, ..what_rustc_thinks }\n-    }\n-}\n-\n-impl<'tcx> Clean<'tcx, Variant> for hir::VariantData<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Variant {\n-        match self {\n-            hir::VariantData::Struct(..) => Variant::Struct(clean_variant_data(self, cx)),\n-            hir::VariantData::Tuple(..) => {\n-                Variant::Tuple(self.fields().iter().map(|x| clean_field(x, cx)).collect())\n-            }\n-            hir::VariantData::Unit(..) => Variant::CLike,\n+) -> Variant {\n+    match variant {\n+        hir::VariantData::Struct(..) => Variant::Struct(VariantStruct {\n+            struct_type: CtorKind::from_hir(variant),\n+            fields: variant.fields().iter().map(|x| clean_field(x, cx)).collect(),\n+        }),\n+        hir::VariantData::Tuple(..) => {\n+            Variant::Tuple(variant.fields().iter().map(|x| clean_field(x, cx)).collect())\n         }\n+        hir::VariantData::Unit(..) => Variant::CLike,\n     }\n }\n \n@@ -2009,7 +2001,7 @@ fn clean_maybe_renamed_item<'tcx>(\n \n impl<'tcx> Clean<'tcx, Item> for hir::Variant<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n-        let kind = VariantItem(self.data.clean(cx));\n+        let kind = VariantItem(clean_variant_data(&self.data, cx));\n         let what_rustc_thinks =\n             Item::from_hir_id_and_parts(self.id, Some(self.ident.name), kind, cx);\n         // don't show `pub` for variants, which are always public"}, {"sha": "f3a3c853caca638634d2d79fc0a720865ccd6a39", "filename": "src/librustdoc/passes/html_tags.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f4bcadb46006bc484dad85616b484f93879ca4e/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4bcadb46006bc484dad85616b484f93879ca4e/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs?ref=0f4bcadb46006bc484dad85616b484f93879ca4e", "patch": "@@ -94,6 +94,14 @@ fn extract_path_backwards(text: &str, end_pos: usize) -> Option<usize> {\n     if current_pos == end_pos { None } else { Some(current_pos) }\n }\n \n+fn is_valid_for_html_tag_name(c: char, is_empty: bool) -> bool {\n+    // https://spec.commonmark.org/0.30/#raw-html\n+    //\n+    // > A tag name consists of an ASCII letter followed by zero or more ASCII letters, digits, or\n+    // > hyphens (-).\n+    c.is_ascii_alphabetic() || !is_empty && (c == '-' || c.is_ascii_digit())\n+}\n+\n fn extract_html_tag(\n     tags: &mut Vec<(String, Range<usize>)>,\n     text: &str,\n@@ -117,7 +125,7 @@ fn extract_html_tag(\n         // Checking if this is a closing tag (like `</a>` for `<a>`).\n         if c == '/' && tag_name.is_empty() {\n             is_closing = true;\n-        } else if c.is_ascii_alphanumeric() {\n+        } else if is_valid_for_html_tag_name(c, tag_name.is_empty()) {\n             tag_name.push(c);\n         } else {\n             if !tag_name.is_empty() {"}, {"sha": "0f9d2e4b35d0549b1c3bdd1ce74860365c7c62aa", "filename": "src/test/rustdoc-ui/invalid-html-tags.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f4bcadb46006bc484dad85616b484f93879ca4e/src%2Ftest%2Frustdoc-ui%2Finvalid-html-tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4bcadb46006bc484dad85616b484f93879ca4e/src%2Ftest%2Frustdoc-ui%2Finvalid-html-tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finvalid-html-tags.rs?ref=0f4bcadb46006bc484dad85616b484f93879ca4e", "patch": "@@ -108,3 +108,9 @@ pub fn j() {}\n /// <Vec<_> shouldn't warn!\n /// ``````\n pub fn k() {}\n+\n+/// Web Components style <dashed-tags>\n+//~^ ERROR unclosed HTML tag `dashed-tags`\n+/// Web Components style </unopened-tag>\n+//~^ ERROR unopened HTML tag `unopened-tag`\n+pub fn m() {}"}, {"sha": "24a455576e80aef6e4e363614ce143995575fb73", "filename": "src/test/rustdoc-ui/invalid-html-tags.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0f4bcadb46006bc484dad85616b484f93879ca4e/src%2Ftest%2Frustdoc-ui%2Finvalid-html-tags.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f4bcadb46006bc484dad85616b484f93879ca4e/src%2Ftest%2Frustdoc-ui%2Finvalid-html-tags.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finvalid-html-tags.stderr?ref=0f4bcadb46006bc484dad85616b484f93879ca4e", "patch": "@@ -82,5 +82,17 @@ error: Unclosed HTML comment\n LL | /// <!--\n    |     ^^^\n \n-error: aborting due to 13 previous errors\n+error: unopened HTML tag `unopened-tag`\n+  --> $DIR/invalid-html-tags.rs:114:26\n+   |\n+LL | /// Web Components style </unopened-tag>\n+   |                          ^^^^^^^^^^^^^^^\n+\n+error: unclosed HTML tag `dashed-tags`\n+  --> $DIR/invalid-html-tags.rs:112:26\n+   |\n+LL | /// Web Components style <dashed-tags>\n+   |                          ^^^^^^^^^^^^^\n+\n+error: aborting due to 15 previous errors\n "}, {"sha": "c5d78469e955ef1abaaf952e1e297e3066467f1b", "filename": "src/test/ui/associated-consts/assoc-const-ty-mismatch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f4bcadb46006bc484dad85616b484f93879ca4e/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const-ty-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4bcadb46006bc484dad85616b484f93879ca4e/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const-ty-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const-ty-mismatch.rs?ref=0f4bcadb46006bc484dad85616b484f93879ca4e", "patch": "@@ -21,9 +21,9 @@ impl FooTy for Bar {\n \n \n fn foo<F: Foo<N=usize>>() {}\n-//~^ ERROR mismatch in\n+//~^ ERROR expected associated constant bound, found type\n fn foo2<F: FooTy<T=3usize>>() {}\n-//~^ ERROR mismatch in\n+//~^ ERROR expected associated type bound, found constant\n \n fn main() {\n   foo::<Bar>();"}, {"sha": "11198729e38cbd2d5d3c1439451a417c0d7ec72a", "filename": "src/test/ui/associated-consts/assoc-const-ty-mismatch.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f4bcadb46006bc484dad85616b484f93879ca4e/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const-ty-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f4bcadb46006bc484dad85616b484f93879ca4e/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const-ty-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const-ty-mismatch.stderr?ref=0f4bcadb46006bc484dad85616b484f93879ca4e", "patch": "@@ -1,22 +1,22 @@\n-error: mismatch in bind of associated constant, got type\n+error: expected associated constant bound, found type\n   --> $DIR/assoc-const-ty-mismatch.rs:23:15\n    |\n LL | fn foo<F: Foo<N=usize>>() {}\n    |               ^^^^^^^\n    |\n-note: associated constant defined here does not match type\n+note: associated constant defined here\n   --> $DIR/assoc-const-ty-mismatch.rs:5:3\n    |\n LL |   const N: usize;\n    |   ^^^^^^^^^^^^^^\n \n-error: mismatch in bind of associated type, got const\n+error: expected associated type bound, found constant\n   --> $DIR/assoc-const-ty-mismatch.rs:25:18\n    |\n LL | fn foo2<F: FooTy<T=3usize>>() {}\n    |                  ^^^^^^^^\n    |\n-note: associated type defined here does not match const\n+note: associated type defined here\n   --> $DIR/assoc-const-ty-mismatch.rs:9:3\n    |\n LL |   type T;"}, {"sha": "7b711283f5b8316ccb788a43e032aecba7b016c0", "filename": "src/test/ui/associated-type-bounds/issue-99828.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f4bcadb46006bc484dad85616b484f93879ca4e/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fissue-99828.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4bcadb46006bc484dad85616b484f93879ca4e/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fissue-99828.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fissue-99828.rs?ref=0f4bcadb46006bc484dad85616b484f93879ca4e", "patch": "@@ -0,0 +1,11 @@\n+fn get_iter(vec: &[i32]) -> impl Iterator<Item = {}> + '_ {\n+    //~^ ERROR expected associated type bound, found constant\n+    //~| ERROR associated const equality is incomplete\n+    vec.iter()\n+}\n+\n+fn main() {\n+    let vec = Vec::new();\n+    let mut iter = get_iter(&vec);\n+    iter.next();\n+}"}, {"sha": "1c20ead0556593267c0de5ff5de5e0e81c38309e", "filename": "src/test/ui/associated-type-bounds/issue-99828.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0f4bcadb46006bc484dad85616b484f93879ca4e/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fissue-99828.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f4bcadb46006bc484dad85616b484f93879ca4e/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fissue-99828.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fissue-99828.stderr?ref=0f4bcadb46006bc484dad85616b484f93879ca4e", "patch": "@@ -0,0 +1,24 @@\n+error[E0658]: associated const equality is incomplete\n+  --> $DIR/issue-99828.rs:1:43\n+   |\n+LL | fn get_iter(vec: &[i32]) -> impl Iterator<Item = {}> + '_ {\n+   |                                           ^^^^^^^^^\n+   |\n+   = note: see issue #92827 <https://github.com/rust-lang/rust/issues/92827> for more information\n+   = help: add `#![feature(associated_const_equality)]` to the crate attributes to enable\n+\n+error: expected associated type bound, found constant\n+  --> $DIR/issue-99828.rs:1:43\n+   |\n+LL | fn get_iter(vec: &[i32]) -> impl Iterator<Item = {}> + '_ {\n+   |                                           ^^^^^^^^^\n+   |\n+note: associated type defined here\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |     type Item;\n+   |     ^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}]}