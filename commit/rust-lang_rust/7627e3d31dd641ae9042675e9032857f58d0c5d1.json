{"sha": "7627e3d31dd641ae9042675e9032857f58d0c5d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2MjdlM2QzMWRkNjQxYWU5MDQyNjc1ZTkwMzI4NTdmNThkMGM1ZDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-16T19:13:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-16T19:13:52Z"}, "message": "Auto merge of #40409 - mbrubeck:calloc, r=sfackler\n\nSpecialize Vec::from_elem to use calloc\n\nFixes #38723.  This specializes the implementation for `u8` only, but it could be extended to other zeroable types if desired.\n\nI haven't tested this extensively, but I did verify that it gives the expected performance boost for large `vec![0; n]` allocations with both alloc_system and jemalloc, on Linux.  (I have not tested or even built the Windows code.)", "tree": {"sha": "a9e6a160ae903447feee5c907ac67b1f2281750e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9e6a160ae903447feee5c907ac67b1f2281750e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7627e3d31dd641ae9042675e9032857f58d0c5d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7627e3d31dd641ae9042675e9032857f58d0c5d1", "html_url": "https://github.com/rust-lang/rust/commit/7627e3d31dd641ae9042675e9032857f58d0c5d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7627e3d31dd641ae9042675e9032857f58d0c5d1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9af79f52d0ab43e318bdf3aa73d939c4482cc946", "url": "https://api.github.com/repos/rust-lang/rust/commits/9af79f52d0ab43e318bdf3aa73d939c4482cc946", "html_url": "https://github.com/rust-lang/rust/commit/9af79f52d0ab43e318bdf3aa73d939c4482cc946"}, {"sha": "aad2062073f46f28c6d1269463cc6c19df1e0199", "url": "https://api.github.com/repos/rust-lang/rust/commits/aad2062073f46f28c6d1269463cc6c19df1e0199", "html_url": "https://github.com/rust-lang/rust/commit/aad2062073f46f28c6d1269463cc6c19df1e0199"}], "stats": {"total": 190, "additions": 183, "deletions": 7}, "files": [{"sha": "cfcf8e22d7088f3d676dbcc0de2efb09c3f447f8", "filename": "src/doc/unstable-book/src/allocator.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7627e3d31dd641ae9042675e9032857f58d0c5d1/src%2Fdoc%2Funstable-book%2Fsrc%2Fallocator.md", "raw_url": "https://github.com/rust-lang/rust/raw/7627e3d31dd641ae9042675e9032857f58d0c5d1/src%2Fdoc%2Funstable-book%2Fsrc%2Fallocator.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fallocator.md?ref=7627e3d31dd641ae9042675e9032857f58d0c5d1", "patch": "@@ -51,6 +51,11 @@ pub extern fn __rust_allocate(size: usize, _align: usize) -> *mut u8 {\n     unsafe { libc::malloc(size as libc::size_t) as *mut u8 }\n }\n \n+#[no_mangle]\n+pub extern fn __rust_allocate_zeroed(size: usize, _align: usize) -> *mut u8 {\n+    unsafe { libc::calloc(size as libc::size_t, 1) as *mut u8 }\n+}\n+\n #[no_mangle]\n pub extern fn __rust_deallocate(ptr: *mut u8, _old_size: usize, _align: usize) {\n     unsafe { libc::free(ptr as *mut libc::c_void) }"}, {"sha": "08a0b2a6d0080a2dfc053c78ea73f62900ac1a39", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7627e3d31dd641ae9042675e9032857f58d0c5d1/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7627e3d31dd641ae9042675e9032857f58d0c5d1/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=7627e3d31dd641ae9042675e9032857f58d0c5d1", "patch": "@@ -23,6 +23,7 @@ use core::intrinsics::{min_align_of_val, size_of_val};\n extern \"C\" {\n     #[allocator]\n     fn __rust_allocate(size: usize, align: usize) -> *mut u8;\n+    fn __rust_allocate_zeroed(size: usize, align: usize) -> *mut u8;\n     fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize);\n     fn __rust_reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8;\n     fn __rust_reallocate_inplace(ptr: *mut u8,\n@@ -59,6 +60,20 @@ pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n     __rust_allocate(size, align)\n }\n \n+/// Return a pointer to `size` bytes of memory aligned to `align` and\n+/// initialized to zeroes.\n+///\n+/// On failure, return a null pointer.\n+///\n+/// Behavior is undefined if the requested size is 0 or the alignment is not a\n+/// power of 2. The alignment must be no larger than the largest supported page\n+/// size on the platform.\n+#[inline]\n+pub unsafe fn allocate_zeroed(size: usize, align: usize) -> *mut u8 {\n+    check_size_and_alignment(size, align);\n+    __rust_allocate_zeroed(size, align)\n+}\n+\n /// Resize the allocation referenced by `ptr` to `size` bytes.\n ///\n /// On failure, return a null pointer and leave the original allocation intact.\n@@ -162,6 +177,25 @@ mod tests {\n     use boxed::Box;\n     use heap;\n \n+    #[test]\n+    fn allocate_zeroed() {\n+        unsafe {\n+            let size = 1024;\n+            let ptr = heap::allocate_zeroed(size, 1);\n+            if ptr.is_null() {\n+                ::oom()\n+            }\n+\n+            let end = ptr.offset(size as isize);\n+            let mut i = ptr;\n+            while i < end {\n+                assert_eq!(*i, 0);\n+                i = i.offset(1);\n+            }\n+            heap::deallocate(ptr, size, 1);\n+        }\n+    }\n+\n     #[test]\n     fn basic_reallocate_inplace_noop() {\n         unsafe {"}, {"sha": "6a53d3a9ca57afeeca839fdb9b99740ed4f2930b", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7627e3d31dd641ae9042675e9032857f58d0c5d1/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7627e3d31dd641ae9042675e9032857f58d0c5d1/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=7627e3d31dd641ae9042675e9032857f58d0c5d1", "patch": "@@ -81,7 +81,18 @@ impl<T> RawVec<T> {\n     /// # Aborts\n     ///\n     /// Aborts on OOM\n+    #[inline]\n     pub fn with_capacity(cap: usize) -> Self {\n+        RawVec::allocate(cap, false)\n+    }\n+\n+    /// Like `with_capacity` but guarantees the buffer is zeroed.\n+    #[inline]\n+    pub fn with_capacity_zeroed(cap: usize) -> Self {\n+        RawVec::allocate(cap, true)\n+    }\n+\n+    fn allocate(cap: usize, zeroed: bool) -> Self {\n         unsafe {\n             let elem_size = mem::size_of::<T>();\n \n@@ -93,7 +104,11 @@ impl<T> RawVec<T> {\n                 heap::EMPTY as *mut u8\n             } else {\n                 let align = mem::align_of::<T>();\n-                let ptr = heap::allocate(alloc_size, align);\n+                let ptr = if zeroed {\n+                    heap::allocate_zeroed(alloc_size, align)\n+                } else {\n+                    heap::allocate(alloc_size, align)\n+                };\n                 if ptr.is_null() {\n                     oom()\n                 }"}, {"sha": "288531cb5b21f3b438edb8f3fb1d0bca76b4f520", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7627e3d31dd641ae9042675e9032857f58d0c5d1/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7627e3d31dd641ae9042675e9032857f58d0c5d1/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=7627e3d31dd641ae9042675e9032857f58d0c5d1", "patch": "@@ -38,6 +38,10 @@ mod imp {\n                        target_os = \"dragonfly\", target_os = \"windows\", target_env = \"musl\"),\n                    link_name = \"je_mallocx\")]\n         fn mallocx(size: size_t, flags: c_int) -> *mut c_void;\n+        #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n+                       target_os = \"dragonfly\", target_os = \"windows\", target_env = \"musl\"),\n+                   link_name = \"je_calloc\")]\n+        fn calloc(size: size_t, flags: c_int) -> *mut c_void;\n         #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n                        target_os = \"dragonfly\", target_os = \"windows\", target_env = \"musl\"),\n                    link_name = \"je_rallocx\")]\n@@ -56,6 +60,8 @@ mod imp {\n         fn nallocx(size: size_t, flags: c_int) -> size_t;\n     }\n \n+    const MALLOCX_ZERO: c_int = 0x40;\n+\n     // The minimum alignment guaranteed by the architecture. This value is used to\n     // add fast paths for low alignment values. In practice, the alignment is a\n     // constant at the call site and the branch will be optimized out.\n@@ -91,6 +97,16 @@ mod imp {\n         unsafe { mallocx(size as size_t, flags) as *mut u8 }\n     }\n \n+    #[no_mangle]\n+    pub extern \"C\" fn __rust_allocate_zeroed(size: usize, align: usize) -> *mut u8 {\n+        if align <= MIN_ALIGN {\n+            unsafe { calloc(size as size_t, 1) as *mut u8 }\n+        } else {\n+            let flags = align_to_flags(align) | MALLOCX_ZERO;\n+            unsafe { mallocx(size as size_t, flags) as *mut u8 }\n+        }\n+    }\n+\n     #[no_mangle]\n     pub extern \"C\" fn __rust_reallocate(ptr: *mut u8,\n                                         _old_size: usize,\n@@ -135,6 +151,11 @@ mod imp {\n         bogus()\n     }\n \n+    #[no_mangle]\n+    pub extern \"C\" fn __rust_allocate_zeroed(_size: usize, _align: usize) -> *mut u8 {\n+        bogus()\n+    }\n+\n     #[no_mangle]\n     pub extern \"C\" fn __rust_reallocate(_ptr: *mut u8,\n                                         _old_size: usize,"}, {"sha": "6d47c2ff28fbf77ad565d1eeea92c622f03dd9f4", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7627e3d31dd641ae9042675e9032857f58d0c5d1/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7627e3d31dd641ae9042675e9032857f58d0c5d1/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=7627e3d31dd641ae9042675e9032857f58d0c5d1", "patch": "@@ -44,6 +44,11 @@ pub extern \"C\" fn __rust_allocate(size: usize, align: usize) -> *mut u8 {\n     unsafe { imp::allocate(size, align) }\n }\n \n+#[no_mangle]\n+pub extern \"C\" fn __rust_allocate_zeroed(size: usize, align: usize) -> *mut u8 {\n+    unsafe { imp::allocate_zeroed(size, align) }\n+}\n+\n #[no_mangle]\n pub extern \"C\" fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n     unsafe { imp::deallocate(ptr, old_size, align) }\n@@ -121,6 +126,18 @@ mod imp {\n         }\n     }\n \n+    pub unsafe fn allocate_zeroed(size: usize, align: usize) -> *mut u8 {\n+        if align <= MIN_ALIGN {\n+            libc::calloc(size as libc::size_t, 1) as *mut u8\n+        } else {\n+            let ptr = aligned_malloc(size, align);\n+            if !ptr.is_null() {\n+                ptr::write_bytes(ptr, 0, size);\n+            }\n+            ptr\n+        }\n+    }\n+\n     pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 {\n         if align <= MIN_ALIGN {\n             libc::realloc(ptr as *mut libc::c_void, size as libc::size_t) as *mut u8\n@@ -173,6 +190,8 @@ mod imp {\n     #[repr(C)]\n     struct Header(*mut u8);\n \n+\n+    const HEAP_ZERO_MEMORY: DWORD = 0x00000008;\n     const HEAP_REALLOC_IN_PLACE_ONLY: DWORD = 0x00000010;\n \n     unsafe fn get_header<'a>(ptr: *mut u8) -> &'a mut Header {\n@@ -185,18 +204,27 @@ mod imp {\n         aligned\n     }\n \n-    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n+    #[inline]\n+    unsafe fn allocate_with_flags(size: usize, align: usize, flags: DWORD) -> *mut u8 {\n         if align <= MIN_ALIGN {\n-            HeapAlloc(GetProcessHeap(), 0, size as SIZE_T) as *mut u8\n+            HeapAlloc(GetProcessHeap(), flags, size as SIZE_T) as *mut u8\n         } else {\n-            let ptr = HeapAlloc(GetProcessHeap(), 0, (size + align) as SIZE_T) as *mut u8;\n+            let ptr = HeapAlloc(GetProcessHeap(), flags, (size + align) as SIZE_T) as *mut u8;\n             if ptr.is_null() {\n                 return ptr;\n             }\n             align_ptr(ptr, align)\n         }\n     }\n \n+    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n+        allocate_with_flags(size, align, 0)\n+    }\n+\n+    pub unsafe fn allocate_zeroed(size: usize, align: usize) -> *mut u8 {\n+        allocate_with_flags(size, align, HEAP_ZERO_MEMORY)\n+    }\n+\n     pub unsafe fn reallocate(ptr: *mut u8, _old_size: usize, size: usize, align: usize) -> *mut u8 {\n         if align <= MIN_ALIGN {\n             HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, size as SIZE_T) as *mut u8"}, {"sha": "3bea61f6220b6d994778c3155c67f042edc816c7", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7627e3d31dd641ae9042675e9032857f58d0c5d1/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7627e3d31dd641ae9042675e9032857f58d0c5d1/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=7627e3d31dd641ae9042675e9032857f58d0c5d1", "patch": "@@ -35,13 +35,15 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![cfg_attr(not(test), feature(char_escape_debug))]\n+#![cfg_attr(not(test), feature(core_float))]\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n #![feature(fmt_internals)]\n #![feature(fused)]\n #![feature(generic_param_attrs)]\n #![feature(heap_api)]\n+#![feature(i128_type)]\n #![feature(inclusive_range)]\n #![feature(lang_items)]\n #![feature(manually_drop)]"}, {"sha": "a3c529f35859837789ab5554f79fd1a8e9a04de1", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 69, "deletions": 3, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7627e3d31dd641ae9042675e9032857f58d0c5d1/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7627e3d31dd641ae9042675e9032857f58d0c5d1/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=7627e3d31dd641ae9042675e9032857f58d0c5d1", "patch": "@@ -77,6 +77,8 @@ use core::hash::{self, Hash};\n use core::intrinsics::{arith_offset, assume};\n use core::iter::{FromIterator, FusedIterator, TrustedLen};\n use core::mem;\n+#[cfg(not(test))]\n+use core::num::Float;\n use core::ops::{InPlace, Index, IndexMut, Place, Placer};\n use core::ops;\n use core::ptr;\n@@ -1370,11 +1372,75 @@ impl<T: PartialEq> Vec<T> {\n #[doc(hidden)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {\n-    let mut v = Vec::with_capacity(n);\n-    v.extend_with_element(n, elem);\n-    v\n+    <T as SpecFromElem>::from_elem(elem, n)\n+}\n+\n+// Specialization trait used for Vec::from_elem\n+trait SpecFromElem: Sized {\n+    fn from_elem(elem: Self, n: usize) -> Vec<Self>;\n }\n \n+impl<T: Clone> SpecFromElem for T {\n+    default fn from_elem(elem: Self, n: usize) -> Vec<Self> {\n+        let mut v = Vec::with_capacity(n);\n+        v.extend_with_element(n, elem);\n+        v\n+    }\n+}\n+\n+impl SpecFromElem for u8 {\n+    #[inline]\n+    fn from_elem(elem: u8, n: usize) -> Vec<u8> {\n+        if elem == 0 {\n+            return Vec {\n+                buf: RawVec::with_capacity_zeroed(n),\n+                len: n,\n+            }\n+        }\n+        unsafe {\n+            let mut v = Vec::with_capacity(n);\n+            ptr::write_bytes(v.as_mut_ptr(), elem, n);\n+            v.set_len(n);\n+            v\n+        }\n+    }\n+}\n+\n+macro_rules! impl_spec_from_elem {\n+    ($t: ty, $is_zero: expr) => {\n+        impl SpecFromElem for $t {\n+            #[inline]\n+            fn from_elem(elem: $t, n: usize) -> Vec<$t> {\n+                if $is_zero(elem) {\n+                    return Vec {\n+                        buf: RawVec::with_capacity_zeroed(n),\n+                        len: n,\n+                    }\n+                }\n+                let mut v = Vec::with_capacity(n);\n+                v.extend_with_element(n, elem);\n+                v\n+            }\n+        }\n+    };\n+}\n+\n+impl_spec_from_elem!(i8, |x| x == 0);\n+impl_spec_from_elem!(i16, |x| x == 0);\n+impl_spec_from_elem!(i32, |x| x == 0);\n+impl_spec_from_elem!(i64, |x| x == 0);\n+impl_spec_from_elem!(i128, |x| x == 0);\n+impl_spec_from_elem!(isize, |x| x == 0);\n+\n+impl_spec_from_elem!(u16, |x| x == 0);\n+impl_spec_from_elem!(u32, |x| x == 0);\n+impl_spec_from_elem!(u64, |x| x == 0);\n+impl_spec_from_elem!(u128, |x| x == 0);\n+impl_spec_from_elem!(usize, |x| x == 0);\n+\n+impl_spec_from_elem!(f32, |x: f32| x == 0. && x.is_sign_positive());\n+impl_spec_from_elem!(f64, |x: f64| x == 0. && x.is_sign_positive());\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Common trait implementations for Vec\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "1133ace275b864be750fa416ba5a697f892a3c04", "filename": "src/test/run-pass/auxiliary/allocator-dummy.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7627e3d31dd641ae9042675e9032857f58d0c5d1/src%2Ftest%2Frun-pass%2Fauxiliary%2Fallocator-dummy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7627e3d31dd641ae9042675e9032857f58d0c5d1/src%2Ftest%2Frun-pass%2Fauxiliary%2Fallocator-dummy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fallocator-dummy.rs?ref=7627e3d31dd641ae9042675e9032857f58d0c5d1", "patch": "@@ -27,6 +27,11 @@ pub extern fn __rust_allocate(size: usize, align: usize) -> *mut u8 {\n     }\n }\n \n+#[no_mangle]\n+pub extern fn __rust_allocate_zeroed(size: usize, _align: usize) -> *mut u8 {\n+    unsafe { libc::calloc(size as libc::size_t, 1) as *mut u8 }\n+}\n+\n #[no_mangle]\n pub extern fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n     unsafe {"}]}