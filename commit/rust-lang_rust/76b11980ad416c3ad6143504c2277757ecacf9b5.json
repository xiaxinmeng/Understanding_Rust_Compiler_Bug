{"sha": "76b11980ad416c3ad6143504c2277757ecacf9b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2YjExOTgwYWQ0MTZjM2FkNjE0MzUwNGMyMjc3NzU3ZWNhY2Y5YjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-01T20:30:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-01T20:30:35Z"}, "message": "Auto merge of #70672 - Dylan-DPC:rollup-cco9bbd, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #70535 (Track the finalizing node in the specialization graph)\n - #70590 (Miri: make backtrace function names and spans match up)\n - #70616 (rustc_target::abi: rename FieldPlacement to FieldsShape.)\n - #70626 (cargotest: remove webrender)\n - #70649 (clean up E0468 explanation)\n - #70662 (compiletest: don't use `std::io::stdout()`, as it bypasses `set_print`.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "09ff9388a0a0a757eed3e6f73b646ed784241816", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09ff9388a0a0a757eed3e6f73b646ed784241816"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76b11980ad416c3ad6143504c2277757ecacf9b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76b11980ad416c3ad6143504c2277757ecacf9b5", "html_url": "https://github.com/rust-lang/rust/commit/76b11980ad416c3ad6143504c2277757ecacf9b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76b11980ad416c3ad6143504c2277757ecacf9b5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "235938d1acdd93d6641a741c81f64e415b786751", "url": "https://api.github.com/repos/rust-lang/rust/commits/235938d1acdd93d6641a741c81f64e415b786751", "html_url": "https://github.com/rust-lang/rust/commit/235938d1acdd93d6641a741c81f64e415b786751"}, {"sha": "7d4d450da96677cb6b8f90af13ada38c74f73632", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d4d450da96677cb6b8f90af13ada38c74f73632", "html_url": "https://github.com/rust-lang/rust/commit/7d4d450da96677cb6b8f90af13ada38c74f73632"}], "stats": {"total": 774, "additions": 411, "deletions": 363}, "files": [{"sha": "6501ba031e44507a97f096a8172ecbe6655570fa", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -79,7 +79,7 @@ fn uncached_llvm_type<'a, 'tcx>(\n     };\n \n     match layout.fields {\n-        layout::FieldPlacement::Union(_) => {\n+        layout::FieldsShape::Union(_) => {\n             let fill = cx.type_padding_filler(layout.size, layout.align.abi);\n             let packed = false;\n             match name {\n@@ -91,10 +91,10 @@ fn uncached_llvm_type<'a, 'tcx>(\n                 }\n             }\n         }\n-        layout::FieldPlacement::Array { count, .. } => {\n+        layout::FieldsShape::Array { count, .. } => {\n             cx.type_array(layout.field(cx, 0).llvm_type(cx), count)\n         }\n-        layout::FieldPlacement::Arbitrary { .. } => match name {\n+        layout::FieldsShape::Arbitrary { .. } => match name {\n             None => {\n                 let (llfields, packed) = struct_llfields(cx, layout);\n                 cx.type_struct(&llfields, packed)\n@@ -371,13 +371,13 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n             _ => {}\n         }\n         match self.fields {\n-            layout::FieldPlacement::Union(_) => {\n+            layout::FieldsShape::Union(_) => {\n                 bug!(\"TyAndLayout::llvm_field_index({:?}): not applicable\", self)\n             }\n \n-            layout::FieldPlacement::Array { .. } => index as u64,\n+            layout::FieldsShape::Array { .. } => index as u64,\n \n-            layout::FieldPlacement::Arbitrary { .. } => {\n+            layout::FieldsShape::Arbitrary { .. } => {\n                 1 + (self.fields.memory_index(index) as u64) * 2\n             }\n         }"}, {"sha": "eca66a5704db90548d764f6317f8ce3df67148b0", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -66,7 +66,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     }\n \n     pub fn len<Cx: ConstMethods<'tcx, Value = V>>(&self, cx: &Cx) -> V {\n-        if let layout::FieldPlacement::Array { count, .. } = self.layout.fields {\n+        if let layout::FieldsShape::Array { count, .. } = self.layout.fields {\n             if self.layout.is_unsized() {\n                 assert_eq!(count, 0);\n                 self.llextra.unwrap()"}, {"sha": "cf8664718fa635404a6431a315a36a3b9052aca8", "filename": "src/librustc_error_codes/error_codes/E0468.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_error_codes%2Ferror_codes%2FE0468.md", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_error_codes%2Ferror_codes%2FE0468.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0468.md?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -1,4 +1,4 @@\n-A non-root module attempts to import macros from another crate.\n+A non-root module tried to import macros from another crate.\n \n Example of erroneous code:\n \n@@ -17,7 +17,7 @@ Either move the macro import to crate root or do without the foreign macros.\n This will work:\n \n ```\n-#[macro_use(debug_assert)]\n+#[macro_use(debug_assert)] // ok!\n extern crate core;\n \n mod foo {"}, {"sha": "d46f1bc4cc4d82fa2f4db3ecdf3989b9ec260b72", "filename": "src/librustc_middle/mir/interpret/error.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -53,9 +53,8 @@ pub struct ConstEvalErr<'tcx> {\n \n #[derive(Debug)]\n pub struct FrameInfo<'tcx> {\n-    /// This span is in the caller.\n-    pub call_site: Span,\n     pub instance: ty::Instance<'tcx>,\n+    pub span: Span,\n     pub lint_root: Option<hir::HirId>,\n }\n \n@@ -65,12 +64,12 @@ impl<'tcx> fmt::Display for FrameInfo<'tcx> {\n             if tcx.def_key(self.instance.def_id()).disambiguated_data.data\n                 == DefPathData::ClosureExpr\n             {\n-                write!(f, \"inside call to closure\")?;\n+                write!(f, \"inside closure\")?;\n             } else {\n-                write!(f, \"inside call to `{}`\", self.instance)?;\n+                write!(f, \"inside `{}`\", self.instance)?;\n             }\n-            if !self.call_site.is_dummy() {\n-                let lo = tcx.sess.source_map().lookup_char_pos(self.call_site.lo());\n+            if !self.span.is_dummy() {\n+                let lo = tcx.sess.source_map().lookup_char_pos(self.span.lo());\n                 write!(f, \" at {}:{}:{}\", lo.file.name, lo.line, lo.col.to_usize() + 1)?;\n             }\n             Ok(())\n@@ -168,13 +167,10 @@ impl<'tcx> ConstEvalErr<'tcx> {\n             if let Some(span_msg) = span_msg {\n                 err.span_label(self.span, span_msg);\n             }\n-            // Add spans for the stacktrace.\n-            // Skip the last, which is just the environment of the constant.  The stacktrace\n-            // is sometimes empty because we create \"fake\" eval contexts in CTFE to do work\n-            // on constant values.\n-            if !self.stacktrace.is_empty() {\n-                for frame_info in &self.stacktrace[..self.stacktrace.len() - 1] {\n-                    err.span_label(frame_info.call_site, frame_info.to_string());\n+            // Add spans for the stacktrace. Don't print a single-line backtrace though.\n+            if self.stacktrace.len() > 1 {\n+                for frame_info in &self.stacktrace {\n+                    err.span_label(frame_info.span, frame_info.to_string());\n                 }\n             }\n             // Let the caller finish the job."}, {"sha": "a2793f98050048ceeed91f55138599f5ebe0982e", "filename": "src/librustc_middle/traits/specialization_graph.rs", "status": "modified", "additions": 59, "deletions": 11, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_middle%2Ftraits%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_middle%2Ftraits%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fspecialization_graph.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -154,14 +154,44 @@ impl Iterator for Ancestors<'_> {\n     }\n }\n \n-pub struct NodeItem<T> {\n-    pub node: Node,\n-    pub item: T,\n+/// Information about the most specialized definition of an associated item.\n+pub struct LeafDef {\n+    /// The associated item described by this `LeafDef`.\n+    pub item: ty::AssocItem,\n+\n+    /// The node in the specialization graph containing the definition of `item`.\n+    pub defining_node: Node,\n+\n+    /// The \"top-most\" (ie. least specialized) specialization graph node that finalized the\n+    /// definition of `item`.\n+    ///\n+    /// Example:\n+    ///\n+    /// ```\n+    /// trait Tr {\n+    ///     fn assoc(&self);\n+    /// }\n+    ///\n+    /// impl<T> Tr for T {\n+    ///     default fn assoc(&self) {}\n+    /// }\n+    ///\n+    /// impl Tr for u8 {}\n+    /// ```\n+    ///\n+    /// If we start the leaf definition search at `impl Tr for u8`, that impl will be the\n+    /// `finalizing_node`, while `defining_node` will be the generic impl.\n+    ///\n+    /// If the leaf definition search is started at the generic impl, `finalizing_node` will be\n+    /// `None`, since the most specialized impl we found still allows overriding the method\n+    /// (doesn't finalize it).\n+    pub finalizing_node: Option<Node>,\n }\n \n-impl<T> NodeItem<T> {\n-    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> NodeItem<U> {\n-        NodeItem { node: self.node, item: f(self.item) }\n+impl LeafDef {\n+    /// Returns whether this definition is known to not be further specializable.\n+    pub fn is_final(&self) -> bool {\n+        self.finalizing_node.is_some()\n     }\n }\n \n@@ -173,18 +203,36 @@ impl<'tcx> Ancestors<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         trait_item_name: Ident,\n         trait_item_kind: ty::AssocKind,\n-    ) -> Option<NodeItem<ty::AssocItem>> {\n+    ) -> Option<LeafDef> {\n         let trait_def_id = self.trait_def_id;\n+        let mut finalizing_node = None;\n+\n         self.find_map(|node| {\n-            node.item(tcx, trait_item_name, trait_item_kind, trait_def_id)\n-                .map(|item| NodeItem { node, item })\n+            if let Some(item) = node.item(tcx, trait_item_name, trait_item_kind, trait_def_id) {\n+                if finalizing_node.is_none() {\n+                    let is_specializable = item.defaultness.is_default()\n+                        || tcx.impl_defaultness(node.def_id()).is_default();\n+\n+                    if !is_specializable {\n+                        finalizing_node = Some(node);\n+                    }\n+                }\n+\n+                Some(LeafDef { item, defining_node: node, finalizing_node })\n+            } else {\n+                // Item not mentioned. This \"finalizes\" any defaulted item provided by an ancestor.\n+                finalizing_node = Some(node);\n+                None\n+            }\n         })\n     }\n }\n \n /// Walk up the specialization ancestors of a given impl, starting with that\n-/// impl itself. Returns `None` if an error was reported while building the\n-/// specialization graph.\n+/// impl itself.\n+///\n+/// Returns `Err` if an error was reported while building the specialization\n+/// graph.\n pub fn ancestors(\n     tcx: TyCtxt<'tcx>,\n     trait_def_id: DefId,"}, {"sha": "727d302d53f08216031929dbd2e9726526e18ba2", "filename": "src/librustc_middle/ty/layout.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_middle%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_middle%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flayout.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -230,7 +230,7 @@ enum StructKind {\n // Invert a bijective mapping, i.e. `invert(map)[y] = x` if `map[x] = y`.\n // This is used to go between `memory_index` (source field order to memory order)\n // and `inverse_memory_index` (memory order to source field order).\n-// See also `FieldPlacement::Arbitrary::memory_index` for more details.\n+// See also `FieldsShape::Arbitrary::memory_index` for more details.\n // FIXME(eddyb) build a better abstraction for permutations, if possible.\n fn invert_mapping(map: &[u32]) -> Vec<u32> {\n     let mut inverse = vec![0; map.len()];\n@@ -257,7 +257,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n         Layout {\n             variants: Variants::Single { index: VariantIdx::new(0) },\n-            fields: FieldPlacement::Arbitrary {\n+            fields: FieldsShape::Arbitrary {\n                 offsets: vec![Size::ZERO, b_offset],\n                 memory_index: vec![0, 1],\n             },\n@@ -443,7 +443,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         };\n                         let pair = self.scalar_pair(a.clone(), b.clone());\n                         let pair_offsets = match pair.fields {\n-                            FieldPlacement::Arbitrary { ref offsets, ref memory_index } => {\n+                            FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n                                 assert_eq!(memory_index, &[0, 1]);\n                                 offsets\n                             }\n@@ -471,7 +471,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n         Ok(Layout {\n             variants: Variants::Single { index: VariantIdx::new(0) },\n-            fields: FieldPlacement::Arbitrary { offsets, memory_index },\n+            fields: FieldsShape::Arbitrary { offsets, memory_index },\n             abi,\n             largest_niche,\n             align,\n@@ -520,7 +520,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             // The never type.\n             ty::Never => tcx.intern_layout(Layout {\n                 variants: Variants::Single { index: VariantIdx::new(0) },\n-                fields: FieldPlacement::Union(0),\n+                fields: FieldsShape::Union(0),\n                 abi: Abi::Uninhabited,\n                 largest_niche: None,\n                 align: dl.i8_align,\n@@ -581,7 +581,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                 tcx.intern_layout(Layout {\n                     variants: Variants::Single { index: VariantIdx::new(0) },\n-                    fields: FieldPlacement::Array { stride: element.size, count },\n+                    fields: FieldsShape::Array { stride: element.size, count },\n                     abi,\n                     largest_niche,\n                     align: element.align,\n@@ -592,7 +592,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 let element = self.layout_of(element)?;\n                 tcx.intern_layout(Layout {\n                     variants: Variants::Single { index: VariantIdx::new(0) },\n-                    fields: FieldPlacement::Array { stride: element.size, count: 0 },\n+                    fields: FieldsShape::Array { stride: element.size, count: 0 },\n                     abi: Abi::Aggregate { sized: false },\n                     largest_niche: None,\n                     align: element.align,\n@@ -601,7 +601,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             }\n             ty::Str => tcx.intern_layout(Layout {\n                 variants: Variants::Single { index: VariantIdx::new(0) },\n-                fields: FieldPlacement::Array { stride: Size::from_bytes(1), count: 0 },\n+                fields: FieldsShape::Array { stride: Size::from_bytes(1), count: 0 },\n                 abi: Abi::Aggregate { sized: false },\n                 largest_niche: None,\n                 align: dl.i8_align,\n@@ -670,7 +670,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                 tcx.intern_layout(Layout {\n                     variants: Variants::Single { index: VariantIdx::new(0) },\n-                    fields: FieldPlacement::Array { stride: element.size, count },\n+                    fields: FieldsShape::Array { stride: element.size, count },\n                     abi: Abi::Vector { element: scalar, count },\n                     largest_niche: element.largest_niche.clone(),\n                     size,\n@@ -746,7 +746,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                     return Ok(tcx.intern_layout(Layout {\n                         variants: Variants::Single { index },\n-                        fields: FieldPlacement::Union(variants[index].len()),\n+                        fields: FieldsShape::Union(variants[index].len()),\n                         abi,\n                         largest_niche: None,\n                         align,\n@@ -980,7 +980,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                                     discr_index: 0,\n                                     variants: st,\n                                 },\n-                                fields: FieldPlacement::Arbitrary {\n+                                fields: FieldsShape::Arbitrary {\n                                     offsets: vec![offset],\n                                     memory_index: vec![0],\n                                 },\n@@ -1121,7 +1121,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     let new_ity_size = ity.size();\n                     for variant in &mut layout_variants {\n                         match variant.fields {\n-                            FieldPlacement::Arbitrary { ref mut offsets, .. } => {\n+                            FieldsShape::Arbitrary { ref mut offsets, .. } => {\n                                 for i in offsets {\n                                     if *i <= old_ity_size {\n                                         assert_eq!(*i, old_ity_size);\n@@ -1151,7 +1151,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     let mut common_prim = None;\n                     for (field_layouts, layout_variant) in variants.iter().zip(&layout_variants) {\n                         let offsets = match layout_variant.fields {\n-                            FieldPlacement::Arbitrary { ref offsets, .. } => offsets,\n+                            FieldsShape::Arbitrary { ref offsets, .. } => offsets,\n                             _ => bug!(),\n                         };\n                         let mut fields =\n@@ -1187,7 +1187,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     if let Some((prim, offset)) = common_prim {\n                         let pair = self.scalar_pair(tag.clone(), scalar_unit(prim));\n                         let pair_offsets = match pair.fields {\n-                            FieldPlacement::Arbitrary { ref offsets, ref memory_index } => {\n+                            FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n                                 assert_eq!(memory_index, &[0, 1]);\n                                 offsets\n                             }\n@@ -1218,7 +1218,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         discr_index: 0,\n                         variants: layout_variants,\n                     },\n-                    fields: FieldPlacement::Arbitrary {\n+                    fields: FieldsShape::Arbitrary {\n                         offsets: vec![Size::ZERO],\n                         memory_index: vec![0],\n                     },\n@@ -1435,7 +1435,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         // GeneratorLayout.\n         debug!(\"prefix = {:#?}\", prefix);\n         let (outer_fields, promoted_offsets, promoted_memory_index) = match prefix.fields {\n-            FieldPlacement::Arbitrary { mut offsets, memory_index } => {\n+            FieldsShape::Arbitrary { mut offsets, memory_index } => {\n                 let mut inverse_memory_index = invert_mapping(&memory_index);\n \n                 // \"a\" (`0..b_start`) and \"b\" (`b_start..`) correspond to\n@@ -1458,7 +1458,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 let memory_index_b = invert_mapping(&inverse_memory_index_b);\n \n                 let outer_fields =\n-                    FieldPlacement::Arbitrary { offsets: offsets_a, memory_index: memory_index_a };\n+                    FieldsShape::Arbitrary { offsets: offsets_a, memory_index: memory_index_a };\n                 (outer_fields, offsets_b, memory_index_b)\n             }\n             _ => bug!(),\n@@ -1492,7 +1492,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 variant.variants = Variants::Single { index };\n \n                 let (offsets, memory_index) = match variant.fields {\n-                    FieldPlacement::Arbitrary { offsets, memory_index } => (offsets, memory_index),\n+                    FieldsShape::Arbitrary { offsets, memory_index } => (offsets, memory_index),\n                     _ => bug!(),\n                 };\n \n@@ -1535,7 +1535,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 combined_inverse_memory_index.retain(|&i| i != INVALID_FIELD_IDX);\n                 let combined_memory_index = invert_mapping(&combined_inverse_memory_index);\n \n-                variant.fields = FieldPlacement::Arbitrary {\n+                variant.fields = FieldsShape::Arbitrary {\n                     offsets: combined_offsets,\n                     memory_index: combined_memory_index,\n                 };\n@@ -1990,7 +1990,7 @@ where\n                 if index == variant_index &&\n                 // Don't confuse variants of uninhabited enums with the enum itself.\n                 // For more details see https://github.com/rust-lang/rust/issues/69763.\n-                this.fields != FieldPlacement::Union(0) =>\n+                this.fields != FieldsShape::Union(0) =>\n             {\n                 this.layout\n             }\n@@ -2008,7 +2008,7 @@ where\n                 let tcx = cx.tcx();\n                 tcx.intern_layout(Layout {\n                     variants: Variants::Single { index: variant_index },\n-                    fields: FieldPlacement::Union(fields),\n+                    fields: FieldsShape::Union(fields),\n                     abi: Abi::Uninhabited,\n                     largest_niche: None,\n                     align: tcx.data_layout.i8_align,\n@@ -2054,7 +2054,7 @@ where\n                 // Reuse the fat `*T` type as its own thin pointer data field.\n                 // This provides information about, e.g., DST struct pointees\n                 // (which may have no non-DST form), and will work as long\n-                // as the `Abi` or `FieldPlacement` is checked by users.\n+                // as the `Abi` or `FieldsShape` is checked by users.\n                 if i == 0 {\n                     let nil = tcx.mk_unit();\n                     let ptr_ty = if this.ty.is_unsafe_ptr() {\n@@ -2219,7 +2219,7 @@ where\n \n                 if let Some(variant) = data_variant {\n                     // We're not interested in any unions.\n-                    if let FieldPlacement::Union(_) = variant.fields {\n+                    if let FieldsShape::Union(_) = variant.fields {\n                         data_variant = None;\n                     }\n                 }"}, {"sha": "f7e28cf8d8c2f2ebfbd7715e0d0182a73a38eef2", "filename": "src/librustc_mir/const_eval/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -55,6 +55,6 @@ pub fn error_to_const_error<'mir, 'tcx, M: Machine<'mir, 'tcx>>(\n     mut error: InterpErrorInfo<'tcx>,\n ) -> ConstEvalErr<'tcx> {\n     error.print_backtrace();\n-    let stacktrace = ecx.generate_stacktrace(None);\n+    let stacktrace = ecx.generate_stacktrace();\n     ConstEvalErr { error: error.kind, stacktrace, span: ecx.tcx.span }\n }"}, {"sha": "af79198ef6415631ae80ec419fefccba5aaead7c", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -46,7 +46,6 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n \n     ecx.push_stack_frame(\n         cid.instance,\n-        body.span,\n         body,\n         Some(ret.into()),\n         StackPopCleanup::None { cleanup: false },"}, {"sha": "e92634714789495b383426a3d58b654235544f9d", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -8,9 +8,9 @@ use std::hash::Hash;\n use rustc_data_structures::fx::FxHashMap;\n \n use rustc_ast::ast::Mutability;\n+use rustc_hir::def_id::DefId;\n use rustc_middle::mir::AssertMessage;\n use rustc_span::symbol::Symbol;\n-use rustc_span::{def_id::DefId, Span};\n \n use crate::interpret::{\n     self, AllocId, Allocation, GlobalId, ImmTy, InterpCx, InterpResult, Memory, MemoryKind, OpTy,\n@@ -64,7 +64,6 @@ impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter> {\n     /// If this returns successfully (`Ok`), the function should just be evaluated normally.\n     fn hook_panic_fn(\n         &mut self,\n-        span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n     ) -> InterpResult<'tcx> {\n@@ -77,7 +76,7 @@ impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter> {\n \n             let msg_place = self.deref_operand(args[0])?;\n             let msg = Symbol::intern(self.read_str(msg_place)?);\n-            let span = self.find_closest_untracked_caller_location().unwrap_or(span);\n+            let span = self.find_closest_untracked_caller_location();\n             let (file, line, col) = self.location_triple_for_span(span);\n             Err(ConstEvalErrKind::Panic { msg, file, line, col }.into())\n         } else {\n@@ -191,7 +190,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter {\n \n     fn find_mir_or_eval_fn(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n@@ -213,7 +211,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter {\n             } else {\n                 // Some functions we support even if they are non-const -- but avoid testing\n                 // that for const fn!\n-                ecx.hook_panic_fn(span, instance, args)?;\n+                ecx.hook_panic_fn(instance, args)?;\n                 // We certainly do *not* want to actually call the fn\n                 // though, so be sure we return here.\n                 throw_unsup_format!(\"calling non-const function `{}`\", instance)\n@@ -248,13 +246,12 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter {\n \n     fn call_intrinsic(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n         _unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n-        if ecx.emulate_intrinsic(span, instance, args, ret)? {\n+        if ecx.emulate_intrinsic(instance, args, ret)? {\n             return Ok(());\n         }\n         // An intrinsic that we do not support"}, {"sha": "8f24fc451bc3f724af40b531b39e8907b7cf5f11", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 7, "deletions": 26, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::ty::layout::{self, Align, HasDataLayout, LayoutOf, Size, TyAnd\n use rustc_middle::ty::query::TyCtxtAt;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc_span::source_map::{self, Span, DUMMY_SP};\n+use rustc_span::source_map::DUMMY_SP;\n \n use super::{\n     Immediate, MPlaceTy, Machine, MemPlace, MemPlaceMeta, Memory, OpTy, Operand, Place, PlaceTy,\n@@ -57,9 +57,6 @@ pub struct Frame<'mir, 'tcx, Tag = (), Extra = ()> {\n     /// The def_id and substs of the current function.\n     pub instance: ty::Instance<'tcx>,\n \n-    /// The span of the call site.\n-    pub span: source_map::Span,\n-\n     /// Extra data for the machine.\n     pub extra: Extra,\n \n@@ -502,7 +499,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn push_stack_frame(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        span: Span,\n         body: &'mir mir::Body<'tcx>,\n         return_place: Option<PlaceTy<'tcx, M::PointerTag>>,\n         return_to_block: StackPopCleanup,\n@@ -522,7 +518,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // empty local array, we fill it in below, after we are inside the stack frame and\n             // all methods actually know about the frame\n             locals: IndexVec::new(),\n-            span,\n             instance,\n             stmt: 0,\n             extra,\n@@ -541,7 +536,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // statics and constants don't have `Storage*` statements, no need to look for them\n                 Some(DefKind::Static) | Some(DefKind::Const) | Some(DefKind::AssocConst) => {}\n                 _ => {\n-                    trace!(\"push_stack_frame: {:?}: num_bbs: {}\", span, body.basic_blocks().len());\n                     for block in body.basic_blocks() {\n                         for stmt in block.statements.iter() {\n                             use rustc_middle::mir::StatementKind::{StorageDead, StorageLive};\n@@ -859,33 +853,21 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n     }\n \n-    pub fn generate_stacktrace(&self, explicit_span: Option<Span>) -> Vec<FrameInfo<'tcx>> {\n-        let mut last_span = None;\n+    pub fn generate_stacktrace(&self) -> Vec<FrameInfo<'tcx>> {\n         let mut frames = Vec::new();\n         for frame in self.stack().iter().rev() {\n-            // make sure we don't emit frames that are duplicates of the previous\n-            if explicit_span == Some(frame.span) {\n-                last_span = Some(frame.span);\n-                continue;\n-            }\n-            if let Some(last) = last_span {\n-                if last == frame.span {\n-                    continue;\n-                }\n-            } else {\n-                last_span = Some(frame.span);\n-            }\n-\n-            let lint_root = frame.current_source_info().and_then(|source_info| {\n+            let source_info = frame.current_source_info();\n+            let lint_root = source_info.and_then(|source_info| {\n                 match &frame.body.source_scopes[source_info.scope].local_data {\n                     mir::ClearCrossCrate::Set(data) => Some(data.lint_root),\n                     mir::ClearCrossCrate::Clear => None,\n                 }\n             });\n+            let span = source_info.map_or(DUMMY_SP, |source_info| source_info.span);\n \n-            frames.push(FrameInfo { call_site: frame.span, instance: frame.instance, lint_root });\n+            frames.push(FrameInfo { span, instance: frame.instance, lint_root });\n         }\n-        trace!(\"generate stacktrace: {:#?}, {:?}\", frames, explicit_span);\n+        trace!(\"generate stacktrace: {:#?}\", frames);\n         frames\n     }\n }\n@@ -899,7 +881,6 @@ where\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'ctx>, hasher: &mut StableHasher) {\n         self.body.hash_stable(hcx, hasher);\n         self.instance.hash_stable(hcx, hasher);\n-        self.span.hash_stable(hcx, hasher);\n         self.return_to_block.hash_stable(hcx, hasher);\n         self.return_place.as_ref().map(|r| &**r).hash_stable(hcx, hasher);\n         self.locals.hash_stable(hcx, hasher);"}, {"sha": "b60377fbcd69a261dfb4a0d3b0b5499a58220d89", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -15,7 +15,6 @@ use rustc_middle::ty::layout::{LayoutOf, Primitive, Size};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::Span;\n \n use super::{ImmTy, InterpCx, Machine, OpTy, PlaceTy};\n \n@@ -78,7 +77,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Returns `true` if emulation happened.\n     pub fn emulate_intrinsic(\n         &mut self,\n-        span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, M::PointerTag>],\n         ret: Option<(PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n@@ -101,7 +99,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // `src/librustc_middle/ty/constness.rs`\n         match intrinsic_name {\n             sym::caller_location => {\n-                let span = self.find_closest_untracked_caller_location().unwrap_or(span);\n+                let span = self.find_closest_untracked_caller_location();\n                 let location = self.alloc_caller_location_for_span(span);\n                 self.write_scalar(location.ptr, dest)?;\n             }\n@@ -118,7 +116,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     sym::needs_drop => self.tcx.types.bool,\n                     sym::type_id => self.tcx.types.u64,\n                     sym::type_name => self.tcx.mk_static_str(),\n-                    _ => span_bug!(span, \"Already checked for nullary intrinsics\"),\n+                    _ => bug!(\"already checked for nullary intrinsics\"),\n                 };\n                 let val = self.const_eval(gid, ty)?;\n                 self.copy_op(val, dest)?;"}, {"sha": "f7e264b01d16df1d27f10ac7e1caf5f608cdcf54", "filename": "src/librustc_mir/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -12,18 +12,21 @@ use crate::interpret::{\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Walks up the callstack from the intrinsic's callsite, searching for the first callsite in a\n-    /// frame which is not `#[track_caller]`. If the first frame found lacks `#[track_caller]`, then\n-    /// `None` is returned and the callsite of the function invocation itself should be used.\n-    crate fn find_closest_untracked_caller_location(&self) -> Option<Span> {\n-        let mut caller_span = None;\n-        for next_caller in self.stack.iter().rev() {\n-            if !next_caller.instance.def.requires_caller_location(*self.tcx) {\n-                return caller_span;\n-            }\n-            caller_span = Some(next_caller.span);\n-        }\n-\n-        caller_span\n+    /// frame which is not `#[track_caller]`.\n+    crate fn find_closest_untracked_caller_location(&self) -> Span {\n+        self.stack\n+            .iter()\n+            .rev()\n+            // Find first non-`#[track_caller]` frame.\n+            .find(|frame| !frame.instance.def.requires_caller_location(*self.tcx))\n+            // Assert that there is always such a frame.\n+            .unwrap()\n+            .current_source_info()\n+            // Assert that the frame we look at is actually executing code currently\n+            // (`current_source_info` is None when we are unwinding and the frame does\n+            // not require cleanup).\n+            .unwrap()\n+            .span\n     }\n \n     /// Allocate a `const core::panic::Location` with the provided filename and line/column numbers."}, {"sha": "48082a1e3469680126ecbb62ad9da812ada31cdb", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -7,7 +7,7 @@ use std::hash::Hash;\n \n use rustc_middle::mir;\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::{def_id::DefId, Span};\n+use rustc_span::def_id::DefId;\n \n use super::{\n     AllocId, Allocation, AllocationExtra, Frame, ImmTy, InterpCx, InterpResult, Memory, MemoryKind,\n@@ -135,7 +135,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// was used.\n     fn find_mir_or_eval_fn(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         ret: Option<(PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,\n@@ -156,7 +155,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// responsibility to advance the instruction pointer as appropriate.\n     fn call_intrinsic(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         ret: Option<(PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,"}, {"sha": "a8e65a7e7f5a983bc37a141a5fb62937ebfd82ed", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -219,7 +219,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n             // Go through the layout.  There are lots of types that support a length,\n             // e.g., SIMD types.\n             match self.layout.fields {\n-                layout::FieldPlacement::Array { count, .. } => Ok(count),\n+                layout::FieldsShape::Array { count, .. } => Ok(count),\n                 _ => bug!(\"len not supported on sized type {:?}\", self.layout.ty),\n             }\n         }\n@@ -437,7 +437,7 @@ where\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // Not using the layout method because we want to compute on u64\n         match base.layout.fields {\n-            layout::FieldPlacement::Array { stride, .. } => {\n+            layout::FieldsShape::Array { stride, .. } => {\n                 let len = base.len(self)?;\n                 if index >= len {\n                     // This can only be reached in ConstProp and non-rustc-MIR.\n@@ -463,7 +463,7 @@ where\n     {\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         let stride = match base.layout.fields {\n-            layout::FieldPlacement::Array { stride, .. } => stride,\n+            layout::FieldsShape::Array { stride, .. } => stride,\n             _ => bug!(\"mplace_array_fields: expected an array layout\"),\n         };\n         let layout = base.layout.field(self, 0)?;\n@@ -493,7 +493,7 @@ where\n         // Not using layout method because that works with usize, and does not work with slices\n         // (that have count 0 in their layout).\n         let from_offset = match base.layout.fields {\n-            layout::FieldPlacement::Array { stride, .. } => stride * from, // `Size` multiplication is checked\n+            layout::FieldsShape::Array { stride, .. } => stride * from, // `Size` multiplication is checked\n             _ => bug!(\"Unexpected layout of index access: {:#?}\", base.layout),\n         };\n "}, {"sha": "6ca6f50b0ee7c35b1dcf8a4d6016d6a8b737ffe5", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -4,7 +4,6 @@ use std::convert::TryFrom;\n use rustc_middle::ty::layout::{self, LayoutOf, TyAndLayout};\n use rustc_middle::ty::Instance;\n use rustc_middle::{mir, ty};\n-use rustc_span::source_map::Span;\n use rustc_target::spec::abi::Abi;\n \n use super::{\n@@ -71,14 +70,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Some((dest, ret)) => Some((self.eval_place(dest)?, ret)),\n                     None => None,\n                 };\n-                self.eval_fn_call(\n-                    fn_val,\n-                    terminator.source_info.span,\n-                    abi,\n-                    &args[..],\n-                    ret,\n-                    *cleanup,\n-                )?;\n+                self.eval_fn_call(fn_val, abi, &args[..], ret, *cleanup)?;\n             }\n \n             Drop { location, target, unwind } => {\n@@ -88,7 +80,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 trace!(\"TerminatorKind::drop: {:?}, type {}\", location, ty);\n \n                 let instance = Instance::resolve_drop_in_place(*self.tcx, ty);\n-                self.drop_in_place(place, instance, terminator.source_info.span, target, unwind)?;\n+                self.drop_in_place(place, instance, target, unwind)?;\n             }\n \n             Assert { ref cond, expected, ref msg, target, cleanup } => {\n@@ -196,7 +188,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn eval_fn_call(\n         &mut self,\n         fn_val: FnVal<'tcx, M::ExtraFnVal>,\n-        span: Span,\n         caller_abi: Abi,\n         args: &[OpTy<'tcx, M::PointerTag>],\n         ret: Option<(PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n@@ -242,7 +233,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match instance.def {\n             ty::InstanceDef::Intrinsic(..) => {\n                 assert!(caller_abi == Abi::RustIntrinsic || caller_abi == Abi::PlatformIntrinsic);\n-                M::call_intrinsic(self, span, instance, args, ret, unwind)\n+                M::call_intrinsic(self, instance, args, ret, unwind)\n             }\n             ty::InstanceDef::VtableShim(..)\n             | ty::InstanceDef::ReifyShim(..)\n@@ -252,14 +243,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | ty::InstanceDef::CloneShim(..)\n             | ty::InstanceDef::Item(_) => {\n                 // We need MIR for this fn\n-                let body = match M::find_mir_or_eval_fn(self, span, instance, args, ret, unwind)? {\n+                let body = match M::find_mir_or_eval_fn(self, instance, args, ret, unwind)? {\n                     Some(body) => body,\n                     None => return Ok(()),\n                 };\n \n                 self.push_stack_frame(\n                     instance,\n-                    span,\n                     body,\n                     ret.map(|p| p.0),\n                     StackPopCleanup::Goto { ret: ret.map(|p| p.1), unwind },\n@@ -407,7 +397,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     OpTy::from(ImmTy { layout: this_receiver_ptr, imm: receiver_place.ptr.into() });\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n-                self.eval_fn_call(drop_fn, span, caller_abi, &args, ret, unwind)\n+                self.eval_fn_call(drop_fn, caller_abi, &args, ret, unwind)\n             }\n         }\n     }\n@@ -416,7 +406,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &mut self,\n         place: PlaceTy<'tcx, M::PointerTag>,\n         instance: ty::Instance<'tcx>,\n-        span: Span,\n         target: mir::BasicBlock,\n         unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n@@ -444,7 +433,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         self.eval_fn_call(\n             FnVal::Instance(instance),\n-            span,\n             Abi::Rust,\n             &[arg.into()],\n             Some((dest.into(), target)),"}, {"sha": "66a46c12c062fd64336fa715fe3fcf14d98026bc", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -207,10 +207,10 @@ macro_rules! make_value_visitor {\n \n                 // Visit the fields of this value.\n                 match v.layout().fields {\n-                    layout::FieldPlacement::Union(fields) => {\n+                    layout::FieldsShape::Union(fields) => {\n                         self.visit_union(v, fields)?;\n                     },\n-                    layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n+                    layout::FieldsShape::Arbitrary { ref offsets, .. } => {\n                         // FIXME: We collect in a vec because otherwise there are lifetime\n                         // errors: Projecting to a field needs access to `ecx`.\n                         let fields: Vec<InterpResult<'tcx, Self::V>> =\n@@ -220,7 +220,7 @@ macro_rules! make_value_visitor {\n                             .collect();\n                         self.visit_aggregate(v, fields.into_iter())?;\n                     },\n-                    layout::FieldPlacement::Array { .. } => {\n+                    layout::FieldsShape::Array { .. } => {\n                         // Let's get an mplace first.\n                         let mplace = v.to_op(self.ecx())?.assert_mem_place(self.ecx());\n                         // Now we can go over all the fields."}, {"sha": "f4cba875620ebe3c29b1b20b47e51b5811efddc1", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -183,7 +183,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n \n     fn find_mir_or_eval_fn(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _span: Span,\n         _instance: ty::Instance<'tcx>,\n         _args: &[OpTy<'tcx>],\n         _ret: Option<(PlaceTy<'tcx>, BasicBlock)>,\n@@ -204,7 +203,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n \n     fn call_intrinsic(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _span: Span,\n         _instance: ty::Instance<'tcx>,\n         _args: &[OpTy<'tcx>],\n         _ret: Option<(PlaceTy<'tcx>, BasicBlock)>,\n@@ -361,7 +359,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n         ecx.push_stack_frame(\n             Instance::new(def_id, substs),\n-            span,\n             dummy_body,\n             ret.map(Into::into),\n             StackPopCleanup::None { cleanup: false },"}, {"sha": "81de6306788908bfd1eabf5dd0a136265496e8f0", "filename": "src/librustc_target/abi/call/mips64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -49,7 +49,7 @@ where\n         // use of float registers to structures (not unions) containing exactly one or two\n         // float fields.\n \n-        if let abi::FieldPlacement::Arbitrary { .. } = ret.layout.fields {\n+        if let abi::FieldsShape::Arbitrary { .. } = ret.layout.fields {\n             if ret.layout.fields.count() == 1 {\n                 if let Some(reg) = float_reg(cx, ret, 0) {\n                     ret.cast_to(reg);\n@@ -88,15 +88,15 @@ where\n     let mut prefix_index = 0;\n \n     match arg.layout.fields {\n-        abi::FieldPlacement::Array { .. } => {\n+        abi::FieldsShape::Array { .. } => {\n             // Arrays are passed indirectly\n             arg.make_indirect();\n             return;\n         }\n-        abi::FieldPlacement::Union(_) => {\n+        abi::FieldsShape::Union(_) => {\n             // Unions and are always treated as a series of 64-bit integer chunks\n         }\n-        abi::FieldPlacement::Arbitrary { .. } => {\n+        abi::FieldsShape::Arbitrary { .. } => {\n             // Structures are split up into a series of 64-bit integer chunks, but any aligned\n             // doubles not part of another aggregate are passed as floats.\n             let mut last_offset = Size::ZERO;"}, {"sha": "b6bfa70005b5e6359416fdf9aee1fb30d8a8125c", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -1,4 +1,4 @@\n-use crate::abi::{self, Abi, Align, FieldPlacement, Size};\n+use crate::abi::{self, Abi, Align, FieldsShape, Size};\n use crate::abi::{HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n use crate::spec::{self, HasTargetSpec};\n \n@@ -315,7 +315,7 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n                      start: Size|\n                      -> Result<(HomogeneousAggregate, Size), Heterogeneous> {\n                         let is_union = match layout.fields {\n-                            FieldPlacement::Array { count, .. } => {\n+                            FieldsShape::Array { count, .. } => {\n                                 assert_eq!(start, Size::ZERO);\n \n                                 let result = if count > 0 {\n@@ -325,8 +325,8 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n                                 };\n                                 return Ok((result, layout.size));\n                             }\n-                            FieldPlacement::Union(_) => true,\n-                            FieldPlacement::Arbitrary { .. } => false,\n+                            FieldsShape::Union(_) => true,\n+                            FieldsShape::Arbitrary { .. } => false,\n                         };\n \n                         let mut result = HomogeneousAggregate::NoData;"}, {"sha": "0eb8816e4346195672a30f42f6956bd48189c6e0", "filename": "src/librustc_target/abi/call/riscv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_target%2Fabi%2Fcall%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_target%2Fabi%2Fcall%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Friscv.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -6,7 +6,7 @@\n \n use crate::abi::call::{ArgAbi, ArgAttribute, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};\n use crate::abi::{\n-    self, Abi, FieldPlacement, HasDataLayout, LayoutOf, Size, TyAndLayout, TyAndLayoutMethods,\n+    self, Abi, FieldsShape, HasDataLayout, LayoutOf, Size, TyAndLayout, TyAndLayoutMethods,\n };\n use crate::spec::HasTargetSpec;\n \n@@ -87,12 +87,12 @@ where\n         },\n         Abi::Vector { .. } | Abi::Uninhabited => return Err(CannotUseFpConv),\n         Abi::ScalarPair(..) | Abi::Aggregate { .. } => match arg_layout.fields {\n-            FieldPlacement::Union(_) => {\n+            FieldsShape::Union(_) => {\n                 if !arg_layout.is_zst() {\n                     return Err(CannotUseFpConv);\n                 }\n             }\n-            FieldPlacement::Array { count, .. } => {\n+            FieldsShape::Array { count, .. } => {\n                 for _ in 0..count {\n                     let elem_layout = arg_layout.field(cx, 0);\n                     should_use_fp_conv_helper(\n@@ -105,7 +105,7 @@ where\n                     )?;\n                 }\n             }\n-            FieldPlacement::Arbitrary { .. } => {\n+            FieldsShape::Arbitrary { .. } => {\n                 match arg_layout.variants {\n                     abi::Variants::Multiple { .. } => return Err(CannotUseFpConv),\n                     abi::Variants::Single { .. } => (),"}, {"sha": "f382ef984be24a3b3ceba77b89b6f3f0950395c3", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -618,7 +618,7 @@ impl Scalar {\n \n /// Describes how the fields of a type are located in memory.\n #[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n-pub enum FieldPlacement {\n+pub enum FieldsShape {\n     /// All fields start at no offset. The `usize` is the field count.\n     ///\n     /// In the case of primitives the number of fields is `0`.\n@@ -657,38 +657,38 @@ pub enum FieldPlacement {\n     },\n }\n \n-impl FieldPlacement {\n+impl FieldsShape {\n     pub fn count(&self) -> usize {\n         match *self {\n-            FieldPlacement::Union(count) => count,\n-            FieldPlacement::Array { count, .. } => {\n+            FieldsShape::Union(count) => count,\n+            FieldsShape::Array { count, .. } => {\n                 let usize_count = count as usize;\n                 assert_eq!(usize_count as u64, count);\n                 usize_count\n             }\n-            FieldPlacement::Arbitrary { ref offsets, .. } => offsets.len(),\n+            FieldsShape::Arbitrary { ref offsets, .. } => offsets.len(),\n         }\n     }\n \n     pub fn offset(&self, i: usize) -> Size {\n         match *self {\n-            FieldPlacement::Union(count) => {\n+            FieldsShape::Union(count) => {\n                 assert!(i < count, \"tried to access field {} of union with {} fields\", i, count);\n                 Size::ZERO\n             }\n-            FieldPlacement::Array { stride, count } => {\n+            FieldsShape::Array { stride, count } => {\n                 let i = u64::try_from(i).unwrap();\n                 assert!(i < count);\n                 stride * i\n             }\n-            FieldPlacement::Arbitrary { ref offsets, .. } => offsets[i],\n+            FieldsShape::Arbitrary { ref offsets, .. } => offsets[i],\n         }\n     }\n \n     pub fn memory_index(&self, i: usize) -> usize {\n         match *self {\n-            FieldPlacement::Union(_) | FieldPlacement::Array { .. } => i,\n-            FieldPlacement::Arbitrary { ref memory_index, .. } => {\n+            FieldsShape::Union(_) | FieldsShape::Array { .. } => i,\n+            FieldsShape::Arbitrary { ref memory_index, .. } => {\n                 let r = memory_index[i];\n                 assert_eq!(r as usize as u32, r);\n                 r as usize\n@@ -704,7 +704,7 @@ impl FieldPlacement {\n         let use_small = self.count() <= inverse_small.len();\n \n         // We have to write this logic twice in order to keep the array small.\n-        if let FieldPlacement::Arbitrary { ref memory_index, .. } = *self {\n+        if let FieldsShape::Arbitrary { ref memory_index, .. } = *self {\n             if use_small {\n                 for i in 0..self.count() {\n                     inverse_small[memory_index[i] as usize] = i as u8;\n@@ -718,8 +718,8 @@ impl FieldPlacement {\n         }\n \n         (0..self.count()).map(move |i| match *self {\n-            FieldPlacement::Union(_) | FieldPlacement::Array { .. } => i,\n-            FieldPlacement::Arbitrary { .. } => {\n+            FieldsShape::Union(_) | FieldsShape::Array { .. } => i,\n+            FieldsShape::Arbitrary { .. } => {\n                 if use_small {\n                     inverse_small[i] as usize\n                 } else {\n@@ -888,7 +888,7 @@ impl Niche {\n pub struct Layout {\n     /// Says where the fields are located within the layout.\n     /// Primitives and uninhabited enums appear as unions without fields.\n-    pub fields: FieldPlacement,\n+    pub fields: FieldsShape,\n \n     /// Encodes information about multi-variant layouts.\n     /// Even with `Multiple` variants, a layout still has its own fields! Those are then\n@@ -923,7 +923,7 @@ impl Layout {\n         let align = scalar.value.align(cx);\n         Layout {\n             variants: Variants::Single { index: VariantIdx::new(0) },\n-            fields: FieldPlacement::Union(0),\n+            fields: FieldsShape::Union(0),\n             abi: Abi::Scalar(scalar),\n             largest_niche,\n             size,"}, {"sha": "5f98850633075f5540ef1526b95983032c927aa5", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -54,7 +54,6 @@ pub use self::project::{\n };\n pub use self::select::{EvaluationCache, SelectionCache, SelectionContext};\n pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};\n-pub use self::specialize::find_associated_item;\n pub use self::specialize::specialization_graph::FutureCompatOverlapError;\n pub use self::specialize::specialization_graph::FutureCompatOverlapErrorKind;\n pub use self::specialize::{specialization_graph, translate_substs, OverlapError};\n@@ -64,8 +63,7 @@ pub use self::structural_match::NonStructuralMatchTy;\n pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_refs};\n pub use self::util::{expand_trait_aliases, TraitAliasExpander};\n pub use self::util::{\n-    get_vtable_index_of_object_method, impl_is_default, impl_item_is_final,\n-    predicate_for_trait_def, upcast_choices,\n+    get_vtable_index_of_object_method, impl_item_is_final, predicate_for_trait_def, upcast_choices,\n };\n pub use self::util::{\n     supertrait_def_ids, supertraits, transitive_bounds, SupertraitDefIds, Supertraits,"}, {"sha": "aae0d46756331310c063f589ac859f2de4bd37de", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 11, "deletions": 37, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -1015,49 +1015,21 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                     assoc_ty_def(selcx, impl_data.impl_def_id, obligation.predicate.item_def_id)\n                         .map_err(|ErrorReported| ())?;\n \n-                let is_default = if node_item.node.is_from_trait() {\n-                    // If true, the impl inherited a `type Foo = Bar`\n-                    // given in the trait, which is implicitly default.\n-                    // Otherwise, the impl did not specify `type` and\n-                    // neither did the trait:\n-                    //\n-                    // ```rust\n-                    // trait Foo { type T; }\n-                    // impl Foo for Bar { }\n-                    // ```\n-                    //\n-                    // This is an error, but it will be\n-                    // reported in `check_impl_items_against_trait`.\n-                    // We accept it here but will flag it as\n-                    // an error when we confirm the candidate\n-                    // (which will ultimately lead to `normalize_to_error`\n-                    // being invoked).\n-                    false\n+                if node_item.is_final() {\n+                    // Non-specializable items are always projectable.\n+                    true\n                 } else {\n-                    // If we're looking at a trait *impl*, the item is\n-                    // specializable if the impl or the item are marked\n-                    // `default`.\n-                    node_item.item.defaultness.is_default()\n-                        || super::util::impl_is_default(selcx.tcx(), node_item.node.def_id())\n-                };\n-\n-                match is_default {\n-                    // Non-specializable items are always projectable\n-                    false => true,\n-\n                     // Only reveal a specializable default if we're past type-checking\n                     // and the obligation is monomorphic, otherwise passes such as\n                     // transmute checking and polymorphic MIR optimizations could\n                     // get a result which isn't correct for all monomorphizations.\n-                    true if obligation.param_env.reveal == Reveal::All => {\n+                    if obligation.param_env.reveal == Reveal::All {\n                         // NOTE(eddyb) inference variables can resolve to parameters, so\n                         // assume `poly_trait_ref` isn't monomorphic, if it contains any.\n                         let poly_trait_ref =\n                             selcx.infcx().resolve_vars_if_possible(&poly_trait_ref);\n                         !poly_trait_ref.needs_infer() && !poly_trait_ref.needs_subst()\n-                    }\n-\n-                    true => {\n+                    } else {\n                         debug!(\n                             \"assemble_candidates_from_impls: not eligible due to default: \\\n                              assoc_ty={} predicate={}\",\n@@ -1422,7 +1394,8 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n         return Progress { ty: tcx.types.err, obligations: nested };\n     }\n     let substs = obligation.predicate.substs.rebase_onto(tcx, trait_def_id, substs);\n-    let substs = translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ty.node);\n+    let substs =\n+        translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ty.defining_node);\n     let ty = if let ty::AssocKind::OpaqueTy = assoc_ty.item.kind {\n         let item_substs = InternalSubsts::identity_for_item(tcx, assoc_ty.item.def_id);\n         tcx.mk_opaque(assoc_ty.item.def_id, item_substs)\n@@ -1447,7 +1420,7 @@ fn assoc_ty_def(\n     selcx: &SelectionContext<'_, '_>,\n     impl_def_id: DefId,\n     assoc_ty_def_id: DefId,\n-) -> Result<specialization_graph::NodeItem<ty::AssocItem>, ErrorReported> {\n+) -> Result<specialization_graph::LeafDef, ErrorReported> {\n     let tcx = selcx.tcx();\n     let assoc_ty_name = tcx.associated_item(assoc_ty_def_id).ident;\n     let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n@@ -1464,9 +1437,10 @@ fn assoc_ty_def(\n         if matches!(item.kind, ty::AssocKind::Type | ty::AssocKind::OpaqueTy)\n             && tcx.hygienic_eq(item.ident, assoc_ty_name, trait_def_id)\n         {\n-            return Ok(specialization_graph::NodeItem {\n-                node: specialization_graph::Node::Impl(impl_def_id),\n+            return Ok(specialization_graph::LeafDef {\n                 item: *item,\n+                defining_node: impl_node,\n+                finalizing_node: if item.defaultness.is_default() { None } else { Some(impl_node) },\n             });\n         }\n     }"}, {"sha": "fabd8c89b72af7e075e8476bf747495f9a6d26d9", "filename": "src/librustc_trait_selection/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 43, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -20,7 +20,7 @@ use rustc_errors::struct_span_err;\n use rustc_hir::def_id::DefId;\n use rustc_middle::lint::LintDiagnosticBuilder;\n use rustc_middle::ty::subst::{InternalSubsts, Subst, SubstsRef};\n-use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::lint::builtin::COHERENCE_LEAK_CHECK;\n use rustc_session::lint::builtin::ORDER_DEPENDENT_TRAIT_OBJECTS;\n use rustc_span::DUMMY_SP;\n@@ -112,48 +112,6 @@ pub fn translate_substs<'a, 'tcx>(\n     source_substs.rebase_onto(infcx.tcx, source_impl, target_substs)\n }\n \n-/// Given a selected impl described by `impl_data`, returns the\n-/// definition and substitutions for the method with the name `name`\n-/// the kind `kind`, and trait method substitutions `substs`, in\n-/// that impl, a less specialized impl, or the trait default,\n-/// whichever applies.\n-pub fn find_associated_item<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    item: &ty::AssocItem,\n-    substs: SubstsRef<'tcx>,\n-    impl_data: &super::VtableImplData<'tcx, ()>,\n-) -> (DefId, SubstsRef<'tcx>) {\n-    debug!(\"find_associated_item({:?}, {:?}, {:?}, {:?})\", param_env, item, substs, impl_data);\n-    assert!(!substs.needs_infer());\n-\n-    let trait_def_id = tcx.trait_id_of_impl(impl_data.impl_def_id).unwrap();\n-    let trait_def = tcx.trait_def(trait_def_id);\n-\n-    if let Ok(ancestors) = trait_def.ancestors(tcx, impl_data.impl_def_id) {\n-        match ancestors.leaf_def(tcx, item.ident, item.kind) {\n-            Some(node_item) => {\n-                let substs = tcx.infer_ctxt().enter(|infcx| {\n-                    let param_env = param_env.with_reveal_all();\n-                    let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n-                    let substs = translate_substs(\n-                        &infcx,\n-                        param_env,\n-                        impl_data.impl_def_id,\n-                        substs,\n-                        node_item.node,\n-                    );\n-                    infcx.tcx.erase_regions(&substs)\n-                });\n-                (node_item.item.def_id, substs)\n-            }\n-            None => bug!(\"{:?} not found in {:?}\", item, impl_data.impl_def_id),\n-        }\n-    } else {\n-        (item.def_id, substs)\n-    }\n-}\n-\n /// Is `impl1` a specialization of `impl2`?\n ///\n /// Specialization is determined by the sets of types to which the impls apply;"}, {"sha": "6348673dab8b542a28450966d6da22f68f31a957", "filename": "src/librustc_trait_selection/traits/util.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -4,7 +4,6 @@ use smallvec::smallvec;\n use smallvec::SmallVec;\n \n use rustc_data_structures::fx::FxHashSet;\n-use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::outlives::Component;\n use rustc_middle::ty::subst::{GenericArg, Subst, SubstsRef};\n@@ -651,22 +650,8 @@ pub fn generator_trait_ref_and_outputs(\n     ty::Binder::bind((trait_ref, sig.skip_binder().yield_ty, sig.skip_binder().return_ty))\n }\n \n-pub fn impl_is_default(tcx: TyCtxt<'_>, node_item_def_id: DefId) -> bool {\n-    match tcx.hir().as_local_hir_id(node_item_def_id) {\n-        Some(hir_id) => {\n-            let item = tcx.hir().expect_item(hir_id);\n-            if let hir::ItemKind::Impl { defaultness, .. } = item.kind {\n-                defaultness.is_default()\n-            } else {\n-                false\n-            }\n-        }\n-        None => tcx.impl_defaultness(node_item_def_id).is_default(),\n-    }\n-}\n-\n pub fn impl_item_is_final(tcx: TyCtxt<'_>, assoc_item: &ty::AssocItem) -> bool {\n-    assoc_item.defaultness.is_final() && !impl_is_default(tcx, assoc_item.container.id())\n+    assoc_item.defaultness.is_final() && tcx.impl_defaultness(assoc_item.container.id()).is_final()\n }\n \n pub enum TupleArgumentsFlag {"}, {"sha": "47c4b1c41cdbdbc4fae61918836d4b530f611068", "filename": "src/librustc_ty/instance.rs", "status": "modified", "additions": 39, "deletions": 8, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_ty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_ty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Finstance.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -1,9 +1,11 @@\n use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Instance, TyCtxt, TypeFoldable};\n use rustc_span::sym;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n+use traits::{translate_substs, Reveal};\n \n use log::debug;\n \n@@ -82,21 +84,50 @@ fn resolve_associated_item<'tcx>(\n     // the actual function:\n     match vtbl {\n         traits::VtableImpl(impl_data) => {\n-            let (def_id, substs) =\n-                traits::find_associated_item(tcx, param_env, trait_item, rcvr_substs, &impl_data);\n-\n-            let resolved_item = tcx.associated_item(def_id);\n+            debug!(\n+                \"resolving VtableImpl: {:?}, {:?}, {:?}, {:?}\",\n+                param_env, trait_item, rcvr_substs, impl_data\n+            );\n+            assert!(!rcvr_substs.needs_infer());\n+            assert!(!trait_ref.needs_infer());\n+\n+            let trait_def_id = tcx.trait_id_of_impl(impl_data.impl_def_id).unwrap();\n+            let trait_def = tcx.trait_def(trait_def_id);\n+            let leaf_def = trait_def\n+                .ancestors(tcx, impl_data.impl_def_id)\n+                .ok()?\n+                .leaf_def(tcx, trait_item.ident, trait_item.kind)\n+                .unwrap_or_else(|| {\n+                    bug!(\"{:?} not found in {:?}\", trait_item, impl_data.impl_def_id);\n+                });\n+            let def_id = leaf_def.item.def_id;\n+\n+            let substs = tcx.infer_ctxt().enter(|infcx| {\n+                let param_env = param_env.with_reveal_all();\n+                let substs = rcvr_substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n+                let substs = translate_substs(\n+                    &infcx,\n+                    param_env,\n+                    impl_data.impl_def_id,\n+                    substs,\n+                    leaf_def.defining_node,\n+                );\n+                infcx.tcx.erase_regions(&substs)\n+            });\n \n             // Since this is a trait item, we need to see if the item is either a trait default item\n             // or a specialization because we can't resolve those unless we can `Reveal::All`.\n             // NOTE: This should be kept in sync with the similar code in\n             // `rustc_middle::traits::project::assemble_candidates_from_impls()`.\n-            let eligible = if !resolved_item.defaultness.is_default() {\n+            let eligible = if leaf_def.is_final() {\n+                // Non-specializable items are always projectable.\n                 true\n-            } else if param_env.reveal == traits::Reveal::All {\n-                !trait_ref.needs_subst()\n             } else {\n-                false\n+                // Only reveal a specializable default if we're past type-checking\n+                // and the obligation is monomorphic, otherwise passes such as\n+                // transmute checking and polymorphic MIR optimizations could\n+                // get a result which isn't correct for all monomorphizations.\n+                if param_env.reveal == Reveal::All { !trait_ref.needs_subst() } else { false }\n             };\n \n             if !eligible {"}, {"sha": "aefe61f60b87a4e59b2d2effa8a9d33b1cc751d6", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -165,6 +165,16 @@ fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n     )\n }\n \n+fn impl_defaultness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Defaultness {\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let item = tcx.hir().expect_item(hir_id);\n+    if let hir::ItemKind::Impl { defaultness, .. } = item.kind {\n+        defaultness\n+    } else {\n+        bug!(\"`impl_defaultness` called on {:?}\", item);\n+    }\n+}\n+\n /// Calculates the `Sized` constraint.\n ///\n /// In fact, there are only a few options for the types in the constraint:\n@@ -371,6 +381,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         crate_hash,\n         instance_def_size_estimate,\n         issue33140_self_ty,\n+        impl_defaultness,\n         ..*providers\n     };\n }"}, {"sha": "3823efe9d927e9667fd9ede644a9cbb876d36815", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -1942,7 +1942,7 @@ fn check_specialization_validity<'tcx>(\n             // grandparent. In that case, if parent is a `default impl`, inherited items use the\n             // \"defaultness\" from the grandparent, else they are final.\n             None => {\n-                if traits::impl_is_default(tcx, parent_impl.def_id()) {\n+                if tcx.impl_defaultness(parent_impl.def_id()).is_default() {\n                     None\n                 } else {\n                     Some(Err(parent_impl.def_id()))\n@@ -2114,10 +2114,10 @@ fn check_impl_items_against_trait<'tcx>(\n         for trait_item in tcx.associated_items(impl_trait_ref.def_id).in_definition_order() {\n             let is_implemented = ancestors\n                 .leaf_def(tcx, trait_item.ident, trait_item.kind)\n-                .map(|node_item| !node_item.node.is_from_trait())\n+                .map(|node_item| !node_item.defining_node.is_from_trait())\n                 .unwrap_or(false);\n \n-            if !is_implemented && !traits::impl_is_default(tcx, impl_id) {\n+            if !is_implemented && tcx.impl_defaultness(impl_id).is_final() {\n                 if !trait_item.defaultness.has_value() {\n                     missing_items.push(*trait_item);\n                 }"}, {"sha": "f1e91920f17f7b98a9a50db5b0a5b16312cb055d", "filename": "src/test/ui/consts/const-eval/validate_uninhabited_zsts.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.stderr?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -5,7 +5,8 @@ LL |     unsafe { std::mem::transmute(()) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^\n    |              |\n    |              transmuting to uninhabited type\n-   |              inside call to `foo` at $DIR/validate_uninhabited_zsts.rs:14:26\n+   |              inside `foo` at $DIR/validate_uninhabited_zsts.rs:5:14\n+   |              inside `FOO` at $DIR/validate_uninhabited_zsts.rs:14:26\n ...\n LL | const FOO: [Empty; 3] = [foo(); 3];\n    | -----------------------------------"}, {"sha": "8ed1431dd31c089a98a5f75ed5e7d17a60859b2f", "filename": "src/test/ui/consts/miri_unleashed/abi-mismatch.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fabi-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fabi-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fabi-mismatch.stderr?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -17,7 +17,8 @@ LL |     my_fn();\n    |     ^^^^^^^\n    |     |\n    |     calling a function with ABI C using caller ABI Rust\n-   |     inside call to `call_rust_fn` at $DIR/abi-mismatch.rs:13:17\n+   |     inside `call_rust_fn` at $DIR/abi-mismatch.rs:9:5\n+   |     inside `VAL` at $DIR/abi-mismatch.rs:13:17\n ...\n LL | const VAL: () = call_rust_fn(unsafe { std::mem::transmute(c_fn as extern \"C\" fn()) });\n    | --------------------------------------------------------------------------------------"}, {"sha": "5d560fab8351a8cedd03c69ac4c61e26e75e0861", "filename": "src/test/ui/consts/miri_unleashed/drop.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fdrop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fdrop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fdrop.stderr?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -12,12 +12,15 @@ LL | |     // Code here does not matter - this is replaced by the\n LL | |     // real drop glue by the compiler.\n LL | |     drop_in_place(to_drop)\n LL | | }\n-   | |_^ calling non-const function `<std::vec::Vec<i32> as std::ops::Drop>::drop`\n+   | | ^\n+   | | |\n+   | |_calling non-const function `<std::vec::Vec<i32> as std::ops::Drop>::drop`\n+   |   inside `std::intrinsics::drop_in_place::<std::vec::Vec<i32>> - shim(Some(std::vec::Vec<i32>))` at $SRC_DIR/libcore/ptr/mod.rs:LL:COL\n    | \n   ::: $DIR/drop.rs:23:1\n    |\n LL |   };\n-   |   - inside call to `std::intrinsics::drop_in_place::<std::vec::Vec<i32>> - shim(Some(std::vec::Vec<i32>))` at $DIR/drop.rs:23:1\n+   |   - inside `TEST_BAD` at $DIR/drop.rs:23:1\n \n error: aborting due to previous error\n "}, {"sha": "f1a183b229dd46ee6ae712a8abd20d08a6611aa8", "filename": "src/test/ui/consts/offset_from_ub.stderr", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -5,7 +5,8 @@ LL |           intrinsics::ptr_offset_from(self, origin)\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |           |\n    |           ptr_offset_from cannot compute offset of pointers into different allocations.\n-   |           inside call to `std::ptr::const_ptr::<impl *const Struct>::offset_from` at $DIR/offset_from_ub.rs:22:27\n+   |           inside `std::ptr::const_ptr::<impl *const Struct>::offset_from` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |           inside `DIFFERENT_ALLOC` at $DIR/offset_from_ub.rs:22:27\n    | \n   ::: $DIR/offset_from_ub.rs:16:1\n    |\n@@ -27,7 +28,8 @@ LL |           intrinsics::ptr_offset_from(self, origin)\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |           |\n    |           unable to turn bytes into a pointer\n-   |           inside call to `std::ptr::const_ptr::<impl *const u8>::offset_from` at $DIR/offset_from_ub.rs:28:14\n+   |           inside `std::ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |           inside `NOT_PTR` at $DIR/offset_from_ub.rs:28:14\n    | \n   ::: $DIR/offset_from_ub.rs:26:1\n    |\n@@ -44,7 +46,8 @@ LL |           intrinsics::ptr_offset_from(self, origin)\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |           |\n    |           exact_div: 1isize cannot be divided by 2isize without remainder\n-   |           inside call to `std::ptr::const_ptr::<impl *const u16>::offset_from` at $DIR/offset_from_ub.rs:36:14\n+   |           inside `std::ptr::const_ptr::<impl *const u16>::offset_from` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |           inside `NOT_MULTIPLE_OF_SIZE` at $DIR/offset_from_ub.rs:36:14\n    | \n   ::: $DIR/offset_from_ub.rs:31:1\n    |\n@@ -64,7 +67,8 @@ LL |           intrinsics::ptr_offset_from(self, origin)\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |           |\n    |           invalid use of NULL pointer\n-   |           inside call to `std::ptr::const_ptr::<impl *const u8>::offset_from` at $DIR/offset_from_ub.rs:42:14\n+   |           inside `std::ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |           inside `OFFSET_FROM_NULL` at $DIR/offset_from_ub.rs:42:14\n    | \n   ::: $DIR/offset_from_ub.rs:39:1\n    |\n@@ -82,7 +86,8 @@ LL |           intrinsics::ptr_offset_from(self, origin)\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |           |\n    |           unable to turn bytes into a pointer\n-   |           inside call to `std::ptr::const_ptr::<impl *const u8>::offset_from` at $DIR/offset_from_ub.rs:49:14\n+   |           inside `std::ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |           inside `DIFFERENT_INT` at $DIR/offset_from_ub.rs:49:14\n    | \n   ::: $DIR/offset_from_ub.rs:45:1\n    |"}, {"sha": "ca232380897e3baa9e3e4fe2393c2c70665ab566", "filename": "src/test/ui/consts/uninhabited-const-issue-61744.stderr", "status": "modified", "additions": 129, "deletions": 65, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.stderr?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -4,76 +4,140 @@ error[E0080]: evaluation of constant value failed\n LL |     hint_unreachable()\n    |     ------------------\n    |     |\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n-   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside `fake_type::<i32>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n ...\n LL |     fake_type()\n    |     ^^^^^^^^^^^\n    |     |\n    |     reached the configured maximum number of stack frames\n-   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+   |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n \n error: any use of this value will cause an error\n   --> $DIR/uninhabited-const-issue-61744.rs:12:36"}, {"sha": "4371dd2e16747784fc67047d13384ac5a8cccbe0", "filename": "src/test/ui/specialization/issue-70442.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Ftest%2Fui%2Fspecialization%2Fissue-70442.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Ftest%2Fui%2Fspecialization%2Fissue-70442.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fissue-70442.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -0,0 +1,23 @@\n+#![feature(specialization)]\n+\n+// check-pass\n+\n+trait Trait {\n+    type Assoc;\n+}\n+\n+impl<T> Trait for T {\n+    default type Assoc = bool;\n+}\n+\n+// This impl inherits the `Assoc` definition from above and \"locks it in\", or finalizes it, making\n+// child impls unable to further specialize it. However, since the specialization graph didn't\n+// correctly track this, we would refuse to project `Assoc` from this impl, even though that should\n+// happen for items that are final.\n+impl Trait for () {}\n+\n+fn foo<X: Trait<Assoc=bool>>() {}\n+\n+fn main() {\n+    foo::<()>();  // `<() as Trait>::Assoc` is normalized to `bool` correctly\n+}"}, {"sha": "6968822c1b8aec7f37790c3169774cb07f9a1c8a", "filename": "src/tools/cargotest/main.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Ftools%2Fcargotest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Ftools%2Fcargotest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargotest%2Fmain.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -58,13 +58,6 @@ const TEST_REPOS: &'static [Test] = &[\n         // This takes much less time to build than all of Servo and supports stable Rust.\n         packages: &[\"selectors\"],\n     },\n-    Test {\n-        name: \"webrender\",\n-        repo: \"https://github.com/servo/webrender\",\n-        sha: \"a3d6e6894c5a601fa547c6273eb963ca1321c2bb\",\n-        lock: None,\n-        packages: &[],\n-    },\n ];\n \n fn main() {"}, {"sha": "8a291a3611efdc7db6ca00b73e7352a1616df7cb", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b11980ad416c3ad6143504c2277757ecacf9b5/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=76b11980ad416c3ad6143504c2277757ecacf9b5", "patch": "@@ -180,29 +180,25 @@ pub fn make_diff(expected: &str, actual: &str, context_size: usize) -> Vec<Misma\n }\n \n fn print_diff(expected: &str, actual: &str, context_size: usize) {\n-    write_diff(expected, actual, context_size, std::io::stdout());\n-}\n-\n-fn write_diff(expected: &str, actual: &str, context_size: usize, mut dest: impl io::Write) {\n     let diff_results = make_diff(expected, actual, context_size);\n     for result in diff_results {\n         let mut line_number = result.line_number;\n         for line in result.lines {\n             match line {\n                 DiffLine::Expected(e) => {\n-                    writeln!(dest, \"-\\t{}\", e).unwrap();\n+                    println!(\"-\\t{}\", e);\n                     line_number += 1;\n                 }\n                 DiffLine::Context(c) => {\n-                    writeln!(dest, \"{}\\t{}\", line_number, c).unwrap();\n+                    println!(\"{}\\t{}\", line_number, c);\n                     line_number += 1;\n                 }\n                 DiffLine::Resulting(r) => {\n-                    writeln!(dest, \"+\\t{}\", r).unwrap();\n+                    println!(\"+\\t{}\", r);\n                 }\n             }\n         }\n-        writeln!(dest).unwrap();\n+        println!();\n     }\n }\n "}]}