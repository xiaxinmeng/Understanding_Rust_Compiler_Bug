{"sha": "ef4c7241f82c08848938b8b2dafed01535559ec0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmNGM3MjQxZjgyYzA4ODQ4OTM4YjhiMmRhZmVkMDE1MzU1NTllYzA=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-29T06:32:58Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-04-06T06:01:55Z"}, "message": "rustc: dismantle hir::util, mostly moving functions to methods.", "tree": {"sha": "e8f7e46179a2f8ac376b4b1054fde89ff14c71a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8f7e46179a2f8ac376b4b1054fde89ff14c71a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef4c7241f82c08848938b8b2dafed01535559ec0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef4c7241f82c08848938b8b2dafed01535559ec0", "html_url": "https://github.com/rust-lang/rust/commit/ef4c7241f82c08848938b8b2dafed01535559ec0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef4c7241f82c08848938b8b2dafed01535559ec0/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b0937293bdb70ab4a5efed02b90a71af2b234f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b0937293bdb70ab4a5efed02b90a71af2b234f6", "html_url": "https://github.com/rust-lang/rust/commit/8b0937293bdb70ab4a5efed02b90a71af2b234f6"}], "stats": {"total": 819, "additions": 393, "deletions": 426}, "files": [{"sha": "13c3e3895b5d0bfaaed0b901e8e5115d11f57177", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -257,7 +257,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.match_(expr.id, &discr, &arms, pred)\n             }\n \n-            hir::ExprBinary(op, ref l, ref r) if hir::util::lazy_binop(op.node) => {\n+            hir::ExprBinary(op, ref l, ref r) if op.node.is_lazy() => {\n                 //\n                 //     [pred]\n                 //       |"}, {"sha": "90fba0c8985dcd71ee8d281f8f23956c2761a98d", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -27,6 +27,7 @@\n \n use syntax::abi::Abi;\n use syntax::ast::{NodeId, CRATE_NODE_ID, Name, Attribute};\n+use syntax::ast_util;\n use syntax::attr::ThinAttributesExt;\n use syntax::codemap::Span;\n use hir::*;\n@@ -835,3 +836,185 @@ pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n     visitor.visit_expr(&arm.body);\n     walk_list!(visitor, visit_attribute, &arm.attrs);\n }\n+\n+pub struct IdVisitor<'a, O: 'a> {\n+    operation: &'a mut O,\n+\n+    // In general, the id visitor visits the contents of an item, but\n+    // not including nested trait/impl items, nor other nested items.\n+    // The base visitor itself always skips nested items, but not\n+    // trait/impl items. This means in particular that if you start by\n+    // visiting a trait or an impl, you should not visit the\n+    // trait/impl items respectively.  This is handled by setting\n+    // `skip_members` to true when `visit_item` is on the stack. This\n+    // way, if the user begins by calling `visit_trait_item`, we will\n+    // visit the trait item, but if they begin with `visit_item`, we\n+    // won't visit the (nested) trait items.\n+    skip_members: bool,\n+}\n+\n+impl<'a, O: ast_util::IdVisitingOperation> IdVisitor<'a, O> {\n+    pub fn new(operation: &'a mut O) -> IdVisitor<'a, O> {\n+        IdVisitor { operation: operation, skip_members: false }\n+    }\n+\n+    fn visit_generics_helper(&mut self, generics: &Generics) {\n+        for type_parameter in generics.ty_params.iter() {\n+            self.operation.visit_id(type_parameter.id)\n+        }\n+        for lifetime in &generics.lifetimes {\n+            self.operation.visit_id(lifetime.lifetime.id)\n+        }\n+    }\n+}\n+\n+impl<'a, 'v, O: ast_util::IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n+    fn visit_mod(&mut self, module: &Mod, _: Span, node_id: NodeId) {\n+        self.operation.visit_id(node_id);\n+        walk_mod(self, module)\n+    }\n+\n+    fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n+        self.operation.visit_id(foreign_item.id);\n+        walk_foreign_item(self, foreign_item)\n+    }\n+\n+    fn visit_item(&mut self, item: &Item) {\n+        assert!(!self.skip_members);\n+        self.skip_members = true;\n+\n+        self.operation.visit_id(item.id);\n+        match item.node {\n+            ItemUse(ref view_path) => {\n+                match view_path.node {\n+                    ViewPathSimple(_, _) |\n+                    ViewPathGlob(_) => {}\n+                    ViewPathList(_, ref paths) => {\n+                        for path in paths {\n+                            self.operation.visit_id(path.node.id())\n+                        }\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+        walk_item(self, item);\n+\n+        self.skip_members = false;\n+    }\n+\n+    fn visit_local(&mut self, local: &Local) {\n+        self.operation.visit_id(local.id);\n+        walk_local(self, local)\n+    }\n+\n+    fn visit_block(&mut self, block: &Block) {\n+        self.operation.visit_id(block.id);\n+        walk_block(self, block)\n+    }\n+\n+    fn visit_stmt(&mut self, statement: &Stmt) {\n+        self.operation.visit_id(statement.node.id());\n+        walk_stmt(self, statement)\n+    }\n+\n+    fn visit_pat(&mut self, pattern: &Pat) {\n+        self.operation.visit_id(pattern.id);\n+        walk_pat(self, pattern)\n+    }\n+\n+    fn visit_expr(&mut self, expression: &Expr) {\n+        self.operation.visit_id(expression.id);\n+        walk_expr(self, expression)\n+    }\n+\n+    fn visit_ty(&mut self, typ: &Ty) {\n+        self.operation.visit_id(typ.id);\n+        walk_ty(self, typ)\n+    }\n+\n+    fn visit_generics(&mut self, generics: &Generics) {\n+        self.visit_generics_helper(generics);\n+        walk_generics(self, generics)\n+    }\n+\n+    fn visit_fn(&mut self,\n+                function_kind: FnKind<'v>,\n+                function_declaration: &'v FnDecl,\n+                block: &'v Block,\n+                span: Span,\n+                node_id: NodeId) {\n+        self.operation.visit_id(node_id);\n+\n+        match function_kind {\n+            FnKind::ItemFn(_, generics, _, _, _, _, _) => {\n+                self.visit_generics_helper(generics)\n+            }\n+            FnKind::Method(_, sig, _, _) => {\n+                self.visit_generics_helper(&sig.generics)\n+            }\n+            FnKind::Closure(_) => {}\n+        }\n+\n+        for argument in &function_declaration.inputs {\n+            self.operation.visit_id(argument.id)\n+        }\n+\n+        walk_fn(self, function_kind, function_declaration, block, span);\n+    }\n+\n+    fn visit_struct_field(&mut self, struct_field: &StructField) {\n+        self.operation.visit_id(struct_field.id);\n+        walk_struct_field(self, struct_field)\n+    }\n+\n+    fn visit_variant_data(&mut self,\n+                          struct_def: &VariantData,\n+                          _: Name,\n+                          _: &Generics,\n+                          _: NodeId,\n+                          _: Span) {\n+        self.operation.visit_id(struct_def.id());\n+        walk_struct_def(self, struct_def);\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &TraitItem) {\n+        if !self.skip_members {\n+            self.operation.visit_id(ti.id);\n+            walk_trait_item(self, ti);\n+        }\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &ImplItem) {\n+        if !self.skip_members {\n+            self.operation.visit_id(ii.id);\n+            walk_impl_item(self, ii);\n+        }\n+    }\n+\n+    fn visit_lifetime(&mut self, lifetime: &Lifetime) {\n+        self.operation.visit_id(lifetime.id);\n+    }\n+\n+    fn visit_lifetime_def(&mut self, def: &LifetimeDef) {\n+        self.visit_lifetime(&def.lifetime);\n+    }\n+\n+    fn visit_trait_ref(&mut self, trait_ref: &TraitRef) {\n+        self.operation.visit_id(trait_ref.ref_id);\n+        walk_trait_ref(self, trait_ref);\n+    }\n+}\n+\n+/// Computes the id range for a single fn body, ignoring nested items.\n+pub fn compute_id_range_for_fn_body(fk: FnKind,\n+                                    decl: &FnDecl,\n+                                    body: &Block,\n+                                    sp: Span,\n+                                    id: NodeId)\n+                                    -> ast_util::IdRange {\n+    let mut visitor = ast_util::IdRangeComputingVisitor { result: ast_util::IdRange::max() };\n+    let mut id_visitor = IdVisitor::new(&mut visitor);\n+    id_visitor.visit_fn(fk, decl, body, sp, id);\n+    id_visitor.operation.result\n+}"}, {"sha": "62c80c9c8bbc38fcd700d46b5fb7a85ae2294036", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -304,7 +304,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     }\n \n     fn visit_stmt(&mut self, stmt: &'ast Stmt) {\n-        let id = util::stmt_id(stmt);\n+        let id = stmt.node.id();\n         self.insert(id, NodeStmt(stmt));\n         let parent_node = self.parent_node;\n         self.parent_node = id;"}, {"sha": "cb3cdd0b8258d8be5f508c766570a59a063d46c1", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 162, "deletions": 3, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -59,7 +59,7 @@ macro_rules! hir_vec {\n     ($($x:expr),*) => (\n         $crate::hir::HirVec::from(vec![$($x),*])\n     );\n-    ($($x:expr,)*) => (vec![$($x),*])\n+    ($($x:expr,)*) => (hir_vec![$($x),*])\n }\n \n pub mod check_attr;\n@@ -69,7 +69,6 @@ pub mod lowering;\n pub mod map;\n pub mod print;\n pub mod svh;\n-pub mod util;\n \n /// Identifier in HIR\n #[derive(Clone, Copy, Eq)]\n@@ -176,6 +175,21 @@ impl fmt::Display for Path {\n     }\n }\n \n+impl Path {\n+    /// Convert a span and an identifier to the corresponding\n+    /// 1-segment path.\n+    pub fn from_ident(s: Span, ident: Ident) -> Path {\n+        Path {\n+            span: s,\n+            global: false,\n+            segments: hir_vec![PathSegment {\n+                identifier: ident,\n+                parameters: PathParameters::none()\n+            }],\n+        }\n+    }\n+}\n+\n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -349,12 +363,25 @@ pub struct Generics {\n }\n \n impl Generics {\n+    pub fn empty() -> Generics {\n+        Generics {\n+            lifetimes: HirVec::new(),\n+            ty_params: HirVec::new(),\n+            where_clause: WhereClause {\n+                id: DUMMY_NODE_ID,\n+                predicates: HirVec::new(),\n+            },\n+        }\n+    }\n+\n     pub fn is_lt_parameterized(&self) -> bool {\n         !self.lifetimes.is_empty()\n     }\n+\n     pub fn is_type_parameterized(&self) -> bool {\n         !self.ty_params.is_empty()\n     }\n+\n     pub fn is_parameterized(&self) -> bool {\n         self.is_lt_parameterized() || self.is_type_parameterized()\n     }\n@@ -490,6 +517,50 @@ impl fmt::Debug for Pat {\n     }\n }\n \n+impl Pat {\n+    // FIXME(#19596) this is a workaround, but there should be a better way\n+    fn walk_<G>(&self, it: &mut G) -> bool\n+        where G: FnMut(&Pat) -> bool\n+    {\n+        if !it(self) {\n+            return false;\n+        }\n+\n+        match self.node {\n+            PatKind::Ident(_, _, Some(ref p)) => p.walk_(it),\n+            PatKind::Struct(_, ref fields, _) => {\n+                fields.iter().all(|field| field.node.pat.walk_(it))\n+            }\n+            PatKind::TupleStruct(_, Some(ref s)) | PatKind::Tup(ref s) => {\n+                s.iter().all(|p| p.walk_(it))\n+            }\n+            PatKind::Box(ref s) | PatKind::Ref(ref s, _) => {\n+                s.walk_(it)\n+            }\n+            PatKind::Vec(ref before, ref slice, ref after) => {\n+                before.iter().all(|p| p.walk_(it)) &&\n+                slice.iter().all(|p| p.walk_(it)) &&\n+                after.iter().all(|p| p.walk_(it))\n+            }\n+            PatKind::Wild |\n+            PatKind::Lit(_) |\n+            PatKind::Range(_, _) |\n+            PatKind::Ident(_, _, _) |\n+            PatKind::TupleStruct(..) |\n+            PatKind::Path(..) |\n+            PatKind::QPath(_, _) => {\n+                true\n+            }\n+        }\n+    }\n+\n+    pub fn walk<F>(&self, mut it: F) -> bool\n+        where F: FnMut(&Pat) -> bool\n+    {\n+        self.walk_(&mut it)\n+    }\n+}\n+\n /// A single field in a struct pattern\n ///\n /// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n@@ -604,6 +675,68 @@ pub enum BinOp_ {\n     BiGt,\n }\n \n+impl BinOp_ {\n+    pub fn as_str(self) -> &'static str {\n+        match self {\n+            BiAdd => \"+\",\n+            BiSub => \"-\",\n+            BiMul => \"*\",\n+            BiDiv => \"/\",\n+            BiRem => \"%\",\n+            BiAnd => \"&&\",\n+            BiOr => \"||\",\n+            BiBitXor => \"^\",\n+            BiBitAnd => \"&\",\n+            BiBitOr => \"|\",\n+            BiShl => \"<<\",\n+            BiShr => \">>\",\n+            BiEq => \"==\",\n+            BiLt => \"<\",\n+            BiLe => \"<=\",\n+            BiNe => \"!=\",\n+            BiGe => \">=\",\n+            BiGt => \">\",\n+        }\n+    }\n+\n+    pub fn is_lazy(self) -> bool {\n+        match self {\n+            BiAnd | BiOr => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_shift(self) -> bool {\n+        match self {\n+            BiShl | BiShr => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_comparison(self) -> bool {\n+        match self {\n+            BiEq | BiLt | BiLe | BiNe | BiGt | BiGe => true,\n+            BiAnd |\n+            BiOr |\n+            BiAdd |\n+            BiSub |\n+            BiMul |\n+            BiDiv |\n+            BiRem |\n+            BiBitXor |\n+            BiBitAnd |\n+            BiBitOr |\n+            BiShl |\n+            BiShr => false,\n+        }\n+    }\n+\n+    /// Returns `true` if the binary operator takes its arguments by value\n+    pub fn is_by_value(self) -> bool {\n+        !self.is_comparison()\n+    }\n+}\n+\n pub type BinOp = Spanned<BinOp_>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -616,6 +749,24 @@ pub enum UnOp {\n     UnNeg,\n }\n \n+impl UnOp {\n+    pub fn as_str(self) -> &'static str {\n+        match self {\n+            UnDeref => \"*\",\n+            UnNot => \"!\",\n+            UnNeg => \"-\",\n+        }\n+    }\n+\n+    /// Returns `true` if the unary operator takes its argument by value\n+    pub fn is_by_value(self) -> bool {\n+        match self {\n+            UnNeg | UnNot => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n /// A statement\n pub type Stmt = Spanned<Stmt_>;\n \n@@ -625,7 +776,7 @@ impl fmt::Debug for Stmt_ {\n         let spanned = codemap::dummy_spanned(self.clone());\n         write!(f,\n                \"stmt({}: {})\",\n-               util::stmt_id(&spanned),\n+               spanned.node.id(),\n                print::stmt_to_string(&spanned))\n     }\n }\n@@ -650,6 +801,14 @@ impl Stmt_ {\n             StmtSemi(ref e, _) => e.attrs.as_attr_slice(),\n         }\n     }\n+\n+    pub fn id(&self) -> NodeId {\n+        match *self {\n+            StmtDecl(_, id) => id,\n+            StmtExpr(_, id) => id,\n+            StmtSemi(_, id) => id,\n+        }\n+    }\n }\n \n // FIXME (pending discussion of #1697, #2178...): local should really be"}, {"sha": "cd2dfd44639523bf6751d45e4e14d21655c85a84", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -950,7 +950,7 @@ impl<'a> State<'a> {\n \n     pub fn print_variant(&mut self, v: &hir::Variant) -> io::Result<()> {\n         self.head(\"\")?;\n-        let generics = hir::util::empty_generics();\n+        let generics = hir::Generics::empty();\n         self.print_struct(&v.node.data, &generics, v.node.name, v.span, false)?;\n         match v.node.disr_expr {\n             Some(ref d) => {\n@@ -1285,12 +1285,12 @@ impl<'a> State<'a> {\n                          -> io::Result<()> {\n         self.print_expr(lhs)?;\n         space(&mut self.s)?;\n-        self.word_space(hir::util::binop_to_string(op.node))?;\n+        self.word_space(op.node.as_str())?;\n         self.print_expr(rhs)\n     }\n \n     fn print_expr_unary(&mut self, op: hir::UnOp, expr: &hir::Expr) -> io::Result<()> {\n-        word(&mut self.s, hir::util::unop_to_string(op))?;\n+        word(&mut self.s, op.as_str())?;\n         self.print_expr_maybe_paren(expr)\n     }\n \n@@ -1434,7 +1434,7 @@ impl<'a> State<'a> {\n             hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n                 self.print_expr(&lhs)?;\n                 space(&mut self.s)?;\n-                word(&mut self.s, hir::util::binop_to_string(op.node))?;\n+                word(&mut self.s, op.node.as_str())?;\n                 self.word_space(\"=\")?;\n                 self.print_expr(&rhs)?;\n             }"}, {"sha": "7745c320e7681ae4032da3153d7c1ed381212669", "filename": "src/librustc/hir/util.rs", "status": "removed", "additions": 0, "deletions": 362, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/8b0937293bdb70ab4a5efed02b90a71af2b234f6/src%2Flibrustc%2Fhir%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b0937293bdb70ab4a5efed02b90a71af2b234f6/src%2Flibrustc%2Fhir%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Futil.rs?ref=8b0937293bdb70ab4a5efed02b90a71af2b234f6", "patch": "@@ -1,362 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use hir;\n-use hir::*;\n-use hir::intravisit::{Visitor, FnKind};\n-use syntax::ast_util;\n-use syntax::ast::{Name, NodeId, DUMMY_NODE_ID};\n-use syntax::codemap::Span;\n-use syntax::ptr::P;\n-\n-pub fn walk_pat<F>(pat: &Pat, mut it: F) -> bool\n-    where F: FnMut(&Pat) -> bool\n-{\n-    // FIXME(#19596) this is a workaround, but there should be a better way\n-    fn walk_pat_<G>(pat: &Pat, it: &mut G) -> bool\n-        where G: FnMut(&Pat) -> bool\n-    {\n-        if !it(pat) {\n-            return false;\n-        }\n-\n-        match pat.node {\n-            PatKind::Ident(_, _, Some(ref p)) => walk_pat_(&p, it),\n-            PatKind::Struct(_, ref fields, _) => {\n-                fields.iter().all(|field| walk_pat_(&field.node.pat, it))\n-            }\n-            PatKind::TupleStruct(_, Some(ref s)) | PatKind::Tup(ref s) => {\n-                s.iter().all(|p| walk_pat_(&p, it))\n-            }\n-            PatKind::Box(ref s) | PatKind::Ref(ref s, _) => {\n-                walk_pat_(&s, it)\n-            }\n-            PatKind::Vec(ref before, ref slice, ref after) => {\n-                before.iter().all(|p| walk_pat_(&p, it)) &&\n-                slice.iter().all(|p| walk_pat_(&p, it)) &&\n-                after.iter().all(|p| walk_pat_(&p, it))\n-            }\n-            PatKind::Wild |\n-            PatKind::Lit(_) |\n-            PatKind::Range(_, _) |\n-            PatKind::Ident(_, _, _) |\n-            PatKind::TupleStruct(..) |\n-            PatKind::Path(..) |\n-            PatKind::QPath(_, _) => {\n-                true\n-            }\n-        }\n-    }\n-\n-    walk_pat_(pat, &mut it)\n-}\n-\n-pub fn binop_to_string(op: BinOp_) -> &'static str {\n-    match op {\n-        BiAdd => \"+\",\n-        BiSub => \"-\",\n-        BiMul => \"*\",\n-        BiDiv => \"/\",\n-        BiRem => \"%\",\n-        BiAnd => \"&&\",\n-        BiOr => \"||\",\n-        BiBitXor => \"^\",\n-        BiBitAnd => \"&\",\n-        BiBitOr => \"|\",\n-        BiShl => \"<<\",\n-        BiShr => \">>\",\n-        BiEq => \"==\",\n-        BiLt => \"<\",\n-        BiLe => \"<=\",\n-        BiNe => \"!=\",\n-        BiGe => \">=\",\n-        BiGt => \">\",\n-    }\n-}\n-\n-pub fn stmt_id(s: &Stmt) -> NodeId {\n-    match s.node {\n-        StmtDecl(_, id) => id,\n-        StmtExpr(_, id) => id,\n-        StmtSemi(_, id) => id,\n-    }\n-}\n-\n-pub fn lazy_binop(b: BinOp_) -> bool {\n-    match b {\n-        BiAnd => true,\n-        BiOr => true,\n-        _ => false,\n-    }\n-}\n-\n-pub fn is_shift_binop(b: BinOp_) -> bool {\n-    match b {\n-        BiShl => true,\n-        BiShr => true,\n-        _ => false,\n-    }\n-}\n-\n-pub fn is_comparison_binop(b: BinOp_) -> bool {\n-    match b {\n-        BiEq | BiLt | BiLe | BiNe | BiGt | BiGe => true,\n-        BiAnd |\n-        BiOr |\n-        BiAdd |\n-        BiSub |\n-        BiMul |\n-        BiDiv |\n-        BiRem |\n-        BiBitXor |\n-        BiBitAnd |\n-        BiBitOr |\n-        BiShl |\n-        BiShr => false,\n-    }\n-}\n-\n-/// Returns `true` if the binary operator takes its arguments by value\n-pub fn is_by_value_binop(b: BinOp_) -> bool {\n-    !is_comparison_binop(b)\n-}\n-\n-/// Returns `true` if the unary operator takes its argument by value\n-pub fn is_by_value_unop(u: UnOp) -> bool {\n-    match u {\n-        UnNeg | UnNot => true,\n-        _ => false,\n-    }\n-}\n-\n-pub fn unop_to_string(op: UnOp) -> &'static str {\n-    match op {\n-        UnDeref => \"*\",\n-        UnNot => \"!\",\n-        UnNeg => \"-\",\n-    }\n-}\n-\n-pub struct IdVisitor<'a, O: 'a> {\n-    operation: &'a mut O,\n-\n-    // In general, the id visitor visits the contents of an item, but\n-    // not including nested trait/impl items, nor other nested items.\n-    // The base visitor itself always skips nested items, but not\n-    // trait/impl items. This means in particular that if you start by\n-    // visiting a trait or an impl, you should not visit the\n-    // trait/impl items respectively.  This is handled by setting\n-    // `skip_members` to true when `visit_item` is on the stack. This\n-    // way, if the user begins by calling `visit_trait_item`, we will\n-    // visit the trait item, but if they begin with `visit_item`, we\n-    // won't visit the (nested) trait items.\n-    skip_members: bool,\n-}\n-\n-impl<'a, O: ast_util::IdVisitingOperation> IdVisitor<'a, O> {\n-    pub fn new(operation: &'a mut O) -> IdVisitor<'a, O> {\n-        IdVisitor { operation: operation, skip_members: false }\n-    }\n-\n-    fn visit_generics_helper(&mut self, generics: &Generics) {\n-        for type_parameter in generics.ty_params.iter() {\n-            self.operation.visit_id(type_parameter.id)\n-        }\n-        for lifetime in &generics.lifetimes {\n-            self.operation.visit_id(lifetime.lifetime.id)\n-        }\n-    }\n-}\n-\n-impl<'a, 'v, O: ast_util::IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n-    fn visit_mod(&mut self, module: &Mod, _: Span, node_id: NodeId) {\n-        self.operation.visit_id(node_id);\n-        intravisit::walk_mod(self, module)\n-    }\n-\n-    fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n-        self.operation.visit_id(foreign_item.id);\n-        intravisit::walk_foreign_item(self, foreign_item)\n-    }\n-\n-    fn visit_item(&mut self, item: &Item) {\n-        assert!(!self.skip_members);\n-        self.skip_members = true;\n-\n-        self.operation.visit_id(item.id);\n-        match item.node {\n-            ItemUse(ref view_path) => {\n-                match view_path.node {\n-                    ViewPathSimple(_, _) |\n-                    ViewPathGlob(_) => {}\n-                    ViewPathList(_, ref paths) => {\n-                        for path in paths {\n-                            self.operation.visit_id(path.node.id())\n-                        }\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-        intravisit::walk_item(self, item);\n-\n-        self.skip_members = false;\n-    }\n-\n-    fn visit_local(&mut self, local: &Local) {\n-        self.operation.visit_id(local.id);\n-        intravisit::walk_local(self, local)\n-    }\n-\n-    fn visit_block(&mut self, block: &Block) {\n-        self.operation.visit_id(block.id);\n-        intravisit::walk_block(self, block)\n-    }\n-\n-    fn visit_stmt(&mut self, statement: &Stmt) {\n-        self.operation.visit_id(stmt_id(statement));\n-        intravisit::walk_stmt(self, statement)\n-    }\n-\n-    fn visit_pat(&mut self, pattern: &Pat) {\n-        self.operation.visit_id(pattern.id);\n-        intravisit::walk_pat(self, pattern)\n-    }\n-\n-    fn visit_expr(&mut self, expression: &Expr) {\n-        self.operation.visit_id(expression.id);\n-        intravisit::walk_expr(self, expression)\n-    }\n-\n-    fn visit_ty(&mut self, typ: &Ty) {\n-        self.operation.visit_id(typ.id);\n-        intravisit::walk_ty(self, typ)\n-    }\n-\n-    fn visit_generics(&mut self, generics: &Generics) {\n-        self.visit_generics_helper(generics);\n-        intravisit::walk_generics(self, generics)\n-    }\n-\n-    fn visit_fn(&mut self,\n-                function_kind: FnKind<'v>,\n-                function_declaration: &'v FnDecl,\n-                block: &'v Block,\n-                span: Span,\n-                node_id: NodeId) {\n-        self.operation.visit_id(node_id);\n-\n-        match function_kind {\n-            FnKind::ItemFn(_, generics, _, _, _, _, _) => {\n-                self.visit_generics_helper(generics)\n-            }\n-            FnKind::Method(_, sig, _, _) => {\n-                self.visit_generics_helper(&sig.generics)\n-            }\n-            FnKind::Closure(_) => {}\n-        }\n-\n-        for argument in &function_declaration.inputs {\n-            self.operation.visit_id(argument.id)\n-        }\n-\n-        intravisit::walk_fn(self, function_kind, function_declaration, block, span);\n-    }\n-\n-    fn visit_struct_field(&mut self, struct_field: &StructField) {\n-        self.operation.visit_id(struct_field.id);\n-        intravisit::walk_struct_field(self, struct_field)\n-    }\n-\n-    fn visit_variant_data(&mut self,\n-                          struct_def: &VariantData,\n-                          _: Name,\n-                          _: &hir::Generics,\n-                          _: NodeId,\n-                          _: Span) {\n-        self.operation.visit_id(struct_def.id());\n-        intravisit::walk_struct_def(self, struct_def);\n-    }\n-\n-    fn visit_trait_item(&mut self, ti: &hir::TraitItem) {\n-        if !self.skip_members {\n-            self.operation.visit_id(ti.id);\n-            intravisit::walk_trait_item(self, ti);\n-        }\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &hir::ImplItem) {\n-        if !self.skip_members {\n-            self.operation.visit_id(ii.id);\n-            intravisit::walk_impl_item(self, ii);\n-        }\n-    }\n-\n-    fn visit_lifetime(&mut self, lifetime: &Lifetime) {\n-        self.operation.visit_id(lifetime.id);\n-    }\n-\n-    fn visit_lifetime_def(&mut self, def: &LifetimeDef) {\n-        self.visit_lifetime(&def.lifetime);\n-    }\n-\n-    fn visit_trait_ref(&mut self, trait_ref: &TraitRef) {\n-        self.operation.visit_id(trait_ref.ref_id);\n-        intravisit::walk_trait_ref(self, trait_ref);\n-    }\n-}\n-\n-/// Computes the id range for a single fn body, ignoring nested items.\n-pub fn compute_id_range_for_fn_body(fk: FnKind,\n-                                    decl: &FnDecl,\n-                                    body: &Block,\n-                                    sp: Span,\n-                                    id: NodeId)\n-                                    -> ast_util::IdRange {\n-    let mut visitor = ast_util::IdRangeComputingVisitor { result: ast_util::IdRange::max() };\n-    let mut id_visitor = IdVisitor::new(&mut visitor);\n-    id_visitor.visit_fn(fk, decl, body, sp, id);\n-    id_visitor.operation.result\n-}\n-\n-pub fn is_path(e: P<Expr>) -> bool {\n-    match e.node {\n-        ExprPath(..) => true,\n-        _ => false,\n-    }\n-}\n-\n-pub fn empty_generics() -> Generics {\n-    Generics {\n-        lifetimes: HirVec::new(),\n-        ty_params: HirVec::new(),\n-        where_clause: WhereClause {\n-            id: DUMMY_NODE_ID,\n-            predicates: HirVec::new(),\n-        },\n-    }\n-}\n-\n-// convert a span and an identifier to the corresponding\n-// 1-segment path\n-pub fn ident_to_path(s: Span, ident: Ident) -> Path {\n-    hir::Path {\n-        span: s,\n-        global: false,\n-        segments: hir_vec![hir::PathSegment {\n-            identifier: ident,\n-            parameters: hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n-                lifetimes: HirVec::new(),\n-                types: HirVec::new(),\n-                bindings: HirVec::new(),\n-            }),\n-        }],\n-    }\n-}"}, {"sha": "18c8220192487eeb7230717e546738252f7c11bf", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -47,8 +47,8 @@ use syntax::parse::token::InternedString;\n use syntax::ast;\n use syntax::attr::ThinAttributesExt;\n use hir;\n-use hir::util;\n use hir::intravisit as hir_visit;\n+use hir::intravisit::IdVisitor;\n use syntax::visit as ast_visit;\n \n /// Information about the registered lints.\n@@ -685,9 +685,9 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n     }\n \n     fn visit_ids<F>(&mut self, f: F)\n-        where F: FnOnce(&mut util::IdVisitor<LateContext>)\n+        where F: FnOnce(&mut IdVisitor<LateContext>)\n     {\n-        let mut v = util::IdVisitor::new(self);\n+        let mut v = IdVisitor::new(self);\n         f(&mut v);\n     }\n }"}, {"sha": "3ac2c3841346ad3cc7736a4ea77a1644b34cf8fd", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -45,8 +45,7 @@ use syntax::ptr::P;\n use syntax::parse::token::InternedString;\n use rustc_back::target::Target;\n use hir;\n-use hir::intravisit::Visitor;\n-use hir::util::IdVisitor;\n+use hir::intravisit::{IdVisitor, Visitor};\n \n pub use self::DefLike::{DlDef, DlField, DlImpl};\n pub use self::NativeLibraryKind::{NativeStatic, NativeFramework, NativeUnknown};"}, {"sha": "1b9673773041bd18e86c7ada06f7489be40df26d", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -479,7 +479,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             }\n \n             hir::ExprUnary(op, ref lhs) => {\n-                let pass_args = if hir::util::is_by_value_unop(op) {\n+                let pass_args = if op.is_by_value() {\n                     PassArgs::ByValue\n                 } else {\n                     PassArgs::ByRef\n@@ -491,7 +491,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             }\n \n             hir::ExprBinary(op, ref lhs, ref rhs) => {\n-                let pass_args = if hir::util::is_by_value_binop(op.node) {\n+                let pass_args = if op.node.is_by_value() {\n                     PassArgs::ByValue\n                 } else {\n                     PassArgs::ByRef\n@@ -524,7 +524,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n \n             hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n                 // NB All our assignment operations take the RHS by value\n-                assert!(hir::util::is_by_value_binop(op.node));\n+                assert!(op.node.is_by_value());\n \n                 if !self.walk_overloaded_operator(expr, lhs, vec![rhs], PassArgs::ByValue) {\n                     self.mutate_expr(expr, &lhs, MutateMode::WriteAndRead);"}, {"sha": "72d3c9414a4086d58fcb2235636b1364e5929541", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -484,7 +484,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         intravisit::walk_expr(ir, expr);\n       }\n-      hir::ExprBinary(op, _, _) if hir::util::lazy_binop(op.node) => {\n+      hir::ExprBinary(op, _, _) if op.node.is_lazy() => {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         intravisit::walk_expr(ir, expr);\n       }\n@@ -1142,7 +1142,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_exprs(&exprs[..], succ)\n           }\n \n-          hir::ExprBinary(op, ref l, ref r) if hir::util::lazy_binop(op.node) => {\n+          hir::ExprBinary(op, ref l, ref r) if op.node.is_lazy() => {\n             let r_succ = self.propagate_through_expr(&r, succ);\n \n             let ln = self.live_node(expr.id, expr.span);"}, {"sha": "3c60d5442285fed881834398b819cf8574e55ef2", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -15,7 +15,6 @@ use util::nodemap::FnvHashMap;\n \n use syntax::ast;\n use hir::{self, PatKind};\n-use hir::util::walk_pat;\n use syntax::codemap::{respan, Span, Spanned, DUMMY_SP};\n \n use std::cell::RefCell;\n@@ -115,7 +114,7 @@ pub fn pat_is_binding_or_wild(dm: &DefMap, pat: &hir::Pat) -> bool {\n pub fn pat_bindings<I>(dm: &RefCell<DefMap>, pat: &hir::Pat, mut it: I) where\n     I: FnMut(hir::BindingMode, ast::NodeId, Span, &Spanned<ast::Name>),\n {\n-    walk_pat(pat, |p| {\n+    pat.walk(|p| {\n         match p.node {\n           PatKind::Ident(binding_mode, ref pth, _) if pat_is_binding(&dm.borrow(), p) => {\n             it(binding_mode, p.id, p.span, &respan(pth.span, pth.node.name));\n@@ -128,7 +127,7 @@ pub fn pat_bindings<I>(dm: &RefCell<DefMap>, pat: &hir::Pat, mut it: I) where\n pub fn pat_bindings_ident<I>(dm: &RefCell<DefMap>, pat: &hir::Pat, mut it: I) where\n     I: FnMut(hir::BindingMode, ast::NodeId, Span, &Spanned<hir::Ident>),\n {\n-    walk_pat(pat, |p| {\n+    pat.walk(|p| {\n         match p.node {\n           PatKind::Ident(binding_mode, ref pth, _) if pat_is_binding(&dm.borrow(), p) => {\n             it(binding_mode, p.id, p.span, &respan(pth.span, pth.node));\n@@ -143,7 +142,7 @@ pub fn pat_bindings_ident<I>(dm: &RefCell<DefMap>, pat: &hir::Pat, mut it: I) wh\n /// an ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n pub fn pat_contains_bindings(dm: &DefMap, pat: &hir::Pat) -> bool {\n     let mut contains_bindings = false;\n-    walk_pat(pat, |p| {\n+    pat.walk(|p| {\n         if pat_is_binding(dm, p) {\n             contains_bindings = true;\n             false // there's at least one binding, can short circuit now.\n@@ -188,7 +187,7 @@ pub fn arm_contains_ref_binding(dm: &RefCell<DefMap>, arm: &hir::Arm) -> Option<\n /// an ident or wildcard, e.g. `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n pub fn pat_contains_bindings_or_wild(dm: &DefMap, pat: &hir::Pat) -> bool {\n     let mut contains_bindings = false;\n-    walk_pat(pat, |p| {\n+    pat.walk(|p| {\n         if pat_is_binding_or_wild(dm, p) {\n             contains_bindings = true;\n             false // there's at least one binding/wildcard, can short circuit now.\n@@ -224,7 +223,7 @@ pub fn def_to_path(tcx: &TyCtxt, id: DefId) -> hir::Path {\n /// Return variants that are necessary to exist for the pattern to match.\n pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<DefId> {\n     let mut variants = vec![];\n-    walk_pat(pat, |p| {\n+    pat.walk(|p| {\n         match p.node {\n             PatKind::TupleStruct(..) |\n             PatKind::Path(..) |"}, {"sha": "f8c0b63bf11bd41d36c1acc3d1b45912c603c83f", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -33,7 +33,6 @@ use syntax::ast::{self, NodeId};\n use hir;\n use hir::intravisit::{self, Visitor, FnKind};\n use hir::{Block, Item, FnDecl, Arm, Pat, PatKind, Stmt, Expr, Local};\n-use hir::util::stmt_id;\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n            RustcDecodable, Copy)]\n@@ -765,7 +764,7 @@ fn resolve_pat(visitor: &mut RegionResolutionVisitor, pat: &hir::Pat) {\n }\n \n fn resolve_stmt(visitor: &mut RegionResolutionVisitor, stmt: &hir::Stmt) {\n-    let stmt_id = stmt_id(stmt);\n+    let stmt_id = stmt.node.id();\n     debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n     // Every statement will clean up the temporaries created during"}, {"sha": "789d7dd9fefb001a328bed799555ef8da387cc57", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -48,7 +48,6 @@ use rustc::hir;\n use rustc::hir::{FnDecl, Block};\n use rustc::hir::intravisit;\n use rustc::hir::intravisit::{Visitor, FnKind};\n-use rustc::hir::util as hir_util;\n \n use rustc::mir::mir_map::MirMap;\n \n@@ -210,7 +209,7 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n {\n     // Check the body of fn items.\n     let tcx = this.tcx;\n-    let id_range = hir_util::compute_id_range_for_fn_body(fk, decl, body, sp, id);\n+    let id_range = intravisit::compute_id_range_for_fn_body(fk, decl, body, sp, id);\n     let (all_loans, move_data) =\n         gather_loans::gather_loans_in_fn(this, id, decl, body);\n "}, {"sha": "d290652576d84ded2edc8dae367a0595e0806cda", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -34,8 +34,7 @@ use std::iter::{FromIterator, IntoIterator, repeat};\n \n use rustc::hir;\n use rustc::hir::{Pat, PatKind};\n-use rustc::hir::intravisit::{self, Visitor, FnKind};\n-use rustc::hir::util as front_util;\n+use rustc::hir::intravisit::{self, IdVisitor, Visitor, FnKind};\n use rustc_back::slice;\n \n use syntax::ast::{self, DUMMY_NODE_ID, NodeId};\n@@ -241,7 +240,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n }\n \n fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat) {\n-    front_util::walk_pat(pat, |p| {\n+    pat.walk(|p| {\n         match p.node {\n             PatKind::Ident(hir::BindByValue(hir::MutImmutable), ident, None) => {\n                 let pat_ty = cx.tcx.pat_ty(p);\n@@ -274,7 +273,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n \n // Check that we do not match against a static NaN (#6804)\n fn check_for_static_nan(cx: &MatchCheckCtxt, pat: &Pat) {\n-    front_util::walk_pat(pat, |p| {\n+    pat.walk(|p| {\n         if let PatKind::Lit(ref expr) = p.node {\n             match eval_const_expr_partial(cx.tcx, &expr, ExprTypeChecked, None) {\n                 Ok(ConstVal::Float(f)) if f.is_nan() => {\n@@ -518,7 +517,7 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n                 renaming_map: renaming_map,\n             };\n \n-            let mut id_visitor = front_util::IdVisitor::new(&mut renaming_recorder);\n+            let mut id_visitor = IdVisitor::new(&mut renaming_recorder);\n \n             id_visitor.visit_expr(const_expr);\n         }\n@@ -1100,7 +1099,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n     };\n \n     for pat in pats {\n-        front_util::walk_pat(&pat, |p| {\n+        pat.walk(|p| {\n             if pat_is_binding(&def_map.borrow(), &p) {\n                 match p.node {\n                     PatKind::Ident(hir::BindByValue(_), _, ref sub) => {"}, {"sha": "574c7af4cfc28cf348b0f1a1035324093c507487", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -30,7 +30,6 @@ use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::{self, Span};\n \n use rustc::hir;\n-use rustc::hir::util::is_shift_binop;\n \n register_long_diagnostics! {\n E0519: r##\"\n@@ -130,7 +129,7 @@ impl LateLintPass for TypeLimits {\n                                  \"comparison is useless due to type limits\");\n                 }\n \n-                if is_shift_binop(binop.node) {\n+                if binop.node.is_shift() {\n                     let opt_ty_bits = match cx.tcx.node_id_to_type(l.id).sty {\n                         ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n                         ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),"}, {"sha": "790833f99ca8a432a62b773bffafb2987d47eb2f", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -23,7 +23,6 @@ use rustc::middle::pat_util;\n use rustc::ty::{self, VariantDef, Ty};\n use rustc::mir::repr::*;\n use rustc::hir;\n-use rustc::hir::util as hir_util;\n use syntax::ptr::P;\n \n impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n@@ -150,7 +149,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n \n             hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n                 if cx.tcx.is_method_call(self.id) {\n-                    let pass_args = if hir_util::is_by_value_binop(op.node) {\n+                    let pass_args = if op.node.is_by_value() {\n                         PassArgs::ByValue\n                     } else {\n                         PassArgs::ByRef\n@@ -172,7 +171,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n \n             hir::ExprBinary(op, ref lhs, ref rhs) => {\n                 if cx.tcx.is_method_call(self.id) {\n-                    let pass_args = if hir_util::is_by_value_binop(op.node) {\n+                    let pass_args = if op.node.is_by_value() {\n                         PassArgs::ByValue\n                     } else {\n                         PassArgs::ByRef"}, {"sha": "c0b8aad1c091393ce7fd9a526b54bb08ac4281b0", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -84,7 +84,6 @@ use rustc::hir::{PathSegment, PathParameters};\n use rustc::hir::HirVec;\n use rustc::hir::{TraitRef, Ty, TyBool, TyChar, TyFloat, TyInt};\n use rustc::hir::{TyRptr, TyStr, TyUint, TyPath, TyPtr};\n-use rustc::hir::util::walk_pat;\n \n use std::collections::{HashMap, HashSet};\n use std::cell::{Cell, RefCell};\n@@ -2244,7 +2243,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                        // pattern that binds them\n                        bindings_list: &mut HashMap<Name, NodeId>) {\n         let pat_id = pattern.id;\n-        walk_pat(pattern, |pattern| {\n+        pattern.walk(|pattern| {\n             match pattern.node {\n                 PatKind::Ident(binding_mode, ref path1, ref at_rhs) => {\n                     // The meaning of PatKind::Ident with no type parameters"}, {"sha": "6714f6440ee4ffe25716f13bf34989fd5f7f2b0d", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -712,7 +712,7 @@ fn cast_shift_rhs<F, G>(op: hir::BinOp_,\n           G: FnOnce(ValueRef, Type) -> ValueRef\n {\n     // Shifts may have any size int on the rhs\n-    if hir::util::is_shift_binop(op) {\n+    if op.is_shift() {\n         let mut rhs_llty = val_ty(rhs);\n         let mut lhs_llty = val_ty(lhs);\n         if rhs_llty.kind() == Vector {"}, {"sha": "f3cb4d5001aa517a9df5fb44247f020117900d29", "filename": "src/librustc_trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_trans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_trans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontrolflow.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -26,7 +26,6 @@ use expr;\n use machine;\n \n use rustc::hir;\n-use rustc::hir::util as ast_util;\n \n use syntax::ast;\n use syntax::parse::token::InternedString;\n@@ -49,7 +48,7 @@ pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n \n     let mut bcx = cx;\n \n-    let id = ast_util::stmt_id(s);\n+    let id = s.node.id();\n     let cleanup_debug_loc =\n         debuginfo::get_cleanup_debug_loc_for_ast_node(bcx.ccx(), id, s.span, false);\n     fcx.push_ast_cleanup_scope(cleanup_debug_loc);\n@@ -70,7 +69,7 @@ pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         }\n     }\n \n-    bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, ast_util::stmt_id(s));\n+    bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, s.node.id());\n \n     return bcx;\n }"}, {"sha": "b98b98813507a39f2eafc0027bd7a67c1519ee82", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -116,7 +116,7 @@ fn walk_block(cx: &CrateContext,\n \n     // The interesting things here are statements and the concluding expression.\n     for statement in &block.stmts {\n-        scope_map.insert(hir::util::stmt_id(statement),\n+        scope_map.insert(statement.node.id(),\n                          scope_stack.last().unwrap().scope_metadata);\n \n         match statement.node {"}, {"sha": "7e9c8228f29f43b30b74d181c9eb869a76a04f7d", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -238,7 +238,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         return FunctionDebugContext::FunctionWithoutDebugInfo;\n     }\n \n-    let empty_generics = hir::util::empty_generics();\n+    let empty_generics = hir::Generics::empty();\n \n     let fnitem = cx.tcx().map.get(fn_ast_id);\n "}, {"sha": "fce8656fb93d86dfb03c89a36fb2796a08ce39b9", "filename": "src/librustc_trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_trans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_trans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fexpr.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -1180,7 +1180,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // if not overloaded, would be RvalueDatumExpr\n             let lhs = unpack_datum!(bcx, trans(bcx, &lhs));\n             let mut rhs = unpack_datum!(bcx, trans(bcx, &rhs_expr));\n-            if !hir::util::is_by_value_binop(op.node) {\n+            if !op.node.is_by_value() {\n                 rhs = unpack_datum!(bcx, auto_ref(bcx, rhs, rhs_expr));\n             }\n \n@@ -1204,7 +1204,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             span_bug!(\n                 expr.span,\n                 \"augmented assignment `{}=` should always be a rvalue_stmt\",\n-                hir::util::binop_to_string(op.node))\n+                op.node.as_str())\n         }\n         _ => {\n             span_bug!("}, {"sha": "eaf8479585f8d8d2aabb61ba711f899892422621", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -32,7 +32,6 @@ use syntax::ptr::P;\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::print as pprust;\n-use rustc::hir::util as hir_util;\n \n pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                            pat: &'tcx hir::Pat,\n@@ -197,7 +196,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             }\n         }\n         PatKind::Ident(_, ref path, _) => {\n-            let path = hir_util::ident_to_path(path.span, path.node);\n+            let path = hir::Path::from_ident(path.span, path.node);\n             check_pat_enum(pcx, pat, &path, Some(&[]), expected, false);\n         }\n         PatKind::TupleStruct(ref path, ref subpats) => {"}, {"sha": "c3a42826dbc417bb661f2d5cfca045da250bc7bf", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -3987,7 +3987,7 @@ fn check_block_with_expected<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let mut any_err = false;\n     for s in &blk.stmts {\n         check_stmt(fcx, s);\n-        let s_id = hir::util::stmt_id(s);\n+        let s_id = s.node.id();\n         let s_ty = fcx.node_ty(s_id);\n         if any_diverges && !warned && match s.node {\n             hir::StmtDecl(ref decl, _) => {"}, {"sha": "f7f40e6077f4a55c1a89e080642acc50eb280ee1", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -23,7 +23,6 @@ use rustc::ty::{Ty, TypeFoldable, PreferMutLvalue};\n use syntax::ast;\n use syntax::parse::token;\n use rustc::hir;\n-use rustc::hir::util as hir_util;\n \n /// Check a `a <op>= b`\n pub fn check_binop_assign<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n@@ -184,12 +183,12 @@ fn check_overloaded_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 if let IsAssign::Yes = is_assign {\n                     span_err!(fcx.tcx().sess, lhs_expr.span, E0368,\n                               \"binary assignment operation `{}=` cannot be applied to type `{}`\",\n-                              hir_util::binop_to_string(op.node),\n+                              op.node.as_str(),\n                               lhs_ty);\n                 } else {\n                     let mut err = struct_span_err!(fcx.tcx().sess, lhs_expr.span, E0369,\n                         \"binary operation `{}` cannot be applied to type `{}`\",\n-                        hir_util::binop_to_string(op.node),\n+                        op.node.as_str(),\n                         lhs_ty);\n                     let missing_trait = match op.node {\n                         hir::BiAdd    => Some(\"std::ops::Add\"),\n@@ -235,7 +234,7 @@ pub fn check_user_unop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                  op: hir::UnOp)\n                                  -> Ty<'tcx>\n {\n-    assert!(hir_util::is_by_value_unop(op));\n+    assert!(op.is_by_value());\n     match lookup_op_method(fcx, ex, operand_ty, vec![],\n                            token::intern(mname), trait_did,\n                            operand_expr) {\n@@ -272,7 +271,7 @@ fn name_and_trait_def_id(fcx: &FnCtxt,\n             hir::BiOr => {\n                 span_bug!(op.span,\n                           \"impossible assignment operation: {}=\",\n-                          hir_util::binop_to_string(op.node))\n+                          op.node.as_str())\n             }\n         }\n     } else {"}, {"sha": "02114c170c44bf37ff945d0d0688d1e35e9fae15", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -102,7 +102,6 @@ use syntax::ast;\n use syntax::codemap::Span;\n use rustc::hir::intravisit::{self, Visitor};\n use rustc::hir::{self, PatKind};\n-use rustc::hir::util as hir_util;\n \n use self::SubjectNode::Subject;\n \n@@ -689,7 +688,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n         },\n \n         hir::ExprBinary(op, ref lhs, ref rhs) if has_method_map => {\n-            let implicitly_ref_args = !hir_util::is_by_value_binop(op.node);\n+            let implicitly_ref_args = !op.node.is_by_value();\n \n             // As `expr_method_call`, but the call is via an\n             // overloaded op.  Note that we (sadly) currently use an\n@@ -716,7 +715,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n         }\n \n         hir::ExprUnary(op, ref lhs) if has_method_map => {\n-            let implicitly_ref_args = !hir_util::is_by_value_unop(op);\n+            let implicitly_ref_args = !op.is_by_value();\n \n             // As above.\n             constrain_call(rcx, expr, Some(&lhs),"}, {"sha": "50f2f27b3d2a200a422cec737192dca2e4c1fba2", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -30,7 +30,6 @@ use syntax::ast;\n use syntax::codemap::{DUMMY_SP, Span};\n use rustc::hir::print::pat_to_string;\n use rustc::hir::intravisit::{self, Visitor};\n-use rustc::hir::util as hir_util;\n use rustc::hir;\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -112,7 +111,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                     // system.\n                     match e.node {\n                         hir::ExprBinary(..) => {\n-                            if !hir_util::is_by_value_binop(op.node) {\n+                            if !op.node.is_by_value() {\n                                 self.fcx.inh.tables.borrow_mut().adjustments.remove(&lhs.id);\n                             }\n                         },\n@@ -142,7 +141,7 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n             return;\n         }\n \n-        self.visit_node_id(ResolvingExpr(s.span), hir_util::stmt_id(s));\n+        self.visit_node_id(ResolvingExpr(s.span), s.node.id());\n         intravisit::walk_stmt(self, s);\n     }\n "}]}