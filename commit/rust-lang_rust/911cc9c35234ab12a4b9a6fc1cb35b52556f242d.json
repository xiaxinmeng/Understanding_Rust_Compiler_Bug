{"sha": "911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxMWNjOWMzNTIzNGFiMTJhNGI5YTZmYzFjYjM1YjUyNTU2ZjI0MmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-28T00:46:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-28T00:46:48Z"}, "message": "auto merge of #14414 : richo/rust/features/nerf_unused_string_fns, r=alexcrichton\n\nThis should block on #14323", "tree": {"sha": "f434006eca9cc58dd01c2a033c505d606d2fced2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f434006eca9cc58dd01c2a033c505d606d2fced2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "html_url": "https://github.com/rust-lang/rust/commit/911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30bf73fd789ad1414284f59b005e85304ff963ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/30bf73fd789ad1414284f59b005e85304ff963ad", "html_url": "https://github.com/rust-lang/rust/commit/30bf73fd789ad1414284f59b005e85304ff963ad"}, {"sha": "c256dcf8b66fb7100e2d735d6640cf76cb2d22f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c256dcf8b66fb7100e2d735d6640cf76cb2d22f5", "html_url": "https://github.com/rust-lang/rust/commit/c256dcf8b66fb7100e2d735d6640cf76cb2d22f5"}], "stats": {"total": 6034, "additions": 3019, "deletions": 3015}, "files": [{"sha": "701f8899fa4ef8da792eefaa6f6dc4cd763c946a", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -50,7 +50,7 @@ fn start(argc: int, argv: **u8) -> int {\n pub fn main() {\n     let args = os::args();\n     let config = parse_config(args.move_iter()\n-                                  .map(|x| x.to_strbuf())\n+                                  .map(|x| x.to_string())\n                                   .collect());\n     log_config(&config);\n     run_tests(&config);\n@@ -134,15 +134,15 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n     Config {\n         compile_lib_path: matches.opt_str(\"compile-lib-path\")\n                                  .unwrap()\n-                                 .to_strbuf(),\n-        run_lib_path: matches.opt_str(\"run-lib-path\").unwrap().to_strbuf(),\n+                                 .to_string(),\n+        run_lib_path: matches.opt_str(\"run-lib-path\").unwrap().to_string(),\n         rustc_path: opt_path(matches, \"rustc-path\"),\n         clang_path: matches.opt_str(\"clang-path\").map(|s| Path::new(s)),\n         llvm_bin_path: matches.opt_str(\"llvm-bin-path\").map(|s| Path::new(s)),\n         src_base: opt_path(matches, \"src-base\"),\n         build_base: opt_path(matches, \"build-base\"),\n         aux_base: opt_path(matches, \"aux-base\"),\n-        stage_id: matches.opt_str(\"stage-id\").unwrap().to_strbuf(),\n+        stage_id: matches.opt_str(\"stage-id\").unwrap().to_string(),\n         mode: FromStr::from_str(matches.opt_str(\"mode\")\n                                        .unwrap()\n                                        .as_slice()).expect(\"invalid mode\"),\n@@ -156,32 +156,32 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n         ratchet_noise_percent:\n             matches.opt_str(\"ratchet-noise-percent\")\n                    .and_then(|s| from_str::<f64>(s.as_slice())),\n-        runtool: matches.opt_str(\"runtool\").map(|x| x.to_strbuf()),\n+        runtool: matches.opt_str(\"runtool\").map(|x| x.to_string()),\n         host_rustcflags: matches.opt_str(\"host-rustcflags\")\n-                                .map(|x| x.to_strbuf()),\n+                                .map(|x| x.to_string()),\n         target_rustcflags: matches.opt_str(\"target-rustcflags\")\n-                                  .map(|x| x.to_strbuf()),\n+                                  .map(|x| x.to_string()),\n         jit: matches.opt_present(\"jit\"),\n-        target: opt_str2(matches.opt_str(\"target\").map(|x| x.to_strbuf())),\n-        host: opt_str2(matches.opt_str(\"host\").map(|x| x.to_strbuf())),\n+        target: opt_str2(matches.opt_str(\"target\").map(|x| x.to_string())),\n+        host: opt_str2(matches.opt_str(\"host\").map(|x| x.to_string())),\n         android_cross_path: opt_path(matches, \"android-cross-path\"),\n         adb_path: opt_str2(matches.opt_str(\"adb-path\")\n-                                  .map(|x| x.to_strbuf())),\n+                                  .map(|x| x.to_string())),\n         adb_test_dir: opt_str2(matches.opt_str(\"adb-test-dir\")\n-                                      .map(|x| x.to_strbuf())),\n+                                      .map(|x| x.to_string())),\n         adb_device_status:\n             \"arm-linux-androideabi\" ==\n                 opt_str2(matches.opt_str(\"target\")\n-                                .map(|x| x.to_strbuf())).as_slice() &&\n+                                .map(|x| x.to_string())).as_slice() &&\n             \"(none)\" !=\n                 opt_str2(matches.opt_str(\"adb-test-dir\")\n-                                .map(|x| x.to_strbuf())).as_slice() &&\n+                                .map(|x| x.to_string())).as_slice() &&\n             !opt_str2(matches.opt_str(\"adb-test-dir\")\n-                             .map(|x| x.to_strbuf())).is_empty(),\n+                             .map(|x| x.to_string())).is_empty(),\n         lldb_python_dir: matches.opt_str(\"lldb-python-dir\")\n-                                .map(|x| x.to_strbuf()),\n+                                .map(|x| x.to_string()),\n         test_shard: test::opt_shard(matches.opt_str(\"test-shard\")\n-                                           .map(|x| x.to_strbuf())),\n+                                           .map(|x| x.to_string())),\n         verbose: matches.opt_present(\"verbose\")\n     }\n }\n@@ -201,7 +201,7 @@ pub fn log_config(config: &Config) {\n                            opt_str(&config.filter\n                                           .as_ref()\n                                           .map(|re| {\n-                                              re.to_str().into_strbuf()\n+                                              re.to_str().into_string()\n                                           }))));\n     logv(c, format_strbuf!(\"runtool: {}\", opt_str(&config.runtool)));\n     logv(c, format_strbuf!(\"host-rustcflags: {}\",\n@@ -218,7 +218,7 @@ pub fn log_config(config: &Config) {\n     logv(c, format_strbuf!(\"adb_device_status: {}\",\n                            config.adb_device_status));\n     match config.test_shard {\n-        None => logv(c, \"test_shard: (all)\".to_strbuf()),\n+        None => logv(c, \"test_shard: (all)\".to_string()),\n         Some((a,b)) => logv(c, format_strbuf!(\"test_shard: {}.{}\", a, b))\n     }\n     logv(c, format_strbuf!(\"verbose: {}\", config.verbose));\n@@ -234,7 +234,7 @@ pub fn opt_str<'a>(maybestr: &'a Option<String>) -> &'a str {\n \n pub fn opt_str2(maybestr: Option<String>) -> String {\n     match maybestr {\n-        None => \"(none)\".to_strbuf(),\n+        None => \"(none)\".to_string(),\n         Some(s) => s,\n     }\n }\n@@ -314,10 +314,10 @@ pub fn is_test(config: &Config, testfile: &Path) -> bool {\n     // Pretty-printer does not work with .rc files yet\n     let valid_extensions =\n         match config.mode {\n-          Pretty => vec!(\".rs\".to_owned()),\n-          _ => vec!(\".rc\".to_owned(), \".rs\".to_owned())\n+          Pretty => vec!(\".rs\".to_string()),\n+          _ => vec!(\".rc\".to_string(), \".rs\".to_string())\n         };\n-    let invalid_prefixes = vec!(\".\".to_owned(), \"#\".to_owned(), \"~\".to_owned());\n+    let invalid_prefixes = vec!(\".\".to_string(), \"#\".to_string(), \"~\".to_string());\n     let name = testfile.filename_str().unwrap();\n \n     let mut valid = false;\n@@ -367,7 +367,7 @@ pub fn make_test_name(config: &Config, testfile: &Path) -> test::TestName {\n pub fn make_test_closure(config: &Config, testfile: &Path) -> test::TestFn {\n     let config = (*config).clone();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let testfile = testfile.as_str().unwrap().to_strbuf();\n+    let testfile = testfile.as_str().unwrap().to_string();\n     test::DynTestFn(proc() {\n         runtest::run(config, testfile)\n     })\n@@ -376,7 +376,7 @@ pub fn make_test_closure(config: &Config, testfile: &Path) -> test::TestFn {\n pub fn make_metrics_test_closure(config: &Config, testfile: &Path) -> test::TestFn {\n     let config = (*config).clone();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let testfile = testfile.as_str().unwrap().to_strbuf();\n+    let testfile = testfile.as_str().unwrap().to_string();\n     test::DynMetricFn(proc(mm) {\n         runtest::run_metrics(config, testfile, mm)\n     })"}, {"sha": "c96e688c2900cae3d864b04715d2ef9df5cd5b7d", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -31,8 +31,8 @@ pub fn load_errors(re: &Regex, testfile: &Path) -> Vec<ExpectedError> {\n fn parse_expected(line_num: uint, line: &str, re: &Regex) -> Option<ExpectedError> {\n     re.captures(line).and_then(|caps| {\n         let adjusts = caps.name(\"adjusts\").len();\n-        let kind = caps.name(\"kind\").to_ascii().to_lower().into_str().to_strbuf();\n-        let msg = caps.name(\"msg\").trim().to_strbuf();\n+        let kind = caps.name(\"kind\").to_ascii().to_lower().into_str().to_string();\n+        let msg = caps.name(\"msg\").trim().to_string();\n \n         debug!(\"line={} kind={} msg={}\", line_num, kind, msg);\n         Some(ExpectedError {"}, {"sha": "531f51f982f6bdfeb45d53c5f4af51447d4b1b19", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -170,23 +170,23 @@ fn iter_header(testfile: &Path, it: |&str| -> bool) -> bool {\n }\n \n fn parse_error_pattern(line: &str) -> Option<String> {\n-    parse_name_value_directive(line, \"error-pattern\".to_strbuf())\n+    parse_name_value_directive(line, \"error-pattern\".to_string())\n }\n \n fn parse_aux_build(line: &str) -> Option<String> {\n-    parse_name_value_directive(line, \"aux-build\".to_strbuf())\n+    parse_name_value_directive(line, \"aux-build\".to_string())\n }\n \n fn parse_compile_flags(line: &str) -> Option<String> {\n-    parse_name_value_directive(line, \"compile-flags\".to_strbuf())\n+    parse_name_value_directive(line, \"compile-flags\".to_string())\n }\n \n fn parse_run_flags(line: &str) -> Option<String> {\n-    parse_name_value_directive(line, \"run-flags\".to_strbuf())\n+    parse_name_value_directive(line, \"run-flags\".to_string())\n }\n \n fn parse_check_line(line: &str) -> Option<String> {\n-    parse_name_value_directive(line, \"check\".to_strbuf())\n+    parse_name_value_directive(line, \"check\".to_string())\n }\n \n fn parse_force_host(line: &str) -> bool {\n@@ -206,15 +206,15 @@ fn parse_no_pretty_expanded(line: &str) -> bool {\n }\n \n fn parse_exec_env(line: &str) -> Option<(String, String)> {\n-    parse_name_value_directive(line, \"exec-env\".to_strbuf()).map(|nv| {\n+    parse_name_value_directive(line, \"exec-env\".to_string()).map(|nv| {\n         // nv is either FOO or FOO=BAR\n         let mut strs: Vec<String> = nv.as_slice()\n                                       .splitn('=', 1)\n-                                      .map(|s| s.to_strbuf())\n+                                      .map(|s| s.to_string())\n                                       .collect();\n \n         match strs.len() {\n-          1u => (strs.pop().unwrap(), \"\".to_strbuf()),\n+          1u => (strs.pop().unwrap(), \"\".to_string()),\n           2u => {\n               let end = strs.pop().unwrap();\n               (strs.pop().unwrap(), end)\n@@ -225,7 +225,7 @@ fn parse_exec_env(line: &str) -> Option<(String, String)> {\n }\n \n fn parse_pp_exact(line: &str, testfile: &Path) -> Option<Path> {\n-    match parse_name_value_directive(line, \"pp-exact\".to_strbuf()) {\n+    match parse_name_value_directive(line, \"pp-exact\".to_string()) {\n       Some(s) => Some(Path::new(s)),\n       None => {\n         if parse_name_directive(line, \"pp-exact\") {\n@@ -247,7 +247,7 @@ pub fn parse_name_value_directive(line: &str, directive: String)\n     match line.find_str(keycolon.as_slice()) {\n         Some(colon) => {\n             let value = line.slice(colon + keycolon.len(),\n-                                   line.len()).to_strbuf();\n+                                   line.len()).to_string();\n             debug!(\"{}: {}\", directive, value);\n             Some(value)\n         }"}, {"sha": "a48a9f1be754133af968a123c297bc9506cb0e2c", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -15,7 +15,7 @@ use std::unstable::dynamic_lib::DynamicLibrary;\n \n fn target_env(lib_path: &str, prog: &str) -> Vec<(String, String)> {\n     let prog = if cfg!(windows) {prog.slice_to(prog.len() - 4)} else {prog};\n-    let mut aux_path = prog.to_strbuf();\n+    let mut aux_path = prog.to_string();\n     aux_path.push_str(\".libaux\");\n \n     // Need to be sure to put both the lib_path and the aux path in the dylib\n@@ -27,16 +27,16 @@ fn target_env(lib_path: &str, prog: &str) -> Vec<(String, String)> {\n     // Remove the previous dylib search path var\n     let var = DynamicLibrary::envvar();\n     let mut env: Vec<(String,String)> =\n-        os::env().move_iter().map(|(a,b)|(a.to_strbuf(), b.to_strbuf())).collect();\n+        os::env().move_iter().map(|(a,b)|(a.to_string(), b.to_string())).collect();\n     match env.iter().position(|&(ref k, _)| k.as_slice() == var) {\n         Some(i) => { env.remove(i); }\n         None => {}\n     }\n \n     // Add the new dylib search path var\n     let newpath = DynamicLibrary::create_path(path.as_slice());\n-    env.push((var.to_strbuf(),\n-              str::from_utf8(newpath.as_slice()).unwrap().to_strbuf()));\n+    env.push((var.to_string(),\n+              str::from_utf8(newpath.as_slice()).unwrap().to_string()));\n     return env;\n }\n \n@@ -59,8 +59,8 @@ pub fn run(lib_path: &str,\n \n             Some(Result {\n                 status: status,\n-                out: str::from_utf8(output.as_slice()).unwrap().to_strbuf(),\n-                err: str::from_utf8(error.as_slice()).unwrap().to_strbuf()\n+                out: str::from_utf8(output.as_slice()).unwrap().to_string(),\n+                err: str::from_utf8(error.as_slice()).unwrap().to_string()\n             })\n         },\n         Err(..) => None"}, {"sha": "7ad302646b36cee5b633964b69d1ce857f72f9f6", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 149, "deletions": 149, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -73,7 +73,7 @@ fn run_cfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n     let proc_res = compile_test(config, props, testfile);\n \n     if proc_res.status.success() {\n-        fatal_ProcRes(\"compile-fail test compiled successfully!\".to_strbuf(),\n+        fatal_ProcRes(\"compile-fail test compiled successfully!\".to_string(),\n                       &proc_res);\n     }\n \n@@ -83,7 +83,7 @@ fn run_cfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n     if !expected_errors.is_empty() {\n         if !props.error_patterns.is_empty() {\n             fatal(\"both error pattern and expected errors \\\n-                   specified\".to_strbuf());\n+                   specified\".to_string());\n         }\n         check_expected_errors(expected_errors, testfile, &proc_res);\n     } else {\n@@ -97,7 +97,7 @@ fn run_rfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n         let proc_res = compile_test(config, props, testfile);\n \n         if !proc_res.status.success() {\n-            fatal_ProcRes(\"compilation failed!\".to_strbuf(), &proc_res);\n+            fatal_ProcRes(\"compilation failed!\".to_string(), &proc_res);\n         }\n \n         exec_compiled_test(config, props, testfile)\n@@ -108,7 +108,7 @@ fn run_rfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n     // The value our Makefile configures valgrind to return on failure\n     static VALGRIND_ERR: int = 100;\n     if proc_res.status.matches_exit_status(VALGRIND_ERR) {\n-        fatal_ProcRes(\"run-fail test isn't valgrind-clean!\".to_strbuf(),\n+        fatal_ProcRes(\"run-fail test isn't valgrind-clean!\".to_string(),\n                       &proc_res);\n     }\n \n@@ -132,35 +132,35 @@ fn run_rpass_test(config: &Config, props: &TestProps, testfile: &Path) {\n         let mut proc_res = compile_test(config, props, testfile);\n \n         if !proc_res.status.success() {\n-            fatal_ProcRes(\"compilation failed!\".to_strbuf(), &proc_res);\n+            fatal_ProcRes(\"compilation failed!\".to_string(), &proc_res);\n         }\n \n         proc_res = exec_compiled_test(config, props, testfile);\n \n         if !proc_res.status.success() {\n-            fatal_ProcRes(\"test run failed!\".to_strbuf(), &proc_res);\n+            fatal_ProcRes(\"test run failed!\".to_string(), &proc_res);\n         }\n     } else {\n         let proc_res = jit_test(config, props, testfile);\n \n         if !proc_res.status.success() {\n-            fatal_ProcRes(\"jit failed!\".to_strbuf(), &proc_res);\n+            fatal_ProcRes(\"jit failed!\".to_string(), &proc_res);\n         }\n     }\n }\n \n fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n     if props.pp_exact.is_some() {\n-        logv(config, \"testing for exact pretty-printing\".to_strbuf());\n+        logv(config, \"testing for exact pretty-printing\".to_string());\n     } else {\n-        logv(config, \"testing for converging pretty-printing\".to_strbuf());\n+        logv(config, \"testing for converging pretty-printing\".to_string());\n     }\n \n     let rounds =\n         match props.pp_exact { Some(_) => 1, None => 2 };\n \n     let src = File::open(testfile).read_to_end().unwrap();\n-    let src = str::from_utf8(src.as_slice()).unwrap().to_strbuf();\n+    let src = str::from_utf8(src.as_slice()).unwrap().to_string();\n     let mut srcs = vec!(src);\n \n     let mut round = 0;\n@@ -169,7 +169,7 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n         let proc_res = print_source(config,\n                                     props,\n                                     testfile,\n-                                    (*srcs.get(round)).to_strbuf(),\n+                                    (*srcs.get(round)).to_string(),\n                                     \"normal\");\n \n         if !proc_res.status.success() {\n@@ -187,17 +187,17 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n         Some(ref file) => {\n             let filepath = testfile.dir_path().join(file);\n             let s = File::open(&filepath).read_to_end().unwrap();\n-            str::from_utf8(s.as_slice()).unwrap().to_strbuf()\n+            str::from_utf8(s.as_slice()).unwrap().to_string()\n           }\n           None => { (*srcs.get(srcs.len() - 2u)).clone() }\n         };\n     let mut actual = (*srcs.get(srcs.len() - 1u)).clone();\n \n     if props.pp_exact.is_some() {\n         // Now we have to care about line endings\n-        let cr = \"\\r\".to_strbuf();\n-        actual = actual.replace(cr.as_slice(), \"\").to_strbuf();\n-        expected = expected.replace(cr.as_slice(), \"\").to_strbuf();\n+        let cr = \"\\r\".to_string();\n+        actual = actual.replace(cr.as_slice(), \"\").to_string();\n+        expected = expected.replace(cr.as_slice(), \"\").to_string();\n     }\n \n     compare_source(expected.as_slice(), actual.as_slice());\n@@ -206,7 +206,7 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n     let proc_res = typecheck_source(config, props, testfile, actual);\n \n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"pretty-printed source does not typecheck\".to_strbuf(),\n+        fatal_ProcRes(\"pretty-printed source does not typecheck\".to_string(),\n                       &proc_res);\n     }\n     if props.no_pretty_expanded { return }\n@@ -238,7 +238,7 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n                         make_pp_args(config,\n                                      props,\n                                      testfile,\n-                                     pretty_type.to_strbuf()),\n+                                     pretty_type.to_string()),\n                         props.exec_env.clone(),\n                         config.compile_lib_path.as_slice(),\n                         Some(src))\n@@ -250,24 +250,24 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n                     pretty_type: String) -> ProcArgs {\n         let aux_dir = aux_output_dir_name(config, testfile);\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        let mut args = vec!(\"-\".to_strbuf(),\n-                            \"--pretty\".to_strbuf(),\n+        let mut args = vec!(\"-\".to_string(),\n+                            \"--pretty\".to_string(),\n                             pretty_type,\n                             format_strbuf!(\"--target={}\", config.target),\n-                            \"-L\".to_strbuf(),\n-                            aux_dir.as_str().unwrap().to_strbuf());\n+                            \"-L\".to_string(),\n+                            aux_dir.as_str().unwrap().to_string());\n         args.push_all_move(split_maybe_args(&config.target_rustcflags));\n         args.push_all_move(split_maybe_args(&props.compile_flags));\n         return ProcArgs {\n-            prog: config.rustc_path.as_str().unwrap().to_strbuf(),\n+            prog: config.rustc_path.as_str().unwrap().to_string(),\n             args: args,\n         };\n     }\n \n     fn compare_source(expected: &str, actual: &str) {\n         if expected != actual {\n             error(\"pretty-printed source does not match expected \\\n-                   source\".to_strbuf());\n+                   source\".to_string());\n             println!(\"\\n\\\n expected:\\n\\\n ------------------------------------------\\n\\\n@@ -297,19 +297,19 @@ actual:\\n\\\n             config.target.as_slice()\n         };\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        let mut args = vec!(\"-\".to_strbuf(),\n-                            \"--no-trans\".to_strbuf(),\n-                            \"--crate-type=lib\".to_strbuf(),\n+        let mut args = vec!(\"-\".to_string(),\n+                            \"--no-trans\".to_string(),\n+                            \"--crate-type=lib\".to_string(),\n                             format_strbuf!(\"--target={}\", target),\n-                            \"-L\".to_strbuf(),\n-                            config.build_base.as_str().unwrap().to_strbuf(),\n-                            \"-L\".to_strbuf(),\n-                            aux_dir.as_str().unwrap().to_strbuf());\n+                            \"-L\".to_string(),\n+                            config.build_base.as_str().unwrap().to_string(),\n+                            \"-L\".to_string(),\n+                            aux_dir.as_str().unwrap().to_string());\n         args.push_all_move(split_maybe_args(&config.target_rustcflags));\n         args.push_all_move(split_maybe_args(&props.compile_flags));\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         return ProcArgs {\n-            prog: config.rustc_path.as_str().unwrap().to_strbuf(),\n+            prog: config.rustc_path.as_str().unwrap().to_string(),\n             args: args,\n         };\n     }\n@@ -324,12 +324,12 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n \n     let config = &mut config;\n     let DebuggerCommands { commands, check_lines, .. } = parse_debugger_commands(testfile, \"gdb\");\n-    let mut cmds = commands.connect(\"\\n\").to_strbuf();\n+    let mut cmds = commands.connect(\"\\n\").to_string();\n \n     // compile test file (it shoud have 'compile-flags:-g' in the header)\n     let compiler_run_result = compile_test(config, props, testfile);\n     if !compiler_run_result.status.success() {\n-        fatal_ProcRes(\"compilation failed!\".to_strbuf(), &compiler_run_result);\n+        fatal_ProcRes(\"compilation failed!\".to_string(), &compiler_run_result);\n     }\n \n     let exe_file = make_exe_name(config, testfile);\n@@ -339,17 +339,17 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n     match config.target.as_slice() {\n         \"arm-linux-androideabi\" => {\n \n-            cmds = cmds.replace(\"run\", \"continue\").to_strbuf();\n+            cmds = cmds.replace(\"run\", \"continue\").to_string();\n \n             // write debugger script\n-            let script_str = [\"set charset UTF-8\".to_strbuf(),\n+            let script_str = [\"set charset UTF-8\".to_string(),\n                               format_strbuf!(\"file {}\",\n                                              exe_file.as_str()\n                                                      .unwrap()\n-                                                     .to_strbuf()),\n-                              \"target remote :5039\".to_strbuf(),\n+                                                     .to_string()),\n+                              \"target remote :5039\".to_string(),\n                               cmds,\n-                              \"quit\".to_strbuf()].connect(\"\\n\");\n+                              \"quit\".to_string()].connect(\"\\n\");\n             debug!(\"script_str = {}\", script_str);\n             dump_output_file(config,\n                              testfile,\n@@ -360,24 +360,24 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             procsrv::run(\"\",\n                          config.adb_path.as_slice(),\n                          [\n-                            \"push\".to_strbuf(),\n-                            exe_file.as_str().unwrap().to_strbuf(),\n+                            \"push\".to_string(),\n+                            exe_file.as_str().unwrap().to_string(),\n                             config.adb_test_dir.clone()\n                          ],\n-                         vec!((\"\".to_strbuf(), \"\".to_strbuf())),\n-                         Some(\"\".to_strbuf()))\n+                         vec!((\"\".to_string(), \"\".to_string())),\n+                         Some(\"\".to_string()))\n                 .expect(format_strbuf!(\"failed to exec `{}`\",\n                                        config.adb_path));\n \n             procsrv::run(\"\",\n                          config.adb_path.as_slice(),\n                          [\n-                            \"forward\".to_strbuf(),\n-                            \"tcp:5039\".to_strbuf(),\n-                            \"tcp:5039\".to_strbuf()\n+                            \"forward\".to_string(),\n+                            \"tcp:5039\".to_string(),\n+                            \"tcp:5039\".to_string()\n                          ],\n-                         vec!((\"\".to_strbuf(), \"\".to_strbuf())),\n-                         Some(\"\".to_strbuf()))\n+                         vec!((\"\".to_string(), \"\".to_string())),\n+                         Some(\"\".to_string()))\n                 .expect(format_strbuf!(\"failed to exec `{}`\", config.adb_path));\n \n             let adb_arg = format_strbuf!(\"export LD_LIBRARY_PATH={}; \\\n@@ -392,12 +392,12 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                                                       config.adb_path\n                                                             .as_slice(),\n                                                       [\n-                                                        \"shell\".to_strbuf(),\n+                                                        \"shell\".to_string(),\n                                                         adb_arg.clone()\n                                                       ],\n-                                                      vec!((\"\".to_strbuf(),\n-                                                            \"\".to_strbuf())),\n-                                                      Some(\"\".to_strbuf()))\n+                                                      vec!((\"\".to_string(),\n+                                                            \"\".to_string())),\n+                                                      Some(\"\".to_string()))\n                 .expect(format_strbuf!(\"failed to exec `{}`\",\n                                        config.adb_path));\n             loop {\n@@ -413,16 +413,16 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             }\n \n             let tool_path = match config.android_cross_path.as_str() {\n-                Some(x) => x.to_strbuf(),\n-                None => fatal(\"cannot find android cross path\".to_strbuf())\n+                Some(x) => x.to_string(),\n+                None => fatal(\"cannot find android cross path\".to_string())\n             };\n \n             let debugger_script = make_out_name(config, testfile, \"debugger.script\");\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             let debugger_opts =\n-                vec!(\"-quiet\".to_strbuf(),\n-                     \"-batch\".to_strbuf(),\n-                     \"-nx\".to_strbuf(),\n+                vec!(\"-quiet\".to_string(),\n+                     \"-batch\".to_string(),\n+                     \"-nx\".to_string(),\n                      format_strbuf!(\"-command={}\",\n                                     debugger_script.as_str().unwrap()));\n \n@@ -434,7 +434,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             } = procsrv::run(\"\",\n                              gdb_path.as_slice(),\n                              debugger_opts.as_slice(),\n-                             vec!((\"\".to_strbuf(), \"\".to_strbuf())),\n+                             vec!((\"\".to_string(), \"\".to_string())),\n                              None)\n                 .expect(format_strbuf!(\"failed to exec `{}`\", gdb_path));\n             let cmdline = {\n@@ -457,9 +457,9 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n         _=> {\n             // write debugger script\n             let script_str = [\n-                \"set charset UTF-8\".to_strbuf(),\n+                \"set charset UTF-8\".to_string(),\n                 cmds,\n-                \"quit\\n\".to_strbuf()\n+                \"quit\\n\".to_string()\n             ].connect(\"\\n\");\n             debug!(\"script_str = {}\", script_str);\n             dump_output_file(config,\n@@ -470,23 +470,23 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             // run debugger script with gdb\n             #[cfg(windows)]\n             fn debugger() -> String {\n-                \"gdb.exe\".to_strbuf()\n+                \"gdb.exe\".to_string()\n             }\n             #[cfg(unix)]\n             fn debugger() -> String {\n-                \"gdb\".to_strbuf()\n+                \"gdb\".to_string()\n             }\n \n             let debugger_script = make_out_name(config, testfile, \"debugger.script\");\n \n             // FIXME (#9639): This needs to handle non-utf8 paths\n             let debugger_opts =\n-                vec!(\"-quiet\".to_strbuf(),\n-                     \"-batch\".to_strbuf(),\n-                     \"-nx\".to_strbuf(),\n+                vec!(\"-quiet\".to_string(),\n+                     \"-batch\".to_string(),\n+                     \"-nx\".to_string(),\n                      format_strbuf!(\"-command={}\",\n                                     debugger_script.as_str().unwrap()),\n-                     exe_file.as_str().unwrap().to_strbuf());\n+                     exe_file.as_str().unwrap().to_string());\n             proc_args = ProcArgs {\n                 prog: debugger(),\n                 args: debugger_opts,\n@@ -501,7 +501,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n     }\n \n     if !debugger_run_result.status.success() {\n-        fatal(\"gdb failed to execute\".to_strbuf());\n+        fatal(\"gdb failed to execute\".to_string());\n     }\n \n     check_debugger_output(&debugger_run_result, check_lines.as_slice());\n@@ -512,7 +512,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n \n     if config.lldb_python_dir.is_none() {\n         fatal(\"Can't run LLDB test because LLDB's python path is not \\\n-               set.\".to_strbuf());\n+               set.\".to_string());\n     }\n \n     let mut config = Config {\n@@ -526,7 +526,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n     // compile test file (it shoud have 'compile-flags:-g' in the header)\n     let compile_result = compile_test(config, props, testfile);\n     if !compile_result.status.success() {\n-        fatal_ProcRes(\"compilation failed!\".to_strbuf(), &compile_result);\n+        fatal_ProcRes(\"compilation failed!\".to_string(), &compile_result);\n     }\n \n     let exe_file = make_exe_name(config, testfile);\n@@ -569,7 +569,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n     let debugger_run_result = run_lldb(config, &exe_file, &debugger_script);\n \n     if !debugger_run_result.status.success() {\n-        fatal_ProcRes(\"Error while running LLDB\".to_strbuf(),\n+        fatal_ProcRes(\"Error while running LLDB\".to_string(),\n                       &debugger_run_result);\n     }\n \n@@ -589,8 +589,8 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n                     process.wait_with_output().unwrap();\n \n                 (status,\n-                 str::from_utf8(output.as_slice()).unwrap().to_strbuf(),\n-                 str::from_utf8(error.as_slice()).unwrap().to_strbuf())\n+                 str::from_utf8(output.as_slice()).unwrap().to_string(),\n+                 str::from_utf8(error.as_slice()).unwrap().to_string())\n             },\n             Err(e) => {\n                 fatal(format_strbuf!(\"Failed to setup Python process for \\\n@@ -636,13 +636,13 @@ fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str)\n \n                 header::parse_name_value_directive(\n                         line.as_slice(),\n-                        command_directive.to_strbuf()).map(|cmd| {\n+                        command_directive.to_string()).map(|cmd| {\n                     commands.push(cmd)\n                 });\n \n                 header::parse_name_value_directive(\n                         line.as_slice(),\n-                        check_directive.to_strbuf()).map(|cmd| {\n+                        check_directive.to_string()).map(|cmd| {\n                     check_lines.push(cmd)\n                 });\n             }\n@@ -669,16 +669,16 @@ fn cleanup_debug_info_options(options: &Option<String>) -> Option<String> {\n \n     // Remove options that are either unwanted (-O) or may lead to duplicates due to RUSTFLAGS.\n     let options_to_remove = [\n-        \"-O\".to_strbuf(),\n-        \"-g\".to_strbuf(),\n-        \"--debuginfo\".to_strbuf()\n+        \"-O\".to_string(),\n+        \"-g\".to_string(),\n+        \"--debuginfo\".to_string()\n     ];\n     let new_options =\n         split_maybe_args(options).move_iter()\n                                  .filter(|x| !options_to_remove.contains(x))\n                                  .collect::<Vec<String>>()\n                                  .connect(\" \")\n-                                 .to_strbuf();\n+                                 .to_string();\n     Some(new_options)\n }\n \n@@ -692,7 +692,7 @@ fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[String])\n                 s.as_slice()\n                  .trim()\n                  .split_str(\"[...]\")\n-                 .map(|x| x.to_strbuf())\n+                 .map(|x| x.to_string())\n                  .collect()\n             }).collect();\n         // check if each line in props.check_lines appears in the\n@@ -749,7 +749,7 @@ fn check_error_patterns(props: &TestProps,\n     }\n \n     if proc_res.status.success() {\n-        fatal(\"process did not return an error status\".to_strbuf());\n+        fatal(\"process did not return an error status\".to_string());\n     }\n \n     let mut next_err_idx = 0u;\n@@ -784,15 +784,15 @@ fn check_error_patterns(props: &TestProps,\n         for pattern in missing_patterns.iter() {\n             error(format_strbuf!(\"error pattern '{}' not found!\", *pattern));\n         }\n-        fatal_ProcRes(\"multiple error patterns not found\".to_strbuf(),\n+        fatal_ProcRes(\"multiple error patterns not found\".to_string(),\n                       proc_res);\n     }\n }\n \n fn check_no_compiler_crash(proc_res: &ProcRes) {\n     for line in proc_res.stderr.as_slice().lines() {\n         if line.starts_with(\"error: internal compiler error:\") {\n-            fatal_ProcRes(\"compiler encountered internal error\".to_strbuf(),\n+            fatal_ProcRes(\"compiler encountered internal error\".to_string(),\n                           proc_res);\n         }\n     }\n@@ -807,7 +807,7 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n         expected_errors.len(), false);\n \n     if proc_res.status.success() {\n-        fatal(\"process did not return an error status\".to_strbuf());\n+        fatal(\"process did not return an error status\".to_string());\n     }\n \n     let prefixes = expected_errors.iter().map(|ee| {\n@@ -824,7 +824,7 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n                 c\n             }\n         } ).collect();\n-        str::from_chars(c.as_slice()).to_strbuf()\n+        str::from_chars(c.as_slice()).to_string()\n     }\n \n     #[cfg(target_os = \"win32\")]\n@@ -983,15 +983,15 @@ fn compile_test(config: &Config, props: &TestProps,\n }\n \n fn jit_test(config: &Config, props: &TestProps, testfile: &Path) -> ProcRes {\n-    compile_test_(config, props, testfile, [\"--jit\".to_strbuf()])\n+    compile_test_(config, props, testfile, [\"--jit\".to_string()])\n }\n \n fn compile_test_(config: &Config, props: &TestProps,\n                  testfile: &Path, extra_args: &[String]) -> ProcRes {\n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let link_args = vec!(\"-L\".to_strbuf(),\n-                         aux_dir.as_str().unwrap().to_strbuf());\n+    let link_args = vec!(\"-L\".to_string(),\n+                         aux_dir.as_str().unwrap().to_string());\n     let args = make_compile_args(config,\n                                  props,\n                                  link_args.append(extra_args),\n@@ -1034,22 +1034,22 @@ fn compose_and_run_compiler(\n \n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let extra_link_args = vec!(\"-L\".to_owned(), aux_dir.as_str().unwrap().to_owned());\n+    let extra_link_args = vec!(\"-L\".to_string(), aux_dir.as_str().unwrap().to_string());\n \n     for rel_ab in props.aux_builds.iter() {\n         let abs_ab = config.aux_base.join(rel_ab.as_slice());\n         let aux_props = header::load_props(&abs_ab);\n         let crate_type = if aux_props.no_prefer_dynamic {\n             Vec::new()\n         } else {\n-            vec!(\"--crate-type=dylib\".to_strbuf())\n+            vec!(\"--crate-type=dylib\".to_string())\n         };\n         let aux_args =\n             make_compile_args(config,\n                               &aux_props,\n                               crate_type.append(\n                                   extra_link_args.iter()\n-                                                 .map(|x| x.to_strbuf())\n+                                                 .map(|x| x.to_string())\n                                                  .collect::<Vec<_>>()\n                                                  .as_slice()),\n                               |a,b| {\n@@ -1118,34 +1118,34 @@ fn make_compile_args(config: &Config,\n         config.target.as_slice()\n     };\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let mut args = vec!(testfile.as_str().unwrap().to_strbuf(),\n-                        \"-L\".to_strbuf(),\n-                        config.build_base.as_str().unwrap().to_strbuf(),\n+    let mut args = vec!(testfile.as_str().unwrap().to_string(),\n+                        \"-L\".to_string(),\n+                        config.build_base.as_str().unwrap().to_string(),\n                         format_strbuf!(\"--target={}\", target));\n     args.push_all(extras.as_slice());\n     if !props.no_prefer_dynamic {\n-        args.push(\"-C\".to_strbuf());\n-        args.push(\"prefer-dynamic\".to_strbuf());\n+        args.push(\"-C\".to_string());\n+        args.push(\"prefer-dynamic\".to_string());\n     }\n     let path = match xform_file {\n         ThisFile(path) => {\n-            args.push(\"-o\".to_strbuf());\n+            args.push(\"-o\".to_string());\n             path\n         }\n         ThisDirectory(path) => {\n-            args.push(\"--out-dir\".to_strbuf());\n+            args.push(\"--out-dir\".to_string());\n             path\n         }\n     };\n-    args.push(path.as_str().unwrap().to_strbuf());\n+    args.push(path.as_str().unwrap().to_string());\n     if props.force_host {\n         args.push_all_move(split_maybe_args(&config.host_rustcflags));\n     } else {\n         args.push_all_move(split_maybe_args(&config.target_rustcflags));\n     }\n     args.push_all_move(split_maybe_args(&props.compile_flags));\n     return ProcArgs {\n-        prog: config.rustc_path.as_str().unwrap().to_strbuf(),\n+        prog: config.rustc_path.as_str().unwrap().to_string(),\n         args: args,\n     };\n }\n@@ -1176,7 +1176,7 @@ fn make_run_args(config: &Config, props: &TestProps, testfile: &Path) ->\n     let exe_file = make_exe_name(config, testfile);\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    args.push(exe_file.as_str().unwrap().to_strbuf());\n+    args.push(exe_file.as_str().unwrap().to_string());\n \n     // Add the arguments in the run_flags directive\n     args.push_all_move(split_maybe_args(&props.run_flags));\n@@ -1197,7 +1197,7 @@ fn split_maybe_args(argstr: &Option<String>) -> Vec<String> {\n                  if s.is_whitespace() {\n                      None\n                  } else {\n-                     Some(s.to_strbuf())\n+                     Some(s.to_string())\n                  }\n              }).collect()\n         }\n@@ -1342,20 +1342,20 @@ fn _arm_exec_compiled_test(config: &Config,\n     let mut tvec: Vec<String> = args.prog\n                                     .as_slice()\n                                     .split('/')\n-                                    .map(|ts| ts.to_strbuf())\n+                                    .map(|ts| ts.to_string())\n                                     .collect();\n     let prog_short = tvec.pop().unwrap();\n \n     // copy to target\n     let copy_result = procsrv::run(\"\",\n                                    config.adb_path.as_slice(),\n                                    [\n-                                    \"push\".to_strbuf(),\n+                                    \"push\".to_string(),\n                                     args.prog.clone(),\n                                     config.adb_test_dir.clone()\n                                    ],\n-                                   vec!((\"\".to_strbuf(), \"\".to_strbuf())),\n-                                   Some(\"\".to_strbuf()))\n+                                   vec!((\"\".to_string(), \"\".to_string())),\n+                                   Some(\"\".to_string()))\n         .expect(format_strbuf!(\"failed to exec `{}`\", config.adb_path));\n \n     if config.verbose {\n@@ -1371,7 +1371,7 @@ fn _arm_exec_compiled_test(config: &Config,\n     let mut runargs = Vec::new();\n \n     // run test via adb_run_wrapper\n-    runargs.push(\"shell\".to_strbuf());\n+    runargs.push(\"shell\".to_string());\n     for (key, val) in env.move_iter() {\n         runargs.push(format_strbuf!(\"{}={}\", key, val));\n     }\n@@ -1381,18 +1381,18 @@ fn _arm_exec_compiled_test(config: &Config,\n     runargs.push(format_strbuf!(\"{}\", prog_short));\n \n     for tv in args.args.iter() {\n-        runargs.push(tv.to_strbuf());\n+        runargs.push(tv.to_string());\n     }\n     procsrv::run(\"\",\n                  config.adb_path.as_slice(),\n                  runargs.as_slice(),\n-                 vec!((\"\".to_strbuf(), \"\".to_strbuf())), Some(\"\".to_strbuf()))\n+                 vec!((\"\".to_string(), \"\".to_string())), Some(\"\".to_string()))\n         .expect(format_strbuf!(\"failed to exec `{}`\", config.adb_path));\n \n     // get exitcode of result\n     runargs = Vec::new();\n-    runargs.push(\"shell\".to_strbuf());\n-    runargs.push(\"cat\".to_strbuf());\n+    runargs.push(\"shell\".to_string());\n+    runargs.push(\"cat\".to_string());\n     runargs.push(format_strbuf!(\"{}/{}.exitcode\",\n                                 config.adb_test_dir,\n                                 prog_short));\n@@ -1401,8 +1401,8 @@ fn _arm_exec_compiled_test(config: &Config,\n         procsrv::run(\"\",\n                      config.adb_path.as_slice(),\n                      runargs.as_slice(),\n-                     vec!((\"\".to_strbuf(), \"\".to_strbuf())),\n-                     Some(\"\".to_strbuf()))\n+                     vec!((\"\".to_string(), \"\".to_string())),\n+                     Some(\"\".to_string()))\n         .expect(format_strbuf!(\"failed to exec `{}`\", config.adb_path));\n \n     let mut exitcode: int = 0;\n@@ -1416,8 +1416,8 @@ fn _arm_exec_compiled_test(config: &Config,\n \n     // get stdout of result\n     runargs = Vec::new();\n-    runargs.push(\"shell\".to_strbuf());\n-    runargs.push(\"cat\".to_strbuf());\n+    runargs.push(\"shell\".to_string());\n+    runargs.push(\"cat\".to_string());\n     runargs.push(format_strbuf!(\"{}/{}.stdout\",\n                                 config.adb_test_dir,\n                                 prog_short));\n@@ -1426,14 +1426,14 @@ fn _arm_exec_compiled_test(config: &Config,\n         procsrv::run(\"\",\n                      config.adb_path.as_slice(),\n                      runargs.as_slice(),\n-                     vec!((\"\".to_strbuf(), \"\".to_strbuf())),\n-                     Some(\"\".to_strbuf()))\n+                     vec!((\"\".to_string(), \"\".to_string())),\n+                     Some(\"\".to_string()))\n         .expect(format_strbuf!(\"failed to exec `{}`\", config.adb_path));\n \n     // get stderr of result\n     runargs = Vec::new();\n-    runargs.push(\"shell\".to_strbuf());\n-    runargs.push(\"cat\".to_strbuf());\n+    runargs.push(\"shell\".to_string());\n+    runargs.push(\"cat\".to_string());\n     runargs.push(format_strbuf!(\"{}/{}.stderr\",\n                                 config.adb_test_dir,\n                                 prog_short));\n@@ -1442,8 +1442,8 @@ fn _arm_exec_compiled_test(config: &Config,\n         procsrv::run(\"\",\n                      config.adb_path.as_slice(),\n                      runargs.as_slice(),\n-                     vec!((\"\".to_strbuf(), \"\".to_strbuf())),\n-                     Some(\"\".to_strbuf()))\n+                     vec!((\"\".to_string(), \"\".to_string())),\n+                     Some(\"\".to_string()))\n         .expect(format_strbuf!(\"failed to exec `{}`\", config.adb_path));\n \n     dump_output(config,\n@@ -1469,15 +1469,15 @@ fn _arm_push_aux_shared_library(config: &Config, testfile: &Path) {\n             let copy_result = procsrv::run(\"\",\n                                            config.adb_path.as_slice(),\n                                            [\n-                                            \"push\".to_strbuf(),\n+                                            \"push\".to_string(),\n                                             file.as_str()\n                                                 .unwrap()\n-                                                .to_strbuf(),\n-                                            config.adb_test_dir.to_strbuf()\n+                                                .to_string(),\n+                                            config.adb_test_dir.to_string()\n                                            ],\n-                                           vec!((\"\".to_strbuf(),\n-                                                 \"\".to_strbuf())),\n-                                           Some(\"\".to_strbuf()))\n+                                           vec!((\"\".to_string(),\n+                                                 \"\".to_string())),\n+                                           Some(\"\".to_string()))\n                 .expect(format_strbuf!(\"failed to exec `{}`\",\n                                        config.adb_path));\n \n@@ -1509,12 +1509,12 @@ fn compile_test_and_save_bitcode(config: &Config, props: &TestProps,\n                                  testfile: &Path) -> ProcRes {\n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let link_args = vec!(\"-L\".to_strbuf(),\n-                         aux_dir.as_str().unwrap().to_strbuf());\n-    let llvm_args = vec!(\"--emit=obj\".to_strbuf(),\n-                         \"--crate-type=lib\".to_strbuf(),\n-                         \"-C\".to_strbuf(),\n-                         \"save-temps\".to_strbuf());\n+    let link_args = vec!(\"-L\".to_string(),\n+                         aux_dir.as_str().unwrap().to_string());\n+    let llvm_args = vec!(\"--emit=obj\".to_string(),\n+                         \"--crate-type=lib\".to_string(),\n+                         \"-C\".to_string(),\n+                         \"save-temps\".to_string());\n     let args = make_compile_args(config,\n                                  props,\n                                  link_args.append(llvm_args.as_slice()),\n@@ -1529,12 +1529,12 @@ fn compile_cc_with_clang_and_save_bitcode(config: &Config, _props: &TestProps,\n     let testcc = testfile.with_extension(\"cc\");\n     let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        prog: config.clang_path.get_ref().as_str().unwrap().to_strbuf(),\n-        args: vec!(\"-c\".to_strbuf(),\n-                   \"-emit-llvm\".to_strbuf(),\n-                   \"-o\".to_strbuf(),\n-                   bitcodefile.as_str().unwrap().to_strbuf(),\n-                   testcc.as_str().unwrap().to_strbuf())\n+        prog: config.clang_path.get_ref().as_str().unwrap().to_string(),\n+        args: vec!(\"-c\".to_string(),\n+                   \"-emit-llvm\".to_string(),\n+                   \"-o\".to_string(),\n+                   bitcodefile.as_str().unwrap().to_string(),\n+                   testcc.as_str().unwrap().to_string())\n     };\n     compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None)\n }\n@@ -1548,10 +1548,10 @@ fn extract_function_from_bitcode(config: &Config, _props: &TestProps,\n     let prog = config.llvm_bin_path.get_ref().join(\"llvm-extract\");\n     let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        prog: prog.as_str().unwrap().to_strbuf(),\n+        prog: prog.as_str().unwrap().to_string(),\n         args: vec!(format_strbuf!(\"-func={}\", fname),\n                    format_strbuf!(\"-o={}\", extracted_bc.as_str().unwrap()),\n-                   bitcodefile.as_str().unwrap().to_strbuf())\n+                   bitcodefile.as_str().unwrap().to_string())\n     };\n     compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None)\n }\n@@ -1565,9 +1565,9 @@ fn disassemble_extract(config: &Config, _props: &TestProps,\n     let prog = config.llvm_bin_path.get_ref().join(\"llvm-dis\");\n     let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        prog: prog.as_str().unwrap().to_strbuf(),\n+        prog: prog.as_str().unwrap().to_string(),\n         args: vec!(format_strbuf!(\"-o={}\", extracted_ll.as_str().unwrap()),\n-                   extracted_bc.as_str().unwrap().to_strbuf())\n+                   extracted_bc.as_str().unwrap().to_string())\n     };\n     compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None)\n }\n@@ -1584,44 +1584,44 @@ fn run_codegen_test(config: &Config, props: &TestProps,\n                     testfile: &Path, mm: &mut MetricMap) {\n \n     if config.llvm_bin_path.is_none() {\n-        fatal(\"missing --llvm-bin-path\".to_strbuf());\n+        fatal(\"missing --llvm-bin-path\".to_string());\n     }\n \n     if config.clang_path.is_none() {\n-        fatal(\"missing --clang-path\".to_strbuf());\n+        fatal(\"missing --clang-path\".to_string());\n     }\n \n     let mut proc_res = compile_test_and_save_bitcode(config, props, testfile);\n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"compilation failed!\".to_strbuf(), &proc_res);\n+        fatal_ProcRes(\"compilation failed!\".to_string(), &proc_res);\n     }\n \n     proc_res = extract_function_from_bitcode(config, props, \"test\", testfile, \"\");\n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"extracting 'test' function failed\".to_strbuf(),\n+        fatal_ProcRes(\"extracting 'test' function failed\".to_string(),\n                       &proc_res);\n     }\n \n     proc_res = disassemble_extract(config, props, testfile, \"\");\n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"disassembling extract failed\".to_strbuf(), &proc_res);\n+        fatal_ProcRes(\"disassembling extract failed\".to_string(), &proc_res);\n     }\n \n \n     let mut proc_res = compile_cc_with_clang_and_save_bitcode(config, props, testfile);\n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"compilation failed!\".to_strbuf(), &proc_res);\n+        fatal_ProcRes(\"compilation failed!\".to_string(), &proc_res);\n     }\n \n     proc_res = extract_function_from_bitcode(config, props, \"test\", testfile, \"clang\");\n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"extracting 'test' function failed\".to_strbuf(),\n+        fatal_ProcRes(\"extracting 'test' function failed\".to_string(),\n                       &proc_res);\n     }\n \n     proc_res = disassemble_extract(config, props, testfile, \"clang\");\n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"disassembling extract failed\".to_strbuf(), &proc_res);\n+        fatal_ProcRes(\"disassembling extract failed\".to_string(), &proc_res);\n     }\n \n     let base = output_base_name(config, testfile);"}, {"sha": "8f1d5cceb2b995ea0ee3432b3dfc9a2738bde8bd", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -41,15 +41,15 @@ pub fn make_new_path(path: &str) -> String {\n       Some(curr) => {\n         format_strbuf!(\"{}{}{}\", path, path_div(), curr)\n       }\n-      None => path.to_str().to_strbuf()\n+      None => path.to_str().to_string()\n     }\n }\n \n #[cfg(target_os = \"win32\")]\n-pub fn lib_path_env_var() -> String { \"PATH\".to_strbuf() }\n+pub fn lib_path_env_var() -> String { \"PATH\".to_string() }\n \n #[cfg(target_os = \"win32\")]\n-pub fn path_div() -> String { \";\".to_strbuf() }\n+pub fn path_div() -> String { \";\".to_string() }\n \n pub fn logv(config: &Config, s: String) {\n     debug!(\"{}\", s);"}, {"sha": "759518b6769174a22670aff1e7e08d09af214e96", "filename": "src/doc/complement-cheatsheet.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fdoc%2Fcomplement-cheatsheet.md", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fdoc%2Fcomplement-cheatsheet.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-cheatsheet.md?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -8,7 +8,7 @@ Use [`ToStr`](../std/to_str/trait.ToStr.html).\n \n ~~~\n let x: int = 42;\n-let y: String = x.to_str().to_strbuf();\n+let y: String = x.to_str().to_string();\n ~~~\n \n **String to int**\n@@ -65,7 +65,7 @@ To return an Owned String use the str helper function\n use std::str;\n \n let x: Option<String> =\n-    str::from_utf8([ 104u8, 105u8 ]).map(|x| x.to_strbuf());\n+    str::from_utf8([ 104u8, 105u8 ]).map(|x| x.to_string());\n let y: String = x.unwrap();\n ~~~\n \n@@ -211,13 +211,13 @@ fn open(Door(name): Door<Closed>) -> Door<Open> {\n     Door::<Open>(name)\n }\n \n-let _ = close(Door::<Open>(\"front\".to_strbuf()));\n+let _ = close(Door::<Open>(\"front\".to_string()));\n ~~~\n \n Attempting to close a closed door is prevented statically:\n \n ~~~ {.ignore}\n-let _ = close(Door::<Closed>(\"front\".to_strbuf())); // error: mismatched types: expected `main::Door<main::Open>` but found `main::Door<main::Closed>`\n+let _ = close(Door::<Closed>(\"front\".to_string())); // error: mismatched types: expected `main::Door<main::Open>` but found `main::Door<main::Closed>`\n ~~~\n \n # FFI (Foreign Function Interface)"}, {"sha": "f6b7946c86c68089a06e2c7b003c09924d43ee1a", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -467,7 +467,7 @@ fn stringifier(channel: &sync::DuplexStream<String, uint>) {\n     let mut value: uint;\n     loop {\n         value = channel.recv();\n-        channel.send(value.to_str().to_strbuf());\n+        channel.send(value.to_str().to_string());\n         if value == 0 { break; }\n     }\n }\n@@ -492,7 +492,7 @@ extern crate sync;\n #     let mut value: uint;\n #     loop {\n #         value = channel.recv();\n-#         channel.send(value.to_str().to_strbuf());\n+#         channel.send(value.to_str().to_string());\n #         if value == 0u { break; }\n #     }\n # }"}, {"sha": "4ea17e735dfcd4a4954108b8c6e4a76301062c2c", "filename": "src/doc/rust.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -1264,8 +1264,8 @@ enum Animal {\n     Cat { name: String, weight: f64 }\n }\n \n-let mut a: Animal = Dog(\"Cocoa\".to_strbuf(), 37.2);\n-a = Cat { name: \"Spotty\".to_strbuf(), weight: 2.7 };\n+let mut a: Animal = Dog(\"Cocoa\".to_string(), 37.2);\n+a = Cat { name: \"Spotty\".to_string(), weight: 2.7 };\n ~~~~\n \n In this example, `Cat` is a _struct-like enum variant_,\n@@ -3538,7 +3538,7 @@ allocated on the heap (unlike closures). An example of creating and calling a\n procedure:\n \n ```rust\n-let string = \"Hello\".to_owned();\n+let string = \"Hello\".to_string();\n \n // Creates a new procedure, passing it to the `spawn` function.\n spawn(proc() {\n@@ -3578,7 +3578,7 @@ trait Printable {\n }\n \n impl Printable for int {\n-  fn to_string(&self) -> String { self.to_str().to_strbuf() }\n+  fn to_string(&self) -> String { self.to_str().to_string() }\n }\n \n fn print(a: Box<Printable>) {"}, {"sha": "2a59e3a756acc2b205423758c36c84082aa16c73", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -2236,7 +2236,7 @@ impl Printable for String {\n }\n \n # 1.print();\n-# (\"foo\".to_strbuf()).print();\n+# (\"foo\".to_string()).print();\n ~~~~\n \n Methods defined in an impl for a trait may be called just like\n@@ -2286,7 +2286,7 @@ impl Printable for bool {}\n impl Printable for f32 {}\n \n # 1.print();\n-# (\"foo\".to_strbuf()).print();\n+# (\"foo\".to_string()).print();\n # true.print();\n # 3.14159.print();\n ~~~~"}, {"sha": "58d8bf289e173bcc4fc996f1b0c9bc512c492d60", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -547,7 +547,7 @@ mod tests {\n         let arena = TypedArena::new();\n         for _ in range(0, 100000) {\n             arena.alloc(Noncopy {\n-                string: \"hello world\".to_strbuf(),\n+                string: \"hello world\".to_string(),\n                 array: vec!( 1, 2, 3, 4, 5 ),\n             });\n         }\n@@ -558,7 +558,7 @@ mod tests {\n         let arena = TypedArena::new();\n         b.iter(|| {\n             arena.alloc(Noncopy {\n-                string: \"hello world\".to_strbuf(),\n+                string: \"hello world\".to_string(),\n                 array: vec!( 1, 2, 3, 4, 5 ),\n             })\n         })\n@@ -568,7 +568,7 @@ mod tests {\n     pub fn bench_noncopy_nonarena(b: &mut Bencher) {\n         b.iter(|| {\n             box Noncopy {\n-                string: \"hello world\".to_strbuf(),\n+                string: \"hello world\".to_string(),\n                 array: vec!( 1, 2, 3, 4, 5 ),\n             }\n         })\n@@ -579,7 +579,7 @@ mod tests {\n         let arena = Arena::new();\n         b.iter(|| {\n             arena.alloc(|| Noncopy {\n-                string: \"hello world\".to_strbuf(),\n+                string: \"hello world\".to_string(),\n                 array: vec!( 1, 2, 3, 4, 5 ),\n             })\n         })"}, {"sha": "0b5d499c533bc37d7bac5da57568bde590690000", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -988,10 +988,10 @@ mod tests {\n     #[test]\n     fn test_to_str() {\n         let zerolen = Bitv::new(0u, false);\n-        assert_eq!(zerolen.to_str(), \"\".to_owned());\n+        assert_eq!(zerolen.to_str(), \"\".to_string());\n \n         let eightbits = Bitv::new(8u, false);\n-        assert_eq!(eightbits.to_str(), \"00000000\".to_owned());\n+        assert_eq!(eightbits.to_str(), \"00000000\".to_string());\n     }\n \n     #[test]\n@@ -1014,7 +1014,7 @@ mod tests {\n         let mut b = bitv::Bitv::new(2, false);\n         b.set(0, true);\n         b.set(1, false);\n-        assert_eq!(b.to_str(), \"10\".to_owned());\n+        assert_eq!(b.to_str(), \"10\".to_string());\n     }\n \n     #[test]\n@@ -1343,7 +1343,7 @@ mod tests {\n     #[test]\n     fn test_from_bools() {\n         assert!(from_bools([true, false, true, true]).to_str() ==\n-            \"1011\".to_owned());\n+            \"1011\".to_string());\n     }\n \n     #[test]"}, {"sha": "184a59303f3a4c2e5fa7ee375f7c10afe81b9ac7", "filename": "src/libcollections/btree.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibcollections%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibcollections%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -778,81 +778,81 @@ mod test_btree {\n     //Tests the functionality of the insert methods (which are unfinished).\n     #[test]\n     fn insert_test_one() {\n-        let b = BTree::new(1, \"abc\".to_owned(), 2);\n-        let is_insert = b.insert(2, \"xyz\".to_owned());\n+        let b = BTree::new(1, \"abc\".to_string(), 2);\n+        let is_insert = b.insert(2, \"xyz\".to_string());\n         //println!(\"{}\", is_insert.clone().to_str());\n         assert!(is_insert.root.is_leaf());\n     }\n \n     #[test]\n     fn insert_test_two() {\n-        let leaf_elt_1 = LeafElt::new(1, \"aaa\".to_owned());\n-        let leaf_elt_2 = LeafElt::new(2, \"bbb\".to_owned());\n-        let leaf_elt_3 = LeafElt::new(3, \"ccc\".to_owned());\n+        let leaf_elt_1 = LeafElt::new(1, \"aaa\".to_string());\n+        let leaf_elt_2 = LeafElt::new(2, \"bbb\".to_string());\n+        let leaf_elt_3 = LeafElt::new(3, \"ccc\".to_string());\n         let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3));\n         let b = BTree::new_with_node_len(n, 3, 2);\n-        //println!(\"{}\", b.clone().insert(4, \"ddd\".to_owned()).to_str());\n-        assert!(b.insert(4, \"ddd\".to_owned()).root.is_leaf());\n+        //println!(\"{}\", b.clone().insert(4, \"ddd\".to_string()).to_str());\n+        assert!(b.insert(4, \"ddd\".to_string()).root.is_leaf());\n     }\n \n     #[test]\n     fn insert_test_three() {\n-        let leaf_elt_1 = LeafElt::new(1, \"aaa\".to_owned());\n-        let leaf_elt_2 = LeafElt::new(2, \"bbb\".to_owned());\n-        let leaf_elt_3 = LeafElt::new(3, \"ccc\".to_owned());\n-        let leaf_elt_4 = LeafElt::new(4, \"ddd\".to_owned());\n+        let leaf_elt_1 = LeafElt::new(1, \"aaa\".to_string());\n+        let leaf_elt_2 = LeafElt::new(2, \"bbb\".to_string());\n+        let leaf_elt_3 = LeafElt::new(3, \"ccc\".to_string());\n+        let leaf_elt_4 = LeafElt::new(4, \"ddd\".to_string());\n         let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4));\n         let b = BTree::new_with_node_len(n, 3, 2);\n-        //println!(\"{}\", b.clone().insert(5, \"eee\".to_owned()).to_str());\n-        assert!(!b.insert(5, \"eee\".to_owned()).root.is_leaf());\n+        //println!(\"{}\", b.clone().insert(5, \"eee\".to_string()).to_str());\n+        assert!(!b.insert(5, \"eee\".to_string()).root.is_leaf());\n     }\n \n     #[test]\n     fn insert_test_four() {\n-        let leaf_elt_1 = LeafElt::new(1, \"aaa\".to_owned());\n-        let leaf_elt_2 = LeafElt::new(2, \"bbb\".to_owned());\n-        let leaf_elt_3 = LeafElt::new(3, \"ccc\".to_owned());\n-        let leaf_elt_4 = LeafElt::new(4, \"ddd\".to_owned());\n+        let leaf_elt_1 = LeafElt::new(1, \"aaa\".to_string());\n+        let leaf_elt_2 = LeafElt::new(2, \"bbb\".to_string());\n+        let leaf_elt_3 = LeafElt::new(3, \"ccc\".to_string());\n+        let leaf_elt_4 = LeafElt::new(4, \"ddd\".to_string());\n         let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4));\n         let mut b = BTree::new_with_node_len(n, 3, 2);\n-        b = b.clone().insert(5, \"eee\".to_owned());\n-        b = b.clone().insert(6, \"fff\".to_owned());\n-        b = b.clone().insert(7, \"ggg\".to_owned());\n-        b = b.clone().insert(8, \"hhh\".to_owned());\n-        b = b.clone().insert(0, \"omg\".to_owned());\n+        b = b.clone().insert(5, \"eee\".to_string());\n+        b = b.clone().insert(6, \"fff\".to_string());\n+        b = b.clone().insert(7, \"ggg\".to_string());\n+        b = b.clone().insert(8, \"hhh\".to_string());\n+        b = b.clone().insert(0, \"omg\".to_string());\n         //println!(\"{}\", b.clone().to_str());\n         assert!(!b.root.is_leaf());\n     }\n \n     #[test]\n     fn bsearch_test_one() {\n-        let b = BTree::new(1, \"abc\".to_owned(), 2);\n+        let b = BTree::new(1, \"abc\".to_string(), 2);\n         assert_eq!(Some(1), b.root.bsearch_node(2));\n     }\n \n     #[test]\n     fn bsearch_test_two() {\n-        let b = BTree::new(1, \"abc\".to_owned(), 2);\n+        let b = BTree::new(1, \"abc\".to_string(), 2);\n         assert_eq!(Some(0), b.root.bsearch_node(0));\n     }\n \n     #[test]\n     fn bsearch_test_three() {\n-        let leaf_elt_1 = LeafElt::new(1, \"aaa\".to_owned());\n-        let leaf_elt_2 = LeafElt::new(2, \"bbb\".to_owned());\n-        let leaf_elt_3 = LeafElt::new(4, \"ccc\".to_owned());\n-        let leaf_elt_4 = LeafElt::new(5, \"ddd\".to_owned());\n+        let leaf_elt_1 = LeafElt::new(1, \"aaa\".to_string());\n+        let leaf_elt_2 = LeafElt::new(2, \"bbb\".to_string());\n+        let leaf_elt_3 = LeafElt::new(4, \"ccc\".to_string());\n+        let leaf_elt_4 = LeafElt::new(5, \"ddd\".to_string());\n         let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4));\n         let b = BTree::new_with_node_len(n, 3, 2);\n         assert_eq!(Some(2), b.root.bsearch_node(3));\n     }\n \n     #[test]\n     fn bsearch_test_four() {\n-        let leaf_elt_1 = LeafElt::new(1, \"aaa\".to_owned());\n-        let leaf_elt_2 = LeafElt::new(2, \"bbb\".to_owned());\n-        let leaf_elt_3 = LeafElt::new(4, \"ccc\".to_owned());\n-        let leaf_elt_4 = LeafElt::new(5, \"ddd\".to_owned());\n+        let leaf_elt_1 = LeafElt::new(1, \"aaa\".to_string());\n+        let leaf_elt_2 = LeafElt::new(2, \"bbb\".to_string());\n+        let leaf_elt_3 = LeafElt::new(4, \"ccc\".to_string());\n+        let leaf_elt_4 = LeafElt::new(5, \"ddd\".to_string());\n         let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4));\n         let b = BTree::new_with_node_len(n, 3, 2);\n         assert_eq!(Some(4), b.root.bsearch_node(800));\n@@ -861,48 +861,48 @@ mod test_btree {\n     //Tests the functionality of the get method.\n     #[test]\n     fn get_test() {\n-        let b = BTree::new(1, \"abc\".to_owned(), 2);\n+        let b = BTree::new(1, \"abc\".to_string(), 2);\n         let val = b.get(1);\n-        assert_eq!(val, Some(\"abc\".to_owned()));\n+        assert_eq!(val, Some(\"abc\".to_string()));\n     }\n \n     //Tests the BTree's clone() method.\n     #[test]\n     fn btree_clone_test() {\n-        let b = BTree::new(1, \"abc\".to_owned(), 2);\n+        let b = BTree::new(1, \"abc\".to_string(), 2);\n         let b2 = b.clone();\n         assert!(b.root == b2.root)\n     }\n \n     //Tests the BTree's cmp() method when one node is \"less than\" another.\n     #[test]\n     fn btree_cmp_test_less() {\n-        let b = BTree::new(1, \"abc\".to_owned(), 2);\n-        let b2 = BTree::new(2, \"bcd\".to_owned(), 2);\n+        let b = BTree::new(1, \"abc\".to_string(), 2);\n+        let b2 = BTree::new(2, \"bcd\".to_string(), 2);\n         assert!(&b.cmp(&b2) == &Less)\n     }\n \n     //Tests the BTree's cmp() method when two nodes are equal.\n     #[test]\n     fn btree_cmp_test_eq() {\n-        let b = BTree::new(1, \"abc\".to_owned(), 2);\n-        let b2 = BTree::new(1, \"bcd\".to_owned(), 2);\n+        let b = BTree::new(1, \"abc\".to_string(), 2);\n+        let b2 = BTree::new(1, \"bcd\".to_string(), 2);\n         assert!(&b.cmp(&b2) == &Equal)\n     }\n \n     //Tests the BTree's cmp() method when one node is \"greater than\" another.\n     #[test]\n     fn btree_cmp_test_greater() {\n-        let b = BTree::new(1, \"abc\".to_owned(), 2);\n-        let b2 = BTree::new(2, \"bcd\".to_owned(), 2);\n+        let b = BTree::new(1, \"abc\".to_string(), 2);\n+        let b2 = BTree::new(2, \"bcd\".to_string(), 2);\n         assert!(&b2.cmp(&b) == &Greater)\n     }\n \n     //Tests the BTree's to_str() method.\n     #[test]\n     fn btree_tostr_test() {\n-        let b = BTree::new(1, \"abc\".to_owned(), 2);\n-        assert_eq!(b.to_str(), \"Key: 1, value: abc;\".to_owned())\n+        let b = BTree::new(1, \"abc\".to_string(), 2);\n+        assert_eq!(b.to_str(), \"Key: 1, value: abc;\".to_string())\n     }\n \n }"}, {"sha": "42b57a1ea40632844dac9c1fbea763bb3de72e1a", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -2040,9 +2040,9 @@ mod test_map {\n         let mut m = HashMap::new();\n \n         let (foo, bar, baz) = (1,2,3);\n-        m.insert(\"foo\".to_owned(), foo);\n-        m.insert(\"bar\".to_owned(), bar);\n-        m.insert(\"baz\".to_owned(), baz);\n+        m.insert(\"foo\".to_string(), foo);\n+        m.insert(\"bar\".to_string(), bar);\n+        m.insert(\"baz\".to_string(), baz);\n \n \n         assert_eq!(m.find_equiv(&(\"foo\")), Some(&foo));\n@@ -2327,8 +2327,8 @@ mod test_set {\n \n         let set_str = format!(\"{}\", set);\n \n-        assert!(set_str == \"{1, 2}\".to_owned() || set_str == \"{2, 1}\".to_owned());\n-        assert_eq!(format!(\"{}\", empty), \"{}\".to_owned());\n+        assert!(set_str == \"{1, 2}\".to_string() || set_str == \"{2, 1}\".to_string());\n+        assert_eq!(format!(\"{}\", empty), \"{}\".to_string());\n     }\n }\n "}, {"sha": "7db3525a36eceb9ec5735f9eb5ff2684089aa623", "filename": "src/libcollections/lru_cache.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flru_cache.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -271,22 +271,22 @@ mod tests {\n     #[test]\n     fn test_put_update() {\n         let mut cache: LruCache<String, Vec<u8>> = LruCache::new(1);\n-        cache.put(\"1\".to_strbuf(), vec![10, 10]);\n-        cache.put(\"1\".to_strbuf(), vec![10, 19]);\n-        assert_opt_eq(cache.get(&\"1\".to_strbuf()), vec![10, 19]);\n+        cache.put(\"1\".to_string(), vec![10, 10]);\n+        cache.put(\"1\".to_string(), vec![10, 19]);\n+        assert_opt_eq(cache.get(&\"1\".to_string()), vec![10, 19]);\n         assert_eq!(cache.len(), 1);\n     }\n \n     #[test]\n     fn test_expire_lru() {\n         let mut cache: LruCache<String, String> = LruCache::new(2);\n-        cache.put(\"foo1\".to_strbuf(), \"bar1\".to_strbuf());\n-        cache.put(\"foo2\".to_strbuf(), \"bar2\".to_strbuf());\n-        cache.put(\"foo3\".to_strbuf(), \"bar3\".to_strbuf());\n-        assert!(cache.get(&\"foo1\".to_strbuf()).is_none());\n-        cache.put(\"foo2\".to_strbuf(), \"bar2update\".to_strbuf());\n-        cache.put(\"foo4\".to_strbuf(), \"bar4\".to_strbuf());\n-        assert!(cache.get(&\"foo3\".to_strbuf()).is_none());\n+        cache.put(\"foo1\".to_string(), \"bar1\".to_string());\n+        cache.put(\"foo2\".to_string(), \"bar2\".to_string());\n+        cache.put(\"foo3\".to_string(), \"bar3\".to_string());\n+        assert!(cache.get(&\"foo1\".to_string()).is_none());\n+        cache.put(\"foo2\".to_string(), \"bar2update\".to_string());\n+        cache.put(\"foo4\".to_string(), \"bar4\".to_string());\n+        assert!(cache.get(&\"foo3\".to_string()).is_none());\n     }\n \n     #[test]\n@@ -319,15 +319,15 @@ mod tests {\n         cache.put(1, 10);\n         cache.put(2, 20);\n         cache.put(3, 30);\n-        assert_eq!(cache.to_str(), \"{3: 30, 2: 20, 1: 10}\".to_owned());\n+        assert_eq!(cache.to_str(), \"{3: 30, 2: 20, 1: 10}\".to_string());\n         cache.put(2, 22);\n-        assert_eq!(cache.to_str(), \"{2: 22, 3: 30, 1: 10}\".to_owned());\n+        assert_eq!(cache.to_str(), \"{2: 22, 3: 30, 1: 10}\".to_string());\n         cache.put(6, 60);\n-        assert_eq!(cache.to_str(), \"{6: 60, 2: 22, 3: 30}\".to_owned());\n+        assert_eq!(cache.to_str(), \"{6: 60, 2: 22, 3: 30}\".to_string());\n         cache.get(&3);\n-        assert_eq!(cache.to_str(), \"{3: 30, 6: 60, 2: 22}\".to_owned());\n+        assert_eq!(cache.to_str(), \"{3: 30, 6: 60, 2: 22}\".to_string());\n         cache.change_capacity(2);\n-        assert_eq!(cache.to_str(), \"{3: 30, 6: 60}\".to_owned());\n+        assert_eq!(cache.to_str(), \"{3: 30, 6: 60}\".to_string());\n     }\n \n     #[test]\n@@ -338,6 +338,6 @@ mod tests {\n         cache.clear();\n         assert!(cache.get(&1).is_none());\n         assert!(cache.get(&2).is_none());\n-        assert_eq!(cache.to_str(), \"{}\".to_owned());\n+        assert_eq!(cache.to_str(), \"{}\".to_string());\n     }\n }"}, {"sha": "731911185ff7e4e0b382cb2c5e0772977507e99f", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -140,7 +140,7 @@ pub struct RadixFmt<T, R>(T, R);\n ///\n /// ~~~\n /// use std::fmt::radix;\n-/// assert_eq!(format!(\"{}\", radix(55, 36)), \"1j\".to_owned());\n+/// assert_eq!(format!(\"{}\", radix(55, 36)), \"1j\".to_string());\n /// ~~~\n pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> {\n     RadixFmt(x, Radix::new(base))"}, {"sha": "6135f4dcca4211a2290afb2e5080a9d7e1a97f2e", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -552,7 +552,7 @@ mod tests {\n \n     #[test]\n     fn test_replace() {\n-        let mut x = Some(\"test\".to_owned());\n+        let mut x = Some(\"test\".to_string());\n         let y = replace(&mut x, None);\n         assert!(x.is_none());\n         assert!(y.is_some());\n@@ -576,7 +576,7 @@ mod tests {\n         }\n \n         unsafe {\n-            assert!(Vec::from_slice([76u8]) == transmute(\"L\".to_owned()));\n+            assert!(Vec::from_slice([76u8]) == transmute(\"L\".to_string()));\n         }\n     }\n }"}, {"sha": "975736cb40cef3164022ac1e98c245d4b7768a12", "filename": "src/libcore/option.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -194,7 +194,7 @@ impl<T> Option<T> {\n     /// to the value inside the original.\n     ///\n     /// ```\n-    /// let num_as_str: Option<String> = Some(\"10\".to_strbuf());\n+    /// let num_as_str: Option<String> = Some(\"10\".to_string());\n     /// // First, cast `Option<String>` to `Option<&String>` with `as_ref`,\n     /// // then consume *that* with `map`, leaving `num_as_str` on the stack.\n     /// let num_as_int: Option<uint> = num_as_str.as_ref().map(|n| n.len());\n@@ -281,7 +281,7 @@ impl<T> Option<T> {\n     /// Convert an `Option<String>` into an `Option<uint>`, consuming the original:\n     ///\n     /// ```\n-    /// let num_as_str: Option<String> = Some(\"10\".to_strbuf());\n+    /// let num_as_str: Option<String> = Some(\"10\".to_string());\n     /// // `Option::map` takes self *by value*, consuming `num_as_str`\n     /// let num_as_int: Option<uint> = num_as_str.map(|n| n.len());\n     /// ```\n@@ -620,7 +620,7 @@ mod tests {\n \n     #[test]\n     fn test_get_str() {\n-        let x = \"test\".to_strbuf();\n+        let x = \"test\".to_string();\n         let addr_x = x.as_slice().as_ptr();\n         let opt = Some(x);\n         let y = opt.unwrap();\n@@ -746,7 +746,7 @@ mod tests {\n     #[test]\n     fn test_unwrap() {\n         assert_eq!(Some(1).unwrap(), 1);\n-        let s = Some(\"hello\".to_strbuf()).unwrap();\n+        let s = Some(\"hello\".to_string()).unwrap();\n         assert_eq!(s.as_slice(), \"hello\");\n     }\n "}, {"sha": "31313050165a6d022f7a5af436a35293274dde0a", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -925,15 +925,15 @@ pub trait MutableVector<'a, T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut v = ~[\"foo\".to_owned(), \"bar\".to_owned(), \"baz\".to_owned()];\n+    /// let mut v = ~[\"foo\".to_string(), \"bar\".to_string(), \"baz\".to_string()];\n     ///\n     /// unsafe {\n-    ///     // `\"baz\".to_owned()` is deallocated.\n-    ///     v.unsafe_set(2, \"qux\".to_owned());\n+    ///     // `\"baz\".to_string()` is deallocated.\n+    ///     v.unsafe_set(2, \"qux\".to_string());\n     ///\n     ///     // Out of bounds: could cause a crash, or overwriting\n     ///     // other data, or something else.\n-    ///     // v.unsafe_set(10, \"oops\".to_owned());\n+    ///     // v.unsafe_set(10, \"oops\".to_string());\n     /// }\n     /// ```\n     unsafe fn unsafe_set(self, index: uint, val: T);\n@@ -945,10 +945,10 @@ pub trait MutableVector<'a, T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut v = [\"foo\".to_owned(), \"bar\".to_owned()];\n+    /// let mut v = [\"foo\".to_string(), \"bar\".to_string()];\n     ///\n-    /// // memory leak! `\"bar\".to_owned()` is not deallocated.\n-    /// unsafe { v.init_elem(1, \"baz\".to_owned()); }\n+    /// // memory leak! `\"bar\".to_string()` is not deallocated.\n+    /// unsafe { v.init_elem(1, \"baz\".to_string()); }\n     /// ```\n     unsafe fn init_elem(self, i: uint, val: T);\n "}, {"sha": "5300374333b2e875c886b26493ae557ad0b450e0", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -249,7 +249,7 @@ impl<'a> Parser<'a> {\n     /// String, but I think it does when this eventually uses conditions so it\n     /// might as well start using it now.\n     fn err(&mut self, msg: &str) {\n-        self.errors.push(msg.to_strbuf());\n+        self.errors.push(msg.to_string());\n     }\n \n     /// Optionally consumes the specified character. If the character is not at"}, {"sha": "08aead025985a8f78828a39eac32e6b7fe54b859", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 156, "deletions": 156, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -50,7 +50,7 @@\n //!\n //! fn main() {\n //!     let args: Vec<String> = os::args().iter()\n-//!                                       .map(|x| x.to_strbuf())\n+//!                                       .map(|x| x.to_string())\n //!                                       .collect();\n //!\n //!     let program = args.get(0).clone();\n@@ -215,14 +215,14 @@ impl Name {\n         if nm.len() == 1u {\n             Short(nm.char_at(0u))\n         } else {\n-            Long(nm.to_strbuf())\n+            Long(nm.to_string())\n         }\n     }\n \n     fn to_str(&self) -> String {\n         match *self {\n-            Short(ch) => ch.to_str().to_strbuf(),\n-            Long(ref s) => s.to_strbuf()\n+            Short(ch) => ch.to_str().to_string(),\n+            Long(ref s) => s.to_string()\n         }\n     }\n }\n@@ -362,7 +362,7 @@ impl Matches {\n         }\n         match vals.get(0) {\n             &Val(ref s) => Some((*s).clone()),\n-            _ => Some(def.to_strbuf())\n+            _ => Some(def.to_string())\n         }\n     }\n \n@@ -394,10 +394,10 @@ pub fn reqopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptG\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_strbuf(),\n-        long_name: long_name.to_strbuf(),\n-        hint: hint.to_strbuf(),\n-        desc: desc.to_strbuf(),\n+        short_name: short_name.to_string(),\n+        long_name: long_name.to_string(),\n+        hint: hint.to_string(),\n+        desc: desc.to_string(),\n         hasarg: Yes,\n         occur: Req\n     }\n@@ -408,10 +408,10 @@ pub fn optopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptG\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_strbuf(),\n-        long_name: long_name.to_strbuf(),\n-        hint: hint.to_strbuf(),\n-        desc: desc.to_strbuf(),\n+        short_name: short_name.to_string(),\n+        long_name: long_name.to_string(),\n+        hint: hint.to_string(),\n+        desc: desc.to_string(),\n         hasarg: Yes,\n         occur: Optional\n     }\n@@ -422,10 +422,10 @@ pub fn optflag(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_strbuf(),\n-        long_name: long_name.to_strbuf(),\n-        hint: \"\".to_strbuf(),\n-        desc: desc.to_strbuf(),\n+        short_name: short_name.to_string(),\n+        long_name: long_name.to_string(),\n+        hint: \"\".to_string(),\n+        desc: desc.to_string(),\n         hasarg: No,\n         occur: Optional\n     }\n@@ -437,10 +437,10 @@ pub fn optflagmulti(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_strbuf(),\n-        long_name: long_name.to_strbuf(),\n-        hint: \"\".to_strbuf(),\n-        desc: desc.to_strbuf(),\n+        short_name: short_name.to_string(),\n+        long_name: long_name.to_string(),\n+        hint: \"\".to_string(),\n+        desc: desc.to_string(),\n         hasarg: No,\n         occur: Multi\n     }\n@@ -451,10 +451,10 @@ pub fn optflagopt(short_name: &str, long_name: &str, desc: &str, hint: &str) ->\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_strbuf(),\n-        long_name: long_name.to_strbuf(),\n-        hint: hint.to_strbuf(),\n-        desc: desc.to_strbuf(),\n+        short_name: short_name.to_string(),\n+        long_name: long_name.to_string(),\n+        hint: hint.to_string(),\n+        desc: desc.to_string(),\n         hasarg: Maybe,\n         occur: Optional\n     }\n@@ -466,10 +466,10 @@ pub fn optmulti(short_name: &str, long_name: &str, desc: &str, hint: &str) -> Op\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_strbuf(),\n-        long_name: long_name.to_strbuf(),\n-        hint: hint.to_strbuf(),\n-        desc: desc.to_strbuf(),\n+        short_name: short_name.to_string(),\n+        long_name: long_name.to_string(),\n+        hint: hint.to_string(),\n+        desc: desc.to_string(),\n         hasarg: Yes,\n         occur: Multi\n     }\n@@ -485,10 +485,10 @@ pub fn opt(short_name: &str,\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_strbuf(),\n-        long_name: long_name.to_strbuf(),\n-        hint: hint.to_strbuf(),\n-        desc: desc.to_strbuf(),\n+        short_name: short_name.to_string(),\n+        long_name: long_name.to_string(),\n+        hint: hint.to_string(),\n+        desc: desc.to_string(),\n         hasarg: hasarg,\n         occur: occur\n     }\n@@ -548,11 +548,11 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                 let tail = cur.as_slice().slice(2, curlen);\n                 let tail_eq: Vec<&str> = tail.split('=').collect();\n                 if tail_eq.len() <= 1 {\n-                    names = vec!(Long(tail.to_strbuf()));\n+                    names = vec!(Long(tail.to_string()));\n                 } else {\n                     names =\n-                        vec!(Long((*tail_eq.get(0)).to_strbuf()));\n-                    i_arg = Some((*tail_eq.get(1)).to_strbuf());\n+                        vec!(Long((*tail_eq.get(0)).to_string()));\n+                    i_arg = Some((*tail_eq.get(1)).to_string());\n                 }\n             } else {\n                 let mut j = 1;\n@@ -582,7 +582,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                             };\n                         if arg_follows && j < curlen {\n                             i_arg = Some(cur.as_slice()\n-                                            .slice(j, curlen).to_strbuf());\n+                                            .slice(j, curlen).to_string());\n                             break;\n                         } else {\n                             last_valid_opt_id = None;\n@@ -671,7 +671,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n                      hasarg: hasarg,\n                      ..} = (*optref).clone();\n \n-        let mut row = String::from_owned_str(\" \".repeat(4));\n+        let mut row = \" \".repeat(4);\n \n         // short option\n         match short_name.len() {\n@@ -728,7 +728,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n         each_split_within(desc_normalized_whitespace.as_slice(),\n                           54,\n                           |substr| {\n-            desc_rows.push(substr.to_owned());\n+            desc_rows.push(substr.to_string());\n             true\n         });\n \n@@ -900,19 +900,19 @@ fn each_split_within<'a>(ss: &'a str, lim: uint, it: |&'a str| -> bool)\n fn test_split_within() {\n     fn t(s: &str, i: uint, u: &[String]) {\n         let mut v = Vec::new();\n-        each_split_within(s, i, |s| { v.push(s.to_strbuf()); true });\n+        each_split_within(s, i, |s| { v.push(s.to_string()); true });\n         assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n     }\n     t(\"\", 0, []);\n     t(\"\", 15, []);\n-    t(\"hello\", 15, [\"hello\".to_strbuf()]);\n+    t(\"hello\", 15, [\"hello\".to_string()]);\n     t(\"\\nMary had a little lamb\\nLittle lamb\\n\", 15, [\n-        \"Mary had a\".to_strbuf(),\n-        \"little lamb\".to_strbuf(),\n-        \"Little lamb\".to_strbuf()\n+        \"Mary had a\".to_string(),\n+        \"little lamb\".to_string(),\n+        \"Little lamb\".to_string()\n     ]);\n     t(\"\\nMary had a little lamb\\nLittle lamb\\n\", ::std::uint::MAX,\n-        [\"Mary had a little lamb\\nLittle lamb\".to_strbuf()]);\n+        [\"Mary had a little lamb\\nLittle lamb\".to_string()]);\n }\n \n #[cfg(test)]\n@@ -935,33 +935,33 @@ mod tests {\n     // Tests for reqopt\n     #[test]\n     fn test_reqopt() {\n-        let long_args = vec!(\"--test=20\".to_strbuf());\n+        let long_args = vec!(\"--test=20\".to_string());\n         let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             assert!(m.opt_present(\"test\"));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_strbuf());\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_string());\n             assert!(m.opt_present(\"t\"));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_strbuf());\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_string());\n           }\n           _ => { fail!(\"test_reqopt failed (long arg)\"); }\n         }\n-        let short_args = vec!(\"-t\".to_strbuf(), \"20\".to_strbuf());\n+        let short_args = vec!(\"-t\".to_string(), \"20\".to_string());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_strbuf());\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_string());\n             assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_strbuf());\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_string());\n           }\n           _ => { fail!(\"test_reqopt failed (short arg)\"); }\n         }\n     }\n \n     #[test]\n     fn test_reqopt_missing() {\n-        let args = vec!(\"blah\".to_strbuf());\n+        let args = vec!(\"blah\".to_string());\n         let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -972,14 +972,14 @@ mod tests {\n \n     #[test]\n     fn test_reqopt_no_arg() {\n-        let long_args = vec!(\"--test\".to_strbuf());\n+        let long_args = vec!(\"--test\".to_string());\n         let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n-        let short_args = vec!(\"-t\".to_strbuf());\n+        let short_args = vec!(\"-t\".to_string());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n@@ -988,7 +988,7 @@ mod tests {\n \n     #[test]\n     fn test_reqopt_multi() {\n-        let args = vec!(\"--test=20\".to_strbuf(), \"-t\".to_strbuf(), \"30\".to_strbuf());\n+        let args = vec!(\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string());\n         let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1000,33 +1000,33 @@ mod tests {\n     // Tests for optopt\n     #[test]\n     fn test_optopt() {\n-        let long_args = vec!(\"--test=20\".to_strbuf());\n+        let long_args = vec!(\"--test=20\".to_string());\n         let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             assert!(m.opt_present(\"test\"));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_strbuf());\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_string());\n             assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_strbuf());\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_string());\n           }\n           _ => fail!()\n         }\n-        let short_args = vec!(\"-t\".to_strbuf(), \"20\".to_strbuf());\n+        let short_args = vec!(\"-t\".to_string(), \"20\".to_string());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_strbuf());\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_string());\n             assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_strbuf());\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_string());\n           }\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optopt_missing() {\n-        let args = vec!(\"blah\".to_strbuf());\n+        let args = vec!(\"blah\".to_string());\n         let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1040,14 +1040,14 @@ mod tests {\n \n     #[test]\n     fn test_optopt_no_arg() {\n-        let long_args = vec!(\"--test\".to_strbuf());\n+        let long_args = vec!(\"--test\".to_string());\n         let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n-        let short_args = vec!(\"-t\".to_strbuf());\n+        let short_args = vec!(\"-t\".to_string());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n@@ -1056,7 +1056,7 @@ mod tests {\n \n     #[test]\n     fn test_optopt_multi() {\n-        let args = vec!(\"--test=20\".to_strbuf(), \"-t\".to_strbuf(), \"30\".to_strbuf());\n+        let args = vec!(\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string());\n         let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1068,7 +1068,7 @@ mod tests {\n     // Tests for optflag\n     #[test]\n     fn test_optflag() {\n-        let long_args = vec!(\"--test\".to_strbuf());\n+        let long_args = vec!(\"--test\".to_string());\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1078,7 +1078,7 @@ mod tests {\n           }\n           _ => fail!()\n         }\n-        let short_args = vec!(\"-t\".to_strbuf());\n+        let short_args = vec!(\"-t\".to_string());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Ok(ref m) => {\n             assert!(m.opt_present(\"test\"));\n@@ -1090,7 +1090,7 @@ mod tests {\n \n     #[test]\n     fn test_optflag_missing() {\n-        let args = vec!(\"blah\".to_strbuf());\n+        let args = vec!(\"blah\".to_string());\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1104,7 +1104,7 @@ mod tests {\n \n     #[test]\n     fn test_optflag_long_arg() {\n-        let args = vec!(\"--test=20\".to_strbuf());\n+        let args = vec!(\"--test=20\".to_string());\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1118,7 +1118,7 @@ mod tests {\n \n     #[test]\n     fn test_optflag_multi() {\n-        let args = vec!(\"--test\".to_strbuf(), \"-t\".to_strbuf());\n+        let args = vec!(\"--test\".to_string(), \"-t\".to_string());\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1129,14 +1129,14 @@ mod tests {\n \n     #[test]\n     fn test_optflag_short_arg() {\n-        let args = vec!(\"-t\".to_strbuf(), \"20\".to_strbuf());\n+        let args = vec!(\"-t\".to_string(), \"20\".to_string());\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             // The next variable after the flag is just a free argument\n \n-            assert!(*m.free.get(0) == \"20\".to_strbuf());\n+            assert!(*m.free.get(0) == \"20\".to_string());\n           }\n           _ => fail!()\n         }\n@@ -1145,7 +1145,7 @@ mod tests {\n     // Tests for optflagmulti\n     #[test]\n     fn test_optflagmulti_short1() {\n-        let args = vec!(\"-v\".to_strbuf());\n+        let args = vec!(\"-v\".to_string());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1158,7 +1158,7 @@ mod tests {\n \n     #[test]\n     fn test_optflagmulti_short2a() {\n-        let args = vec!(\"-v\".to_strbuf(), \"-v\".to_strbuf());\n+        let args = vec!(\"-v\".to_string(), \"-v\".to_string());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1171,7 +1171,7 @@ mod tests {\n \n     #[test]\n     fn test_optflagmulti_short2b() {\n-        let args = vec!(\"-vv\".to_strbuf());\n+        let args = vec!(\"-vv\".to_string());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1184,7 +1184,7 @@ mod tests {\n \n     #[test]\n     fn test_optflagmulti_long1() {\n-        let args = vec!(\"--verbose\".to_strbuf());\n+        let args = vec!(\"--verbose\".to_string());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1197,7 +1197,7 @@ mod tests {\n \n     #[test]\n     fn test_optflagmulti_long2() {\n-        let args = vec!(\"--verbose\".to_strbuf(), \"--verbose\".to_strbuf());\n+        let args = vec!(\"--verbose\".to_string(), \"--verbose\".to_string());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1210,8 +1210,8 @@ mod tests {\n \n     #[test]\n     fn test_optflagmulti_mix() {\n-        let args = vec!(\"--verbose\".to_strbuf(), \"-v\".to_strbuf(),\n-                        \"-vv\".to_strbuf(), \"verbose\".to_strbuf());\n+        let args = vec!(\"--verbose\".to_string(), \"-v\".to_string(),\n+                        \"-vv\".to_string(), \"verbose\".to_string());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1226,33 +1226,33 @@ mod tests {\n     // Tests for optmulti\n     #[test]\n     fn test_optmulti() {\n-        let long_args = vec!(\"--test=20\".to_strbuf());\n+        let long_args = vec!(\"--test=20\".to_string());\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_strbuf());\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_string());\n             assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_strbuf());\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_string());\n           }\n           _ => fail!()\n         }\n-        let short_args = vec!(\"-t\".to_strbuf(), \"20\".to_strbuf());\n+        let short_args = vec!(\"-t\".to_string(), \"20\".to_string());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_strbuf());\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_string());\n             assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_strbuf());\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_string());\n           }\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optmulti_missing() {\n-        let args = vec!(\"blah\".to_strbuf());\n+        let args = vec!(\"blah\".to_string());\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1266,14 +1266,14 @@ mod tests {\n \n     #[test]\n     fn test_optmulti_no_arg() {\n-        let long_args = vec!(\"--test\".to_strbuf());\n+        let long_args = vec!(\"--test\".to_string());\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n-        let short_args = vec!(\"-t\".to_strbuf());\n+        let short_args = vec!(\"-t\".to_string());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n@@ -1282,33 +1282,33 @@ mod tests {\n \n     #[test]\n     fn test_optmulti_multi() {\n-        let args = vec!(\"--test=20\".to_strbuf(), \"-t\".to_strbuf(), \"30\".to_strbuf());\n+        let args = vec!(\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string());\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n               assert!(m.opt_present(\"test\"));\n-              assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_strbuf());\n+              assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_string());\n               assert!(m.opt_present(\"t\"));\n-              assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_strbuf());\n+              assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_string());\n               let pair = m.opt_strs(\"test\");\n-              assert!(*pair.get(0) == \"20\".to_strbuf());\n-              assert!(*pair.get(1) == \"30\".to_strbuf());\n+              assert!(*pair.get(0) == \"20\".to_string());\n+              assert!(*pair.get(1) == \"30\".to_string());\n           }\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_unrecognized_option() {\n-        let long_args = vec!(\"--untest\".to_strbuf());\n+        let long_args = vec!(\"--untest\".to_string());\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, UnrecognizedOption_),\n           _ => fail!()\n         }\n-        let short_args = vec!(\"-u\".to_strbuf());\n+        let short_args = vec!(\"-u\".to_string());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Err(f) => check_fail_type(f, UnrecognizedOption_),\n           _ => fail!()\n@@ -1318,22 +1318,22 @@ mod tests {\n     #[test]\n     fn test_combined() {\n         let args =\n-            vec!(\"prog\".to_strbuf(),\n-                 \"free1\".to_strbuf(),\n-                 \"-s\".to_strbuf(),\n-                 \"20\".to_strbuf(),\n-                 \"free2\".to_strbuf(),\n-                 \"--flag\".to_strbuf(),\n-                 \"--long=30\".to_strbuf(),\n-                 \"-f\".to_strbuf(),\n-                 \"-m\".to_strbuf(),\n-                 \"40\".to_strbuf(),\n-                 \"-m\".to_strbuf(),\n-                 \"50\".to_strbuf(),\n-                 \"-n\".to_strbuf(),\n-                 \"-A B\".to_strbuf(),\n-                 \"-n\".to_strbuf(),\n-                 \"-60 70\".to_strbuf());\n+            vec!(\"prog\".to_string(),\n+                 \"free1\".to_string(),\n+                 \"-s\".to_string(),\n+                 \"20\".to_string(),\n+                 \"free2\".to_string(),\n+                 \"--flag\".to_string(),\n+                 \"--long=30\".to_string(),\n+                 \"-f\".to_string(),\n+                 \"-m\".to_string(),\n+                 \"40\".to_string(),\n+                 \"-m\".to_string(),\n+                 \"50\".to_string(),\n+                 \"-n\".to_string(),\n+                 \"-A B\".to_string(),\n+                 \"-n\".to_string(),\n+                 \"-60 70\".to_string());\n         let opts =\n             vec!(optopt(\"s\", \"something\", \"something\", \"SOMETHING\"),\n               optflag(\"\", \"flag\", \"a flag\"),\n@@ -1345,19 +1345,19 @@ mod tests {\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n-            assert!(*m.free.get(0) == \"prog\".to_strbuf());\n-            assert!(*m.free.get(1) == \"free1\".to_strbuf());\n-            assert_eq!(m.opt_str(\"s\").unwrap(), \"20\".to_strbuf());\n-            assert!(*m.free.get(2) == \"free2\".to_strbuf());\n+            assert!(*m.free.get(0) == \"prog\".to_string());\n+            assert!(*m.free.get(1) == \"free1\".to_string());\n+            assert_eq!(m.opt_str(\"s\").unwrap(), \"20\".to_string());\n+            assert!(*m.free.get(2) == \"free2\".to_string());\n             assert!((m.opt_present(\"flag\")));\n-            assert_eq!(m.opt_str(\"long\").unwrap(), \"30\".to_strbuf());\n+            assert_eq!(m.opt_str(\"long\").unwrap(), \"30\".to_string());\n             assert!((m.opt_present(\"f\")));\n             let pair = m.opt_strs(\"m\");\n-            assert!(*pair.get(0) == \"40\".to_strbuf());\n-            assert!(*pair.get(1) == \"50\".to_strbuf());\n+            assert!(*pair.get(0) == \"40\".to_string());\n+            assert!(*pair.get(1) == \"50\".to_string());\n             let pair = m.opt_strs(\"n\");\n-            assert!(*pair.get(0) == \"-A B\".to_strbuf());\n-            assert!(*pair.get(1) == \"-60 70\".to_strbuf());\n+            assert!(*pair.get(0) == \"-A B\".to_string());\n+            assert!(*pair.get(1) == \"-60 70\".to_string());\n             assert!((!m.opt_present(\"notpresent\")));\n           }\n           _ => fail!()\n@@ -1370,68 +1370,68 @@ mod tests {\n                      optopt(\"\", \"encrypt\", \"encrypt\", \"ENCRYPT\"),\n                      optopt(\"f\", \"\", \"flag\", \"FLAG\"));\n \n-        let args_single = vec!(\"-e\".to_strbuf(), \"foo\".to_strbuf());\n+        let args_single = vec!(\"-e\".to_string(), \"foo\".to_string());\n         let matches_single = &match getopts(args_single.as_slice(),\n                                             opts.as_slice()) {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        assert!(matches_single.opts_present([\"e\".to_strbuf()]));\n-        assert!(matches_single.opts_present([\"encrypt\".to_strbuf(), \"e\".to_strbuf()]));\n-        assert!(matches_single.opts_present([\"e\".to_strbuf(), \"encrypt\".to_strbuf()]));\n-        assert!(!matches_single.opts_present([\"encrypt\".to_strbuf()]));\n-        assert!(!matches_single.opts_present([\"thing\".to_strbuf()]));\n+        assert!(matches_single.opts_present([\"e\".to_string()]));\n+        assert!(matches_single.opts_present([\"encrypt\".to_string(), \"e\".to_string()]));\n+        assert!(matches_single.opts_present([\"e\".to_string(), \"encrypt\".to_string()]));\n+        assert!(!matches_single.opts_present([\"encrypt\".to_string()]));\n+        assert!(!matches_single.opts_present([\"thing\".to_string()]));\n         assert!(!matches_single.opts_present([]));\n \n-        assert_eq!(matches_single.opts_str([\"e\".to_strbuf()]).unwrap(), \"foo\".to_strbuf());\n-        assert_eq!(matches_single.opts_str([\"e\".to_strbuf(), \"encrypt\".to_strbuf()]).unwrap(),\n-                   \"foo\".to_strbuf());\n-        assert_eq!(matches_single.opts_str([\"encrypt\".to_strbuf(), \"e\".to_strbuf()]).unwrap(),\n-                   \"foo\".to_strbuf());\n+        assert_eq!(matches_single.opts_str([\"e\".to_string()]).unwrap(), \"foo\".to_string());\n+        assert_eq!(matches_single.opts_str([\"e\".to_string(), \"encrypt\".to_string()]).unwrap(),\n+                   \"foo\".to_string());\n+        assert_eq!(matches_single.opts_str([\"encrypt\".to_string(), \"e\".to_string()]).unwrap(),\n+                   \"foo\".to_string());\n \n-        let args_both = vec!(\"-e\".to_strbuf(), \"foo\".to_strbuf(), \"--encrypt\".to_strbuf(),\n-                             \"foo\".to_strbuf());\n+        let args_both = vec!(\"-e\".to_string(), \"foo\".to_string(), \"--encrypt\".to_string(),\n+                             \"foo\".to_string());\n         let matches_both = &match getopts(args_both.as_slice(),\n                                           opts.as_slice()) {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        assert!(matches_both.opts_present([\"e\".to_strbuf()]));\n-        assert!(matches_both.opts_present([\"encrypt\".to_strbuf()]));\n-        assert!(matches_both.opts_present([\"encrypt\".to_strbuf(), \"e\".to_strbuf()]));\n-        assert!(matches_both.opts_present([\"e\".to_strbuf(), \"encrypt\".to_strbuf()]));\n-        assert!(!matches_both.opts_present([\"f\".to_strbuf()]));\n-        assert!(!matches_both.opts_present([\"thing\".to_strbuf()]));\n+        assert!(matches_both.opts_present([\"e\".to_string()]));\n+        assert!(matches_both.opts_present([\"encrypt\".to_string()]));\n+        assert!(matches_both.opts_present([\"encrypt\".to_string(), \"e\".to_string()]));\n+        assert!(matches_both.opts_present([\"e\".to_string(), \"encrypt\".to_string()]));\n+        assert!(!matches_both.opts_present([\"f\".to_string()]));\n+        assert!(!matches_both.opts_present([\"thing\".to_string()]));\n         assert!(!matches_both.opts_present([]));\n \n-        assert_eq!(matches_both.opts_str([\"e\".to_strbuf()]).unwrap(), \"foo\".to_strbuf());\n-        assert_eq!(matches_both.opts_str([\"encrypt\".to_strbuf()]).unwrap(), \"foo\".to_strbuf());\n-        assert_eq!(matches_both.opts_str([\"e\".to_strbuf(), \"encrypt\".to_strbuf()]).unwrap(),\n-                   \"foo\".to_strbuf());\n-        assert_eq!(matches_both.opts_str([\"encrypt\".to_strbuf(), \"e\".to_strbuf()]).unwrap(),\n-                   \"foo\".to_strbuf());\n+        assert_eq!(matches_both.opts_str([\"e\".to_string()]).unwrap(), \"foo\".to_string());\n+        assert_eq!(matches_both.opts_str([\"encrypt\".to_string()]).unwrap(), \"foo\".to_string());\n+        assert_eq!(matches_both.opts_str([\"e\".to_string(), \"encrypt\".to_string()]).unwrap(),\n+                   \"foo\".to_string());\n+        assert_eq!(matches_both.opts_str([\"encrypt\".to_string(), \"e\".to_string()]).unwrap(),\n+                   \"foo\".to_string());\n     }\n \n     #[test]\n     fn test_nospace() {\n-        let args = vec!(\"-Lfoo\".to_strbuf(), \"-M.\".to_strbuf());\n+        let args = vec!(\"-Lfoo\".to_string(), \"-M.\".to_string());\n         let opts = vec!(optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n                      optmulti(\"M\", \"\", \"something\", \"MMMM\"));\n         let matches = &match getopts(args.as_slice(), opts.as_slice()) {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        assert!(matches.opts_present([\"L\".to_strbuf()]));\n-        assert_eq!(matches.opts_str([\"L\".to_strbuf()]).unwrap(), \"foo\".to_strbuf());\n-        assert!(matches.opts_present([\"M\".to_strbuf()]));\n-        assert_eq!(matches.opts_str([\"M\".to_strbuf()]).unwrap(), \".\".to_strbuf());\n+        assert!(matches.opts_present([\"L\".to_string()]));\n+        assert_eq!(matches.opts_str([\"L\".to_string()]).unwrap(), \"foo\".to_string());\n+        assert!(matches.opts_present([\"M\".to_string()]));\n+        assert_eq!(matches.opts_str([\"M\".to_string()]).unwrap(), \".\".to_string());\n \n     }\n \n     #[test]\n     fn test_long_to_short() {\n         let mut short = Opt {\n-            name: Long(\"banana\".to_strbuf()),\n+            name: Long(\"banana\".to_string()),\n             hasarg: Yes,\n             occur: Req,\n             aliases: Vec::new(),\n@@ -1450,7 +1450,7 @@ mod tests {\n         let opts = vec!(\n             optflagmulti(\"a\", \"apple\", \"Desc\"));\n \n-        let args = vec!(\"-a\".to_strbuf(), \"--apple\".to_strbuf(), \"-a\".to_strbuf());\n+        let args = vec!(\"-a\".to_string(), \"--apple\".to_string(), \"-a\".to_string());\n \n         let matches = getopts(args.as_slice(), opts.as_slice()).unwrap();\n         assert_eq!(3, matches.opt_count(\"a\"));\n@@ -1477,7 +1477,7 @@ Options:\n     -k --kiwi           Desc\n     -p [VAL]            Desc\n     -l VAL              Desc\n-\".to_strbuf();\n+\".to_string();\n \n         let generated_usage = usage(\"Usage: fruits\", optgroups.as_slice());\n \n@@ -1504,7 +1504,7 @@ Options:\n     -k --kiwi           This is a long description which won't be wrapped..+..\n     -a --apple          This is a long description which _will_ be\n                         wrapped..+..\n-\".to_strbuf();\n+\".to_string();\n \n         let usage = usage(\"Usage: fruits\", optgroups.as_slice());\n \n@@ -1530,7 +1530,7 @@ Options:\n     -a --apple          This \u201cdescription\u201d has some characters that could\n                         confuse the line wrapping; an apple costs 0.51\u20ac in\n                         some parts of Europe.\n-\".to_strbuf();\n+\".to_string();\n \n         let usage = usage(\"Usage: fruits\", optgroups.as_slice());\n \n@@ -1549,7 +1549,7 @@ Options:\n             optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n             optmulti(\"l\", \"\", \"Desc\", \"VAL\"));\n \n-        let expected = \"Usage: fruits -b VAL [-a VAL] [-k] [-p [VAL]] [-l VAL]..\".to_strbuf();\n+        let expected = \"Usage: fruits -b VAL [-a VAL] [-k] [-p [VAL]] [-l VAL]..\".to_string();\n         let generated_usage = short_usage(\"fruits\", optgroups.as_slice());\n \n         debug!(\"expected: <<{}>>\", expected);"}, {"sha": "1affeadbff1f2f9eaa7f0d79cbeb9eaec6cdd371", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -767,7 +767,7 @@ mod test {\n     #[test]\n     fn test_pattern_escape() {\n         let s = \"_[_]_?_*_!_\";\n-        assert_eq!(Pattern::escape(s), \"_[[]_[]]_[?]_[*]_!_\".to_strbuf());\n+        assert_eq!(Pattern::escape(s), \"_[[]_[]]_[?]_[*]_!_\".to_string());\n         assert!(Pattern::new(Pattern::escape(s).as_slice()).matches(s));\n     }\n "}, {"sha": "e5fb200a1c4179cfb7e7ed7d7e463eb033e813a6", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -435,8 +435,8 @@ impl<'a> LabelText<'a> {\n     /// Renders text as string suitable for a label in a .dot file.\n     pub fn escape(&self) -> String {\n         match self {\n-            &LabelStr(ref s) => s.as_slice().escape_default().to_strbuf(),\n-            &EscStr(ref s) => LabelText::escape_str(s.as_slice()).to_strbuf(),\n+            &LabelStr(ref s) => s.as_slice().escape_default().to_string(),\n+            &EscStr(ref s) => LabelText::escape_str(s.as_slice()).to_string(),\n         }\n     }\n }\n@@ -666,7 +666,7 @@ mod tests {\n         render(&g, &mut writer).unwrap();\n         let mut r = BufReader::new(writer.get_ref());\n         match r.read_to_str() {\n-            Ok(string) => Ok(string.to_strbuf()),\n+            Ok(string) => Ok(string.to_string()),\n             Err(err) => Err(err),\n         }\n     }"}, {"sha": "ee14f1aaea9a2a97fd0b2d28eb8dbc56cf2bd291", "filename": "src/libhexfloat/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibhexfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibhexfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibhexfloat%2Flib.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -75,34 +75,34 @@ fn hex_float_lit_err(s: &str) -> Option<(uint, String)> {\n     let mut i = 0;\n     if chars.peek() == Some(&'-') { chars.next(); i+= 1 }\n     if chars.next() != Some('0') {\n-        return Some((i, \"Expected '0'\".to_strbuf()));\n+        return Some((i, \"Expected '0'\".to_string()));\n     } i+=1;\n     if chars.next() != Some('x') {\n-        return Some((i, \"Expected 'x'\".to_strbuf()));\n+        return Some((i, \"Expected 'x'\".to_string()));\n     } i+=1;\n     let mut d_len = 0;\n     for _ in chars.take_while(|c| c.is_digit_radix(16)) { chars.next(); i+=1; d_len += 1;}\n     if chars.next() != Some('.') {\n-        return Some((i, \"Expected '.'\".to_strbuf()));\n+        return Some((i, \"Expected '.'\".to_string()));\n     } i+=1;\n     let mut f_len = 0;\n     for _ in chars.take_while(|c| c.is_digit_radix(16)) { chars.next(); i+=1; f_len += 1;}\n     if d_len == 0 && f_len == 0 {\n         return Some((i, \"Expected digits before or after decimal \\\n-                         point\".to_strbuf()));\n+                         point\".to_string()));\n     }\n     if chars.next() != Some('p') {\n-        return Some((i, \"Expected 'p'\".to_strbuf()));\n+        return Some((i, \"Expected 'p'\".to_string()));\n     } i+=1;\n     if chars.peek() == Some(&'-') { chars.next(); i+= 1 }\n     let mut e_len = 0;\n     for _ in chars.take_while(|c| c.is_digit()) { chars.next(); i+=1; e_len += 1}\n     if e_len == 0 {\n-        return Some((i, \"Expected exponent digits\".to_strbuf()));\n+        return Some((i, \"Expected exponent digits\".to_string()));\n     }\n     match chars.next() {\n         None => None,\n-        Some(_) => Some((i, \"Expected end of string\".to_strbuf()))\n+        Some(_) => Some((i, \"Expected end of string\".to_string()))\n     }\n }\n "}, {"sha": "2062bb4c7b1b67d95261c5f023ec131309837f5a", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -64,7 +64,7 @@ pub fn parse_logging_spec(spec: &str) -> Vec<LogDirective> {\n             }\n         };\n         dirs.push(LogDirective {\n-            name: name.map(|s| s.to_strbuf()),\n+            name: name.map(|s| s.to_string()),\n             level: log_level,\n         });\n     }\n@@ -80,13 +80,13 @@ mod tests {\n         let dirs = parse_logging_spec(\"crate1::mod1=1,crate1::mod2,crate2=4\");\n         let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 3);\n-        assert_eq!(dirs[0].name, Some(\"crate1::mod1\".to_strbuf()));\n+        assert_eq!(dirs[0].name, Some(\"crate1::mod1\".to_string()));\n         assert_eq!(dirs[0].level, 1);\n \n-        assert_eq!(dirs[1].name, Some(\"crate1::mod2\".to_strbuf()));\n+        assert_eq!(dirs[1].name, Some(\"crate1::mod2\".to_string()));\n         assert_eq!(dirs[1].level, ::MAX_LOG_LEVEL);\n \n-        assert_eq!(dirs[2].name, Some(\"crate2\".to_strbuf()));\n+        assert_eq!(dirs[2].name, Some(\"crate2\".to_string()));\n         assert_eq!(dirs[2].level, 4);\n     }\n \n@@ -96,7 +96,7 @@ mod tests {\n         let dirs = parse_logging_spec(\"crate1::mod1=1=2,crate2=4\");\n         let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 1);\n-        assert_eq!(dirs[0].name, Some(\"crate2\".to_strbuf()));\n+        assert_eq!(dirs[0].name, Some(\"crate2\".to_string()));\n         assert_eq!(dirs[0].level, 4);\n     }\n \n@@ -106,7 +106,7 @@ mod tests {\n         let dirs = parse_logging_spec(\"crate1::mod1=noNumber,crate2=4\");\n         let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 1);\n-        assert_eq!(dirs[0].name, Some(\"crate2\".to_strbuf()));\n+        assert_eq!(dirs[0].name, Some(\"crate2\".to_string()));\n         assert_eq!(dirs[0].level, 4);\n     }\n \n@@ -116,7 +116,7 @@ mod tests {\n         let dirs = parse_logging_spec(\"crate1::mod1=wrong,crate2=warn\");\n         let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 1);\n-        assert_eq!(dirs[0].name, Some(\"crate2\".to_strbuf()));\n+        assert_eq!(dirs[0].name, Some(\"crate2\".to_string()));\n         assert_eq!(dirs[0].level, ::WARN);\n     }\n \n@@ -128,7 +128,7 @@ mod tests {\n         assert_eq!(dirs.len(), 2);\n         assert_eq!(dirs[0].name, None);\n         assert_eq!(dirs[0].level, 2);\n-        assert_eq!(dirs[1].name, Some(\"crate2\".to_strbuf()));\n+        assert_eq!(dirs[1].name, Some(\"crate2\".to_string()));\n         assert_eq!(dirs[1].level, 4);\n     }\n }"}, {"sha": "6f9f3f2e21e031f29d92ed36793a23b08b1b3b43", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -366,11 +366,11 @@ mod tests {\n     fn match_full_path() {\n         let dirs = [\n             LogDirective {\n-                name: Some(\"crate2\".to_strbuf()),\n+                name: Some(\"crate2\".to_string()),\n                 level: 3\n             },\n             LogDirective {\n-                name: Some(\"crate1::mod1\".to_strbuf()),\n+                name: Some(\"crate1::mod1\".to_string()),\n                 level: 2\n             }\n         ];\n@@ -383,27 +383,27 @@ mod tests {\n     #[test]\n     fn no_match() {\n         let dirs = [\n-            LogDirective { name: Some(\"crate2\".to_strbuf()), level: 3 },\n-            LogDirective { name: Some(\"crate1::mod1\".to_strbuf()), level: 2 }\n+            LogDirective { name: Some(\"crate2\".to_string()), level: 3 },\n+            LogDirective { name: Some(\"crate1::mod1\".to_string()), level: 2 }\n         ];\n         assert!(!enabled(2, \"crate3\", dirs.iter()));\n     }\n \n     #[test]\n     fn match_beginning() {\n         let dirs = [\n-            LogDirective { name: Some(\"crate2\".to_strbuf()), level: 3 },\n-            LogDirective { name: Some(\"crate1::mod1\".to_strbuf()), level: 2 }\n+            LogDirective { name: Some(\"crate2\".to_string()), level: 3 },\n+            LogDirective { name: Some(\"crate1::mod1\".to_string()), level: 2 }\n         ];\n         assert!(enabled(3, \"crate2::mod1\", dirs.iter()));\n     }\n \n     #[test]\n     fn match_beginning_longest_match() {\n         let dirs = [\n-            LogDirective { name: Some(\"crate2\".to_strbuf()), level: 3 },\n-            LogDirective { name: Some(\"crate2::mod\".to_strbuf()), level: 4 },\n-            LogDirective { name: Some(\"crate1::mod1\".to_strbuf()), level: 2 }\n+            LogDirective { name: Some(\"crate2\".to_string()), level: 3 },\n+            LogDirective { name: Some(\"crate2::mod\".to_string()), level: 4 },\n+            LogDirective { name: Some(\"crate1::mod1\".to_string()), level: 2 }\n         ];\n         assert!(enabled(4, \"crate2::mod1\", dirs.iter()));\n         assert!(!enabled(4, \"crate2\", dirs.iter()));\n@@ -413,7 +413,7 @@ mod tests {\n     fn match_default() {\n         let dirs = [\n             LogDirective { name: None, level: 3 },\n-            LogDirective { name: Some(\"crate1::mod1\".to_strbuf()), level: 2 }\n+            LogDirective { name: Some(\"crate1::mod1\".to_string()), level: 2 }\n         ];\n         assert!(enabled(2, \"crate1::mod1\", dirs.iter()));\n         assert!(enabled(3, \"crate2::mod2\", dirs.iter()));\n@@ -423,7 +423,7 @@ mod tests {\n     fn zero_level() {\n         let dirs = [\n             LogDirective { name: None, level: 3 },\n-            LogDirective { name: Some(\"crate1::mod1\".to_strbuf()), level: 0 }\n+            LogDirective { name: Some(\"crate1::mod1\".to_string()), level: 0 }\n         ];\n         assert!(!enabled(1, \"crate1::mod1\", dirs.iter()));\n         assert!(enabled(3, \"crate2::mod2\", dirs.iter()));"}, {"sha": "6bc41a9c4c5b2d28b2bdb978573de27e80349bca", "filename": "src/libnative/io/addrinfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibnative%2Fio%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibnative%2Fio%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Faddrinfo.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -106,7 +106,7 @@ fn get_error(s: c_int) -> IoError {\n     use std::io;\n \n     let err_str = unsafe {\n-        CString::new(gai_strerror(s), false).as_str().unwrap().to_strbuf()\n+        CString::new(gai_strerror(s), false).as_str().unwrap().to_string()\n     };\n     IoError {\n         kind: io::OtherIoError,"}, {"sha": "177b90f2e1acd2c4f7b1976c29a46e7e17d24a39", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -1103,24 +1103,24 @@ mod tests {\n \n         assert_eq!(\n             test_wrapper(\"prog\", [\"aaa\", \"bbb\", \"ccc\"]),\n-            \"prog aaa bbb ccc\".to_owned()\n+            \"prog aaa bbb ccc\".to_string()\n         );\n \n         assert_eq!(\n             test_wrapper(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", [\"aaa\"]),\n-            \"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" aaa\".to_owned()\n+            \"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" aaa\".to_string()\n         );\n         assert_eq!(\n             test_wrapper(\"C:\\\\Program Files\\\\test\", [\"aa\\\"bb\"]),\n-            \"\\\"C:\\\\Program Files\\\\test\\\" aa\\\\\\\"bb\".to_owned()\n+            \"\\\"C:\\\\Program Files\\\\test\\\" aa\\\\\\\"bb\".to_string()\n         );\n         assert_eq!(\n             test_wrapper(\"echo\", [\"a b c\"]),\n-            \"echo \\\"a b c\\\"\".to_owned()\n+            \"echo \\\"a b c\\\"\".to_string()\n         );\n         assert_eq!(\n             test_wrapper(\"\\u03c0\\u042f\\u97f3\\u00e6\\u221e\", []),\n-            \"\\u03c0\\u042f\\u97f3\\u00e6\\u221e\".to_owned()\n+            \"\\u03c0\\u042f\\u97f3\\u00e6\\u221e\".to_string()\n         );\n     }\n }"}, {"sha": "e8d0434c392856c4eb83b385c5667a4d7f2f26d6", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -629,15 +629,15 @@ impl ToStrRadix for BigUint {\n \n         fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> String {\n             if v.is_empty() {\n-                return \"0\".to_strbuf()\n+                return \"0\".to_string()\n             }\n             let mut s = String::with_capacity(v.len() * l);\n             for n in v.iter().rev() {\n                 let ss = (*n as uint).to_str_radix(radix);\n                 s.push_str(\"0\".repeat(l - ss.len()).as_slice());\n                 s.push_str(ss.as_slice());\n             }\n-            s.as_slice().trim_left_chars('0').to_strbuf()\n+            s.as_slice().trim_left_chars('0').to_string()\n         }\n     }\n }\n@@ -1214,7 +1214,7 @@ impl ToStrRadix for BigInt {\n     fn to_str_radix(&self, radix: uint) -> String {\n         match self.sign {\n             Plus  => self.data.to_str_radix(radix),\n-            Zero  => \"0\".to_strbuf(),\n+            Zero  => \"0\".to_string(),\n             Minus => format_strbuf!(\"-{}\", self.data.to_str_radix(radix)),\n         }\n     }\n@@ -2032,35 +2032,35 @@ mod biguint_tests {\n     fn to_str_pairs() -> Vec<(BigUint, Vec<(uint, String)>)> {\n         let bits = BigDigit::bits;\n         vec!(( Zero::zero(), vec!(\n-            (2, \"0\".to_strbuf()), (3, \"0\".to_strbuf())\n+            (2, \"0\".to_string()), (3, \"0\".to_string())\n         )), ( BigUint::from_slice([ 0xff ]), vec!(\n-            (2,  \"11111111\".to_strbuf()),\n-            (3,  \"100110\".to_strbuf()),\n-            (4,  \"3333\".to_strbuf()),\n-            (5,  \"2010\".to_strbuf()),\n-            (6,  \"1103\".to_strbuf()),\n-            (7,  \"513\".to_strbuf()),\n-            (8,  \"377\".to_strbuf()),\n-            (9,  \"313\".to_strbuf()),\n-            (10, \"255\".to_strbuf()),\n-            (11, \"212\".to_strbuf()),\n-            (12, \"193\".to_strbuf()),\n-            (13, \"168\".to_strbuf()),\n-            (14, \"143\".to_strbuf()),\n-            (15, \"120\".to_strbuf()),\n-            (16, \"ff\".to_strbuf())\n+            (2,  \"11111111\".to_string()),\n+            (3,  \"100110\".to_string()),\n+            (4,  \"3333\".to_string()),\n+            (5,  \"2010\".to_string()),\n+            (6,  \"1103\".to_string()),\n+            (7,  \"513\".to_string()),\n+            (8,  \"377\".to_string()),\n+            (9,  \"313\".to_string()),\n+            (10, \"255\".to_string()),\n+            (11, \"212\".to_string()),\n+            (12, \"193\".to_string()),\n+            (13, \"168\".to_string()),\n+            (14, \"143\".to_string()),\n+            (15, \"120\".to_string()),\n+            (16, \"ff\".to_string())\n         )), ( BigUint::from_slice([ 0xfff ]), vec!(\n-            (2,  \"111111111111\".to_strbuf()),\n-            (4,  \"333333\".to_strbuf()),\n-            (16, \"fff\".to_strbuf())\n+            (2,  \"111111111111\".to_string()),\n+            (4,  \"333333\".to_string()),\n+            (16, \"fff\".to_string())\n         )), ( BigUint::from_slice([ 1, 2 ]), vec!(\n             (2,\n              format_strbuf!(\"10{}1\", \"0\".repeat(bits - 1))),\n             (4,\n              format_strbuf!(\"2{}1\", \"0\".repeat(bits / 2 - 1))),\n             (10, match bits {\n-                32 => \"8589934593\".to_strbuf(),\n-                16 => \"131073\".to_strbuf(),\n+                32 => \"8589934593\".to_string(),\n+                16 => \"131073\".to_string(),\n                 _ => fail!()\n             }),\n             (16,\n@@ -2075,8 +2075,8 @@ mod biguint_tests {\n                             \"0\".repeat(bits / 2 - 1),\n                             \"0\".repeat(bits / 2 - 1))),\n             (10, match bits {\n-                32 => \"55340232229718589441\".to_strbuf(),\n-                16 => \"12885032961\".to_strbuf(),\n+                32 => \"55340232229718589441\".to_string(),\n+                16 => \"12885032961\".to_string(),\n                 _ => fail!()\n             }),\n             (16,"}, {"sha": "a4c2183921433af9fa6ccfb65ceb6b61455497bf", "filename": "src/libnum/complex.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fcomplex.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -349,14 +349,14 @@ mod test {\n     #[test]\n     fn test_to_str() {\n         fn test(c : Complex64, s: String) {\n-            assert_eq!(c.to_str().to_strbuf(), s);\n+            assert_eq!(c.to_str().to_string(), s);\n         }\n-        test(_0_0i, \"0+0i\".to_strbuf());\n-        test(_1_0i, \"1+0i\".to_strbuf());\n-        test(_0_1i, \"0+1i\".to_strbuf());\n-        test(_1_1i, \"1+1i\".to_strbuf());\n-        test(_neg1_1i, \"-1+1i\".to_strbuf());\n-        test(-_neg1_1i, \"1-1i\".to_strbuf());\n-        test(_05_05i, \"0.5+0.5i\".to_strbuf());\n+        test(_0_0i, \"0+0i\".to_string());\n+        test(_1_0i, \"1+0i\".to_string());\n+        test(_0_1i, \"0+1i\".to_string());\n+        test(_1_1i, \"1+1i\".to_string());\n+        test(_neg1_1i, \"-1+1i\".to_string());\n+        test(-_neg1_1i, \"1-1i\".to_string());\n+        test(_05_05i, \"0.5+0.5i\".to_string());\n     }\n }"}, {"sha": "e916265396e265204a3844d22b92a2bb7fd501ce", "filename": "src/libnum/rational.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -559,14 +559,14 @@ mod test {\n     fn test_to_from_str() {\n         fn test(r: Rational, s: String) {\n             assert_eq!(FromStr::from_str(s.as_slice()), Some(r));\n-            assert_eq!(r.to_str().to_strbuf(), s);\n+            assert_eq!(r.to_str().to_string(), s);\n         }\n-        test(_1, \"1/1\".to_strbuf());\n-        test(_0, \"0/1\".to_strbuf());\n-        test(_1_2, \"1/2\".to_strbuf());\n-        test(_3_2, \"3/2\".to_strbuf());\n-        test(_2, \"2/1\".to_strbuf());\n-        test(_neg1_2, \"-1/2\".to_strbuf());\n+        test(_1, \"1/1\".to_string());\n+        test(_0, \"0/1\".to_string());\n+        test(_1_2, \"1/2\".to_string());\n+        test(_3_2, \"3/2\".to_string());\n+        test(_2, \"2/1\".to_string());\n+        test(_neg1_2, \"-1/2\".to_string());\n     }\n     #[test]\n     fn test_from_str_fail() {\n@@ -586,28 +586,28 @@ mod test {\n         fn test(r: Rational, s: String, n: uint) {\n             assert_eq!(FromStrRadix::from_str_radix(s.as_slice(), n),\n                        Some(r));\n-            assert_eq!(r.to_str_radix(n).to_strbuf(), s);\n+            assert_eq!(r.to_str_radix(n).to_string(), s);\n         }\n         fn test3(r: Rational, s: String) { test(r, s, 3) }\n         fn test16(r: Rational, s: String) { test(r, s, 16) }\n \n-        test3(_1, \"1/1\".to_strbuf());\n-        test3(_0, \"0/1\".to_strbuf());\n-        test3(_1_2, \"1/2\".to_strbuf());\n-        test3(_3_2, \"10/2\".to_strbuf());\n-        test3(_2, \"2/1\".to_strbuf());\n-        test3(_neg1_2, \"-1/2\".to_strbuf());\n-        test3(_neg1_2 / _2, \"-1/11\".to_strbuf());\n-\n-        test16(_1, \"1/1\".to_strbuf());\n-        test16(_0, \"0/1\".to_strbuf());\n-        test16(_1_2, \"1/2\".to_strbuf());\n-        test16(_3_2, \"3/2\".to_strbuf());\n-        test16(_2, \"2/1\".to_strbuf());\n-        test16(_neg1_2, \"-1/2\".to_strbuf());\n-        test16(_neg1_2 / _2, \"-1/4\".to_strbuf());\n-        test16(Ratio::new(13,15), \"d/f\".to_strbuf());\n-        test16(_1_2*_1_2*_1_2*_1_2, \"1/10\".to_strbuf());\n+        test3(_1, \"1/1\".to_string());\n+        test3(_0, \"0/1\".to_string());\n+        test3(_1_2, \"1/2\".to_string());\n+        test3(_3_2, \"10/2\".to_string());\n+        test3(_2, \"2/1\".to_string());\n+        test3(_neg1_2, \"-1/2\".to_string());\n+        test3(_neg1_2 / _2, \"-1/11\".to_string());\n+\n+        test16(_1, \"1/1\".to_string());\n+        test16(_0, \"0/1\".to_string());\n+        test16(_1_2, \"1/2\".to_string());\n+        test16(_3_2, \"3/2\".to_string());\n+        test16(_2, \"2/1\".to_string());\n+        test16(_neg1_2, \"-1/2\".to_string());\n+        test16(_neg1_2 / _2, \"-1/4\".to_string());\n+        test16(Ratio::new(13,15), \"d/f\".to_string());\n+        test16(_1_2*_1_2*_1_2*_1_2, \"1/10\".to_string());\n     }\n \n     #[test]"}, {"sha": "87b6e2b110441f3ee7e1702a93799f69e33e7a53", "filename": "src/libregex/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibregex%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibregex%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse%2Fmod.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -222,7 +222,7 @@ impl<'a> Parser<'a> {\n                         self.caps += 1;\n                         self.stack.push(Paren(self.flags,\n                                               self.caps,\n-                                              \"\".to_strbuf()))\n+                                              \"\".to_string()))\n                     }\n                 }\n                 ')' => {\n@@ -796,7 +796,7 @@ impl<'a> Parser<'a> {\n                     }\n                     if self.cur() == ':' {\n                         // Save the old flags with the opening paren.\n-                        self.stack.push(Paren(self.flags, 0, \"\".to_strbuf()));\n+                        self.stack.push(Paren(self.flags, 0, \"\".to_string()));\n                     }\n                     self.flags = flags;\n                     return Ok(())\n@@ -922,7 +922,7 @@ impl<'a> Parser<'a> {\n     fn err<T>(&self, msg: &str) -> Result<T, Error> {\n         Err(Error {\n             pos: self.chari,\n-            msg: msg.to_strbuf(),\n+            msg: msg.to_string(),\n         })\n     }\n \n@@ -942,7 +942,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn slice(&self, start: uint, end: uint) -> String {\n-        str::from_chars(self.chars.as_slice().slice(start, end)).to_strbuf()\n+        str::from_chars(self.chars.as_slice().slice(start, end)).to_string()\n     }\n }\n "}, {"sha": "5958089a8a47d51ee5714bb8184b77248329e21b", "filename": "src/libregex/re.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -154,7 +154,7 @@ impl Regex {\n         let ast = try!(parse::parse(re));\n         let (prog, names) = Program::new(ast);\n         Ok(Dynamic(Dynamic {\n-            original: re.to_strbuf(),\n+            original: re.to_string(),\n             names: names,\n             prog: prog,\n         }))\n@@ -539,8 +539,8 @@ enum NamesIter<'a> {\n impl<'a> Iterator<Option<String>> for NamesIter<'a> {\n     fn next(&mut self) -> Option<Option<String>> {\n         match *self {\n-            NamesIterNative(ref mut i) => i.next().map(|x| x.map(|s| s.to_strbuf())),\n-            NamesIterDynamic(ref mut i) => i.next().map(|x| x.as_ref().map(|s| s.to_strbuf())),\n+            NamesIterNative(ref mut i) => i.next().map(|x| x.map(|s| s.to_string())),\n+            NamesIterDynamic(ref mut i) => i.next().map(|x| x.as_ref().map(|s| s.to_string())),\n         }\n     }\n }\n@@ -764,8 +764,8 @@ impl<'t> Captures<'t> {\n             format_strbuf!(\"{}{}\",\n                            pre,\n                            match from_str::<uint>(name.as_slice()) {\n-                None => self.name(name).to_strbuf(),\n-                Some(i) => self.at(i).to_strbuf(),\n+                None => self.name(name).to_string(),\n+                Some(i) => self.at(i).to_string(),\n             })\n         });\n         let re = Regex::new(r\"\\$\\$\").unwrap();"}, {"sha": "8dc6484a13629c02d1535bf4990c3324a2e068cd", "filename": "src/libregex/test/bench.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibregex%2Ftest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibregex%2Ftest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fbench.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -161,7 +161,7 @@ fn gen_text(n: uint) -> String {\n             *b = '\\n' as u8\n         }\n     }\n-    str::from_utf8(bytes.as_slice()).unwrap().to_strbuf()\n+    str::from_utf8(bytes.as_slice()).unwrap().to_string()\n }\n \n throughput!(easy0_32, easy0(), 32)"}, {"sha": "71e3d06cf967c9e72c3a27085a4d7518eb30ccc0", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -97,7 +97,7 @@ fn native(cx: &mut ExtCtxt, sp: codemap::Span, tts: &[ast::TokenTree])\n \n     let mut gen = NfaGen {\n         cx: &*cx, sp: sp, prog: prog,\n-        names: re.names_iter().collect(), original: re.as_str().to_strbuf(),\n+        names: re.names_iter().collect(), original: re.as_str().to_string(),\n     };\n     MacExpr::new(gen.code())\n }\n@@ -611,7 +611,7 @@ fn parse(cx: &mut ExtCtxt, tts: &[ast::TokenTree]) -> Option<String> {\n     let regex = match entry.node {\n         ast::ExprLit(lit) => {\n             match lit.node {\n-                ast::LitStr(ref s, _) => s.to_str().to_strbuf(),\n+                ast::LitStr(ref s, _) => s.to_str().to_string(),\n                 _ => {\n                     cx.span_err(entry.span, format!(\n                         \"expected string literal but got `{}`\","}, {"sha": "82cda6f13f108d183905b400141d1e2447827c2e", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -139,7 +139,7 @@ impl<'a> Archive<'a> {\n         let output = str::from_utf8(output.output.as_slice()).unwrap();\n         // use lines_any because windows delimits output with `\\r\\n` instead of\n         // just `\\n`\n-        output.lines_any().map(|s| s.to_strbuf()).collect()\n+        output.lines_any().map(|s| s.to_string()).collect()\n     }\n \n     fn add_archive(&mut self, archive: &Path, name: &str,"}, {"sha": "e5e8126ace1841087957b8e79b0ac02470b7cbc5", "filename": "src/librustc/back/arm.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fback%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fback%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farm.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -15,55 +15,55 @@ use syntax::abi;\n \n pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs::t {\n     let cc_args = if target_triple.as_slice().contains(\"thumb\") {\n-        vec!(\"-mthumb\".to_strbuf())\n+        vec!(\"-mthumb\".to_string())\n     } else {\n-        vec!(\"-marm\".to_strbuf())\n+        vec!(\"-marm\".to_string())\n     };\n     return target_strs::t {\n-        module_asm: \"\".to_strbuf(),\n+        module_asm: \"\".to_string(),\n \n         meta_sect_name:\n-            meta_section_name(cfg_os_to_meta_os(target_os)).to_strbuf(),\n+            meta_section_name(cfg_os_to_meta_os(target_os)).to_string(),\n \n         data_layout: match target_os {\n           abi::OsMacos => {\n             \"e-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_strbuf()\n+                -a0:0:64-n32\".to_string()\n           }\n \n           abi::OsWin32 => {\n             \"e-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_strbuf()\n+                -a0:0:64-n32\".to_string()\n           }\n \n           abi::OsLinux => {\n             \"e-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_strbuf()\n+                -a0:0:64-n32\".to_string()\n           }\n \n           abi::OsAndroid => {\n             \"e-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_strbuf()\n+                -a0:0:64-n32\".to_string()\n           }\n \n           abi::OsFreebsd => {\n             \"e-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_strbuf()\n+                -a0:0:64-n32\".to_string()\n           }\n         },\n "}, {"sha": "2baf8c2469728c531917dda82590353591acb83c", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -81,7 +81,7 @@ pub fn WriteOutputFile(\n             let result = llvm::LLVMRustWriteOutputFile(\n                     target, pm, m, output, file_type);\n             if !result {\n-                llvm_err(sess, \"could not write output\".to_strbuf());\n+                llvm_err(sess, \"could not write output\".to_string());\n             }\n         })\n     }\n@@ -554,7 +554,7 @@ pub fn crate_id_hash(crate_id: &CrateId) -> String {\n     // not by path.\n     let mut s = Sha256::new();\n     s.input_str(crate_id.short_name_with_version().as_slice());\n-    truncated_hash_result(&mut s).as_slice().slice_to(8).to_strbuf()\n+    truncated_hash_result(&mut s).as_slice().slice_to(8).to_string()\n }\n \n // FIXME (#9639): This needs to handle non-utf8 `out_filestem` values\n@@ -570,7 +570,7 @@ pub fn build_link_meta(krate: &ast::Crate, out_filestem: &str) -> LinkMeta {\n fn truncated_hash_result(symbol_hasher: &mut Sha256) -> String {\n     let output = symbol_hasher.result_bytes();\n     // 64 bits should be enough to avoid collisions.\n-    output.slice_to(8).to_hex().to_strbuf()\n+    output.slice_to(8).to_hex().to_string()\n }\n \n \n@@ -597,7 +597,7 @@ fn symbol_hash(tcx: &ty::ctxt,\n \n fn get_symbol_hash(ccx: &CrateContext, t: ty::t) -> String {\n     match ccx.type_hashcodes.borrow().find(&t) {\n-        Some(h) => return h.to_strbuf(),\n+        Some(h) => return h.to_string(),\n         None => {}\n     }\n \n@@ -649,7 +649,7 @@ pub fn sanitize(s: &str) -> String {\n     if result.len() > 0u &&\n         result.as_slice()[0] != '_' as u8 &&\n         ! char::is_XID_start(result.as_slice()[0] as char) {\n-        return format!(\"_{}\", result.as_slice()).to_strbuf();\n+        return format!(\"_{}\", result.as_slice()).to_string();\n     }\n \n     return result;\n@@ -703,7 +703,7 @@ pub fn exported_name(path: PathElems, hash: &str, vers: &str) -> String {\n     let vers = if vers.len() > 0 && !char::is_XID_start(vers.char_at(0)) {\n         format!(\"v{}\", vers)\n     } else {\n-        vers.to_owned()\n+        vers.to_string()\n     };\n \n     mangle(path, Some(hash), Some(vers.as_slice()))\n@@ -759,7 +759,7 @@ pub fn output_lib_filename(id: &CrateId) -> String {\n \n pub fn get_cc_prog(sess: &Session) -> String {\n     match sess.opts.cg.linker {\n-        Some(ref linker) => return linker.to_strbuf(),\n+        Some(ref linker) => return linker.to_string(),\n         None => {}\n     }\n \n@@ -770,13 +770,13 @@ pub fn get_cc_prog(sess: &Session) -> String {\n     match sess.targ_cfg.os {\n         abi::OsWin32 => \"gcc\",\n         _ => \"cc\",\n-    }.to_strbuf()\n+    }.to_string()\n }\n \n pub fn get_ar_prog(sess: &Session) -> String {\n     match sess.opts.cg.ar {\n         Some(ref ar) => (*ar).clone(),\n-        None => \"ar\".to_strbuf()\n+        None => \"ar\".to_string()\n     }\n }\n "}, {"sha": "9f640a2c9cbe0eae2974c07b081cabc6610cc2bf", "filename": "src/librustc/back/mips.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fback%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fback%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fmips.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -15,50 +15,50 @@ use syntax::abi;\n \n pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs::t {\n     return target_strs::t {\n-        module_asm: \"\".to_strbuf(),\n+        module_asm: \"\".to_string(),\n \n         meta_sect_name:\n-            meta_section_name(cfg_os_to_meta_os(target_os)).to_strbuf(),\n+            meta_section_name(cfg_os_to_meta_os(target_os)).to_string(),\n \n         data_layout: match target_os {\n           abi::OsMacos => {\n             \"E-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_strbuf()\n+                -a0:0:64-n32\".to_string()\n           }\n \n           abi::OsWin32 => {\n             \"E-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_strbuf()\n+                -a0:0:64-n32\".to_string()\n           }\n \n           abi::OsLinux => {\n             \"E-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_strbuf()\n+                -a0:0:64-n32\".to_string()\n           }\n \n           abi::OsAndroid => {\n             \"E-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_strbuf()\n+                -a0:0:64-n32\".to_string()\n           }\n \n           abi::OsFreebsd => {\n             \"E-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_strbuf()\n+                -a0:0:64-n32\".to_string()\n           }\n         },\n "}, {"sha": "3cee832227817047a47e318157641262f6c3fe41", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -33,9 +33,9 @@ pub fn get_rpath_flags(sess: &Session, out_filename: &Path) -> Vec<String> {\n     let mut flags = Vec::new();\n \n     if sess.targ_cfg.os == abi::OsFreebsd {\n-        flags.push_all([\"-Wl,-rpath,/usr/local/lib/gcc46\".to_strbuf(),\n-                        \"-Wl,-rpath,/usr/local/lib/gcc44\".to_strbuf(),\n-                        \"-Wl,-z,origin\".to_strbuf()]);\n+        flags.push_all([\"-Wl,-rpath,/usr/local/lib/gcc46\".to_string(),\n+                        \"-Wl,-rpath,/usr/local/lib/gcc44\".to_string(),\n+                        \"-Wl,-z,origin\".to_string()]);\n     }\n \n     debug!(\"preparing the RPATH!\");\n@@ -145,7 +145,7 @@ pub fn get_install_prefix_rpath(sysroot: &Path, target_triple: &str) -> String {\n     path.push(&tlib);\n     let path = os::make_absolute(&path);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    path.as_str().expect(\"non-utf8 component in rpath\").to_strbuf()\n+    path.as_str().expect(\"non-utf8 component in rpath\").to_string()\n }\n \n pub fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {\n@@ -169,12 +169,12 @@ mod test {\n     #[test]\n     fn test_rpaths_to_flags() {\n         let flags = rpaths_to_flags([\n-            \"path1\".to_strbuf(),\n-            \"path2\".to_strbuf()\n+            \"path1\".to_string(),\n+            \"path2\".to_string()\n         ]);\n         assert_eq!(flags,\n-                   vec!(\"-Wl,-rpath,path1\".to_strbuf(),\n-                        \"-Wl,-rpath,path2\".to_strbuf()));\n+                   vec!(\"-Wl,-rpath,path1\".to_string(),\n+                        \"-Wl,-rpath,path2\".to_string()));\n     }\n \n     #[test]\n@@ -201,35 +201,35 @@ mod test {\n     #[test]\n     fn test_minimize1() {\n         let res = minimize_rpaths([\n-            \"rpath1\".to_strbuf(),\n-            \"rpath2\".to_strbuf(),\n-            \"rpath1\".to_strbuf()\n+            \"rpath1\".to_string(),\n+            \"rpath2\".to_string(),\n+            \"rpath1\".to_string()\n         ]);\n         assert!(res.as_slice() == [\n-            \"rpath1\".to_strbuf(),\n-            \"rpath2\".to_strbuf()\n+            \"rpath1\".to_string(),\n+            \"rpath2\".to_string()\n         ]);\n     }\n \n     #[test]\n     fn test_minimize2() {\n         let res = minimize_rpaths([\n-            \"1a\".to_strbuf(),\n-            \"2\".to_strbuf(),\n-            \"2\".to_strbuf(),\n-            \"1a\".to_strbuf(),\n-            \"4a\".to_strbuf(),\n-            \"1a\".to_strbuf(),\n-            \"2\".to_strbuf(),\n-            \"3\".to_strbuf(),\n-            \"4a\".to_strbuf(),\n-            \"3\".to_strbuf()\n+            \"1a\".to_string(),\n+            \"2\".to_string(),\n+            \"2\".to_string(),\n+            \"1a\".to_string(),\n+            \"4a\".to_string(),\n+            \"1a\".to_string(),\n+            \"2\".to_string(),\n+            \"3\".to_string(),\n+            \"4a\".to_string(),\n+            \"3\".to_string()\n         ]);\n         assert!(res.as_slice() == [\n-            \"1a\".to_strbuf(),\n-            \"2\".to_strbuf(),\n-            \"4a\".to_strbuf(),\n-            \"3\".to_strbuf()\n+            \"1a\".to_string(),\n+            \"2\".to_string(),\n+            \"4a\".to_string(),\n+            \"3\".to_string()\n         ]);\n     }\n "}, {"sha": "9fd829ab901f62a85e08b6309be9eb9db9fd35b2", "filename": "src/librustc/back/svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fback%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fback%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fsvh.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -61,7 +61,7 @@ pub struct Svh {\n impl Svh {\n     pub fn new(hash: &str) -> Svh {\n         assert!(hash.len() == 16);\n-        Svh { hash: hash.to_strbuf() }\n+        Svh { hash: hash.to_string() }\n     }\n \n     pub fn as_str<'a>(&'a self) -> &'a str {"}, {"sha": "3ef013d47c91dc9837df7bc2e9a9926b407a0889", "filename": "src/librustc/back/x86.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -17,38 +17,38 @@ use syntax::abi;\n pub fn get_target_strs(target_triple: String, target_os: abi::Os)\n                        -> target_strs::t {\n     return target_strs::t {\n-        module_asm: \"\".to_strbuf(),\n+        module_asm: \"\".to_string(),\n \n         meta_sect_name:\n-            meta_section_name(cfg_os_to_meta_os(target_os)).to_strbuf(),\n+            meta_section_name(cfg_os_to_meta_os(target_os)).to_string(),\n \n         data_layout: match target_os {\n           abi::OsMacos => {\n             \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16\\\n                 -i32:32:32-i64:32:64\\\n                 -f32:32:32-f64:32:64-v64:64:64\\\n                 -v128:128:128-a0:0:64-f80:128:128\\\n-                -n8:16:32\".to_strbuf()\n+                -n8:16:32\".to_string()\n           }\n \n           abi::OsWin32 => {\n-            \"e-p:32:32-f64:64:64-i64:64:64-f80:32:32-n8:16:32\".to_strbuf()\n+            \"e-p:32:32-f64:64:64-i64:64:64-f80:32:32-n8:16:32\".to_string()\n           }\n \n           abi::OsLinux => {\n-            \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\".to_strbuf()\n+            \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\".to_string()\n           }\n           abi::OsAndroid => {\n-            \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\".to_strbuf()\n+            \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\".to_string()\n           }\n \n           abi::OsFreebsd => {\n-            \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\".to_strbuf()\n+            \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\".to_string()\n           }\n         },\n \n         target_triple: target_triple,\n \n-        cc_args: vec!(\"-m32\".to_strbuf()),\n+        cc_args: vec!(\"-m32\".to_string()),\n     };\n }"}, {"sha": "80dd2b2c516294fa2d4e6b0d8b3713470356470f", "filename": "src/librustc/back/x86_64.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fback%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fback%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86_64.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -16,45 +16,45 @@ use syntax::abi;\n \n pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs::t {\n     return target_strs::t {\n-        module_asm: \"\".to_strbuf(),\n+        module_asm: \"\".to_string(),\n \n         meta_sect_name:\n-            meta_section_name(cfg_os_to_meta_os(target_os)).to_strbuf(),\n+            meta_section_name(cfg_os_to_meta_os(target_os)).to_string(),\n \n         data_layout: match target_os {\n           abi::OsMacos => {\n             \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n                 f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n-                s0:64:64-f80:128:128-n8:16:32:64\".to_strbuf()\n+                s0:64:64-f80:128:128-n8:16:32:64\".to_string()\n           }\n \n           abi::OsWin32 => {\n             // FIXME: Test this. Copied from linux (#2398)\n             \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n                 f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n-                s0:64:64-f80:128:128-n8:16:32:64-S128\".to_strbuf()\n+                s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string()\n           }\n \n           abi::OsLinux => {\n             \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n                 f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n-                s0:64:64-f80:128:128-n8:16:32:64-S128\".to_strbuf()\n+                s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string()\n           }\n           abi::OsAndroid => {\n             \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n                 f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n-                s0:64:64-f80:128:128-n8:16:32:64-S128\".to_strbuf()\n+                s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string()\n           }\n \n           abi::OsFreebsd => {\n             \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n                 f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n-                s0:64:64-f80:128:128-n8:16:32:64-S128\".to_strbuf()\n+                s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string()\n           }\n         },\n \n         target_triple: target_triple,\n \n-        cc_args: vec!(\"-m64\".to_strbuf()),\n+        cc_args: vec!(\"-m64\".to_string()),\n     };\n }"}, {"sha": "16965bfa67fa8386cfda4952b9d217d057c7b298", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -107,7 +107,7 @@ pub fn basic_options() -> Options {\n         output_types: Vec::new(),\n         addl_lib_search_paths: RefCell::new(HashSet::new()),\n         maybe_sysroot: None,\n-        target_triple: driver::host_triple().to_strbuf(),\n+        target_triple: driver::host_triple().to_string(),\n         cfg: Vec::new(),\n         test: false,\n         parse_only: false,\n@@ -252,14 +252,14 @@ macro_rules! cgoptions(\n \n         fn parse_opt_string(slot: &mut Option<String>, v: Option<&str>) -> bool {\n             match v {\n-                Some(s) => { *slot = Some(s.to_strbuf()); true },\n+                Some(s) => { *slot = Some(s.to_string()); true },\n                 None => false,\n             }\n         }\n \n         fn parse_string(slot: &mut String, v: Option<&str>) -> bool {\n             match v {\n-                Some(s) => { *slot = s.to_strbuf(); true },\n+                Some(s) => { *slot = s.to_string(); true },\n                 None => false,\n             }\n         }\n@@ -269,7 +269,7 @@ macro_rules! cgoptions(\n             match v {\n                 Some(s) => {\n                     for s in s.words() {\n-                        slot.push(s.to_strbuf());\n+                        slot.push(s.to_string());\n                     }\n                     true\n                 },\n@@ -287,9 +287,9 @@ cgoptions!(\n         \"system linker to link outputs with\"),\n     link_args: Vec<String> = (Vec::new(), parse_list,\n         \"extra arguments to pass to the linker (space separated)\"),\n-    target_cpu: String = (\"generic\".to_strbuf(), parse_string,\n+    target_cpu: String = (\"generic\".to_string(), parse_string,\n         \"select target processor (llc -mcpu=help for details)\"),\n-    target_feature: String = (\"\".to_strbuf(), parse_string,\n+    target_feature: String = (\"\".to_string(), parse_string,\n         \"target specific attributes (llc -mattr=help for details)\"),\n     passes: Vec<String> = (Vec::new(), parse_list,\n         \"a list of extra LLVM passes to run (space separated)\"),\n@@ -311,7 +311,7 @@ cgoptions!(\n         \"prefer dynamic linking to static linking\"),\n     no_integrated_as: bool = (false, parse_bool,\n         \"use an external assembler rather than LLVM's integrated one\"),\n-    relocation_model: String = (\"pic\".to_strbuf(), parse_string,\n+    relocation_model: String = (\"pic\".to_string(), parse_string,\n          \"choose the relocation model to use (llc -relocation-model for details)\"),\n )\n \n@@ -557,8 +557,8 @@ pub fn optgroups() -> Vec<getopts::OptGroup> {\n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n fn parse_cfgspecs(cfgspecs: Vec<String> ) -> ast::CrateConfig {\n     cfgspecs.move_iter().map(|s| {\n-        parse::parse_meta_from_source_str(\"cfgspec\".to_strbuf(),\n-                                          s.to_strbuf(),\n+        parse::parse_meta_from_source_str(\"cfgspec\".to_string(),\n+                                          s.to_string(),\n                                           Vec::new(),\n                                           &parse::new_parse_sess())\n     }).collect::<ast::CrateConfig>()\n@@ -602,7 +602,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                            .collect::<Vec<_>>()\n                            .append(matches.opt_strs(level_name).as_slice());\n         for lint_name in flags.iter() {\n-            let lint_name = lint_name.replace(\"-\", \"_\").into_strbuf();\n+            let lint_name = lint_name.replace(\"-\", \"_\").into_string();\n             match lint_dict.find_equiv(&lint_name) {\n               None => {\n                 early_error(format!(\"unknown {} flag: {}\",\n@@ -667,8 +667,8 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| Path::new(m));\n     let target = match matches.opt_str(\"target\") {\n-        Some(supplied_target) => supplied_target.to_strbuf(),\n-        None => driver::host_triple().to_strbuf(),\n+        Some(supplied_target) => supplied_target.to_string(),\n+        None => driver::host_triple().to_string(),\n     };\n     let opt_level = {\n         if (debugging_opts & NO_OPT) != 0 {\n@@ -723,7 +723,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let cfg = parse_cfgspecs(matches.opt_strs(\"cfg\")\n                                     .move_iter()\n-                                    .map(|x| x.to_strbuf())\n+                                    .map(|x| x.to_string())\n                                     .collect());\n     let test = matches.opt_present(\"test\");\n     let write_dependency_info = (matches.opt_present(\"dep-info\"),\n@@ -787,7 +787,7 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test() {\n         let matches =\n-            &match getopts([\"--test\".to_strbuf()], optgroups().as_slice()) {\n+            &match getopts([\"--test\".to_string()], optgroups().as_slice()) {\n               Ok(m) => m,\n               Err(f) => fail!(\"test_switch_implies_cfg_test: {}\", f.to_err_msg())\n             };\n@@ -802,7 +802,7 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n-            &match getopts([\"--test\".to_strbuf(), \"--cfg=test\".to_strbuf()],\n+            &match getopts([\"--test\".to_string(), \"--cfg=test\".to_string()],\n                            optgroups().as_slice()) {\n               Ok(m) => m,\n               Err(f) => {"}, {"sha": "bc0d8e2f75c1579c4ec6e7f24b2da07920f6ffad", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -106,13 +106,13 @@ pub fn compile_input(sess: Session,\n  * (e.g. source from stdin or a string)\n  */\n pub fn anon_src() -> String {\n-    \"<anon>\".to_strbuf()\n+    \"<anon>\".to_string()\n }\n \n pub fn source_name(input: &Input) -> String {\n     match *input {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        FileInput(ref ifile) => ifile.as_str().unwrap().to_strbuf(),\n+        FileInput(ref ifile) => ifile.as_str().unwrap().to_string(),\n         StrInput(_) => anon_src()\n     }\n }\n@@ -127,8 +127,8 @@ pub enum Input {\n impl Input {\n     fn filestem(&self) -> String {\n         match *self {\n-            FileInput(ref ifile) => ifile.filestem_str().unwrap().to_strbuf(),\n-            StrInput(_) => \"rust_out\".to_strbuf(),\n+            FileInput(ref ifile) => ifile.filestem_str().unwrap().to_string(),\n+            StrInput(_) => \"rust_out\".to_string(),\n         }\n     }\n }\n@@ -142,8 +142,8 @@ pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n                 parse::parse_crate_from_file(&(*file), cfg.clone(), &sess.parse_sess)\n             }\n             StrInput(ref src) => {\n-                parse::parse_crate_from_source_str(anon_src().to_strbuf(),\n-                                                   src.to_strbuf(),\n+                parse::parse_crate_from_source_str(anon_src().to_string(),\n+                                                   src.to_string(),\n                                                    cfg.clone(),\n                                                    &sess.parse_sess)\n             }\n@@ -497,7 +497,7 @@ fn write_out_deps(sess: &Session,\n         // write Makefile-compatible dependency rules\n         let files: Vec<String> = sess.codemap().files.borrow()\n                                    .iter().filter(|fmap| fmap.is_real_file())\n-                                   .map(|fmap| fmap.name.to_strbuf())\n+                                   .map(|fmap| fmap.name.to_string())\n                                    .collect();\n         let mut file = try!(io::File::create(&deps_filename));\n         for path in out_filenames.iter() {\n@@ -533,20 +533,20 @@ impl pprust::PpAnn for IdentifiedAnnotation {\n         match node {\n             pprust::NodeItem(item) => {\n                 try!(pp::space(&mut s.s));\n-                s.synth_comment(item.id.to_str().to_strbuf())\n+                s.synth_comment(item.id.to_str().to_string())\n             }\n             pprust::NodeBlock(blk) => {\n                 try!(pp::space(&mut s.s));\n-                s.synth_comment((format!(\"block {}\", blk.id)).to_strbuf())\n+                s.synth_comment((format!(\"block {}\", blk.id)).to_string())\n             }\n             pprust::NodeExpr(expr) => {\n                 try!(pp::space(&mut s.s));\n-                try!(s.synth_comment(expr.id.to_str().to_strbuf()));\n+                try!(s.synth_comment(expr.id.to_str().to_string()));\n                 s.pclose()\n             }\n             pprust::NodePat(pat) => {\n                 try!(pp::space(&mut s.s));\n-                s.synth_comment((format!(\"pat {}\", pat.id)).to_strbuf())\n+                s.synth_comment((format!(\"pat {}\", pat.id)).to_string())\n             }\n         }\n     }\n@@ -629,7 +629,7 @@ pub fn pretty_print_input(sess: Session,\n             pprust::print_crate(sess.codemap(),\n                                 sess.diagnostic(),\n                                 &krate,\n-                                src_name.to_strbuf(),\n+                                src_name.to_string(),\n                                 &mut rdr,\n                                 out,\n                                 &IdentifiedAnnotation,\n@@ -644,7 +644,7 @@ pub fn pretty_print_input(sess: Session,\n             pprust::print_crate(annotation.analysis.ty_cx.sess.codemap(),\n                                 annotation.analysis.ty_cx.sess.diagnostic(),\n                                 &krate,\n-                                src_name.to_strbuf(),\n+                                src_name.to_string(),\n                                 &mut rdr,\n                                 out,\n                                 &annotation,\n@@ -677,7 +677,7 @@ pub fn pretty_print_input(sess: Session,\n             pprust::print_crate(sess.codemap(),\n                                 sess.diagnostic(),\n                                 &krate,\n-                                src_name.to_strbuf(),\n+                                src_name.to_string(),\n                                 &mut rdr,\n                                 out,\n                                 &pprust::NoAnn,\n@@ -694,7 +694,7 @@ fn print_flowgraph<W:io::Writer>(analysis: CrateAnalysis,\n     let cfg = cfg::CFG::new(ty_cx, block);\n     let lcfg = LabelledCFG { ast_map: &ty_cx.map,\n                              cfg: &cfg,\n-                             name: format!(\"block{}\", block.id).to_strbuf(), };\n+                             name: format!(\"block{}\", block.id).to_string(), };\n     debug!(\"cfg: {:?}\", cfg);\n     let r = dot::render(&lcfg, &mut out);\n     return expand_err_details(r);\n@@ -705,7 +705,7 @@ fn print_flowgraph<W:io::Writer>(analysis: CrateAnalysis,\n             let m = \"graphviz::render failed\";\n             io::IoError {\n                 detail: Some(match orig_detail {\n-                    None => m.into_strbuf(),\n+                    None => m.into_string(),\n                     Some(d) => format_strbuf!(\"{}: {}\", m, d)\n                 }),\n                 ..ioerr\n@@ -738,15 +738,15 @@ pub fn collect_crate_types(session: &Session,\n                                      ast::CRATE_NODE_ID,\n                                      a.span,\n                                      \"invalid `crate_type` \\\n-                                      value\".to_strbuf());\n+                                      value\".to_string());\n                     None\n                 }\n                 _ => {\n                     session.add_lint(lint::UnknownCrateType,\n                                      ast::CRATE_NODE_ID,\n                                      a.span,\n                                      \"`crate_type` requires a \\\n-                                      value\".to_strbuf());\n+                                      value\".to_string());\n                     None\n                 }\n             }\n@@ -832,7 +832,7 @@ pub fn build_output_filenames(input: &Input,\n             let crateid = attr::find_crateid(attrs);\n             match crateid {\n                 None => {}\n-                Some(crateid) => stem = crateid.name.to_strbuf(),\n+                Some(crateid) => stem = crateid.name.to_string(),\n             }\n             OutputFilenames {\n                 out_directory: dirpath,\n@@ -854,7 +854,7 @@ pub fn build_output_filenames(input: &Input,\n             }\n             OutputFilenames {\n                 out_directory: out_file.dir_path(),\n-                out_filestem: out_file.filestem_str().unwrap().to_strbuf(),\n+                out_filestem: out_file.filestem_str().unwrap().to_string(),\n                 single_output_file: ofile,\n             }\n         }"}, {"sha": "04bc46e5dfc0dfe20cc7bb43774e2d19a8845cb0", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -57,7 +57,7 @@ fn run_compiler(args: &[String]) {\n             if ifile == \"-\" {\n                 let contents = io::stdin().read_to_end().unwrap();\n                 let src = str::from_utf8(contents.as_slice()).unwrap()\n-                                                             .to_strbuf();\n+                                                             .to_string();\n                 (StrInput(src), None)\n             } else {\n                 (FileInput(Path::new(ifile)), Some(Path::new(ifile)))\n@@ -84,7 +84,7 @@ fn run_compiler(args: &[String]) {\n     }\n \n     let r = matches.opt_strs(\"Z\");\n-    if r.contains(&(\"ls\".to_strbuf())) {\n+    if r.contains(&(\"ls\".to_string())) {\n         match input {\n             FileInput(ref ifile) => {\n                 let mut stdout = io::stdout();\n@@ -233,7 +233,7 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n         return None;\n     }\n \n-    if cg_flags.contains(&\"passes=list\".to_strbuf()) {\n+    if cg_flags.contains(&\"passes=list\".to_string()) {\n         unsafe { ::lib::llvm::llvm::LLVMRustPrintPasses(); }\n         return None;\n     }\n@@ -332,8 +332,8 @@ fn parse_crate_attrs(sess: &Session, input: &Input) ->\n         }\n         StrInput(ref src) => {\n             parse::parse_crate_attrs_from_source_str(\n-                driver::anon_src().to_strbuf(),\n-                src.to_strbuf(),\n+                driver::anon_src().to_string(),\n+                src.to_string(),\n                 Vec::new(),\n                 &sess.parse_sess)\n         }\n@@ -399,10 +399,10 @@ fn monitor(f: proc():Send) {\n                 }\n \n                 let xs = [\n-                    \"the compiler hit an unexpected failure path. this is a bug.\".to_owned(),\n+                    \"the compiler hit an unexpected failure path. this is a bug.\".to_string(),\n                     format!(\"we would appreciate a bug report: {}\",\n                             BUG_REPORT_URL),\n-                    \"run with `RUST_BACKTRACE=1` for a backtrace\".to_owned(),\n+                    \"run with `RUST_BACKTRACE=1` for a backtrace\".to_string(),\n                 ];\n                 for note in xs.iter() {\n                     emitter.emit(None, note.as_slice(), diagnostic::Note)"}, {"sha": "25f0dc808c849f62ca1da0391bef7f2e78a04c29", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -361,7 +361,7 @@ pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n                             sess.add_lint(lint::UnknownFeatures,\n                                           ast::CRATE_NODE_ID,\n                                           mi.span,\n-                                          \"unknown feature\".to_strbuf());\n+                                          \"unknown feature\".to_string());\n                         }\n                     }\n                 }"}, {"sha": "b21f3c2a019322ea5d74265b9bc720ae0e1ec052", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -168,7 +168,7 @@ fn generate_test_harness(sess: &Session, krate: ast::Crate)\n     cx.ext_cx.bt_push(ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n-            name: \"test\".to_strbuf(),\n+            name: \"test\".to_string(),\n             format: MacroAttribute,\n             span: None\n         }"}, {"sha": "2459c1d53c0c46bca502e6c59aff7121774b9b7f", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -123,7 +123,7 @@ pub mod lib {\n \n pub fn main() {\n     let args = std::os::args().iter()\n-                              .map(|x| x.to_strbuf())\n+                              .map(|x| x.to_string())\n                               .collect::<Vec<_>>();\n     std::os::set_exit_status(driver::main_args(args.as_slice()));\n }"}, {"sha": "781720277a980577ec3615e90d7ad1fcc768f643", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -1873,7 +1873,7 @@ impl TypeNames {\n     }\n \n     pub fn associate_type(&self, s: &str, t: &Type) {\n-        assert!(self.named_types.borrow_mut().insert(s.to_strbuf(),\n+        assert!(self.named_types.borrow_mut().insert(s.to_string(),\n                                                      t.to_ref()));\n     }\n \n@@ -1886,21 +1886,21 @@ impl TypeNames {\n             let s = llvm::LLVMTypeToString(ty.to_ref());\n             let ret = from_c_str(s);\n             free(s as *mut c_void);\n-            ret.to_strbuf()\n+            ret.to_string()\n         }\n     }\n \n     pub fn types_to_str(&self, tys: &[Type]) -> String {\n         let strs: Vec<String> = tys.iter().map(|t| self.type_to_str(*t)).collect();\n-        format_strbuf!(\"[{}]\", strs.connect(\",\").to_strbuf())\n+        format_strbuf!(\"[{}]\", strs.connect(\",\").to_string())\n     }\n \n     pub fn val_to_str(&self, val: ValueRef) -> String {\n         unsafe {\n             let s = llvm::LLVMValueToString(val);\n             let ret = from_c_str(s);\n             free(s as *mut c_void);\n-            ret.to_strbuf()\n+            ret.to_string()\n         }\n     }\n }"}, {"sha": "e613fa7eb76c80a2d9897d9cff0dd76d0e4abafe", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -165,7 +165,7 @@ fn extract_crate_info(e: &Env, i: &ast::ViewItem) -> Option<CrateInfo> {\n                 None => from_str(ident.get().to_str().as_slice()).unwrap()\n             };\n             Some(CrateInfo {\n-                ident: ident.get().to_strbuf(),\n+                ident: ident.get().to_string(),\n                 crate_id: crate_id,\n                 id: id,\n                 should_link: should_link(i),\n@@ -251,7 +251,7 @@ fn visit_item(e: &Env, i: &ast::Item) {\n                         } else {\n                             e.sess\n                              .cstore\n-                             .add_used_library(n.get().to_strbuf(), kind);\n+                             .add_used_library(n.get().to_string(), kind);\n                         }\n                     }\n                     None => {}\n@@ -293,7 +293,7 @@ fn register_crate<'a>(e: &mut Env,\n     // Stash paths for top-most crate locally if necessary.\n     let crate_paths = if root.is_none() {\n         Some(CratePaths {\n-            ident: ident.to_strbuf(),\n+            ident: ident.to_string(),\n             dylib: lib.dylib.clone(),\n             rlib:  lib.rlib.clone(),\n         })\n@@ -308,7 +308,7 @@ fn register_crate<'a>(e: &mut Env,\n     let loader::Library{ dylib, rlib, metadata } = lib;\n \n     let cmeta = Rc::new( cstore::crate_metadata {\n-        name: crate_id.name.to_strbuf(),\n+        name: crate_id.name.to_string(),\n         data: metadata,\n         cnum_map: cnum_map,\n         cnum: cnum,\n@@ -442,11 +442,11 @@ impl<'a> CrateLoader for Loader<'a> {\n         };\n         let macros = decoder::get_exported_macros(library.metadata.as_slice());\n         let registrar = decoder::get_macro_registrar_fn(library.metadata.as_slice()).map(|id| {\n-            decoder::get_symbol(library.metadata.as_slice(), id).to_strbuf()\n+            decoder::get_symbol(library.metadata.as_slice(), id).to_string()\n         });\n         let mc = MacroCrate {\n             lib: library.dylib.clone(),\n-            macros: macros.move_iter().map(|x| x.to_strbuf()).collect(),\n+            macros: macros.move_iter().map(|x| x.to_string()).collect(),\n             registrar_symbol: registrar,\n         };\n         if should_link {"}, {"sha": "781222a3a6e8942c85c161bd296943ad2352f34f", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -211,14 +211,14 @@ pub fn get_field_type(tcx: &ty::ctxt, class_id: ast::DefId,\n                            decoder::maybe_find_item(class_id.node, all_items),\n                            || {\n         (format!(\"get_field_type: class ID {:?} not found\",\n-                 class_id)).to_strbuf()\n+                 class_id)).to_string()\n     });\n     let the_field = expect(tcx.sess.diagnostic(),\n         decoder::maybe_find_item(def.node, class_doc),\n         || {\n             (format!(\"get_field_type: in class {:?}, field ID {:?} not found\",\n                     class_id,\n-                    def)).to_strbuf()\n+                    def)).to_string()\n         });\n     let ty = decoder::item_type(def, the_field, tcx, &*cdata);\n     ty::ty_param_bounds_and_ty {"}, {"sha": "eb1beda898fd51f124dbd719cbdf0dc3c211bf61", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -201,7 +201,7 @@ impl CStore {\n \n     pub fn add_used_link_args(&self, args: &str) {\n         for s in args.split(' ') {\n-            self.used_link_args.borrow_mut().push(s.to_strbuf());\n+            self.used_link_args.borrow_mut().push(s.to_string());\n         }\n     }\n "}, {"sha": "ddd493b2c1354783a6e3d1df8c2858c35f32fcb7", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -186,7 +186,7 @@ fn item_method_sort(item: ebml::Doc) -> char {\n }\n \n fn item_symbol(item: ebml::Doc) -> String {\n-    reader::get_doc(item, tag_items_data_item_symbol).as_str().to_strbuf()\n+    reader::get_doc(item, tag_items_data_item_symbol).as_str().to_string()\n }\n \n fn item_parent_item(d: ebml::Doc) -> Option<ast::DefId> {\n@@ -1095,7 +1095,7 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n     let mut crate_num = 1;\n     fn docstr(doc: ebml::Doc, tag_: uint) -> String {\n         let d = reader::get_doc(doc, tag_);\n-        d.as_str_slice().to_strbuf()\n+        d.as_str_slice().to_string()\n     }\n     reader::tagged_docs(depsdoc, tag_crate_dep, |depdoc| {\n         let crate_id =\n@@ -1145,7 +1145,7 @@ pub fn maybe_get_crate_id(data: &[u8]) -> Option<CrateId> {\n pub fn get_crate_triple(data: &[u8]) -> String {\n     let cratedoc = reader::Doc(data);\n     let triple_doc = reader::maybe_get_doc(cratedoc, tag_crate_triple);\n-    triple_doc.expect(\"No triple in crate\").as_str().to_strbuf()\n+    triple_doc.expect(\"No triple in crate\").as_str().to_string()\n }\n \n pub fn get_crate_id(data: &[u8]) -> CrateId {\n@@ -1247,7 +1247,7 @@ pub fn get_native_libraries(cdata: Cmd)\n         let name_doc = reader::get_doc(lib_doc, tag_native_libraries_name);\n         let kind: cstore::NativeLibaryKind =\n             FromPrimitive::from_u32(reader::doc_as_u32(kind_doc)).unwrap();\n-        let name = name_doc.as_str().to_strbuf();\n+        let name = name_doc.as_str().to_string();\n         result.push((kind, name));\n         true\n     });\n@@ -1264,7 +1264,7 @@ pub fn get_exported_macros(data: &[u8]) -> Vec<String> {\n                                  tag_exported_macros);\n     let mut result = Vec::new();\n     reader::tagged_docs(macros, tag_macro_def, |macro_doc| {\n-        result.push(macro_doc.as_str().to_strbuf());\n+        result.push(macro_doc.as_str().to_string());\n         true\n     });\n     result\n@@ -1316,7 +1316,7 @@ pub fn get_method_arg_names(cdata: Cmd, id: ast::NodeId) -> Vec<String> {\n     match reader::maybe_get_doc(method_doc, tag_method_argument_names) {\n         Some(args_doc) => {\n             reader::tagged_docs(args_doc, tag_method_argument_name, |name_doc| {\n-                ret.push(name_doc.as_str_slice().to_strbuf());\n+                ret.push(name_doc.as_str_slice().to_string());\n                 true\n             });\n         }"}, {"sha": "60562e55ce68776655e33ef3655a6361e9b68d5b", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -1738,7 +1738,7 @@ fn encode_dylib_dependency_formats(ebml_w: &mut Encoder, ecx: &EncodeContext) {\n                 slot.map(|kind| (format!(\"{}:{}\", i + 1, match kind {\n                     cstore::RequireDynamic => \"d\",\n                     cstore::RequireStatic => \"s\",\n-                })).to_strbuf())\n+                })).to_string())\n             }).collect::<Vec<String>>();\n             ebml_w.writer.write(s.connect(\",\").as_bytes());\n         }\n@@ -1909,5 +1909,5 @@ pub fn encoded_ty(tcx: &ty::ctxt, t: ty::t) -> String {\n         tcx: tcx,\n         abbrevs: &RefCell::new(HashMap::new())\n     }, t);\n-    str::from_utf8_owned(Vec::from_slice(wr.get_ref())).unwrap().to_strbuf()\n+    str::from_utf8_owned(Vec::from_slice(wr.get_ref())).unwrap().to_string()\n }"}, {"sha": "c47d4e5d9c2655a436517bb45eded9519379bc1b", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -187,7 +187,7 @@ static PATH_ENTRY_SEPARATOR: &'static str = \":\";\n \n /// Returns RUST_PATH as a string, without default paths added\n pub fn get_rust_path() -> Option<String> {\n-    os::getenv(\"RUST_PATH\").map(|x| x.to_strbuf())\n+    os::getenv(\"RUST_PATH\").map(|x| x.to_string())\n }\n \n /// Returns the value of RUST_PATH, as a list\n@@ -251,26 +251,26 @@ fn find_libdir(sysroot: &Path) -> String {\n \n     #[cfg(target_word_size = \"64\")]\n     fn primary_libdir_name() -> String {\n-        \"lib64\".to_strbuf()\n+        \"lib64\".to_string()\n     }\n \n     #[cfg(target_word_size = \"32\")]\n     fn primary_libdir_name() -> String {\n-        \"lib32\".to_strbuf()\n+        \"lib32\".to_string()\n     }\n \n     fn secondary_libdir_name() -> String {\n-        \"lib\".to_strbuf()\n+        \"lib\".to_string()\n     }\n }\n \n #[cfg(windows)]\n fn find_libdir(_sysroot: &Path) -> String {\n-    \"bin\".to_strbuf()\n+    \"bin\".to_string()\n }\n \n // The name of rustc's own place to organize libraries.\n // Used to be \"rustc\", now the default is \"rustlib\"\n pub fn rustlibdir() -> String {\n-    \"rustlib\".to_strbuf()\n+    \"rustlib\".to_string()\n }"}, {"sha": "5cc8d9f7a1569e91aa9c495883e4c9cea1edf3f5", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -327,13 +327,13 @@ impl<'a> Context<'a> {\n             Some(..) => {} // check the hash\n \n             // hash is irrelevant, no version specified\n-            None => return Some(hash.to_strbuf())\n+            None => return Some(hash.to_string())\n         }\n         debug!(\"matching -- {}, vers ok\", file);\n         // hashes in filenames are prefixes of the \"true hash\"\n         if self.id_hash == hash.as_slice() {\n             debug!(\"matching -- {}, hash ok\", file);\n-            Some(hash.to_strbuf())\n+            Some(hash.to_string())\n         } else {\n             None\n         }\n@@ -423,7 +423,7 @@ impl<'a> Context<'a> {\n             info!(\"Rejecting via crate triple: expected {} got {}\", self.triple, triple);\n             self.rejected_via_triple.push(CrateMismatch {\n                 path: libpath.clone(),\n-                got: triple.to_strbuf()\n+                got: triple.to_string()\n             });\n             return false;\n         }\n@@ -435,7 +435,7 @@ impl<'a> Context<'a> {\n                     info!(\"Rejecting via hash: expected {} got {}\", *myhash, hash);\n                     self.rejected_via_hash.push(CrateMismatch {\n                         path: libpath.clone(),\n-                        got: myhash.as_str().to_strbuf()\n+                        got: myhash.as_str().to_string()\n                     });\n                     false\n                 } else {"}, {"sha": "9fd1fb674501d886db113737fb51df2a43add169", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -451,7 +451,7 @@ fn parse_fn_style(c: char) -> FnStyle {\n fn parse_abi_set(st: &mut PState) -> abi::Abi {\n     assert_eq!(next(st), '[');\n     scan(st, |c| c == ']', |bytes| {\n-        let abi_str = str::from_utf8(bytes).unwrap().to_owned();\n+        let abi_str = str::from_utf8(bytes).unwrap().to_string();\n         abi::lookup(abi_str.as_slice()).expect(abi_str)\n     })\n }"}, {"sha": "052baac78554025094be8d223ca38d3e83f4fba2", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -243,7 +243,7 @@ impl<'a> CheckLoanCtxt<'a> {\n             if restr.loan_path != loan2.loan_path { continue; }\n \n             let old_pronoun = if new_loan.loan_path == old_loan.loan_path {\n-                \"it\".to_strbuf()\n+                \"it\".to_string()\n             } else {\n                 format!(\"`{}`\",\n                         self.bccx.loan_path_to_str(&*old_loan.loan_path))"}, {"sha": "5dd988a82ce42a37b71d1ba9e88617feac1991b9", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -609,7 +609,7 @@ impl<'a> BorrowckCtxt<'a> {\n             }\n             err_out_of_scope(..) => {\n                 let msg = match opt_loan_path(&err.cmt) {\n-                    None => \"borrowed value\".to_strbuf(),\n+                    None => \"borrowed value\".to_string(),\n                     Some(lp) => {\n                         format_strbuf!(\"`{}`\", self.loan_path_to_str(&*lp))\n                     }\n@@ -826,33 +826,33 @@ impl Repr for Loan {\n                  self.kind,\n                  self.gen_scope,\n                  self.kill_scope,\n-                 self.restrictions.repr(tcx))).to_strbuf()\n+                 self.restrictions.repr(tcx))).to_string()\n     }\n }\n \n impl Repr for Restriction {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         (format!(\"Restriction({}, {:x})\",\n                  self.loan_path.repr(tcx),\n-                 self.set.bits as uint)).to_strbuf()\n+                 self.set.bits as uint)).to_string()\n     }\n }\n \n impl Repr for LoanPath {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         match self {\n             &LpVar(id) => {\n-                (format!(\"$({})\", tcx.map.node_to_str(id))).to_strbuf()\n+                (format!(\"$({})\", tcx.map.node_to_str(id))).to_string()\n             }\n \n             &LpExtend(ref lp, _, LpDeref(_)) => {\n-                (format!(\"{}.*\", lp.repr(tcx))).to_strbuf()\n+                (format!(\"{}.*\", lp.repr(tcx))).to_string()\n             }\n \n             &LpExtend(ref lp, _, LpInterior(ref interior)) => {\n                 (format!(\"{}.{}\",\n                          lp.repr(tcx),\n-                         interior.repr(tcx))).to_strbuf()\n+                         interior.repr(tcx))).to_string()\n             }\n         }\n     }"}, {"sha": "c33580d869b15ea7cc7381aa8232b5f0fc6cd9d3", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -43,7 +43,7 @@ fn replace_newline_with_backslash_l(s: String) -> String {\n         if last_two.as_slice() != ['\\\\', 'l'] {\n             s = s.append(\"\\\\l\");\n         }\n-        s.to_strbuf()\n+        s.to_string()\n     } else {\n         s\n     }"}, {"sha": "ffc9ee7ec767a770a4e7bbc33238d273d73d8b01", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -164,8 +164,8 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: Vec<@Pat> ) {\n             match ty::get(ty).sty {\n                 ty::ty_bool => {\n                     match *ctor {\n-                        val(const_bool(true)) => Some(\"true\".to_strbuf()),\n-                        val(const_bool(false)) => Some(\"false\".to_strbuf()),\n+                        val(const_bool(true)) => Some(\"true\".to_string()),\n+                        val(const_bool(false)) => Some(\"false\".to_string()),\n                         _ => None\n                     }\n                 }\n@@ -180,7 +180,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: Vec<@Pat> ) {\n                         Some(v) => {\n                             Some(token::get_ident(v.name).get()\n                                                          .to_str()\n-                                                         .into_strbuf())\n+                                                         .into_string())\n                         }\n                         None => {\n                             fail!(\"check_exhaustive: bad variant in ctor\")\n@@ -201,7 +201,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: Vec<@Pat> ) {\n     };\n     let msg = format_strbuf!(\"non-exhaustive patterns{}\", match ext {\n         Some(ref s) => format_strbuf!(\": {} not covered\", *s),\n-        None => \"\".to_strbuf()\n+        None => \"\".to_string()\n     });\n     cx.tcx.sess.span_err(sp, msg.as_slice());\n }"}, {"sha": "4bf56ad11e3b68644032d9d9a5f62896430ad229", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -134,7 +134,7 @@ impl<'a> Visitor<bool> for CheckStaticVisitor<'a> {\n                         if ty::has_dtor(self.tcx, did) {\n                             self.report_error(e.span,\n                              Some(\"static items are not allowed to have \\\n-                                   destructors\".to_strbuf()));\n+                                   destructors\".to_string()));\n                             return;\n                         }\n                     }"}, {"sha": "d8fe801b395c69aa981e07eb0e13514c43920ee4", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -314,8 +314,8 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n           Ok(const_float(f)) => Ok(const_float(-f)),\n           Ok(const_int(i)) => Ok(const_int(-i)),\n           Ok(const_uint(i)) => Ok(const_uint(-i)),\n-          Ok(const_str(_)) => Err(\"negate on string\".to_strbuf()),\n-          Ok(const_bool(_)) => Err(\"negate on boolean\".to_strbuf()),\n+          Ok(const_str(_)) => Err(\"negate on string\".to_string()),\n+          Ok(const_bool(_)) => Err(\"negate on boolean\".to_string()),\n           ref err => ((*err).clone())\n         }\n       }\n@@ -324,7 +324,7 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n           Ok(const_int(i)) => Ok(const_int(!i)),\n           Ok(const_uint(i)) => Ok(const_uint(!i)),\n           Ok(const_bool(b)) => Ok(const_bool(!b)),\n-          _ => Err(\"not on float or string\".to_strbuf())\n+          _ => Err(\"not on float or string\".to_string())\n         }\n       }\n       ExprBinary(op, a, b) => {\n@@ -343,7 +343,7 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n               BiNe => fromb(a != b),\n               BiGe => fromb(a >= b),\n               BiGt => fromb(a > b),\n-              _ => Err(\"can't do this op on floats\".to_strbuf())\n+              _ => Err(\"can't do this op on floats\".to_string())\n             }\n           }\n           (Ok(const_int(a)), Ok(const_int(b))) => {\n@@ -352,12 +352,12 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n               BiSub => Ok(const_int(a - b)),\n               BiMul => Ok(const_int(a * b)),\n               BiDiv if b == 0 => {\n-                  Err(\"attempted to divide by zero\".to_strbuf())\n+                  Err(\"attempted to divide by zero\".to_string())\n               }\n               BiDiv => Ok(const_int(a / b)),\n               BiRem if b == 0 => {\n                   Err(\"attempted remainder with a divisor of \\\n-                       zero\".to_strbuf())\n+                       zero\".to_string())\n               }\n               BiRem => Ok(const_int(a % b)),\n               BiAnd | BiBitAnd => Ok(const_int(a & b)),\n@@ -379,12 +379,12 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n               BiSub => Ok(const_uint(a - b)),\n               BiMul => Ok(const_uint(a * b)),\n               BiDiv if b == 0 => {\n-                  Err(\"attempted to divide by zero\".to_strbuf())\n+                  Err(\"attempted to divide by zero\".to_string())\n               }\n               BiDiv => Ok(const_uint(a / b)),\n               BiRem if b == 0 => {\n                   Err(\"attempted remainder with a divisor of \\\n-                       zero\".to_strbuf())\n+                       zero\".to_string())\n               }\n               BiRem => Ok(const_uint(a % b)),\n               BiAnd | BiBitAnd => Ok(const_uint(a & b)),\n@@ -405,14 +405,14 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n             match op {\n               BiShl => Ok(const_int(a << b)),\n               BiShr => Ok(const_int(a >> b)),\n-              _ => Err(\"can't do this op on an int and uint\".to_strbuf())\n+              _ => Err(\"can't do this op on an int and uint\".to_string())\n             }\n           }\n           (Ok(const_uint(a)), Ok(const_int(b))) => {\n             match op {\n               BiShl => Ok(const_uint(a << b)),\n               BiShr => Ok(const_uint(a >> b)),\n-              _ => Err(\"can't do this op on a uint and int\".to_strbuf())\n+              _ => Err(\"can't do this op on a uint and int\".to_string())\n             }\n           }\n           (Ok(const_bool(a)), Ok(const_bool(b))) => {\n@@ -424,10 +424,10 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n               BiBitOr => a | b,\n               BiEq => a == b,\n               BiNe => a != b,\n-              _ => return Err(\"can't do this op on bools\".to_strbuf())\n+              _ => return Err(\"can't do this op on bools\".to_string())\n              }))\n           }\n-          _ => Err(\"bad operands for binary\".to_strbuf())\n+          _ => Err(\"bad operands for binary\".to_string())\n         }\n       }\n       ExprCast(base, target_ty) => {\n@@ -452,34 +452,34 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n                             const_uint(u) => Ok(const_float(u as f64)),\n                             const_int(i) => Ok(const_float(i as f64)),\n                             const_float(f) => Ok(const_float(f)),\n-                            _ => Err(\"can't cast float to str\".to_strbuf()),\n+                            _ => Err(\"can't cast float to str\".to_string()),\n                         }\n                     }\n                     ty::ty_uint(_) => {\n                         match val {\n                             const_uint(u) => Ok(const_uint(u)),\n                             const_int(i) => Ok(const_uint(i as u64)),\n                             const_float(f) => Ok(const_uint(f as u64)),\n-                            _ => Err(\"can't cast str to uint\".to_strbuf()),\n+                            _ => Err(\"can't cast str to uint\".to_string()),\n                         }\n                     }\n                     ty::ty_int(_) | ty::ty_bool => {\n                         match val {\n                             const_uint(u) => Ok(const_int(u as i64)),\n                             const_int(i) => Ok(const_int(i)),\n                             const_float(f) => Ok(const_int(f as i64)),\n-                            _ => Err(\"can't cast str to int\".to_strbuf()),\n+                            _ => Err(\"can't cast str to int\".to_string()),\n                         }\n                     }\n-                    _ => Err(\"can't cast this type\".to_strbuf())\n+                    _ => Err(\"can't cast this type\".to_string())\n                 }\n             }\n         }\n       }\n       ExprPath(_) => {\n           match lookup_const(tcx.ty_ctxt(), e) {\n               Some(actual_e) => eval_const_expr_partial(tcx.ty_ctxt(), actual_e),\n-              None => Err(\"non-constant path in constant expr\".to_strbuf())\n+              None => Err(\"non-constant path in constant expr\".to_string())\n           }\n       }\n       ExprLit(lit) => Ok(lit_to_const(lit)),\n@@ -492,7 +492,7 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n             None => Ok(const_int(0i64))\n         }\n       }\n-      _ => Err(\"unsupported constant expr\".to_strbuf())\n+      _ => Err(\"unsupported constant expr\".to_string())\n     }\n }\n "}, {"sha": "91c1c0bcf9fb1605639227c0694b2e0e23c21b5e", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -102,14 +102,14 @@ impl<'a, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, O> {\n             let gens_str = if gens.iter().any(|&u| u != 0) {\n                 format!(\" gen: {}\", bits_to_str(gens))\n             } else {\n-                \"\".to_strbuf()\n+                \"\".to_string()\n             };\n \n             let kills = self.kills.slice(start, end);\n             let kills_str = if kills.iter().any(|&u| u != 0) {\n                 format!(\" kill: {}\", bits_to_str(kills))\n             } else {\n-                \"\".to_strbuf()\n+                \"\".to_string()\n             };\n \n             try!(ps.synth_comment(format_strbuf!(\"id {}: {}{}{}\","}, {"sha": "2b82dd6fd579f6d28b644ee4ae9ac7aff1ded82e", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -587,8 +587,8 @@ fn check_sized(tcx: &ty::ctxt, ty: ty::t, name: String, sp: Span) {\n // Check that any variables in a pattern have types with statically known size.\n fn check_pat(cx: &mut Context, pat: &Pat) {\n     let var_name = match pat.node {\n-        PatWild => Some(\"_\".to_strbuf()),\n-        PatIdent(_, ref path, _) => Some(path_to_str(path).to_strbuf()),\n+        PatWild => Some(\"_\".to_string()),\n+        PatIdent(_, ref path, _) => Some(path_to_str(path).to_string()),\n         _ => None\n     };\n "}, {"sha": "5759a1005f093b20b48f6f41a75ba55caa23967e", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -162,7 +162,7 @@ fn live_node_kind_to_str(lnk: LiveNodeKind, cx: &ty::ctxt) -> String {\n         VarDefNode(s) => {\n             format_strbuf!(\"Var def node [{}]\", cm.span_to_str(s))\n         }\n-        ExitNode => \"Exit node\".to_strbuf(),\n+        ExitNode => \"Exit node\".to_string(),\n     }\n }\n \n@@ -325,9 +325,9 @@ impl<'a> IrMaps<'a> {\n     fn variable_name(&self, var: Variable) -> String {\n         match self.var_kinds.get(var.get()) {\n             &Local(LocalInfo { ident: nm, .. }) | &Arg(_, nm) => {\n-                token::get_ident(nm).get().to_str().to_strbuf()\n+                token::get_ident(nm).get().to_str().to_string()\n             },\n-            &ImplicitRet => \"<implicit-ret>\".to_strbuf()\n+            &ImplicitRet => \"<implicit-ret>\".to_string()\n         }\n     }\n \n@@ -760,7 +760,7 @@ impl<'a> Liveness<'a> {\n             self.write_vars(wr, ln, |idx| self.users.get(idx).writer);\n             write!(wr, \"  precedes {}]\", self.successors.get(ln.get()).to_str());\n         }\n-        str::from_utf8(wr.unwrap().as_slice()).unwrap().to_strbuf()\n+        str::from_utf8(wr.unwrap().as_slice()).unwrap().to_string()\n     }\n \n     fn init_empty(&mut self, ln: LiveNode, succ_ln: LiveNode) {"}, {"sha": "5787657d6396fa58463e7dceb0097a20c479d5a1", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -1096,24 +1096,24 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n     pub fn cmt_to_str(&self, cmt: &cmt_) -> String {\n         match cmt.cat {\n           cat_static_item => {\n-              \"static item\".to_strbuf()\n+              \"static item\".to_string()\n           }\n           cat_copied_upvar(_) => {\n-              \"captured outer variable in a proc\".to_strbuf()\n+              \"captured outer variable in a proc\".to_string()\n           }\n           cat_rvalue(..) => {\n-              \"non-lvalue\".to_strbuf()\n+              \"non-lvalue\".to_string()\n           }\n           cat_local(_) => {\n-              \"local variable\".to_strbuf()\n+              \"local variable\".to_string()\n           }\n           cat_arg(..) => {\n-              \"argument\".to_strbuf()\n+              \"argument\".to_string()\n           }\n           cat_deref(ref base, _, pk) => {\n               match base.cat {\n                   cat_upvar(..) => {\n-                      \"captured outer variable\".to_strbuf()\n+                      \"captured outer variable\".to_string()\n                   }\n                   _ => {\n                       format_strbuf!(\"dereference of `{}`-pointer\",\n@@ -1122,22 +1122,22 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n               }\n           }\n           cat_interior(_, InteriorField(NamedField(_))) => {\n-              \"field\".to_strbuf()\n+              \"field\".to_string()\n           }\n           cat_interior(_, InteriorField(PositionalField(_))) => {\n-              \"anonymous field\".to_strbuf()\n+              \"anonymous field\".to_string()\n           }\n           cat_interior(_, InteriorElement(VecElement)) => {\n-              \"vec content\".to_strbuf()\n+              \"vec content\".to_string()\n           }\n           cat_interior(_, InteriorElement(StrElement)) => {\n-              \"str content\".to_strbuf()\n+              \"str content\".to_string()\n           }\n           cat_interior(_, InteriorElement(OtherElement)) => {\n-              \"indexed content\".to_strbuf()\n+              \"indexed content\".to_string()\n           }\n           cat_upvar(..) => {\n-              \"captured outer variable\".to_strbuf()\n+              \"captured outer variable\".to_string()\n           }\n           cat_discr(ref cmt, _) => {\n             self.cmt_to_str(&**cmt)\n@@ -1303,10 +1303,10 @@ impl Repr for InteriorKind {\n     fn repr(&self, _tcx: &ty::ctxt) -> String {\n         match *self {\n             InteriorField(NamedField(fld)) => {\n-                token::get_name(fld).get().to_str().to_strbuf()\n+                token::get_name(fld).get().to_str().to_string()\n             }\n             InteriorField(PositionalField(i)) => format_strbuf!(\"\\\\#{:?}\", i),\n-            InteriorElement(_) => \"[]\".to_strbuf(),\n+            InteriorElement(_) => \"[]\".to_string(),\n         }\n     }\n }"}, {"sha": "1f2bb643b3cff40f4e1a61bd6d6bbac2ffa13851", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -374,7 +374,7 @@ enum FieldName {\n impl<'a> PrivacyVisitor<'a> {\n     // used when debugging\n     fn nodestr(&self, id: ast::NodeId) -> String {\n-        self.tcx.map.node_to_str(id).to_strbuf()\n+        self.tcx.map.node_to_str(id).to_string()\n     }\n \n     // Determines whether the given definition is public from the point of view\n@@ -1400,7 +1400,7 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n                         lint::VisiblePrivateTypes,\n                         path_id, p.span,\n                         \"private type in exported type \\\n-                         signature\".to_strbuf());\n+                         signature\".to_string());\n                 }\n             }\n             _ => {}"}, {"sha": "1a29cff3cd6ddcc1330f59156c468f571ffa235c", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -2097,9 +2097,9 @@ impl<'a> Resolver<'a> {\n                                         -> String {\n         match subclass {\n             SingleImport(_, source) => {\n-                token::get_ident(source).get().to_strbuf()\n+                token::get_ident(source).get().to_string()\n             }\n-            GlobImport => \"*\".to_strbuf()\n+            GlobImport => \"*\".to_string()\n         }\n     }\n \n@@ -2113,7 +2113,7 @@ impl<'a> Resolver<'a> {\n             (format!(\"{}::{}\",\n                      self.idents_to_str(idents),\n                      self.import_directive_subclass_to_str(\n-                         subclass))).to_strbuf()\n+                         subclass))).to_string()\n         }\n     }\n \n@@ -3314,7 +3314,7 @@ impl<'a> Resolver<'a> {\n                 debug!(\"(computing exports) YES: export '{}' => {:?}\",\n                        name, def_id_of_def(d));\n                 exports2.push(Export2 {\n-                    name: name.get().to_strbuf(),\n+                    name: name.get().to_string(),\n                     def_id: def_id_of_def(d)\n                 });\n             }\n@@ -4591,7 +4591,7 @@ impl<'a> Resolver<'a> {\n                         .add_lint(UnnecessaryQualification,\n                                   id,\n                                   path.span,\n-                                  \"unnecessary qualification\".to_strbuf());\n+                                  \"unnecessary qualification\".to_string());\n                 }\n                 _ => ()\n             }\n@@ -5051,7 +5051,7 @@ impl<'a> Resolver<'a> {\n             *values.get(smallest) <= max_distance &&\n             name != maybes.get(smallest).get() {\n \n-            Some(maybes.get(smallest).get().to_strbuf())\n+            Some(maybes.get(smallest).get().to_string())\n \n         } else {\n             None\n@@ -5145,7 +5145,7 @@ impl<'a> Resolver<'a> {\n                                             // limit search to 5 to reduce the number\n                                             // of stupid suggestions\n                                             self.find_best_match_for_name(wrong_name.as_slice(), 5)\n-                                                                .map_or(\"\".to_strbuf(),\n+                                                                .map_or(\"\".to_string(),\n                                                                         |x| format!(\"`{}`\", x))\n                                         }\n                                         Field =>\n@@ -5426,7 +5426,7 @@ impl<'a> Resolver<'a> {\n                                 .add_lint(UnusedImports,\n                                           id,\n                                           p.span,\n-                                          \"unused import\".to_strbuf());\n+                                          \"unused import\".to_string());\n                         }\n                     },\n                 }\n@@ -5450,7 +5450,7 @@ impl<'a> Resolver<'a> {\n             self.session.add_lint(UnusedImports,\n                                   id,\n                                   span,\n-                                  \"unused import\".to_strbuf());\n+                                  \"unused import\".to_string());\n         }\n \n         let (v_priv, t_priv) = match self.last_private.find(&id) {\n@@ -5518,7 +5518,7 @@ impl<'a> Resolver<'a> {\n         collect_mod(&mut idents, module);\n \n         if idents.len() == 0 {\n-            return \"???\".to_strbuf();\n+            return \"???\".to_string();\n         }\n         self.idents_to_str(idents.move_iter().rev()\n                                  .collect::<Vec<ast::Ident>>()\n@@ -5540,18 +5540,18 @@ impl<'a> Resolver<'a> {\n         for (&name, import_resolution) in import_resolutions.iter() {\n             let value_repr;\n             match import_resolution.target_for_namespace(ValueNS) {\n-                None => { value_repr = \"\".to_owned(); }\n+                None => { value_repr = \"\".to_string(); }\n                 Some(_) => {\n-                    value_repr = \" value:?\".to_owned();\n+                    value_repr = \" value:?\".to_string();\n                     // FIXME #4954\n                 }\n             }\n \n             let type_repr;\n             match import_resolution.target_for_namespace(TypeNS) {\n-                None => { type_repr = \"\".to_owned(); }\n+                None => { type_repr = \"\".to_string(); }\n                 Some(_) => {\n-                    type_repr = \" type:?\".to_owned();\n+                    type_repr = \" type:?\".to_string();\n                     // FIXME #4954\n                 }\n             }"}, {"sha": "e4bd8243e435bad9f239ea449359048eea2f8410", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -112,7 +112,7 @@ impl<'a> TypeFolder for SubstFolder<'a> {\n                     let root_msg = match self.root_ty {\n                         Some(root) => format!(\" in the substitution of `{}`\",\n                                               root.repr(self.tcx)),\n-                        None => \"\".to_strbuf()\n+                        None => \"\".to_string()\n                     };\n                     let m = format!(\"can't use type parameters from outer \\\n                                     function{}; try using a local type \\\n@@ -134,7 +134,7 @@ impl<'a> TypeFolder for SubstFolder<'a> {\n                         let root_msg = match self.root_ty {\n                             Some(root) => format!(\" in the substitution of `{}`\",\n                                                   root.repr(self.tcx)),\n-                            None => \"\".to_strbuf()\n+                            None => \"\".to_string()\n                         };\n                         let m = format!(\"missing `Self` type param{}\",\n                                         root_msg);"}, {"sha": "140f60c1ea9731ca6ded23e0a730b82403e779f5", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -65,7 +65,7 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n \n     let mut constraints =\n         String::from_str(constraints.iter()\n-                                    .map(|s| s.get().to_strbuf())\n+                                    .map(|s| s.get().to_string())\n                                     .collect::<Vec<String>>()\n                                     .connect(\",\")\n                                     .as_slice());\n@@ -136,11 +136,11 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n #[cfg(target_arch = \"arm\")]\n #[cfg(target_arch = \"mips\")]\n fn getClobbers() -> String {\n-    \"\".to_strbuf()\n+    \"\".to_string()\n }\n \n #[cfg(target_arch = \"x86\")]\n #[cfg(target_arch = \"x86_64\")]\n fn getClobbers() -> String {\n-    \"~{dirflag},~{fpsr},~{flags}\".to_strbuf()\n+    \"~{dirflag},~{fpsr},~{flags}\".to_string()\n }"}, {"sha": "77ce3b3249f3b4adc9f5e533b0a183e3fe56d331", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -216,7 +216,7 @@ pub fn get_extern_fn(ccx: &CrateContext,\n         None => {}\n     }\n     let f = decl_fn(ccx.llmod, name, cc, ty, output);\n-    externs.insert(name.to_strbuf(), f);\n+    externs.insert(name.to_string(), f);\n     f\n }\n \n@@ -232,7 +232,7 @@ fn get_extern_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str, did: ast::De\n         set_llvm_fn_attrs(attrs.as_slice(), f)\n     });\n \n-    ccx.externs.borrow_mut().insert(name.to_strbuf(), f);\n+    ccx.externs.borrow_mut().insert(name.to_string(), f);\n     f\n }\n \n@@ -271,7 +271,7 @@ pub fn get_extern_const(externs: &mut ExternMap, llmod: ModuleRef,\n         let c = name.with_c_str(|buf| {\n             llvm::LLVMAddGlobal(llmod, ty.to_ref(), buf)\n         });\n-        externs.insert(name.to_strbuf(), c);\n+        externs.insert(name.to_string(), c);\n         return c;\n     }\n }\n@@ -1106,9 +1106,9 @@ pub fn new_fn_ctxt<'a>(ccx: &'a CrateContext,\n \n     debug!(\"new_fn_ctxt(path={}, id={}, param_substs={})\",\n            if id == -1 {\n-               \"\".to_owned()\n+               \"\".to_string()\n            } else {\n-               ccx.tcx.map.path_to_str(id).to_owned()\n+               ccx.tcx.map.path_to_str(id).to_string()\n            },\n            id, param_substs.map(|s| s.repr(ccx.tcx())));\n \n@@ -1406,7 +1406,7 @@ pub fn trans_fn(ccx: &CrateContext,\n                 param_substs: Option<&param_substs>,\n                 id: ast::NodeId,\n                 attrs: &[ast::Attribute]) {\n-    let _s = StatRecorder::new(ccx, ccx.tcx.map.path_to_str(id).to_strbuf());\n+    let _s = StatRecorder::new(ccx, ccx.tcx.map.path_to_str(id).to_string());\n     debug!(\"trans_fn(param_substs={})\", param_substs.map(|s| s.repr(ccx.tcx())));\n     let _icx = push_ctxt(\"trans_fn\");\n     let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx(), id));\n@@ -1923,15 +1923,15 @@ fn exported_name(ccx: &CrateContext, id: ast::NodeId,\n                  ty: ty::t, attrs: &[ast::Attribute]) -> String {\n     match attr::first_attr_value_str_by_name(attrs, \"export_name\") {\n         // Use provided name\n-        Some(name) => name.get().to_strbuf(),\n+        Some(name) => name.get().to_string(),\n \n         _ => ccx.tcx.map.with_path(id, |mut path| {\n             if attr::contains_name(attrs, \"no_mangle\") {\n                 // Don't mangle\n-                path.last().unwrap().to_str().to_strbuf()\n+                path.last().unwrap().to_str().to_string()\n             } else {\n                 match weak_lang_items::link_name(attrs) {\n-                    Some(name) => name.get().to_strbuf(),\n+                    Some(name) => name.get().to_string(),\n                     None => {\n                         // Usual name mangling\n                         mangle_exported_name(ccx, path, ty, id)\n@@ -2328,7 +2328,7 @@ pub fn trans_crate(krate: ast::Crate,\n     let llmod = ccx.llmod;\n \n     let mut reachable: Vec<String> = ccx.reachable.iter().filter_map(|id| {\n-        ccx.item_symbols.borrow().find(id).map(|s| s.to_strbuf())\n+        ccx.item_symbols.borrow().find(id).map(|s| s.to_string())\n     }).collect();\n \n     // Make sure that some other crucial symbols are not eliminated from the\n@@ -2337,13 +2337,13 @@ pub fn trans_crate(krate: ast::Crate,\n     // symbol. This symbol is required for use by the libmorestack library that\n     // we link in, so we must ensure that this symbol is not internalized (if\n     // defined in the crate).\n-    reachable.push(\"main\".to_strbuf());\n-    reachable.push(\"rust_stack_exhausted\".to_strbuf());\n+    reachable.push(\"main\".to_string());\n+    reachable.push(\"rust_stack_exhausted\".to_string());\n \n     // referenced from .eh_frame section on some platforms\n-    reachable.push(\"rust_eh_personality\".to_strbuf());\n+    reachable.push(\"rust_eh_personality\".to_string());\n     // referenced from rt/rust_try.ll\n-    reachable.push(\"rust_eh_personality_catch\".to_strbuf());\n+    reachable.push(\"rust_eh_personality_catch\".to_string());\n \n     let metadata_module = ccx.metadata_llmod;\n     let formats = ccx.tcx.dependency_formats.borrow().clone();"}, {"sha": "1659ecaecd89cf325283ed33c2f8b92cac07f2db", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -358,7 +358,7 @@ pub fn trans_fn_ref_with_vtables(\n         let map_node = session::expect(\n             ccx.sess(),\n             tcx.map.find(def_id.node),\n-            || \"local item should be in ast map\".to_strbuf());\n+            || \"local item should be in ast map\".to_string());\n \n         match map_node {\n             ast_map::NodeForeignItem(_) => {"}, {"sha": "237c5e8711df54ae4864f83b5070e83764866eb3", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -443,11 +443,11 @@ impl<'a> Block<'a> {\n     pub fn sess(&self) -> &'a Session { self.fcx.ccx.sess() }\n \n     pub fn ident(&self, ident: Ident) -> String {\n-        token::get_ident(ident).get().to_strbuf()\n+        token::get_ident(ident).get().to_string()\n     }\n \n     pub fn node_id_to_str(&self, id: ast::NodeId) -> String {\n-        self.tcx().map.node_to_str(id).to_strbuf()\n+        self.tcx().map.node_to_str(id).to_string()\n     }\n \n     pub fn expr_to_str(&self, e: &ast::Expr) -> String {"}, {"sha": "225c3c48cf406786e7c82ead502692a85184b3a1", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -736,7 +736,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         let containing_scope = namespace_node.scope;\n         (linkage_name, containing_scope)\n     } else {\n-        (function_name.as_slice().to_strbuf(), file_metadata)\n+        (function_name.as_slice().to_string(), file_metadata)\n     };\n \n     // Clang sets this parameter to the opening brace of the function's block, so let's do this too.\n@@ -1119,7 +1119,7 @@ fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n         });\n \n     let mut created_files = debug_context(cx).created_files.borrow_mut();\n-    created_files.insert(full_path.to_strbuf(), file_metadata);\n+    created_files.insert(full_path.to_string(), file_metadata);\n     return file_metadata;\n }\n \n@@ -1146,28 +1146,28 @@ fn basic_type_metadata(cx: &CrateContext, t: ty::t) -> DIType {\n     debug!(\"basic_type_metadata: {:?}\", ty::get(t));\n \n     let (name, encoding) = match ty::get(t).sty {\n-        ty::ty_nil => (\"()\".to_owned(), DW_ATE_unsigned),\n-        ty::ty_bot => (\"!\".to_owned(), DW_ATE_unsigned),\n-        ty::ty_bool => (\"bool\".to_owned(), DW_ATE_boolean),\n-        ty::ty_char => (\"char\".to_owned(), DW_ATE_unsigned_char),\n+        ty::ty_nil => (\"()\".to_string(), DW_ATE_unsigned),\n+        ty::ty_bot => (\"!\".to_string(), DW_ATE_unsigned),\n+        ty::ty_bool => (\"bool\".to_string(), DW_ATE_boolean),\n+        ty::ty_char => (\"char\".to_string(), DW_ATE_unsigned_char),\n         ty::ty_int(int_ty) => match int_ty {\n-            ast::TyI => (\"int\".to_owned(), DW_ATE_signed),\n-            ast::TyI8 => (\"i8\".to_owned(), DW_ATE_signed),\n-            ast::TyI16 => (\"i16\".to_owned(), DW_ATE_signed),\n-            ast::TyI32 => (\"i32\".to_owned(), DW_ATE_signed),\n-            ast::TyI64 => (\"i64\".to_owned(), DW_ATE_signed)\n+            ast::TyI => (\"int\".to_string(), DW_ATE_signed),\n+            ast::TyI8 => (\"i8\".to_string(), DW_ATE_signed),\n+            ast::TyI16 => (\"i16\".to_string(), DW_ATE_signed),\n+            ast::TyI32 => (\"i32\".to_string(), DW_ATE_signed),\n+            ast::TyI64 => (\"i64\".to_string(), DW_ATE_signed)\n         },\n         ty::ty_uint(uint_ty) => match uint_ty {\n-            ast::TyU => (\"uint\".to_owned(), DW_ATE_unsigned),\n-            ast::TyU8 => (\"u8\".to_owned(), DW_ATE_unsigned),\n-            ast::TyU16 => (\"u16\".to_owned(), DW_ATE_unsigned),\n-            ast::TyU32 => (\"u32\".to_owned(), DW_ATE_unsigned),\n-            ast::TyU64 => (\"u64\".to_owned(), DW_ATE_unsigned)\n+            ast::TyU => (\"uint\".to_string(), DW_ATE_unsigned),\n+            ast::TyU8 => (\"u8\".to_string(), DW_ATE_unsigned),\n+            ast::TyU16 => (\"u16\".to_string(), DW_ATE_unsigned),\n+            ast::TyU32 => (\"u32\".to_string(), DW_ATE_unsigned),\n+            ast::TyU64 => (\"u64\".to_string(), DW_ATE_unsigned)\n         },\n         ty::ty_float(float_ty) => match float_ty {\n-            ast::TyF32 => (\"f32\".to_owned(), DW_ATE_float),\n-            ast::TyF64 => (\"f64\".to_owned(), DW_ATE_float),\n-            ast::TyF128 => (\"f128\".to_owned(), DW_ATE_float)\n+            ast::TyF32 => (\"f32\".to_string(), DW_ATE_float),\n+            ast::TyF64 => (\"f64\".to_string(), DW_ATE_float),\n+            ast::TyF128 => (\"f128\".to_string(), DW_ATE_float)\n         },\n         _ => cx.sess().bug(\"debuginfo::basic_type_metadata - t is invalid type\")\n     };\n@@ -1255,9 +1255,9 @@ impl StructMemberDescriptionFactory {\n \n         self.fields.iter().enumerate().map(|(i, field)| {\n             let name = if field.ident.name == special_idents::unnamed_field.name {\n-                \"\".to_strbuf()\n+                \"\".to_string()\n             } else {\n-                token::get_ident(field.ident).get().to_strbuf()\n+                token::get_ident(field.ident).get().to_string()\n             };\n \n             let offset = if self.is_simd {\n@@ -1366,7 +1366,7 @@ impl TupleMemberDescriptionFactory {\n                                   -> Vec<MemberDescription> {\n         self.component_types.iter().map(|&component_type| {\n             MemberDescription {\n-                name: \"\".to_strbuf(),\n+                name: \"\".to_string(),\n                 llvm_type: type_of::type_of(cx, component_type),\n                 type_metadata: type_metadata(cx, component_type, self.span),\n                 offset: ComputedMemberOffset,\n@@ -1444,7 +1444,7 @@ impl GeneralMemberDescriptionFactory {\n                                               self.file_metadata,\n                                               codemap::DUMMY_SP);\n                 MemberDescription {\n-                    name: \"\".to_strbuf(),\n+                    name: \"\".to_string(),\n                     llvm_type: variant_llvm_type,\n                     type_metadata: variant_type_metadata,\n                     offset: FixedMemberOffset { bytes: 0 },\n@@ -1464,7 +1464,7 @@ impl EnumVariantMemberDescriptionFactory {\n                                   -> Vec<MemberDescription> {\n         self.args.iter().enumerate().map(|(i, &(ref name, ty))| {\n             MemberDescription {\n-                name: name.to_strbuf(),\n+                name: name.to_string(),\n                 llvm_type: type_of::type_of(cx, ty),\n                 type_metadata: match self.discriminant_type_metadata {\n                     Some(metadata) if i == 0 => metadata,\n@@ -1513,21 +1513,21 @@ fn describe_enum_variant(cx: &CrateContext,\n         Some(ref names) => {\n             names.iter()\n                  .map(|ident| {\n-                     token::get_ident(*ident).get().to_str().into_strbuf()\n+                     token::get_ident(*ident).get().to_str().into_string()\n                  }).collect()\n         }\n-        None => variant_info.args.iter().map(|_| \"\".to_strbuf()).collect()\n+        None => variant_info.args.iter().map(|_| \"\".to_string()).collect()\n     };\n \n     // If this is not a univariant enum, there is also the (unnamed) discriminant field\n     if discriminant_type_metadata.is_some() {\n-        arg_names.insert(0, \"\".to_strbuf());\n+        arg_names.insert(0, \"\".to_string());\n     }\n \n     // Build an array of (field name, field type) pairs to be captured in the factory closure.\n     let args: Vec<(String, ty::t)> = arg_names.iter()\n         .zip(struct_def.fields.iter())\n-        .map(|(s, &t)| (s.to_strbuf(), t))\n+        .map(|(s, &t)| (s.to_string(), t))\n         .collect();\n \n     let member_description_factory =\n@@ -1876,7 +1876,7 @@ fn boxed_type_metadata(cx: &CrateContext,\n                     -> DICompositeType {\n     let box_type_name = match content_type_name {\n         Some(content_type_name) => format!(\"Boxed<{}>\", content_type_name),\n-        None                    => \"BoxedType\".to_strbuf()\n+        None                    => \"BoxedType\".to_string()\n     };\n \n     let box_llvm_type = Type::at_box(cx, content_llvm_type);\n@@ -1891,31 +1891,31 @@ fn boxed_type_metadata(cx: &CrateContext,\n \n     let member_descriptions = [\n         MemberDescription {\n-            name: \"refcnt\".to_strbuf(),\n+            name: \"refcnt\".to_string(),\n             llvm_type: *member_llvm_types.get(0),\n             type_metadata: type_metadata(cx, int_type, codemap::DUMMY_SP),\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: \"drop_glue\".to_strbuf(),\n+            name: \"drop_glue\".to_string(),\n             llvm_type: *member_llvm_types.get(1),\n             type_metadata: nil_pointer_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: \"prev\".to_strbuf(),\n+            name: \"prev\".to_string(),\n             llvm_type: *member_llvm_types.get(2),\n             type_metadata: nil_pointer_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: \"next\".to_strbuf(),\n+            name: \"next\".to_string(),\n             llvm_type: *member_llvm_types.get(3),\n             type_metadata: nil_pointer_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: \"val\".to_strbuf(),\n+            name: \"val\".to_string(),\n             llvm_type: *member_llvm_types.get(4),\n             type_metadata: content_type_metadata,\n             offset: ComputedMemberOffset,\n@@ -2004,19 +2004,19 @@ fn vec_metadata(cx: &CrateContext,\n \n     let member_descriptions = [\n         MemberDescription {\n-            name: \"fill\".to_strbuf(),\n+            name: \"fill\".to_string(),\n             llvm_type: *member_llvm_types.get(0),\n             type_metadata: int_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: \"alloc\".to_strbuf(),\n+            name: \"alloc\".to_string(),\n             llvm_type: *member_llvm_types.get(1),\n             type_metadata: int_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: \"elements\".to_strbuf(),\n+            name: \"elements\".to_string(),\n             llvm_type: *member_llvm_types.get(2),\n             type_metadata: array_type_metadata,\n             offset: ComputedMemberOffset,\n@@ -2061,13 +2061,13 @@ fn vec_slice_metadata(cx: &CrateContext,\n \n     let member_descriptions = [\n         MemberDescription {\n-            name: \"data_ptr\".to_strbuf(),\n+            name: \"data_ptr\".to_string(),\n             llvm_type: *member_llvm_types.get(0),\n             type_metadata: type_metadata(cx, data_ptr_type, span),\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: \"length\".to_strbuf(),\n+            name: \"length\".to_string(),\n             llvm_type: *member_llvm_types.get(1),\n             type_metadata: type_metadata(cx, ty::mk_uint(), span),\n             offset: ComputedMemberOffset,"}, {"sha": "f254422226fcdeab451b25e0ef099fd344c20a38", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -89,7 +89,7 @@ impl Dest {\n     pub fn to_str(&self, ccx: &CrateContext) -> String {\n         match *self {\n             SaveIn(v) => format_strbuf!(\"SaveIn({})\", ccx.tn.val_to_str(v)),\n-            Ignore => \"Ignore\".to_strbuf()\n+            Ignore => \"Ignore\".to_string()\n         }\n     }\n }"}, {"sha": "96fb8ac0e980ce0dadecaf8df2add3b6323e72e4", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -163,7 +163,7 @@ pub fn register_static(ccx: &CrateContext,\n                 });\n                 lib::llvm::SetLinkage(g1, linkage);\n \n-                let mut real_name = \"_rust_extern_with_linkage_\".to_strbuf();\n+                let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n                 real_name.push_str(ident.get());\n                 let g2 = real_name.with_c_str(|buf| {\n                     llvm::LLVMAddGlobal(ccx.llmod, llty.to_ref(), buf)\n@@ -465,7 +465,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n         }\n \n         ccx.item_symbols.borrow_mut().insert(foreign_item.id,\n-                                             lname.get().to_strbuf());\n+                                             lname.get().to_string());\n     }\n }\n "}, {"sha": "4b81463ed795f3dc9d9854b0d41491c6b0ae24eb", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -190,7 +190,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n           ty::ty_rptr(_, ref mt) => {\n               match ty::get(mt.ty).sty {\n                   ty::ty_vec(ref mt, None) => {\n-                      let (name, extra) = (\"slice\".to_owned(), Vec::new());\n+                      let (name, extra) = (\"slice\".to_string(), Vec::new());\n                       let extra = extra.append(self.c_mt(mt).as_slice());\n                       self.visit(format!(\"evec_{}\", name).as_slice(),\n                                  extra.as_slice())"}, {"sha": "4421c84e86f3c93325f1a7925615650331f75f06", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -228,15 +228,15 @@ pub fn trans_uniq_vstore<'a>(bcx: &'a Block<'a>,\n                              content_expr: &ast::Expr)\n                              -> DatumBlock<'a, Expr> {\n     /*!\n-     * ~[...] and \"...\".to_owned() allocate boxes in the exchange heap and write\n+     * ~[...] and \"...\".to_string() allocate boxes in the exchange heap and write\n      * the array elements into them.\n      */\n \n     debug!(\"trans_uniq_vstore(vstore_expr={})\", bcx.expr_to_str(vstore_expr));\n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n \n-    // Handle \"\".to_owned().\n+    // Handle \"\".to_string().\n     match content_expr.node {\n         ast::ExprLit(lit) => {\n             match lit.node {"}, {"sha": "fe8db6fa8a11fc1443a72274c4a8587dba810ddf", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -3205,7 +3205,7 @@ pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n         \"no field named `{}` found in the list of fields `{:?}`\",\n         token::get_name(name),\n         fields.iter()\n-              .map(|f| token::get_ident(f.ident).get().to_strbuf())\n+              .map(|f| token::get_ident(f.ident).get().to_string())\n               .collect::<Vec<String>>()).as_slice());\n }\n \n@@ -3237,26 +3237,26 @@ pub fn ty_sort_str(cx: &ctxt, t: t) -> String {\n         }\n \n         ty_enum(id, _) => format_strbuf!(\"enum {}\", item_path_str(cx, id)),\n-        ty_box(_) => \"@-ptr\".to_strbuf(),\n-        ty_uniq(_) => \"box\".to_strbuf(),\n-        ty_vec(_, _) => \"vector\".to_strbuf(),\n-        ty_ptr(_) => \"*-ptr\".to_strbuf(),\n-        ty_rptr(_, _) => \"&-ptr\".to_strbuf(),\n-        ty_bare_fn(_) => \"extern fn\".to_strbuf(),\n-        ty_closure(_) => \"fn\".to_strbuf(),\n+        ty_box(_) => \"@-ptr\".to_string(),\n+        ty_uniq(_) => \"box\".to_string(),\n+        ty_vec(_, _) => \"vector\".to_string(),\n+        ty_ptr(_) => \"*-ptr\".to_string(),\n+        ty_rptr(_, _) => \"&-ptr\".to_string(),\n+        ty_bare_fn(_) => \"extern fn\".to_string(),\n+        ty_closure(_) => \"fn\".to_string(),\n         ty_trait(ref inner) => {\n             format_strbuf!(\"trait {}\", item_path_str(cx, inner.def_id))\n         }\n         ty_struct(id, _) => {\n             format_strbuf!(\"struct {}\", item_path_str(cx, id))\n         }\n-        ty_tup(_) => \"tuple\".to_strbuf(),\n-        ty_infer(TyVar(_)) => \"inferred type\".to_strbuf(),\n-        ty_infer(IntVar(_)) => \"integral variable\".to_strbuf(),\n-        ty_infer(FloatVar(_)) => \"floating-point variable\".to_strbuf(),\n-        ty_param(_) => \"type parameter\".to_strbuf(),\n-        ty_self(_) => \"self\".to_strbuf(),\n-        ty_err => \"type error\".to_strbuf(),\n+        ty_tup(_) => \"tuple\".to_string(),\n+        ty_infer(TyVar(_)) => \"inferred type\".to_string(),\n+        ty_infer(IntVar(_)) => \"integral variable\".to_string(),\n+        ty_infer(FloatVar(_)) => \"floating-point variable\".to_string(),\n+        ty_param(_) => \"type parameter\".to_string(),\n+        ty_self(_) => \"self\".to_string(),\n+        ty_err => \"type error\".to_string(),\n     }\n }\n \n@@ -3272,13 +3272,13 @@ pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> String {\n \n     fn tstore_to_closure(s: &TraitStore) -> String {\n         match s {\n-            &UniqTraitStore => \"proc\".to_strbuf(),\n-            &RegionTraitStore(..) => \"closure\".to_strbuf()\n+            &UniqTraitStore => \"proc\".to_string(),\n+            &RegionTraitStore(..) => \"closure\".to_string()\n         }\n     }\n \n     match *err {\n-        terr_mismatch => \"types differ\".to_strbuf(),\n+        terr_mismatch => \"types differ\".to_string(),\n         terr_fn_style_mismatch(values) => {\n             format_strbuf!(\"expected {} fn but found {} fn\",\n                            values.expected.to_str(),\n@@ -3299,13 +3299,13 @@ pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> String {\n                            tstore_to_closure(&values.expected),\n                            tstore_to_closure(&values.found))\n         }\n-        terr_mutability => \"values differ in mutability\".to_strbuf(),\n+        terr_mutability => \"values differ in mutability\".to_string(),\n         terr_box_mutability => {\n-            \"boxed values differ in mutability\".to_strbuf()\n+            \"boxed values differ in mutability\".to_string()\n         }\n-        terr_vec_mutability => \"vectors differ in mutability\".to_strbuf(),\n-        terr_ptr_mutability => \"pointers differ in mutability\".to_strbuf(),\n-        terr_ref_mutability => \"references differ in mutability\".to_strbuf(),\n+        terr_vec_mutability => \"vectors differ in mutability\".to_string(),\n+        terr_ptr_mutability => \"pointers differ in mutability\".to_string(),\n+        terr_ref_mutability => \"references differ in mutability\".to_string(),\n         terr_ty_param_size(values) => {\n             format_strbuf!(\"expected a type with {} type params \\\n                             but found one with {} type params\",\n@@ -3325,7 +3325,7 @@ pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> String {\n                            values.found)\n         }\n         terr_record_mutability => {\n-            \"record elements differ in mutability\".to_strbuf()\n+            \"record elements differ in mutability\".to_string()\n         }\n         terr_record_fields(values) => {\n             format_strbuf!(\"expected a record with field `{}` but found one \\\n@@ -3334,16 +3334,16 @@ pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> String {\n                            token::get_ident(values.found))\n         }\n         terr_arg_count => {\n-            \"incorrect number of function parameters\".to_strbuf()\n+            \"incorrect number of function parameters\".to_string()\n         }\n         terr_regions_does_not_outlive(..) => {\n-            \"lifetime mismatch\".to_strbuf()\n+            \"lifetime mismatch\".to_string()\n         }\n         terr_regions_not_same(..) => {\n-            \"lifetimes are not the same\".to_strbuf()\n+            \"lifetimes are not the same\".to_string()\n         }\n         terr_regions_no_overlap(..) => {\n-            \"lifetimes do not intersect\".to_strbuf()\n+            \"lifetimes do not intersect\".to_string()\n         }\n         terr_regions_insufficiently_polymorphic(br, _) => {\n             format_strbuf!(\"expected bound lifetime parameter {}, \\\n@@ -3385,7 +3385,7 @@ pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> String {\n             }\n         }\n         terr_integer_as_char => {\n-            \"expected an integral type but found `char`\".to_strbuf()\n+            \"expected an integral type but found `char`\".to_string()\n         }\n         terr_int_mismatch(ref values) => {\n             format_strbuf!(\"expected `{}` but found `{}`\",\n@@ -3714,7 +3714,7 @@ pub fn substd_enum_variants(cx: &ctxt,\n }\n \n pub fn item_path_str(cx: &ctxt, id: ast::DefId) -> String {\n-    with_path(cx, id, |path| ast_map::path_to_str(path)).to_strbuf()\n+    with_path(cx, id, |path| ast_map::path_to_str(path)).to_string()\n }\n \n pub enum DtorKind {"}, {"sha": "3d37de38e4523eba450b9ddc34a62703cf524a9e", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -166,14 +166,14 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n                     // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n                     fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                        |expected, actual| {\n-                       expected.map_or(\"\".to_strbuf(), |e| {\n+                       expected.map_or(\"\".to_string(), |e| {\n                         format_strbuf!(\"mismatched types: expected `{}` but \\\n                                         found {}\",\n                                        e,\n                                        actual)\n                         })},\n                         Some(expected),\n-                        \"a structure pattern\".to_strbuf(),\n+                        \"a structure pattern\".to_string(),\n                         None);\n                     fcx.write_error(pat.id);\n                     kind_name = \"[error]\";\n@@ -221,7 +221,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n             // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n             fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                |expected, actual| {\n-                                               expected.map_or(\"\".to_strbuf(),\n+                                               expected.map_or(\"\".to_string(),\n                                                               |e| {\n                         format_strbuf!(\"mismatched types: expected `{}` but \\\n                                         found {}\",\n@@ -230,7 +230,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n                     })\n                 },\n                 Some(expected),\n-                \"an enum or structure pattern\".to_strbuf(),\n+                \"an enum or structure pattern\".to_string(),\n                 None);\n             fcx.write_error(pat.id);\n             kind_name = \"[error]\";\n@@ -459,7 +459,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         debug!(\"pat_range ending type: {:?}\", e_ty);\n         if !require_same_types(\n             tcx, Some(fcx.infcx()), false, pat.span, b_ty, e_ty,\n-            || \"mismatched types in range\".to_strbuf())\n+            || \"mismatched types in range\".to_string())\n         {\n             // no-op\n         } else if !ty::type_is_numeric(b_ty) && !ty::type_is_char(b_ty) {\n@@ -553,15 +553,15 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n                 fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                                 |expected, actual| {\n-                            expected.map_or(\"\".to_strbuf(),\n+                            expected.map_or(\"\".to_string(),\n                                             |e| {\n                                 format_strbuf!(\"mismatched types: expected \\\n                                                 `{}` but found {}\",\n                                                e,\n                                                actual)\n                             })},\n                             Some(expected),\n-                            \"a structure pattern\".to_strbuf(),\n+                            \"a structure pattern\".to_string(),\n                             None);\n                 match tcx.def_map.borrow().find(&pat.id) {\n                     Some(&ast::DefStruct(supplied_def_id)) => {\n@@ -620,15 +620,15 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                 fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                                  |expected,\n                                                                   actual| {\n-                        expected.map_or(\"\".to_strbuf(), |e| {\n+                        expected.map_or(\"\".to_string(), |e| {\n                             format_strbuf!(\"mismatched types: expected `{}` \\\n                                             but found {}\",\n                                            e,\n                                            actual)\n                         }\n                     )},\n                     Some(expected),\n-                    \"tuple\".to_strbuf(),\n+                    \"tuple\".to_string(),\n                     Some(&type_error));\n                 fcx.write_error(pat.id);\n             }\n@@ -659,7 +659,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n             fcx.infcx().type_error_message_str_with_expected(\n                 pat.span,\n                 |expected, actual| {\n-                    expected.map_or(\"\".to_strbuf(),\n+                    expected.map_or(\"\".to_string(),\n                                     |e| {\n                         format_strbuf!(\"mismatched types: expected `{}` but \\\n                                         found {}\",\n@@ -668,7 +668,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                     })\n                 },\n                 Some(expected),\n-                \"a vector pattern\".to_strbuf(),\n+                \"a vector pattern\".to_string(),\n                 None);\n             fcx.write_error(pat.id);\n         };\n@@ -682,7 +682,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                   fcx.type_error_message(pat.span,\n                                          |_| {\n                                             \"unique vector patterns are no \\\n-                                             longer supported\".to_strbuf()\n+                                             longer supported\".to_string()\n                                          },\n                                          expected,\n                                          None);\n@@ -750,7 +750,7 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n             fcx.infcx().type_error_message_str_with_expected(\n                 span,\n                 |expected, actual| {\n-                    expected.map_or(\"\".to_strbuf(), |e| {\n+                    expected.map_or(\"\".to_string(), |e| {\n                         format_strbuf!(\"mismatched types: expected `{}` but \\\n                                         found {}\",\n                                        e,"}, {"sha": "cdf8b50a1cd2390b4884cbd58cc34fb302ad7f0f", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -2707,7 +2707,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                     let error = if vst == ast::ExprVstoreSlice {\n                         \"`&\\\"string\\\"` has been removed; use `\\\"string\\\"` instead\"\n                     } else {\n-                        \"`~\\\"string\\\"` has been removed; use `\\\"string\\\".to_owned()` instead\"\n+                        \"`~\\\"string\\\"` has been removed; use `\\\"string\\\".to_string()` instead\"\n                     };\n                     tcx.sess.span_err(expr.span, error);\n                     ty::mk_err()\n@@ -3355,7 +3355,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n            ppaux::ty_to_str(tcx, fcx.expr_ty(expr)),\n            match expected {\n                Some(t) => ppaux::ty_to_str(tcx, t),\n-               _ => \"empty\".to_strbuf()\n+               _ => \"empty\".to_string()\n            });\n \n     unifier();\n@@ -3511,7 +3511,7 @@ pub fn check_block_with_expected(fcx: &FnCtxt,\n                    .add_lint(UnreachableCode,\n                              s_id,\n                              s.span,\n-                             \"unreachable statement\".to_strbuf());\n+                             \"unreachable statement\".to_string());\n                 warned = true;\n             }\n             if ty::type_is_bot(s_ty) {\n@@ -3538,7 +3538,7 @@ pub fn check_block_with_expected(fcx: &FnCtxt,\n                    .add_lint(UnreachableCode,\n                              e.id,\n                              e.span,\n-                             \"unreachable expression\".to_strbuf());\n+                             \"unreachable expression\".to_string());\n             }\n             check_expr_with_opt_hint(fcx, e, expected);\n               let ety = fcx.expr_ty(e);\n@@ -4077,7 +4077,7 @@ pub fn structurally_resolved_type(fcx: &FnCtxt, sp: Span, tp: ty::t) -> ty::t {\n         _ => {\n             fcx.type_error_message(sp, |_actual| {\n                 \"the type of this value must be known in this \\\n-                 context\".to_strbuf()\n+                 context\".to_string()\n             }, tp, None);\n             demand::suptype(fcx, sp, ty::mk_err(), tp);\n             tp"}, {"sha": "d7e70205f5d480b04e72011bad0fa9ac2fb3319b", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -808,7 +808,7 @@ impl<'a> Rebuilder<'a> {\n             // choice of lifetime name deterministic and thus easier to test.\n             let mut names = Vec::new();\n             for rn in region_names.iter() {\n-                let lt_name = token::get_name(*rn).get().to_owned();\n+                let lt_name = token::get_name(*rn).get().to_string();\n                 names.push(lt_name);\n             }\n             names.sort();\n@@ -1227,12 +1227,12 @@ impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n     fn report_inference_failure(&self,\n                                 var_origin: RegionVariableOrigin) {\n         let var_description = match var_origin {\n-            infer::MiscVariable(_) => \"\".to_strbuf(),\n-            infer::PatternRegion(_) => \" for pattern\".to_strbuf(),\n-            infer::AddrOfRegion(_) => \" for borrow expression\".to_strbuf(),\n-            infer::AddrOfSlice(_) => \" for slice expression\".to_strbuf(),\n-            infer::Autoref(_) => \" for autoref\".to_strbuf(),\n-            infer::Coercion(_) => \" for automatic coercion\".to_strbuf(),\n+            infer::MiscVariable(_) => \"\".to_string(),\n+            infer::PatternRegion(_) => \" for pattern\".to_string(),\n+            infer::AddrOfRegion(_) => \" for borrow expression\".to_string(),\n+            infer::AddrOfSlice(_) => \" for slice expression\".to_string(),\n+            infer::Autoref(_) => \" for autoref\".to_string(),\n+            infer::Coercion(_) => \" for automatic coercion\".to_string(),\n             infer::LateBoundRegion(_, br) => {\n                 format!(\" for {}in function call\",\n                         bound_region_to_str(self.tcx, \"lifetime parameter \", true, br))\n@@ -1475,7 +1475,7 @@ impl LifeGiver {\n     fn with_taken(taken: &[ast::Lifetime]) -> LifeGiver {\n         let mut taken_ = HashSet::new();\n         for lt in taken.iter() {\n-            let lt_name = token::get_name(lt.name).get().to_strbuf();\n+            let lt_name = token::get_name(lt.name).get().to_string();\n             taken_.insert(lt_name);\n         }\n         LifeGiver {"}, {"sha": "38b2cdcb528105059285fda10f6864e38e767217", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -36,7 +36,7 @@ impl<'f> Glb<'f> {\n \n impl<'f> Combine for Glb<'f> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n-    fn tag(&self) -> String { \"glb\".to_strbuf() }\n+    fn tag(&self) -> String { \"glb\".to_string() }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n     fn trace(&self) -> TypeTrace { self.get_ref().trace.clone() }\n "}, {"sha": "98086fcf6613c3eb59dc4cb4c956f91ed9ff9bf8", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -35,7 +35,7 @@ impl<'f> Lub<'f> {\n \n impl<'f> Combine for Lub<'f> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n-    fn tag(&self) -> String { \"lub\".to_strbuf() }\n+    fn tag(&self) -> String { \"lub\".to_string() }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n     fn trace(&self) -> TypeTrace { self.get_ref().trace.clone() }\n "}, {"sha": "107c54115b42aad91f9c9f66f1ebb12b9ac1eabe", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -247,10 +247,10 @@ pub enum fixup_err {\n \n pub fn fixup_err_to_str(f: fixup_err) -> String {\n     match f {\n-      unresolved_int_ty(_) => \"unconstrained integral type\".to_strbuf(),\n-      unresolved_ty(_) => \"unconstrained type\".to_strbuf(),\n-      cyclic_ty(_) => \"cyclic type of infinite size\".to_strbuf(),\n-      unresolved_region(_) => \"unconstrained region\".to_strbuf(),\n+      unresolved_int_ty(_) => \"unconstrained integral type\".to_string(),\n+      unresolved_ty(_) => \"unconstrained type\".to_string(),\n+      cyclic_ty(_) => \"cyclic type of infinite size\".to_string(),\n+      unresolved_region(_) => \"unconstrained region\".to_string(),\n       region_var_bound_by_region_var(r1, r2) => {\n         format_strbuf!(\"region var {:?} bound by another region var {:?}; \\\n                         this is a bug in rustc\",\n@@ -729,7 +729,7 @@ impl<'a> InferCtxt<'a> {\n                                                 err: Option<&ty::type_err>) {\n         debug!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n \n-        let error_str = err.map_or(\"\".to_strbuf(), |t_err| {\n+        let error_str = err.map_or(\"\".to_string(), |t_err| {\n             format!(\" ({})\", ty::type_err_to_str(self.tcx, t_err))\n         });\n         let resolved_expected = expected_ty.map(|e_ty| {"}, {"sha": "a543cf18d565a19114115dca69c698ff8d1d467e", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -35,7 +35,7 @@ impl<'f> Sub<'f> {\n \n impl<'f> Combine for Sub<'f> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n-    fn tag(&self) -> String { \"sub\".to_strbuf() }\n+    fn tag(&self) -> String { \"sub\".to_string() }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n     fn trace(&self) -> TypeTrace { self.get_ref().trace.clone() }\n "}, {"sha": "e4636e1c7c6d721d32ae97faf60527cecf790bc5", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -46,11 +46,11 @@ static EMPTY_SOURCE_STR: &str = \"/* Hello, world! */\";\n \n fn setup_env(test_name: &str, source_string: &str) -> Env {\n     let messages = @DVec();\n-    let matches = getopts(vec!(\"-Z\".to_owned(), \"verbose\".to_owned()), optgroups()).get();\n+    let matches = getopts(vec!(\"-Z\".to_string(), \"verbose\".to_string()), optgroups()).get();\n     let diag = diagnostic::collect(messages);\n-    let sessopts = build_session_options(\"rustc\".to_owned(), &matches, diag);\n+    let sessopts = build_session_options(\"rustc\".to_string(), &matches, diag);\n     let sess = build_session(sessopts, None, diag);\n-    let cfg = build_configuration(sess, \"whatever\".to_owned(), str_input(\"\".to_owned()));\n+    let cfg = build_configuration(sess, \"whatever\".to_string(), str_input(\"\".to_string()));\n     let dm = HashMap();\n     let amap = HashMap();\n     let freevars = HashMap();"}, {"sha": "eaca07b782f7df4b95faa1415a285038abeaf5e1", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -56,7 +56,7 @@ impl<V:InferStr> InferStr for Bound<V> {\n     fn inf_str(&self, cx: &InferCtxt) -> String {\n         match *self {\n             Some(ref v) => v.inf_str(cx),\n-            None => \"none\".to_strbuf()\n+            None => \"none\".to_string()\n         }\n     }\n }\n@@ -82,13 +82,13 @@ impl<V:Vid + ToStr,T:InferStr> InferStr for VarValue<V, T> {\n \n impl InferStr for IntVarValue {\n     fn inf_str(&self, _cx: &InferCtxt) -> String {\n-        self.to_str().to_strbuf()\n+        self.to_str().to_string()\n     }\n }\n \n impl InferStr for ast::FloatTy {\n     fn inf_str(&self, _cx: &InferCtxt) -> String {\n-        self.to_str().to_strbuf()\n+        self.to_str().to_string()\n     }\n }\n "}, {"sha": "7b8c62fbf88f19cf751d12dab7453b08643701de", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -99,7 +99,7 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n               format_strbuf!(\"the anonymous lifetime \\\\#{} defined on\",\n                              idx + 1)\n           }\n-          BrFresh(_) => \"an anonymous lifetime defined on\".to_strbuf(),\n+          BrFresh(_) => \"an anonymous lifetime defined on\".to_string(),\n           _ => {\n               format_strbuf!(\"the lifetime {} as defined on\",\n                              bound_region_ptr_to_str(cx, fr.bound_region))\n@@ -123,9 +123,9 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n         }\n       }\n \n-      ReStatic => { (\"the static lifetime\".to_strbuf(), None) }\n+      ReStatic => { (\"the static lifetime\".to_string(), None) }\n \n-      ReEmpty => { (\"the empty lifetime\".to_strbuf(), None) }\n+      ReEmpty => { (\"the empty lifetime\".to_string(), None) }\n \n       // I believe these cases should not occur (except when debugging,\n       // perhaps)\n@@ -164,8 +164,8 @@ pub fn bound_region_to_str(cx: &ctxt,\n                            token::get_name(name),\n                            space_str)\n         }\n-        BrAnon(_) => prefix.to_strbuf(),\n-        BrFresh(_) => prefix.to_strbuf(),\n+        BrAnon(_) => prefix.to_string(),\n+        BrFresh(_) => prefix.to_string(),\n     }\n }\n \n@@ -188,25 +188,25 @@ pub fn region_to_str(cx: &ctxt, prefix: &str, space: bool, region: Region) -> St\n     // to fit that into a short string.  Hence the recommendation to use\n     // `explain_region()` or `note_and_explain_region()`.\n     match region {\n-        ty::ReScope(_) => prefix.to_strbuf(),\n+        ty::ReScope(_) => prefix.to_string(),\n         ty::ReEarlyBound(_, _, name) => {\n-            token::get_name(name).get().to_strbuf()\n+            token::get_name(name).get().to_string()\n         }\n         ty::ReLateBound(_, br) => bound_region_to_str(cx, prefix, space, br),\n         ty::ReFree(ref fr) => bound_region_to_str(cx, prefix, space, fr.bound_region),\n         ty::ReInfer(ReSkolemized(_, br)) => {\n             bound_region_to_str(cx, prefix, space, br)\n         }\n-        ty::ReInfer(ReVar(_)) => prefix.to_strbuf(),\n+        ty::ReInfer(ReVar(_)) => prefix.to_string(),\n         ty::ReStatic => format_strbuf!(\"{}'static{}\", prefix, space_str),\n         ty::ReEmpty => format_strbuf!(\"{}'<empty>{}\", prefix, space_str),\n     }\n }\n \n pub fn mutability_to_str(m: ast::Mutability) -> String {\n     match m {\n-        ast::MutMutable => \"mut \".to_strbuf(),\n-        ast::MutImmutable => \"\".to_strbuf(),\n+        ast::MutMutable => \"mut \".to_string(),\n+        ast::MutImmutable => \"\".to_string(),\n     }\n }\n \n@@ -216,7 +216,7 @@ pub fn mt_to_str(cx: &ctxt, m: &mt) -> String {\n \n pub fn trait_store_to_str(cx: &ctxt, s: ty::TraitStore) -> String {\n     match s {\n-        ty::UniqTraitStore => \"Box \".to_strbuf(),\n+        ty::UniqTraitStore => \"Box \".to_string(),\n         ty::RegionTraitStore(r, m) => {\n             format_strbuf!(\"{}{}\",\n                            region_ptr_to_str(cx, r),\n@@ -238,12 +238,12 @@ pub fn fn_sig_to_str(cx: &ctxt, typ: &ty::FnSig) -> String {\n }\n \n pub fn trait_ref_to_str(cx: &ctxt, trait_ref: &ty::TraitRef) -> String {\n-    trait_ref.user_string(cx).to_strbuf()\n+    trait_ref.user_string(cx).to_string()\n }\n \n pub fn ty_to_str(cx: &ctxt, typ: t) -> String {\n     fn fn_input_to_str(cx: &ctxt, input: ty::t) -> String {\n-        ty_to_str(cx, input).to_strbuf()\n+        ty_to_str(cx, input).to_string()\n     }\n     fn bare_fn_to_str(cx: &ctxt,\n                       fn_style: ast::FnStyle,\n@@ -351,15 +351,15 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> String {\n \n     // pretty print the structural type representation:\n     return match ty::get(typ).sty {\n-      ty_nil => \"()\".to_strbuf(),\n-      ty_bot => \"!\".to_strbuf(),\n-      ty_bool => \"bool\".to_strbuf(),\n-      ty_char => \"char\".to_strbuf(),\n+      ty_nil => \"()\".to_string(),\n+      ty_bot => \"!\".to_string(),\n+      ty_bool => \"bool\".to_string(),\n+      ty_char => \"char\".to_string(),\n       ty_int(t) => ast_util::int_ty_to_str(t, None,\n-                                           ast_util::AutoSuffix).to_strbuf(),\n+                                           ast_util::AutoSuffix).to_string(),\n       ty_uint(t) => ast_util::uint_ty_to_str(t, None,\n-                                             ast_util::AutoSuffix).to_strbuf(),\n-      ty_float(t) => ast_util::float_ty_to_str(t).to_strbuf(),\n+                                             ast_util::AutoSuffix).to_string(),\n+      ty_float(t) => ast_util::float_ty_to_str(t).to_string(),\n       ty_box(typ) => format_strbuf!(\"@{}\", ty_to_str(cx, typ)),\n       ty_uniq(typ) => format_strbuf!(\"~{}\", ty_to_str(cx, typ)),\n       ty_ptr(ref tm) => format_strbuf!(\"*{}\", mt_to_str(cx, tm)),\n@@ -378,11 +378,11 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> String {\n       ty_bare_fn(ref f) => {\n           bare_fn_to_str(cx, f.fn_style, f.abi, None, &f.sig)\n       }\n-      ty_infer(infer_ty) => infer_ty.to_str().to_strbuf(),\n-      ty_err => \"[type error]\".to_strbuf(),\n+      ty_infer(infer_ty) => infer_ty.to_str().to_string(),\n+      ty_err => \"[type error]\".to_string(),\n       ty_param(param_ty {idx: id, def_id: did}) => {\n           let ident = match cx.ty_param_defs.borrow().find(&did.node) {\n-              Some(def) => token::get_ident(def.ident).get().to_strbuf(),\n+              Some(def) => token::get_ident(def.ident).get().to_string(),\n               // This can only happen when a type mismatch error happens and\n               // the actual type has more type parameters than the expected one.\n               None => format_strbuf!(\"<generic \\\\#{}>\", id)\n@@ -393,7 +393,7 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> String {\n               format_strbuf!(\"{}:{:?}\", ident, did)\n           }\n       }\n-      ty_self(..) => \"Self\".to_strbuf(),\n+      ty_self(..) => \"Self\".to_string(),\n       ty_enum(did, ref substs) | ty_struct(did, ref substs) => {\n         let base = ty::item_path_str(cx, did);\n         parameterized(cx,\n@@ -417,7 +417,7 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> String {\n                        bound_sep,\n                        bound_str)\n       }\n-      ty_str => \"str\".to_strbuf(),\n+      ty_str => \"str\".to_string(),\n       ty_vec(ref mt, sz) => {\n           match sz {\n               Some(n) => {\n@@ -483,17 +483,17 @@ pub fn parameterized(cx: &ctxt,\n }\n \n pub fn ty_to_short_str(cx: &ctxt, typ: t) -> String {\n-    let mut s = typ.repr(cx).to_strbuf();\n+    let mut s = typ.repr(cx).to_string();\n     if s.len() >= 32u {\n-        s = s.as_slice().slice(0u, 32u).to_strbuf();\n+        s = s.as_slice().slice(0u, 32u).to_string();\n     }\n     return s;\n }\n \n impl<T:Repr> Repr for Option<T> {\n     fn repr(&self, tcx: &ctxt) -> String {\n         match self {\n-            &None => \"None\".to_strbuf(),\n+            &None => \"None\".to_string(),\n             &Some(ref t) => t.repr(tcx),\n         }\n     }\n@@ -510,7 +510,7 @@ impl<T:Repr,U:Repr> Repr for Result<T,U> {\n \n impl Repr for () {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        \"()\".to_strbuf()\n+        \"()\".to_string()\n     }\n }\n \n@@ -596,7 +596,7 @@ impl Repr for ty::ItemSubsts {\n impl Repr for ty::RegionSubsts {\n     fn repr(&self, tcx: &ctxt) -> String {\n         match *self {\n-            ty::ErasedRegions => \"erased\".to_strbuf(),\n+            ty::ErasedRegions => \"erased\".to_string(),\n             ty::NonerasedRegions(ref regions) => regions.repr(tcx)\n         }\n     }\n@@ -607,17 +607,17 @@ impl Repr for ty::ParamBounds {\n         let mut res = Vec::new();\n         for b in self.builtin_bounds.iter() {\n             res.push(match b {\n-                ty::BoundStatic => \"'static\".to_strbuf(),\n-                ty::BoundSend => \"Send\".to_strbuf(),\n-                ty::BoundSized => \"Sized\".to_strbuf(),\n-                ty::BoundCopy => \"Copy\".to_strbuf(),\n-                ty::BoundShare => \"Share\".to_strbuf(),\n+                ty::BoundStatic => \"'static\".to_string(),\n+                ty::BoundSend => \"Send\".to_string(),\n+                ty::BoundSized => \"Sized\".to_string(),\n+                ty::BoundCopy => \"Copy\".to_string(),\n+                ty::BoundShare => \"Share\".to_string(),\n             });\n         }\n         for t in self.trait_bounds.iter() {\n             res.push(t.repr(tcx));\n         }\n-        res.connect(\"+\").to_strbuf()\n+        res.connect(\"+\").to_string()\n     }\n }\n \n@@ -694,7 +694,7 @@ impl Repr for ty::Region {\n             }\n \n             ty::ReStatic => {\n-                \"ReStatic\".to_strbuf()\n+                \"ReStatic\".to_string()\n             }\n \n             ty::ReInfer(ReVar(ref vid)) => {\n@@ -708,7 +708,7 @@ impl Repr for ty::Region {\n             }\n \n             ty::ReEmpty => {\n-                \"ReEmpty\".to_strbuf()\n+                \"ReEmpty\".to_string()\n             }\n         }\n     }\n@@ -771,7 +771,7 @@ impl Repr for ty::ItemVariances {\n \n impl Repr for ty::Variance {\n     fn repr(&self, _: &ctxt) -> String {\n-        self.to_str().to_strbuf()\n+        self.to_str().to_string()\n     }\n }\n \n@@ -790,13 +790,13 @@ impl Repr for ty::Method {\n \n impl Repr for ast::Name {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        token::get_name(*self).get().to_strbuf()\n+        token::get_name(*self).get().to_string()\n     }\n }\n \n impl Repr for ast::Ident {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        token::get_ident(*self).get().to_strbuf()\n+        token::get_ident(*self).get().to_string()\n     }\n }\n \n@@ -893,11 +893,11 @@ impl Repr for ty::BuiltinBound {\n impl UserString for ty::BuiltinBound {\n     fn user_string(&self, _tcx: &ctxt) -> String {\n         match *self {\n-            ty::BoundStatic => \"'static\".to_strbuf(),\n-            ty::BoundSend => \"Send\".to_strbuf(),\n-            ty::BoundSized => \"Sized\".to_strbuf(),\n-            ty::BoundCopy => \"Copy\".to_strbuf(),\n-            ty::BoundShare => \"Share\".to_strbuf(),\n+            ty::BoundStatic => \"'static\".to_string(),\n+            ty::BoundSend => \"Send\".to_string(),\n+            ty::BoundSized => \"Sized\".to_string(),\n+            ty::BoundCopy => \"Copy\".to_string(),\n+            ty::BoundShare => \"Share\".to_string(),\n         }\n     }\n }\n@@ -910,7 +910,7 @@ impl Repr for ty::BuiltinBounds {\n \n impl Repr for Span {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        tcx.sess.codemap().span_to_str(*self).to_strbuf()\n+        tcx.sess.codemap().span_to_str(*self).to_string()\n     }\n }\n \n@@ -927,7 +927,7 @@ impl UserString for ty::BuiltinBounds {\n             .map(|bb| bb.user_string(tcx))\n             .collect::<Vec<String>>()\n             .connect(\"+\")\n-            .to_strbuf()\n+            .to_string()\n     }\n }\n \n@@ -962,19 +962,19 @@ impl UserString for ty::t {\n \n impl UserString for ast::Ident {\n     fn user_string(&self, _tcx: &ctxt) -> String {\n-        token::get_name(self.name).get().to_strbuf()\n+        token::get_name(self.name).get().to_string()\n     }\n }\n \n impl Repr for abi::Abi {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        self.to_str().to_strbuf()\n+        self.to_str().to_string()\n     }\n }\n \n impl UserString for abi::Abi {\n     fn user_string(&self, _tcx: &ctxt) -> String {\n-        self.to_str().to_strbuf()\n+        self.to_str().to_string()\n     }\n }\n "}, {"sha": "f0d691823256d5a3a7bd0ec846dafa8553aa79d8", "filename": "src/librustc/util/sha2.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Futil%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustc%2Futil%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsha2.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -259,7 +259,7 @@ pub trait Digest {\n     /// Convenience function that retrieves the result of a digest as a\n     /// String in hexadecimal format.\n     fn result_str(&mut self) -> String {\n-        self.result_bytes().as_slice().to_hex().to_strbuf()\n+        self.result_bytes().as_slice().to_hex().to_string()\n     }\n }\n \n@@ -578,21 +578,21 @@ mod tests {\n         // Examples from wikipedia\n         let wikipedia_tests = vec!(\n             Test {\n-                input: \"\".to_strbuf(),\n+                input: \"\".to_string(),\n                 output_str: \"e3b0c44298fc1c149afb\\\n-            f4c8996fb92427ae41e4649b934ca495991b7852b855\".to_strbuf()\n+            f4c8996fb92427ae41e4649b934ca495991b7852b855\".to_string()\n             },\n             Test {\n                 input: \"The quick brown fox jumps over the lazy \\\n-                        dog\".to_strbuf(),\n+                        dog\".to_string(),\n                 output_str: \"d7a8fbb307d7809469ca\\\n-            9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592\".to_strbuf()\n+            9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592\".to_string()\n             },\n             Test {\n                 input: \"The quick brown fox jumps over the lazy \\\n-                        dog.\".to_strbuf(),\n+                        dog.\".to_string(),\n                 output_str: \"ef537f25c895bfa78252\\\n-            6529a9b63d97aa631564d5d789c2b765448c8635fb6c\".to_strbuf()\n+            6529a9b63d97aa631564d5d789c2b765448c8635fb6c\".to_string()\n             });\n \n         let tests = wikipedia_tests;"}, {"sha": "c434087dd2b6ce92370270cac87a0b8b71bfee8e", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -87,7 +87,7 @@ fn try_inline_def(cx: &core::DocContext,\n     let fqn = csearch::get_item_path(tcx, did);\n     ret.push(clean::Item {\n         source: clean::Span::empty(),\n-        name: Some(fqn.last().unwrap().to_str().to_strbuf()),\n+        name: Some(fqn.last().unwrap().to_str().to_string()),\n         attrs: load_attrs(tcx, did),\n         inner: inner,\n         visibility: Some(ast::Public),\n@@ -123,7 +123,7 @@ pub fn record_extern_fqn(cx: &core::DocContext,\n     match cx.maybe_typed {\n         core::Typed(ref tcx) => {\n             let fqn = csearch::get_item_path(tcx, did);\n-            let fqn = fqn.move_iter().map(|i| i.to_str().to_strbuf()).collect();\n+            let fqn = fqn.move_iter().map(|i| i.to_str().to_string()).collect();\n             cx.external_paths.borrow_mut().get_mut_ref().insert(did, (fqn, kind));\n         }\n         core::NotTyped(..) => {}"}, {"sha": "33e3e5370e69ed8928b99866709d4eab0531c7e2", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -101,7 +101,7 @@ impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n         let id = link::find_crate_id(self.attrs.as_slice(),\n                                      t_outputs.out_filestem.as_slice());\n         Crate {\n-            name: id.name.to_strbuf(),\n+            name: id.name.to_string(),\n             module: Some(self.module.clean()),\n             externs: externs,\n         }\n@@ -117,7 +117,7 @@ pub struct ExternalCrate {\n impl Clean<ExternalCrate> for cstore::crate_metadata {\n     fn clean(&self) -> ExternalCrate {\n         ExternalCrate {\n-            name: self.name.to_strbuf(),\n+            name: self.name.to_string(),\n             attrs: decoder::get_crate_attributes(self.data()).clean()\n                                                              .move_iter()\n                                                              .collect(),\n@@ -240,7 +240,7 @@ impl Clean<Item> for doctree::Module {\n         let name = if self.name.is_some() {\n             self.name.unwrap().clean()\n         } else {\n-            \"\".to_strbuf()\n+            \"\".to_string()\n         };\n         let mut foreigns = Vec::new();\n         for subforeigns in self.foreigns.clean().move_iter() {\n@@ -305,12 +305,12 @@ pub enum Attribute {\n impl Clean<Attribute> for ast::MetaItem {\n     fn clean(&self) -> Attribute {\n         match self.node {\n-            ast::MetaWord(ref s) => Word(s.get().to_strbuf()),\n+            ast::MetaWord(ref s) => Word(s.get().to_string()),\n             ast::MetaList(ref s, ref l) => {\n-                List(s.get().to_strbuf(), l.clean().move_iter().collect())\n+                List(s.get().to_string(), l.clean().move_iter().collect())\n             }\n             ast::MetaNameValue(ref s, ref v) => {\n-                NameValue(s.get().to_strbuf(), lit_to_str(v))\n+                NameValue(s.get().to_string(), lit_to_str(v))\n             }\n         }\n     }\n@@ -404,7 +404,7 @@ fn external_path(name: &str) -> Path {\n     Path {\n         global: false,\n         segments: vec![PathSegment {\n-            name: name.to_strbuf(),\n+            name: name.to_string(),\n             lifetimes: Vec::new(),\n             types: Vec::new(),\n         }]\n@@ -430,7 +430,7 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n                 (tcx.lang_items.share_trait().unwrap(), external_path(\"Share\")),\n         };\n         let fqn = csearch::get_item_path(tcx, did);\n-        let fqn = fqn.move_iter().map(|i| i.to_str().to_strbuf()).collect();\n+        let fqn = fqn.move_iter().map(|i| i.to_str().to_string()).collect();\n         cx.external_paths.borrow_mut().get_mut_ref().insert(did,\n                                                             (fqn, TypeTrait));\n         TraitBound(ResolvedPath {\n@@ -449,7 +449,7 @@ impl Clean<TyParamBound> for ty::TraitRef {\n             core::NotTyped(_) => return RegionBound,\n         };\n         let fqn = csearch::get_item_path(tcx, self.def_id);\n-        let fqn = fqn.move_iter().map(|i| i.to_str().to_strbuf())\n+        let fqn = fqn.move_iter().map(|i| i.to_str().to_string())\n                      .collect::<Vec<String>>();\n         let path = external_path(fqn.last().unwrap().as_slice());\n         cx.external_paths.borrow_mut().get_mut_ref().insert(self.def_id,\n@@ -503,22 +503,22 @@ impl Lifetime {\n \n impl Clean<Lifetime> for ast::Lifetime {\n     fn clean(&self) -> Lifetime {\n-        Lifetime(token::get_name(self.name).get().to_strbuf())\n+        Lifetime(token::get_name(self.name).get().to_string())\n     }\n }\n \n impl Clean<Lifetime> for ty::RegionParameterDef {\n     fn clean(&self) -> Lifetime {\n-        Lifetime(token::get_name(self.name).get().to_strbuf())\n+        Lifetime(token::get_name(self.name).get().to_string())\n     }\n }\n \n impl Clean<Option<Lifetime>> for ty::Region {\n     fn clean(&self) -> Option<Lifetime> {\n         match *self {\n-            ty::ReStatic => Some(Lifetime(\"static\".to_strbuf())),\n+            ty::ReStatic => Some(Lifetime(\"static\".to_string())),\n             ty::ReLateBound(_, ty::BrNamed(_, name)) =>\n-                Some(Lifetime(token::get_name(name).get().to_strbuf())),\n+                Some(Lifetime(token::get_name(name).get().to_string())),\n \n             ty::ReLateBound(..) |\n             ty::ReEarlyBound(..) |\n@@ -749,7 +749,7 @@ impl<'a> Clean<FnDecl> for (ast::DefId, &'a ty::FnSig) {\n                     Argument {\n                         type_: t.clean(),\n                         id: 0,\n-                        name: names.next().unwrap_or(\"\".to_strbuf()),\n+                        name: names.next().unwrap_or(\"\".to_string()),\n                     }\n                 }).collect(),\n             },\n@@ -1013,7 +1013,7 @@ impl Clean<Type> for ty::t {\n                     lifetimes: Vec::new(), type_params: Vec::new()\n                 },\n                 decl: (ast_util::local_def(0), &fty.sig).clean(),\n-                abi: fty.abi.to_str().to_strbuf(),\n+                abi: fty.abi.to_str(),\n             }),\n             ty::ty_closure(ref fty) => {\n                 let decl = box ClosureDecl {\n@@ -1038,7 +1038,7 @@ impl Clean<Type> for ty::t {\n                 };\n                 let fqn = csearch::get_item_path(tcx, did);\n                 let fqn: Vec<String> = fqn.move_iter().map(|i| {\n-                    i.to_str().to_strbuf()\n+                    i.to_str().to_string()\n                 }).collect();\n                 let mut path = external_path(fqn.last()\n                                                 .unwrap()\n@@ -1302,7 +1302,7 @@ pub struct Span {\n impl Span {\n     fn empty() -> Span {\n         Span {\n-            filename: \"\".to_strbuf(),\n+            filename: \"\".to_string(),\n             loline: 0, locol: 0,\n             hiline: 0, hicol: 0,\n         }\n@@ -1317,7 +1317,7 @@ impl Clean<Span> for syntax::codemap::Span {\n         let lo = cm.lookup_char_pos(self.lo);\n         let hi = cm.lookup_char_pos(self.hi);\n         Span {\n-            filename: filename.to_strbuf(),\n+            filename: filename.to_string(),\n             loline: lo.line,\n             locol: lo.col.to_uint(),\n             hiline: hi.line,\n@@ -1376,13 +1376,13 @@ fn path_to_str(p: &ast::Path) -> String {\n \n impl Clean<String> for ast::Ident {\n     fn clean(&self) -> String {\n-        token::get_ident(*self).get().to_strbuf()\n+        token::get_ident(*self).get().to_string()\n     }\n }\n \n impl Clean<String> for ast::Name {\n     fn clean(&self) -> String {\n-        token::get_name(*self).get().to_strbuf()\n+        token::get_name(*self).get().to_string()\n     }\n }\n \n@@ -1425,7 +1425,7 @@ impl Clean<BareFunctionDecl> for ast::BareFnTy {\n                 type_params: Vec::new(),\n             },\n             decl: self.decl.clean(),\n-            abi: self.abi.to_str().to_strbuf(),\n+            abi: self.abi.to_str().to_string(),\n         }\n     }\n }\n@@ -1582,7 +1582,7 @@ impl Clean<ViewItemInner> for ast::ViewItem_ {\n             &ast::ViewItemExternCrate(ref i, ref p, ref id) => {\n                 let string = match *p {\n                     None => None,\n-                    Some((ref x, _)) => Some(x.get().to_strbuf()),\n+                    Some((ref x, _)) => Some(x.get().to_string()),\n                 };\n                 ExternCrate(i.clean(), string, *id)\n             }\n@@ -1659,7 +1659,7 @@ impl Clean<Item> for ast::ForeignItem {\n                 ForeignStaticItem(Static {\n                     type_: ty.clean(),\n                     mutability: if mutbl {Mutable} else {Immutable},\n-                    expr: \"\".to_strbuf(),\n+                    expr: \"\".to_string(),\n                 })\n             }\n         };\n@@ -1686,8 +1686,8 @@ impl ToSource for syntax::codemap::Span {\n         let ctxt = super::ctxtkey.get().unwrap();\n         let cm = ctxt.sess().codemap().clone();\n         let sn = match cm.span_to_snippet(*self) {\n-            Some(x) => x.to_strbuf(),\n-            None    => \"\".to_strbuf()\n+            Some(x) => x.to_string(),\n+            None    => \"\".to_string()\n         };\n         debug!(\"got snippet {}\", sn);\n         sn\n@@ -1696,16 +1696,16 @@ impl ToSource for syntax::codemap::Span {\n \n fn lit_to_str(lit: &ast::Lit) -> String {\n     match lit.node {\n-        ast::LitStr(ref st, _) => st.get().to_strbuf(),\n+        ast::LitStr(ref st, _) => st.get().to_string(),\n         ast::LitBinary(ref data) => format_strbuf!(\"{:?}\", data.as_slice()),\n         ast::LitChar(c) => format_strbuf!(\"'{}'\", c),\n-        ast::LitInt(i, _t) => i.to_str().to_strbuf(),\n-        ast::LitUint(u, _t) => u.to_str().to_strbuf(),\n-        ast::LitIntUnsuffixed(i) => i.to_str().to_strbuf(),\n-        ast::LitFloat(ref f, _t) => f.get().to_strbuf(),\n-        ast::LitFloatUnsuffixed(ref f) => f.get().to_strbuf(),\n-        ast::LitBool(b) => b.to_str().to_strbuf(),\n-        ast::LitNil => \"\".to_strbuf(),\n+        ast::LitInt(i, _t) => i.to_str().to_string(),\n+        ast::LitUint(u, _t) => u.to_str().to_string(),\n+        ast::LitIntUnsuffixed(i) => i.to_str().to_string(),\n+        ast::LitFloat(ref f, _t) => f.get().to_string(),\n+        ast::LitFloatUnsuffixed(ref f) => f.get().to_string(),\n+        ast::LitBool(b) => b.to_str().to_string(),\n+        ast::LitNil => \"\".to_string(),\n     }\n }\n \n@@ -1714,19 +1714,19 @@ fn name_from_pat(p: &ast::Pat) -> String {\n     debug!(\"Trying to get a name from pattern: {:?}\", p);\n \n     match p.node {\n-        PatWild => \"_\".to_strbuf(),\n-        PatWildMulti => \"..\".to_strbuf(),\n+        PatWild => \"_\".to_string(),\n+        PatWildMulti => \"..\".to_string(),\n         PatIdent(_, ref p, _) => path_to_str(p),\n         PatEnum(ref p, _) => path_to_str(p),\n         PatStruct(..) => fail!(\"tried to get argument name from pat_struct, \\\n                                 which is not allowed in function arguments\"),\n-        PatTup(..) => \"(tuple arg NYI)\".to_strbuf(),\n+        PatTup(..) => \"(tuple arg NYI)\".to_string(),\n         PatUniq(p) => name_from_pat(p),\n         PatRegion(p) => name_from_pat(p),\n         PatLit(..) => {\n             warn!(\"tried to get argument name from PatLit, \\\n                   which is silly in function arguments\");\n-            \"()\".to_strbuf()\n+            \"()\".to_string()\n         },\n         PatRange(..) => fail!(\"tried to get argument name from PatRange, \\\n                               which is not allowed in function arguments\"),"}, {"sha": "c1b5b8af07af614ff8fc0da27b899b9350ec5f57", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -151,12 +151,12 @@ fn resolved_path(w: &mut fmt::Formatter, did: ast::DefId, p: &clean::Path,\n     path(w, p, print_all,\n         |cache, loc| {\n             if ast_util::is_local(did) || cache.paths.contains_key(&did) {\n-                Some((\"../\".repeat(loc.len())).to_strbuf())\n+                Some((\"../\".repeat(loc.len())).to_string())\n             } else {\n                 match *cache.extern_locations.get(&did.krate) {\n-                    render::Remote(ref s) => Some(s.to_strbuf()),\n+                    render::Remote(ref s) => Some(s.to_string()),\n                     render::Local => {\n-                        Some((\"../\".repeat(loc.len())).to_strbuf())\n+                        Some((\"../\".repeat(loc.len())).to_string())\n                     }\n                     render::Unknown => None,\n                 }\n@@ -198,7 +198,7 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n     let cache = cache_key.get().unwrap();\n     let abs_root = root(&**cache, loc.as_slice());\n     let rel_root = match path.segments.get(0).name.as_slice() {\n-        \"self\" => Some(\"./\".to_owned()),\n+        \"self\" => Some(\"./\".to_string()),\n         _ => None,\n     };\n \n@@ -323,7 +323,7 @@ impl fmt::Show for clean::Type {\n                            {arrow, select, yes{ -&gt; {ret}} other{}}\",\n                        style = FnStyleSpace(decl.fn_style),\n                        lifetimes = if decl.lifetimes.len() == 0 {\n-                           \"\".to_strbuf()\n+                           \"\".to_string()\n                        } else {\n                            format!(\"&lt;{:#}&gt;\", decl.lifetimes)\n                        },\n@@ -364,17 +364,17 @@ impl fmt::Show for clean::Type {\n                            {arrow, select, yes{ -&gt; {ret}} other{}}\",\n                        style = FnStyleSpace(decl.fn_style),\n                        lifetimes = if decl.lifetimes.len() == 0 {\n-                           \"\".to_strbuf()\n+                           \"\".to_string()\n                        } else {\n                            format_strbuf!(\"&lt;{:#}&gt;\", decl.lifetimes)\n                        },\n                        args = decl.decl.inputs,\n                        bounds = if decl.bounds.len() == 0 {\n-                           \"\".to_strbuf()\n+                           \"\".to_string()\n                        } else {\n                            let mut m = decl.bounds\n                                            .iter()\n-                                           .map(|s| s.to_str().to_strbuf());\n+                                           .map(|s| s.to_str().to_string());\n                            format_strbuf!(\n                                \": {}\",\n                                m.collect::<Vec<String>>().connect(\" + \"))\n@@ -386,8 +386,8 @@ impl fmt::Show for clean::Type {\n                 write!(f, \"{}{}fn{}{}\",\n                        FnStyleSpace(decl.fn_style),\n                        match decl.abi.as_slice() {\n-                           \"\" => \" extern \".to_strbuf(),\n-                           \"\\\"Rust\\\"\" => \"\".to_strbuf(),\n+                           \"\" => \" extern \".to_string(),\n+                           \"\\\"Rust\\\"\" => \"\".to_string(),\n                            s => format_strbuf!(\" extern {} \", s)\n                        },\n                        decl.generics,\n@@ -423,7 +423,7 @@ impl fmt::Show for clean::Type {\n             clean::BorrowedRef{ lifetime: ref l, mutability, type_: ref ty} => {\n                 let lt = match *l {\n                     Some(ref l) => format!(\"{} \", *l),\n-                    _ => \"\".to_strbuf(),\n+                    _ => \"\".to_string(),\n                 };\n                 write!(f, \"&amp;{}{}{}\",\n                        lt,"}, {"sha": "1f3ed01092858e662a08befbdf76ca4da4e3091d", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -29,15 +29,15 @@ pub fn highlight(src: &str, class: Option<&str>) -> String {\n     debug!(\"highlighting: ================\\n{}\\n==============\", src);\n     let sess = parse::new_parse_sess();\n     let fm = parse::string_to_filemap(&sess,\n-                                      src.to_strbuf(),\n-                                      \"<stdin>\".to_strbuf());\n+                                      src.to_string(),\n+                                      \"<stdin>\".to_string());\n \n     let mut out = io::MemWriter::new();\n     doit(&sess,\n          lexer::new_string_reader(&sess.span_diagnostic, fm),\n          class,\n          &mut out).unwrap();\n-    str::from_utf8_lossy(out.unwrap().as_slice()).to_strbuf()\n+    str::from_utf8_lossy(out.unwrap().as_slice()).to_string()\n }\n \n /// Exhausts the `lexer` writing the output into `out`."}, {"sha": "d1153db8d30db95f5b9d6e0d633ad53583c952b3", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -197,7 +197,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n \n         // Extract the text provided\n         let s = if text.is_null() {\n-            \"\".to_owned()\n+            \"\".to_string()\n         } else {\n             unsafe {\n                 str::raw::from_buf_len((*text).data, (*text).size as uint)\n@@ -207,14 +207,14 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n         // Transform the contents of the header into a hyphenated string\n         let id = (s.as_slice().words().map(|s| {\n             match s.to_ascii_opt() {\n-                Some(s) => s.to_lower().into_str().to_strbuf(),\n-                None => s.to_strbuf()\n+                Some(s) => s.to_lower().into_str().to_string(),\n+                None => s.to_string()\n             }\n-        }).collect::<Vec<String>>().connect(\"-\")).to_strbuf();\n+        }).collect::<Vec<String>>().connect(\"-\")).to_string();\n \n         // This is a terrible hack working around how hoedown gives us rendered\n         // html for text rather than the raw text.\n-        let id = id.replace(\"<code>\", \"\").replace(\"</code>\", \"\").to_strbuf();\n+        let id = id.replace(\"<code>\", \"\").replace(\"</code>\", \"\").to_string();\n \n         let opaque = opaque as *mut hoedown_html_renderer_state;\n         let opaque = unsafe { &mut *((*opaque).opaque as *mut MyOpaque) };\n@@ -229,7 +229,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n \n         let sec = match opaque.toc_builder {\n             Some(ref mut builder) => {\n-                builder.push(level as u32, s.to_strbuf(), id.clone())\n+                builder.push(level as u32, s.to_string(), id.clone())\n             }\n             None => {\"\"}\n         };\n@@ -302,7 +302,7 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n                     stripped_filtered_line(l).unwrap_or(l)\n                 });\n                 let text = lines.collect::<Vec<&str>>().connect(\"\\n\");\n-                tests.add_test(text.to_strbuf(), should_fail, no_run, ignore);\n+                tests.add_test(text.to_string(), should_fail, no_run, ignore);\n             })\n         }\n     }"}, {"sha": "a23aefe03e813af9eca58140f79099c8635dad04", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -218,8 +218,8 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n         root_path: String::new(),\n         sidebar: HashMap::new(),\n         layout: layout::Layout {\n-            logo: \"\".to_strbuf(),\n-            favicon: \"\".to_strbuf(),\n+            logo: \"\".to_string(),\n+            favicon: \"\".to_string(),\n             krate: krate.name.clone(),\n         },\n         include_sources: true,\n@@ -232,11 +232,11 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n                 match *attr {\n                     clean::NameValue(ref x, ref s)\n                             if \"html_favicon_url\" == x.as_slice() => {\n-                        cx.layout.favicon = s.to_strbuf();\n+                        cx.layout.favicon = s.to_string();\n                     }\n                     clean::NameValue(ref x, ref s)\n                             if \"html_logo_url\" == x.as_slice() => {\n-                        cx.layout.logo = s.to_strbuf();\n+                        cx.layout.logo = s.to_string();\n                     }\n                     clean::Word(ref x)\n                             if \"html_no_source\" == x.as_slice() => {\n@@ -307,8 +307,8 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n                         ty: shortty(item),\n                         name: item.name.clone().unwrap(),\n                         path: fqp.slice_to(fqp.len() - 1).connect(\"::\")\n-                                                         .to_strbuf(),\n-                        desc: shorter(item.doc_value()).to_strbuf(),\n+                                                         .to_string(),\n+                        desc: shorter(item.doc_value()).to_string(),\n                         parent: Some(did),\n                     });\n                 },\n@@ -338,14 +338,14 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n         let mut w = MemWriter::new();\n         try!(write!(&mut w, r#\"searchIndex['{}'] = \\{\"items\":[\"#, krate.name));\n \n-        let mut lastpath = \"\".to_strbuf();\n+        let mut lastpath = \"\".to_string();\n         for (i, item) in cache.search_index.iter().enumerate() {\n             // Omit the path if it is same to that of the prior item.\n             let path;\n             if lastpath.as_slice() == item.path.as_slice() {\n                 path = \"\";\n             } else {\n-                lastpath = item.path.to_strbuf();\n+                lastpath = item.path.to_string();\n                 path = item.path.as_slice();\n             };\n \n@@ -378,7 +378,7 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n \n         try!(write!(&mut w, r\"]\\};\"));\n \n-        str::from_utf8(w.unwrap().as_slice()).unwrap().to_owned()\n+        str::from_utf8(w.unwrap().as_slice()).unwrap().to_string()\n     };\n \n     // Write out the shared files. Note that these are shared among all rustdoc\n@@ -420,7 +420,7 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n                             format!(\"{}['{}']\", key, krate).as_slice()) {\n                         continue\n                     }\n-                    ret.push(line.to_strbuf());\n+                    ret.push(line.to_string());\n                 }\n             }\n             return Ok(ret);\n@@ -504,14 +504,14 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n             cx: &mut cx,\n         };\n         // skip all invalid spans\n-        folder.seen.insert(\"\".to_strbuf());\n+        folder.seen.insert(\"\".to_string());\n         krate = folder.fold_crate(krate);\n     }\n \n     for &(n, ref e) in krate.externs.iter() {\n         cache.extern_locations.insert(n, extern_location(e, &cx.dst));\n         let did = ast::DefId { krate: n, node: ast::CRATE_NODE_ID };\n-        cache.paths.insert(did, (vec![e.name.to_strbuf()], item_type::Module));\n+        cache.paths.insert(did, (vec![e.name.to_string()], item_type::Module));\n     }\n \n     // And finally render the whole crate's documentation\n@@ -570,7 +570,7 @@ fn extern_location(e: &clean::ExternalCrate, dst: &Path) -> ExternalLocation {\n                         clean::NameValue(ref x, ref s)\n                                 if \"html_root_url\" == x.as_slice() => {\n                             if s.as_slice().ends_with(\"/\") {\n-                                return Remote(s.to_strbuf());\n+                                return Remote(s.to_string());\n                             }\n                             return Remote(format_strbuf!(\"{}/\", s));\n                         }\n@@ -766,9 +766,9 @@ impl DocFolder for Cache {\n                     (parent, Some(path)) if !self.privmod => {\n                         self.search_index.push(IndexItem {\n                             ty: shortty(&item),\n-                            name: s.to_strbuf(),\n-                            path: path.connect(\"::\").to_strbuf(),\n-                            desc: shorter(item.doc_value()).to_strbuf(),\n+                            name: s.to_string(),\n+                            path: path.connect(\"::\").to_string(),\n+                            desc: shorter(item.doc_value()).to_string(),\n                             parent: parent,\n                         });\n                     }\n@@ -789,7 +789,7 @@ impl DocFolder for Cache {\n         let pushed = if item.name.is_some() {\n             let n = item.name.get_ref();\n             if n.len() > 0 {\n-                self.stack.push(n.to_strbuf());\n+                self.stack.push(n.to_string());\n                 true\n             } else { false }\n         } else { false };\n@@ -1001,7 +1001,7 @@ impl Context {\n             // modules are special because they add a namespace. We also need to\n             // recurse into the items of the module as well.\n             clean::ModuleItem(..) => {\n-                let name = item.name.get_ref().to_strbuf();\n+                let name = item.name.get_ref().to_string();\n                 let mut item = Some(item);\n                 self.recurse(name, |this| {\n                     let item = item.take_unwrap();\n@@ -1057,7 +1057,7 @@ impl<'a> Item<'a> {\n         if ast_util::is_local(self.item.def_id) {\n             let mut path = Vec::new();\n             clean_srcpath(self.item.source.filename.as_bytes(), |component| {\n-                path.push(component.to_owned());\n+                path.push(component.to_string());\n             });\n             let href = if self.item.source.loline == self.item.source.hiline {\n                 format!(\"{}\", self.item.source.loline)\n@@ -1087,7 +1087,7 @@ impl<'a> Item<'a> {\n             let cache = cache_key.get().unwrap();\n             let path = cache.external_paths.get(&self.item.def_id);\n             let root = match *cache.extern_locations.get(&self.item.def_id.krate) {\n-                Remote(ref s) => s.to_strbuf(),\n+                Remote(ref s) => s.to_string(),\n                 Local => format!(\"{}/..\", self.cx.root_path),\n                 Unknown => return None,\n             };\n@@ -1908,9 +1908,9 @@ fn build_sidebar(m: &clean::Module) -> HashMap<String, Vec<String>> {\n         let short = shortty(item).to_static_str();\n         let myname = match item.name {\n             None => continue,\n-            Some(ref s) => s.to_strbuf(),\n+            Some(ref s) => s.to_string(),\n         };\n-        let v = map.find_or_insert_with(short.to_strbuf(), |_| Vec::new());\n+        let v = map.find_or_insert_with(short.to_string(), |_| Vec::new());\n         v.push(myname);\n     }\n "}, {"sha": "212fe006aa1be8a4e494df8dbfbf6d6bebd000d1", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -202,8 +202,8 @@ mod test {\n         macro_rules! push {\n             ($level: expr, $name: expr) => {\n                 assert_eq!(builder.push($level,\n-                                        $name.to_strbuf(),\n-                                        \"\".to_strbuf()),\n+                                        $name.to_string(),\n+                                        \"\".to_string()),\n                            $name);\n             }\n         }\n@@ -242,9 +242,9 @@ mod test {\n                         $(\n                             TocEntry {\n                                 level: $level,\n-                                name: $name.to_strbuf(),\n-                                sec_number: $name.to_strbuf(),\n-                                id: \"\".to_strbuf(),\n+                                name: $name.to_string(),\n+                                sec_number: $name.to_string(),\n+                                id: \"\".to_string(),\n                                 children: toc!($($sub),*)\n                             }\n                             ),*"}, {"sha": "160994f603aa3e15764dd7ac4646df64fbe3b3ef", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -86,7 +86,7 @@ type Output = (clean::Crate, Vec<plugins::PluginJson> );\n \n pub fn main() {\n     std::os::set_exit_status(main_args(std::os::args().iter()\n-                                                      .map(|x| x.to_strbuf())\n+                                                      .map(|x| x.to_string())\n                                                       .collect::<Vec<_>>()\n                                                       .as_slice()));\n }\n@@ -166,7 +166,7 @@ pub fn main_args(args: &[String]) -> int {\n     let test_args = matches.opt_strs(\"test-args\");\n     let test_args: Vec<String> = test_args.iter()\n                                           .flat_map(|s| s.as_slice().words())\n-                                          .map(|s| s.to_strbuf())\n+                                          .map(|s| s.to_string())\n                                           .collect();\n \n     let should_test = matches.opt_present(\"test\");\n@@ -184,7 +184,7 @@ pub fn main_args(args: &[String]) -> int {\n         (true, false) => {\n             return test::run(input,\n                              cfgs.move_iter()\n-                                 .map(|x| x.to_strbuf())\n+                                 .map(|x| x.to_string())\n                                  .collect(),\n                              libs,\n                              test_args)\n@@ -194,7 +194,7 @@ pub fn main_args(args: &[String]) -> int {\n         (false, false) => {}\n     }\n \n-    if matches.opt_strs(\"passes\").as_slice() == &[\"list\".to_strbuf()] {\n+    if matches.opt_strs(\"passes\").as_slice() == &[\"list\".to_string()] {\n         println!(\"Available passes for running rustdoc:\");\n         for &(name, _, description) in PASSES.iter() {\n             println!(\"{:>20s} - {}\", name, description);\n@@ -268,7 +268,7 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n     let mut passes = matches.opt_strs(\"passes\");\n     let mut plugins = matches.opt_strs(\"plugins\")\n                              .move_iter()\n-                             .map(|x| x.to_strbuf())\n+                             .map(|x| x.to_string())\n                              .collect::<Vec<_>>();\n \n     // First, parse the crate and extract all relevant information.\n@@ -282,7 +282,7 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n     let (krate, analysis) = std::task::try(proc() {\n         let cr = cr;\n         core::run_core(libs.move_iter().map(|x| x.clone()).collect(),\n-                       cfgs.move_iter().map(|x| x.to_strbuf()).collect(),\n+                       cfgs.move_iter().map(|x| x.to_string()).collect(),\n                        &cr)\n     }).map_err(|boxed_any|format!(\"{:?}\", boxed_any)).unwrap();\n     info!(\"finished with rustc\");\n@@ -301,13 +301,13 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n                     clean::NameValue(ref x, ref value)\n                             if \"passes\" == x.as_slice() => {\n                         for pass in value.as_slice().words() {\n-                            passes.push(pass.to_strbuf());\n+                            passes.push(pass.to_string());\n                         }\n                     }\n                     clean::NameValue(ref x, ref value)\n                             if \"plugins\" == x.as_slice() => {\n                         for p in value.as_slice().words() {\n-                            plugins.push(p.to_strbuf());\n+                            plugins.push(p.to_string());\n                         }\n                     }\n                     _ => {}\n@@ -318,13 +318,13 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n     }\n     if default_passes {\n         for name in DEFAULT_PASSES.iter().rev() {\n-            passes.unshift(name.to_strbuf());\n+            passes.unshift(name.to_string());\n         }\n     }\n \n     // Load all plugins/passes into a PluginManager\n     let path = matches.opt_str(\"plugin-path\")\n-                      .unwrap_or(\"/tmp/rustdoc/plugins\".to_strbuf());\n+                      .unwrap_or(\"/tmp/rustdoc/plugins\".to_string());\n     let mut pm = plugins::PluginManager::new(Path::new(path));\n     for pass in passes.iter() {\n         let plugin = match PASSES.iter()\n@@ -359,27 +359,27 @@ fn json_input(input: &str) -> Result<Output, String> {\n         }\n     };\n     match json::from_reader(&mut input) {\n-        Err(s) => Err(s.to_str().to_strbuf()),\n+        Err(s) => Err(s.to_str().to_string()),\n         Ok(json::Object(obj)) => {\n             let mut obj = obj;\n             // Make sure the schema is what we expect\n-            match obj.pop(&\"schema\".to_strbuf()) {\n+            match obj.pop(&\"schema\".to_string()) {\n                 Some(json::String(version)) => {\n                     if version.as_slice() != SCHEMA_VERSION {\n                         return Err(format_strbuf!(\n                                 \"sorry, but I only understand version {}\",\n                                 SCHEMA_VERSION))\n                     }\n                 }\n-                Some(..) => return Err(\"malformed json\".to_strbuf()),\n-                None => return Err(\"expected a schema version\".to_strbuf()),\n+                Some(..) => return Err(\"malformed json\".to_string()),\n+                None => return Err(\"expected a schema version\".to_string()),\n             }\n-            let krate = match obj.pop(&\"crate\".to_strbuf()) {\n+            let krate = match obj.pop(&\"crate\".to_string()) {\n                 Some(json) => {\n                     let mut d = json::Decoder::new(json);\n                     Decodable::decode(&mut d).unwrap()\n                 }\n-                None => return Err(\"malformed json\".to_strbuf()),\n+                None => return Err(\"malformed json\".to_string()),\n             };\n             // FIXME: this should read from the \"plugins\" field, but currently\n             //      Json doesn't implement decodable...\n@@ -388,7 +388,7 @@ fn json_input(input: &str) -> Result<Output, String> {\n         }\n         Ok(..) => {\n             Err(\"malformed json input: expected an object at the \\\n-                 top\".to_strbuf())\n+                 top\".to_string())\n         }\n     }\n }\n@@ -403,14 +403,14 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n     //   \"plugins\": { output of plugins ... }\n     // }\n     let mut json = box collections::TreeMap::new();\n-    json.insert(\"schema\".to_strbuf(),\n-                json::String(SCHEMA_VERSION.to_strbuf()));\n+    json.insert(\"schema\".to_string(),\n+                json::String(SCHEMA_VERSION.to_string()));\n     let plugins_json = box res.move_iter()\n                               .filter_map(|opt| {\n                                   match opt {\n                                       None => None,\n                                       Some((string, json)) => {\n-                                          Some((string.to_strbuf(), json))\n+                                          Some((string.to_string(), json))\n                                       }\n                                   }\n                               }).collect();\n@@ -423,15 +423,15 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n             let mut encoder = json::Encoder::new(&mut w as &mut io::Writer);\n             krate.encode(&mut encoder).unwrap();\n         }\n-        str::from_utf8(w.unwrap().as_slice()).unwrap().to_strbuf()\n+        str::from_utf8(w.unwrap().as_slice()).unwrap().to_string()\n     };\n     let crate_json = match json::from_str(crate_json_str.as_slice()) {\n         Ok(j) => j,\n         Err(e) => fail!(\"Rust generated JSON is invalid: {:?}\", e)\n     };\n \n-    json.insert(\"crate\".to_strbuf(), crate_json);\n-    json.insert(\"plugins\".to_strbuf(), json::Object(plugins_json));\n+    json.insert(\"crate\".to_string(), crate_json);\n+    json.insert(\"plugins\".to_string(), json::Object(plugins_json));\n \n     let mut file = try!(File::create(&dst));\n     try!(json::Object(json).to_writer(&mut file));"}, {"sha": "f5cfc840562b4e69ab45ddf83aa12a6e8432afe6", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -22,7 +22,7 @@ use test::Collector;\n fn load_string(input: &Path) -> io::IoResult<Option<String>> {\n     let mut f = try!(io::File::open(input));\n     let d = try!(f.read_to_end());\n-    Ok(str::from_utf8(d.as_slice()).map(|s| s.to_strbuf()))\n+    Ok(str::from_utf8(d.as_slice()).map(|s| s.to_string()))\n }\n macro_rules! load_or_return {\n     ($input: expr, $cant_read: expr, $not_utf8: expr) => {\n@@ -88,17 +88,17 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches) -> int\n     let (in_header, before_content, after_content) =\n         match (load_external_files(matches.opt_strs(\"markdown-in-header\")\n                                           .move_iter()\n-                                          .map(|x| x.to_strbuf())\n+                                          .map(|x| x.to_string())\n                                           .collect::<Vec<_>>()\n                                           .as_slice()),\n                load_external_files(matches.opt_strs(\"markdown-before-content\")\n                                           .move_iter()\n-                                          .map(|x| x.to_strbuf())\n+                                          .map(|x| x.to_string())\n                                           .collect::<Vec<_>>()\n                                           .as_slice()),\n                load_external_files(matches.opt_strs(\"markdown-after-content\")\n                                           .move_iter()\n-                                          .map(|x| x.to_strbuf())\n+                                          .map(|x| x.to_string())\n                                           .collect::<Vec<_>>()\n                                           .as_slice())) {\n         (Some(a), Some(b), Some(c)) => (a,b,c),\n@@ -173,9 +173,9 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches) -> int\n pub fn test(input: &str, libs: HashSet<Path>, mut test_args: Vec<String>) -> int {\n     let input_str = load_or_return!(input, 1, 2);\n \n-    let mut collector = Collector::new(input.to_strbuf(), libs, true, true);\n+    let mut collector = Collector::new(input.to_string(), libs, true, true);\n     find_testable_code(input_str.as_slice(), &mut collector);\n-    test_args.unshift(\"rustdoctest\".to_strbuf());\n+    test_args.unshift(\"rustdoctest\".to_string());\n     testing::test_main(test_args.as_slice(), collector.tests);\n     0\n }"}, {"sha": "efb0689404a5d1782fa31f7f55fdb5b38f032b2a", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -233,7 +233,7 @@ pub fn unindent_comments(krate: clean::Crate) -> plugins::PluginResult {\n                 match attr {\n                     &clean::NameValue(ref x, ref s)\n                             if \"doc\" == x.as_slice() => {\n-                        avec.push(clean::NameValue(\"doc\".to_strbuf(),\n+                        avec.push(clean::NameValue(\"doc\".to_string(),\n                                                    unindent(s.as_slice())))\n                     }\n                     x => avec.push(x.clone())\n@@ -269,7 +269,7 @@ pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n                 _ => true\n             }).map(|x| x.clone()).collect();\n             if docstr.len() > 0 {\n-                a.push(clean::NameValue(\"doc\".to_strbuf(), docstr));\n+                a.push(clean::NameValue(\"doc\".to_string(), docstr));\n             }\n             i.attrs = a;\n             self.fold_item_recur(i)\n@@ -325,18 +325,18 @@ pub fn unindent(s: &str) -> String {\n     });\n \n     if lines.len() >= 1 {\n-        let mut unindented = vec![ lines.get(0).trim().to_strbuf() ];\n+        let mut unindented = vec![ lines.get(0).trim().to_string() ];\n         unindented.push_all(lines.tail().iter().map(|&line| {\n             if line.is_whitespace() {\n-                line.to_strbuf()\n+                line.to_string()\n             } else {\n                 assert!(line.len() >= min_indent);\n-                line.slice_from(min_indent).to_strbuf()\n+                line.slice_from(min_indent).to_string()\n             }\n         }).collect::<Vec<_>>().as_slice());\n-        unindented.connect(\"\\n\").to_strbuf()\n+        unindented.connect(\"\\n\").to_string()\n     } else {\n-        s.to_strbuf()\n+        s.to_string()\n     }\n }\n \n@@ -346,14 +346,14 @@ mod unindent_tests {\n \n     #[test]\n     fn should_unindent() {\n-        let s = \"    line1\\n    line2\".to_owned();\n+        let s = \"    line1\\n    line2\".to_string();\n         let r = unindent(s.as_slice());\n         assert_eq!(r.as_slice(), \"line1\\nline2\");\n     }\n \n     #[test]\n     fn should_unindent_multiple_paragraphs() {\n-        let s = \"    line1\\n\\n    line2\".to_owned();\n+        let s = \"    line1\\n\\n    line2\".to_string();\n         let r = unindent(s.as_slice());\n         assert_eq!(r.as_slice(), \"line1\\n\\nline2\");\n     }\n@@ -362,7 +362,7 @@ mod unindent_tests {\n     fn should_leave_multiple_indent_levels() {\n         // Line 2 is indented another level beyond the\n         // base indentation and should be preserved\n-        let s = \"    line1\\n\\n        line2\".to_owned();\n+        let s = \"    line1\\n\\n        line2\".to_string();\n         let r = unindent(s.as_slice());\n         assert_eq!(r.as_slice(), \"line1\\n\\n    line2\");\n     }\n@@ -374,14 +374,14 @@ mod unindent_tests {\n         //\n         // #[doc = \"Start way over here\n         //          and continue here\"]\n-        let s = \"line1\\n    line2\".to_owned();\n+        let s = \"line1\\n    line2\".to_string();\n         let r = unindent(s.as_slice());\n         assert_eq!(r.as_slice(), \"line1\\nline2\");\n     }\n \n     #[test]\n     fn should_not_ignore_first_line_indent_in_a_single_line_para() {\n-        let s = \"line1\\n\\n    line2\".to_owned();\n+        let s = \"line1\\n\\n    line2\".to_string();\n         let r = unindent(s.as_slice());\n         assert_eq!(r.as_slice(), \"line1\\n\\n    line2\");\n     }"}, {"sha": "4023010537e7296aab09907baf5553b8bff5d2b6", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -87,13 +87,13 @@ pub fn run(input: &str,\n     let (krate, _) = passes::unindent_comments(krate);\n     let (krate, _) = passes::collapse_docs(krate);\n \n-    let mut collector = Collector::new(krate.name.to_strbuf(),\n+    let mut collector = Collector::new(krate.name.to_string(),\n                                        libs,\n                                        false,\n                                        false);\n     collector.fold_crate(krate);\n \n-    test_args.unshift(\"rustdoctest\".to_strbuf());\n+    test_args.unshift(\"rustdoctest\".to_string());\n \n     testing::test_main(test_args.as_slice(),\n                        collector.tests.move_iter().collect());\n@@ -103,7 +103,7 @@ pub fn run(input: &str,\n fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n            no_run: bool, loose_feature_gating: bool) {\n     let test = maketest(test, cratename, loose_feature_gating);\n-    let input = driver::StrInput(test.to_strbuf());\n+    let input = driver::StrInput(test.to_string());\n \n     let sessopts = config::Options {\n         maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),\n@@ -179,8 +179,8 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n \n         // Add the new dylib search path var\n         let newpath = DynamicLibrary::create_path(path.as_slice());\n-        env.push((var.to_owned(),\n-                  str::from_utf8(newpath.as_slice()).unwrap().to_owned()));\n+        env.push((var.to_string(),\n+                  str::from_utf8(newpath.as_slice()).unwrap().to_string()));\n         env\n     };\n     match Command::new(exe).env(env.as_slice()).output() {\n@@ -265,7 +265,7 @@ impl Collector {\n         };\n         self.cnt += 1;\n         let libs = self.libs.clone();\n-        let cratename = self.cratename.to_owned();\n+        let cratename = self.cratename.to_string();\n         let loose_feature_gating = self.loose_feature_gating;\n         debug!(\"Creating test {}: {}\", name, test);\n         self.tests.push(testing::TestDescAndFn {\n@@ -309,7 +309,7 @@ impl DocFolder for Collector {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         let pushed = match item.name {\n             Some(ref name) if name.len() == 0 => false,\n-            Some(ref name) => { self.names.push(name.to_strbuf()); true }\n+            Some(ref name) => { self.names.push(name.to_string()); true }\n             None => false\n         };\n         match item.doc_value() {"}, {"sha": "4bae9bb797a72d00c6249b73561442d4fc0466e0", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -359,7 +359,7 @@ impl UvError {\n             let inner = match self { &UvError(a) => a };\n             let name_str = uvll::uv_err_name(inner);\n             assert!(name_str.is_not_null());\n-            from_c_str(name_str).to_strbuf()\n+            from_c_str(name_str).to_string()\n         }\n     }\n \n@@ -368,7 +368,7 @@ impl UvError {\n             let inner = match self { &UvError(a) => a };\n             let desc_str = uvll::uv_strerror(inner);\n             assert!(desc_str.is_not_null());\n-            from_c_str(desc_str).to_strbuf()\n+            from_c_str(desc_str).to_string()\n         }\n     }\n \n@@ -387,7 +387,7 @@ impl fmt::Show for UvError {\n #[test]\n fn error_smoke_test() {\n     let err: UvError = UvError(uvll::EOF);\n-    assert_eq!(err.to_str(), \"EOF: end of file\".to_strbuf());\n+    assert_eq!(err.to_str(), \"EOF: end of file\".to_string());\n }\n \n pub fn uv_error_to_io_error(uverr: UvError) -> IoError {"}, {"sha": "e533120b3dd0002a2e869373cead76f95f822100", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -851,15 +851,15 @@ mod test {\n     fn connect_close_ip4() {\n         match TcpWatcher::connect(local_loop(), next_test_ip4(), None) {\n             Ok(..) => fail!(),\n-            Err(e) => assert_eq!(e.name(), \"ECONNREFUSED\".to_strbuf()),\n+            Err(e) => assert_eq!(e.name(), \"ECONNREFUSED\".to_string()),\n         }\n     }\n \n     #[test]\n     fn connect_close_ip6() {\n         match TcpWatcher::connect(local_loop(), next_test_ip6(), None) {\n             Ok(..) => fail!(),\n-            Err(e) => assert_eq!(e.name(), \"ECONNREFUSED\".to_strbuf()),\n+            Err(e) => assert_eq!(e.name(), \"ECONNREFUSED\".to_string()),\n         }\n     }\n "}, {"sha": "cf3d4f672e6183b80d2576b72a57a233712f3927", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -338,7 +338,7 @@ mod tests {\n     fn bind_err() {\n         match PipeListener::bind(local_loop(), &\"path/to/nowhere\".to_c_str()) {\n             Ok(..) => fail!(),\n-            Err(e) => assert_eq!(e.name(), \"EACCES\".to_strbuf()),\n+            Err(e) => assert_eq!(e.name(), \"EACCES\".to_string()),\n         }\n     }\n "}, {"sha": "a119d4832db45d4de9c47ac9507ff3b24ded05e9", "filename": "src/libsemver/lib.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsemver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsemver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsemver%2Flib.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -308,52 +308,52 @@ fn test_parse() {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n-        pre: vec!(AlphaNumeric(\"alpha1\".to_strbuf())),\n+        pre: vec!(AlphaNumeric(\"alpha1\".to_string())),\n         build: vec!(),\n     }));\n     assert!(parse(\"  1.2.3-alpha1  \") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n-        pre: vec!(AlphaNumeric(\"alpha1\".to_strbuf())),\n+        pre: vec!(AlphaNumeric(\"alpha1\".to_string())),\n         build: vec!()\n     }));\n     assert!(parse(\"1.2.3+build5\") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n         pre: vec!(),\n-        build: vec!(AlphaNumeric(\"build5\".to_strbuf()))\n+        build: vec!(AlphaNumeric(\"build5\".to_string()))\n     }));\n     assert!(parse(\"  1.2.3+build5  \") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n         pre: vec!(),\n-        build: vec!(AlphaNumeric(\"build5\".to_strbuf()))\n+        build: vec!(AlphaNumeric(\"build5\".to_string()))\n     }));\n     assert!(parse(\"1.2.3-alpha1+build5\") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n-        pre: vec!(AlphaNumeric(\"alpha1\".to_strbuf())),\n-        build: vec!(AlphaNumeric(\"build5\".to_strbuf()))\n+        pre: vec!(AlphaNumeric(\"alpha1\".to_string())),\n+        build: vec!(AlphaNumeric(\"build5\".to_string()))\n     }));\n     assert!(parse(\"  1.2.3-alpha1+build5  \") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n-        pre: vec!(AlphaNumeric(\"alpha1\".to_strbuf())),\n-        build: vec!(AlphaNumeric(\"build5\".to_strbuf()))\n+        pre: vec!(AlphaNumeric(\"alpha1\".to_string())),\n+        build: vec!(AlphaNumeric(\"build5\".to_string()))\n     }));\n     assert!(parse(\"1.2.3-1.alpha1.9+build5.7.3aedf  \") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n-        pre: vec!(Numeric(1),AlphaNumeric(\"alpha1\".to_strbuf()),Numeric(9)),\n-        build: vec!(AlphaNumeric(\"build5\".to_strbuf()),\n+        pre: vec!(Numeric(1),AlphaNumeric(\"alpha1\".to_string()),Numeric(9)),\n+        build: vec!(AlphaNumeric(\"build5\".to_string()),\n                  Numeric(7),\n-                 AlphaNumeric(\"3aedf\".to_strbuf()))\n+                 AlphaNumeric(\"3aedf\".to_string()))\n     }));\n \n }\n@@ -378,21 +378,21 @@ fn test_ne() {\n #[test]\n fn test_show() {\n     assert_eq!(format_strbuf!(\"{}\", parse(\"1.2.3\").unwrap()),\n-               \"1.2.3\".to_strbuf());\n+               \"1.2.3\".to_string());\n     assert_eq!(format_strbuf!(\"{}\", parse(\"1.2.3-alpha1\").unwrap()),\n-               \"1.2.3-alpha1\".to_strbuf());\n+               \"1.2.3-alpha1\".to_string());\n     assert_eq!(format_strbuf!(\"{}\", parse(\"1.2.3+build.42\").unwrap()),\n-               \"1.2.3+build.42\".to_strbuf());\n+               \"1.2.3+build.42\".to_string());\n     assert_eq!(format_strbuf!(\"{}\", parse(\"1.2.3-alpha1+42\").unwrap()),\n-               \"1.2.3-alpha1+42\".to_strbuf());\n+               \"1.2.3-alpha1+42\".to_string());\n }\n \n #[test]\n fn test_to_str() {\n-    assert_eq!(parse(\"1.2.3\").unwrap().to_str(), \"1.2.3\".to_owned());\n-    assert_eq!(parse(\"1.2.3-alpha1\").unwrap().to_str(), \"1.2.3-alpha1\".to_owned());\n-    assert_eq!(parse(\"1.2.3+build.42\").unwrap().to_str(), \"1.2.3+build.42\".to_owned());\n-    assert_eq!(parse(\"1.2.3-alpha1+42\").unwrap().to_str(), \"1.2.3-alpha1+42\".to_owned());\n+    assert_eq!(parse(\"1.2.3\").unwrap().to_str(), \"1.2.3\".to_string());\n+    assert_eq!(parse(\"1.2.3-alpha1\").unwrap().to_str(), \"1.2.3-alpha1\".to_string());\n+    assert_eq!(parse(\"1.2.3+build.42\").unwrap().to_str(), \"1.2.3+build.42\".to_string());\n+    assert_eq!(parse(\"1.2.3-alpha1+42\").unwrap().to_str(), \"1.2.3-alpha1+42\".to_string());\n }\n \n #[test]"}, {"sha": "5d2f229beb675e3a7a99a983f17d892207c25bf4", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -146,7 +146,7 @@ impl<'a> ToBase64 for &'a [u8] {\n         }\n \n         unsafe {\n-            str::raw::from_utf8(v.as_slice()).to_strbuf()\n+            str::raw::from_utf8(v.as_slice()).to_string()\n         }\n     }\n }\n@@ -267,13 +267,13 @@ mod tests {\n \n     #[test]\n     fn test_to_base64_basic() {\n-        assert_eq!(\"\".as_bytes().to_base64(STANDARD), \"\".to_strbuf());\n-        assert_eq!(\"f\".as_bytes().to_base64(STANDARD), \"Zg==\".to_strbuf());\n-        assert_eq!(\"fo\".as_bytes().to_base64(STANDARD), \"Zm8=\".to_strbuf());\n-        assert_eq!(\"foo\".as_bytes().to_base64(STANDARD), \"Zm9v\".to_strbuf());\n-        assert_eq!(\"foob\".as_bytes().to_base64(STANDARD), \"Zm9vYg==\".to_strbuf());\n-        assert_eq!(\"fooba\".as_bytes().to_base64(STANDARD), \"Zm9vYmE=\".to_strbuf());\n-        assert_eq!(\"foobar\".as_bytes().to_base64(STANDARD), \"Zm9vYmFy\".to_strbuf());\n+        assert_eq!(\"\".as_bytes().to_base64(STANDARD), \"\".to_string());\n+        assert_eq!(\"f\".as_bytes().to_base64(STANDARD), \"Zg==\".to_string());\n+        assert_eq!(\"fo\".as_bytes().to_base64(STANDARD), \"Zm8=\".to_string());\n+        assert_eq!(\"foo\".as_bytes().to_base64(STANDARD), \"Zm9v\".to_string());\n+        assert_eq!(\"foob\".as_bytes().to_base64(STANDARD), \"Zm9vYg==\".to_string());\n+        assert_eq!(\"fooba\".as_bytes().to_base64(STANDARD), \"Zm9vYmE=\".to_string());\n+        assert_eq!(\"foobar\".as_bytes().to_base64(STANDARD), \"Zm9vYmFy\".to_string());\n     }\n \n     #[test]\n@@ -283,19 +283,19 @@ mod tests {\n                               .contains(\"\\r\\n\"));\n         assert_eq!(\"foobar\".as_bytes().to_base64(Config {line_length: Some(4),\n                                                          ..STANDARD}),\n-                   \"Zm9v\\r\\nYmFy\".to_strbuf());\n+                   \"Zm9v\\r\\nYmFy\".to_string());\n     }\n \n     #[test]\n     fn test_to_base64_padding() {\n-        assert_eq!(\"f\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), \"Zg\".to_strbuf());\n-        assert_eq!(\"fo\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), \"Zm8\".to_strbuf());\n+        assert_eq!(\"f\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), \"Zg\".to_string());\n+        assert_eq!(\"fo\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), \"Zm8\".to_string());\n     }\n \n     #[test]\n     fn test_to_base64_url_safe() {\n-        assert_eq!([251, 255].to_base64(URL_SAFE), \"-_8\".to_strbuf());\n-        assert_eq!([251, 255].to_base64(STANDARD), \"+/8=\".to_strbuf());\n+        assert_eq!([251, 255].to_base64(URL_SAFE), \"-_8\".to_string());\n+        assert_eq!([251, 255].to_base64(STANDARD), \"+/8=\".to_string());\n     }\n \n     #[test]"}, {"sha": "e6fe57006cae6ba341eb524674e8acd04fa58ba3", "filename": "src/libserialize/ebml.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibserialize%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibserialize%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Febml.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -35,7 +35,7 @@ impl<'doc> Doc<'doc> {\n     }\n \n     pub fn as_str(&self) -> String {\n-        self.as_str_slice().to_strbuf()\n+        self.as_str_slice().to_string()\n     }\n }\n "}, {"sha": "e72de88a06b47526ffb4db8bba92bb618d90660f", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -45,7 +45,7 @@ impl<'a> ToHex for &'a [u8] {\n         }\n \n         unsafe {\n-            str::raw::from_utf8(v.as_slice()).to_strbuf()\n+            str::raw::from_utf8(v.as_slice()).to_string()\n         }\n     }\n }\n@@ -143,7 +143,7 @@ mod tests {\n \n     #[test]\n     pub fn test_to_hex() {\n-        assert_eq!(\"foobar\".as_bytes().to_hex(), \"666f6f626172\".to_strbuf());\n+        assert_eq!(\"foobar\".as_bytes().to_hex(), \"666f6f626172\".to_string());\n     }\n \n     #[test]"}, {"sha": "4375e65891bc9b18a64daac97b38c8a872ab7071", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 135, "deletions": 135, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -68,7 +68,7 @@ use serialize::{json, Encodable};\n  }\n \n fn main() {\n-    let to_encode_object = TestStruct{data_str:\"example of string to encode\".to_strbuf()};\n+    let to_encode_object = TestStruct{data_str:\"example of string to encode\".to_string()};\n     let mut m = io::MemWriter::new();\n     {\n         let mut encoder = json::Encoder::new(&mut m as &mut std::io::Writer);\n@@ -85,7 +85,7 @@ into a string (String) or buffer (~[u8]): `str_encode(&m)` and `buffer_encode(&m\n \n ```rust\n use serialize::json;\n-let to_encode_object = \"example of string to encode\".to_strbuf();\n+let to_encode_object = \"example of string to encode\".to_string();\n let encoded_str: String = json::Encoder::str_encode(&to_encode_object);\n ```\n \n@@ -114,16 +114,16 @@ pub struct MyStruct  {\n impl ToJson for MyStruct {\n     fn to_json( &self ) -> json::Json {\n         let mut d = box TreeMap::new();\n-        d.insert(\"attr1\".to_strbuf(), self.attr1.to_json());\n-        d.insert(\"attr2\".to_strbuf(), self.attr2.to_json());\n+        d.insert(\"attr1\".to_string(), self.attr1.to_json());\n+        d.insert(\"attr2\".to_string(), self.attr2.to_json());\n         json::Object(d)\n     }\n }\n \n fn main() {\n-    let test2: MyStruct = MyStruct {attr1: 1, attr2:\"test\".to_strbuf()};\n+    let test2: MyStruct = MyStruct {attr1: 1, attr2:\"test\".to_string()};\n     let tjson: json::Json = test2.to_json();\n-    let json_str: String = tjson.to_str().into_strbuf();\n+    let json_str: String = tjson.to_str().into_string();\n }\n ```\n \n@@ -141,7 +141,7 @@ pub struct MyStruct  {\n \n fn main() {\n     let json_str_to_decode: String =\n-            \"{\\\"attr1\\\":1,\\\"attr2\\\":\\\"toto\\\"}\".to_strbuf();\n+            \"{\\\"attr1\\\":1,\\\"attr2\\\":\\\"toto\\\"}\".to_string();\n     let json_object = json::from_str(json_str_to_decode.as_slice());\n     let mut decoder = json::Decoder::new(json_object.unwrap());\n     let decoded_object: MyStruct = match Decodable::decode(&mut decoder) {\n@@ -173,7 +173,7 @@ use serialize::{json, Encodable, Decodable};\n // It calls the generated `Encodable` impl.\n fn main() {\n     let to_encode_object = TestStruct1\n-         {data_int: 1, data_str:\"toto\".to_strbuf(), data_vector:vec![2,3,4,5]};\n+         {data_int: 1, data_str:\"toto\".to_string(), data_vector:vec![2,3,4,5]};\n     let encoded_str: String = json::Encoder::str_encode(&to_encode_object);\n \n     // To deserialize use the `json::from_str` and `json::Decoder`\n@@ -207,20 +207,20 @@ pub struct TestStruct1  {\n impl ToJson for TestStruct1 {\n     fn to_json( &self ) -> json::Json {\n         let mut d = box TreeMap::new();\n-        d.insert(\"data_int\".to_strbuf(), self.data_int.to_json());\n-        d.insert(\"data_str\".to_strbuf(), self.data_str.to_json());\n-        d.insert(\"data_vector\".to_strbuf(), self.data_vector.to_json());\n+        d.insert(\"data_int\".to_string(), self.data_int.to_json());\n+        d.insert(\"data_str\".to_string(), self.data_str.to_json());\n+        d.insert(\"data_vector\".to_string(), self.data_vector.to_json());\n         json::Object(d)\n     }\n }\n \n fn main() {\n     // Serialization using our impl of to_json\n \n-    let test2: TestStruct1 = TestStruct1 {data_int: 1, data_str:\"toto\".to_strbuf(),\n+    let test2: TestStruct1 = TestStruct1 {data_int: 1, data_str:\"toto\".to_string(),\n                                           data_vector:vec![2,3,4,5]};\n     let tjson: json::Json = test2.to_json();\n-    let json_str: String = tjson.to_str().into_strbuf();\n+    let json_str: String = tjson.to_str().into_string();\n \n     // Deserialize like before.\n \n@@ -393,7 +393,7 @@ impl<'a> Encoder<'a> {\n                       to_encode_object: &T)\n                       -> String {\n         let buff = Encoder::buffer_encode(to_encode_object);\n-        str::from_utf8(buff.as_slice()).unwrap().to_strbuf()\n+        str::from_utf8(buff.as_slice()).unwrap().to_string()\n     }\n }\n \n@@ -839,7 +839,7 @@ impl Json {\n     pub fn to_pretty_str(&self) -> String {\n         let mut s = MemWriter::new();\n         self.to_pretty_writer(&mut s as &mut io::Writer).unwrap();\n-        str::from_utf8(s.unwrap().as_slice()).unwrap().to_strbuf()\n+        str::from_utf8(s.unwrap().as_slice()).unwrap().to_string()\n     }\n \n      /// If the Json value is an Object, returns the value associated with the provided key.\n@@ -1760,7 +1760,7 @@ impl<T: Iterator<char>> Builder<T> {\n                 _ => {}\n             }\n             let key = match self.parser.stack().top() {\n-                Some(Key(k)) => { k.to_strbuf() }\n+                Some(Key(k)) => { k.to_string() }\n                 _ => { fail!(\"invalid state\"); }\n             };\n             match self.build_value() {\n@@ -1781,7 +1781,7 @@ pub fn from_reader(rdr: &mut io::Reader) -> Result<Json, BuilderError> {\n         Err(e) => return Err(io_error_to_error(e))\n     };\n     let s = match str::from_utf8(contents.as_slice()) {\n-        Some(s) => s.to_strbuf(),\n+        Some(s) => s.to_string(),\n         None => return Err(SyntaxError(NotUtf8, 0, 0))\n     };\n     let mut builder = Builder::new(s.as_slice().chars());\n@@ -1818,15 +1818,15 @@ macro_rules! expect(\n     ($e:expr, Null) => ({\n         match $e {\n             Null => Ok(()),\n-            other => Err(ExpectedError(\"Null\".to_strbuf(),\n+            other => Err(ExpectedError(\"Null\".to_string(),\n                                        format_strbuf!(\"{}\", other)))\n         }\n     });\n     ($e:expr, $t:ident) => ({\n         match $e {\n             $t(v) => Ok(v),\n             other => {\n-                Err(ExpectedError(stringify!($t).to_strbuf(),\n+                Err(ExpectedError(stringify!($t).to_string(),\n                                   format_strbuf!(\"{}\", other)))\n             }\n         }\n@@ -1868,7 +1868,7 @@ impl ::Decoder<DecoderError> for Decoder {\n                 Ok(FromStr::from_str(s.as_slice()).unwrap())\n             },\n             value => {\n-                Err(ExpectedError(\"Number\".to_strbuf(),\n+                Err(ExpectedError(\"Number\".to_string(),\n                                   format_strbuf!(\"{}\", value)))\n             }\n         }\n@@ -1886,7 +1886,7 @@ impl ::Decoder<DecoderError> for Decoder {\n                 _ => ()\n             }\n         }\n-        Err(ExpectedError(\"single character string\".to_strbuf(),\n+        Err(ExpectedError(\"single character string\".to_string(),\n                           format_strbuf!(\"{}\", s)))\n     }\n \n@@ -1910,34 +1910,34 @@ impl ::Decoder<DecoderError> for Decoder {\n         let name = match self.pop() {\n             String(s) => s,\n             Object(mut o) => {\n-                let n = match o.pop(&\"variant\".to_strbuf()) {\n+                let n = match o.pop(&\"variant\".to_string()) {\n                     Some(String(s)) => s,\n                     Some(val) => {\n-                        return Err(ExpectedError(\"String\".to_strbuf(),\n+                        return Err(ExpectedError(\"String\".to_string(),\n                                                  format_strbuf!(\"{}\", val)))\n                     }\n                     None => {\n-                        return Err(MissingFieldError(\"variant\".to_strbuf()))\n+                        return Err(MissingFieldError(\"variant\".to_string()))\n                     }\n                 };\n-                match o.pop(&\"fields\".to_strbuf()) {\n+                match o.pop(&\"fields\".to_string()) {\n                     Some(List(l)) => {\n                         for field in l.move_iter().rev() {\n                             self.stack.push(field.clone());\n                         }\n                     },\n                     Some(val) => {\n-                        return Err(ExpectedError(\"List\".to_strbuf(),\n+                        return Err(ExpectedError(\"List\".to_string(),\n                                                  format_strbuf!(\"{}\", val)))\n                     }\n                     None => {\n-                        return Err(MissingFieldError(\"fields\".to_strbuf()))\n+                        return Err(MissingFieldError(\"fields\".to_string()))\n                     }\n                 }\n                 n\n             }\n             json => {\n-                return Err(ExpectedError(\"String or Object\".to_strbuf(),\n+                return Err(ExpectedError(\"String or Object\".to_string(),\n                                          format_strbuf!(\"{}\", json)))\n             }\n         };\n@@ -1994,8 +1994,8 @@ impl ::Decoder<DecoderError> for Decoder {\n         debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n         let mut obj = try!(expect!(self.pop(), Object));\n \n-        let value = match obj.pop(&name.to_strbuf()) {\n-            None => return Err(MissingFieldError(name.to_strbuf())),\n+        let value = match obj.pop(&name.to_string()) {\n+            None => return Err(MissingFieldError(name.to_string())),\n             Some(json) => {\n                 self.stack.push(json);\n                 try!(f(self))\n@@ -2320,67 +2320,67 @@ mod tests {\n \n     #[test]\n     fn test_write_null() {\n-        assert_eq!(Null.to_str().into_strbuf(), \"null\".to_strbuf());\n-        assert_eq!(Null.to_pretty_str().into_strbuf(), \"null\".to_strbuf());\n+        assert_eq!(Null.to_str().into_string(), \"null\".to_string());\n+        assert_eq!(Null.to_pretty_str().into_string(), \"null\".to_string());\n     }\n \n \n     #[test]\n     fn test_write_number() {\n-        assert_eq!(Number(3.0).to_str().into_strbuf(), \"3\".to_strbuf());\n-        assert_eq!(Number(3.0).to_pretty_str().into_strbuf(), \"3\".to_strbuf());\n+        assert_eq!(Number(3.0).to_str().into_string(), \"3\".to_string());\n+        assert_eq!(Number(3.0).to_pretty_str().into_string(), \"3\".to_string());\n \n-        assert_eq!(Number(3.1).to_str().into_strbuf(), \"3.1\".to_strbuf());\n-        assert_eq!(Number(3.1).to_pretty_str().into_strbuf(), \"3.1\".to_strbuf());\n+        assert_eq!(Number(3.1).to_str().into_string(), \"3.1\".to_string());\n+        assert_eq!(Number(3.1).to_pretty_str().into_string(), \"3.1\".to_string());\n \n-        assert_eq!(Number(-1.5).to_str().into_strbuf(), \"-1.5\".to_strbuf());\n-        assert_eq!(Number(-1.5).to_pretty_str().into_strbuf(), \"-1.5\".to_strbuf());\n+        assert_eq!(Number(-1.5).to_str().into_string(), \"-1.5\".to_string());\n+        assert_eq!(Number(-1.5).to_pretty_str().into_string(), \"-1.5\".to_string());\n \n-        assert_eq!(Number(0.5).to_str().into_strbuf(), \"0.5\".to_strbuf());\n-        assert_eq!(Number(0.5).to_pretty_str().into_strbuf(), \"0.5\".to_strbuf());\n+        assert_eq!(Number(0.5).to_str().into_string(), \"0.5\".to_string());\n+        assert_eq!(Number(0.5).to_pretty_str().into_string(), \"0.5\".to_string());\n     }\n \n     #[test]\n     fn test_write_str() {\n-        assert_eq!(String(\"\".to_strbuf()).to_str().into_strbuf(), \"\\\"\\\"\".to_strbuf());\n-        assert_eq!(String(\"\".to_strbuf()).to_pretty_str().into_strbuf(), \"\\\"\\\"\".to_strbuf());\n+        assert_eq!(String(\"\".to_string()).to_str().into_string(), \"\\\"\\\"\".to_string());\n+        assert_eq!(String(\"\".to_string()).to_pretty_str().into_string(), \"\\\"\\\"\".to_string());\n \n-        assert_eq!(String(\"foo\".to_strbuf()).to_str().into_strbuf(), \"\\\"foo\\\"\".to_strbuf());\n-        assert_eq!(String(\"foo\".to_strbuf()).to_pretty_str().into_strbuf(), \"\\\"foo\\\"\".to_strbuf());\n+        assert_eq!(String(\"foo\".to_string()).to_str().into_string(), \"\\\"foo\\\"\".to_string());\n+        assert_eq!(String(\"foo\".to_string()).to_pretty_str().into_string(), \"\\\"foo\\\"\".to_string());\n     }\n \n     #[test]\n     fn test_write_bool() {\n-        assert_eq!(Boolean(true).to_str().into_strbuf(), \"true\".to_strbuf());\n-        assert_eq!(Boolean(true).to_pretty_str().into_strbuf(), \"true\".to_strbuf());\n+        assert_eq!(Boolean(true).to_str().into_string(), \"true\".to_string());\n+        assert_eq!(Boolean(true).to_pretty_str().into_string(), \"true\".to_string());\n \n-        assert_eq!(Boolean(false).to_str().into_strbuf(), \"false\".to_strbuf());\n-        assert_eq!(Boolean(false).to_pretty_str().into_strbuf(), \"false\".to_strbuf());\n+        assert_eq!(Boolean(false).to_str().into_string(), \"false\".to_string());\n+        assert_eq!(Boolean(false).to_pretty_str().into_string(), \"false\".to_string());\n     }\n \n     #[test]\n     fn test_write_list() {\n-        assert_eq!(List(vec![]).to_str().into_strbuf(), \"[]\".to_strbuf());\n-        assert_eq!(List(vec![]).to_pretty_str().into_strbuf(), \"[]\".to_strbuf());\n+        assert_eq!(List(vec![]).to_str().into_string(), \"[]\".to_string());\n+        assert_eq!(List(vec![]).to_pretty_str().into_string(), \"[]\".to_string());\n \n-        assert_eq!(List(vec![Boolean(true)]).to_str().into_strbuf(), \"[true]\".to_strbuf());\n+        assert_eq!(List(vec![Boolean(true)]).to_str().into_string(), \"[true]\".to_string());\n         assert_eq!(\n-            List(vec![Boolean(true)]).to_pretty_str().into_strbuf(),\n+            List(vec![Boolean(true)]).to_pretty_str().into_string(),\n             \"\\\n             [\\n  \\\n                 true\\n\\\n-            ]\".to_strbuf()\n+            ]\".to_string()\n         );\n \n         let long_test_list = List(vec![\n             Boolean(false),\n             Null,\n-            List(vec![String(\"foo\\nbar\".to_strbuf()), Number(3.5)])]);\n+            List(vec![String(\"foo\\nbar\".to_string()), Number(3.5)])]);\n \n-        assert_eq!(long_test_list.to_str().into_strbuf(),\n-            \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\".to_strbuf());\n+        assert_eq!(long_test_list.to_str().into_string(),\n+            \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\".to_string());\n         assert_eq!(\n-            long_test_list.to_pretty_str().into_strbuf(),\n+            long_test_list.to_pretty_str().into_string(),\n             \"\\\n             [\\n  \\\n                 false,\\n  \\\n@@ -2389,47 +2389,47 @@ mod tests {\n                     \\\"foo\\\\nbar\\\",\\n    \\\n                     3.5\\n  \\\n                 ]\\n\\\n-            ]\".to_strbuf()\n+            ]\".to_string()\n         );\n     }\n \n     #[test]\n     fn test_write_object() {\n-        assert_eq!(mk_object([]).to_str().into_strbuf(), \"{}\".to_strbuf());\n-        assert_eq!(mk_object([]).to_pretty_str().into_strbuf(), \"{}\".to_strbuf());\n+        assert_eq!(mk_object([]).to_str().into_string(), \"{}\".to_string());\n+        assert_eq!(mk_object([]).to_pretty_str().into_string(), \"{}\".to_string());\n \n         assert_eq!(\n             mk_object([\n-                (\"a\".to_strbuf(), Boolean(true))\n-            ]).to_str().into_strbuf(),\n-            \"{\\\"a\\\":true}\".to_strbuf()\n+                (\"a\".to_string(), Boolean(true))\n+            ]).to_str().into_string(),\n+            \"{\\\"a\\\":true}\".to_string()\n         );\n         assert_eq!(\n-            mk_object([(\"a\".to_strbuf(), Boolean(true))]).to_pretty_str(),\n+            mk_object([(\"a\".to_string(), Boolean(true))]).to_pretty_str(),\n             \"\\\n             {\\n  \\\n                 \\\"a\\\": true\\n\\\n-            }\".to_strbuf()\n+            }\".to_string()\n         );\n \n         let complex_obj = mk_object([\n-                (\"b\".to_strbuf(), List(vec![\n-                    mk_object([(\"c\".to_strbuf(), String(\"\\x0c\\r\".to_strbuf()))]),\n-                    mk_object([(\"d\".to_strbuf(), String(\"\".to_strbuf()))])\n+                (\"b\".to_string(), List(vec![\n+                    mk_object([(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n+                    mk_object([(\"d\".to_string(), String(\"\".to_string()))])\n                 ]))\n             ]);\n \n         assert_eq!(\n-            complex_obj.to_str().into_strbuf(),\n+            complex_obj.to_str().into_string(),\n             \"{\\\n                 \\\"b\\\":[\\\n                     {\\\"c\\\":\\\"\\\\f\\\\r\\\"},\\\n                     {\\\"d\\\":\\\"\\\"}\\\n                 ]\\\n-            }\".to_strbuf()\n+            }\".to_string()\n         );\n         assert_eq!(\n-            complex_obj.to_pretty_str().into_strbuf(),\n+            complex_obj.to_pretty_str().into_string(),\n             \"\\\n             {\\n  \\\n                 \\\"b\\\": [\\n    \\\n@@ -2440,14 +2440,14 @@ mod tests {\n                         \\\"d\\\": \\\"\\\"\\n    \\\n                     }\\n  \\\n                 ]\\n\\\n-            }\".to_strbuf()\n+            }\".to_string()\n         );\n \n         let a = mk_object([\n-            (\"a\".to_strbuf(), Boolean(true)),\n-            (\"b\".to_strbuf(), List(vec![\n-                mk_object([(\"c\".to_strbuf(), String(\"\\x0c\\r\".to_strbuf()))]),\n-                mk_object([(\"d\".to_strbuf(), String(\"\".to_strbuf()))])\n+            (\"a\".to_string(), Boolean(true)),\n+            (\"b\".to_string(), List(vec![\n+                mk_object([(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n+                mk_object([(\"d\".to_string(), String(\"\".to_string()))])\n             ]))\n         ]);\n \n@@ -2464,7 +2464,7 @@ mod tests {\n \n         let mut m = MemWriter::new();\n         f(&mut m as &mut io::Writer);\n-        str::from_utf8(m.unwrap().as_slice()).unwrap().to_strbuf()\n+        str::from_utf8(m.unwrap().as_slice()).unwrap().to_string()\n     }\n \n     #[test]\n@@ -2475,23 +2475,23 @@ mod tests {\n                 let mut encoder = Encoder::new(wr);\n                 animal.encode(&mut encoder).unwrap();\n             }),\n-            \"\\\"Dog\\\"\".to_strbuf()\n+            \"\\\"Dog\\\"\".to_string()\n         );\n         assert_eq!(\n             with_str_writer(|wr| {\n                 let mut encoder = PrettyEncoder::new(wr);\n                 animal.encode(&mut encoder).unwrap();\n             }),\n-            \"\\\"Dog\\\"\".to_strbuf()\n+            \"\\\"Dog\\\"\".to_string()\n         );\n \n-        let animal = Frog(\"Henry\".to_strbuf(), 349);\n+        let animal = Frog(\"Henry\".to_string(), 349);\n         assert_eq!(\n             with_str_writer(|wr| {\n                 let mut encoder = Encoder::new(wr);\n                 animal.encode(&mut encoder).unwrap();\n             }),\n-            \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\".to_strbuf()\n+            \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\".to_string()\n         );\n         assert_eq!(\n             with_str_writer(|wr| {\n@@ -2503,25 +2503,25 @@ mod tests {\n                 \\\"Frog\\\",\\n  \\\n                 \\\"Henry\\\",\\n  \\\n                 349\\n\\\n-            ]\".to_strbuf()\n+            ]\".to_string()\n         );\n     }\n \n     #[test]\n     fn test_write_some() {\n-        let value = Some(\"jodhpurs\".to_strbuf());\n+        let value = Some(\"jodhpurs\".to_string());\n         let s = with_str_writer(|wr| {\n             let mut encoder = Encoder::new(wr);\n             value.encode(&mut encoder).unwrap();\n         });\n-        assert_eq!(s, \"\\\"jodhpurs\\\"\".to_strbuf());\n+        assert_eq!(s, \"\\\"jodhpurs\\\"\".to_string());\n \n-        let value = Some(\"jodhpurs\".to_strbuf());\n+        let value = Some(\"jodhpurs\".to_string());\n         let s = with_str_writer(|wr| {\n             let mut encoder = PrettyEncoder::new(wr);\n             value.encode(&mut encoder).unwrap();\n         });\n-        assert_eq!(s, \"\\\"jodhpurs\\\"\".to_strbuf());\n+        assert_eq!(s, \"\\\"jodhpurs\\\"\".to_string());\n     }\n \n     #[test]\n@@ -2531,13 +2531,13 @@ mod tests {\n             let mut encoder = Encoder::new(wr);\n             value.encode(&mut encoder).unwrap();\n         });\n-        assert_eq!(s, \"null\".to_strbuf());\n+        assert_eq!(s, \"null\".to_string());\n \n         let s = with_str_writer(|wr| {\n             let mut encoder = Encoder::new(wr);\n             value.encode(&mut encoder).unwrap();\n         });\n-        assert_eq!(s, \"null\".to_strbuf());\n+        assert_eq!(s, \"null\".to_string());\n     }\n \n     #[test]\n@@ -2638,16 +2638,16 @@ mod tests {\n         assert_eq!(from_str(\"\\\"\"),    Err(SyntaxError(EOFWhileParsingString, 1, 2)));\n         assert_eq!(from_str(\"\\\"lol\"), Err(SyntaxError(EOFWhileParsingString, 1, 5)));\n \n-        assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(\"\".to_strbuf())));\n-        assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(\"foo\".to_strbuf())));\n-        assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(\"\\\"\".to_strbuf())));\n-        assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(\"\\x08\".to_strbuf())));\n-        assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(\"\\n\".to_strbuf())));\n-        assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(\"\\r\".to_strbuf())));\n-        assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(\"\\t\".to_strbuf())));\n-        assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(\"foo\".to_strbuf())));\n-        assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(\"\\u12ab\".to_strbuf())));\n-        assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(\"\\uAB12\".to_strbuf())));\n+        assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(\"\".to_string())));\n+        assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(\"foo\".to_string())));\n+        assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(\"\\\"\".to_string())));\n+        assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(\"\\x08\".to_string())));\n+        assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(\"\\n\".to_string())));\n+        assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(\"\\r\".to_string())));\n+        assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(\"\\t\".to_string())));\n+        assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(\"foo\".to_string())));\n+        assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(\"\\u12ab\".to_string())));\n+        assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(\"\\uAB12\".to_string())));\n     }\n \n     #[test]\n@@ -2669,7 +2669,7 @@ mod tests {\n \n             let mut decoder = Decoder::new(from_str(i).unwrap());\n             let v: String = Decodable::decode(&mut decoder).unwrap();\n-            assert_eq!(v, o.to_strbuf());\n+            assert_eq!(v, o.to_string());\n         }\n     }\n \n@@ -2738,22 +2738,22 @@ mod tests {\n \n         assert_eq!(from_str(\"{}\").unwrap(), mk_object([]));\n         assert_eq!(from_str(\"{\\\"a\\\": 3}\").unwrap(),\n-                  mk_object([(\"a\".to_strbuf(), Number(3.0))]));\n+                  mk_object([(\"a\".to_string(), Number(3.0))]));\n \n         assert_eq!(from_str(\n                       \"{ \\\"a\\\": null, \\\"b\\\" : true }\").unwrap(),\n                   mk_object([\n-                      (\"a\".to_strbuf(), Null),\n-                      (\"b\".to_strbuf(), Boolean(true))]));\n+                      (\"a\".to_string(), Null),\n+                      (\"b\".to_string(), Boolean(true))]));\n         assert_eq!(from_str(\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\").unwrap(),\n                   mk_object([\n-                      (\"a\".to_strbuf(), Null),\n-                      (\"b\".to_strbuf(), Boolean(true))]));\n+                      (\"a\".to_string(), Null),\n+                      (\"b\".to_string(), Boolean(true))]));\n         assert_eq!(from_str(\n                       \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\").unwrap(),\n                   mk_object([\n-                      (\"a\".to_strbuf(), Number(1.0)),\n-                      (\"b\".to_strbuf(), List(vec![Boolean(true)]))\n+                      (\"a\".to_string(), Number(1.0)),\n+                      (\"b\".to_string(), List(vec![Boolean(true)]))\n                   ]));\n         assert_eq!(from_str(\n                       \"{\\\n@@ -2765,12 +2765,12 @@ mod tests {\n                           ]\\\n                       }\").unwrap(),\n                   mk_object([\n-                      (\"a\".to_strbuf(), Number(1.0)),\n-                      (\"b\".to_strbuf(), List(vec![\n+                      (\"a\".to_string(), Number(1.0)),\n+                      (\"b\".to_string(), List(vec![\n                           Boolean(true),\n-                          String(\"foo\\nbar\".to_strbuf()),\n+                          String(\"foo\\nbar\".to_string()),\n                           mk_object([\n-                              (\"c\".to_strbuf(), mk_object([(\"d\".to_strbuf(), Null)]))\n+                              (\"c\".to_string(), mk_object([(\"d\".to_string(), Null)]))\n                           ])\n                       ]))\n                   ]));\n@@ -2789,7 +2789,7 @@ mod tests {\n             v,\n             Outer {\n                 inner: vec![\n-                    Inner { a: (), b: 2, c: vec![\"abc\".to_strbuf(), \"xyz\".to_strbuf()] }\n+                    Inner { a: (), b: 2, c: vec![\"abc\".to_string(), \"xyz\".to_string()] }\n                 ]\n             }\n         );\n@@ -2803,7 +2803,7 @@ mod tests {\n \n         let mut decoder = Decoder::new(from_str(\"\\\"jodhpurs\\\"\").unwrap());\n         let value: Option<String> = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(value, Some(\"jodhpurs\".to_strbuf()));\n+        assert_eq!(value, Some(\"jodhpurs\".to_string()));\n     }\n \n     #[test]\n@@ -2815,7 +2815,7 @@ mod tests {\n         let s = \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\";\n         let mut decoder = Decoder::new(from_str(s).unwrap());\n         let value: Animal = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(value, Frog(\"Henry\".to_strbuf(), 349));\n+        assert_eq!(value, Frog(\"Henry\".to_string(), 349));\n     }\n \n     #[test]\n@@ -2825,8 +2825,8 @@ mod tests {\n         let mut decoder = Decoder::new(from_str(s).unwrap());\n         let mut map: TreeMap<String, Animal> = Decodable::decode(&mut decoder).unwrap();\n \n-        assert_eq!(map.pop(&\"a\".to_strbuf()), Some(Dog));\n-        assert_eq!(map.pop(&\"b\".to_strbuf()), Some(Frog(\"Henry\".to_strbuf(), 349)));\n+        assert_eq!(map.pop(&\"a\".to_string()), Some(Dog));\n+        assert_eq!(map.pop(&\"b\".to_string()), Some(Frog(\"Henry\".to_string(), 349)));\n     }\n \n     #[test]\n@@ -2865,51 +2865,51 @@ mod tests {\n     }\n     #[test]\n     fn test_decode_errors_struct() {\n-        check_err::<DecodeStruct>(\"[]\", ExpectedError(\"Object\".to_strbuf(), \"[]\".to_strbuf()));\n+        check_err::<DecodeStruct>(\"[]\", ExpectedError(\"Object\".to_string(), \"[]\".to_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": true, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n-                                  ExpectedError(\"Number\".to_strbuf(), \"true\".to_strbuf()));\n+                                  ExpectedError(\"Number\".to_string(), \"true\".to_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": [], \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n-                                  ExpectedError(\"Boolean\".to_strbuf(), \"[]\".to_strbuf()));\n+                                  ExpectedError(\"Boolean\".to_string(), \"[]\".to_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": {}, \\\"w\\\": []}\",\n-                                  ExpectedError(\"String\".to_strbuf(), \"{}\".to_strbuf()));\n+                                  ExpectedError(\"String\".to_string(), \"{}\".to_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": null}\",\n-                                  ExpectedError(\"List\".to_strbuf(), \"null\".to_strbuf()));\n+                                  ExpectedError(\"List\".to_string(), \"null\".to_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\"}\",\n-                                  MissingFieldError(\"w\".to_strbuf()));\n+                                  MissingFieldError(\"w\".to_string()));\n     }\n     #[test]\n     fn test_decode_errors_enum() {\n         check_err::<DecodeEnum>(\"{}\",\n-                                MissingFieldError(\"variant\".to_strbuf()));\n+                                MissingFieldError(\"variant\".to_string()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": 1}\",\n-                                ExpectedError(\"String\".to_strbuf(), \"1\".to_strbuf()));\n+                                ExpectedError(\"String\".to_string(), \"1\".to_string()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\"}\",\n-                                MissingFieldError(\"fields\".to_strbuf()));\n+                                MissingFieldError(\"fields\".to_string()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\", \\\"fields\\\": null}\",\n-                                ExpectedError(\"List\".to_strbuf(), \"null\".to_strbuf()));\n+                                ExpectedError(\"List\".to_string(), \"null\".to_string()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"C\\\", \\\"fields\\\": []}\",\n-                                UnknownVariantError(\"C\".to_strbuf()));\n+                                UnknownVariantError(\"C\".to_string()));\n     }\n \n     #[test]\n     fn test_find(){\n         let json_value = from_str(\"{\\\"dog\\\" : \\\"cat\\\"}\").unwrap();\n-        let found_str = json_value.find(&\"dog\".to_strbuf());\n+        let found_str = json_value.find(&\"dog\".to_string());\n         assert!(found_str.is_some() && found_str.unwrap().as_string().unwrap() == \"cat\");\n     }\n \n     #[test]\n     fn test_find_path(){\n         let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n-        let found_str = json_value.find_path(&[&\"dog\".to_strbuf(),\n-                                             &\"cat\".to_strbuf(), &\"mouse\".to_strbuf()]);\n+        let found_str = json_value.find_path(&[&\"dog\".to_string(),\n+                                             &\"cat\".to_string(), &\"mouse\".to_string()]);\n         assert!(found_str.is_some() && found_str.unwrap().as_string().unwrap() == \"cheese\");\n     }\n \n     #[test]\n     fn test_search(){\n         let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n-        let found_str = json_value.search(&\"mouse\".to_strbuf()).and_then(|j| j.as_string());\n+        let found_str = json_value.search(&\"mouse\".to_string()).and_then(|j| j.as_string());\n         assert!(found_str.is_some());\n         assert!(found_str.unwrap() == \"cheese\");\n     }\n@@ -3072,7 +3072,7 @@ mod tests {\n             r#\"{ \"foo\":\"bar\", \"array\" : [0, 1, 2,3 ,4,5], \"idents\":[null,true,false]}\"#,\n             ~[\n                 (ObjectStart,             ~[]),\n-                  (StringValue(\"bar\".to_strbuf()),   ~[Key(\"foo\")]),\n+                  (StringValue(\"bar\".to_string()),   ~[Key(\"foo\")]),\n                   (ListStart,             ~[Key(\"array\")]),\n                     (NumberValue(0.0),    ~[Key(\"array\"), Index(0)]),\n                     (NumberValue(1.0),    ~[Key(\"array\"), Index(1)]),\n@@ -3161,7 +3161,7 @@ mod tests {\n                   (NumberValue(1.0),            ~[Key(\"a\")]),\n                   (ListStart,                   ~[Key(\"b\")]),\n                     (BooleanValue(true),        ~[Key(\"b\"), Index(0)]),\n-                    (StringValue(\"foo\\nbar\".to_strbuf()),  ~[Key(\"b\"), Index(1)]),\n+                    (StringValue(\"foo\\nbar\".to_string()),  ~[Key(\"b\"), Index(1)]),\n                     (ObjectStart,               ~[Key(\"b\"), Index(2)]),\n                       (ObjectStart,             ~[Key(\"b\"), Index(2), Key(\"c\")]),\n                         (NullValue,             ~[Key(\"b\"), Index(2), Key(\"c\"), Key(\"d\")]),\n@@ -3294,7 +3294,7 @@ mod tests {\n         assert!(stack.last_is_index());\n         assert!(stack.get(0) == Index(1));\n \n-        stack.push_key(\"foo\".to_strbuf());\n+        stack.push_key(\"foo\".to_string());\n \n         assert!(stack.len() == 2);\n         assert!(stack.is_equal_to([Index(1), Key(\"foo\")]));\n@@ -3306,7 +3306,7 @@ mod tests {\n         assert!(stack.get(0) == Index(1));\n         assert!(stack.get(1) == Key(\"foo\"));\n \n-        stack.push_key(\"bar\".to_strbuf());\n+        stack.push_key(\"bar\".to_string());\n \n         assert!(stack.len() == 3);\n         assert!(stack.is_equal_to([Index(1), Key(\"foo\"), Key(\"bar\")]));\n@@ -3370,7 +3370,7 @@ mod tests {\n     }\n \n     fn big_json() -> String {\n-        let mut src = \"[\\n\".to_strbuf();\n+        let mut src = \"[\\n\".to_string();\n         for _ in range(0, 500) {\n             src.push_str(r#\"{ \"a\": true, \"b\": null, \"c\":3.1415, \"d\": \"Hello world\", \"e\": \\\n                             [1,2,3]},\"#);"}, {"sha": "55bbf4ddf75ab90774f59068a3c3490b921361cd", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -366,7 +366,7 @@ impl IntoStr for Vec<Ascii> {\n     fn into_str(self) -> String {\n         unsafe {\n             let s: &str = mem::transmute(self.as_slice());\n-            s.to_strbuf()\n+            s.to_string()\n         }\n     }\n }\n@@ -456,16 +456,16 @@ unsafe fn str_map_bytes(string: String, map: &'static [u8]) -> String {\n         *b = map[*b as uint];\n     }\n \n-    str::from_utf8(bytes.as_slice()).unwrap().to_strbuf()\n+    str::from_utf8(bytes.as_slice()).unwrap().to_string()\n }\n \n #[inline]\n unsafe fn str_copy_map_bytes(string: &str, map: &'static [u8]) -> String {\n-    let mut s = string.to_strbuf();\n+    let mut s = string.to_string();\n     for b in s.as_mut_bytes().mut_iter() {\n         *b = map[*b as uint];\n     }\n-    s.into_strbuf()\n+    s.into_string()\n }\n \n static ASCII_LOWER_MAP: &'static [u8] = &[\n@@ -594,14 +594,14 @@ mod tests {\n         assert_eq!(\"( ;\".to_ascii(), v2ascii!([40, 32, 59]));\n         let v = box [40u8, 32u8, 59u8];\n         assert_eq!(v.to_ascii(), v2ascii!([40, 32, 59]));\n-        assert_eq!(\"( ;\".to_strbuf().as_slice().to_ascii(), v2ascii!([40, 32, 59]));\n+        assert_eq!(\"( ;\".to_string().as_slice().to_ascii(), v2ascii!([40, 32, 59]));\n \n-        assert_eq!(\"abCDef&?#\".to_ascii().to_lower().into_str(), \"abcdef&?#\".to_strbuf());\n-        assert_eq!(\"abCDef&?#\".to_ascii().to_upper().into_str(), \"ABCDEF&?#\".to_strbuf());\n+        assert_eq!(\"abCDef&?#\".to_ascii().to_lower().into_str(), \"abcdef&?#\".to_string());\n+        assert_eq!(\"abCDef&?#\".to_ascii().to_upper().into_str(), \"ABCDEF&?#\".to_string());\n \n-        assert_eq!(\"\".to_ascii().to_lower().into_str(), \"\".to_strbuf());\n-        assert_eq!(\"YMCA\".to_ascii().to_lower().into_str(), \"ymca\".to_strbuf());\n-        assert_eq!(\"abcDEFxyz:.;\".to_ascii().to_upper().into_str(), \"ABCDEFXYZ:.;\".to_strbuf());\n+        assert_eq!(\"\".to_ascii().to_lower().into_str(), \"\".to_string());\n+        assert_eq!(\"YMCA\".to_ascii().to_lower().into_str(), \"ymca\".to_string());\n+        assert_eq!(\"abcDEFxyz:.;\".to_ascii().to_upper().into_str(), \"ABCDEFXYZ:.;\".to_string());\n \n         assert!(\"aBcDeF&?#\".to_ascii().eq_ignore_case(\"AbCdEf&?#\".to_ascii()));\n \n@@ -613,16 +613,16 @@ mod tests {\n \n     #[test]\n     fn test_ascii_vec_ng() {\n-        assert_eq!(\"abCDef&?#\".to_ascii().to_lower().into_str(), \"abcdef&?#\".to_strbuf());\n-        assert_eq!(\"abCDef&?#\".to_ascii().to_upper().into_str(), \"ABCDEF&?#\".to_strbuf());\n-        assert_eq!(\"\".to_ascii().to_lower().into_str(), \"\".to_strbuf());\n-        assert_eq!(\"YMCA\".to_ascii().to_lower().into_str(), \"ymca\".to_strbuf());\n-        assert_eq!(\"abcDEFxyz:.;\".to_ascii().to_upper().into_str(), \"ABCDEFXYZ:.;\".to_strbuf());\n+        assert_eq!(\"abCDef&?#\".to_ascii().to_lower().into_str(), \"abcdef&?#\".to_string());\n+        assert_eq!(\"abCDef&?#\".to_ascii().to_upper().into_str(), \"ABCDEF&?#\".to_string());\n+        assert_eq!(\"\".to_ascii().to_lower().into_str(), \"\".to_string());\n+        assert_eq!(\"YMCA\".to_ascii().to_lower().into_str(), \"ymca\".to_string());\n+        assert_eq!(\"abcDEFxyz:.;\".to_ascii().to_upper().into_str(), \"ABCDEFXYZ:.;\".to_string());\n     }\n \n     #[test]\n     fn test_owned_ascii_vec() {\n-        assert_eq!((\"( ;\".to_strbuf()).into_ascii(), vec2ascii![40, 32, 59]);\n+        assert_eq!((\"( ;\".to_string()).into_ascii(), vec2ascii![40, 32, 59]);\n         assert_eq!((box [40u8, 32u8, 59u8]).into_ascii(), vec2ascii![40, 32, 59]);\n     }\n \n@@ -634,8 +634,8 @@ mod tests {\n \n     #[test]\n     fn test_ascii_into_str() {\n-        assert_eq!(vec2ascii![40, 32, 59].into_str(), \"( ;\".to_strbuf());\n-        assert_eq!(vec2ascii!(40, 32, 59).into_str(), \"( ;\".to_strbuf());\n+        assert_eq!(vec2ascii![40, 32, 59].into_str(), \"( ;\".to_string());\n+        assert_eq!(vec2ascii!(40, 32, 59).into_str(), \"( ;\".to_string());\n     }\n \n     #[test]\n@@ -682,70 +682,70 @@ mod tests {\n         assert_eq!((vec![40u8, 32u8, 59u8]).into_ascii_opt(), Some(vec2ascii![40, 32, 59]));\n         assert_eq!((vec![127u8, 128u8, 255u8]).into_ascii_opt(), None);\n \n-        assert_eq!((\"( ;\".to_strbuf()).into_ascii_opt(), Some(vec2ascii![40, 32, 59]));\n-        assert_eq!((\"zo\u00e4\u534e\".to_strbuf()).into_ascii_opt(), None);\n+        assert_eq!((\"( ;\".to_string()).into_ascii_opt(), Some(vec2ascii![40, 32, 59]));\n+        assert_eq!((\"zo\u00e4\u534e\".to_string()).into_ascii_opt(), None);\n     }\n \n     #[test]\n     fn test_to_ascii_upper() {\n-        assert_eq!(\"url()URL()uRl()\u00fcrl\".to_ascii_upper(), \"URL()URL()URL()\u00fcRL\".to_strbuf());\n-        assert_eq!(\"h\u0131\u212a\u00df\".to_ascii_upper(), \"H\u0131\u212a\u00df\".to_strbuf());\n+        assert_eq!(\"url()URL()uRl()\u00fcrl\".to_ascii_upper(), \"URL()URL()URL()\u00fcRL\".to_string());\n+        assert_eq!(\"h\u0131\u212a\u00df\".to_ascii_upper(), \"H\u0131\u212a\u00df\".to_string());\n \n         let mut i = 0;\n         while i <= 500 {\n             let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n                         else { i };\n             assert_eq!(from_char(from_u32(i).unwrap()).as_slice().to_ascii_upper(),\n-                       from_char(from_u32(upper).unwrap()).to_strbuf())\n+                       from_char(from_u32(upper).unwrap()).to_string())\n             i += 1;\n         }\n     }\n \n     #[test]\n     fn test_to_ascii_lower() {\n-        assert_eq!(\"url()URL()uRl()\u00dcrl\".to_ascii_lower(), \"url()url()url()\u00dcrl\".to_strbuf());\n+        assert_eq!(\"url()URL()uRl()\u00dcrl\".to_ascii_lower(), \"url()url()url()\u00dcrl\".to_string());\n         // Dotted capital I, Kelvin sign, Sharp S.\n-        assert_eq!(\"H\u0130\u212a\u00df\".to_ascii_lower(), \"h\u0130\u212a\u00df\".to_strbuf());\n+        assert_eq!(\"H\u0130\u212a\u00df\".to_ascii_lower(), \"h\u0130\u212a\u00df\".to_string());\n \n         let mut i = 0;\n         while i <= 500 {\n             let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n                         else { i };\n             assert_eq!(from_char(from_u32(i).unwrap()).as_slice().to_ascii_lower(),\n-                       from_char(from_u32(lower).unwrap()).to_strbuf())\n+                       from_char(from_u32(lower).unwrap()).to_string())\n             i += 1;\n         }\n     }\n \n     #[test]\n     fn test_into_ascii_upper() {\n-        assert_eq!((\"url()URL()uRl()\u00fcrl\".to_strbuf()).into_ascii_upper(),\n-                   \"URL()URL()URL()\u00fcRL\".to_strbuf());\n-        assert_eq!((\"h\u0131\u212a\u00df\".to_strbuf()).into_ascii_upper(), \"H\u0131\u212a\u00df\".to_strbuf());\n+        assert_eq!((\"url()URL()uRl()\u00fcrl\".to_string()).into_ascii_upper(),\n+                   \"URL()URL()URL()\u00fcRL\".to_string());\n+        assert_eq!((\"h\u0131\u212a\u00df\".to_string()).into_ascii_upper(), \"H\u0131\u212a\u00df\".to_string());\n \n         let mut i = 0;\n         while i <= 500 {\n             let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n                         else { i };\n-            assert_eq!(from_char(from_u32(i).unwrap()).to_strbuf().into_ascii_upper(),\n-                       from_char(from_u32(upper).unwrap()).to_strbuf())\n+            assert_eq!(from_char(from_u32(i).unwrap()).to_string().into_ascii_upper(),\n+                       from_char(from_u32(upper).unwrap()).to_string())\n             i += 1;\n         }\n     }\n \n     #[test]\n     fn test_into_ascii_lower() {\n-        assert_eq!((\"url()URL()uRl()\u00dcrl\".to_strbuf()).into_ascii_lower(),\n-                   \"url()url()url()\u00dcrl\".to_strbuf());\n+        assert_eq!((\"url()URL()uRl()\u00dcrl\".to_string()).into_ascii_lower(),\n+                   \"url()url()url()\u00dcrl\".to_string());\n         // Dotted capital I, Kelvin sign, Sharp S.\n-        assert_eq!((\"H\u0130\u212a\u00df\".to_strbuf()).into_ascii_lower(), \"h\u0130\u212a\u00df\".to_strbuf());\n+        assert_eq!((\"H\u0130\u212a\u00df\".to_string()).into_ascii_lower(), \"h\u0130\u212a\u00df\".to_string());\n \n         let mut i = 0;\n         while i <= 500 {\n             let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n                         else { i };\n-            assert_eq!(from_char(from_u32(i).unwrap()).to_strbuf().into_ascii_lower(),\n-                       from_char(from_u32(lower).unwrap()).to_strbuf())\n+            assert_eq!(from_char(from_u32(i).unwrap()).to_string().into_ascii_lower(),\n+                       from_char(from_u32(lower).unwrap()).to_string())\n             i += 1;\n         }\n     }\n@@ -777,12 +777,12 @@ mod tests {\n     #[test]\n     fn test_to_str() {\n         let s = Ascii{ chr: 't' as u8 }.to_str();\n-        assert_eq!(s, \"t\".to_strbuf());\n+        assert_eq!(s, \"t\".to_string());\n     }\n \n     #[test]\n     fn test_show() {\n         let c = Ascii { chr: 't' as u8 };\n-        assert_eq!(format_strbuf!(\"{}\", c), \"t\".to_strbuf());\n+        assert_eq!(format_strbuf!(\"{}\", c), \"t\".to_string());\n     }\n }"}, {"sha": "983d76a08442bdb9885ad0eb812c7c340e39d950", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -669,7 +669,7 @@ mod tests {\n     #[test]\n     fn test_clone_noleak() {\n         fn foo(f: |c: &CString|) {\n-            let s = \"test\".to_owned();\n+            let s = \"test\".to_string();\n             let c = s.to_c_str();\n             // give the closure a non-owned CString\n             let mut c_ = c.with_ref(|c| unsafe { CString::new(c, false) } );"}, {"sha": "ba2bc261bc3018735d280e1f0b32cae1348ad183", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -34,12 +34,12 @@ format arguments directly while performing minimal allocations.\n Some examples of the `format!` extension are:\n \n ```rust\n-format!(\"Hello\");                 // => \"Hello\".to_owned()\n-format!(\"Hello, {:s}!\", \"world\"); // => \"Hello, world!\".to_owned()\n-format!(\"The number is {:d}\", 1); // => \"The number is 1\".to_owned()\n-format!(\"{:?}\", ~[3, 4]);         // => \"~[3, 4]\".to_owned()\n-format!(\"{value}\", value=4);      // => \"4\".to_owned()\n-format!(\"{} {}\", 1, 2);           // => \"1 2\".to_owned()\n+format!(\"Hello\");                 // => \"Hello\".to_string()\n+format!(\"Hello, {:s}!\", \"world\"); // => \"Hello, world!\".to_string()\n+format!(\"The number is {:d}\", 1); // => \"The number is 1\".to_string()\n+format!(\"{:?}\", ~[3, 4]);         // => \"~[3, 4]\".to_string()\n+format!(\"{value}\", value=4);      // => \"4\".to_string()\n+format!(\"{} {}\", 1, 2);           // => \"1 2\".to_string()\n ```\n \n From these, you can see that the first argument is a format string. It is\n@@ -62,7 +62,7 @@ iterator over the argument. Each time a \"next argument\" specifier is seen, the\n iterator advances. This leads to behavior like this:\n \n ```rust\n-format!(\"{1} {} {0} {}\", 1, 2); // => \"2 1 1 2\".to_owned()\n+format!(\"{1} {} {0} {}\", 1, 2); // => \"2 1 1 2\".to_string()\n ```\n \n The internal iterator over the argument has not been advanced by the time the\n@@ -89,9 +89,9 @@ identifier '=' expression\n For example, the following `format!` expressions all use named argument:\n \n ```rust\n-format!(\"{argument}\", argument = \"test\");       // => \"test\".to_owned()\n-format!(\"{name} {}\", 1, name = 2);              // => \"2 1\".to_owned()\n-format!(\"{a:s} {c:d} {b:?}\", a=\"a\", b=(), c=3); // => \"a 3 ()\".to_owned()\n+format!(\"{argument}\", argument = \"test\");       // => \"test\".to_string()\n+format!(\"{name} {}\", 1, name = 2);              // => \"2 1\".to_string()\n+format!(\"{a:s} {c:d} {b:?}\", a=\"a\", b=(), c=3); // => \"a 3 ()\".to_string()\n ```\n \n It is illegal to put positional parameters (those without names) after arguments\n@@ -330,7 +330,7 @@ to reference the string value of the argument which was selected upon. As an\n example:\n \n ```rust\n-format!(\"{0, select, other{#}}\", \"hello\"); // => \"hello\".to_owned()\n+format!(\"{0, select, other{#}}\", \"hello\"); // => \"hello\".to_string()\n ```\n \n This example is the equivalent of `{0:s}` essentially.\n@@ -543,19 +543,19 @@ pub trait Poly {\n /// use std::fmt;\n ///\n /// let s = format_args!(fmt::format, \"Hello, {}!\", \"world\");\n-/// assert_eq!(s, \"Hello, world!\".to_owned());\n+/// assert_eq!(s, \"Hello, world!\".to_string());\n /// ```\n pub fn format(args: &Arguments) -> string::String{\n     let mut output = io::MemWriter::new();\n     let _ = write!(&mut output, \"{}\", args);\n-    str::from_utf8(output.unwrap().as_slice()).unwrap().into_strbuf()\n+    str::from_utf8(output.unwrap().as_slice()).unwrap().into_string()\n }\n \n /// Temporary transition utility\n pub fn format_strbuf(args: &Arguments) -> string::String {\n     let mut output = io::MemWriter::new();\n     let _ = write!(&mut output, \"{}\", args);\n-    str::from_utf8(output.unwrap().as_slice()).unwrap().into_strbuf()\n+    str::from_utf8(output.unwrap().as_slice()).unwrap().into_string()\n }\n \n impl<T> Poly for T {"}, {"sha": "8e95263d48e095adf6b5fe6e6333a58d44911dd0", "filename": "src/libstd/hash/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fmod.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -27,8 +27,8 @@\n  *     phone: u64,\n  * }\n  *\n- * let person1 = Person { id: 5, name: \"Janet\".to_owned(), phone: 555_666_7777 };\n- * let person2 = Person { id: 5, name: \"Bob\".to_owned(), phone: 555_666_7777 };\n+ * let person1 = Person { id: 5, name: \"Janet\".to_string(), phone: 555_666_7777 };\n+ * let person2 = Person { id: 5, name: \"Bob\".to_string(), phone: 555_666_7777 };\n  *\n  * assert!(hash::hash(&person1) != hash::hash(&person2));\n  * ```\n@@ -54,8 +54,8 @@\n  *     }\n  * }\n  *\n- * let person1 = Person { id: 5, name: \"Janet\".to_owned(), phone: 555_666_7777 };\n- * let person2 = Person { id: 5, name: \"Bob\".to_owned(), phone: 555_666_7777 };\n+ * let person1 = Person { id: 5, name: \"Janet\".to_string(), phone: 555_666_7777 };\n+ * let person2 = Person { id: 5, name: \"Bob\".to_string(), phone: 555_666_7777 };\n  *\n  * assert!(hash::hash(&person1) == hash::hash(&person2));\n  * ```"}, {"sha": "643bc166c2762d30262e9958be942268c901ae80", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -537,9 +537,9 @@ mod test {\n     fn test_read_line() {\n         let in_buf = MemReader::new(Vec::from_slice(bytes!(\"a\\nb\\nc\")));\n         let mut reader = BufferedReader::with_capacity(2, in_buf);\n-        assert_eq!(reader.read_line(), Ok(\"a\\n\".to_strbuf()));\n-        assert_eq!(reader.read_line(), Ok(\"b\\n\".to_strbuf()));\n-        assert_eq!(reader.read_line(), Ok(\"c\".to_strbuf()));\n+        assert_eq!(reader.read_line(), Ok(\"a\\n\".to_string()));\n+        assert_eq!(reader.read_line(), Ok(\"b\\n\".to_string()));\n+        assert_eq!(reader.read_line(), Ok(\"c\".to_string()));\n         assert!(reader.read_line().is_err());\n     }\n \n@@ -548,9 +548,9 @@ mod test {\n         let in_buf = MemReader::new(Vec::from_slice(bytes!(\"a\\nb\\nc\")));\n         let mut reader = BufferedReader::with_capacity(2, in_buf);\n         let mut it = reader.lines();\n-        assert_eq!(it.next(), Some(Ok(\"a\\n\".to_strbuf())));\n-        assert_eq!(it.next(), Some(Ok(\"b\\n\".to_strbuf())));\n-        assert_eq!(it.next(), Some(Ok(\"c\".to_strbuf())));\n+        assert_eq!(it.next(), Some(Ok(\"a\\n\".to_string())));\n+        assert_eq!(it.next(), Some(Ok(\"b\\n\".to_string())));\n+        assert_eq!(it.next(), Some(Ok(\"c\".to_string())));\n         assert_eq!(it.next(), None);\n     }\n "}, {"sha": "735966d812b92f8c0ec59d18eeda2b312ba03e89", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -497,7 +497,7 @@ mod test {\n         writer.write_line(\"testing\").unwrap();\n         writer.write_str(\"testing\").unwrap();\n         let mut r = BufReader::new(writer.get_ref());\n-        assert_eq!(r.read_to_str().unwrap(), \"testingtesting\\ntesting\".to_strbuf());\n+        assert_eq!(r.read_to_str().unwrap(), \"testingtesting\\ntesting\".to_string());\n     }\n \n     #[test]\n@@ -507,7 +507,7 @@ mod test {\n         writer.write_char('\\n').unwrap();\n         writer.write_char('\u1ec7').unwrap();\n         let mut r = BufReader::new(writer.get_ref());\n-        assert_eq!(r.read_to_str().unwrap(), \"a\\n\u1ec7\".to_strbuf());\n+        assert_eq!(r.read_to_str().unwrap(), \"a\\n\u1ec7\".to_string());\n     }\n \n     #[test]"}, {"sha": "4d02a470f308c194da396a141843aea79ddeefa2", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -496,7 +496,7 @@ pub trait Reader {\n     fn read_at_least(&mut self, min: uint, buf: &mut [u8]) -> IoResult<uint> {\n         if min > buf.len() {\n             return Err(IoError {\n-                detail: Some(\"the buffer is too short\".to_strbuf()),\n+                detail: Some(\"the buffer is too short\".to_string()),\n                 ..standard_error(InvalidInput)\n             });\n         }\n@@ -564,7 +564,7 @@ pub trait Reader {\n     fn push_at_least(&mut self, min: uint, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> {\n         if min > len {\n             return Err(IoError {\n-                detail: Some(\"the buffer is too short\".to_strbuf()),\n+                detail: Some(\"the buffer is too short\".to_string()),\n                 ..standard_error(InvalidInput)\n             });\n         }\n@@ -635,7 +635,7 @@ pub trait Reader {\n     fn read_to_str(&mut self) -> IoResult<String> {\n         self.read_to_end().and_then(|s| {\n             match str::from_utf8(s.as_slice()) {\n-                Some(s) => Ok(s.to_strbuf()),\n+                Some(s) => Ok(s.to_string()),\n                 None => Err(standard_error(InvalidInput)),\n             }\n         })\n@@ -1315,7 +1315,7 @@ pub trait Buffer: Reader {\n     /// use std::io;\n     ///\n     /// let mut reader = io::stdin();\n-    /// let input = reader.read_line().ok().unwrap_or(\"nothing\".to_owned());\n+    /// let input = reader.read_line().ok().unwrap_or(\"nothing\".to_string());\n     /// ```\n     ///\n     /// # Error\n@@ -1333,7 +1333,7 @@ pub trait Buffer: Reader {\n     fn read_line(&mut self) -> IoResult<String> {\n         self.read_until('\\n' as u8).and_then(|line|\n             match str::from_utf8(line.as_slice()) {\n-                Some(s) => Ok(s.to_strbuf()),\n+                Some(s) => Ok(s.to_string()),\n                 None => Err(standard_error(InvalidInput)),\n             }\n         )"}, {"sha": "5004e8a5a07077ae405465f90feb00dee66dd3df", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -445,8 +445,8 @@ mod test {\n     #[test]\n     fn ipv6_addr_to_str() {\n         let a1 = Ipv6Addr(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x280);\n-        assert!(a1.to_str() == \"::ffff:192.0.2.128\".to_strbuf() ||\n-                a1.to_str() == \"::FFFF:192.0.2.128\".to_strbuf());\n-        assert_eq!(Ipv6Addr(8, 9, 10, 11, 12, 13, 14, 15).to_str(), \"8:9:a:b:c:d:e:f\".to_strbuf());\n+        assert!(a1.to_str() == \"::ffff:192.0.2.128\".to_string() ||\n+                a1.to_str() == \"::FFFF:192.0.2.128\".to_string());\n+        assert_eq!(Ipv6Addr(8, 9, 10, 11, 12, 13, 14, 15).to_str(), \"8:9:a:b:c:d:e:f\".to_string());\n     }\n }"}, {"sha": "20d20a14f9a1870c438000f1c68c928b909c0dab", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -601,7 +601,7 @@ mod tests {\n     iotest!(fn stdout_works() {\n         let mut cmd = Command::new(\"echo\");\n         cmd.arg(\"foobar\").stdout(CreatePipe(false, true));\n-        assert_eq!(run_output(cmd), \"foobar\\n\".to_strbuf());\n+        assert_eq!(run_output(cmd), \"foobar\\n\".to_string());\n     })\n \n     #[cfg(unix, not(target_os=\"android\"))]\n@@ -610,7 +610,7 @@ mod tests {\n         cmd.arg(\"-c\").arg(\"pwd\")\n            .cwd(&Path::new(\"/\"))\n            .stdout(CreatePipe(false, true));\n-        assert_eq!(run_output(cmd), \"/\\n\".to_strbuf());\n+        assert_eq!(run_output(cmd), \"/\\n\".to_string());\n     })\n \n     #[cfg(unix, not(target_os=\"android\"))]\n@@ -624,7 +624,7 @@ mod tests {\n         drop(p.stdin.take());\n         let out = read_all(p.stdout.get_mut_ref() as &mut Reader);\n         assert!(p.wait().unwrap().success());\n-        assert_eq!(out, \"foobar\\n\".to_strbuf());\n+        assert_eq!(out, \"foobar\\n\".to_string());\n     })\n \n     #[cfg(not(target_os=\"android\"))]\n@@ -682,7 +682,7 @@ mod tests {\n         let output_str = str::from_utf8(output.as_slice()).unwrap();\n \n         assert!(status.success());\n-        assert_eq!(output_str.trim().to_strbuf(), \"hello\".to_strbuf());\n+        assert_eq!(output_str.trim().to_string(), \"hello\".to_string());\n         // FIXME #7224\n         if !running_on_valgrind() {\n             assert_eq!(error, Vec::new());\n@@ -719,7 +719,7 @@ mod tests {\n         let output_str = str::from_utf8(output.as_slice()).unwrap();\n \n         assert!(status.success());\n-        assert_eq!(output_str.trim().to_strbuf(), \"hello\".to_strbuf());\n+        assert_eq!(output_str.trim().to_string(), \"hello\".to_string());\n         // FIXME #7224\n         if !running_on_valgrind() {\n             assert_eq!(error, Vec::new());\n@@ -749,7 +749,7 @@ mod tests {\n         let prog = pwd_cmd().spawn().unwrap();\n \n         let output = str::from_utf8(prog.wait_with_output().unwrap()\n-                                        .output.as_slice()).unwrap().to_strbuf();\n+                                        .output.as_slice()).unwrap().to_string();\n         let parent_dir = os::getcwd();\n         let child_dir = Path::new(output.as_slice().trim());\n \n@@ -768,8 +768,8 @@ mod tests {\n         let prog = pwd_cmd().cwd(&parent_dir).spawn().unwrap();\n \n         let output = str::from_utf8(prog.wait_with_output().unwrap()\n-                                        .output.as_slice()).unwrap().to_strbuf();\n-        let child_dir = Path::new(output.as_slice().trim().into_strbuf());\n+                                        .output.as_slice()).unwrap().to_string();\n+        let child_dir = Path::new(output.as_slice().trim().into_string());\n \n         let parent_stat = parent_dir.stat().unwrap();\n         let child_stat = child_dir.stat().unwrap();\n@@ -803,7 +803,7 @@ mod tests {\n \n         let prog = env_cmd().spawn().unwrap();\n         let output = str::from_utf8(prog.wait_with_output().unwrap()\n-                                        .output.as_slice()).unwrap().to_strbuf();\n+                                        .output.as_slice()).unwrap().to_string();\n \n         let r = os::env();\n         for &(ref k, ref v) in r.iter() {\n@@ -821,12 +821,12 @@ mod tests {\n         let mut prog = env_cmd().spawn().unwrap();\n         let output = str::from_utf8(prog.wait_with_output()\n                                         .unwrap().output.as_slice())\n-                                   .unwrap().to_strbuf();\n+                                   .unwrap().to_string();\n \n         let r = os::env();\n         for &(ref k, ref v) in r.iter() {\n             // don't check android RANDOM variables\n-            if *k != \"RANDOM\".to_strbuf() {\n+            if *k != \"RANDOM\".to_string() {\n                 assert!(output.as_slice()\n                               .contains(format!(\"{}={}\",\n                                                 *k,\n@@ -843,7 +843,7 @@ mod tests {\n         let new_env = box [(\"RUN_TEST_NEW_ENV\", \"123\")];\n         let prog = env_cmd().env(new_env).spawn().unwrap();\n         let result = prog.wait_with_output().unwrap();\n-        let output = str::from_utf8_lossy(result.output.as_slice()).into_strbuf();\n+        let output = str::from_utf8_lossy(result.output.as_slice()).into_string();\n \n         assert!(output.as_slice().contains(\"RUN_TEST_NEW_ENV=123\"),\n                 \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);"}, {"sha": "6de4c6316d1df1112253d07f03e5dc332feae352", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -409,7 +409,7 @@ mod tests {\n             set_stdout(box w);\n             println!(\"hello!\");\n         });\n-        assert_eq!(r.read_to_str().unwrap(), \"hello!\\n\".to_strbuf());\n+        assert_eq!(r.read_to_str().unwrap(), \"hello!\\n\".to_string());\n     })\n \n     iotest!(fn capture_stderr() {"}, {"sha": "bc1e3b82547fe4aa86090b915ceed8fa337e64f1", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -49,7 +49,7 @@\n //! `&str`, a UTF-8 string, is a built-in type, and the standard library\n //! defines methods for it on a variety of traits in the\n //! [`str`](str/index.html) module. Rust strings are immutable;\n-//! use the `String` type defined in [`strbuf`](strbuf/index.html)\n+//! use the `String` type defined in [`string`](string/index.html)\n //! for a mutable string builder.\n //!\n //! For converting to strings use the [`format!`](fmt/index.html)"}, {"sha": "7bf0b19407fe34ca5e7af0c56d019204e8da9aef", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -277,11 +277,11 @@ mod tests {\n     #[test]\n     fn test_tls_multitask() {\n         static my_key: Key<String> = &Key;\n-        my_key.replace(Some(\"parent data\".to_strbuf()));\n+        my_key.replace(Some(\"parent data\".to_string()));\n         task::spawn(proc() {\n             // TLS shouldn't carry over.\n             assert!(my_key.get().is_none());\n-            my_key.replace(Some(\"child data\".to_strbuf()));\n+            my_key.replace(Some(\"child data\".to_string()));\n             assert!(my_key.get().get_ref().as_slice() == \"child data\");\n             // should be cleaned up for us\n         });\n@@ -295,16 +295,16 @@ mod tests {\n     #[test]\n     fn test_tls_overwrite() {\n         static my_key: Key<String> = &Key;\n-        my_key.replace(Some(\"first data\".to_strbuf()));\n-        my_key.replace(Some(\"next data\".to_strbuf())); // Shouldn't leak.\n+        my_key.replace(Some(\"first data\".to_string()));\n+        my_key.replace(Some(\"next data\".to_string())); // Shouldn't leak.\n         assert!(my_key.get().unwrap().as_slice() == \"next data\");\n     }\n \n     #[test]\n     fn test_tls_pop() {\n         static my_key: Key<String> = &Key;\n-        my_key.replace(Some(\"weasel\".to_strbuf()));\n-        assert!(my_key.replace(None).unwrap() == \"weasel\".to_strbuf());\n+        my_key.replace(Some(\"weasel\".to_string()));\n+        assert!(my_key.replace(None).unwrap() == \"weasel\".to_string());\n         // Pop must remove the data from the map.\n         assert!(my_key.replace(None).is_none());\n     }\n@@ -319,7 +319,7 @@ mod tests {\n         // a stack smaller than 1 MB.\n         static my_key: Key<String> = &Key;\n         task::spawn(proc() {\n-            my_key.replace(Some(\"hax\".to_strbuf()));\n+            my_key.replace(Some(\"hax\".to_string()));\n         });\n     }\n \n@@ -329,7 +329,7 @@ mod tests {\n         static box_key: Key<@()> = &Key;\n         static int_key: Key<int> = &Key;\n         task::spawn(proc() {\n-            str_key.replace(Some(\"string data\".to_strbuf()));\n+            str_key.replace(Some(\"string data\".to_string()));\n             box_key.replace(Some(@()));\n             int_key.replace(Some(42));\n         });\n@@ -341,8 +341,8 @@ mod tests {\n         static box_key: Key<@()> = &Key;\n         static int_key: Key<int> = &Key;\n         task::spawn(proc() {\n-            str_key.replace(Some(\"string data\".to_strbuf()));\n-            str_key.replace(Some(\"string data 2\".to_strbuf()));\n+            str_key.replace(Some(\"string data\".to_string()));\n+            str_key.replace(Some(\"string data 2\".to_string()));\n             box_key.replace(Some(@()));\n             box_key.replace(Some(@()));\n             int_key.replace(Some(42));\n@@ -359,10 +359,10 @@ mod tests {\n         static str_key: Key<String> = &Key;\n         static box_key: Key<@()> = &Key;\n         static int_key: Key<int> = &Key;\n-        str_key.replace(Some(\"parent data\".to_strbuf()));\n+        str_key.replace(Some(\"parent data\".to_string()));\n         box_key.replace(Some(@()));\n         task::spawn(proc() {\n-            str_key.replace(Some(\"string data\".to_strbuf()));\n+            str_key.replace(Some(\"string data\".to_string()));\n             box_key.replace(Some(@()));\n             int_key.replace(Some(42));\n             fail!();"}, {"sha": "7ed00e3dd9d6fa8e6720a2ef07801fdebf0f2ace", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -136,39 +136,39 @@ mod tests {\n \n     #[test]\n     fn test_to_str() {\n-        assert_eq!((0 as $T).to_str_radix(10u), \"0\".to_strbuf());\n-        assert_eq!((1 as $T).to_str_radix(10u), \"1\".to_strbuf());\n-        assert_eq!((-1 as $T).to_str_radix(10u), \"-1\".to_strbuf());\n-        assert_eq!((127 as $T).to_str_radix(16u), \"7f\".to_strbuf());\n-        assert_eq!((100 as $T).to_str_radix(10u), \"100\".to_strbuf());\n+        assert_eq!((0 as $T).to_str_radix(10u), \"0\".to_string());\n+        assert_eq!((1 as $T).to_str_radix(10u), \"1\".to_string());\n+        assert_eq!((-1 as $T).to_str_radix(10u), \"-1\".to_string());\n+        assert_eq!((127 as $T).to_str_radix(16u), \"7f\".to_string());\n+        assert_eq!((100 as $T).to_str_radix(10u), \"100\".to_string());\n \n     }\n \n     #[test]\n     fn test_int_to_str_overflow() {\n         let mut i8_val: i8 = 127_i8;\n-        assert_eq!(i8_val.to_str(), \"127\".to_strbuf());\n+        assert_eq!(i8_val.to_str(), \"127\".to_string());\n \n         i8_val += 1 as i8;\n-        assert_eq!(i8_val.to_str(), \"-128\".to_strbuf());\n+        assert_eq!(i8_val.to_str(), \"-128\".to_string());\n \n         let mut i16_val: i16 = 32_767_i16;\n-        assert_eq!(i16_val.to_str(), \"32767\".to_strbuf());\n+        assert_eq!(i16_val.to_str(), \"32767\".to_string());\n \n         i16_val += 1 as i16;\n-        assert_eq!(i16_val.to_str(), \"-32768\".to_strbuf());\n+        assert_eq!(i16_val.to_str(), \"-32768\".to_string());\n \n         let mut i32_val: i32 = 2_147_483_647_i32;\n-        assert_eq!(i32_val.to_str(), \"2147483647\".to_strbuf());\n+        assert_eq!(i32_val.to_str(), \"2147483647\".to_string());\n \n         i32_val += 1 as i32;\n-        assert_eq!(i32_val.to_str(), \"-2147483648\".to_strbuf());\n+        assert_eq!(i32_val.to_str(), \"-2147483648\".to_string());\n \n         let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-        assert_eq!(i64_val.to_str(), \"9223372036854775807\".to_strbuf());\n+        assert_eq!(i64_val.to_str(), \"9223372036854775807\".to_string());\n \n         i64_val += 1 as i64;\n-        assert_eq!(i64_val.to_str(), \"-9223372036854775808\".to_strbuf());\n+        assert_eq!(i64_val.to_str(), \"-9223372036854775808\".to_string());\n     }\n \n     #[test]"}, {"sha": "43048453717464959516ecece10fb7942a2e4544", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -94,13 +94,13 @@ mod tests {\n \n     #[test]\n     pub fn test_to_str() {\n-        assert_eq!((0 as $T).to_str_radix(10u), \"0\".to_strbuf());\n-        assert_eq!((1 as $T).to_str_radix(10u), \"1\".to_strbuf());\n-        assert_eq!((2 as $T).to_str_radix(10u), \"2\".to_strbuf());\n-        assert_eq!((11 as $T).to_str_radix(10u), \"11\".to_strbuf());\n-        assert_eq!((11 as $T).to_str_radix(16u), \"b\".to_strbuf());\n-        assert_eq!((255 as $T).to_str_radix(16u), \"ff\".to_strbuf());\n-        assert_eq!((0xff as $T).to_str_radix(10u), \"255\".to_strbuf());\n+        assert_eq!((0 as $T).to_str_radix(10u), \"0\".to_string());\n+        assert_eq!((1 as $T).to_str_radix(10u), \"1\".to_string());\n+        assert_eq!((2 as $T).to_str_radix(10u), \"2\".to_string());\n+        assert_eq!((11 as $T).to_str_radix(10u), \"11\".to_string());\n+        assert_eq!((11 as $T).to_str_radix(16u), \"b\".to_string());\n+        assert_eq!((255 as $T).to_str_radix(16u), \"ff\".to_string());\n+        assert_eq!((0xff as $T).to_str_radix(10u), \"255\".to_string());\n     }\n \n     #[test]\n@@ -133,28 +133,28 @@ mod tests {\n     #[test]\n     fn test_uint_to_str_overflow() {\n         let mut u8_val: u8 = 255_u8;\n-        assert_eq!(u8_val.to_str(), \"255\".to_strbuf());\n+        assert_eq!(u8_val.to_str(), \"255\".to_string());\n \n         u8_val += 1 as u8;\n-        assert_eq!(u8_val.to_str(), \"0\".to_strbuf());\n+        assert_eq!(u8_val.to_str(), \"0\".to_string());\n \n         let mut u16_val: u16 = 65_535_u16;\n-        assert_eq!(u16_val.to_str(), \"65535\".to_strbuf());\n+        assert_eq!(u16_val.to_str(), \"65535\".to_string());\n \n         u16_val += 1 as u16;\n-        assert_eq!(u16_val.to_str(), \"0\".to_strbuf());\n+        assert_eq!(u16_val.to_str(), \"0\".to_string());\n \n         let mut u32_val: u32 = 4_294_967_295_u32;\n-        assert_eq!(u32_val.to_str(), \"4294967295\".to_strbuf());\n+        assert_eq!(u32_val.to_str(), \"4294967295\".to_string());\n \n         u32_val += 1 as u32;\n-        assert_eq!(u32_val.to_str(), \"0\".to_strbuf());\n+        assert_eq!(u32_val.to_str(), \"0\".to_string());\n \n         let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n-        assert_eq!(u64_val.to_str(), \"18446744073709551615\".to_strbuf());\n+        assert_eq!(u64_val.to_str(), \"18446744073709551615\".to_string());\n \n         u64_val += 1 as u64;\n-        assert_eq!(u64_val.to_str(), \"0\".to_strbuf());\n+        assert_eq!(u64_val.to_str(), \"0\".to_string());\n     }\n \n     #[test]"}, {"sha": "7d3758d621d32249627a723cab852ec5dd4159d8", "filename": "src/libstd/os.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -178,8 +178,8 @@ fn with_env_lock<T>(f: || -> T) -> T {\n /// for details.\n pub fn env() -> Vec<(String,String)> {\n     env_as_bytes().move_iter().map(|(k,v)| {\n-        let k = str::from_utf8_lossy(k.as_slice()).to_strbuf();\n-        let v = str::from_utf8_lossy(v.as_slice()).to_strbuf();\n+        let k = str::from_utf8_lossy(k.as_slice()).to_string();\n+        let v = str::from_utf8_lossy(v.as_slice()).to_string();\n         (k,v)\n     }).collect()\n }\n@@ -277,7 +277,7 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n ///\n /// Fails if `n` has any interior NULs.\n pub fn getenv(n: &str) -> Option<String> {\n-    getenv_as_bytes(n).map(|v| str::from_utf8_lossy(v.as_slice()).to_strbuf())\n+    getenv_as_bytes(n).map(|v| str::from_utf8_lossy(v.as_slice()).to_string())\n }\n \n #[cfg(unix)]\n@@ -503,7 +503,7 @@ pub fn self_exe_name() -> Option<Path> {\n             use os::win32::fill_utf16_buf_and_decode;\n             fill_utf16_buf_and_decode(|buf, sz| {\n                 libc::GetModuleFileNameW(0u as libc::DWORD, buf, sz)\n-            }).map(|s| s.into_strbuf().into_bytes())\n+            }).map(|s| s.into_string().into_bytes())\n         }\n     }\n \n@@ -736,7 +736,7 @@ pub fn error_string(errnum: uint) -> String {\n                 fail!(\"strerror_r failure\");\n             }\n \n-            str::raw::from_c_str(p as *c_char).into_strbuf()\n+            str::raw::from_c_str(p as *c_char).into_string()\n         }\n     }\n \n@@ -859,7 +859,7 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n fn real_args() -> Vec<String> {\n     real_args_as_bytes().move_iter()\n                         .map(|v| {\n-                            str::from_utf8_lossy(v.as_slice()).into_strbuf()\n+                            str::from_utf8_lossy(v.as_slice()).into_string()\n                         }).collect()\n }\n \n@@ -1522,7 +1522,7 @@ mod tests {\n     fn test_setenv() {\n         let n = make_rand_name();\n         setenv(n.as_slice(), \"VALUE\");\n-        assert_eq!(getenv(n.as_slice()), option::Some(\"VALUE\".to_strbuf()));\n+        assert_eq!(getenv(n.as_slice()), option::Some(\"VALUE\".to_string()));\n     }\n \n     #[test]\n@@ -1539,17 +1539,17 @@ mod tests {\n         let n = make_rand_name();\n         setenv(n.as_slice(), \"1\");\n         setenv(n.as_slice(), \"2\");\n-        assert_eq!(getenv(n.as_slice()), option::Some(\"2\".to_strbuf()));\n+        assert_eq!(getenv(n.as_slice()), option::Some(\"2\".to_string()));\n         setenv(n.as_slice(), \"\");\n-        assert_eq!(getenv(n.as_slice()), option::Some(\"\".to_strbuf()));\n+        assert_eq!(getenv(n.as_slice()), option::Some(\"\".to_string()));\n     }\n \n     // Windows GetEnvironmentVariable requires some extra work to make sure\n     // the buffer the variable is copied into is the right size\n     #[test]\n     #[ignore]\n     fn test_getenv_big() {\n-        let mut s = \"\".to_strbuf();\n+        let mut s = \"\".to_string();\n         let mut i = 0;\n         while i < 100 {\n             s.push_str(\"aaaaaaaaaa\");\n@@ -1602,7 +1602,7 @@ mod tests {\n     #[test]\n     fn test_env_set_get_huge() {\n         let n = make_rand_name();\n-        let s = \"x\".repeat(10000).to_strbuf();\n+        let s = \"x\".repeat(10000).to_string();\n         setenv(n.as_slice(), s.as_slice());\n         assert_eq!(getenv(n.as_slice()), Some(s));\n         unsetenv(n.as_slice());\n@@ -1615,10 +1615,10 @@ mod tests {\n \n         let mut e = env();\n         setenv(n.as_slice(), \"VALUE\");\n-        assert!(!e.contains(&(n.clone(), \"VALUE\".to_strbuf())));\n+        assert!(!e.contains(&(n.clone(), \"VALUE\".to_string())));\n \n         e = env();\n-        assert!(e.contains(&(n, \"VALUE\".to_strbuf())));\n+        assert!(e.contains(&(n, \"VALUE\".to_string())));\n     }\n \n     #[test]"}, {"sha": "c0c7a042f11c91580003bbdbc9460c3e4cc4e66a", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -761,7 +761,7 @@ mod tests {\n         t!(s: \"a/b/c\", [\"d\", \"e\"], \"a/b/c/d/e\");\n         t!(s: \"a/b/c\", [\"d\", \"/e\"], \"/e\");\n         t!(s: \"a/b/c\", [\"d\", \"/e\", \"f\"], \"/e/f\");\n-        t!(s: \"a/b/c\", [\"d\".to_strbuf(), \"e\".to_strbuf()], \"a/b/c/d/e\");\n+        t!(s: \"a/b/c\", [\"d\".to_string(), \"e\".to_string()], \"a/b/c/d/e\");\n         t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"e\")], b!(\"a/b/c/d/e\"));\n         t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"/e\"), b!(\"f\")], b!(\"/e/f\"));\n         t!(v: b!(\"a/b/c\"), [Vec::from_slice(b!(\"d\")), Vec::from_slice(b!(\"e\"))], b!(\"a/b/c/d/e\"));\n@@ -866,7 +866,7 @@ mod tests {\n         t!(s: \"a/b/c\", [\"d\", \"e\"], \"a/b/c/d/e\");\n         t!(s: \"a/b/c\", [\"..\", \"d\"], \"a/b/d\");\n         t!(s: \"a/b/c\", [\"d\", \"/e\", \"f\"], \"/e/f\");\n-        t!(s: \"a/b/c\", [\"d\".to_strbuf(), \"e\".to_strbuf()], \"a/b/c/d/e\");\n+        t!(s: \"a/b/c\", [\"d\".to_string(), \"e\".to_string()], \"a/b/c/d/e\");\n         t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"e\")], b!(\"a/b/c/d/e\"));\n         t!(v: b!(\"a/b/c\"), [Vec::from_slice(b!(\"d\")), Vec::from_slice(b!(\"e\"))], b!(\"a/b/c/d/e\"));\n     }"}, {"sha": "1fc2fa1d221dc6c3d5184fcf5b588d4f28efbb6d", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -587,7 +587,7 @@ impl GenericPath for Path {\n                     }\n                 }\n             }\n-            Some(Path::new(comps.connect(\"\\\\\").into_strbuf()))\n+            Some(Path::new(comps.connect(\"\\\\\").into_string()))\n         }\n     }\n \n@@ -695,7 +695,7 @@ impl Path {\n             (prefix, path)\n         };\n         (prefix, match val {\n-            None => s.into_strbuf(),\n+            None => s.into_string(),\n             Some(val) => val\n         })\n     }\n@@ -1318,9 +1318,9 @@ mod tests {\n     #[test]\n     fn test_display_str() {\n         let path = Path::new(\"foo\");\n-        assert_eq!(path.display().to_str(), \"foo\".to_strbuf());\n+        assert_eq!(path.display().to_str(), \"foo\".to_string());\n         let path = Path::new(b!(\"\\\\\"));\n-        assert_eq!(path.filename_display().to_str(), \"\".to_strbuf());\n+        assert_eq!(path.filename_display().to_str(), \"\".to_string());\n \n         let path = Path::new(\"foo\");\n         let mo = path.display().as_maybe_owned();\n@@ -1581,7 +1581,7 @@ mod tests {\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\"], \"\\\\e\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\", \"f\"], \"\\\\e\\\\f\");\n-        t!(s: \"a\\\\b\\\\c\", [\"d\".to_strbuf(), \"e\".to_strbuf()], \"a\\\\b\\\\c\\\\d\\\\e\");\n+        t!(s: \"a\\\\b\\\\c\", [\"d\".to_string(), \"e\".to_string()], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"e\")], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n         t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"\\\\e\"), b!(\"f\")], b!(\"\\\\e\\\\f\"));\n         t!(v: b!(\"a\\\\b\\\\c\"), [Vec::from_slice(b!(\"d\")), Vec::from_slice(b!(\"e\"))],\n@@ -1722,7 +1722,7 @@ mod tests {\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(s: \"a\\\\b\\\\c\", [\"..\", \"d\"], \"a\\\\b\\\\d\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\", \"f\"], \"\\\\e\\\\f\");\n-        t!(s: \"a\\\\b\\\\c\", [\"d\".to_strbuf(), \"e\".to_strbuf()], \"a\\\\b\\\\c\\\\d\\\\e\");\n+        t!(s: \"a\\\\b\\\\c\", [\"d\".to_string(), \"e\".to_string()], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"e\")], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n         t!(v: b!(\"a\\\\b\\\\c\"), [Vec::from_slice(b!(\"d\")), Vec::from_slice(b!(\"e\"))],\n            b!(\"a\\\\b\\\\c\\\\d\\\\e\"));"}, {"sha": "969c20d8b55de221be036aca9d621983d7cf5f17", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -609,7 +609,7 @@ pub fn repr_to_str<T>(t: &T) -> String {\n \n     let mut result = io::MemWriter::new();\n     write_repr(&mut result as &mut io::Writer, t).unwrap();\n-    str::from_utf8(result.unwrap().as_slice()).unwrap().to_strbuf()\n+    str::from_utf8(result.unwrap().as_slice()).unwrap().to_string()\n }\n \n #[cfg(test)]"}, {"sha": "7f492a00b80db2f2b37b3bf0162fdca6321450cc", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -421,10 +421,10 @@ mod test {\n     #[test]\n     fn tls() {\n         local_data_key!(key: @String)\n-        key.replace(Some(@\"data\".to_strbuf()));\n+        key.replace(Some(@\"data\".to_string()));\n         assert_eq!(key.get().unwrap().as_slice(), \"data\");\n         local_data_key!(key2: @String)\n-        key2.replace(Some(@\"data\".to_strbuf()));\n+        key2.replace(Some(@\"data\".to_string()));\n         assert_eq!(key2.get().unwrap().as_slice(), \"data\");\n     }\n "}, {"sha": "e5c0cc3babd0377dadc41e5c32b3118b1e07ffcb", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -396,7 +396,7 @@ pub trait OwnedVector<T> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// let v = ~[\"a\".to_owned(), \"b\".to_owned()];\n+    /// let v = ~[\"a\".to_string(), \"b\".to_string()];\n     /// for s in v.move_iter() {\n     ///   // s has type ~str, not &~str\n     ///   println!(\"{}\", s);\n@@ -1186,7 +1186,7 @@ mod tests {\n             assert_eq!(it.next(), None);\n         }\n         {\n-            let v = [\"Hello\".to_owned()];\n+            let v = [\"Hello\".to_string()];\n             let mut it = v.permutations();\n             let (min_size, max_opt) = it.size_hint();\n             assert_eq!(min_size, 1);\n@@ -1839,18 +1839,18 @@ mod tests {\n             })\n         )\n         let empty: ~[int] = box [];\n-        test_show_vec!(empty, \"[]\".to_strbuf());\n-        test_show_vec!(box [1], \"[1]\".to_strbuf());\n-        test_show_vec!(box [1, 2, 3], \"[1, 2, 3]\".to_strbuf());\n+        test_show_vec!(empty, \"[]\".to_string());\n+        test_show_vec!(box [1], \"[1]\".to_string());\n+        test_show_vec!(box [1, 2, 3], \"[1, 2, 3]\".to_string());\n         test_show_vec!(box [box [], box [1u], box [1u, 1u]],\n-                       \"[[], [1], [1, 1]]\".to_strbuf());\n+                       \"[[], [1], [1, 1]]\".to_string());\n \n         let empty_mut: &mut [int] = &mut[];\n-        test_show_vec!(empty_mut, \"[]\".to_strbuf());\n-        test_show_vec!(&mut[1], \"[1]\".to_strbuf());\n-        test_show_vec!(&mut[1, 2, 3], \"[1, 2, 3]\".to_strbuf());\n+        test_show_vec!(empty_mut, \"[]\".to_string());\n+        test_show_vec!(&mut[1], \"[1]\".to_string());\n+        test_show_vec!(&mut[1, 2, 3], \"[1, 2, 3]\".to_string());\n         test_show_vec!(&mut[&mut[], &mut[1u], &mut[1u, 1u]],\n-                       \"[[], [1], [1, 1]]\".to_strbuf());\n+                       \"[[], [1], [1, 1]]\".to_string());\n     }\n \n     #[test]"}, {"sha": "9e15612c72b405555be1a36ac36ebeb0604acafd", "filename": "src/libstd/str.rs", "status": "modified", "additions": 115, "deletions": 113, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -331,7 +331,7 @@ Section: Misc\n /// // \ud834\udd1emusic\n /// let mut v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n ///              0x0073, 0x0069, 0x0063];\n-/// assert_eq!(str::from_utf16(v), Some(\"\ud834\udd1emusic\".to_owned()));\n+/// assert_eq!(str::from_utf16(v), Some(\"\ud834\udd1emusic\".to_string()));\n ///\n /// // \ud834\udd1emu<invalid>ic\n /// v[4] = 0xD800;\n@@ -361,7 +361,7 @@ pub fn from_utf16(v: &[u16]) -> Option<String> {\n ///          0xD834];\n ///\n /// assert_eq!(str::from_utf16_lossy(v),\n-///            \"\ud834\udd1emus\\uFFFDic\\uFFFD\".to_owned());\n+///            \"\ud834\udd1emus\\uFFFDic\\uFFFD\".to_string());\n /// ```\n pub fn from_utf16_lossy(v: &[u16]) -> String {\n     utf16_items(v).map(|c| c.to_char_lossy()).collect()\n@@ -610,7 +610,7 @@ impl<'a> StrAllocating for MaybeOwned<'a> {\n     #[inline]\n     fn into_owned(self) -> String {\n         match self {\n-            Slice(s) => s.to_owned(),\n+            Slice(s) => s.to_string(),\n             Owned(s) => s\n         }\n     }\n@@ -626,7 +626,7 @@ impl<'a> Clone for MaybeOwned<'a> {\n     fn clone(&self) -> MaybeOwned<'a> {\n         match *self {\n             Slice(s) => Slice(s),\n-            Owned(ref s) => Owned(s.to_owned())\n+            Owned(ref s) => Owned(s.to_string())\n         }\n     }\n }\n@@ -711,7 +711,7 @@ pub mod raw {\n             let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n             let b = a.as_ptr();\n             let c = from_buf_len(b, 3u);\n-            assert_eq!(c, \"AAA\".to_owned());\n+            assert_eq!(c, \"AAA\".to_string());\n         }\n     }\n }\n@@ -727,13 +727,13 @@ pub trait StrAllocating: Str {\n \n     /// Convert `self` into a `String`.\n     #[inline]\n-    fn to_strbuf(&self) -> String {\n+    fn to_string(&self) -> String {\n         String::from_str(self.as_slice())\n     }\n \n     /// Convert `self` into a `String`, not making a copy if possible.\n     #[inline]\n-    fn into_strbuf(self) -> String {\n+    fn into_string(self) -> String {\n         self.into_owned()\n     }\n \n@@ -772,11 +772,11 @@ pub trait StrAllocating: Str {\n     ///\n     /// ```rust\n     /// let s = \"Do you know the muffin man,\n-    /// The muffin man, the muffin man, ...\".to_owned();\n+    /// The muffin man, the muffin man, ...\".to_string();\n     ///\n     /// assert_eq!(s.replace(\"muffin man\", \"little lamb\"),\n     ///            \"Do you know the little lamb,\n-    /// The little lamb, the little lamb, ...\".to_owned());\n+    /// The little lamb, the little lamb, ...\".to_string());\n     ///\n     /// // not found, so no change.\n     /// assert_eq!(s.replace(\"cookie monster\", \"little lamb\"), s);\n@@ -794,7 +794,8 @@ pub trait StrAllocating: Str {\n         result\n     }\n \n-    /// Copy a slice into a new `String`.\n+    #[allow(missing_doc)]\n+    #[deprecated = \"obsolete, use `to_string`\"]\n     #[inline]\n     fn to_owned(&self) -> String {\n         use slice::Vector;\n@@ -889,7 +890,7 @@ pub trait StrAllocating: Str {\n impl<'a> StrAllocating for &'a str {\n     #[inline]\n     fn into_owned(self) -> String {\n-        self.to_owned()\n+        self.to_string()\n     }\n }\n \n@@ -911,10 +912,9 @@ impl OwnedStr for String {\n     }\n \n     #[inline]\n-    fn append(self, rhs: &str) -> String {\n-        let mut new_str = String::from_owned_str(self);\n-        new_str.push_str(rhs);\n-        new_str\n+    fn append(mut self, rhs: &str) -> String {\n+        self.push_str(rhs);\n+        self\n     }\n }\n \n@@ -983,17 +983,17 @@ mod tests {\n \n     #[test]\n     fn test_collect() {\n-        let empty = \"\".to_owned();\n+        let empty = \"\".to_string();\n         let s: String = empty.as_slice().chars().collect();\n         assert_eq!(empty, s);\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\".to_owned();\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\".to_string();\n         let s: String = data.as_slice().chars().collect();\n         assert_eq!(data, s);\n     }\n \n     #[test]\n     fn test_into_bytes() {\n-        let data = \"asdf\".to_owned();\n+        let data = \"asdf\".to_string();\n         let buf = data.into_bytes();\n         assert_eq!(bytes!(\"asdf\"), buf.as_slice());\n     }\n@@ -1010,7 +1010,7 @@ mod tests {\n         assert!(data.slice(2u, 4u).find_str(\"ab\").is_none());\n \n         let string = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let mut data = string.to_strbuf();\n+        let mut data = string.to_string();\n         data.push_str(string);\n         assert!(data.as_slice().find_str(\"\u0e44\u0e17\u534e\").is_none());\n         assert_eq!(data.as_slice().slice(0u, 43u).find_str(\"\"), Some(0u));\n@@ -1047,24 +1047,24 @@ mod tests {\n         fn t(v: &[String], s: &str) {\n             assert_eq!(v.concat(), s.to_str().into_owned());\n         }\n-        t([\"you\".to_owned(), \"know\".to_owned(), \"I'm\".to_owned(),\n-          \"no\".to_owned(), \"good\".to_owned()], \"youknowI'mnogood\");\n+        t([\"you\".to_string(), \"know\".to_string(), \"I'm\".to_string(),\n+          \"no\".to_string(), \"good\".to_string()], \"youknowI'mnogood\");\n         let v: &[String] = [];\n         t(v, \"\");\n-        t([\"hi\".to_owned()], \"hi\");\n+        t([\"hi\".to_string()], \"hi\");\n     }\n \n     #[test]\n     fn test_connect() {\n         fn t(v: &[String], sep: &str, s: &str) {\n             assert_eq!(v.connect(sep), s.to_str().into_owned());\n         }\n-        t([\"you\".to_owned(), \"know\".to_owned(), \"I'm\".to_owned(),\n-           \"no\".to_owned(), \"good\".to_owned()],\n+        t([\"you\".to_string(), \"know\".to_string(), \"I'm\".to_string(),\n+           \"no\".to_string(), \"good\".to_string()],\n           \" \", \"you know I'm no good\");\n         let v: &[String] = [];\n         t(v, \" \", \"\");\n-        t([\"hi\".to_owned()], \" \", \"hi\");\n+        t([\"hi\".to_string()], \" \", \"hi\");\n     }\n \n     #[test]\n@@ -1091,11 +1091,11 @@ mod tests {\n \n     #[test]\n     fn test_repeat() {\n-        assert_eq!(\"x\".repeat(4), \"xxxx\".to_owned());\n-        assert_eq!(\"hi\".repeat(4), \"hihihihi\".to_owned());\n-        assert_eq!(\"\u0e44\u0e17\u534e\".repeat(3), \"\u0e44\u0e17\u534e\u0e44\u0e17\u534e\u0e44\u0e17\u534e\".to_owned());\n-        assert_eq!(\"\".repeat(4), \"\".to_owned());\n-        assert_eq!(\"hi\".repeat(0), \"\".to_owned());\n+        assert_eq!(\"x\".repeat(4), \"xxxx\".to_string());\n+        assert_eq!(\"hi\".repeat(4), \"hihihihi\".to_string());\n+        assert_eq!(\"\u0e44\u0e17\u534e\".repeat(3), \"\u0e44\u0e17\u534e\u0e44\u0e17\u534e\u0e44\u0e17\u534e\".to_string());\n+        assert_eq!(\"\".repeat(4), \"\".to_string());\n+        assert_eq!(\"hi\".repeat(0), \"\".to_string());\n     }\n \n     #[test]\n@@ -1159,13 +1159,13 @@ mod tests {\n     #[test]\n     fn test_replace() {\n         let a = \"a\";\n-        assert_eq!(\"\".replace(a, \"b\"), \"\".to_owned());\n-        assert_eq!(\"a\".replace(a, \"b\"), \"b\".to_owned());\n-        assert_eq!(\"ab\".replace(a, \"b\"), \"bb\".to_owned());\n+        assert_eq!(\"\".replace(a, \"b\"), \"\".to_string());\n+        assert_eq!(\"a\".replace(a, \"b\"), \"b\".to_string());\n+        assert_eq!(\"ab\".replace(a, \"b\"), \"bb\".to_string());\n         let test = \"test\";\n         assert!(\" test test \".replace(test, \"toast\") ==\n-            \" toast toast \".to_owned());\n-        assert_eq!(\" test test \".replace(test, \"\"), \"   \".to_owned());\n+            \" toast toast \".to_string());\n+        assert_eq!(\" test test \".replace(test, \"\"), \"   \".to_string());\n     }\n \n     #[test]\n@@ -1468,7 +1468,7 @@ mod tests {\n             let a = box [65, 65, 65, 65, 65, 65, 65, 0];\n             let b = a.as_ptr();\n             let c = raw::from_c_str(b);\n-            assert_eq!(c, \"AAAAAAA\".to_owned());\n+            assert_eq!(c, \"AAAAAAA\".to_string());\n         }\n     }\n \n@@ -1490,7 +1490,7 @@ mod tests {\n     fn test_as_bytes_fail() {\n         // Don't double free. (I'm not sure if this exercises the\n         // original problem code path anymore.)\n-        let s = \"\".to_owned();\n+        let s = \"\".to_string();\n         let _bytes = s.as_bytes();\n         fail!();\n     }\n@@ -1533,10 +1533,10 @@ mod tests {\n \n     #[test]\n     fn vec_str_conversions() {\n-        let s1: String = \"All mimsy were the borogoves\".to_strbuf();\n+        let s1: String = \"All mimsy were the borogoves\".to_string();\n \n         let v: Vec<u8> = Vec::from_slice(s1.as_bytes());\n-        let s2: String = from_utf8(v.as_slice()).unwrap().to_strbuf();\n+        let s2: String = from_utf8(v.as_slice()).unwrap().to_string();\n         let mut i: uint = 0u;\n         let n1: uint = s1.len();\n         let n2: uint = v.len();\n@@ -1579,21 +1579,21 @@ mod tests {\n     #[test]\n     fn test_utf16() {\n         let pairs =\n-            [(\"\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\\n\".to_owned(),\n+            [(\"\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\\n\".to_string(),\n               vec![0xd800_u16, 0xdf45_u16, 0xd800_u16, 0xdf3f_u16,\n                 0xd800_u16, 0xdf3b_u16, 0xd800_u16, 0xdf46_u16,\n                 0xd800_u16, 0xdf39_u16, 0xd800_u16, 0xdf3b_u16,\n                 0xd800_u16, 0xdf30_u16, 0x000a_u16]),\n \n-             (\"\ud801\udc12\ud801\udc49\ud801\udc2e\ud801\udc40\ud801\udc32\ud801\udc4b \ud801\udc0f\ud801\udc32\ud801\udc4d\\n\".to_owned(),\n+             (\"\ud801\udc12\ud801\udc49\ud801\udc2e\ud801\udc40\ud801\udc32\ud801\udc4b \ud801\udc0f\ud801\udc32\ud801\udc4d\\n\".to_string(),\n               vec![0xd801_u16, 0xdc12_u16, 0xd801_u16,\n                 0xdc49_u16, 0xd801_u16, 0xdc2e_u16, 0xd801_u16,\n                 0xdc40_u16, 0xd801_u16, 0xdc32_u16, 0xd801_u16,\n                 0xdc4b_u16, 0x0020_u16, 0xd801_u16, 0xdc0f_u16,\n                 0xd801_u16, 0xdc32_u16, 0xd801_u16, 0xdc4d_u16,\n                 0x000a_u16]),\n \n-             (\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u00b7\ud800\udf0c\ud800\udf04\ud800\udf15\ud800\udf04\ud800\udf0b\ud800\udf09\ud800\udf11\\n\".to_owned(),\n+             (\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u00b7\ud800\udf0c\ud800\udf04\ud800\udf15\ud800\udf04\ud800\udf0b\ud800\udf09\ud800\udf11\\n\".to_string(),\n               vec![0xd800_u16, 0xdf00_u16, 0xd800_u16, 0xdf16_u16,\n                 0xd800_u16, 0xdf0b_u16, 0xd800_u16, 0xdf04_u16,\n                 0xd800_u16, 0xdf11_u16, 0xd800_u16, 0xdf09_u16,\n@@ -1602,7 +1602,7 @@ mod tests {\n                 0xdf04_u16, 0xd800_u16, 0xdf0b_u16, 0xd800_u16,\n                 0xdf09_u16, 0xd800_u16, 0xdf11_u16, 0x000a_u16 ]),\n \n-             (\"\ud801\udc8b\ud801\udc98\ud801\udc88\ud801\udc91\ud801\udc9b\ud801\udc92 \ud801\udc95\ud801\udc93 \ud801\udc88\ud801\udc9a\ud801\udc8d \ud801\udc8f\ud801\udc9c\ud801\udc92\ud801\udc96\ud801\udc86 \ud801\udc95\ud801\udc86\\n\".to_owned(),\n+             (\"\ud801\udc8b\ud801\udc98\ud801\udc88\ud801\udc91\ud801\udc9b\ud801\udc92 \ud801\udc95\ud801\udc93 \ud801\udc88\ud801\udc9a\ud801\udc8d \ud801\udc8f\ud801\udc9c\ud801\udc92\ud801\udc96\ud801\udc86 \ud801\udc95\ud801\udc86\\n\".to_string(),\n               vec![0xd801_u16, 0xdc8b_u16, 0xd801_u16, 0xdc98_u16,\n                 0xd801_u16, 0xdc88_u16, 0xd801_u16, 0xdc91_u16,\n                 0xd801_u16, 0xdc9b_u16, 0xd801_u16, 0xdc92_u16,\n@@ -1615,7 +1615,7 @@ mod tests {\n                 0xd801_u16, 0xdc95_u16, 0xd801_u16, 0xdc86_u16,\n                 0x000a_u16 ]),\n              // Issue #12318, even-numbered non-BMP planes\n-             (\"\\U00020000\".to_owned(),\n+             (\"\\U00020000\".to_string(),\n               vec![0xD840, 0xDC00])];\n \n         for p in pairs.iter() {\n@@ -1650,15 +1650,16 @@ mod tests {\n     fn test_utf16_lossy() {\n         // completely positive cases tested above.\n         // lead + eof\n-        assert_eq!(from_utf16_lossy([0xD800]), \"\\uFFFD\".to_owned());\n+        assert_eq!(from_utf16_lossy([0xD800]), \"\\uFFFD\".to_string());\n         // lead + lead\n-        assert_eq!(from_utf16_lossy([0xD800, 0xD800]), \"\\uFFFD\\uFFFD\".to_owned());\n+        assert_eq!(from_utf16_lossy([0xD800, 0xD800]), \"\\uFFFD\\uFFFD\".to_string());\n \n         // isolated trail\n-        assert_eq!(from_utf16_lossy([0x0061, 0xDC00]), \"a\\uFFFD\".to_owned());\n+        assert_eq!(from_utf16_lossy([0x0061, 0xDC00]), \"a\\uFFFD\".to_string());\n \n         // general\n-        assert_eq!(from_utf16_lossy([0xD800, 0xd801, 0xdc8b, 0xD800]), \"\\uFFFD\ud801\udc8b\\uFFFD\".to_owned());\n+        assert_eq!(from_utf16_lossy([0xD800, 0xd801, 0xdc8b, 0xD800]),\n+                   \"\\uFFFD\ud801\udc8b\\uFFFD\".to_string());\n     }\n \n     #[test]\n@@ -1703,27 +1704,27 @@ mod tests {\n \n     #[test]\n     fn test_escape_unicode() {\n-        assert_eq!(\"abc\".escape_unicode(), \"\\\\x61\\\\x62\\\\x63\".to_owned());\n-        assert_eq!(\"a c\".escape_unicode(), \"\\\\x61\\\\x20\\\\x63\".to_owned());\n-        assert_eq!(\"\\r\\n\\t\".escape_unicode(), \"\\\\x0d\\\\x0a\\\\x09\".to_owned());\n-        assert_eq!(\"'\\\"\\\\\".escape_unicode(), \"\\\\x27\\\\x22\\\\x5c\".to_owned());\n-        assert_eq!(\"\\x00\\x01\\xfe\\xff\".escape_unicode(), \"\\\\x00\\\\x01\\\\xfe\\\\xff\".to_owned());\n-        assert_eq!(\"\\u0100\\uffff\".escape_unicode(), \"\\\\u0100\\\\uffff\".to_owned());\n-        assert_eq!(\"\\U00010000\\U0010ffff\".escape_unicode(), \"\\\\U00010000\\\\U0010ffff\".to_owned());\n-        assert_eq!(\"ab\\ufb00\".escape_unicode(), \"\\\\x61\\\\x62\\\\ufb00\".to_owned());\n-        assert_eq!(\"\\U0001d4ea\\r\".escape_unicode(), \"\\\\U0001d4ea\\\\x0d\".to_owned());\n+        assert_eq!(\"abc\".escape_unicode(), \"\\\\x61\\\\x62\\\\x63\".to_string());\n+        assert_eq!(\"a c\".escape_unicode(), \"\\\\x61\\\\x20\\\\x63\".to_string());\n+        assert_eq!(\"\\r\\n\\t\".escape_unicode(), \"\\\\x0d\\\\x0a\\\\x09\".to_string());\n+        assert_eq!(\"'\\\"\\\\\".escape_unicode(), \"\\\\x27\\\\x22\\\\x5c\".to_string());\n+        assert_eq!(\"\\x00\\x01\\xfe\\xff\".escape_unicode(), \"\\\\x00\\\\x01\\\\xfe\\\\xff\".to_string());\n+        assert_eq!(\"\\u0100\\uffff\".escape_unicode(), \"\\\\u0100\\\\uffff\".to_string());\n+        assert_eq!(\"\\U00010000\\U0010ffff\".escape_unicode(), \"\\\\U00010000\\\\U0010ffff\".to_string());\n+        assert_eq!(\"ab\\ufb00\".escape_unicode(), \"\\\\x61\\\\x62\\\\ufb00\".to_string());\n+        assert_eq!(\"\\U0001d4ea\\r\".escape_unicode(), \"\\\\U0001d4ea\\\\x0d\".to_string());\n     }\n \n     #[test]\n     fn test_escape_default() {\n-        assert_eq!(\"abc\".escape_default(), \"abc\".to_owned());\n-        assert_eq!(\"a c\".escape_default(), \"a c\".to_owned());\n-        assert_eq!(\"\\r\\n\\t\".escape_default(), \"\\\\r\\\\n\\\\t\".to_owned());\n-        assert_eq!(\"'\\\"\\\\\".escape_default(), \"\\\\'\\\\\\\"\\\\\\\\\".to_owned());\n-        assert_eq!(\"\\u0100\\uffff\".escape_default(), \"\\\\u0100\\\\uffff\".to_owned());\n-        assert_eq!(\"\\U00010000\\U0010ffff\".escape_default(), \"\\\\U00010000\\\\U0010ffff\".to_owned());\n-        assert_eq!(\"ab\\ufb00\".escape_default(), \"ab\\\\ufb00\".to_owned());\n-        assert_eq!(\"\\U0001d4ea\\r\".escape_default(), \"\\\\U0001d4ea\\\\r\".to_owned());\n+        assert_eq!(\"abc\".escape_default(), \"abc\".to_string());\n+        assert_eq!(\"a c\".escape_default(), \"a c\".to_string());\n+        assert_eq!(\"\\r\\n\\t\".escape_default(), \"\\\\r\\\\n\\\\t\".to_string());\n+        assert_eq!(\"'\\\"\\\\\".escape_default(), \"\\\\'\\\\\\\"\\\\\\\\\".to_string());\n+        assert_eq!(\"\\u0100\\uffff\".escape_default(), \"\\\\u0100\\\\uffff\".to_string());\n+        assert_eq!(\"\\U00010000\\U0010ffff\".escape_default(), \"\\\\U00010000\\\\U0010ffff\".to_string());\n+        assert_eq!(\"ab\\ufb00\".escape_default(), \"ab\\\\ufb00\".to_string());\n+        assert_eq!(\"\\U0001d4ea\\r\".escape_default(), \"\\\\U0001d4ea\\\\r\".to_string());\n     }\n \n     #[test]\n@@ -1968,30 +1969,30 @@ mod tests {\n \n     #[test]\n     fn test_nfd_chars() {\n-        assert_eq!(\"abc\".nfd_chars().collect::<String>(), \"abc\".to_strbuf());\n-        assert_eq!(\"\\u1e0b\\u01c4\".nfd_chars().collect::<String>(), \"d\\u0307\\u01c4\".to_strbuf());\n-        assert_eq!(\"\\u2026\".nfd_chars().collect::<String>(), \"\\u2026\".to_strbuf());\n-        assert_eq!(\"\\u2126\".nfd_chars().collect::<String>(), \"\\u03a9\".to_strbuf());\n-        assert_eq!(\"\\u1e0b\\u0323\".nfd_chars().collect::<String>(), \"d\\u0323\\u0307\".to_strbuf());\n-        assert_eq!(\"\\u1e0d\\u0307\".nfd_chars().collect::<String>(), \"d\\u0323\\u0307\".to_strbuf());\n-        assert_eq!(\"a\\u0301\".nfd_chars().collect::<String>(), \"a\\u0301\".to_strbuf());\n-        assert_eq!(\"\\u0301a\".nfd_chars().collect::<String>(), \"\\u0301a\".to_strbuf());\n-        assert_eq!(\"\\ud4db\".nfd_chars().collect::<String>(), \"\\u1111\\u1171\\u11b6\".to_strbuf());\n-        assert_eq!(\"\\uac1c\".nfd_chars().collect::<String>(), \"\\u1100\\u1162\".to_strbuf());\n+        assert_eq!(\"abc\".nfd_chars().collect::<String>(), \"abc\".to_string());\n+        assert_eq!(\"\\u1e0b\\u01c4\".nfd_chars().collect::<String>(), \"d\\u0307\\u01c4\".to_string());\n+        assert_eq!(\"\\u2026\".nfd_chars().collect::<String>(), \"\\u2026\".to_string());\n+        assert_eq!(\"\\u2126\".nfd_chars().collect::<String>(), \"\\u03a9\".to_string());\n+        assert_eq!(\"\\u1e0b\\u0323\".nfd_chars().collect::<String>(), \"d\\u0323\\u0307\".to_string());\n+        assert_eq!(\"\\u1e0d\\u0307\".nfd_chars().collect::<String>(), \"d\\u0323\\u0307\".to_string());\n+        assert_eq!(\"a\\u0301\".nfd_chars().collect::<String>(), \"a\\u0301\".to_string());\n+        assert_eq!(\"\\u0301a\".nfd_chars().collect::<String>(), \"\\u0301a\".to_string());\n+        assert_eq!(\"\\ud4db\".nfd_chars().collect::<String>(), \"\\u1111\\u1171\\u11b6\".to_string());\n+        assert_eq!(\"\\uac1c\".nfd_chars().collect::<String>(), \"\\u1100\\u1162\".to_string());\n     }\n \n     #[test]\n     fn test_nfkd_chars() {\n-        assert_eq!(\"abc\".nfkd_chars().collect::<String>(), \"abc\".to_strbuf());\n-        assert_eq!(\"\\u1e0b\\u01c4\".nfkd_chars().collect::<String>(), \"d\\u0307DZ\\u030c\".to_strbuf());\n-        assert_eq!(\"\\u2026\".nfkd_chars().collect::<String>(), \"...\".to_strbuf());\n-        assert_eq!(\"\\u2126\".nfkd_chars().collect::<String>(), \"\\u03a9\".to_strbuf());\n-        assert_eq!(\"\\u1e0b\\u0323\".nfkd_chars().collect::<String>(), \"d\\u0323\\u0307\".to_strbuf());\n-        assert_eq!(\"\\u1e0d\\u0307\".nfkd_chars().collect::<String>(), \"d\\u0323\\u0307\".to_strbuf());\n-        assert_eq!(\"a\\u0301\".nfkd_chars().collect::<String>(), \"a\\u0301\".to_strbuf());\n-        assert_eq!(\"\\u0301a\".nfkd_chars().collect::<String>(), \"\\u0301a\".to_strbuf());\n-        assert_eq!(\"\\ud4db\".nfkd_chars().collect::<String>(), \"\\u1111\\u1171\\u11b6\".to_strbuf());\n-        assert_eq!(\"\\uac1c\".nfkd_chars().collect::<String>(), \"\\u1100\\u1162\".to_strbuf());\n+        assert_eq!(\"abc\".nfkd_chars().collect::<String>(), \"abc\".to_string());\n+        assert_eq!(\"\\u1e0b\\u01c4\".nfkd_chars().collect::<String>(), \"d\\u0307DZ\\u030c\".to_string());\n+        assert_eq!(\"\\u2026\".nfkd_chars().collect::<String>(), \"...\".to_string());\n+        assert_eq!(\"\\u2126\".nfkd_chars().collect::<String>(), \"\\u03a9\".to_string());\n+        assert_eq!(\"\\u1e0b\\u0323\".nfkd_chars().collect::<String>(), \"d\\u0323\\u0307\".to_string());\n+        assert_eq!(\"\\u1e0d\\u0307\".nfkd_chars().collect::<String>(), \"d\\u0323\\u0307\".to_string());\n+        assert_eq!(\"a\\u0301\".nfkd_chars().collect::<String>(), \"a\\u0301\".to_string());\n+        assert_eq!(\"\\u0301a\".nfkd_chars().collect::<String>(), \"\\u0301a\".to_string());\n+        assert_eq!(\"\\ud4db\".nfkd_chars().collect::<String>(), \"\\u1111\\u1171\\u11b6\".to_string());\n+        assert_eq!(\"\\uac1c\".nfkd_chars().collect::<String>(), \"\\u1100\\u1162\".to_string());\n     }\n \n     #[test]\n@@ -2045,9 +2046,10 @@ mod tests {\n             v.iter().map(|x| x.len()).sum()\n         }\n \n-        let s = \"01234\".to_owned();\n+        let s = \"01234\".to_string();\n         assert_eq!(5, sum_len([\"012\", \"\", \"34\"]));\n-        assert_eq!(5, sum_len([\"01\".to_owned(), \"2\".to_owned(), \"34\".to_owned(), \"\".to_owned()]));\n+        assert_eq!(5, sum_len([\"01\".to_string(), \"2\".to_string(),\n+                               \"34\".to_string(), \"\".to_string()]));\n         assert_eq!(5, sum_len([s.as_slice()]));\n     }\n \n@@ -2066,10 +2068,10 @@ mod tests {\n     #[test]\n     fn test_str_from_utf8_owned() {\n         let xs = Vec::from_slice(bytes!(\"hello\"));\n-        assert_eq!(from_utf8_owned(xs), Ok(\"hello\".to_owned()));\n+        assert_eq!(from_utf8_owned(xs), Ok(\"hello\".to_string()));\n \n         let xs = Vec::from_slice(bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n-        assert_eq!(from_utf8_owned(xs), Ok(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_owned()));\n+        assert_eq!(from_utf8_owned(xs), Ok(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_string()));\n \n         let xs = Vec::from_slice(bytes!(\"hello\", 0xff));\n         assert_eq!(from_utf8_owned(xs),\n@@ -2085,53 +2087,53 @@ mod tests {\n         assert_eq!(from_utf8_lossy(xs), Slice(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n \n         let xs = bytes!(\"Hello\", 0xC2, \" There\", 0xFF, \" Goodbye\");\n-        assert_eq!(from_utf8_lossy(xs), Owned(\"Hello\\uFFFD There\\uFFFD Goodbye\".to_owned()));\n+        assert_eq!(from_utf8_lossy(xs), Owned(\"Hello\\uFFFD There\\uFFFD Goodbye\".to_string()));\n \n         let xs = bytes!(\"Hello\", 0xC0, 0x80, \" There\", 0xE6, 0x83, \" Goodbye\");\n-        assert_eq!(from_utf8_lossy(xs), Owned(\"Hello\\uFFFD\\uFFFD There\\uFFFD Goodbye\".to_owned()));\n+        assert_eq!(from_utf8_lossy(xs), Owned(\"Hello\\uFFFD\\uFFFD There\\uFFFD Goodbye\".to_string()));\n \n         let xs = bytes!(0xF5, \"foo\", 0xF5, 0x80, \"bar\");\n-        assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFDfoo\\uFFFD\\uFFFDbar\".to_owned()));\n+        assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFDfoo\\uFFFD\\uFFFDbar\".to_string()));\n \n         let xs = bytes!(0xF1, \"foo\", 0xF1, 0x80, \"bar\", 0xF1, 0x80, 0x80, \"baz\");\n-        assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFDfoo\\uFFFDbar\\uFFFDbaz\".to_owned()));\n+        assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFDfoo\\uFFFDbar\\uFFFDbaz\".to_string()));\n \n         let xs = bytes!(0xF4, \"foo\", 0xF4, 0x80, \"bar\", 0xF4, 0xBF, \"baz\");\n-        assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFDfoo\\uFFFDbar\\uFFFD\\uFFFDbaz\".to_owned()));\n+        assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFDfoo\\uFFFDbar\\uFFFD\\uFFFDbaz\".to_string()));\n \n         let xs = bytes!(0xF0, 0x80, 0x80, 0x80, \"foo\", 0xF0, 0x90, 0x80, 0x80, \"bar\");\n         assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\\n-                                               foo\\U00010000bar\".to_owned()));\n+                                               foo\\U00010000bar\".to_string()));\n \n         // surrogates\n         let xs = bytes!(0xED, 0xA0, 0x80, \"foo\", 0xED, 0xBF, 0xBF, \"bar\");\n         assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFD\\uFFFD\\uFFFDfoo\\\n-                                               \\uFFFD\\uFFFD\\uFFFDbar\".to_owned()));\n+                                               \\uFFFD\\uFFFD\\uFFFDbar\".to_string()));\n     }\n \n     #[test]\n     fn test_from_str() {\n       let owned: Option<String> = from_str(\"string\");\n-      assert_eq!(owned, Some(\"string\".to_strbuf()));\n+      assert_eq!(owned, Some(\"string\".to_string()));\n     }\n \n     #[test]\n     fn test_maybe_owned_traits() {\n         let s = Slice(\"abcde\");\n         assert_eq!(s.len(), 5);\n         assert_eq!(s.as_slice(), \"abcde\");\n-        assert_eq!(s.to_str(), \"abcde\".to_strbuf());\n-        assert_eq!(format_strbuf!(\"{}\", s), \"abcde\".to_strbuf());\n-        assert!(s.lt(&Owned(\"bcdef\".to_owned())));\n+        assert_eq!(s.to_str(), \"abcde\".to_string());\n+        assert_eq!(format_strbuf!(\"{}\", s), \"abcde\".to_string());\n+        assert!(s.lt(&Owned(\"bcdef\".to_string())));\n         assert_eq!(Slice(\"\"), Default::default());\n \n-        let o = Owned(\"abcde\".to_owned());\n+        let o = Owned(\"abcde\".to_string());\n         assert_eq!(o.len(), 5);\n         assert_eq!(o.as_slice(), \"abcde\");\n-        assert_eq!(o.to_str(), \"abcde\".to_strbuf());\n-        assert_eq!(format_strbuf!(\"{}\", o), \"abcde\".to_strbuf());\n+        assert_eq!(o.to_str(), \"abcde\".to_string());\n+        assert_eq!(format_strbuf!(\"{}\", o), \"abcde\".to_string());\n         assert!(o.lt(&Slice(\"bcdef\")));\n-        assert_eq!(Owned(\"\".to_owned()), Default::default());\n+        assert_eq!(Owned(\"\".to_string()), Default::default());\n \n         assert!(s.cmp(&o) == Equal);\n         assert!(s.equiv(&o));\n@@ -2146,31 +2148,31 @@ mod tests {\n         assert!(s.is_slice());\n         assert!(!s.is_owned());\n \n-        let o = Owned(\"abcde\".to_owned());\n+        let o = Owned(\"abcde\".to_string());\n         assert!(!o.is_slice());\n         assert!(o.is_owned());\n     }\n \n     #[test]\n     fn test_maybe_owned_clone() {\n-        assert_eq!(Owned(\"abcde\".to_owned()), Slice(\"abcde\").clone());\n-        assert_eq!(Owned(\"abcde\".to_owned()), Owned(\"abcde\".to_owned()).clone());\n+        assert_eq!(Owned(\"abcde\".to_string()), Slice(\"abcde\").clone());\n+        assert_eq!(Owned(\"abcde\".to_string()), Owned(\"abcde\".to_string()).clone());\n         assert_eq!(Slice(\"abcde\"), Slice(\"abcde\").clone());\n-        assert_eq!(Slice(\"abcde\"), Owned(\"abcde\".to_owned()).clone());\n+        assert_eq!(Slice(\"abcde\"), Owned(\"abcde\".to_string()).clone());\n     }\n \n     #[test]\n     fn test_maybe_owned_into_owned() {\n-        assert_eq!(Slice(\"abcde\").into_owned(), \"abcde\".to_owned());\n-        assert_eq!(Owned(\"abcde\".to_owned()).into_owned(), \"abcde\".to_owned());\n+        assert_eq!(Slice(\"abcde\").into_owned(), \"abcde\".to_string());\n+        assert_eq!(Owned(\"abcde\".to_string()).into_owned(), \"abcde\".to_string());\n     }\n \n     #[test]\n     fn test_into_maybe_owned() {\n         assert_eq!(\"abcde\".into_maybe_owned(), Slice(\"abcde\"));\n-        assert_eq!((\"abcde\".to_owned()).into_maybe_owned(), Slice(\"abcde\"));\n-        assert_eq!(\"abcde\".into_maybe_owned(), Owned(\"abcde\".to_owned()));\n-        assert_eq!((\"abcde\".to_owned()).into_maybe_owned(), Owned(\"abcde\".to_owned()));\n+        assert_eq!((\"abcde\".to_string()).into_maybe_owned(), Slice(\"abcde\"));\n+        assert_eq!(\"abcde\".into_maybe_owned(), Owned(\"abcde\".to_string()));\n+        assert_eq!((\"abcde\".to_string()).into_maybe_owned(), Owned(\"abcde\".to_string()));\n     }\n }\n "}, {"sha": "dce96cb2e8f3276afa2805768984af1fe3efe6fc", "filename": "src/libstd/string.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstring.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -68,7 +68,8 @@ impl String {\n         }\n     }\n \n-    /// Creates a new string buffer from the given owned string, taking care not to copy it.\n+    #[allow(missing_doc)]\n+    #[deprecated = \"obsoleted by the removal of ~str\"]\n     #[inline]\n     pub fn from_owned_str(string: String) -> String {\n         string\n@@ -327,7 +328,7 @@ impl StrAllocating for String {\n     }\n \n     #[inline]\n-    fn into_strbuf(self) -> String {\n+    fn into_string(self) -> String {\n         self\n     }\n }\n@@ -361,7 +362,7 @@ impl<'a, S: Str> Equiv<S> for String {\n impl FromStr for String {\n     #[inline]\n     fn from_str(s: &str) -> Option<String> {\n-        Some(s.to_strbuf())\n+        Some(s.to_string())\n     }\n }\n "}, {"sha": "4824a9561078fe2d234181ab906b498c7aabe88f", "filename": "src/libstd/task.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -295,7 +295,7 @@ fn test_unnamed_task() {\n \n #[test]\n fn test_owned_named_task() {\n-    TaskBuilder::new().named(\"ada lovelace\".to_owned()).spawn(proc() {\n+    TaskBuilder::new().named(\"ada lovelace\".to_string()).spawn(proc() {\n         with_task_name(|name| {\n             assert!(name.unwrap() == \"ada lovelace\");\n         })\n@@ -367,7 +367,7 @@ fn test_back_to_the_future_result() {\n #[test]\n fn test_try_success() {\n     match try(proc() {\n-        \"Success!\".to_owned()\n+        \"Success!\".to_string()\n     }).as_ref().map(|s| s.as_slice()) {\n         result::Ok(\"Success!\") => (),\n         _ => fail!()\n@@ -497,12 +497,12 @@ fn test_try_fail_message_static_str() {\n #[test]\n fn test_try_fail_message_owned_str() {\n     match try(proc() {\n-        fail!(\"owned string\".to_strbuf());\n+        fail!(\"owned string\".to_string());\n     }) {\n         Err(e) => {\n             type T = String;\n             assert!(e.is::<T>());\n-            assert_eq!(*e.move::<T>().unwrap(), \"owned string\".to_strbuf());\n+            assert_eq!(*e.move::<T>().unwrap(), \"owned string\".to_string());\n         }\n         Ok(()) => fail!()\n     }"}, {"sha": "c2100111e126803788fcda483c25764a834bc43b", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -42,23 +42,23 @@ mod tests {\n \n     #[test]\n     fn test_simple_types() {\n-        assert_eq!(1i.to_str(), \"1\".to_strbuf());\n-        assert_eq!((-1i).to_str(), \"-1\".to_strbuf());\n-        assert_eq!(200u.to_str(), \"200\".to_strbuf());\n-        assert_eq!(2u8.to_str(), \"2\".to_strbuf());\n-        assert_eq!(true.to_str(), \"true\".to_strbuf());\n-        assert_eq!(false.to_str(), \"false\".to_strbuf());\n-        assert_eq!(().to_str(), \"()\".to_strbuf());\n-        assert_eq!((\"hi\".to_strbuf()).to_str(), \"hi\".to_strbuf());\n+        assert_eq!(1i.to_str(), \"1\".to_string());\n+        assert_eq!((-1i).to_str(), \"-1\".to_string());\n+        assert_eq!(200u.to_str(), \"200\".to_string());\n+        assert_eq!(2u8.to_str(), \"2\".to_string());\n+        assert_eq!(true.to_str(), \"true\".to_string());\n+        assert_eq!(false.to_str(), \"false\".to_string());\n+        assert_eq!(().to_str(), \"()\".to_string());\n+        assert_eq!((\"hi\".to_string()).to_str(), \"hi\".to_string());\n     }\n \n     #[test]\n     fn test_vectors() {\n         let x: ~[int] = box [];\n-        assert_eq!(x.to_str(), \"[]\".to_strbuf());\n-        assert_eq!((box [1]).to_str(), \"[1]\".to_strbuf());\n-        assert_eq!((box [1, 2, 3]).to_str(), \"[1, 2, 3]\".to_strbuf());\n+        assert_eq!(x.to_str(), \"[]\".to_string());\n+        assert_eq!((box [1]).to_str(), \"[1]\".to_string());\n+        assert_eq!((box [1, 2, 3]).to_str(), \"[1, 2, 3]\".to_string());\n         assert!((box [box [], box [1], box [1, 1]]).to_str() ==\n-               \"[[], [1], [1, 1]]\".to_strbuf());\n+               \"[[], [1], [1, 1]]\".to_string());\n     }\n }"}, {"sha": "81eb51107ba065deb23cad2ded43e58ec9f57fab", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -240,7 +240,7 @@ pub mod dl {\n             } else {\n                 Err(CString::new(last_error, false).as_str()\n                                                    .unwrap()\n-                                                   .to_strbuf())\n+                                                   .to_string())\n             };\n \n             ret"}, {"sha": "81f6c7c7c9b7d75fee0b7b987a4af01c31ea7310", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -669,7 +669,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v = vec!(\"a\".to_owned(), \"b\".to_owned());\n+    /// let v = vec!(\"a\".to_string(), \"b\".to_string());\n     /// for s in v.move_iter() {\n     ///     // s has type String, not &String\n     ///     println!(\"{}\", s);\n@@ -874,13 +874,14 @@ impl<T> Vec<T> {\n     ///\n     /// # Example\n     /// ```rust\n-    /// let mut v = vec!(\"foo\".to_owned(), \"bar\".to_owned(), \"baz\".to_owned(), \"qux\".to_owned());\n+    /// let mut v = vec!(\"foo\".to_string(), \"bar\".to_string(),\n+    ///                  \"baz\".to_string(), \"qux\".to_string());\n     ///\n-    /// assert_eq!(v.swap_remove(1), Some(\"bar\".to_owned()));\n-    /// assert_eq!(v, vec!(\"foo\".to_owned(), \"qux\".to_owned(), \"baz\".to_owned()));\n+    /// assert_eq!(v.swap_remove(1), Some(\"bar\".to_string()));\n+    /// assert_eq!(v, vec!(\"foo\".to_string(), \"qux\".to_string(), \"baz\".to_string()));\n     ///\n-    /// assert_eq!(v.swap_remove(0), Some(\"foo\".to_owned()));\n-    /// assert_eq!(v, vec!(\"baz\".to_owned(), \"qux\".to_owned()));\n+    /// assert_eq!(v.swap_remove(0), Some(\"foo\".to_string()));\n+    /// assert_eq!(v, vec!(\"baz\".to_string(), \"qux\".to_string()));\n     ///\n     /// assert_eq!(v.swap_remove(2), None);\n     /// ```\n@@ -1849,9 +1850,9 @@ mod tests {\n         let b: ~[u8] = FromVec::from_vec(a);\n         assert_eq!(b.as_slice(), &[]);\n \n-        let a = vec![\"one\".to_strbuf(), \"two\".to_strbuf()];\n+        let a = vec![\"one\".to_string(), \"two\".to_string()];\n         let b: ~[String] = FromVec::from_vec(a);\n-        assert_eq!(b.as_slice(), &[\"one\".to_strbuf(), \"two\".to_strbuf()]);\n+        assert_eq!(b.as_slice(), &[\"one\".to_string(), \"two\".to_string()]);\n \n         struct Foo {\n             x: uint,"}, {"sha": "eefa4da82a1c361dbc2c4b36397f5bf4a6b702be", "filename": "src/libsync/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsync%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsync%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -60,10 +60,10 @@ mod test {\n     pub fn DuplexStream1() {\n         let (left, right) = duplex();\n \n-        left.send(\"abc\".to_owned());\n+        left.send(\"abc\".to_string());\n         right.send(123);\n \n         assert!(left.recv() == 123);\n-        assert!(right.recv() == \"abc\".to_owned());\n+        assert!(right.recv() == \"abc\".to_string());\n     }\n }"}, {"sha": "0ce19e8f00a58aa83aa976dbd9278b2dfadf265e", "filename": "src/libsync/future.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Ffuture.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -143,34 +143,34 @@ mod test {\n \n     #[test]\n     fn test_from_value() {\n-        let mut f = Future::from_value(\"snail\".to_owned());\n-        assert_eq!(f.get(), \"snail\".to_owned());\n+        let mut f = Future::from_value(\"snail\".to_string());\n+        assert_eq!(f.get(), \"snail\".to_string());\n     }\n \n     #[test]\n     fn test_from_receiver() {\n         let (tx, rx) = channel();\n-        tx.send(\"whale\".to_owned());\n+        tx.send(\"whale\".to_string());\n         let mut f = Future::from_receiver(rx);\n-        assert_eq!(f.get(), \"whale\".to_owned());\n+        assert_eq!(f.get(), \"whale\".to_string());\n     }\n \n     #[test]\n     fn test_from_fn() {\n-        let mut f = Future::from_fn(proc() \"brail\".to_owned());\n-        assert_eq!(f.get(), \"brail\".to_owned());\n+        let mut f = Future::from_fn(proc() \"brail\".to_string());\n+        assert_eq!(f.get(), \"brail\".to_string());\n     }\n \n     #[test]\n     fn test_interface_get() {\n-        let mut f = Future::from_value(\"fail\".to_owned());\n-        assert_eq!(f.get(), \"fail\".to_owned());\n+        let mut f = Future::from_value(\"fail\".to_string());\n+        assert_eq!(f.get(), \"fail\".to_string());\n     }\n \n     #[test]\n     fn test_interface_unwrap() {\n-        let f = Future::from_value(\"fail\".to_owned());\n-        assert_eq!(f.unwrap(), \"fail\".to_owned());\n+        let f = Future::from_value(\"fail\".to_string());\n+        assert_eq!(f.unwrap(), \"fail\".to_string());\n     }\n \n     #[test]\n@@ -181,8 +181,8 @@ mod test {\n \n     #[test]\n     fn test_spawn() {\n-        let mut f = Future::spawn(proc() \"bale\".to_owned());\n-        assert_eq!(f.get(), \"bale\".to_owned());\n+        let mut f = Future::spawn(proc() \"bale\".to_string());\n+        assert_eq!(f.get(), \"bale\".to_string());\n     }\n \n     #[test]"}, {"sha": "6b81f8ee2e108b7520a9136c865b4040332cdf02", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -89,7 +89,7 @@ pub fn path_to_str<PI: Iterator<PathElem>>(mut path: PI) -> String {\n         }\n         s.push_str(e.as_slice());\n         s\n-    }).to_strbuf()\n+    }).to_string()\n }\n \n #[deriving(Clone)]\n@@ -679,61 +679,61 @@ fn node_id_to_str(map: &Map, id: NodeId) -> String {\n                 ItemImpl(..) => \"impl\",\n                 ItemMac(..) => \"macro\"\n             };\n-            (format!(\"{} {} (id={})\", item_str, path_str, id)).to_strbuf()\n+            (format!(\"{} {} (id={})\", item_str, path_str, id)).to_string()\n         }\n         Some(NodeForeignItem(item)) => {\n             let path_str = map.path_to_str_with_ident(id, item.ident);\n-            (format!(\"foreign item {} (id={})\", path_str, id)).to_strbuf()\n+            (format!(\"foreign item {} (id={})\", path_str, id)).to_string()\n         }\n         Some(NodeMethod(m)) => {\n             (format!(\"method {} in {} (id={})\",\n                     token::get_ident(m.ident),\n-                    map.path_to_str(id), id)).to_strbuf()\n+                    map.path_to_str(id), id)).to_string()\n         }\n         Some(NodeTraitMethod(ref tm)) => {\n             let m = ast_util::trait_method_to_ty_method(&**tm);\n             (format!(\"method {} in {} (id={})\",\n                     token::get_ident(m.ident),\n-                    map.path_to_str(id), id)).to_strbuf()\n+                    map.path_to_str(id), id)).to_string()\n         }\n         Some(NodeVariant(ref variant)) => {\n             (format!(\"variant {} in {} (id={})\",\n                     token::get_ident(variant.node.name),\n-                    map.path_to_str(id), id)).to_strbuf()\n+                    map.path_to_str(id), id)).to_string()\n         }\n         Some(NodeExpr(expr)) => {\n             (format!(\"expr {} (id={})\",\n-                    pprust::expr_to_str(expr), id)).to_strbuf()\n+                    pprust::expr_to_str(expr), id)).to_string()\n         }\n         Some(NodeStmt(stmt)) => {\n             (format!(\"stmt {} (id={})\",\n-                    pprust::stmt_to_str(stmt), id)).to_strbuf()\n+                    pprust::stmt_to_str(stmt), id)).to_string()\n         }\n         Some(NodeArg(pat)) => {\n             (format!(\"arg {} (id={})\",\n-                    pprust::pat_to_str(pat), id)).to_strbuf()\n+                    pprust::pat_to_str(pat), id)).to_string()\n         }\n         Some(NodeLocal(pat)) => {\n             (format!(\"local {} (id={})\",\n-                    pprust::pat_to_str(pat), id)).to_strbuf()\n+                    pprust::pat_to_str(pat), id)).to_string()\n         }\n         Some(NodePat(pat)) => {\n-            (format!(\"pat {} (id={})\", pprust::pat_to_str(pat), id)).to_strbuf()\n+            (format!(\"pat {} (id={})\", pprust::pat_to_str(pat), id)).to_string()\n         }\n         Some(NodeBlock(block)) => {\n             (format!(\"block {} (id={})\",\n-                    pprust::block_to_str(block), id)).to_strbuf()\n+                    pprust::block_to_str(block), id)).to_string()\n         }\n         Some(NodeStructCtor(_)) => {\n             (format!(\"struct_ctor {} (id={})\",\n-                    map.path_to_str(id), id)).to_strbuf()\n+                    map.path_to_str(id), id)).to_string()\n         }\n         Some(NodeLifetime(ref l)) => {\n             (format!(\"lifetime {} (id={})\",\n-                    pprust::lifetime_to_str(*l), id)).to_strbuf()\n+                    pprust::lifetime_to_str(*l), id)).to_string()\n         }\n         None => {\n-            (format!(\"unknown node (id={})\", id)).to_strbuf()\n+            (format!(\"unknown node (id={})\", id)).to_string()\n         }\n     }\n }"}, {"sha": "3e41e58fbe21827e4a517d97960f7ccbb1151986", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -27,8 +27,8 @@ use std::u32;\n pub fn path_name_i(idents: &[Ident]) -> String {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n     idents.iter().map(|i| {\n-        token::get_ident(*i).get().to_strbuf()\n-    }).collect::<Vec<String>>().connect(\"::\").to_strbuf()\n+        token::get_ident(*i).get().to_string()\n+    }).collect::<Vec<String>>().connect(\"::\").to_string()\n }\n \n // totally scary function: ignores all but the last element, should have\n@@ -156,8 +156,8 @@ pub fn int_ty_to_str(t: IntTy, val: Option<i64>, mode: SuffixMode) -> String {\n         // cast to a u64 so we can correctly print INT64_MIN. All integral types\n         // are parsed as u64, so we wouldn't want to print an extra negative\n         // sign.\n-        Some(n) => format!(\"{}{}\", n as u64, s).to_strbuf(),\n-        None => s.to_strbuf()\n+        Some(n) => format!(\"{}{}\", n as u64, s).to_string(),\n+        None => s.to_string()\n     }\n }\n \n@@ -186,8 +186,8 @@ pub fn uint_ty_to_str(t: UintTy, val: Option<u64>, mode: SuffixMode) -> String {\n     };\n \n     match val {\n-        Some(n) => format!(\"{}{}\", n, s).to_strbuf(),\n-        None => s.to_strbuf()\n+        Some(n) => format!(\"{}{}\", n, s).to_string(),\n+        None => s.to_string()\n     }\n }\n \n@@ -202,9 +202,9 @@ pub fn uint_ty_max(t: UintTy) -> u64 {\n \n pub fn float_ty_to_str(t: FloatTy) -> String {\n     match t {\n-        TyF32 => \"f32\".to_strbuf(),\n-        TyF64 => \"f64\".to_strbuf(),\n-        TyF128 => \"f128\".to_strbuf(),\n+        TyF32 => \"f32\".to_string(),\n+        TyF64 => \"f64\".to_string(),\n+        TyF128 => \"f128\".to_string(),\n     }\n }\n "}, {"sha": "1ef7576335ba569035c7712c6b404d90843ecc52", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -276,8 +276,8 @@ impl FileMap {\n         let begin = begin.to_uint();\n         let slice = self.src.as_slice().slice_from(begin);\n         match slice.find('\\n') {\n-            Some(e) => slice.slice_to(e).to_strbuf(),\n-            None => slice.to_strbuf()\n+            Some(e) => slice.slice_to(e).to_string(),\n+            None => slice.to_string()\n         }\n     }\n \n@@ -333,7 +333,7 @@ impl CodeMap {\n \n         let filemap = Rc::new(FileMap {\n             name: filename,\n-            src: src.to_strbuf(),\n+            src: src.to_string(),\n             start_pos: Pos::from_uint(start_pos),\n             lines: RefCell::new(Vec::new()),\n             multibyte_chars: RefCell::new(Vec::new()),\n@@ -349,7 +349,7 @@ impl CodeMap {\n         (format!(\"<{}:{}:{}>\",\n                  pos.file.name,\n                  pos.line,\n-                 pos.col.to_uint() + 1)).to_strbuf()\n+                 pos.col.to_uint() + 1)).to_string()\n     }\n \n     /// Lookup source information about a BytePos\n@@ -360,7 +360,7 @@ impl CodeMap {\n     pub fn lookup_char_pos_adj(&self, pos: BytePos) -> LocWithOpt {\n         let loc = self.lookup_char_pos(pos);\n         LocWithOpt {\n-            filename: loc.file.name.to_strbuf(),\n+            filename: loc.file.name.to_string(),\n             line: loc.line,\n             col: loc.col,\n             file: Some(loc.file)\n@@ -369,7 +369,7 @@ impl CodeMap {\n \n     pub fn span_to_str(&self, sp: Span) -> String {\n         if self.files.borrow().len() == 0 && sp == DUMMY_SP {\n-            return \"no-location\".to_strbuf();\n+            return \"no-location\".to_string();\n         }\n \n         let lo = self.lookup_char_pos_adj(sp.lo);\n@@ -379,11 +379,11 @@ impl CodeMap {\n                         lo.line,\n                         lo.col.to_uint() + 1,\n                         hi.line,\n-                        hi.col.to_uint() + 1)).to_strbuf()\n+                        hi.col.to_uint() + 1)).to_string()\n     }\n \n     pub fn span_to_filename(&self, sp: Span) -> FileName {\n-        self.lookup_char_pos(sp.lo).file.name.to_strbuf()\n+        self.lookup_char_pos(sp.lo).file.name.to_string()\n     }\n \n     pub fn span_to_lines(&self, sp: Span) -> FileLines {\n@@ -408,7 +408,7 @@ impl CodeMap {\n             None\n         } else {\n             Some(begin.fm.src.as_slice().slice(begin.pos.to_uint(),\n-                                               end.pos.to_uint()).to_strbuf())\n+                                               end.pos.to_uint()).to_string())\n         }\n     }\n \n@@ -535,21 +535,21 @@ mod test {\n     #[test]\n     fn t1 () {\n         let cm = CodeMap::new();\n-        let fm = cm.new_filemap(\"blork.rs\".to_strbuf(),\n-                                \"first line.\\nsecond line\".to_strbuf());\n+        let fm = cm.new_filemap(\"blork.rs\".to_string(),\n+                                \"first line.\\nsecond line\".to_string());\n         fm.next_line(BytePos(0));\n-        assert_eq!(&fm.get_line(0),&\"first line.\".to_strbuf());\n+        assert_eq!(&fm.get_line(0),&\"first line.\".to_string());\n         // TESTING BROKEN BEHAVIOR:\n         fm.next_line(BytePos(10));\n-        assert_eq!(&fm.get_line(1), &\".\".to_strbuf());\n+        assert_eq!(&fm.get_line(1), &\".\".to_string());\n     }\n \n     #[test]\n     #[should_fail]\n     fn t2 () {\n         let cm = CodeMap::new();\n-        let fm = cm.new_filemap(\"blork.rs\".to_strbuf(),\n-                                \"first line.\\nsecond line\".to_strbuf());\n+        let fm = cm.new_filemap(\"blork.rs\".to_string(),\n+                                \"first line.\\nsecond line\".to_string());\n         // TESTING *REALLY* BROKEN BEHAVIOR:\n         fm.next_line(BytePos(0));\n         fm.next_line(BytePos(10));\n@@ -558,12 +558,12 @@ mod test {\n \n     fn init_code_map() -> CodeMap {\n         let cm = CodeMap::new();\n-        let fm1 = cm.new_filemap(\"blork.rs\".to_strbuf(),\n-                                 \"first line.\\nsecond line\".to_strbuf());\n-        let fm2 = cm.new_filemap(\"empty.rs\".to_strbuf(),\n-                                 \"\".to_strbuf());\n-        let fm3 = cm.new_filemap(\"blork2.rs\".to_strbuf(),\n-                                 \"first line.\\nsecond line\".to_strbuf());\n+        let fm1 = cm.new_filemap(\"blork.rs\".to_string(),\n+                                 \"first line.\\nsecond line\".to_string());\n+        let fm2 = cm.new_filemap(\"empty.rs\".to_string(),\n+                                 \"\".to_string());\n+        let fm3 = cm.new_filemap(\"blork2.rs\".to_string(),\n+                                 \"first line.\\nsecond line\".to_string());\n \n         fm1.next_line(BytePos(0));\n         fm1.next_line(BytePos(12));\n@@ -580,11 +580,11 @@ mod test {\n         let cm = init_code_map();\n \n         let fmabp1 = cm.lookup_byte_offset(BytePos(22));\n-        assert_eq!(fmabp1.fm.name, \"blork.rs\".to_strbuf());\n+        assert_eq!(fmabp1.fm.name, \"blork.rs\".to_string());\n         assert_eq!(fmabp1.pos, BytePos(22));\n \n         let fmabp2 = cm.lookup_byte_offset(BytePos(24));\n-        assert_eq!(fmabp2.fm.name, \"blork2.rs\".to_strbuf());\n+        assert_eq!(fmabp2.fm.name, \"blork2.rs\".to_string());\n         assert_eq!(fmabp2.pos, BytePos(0));\n     }\n \n@@ -606,12 +606,12 @@ mod test {\n         let cm = init_code_map();\n \n         let loc1 = cm.lookup_char_pos(BytePos(22));\n-        assert_eq!(loc1.file.name, \"blork.rs\".to_strbuf());\n+        assert_eq!(loc1.file.name, \"blork.rs\".to_string());\n         assert_eq!(loc1.line, 2);\n         assert_eq!(loc1.col, CharPos(10));\n \n         let loc2 = cm.lookup_char_pos(BytePos(24));\n-        assert_eq!(loc2.file.name, \"blork2.rs\".to_strbuf());\n+        assert_eq!(loc2.file.name, \"blork2.rs\".to_string());\n         assert_eq!(loc2.line, 1);\n         assert_eq!(loc2.col, CharPos(0));\n     }\n@@ -620,10 +620,10 @@ mod test {\n         let cm = CodeMap::new();\n         // \u20ac is a three byte utf8 char.\n         let fm1 =\n-            cm.new_filemap(\"blork.rs\".to_strbuf(),\n-                           \"fir\u20acst \u20ac\u20ac\u20ac\u20ac line.\\nsecond line\".to_strbuf());\n-        let fm2 = cm.new_filemap(\"blork2.rs\".to_strbuf(),\n-                                 \"first line\u20ac\u20ac.\\n\u20ac second line\".to_strbuf());\n+            cm.new_filemap(\"blork.rs\".to_string(),\n+                           \"fir\u20acst \u20ac\u20ac\u20ac\u20ac line.\\nsecond line\".to_string());\n+        let fm2 = cm.new_filemap(\"blork2.rs\".to_string(),\n+                                 \"first line\u20ac\u20ac.\\n\u20ac second line\".to_string());\n \n         fm1.next_line(BytePos(0));\n         fm1.next_line(BytePos(22));\n@@ -667,7 +667,7 @@ mod test {\n         let span = Span {lo: BytePos(12), hi: BytePos(23), expn_info: None};\n         let file_lines = cm.span_to_lines(span);\n \n-        assert_eq!(file_lines.file.name, \"blork.rs\".to_strbuf());\n+        assert_eq!(file_lines.file.name, \"blork.rs\".to_string());\n         assert_eq!(file_lines.lines.len(), 1);\n         assert_eq!(*file_lines.lines.get(0), 1u);\n     }\n@@ -679,7 +679,7 @@ mod test {\n         let span = Span {lo: BytePos(12), hi: BytePos(23), expn_info: None};\n         let snippet = cm.span_to_snippet(span);\n \n-        assert_eq!(snippet, Some(\"second line\".to_strbuf()));\n+        assert_eq!(snippet, Some(\"second line\".to_string()));\n     }\n \n     #[test]\n@@ -689,6 +689,6 @@ mod test {\n         let span = Span {lo: BytePos(12), hi: BytePos(23), expn_info: None};\n         let sstr =  cm.span_to_str(span);\n \n-        assert_eq!(sstr, \"blork.rs:2:1: 2:12\".to_strbuf());\n+        assert_eq!(sstr, \"blork.rs:2:1: 2:12\".to_string());\n     }\n }"}, {"sha": "329ddcad461e2359d3b49a3a9bfb24509845c835", "filename": "src/libsyntax/crateid.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fcrateid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fcrateid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcrateid.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -52,7 +52,7 @@ impl fmt::Show for CrateId {\n impl FromStr for CrateId {\n     fn from_str(s: &str) -> Option<CrateId> {\n         let pieces: Vec<&str> = s.splitn('#', 1).collect();\n-        let path = pieces.get(0).to_owned();\n+        let path = pieces.get(0).to_string();\n \n         if path.as_slice().starts_with(\"/\") || path.as_slice().ends_with(\"/\") ||\n             path.as_slice().starts_with(\".\") || path.is_empty() {\n@@ -65,7 +65,7 @@ impl FromStr for CrateId {\n         let inferred_name = *path_pieces.get(0);\n \n         let (name, version) = if pieces.len() == 1 {\n-            (inferred_name.to_strbuf(), None)\n+            (inferred_name.to_string(), None)\n         } else {\n             let hash_pieces: Vec<&str> = pieces.get(1)\n                                                .splitn(':', 1)\n@@ -77,16 +77,16 @@ impl FromStr for CrateId {\n             };\n \n             let name = if !hash_name.is_empty() {\n-                hash_name.to_strbuf()\n+                hash_name.to_string()\n             } else {\n-                inferred_name.to_strbuf()\n+                inferred_name.to_string()\n             };\n \n             let version = if !hash_version.is_empty() {\n                 if hash_version == \"0.0\" {\n                     None\n                 } else {\n-                    Some(hash_version.to_strbuf())\n+                    Some(hash_version.to_string())\n                 }\n             } else {\n                 None\n@@ -96,7 +96,7 @@ impl FromStr for CrateId {\n         };\n \n         Some(CrateId {\n-            path: path.to_strbuf(),\n+            path: path.to_string(),\n             name: name,\n             version: version,\n         })\n@@ -112,7 +112,7 @@ impl CrateId {\n     }\n \n     pub fn short_name_with_version(&self) -> String {\n-        (format!(\"{}-{}\", self.name, self.version_or_default())).to_strbuf()\n+        (format!(\"{}-{}\", self.name, self.version_or_default())).to_string()\n     }\n \n     pub fn matches(&self, other: &CrateId) -> bool {\n@@ -128,17 +128,17 @@ impl CrateId {\n #[test]\n fn bare_name() {\n     let crateid: CrateId = from_str(\"foo\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"foo\".to_strbuf());\n+    assert_eq!(crateid.name, \"foo\".to_string());\n     assert_eq!(crateid.version, None);\n-    assert_eq!(crateid.path, \"foo\".to_strbuf());\n+    assert_eq!(crateid.path, \"foo\".to_string());\n }\n \n #[test]\n fn bare_name_single_char() {\n     let crateid: CrateId = from_str(\"f\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"f\".to_strbuf());\n+    assert_eq!(crateid.name, \"f\".to_string());\n     assert_eq!(crateid.version, None);\n-    assert_eq!(crateid.path, \"f\".to_strbuf());\n+    assert_eq!(crateid.path, \"f\".to_string());\n }\n \n #[test]\n@@ -150,17 +150,17 @@ fn empty_crateid() {\n #[test]\n fn simple_path() {\n     let crateid: CrateId = from_str(\"example.com/foo/bar\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"bar\".to_strbuf());\n+    assert_eq!(crateid.name, \"bar\".to_string());\n     assert_eq!(crateid.version, None);\n-    assert_eq!(crateid.path, \"example.com/foo/bar\".to_strbuf());\n+    assert_eq!(crateid.path, \"example.com/foo/bar\".to_string());\n }\n \n #[test]\n fn simple_version() {\n     let crateid: CrateId = from_str(\"foo#1.0\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"foo\".to_strbuf());\n-    assert_eq!(crateid.version, Some(\"1.0\".to_strbuf()));\n-    assert_eq!(crateid.path, \"foo\".to_strbuf());\n+    assert_eq!(crateid.name, \"foo\".to_string());\n+    assert_eq!(crateid.version, Some(\"1.0\".to_string()));\n+    assert_eq!(crateid.path, \"foo\".to_string());\n }\n \n #[test]\n@@ -178,39 +178,39 @@ fn path_ends_with_slash() {\n #[test]\n fn path_and_version() {\n     let crateid: CrateId = from_str(\"example.com/foo/bar#1.0\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"bar\".to_strbuf());\n-    assert_eq!(crateid.version, Some(\"1.0\".to_strbuf()));\n-    assert_eq!(crateid.path, \"example.com/foo/bar\".to_strbuf());\n+    assert_eq!(crateid.name, \"bar\".to_string());\n+    assert_eq!(crateid.version, Some(\"1.0\".to_string()));\n+    assert_eq!(crateid.path, \"example.com/foo/bar\".to_string());\n }\n \n #[test]\n fn single_chars() {\n     let crateid: CrateId = from_str(\"a/b#1\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"b\".to_strbuf());\n-    assert_eq!(crateid.version, Some(\"1\".to_strbuf()));\n-    assert_eq!(crateid.path, \"a/b\".to_strbuf());\n+    assert_eq!(crateid.name, \"b\".to_string());\n+    assert_eq!(crateid.version, Some(\"1\".to_string()));\n+    assert_eq!(crateid.path, \"a/b\".to_string());\n }\n \n #[test]\n fn missing_version() {\n     let crateid: CrateId = from_str(\"foo#\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"foo\".to_strbuf());\n+    assert_eq!(crateid.name, \"foo\".to_string());\n     assert_eq!(crateid.version, None);\n-    assert_eq!(crateid.path, \"foo\".to_strbuf());\n+    assert_eq!(crateid.path, \"foo\".to_string());\n }\n \n #[test]\n fn path_and_name() {\n     let crateid: CrateId = from_str(\"foo/rust-bar#bar:1.0\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"bar\".to_strbuf());\n-    assert_eq!(crateid.version, Some(\"1.0\".to_strbuf()));\n-    assert_eq!(crateid.path, \"foo/rust-bar\".to_strbuf());\n+    assert_eq!(crateid.name, \"bar\".to_string());\n+    assert_eq!(crateid.version, Some(\"1.0\".to_string()));\n+    assert_eq!(crateid.path, \"foo/rust-bar\".to_string());\n }\n \n #[test]\n fn empty_name() {\n     let crateid: CrateId = from_str(\"foo/bar#:1.0\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"bar\".to_strbuf());\n-    assert_eq!(crateid.version, Some(\"1.0\".to_strbuf()));\n-    assert_eq!(crateid.path, \"foo/bar\".to_strbuf());\n+    assert_eq!(crateid.name, \"bar\".to_string());\n+    assert_eq!(crateid.version, Some(\"1.0\".to_string()));\n+    assert_eq!(crateid.path, \"foo/bar\".to_string());\n }"}, {"sha": "49da91e10533deb11aad26dc779aef384a72d0a6", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -143,7 +143,7 @@ impl Handler {\n         let s;\n         match self.err_count.get() {\n           0u => return,\n-          1u => s = \"aborting due to previous error\".to_strbuf(),\n+          1u => s = \"aborting due to previous error\".to_string(),\n           _  => {\n             s = format!(\"aborting due to {} previous errors\",\n                         self.err_count.get());\n@@ -492,7 +492,7 @@ fn print_macro_backtrace(w: &mut EmitterWriter,\n         let ss = ei.callee\n                    .span\n                    .as_ref()\n-                   .map_or(\"\".to_strbuf(), |span| cm.span_to_str(*span));\n+                   .map_or(\"\".to_string(), |span| cm.span_to_str(*span));\n         let (pre, post) = match ei.callee.format {\n             codemap::MacroAttribute => (\"#[\", \"]\"),\n             codemap::MacroBang => (\"\", \"!\")"}, {"sha": "06916d5ac098aef90ba903b2ba2fa29e6a832304", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -57,7 +57,7 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     let mut asm_str_style = None;\n     let mut outputs = Vec::new();\n     let mut inputs = Vec::new();\n-    let mut cons = \"\".to_owned();\n+    let mut cons = \"\".to_string();\n     let mut volatile = false;\n     let mut alignstack = false;\n     let mut dialect = ast::AsmAtt;"}, {"sha": "26c1945db885e4edeb705841fc752a5843daeb6f", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -550,7 +550,7 @@ pub fn get_single_str_from_tts(cx: &ExtCtxt,\n         match tts[0] {\n             ast::TTTok(_, token::LIT_STR(ident))\n             | ast::TTTok(_, token::LIT_STR_RAW(ident, _)) => {\n-                return Some(token::get_ident(ident).get().to_strbuf())\n+                return Some(token::get_ident(ident).get().to_string())\n             }\n             _ => {\n                 cx.span_err(sp,"}, {"sha": "d6b7e84b5355d64cd6a570535e76c73a50144482", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -36,7 +36,7 @@ impl<D:Decoder> Decodable for node_id {\n     fn decode(d: &D) -> Node {\n         d.read_struct(\"Node\", 1, || {\n             Node {\n-                id: d.read_field(\"x\".to_owned(), 0, || decode(d))\n+                id: d.read_field(\"x\".to_string(), 0, || decode(d))\n             }\n         })\n     }\n@@ -73,8 +73,8 @@ would yield functions like:\n         fn decode(d: &D) -> spanned<T> {\n             d.read_rec(|| {\n                 {\n-                    node: d.read_field(\"node\".to_owned(), 0, || decode(d)),\n-                    span: d.read_field(\"span\".to_owned(), 1, || decode(d)),\n+                    node: d.read_field(\"node\".to_string(), 0, || decode(d)),\n+                    span: d.read_field(\"span\".to_string(), 1, || decode(d)),\n                 }\n             })\n         }"}, {"sha": "0f4af144eadea1c7c4e694db8fe25e26b39e451b", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -882,7 +882,7 @@ impl<'a> MethodDef<'a> {\n \n         } else {  // there are still matches to create\n             let current_match_str = if match_count == 0 {\n-                \"__self\".to_strbuf()\n+                \"__self\".to_string()\n             } else {\n                 format!(\"__arg_{}\", match_count)\n             };\n@@ -1011,7 +1011,7 @@ impl<'a> TraitDef<'a> {\n         to_set.expn_info = Some(@codemap::ExpnInfo {\n             call_site: to_set,\n             callee: codemap::NameAndSpan {\n-                name: format!(\"deriving({})\", trait_name).to_strbuf(),\n+                name: format!(\"deriving({})\", trait_name).to_string(),\n                 format: codemap::MacroAttribute,\n                 span: Some(self.span)\n             }"}, {"sha": "0c885c32b76c77b3ba7459d89db0022c9773bc5a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -70,7 +70,7 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n                             fld.cx.bt_push(ExpnInfo {\n                                 call_site: e.span,\n                                 callee: NameAndSpan {\n-                                    name: extnamestr.get().to_strbuf(),\n+                                    name: extnamestr.get().to_string(),\n                                     format: MacroBang,\n                                     span: exp_span,\n                                 },\n@@ -298,7 +298,7 @@ pub fn expand_item(it: @ast::Item, fld: &mut MacroExpander)\n                 fld.cx.bt_push(ExpnInfo {\n                     call_site: attr.span,\n                     callee: NameAndSpan {\n-                        name: mname.get().to_strbuf(),\n+                        name: mname.get().to_string(),\n                         format: MacroAttribute,\n                         span: None\n                     }\n@@ -370,7 +370,7 @@ fn expand_item_modifiers(mut it: @ast::Item, fld: &mut MacroExpander)\n                 fld.cx.bt_push(ExpnInfo {\n                     call_site: attr.span,\n                     callee: NameAndSpan {\n-                        name: mname.get().to_strbuf(),\n+                        name: mname.get().to_string(),\n                         format: MacroAttribute,\n                         span: None,\n                     }\n@@ -430,7 +430,7 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n             fld.cx.bt_push(ExpnInfo {\n                 call_site: it.span,\n                 callee: NameAndSpan {\n-                    name: extnamestr.get().to_strbuf(),\n+                    name: extnamestr.get().to_string(),\n                     format: MacroBang,\n                     span: span\n                 }\n@@ -449,7 +449,7 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n             fld.cx.bt_push(ExpnInfo {\n                 call_site: it.span,\n                 callee: NameAndSpan {\n-                    name: extnamestr.get().to_strbuf(),\n+                    name: extnamestr.get().to_string(),\n                     format: MacroBang,\n                     span: span\n                 }\n@@ -530,7 +530,7 @@ fn load_extern_macros(krate: &ast::ViewItem, fld: &mut MacroExpander) {\n         _ => unreachable!()\n     };\n     let name = format!(\"<{} macros>\", token::get_ident(crate_name));\n-    let name = name.to_strbuf();\n+    let name = name.to_string();\n \n     for source in macros.iter() {\n         let item = parse::parse_item_from_source_str(name.clone(),\n@@ -620,7 +620,7 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n             fld.cx.bt_push(ExpnInfo {\n                 call_site: s.span,\n                 callee: NameAndSpan {\n-                    name: extnamestr.get().to_strbuf(),\n+                    name: extnamestr.get().to_string(),\n                     format: MacroBang,\n                     span: exp_span,\n                 }\n@@ -1067,10 +1067,10 @@ mod test {\n     #[should_fail]\n     #[test] fn macros_cant_escape_fns_test () {\n         let src = \"fn bogus() {macro_rules! z (() => (3+4))}\\\n-                   fn inty() -> int { z!() }\".to_strbuf();\n+                   fn inty() -> int { z!() }\".to_string();\n         let sess = parse::new_parse_sess();\n         let crate_ast = parse::parse_crate_from_source_str(\n-            \"<test>\".to_strbuf(),\n+            \"<test>\".to_string(),\n             src,\n             Vec::new(), &sess);\n         // should fail:\n@@ -1087,10 +1087,10 @@ mod test {\n     #[should_fail]\n     #[test] fn macros_cant_escape_mods_test () {\n         let src = \"mod foo {macro_rules! z (() => (3+4))}\\\n-                   fn inty() -> int { z!() }\".to_strbuf();\n+                   fn inty() -> int { z!() }\".to_string();\n         let sess = parse::new_parse_sess();\n         let crate_ast = parse::parse_crate_from_source_str(\n-            \"<test>\".to_strbuf(),\n+            \"<test>\".to_string(),\n             src,\n             Vec::new(), &sess);\n         // should fail:\n@@ -1106,10 +1106,10 @@ mod test {\n     // macro_escape modules shouldn't cause macros to leave scope\n     #[test] fn macros_can_escape_flattened_mods_test () {\n         let src = \"#[macro_escape] mod foo {macro_rules! z (() => (3+4))}\\\n-                   fn inty() -> int { z!() }\".to_strbuf();\n+                   fn inty() -> int { z!() }\".to_string();\n         let sess = parse::new_parse_sess();\n         let crate_ast = parse::parse_crate_from_source_str(\n-            \"<test>\".to_strbuf(),\n+            \"<test>\".to_string(),\n             src,\n             Vec::new(), &sess);\n         // should fail:\n@@ -1173,7 +1173,7 @@ mod test {\n \n     #[test] fn macro_tokens_should_match(){\n         expand_crate_str(\n-            \"macro_rules! m((a)=>(13)) fn main(){m!(a);}\".to_strbuf());\n+            \"macro_rules! m((a)=>(13)) fn main(){m!(a);}\".to_string());\n     }\n \n     // renaming tests expand a crate and then check that the bindings match\n@@ -1231,7 +1231,7 @@ mod test {\n         let (teststr, bound_connections, bound_ident_check) = match *t {\n             (ref str,ref conns, bic) => (str.to_owned(), conns.clone(), bic)\n         };\n-        let cr = expand_crate_str(teststr.to_strbuf());\n+        let cr = expand_crate_str(teststr.to_string());\n         // find the bindings:\n         let mut name_finder = new_name_finder(Vec::new());\n         visit::walk_crate(&mut name_finder,&cr,());\n@@ -1306,7 +1306,7 @@ mod test {\n         let crate_str = \"macro_rules! fmt_wrap(($b:expr)=>($b.to_str()))\n macro_rules! foo_module (() => (mod generated { fn a() { let xx = 147; fmt_wrap!(xx);}}))\n foo_module!()\n-\".to_strbuf();\n+\".to_string();\n         let cr = expand_crate_str(crate_str);\n         // find the xx binding\n         let mut name_finder = new_name_finder(Vec::new());\n@@ -1353,7 +1353,7 @@ foo_module!()\n     #[test]\n     fn pat_idents(){\n         let pat = string_to_pat(\n-            \"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\".to_strbuf());\n+            \"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\".to_string());\n         let mut pat_idents = new_name_finder(Vec::new());\n         pat_idents.visit_pat(pat, ());\n         assert_eq!(pat_idents.ident_accumulator,"}, {"sha": "86652cd50b0dc6f8343660287a99d040e609d313", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -148,8 +148,8 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, allow_method: bool,\n                     continue\n                 }\n             }\n-            order.push(name.to_strbuf());\n-            names.insert(name.to_strbuf(), e);\n+            order.push(name.to_string());\n+            names.insert(name.to_string(), e);\n         } else {\n             args.push(p.parse_expr());\n         }\n@@ -188,13 +188,13 @@ impl<'a, 'b> Context<'a, 'b> {\n                         Exact(i)\n                     }\n                     parse::ArgumentIs(i) => Exact(i),\n-                    parse::ArgumentNamed(s) => Named(s.to_strbuf()),\n+                    parse::ArgumentNamed(s) => Named(s.to_string()),\n                 };\n \n                 // and finally the method being applied\n                 match arg.method {\n                     None => {\n-                        let ty = Known(arg.format.ty.to_strbuf());\n+                        let ty = Known(arg.format.ty.to_string());\n                         self.verify_arg_type(pos, ty);\n                     }\n                     Some(ref method) => { self.verify_method(pos, *method); }\n@@ -216,7 +216,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 self.verify_arg_type(Exact(i), Unsigned);\n             }\n             parse::CountIsName(s) => {\n-                self.verify_arg_type(Named(s.to_strbuf()), Unsigned);\n+                self.verify_arg_type(Named(s.to_string()), Unsigned);\n             }\n             parse::CountIsNextParam => {\n                 if self.check_positional_ok() {"}, {"sha": "62e052b0bb91c78a09b69654add52bd4586da4a1", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -72,7 +72,7 @@ pub mod rt {\n \n     impl ToSource for ast::Ident {\n         fn to_source(&self) -> String {\n-            get_ident(*self).get().to_strbuf()\n+            get_ident(*self).get().to_string()\n         }\n     }\n \n@@ -88,7 +88,7 @@ pub mod rt {\n                 .map(|i| i.to_source())\n                 .collect::<Vec<String>>()\n                 .connect(\"\\n\\n\")\n-                .to_strbuf()\n+                .to_string()\n         }\n     }\n \n@@ -104,7 +104,7 @@ pub mod rt {\n                 .map(|i| i.to_source())\n                 .collect::<Vec<String>>()\n                 .connect(\", \")\n-                .to_strbuf()\n+                .to_string()\n         }\n     }\n \n@@ -136,7 +136,7 @@ pub mod rt {\n \n     impl ToSource for () {\n         fn to_source(&self) -> String {\n-            \"()\".to_strbuf()\n+            \"()\".to_string()\n         }\n     }\n \n@@ -281,7 +281,7 @@ pub mod rt {\n \n         fn parse_item(&self, s: String) -> @ast::Item {\n             let res = parse::parse_item_from_source_str(\n-                \"<quote expansion>\".to_strbuf(),\n+                \"<quote expansion>\".to_string(),\n                 s,\n                 self.cfg(),\n                 self.parse_sess());\n@@ -295,22 +295,22 @@ pub mod rt {\n         }\n \n         fn parse_stmt(&self, s: String) -> @ast::Stmt {\n-            parse::parse_stmt_from_source_str(\"<quote expansion>\".to_strbuf(),\n+            parse::parse_stmt_from_source_str(\"<quote expansion>\".to_string(),\n                                               s,\n                                               self.cfg(),\n                                               Vec::new(),\n                                               self.parse_sess())\n         }\n \n         fn parse_expr(&self, s: String) -> @ast::Expr {\n-            parse::parse_expr_from_source_str(\"<quote expansion>\".to_strbuf(),\n+            parse::parse_expr_from_source_str(\"<quote expansion>\".to_string(),\n                                               s,\n                                               self.cfg(),\n                                               self.parse_sess())\n         }\n \n         fn parse_tts(&self, s: String) -> Vec<ast::TokenTree> {\n-            parse::parse_tts_from_source_str(\"<quote expansion>\".to_strbuf(),\n+            parse::parse_tts_from_source_str(\"<quote expansion>\".to_string(),\n                                              s,\n                                              self.cfg(),\n                                              self.parse_sess())\n@@ -430,11 +430,11 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n \n         LIT_INT(i, ity) => {\n             let s_ity = match ity {\n-                ast::TyI => \"TyI\".to_owned(),\n-                ast::TyI8 => \"TyI8\".to_owned(),\n-                ast::TyI16 => \"TyI16\".to_owned(),\n-                ast::TyI32 => \"TyI32\".to_owned(),\n-                ast::TyI64 => \"TyI64\".to_owned()\n+                ast::TyI => \"TyI\".to_string(),\n+                ast::TyI8 => \"TyI8\".to_string(),\n+                ast::TyI16 => \"TyI16\".to_string(),\n+                ast::TyI32 => \"TyI32\".to_string(),\n+                ast::TyI64 => \"TyI64\".to_string()\n             };\n             let e_ity = cx.expr_ident(sp, id_ext(s_ity.as_slice()));\n \n@@ -447,11 +447,11 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n \n         LIT_UINT(u, uty) => {\n             let s_uty = match uty {\n-                ast::TyU => \"TyU\".to_owned(),\n-                ast::TyU8 => \"TyU8\".to_owned(),\n-                ast::TyU16 => \"TyU16\".to_owned(),\n-                ast::TyU32 => \"TyU32\".to_owned(),\n-                ast::TyU64 => \"TyU64\".to_owned()\n+                ast::TyU => \"TyU\".to_string(),\n+                ast::TyU8 => \"TyU8\".to_string(),\n+                ast::TyU16 => \"TyU16\".to_string(),\n+                ast::TyU32 => \"TyU32\".to_string(),\n+                ast::TyU64 => \"TyU64\".to_string()\n             };\n             let e_uty = cx.expr_ident(sp, id_ext(s_uty.as_slice()));\n \n@@ -472,9 +472,9 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n \n         LIT_FLOAT(fident, fty) => {\n             let s_fty = match fty {\n-                ast::TyF32 => \"TyF32\".to_owned(),\n-                ast::TyF64 => \"TyF64\".to_owned(),\n-                ast::TyF128 => \"TyF128\".to_owned()\n+                ast::TyF32 => \"TyF32\".to_string(),\n+                ast::TyF64 => \"TyF64\".to_string(),\n+                ast::TyF128 => \"TyF128\".to_string()\n             };\n             let e_fty = cx.expr_ident(sp, id_ext(s_fty.as_slice()));\n \n@@ -686,10 +686,10 @@ fn expand_wrapper(cx: &ExtCtxt,\n                   cx_expr: @ast::Expr,\n                   expr: @ast::Expr) -> @ast::Expr {\n     let uses = vec![ cx.view_use_glob(sp, ast::Inherited,\n-                                   ids_ext(vec![\"syntax\".to_strbuf(),\n-                                                \"ext\".to_strbuf(),\n-                                                \"quote\".to_strbuf(),\n-                                                \"rt\".to_strbuf()])) ];\n+                                   ids_ext(vec![\"syntax\".to_string(),\n+                                                \"ext\".to_string(),\n+                                                \"quote\".to_string(),\n+                                                \"rt\".to_string()])) ];\n \n     let stmt_let_ext_cx = cx.stmt_let(sp, false, id_ext(\"ext_cx\"), cx_expr);\n "}, {"sha": "d2e689b5934f050881fd1462a5f0027ed6d71b5a", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -73,7 +73,7 @@ pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     let string = cx.mod_path()\n                    .iter()\n-                   .map(|x| token::get_ident(*x).get().to_strbuf())\n+                   .map(|x| token::get_ident(*x).get().to_string())\n                    .collect::<Vec<String>>()\n                    .connect(\"::\");\n     base::MacExpr::new(cx.expr_str(\n@@ -125,9 +125,9 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         Some(src) => {\n             // Add this input file to the code map to make it available as\n             // dependency information\n-            let filename = file.display().to_str().to_strbuf();\n+            let filename = file.display().to_str().to_string();\n             let interned = token::intern_and_get_ident(src);\n-            cx.codemap().new_filemap(filename, src.to_strbuf());\n+            cx.codemap().new_filemap(filename, src.to_string());\n \n             base::MacExpr::new(cx.expr_str(sp, interned))\n         }"}, {"sha": "a92802aa3389e9cc50a1dfbb85ec5519a5a6b55c", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -372,9 +372,9 @@ pub fn parse(sess: &ParseSess,\n                 }\n                 return Success(nameize(sess, ms, v.as_slice()));\n             } else if eof_eis.len() > 1u {\n-                return Error(sp, \"ambiguity: multiple successful parses\".to_strbuf());\n+                return Error(sp, \"ambiguity: multiple successful parses\".to_string());\n             } else {\n-                return Failure(sp, \"unexpected end of macro invocation\".to_strbuf());\n+                return Failure(sp, \"unexpected end of macro invocation\".to_string());\n             }\n         } else {\n             if (bb_eis.len() > 0u && next_eis.len() > 0u)\n@@ -384,17 +384,17 @@ pub fn parse(sess: &ParseSess,\n                       MatchNonterminal(bind, name, _) => {\n                         (format!(\"{} ('{}')\",\n                                 token::get_ident(name),\n-                                token::get_ident(bind))).to_strbuf()\n+                                token::get_ident(bind))).to_string()\n                       }\n                       _ => fail!()\n                     } }).collect::<Vec<String>>().connect(\" or \");\n                 return Error(sp, format!(\n                     \"local ambiguity: multiple parsing options: \\\n                      built-in NTs {} or {} other options.\",\n-                    nts, next_eis.len()).to_strbuf());\n+                    nts, next_eis.len()).to_string());\n             } else if bb_eis.len() == 0u && next_eis.len() == 0u {\n                 return Failure(sp, format!(\"no rules expected the token `{}`\",\n-                            token::to_str(&tok)).to_strbuf());\n+                            token::to_str(&tok)).to_string());\n             } else if next_eis.len() > 0u {\n                 /* Now process the next token */\n                 while next_eis.len() > 0u {"}, {"sha": "1bc0c7f7959d0ffca112285225eee8ab543b5ac4", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -132,7 +132,7 @@ fn generic_extension(cx: &ExtCtxt,\n \n     // Which arm's failure should we report? (the one furthest along)\n     let mut best_fail_spot = DUMMY_SP;\n-    let mut best_fail_msg = \"internal error: ran no matchers\".to_strbuf();\n+    let mut best_fail_msg = \"internal error: ran no matchers\".to_string();\n \n     for (i, lhs) in lhses.iter().enumerate() { // try each arm's matchers\n         match **lhs {\n@@ -247,7 +247,7 @@ pub fn add_new_extension(cx: &mut ExtCtxt,\n \n     box MacroRulesDefiner {\n         def: RefCell::new(Some(MacroDef {\n-            name: token::get_ident(name).to_str().to_strbuf(),\n+            name: token::get_ident(name).to_str().to_string(),\n             ext: NormalTT(exp, Some(sp))\n         }))\n     } as Box<MacResult>"}, {"sha": "4b0e2171062f604b570168f3c169fb876cdd60d3", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -117,7 +117,7 @@ fn lis_merge(lhs: LockstepIterSize, rhs: LockstepIterSize) -> LockstepIterSize {\n                 let r_n = token::get_ident(r_id);\n                 LisContradiction(format!(\"inconsistent lockstep iteration: \\\n                                           '{}' has {} items, but '{}' has {}\",\n-                                          l_n, l_len, r_n, r_len).to_strbuf())\n+                                          l_n, l_len, r_n, r_len).to_string())\n             }\n         }\n     }"}, {"sha": "1607820326bb55cfe0e594f7f9df7cda788ebca5", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -964,26 +964,26 @@ mod test {\n     #[test] fn ident_transformation () {\n         let mut zz_fold = ToZzIdentFolder;\n         let ast = string_to_crate(\n-            \"#[a] mod b {fn c (d : e, f : g) {h!(i,j,k);l;m}}\".to_strbuf());\n+            \"#[a] mod b {fn c (d : e, f : g) {h!(i,j,k);l;m}}\".to_string());\n         let folded_crate = zz_fold.fold_crate(ast);\n         assert_pred!(\n             matches_codepattern,\n             \"matches_codepattern\",\n             pprust::to_str(|s| fake_print_crate(s, &folded_crate)),\n-            \"#[a]mod zz{fn zz(zz:zz,zz:zz){zz!(zz,zz,zz);zz;zz}}\".to_strbuf());\n+            \"#[a]mod zz{fn zz(zz:zz,zz:zz){zz!(zz,zz,zz);zz;zz}}\".to_string());\n     }\n \n     // even inside macro defs....\n     #[test] fn ident_transformation_in_defs () {\n         let mut zz_fold = ToZzIdentFolder;\n         let ast = string_to_crate(\n             \"macro_rules! a {(b $c:expr $(d $e:token)f+ => \\\n-             (g $(d $d $e)+))} \".to_strbuf());\n+             (g $(d $d $e)+))} \".to_string());\n         let folded_crate = zz_fold.fold_crate(ast);\n         assert_pred!(\n             matches_codepattern,\n             \"matches_codepattern\",\n             pprust::to_str(|s| fake_print_crate(s, &folded_crate)),\n-            \"zz!zz((zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+)))\".to_strbuf());\n+            \"zz!zz((zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+)))\".to_string());\n     }\n }"}, {"sha": "cc08cb429f55f52139f9e6828ae4ee730d27984a", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -111,7 +111,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n \n         if can_trim {\n             lines.iter().map(|line| {\n-                line.as_slice().slice(i + 1, line.len()).to_strbuf()\n+                line.as_slice().slice(i + 1, line.len()).to_string()\n             }).collect()\n         } else {\n             lines\n@@ -122,20 +122,20 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n     static ONLINERS: &'static [&'static str] = &[\"///!\", \"///\", \"//!\", \"//\"];\n     for prefix in ONLINERS.iter() {\n         if comment.starts_with(*prefix) {\n-            return comment.slice_from(prefix.len()).to_strbuf();\n+            return comment.slice_from(prefix.len()).to_string();\n         }\n     }\n \n     if comment.starts_with(\"/*\") {\n         let lines = comment.slice(3u, comment.len() - 2u)\n             .lines_any()\n-            .map(|s| s.to_strbuf())\n+            .map(|s| s.to_string())\n             .collect::<Vec<String> >();\n \n         let lines = vertical_trim(lines);\n         let lines = horizontal_trim(lines);\n \n-        return lines.connect(\"\\n\").to_strbuf();\n+        return lines.connect(\"\\n\").to_string();\n     }\n \n     fail!(\"not a doc-comment: {}\", comment);\n@@ -247,9 +247,9 @@ fn trim_whitespace_prefix_and_push_line(lines: &mut Vec<String> ,\n     let s1 = match all_whitespace(s.as_slice(), col) {\n         Some(col) => {\n             if col < len {\n-                s.as_slice().slice(col, len).to_strbuf()\n+                s.as_slice().slice(col, len).to_string()\n             } else {\n-                \"\".to_strbuf()\n+                \"\".to_string()\n             }\n         }\n         None => s,\n@@ -368,7 +368,7 @@ pub fn gather_comments_and_literals(span_diagnostic:\n                                     srdr: &mut io::Reader)\n                                  -> (Vec<Comment>, Vec<Literal>) {\n     let src = srdr.read_to_end().unwrap();\n-    let src = str::from_utf8(src.as_slice()).unwrap().to_strbuf();\n+    let src = str::from_utf8(src.as_slice()).unwrap().to_string();\n     let cm = CodeMap::new();\n     let filemap = cm.new_filemap(path, src);\n     let mut rdr = lexer::new_low_level_string_reader(span_diagnostic, filemap);\n@@ -399,7 +399,7 @@ pub fn gather_comments_and_literals(span_diagnostic:\n         if token::is_lit(&tok) {\n             with_str_from(&rdr, bstart, |s| {\n                 debug!(\"tok lit: {}\", s);\n-                literals.push(Literal {lit: s.to_strbuf(), pos: sp.lo});\n+                literals.push(Literal {lit: s.to_string(), pos: sp.lo});\n             })\n         } else {\n             debug!(\"tok: {}\", token::to_str(&tok));\n@@ -417,41 +417,41 @@ mod test {\n     #[test] fn test_block_doc_comment_1() {\n         let comment = \"/**\\n * Test \\n **  Test\\n *   Test\\n*/\";\n         let stripped = strip_doc_comment_decoration(comment);\n-        assert_eq!(stripped, \" Test \\n*  Test\\n   Test\".to_strbuf());\n+        assert_eq!(stripped, \" Test \\n*  Test\\n   Test\".to_string());\n     }\n \n     #[test] fn test_block_doc_comment_2() {\n         let comment = \"/**\\n * Test\\n *  Test\\n*/\";\n         let stripped = strip_doc_comment_decoration(comment);\n-        assert_eq!(stripped, \" Test\\n  Test\".to_strbuf());\n+        assert_eq!(stripped, \" Test\\n  Test\".to_string());\n     }\n \n     #[test] fn test_block_doc_comment_3() {\n         let comment = \"/**\\n let a: *int;\\n *a = 5;\\n*/\";\n         let stripped = strip_doc_comment_decoration(comment);\n-        assert_eq!(stripped, \" let a: *int;\\n *a = 5;\".to_strbuf());\n+        assert_eq!(stripped, \" let a: *int;\\n *a = 5;\".to_string());\n     }\n \n     #[test] fn test_block_doc_comment_4() {\n         let comment = \"/*******************\\n test\\n *********************/\";\n         let stripped = strip_doc_comment_decoration(comment);\n-        assert_eq!(stripped, \" test\".to_strbuf());\n+        assert_eq!(stripped, \" test\".to_string());\n     }\n \n     #[test] fn test_line_doc_comment() {\n         let stripped = strip_doc_comment_decoration(\"/// test\");\n-        assert_eq!(stripped, \" test\".to_strbuf());\n+        assert_eq!(stripped, \" test\".to_string());\n         let stripped = strip_doc_comment_decoration(\"///! test\");\n-        assert_eq!(stripped, \" test\".to_strbuf());\n+        assert_eq!(stripped, \" test\".to_string());\n         let stripped = strip_doc_comment_decoration(\"// test\");\n-        assert_eq!(stripped, \" test\".to_strbuf());\n+        assert_eq!(stripped, \" test\".to_string());\n         let stripped = strip_doc_comment_decoration(\"// test\");\n-        assert_eq!(stripped, \" test\".to_strbuf());\n+        assert_eq!(stripped, \" test\".to_string());\n         let stripped = strip_doc_comment_decoration(\"///test\");\n-        assert_eq!(stripped, \"test\".to_strbuf());\n+        assert_eq!(stripped, \"test\".to_string());\n         let stripped = strip_doc_comment_decoration(\"///!test\");\n-        assert_eq!(stripped, \"test\".to_strbuf());\n+        assert_eq!(stripped, \"test\".to_string());\n         let stripped = strip_doc_comment_decoration(\"//test\");\n-        assert_eq!(stripped, \"test\".to_strbuf());\n+        assert_eq!(stripped, \"test\".to_string());\n     }\n }"}, {"sha": "fb67a76b85b4ca57e449f2023212b3692d91de14", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -156,14 +156,14 @@ fn err_span(rdr: &mut StringReader, from_pos: BytePos, to_pos: BytePos, m: &str)\n fn fatal_span_char(rdr: &mut StringReader,\n                    from_pos: BytePos, to_pos: BytePos,\n                    m: &str, c: char) -> ! {\n-    let mut m = m.to_strbuf();\n+    let mut m = m.to_string();\n     m.push_str(\": \");\n     char::escape_default(c, |c| m.push_char(c));\n     fatal_span(rdr, from_pos, to_pos, m.as_slice());\n }\n \n fn err_span_char(rdr: &mut StringReader, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) {\n-    let mut m = m.to_strbuf();\n+    let mut m = m.to_string();\n     m.push_str(\": \");\n     char::escape_default(c, |c| m.push_char(c));\n     err_span(rdr, from_pos, to_pos, m.as_slice());\n@@ -172,7 +172,7 @@ fn err_span_char(rdr: &mut StringReader, from_pos: BytePos, to_pos: BytePos, m:\n // report a lexical error spanning [`from_pos`, `to_pos`), appending the\n // offending string to the error message\n fn fatal_span_verbose(rdr: &mut StringReader, from_pos: BytePos, to_pos: BytePos, m: &str) -> ! {\n-    let mut m = m.to_strbuf();\n+    let mut m = m.to_string();\n     m.push_str(\": \");\n     let from = byte_offset(rdr, from_pos).to_uint();\n     let to = byte_offset(rdr, to_pos).to_uint();\n@@ -528,7 +528,7 @@ fn scan_number(c: char, rdr: &mut StringReader) -> token::Token {\n         }\n         if num_str.len() == 0u {\n             err_span(rdr, start_bpos, rdr.last_pos, \"no valid digits found for number\");\n-            num_str = \"1\".to_strbuf();\n+            num_str = \"1\".to_string();\n         }\n         let parsed = match from_str_radix::<u64>(num_str.as_slice(),\n                                                  base as uint) {\n@@ -594,7 +594,7 @@ fn scan_number(c: char, rdr: &mut StringReader) -> token::Token {\n     } else {\n         if num_str.len() == 0u {\n             err_span(rdr, start_bpos, rdr.last_pos, \"no valid digits found for number\");\n-            num_str = \"1\".to_strbuf();\n+            num_str = \"1\".to_string();\n         }\n         let parsed = match from_str_radix::<u64>(num_str.as_slice(),\n                                                  base as uint) {\n@@ -1003,15 +1003,15 @@ mod test {\n     // open a string reader for the given string\n     fn setup<'a>(span_handler: &'a diagnostic::SpanHandler,\n                  teststr: String) -> StringReader<'a> {\n-        let fm = span_handler.cm.new_filemap(\"zebra.rs\".to_strbuf(), teststr);\n+        let fm = span_handler.cm.new_filemap(\"zebra.rs\".to_string(), teststr);\n         new_string_reader(span_handler, fm)\n     }\n \n     #[test] fn t1 () {\n         let span_handler = mk_sh();\n         let mut string_reader = setup(&span_handler,\n             \"/* my source file */ \\\n-             fn main() { println!(\\\"zebra\\\"); }\\n\".to_strbuf());\n+             fn main() { println!(\\\"zebra\\\"); }\\n\".to_string());\n         let id = str_to_ident(\"fn\");\n         let tok1 = string_reader.next_token();\n         let tok2 = TokenAndSpan{\n@@ -1044,55 +1044,55 @@ mod test {\n     }\n \n     #[test] fn doublecolonparsing () {\n-        check_tokenization(setup(&mk_sh(), \"a b\".to_strbuf()),\n+        check_tokenization(setup(&mk_sh(), \"a b\".to_string()),\n                            vec!(mk_ident(\"a\",false),\n                              mk_ident(\"b\",false)));\n     }\n \n     #[test] fn dcparsing_2 () {\n-        check_tokenization(setup(&mk_sh(), \"a::b\".to_strbuf()),\n+        check_tokenization(setup(&mk_sh(), \"a::b\".to_string()),\n                            vec!(mk_ident(\"a\",true),\n                              token::MOD_SEP,\n                              mk_ident(\"b\",false)));\n     }\n \n     #[test] fn dcparsing_3 () {\n-        check_tokenization(setup(&mk_sh(), \"a ::b\".to_strbuf()),\n+        check_tokenization(setup(&mk_sh(), \"a ::b\".to_string()),\n                            vec!(mk_ident(\"a\",false),\n                              token::MOD_SEP,\n                              mk_ident(\"b\",false)));\n     }\n \n     #[test] fn dcparsing_4 () {\n-        check_tokenization(setup(&mk_sh(), \"a:: b\".to_strbuf()),\n+        check_tokenization(setup(&mk_sh(), \"a:: b\".to_string()),\n                            vec!(mk_ident(\"a\",true),\n                              token::MOD_SEP,\n                              mk_ident(\"b\",false)));\n     }\n \n     #[test] fn character_a() {\n-        assert_eq!(setup(&mk_sh(), \"'a'\".to_strbuf()).next_token().tok,\n+        assert_eq!(setup(&mk_sh(), \"'a'\".to_string()).next_token().tok,\n                    token::LIT_CHAR('a'));\n     }\n \n     #[test] fn character_space() {\n-        assert_eq!(setup(&mk_sh(), \"' '\".to_strbuf()).next_token().tok,\n+        assert_eq!(setup(&mk_sh(), \"' '\".to_string()).next_token().tok,\n                    token::LIT_CHAR(' '));\n     }\n \n     #[test] fn character_escaped() {\n-        assert_eq!(setup(&mk_sh(), \"'\\\\n'\".to_strbuf()).next_token().tok,\n+        assert_eq!(setup(&mk_sh(), \"'\\\\n'\".to_string()).next_token().tok,\n                    token::LIT_CHAR('\\n'));\n     }\n \n     #[test] fn lifetime_name() {\n-        assert_eq!(setup(&mk_sh(), \"'abc\".to_strbuf()).next_token().tok,\n+        assert_eq!(setup(&mk_sh(), \"'abc\".to_string()).next_token().tok,\n                    token::LIFETIME(token::str_to_ident(\"abc\")));\n     }\n \n     #[test] fn raw_string() {\n         assert_eq!(setup(&mk_sh(),\n-                         \"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\".to_strbuf()).next_token()\n+                         \"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\".to_string()).next_token()\n                                                                  .tok,\n                    token::LIT_STR_RAW(token::str_to_ident(\"\\\"#a\\\\b\\x00c\\\"\"), 3));\n     }\n@@ -1105,7 +1105,7 @@ mod test {\n \n     #[test] fn nested_block_comments() {\n         assert_eq!(setup(&mk_sh(),\n-                         \"/* /* */ */'a'\".to_strbuf()).next_token().tok,\n+                         \"/* /* */ */'a'\".to_string()).next_token().tok,\n                    token::LIT_CHAR('a'));\n     }\n "}, {"sha": "ce89a7dec39e7d9197db0d7d18bab4c44beee6d9", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -232,8 +232,8 @@ pub fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n     };\n     match str::from_utf8(bytes.as_slice()) {\n         Some(s) => {\n-            return string_to_filemap(sess, s.to_strbuf(),\n-                                     path.as_str().unwrap().to_strbuf())\n+            return string_to_filemap(sess, s.to_string(),\n+                                     path.as_str().unwrap().to_string())\n         }\n         None => {\n             err(format!(\"{} is not UTF-8 encoded\", path.display()).as_slice())\n@@ -297,7 +297,7 @@ mod test {\n         let mut writer = MemWriter::new();\n         let mut encoder = json::Encoder::new(&mut writer as &mut io::Writer);\n         let _ = val.encode(&mut encoder);\n-        str::from_utf8(writer.unwrap().as_slice()).unwrap().to_strbuf()\n+        str::from_utf8(writer.unwrap().as_slice()).unwrap().to_string()\n     }\n \n     // produce a codemap::span\n@@ -306,7 +306,7 @@ mod test {\n     }\n \n     #[test] fn path_exprs_1() {\n-        assert!(string_to_expr(\"a\".to_strbuf()) ==\n+        assert!(string_to_expr(\"a\".to_string()) ==\n                    @ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprPath(ast::Path {\n@@ -325,7 +325,7 @@ mod test {\n     }\n \n     #[test] fn path_exprs_2 () {\n-        assert!(string_to_expr(\"::a::b\".to_strbuf()) ==\n+        assert!(string_to_expr(\"::a::b\".to_string()) ==\n                    @ast::Expr {\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprPath(ast::Path {\n@@ -350,12 +350,12 @@ mod test {\n \n     #[should_fail]\n     #[test] fn bad_path_expr_1() {\n-        string_to_expr(\"::abc::def::return\".to_strbuf());\n+        string_to_expr(\"::abc::def::return\".to_string());\n     }\n \n     // check the token-tree-ization of macros\n     #[test] fn string_to_tts_macro () {\n-        let tts = string_to_tts(\"macro_rules! zip (($a)=>($a))\".to_strbuf());\n+        let tts = string_to_tts(\"macro_rules! zip (($a)=>($a))\".to_string());\n         let tts: &[ast::TokenTree] = tts.as_slice();\n         match tts {\n             [ast::TTTok(_,_),\n@@ -408,7 +408,7 @@ mod test {\n     }\n \n     #[test] fn string_to_tts_1 () {\n-        let tts = string_to_tts(\"fn a (b : int) { b; }\".to_strbuf());\n+        let tts = string_to_tts(\"fn a (b : int) { b; }\".to_string());\n         assert_eq!(to_json_str(&tts),\n         \"[\\\n     {\\\n@@ -532,12 +532,12 @@ mod test {\n             ]\\\n         ]\\\n     }\\\n-]\".to_strbuf()\n+]\".to_string()\n         );\n     }\n \n     #[test] fn ret_expr() {\n-        assert!(string_to_expr(\"return d\".to_strbuf()) ==\n+        assert!(string_to_expr(\"return d\".to_string()) ==\n                    @ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n                     node:ast::ExprRet(Some(@ast::Expr{\n@@ -560,7 +560,7 @@ mod test {\n     }\n \n     #[test] fn parse_stmt_1 () {\n-        assert!(string_to_stmt(\"b;\".to_strbuf()) ==\n+        assert!(string_to_stmt(\"b;\".to_string()) ==\n                    @Spanned{\n                        node: ast::StmtExpr(@ast::Expr {\n                            id: ast::DUMMY_NODE_ID,\n@@ -587,7 +587,7 @@ mod test {\n \n     #[test] fn parse_ident_pat () {\n         let sess = new_parse_sess();\n-        let mut parser = string_to_parser(&sess, \"b\".to_strbuf());\n+        let mut parser = string_to_parser(&sess, \"b\".to_string());\n         assert!(parser.parse_pat() ==\n                    @ast::Pat{id: ast::DUMMY_NODE_ID,\n                              node: ast::PatIdent(\n@@ -611,7 +611,7 @@ mod test {\n     // check the contents of the tt manually:\n     #[test] fn parse_fundecl () {\n         // this test depends on the intern order of \"fn\" and \"int\"\n-        assert!(string_to_item(\"fn a (b : int) { b; }\".to_strbuf()) ==\n+        assert!(string_to_item(\"fn a (b : int) { b; }\".to_string()) ==\n                   Some(\n                       @ast::Item{ident:str_to_ident(\"a\"),\n                             attrs:Vec::new(),\n@@ -703,8 +703,8 @@ mod test {\n \n     #[test] fn parse_exprs () {\n         // just make sure that they parse....\n-        string_to_expr(\"3 + 4\".to_strbuf());\n-        string_to_expr(\"a::z.froob(b,@(987+3))\".to_strbuf());\n+        string_to_expr(\"3 + 4\".to_string());\n+        string_to_expr(\"a::z.froob(b,@(987+3))\".to_string());\n     }\n \n     #[test] fn attrs_fix_bug () {\n@@ -719,7 +719,7 @@ mod test {\n     fn wb() -> c_int { O_WRONLY as c_int }\n \n     let mut fflags: c_int = wb();\n-}\".to_strbuf());\n+}\".to_string());\n     }\n \n }"}, {"sha": "6832555f728c01b666a309138479147d968edb2d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -407,7 +407,7 @@ impl<'a> Parser<'a> {\n             let mut i = tokens.iter();\n             // This might be a sign we need a connect method on Iterator.\n             let b = i.next()\n-                     .map_or(\"\".to_strbuf(), |t| Parser::token_to_str(t));\n+                     .map_or(\"\".to_string(), |t| Parser::token_to_str(t));\n             i.fold(b, |b,a| {\n                 let mut b = b;\n                 b.push_str(\"`, `\");\n@@ -4160,7 +4160,7 @@ impl<'a> Parser<'a> {\n                 outer_attrs, \"path\") {\n             Some(d) => (dir_path.join(d), true),\n             None => {\n-                let mod_name = mod_string.get().to_owned();\n+                let mod_name = mod_string.get().to_string();\n                 let default_path_str = format!(\"{}.rs\", mod_name);\n                 let secondary_path_str = format!(\"{}/mod.rs\", mod_name);\n                 let default_path = dir_path.join(default_path_str.as_slice());\n@@ -4172,7 +4172,7 @@ impl<'a> Parser<'a> {\n                     self.span_err(id_sp,\n                                   \"cannot declare a new module at this location\");\n                     let this_module = match self.mod_path_stack.last() {\n-                        Some(name) => name.get().to_strbuf(),\n+                        Some(name) => name.get().to_string(),\n                         None => self.root_module_name.get_ref().clone(),\n                     };\n                     self.span_note(id_sp,\n@@ -4213,7 +4213,7 @@ impl<'a> Parser<'a> {\n         };\n \n         self.eval_src_mod_from_path(file_path, owns_directory,\n-                                    mod_string.get().to_strbuf(), id_sp)\n+                                    mod_string.get().to_string(), id_sp)\n     }\n \n     fn eval_src_mod_from_path(&mut self,"}, {"sha": "2c090d053a3d2fece966b7ea00bfb2975646b2d9", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -138,32 +138,32 @@ impl fmt::Show for Nonterminal {\n \n pub fn binop_to_str(o: BinOp) -> String {\n     match o {\n-      PLUS => \"+\".to_strbuf(),\n-      MINUS => \"-\".to_strbuf(),\n-      STAR => \"*\".to_strbuf(),\n-      SLASH => \"/\".to_strbuf(),\n-      PERCENT => \"%\".to_strbuf(),\n-      CARET => \"^\".to_strbuf(),\n-      AND => \"&\".to_strbuf(),\n-      OR => \"|\".to_strbuf(),\n-      SHL => \"<<\".to_strbuf(),\n-      SHR => \">>\".to_strbuf()\n+      PLUS => \"+\".to_string(),\n+      MINUS => \"-\".to_string(),\n+      STAR => \"*\".to_string(),\n+      SLASH => \"/\".to_string(),\n+      PERCENT => \"%\".to_string(),\n+      CARET => \"^\".to_string(),\n+      AND => \"&\".to_string(),\n+      OR => \"|\".to_string(),\n+      SHL => \"<<\".to_string(),\n+      SHR => \">>\".to_string()\n     }\n }\n \n pub fn to_str(t: &Token) -> String {\n     match *t {\n-      EQ => \"=\".to_strbuf(),\n-      LT => \"<\".to_strbuf(),\n-      LE => \"<=\".to_strbuf(),\n-      EQEQ => \"==\".to_strbuf(),\n-      NE => \"!=\".to_strbuf(),\n-      GE => \">=\".to_strbuf(),\n-      GT => \">\".to_strbuf(),\n-      NOT => \"!\".to_strbuf(),\n-      TILDE => \"~\".to_strbuf(),\n-      OROR => \"||\".to_strbuf(),\n-      ANDAND => \"&&\".to_strbuf(),\n+      EQ => \"=\".to_string(),\n+      LT => \"<\".to_string(),\n+      LE => \"<=\".to_string(),\n+      EQEQ => \"==\".to_string(),\n+      NE => \"!=\".to_string(),\n+      GE => \">=\".to_string(),\n+      GT => \">\".to_string(),\n+      NOT => \"!\".to_string(),\n+      TILDE => \"~\".to_string(),\n+      OROR => \"||\".to_string(),\n+      ANDAND => \"&&\".to_string(),\n       BINOP(op) => binop_to_str(op),\n       BINOPEQ(op) => {\n           let mut s = binop_to_str(op);\n@@ -172,25 +172,25 @@ pub fn to_str(t: &Token) -> String {\n       }\n \n       /* Structural symbols */\n-      AT => \"@\".to_strbuf(),\n-      DOT => \".\".to_strbuf(),\n-      DOTDOT => \"..\".to_strbuf(),\n-      DOTDOTDOT => \"...\".to_strbuf(),\n-      COMMA => \",\".to_strbuf(),\n-      SEMI => \";\".to_strbuf(),\n-      COLON => \":\".to_strbuf(),\n-      MOD_SEP => \"::\".to_strbuf(),\n-      RARROW => \"->\".to_strbuf(),\n-      LARROW => \"<-\".to_strbuf(),\n-      FAT_ARROW => \"=>\".to_strbuf(),\n-      LPAREN => \"(\".to_strbuf(),\n-      RPAREN => \")\".to_strbuf(),\n-      LBRACKET => \"[\".to_strbuf(),\n-      RBRACKET => \"]\".to_strbuf(),\n-      LBRACE => \"{\".to_strbuf(),\n-      RBRACE => \"}\".to_strbuf(),\n-      POUND => \"#\".to_strbuf(),\n-      DOLLAR => \"$\".to_strbuf(),\n+      AT => \"@\".to_string(),\n+      DOT => \".\".to_string(),\n+      DOTDOT => \"..\".to_string(),\n+      DOTDOTDOT => \"...\".to_string(),\n+      COMMA => \",\".to_string(),\n+      SEMI => \";\".to_string(),\n+      COLON => \":\".to_string(),\n+      MOD_SEP => \"::\".to_string(),\n+      RARROW => \"->\".to_string(),\n+      LARROW => \"<-\".to_string(),\n+      FAT_ARROW => \"=>\".to_string(),\n+      LPAREN => \"(\".to_string(),\n+      RPAREN => \")\".to_string(),\n+      LBRACKET => \"[\".to_string(),\n+      RBRACKET => \"]\".to_string(),\n+      LBRACE => \"{\".to_string(),\n+      RBRACE => \"}\".to_string(),\n+      POUND => \"#\".to_string(),\n+      DOLLAR => \"$\".to_string(),\n \n       /* Literals */\n       LIT_CHAR(c) => {\n@@ -205,7 +205,7 @@ pub fn to_str(t: &Token) -> String {\n                                                ast_util::ForceSuffix),\n       LIT_UINT(u, t) => ast_util::uint_ty_to_str(t, Some(u),\n                                                  ast_util::ForceSuffix),\n-      LIT_INT_UNSUFFIXED(i) => { (i as u64).to_str().to_strbuf() }\n+      LIT_INT_UNSUFFIXED(i) => { (i as u64).to_str().to_string() }\n       LIT_FLOAT(s, t) => {\n         let mut body = String::from_str(get_ident(s).get());\n         if body.as_slice().ends_with(\".\") {\n@@ -222,29 +222,29 @@ pub fn to_str(t: &Token) -> String {\n         body\n       }\n       LIT_STR(s) => {\n-          (format!(\"\\\"{}\\\"\", get_ident(s).get().escape_default())).to_strbuf()\n+          (format!(\"\\\"{}\\\"\", get_ident(s).get().escape_default())).to_string()\n       }\n       LIT_STR_RAW(s, n) => {\n           (format!(\"r{delim}\\\"{string}\\\"{delim}\",\n-                  delim=\"#\".repeat(n), string=get_ident(s))).to_strbuf()\n+                  delim=\"#\".repeat(n), string=get_ident(s))).to_string()\n       }\n \n       /* Name components */\n-      IDENT(s, _) => get_ident(s).get().to_strbuf(),\n+      IDENT(s, _) => get_ident(s).get().to_string(),\n       LIFETIME(s) => {\n-          (format!(\"'{}\", get_ident(s))).to_strbuf()\n+          (format!(\"'{}\", get_ident(s))).to_string()\n       }\n-      UNDERSCORE => \"_\".to_strbuf(),\n+      UNDERSCORE => \"_\".to_string(),\n \n       /* Other */\n-      DOC_COMMENT(s) => get_ident(s).get().to_strbuf(),\n-      EOF => \"<eof>\".to_strbuf(),\n+      DOC_COMMENT(s) => get_ident(s).get().to_string(),\n+      EOF => \"<eof>\".to_string(),\n       INTERPOLATED(ref nt) => {\n         match nt {\n             &NtExpr(e) => ::print::pprust::expr_to_str(e),\n             &NtMeta(e) => ::print::pprust::meta_item_to_str(e),\n             _ => {\n-                let mut s = \"an interpolated \".to_strbuf();\n+                let mut s = \"an interpolated \".to_string();\n                 match *nt {\n                     NtItem(..) => s.push_str(\"item\"),\n                     NtBlock(..) => s.push_str(\"block\"),"}, {"sha": "669378b313ad1020baf4be0df31c1e75420e0b57", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -111,11 +111,11 @@ impl Token {\n \n pub fn tok_str(t: Token) -> String {\n     match t {\n-        String(s, len) => return format!(\"STR({},{})\", s, len).to_strbuf(),\n-        Break(_) => return \"BREAK\".to_strbuf(),\n-        Begin(_) => return \"BEGIN\".to_strbuf(),\n-        End => return \"END\".to_strbuf(),\n-        Eof => return \"EOF\".to_strbuf()\n+        String(s, len) => return format!(\"STR({},{})\", s, len).to_string(),\n+        Break(_) => return \"BREAK\".to_string(),\n+        Begin(_) => return \"BEGIN\".to_string(),\n+        End => return \"END\".to_string(),\n+        Eof => return \"EOF\".to_string()\n     }\n }\n \n@@ -142,7 +142,7 @@ pub fn buf_str(toks: Vec<Token>,\n         i %= n;\n     }\n     s.push_char(']');\n-    return s.into_strbuf();\n+    return s.into_string();\n }\n \n pub enum PrintStackBreak {\n@@ -627,15 +627,15 @@ pub fn end(p: &mut Printer) -> io::IoResult<()> { p.pretty_print(End) }\n pub fn eof(p: &mut Printer) -> io::IoResult<()> { p.pretty_print(Eof) }\n \n pub fn word(p: &mut Printer, wrd: &str) -> io::IoResult<()> {\n-    p.pretty_print(String(/* bad */ wrd.to_strbuf(), wrd.len() as int))\n+    p.pretty_print(String(/* bad */ wrd.to_string(), wrd.len() as int))\n }\n \n pub fn huge_word(p: &mut Printer, wrd: &str) -> io::IoResult<()> {\n-    p.pretty_print(String(/* bad */ wrd.to_strbuf(), SIZE_INFINITY))\n+    p.pretty_print(String(/* bad */ wrd.to_string(), SIZE_INFINITY))\n }\n \n pub fn zero_word(p: &mut Printer, wrd: &str) -> io::IoResult<()> {\n-    p.pretty_print(String(/* bad */ wrd.to_strbuf(), 0))\n+    p.pretty_print(String(/* bad */ wrd.to_string(), 0))\n }\n \n pub fn spaces(p: &mut Printer, n: uint) -> io::IoResult<()> {"}, {"sha": "3cb2d0b421c2f3c312d94713b9c790d98e1c783f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -144,7 +144,7 @@ pub fn to_str(f: |&mut State| -> IoResult<()>) -> String {\n         let result =\n             str::from_utf8_owned(Vec::from_slice(wr.get_ref())).unwrap();\n         mem::forget(wr);\n-        result.to_strbuf()\n+        result.to_string()\n     }\n }\n \n@@ -243,8 +243,8 @@ pub fn variant_to_str(var: &ast::Variant) -> String {\n \n pub fn visibility_qualified(vis: ast::Visibility, s: &str) -> String {\n     match vis {\n-        ast::Public => format!(\"pub {}\", s).to_strbuf(),\n-        ast::Inherited => s.to_strbuf()\n+        ast::Public => format!(\"pub {}\", s).to_string(),\n+        ast::Inherited => s.to_string()\n     }\n }\n \n@@ -2475,7 +2475,7 @@ mod test {\n         let generics = ast_util::empty_generics();\n         assert_eq!(&fun_to_str(&decl, ast::NormalFn, abba_ident,\n                                None, &generics),\n-                   &\"fn abba()\".to_strbuf());\n+                   &\"fn abba()\".to_string());\n     }\n \n     #[test]\n@@ -2493,6 +2493,6 @@ mod test {\n         });\n \n         let varstr = variant_to_str(&var);\n-        assert_eq!(&varstr,&\"pub principal_skinner\".to_strbuf());\n+        assert_eq!(&varstr,&\"pub principal_skinner\".to_string());\n     }\n }"}, {"sha": "72600921ba9c7c8e3fe65bf6d2feac62750e0830", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -121,7 +121,7 @@ impl fmt::Show for RcStr {\n impl RcStr {\n     pub fn new(string: &str) -> RcStr {\n         RcStr {\n-            string: Rc::new(string.to_strbuf()),\n+            string: Rc::new(string.to_string()),\n         }\n     }\n }"}, {"sha": "1417cb5e8576f57e813a0568cad92d6371f139b2", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -19,14 +19,14 @@ use parse::token;\n pub fn string_to_tts(source_str: String) -> Vec<ast::TokenTree> {\n     let ps = new_parse_sess();\n     filemap_to_tts(&ps,\n-                   string_to_filemap(&ps, source_str, \"bogofile\".to_strbuf()))\n+                   string_to_filemap(&ps, source_str, \"bogofile\".to_string()))\n }\n \n // map string to parser (via tts)\n pub fn string_to_parser<'a>(ps: &'a ParseSess, source_str: String) -> Parser<'a> {\n     new_parser_from_source_str(ps,\n                                Vec::new(),\n-                               \"bogofile\".to_strbuf(),\n+                               \"bogofile\".to_string(),\n                                source_str)\n }\n "}, {"sha": "7fe9ea33c25056c19c5d6f0c8b4aad5756bb2fba", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -186,7 +186,7 @@ impl<T: Writer> Terminal<T> for TerminfoTerminal<T> {\n                 cap = self.ti.strings.find_equiv(&(\"op\"));\n             }\n         }\n-        let s = cap.map_or(Err(\"can't find terminfo capability `sgr0`\".to_strbuf()), |op| {\n+        let s = cap.map_or(Err(\"can't find terminfo capability `sgr0`\".to_string()), |op| {\n             expand(op.as_slice(), [], &mut Variables::new())\n         });\n         if s.is_ok() {"}, {"sha": "db9509a9dd2114c85479af8737ee823b74db1f48", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -124,9 +124,9 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         match stack.pop().unwrap() {\n                             // if c is 0, use 0200 (128) for ncurses compatibility\n                             Number(c) => output.push(if c == 0 { 128 } else { c } as u8),\n-                            _       => return Err(\"a non-char was used with %c\".to_strbuf())\n+                            _       => return Err(\"a non-char was used with %c\".to_string())\n                         }\n-                    } else { return Err(\"stack is empty\".to_strbuf()) },\n+                    } else { return Err(\"stack is empty\".to_string()) },\n                     'p' => state = PushParam,\n                     'P' => state = SetVar,\n                     'g' => state = GetVar,\n@@ -135,112 +135,112 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     'l' => if stack.len() > 0 {\n                         match stack.pop().unwrap() {\n                             String(s) => stack.push(Number(s.len() as int)),\n-                            _         => return Err(\"a non-str was used with %l\".to_strbuf())\n+                            _         => return Err(\"a non-str was used with %l\".to_string())\n                         }\n-                    } else { return Err(\"stack is empty\".to_strbuf()) },\n+                    } else { return Err(\"stack is empty\".to_string()) },\n                     '+' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x + y)),\n-                            _ => return Err(\"non-numbers on stack with +\".to_strbuf())\n+                            _ => return Err(\"non-numbers on stack with +\".to_string())\n                         }\n-                    } else { return Err(\"stack is empty\".to_strbuf()) },\n+                    } else { return Err(\"stack is empty\".to_string()) },\n                     '-' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x - y)),\n-                            _ => return Err(\"non-numbers on stack with -\".to_strbuf())\n+                            _ => return Err(\"non-numbers on stack with -\".to_string())\n                         }\n-                    } else { return Err(\"stack is empty\".to_strbuf()) },\n+                    } else { return Err(\"stack is empty\".to_string()) },\n                     '*' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x * y)),\n-                            _ => return Err(\"non-numbers on stack with *\".to_strbuf())\n+                            _ => return Err(\"non-numbers on stack with *\".to_string())\n                         }\n-                    } else { return Err(\"stack is empty\".to_strbuf()) },\n+                    } else { return Err(\"stack is empty\".to_string()) },\n                     '/' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x / y)),\n-                            _ => return Err(\"non-numbers on stack with /\".to_strbuf())\n+                            _ => return Err(\"non-numbers on stack with /\".to_string())\n                         }\n-                    } else { return Err(\"stack is empty\".to_strbuf()) },\n+                    } else { return Err(\"stack is empty\".to_string()) },\n                     'm' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x % y)),\n-                            _ => return Err(\"non-numbers on stack with %\".to_strbuf())\n+                            _ => return Err(\"non-numbers on stack with %\".to_string())\n                         }\n-                    } else { return Err(\"stack is empty\".to_strbuf()) },\n+                    } else { return Err(\"stack is empty\".to_string()) },\n                     '&' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x & y)),\n-                            _ => return Err(\"non-numbers on stack with &\".to_strbuf())\n+                            _ => return Err(\"non-numbers on stack with &\".to_string())\n                         }\n-                    } else { return Err(\"stack is empty\".to_strbuf()) },\n+                    } else { return Err(\"stack is empty\".to_string()) },\n                     '|' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x | y)),\n-                            _ => return Err(\"non-numbers on stack with |\".to_strbuf())\n+                            _ => return Err(\"non-numbers on stack with |\".to_string())\n                         }\n-                    } else { return Err(\"stack is empty\".to_strbuf()) },\n+                    } else { return Err(\"stack is empty\".to_string()) },\n                     '^' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x ^ y)),\n-                            _ => return Err(\"non-numbers on stack with ^\".to_strbuf())\n+                            _ => return Err(\"non-numbers on stack with ^\".to_string())\n                         }\n-                    } else { return Err(\"stack is empty\".to_strbuf()) },\n+                    } else { return Err(\"stack is empty\".to_string()) },\n                     '=' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(if x == y { 1 }\n                                                                         else { 0 })),\n-                            _ => return Err(\"non-numbers on stack with =\".to_strbuf())\n+                            _ => return Err(\"non-numbers on stack with =\".to_string())\n                         }\n-                    } else { return Err(\"stack is empty\".to_strbuf()) },\n+                    } else { return Err(\"stack is empty\".to_string()) },\n                     '>' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(if x > y { 1 }\n                                                                         else { 0 })),\n-                            _ => return Err(\"non-numbers on stack with >\".to_strbuf())\n+                            _ => return Err(\"non-numbers on stack with >\".to_string())\n                         }\n-                    } else { return Err(\"stack is empty\".to_strbuf()) },\n+                    } else { return Err(\"stack is empty\".to_string()) },\n                     '<' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(if x < y { 1 }\n                                                                         else { 0 })),\n-                            _ => return Err(\"non-numbers on stack with <\".to_strbuf())\n+                            _ => return Err(\"non-numbers on stack with <\".to_string())\n                         }\n-                    } else { return Err(\"stack is empty\".to_strbuf()) },\n+                    } else { return Err(\"stack is empty\".to_string()) },\n                     'A' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(0), Number(_)) => stack.push(Number(0)),\n                             (Number(_), Number(0)) => stack.push(Number(0)),\n                             (Number(_), Number(_)) => stack.push(Number(1)),\n-                            _ => return Err(\"non-numbers on stack with logical and\".to_strbuf())\n+                            _ => return Err(\"non-numbers on stack with logical and\".to_string())\n                         }\n-                    } else { return Err(\"stack is empty\".to_strbuf()) },\n+                    } else { return Err(\"stack is empty\".to_string()) },\n                     'O' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(0), Number(0)) => stack.push(Number(0)),\n                             (Number(_), Number(_)) => stack.push(Number(1)),\n-                            _ => return Err(\"non-numbers on stack with logical or\".to_strbuf())\n+                            _ => return Err(\"non-numbers on stack with logical or\".to_string())\n                         }\n-                    } else { return Err(\"stack is empty\".to_strbuf()) },\n+                    } else { return Err(\"stack is empty\".to_string()) },\n                     '!' => if stack.len() > 0 {\n                         match stack.pop().unwrap() {\n                             Number(0) => stack.push(Number(1)),\n                             Number(_) => stack.push(Number(0)),\n-                            _ => return Err(\"non-number on stack with logical not\".to_strbuf())\n+                            _ => return Err(\"non-number on stack with logical not\".to_string())\n                         }\n-                    } else { return Err(\"stack is empty\".to_strbuf()) },\n+                    } else { return Err(\"stack is empty\".to_string()) },\n                     '~' => if stack.len() > 0 {\n                         match stack.pop().unwrap() {\n                             Number(x) => stack.push(Number(!x)),\n-                            _         => return Err(\"non-number on stack with %~\".to_strbuf())\n+                            _         => return Err(\"non-number on stack with %~\".to_string())\n                         }\n-                    } else { return Err(\"stack is empty\".to_strbuf()) },\n+                    } else { return Err(\"stack is empty\".to_string()) },\n                     'i' => match (mparams[0].clone(), mparams[1].clone()) {\n                         (Number(x), Number(y)) => {\n                             mparams[0] = Number(x+1);\n                             mparams[1] = Number(y+1);\n                         },\n-                        (_, _) => return Err(\"first two params not numbers with %i\".to_strbuf())\n+                        (_, _) => return Err(\"first two params not numbers with %i\".to_string())\n                     },\n \n                     // printf-style support for %doxXs\n@@ -249,7 +249,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         let res = format(stack.pop().unwrap(), FormatOp::from_char(cur), flags);\n                         if res.is_err() { return res }\n                         output.push_all(res.unwrap().as_slice())\n-                    } else { return Err(\"stack is empty\".to_strbuf()) },\n+                    } else { return Err(\"stack is empty\".to_string()) },\n                     ':'|'#'|' '|'.'|'0'..'9' => {\n                         let mut flags = Flags::new();\n                         let mut fstate = FormatStateFlags;\n@@ -274,9 +274,9 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                             Number(0) => state = SeekIfElse(0),\n                             Number(_) => (),\n                             _         => return Err(\"non-number on stack \\\n-                                                    with conditional\".to_strbuf())\n+                                                    with conditional\".to_string())\n                         }\n-                    } else { return Err(\"stack is empty\".to_strbuf()) },\n+                    } else { return Err(\"stack is empty\".to_string()) },\n                     'e' => state = SeekIfEnd(0),\n                     ';' => (),\n \n@@ -291,22 +291,22 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                 // params are 1-indexed\n                 stack.push(mparams[match char::to_digit(cur, 10) {\n                     Some(d) => d - 1,\n-                    None => return Err(\"bad param number\".to_strbuf())\n+                    None => return Err(\"bad param number\".to_string())\n                 }].clone());\n             },\n             SetVar => {\n                 if cur >= 'A' && cur <= 'Z' {\n                     if stack.len() > 0 {\n                         let idx = (cur as u8) - ('A' as u8);\n                         vars.sta[idx as uint] = stack.pop().unwrap();\n-                    } else { return Err(\"stack is empty\".to_strbuf()) }\n+                    } else { return Err(\"stack is empty\".to_string()) }\n                 } else if cur >= 'a' && cur <= 'z' {\n                     if stack.len() > 0 {\n                         let idx = (cur as u8) - ('a' as u8);\n                         vars.dyn[idx as uint] = stack.pop().unwrap();\n-                    } else { return Err(\"stack is empty\".to_strbuf()) }\n+                    } else { return Err(\"stack is empty\".to_string()) }\n                 } else {\n-                    return Err(\"bad variable name in %P\".to_strbuf());\n+                    return Err(\"bad variable name in %P\".to_string());\n                 }\n             },\n             GetVar => {\n@@ -317,7 +317,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     let idx = (cur as u8) - ('a' as u8);\n                     stack.push(vars.dyn[idx as uint].clone());\n                 } else {\n-                    return Err(\"bad variable name in %g\".to_strbuf());\n+                    return Err(\"bad variable name in %g\".to_string());\n                 }\n             },\n             CharConstant => {\n@@ -326,7 +326,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             },\n             CharClose => {\n                 if cur != '\\'' {\n-                    return Err(\"malformed character constant\".to_strbuf());\n+                    return Err(\"malformed character constant\".to_string());\n                 }\n             },\n             IntConstant(i) => {\n@@ -339,7 +339,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         state = IntConstant(i*10 + (cur as int - '0' as int));\n                         old_state = Nothing;\n                     }\n-                    _ => return Err(\"bad int constant\".to_strbuf())\n+                    _ => return Err(\"bad int constant\".to_string())\n                 }\n             }\n             FormatPattern(ref mut flags, ref mut fstate) => {\n@@ -350,7 +350,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         if res.is_err() { return res }\n                         output.push_all(res.unwrap().as_slice());\n                         old_state = state; // will cause state to go to Nothing\n-                    } else { return Err(\"stack is empty\".to_strbuf()) },\n+                    } else { return Err(\"stack is empty\".to_string()) },\n                     (FormatStateFlags,'#') => {\n                         flags.alternate = true;\n                     }\n@@ -373,7 +373,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     (FormatStateWidth,'0'..'9') => {\n                         let old = flags.width;\n                         flags.width = flags.width * 10 + (cur as uint - '0' as uint);\n-                        if flags.width < old { return Err(\"format width overflow\".to_strbuf()) }\n+                        if flags.width < old { return Err(\"format width overflow\".to_string()) }\n                     }\n                     (FormatStateWidth,'.') => {\n                         *fstate = FormatStatePrecision;\n@@ -382,10 +382,10 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         let old = flags.precision;\n                         flags.precision = flags.precision * 10 + (cur as uint - '0' as uint);\n                         if flags.precision < old {\n-                            return Err(\"format precision overflow\".to_strbuf())\n+                            return Err(\"format precision overflow\".to_string())\n                         }\n                     }\n-                    _ => return Err(\"invalid format specifier\".to_strbuf())\n+                    _ => return Err(\"invalid format specifier\".to_string())\n                 }\n             }\n             SeekIfElse(level) => {\n@@ -493,7 +493,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n                 (FormatHex, _)       => format!(\"{:x}\", d).into_bytes(),\n                 (FormatHEX, _)       => format!(\"{:X}\", d).into_bytes(),\n                 (FormatString, _)    => {\n-                    return Err(\"non-number on stack with %s\".to_strbuf())\n+                    return Err(\"non-number on stack with %s\".to_string())\n                 }\n             };\n             let mut s: Vec<u8> = s.move_iter().collect();\n@@ -607,7 +607,7 @@ mod test {\n             assert!(res.is_err(),\n                     \"Op {} succeeded incorrectly with 0 stack entries\", *cap);\n             let p = if *cap == \"%s\" || *cap == \"%l\" {\n-                String(\"foo\".to_strbuf())\n+                String(\"foo\".to_string())\n             } else {\n                 Number(97)\n             };\n@@ -685,12 +685,12 @@ mod test {\n         let mut varstruct = Variables::new();\n         let vars = &mut varstruct;\n         assert_eq!(expand(bytes!(\"%p1%s%p2%2s%p3%2s%p4%.2s\"),\n-                          [String(\"foo\".to_strbuf()),\n-                           String(\"foo\".to_strbuf()),\n-                           String(\"f\".to_strbuf()),\n-                           String(\"foo\".to_strbuf())], vars),\n+                          [String(\"foo\".to_string()),\n+                           String(\"foo\".to_string()),\n+                           String(\"f\".to_string()),\n+                           String(\"foo\".to_string())], vars),\n                    Ok(bytes!(\"foofoo ffo\").iter().map(|x| *x).collect()));\n-        assert_eq!(expand(bytes!(\"%p1%:-4.2s\"), [String(\"foo\".to_strbuf())], vars),\n+        assert_eq!(expand(bytes!(\"%p1%:-4.2s\"), [String(\"foo\".to_string())], vars),\n                    Ok(bytes!(\"fo  \").iter().map(|x| *x).collect()));\n \n         assert_eq!(expand(bytes!(\"%p1%d%p1%.3d%p1%5d%p1%:+d\"), [Number(1)], vars),"}, {"sha": "1a42addb4bd13455255185869028990fc2dd424e", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -201,29 +201,29 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n \n     if (bools_bytes as uint) > boolnames.len() {\n         return Err(\"incompatible file: more booleans than \\\n-                    expected\".to_strbuf());\n+                    expected\".to_string());\n     }\n \n     if (numbers_count as uint) > numnames.len() {\n         return Err(\"incompatible file: more numbers than \\\n-                    expected\".to_strbuf());\n+                    expected\".to_string());\n     }\n \n     if (string_offsets_count as uint) > stringnames.len() {\n         return Err(\"incompatible file: more string offsets than \\\n-                    expected\".to_strbuf());\n+                    expected\".to_string());\n     }\n \n     // don't read NUL\n     let bytes = try!(file.read_exact(names_bytes as uint - 1));\n     let names_str = match str::from_utf8(bytes.as_slice()) {\n-        Some(s) => s.to_owned(),\n-        None => return Err(\"input not utf-8\".to_strbuf()),\n+        Some(s) => s.to_string(),\n+        None => return Err(\"input not utf-8\".to_string()),\n     };\n \n     let term_names: Vec<String> = names_str.as_slice()\n                                            .split('|')\n-                                           .map(|s| s.to_strbuf())\n+                                           .map(|s| s.to_string())\n                                            .collect();\n \n     try!(file.read_byte()); // consume NUL\n@@ -233,7 +233,7 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n         for i in range(0, bools_bytes) {\n             let b = try!(file.read_byte());\n             if b == 1 {\n-                bools_map.insert(bnames[i as uint].to_strbuf(), true);\n+                bools_map.insert(bnames[i as uint].to_string(), true);\n             }\n         }\n     }\n@@ -247,7 +247,7 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n         for i in range(0, numbers_count) {\n             let n = try!(file.read_le_u16());\n             if n != 0xFFFF {\n-                numbers_map.insert(nnames[i as uint].to_strbuf(), n);\n+                numbers_map.insert(nnames[i as uint].to_string(), n);\n             }\n         }\n     }\n@@ -264,7 +264,7 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n \n         if string_table.len() != string_table_bytes as uint {\n             return Err(\"error: hit EOF before end of string \\\n-                        table\".to_strbuf());\n+                        table\".to_string());\n         }\n \n         for (i, v) in string_offsets.iter().enumerate() {\n@@ -282,7 +282,7 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n             if offset == 0xFFFE {\n                 // undocumented: FFFE indicates cap@, which means the capability is not present\n                 // unsure if the handling for this is correct\n-                string_map.insert(name.to_strbuf(), Vec::new());\n+                string_map.insert(name.to_string(), Vec::new());\n                 continue;\n             }\n \n@@ -292,14 +292,14 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n                 .iter().position(|&b| b == 0);\n             match nulpos {\n                 Some(len) => {\n-                    string_map.insert(name.to_strbuf(),\n+                    string_map.insert(name.to_string(),\n                                       Vec::from_slice(\n                                           string_table.slice(offset as uint,\n                                           offset as uint + len)))\n                 },\n                 None => {\n                     return Err(\"invalid file: missing NUL in \\\n-                                string_table\".to_strbuf());\n+                                string_table\".to_string());\n                 }\n             };\n         }\n@@ -317,12 +317,12 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n /// Create a dummy TermInfo struct for msys terminals\n pub fn msys_terminfo() -> Box<TermInfo> {\n     let mut strings = HashMap::new();\n-    strings.insert(\"sgr0\".to_strbuf(), Vec::from_slice(bytes!(\"\\x1b[0m\")));\n-    strings.insert(\"bold\".to_strbuf(), Vec::from_slice(bytes!(\"\\x1b[1m\")));\n-    strings.insert(\"setaf\".to_strbuf(), Vec::from_slice(bytes!(\"\\x1b[3%p1%dm\")));\n-    strings.insert(\"setab\".to_strbuf(), Vec::from_slice(bytes!(\"\\x1b[4%p1%dm\")));\n+    strings.insert(\"sgr0\".to_string(), Vec::from_slice(bytes!(\"\\x1b[0m\")));\n+    strings.insert(\"bold\".to_string(), Vec::from_slice(bytes!(\"\\x1b[1m\")));\n+    strings.insert(\"setaf\".to_string(), Vec::from_slice(bytes!(\"\\x1b[3%p1%dm\")));\n+    strings.insert(\"setab\".to_string(), Vec::from_slice(bytes!(\"\\x1b[4%p1%dm\")));\n     box TermInfo {\n-        names: vec!(\"cygwin\".to_strbuf()), // msys is a fork of an older cygwin version\n+        names: vec!(\"cygwin\".to_string()), // msys is a fork of an older cygwin version\n         bools: HashMap::new(),\n         numbers: HashMap::new(),\n         strings: strings"}, {"sha": "84f0a4e3565f2c1e4085bbbc4141a8600532c55f", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -40,7 +40,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<Box<Path>> {\n                     if i == \"\" {\n                         dirs_to_search.push(Path::new(\"/usr/share/terminfo\"));\n                     } else {\n-                        dirs_to_search.push(Path::new(i.to_strbuf()));\n+                        dirs_to_search.push(Path::new(i.to_string()));\n                     }\n                 },\n                 // Found nothing in TERMINFO_DIRS, use the default paths:\n@@ -99,12 +99,12 @@ fn test_get_dbpath_for_term() {\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     fn x(t: &str) -> String {\n         let p = get_dbpath_for_term(t).expect(\"no terminfo entry found\");\n-        p.as_str().unwrap().to_strbuf()\n+        p.as_str().unwrap().to_string()\n     };\n-    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\".to_strbuf());\n+    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\".to_string());\n     assert!(get_dbpath_for_term(\"\") == None);\n     setenv(\"TERMINFO_DIRS\", \":\");\n-    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\".to_strbuf());\n+    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\".to_string());\n     unsetenv(\"TERMINFO_DIRS\");\n }\n "}, {"sha": "f02bc144d153cd6cbcdea5116f61f120a58bd76d", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -110,7 +110,7 @@ impl TestDesc {\n         use std::num::Saturating;\n         let mut name = String::from_str(self.name.as_slice());\n         let fill = column_count.saturating_sub(name.len());\n-        let mut pad = String::from_owned_str(\" \".repeat(fill));\n+        let mut pad = \" \".repeat(fill);\n         match align {\n             PadNone => name,\n             PadOnLeft => {\n@@ -266,7 +266,7 @@ pub fn test_main_static(args: &[String], tests: &[TestDescAndFn]) {\n \n pub fn test_main_static_x(args: &[~str], tests: &[TestDescAndFn]) {\n     test_main_static(args.iter()\n-                         .map(|x| x.to_strbuf())\n+                         .map(|x| x.to_string())\n                          .collect::<Vec<_>>()\n                          .as_slice(),\n                      tests)\n@@ -365,7 +365,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n     let matches =\n         match getopts::getopts(args_.as_slice(), optgroups().as_slice()) {\n           Ok(m) => m,\n-          Err(f) => return Some(Err(f.to_err_msg().to_strbuf()))\n+          Err(f) => return Some(Err(f.to_err_msg().to_string()))\n         };\n \n     if matches.opt_present(\"h\") { usage(args[0].as_slice()); return None; }\n@@ -400,7 +400,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n     let save_metrics = save_metrics.map(|s| Path::new(s));\n \n     let test_shard = matches.opt_str(\"test-shard\");\n-    let test_shard = opt_shard(test_shard.map(|x| x.to_strbuf()));\n+    let test_shard = opt_shard(test_shard.map(|x| x.to_string()));\n \n     let mut nocapture = matches.opt_present(\"nocapture\");\n     if !nocapture {\n@@ -602,9 +602,9 @@ impl<T: Writer> ConsoleTestState<T> {\n             None => Ok(()),\n             Some(ref mut o) => {\n                 let s = format!(\"{} {}\\n\", match *result {\n-                        TrOk => \"ok\".to_strbuf(),\n-                        TrFailed => \"failed\".to_strbuf(),\n-                        TrIgnored => \"ignored\".to_strbuf(),\n+                        TrOk => \"ok\".to_string(),\n+                        TrFailed => \"failed\".to_string(),\n+                        TrIgnored => \"ignored\".to_string(),\n                         TrMetrics(ref mm) => fmt_metrics(mm),\n                         TrBench(ref bs) => fmt_bench_samples(bs)\n                     }, test.name.as_slice());\n@@ -744,7 +744,7 @@ pub fn fmt_metrics(mm: &MetricMap) -> String {\n                           v.value as f64,\n                           v.noise as f64))\n         .collect();\n-    v.connect(\", \").to_strbuf()\n+    v.connect(\", \").to_string()\n }\n \n pub fn fmt_bench_samples(bs: &BenchSamples) -> String {\n@@ -1026,8 +1026,8 @@ pub fn run_test(opts: &TestOpts,\n             let stdout = ChanWriter::new(tx.clone());\n             let stderr = ChanWriter::new(tx);\n             let mut task = TaskBuilder::new().named(match desc.name {\n-                DynTestName(ref name) => name.clone().to_owned(),\n-                StaticTestName(name) => name.to_owned(),\n+                DynTestName(ref name) => name.clone().to_string(),\n+                StaticTestName(name) => name.to_string(),\n             });\n             if nocapture {\n                 drop((stdout, stderr));\n@@ -1088,8 +1088,8 @@ fn calc_result(desc: &TestDesc, task_succeeded: bool) -> TestResult {\n impl ToJson for Metric {\n     fn to_json(&self) -> json::Json {\n         let mut map = box TreeMap::new();\n-        map.insert(\"value\".to_strbuf(), json::Number(self.value));\n-        map.insert(\"noise\".to_strbuf(), json::Number(self.noise));\n+        map.insert(\"value\".to_string(), json::Number(self.value));\n+        map.insert(\"noise\".to_string(), json::Number(self.noise));\n         json::Object(map)\n     }\n }\n@@ -1126,7 +1126,7 @@ impl MetricMap {\n         // FIXME(pcwalton): Yuck.\n         let mut new_map = TreeMap::new();\n         for (ref key, ref value) in map.iter() {\n-            new_map.insert(key.to_strbuf(), (*value).clone());\n+            new_map.insert(key.to_string(), (*value).clone());\n         }\n \n         new_map.to_json().to_pretty_writer(&mut file)\n@@ -1208,7 +1208,7 @@ impl MetricMap {\n             noise: noise\n         };\n         let MetricMap(ref mut map) = *self;\n-        map.insert(name.to_strbuf(), m);\n+        map.insert(name.to_string(), m);\n     }\n \n     /// Attempt to \"ratchet\" an external metric file. This involves loading\n@@ -1454,7 +1454,7 @@ mod tests {\n \n     #[test]\n     fn first_free_arg_should_be_a_filter() {\n-        let args = vec!(\"progname\".to_strbuf(), \"some_regex_filter\".to_strbuf());\n+        let args = vec!(\"progname\".to_string(), \"some_regex_filter\".to_string());\n         let opts = match parse_opts(args.as_slice()) {\n             Some(Ok(o)) => o,\n             _ => fail!(\"Malformed arg in first_free_arg_should_be_a_filter\")\n@@ -1464,9 +1464,9 @@ mod tests {\n \n     #[test]\n     fn parse_ignored_flag() {\n-        let args = vec!(\"progname\".to_strbuf(),\n-                        \"filter\".to_strbuf(),\n-                        \"--ignored\".to_strbuf());\n+        let args = vec!(\"progname\".to_string(),\n+                        \"filter\".to_string(),\n+                        \"--ignored\".to_string());\n         let opts = match parse_opts(args.as_slice()) {\n             Some(Ok(o)) => o,\n             _ => fail!(\"Malformed arg in parse_ignored_flag\")\n@@ -1503,8 +1503,8 @@ mod tests {\n         let filtered = filter_tests(&opts, tests);\n \n         assert_eq!(filtered.len(), 1);\n-        assert_eq!(filtered.get(0).desc.name.to_str().to_strbuf(),\n-                   \"1\".to_strbuf());\n+        assert_eq!(filtered.get(0).desc.name.to_str().to_string(),\n+                   \"1\".to_string());\n         assert!(filtered.get(0).desc.ignore == false);\n     }\n \n@@ -1514,15 +1514,15 @@ mod tests {\n         opts.run_tests = true;\n \n         let names =\n-            vec!(\"sha1::test\".to_strbuf(),\n-                 \"int::test_to_str\".to_strbuf(),\n-                 \"int::test_pow\".to_strbuf(),\n-                 \"test::do_not_run_ignored_tests\".to_strbuf(),\n-                 \"test::ignored_tests_result_in_ignored\".to_strbuf(),\n-                 \"test::first_free_arg_should_be_a_filter\".to_strbuf(),\n-                 \"test::parse_ignored_flag\".to_strbuf(),\n-                 \"test::filter_for_ignored_option\".to_strbuf(),\n-                 \"test::sort_tests\".to_strbuf());\n+            vec!(\"sha1::test\".to_string(),\n+                 \"int::test_to_str\".to_string(),\n+                 \"int::test_pow\".to_string(),\n+                 \"test::do_not_run_ignored_tests\".to_string(),\n+                 \"test::ignored_tests_result_in_ignored\".to_string(),\n+                 \"test::first_free_arg_should_be_a_filter\".to_string(),\n+                 \"test::parse_ignored_flag\".to_string(),\n+                 \"test::filter_for_ignored_option\".to_string(),\n+                 \"test::sort_tests\".to_string());\n         let tests =\n         {\n             fn testfn() { }\n@@ -1543,18 +1543,18 @@ mod tests {\n         let filtered = filter_tests(&opts, tests);\n \n         let expected =\n-            vec!(\"int::test_pow\".to_strbuf(),\n-                 \"int::test_to_str\".to_strbuf(),\n-                 \"sha1::test\".to_strbuf(),\n-                 \"test::do_not_run_ignored_tests\".to_strbuf(),\n-                 \"test::filter_for_ignored_option\".to_strbuf(),\n-                 \"test::first_free_arg_should_be_a_filter\".to_strbuf(),\n-                 \"test::ignored_tests_result_in_ignored\".to_strbuf(),\n-                 \"test::parse_ignored_flag\".to_strbuf(),\n-                 \"test::sort_tests\".to_strbuf());\n+            vec!(\"int::test_pow\".to_string(),\n+                 \"int::test_to_str\".to_string(),\n+                 \"sha1::test\".to_string(),\n+                 \"test::do_not_run_ignored_tests\".to_string(),\n+                 \"test::filter_for_ignored_option\".to_string(),\n+                 \"test::first_free_arg_should_be_a_filter\".to_string(),\n+                 \"test::ignored_tests_result_in_ignored\".to_string(),\n+                 \"test::parse_ignored_flag\".to_string(),\n+                 \"test::sort_tests\".to_string());\n \n         for (a, b) in expected.iter().zip(filtered.iter()) {\n-            assert!(*a == b.desc.name.to_str().to_strbuf());\n+            assert!(*a == b.desc.name.to_str().to_string());\n         }\n     }\n \n@@ -1571,7 +1571,7 @@ mod tests {\n         let tests = names.iter().map(|name| {\n             TestDescAndFn {\n                 desc: TestDesc {\n-                    name: DynTestName(name.to_strbuf()),\n+                    name: DynTestName(name.to_string()),\n                     ignore: false,\n                     should_fail: false\n                 },\n@@ -1613,31 +1613,31 @@ mod tests {\n \n         let diff1 = m2.compare_to_old(&m1, None);\n \n-        assert_eq!(*(diff1.find(&\"in-both-noise\".to_strbuf()).unwrap()), LikelyNoise);\n-        assert_eq!(*(diff1.find(&\"in-first-noise\".to_strbuf()).unwrap()), MetricRemoved);\n-        assert_eq!(*(diff1.find(&\"in-second-noise\".to_strbuf()).unwrap()), MetricAdded);\n-        assert_eq!(*(diff1.find(&\"in-both-want-downwards-but-regressed\".to_strbuf()).unwrap()),\n+        assert_eq!(*(diff1.find(&\"in-both-noise\".to_string()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff1.find(&\"in-first-noise\".to_string()).unwrap()), MetricRemoved);\n+        assert_eq!(*(diff1.find(&\"in-second-noise\".to_string()).unwrap()), MetricAdded);\n+        assert_eq!(*(diff1.find(&\"in-both-want-downwards-but-regressed\".to_string()).unwrap()),\n                    Regression(100.0));\n-        assert_eq!(*(diff1.find(&\"in-both-want-downwards-and-improved\".to_strbuf()).unwrap()),\n+        assert_eq!(*(diff1.find(&\"in-both-want-downwards-and-improved\".to_string()).unwrap()),\n                    Improvement(50.0));\n-        assert_eq!(*(diff1.find(&\"in-both-want-upwards-but-regressed\".to_strbuf()).unwrap()),\n+        assert_eq!(*(diff1.find(&\"in-both-want-upwards-but-regressed\".to_string()).unwrap()),\n                    Regression(50.0));\n-        assert_eq!(*(diff1.find(&\"in-both-want-upwards-and-improved\".to_strbuf()).unwrap()),\n+        assert_eq!(*(diff1.find(&\"in-both-want-upwards-and-improved\".to_string()).unwrap()),\n                    Improvement(100.0));\n         assert_eq!(diff1.len(), 7);\n \n         let diff2 = m2.compare_to_old(&m1, Some(200.0));\n \n-        assert_eq!(*(diff2.find(&\"in-both-noise\".to_strbuf()).unwrap()), LikelyNoise);\n-        assert_eq!(*(diff2.find(&\"in-first-noise\".to_strbuf()).unwrap()), MetricRemoved);\n-        assert_eq!(*(diff2.find(&\"in-second-noise\".to_strbuf()).unwrap()), MetricAdded);\n-        assert_eq!(*(diff2.find(&\"in-both-want-downwards-but-regressed\".to_strbuf()).unwrap()),\n+        assert_eq!(*(diff2.find(&\"in-both-noise\".to_string()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&\"in-first-noise\".to_string()).unwrap()), MetricRemoved);\n+        assert_eq!(*(diff2.find(&\"in-second-noise\".to_string()).unwrap()), MetricAdded);\n+        assert_eq!(*(diff2.find(&\"in-both-want-downwards-but-regressed\".to_string()).unwrap()),\n                    LikelyNoise);\n-        assert_eq!(*(diff2.find(&\"in-both-want-downwards-and-improved\".to_strbuf()).unwrap()),\n+        assert_eq!(*(diff2.find(&\"in-both-want-downwards-and-improved\".to_string()).unwrap()),\n                    LikelyNoise);\n-        assert_eq!(*(diff2.find(&\"in-both-want-upwards-but-regressed\".to_strbuf()).unwrap()),\n+        assert_eq!(*(diff2.find(&\"in-both-want-upwards-but-regressed\".to_string()).unwrap()),\n                    LikelyNoise);\n-        assert_eq!(*(diff2.find(&\"in-both-want-upwards-and-improved\".to_strbuf()).unwrap()),\n+        assert_eq!(*(diff2.find(&\"in-both-want-upwards-and-improved\".to_string()).unwrap()),\n                    LikelyNoise);\n         assert_eq!(diff2.len(), 7);\n     }\n@@ -1662,29 +1662,29 @@ mod tests {\n         let (diff1, ok1) = m2.ratchet(&pth, None);\n         assert_eq!(ok1, false);\n         assert_eq!(diff1.len(), 2);\n-        assert_eq!(*(diff1.find(&\"runtime\".to_strbuf()).unwrap()), Regression(10.0));\n-        assert_eq!(*(diff1.find(&\"throughput\".to_strbuf()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff1.find(&\"runtime\".to_string()).unwrap()), Regression(10.0));\n+        assert_eq!(*(diff1.find(&\"throughput\".to_string()).unwrap()), LikelyNoise);\n \n         // Check that it was not rewritten.\n         let m3 = MetricMap::load(&pth);\n         let MetricMap(m3) = m3;\n         assert_eq!(m3.len(), 2);\n-        assert_eq!(*(m3.find(&\"runtime\".to_strbuf()).unwrap()), Metric::new(1000.0, 2.0));\n-        assert_eq!(*(m3.find(&\"throughput\".to_strbuf()).unwrap()), Metric::new(50.0, 2.0));\n+        assert_eq!(*(m3.find(&\"runtime\".to_string()).unwrap()), Metric::new(1000.0, 2.0));\n+        assert_eq!(*(m3.find(&\"throughput\".to_string()).unwrap()), Metric::new(50.0, 2.0));\n \n         // Ask for a ratchet with an explicit noise-percentage override,\n         // that should advance.\n         let (diff2, ok2) = m2.ratchet(&pth, Some(10.0));\n         assert_eq!(ok2, true);\n         assert_eq!(diff2.len(), 2);\n-        assert_eq!(*(diff2.find(&\"runtime\".to_strbuf()).unwrap()), LikelyNoise);\n-        assert_eq!(*(diff2.find(&\"throughput\".to_strbuf()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&\"runtime\".to_string()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&\"throughput\".to_string()).unwrap()), LikelyNoise);\n \n         // Check that it was rewritten.\n         let m4 = MetricMap::load(&pth);\n         let MetricMap(m4) = m4;\n         assert_eq!(m4.len(), 2);\n-        assert_eq!(*(m4.find(&\"runtime\".to_strbuf()).unwrap()), Metric::new(1100.0, 2.0));\n-        assert_eq!(*(m4.find(&\"throughput\".to_strbuf()).unwrap()), Metric::new(50.0, 2.0));\n+        assert_eq!(*(m4.find(&\"runtime\".to_string()).unwrap()), Metric::new(1100.0, 2.0));\n+        assert_eq!(*(m4.find(&\"throughput\".to_string()).unwrap()), Metric::new(50.0, 2.0));\n     }\n }"}, {"sha": "77b1eae0a56c6db6b2ca26dcc217b182c24ad230", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -1032,16 +1032,16 @@ mod tests {\n             use std::io::MemWriter;\n             let mut m = MemWriter::new();\n             write_boxplot(&mut m as &mut io::Writer, s, 30).unwrap();\n-            let out = str::from_utf8(m.unwrap().as_slice()).unwrap().to_strbuf();\n+            let out = str::from_utf8(m.unwrap().as_slice()).unwrap().to_string();\n             assert_eq!(out, expected);\n         }\n \n         t(&Summary::new([-2.0, -1.0]),\n-                        \"-2 |[------******#*****---]| -1\".to_strbuf());\n+                        \"-2 |[------******#*****---]| -1\".to_string());\n         t(&Summary::new([0.0, 2.0]),\n-                        \"0 |[-------*****#*******---]| 2\".to_strbuf());\n+                        \"0 |[-------*****#*******---]| 2\".to_string());\n         t(&Summary::new([-2.0, 0.0]),\n-                        \"-2 |[------******#******---]| 0\".to_strbuf());\n+                        \"-2 |[------******#******---]| 0\".to_string());\n \n     }\n     #[test]"}, {"sha": "743ad823eb367de4948b3b96c6bfc98235bfaf6d", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 209, "deletions": 209, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -477,62 +477,62 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n       -> Result<uint, String> {\n         match ch {\n           'A' => match match_strs(s, pos, [\n-              (\"Sunday\".to_strbuf(), 0_i32),\n-              (\"Monday\".to_strbuf(), 1_i32),\n-              (\"Tuesday\".to_strbuf(), 2_i32),\n-              (\"Wednesday\".to_strbuf(), 3_i32),\n-              (\"Thursday\".to_strbuf(), 4_i32),\n-              (\"Friday\".to_strbuf(), 5_i32),\n-              (\"Saturday\".to_strbuf(), 6_i32)\n+              (\"Sunday\".to_string(), 0_i32),\n+              (\"Monday\".to_string(), 1_i32),\n+              (\"Tuesday\".to_string(), 2_i32),\n+              (\"Wednesday\".to_string(), 3_i32),\n+              (\"Thursday\".to_string(), 4_i32),\n+              (\"Friday\".to_string(), 5_i32),\n+              (\"Saturday\".to_string(), 6_i32)\n           ]) {\n             Some(item) => { let (v, pos) = item; tm.tm_wday = v; Ok(pos) }\n-            None => Err(\"Invalid day\".to_strbuf())\n+            None => Err(\"Invalid day\".to_string())\n           },\n           'a' => match match_strs(s, pos, [\n-              (\"Sun\".to_strbuf(), 0_i32),\n-              (\"Mon\".to_strbuf(), 1_i32),\n-              (\"Tue\".to_strbuf(), 2_i32),\n-              (\"Wed\".to_strbuf(), 3_i32),\n-              (\"Thu\".to_strbuf(), 4_i32),\n-              (\"Fri\".to_strbuf(), 5_i32),\n-              (\"Sat\".to_strbuf(), 6_i32)\n+              (\"Sun\".to_string(), 0_i32),\n+              (\"Mon\".to_string(), 1_i32),\n+              (\"Tue\".to_string(), 2_i32),\n+              (\"Wed\".to_string(), 3_i32),\n+              (\"Thu\".to_string(), 4_i32),\n+              (\"Fri\".to_string(), 5_i32),\n+              (\"Sat\".to_string(), 6_i32)\n           ]) {\n             Some(item) => { let (v, pos) = item; tm.tm_wday = v; Ok(pos) }\n-            None => Err(\"Invalid day\".to_strbuf())\n+            None => Err(\"Invalid day\".to_string())\n           },\n           'B' => match match_strs(s, pos, [\n-              (\"January\".to_strbuf(), 0_i32),\n-              (\"February\".to_strbuf(), 1_i32),\n-              (\"March\".to_strbuf(), 2_i32),\n-              (\"April\".to_strbuf(), 3_i32),\n-              (\"May\".to_strbuf(), 4_i32),\n-              (\"June\".to_strbuf(), 5_i32),\n-              (\"July\".to_strbuf(), 6_i32),\n-              (\"August\".to_strbuf(), 7_i32),\n-              (\"September\".to_strbuf(), 8_i32),\n-              (\"October\".to_strbuf(), 9_i32),\n-              (\"November\".to_strbuf(), 10_i32),\n-              (\"December\".to_strbuf(), 11_i32)\n+              (\"January\".to_string(), 0_i32),\n+              (\"February\".to_string(), 1_i32),\n+              (\"March\".to_string(), 2_i32),\n+              (\"April\".to_string(), 3_i32),\n+              (\"May\".to_string(), 4_i32),\n+              (\"June\".to_string(), 5_i32),\n+              (\"July\".to_string(), 6_i32),\n+              (\"August\".to_string(), 7_i32),\n+              (\"September\".to_string(), 8_i32),\n+              (\"October\".to_string(), 9_i32),\n+              (\"November\".to_string(), 10_i32),\n+              (\"December\".to_string(), 11_i32)\n           ]) {\n             Some(item) => { let (v, pos) = item; tm.tm_mon = v; Ok(pos) }\n-            None => Err(\"Invalid month\".to_strbuf())\n+            None => Err(\"Invalid month\".to_string())\n           },\n           'b' | 'h' => match match_strs(s, pos, [\n-              (\"Jan\".to_strbuf(), 0_i32),\n-              (\"Feb\".to_strbuf(), 1_i32),\n-              (\"Mar\".to_strbuf(), 2_i32),\n-              (\"Apr\".to_strbuf(), 3_i32),\n-              (\"May\".to_strbuf(), 4_i32),\n-              (\"Jun\".to_strbuf(), 5_i32),\n-              (\"Jul\".to_strbuf(), 6_i32),\n-              (\"Aug\".to_strbuf(), 7_i32),\n-              (\"Sep\".to_strbuf(), 8_i32),\n-              (\"Oct\".to_strbuf(), 9_i32),\n-              (\"Nov\".to_strbuf(), 10_i32),\n-              (\"Dec\".to_strbuf(), 11_i32)\n+              (\"Jan\".to_string(), 0_i32),\n+              (\"Feb\".to_string(), 1_i32),\n+              (\"Mar\".to_string(), 2_i32),\n+              (\"Apr\".to_string(), 3_i32),\n+              (\"May\".to_string(), 4_i32),\n+              (\"Jun\".to_string(), 5_i32),\n+              (\"Jul\".to_string(), 6_i32),\n+              (\"Aug\".to_string(), 7_i32),\n+              (\"Sep\".to_string(), 8_i32),\n+              (\"Oct\".to_string(), 9_i32),\n+              (\"Nov\".to_string(), 10_i32),\n+              (\"Dec\".to_string(), 11_i32)\n           ]) {\n             Some(item) => { let (v, pos) = item; tm.tm_mon = v; Ok(pos) }\n-            None => Err(\"Invalid month\".to_strbuf())\n+            None => Err(\"Invalid month\".to_string())\n           },\n           'C' => match match_digits_in_range(s, pos, 2u, false, 0_i32,\n                                              99_i32) {\n@@ -541,7 +541,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n                   tm.tm_year += (v * 100_i32) - 1900_i32;\n                   Ok(pos)\n               }\n-            None => Err(\"Invalid year\".to_strbuf())\n+            None => Err(\"Invalid year\".to_string())\n           },\n           'c' => {\n             parse_type(s, pos, 'a', &mut *tm)\n@@ -564,12 +564,12 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n           'd' => match match_digits_in_range(s, pos, 2u, false, 1_i32,\n                                              31_i32) {\n             Some(item) => { let (v, pos) = item; tm.tm_mday = v; Ok(pos) }\n-            None => Err(\"Invalid day of the month\".to_strbuf())\n+            None => Err(\"Invalid day of the month\".to_string())\n           },\n           'e' => match match_digits_in_range(s, pos, 2u, true, 1_i32,\n                                              31_i32) {\n             Some(item) => { let (v, pos) = item; tm.tm_mday = v; Ok(pos) }\n-            None => Err(\"Invalid day of the month\".to_strbuf())\n+            None => Err(\"Invalid day of the month\".to_string())\n           },\n           'f' => {\n             let (val, pos) = match_fractional_seconds(s, pos);\n@@ -586,7 +586,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n           'H' => {\n             match match_digits_in_range(s, pos, 2u, false, 0_i32, 23_i32) {\n               Some(item) => { let (v, pos) = item; tm.tm_hour = v; Ok(pos) }\n-              None => Err(\"Invalid hour\".to_strbuf())\n+              None => Err(\"Invalid hour\".to_string())\n             }\n           }\n           'I' => {\n@@ -596,7 +596,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n                   tm.tm_hour = if v == 12_i32 { 0_i32 } else { v };\n                   Ok(pos)\n               }\n-              None => Err(\"Invalid hour\".to_strbuf())\n+              None => Err(\"Invalid hour\".to_string())\n             }\n           }\n           'j' => {\n@@ -606,13 +606,13 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n                 tm.tm_yday = v - 1_i32;\n                 Ok(pos)\n               }\n-              None => Err(\"Invalid day of year\".to_strbuf())\n+              None => Err(\"Invalid day of year\".to_string())\n             }\n           }\n           'k' => {\n             match match_digits_in_range(s, pos, 2u, true, 0_i32, 23_i32) {\n               Some(item) => { let (v, pos) = item; tm.tm_hour = v; Ok(pos) }\n-              None => Err(\"Invalid hour\".to_strbuf())\n+              None => Err(\"Invalid hour\".to_string())\n             }\n           }\n           'l' => {\n@@ -622,13 +622,13 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n                   tm.tm_hour = if v == 12_i32 { 0_i32 } else { v };\n                   Ok(pos)\n               }\n-              None => Err(\"Invalid hour\".to_strbuf())\n+              None => Err(\"Invalid hour\".to_string())\n             }\n           }\n           'M' => {\n             match match_digits_in_range(s, pos, 2u, false, 0_i32, 59_i32) {\n               Some(item) => { let (v, pos) = item; tm.tm_min = v; Ok(pos) }\n-              None => Err(\"Invalid minute\".to_strbuf())\n+              None => Err(\"Invalid minute\".to_string())\n             }\n           }\n           'm' => {\n@@ -638,21 +638,21 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n                 tm.tm_mon = v - 1_i32;\n                 Ok(pos)\n               }\n-              None => Err(\"Invalid month\".to_strbuf())\n+              None => Err(\"Invalid month\".to_string())\n             }\n           }\n           'n' => parse_char(s, pos, '\\n'),\n           'P' => match match_strs(s, pos,\n-                                  [(\"am\".to_strbuf(), 0_i32), (\"pm\".to_strbuf(), 12_i32)]) {\n+                                  [(\"am\".to_string(), 0_i32), (\"pm\".to_string(), 12_i32)]) {\n \n             Some(item) => { let (v, pos) = item; tm.tm_hour += v; Ok(pos) }\n-            None => Err(\"Invalid hour\".to_strbuf())\n+            None => Err(\"Invalid hour\".to_string())\n           },\n           'p' => match match_strs(s, pos,\n-                                  [(\"AM\".to_strbuf(), 0_i32), (\"PM\".to_strbuf(), 12_i32)]) {\n+                                  [(\"AM\".to_string(), 0_i32), (\"PM\".to_string(), 12_i32)]) {\n \n             Some(item) => { let (v, pos) = item; tm.tm_hour += v; Ok(pos) }\n-            None => Err(\"Invalid hour\".to_strbuf())\n+            None => Err(\"Invalid hour\".to_string())\n           },\n           'R' => {\n             parse_type(s, pos, 'H', &mut *tm)\n@@ -675,7 +675,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n                 tm.tm_sec = v;\n                 Ok(pos)\n               }\n-              None => Err(\"Invalid second\".to_strbuf())\n+              None => Err(\"Invalid second\".to_string())\n             }\n           }\n           //'s' {}\n@@ -694,7 +694,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n                 tm.tm_wday = if v == 7 { 0 } else { v };\n                 Ok(pos)\n               }\n-              None => Err(\"Invalid day of week\".to_strbuf())\n+              None => Err(\"Invalid day of week\".to_string())\n             }\n           }\n           'v' => {\n@@ -708,7 +708,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n           'w' => {\n             match match_digits_in_range(s, pos, 1u, false, 0_i32, 6_i32) {\n               Some(item) => { let (v, pos) = item; tm.tm_wday = v; Ok(pos) }\n-              None => Err(\"Invalid day of week\".to_strbuf())\n+              None => Err(\"Invalid day of week\".to_string())\n             }\n           }\n           'Y' => {\n@@ -718,7 +718,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n                 tm.tm_year = v - 1900_i32;\n                 Ok(pos)\n               }\n-              None => Err(\"Invalid year\".to_strbuf())\n+              None => Err(\"Invalid year\".to_string())\n             }\n           }\n           'y' => {\n@@ -728,7 +728,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n                 tm.tm_year = v;\n                 Ok(pos)\n               }\n-              None => Err(\"Invalid year\".to_strbuf())\n+              None => Err(\"Invalid year\".to_string())\n             }\n           }\n           'Z' => {\n@@ -762,10 +762,10 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n \n                     Ok(pos)\n                   }\n-                  None => Err(\"Invalid zone offset\".to_strbuf())\n+                  None => Err(\"Invalid zone offset\".to_string())\n                 }\n             } else {\n-                Err(\"Invalid zone offset\".to_strbuf())\n+                Err(\"Invalid zone offset\".to_string())\n             }\n           }\n           '%' => parse_char(s, pos, '%'),\n@@ -792,7 +792,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n     };\n     let mut pos = 0u;\n     let len = s.len();\n-    let mut result = Err(\"Invalid time\".to_strbuf());\n+    let mut result = Err(\"Invalid time\".to_string());\n \n     while pos < len {\n         let range = s.char_range_at(pos);\n@@ -890,7 +890,7 @@ pub fn strftime(format: &str, tm: &Tm) -> String {\n             'G' => format_strbuf!(\"{}\", year),\n             'g' => format_strbuf!(\"{:02d}\", (year % 100 + 100) % 100),\n             'V' => format_strbuf!(\"{:02d}\", days / 7 + 1),\n-            _ => \"\".to_strbuf()\n+            _ => \"\".to_string()\n         }\n     }\n \n@@ -900,53 +900,53 @@ pub fn strftime(format: &str, tm: &Tm) -> String {\n       };\n         match ch {\n           'A' => match tm.tm_wday as int {\n-            0 => \"Sunday\".to_strbuf(),\n-            1 => \"Monday\".to_strbuf(),\n-            2 => \"Tuesday\".to_strbuf(),\n-            3 => \"Wednesday\".to_strbuf(),\n-            4 => \"Thursday\".to_strbuf(),\n-            5 => \"Friday\".to_strbuf(),\n-            6 => \"Saturday\".to_strbuf(),\n+            0 => \"Sunday\".to_string(),\n+            1 => \"Monday\".to_string(),\n+            2 => \"Tuesday\".to_string(),\n+            3 => \"Wednesday\".to_string(),\n+            4 => \"Thursday\".to_string(),\n+            5 => \"Friday\".to_string(),\n+            6 => \"Saturday\".to_string(),\n             _ => die()\n           },\n          'a' => match tm.tm_wday as int {\n-            0 => \"Sun\".to_strbuf(),\n-            1 => \"Mon\".to_strbuf(),\n-            2 => \"Tue\".to_strbuf(),\n-            3 => \"Wed\".to_strbuf(),\n-            4 => \"Thu\".to_strbuf(),\n-            5 => \"Fri\".to_strbuf(),\n-            6 => \"Sat\".to_strbuf(),\n+            0 => \"Sun\".to_string(),\n+            1 => \"Mon\".to_string(),\n+            2 => \"Tue\".to_string(),\n+            3 => \"Wed\".to_string(),\n+            4 => \"Thu\".to_string(),\n+            5 => \"Fri\".to_string(),\n+            6 => \"Sat\".to_string(),\n             _ => die()\n           },\n           'B' => match tm.tm_mon as int {\n-            0 => \"January\".to_strbuf(),\n-            1 => \"February\".to_strbuf(),\n-            2 => \"March\".to_strbuf(),\n-            3 => \"April\".to_strbuf(),\n-            4 => \"May\".to_strbuf(),\n-            5 => \"June\".to_strbuf(),\n-            6 => \"July\".to_strbuf(),\n-            7 => \"August\".to_strbuf(),\n-            8 => \"September\".to_strbuf(),\n-            9 => \"October\".to_strbuf(),\n-            10 => \"November\".to_strbuf(),\n-            11 => \"December\".to_strbuf(),\n+            0 => \"January\".to_string(),\n+            1 => \"February\".to_string(),\n+            2 => \"March\".to_string(),\n+            3 => \"April\".to_string(),\n+            4 => \"May\".to_string(),\n+            5 => \"June\".to_string(),\n+            6 => \"July\".to_string(),\n+            7 => \"August\".to_string(),\n+            8 => \"September\".to_string(),\n+            9 => \"October\".to_string(),\n+            10 => \"November\".to_string(),\n+            11 => \"December\".to_string(),\n             _ => die()\n           },\n           'b' | 'h' => match tm.tm_mon as int {\n-            0 => \"Jan\".to_strbuf(),\n-            1 => \"Feb\".to_strbuf(),\n-            2 => \"Mar\".to_strbuf(),\n-            3 => \"Apr\".to_strbuf(),\n-            4 => \"May\".to_strbuf(),\n-            5 => \"Jun\".to_strbuf(),\n-            6 => \"Jul\".to_strbuf(),\n-            7 => \"Aug\".to_strbuf(),\n-            8 => \"Sep\".to_strbuf(),\n-            9 => \"Oct\".to_strbuf(),\n-            10 => \"Nov\".to_strbuf(),\n-            11 => \"Dec\".to_strbuf(),\n+            0 => \"Jan\".to_string(),\n+            1 => \"Feb\".to_string(),\n+            2 => \"Mar\".to_string(),\n+            3 => \"Apr\".to_string(),\n+            4 => \"May\".to_string(),\n+            5 => \"Jun\".to_string(),\n+            6 => \"Jul\".to_string(),\n+            7 => \"Aug\".to_string(),\n+            8 => \"Sep\".to_string(),\n+            9 => \"Oct\".to_string(),\n+            10 => \"Nov\".to_string(),\n+            11 => \"Dec\".to_string(),\n             _  => die()\n           },\n           'C' => format_strbuf!(\"{:02d}\", (tm.tm_year as int + 1900) / 100),\n@@ -992,9 +992,9 @@ pub fn strftime(format: &str, tm: &Tm) -> String {\n           }\n           'M' => format_strbuf!(\"{:02d}\", tm.tm_min),\n           'm' => format_strbuf!(\"{:02d}\", tm.tm_mon + 1),\n-          'n' => \"\\n\".to_strbuf(),\n-          'P' => if (tm.tm_hour as int) < 12 { \"am\".to_strbuf() } else { \"pm\".to_strbuf() },\n-          'p' => if (tm.tm_hour as int) < 12 { \"AM\".to_strbuf() } else { \"PM\".to_strbuf() },\n+          'n' => \"\\n\".to_string(),\n+          'P' => if (tm.tm_hour as int) < 12 { \"am\".to_string() } else { \"pm\".to_string() },\n+          'p' => if (tm.tm_hour as int) < 12 { \"AM\".to_string() } else { \"PM\".to_string() },\n           'R' => {\n             format_strbuf!(\"{}:{}\",\n                 parse_type('H', tm),\n@@ -1015,11 +1015,11 @@ pub fn strftime(format: &str, tm: &Tm) -> String {\n                 parse_type('M', tm),\n                 parse_type('S', tm))\n           }\n-          't' => \"\\t\".to_strbuf(),\n+          't' => \"\\t\".to_string(),\n           'U' => format_strbuf!(\"{:02d}\", (tm.tm_yday - tm.tm_wday + 7) / 7),\n           'u' => {\n             let i = tm.tm_wday as int;\n-            (if i == 0 { 7 } else { i }).to_str().to_strbuf()\n+            (if i == 0 { 7 } else { i }).to_str().to_string()\n           }\n           'V' => iso_week('V', tm),\n           'v' => {\n@@ -1032,10 +1032,10 @@ pub fn strftime(format: &str, tm: &Tm) -> String {\n               format_strbuf!(\"{:02d}\",\n                              (tm.tm_yday - (tm.tm_wday - 1 + 7) % 7 + 7) / 7)\n           }\n-          'w' => (tm.tm_wday as int).to_str().to_strbuf(),\n-          'Y' => (tm.tm_year as int + 1900).to_str().to_strbuf(),\n+          'w' => (tm.tm_wday as int).to_str().to_string(),\n+          'Y' => (tm.tm_year as int + 1900).to_str().to_string(),\n           'y' => format_strbuf!(\"{:02d}\", (tm.tm_year as int + 1900) % 100),\n-          'Z' => \"\".to_strbuf(),    // FIXME(pcwalton): Implement this.\n+          'Z' => \"\".to_string(),    // FIXME(pcwalton): Implement this.\n           'z' => {\n             let sign = if tm.tm_gmtoff > 0_i32 { '+' } else { '-' };\n             let mut m = num::abs(tm.tm_gmtoff) / 60_i32;\n@@ -1044,7 +1044,7 @@ pub fn strftime(format: &str, tm: &Tm) -> String {\n             format_strbuf!(\"{}{:02d}{:02d}\", sign, h, m)\n           }\n           '+' => tm.rfc3339(),\n-          '%' => \"%\".to_strbuf(),\n+          '%' => \"%\".to_string(),\n           _   => die()\n         }\n     }\n@@ -1068,7 +1068,7 @@ pub fn strftime(format: &str, tm: &Tm) -> String {\n         }\n     }\n \n-    str::from_utf8(buf.as_slice()).unwrap().to_strbuf()\n+    str::from_utf8(buf.as_slice()).unwrap().to_string()\n }\n \n #[cfg(test)]\n@@ -1230,9 +1230,9 @@ mod tests {\n         }\n \n         let format = \"%a %b %e %T.%f %Y\";\n-        assert_eq!(strptime(\"\", format), Err(\"Invalid time\".to_strbuf()));\n+        assert_eq!(strptime(\"\", format), Err(\"Invalid time\".to_string()));\n         assert!(strptime(\"Fri Feb 13 15:31:30\", format)\n-            == Err(\"Invalid time\".to_strbuf()));\n+            == Err(\"Invalid time\".to_string()));\n \n         match strptime(\"Fri Feb 13 15:31:30.01234 2009\", format) {\n           Err(e) => fail!(e),\n@@ -1253,68 +1253,68 @@ mod tests {\n \n         fn test(s: &str, format: &str) -> bool {\n             match strptime(s, format) {\n-              Ok(ref tm) => tm.strftime(format) == s.to_strbuf(),\n+              Ok(ref tm) => tm.strftime(format) == s.to_string(),\n               Err(e) => fail!(e)\n             }\n         }\n \n         let days = [\n-            \"Sunday\".to_strbuf(),\n-            \"Monday\".to_strbuf(),\n-            \"Tuesday\".to_strbuf(),\n-            \"Wednesday\".to_strbuf(),\n-            \"Thursday\".to_strbuf(),\n-            \"Friday\".to_strbuf(),\n-            \"Saturday\".to_strbuf()\n+            \"Sunday\".to_string(),\n+            \"Monday\".to_string(),\n+            \"Tuesday\".to_string(),\n+            \"Wednesday\".to_string(),\n+            \"Thursday\".to_string(),\n+            \"Friday\".to_string(),\n+            \"Saturday\".to_string()\n         ];\n         for day in days.iter() {\n             assert!(test(day.as_slice(), \"%A\"));\n         }\n \n         let days = [\n-            \"Sun\".to_strbuf(),\n-            \"Mon\".to_strbuf(),\n-            \"Tue\".to_strbuf(),\n-            \"Wed\".to_strbuf(),\n-            \"Thu\".to_strbuf(),\n-            \"Fri\".to_strbuf(),\n-            \"Sat\".to_strbuf()\n+            \"Sun\".to_string(),\n+            \"Mon\".to_string(),\n+            \"Tue\".to_string(),\n+            \"Wed\".to_string(),\n+            \"Thu\".to_string(),\n+            \"Fri\".to_string(),\n+            \"Sat\".to_string()\n         ];\n         for day in days.iter() {\n             assert!(test(day.as_slice(), \"%a\"));\n         }\n \n         let months = [\n-            \"January\".to_strbuf(),\n-            \"February\".to_strbuf(),\n-            \"March\".to_strbuf(),\n-            \"April\".to_strbuf(),\n-            \"May\".to_strbuf(),\n-            \"June\".to_strbuf(),\n-            \"July\".to_strbuf(),\n-            \"August\".to_strbuf(),\n-            \"September\".to_strbuf(),\n-            \"October\".to_strbuf(),\n-            \"November\".to_strbuf(),\n-            \"December\".to_strbuf()\n+            \"January\".to_string(),\n+            \"February\".to_string(),\n+            \"March\".to_string(),\n+            \"April\".to_string(),\n+            \"May\".to_string(),\n+            \"June\".to_string(),\n+            \"July\".to_string(),\n+            \"August\".to_string(),\n+            \"September\".to_string(),\n+            \"October\".to_string(),\n+            \"November\".to_string(),\n+            \"December\".to_string()\n         ];\n         for day in months.iter() {\n             assert!(test(day.as_slice(), \"%B\"));\n         }\n \n         let months = [\n-            \"Jan\".to_strbuf(),\n-            \"Feb\".to_strbuf(),\n-            \"Mar\".to_strbuf(),\n-            \"Apr\".to_strbuf(),\n-            \"May\".to_strbuf(),\n-            \"Jun\".to_strbuf(),\n-            \"Jul\".to_strbuf(),\n-            \"Aug\".to_strbuf(),\n-            \"Sep\".to_strbuf(),\n-            \"Oct\".to_strbuf(),\n-            \"Nov\".to_strbuf(),\n-            \"Dec\".to_strbuf()\n+            \"Jan\".to_string(),\n+            \"Feb\".to_string(),\n+            \"Mar\".to_string(),\n+            \"Apr\".to_string(),\n+            \"May\".to_string(),\n+            \"Jun\".to_string(),\n+            \"Jul\".to_string(),\n+            \"Aug\".to_string(),\n+            \"Sep\".to_string(),\n+            \"Oct\".to_string(),\n+            \"Nov\".to_string(),\n+            \"Dec\".to_string()\n         ];\n         for day in months.iter() {\n             assert!(test(day.as_slice(), \"%b\"));\n@@ -1365,7 +1365,7 @@ mod tests {\n         assert!(test(\"%\", \"%%\"));\n \n         // Test for #7256\n-        assert_eq!(strptime(\"360\", \"%Y-%m-%d\"), Err(\"Invalid year\".to_strbuf()))\n+        assert_eq!(strptime(\"360\", \"%Y-%m-%d\"), Err(\"Invalid year\".to_string()))\n     }\n \n     fn test_ctime() {\n@@ -1377,8 +1377,8 @@ mod tests {\n \n         debug!(\"test_ctime: {:?} {:?}\", utc.ctime(), local.ctime());\n \n-        assert_eq!(utc.ctime(), \"Fri Feb 13 23:31:30 2009\".to_strbuf());\n-        assert_eq!(local.ctime(), \"Fri Feb 13 15:31:30 2009\".to_strbuf());\n+        assert_eq!(utc.ctime(), \"Fri Feb 13 23:31:30 2009\".to_string());\n+        assert_eq!(local.ctime(), \"Fri Feb 13 15:31:30 2009\".to_string());\n     }\n \n     fn test_strftime() {\n@@ -1388,58 +1388,58 @@ mod tests {\n         let utc = at_utc(time);\n         let local = at(time);\n \n-        assert_eq!(local.strftime(\"\"), \"\".to_strbuf());\n-        assert_eq!(local.strftime(\"%A\"), \"Friday\".to_strbuf());\n-        assert_eq!(local.strftime(\"%a\"), \"Fri\".to_strbuf());\n-        assert_eq!(local.strftime(\"%B\"), \"February\".to_strbuf());\n-        assert_eq!(local.strftime(\"%b\"), \"Feb\".to_strbuf());\n-        assert_eq!(local.strftime(\"%C\"), \"20\".to_strbuf());\n-        assert_eq!(local.strftime(\"%c\"), \"Fri Feb 13 15:31:30 2009\".to_strbuf());\n-        assert_eq!(local.strftime(\"%D\"), \"02/13/09\".to_strbuf());\n-        assert_eq!(local.strftime(\"%d\"), \"13\".to_strbuf());\n-        assert_eq!(local.strftime(\"%e\"), \"13\".to_strbuf());\n-        assert_eq!(local.strftime(\"%f\"), \"000054321\".to_strbuf());\n-        assert_eq!(local.strftime(\"%F\"), \"2009-02-13\".to_strbuf());\n-        assert_eq!(local.strftime(\"%G\"), \"2009\".to_strbuf());\n-        assert_eq!(local.strftime(\"%g\"), \"09\".to_strbuf());\n-        assert_eq!(local.strftime(\"%H\"), \"15\".to_strbuf());\n-        assert_eq!(local.strftime(\"%I\"), \"03\".to_strbuf());\n-        assert_eq!(local.strftime(\"%j\"), \"044\".to_strbuf());\n-        assert_eq!(local.strftime(\"%k\"), \"15\".to_strbuf());\n-        assert_eq!(local.strftime(\"%l\"), \" 3\".to_strbuf());\n-        assert_eq!(local.strftime(\"%M\"), \"31\".to_strbuf());\n-        assert_eq!(local.strftime(\"%m\"), \"02\".to_strbuf());\n-        assert_eq!(local.strftime(\"%n\"), \"\\n\".to_strbuf());\n-        assert_eq!(local.strftime(\"%P\"), \"pm\".to_strbuf());\n-        assert_eq!(local.strftime(\"%p\"), \"PM\".to_strbuf());\n-        assert_eq!(local.strftime(\"%R\"), \"15:31\".to_strbuf());\n-        assert_eq!(local.strftime(\"%r\"), \"03:31:30 PM\".to_strbuf());\n-        assert_eq!(local.strftime(\"%S\"), \"30\".to_strbuf());\n-        assert_eq!(local.strftime(\"%s\"), \"1234567890\".to_strbuf());\n-        assert_eq!(local.strftime(\"%T\"), \"15:31:30\".to_strbuf());\n-        assert_eq!(local.strftime(\"%t\"), \"\\t\".to_strbuf());\n-        assert_eq!(local.strftime(\"%U\"), \"06\".to_strbuf());\n-        assert_eq!(local.strftime(\"%u\"), \"5\".to_strbuf());\n-        assert_eq!(local.strftime(\"%V\"), \"07\".to_strbuf());\n-        assert_eq!(local.strftime(\"%v\"), \"13-Feb-2009\".to_strbuf());\n-        assert_eq!(local.strftime(\"%W\"), \"06\".to_strbuf());\n-        assert_eq!(local.strftime(\"%w\"), \"5\".to_strbuf());\n-        assert_eq!(local.strftime(\"%X\"), \"15:31:30\".to_strbuf()); // FIXME (#2350): support locale\n-        assert_eq!(local.strftime(\"%x\"), \"02/13/09\".to_strbuf()); // FIXME (#2350): support locale\n-        assert_eq!(local.strftime(\"%Y\"), \"2009\".to_strbuf());\n-        assert_eq!(local.strftime(\"%y\"), \"09\".to_strbuf());\n-        assert_eq!(local.strftime(\"%+\"), \"2009-02-13T15:31:30-08:00\".to_strbuf());\n-        assert_eq!(local.strftime(\"%z\"), \"-0800\".to_strbuf());\n-        assert_eq!(local.strftime(\"%%\"), \"%\".to_strbuf());\n-\n-        assert_eq!(local.ctime(), \"Fri Feb 13 15:31:30 2009\".to_strbuf());\n-        assert_eq!(local.rfc822z(), \"Fri, 13 Feb 2009 15:31:30 -0800\".to_strbuf());\n-        assert_eq!(local.rfc3339(), \"2009-02-13T15:31:30-08:00\".to_strbuf());\n-\n-        assert_eq!(utc.ctime(), \"Fri Feb 13 23:31:30 2009\".to_strbuf());\n-        assert_eq!(utc.rfc822(), \"Fri, 13 Feb 2009 23:31:30 GMT\".to_strbuf());\n-        assert_eq!(utc.rfc822z(), \"Fri, 13 Feb 2009 23:31:30 -0000\".to_strbuf());\n-        assert_eq!(utc.rfc3339(), \"2009-02-13T23:31:30Z\".to_strbuf());\n+        assert_eq!(local.strftime(\"\"), \"\".to_string());\n+        assert_eq!(local.strftime(\"%A\"), \"Friday\".to_string());\n+        assert_eq!(local.strftime(\"%a\"), \"Fri\".to_string());\n+        assert_eq!(local.strftime(\"%B\"), \"February\".to_string());\n+        assert_eq!(local.strftime(\"%b\"), \"Feb\".to_string());\n+        assert_eq!(local.strftime(\"%C\"), \"20\".to_string());\n+        assert_eq!(local.strftime(\"%c\"), \"Fri Feb 13 15:31:30 2009\".to_string());\n+        assert_eq!(local.strftime(\"%D\"), \"02/13/09\".to_string());\n+        assert_eq!(local.strftime(\"%d\"), \"13\".to_string());\n+        assert_eq!(local.strftime(\"%e\"), \"13\".to_string());\n+        assert_eq!(local.strftime(\"%f\"), \"000054321\".to_string());\n+        assert_eq!(local.strftime(\"%F\"), \"2009-02-13\".to_string());\n+        assert_eq!(local.strftime(\"%G\"), \"2009\".to_string());\n+        assert_eq!(local.strftime(\"%g\"), \"09\".to_string());\n+        assert_eq!(local.strftime(\"%H\"), \"15\".to_string());\n+        assert_eq!(local.strftime(\"%I\"), \"03\".to_string());\n+        assert_eq!(local.strftime(\"%j\"), \"044\".to_string());\n+        assert_eq!(local.strftime(\"%k\"), \"15\".to_string());\n+        assert_eq!(local.strftime(\"%l\"), \" 3\".to_string());\n+        assert_eq!(local.strftime(\"%M\"), \"31\".to_string());\n+        assert_eq!(local.strftime(\"%m\"), \"02\".to_string());\n+        assert_eq!(local.strftime(\"%n\"), \"\\n\".to_string());\n+        assert_eq!(local.strftime(\"%P\"), \"pm\".to_string());\n+        assert_eq!(local.strftime(\"%p\"), \"PM\".to_string());\n+        assert_eq!(local.strftime(\"%R\"), \"15:31\".to_string());\n+        assert_eq!(local.strftime(\"%r\"), \"03:31:30 PM\".to_string());\n+        assert_eq!(local.strftime(\"%S\"), \"30\".to_string());\n+        assert_eq!(local.strftime(\"%s\"), \"1234567890\".to_string());\n+        assert_eq!(local.strftime(\"%T\"), \"15:31:30\".to_string());\n+        assert_eq!(local.strftime(\"%t\"), \"\\t\".to_string());\n+        assert_eq!(local.strftime(\"%U\"), \"06\".to_string());\n+        assert_eq!(local.strftime(\"%u\"), \"5\".to_string());\n+        assert_eq!(local.strftime(\"%V\"), \"07\".to_string());\n+        assert_eq!(local.strftime(\"%v\"), \"13-Feb-2009\".to_string());\n+        assert_eq!(local.strftime(\"%W\"), \"06\".to_string());\n+        assert_eq!(local.strftime(\"%w\"), \"5\".to_string());\n+        assert_eq!(local.strftime(\"%X\"), \"15:31:30\".to_string()); // FIXME (#2350): support locale\n+        assert_eq!(local.strftime(\"%x\"), \"02/13/09\".to_string()); // FIXME (#2350): support locale\n+        assert_eq!(local.strftime(\"%Y\"), \"2009\".to_string());\n+        assert_eq!(local.strftime(\"%y\"), \"09\".to_string());\n+        assert_eq!(local.strftime(\"%+\"), \"2009-02-13T15:31:30-08:00\".to_string());\n+        assert_eq!(local.strftime(\"%z\"), \"-0800\".to_string());\n+        assert_eq!(local.strftime(\"%%\"), \"%\".to_string());\n+\n+        assert_eq!(local.ctime(), \"Fri Feb 13 15:31:30 2009\".to_string());\n+        assert_eq!(local.rfc822z(), \"Fri, 13 Feb 2009 15:31:30 -0800\".to_string());\n+        assert_eq!(local.rfc3339(), \"2009-02-13T15:31:30-08:00\".to_string());\n+\n+        assert_eq!(utc.ctime(), \"Fri Feb 13 23:31:30 2009\".to_string());\n+        assert_eq!(utc.rfc822(), \"Fri, 13 Feb 2009 23:31:30 GMT\".to_string());\n+        assert_eq!(utc.rfc822z(), \"Fri, 13 Feb 2009 23:31:30 -0000\".to_string());\n+        assert_eq!(utc.rfc3339(), \"2009-02-13T23:31:30Z\".to_string());\n     }\n \n     fn test_timespec_eq_ord() {"}, {"sha": "b049246ca18839ac873084772184f754e312325a", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 207, "deletions": 207, "changes": 414, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -39,13 +39,13 @@ use std::uint;\n /// ```rust\n /// use url::{Url, UserInfo};\n ///\n-/// let url = Url { scheme: \"https\".to_strbuf(),\n-///                 user: Some(UserInfo { user: \"username\".to_strbuf(), pass: None }),\n-///                 host: \"example.com\".to_strbuf(),\n-///                 port: Some(\"8080\".to_strbuf()),\n-///                 path: \"/foo/bar\".to_strbuf(),\n-///                 query: vec!((\"baz\".to_strbuf(), \"qux\".to_strbuf())),\n-///                 fragment: Some(\"quz\".to_strbuf()) };\n+/// let url = Url { scheme: \"https\".to_string(),\n+///                 user: Some(UserInfo { user: \"username\".to_string(), pass: None }),\n+///                 host: \"example.com\".to_string(),\n+///                 port: Some(\"8080\".to_string()),\n+///                 path: \"/foo/bar\".to_string(),\n+///                 query: vec!((\"baz\".to_string(), \"qux\".to_string())),\n+///                 fragment: Some(\"quz\".to_string()) };\n /// // https://username@example.com:8080/foo/bar?baz=qux#quz\n /// ```\n #[deriving(Clone, Eq, TotalEq)]\n@@ -61,7 +61,7 @@ pub struct Url {\n     /// The path component of a URL, for example `/foo/bar`.\n     pub path: String,\n     /// The query component of a URL.\n-    /// `vec!((\"baz\".to_strbuf(), \"qux\".to_strbuf()))` represents the fragment\n+    /// `vec!((\"baz\".to_string(), \"qux\".to_string()))` represents the fragment\n     /// `baz=qux` in the above example.\n     pub query: Query,\n     /// The fragment component, such as `quz`.  Doesn't include the leading `#` character.\n@@ -73,7 +73,7 @@ pub struct Path {\n     /// The path component of a URL, for example `/foo/bar`.\n     pub path: String,\n     /// The query component of a URL.\n-    /// `vec!((\"baz\".to_strbuf(), \"qux\".to_strbuf()))` represents the fragment\n+    /// `vec!((\"baz\".to_string(), \"qux\".to_string()))` represents the fragment\n     /// `baz=qux` in the above example.\n     pub query: Query,\n     /// The fragment component, such as `quz`.  Doesn't include the leading `#` character.\n@@ -417,10 +417,10 @@ fn split_char_first(s: &str, c: char) -> (String, String) {\n         }\n     }\n     if index+mat == len {\n-        return (s.slice(0, index).to_strbuf(), \"\".to_strbuf());\n+        return (s.slice(0, index).to_string(), \"\".to_string());\n     } else {\n-        return (s.slice(0, index).to_strbuf(),\n-                s.slice(index + mat, s.len()).to_strbuf());\n+        return (s.slice(0, index).to_string(),\n+                s.slice(index + mat, s.len()).to_string());\n     }\n }\n \n@@ -451,9 +451,9 @@ fn query_from_str(rawquery: &str) -> Query {\n  * # Example\n  *\n  * ```rust\n- * let query = vec!((\"title\".to_strbuf(), \"The Village\".to_strbuf()),\n-                    (\"north\".to_strbuf(), \"52.91\".to_strbuf()),\n-                    (\"west\".to_strbuf(), \"4.10\".to_strbuf()));\n+ * let query = vec!((\"title\".to_string(), \"The Village\".to_string()),\n+                    (\"north\".to_string(), \"52.91\".to_string()),\n+                    (\"west\".to_string(), \"4.10\".to_string()));\n  * println!(\"{}\", url::query_to_str(&query));  // title=The%20Village&north=52.91&west=4.10\n  * ```\n  */\n@@ -468,7 +468,7 @@ pub fn query_to_str(query: &Query) -> String {\n         write!(&mut writer, \"{}={}\", encode_component(k.as_slice()),\n                encode_component(v.as_slice()));\n     }\n-    str::from_utf8_lossy(writer.unwrap().as_slice()).to_strbuf()\n+    str::from_utf8_lossy(writer.unwrap().as_slice()).to_string()\n }\n \n /**\n@@ -483,7 +483,7 @@ pub fn query_to_str(query: &Query) -> String {\n  *\n  * let scheme = match get_scheme(\"https://example.com/\") {\n  *     Ok((sch, _)) => sch,\n- *     Err(_) => \"(None)\".to_strbuf(),\n+ *     Err(_) => \"(None)\".to_string(),\n  * };\n  * println!(\"Scheme in use: {}.\", scheme); // Scheme in use: https.\n  * ```\n@@ -495,24 +495,24 @@ pub fn get_scheme(rawurl: &str) -> Result<(String, String), String> {\n           '0' .. '9' | '+' | '-' | '.' => {\n             if i == 0 {\n                 return Err(\"url: Scheme must begin with a \\\n-                            letter.\".to_strbuf());\n+                            letter.\".to_string());\n             }\n             continue;\n           }\n           ':' => {\n             if i == 0 {\n-                return Err(\"url: Scheme cannot be empty.\".to_strbuf());\n+                return Err(\"url: Scheme cannot be empty.\".to_string());\n             } else {\n-                return Ok((rawurl.slice(0,i).to_strbuf(),\n-                           rawurl.slice(i+1,rawurl.len()).to_strbuf()));\n+                return Ok((rawurl.slice(0,i).to_string(),\n+                           rawurl.slice(i+1,rawurl.len()).to_string()));\n             }\n           }\n           _ => {\n-            return Err(\"url: Invalid character in scheme.\".to_strbuf());\n+            return Err(\"url: Invalid character in scheme.\".to_string());\n           }\n         }\n     };\n-    return Err(\"url: Scheme must be terminated with a colon.\".to_strbuf());\n+    return Err(\"url: Scheme must be terminated with a colon.\".to_string());\n }\n \n #[deriving(Clone, Eq)]\n@@ -527,7 +527,7 @@ fn get_authority(rawurl: &str) ->\n     Result<(Option<UserInfo>, String, Option<String>, String), String> {\n     if !rawurl.starts_with(\"//\") {\n         // there is no authority.\n-        return Ok((None, \"\".to_strbuf(), None, rawurl.to_str().to_strbuf()));\n+        return Ok((None, \"\".to_string(), None, rawurl.to_str().to_string()));\n     }\n \n     enum State {\n@@ -544,7 +544,7 @@ fn get_authority(rawurl: &str) ->\n     let mut input = Digit; // most restricted, start here.\n \n     let mut userinfo = None;\n-    let mut host = \"\".to_strbuf();\n+    let mut host = \"\".to_string();\n     let mut port = None;\n \n     let mut colon_count = 0;\n@@ -571,7 +571,7 @@ fn get_authority(rawurl: &str) ->\n             // separators, don't change anything\n           }\n           _ => {\n-            return Err(\"Illegal character in authority\".to_strbuf());\n+            return Err(\"Illegal character in authority\".to_string());\n           }\n         }\n \n@@ -588,15 +588,15 @@ fn get_authority(rawurl: &str) ->\n                 // multiple colons means ipv6 address.\n                 if input == Unreserved {\n                     return Err(\n-                        \"Illegal characters in IPv6 address.\".to_strbuf());\n+                        \"Illegal characters in IPv6 address.\".to_string());\n                 }\n                 st = Ip6Host;\n               }\n               InHost => {\n                 pos = i;\n                 if input == Unreserved {\n                     // must be port\n-                    host = rawurl.slice(begin, i).to_strbuf();\n+                    host = rawurl.slice(begin, i).to_string();\n                     st = InPort;\n                 } else {\n                     // can't be sure whether this is an ipv6 address or a port\n@@ -606,19 +606,19 @@ fn get_authority(rawurl: &str) ->\n               Ip6Port => {\n                 if input == Unreserved {\n                     return Err(\"Illegal characters in \\\n-                                authority.\".to_strbuf());\n+                                authority.\".to_string());\n                 }\n                 st = Ip6Host;\n               }\n               Ip6Host => {\n                 if colon_count > 7 {\n-                    host = rawurl.slice(begin, i).to_strbuf();\n+                    host = rawurl.slice(begin, i).to_string();\n                     pos = i;\n                     st = InPort;\n                 }\n               }\n               _ => {\n-                return Err(\"Invalid ':' in authority.\".to_strbuf());\n+                return Err(\"Invalid ':' in authority.\".to_string());\n               }\n             }\n             input = Digit; // reset input class\n@@ -629,18 +629,18 @@ fn get_authority(rawurl: &str) ->\n             colon_count = 0; // reset count\n             match st {\n               Start => {\n-                let user = rawurl.slice(begin, i).to_strbuf();\n+                let user = rawurl.slice(begin, i).to_string();\n                 userinfo = Some(UserInfo::new(user, None));\n                 st = InHost;\n               }\n               PassHostPort => {\n-                let user = rawurl.slice(begin, pos).to_strbuf();\n-                let pass = rawurl.slice(pos+1, i).to_strbuf();\n+                let user = rawurl.slice(begin, pos).to_string();\n+                let pass = rawurl.slice(pos+1, i).to_string();\n                 userinfo = Some(UserInfo::new(user, Some(pass)));\n                 st = InHost;\n               }\n               _ => {\n-                return Err(\"Invalid '@' in authority.\".to_strbuf());\n+                return Err(\"Invalid '@' in authority.\".to_string());\n               }\n             }\n             begin = i+1;\n@@ -657,27 +657,27 @@ fn get_authority(rawurl: &str) ->\n     // finish up\n     match st {\n       Start => {\n-        host = rawurl.slice(begin, end).to_strbuf();\n+        host = rawurl.slice(begin, end).to_string();\n       }\n       PassHostPort | Ip6Port => {\n         if input != Digit {\n-            return Err(\"Non-digit characters in port.\".to_strbuf());\n+            return Err(\"Non-digit characters in port.\".to_string());\n         }\n-        host = rawurl.slice(begin, pos).to_strbuf();\n-        port = Some(rawurl.slice(pos+1, end).to_strbuf());\n+        host = rawurl.slice(begin, pos).to_string();\n+        port = Some(rawurl.slice(pos+1, end).to_string());\n       }\n       Ip6Host | InHost => {\n-        host = rawurl.slice(begin, end).to_strbuf();\n+        host = rawurl.slice(begin, end).to_string();\n       }\n       InPort => {\n         if input != Digit {\n-            return Err(\"Non-digit characters in port.\".to_strbuf());\n+            return Err(\"Non-digit characters in port.\".to_string());\n         }\n-        port = Some(rawurl.slice(pos+1, end).to_strbuf());\n+        port = Some(rawurl.slice(pos+1, end).to_string());\n       }\n     }\n \n-    let rest = rawurl.slice(end, len).to_strbuf();\n+    let rest = rawurl.slice(end, len).to_string();\n     return Ok((userinfo, host, port, rest));\n }\n \n@@ -698,19 +698,19 @@ fn get_path(rawurl: &str, authority: bool) ->\n             end = i;\n             break;\n           }\n-          _ => return Err(\"Invalid character in path.\".to_strbuf())\n+          _ => return Err(\"Invalid character in path.\".to_string())\n         }\n     }\n \n     if authority {\n         if end != 0 && !rawurl.starts_with(\"/\") {\n             return Err(\"Non-empty path must begin with\\\n-                              '/' in presence of authority.\".to_strbuf());\n+                              '/' in presence of authority.\".to_string());\n         }\n     }\n \n     return Ok((decode_component(rawurl.slice(0, end)),\n-                    rawurl.slice(end, len).to_strbuf()));\n+                    rawurl.slice(end, len).to_string()));\n }\n \n // returns the parsed query and the fragment, if present\n@@ -888,53 +888,53 @@ impl<S: Writer> Hash<S> for Path {\n #[test]\n fn test_split_char_first() {\n     let (u,v) = split_char_first(\"hello, sweet world\", ',');\n-    assert_eq!(u, \"hello\".to_strbuf());\n-    assert_eq!(v, \" sweet world\".to_strbuf());\n+    assert_eq!(u, \"hello\".to_string());\n+    assert_eq!(v, \" sweet world\".to_string());\n \n     let (u,v) = split_char_first(\"hello sweet world\", ',');\n-    assert_eq!(u, \"hello sweet world\".to_strbuf());\n-    assert_eq!(v, \"\".to_strbuf());\n+    assert_eq!(u, \"hello sweet world\".to_string());\n+    assert_eq!(v, \"\".to_string());\n }\n \n #[test]\n fn test_get_authority() {\n     let (u, h, p, r) = get_authority(\n         \"//user:pass@rust-lang.org/something\").unwrap();\n-    assert_eq!(u, Some(UserInfo::new(\"user\".to_strbuf(), Some(\"pass\".to_strbuf()))));\n-    assert_eq!(h, \"rust-lang.org\".to_strbuf());\n+    assert_eq!(u, Some(UserInfo::new(\"user\".to_string(), Some(\"pass\".to_string()))));\n+    assert_eq!(h, \"rust-lang.org\".to_string());\n     assert!(p.is_none());\n-    assert_eq!(r, \"/something\".to_strbuf());\n+    assert_eq!(r, \"/something\".to_string());\n \n     let (u, h, p, r) = get_authority(\n         \"//rust-lang.org:8000?something\").unwrap();\n     assert!(u.is_none());\n-    assert_eq!(h, \"rust-lang.org\".to_strbuf());\n-    assert_eq!(p, Some(\"8000\".to_strbuf()));\n-    assert_eq!(r, \"?something\".to_strbuf());\n+    assert_eq!(h, \"rust-lang.org\".to_string());\n+    assert_eq!(p, Some(\"8000\".to_string()));\n+    assert_eq!(r, \"?something\".to_string());\n \n     let (u, h, p, r) = get_authority(\n         \"//rust-lang.org#blah\").unwrap();\n     assert!(u.is_none());\n-    assert_eq!(h, \"rust-lang.org\".to_strbuf());\n+    assert_eq!(h, \"rust-lang.org\".to_string());\n     assert!(p.is_none());\n-    assert_eq!(r, \"#blah\".to_strbuf());\n+    assert_eq!(r, \"#blah\".to_string());\n \n     // ipv6 tests\n     let (_, h, _, _) = get_authority(\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334#blah\").unwrap();\n-    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_strbuf());\n+    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_string());\n \n     let (_, h, p, _) = get_authority(\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\").unwrap();\n-    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_strbuf());\n-    assert_eq!(p, Some(\"8000\".to_strbuf()));\n+    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_string());\n+    assert_eq!(p, Some(\"8000\".to_string()));\n \n     let (u, h, p, _) = get_authority(\n         \"//us:p@2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\"\n     ).unwrap();\n-    assert_eq!(u, Some(UserInfo::new(\"us\".to_strbuf(), Some(\"p\".to_strbuf()))));\n-    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_strbuf());\n-    assert_eq!(p, Some(\"8000\".to_strbuf()));\n+    assert_eq!(u, Some(UserInfo::new(\"us\".to_string(), Some(\"p\".to_string()))));\n+    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_string());\n+    assert_eq!(p, Some(\"8000\".to_string()));\n \n     // invalid authorities;\n     assert!(get_authority(\"//user:pass@rust-lang:something\").is_err());\n@@ -946,22 +946,22 @@ fn test_get_authority() {\n \n     // these parse as empty, because they don't start with '//'\n     let (_, h, _, _) = get_authority(\"user:pass@rust-lang\").unwrap();\n-    assert_eq!(h, \"\".to_strbuf());\n+    assert_eq!(h, \"\".to_string());\n     let (_, h, _, _) = get_authority(\"rust-lang.org\").unwrap();\n-    assert_eq!(h, \"\".to_strbuf());\n+    assert_eq!(h, \"\".to_string());\n }\n \n #[test]\n fn test_get_path() {\n     let (p, r) = get_path(\"/something+%20orother\", true).unwrap();\n-    assert_eq!(p, \"/something+ orother\".to_strbuf());\n-    assert_eq!(r, \"\".to_strbuf());\n+    assert_eq!(p, \"/something+ orother\".to_string());\n+    assert_eq!(r, \"\".to_string());\n     let (p, r) = get_path(\"test@email.com#fragment\", false).unwrap();\n-    assert_eq!(p, \"test@email.com\".to_strbuf());\n-    assert_eq!(r, \"#fragment\".to_strbuf());\n+    assert_eq!(p, \"test@email.com\".to_string());\n+    assert_eq!(r, \"#fragment\".to_string());\n     let (p, r) = get_path(\"/gen/:addr=?q=v\", false).unwrap();\n-    assert_eq!(p, \"/gen/:addr=\".to_strbuf());\n-    assert_eq!(r, \"?q=v\".to_strbuf());\n+    assert_eq!(p, \"/gen/:addr=\".to_string());\n+    assert_eq!(r, \"?q=v\".to_string());\n \n     //failure cases\n     assert!(get_path(\"something?q\", true).is_err());\n@@ -981,13 +981,13 @@ mod tests {\n \n         let up = from_str(url);\n         let u = up.unwrap();\n-        assert_eq!(&u.scheme, &\"http\".to_strbuf());\n-        assert_eq!(&u.user, &Some(UserInfo::new(\"user\".to_strbuf(), Some(\"pass\".to_strbuf()))));\n-        assert_eq!(&u.host, &\"rust-lang.org\".to_strbuf());\n-        assert_eq!(&u.port, &Some(\"8080\".to_strbuf()));\n-        assert_eq!(&u.path, &\"/doc/~u\".to_strbuf());\n-        assert_eq!(&u.query, &vec!((\"s\".to_strbuf(), \"v\".to_strbuf())));\n-        assert_eq!(&u.fragment, &Some(\"something\".to_strbuf()));\n+        assert_eq!(&u.scheme, &\"http\".to_string());\n+        assert_eq!(&u.user, &Some(UserInfo::new(\"user\".to_string(), Some(\"pass\".to_string()))));\n+        assert_eq!(&u.host, &\"rust-lang.org\".to_string());\n+        assert_eq!(&u.port, &Some(\"8080\".to_string()));\n+        assert_eq!(&u.path, &\"/doc/~u\".to_string());\n+        assert_eq!(&u.query, &vec!((\"s\".to_string(), \"v\".to_string())));\n+        assert_eq!(&u.fragment, &Some(\"something\".to_string()));\n     }\n \n     #[test]\n@@ -996,69 +996,69 @@ mod tests {\n \n         let up = path_from_str(path);\n         let u = up.unwrap();\n-        assert_eq!(&u.path, &\"/doc/~u\".to_strbuf());\n-        assert_eq!(&u.query, &vec!((\"s\".to_strbuf(), \"v\".to_strbuf())));\n-        assert_eq!(&u.fragment, &Some(\"something\".to_strbuf()));\n+        assert_eq!(&u.path, &\"/doc/~u\".to_string());\n+        assert_eq!(&u.query, &vec!((\"s\".to_string(), \"v\".to_string())));\n+        assert_eq!(&u.fragment, &Some(\"something\".to_string()));\n     }\n \n     #[test]\n     fn test_url_parse_host_slash() {\n         let urlstr = \"http://0.42.42.42/\";\n         let url = from_str(urlstr).unwrap();\n-        assert!(url.host == \"0.42.42.42\".to_strbuf());\n-        assert!(url.path == \"/\".to_strbuf());\n+        assert!(url.host == \"0.42.42.42\".to_string());\n+        assert!(url.path == \"/\".to_string());\n     }\n \n     #[test]\n     fn test_path_parse_host_slash() {\n         let pathstr = \"/\";\n         let path = path_from_str(pathstr).unwrap();\n-        assert!(path.path == \"/\".to_strbuf());\n+        assert!(path.path == \"/\".to_string());\n     }\n \n     #[test]\n     fn test_url_host_with_port() {\n         let urlstr = \"scheme://host:1234\";\n         let url = from_str(urlstr).unwrap();\n-        assert_eq!(&url.scheme, &\"scheme\".to_strbuf());\n-        assert_eq!(&url.host, &\"host\".to_strbuf());\n-        assert_eq!(&url.port, &Some(\"1234\".to_strbuf()));\n+        assert_eq!(&url.scheme, &\"scheme\".to_string());\n+        assert_eq!(&url.host, &\"host\".to_string());\n+        assert_eq!(&url.port, &Some(\"1234\".to_string()));\n         // is empty path really correct? Other tests think so\n-        assert_eq!(&url.path, &\"\".to_strbuf());\n+        assert_eq!(&url.path, &\"\".to_string());\n         let urlstr = \"scheme://host:1234/\";\n         let url = from_str(urlstr).unwrap();\n-        assert_eq!(&url.scheme, &\"scheme\".to_strbuf());\n-        assert_eq!(&url.host, &\"host\".to_strbuf());\n-        assert_eq!(&url.port, &Some(\"1234\".to_strbuf()));\n-        assert_eq!(&url.path, &\"/\".to_strbuf());\n+        assert_eq!(&url.scheme, &\"scheme\".to_string());\n+        assert_eq!(&url.host, &\"host\".to_string());\n+        assert_eq!(&url.port, &Some(\"1234\".to_string()));\n+        assert_eq!(&url.path, &\"/\".to_string());\n     }\n \n     #[test]\n     fn test_url_with_underscores() {\n         let urlstr = \"http://dotcom.com/file_name.html\";\n         let url = from_str(urlstr).unwrap();\n-        assert!(url.path == \"/file_name.html\".to_strbuf());\n+        assert!(url.path == \"/file_name.html\".to_string());\n     }\n \n     #[test]\n     fn test_path_with_underscores() {\n         let pathstr = \"/file_name.html\";\n         let path = path_from_str(pathstr).unwrap();\n-        assert!(path.path == \"/file_name.html\".to_strbuf());\n+        assert!(path.path == \"/file_name.html\".to_string());\n     }\n \n     #[test]\n     fn test_url_with_dashes() {\n         let urlstr = \"http://dotcom.com/file-name.html\";\n         let url = from_str(urlstr).unwrap();\n-        assert!(url.path == \"/file-name.html\".to_strbuf());\n+        assert!(url.path == \"/file-name.html\".to_string());\n     }\n \n     #[test]\n     fn test_path_with_dashes() {\n         let pathstr = \"/file-name.html\";\n         let path = path_from_str(pathstr).unwrap();\n-        assert!(path.path == \"/file-name.html\".to_strbuf());\n+        assert!(path.path == \"/file-name.html\".to_string());\n     }\n \n     #[test]\n@@ -1137,16 +1137,16 @@ mod tests {\n     fn test_url_component_encoding() {\n         let url = \"http://rust-lang.org/doc%20uments?ba%25d%20=%23%26%2B\";\n         let u = from_str(url).unwrap();\n-        assert!(u.path == \"/doc uments\".to_strbuf());\n-        assert!(u.query == vec!((\"ba%d \".to_strbuf(), \"#&+\".to_strbuf())));\n+        assert!(u.path == \"/doc uments\".to_string());\n+        assert!(u.query == vec!((\"ba%d \".to_string(), \"#&+\".to_string())));\n     }\n \n     #[test]\n     fn test_path_component_encoding() {\n         let path = \"/doc%20uments?ba%25d%20=%23%26%2B\";\n         let p = path_from_str(path).unwrap();\n-        assert!(p.path == \"/doc uments\".to_strbuf());\n-        assert!(p.query == vec!((\"ba%d \".to_strbuf(), \"#&+\".to_strbuf())));\n+        assert!(p.path == \"/doc uments\".to_string());\n+        assert!(p.query == vec!((\"ba%d \".to_string(), \"#&+\".to_string())));\n     }\n \n     #[test]\n@@ -1157,134 +1157,134 @@ mod tests {\n \n     #[test]\n     fn test_encode() {\n-        assert_eq!(encode(\"\"), \"\".to_strbuf());\n-        assert_eq!(encode(\"http://example.com\"), \"http://example.com\".to_strbuf());\n-        assert_eq!(encode(\"foo bar% baz\"), \"foo%20bar%25%20baz\".to_strbuf());\n-        assert_eq!(encode(\" \"), \"%20\".to_strbuf());\n-        assert_eq!(encode(\"!\"), \"!\".to_strbuf());\n-        assert_eq!(encode(\"\\\"\"), \"\\\"\".to_strbuf());\n-        assert_eq!(encode(\"#\"), \"#\".to_strbuf());\n-        assert_eq!(encode(\"$\"), \"$\".to_strbuf());\n-        assert_eq!(encode(\"%\"), \"%25\".to_strbuf());\n-        assert_eq!(encode(\"&\"), \"&\".to_strbuf());\n-        assert_eq!(encode(\"'\"), \"%27\".to_strbuf());\n-        assert_eq!(encode(\"(\"), \"(\".to_strbuf());\n-        assert_eq!(encode(\")\"), \")\".to_strbuf());\n-        assert_eq!(encode(\"*\"), \"*\".to_strbuf());\n-        assert_eq!(encode(\"+\"), \"+\".to_strbuf());\n-        assert_eq!(encode(\",\"), \",\".to_strbuf());\n-        assert_eq!(encode(\"/\"), \"/\".to_strbuf());\n-        assert_eq!(encode(\":\"), \":\".to_strbuf());\n-        assert_eq!(encode(\";\"), \";\".to_strbuf());\n-        assert_eq!(encode(\"=\"), \"=\".to_strbuf());\n-        assert_eq!(encode(\"?\"), \"?\".to_strbuf());\n-        assert_eq!(encode(\"@\"), \"@\".to_strbuf());\n-        assert_eq!(encode(\"[\"), \"[\".to_strbuf());\n-        assert_eq!(encode(\"]\"), \"]\".to_strbuf());\n+        assert_eq!(encode(\"\"), \"\".to_string());\n+        assert_eq!(encode(\"http://example.com\"), \"http://example.com\".to_string());\n+        assert_eq!(encode(\"foo bar% baz\"), \"foo%20bar%25%20baz\".to_string());\n+        assert_eq!(encode(\" \"), \"%20\".to_string());\n+        assert_eq!(encode(\"!\"), \"!\".to_string());\n+        assert_eq!(encode(\"\\\"\"), \"\\\"\".to_string());\n+        assert_eq!(encode(\"#\"), \"#\".to_string());\n+        assert_eq!(encode(\"$\"), \"$\".to_string());\n+        assert_eq!(encode(\"%\"), \"%25\".to_string());\n+        assert_eq!(encode(\"&\"), \"&\".to_string());\n+        assert_eq!(encode(\"'\"), \"%27\".to_string());\n+        assert_eq!(encode(\"(\"), \"(\".to_string());\n+        assert_eq!(encode(\")\"), \")\".to_string());\n+        assert_eq!(encode(\"*\"), \"*\".to_string());\n+        assert_eq!(encode(\"+\"), \"+\".to_string());\n+        assert_eq!(encode(\",\"), \",\".to_string());\n+        assert_eq!(encode(\"/\"), \"/\".to_string());\n+        assert_eq!(encode(\":\"), \":\".to_string());\n+        assert_eq!(encode(\";\"), \";\".to_string());\n+        assert_eq!(encode(\"=\"), \"=\".to_string());\n+        assert_eq!(encode(\"?\"), \"?\".to_string());\n+        assert_eq!(encode(\"@\"), \"@\".to_string());\n+        assert_eq!(encode(\"[\"), \"[\".to_string());\n+        assert_eq!(encode(\"]\"), \"]\".to_string());\n     }\n \n     #[test]\n     fn test_encode_component() {\n-        assert_eq!(encode_component(\"\"), \"\".to_strbuf());\n+        assert_eq!(encode_component(\"\"), \"\".to_string());\n         assert!(encode_component(\"http://example.com\") ==\n-            \"http%3A%2F%2Fexample.com\".to_strbuf());\n+            \"http%3A%2F%2Fexample.com\".to_string());\n         assert!(encode_component(\"foo bar% baz\") ==\n-            \"foo%20bar%25%20baz\".to_strbuf());\n-        assert_eq!(encode_component(\" \"), \"%20\".to_strbuf());\n-        assert_eq!(encode_component(\"!\"), \"%21\".to_strbuf());\n-        assert_eq!(encode_component(\"#\"), \"%23\".to_strbuf());\n-        assert_eq!(encode_component(\"$\"), \"%24\".to_strbuf());\n-        assert_eq!(encode_component(\"%\"), \"%25\".to_strbuf());\n-        assert_eq!(encode_component(\"&\"), \"%26\".to_strbuf());\n-        assert_eq!(encode_component(\"'\"), \"%27\".to_strbuf());\n-        assert_eq!(encode_component(\"(\"), \"%28\".to_strbuf());\n-        assert_eq!(encode_component(\")\"), \"%29\".to_strbuf());\n-        assert_eq!(encode_component(\"*\"), \"%2A\".to_strbuf());\n-        assert_eq!(encode_component(\"+\"), \"%2B\".to_strbuf());\n-        assert_eq!(encode_component(\",\"), \"%2C\".to_strbuf());\n-        assert_eq!(encode_component(\"/\"), \"%2F\".to_strbuf());\n-        assert_eq!(encode_component(\":\"), \"%3A\".to_strbuf());\n-        assert_eq!(encode_component(\";\"), \"%3B\".to_strbuf());\n-        assert_eq!(encode_component(\"=\"), \"%3D\".to_strbuf());\n-        assert_eq!(encode_component(\"?\"), \"%3F\".to_strbuf());\n-        assert_eq!(encode_component(\"@\"), \"%40\".to_strbuf());\n-        assert_eq!(encode_component(\"[\"), \"%5B\".to_strbuf());\n-        assert_eq!(encode_component(\"]\"), \"%5D\".to_strbuf());\n+            \"foo%20bar%25%20baz\".to_string());\n+        assert_eq!(encode_component(\" \"), \"%20\".to_string());\n+        assert_eq!(encode_component(\"!\"), \"%21\".to_string());\n+        assert_eq!(encode_component(\"#\"), \"%23\".to_string());\n+        assert_eq!(encode_component(\"$\"), \"%24\".to_string());\n+        assert_eq!(encode_component(\"%\"), \"%25\".to_string());\n+        assert_eq!(encode_component(\"&\"), \"%26\".to_string());\n+        assert_eq!(encode_component(\"'\"), \"%27\".to_string());\n+        assert_eq!(encode_component(\"(\"), \"%28\".to_string());\n+        assert_eq!(encode_component(\")\"), \"%29\".to_string());\n+        assert_eq!(encode_component(\"*\"), \"%2A\".to_string());\n+        assert_eq!(encode_component(\"+\"), \"%2B\".to_string());\n+        assert_eq!(encode_component(\",\"), \"%2C\".to_string());\n+        assert_eq!(encode_component(\"/\"), \"%2F\".to_string());\n+        assert_eq!(encode_component(\":\"), \"%3A\".to_string());\n+        assert_eq!(encode_component(\";\"), \"%3B\".to_string());\n+        assert_eq!(encode_component(\"=\"), \"%3D\".to_string());\n+        assert_eq!(encode_component(\"?\"), \"%3F\".to_string());\n+        assert_eq!(encode_component(\"@\"), \"%40\".to_string());\n+        assert_eq!(encode_component(\"[\"), \"%5B\".to_string());\n+        assert_eq!(encode_component(\"]\"), \"%5D\".to_string());\n     }\n \n     #[test]\n     fn test_decode() {\n-        assert_eq!(decode(\"\"), \"\".to_strbuf());\n-        assert_eq!(decode(\"abc/def 123\"), \"abc/def 123\".to_strbuf());\n-        assert_eq!(decode(\"abc%2Fdef%20123\"), \"abc%2Fdef 123\".to_strbuf());\n-        assert_eq!(decode(\"%20\"), \" \".to_strbuf());\n-        assert_eq!(decode(\"%21\"), \"%21\".to_strbuf());\n-        assert_eq!(decode(\"%22\"), \"%22\".to_strbuf());\n-        assert_eq!(decode(\"%23\"), \"%23\".to_strbuf());\n-        assert_eq!(decode(\"%24\"), \"%24\".to_strbuf());\n-        assert_eq!(decode(\"%25\"), \"%\".to_strbuf());\n-        assert_eq!(decode(\"%26\"), \"%26\".to_strbuf());\n-        assert_eq!(decode(\"%27\"), \"'\".to_strbuf());\n-        assert_eq!(decode(\"%28\"), \"%28\".to_strbuf());\n-        assert_eq!(decode(\"%29\"), \"%29\".to_strbuf());\n-        assert_eq!(decode(\"%2A\"), \"%2A\".to_strbuf());\n-        assert_eq!(decode(\"%2B\"), \"%2B\".to_strbuf());\n-        assert_eq!(decode(\"%2C\"), \"%2C\".to_strbuf());\n-        assert_eq!(decode(\"%2F\"), \"%2F\".to_strbuf());\n-        assert_eq!(decode(\"%3A\"), \"%3A\".to_strbuf());\n-        assert_eq!(decode(\"%3B\"), \"%3B\".to_strbuf());\n-        assert_eq!(decode(\"%3D\"), \"%3D\".to_strbuf());\n-        assert_eq!(decode(\"%3F\"), \"%3F\".to_strbuf());\n-        assert_eq!(decode(\"%40\"), \"%40\".to_strbuf());\n-        assert_eq!(decode(\"%5B\"), \"%5B\".to_strbuf());\n-        assert_eq!(decode(\"%5D\"), \"%5D\".to_strbuf());\n+        assert_eq!(decode(\"\"), \"\".to_string());\n+        assert_eq!(decode(\"abc/def 123\"), \"abc/def 123\".to_string());\n+        assert_eq!(decode(\"abc%2Fdef%20123\"), \"abc%2Fdef 123\".to_string());\n+        assert_eq!(decode(\"%20\"), \" \".to_string());\n+        assert_eq!(decode(\"%21\"), \"%21\".to_string());\n+        assert_eq!(decode(\"%22\"), \"%22\".to_string());\n+        assert_eq!(decode(\"%23\"), \"%23\".to_string());\n+        assert_eq!(decode(\"%24\"), \"%24\".to_string());\n+        assert_eq!(decode(\"%25\"), \"%\".to_string());\n+        assert_eq!(decode(\"%26\"), \"%26\".to_string());\n+        assert_eq!(decode(\"%27\"), \"'\".to_string());\n+        assert_eq!(decode(\"%28\"), \"%28\".to_string());\n+        assert_eq!(decode(\"%29\"), \"%29\".to_string());\n+        assert_eq!(decode(\"%2A\"), \"%2A\".to_string());\n+        assert_eq!(decode(\"%2B\"), \"%2B\".to_string());\n+        assert_eq!(decode(\"%2C\"), \"%2C\".to_string());\n+        assert_eq!(decode(\"%2F\"), \"%2F\".to_string());\n+        assert_eq!(decode(\"%3A\"), \"%3A\".to_string());\n+        assert_eq!(decode(\"%3B\"), \"%3B\".to_string());\n+        assert_eq!(decode(\"%3D\"), \"%3D\".to_string());\n+        assert_eq!(decode(\"%3F\"), \"%3F\".to_string());\n+        assert_eq!(decode(\"%40\"), \"%40\".to_string());\n+        assert_eq!(decode(\"%5B\"), \"%5B\".to_string());\n+        assert_eq!(decode(\"%5D\"), \"%5D\".to_string());\n     }\n \n     #[test]\n     fn test_decode_component() {\n-        assert_eq!(decode_component(\"\"), \"\".to_strbuf());\n-        assert_eq!(decode_component(\"abc/def 123\"), \"abc/def 123\".to_strbuf());\n-        assert_eq!(decode_component(\"abc%2Fdef%20123\"), \"abc/def 123\".to_strbuf());\n-        assert_eq!(decode_component(\"%20\"), \" \".to_strbuf());\n-        assert_eq!(decode_component(\"%21\"), \"!\".to_strbuf());\n-        assert_eq!(decode_component(\"%22\"), \"\\\"\".to_strbuf());\n-        assert_eq!(decode_component(\"%23\"), \"#\".to_strbuf());\n-        assert_eq!(decode_component(\"%24\"), \"$\".to_strbuf());\n-        assert_eq!(decode_component(\"%25\"), \"%\".to_strbuf());\n-        assert_eq!(decode_component(\"%26\"), \"&\".to_strbuf());\n-        assert_eq!(decode_component(\"%27\"), \"'\".to_strbuf());\n-        assert_eq!(decode_component(\"%28\"), \"(\".to_strbuf());\n-        assert_eq!(decode_component(\"%29\"), \")\".to_strbuf());\n-        assert_eq!(decode_component(\"%2A\"), \"*\".to_strbuf());\n-        assert_eq!(decode_component(\"%2B\"), \"+\".to_strbuf());\n-        assert_eq!(decode_component(\"%2C\"), \",\".to_strbuf());\n-        assert_eq!(decode_component(\"%2F\"), \"/\".to_strbuf());\n-        assert_eq!(decode_component(\"%3A\"), \":\".to_strbuf());\n-        assert_eq!(decode_component(\"%3B\"), \";\".to_strbuf());\n-        assert_eq!(decode_component(\"%3D\"), \"=\".to_strbuf());\n-        assert_eq!(decode_component(\"%3F\"), \"?\".to_strbuf());\n-        assert_eq!(decode_component(\"%40\"), \"@\".to_strbuf());\n-        assert_eq!(decode_component(\"%5B\"), \"[\".to_strbuf());\n-        assert_eq!(decode_component(\"%5D\"), \"]\".to_strbuf());\n+        assert_eq!(decode_component(\"\"), \"\".to_string());\n+        assert_eq!(decode_component(\"abc/def 123\"), \"abc/def 123\".to_string());\n+        assert_eq!(decode_component(\"abc%2Fdef%20123\"), \"abc/def 123\".to_string());\n+        assert_eq!(decode_component(\"%20\"), \" \".to_string());\n+        assert_eq!(decode_component(\"%21\"), \"!\".to_string());\n+        assert_eq!(decode_component(\"%22\"), \"\\\"\".to_string());\n+        assert_eq!(decode_component(\"%23\"), \"#\".to_string());\n+        assert_eq!(decode_component(\"%24\"), \"$\".to_string());\n+        assert_eq!(decode_component(\"%25\"), \"%\".to_string());\n+        assert_eq!(decode_component(\"%26\"), \"&\".to_string());\n+        assert_eq!(decode_component(\"%27\"), \"'\".to_string());\n+        assert_eq!(decode_component(\"%28\"), \"(\".to_string());\n+        assert_eq!(decode_component(\"%29\"), \")\".to_string());\n+        assert_eq!(decode_component(\"%2A\"), \"*\".to_string());\n+        assert_eq!(decode_component(\"%2B\"), \"+\".to_string());\n+        assert_eq!(decode_component(\"%2C\"), \",\".to_string());\n+        assert_eq!(decode_component(\"%2F\"), \"/\".to_string());\n+        assert_eq!(decode_component(\"%3A\"), \":\".to_string());\n+        assert_eq!(decode_component(\"%3B\"), \";\".to_string());\n+        assert_eq!(decode_component(\"%3D\"), \"=\".to_string());\n+        assert_eq!(decode_component(\"%3F\"), \"?\".to_string());\n+        assert_eq!(decode_component(\"%40\"), \"@\".to_string());\n+        assert_eq!(decode_component(\"%5B\"), \"[\".to_string());\n+        assert_eq!(decode_component(\"%5D\"), \"]\".to_string());\n     }\n \n     #[test]\n     fn test_encode_form_urlencoded() {\n         let mut m = HashMap::new();\n-        assert_eq!(encode_form_urlencoded(&m), \"\".to_strbuf());\n+        assert_eq!(encode_form_urlencoded(&m), \"\".to_string());\n \n-        m.insert(\"\".to_strbuf(), vec!());\n-        m.insert(\"foo\".to_strbuf(), vec!());\n-        assert_eq!(encode_form_urlencoded(&m), \"\".to_strbuf());\n+        m.insert(\"\".to_string(), vec!());\n+        m.insert(\"foo\".to_string(), vec!());\n+        assert_eq!(encode_form_urlencoded(&m), \"\".to_string());\n \n         let mut m = HashMap::new();\n-        m.insert(\"foo\".to_strbuf(), vec!(\"bar\".to_strbuf(), \"123\".to_strbuf()));\n-        assert_eq!(encode_form_urlencoded(&m), \"foo=bar&foo=123\".to_strbuf());\n+        m.insert(\"foo\".to_string(), vec!(\"bar\".to_string(), \"123\".to_string()));\n+        assert_eq!(encode_form_urlencoded(&m), \"foo=bar&foo=123\".to_string());\n \n         let mut m = HashMap::new();\n-        m.insert(\"foo bar\".to_strbuf(), vec!(\"abc\".to_strbuf(), \"12 = 34\".to_strbuf()));\n+        m.insert(\"foo bar\".to_string(), vec!(\"abc\".to_string(), \"12 = 34\".to_string()));\n         assert!(encode_form_urlencoded(&m) ==\n-            \"foo+bar=abc&foo+bar=12+%3D+34\".to_strbuf());\n+            \"foo+bar=abc&foo+bar=12+%3D+34\".to_string());\n     }\n \n     #[test]\n@@ -1294,8 +1294,8 @@ mod tests {\n         let s = \"a=1&foo+bar=abc&foo+bar=12+%3D+34\".as_bytes();\n         let form = decode_form_urlencoded(s);\n         assert_eq!(form.len(), 2);\n-        assert_eq!(form.get(&\"a\".to_strbuf()), &vec!(\"1\".to_strbuf()));\n-        assert_eq!(form.get(&\"foo bar\".to_strbuf()),\n-                   &vec!(\"abc\".to_strbuf(), \"12 = 34\".to_strbuf()));\n+        assert_eq!(form.get(&\"a\".to_string()), &vec!(\"1\".to_string()));\n+        assert_eq!(form.get(&\"foo bar\".to_string()),\n+                   &vec!(\"abc\".to_string(), \"12 = 34\".to_string()));\n     }\n }"}, {"sha": "a9c80c90fd6c8f601ddbdf6cc4daa98c9240223f", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -329,7 +329,7 @@ impl Uuid {\n             *s.get_mut(i*2+0) = digit.as_slice()[0];\n             *s.get_mut(i*2+1) = digit.as_slice()[1];\n         }\n-        str::from_utf8(s.as_slice()).unwrap().to_strbuf()\n+        str::from_utf8(s.as_slice()).unwrap().to_string()\n     }\n \n     /// Returns a string of hexadecimal digits, separated into groups with a hyphen.\n@@ -732,7 +732,7 @@ mod test {\n \n         let u = Uuid::from_fields(d1, d2, d3, d4.as_slice());\n \n-        let expected = \"a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8\".to_strbuf();\n+        let expected = \"a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8\".to_string();\n         let result = u.to_simple_str();\n         assert!(result == expected);\n     }\n@@ -743,7 +743,7 @@ mod test {\n                    0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8 );\n \n         let u = Uuid::from_bytes(b.as_slice()).unwrap();\n-        let expected = \"a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8\".to_strbuf();\n+        let expected = \"a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8\".to_string();\n \n         assert!(u.to_simple_str() == expected);\n     }"}, {"sha": "9a82c411437e3ebcee60bc0fb9f38d611b83ab17", "filename": "src/libworkcache/lib.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibworkcache%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Flibworkcache%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibworkcache%2Flib.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -108,8 +108,8 @@ struct WorkKey {\n impl WorkKey {\n     pub fn new(kind: &str, name: &str) -> WorkKey {\n         WorkKey {\n-            kind: kind.to_strbuf(),\n-            name: name.to_strbuf(),\n+            kind: kind.to_string(),\n+            name: name.to_string(),\n         }\n     }\n }\n@@ -190,7 +190,7 @@ impl Database {\n         // FIXME(pcwalton): Yuck.\n         let mut new_db_cache = TreeMap::new();\n         for (ref k, ref v) in self.db_cache.iter() {\n-            new_db_cache.insert((*k).to_strbuf(), (*v).to_strbuf());\n+            new_db_cache.insert((*k).to_string(), (*v).to_string());\n         }\n \n         new_db_cache.to_json().to_pretty_writer(&mut f)\n@@ -262,7 +262,7 @@ fn json_encode<'a, T:Encodable<json::Encoder<'a>, io::IoError>>(t: &T) -> String\n     let mut writer = MemWriter::new();\n     let mut encoder = json::Encoder::new(&mut writer as &mut io::Writer);\n     let _ = t.encode(&mut encoder);\n-    str::from_utf8(writer.unwrap().as_slice()).unwrap().to_strbuf()\n+    str::from_utf8(writer.unwrap().as_slice()).unwrap().to_string()\n }\n \n // FIXME(#5121)\n@@ -313,15 +313,15 @@ impl Exec {\n                           dependency_val: &str) {\n         debug!(\"Discovering input {} {} {}\", dependency_kind, dependency_name, dependency_val);\n         self.discovered_inputs.insert_work_key(WorkKey::new(dependency_kind, dependency_name),\n-                                 dependency_val.to_strbuf());\n+                                 dependency_val.to_string());\n     }\n     pub fn discover_output(&mut self,\n                            dependency_kind: &str,\n                            dependency_name: &str,\n                            dependency_val: &str) {\n         debug!(\"Discovering output {} {} {}\", dependency_kind, dependency_name, dependency_val);\n         self.discovered_outputs.insert_work_key(WorkKey::new(dependency_kind, dependency_name),\n-                                 dependency_val.to_strbuf());\n+                                 dependency_val.to_string());\n     }\n \n     // returns pairs of (kind, name)\n@@ -364,11 +364,11 @@ impl<'a> Prep<'a> {\n     pub fn declare_input(&mut self, kind: &str, name: &str, val: &str) {\n         debug!(\"Declaring input {} {} {}\", kind, name, val);\n         self.declared_inputs.insert_work_key(WorkKey::new(kind, name),\n-                                 val.to_strbuf());\n+                                 val.to_string());\n     }\n \n     fn is_fresh(&self, cat: &str, kind: &str, name: &str, val: &str) -> bool {\n-        let k = kind.to_strbuf();\n+        let k = kind.to_string();\n         let f = self.ctxt.freshness.deref().find(&k);\n         debug!(\"freshness for: {}/{}/{}/{}\", cat, kind, name, val)\n         let fresh = match f {\n@@ -499,10 +499,10 @@ fn test() {\n         return pth;\n     }\n \n-    let pth = make_path(\"foo.c\".to_strbuf());\n+    let pth = make_path(\"foo.c\".to_string());\n     File::create(&pth).write(bytes!(\"int main() { return 0; }\")).unwrap();\n \n-    let db_path = make_path(\"db.json\".to_strbuf());\n+    let db_path = make_path(\"db.json\".to_string());\n \n     let cx = Context::new(Arc::new(RWLock::new(Database::new(db_path))),\n                           Arc::new(TreeMap::new()));\n@@ -514,22 +514,22 @@ fn test() {\n \n         let contents = File::open(&pth).read_to_end().unwrap();\n         let file_content = from_utf8(contents.as_slice()).unwrap()\n-                                                         .to_strbuf();\n+                                                         .to_string();\n \n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prep.declare_input(\"file\",\n                            pth.as_str().unwrap(),\n                            file_content.as_slice());\n         prep.exec(proc(_exe) {\n-            let out = make_path(\"foo.o\".to_strbuf());\n+            let out = make_path(\"foo.o\".to_string());\n             let compiler = if cfg!(windows) {\"gcc\"} else {\"cc\"};\n             Command::new(compiler).arg(pth).arg(\"-o\").arg(out.clone()).status().unwrap();\n \n             let _proof_of_concept = subcx.prep(\"subfn\");\n             // Could run sub-rules inside here.\n \n             // FIXME (#9639): This needs to handle non-utf8 paths\n-            out.as_str().unwrap().to_strbuf()\n+            out.as_str().unwrap().to_string()\n         })\n     });\n "}, {"sha": "7cfb1dda4b9afd8e163e483b525191d6e27163e2", "filename": "src/test/auxiliary/crateresolve5-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -15,7 +15,7 @@\n pub struct NameVal { pub name: String, pub val: int }\n \n pub fn struct_nameval() -> NameVal {\n-    NameVal { name: \"crateresolve5\".to_strbuf(), val: 10 }\n+    NameVal { name: \"crateresolve5\".to_string(), val: 10 }\n }\n \n pub enum e {"}, {"sha": "566c4385f3c2a74bfd90a7651aea4154f6db47a6", "filename": "src/test/auxiliary/crateresolve5-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -14,7 +14,7 @@\n \n pub struct NameVal { pub name: String, pub val: int }\n pub fn struct_nameval() -> NameVal {\n-    NameVal { name: \"crateresolve5\".to_strbuf(), val: 10 }\n+    NameVal { name: \"crateresolve5\".to_string(), val: 10 }\n }\n \n pub enum e {"}, {"sha": "793be5940c9733a64f681eff4d0e879a08aba6ef", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -21,7 +21,7 @@ pub type header_map = HashMap<String, @RefCell<Vec<@String>>>;\n \n // the unused ty param is necessary so this gets monomorphized\n pub fn request<T>(req: &header_map) {\n-  let _x = (**((**req.get(&\"METHOD\".to_strbuf())).clone()).borrow()\n+  let _x = (**((**req.get(&\"METHOD\".to_string())).clone()).borrow()\n                                                           .clone()\n                                                           .get(0)).clone();\n }"}, {"sha": "882442f5e00906203b5e24a135ecd75da98f809d", "filename": "src/test/auxiliary/reexported_static_methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fauxiliary%2Freexported_static_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fauxiliary%2Freexported_static_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Freexported_static_methods.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -47,7 +47,7 @@ pub mod sub_foo {\n \n     impl Bort {\n         pub fn bort() -> String {\n-            \"bort()\".to_strbuf()\n+            \"bort()\".to_string()\n         }\n     }\n }"}, {"sha": "ab2f9b0020624ba6b0c0791a6bcd0bf275534d51", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -90,11 +90,11 @@ impl Results {\n             let mut set = f();\n             timed(&mut self.sequential_strings, || {\n                 for i in range(0u, num_keys) {\n-                    set.insert(i.to_str().to_strbuf());\n+                    set.insert(i.to_str().to_string());\n                 }\n \n                 for i in range(0u, num_keys) {\n-                    assert!(set.contains(&i.to_str().to_strbuf()));\n+                    assert!(set.contains(&i.to_str().to_string()));\n                 }\n             })\n         }\n@@ -103,7 +103,7 @@ impl Results {\n             let mut set = f();\n             timed(&mut self.random_strings, || {\n                 for _ in range(0, num_keys) {\n-                    let s = rng.gen::<uint>().to_str().to_strbuf();\n+                    let s = rng.gen::<uint>().to_str().to_string();\n                     set.insert(s);\n                 }\n             })\n@@ -112,11 +112,11 @@ impl Results {\n         {\n             let mut set = f();\n             for i in range(0u, num_keys) {\n-                set.insert(i.to_str().to_strbuf());\n+                set.insert(i.to_str().to_string());\n             }\n             timed(&mut self.delete_strings, || {\n                 for i in range(0u, num_keys) {\n-                    assert!(set.remove(&i.to_str().to_strbuf()));\n+                    assert!(set.remove(&i.to_str().to_string()));\n                 }\n             })\n         }"}, {"sha": "d53a89684213d19446ad7197101f4f4021d3d0a5", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -25,12 +25,12 @@ use std::io::File;\n \n macro_rules! bench (\n     ($argv:expr, $id:ident) => (maybe_run_test($argv.as_slice(),\n-                                               stringify!($id).to_strbuf(),\n+                                               stringify!($id).to_string(),\n                                                           $id))\n )\n \n fn main() {\n-    let argv = os::args().move_iter().map(|x| x.to_strbuf()).collect::<Vec<String>>();\n+    let argv = os::args().move_iter().map(|x| x.to_string()).collect::<Vec<String>>();\n     let _tests = argv.slice(1, argv.len());\n \n     bench!(argv, shift_push);\n@@ -48,7 +48,7 @@ fn maybe_run_test(argv: &[String], name: String, test: ||) {\n     if os::getenv(\"RUST_BENCH\").is_some() {\n         run_test = true\n     } else if argv.len() > 0 {\n-        run_test = argv.iter().any(|x| x == &\"all\".to_strbuf()) || argv.iter().any(|x| x == &name)\n+        run_test = argv.iter().any(|x| x == &\"all\".to_string()) || argv.iter().any(|x| x == &name)\n     }\n \n     if !run_test {"}, {"sha": "1c51ea055d04e3ab30a09831eee315dd7511fcac", "filename": "src/test/bench/core-uint-to-str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -14,9 +14,9 @@ use std::uint;\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_owned(), \"10000000\".to_owned())\n+        vec!(\"\".to_string(), \"10000000\".to_string())\n     } else if args.len() <= 1u {\n-        vec!(\"\".to_owned(), \"100000\".to_owned())\n+        vec!(\"\".to_string(), \"100000\".to_string())\n     } else {\n         args.move_iter().collect()\n     };"}, {"sha": "1ec4a236dfd135904fed154ee7bace4b097035cb", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -97,11 +97,11 @@ fn run(args: &[String]) {\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_strbuf(), \"1000000\".to_strbuf(), \"10000\".to_strbuf())\n+        vec!(\"\".to_string(), \"1000000\".to_string(), \"10000\".to_string())\n     } else if args.len() <= 1u {\n-        vec!(\"\".to_strbuf(), \"10000\".to_strbuf(), \"4\".to_strbuf())\n+        vec!(\"\".to_string(), \"10000\".to_string(), \"4\".to_string())\n     } else {\n-        args.move_iter().map(|x| x.to_strbuf()).collect()\n+        args.move_iter().map(|x| x.to_string()).collect()\n     };\n \n     println!(\"{}\", args);"}, {"sha": "5da3e1e9ca6c5d01c8775d253cd287d594147da3", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -107,11 +107,11 @@ fn run(args: &[String]) {\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_strbuf(), \"1000000\".to_strbuf(), \"8\".to_strbuf())\n+        vec!(\"\".to_string(), \"1000000\".to_string(), \"8\".to_string())\n     } else if args.len() <= 1u {\n-        vec!(\"\".to_strbuf(), \"10000\".to_strbuf(), \"4\".to_strbuf())\n+        vec!(\"\".to_string(), \"10000\".to_string(), \"4\".to_string())\n     } else {\n-        args.clone().move_iter().map(|x| x.to_strbuf()).collect()\n+        args.clone().move_iter().map(|x| x.to_string()).collect()\n     };\n \n     println!(\"{:?}\", args);"}, {"sha": "108093acfb4983a25c0a1fc02ffcf0612a3ee75d", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -63,9 +63,9 @@ fn thread_ring(i: uint, count: uint, num_chan: pipe, num_port: pipe) {\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_owned(), \"100\".to_owned(), \"10000\".to_owned())\n+        vec!(\"\".to_string(), \"100\".to_string(), \"10000\".to_string())\n     } else if args.len() <= 1u {\n-        vec!(\"\".to_owned(), \"10\".to_owned(), \"100\".to_owned())\n+        vec!(\"\".to_string(), \"10\".to_string(), \"100\".to_string())\n     } else {\n         args.clone().move_iter().collect()\n     };"}, {"sha": "38a894c4b3d8bf9674b2186e2c00aa467cb27dc7", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -64,9 +64,9 @@ fn thread_ring(i: uint, count: uint, num_chan: pipe, num_port: pipe) {\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_owned(), \"100\".to_owned(), \"10000\".to_owned())\n+        vec!(\"\".to_string(), \"100\".to_string(), \"10000\".to_string())\n     } else if args.len() <= 1u {\n-        vec!(\"\".to_owned(), \"10\".to_owned(), \"100\".to_owned())\n+        vec!(\"\".to_string(), \"10\".to_string(), \"100\".to_string())\n     } else {\n         args.clone().move_iter().collect()\n     };"}, {"sha": "d8eceec6321df17a1f69c6e6d2ff14e014ca8bb1", "filename": "src/test/bench/shootout-ackermann.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -25,9 +25,9 @@ fn ack(m: int, n: int) -> int {\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_owned(), \"12\".to_owned())\n+        vec!(\"\".to_string(), \"12\".to_string())\n     } else if args.len() <= 1u {\n-        vec!(\"\".to_owned(), \"8\".to_owned())\n+        vec!(\"\".to_string(), \"8\".to_string())\n     } else {\n         args.move_iter().collect()\n     };"}, {"sha": "83db926ad6cfa53fc8d8c6d795efbadb05d5a33b", "filename": "src/test/bench/shootout-fibo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -21,9 +21,9 @@ fn fib(n: int) -> int {\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_owned(), \"40\".to_owned())\n+        vec!(\"\".to_string(), \"40\".to_string())\n     } else if args.len() <= 1u {\n-        vec!(\"\".to_owned(), \"30\".to_owned())\n+        vec!(\"\".to_string(), \"30\".to_string())\n     } else {\n         args.move_iter().collect()\n     };"}, {"sha": "8be6439d88c413499a5743a9e7356dd48fae1336", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -129,13 +129,13 @@ fn make_sequence_processor(sz: uint,\n    let buffer = match sz {\n        1u => { sort_and_fmt(&freqs, total) }\n        2u => { sort_and_fmt(&freqs, total) }\n-       3u => { format_strbuf!(\"{}\\t{}\", find(&freqs, \"GGT\".to_strbuf()), \"GGT\") }\n-       4u => { format_strbuf!(\"{}\\t{}\", find(&freqs, \"GGTA\".to_strbuf()), \"GGTA\") }\n-       6u => { format_strbuf!(\"{}\\t{}\", find(&freqs, \"GGTATT\".to_strbuf()), \"GGTATT\") }\n-      12u => { format_strbuf!(\"{}\\t{}\", find(&freqs, \"GGTATTTTAATT\".to_strbuf()), \"GGTATTTTAATT\") }\n-      18u => { format_strbuf!(\"{}\\t{}\", find(&freqs, \"GGTATTTTAATTTATAGT\".to_strbuf()),\n+       3u => { format_strbuf!(\"{}\\t{}\", find(&freqs, \"GGT\".to_string()), \"GGT\") }\n+       4u => { format_strbuf!(\"{}\\t{}\", find(&freqs, \"GGTA\".to_string()), \"GGTA\") }\n+       6u => { format_strbuf!(\"{}\\t{}\", find(&freqs, \"GGTATT\".to_string()), \"GGTATT\") }\n+      12u => { format_strbuf!(\"{}\\t{}\", find(&freqs, \"GGTATTTTAATT\".to_string()), \"GGTATTTTAATT\") }\n+      18u => { format_strbuf!(\"{}\\t{}\", find(&freqs, \"GGTATTTTAATTTATAGT\".to_string()),\n                        \"GGTATTTTAATTTATAGT\") }\n-        _ => { \"\".to_strbuf() }\n+        _ => { \"\".to_string() }\n    };\n \n     to_parent.send(buffer);"}, {"sha": "33853a91b7608554297b259894aa940876f3ae36", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -55,7 +55,7 @@ struct Config {\n fn parse_opts(argv: Vec<String> ) -> Config {\n     let opts = vec!(getopts::optflag(\"\", \"stress\", \"\"));\n \n-    let argv = argv.iter().map(|x| x.to_strbuf()).collect::<Vec<_>>();\n+    let argv = argv.iter().map(|x| x.to_string()).collect::<Vec<_>>();\n     let opt_args = argv.slice(1, argv.len());\n \n     match getopts::getopts(opt_args, opts.as_slice()) {\n@@ -93,11 +93,11 @@ fn stress(num_tasks: int) {\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_strbuf(), \"20\".to_strbuf())\n+        vec!(\"\".to_string(), \"20\".to_string())\n     } else if args.len() <= 1u {\n-        vec!(\"\".to_strbuf(), \"8\".to_strbuf())\n+        vec!(\"\".to_string(), \"8\".to_string())\n     } else {\n-        args.move_iter().map(|x| x.to_strbuf()).collect()\n+        args.move_iter().map(|x| x.to_string()).collect()\n     };\n \n     let opts = parse_opts(args.clone());"}, {"sha": "f774be582a158fa259ec7d506348aa813c6f1f97", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -32,9 +32,9 @@ fn check_sequential(min: uint, max: uint, map: &SmallIntMap<uint>) {\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_owned(), \"100000\".to_owned(), \"100\".to_owned())\n+        vec!(\"\".to_string(), \"100000\".to_string(), \"100\".to_string())\n     } else if args.len() <= 1u {\n-        vec!(\"\".to_owned(), \"10000\".to_owned(), \"50\".to_owned())\n+        vec!(\"\".to_string(), \"10000\".to_string(), \"50\".to_string())\n     } else {\n         args.move_iter().collect()\n     };"}, {"sha": "9235882d1f4980b7d06656f4a5b659e6c8eaebc5", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -67,7 +67,7 @@ impl Sudoku {\n \n     pub fn read(mut reader: BufferedReader<StdReader>) -> Sudoku {\n         /* assert first line is exactly \"9,9\" */\n-        assert!(reader.read_line().unwrap() == \"9,9\".to_owned());\n+        assert!(reader.read_line().unwrap() == \"9,9\".to_string());\n \n         let mut g = Vec::from_fn(10u, { |_i| vec!(0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8) });\n         for line in reader.lines() {"}, {"sha": "c631e3e04f2efe894d44b48b16a082496e614de2", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -41,9 +41,9 @@ fn child_generation(gens_left: uint, tx: comm::Sender<()>) {\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_owned(), \"100000\".to_owned())\n+        vec!(\"\".to_string(), \"100000\".to_string())\n     } else if args.len() <= 1 {\n-        vec!(\"\".to_owned(), \"100\".to_owned())\n+        vec!(\"\".to_string(), \"100\".to_string())\n     } else {\n         args.clone().move_iter().collect()\n     };"}, {"sha": "c980d531bb5ebdab4334b9f3c79f63206ac84ecc", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -49,9 +49,9 @@ fn calc(children: uint, parent_wait_chan: &Sender<Sender<Sender<int>>>) {\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_owned(), \"30\".to_owned())\n+        vec!(\"\".to_string(), \"30\".to_string())\n     } else if args.len() <= 1u {\n-        vec!(\"\".to_owned(), \"10\".to_owned())\n+        vec!(\"\".to_string(), \"10\".to_string())\n     } else {\n         args\n     };"}, {"sha": "8b090d6d7fb79f245709f3453291a7bca803d967", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -25,9 +25,9 @@ fn g() { }\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_owned(), \"400\".to_owned())\n+        vec!(\"\".to_string(), \"400\".to_string())\n     } else if args.len() <= 1u {\n-        vec!(\"\".to_owned(), \"10\".to_owned())\n+        vec!(\"\".to_string(), \"10\".to_string())\n     } else {\n         args.move_iter().collect()\n     };"}, {"sha": "3f26e3ce904cf68b37944d2075ba42acde5a0b02", "filename": "src/test/compile-fail/binop-bitxor-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -10,4 +10,4 @@\n \n // error-pattern:`^` cannot be applied to type `std::string::String`\n \n-fn main() { let x = \"a\".to_strbuf() ^ \"b\".to_strbuf(); }\n+fn main() { let x = \"a\".to_string() ^ \"b\".to_string(); }"}, {"sha": "976a574a18f7d00dbe657b64f7c19865e7824448", "filename": "src/test/compile-fail/borrowck-move-error-with-note.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fborrowck-move-error-with-note.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fborrowck-move-error-with-note.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-error-with-note.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -34,7 +34,7 @@ impl Drop for S {\n }\n \n fn move_in_match() {\n-    match S {f: \"foo\".to_strbuf(), g: \"bar\".to_strbuf()} {\n+    match S {f: \"foo\".to_string(), g: \"bar\".to_string()} {\n         S {         //~ ERROR cannot move out of type `S`, which defines the `Drop` trait\n             f: _s,  //~ NOTE attempting to move value to here\n             g: _t   //~ NOTE and here"}, {"sha": "c7b573562e3484747c7d272b28e7cd9f7d9ddc19", "filename": "src/test/compile-fail/borrowck-move-in-irrefut-pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fborrowck-move-in-irrefut-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fborrowck-move-in-irrefut-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-in-irrefut-pat.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -19,7 +19,7 @@ fn arg_closure() {\n }\n \n fn let_pat() {\n-    let &_x = &\"hi\".to_owned();\n+    let &_x = &\"hi\".to_string();\n     //~^ ERROR cannot move out of dereference of `&`-pointer\n }\n "}, {"sha": "8a93790d5a2989f9f8930a068684da86b331b57f", "filename": "src/test/compile-fail/borrowck-move-out-of-overloaded-deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-overloaded-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-overloaded-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-overloaded-deref.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -11,6 +11,6 @@\n use std::rc::Rc;\n \n pub fn main() {\n-    let _x = *Rc::new(\"hi\".to_owned());\n+    let _x = *Rc::new(\"hi\".to_string());\n     //~^ ERROR cannot move out of dereference of `&`-pointer\n }"}, {"sha": "e6cb2d67324a4c3a45dd3eb223bff774b2b8f3dc", "filename": "src/test/compile-fail/borrowck-move-out-of-struct-with-dtor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-struct-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-struct-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-struct-with-dtor.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -14,14 +14,14 @@ impl Drop for S {\n }\n \n fn move_in_match() {\n-    match S {f:\"foo\".to_strbuf()} {\n+    match S {f:\"foo\".to_string()} {\n         S {f:_s} => {}\n         //~^ ERROR cannot move out of type `S`, which defines the `Drop` trait\n     }\n }\n \n fn move_in_let() {\n-    let S {f:_s} = S {f:\"foo\".to_strbuf()};\n+    let S {f:_s} = S {f:\"foo\".to_string()};\n     //~^ ERROR cannot move out of type `S`, which defines the `Drop` trait\n }\n "}, {"sha": "625f71849057be5a78cf95f5e50b061770eee016", "filename": "src/test/compile-fail/borrowck-move-out-of-tuple-struct-with-dtor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-tuple-struct-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-tuple-struct-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-tuple-struct-with-dtor.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -14,14 +14,14 @@ impl Drop for S {\n }\n \n fn move_in_match() {\n-    match S(\"foo\".to_strbuf()) {\n+    match S(\"foo\".to_string()) {\n         S(_s) => {}\n         //~^ ERROR cannot move out of type `S`, which defines the `Drop` trait\n     }\n }\n \n fn move_in_let() {\n-    let S(_s) = S(\"foo\".to_strbuf());\n+    let S(_s) = S(\"foo\".to_string());\n     //~^ ERROR cannot move out of type `S`, which defines the `Drop` trait\n }\n "}, {"sha": "4110cfd28efceef44950b2eeba865b9e5b0399dc", "filename": "src/test/compile-fail/borrowck-move-out-of-vec-tail.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -17,9 +17,9 @@ struct Foo {\n \n pub fn main() {\n     let x = vec!(\n-        Foo { string: \"foo\".to_strbuf() },\n-        Foo { string: \"bar\".to_strbuf() },\n-        Foo { string: \"baz\".to_strbuf() }\n+        Foo { string: \"foo\".to_string() },\n+        Foo { string: \"bar\".to_string() },\n+        Foo { string: \"baz\".to_string() }\n     );\n     let x: &[Foo] = x.as_slice();\n     match x {"}, {"sha": "ba1d3a9ddba795c749f2e6b5a4660cbfcf71cbc8", "filename": "src/test/compile-fail/borrowck-ref-into-rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-into-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-into-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-into-rvalue.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -10,7 +10,7 @@\n \n fn main() {\n     let msg;\n-    match Some(\"Hello\".to_owned()) {\n+    match Some(\"Hello\".to_string()) {\n         Some(ref m) => { //~ ERROR borrowed value does not live long enough\n             msg = m;\n         },"}, {"sha": "dd9ab6ca74ed8875e831a9efcfec9df7c6904138", "filename": "src/test/compile-fail/by-move-pattern-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fby-move-pattern-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fby-move-pattern-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fby-move-pattern-binding.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -20,7 +20,7 @@ struct S {\n fn f(x: String) {}\n \n fn main() {\n-    let s = S { x: Bar(\"hello\".to_strbuf()) };\n+    let s = S { x: Bar(\"hello\".to_string()) };\n     match &s.x {\n         &Foo => {}\n         &Bar(identifier) => f(identifier.clone())  //~ ERROR cannot move"}, {"sha": "9c6967b461a0dadd741f2d04b80e74cd7f62cee6", "filename": "src/test/compile-fail/check-static-values-constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -109,7 +109,7 @@ static mut STATIC13: SafeStruct = SafeStruct{field1: Variant1, field2: Variant3(\n static mut STATIC14: SafeStruct = SafeStruct {\n //~^ ERROR mutable static items are not allowed to have destructors\n     field1: Variant1,\n-    field2: Variant4(\"str\".to_strbuf())\n+    field2: Variant4(\"str\".to_string())\n };\n \n static STATIC15: &'static [Box<MyOwned>] = &'static [box MyOwned, box MyOwned];"}, {"sha": "ac5ec1236ff9d083294b9503ac261c84022f0436", "filename": "src/test/compile-fail/circular_modules_main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fcircular_modules_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fcircular_modules_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcircular_modules_main.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -12,7 +12,7 @@\n mod circular_modules_hello; //~ERROR: circular modules\n \n pub fn hi_str() -> String {\n-  \"Hi!\".to_owned()\n+  \"Hi!\".to_string()\n }\n \n fn main() {"}, {"sha": "ae0f377ba879d62be21e1f9c2590867fa86a23a9", "filename": "src/test/compile-fail/class-cast-to-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -58,6 +58,6 @@ fn cat(in_x : uint, in_y : int, in_name: String) -> cat {\n }\n \n fn main() {\n-  let nyan: Box<noisy> = box cat(0, 2, \"nyan\".to_strbuf()) as Box<noisy>;\n+  let nyan: Box<noisy> = box cat(0, 2, \"nyan\".to_string()) as Box<noisy>;\n   nyan.eat(); //~ ERROR does not implement any method in scope named `eat`\n }"}, {"sha": "2621820c2229f4a874762b9c3923cfdfa02c0bb9", "filename": "src/test/compile-fail/disallowed-deconstructing-destructing-struct-let.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-let.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -24,7 +24,7 @@ fn unwrap(x: X) -> String {\n }\n \n fn main() {\n-    let x = X { x: \"hello\".to_strbuf() };\n+    let x = X { x: \"hello\".to_string() };\n     let y = unwrap(x);\n     println!(\"contents: {}\", y);\n }"}, {"sha": "5078009d4b2227e4bd3626b27e2c13fbb2022c68", "filename": "src/test/compile-fail/disallowed-deconstructing-destructing-struct-match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-match.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -19,7 +19,7 @@ impl Drop for X {\n }\n \n fn main() {\n-    let x = X { x: \"hello\".to_strbuf() };\n+    let x = X { x: \"hello\".to_string() };\n \n     match x {\n         X { x: y } => println!(\"contents: {}\", y)"}, {"sha": "9186dada780c039efa6895bb33587755cbb2567e", "filename": "src/test/compile-fail/error-should-say-copy-not-pod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Ferror-should-say-copy-not-pod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Ferror-should-say-copy-not-pod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ferror-should-say-copy-not-pod.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -13,5 +13,5 @@\n fn check_bound<T:Copy>(_: T) {}\n \n fn main() {\n-    check_bound(\"nocopy\".to_owned()); //~ ERROR does not fulfill `Copy`\n+    check_bound(\"nocopy\".to_string()); //~ ERROR does not fulfill `Copy`\n }"}, {"sha": "967229a34074bd7259cdb9370493b87fe02791ee", "filename": "src/test/compile-fail/integral-indexing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -10,7 +10,7 @@\n \n pub fn main() {\n     let v: Vec<int> = vec!(0, 1, 2, 3, 4, 5);\n-    let s: String = \"abcdef\".to_strbuf();\n+    let s: String = \"abcdef\".to_string();\n     assert_eq!(v.as_slice()[3u], 3);\n     assert_eq!(v.as_slice()[3u8], 3); //~ ERROR: mismatched types\n     assert_eq!(v.as_slice()[3i8], 3); //~ ERROR: mismatched types"}, {"sha": "8a99633b4fc112641ddbb7a310cedb21823d2a0f", "filename": "src/test/compile-fail/issue-10412.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fissue-10412.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fissue-10412.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10412.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -26,7 +26,7 @@ impl<'self> Serializable<str> for &'self str { //~ ERROR no longer a special lif\n \n fn main() {\n     println!(\"hello\");\n-    let x = \"foo\".to_owned();\n+    let x = \"foo\".to_string();\n     let y = x;\n     println!(\"{}\", y);\n }"}, {"sha": "85bad9f8d60121adb29d1f29e54e5ac85d063a6c", "filename": "src/test/compile-fail/issue-13428.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fissue-13428.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fissue-13428.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13428.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -19,7 +19,7 @@ fn foo() -> String {  //~ ERROR not all control paths return a value\n }\n \n fn bar() -> String {  //~ ERROR not all control paths return a value\n-    \"foobar\".to_strbuf()\n+    \"foobar\".to_string()\n     ;   //~ NOTE consider removing this semicolon\n }\n "}, {"sha": "2c3dda015471fd265aa9ef2d19dc8797bbf3fbd4", "filename": "src/test/compile-fail/issue-2063.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -23,7 +23,7 @@ trait to_str_2 {\n // the compiler to attempt autoderef and then\n // try to resolve the method.\n impl to_str_2 for t {\n-    fn my_to_str() -> String { \"t\".to_strbuf() }\n+    fn my_to_str() -> String { \"t\".to_string() }\n }\n \n fn new_t(x: t) {"}, {"sha": "e920976069accd0d536127e3e33b06962f8db187", "filename": "src/test/compile-fail/issue-6458-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn foo(b: bool) -> Result<bool,String> {\n-    Err(\"bar\".to_owned());\n+    Err(\"bar\".to_string());\n     //~^ ERROR: cannot determine a type for this expression: unconstrained type\n }\n "}, {"sha": "0ce3a62343f275bcb4093d23ad0a076af6061756", "filename": "src/test/compile-fail/issue-7573.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -17,8 +17,8 @@ pub struct CrateId {\n impl CrateId {\n     fn new(s: &str) -> CrateId {\n         CrateId {\n-            local_path: s.to_strbuf(),\n-            junk: \"wutevs\".to_strbuf()\n+            local_path: s.to_string(),\n+            junk: \"wutevs\".to_string()\n         }\n     }\n }"}, {"sha": "edbdc77f0306d3be89fa6295e93a20f5498bc825", "filename": "src/test/compile-fail/match-vec-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    match \"foo\".to_strbuf() {\n+    match \"foo\".to_string() {\n         ['f', 'o', ..] => {} //~ ERROR mismatched types\n         _ => { }\n     }"}, {"sha": "a94b0709646383a2136db8701b0cf242ed1d28a5", "filename": "src/test/compile-fail/match-vec-unreachable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -18,9 +18,9 @@ fn main() {\n         _ => ()\n     }\n \n-    let x: Vec<String> = vec![\"foo\".to_strbuf(),\n-                              \"bar\".to_strbuf(),\n-                              \"baz\".to_strbuf()];\n+    let x: Vec<String> = vec![\"foo\".to_string(),\n+                              \"bar\".to_string(),\n+                              \"baz\".to_string()];\n     let x: &[String] = x.as_slice();\n     match x {\n         [a, _, _, ..] => { println!(\"{}\", a); }"}, {"sha": "1ba30c67a03cfac40b205ee027c61b09426a4bae", "filename": "src/test/compile-fail/minus-string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fminus-string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fminus-string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fminus-string.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -10,4 +10,4 @@\n \n // error-pattern:cannot apply unary operator `-` to type `std::string::String`\n \n-fn main() { -\"foo\".to_strbuf(); }\n+fn main() { -\"foo\".to_string(); }"}, {"sha": "fd44b693dde6a2b1d8bc0ae2433efb29d8128d15", "filename": "src/test/compile-fail/moves-based-on-type-access-to-field.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -16,13 +16,13 @@ fn consume(_s: String) {}\n fn touch<A>(_a: &A) {}\n \n fn f10() {\n-    let x = Foo { f: \"hi\".to_strbuf(), y: 3 };\n+    let x = Foo { f: \"hi\".to_string(), y: 3 };\n     consume(x.f);\n     touch(&x.y); //~ ERROR use of partially moved value: `x`\n }\n \n fn f20() {\n-    let x = vec!(\"hi\".to_strbuf());\n+    let x = vec!(\"hi\".to_string());\n     consume(x.move_iter().next().unwrap());\n     touch(x.get(0)); //~ ERROR use of moved value: `x`\n }"}, {"sha": "97287c147d73f2d8f7da88bde0c2a923c23bb46b", "filename": "src/test/compile-fail/moves-based-on-type-capture-clause-bad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-capture-clause-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-capture-clause-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-capture-clause-bad.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -11,7 +11,7 @@\n use std::task;\n \n fn main() {\n-    let x = \"Hello world!\".to_owned();\n+    let x = \"Hello world!\".to_string();\n     task::spawn(proc() {\n         println!(\"{}\", x);\n     });"}, {"sha": "f30360af46eb4128fb0b0652c05b21638b417317", "filename": "src/test/compile-fail/moves-based-on-type-distribute-copy-over-paren.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-distribute-copy-over-paren.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-distribute-copy-over-paren.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-distribute-copy-over-paren.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -15,37 +15,37 @@ struct Foo<A> { f: A }\n fn touch<A>(_a: &A) {}\n \n fn f00() {\n-    let x = \"hi\".to_owned();\n+    let x = \"hi\".to_string();\n     let _y = Foo { f:x }; //~ NOTE `x` moved here\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n \n fn f05() {\n-    let x = \"hi\".to_owned();\n+    let x = \"hi\".to_string();\n     let _y = Foo { f:(((x))) }; //~ NOTE `x` moved here\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n \n fn f10() {\n-    let x = \"hi\".to_owned();\n+    let x = \"hi\".to_string();\n     let _y = Foo { f:x.clone() };\n     touch(&x);\n }\n \n fn f20() {\n-    let x = \"hi\".to_owned();\n+    let x = \"hi\".to_string();\n     let _y = Foo { f:(x).clone() };\n     touch(&x);\n }\n \n fn f30() {\n-    let x = \"hi\".to_owned();\n+    let x = \"hi\".to_string();\n     let _y = Foo { f:((x)).clone() };\n     touch(&x);\n }\n \n fn f40() {\n-    let x = \"hi\".to_owned();\n+    let x = \"hi\".to_string();\n     let _y = Foo { f:(((((((x)).clone()))))) };\n     touch(&x);\n }"}, {"sha": "82aa5c36c8e4342f04990f761a6fcfb9706be8d0", "filename": "src/test/compile-fail/moves-based-on-type-exprs.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -18,13 +18,13 @@ fn guard(_s: String) -> bool {fail!()}\n fn touch<A>(_a: &A) {}\n \n fn f10() {\n-    let x = \"hi\".to_strbuf();\n+    let x = \"hi\".to_string();\n     let _y = Foo { f:x };\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n \n fn f20() {\n-    let x = \"hi\".to_strbuf();\n+    let x = \"hi\".to_string();\n     let _y = (x, 3);\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n@@ -36,8 +36,8 @@ fn f21() {\n }\n \n fn f30(cond: bool) {\n-    let x = \"hi\".to_strbuf();\n-    let y = \"ho\".to_strbuf();\n+    let x = \"hi\".to_string();\n+    let y = \"ho\".to_string();\n     let _y = if cond {\n         x\n     } else {\n@@ -48,8 +48,8 @@ fn f30(cond: bool) {\n }\n \n fn f40(cond: bool) {\n-    let x = \"hi\".to_strbuf();\n-    let y = \"ho\".to_strbuf();\n+    let x = \"hi\".to_string();\n+    let y = \"ho\".to_string();\n     let _y = match cond {\n         true => x,\n         false => y\n@@ -59,8 +59,8 @@ fn f40(cond: bool) {\n }\n \n fn f50(cond: bool) {\n-    let x = \"hi\".to_strbuf();\n-    let y = \"ho\".to_strbuf();\n+    let x = \"hi\".to_string();\n+    let y = \"ho\".to_string();\n     let _y = match cond {\n         _ if guard(x) => 10,\n         true => 10,\n@@ -71,31 +71,31 @@ fn f50(cond: bool) {\n }\n \n fn f70() {\n-    let x = \"hi\".to_strbuf();\n+    let x = \"hi\".to_string();\n     let _y = [x];\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n \n fn f80() {\n-    let x = \"hi\".to_strbuf();\n+    let x = \"hi\".to_string();\n     let _y = vec!(x);\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n \n fn f100() {\n-    let x = vec!(\"hi\".to_strbuf());\n+    let x = vec!(\"hi\".to_string());\n     let _y = x.move_iter().next().unwrap();\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n \n fn f110() {\n-    let x = vec!(\"hi\".to_strbuf());\n+    let x = vec!(\"hi\".to_string());\n     let _y = [x.move_iter().next().unwrap(), ..1];\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n \n fn f120() {\n-    let mut x = vec!(\"hi\".to_strbuf(), \"ho\".to_strbuf());\n+    let mut x = vec!(\"hi\".to_string(), \"ho\".to_string());\n     x.as_mut_slice().swap(0, 1);\n     touch(x.get(0));\n     touch(x.get(1));"}, {"sha": "65ae25396c8d625502a099a354afc2676ab1e144", "filename": "src/test/compile-fail/moves-based-on-type-match-bindings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-match-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-match-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-match-bindings.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -17,7 +17,7 @@ fn guard(_s: String) -> bool {fail!()}\n fn touch<A>(_a: &A) {}\n \n fn f10() {\n-    let x = Foo {f: \"hi\".to_owned()};\n+    let x = Foo {f: \"hi\".to_string()};\n \n     let y = match x {\n         Foo {f} => {} //~ NOTE moved here"}, {"sha": "3521347705b95b668d5441bee750ced19a8acaa9", "filename": "src/test/compile-fail/moves-based-on-type-no-recursive-stack-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -20,7 +20,7 @@ struct R<'a> {\n }\n \n fn innocent_looking_victim() {\n-    let mut x = Some(\"hello\".to_owned());\n+    let mut x = Some(\"hello\".to_string());\n     conspirator(|f, writer| {\n         if writer {\n             x = None;"}, {"sha": "f772b96c697b7b9cc996e9f23584debc18892d31", "filename": "src/test/compile-fail/multitrait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fmultitrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fmultitrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmultitrait.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -14,5 +14,5 @@ struct S {\n \n impl Cmp, ToStr for S { //~ ERROR: expected `{` but found `,`\n   fn eq(&&other: S) { false }\n-  fn to_str(&self) -> String { \"hi\".to_owned() }\n+  fn to_str(&self) -> String { \"hi\".to_string() }\n }"}, {"sha": "d1e50638138c40fc5df877766079165dc75bcc6a", "filename": "src/test/compile-fail/syntax-extension-minor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-minor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-minor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-minor.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -13,8 +13,8 @@\n #![feature(concat_idents)]\n \n pub fn main() {\n-    let asdf_fdsa = \"<.<\".to_owned();\n-    assert_eq!(concat_idents!(asd, f_f, dsa), \"<.<\".to_owned());\n+    let asdf_fdsa = \"<.<\".to_string();\n+    assert_eq!(concat_idents!(asd, f_f, dsa), \"<.<\".to_string());\n     //~^ ERROR: unresolved name `asdf_fdsa`\n \n     assert!(stringify!(use_mention_distinction) =="}, {"sha": "5f4d51918edc0e901b0b33a39016fce3ef28ea28", "filename": "src/test/compile-fail/trait-coercion-generic-regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -24,7 +24,7 @@ impl Trait<&'static str> for Struct {\n }\n \n fn main() {\n-    let person = \"Fred\".to_owned();\n+    let person = \"Fred\".to_string();\n     let person: &str = person.as_slice();  //~ ERROR `person` does not live long enough\n     let s: Box<Trait<&'static str>> = box Struct { person: person };\n }"}, {"sha": "7c9b2f34ae90fc583cf94476e7a7e753bfd6f83f", "filename": "src/test/compile-fail/unsendable-class.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -26,7 +26,7 @@ fn foo(i:int, j: @String) -> foo {\n }\n \n fn main() {\n-  let cat = \"kitty\".to_strbuf();\n+  let cat = \"kitty\".to_string();\n   let (tx, _) = channel(); //~ ERROR does not fulfill `Send`\n   tx.send(foo(42, @(cat))); //~ ERROR does not fulfill `Send`\n }"}, {"sha": "e2167ca446f2cc1db1bafbcae2160ec7e4167dea", "filename": "src/test/compile-fail/use-after-move-based-on-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fuse-after-move-based-on-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fcompile-fail%2Fuse-after-move-based-on-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-based-on-type.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let x = \"Hello!\".to_owned();\n+    let x = \"Hello!\".to_string();\n     let _y = x;\n     println!(\"{}\", x); //~ ERROR use of moved value\n }"}, {"sha": "5cf6d838f253fc987ae2b2cc8a8fea6afb25e326", "filename": "src/test/pretty/match-naked-expr-medium.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fpretty%2Fmatch-naked-expr-medium.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fpretty%2Fmatch-naked-expr-medium.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fmatch-naked-expr-medium.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -15,10 +15,10 @@ fn main() {\n     let _y =\n         match x {\n             Some(_) =>\n-            [\"some(_)\".to_owned(), \"not\".to_owned(), \"SO\".to_owned(),\n-             \"long\".to_owned(), \"string\".to_owned()],\n+            [\"some(_)\".to_string(), \"not\".to_string(), \"SO\".to_string(),\n+             \"long\".to_string(), \"string\".to_string()],\n             None =>\n-            [\"none\".to_owned(), \"a\".to_owned(), \"a\".to_owned(),\n-             \"a\".to_owned(), \"a\".to_owned()]\n+            [\"none\".to_string(), \"a\".to_string(), \"a\".to_string(),\n+             \"a\".to_string(), \"a\".to_string()]\n         };\n }"}, {"sha": "bb14a74fc183e8ce0daf2f1a80f70da8da15c908", "filename": "src/test/pretty/match-naked-expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fpretty%2Fmatch-naked-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Fpretty%2Fmatch-naked-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fmatch-naked-expr.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -14,7 +14,7 @@ fn main() {\n     let x = Some(3);\n     let _y =\n         match x {\n-            Some(_) => \"some(_)\".to_owned(),\n-            None => \"none\".to_owned()\n+            Some(_) => \"some(_)\".to_string(),\n+            None => \"none\".to_string()\n         };\n }"}, {"sha": "a1a8eb6a092dc146d21bd027d28568bd6f6893da", "filename": "src/test/run-fail/assert-macro-owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-fail%2Fassert-macro-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-fail%2Fassert-macro-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fassert-macro-owned.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -11,5 +11,5 @@\n // error-pattern:failed at 'test-assert-owned'\n \n fn main() {\n-    assert!(false, \"test-assert-owned\".to_strbuf());\n+    assert!(false, \"test-assert-owned\".to_string());\n }"}, {"sha": "1ae520bbf1a74d2e3628e3f384605e34e48c3911", "filename": "src/test/run-fail/binop-fail-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-fail%2Fbinop-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-fail%2Fbinop-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbinop-fail-2.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -10,4 +10,4 @@\n \n // error-pattern:quux\n fn my_err(s: String) -> ! { println!(\"{}\", s); fail!(\"quux\"); }\n-fn main() { 3u == my_err(\"bye\".to_strbuf()); }\n+fn main() { 3u == my_err(\"bye\".to_string()); }"}, {"sha": "1ae520bbf1a74d2e3628e3f384605e34e48c3911", "filename": "src/test/run-fail/binop-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-fail%2Fbinop-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-fail%2Fbinop-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbinop-fail.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -10,4 +10,4 @@\n \n // error-pattern:quux\n fn my_err(s: String) -> ! { println!(\"{}\", s); fail!(\"quux\"); }\n-fn main() { 3u == my_err(\"bye\".to_strbuf()); }\n+fn main() { 3u == my_err(\"bye\".to_string()); }"}, {"sha": "ea643fd26d93d360e9172adf46cc968447cd7c26", "filename": "src/test/run-fail/fail-task-name-owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-fail%2Ffail-task-name-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-fail%2Ffail-task-name-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-task-name-owned.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -13,7 +13,7 @@\n use std::task::TaskBuilder;\n \n fn main() {\n-    TaskBuilder::new().named(\"owned name\".to_owned()).try(proc() {\n+    TaskBuilder::new().named(\"owned name\".to_string()).try(proc() {\n         fail!(\"test\");\n         1\n     }).unwrap()"}, {"sha": "ae89f9518406a2ac1f87dfce70aefd8722289d77", "filename": "src/test/run-fail/fmt-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-fail%2Ffmt-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-fail%2Ffmt-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffmt-fail.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -11,6 +11,6 @@\n // error-pattern:meh\n \n fn main() {\n-    let str_var: String = \"meh\".to_strbuf();\n+    let str_var: String = \"meh\".to_string();\n     fail!(\"{}\", str_var);\n }"}, {"sha": "d80ae967f0e2c2e1c35a31b73284e4b5b4230f39", "filename": "src/test/run-fail/if-cond-bot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-fail%2Fif-cond-bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-fail%2Fif-cond-bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fif-cond-bot.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -10,4 +10,4 @@\n \n // error-pattern:quux\n fn my_err(s: String) -> ! { println!(\"{}\", s); fail!(\"quux\"); }\n-fn main() { if my_err(\"bye\".to_strbuf()) { } }\n+fn main() { if my_err(\"bye\".to_string()) { } }"}, {"sha": "549a101654ba2fbcb048722508968852f0bcf7d6", "filename": "src/test/run-fail/result-get-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -13,5 +13,5 @@\n use std::result;\n \n fn main() {\n-    println!(\"{:?}\", result::Err::<int,String>(\"kitty\".to_strbuf()).unwrap());\n+    println!(\"{:?}\", result::Err::<int,String>(\"kitty\".to_string()).unwrap());\n }"}, {"sha": "26c5a6988cf13d3c7bed9c816bf9ca3ed40cc97c", "filename": "src/test/run-fail/str-overrun.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fstr-overrun.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -11,7 +11,7 @@\n \n // error-pattern:index out of bounds: the len is 5 but the index is 5\n fn main() {\n-    let s: String = \"hello\".to_strbuf();\n+    let s: String = \"hello\".to_string();\n \n     // Bounds-check failure.\n     assert_eq!(s.as_slice()[5], 0x0 as u8);"}, {"sha": "08c8461afe02929d79a55131485fce9ed5ffd054", "filename": "src/test/run-fail/unwind-box-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-fail%2Funwind-box-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-fail%2Funwind-box-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-box-str.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -17,7 +17,7 @@ fn failfn() {\n }\n \n fn main() {\n-    let x = @\"hi\".to_owned();\n+    let x = @\"hi\".to_string();\n     failfn();\n     println!(\"{:?}\", x);\n }"}, {"sha": "00183aa674fa455435a702b80c1c33032e022dc9", "filename": "src/test/run-fail/unwind-lambda.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-fail%2Funwind-lambda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-fail%2Funwind-lambda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-lambda.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -13,8 +13,8 @@\n // error-pattern:fail\n \n fn main() {\n-    let cheese = \"roquefort\".to_strbuf();\n-    let carrots = @\"crunchy\".to_strbuf();\n+    let cheese = \"roquefort\".to_string();\n+    let carrots = @\"crunchy\".to_string();\n \n     let result: |@String, |String||: 'static = (|tasties, macerate| {\n         macerate((*tasties).clone());"}, {"sha": "4af77c434829a14d72d80335ad63d8489cac2cb2", "filename": "src/test/run-fail/unwind-match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-fail%2Funwind-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-fail%2Funwind-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-match.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -16,9 +16,9 @@ fn test_box() {\n     @0;\n }\n fn test_str() {\n-  let res = match false { true => { \"happy\".to_owned() },\n+  let res = match false { true => { \"happy\".to_string() },\n      _ => fail!(\"non-exhaustive match failure\") };\n-  assert_eq!(res, \"happy\".to_owned());\n+  assert_eq!(res, \"happy\".to_string());\n }\n fn main() {\n     test_box();"}, {"sha": "a02c04b3de87f13dee9a55d99f8239a2e3ade70f", "filename": "src/test/run-fail/unwind-misc-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -22,9 +22,9 @@ fn main() {\n     let mut map = collections::HashMap::new();\n     let mut arr = Vec::new();\n     for _i in range(0u, 10u) {\n-        arr.push(@\"key stuff\".to_strbuf());\n+        arr.push(@\"key stuff\".to_string());\n         map.insert(arr.clone(),\n-                   arr.clone().append([@\"value stuff\".to_strbuf()]));\n+                   arr.clone().append([@\"value stuff\".to_string()]));\n         if arr.len() == 5 {\n             fail!();\n         }"}, {"sha": "36b525c134b9940e7e01d6c26ca984edaa42f4a5", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -57,20 +57,20 @@ fn main() {\n     let cx = mk_ctxt();\n \n     let abc = quote_expr!(cx, 23);\n-    check_pp(ext_cx, abc,  pprust::print_expr, \"23\".to_owned());\n+    check_pp(ext_cx, abc,  pprust::print_expr, \"23\".to_string());\n \n \n     let ty = quote_ty!(cx, int);\n-    check_pp(ext_cx, ty, pprust::print_type, \"int\".to_owned());\n+    check_pp(ext_cx, ty, pprust::print_type, \"int\".to_string());\n \n     let item = quote_item!(cx, static x : int = 10;).get();\n-    check_pp(ext_cx, item, pprust::print_item, \"static x: int = 10;\".to_owned());\n+    check_pp(ext_cx, item, pprust::print_item, \"static x: int = 10;\".to_string());\n \n     let stmt = quote_stmt!(cx, let x = 20;);\n-    check_pp(ext_cx, *stmt, pprust::print_stmt, \"let x = 20;\".to_owned());\n+    check_pp(ext_cx, *stmt, pprust::print_stmt, \"let x = 20;\".to_string());\n \n     let pat = quote_pat!(cx, Some(_));\n-    check_pp(ext_cx, pat, pprust::print_pat, \"Some(_)\".to_owned());\n+    check_pp(ext_cx, pat, pprust::print_pat, \"Some(_)\".to_string());\n \n }\n \n@@ -82,7 +82,7 @@ fn check_pp<T>(cx: fake_ext_ctxt,\n         pp::eof(pp.s);\n     });\n     stdout().write_line(s);\n-    if expect != \"\".to_owned() {\n+    if expect != \"\".to_string() {\n         println!(\"expect: '%s', got: '%s'\", expect, s);\n         assert_eq!(s, expect);\n     }"}, {"sha": "4adf10636e6a7897d94afb5551418a4d1e47f1da", "filename": "src/test/run-pass/assert-eq-macro-success.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fassert-eq-macro-success.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fassert-eq-macro-success.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassert-eq-macro-success.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -15,7 +15,7 @@ struct Point { x : int }\n \n pub fn main() {\n     assert_eq!(14,14);\n-    assert_eq!(\"abc\".to_owned(),\"abc\".to_owned());\n+    assert_eq!(\"abc\".to_string(),\"abc\".to_string());\n     assert_eq!(box Point{x:34},box Point{x:34});\n     assert_eq!(&Point{x:34},&Point{x:34});\n     assert_eq!(@Point{x:34},@Point{x:34});"}, {"sha": "5d1a502490140cadd527462d0a9a9292831cb6dc", "filename": "src/test/run-pass/autobind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fautobind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fautobind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautobind.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -16,6 +16,6 @@ fn g(act: |Vec<int> | -> int) -> int { return act(vec!(1, 2, 3)); }\n pub fn main() {\n     assert_eq!(g(f), 1);\n     let f1: |Vec<String>| -> String = f;\n-    assert_eq!(f1(vec![\"x\".to_strbuf(), \"y\".to_strbuf(), \"z\".to_strbuf()]),\n-               \"x\".to_strbuf());\n+    assert_eq!(f1(vec![\"x\".to_string(), \"y\".to_string(), \"z\".to_string()]),\n+               \"x\".to_string());\n }"}, {"sha": "e10428e3c5dc24453afddbbdb7fcd489c87ed3eb", "filename": "src/test/run-pass/autoref-intermediate-types-issue-3585.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fautoref-intermediate-types-issue-3585.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fautoref-intermediate-types-issue-3585.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoref-intermediate-types-issue-3585.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -28,5 +28,5 @@ impl Foo for uint {\n \n pub fn main() {\n     let x = @3u;\n-    assert_eq!(x.foo(), \"@3\".to_strbuf());\n+    assert_eq!(x.foo(), \"@3\".to_string());\n }"}, {"sha": "894c54218b45120a92053d93826b0af677222b99", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -36,14 +36,14 @@ fn double() {\n fn runtest(me: &str) {\n     let mut env = os::env().move_iter()\n                            .map(|(ref k, ref v)| {\n-                               (k.to_strbuf(), v.to_strbuf())\n+                               (k.to_string(), v.to_string())\n                            }).collect::<Vec<(String,String)>>();\n     match env.iter()\n              .position(|&(ref s, _)| \"RUST_BACKTRACE\" == s.as_slice()) {\n         Some(i) => { env.remove(i); }\n         None => {}\n     }\n-    env.push((\"RUST_BACKTRACE\".to_strbuf(), \"1\".to_strbuf()));\n+    env.push((\"RUST_BACKTRACE\".to_string(), \"1\".to_string()));\n \n     // Make sure that the stack trace is printed\n     let mut p = Command::new(me).arg(\"fail\").env(env.as_slice()).spawn().unwrap();"}, {"sha": "63051d71271dde0314978206707352e4be051686", "filename": "src/test/run-pass/block-explicit-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fblock-explicit-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fblock-explicit-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-explicit-types.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -10,5 +10,5 @@\n \n pub fn main() {\n     fn as_buf<T>(s: String, f: |String| -> T) -> T { f(s) }\n-    as_buf(\"foo\".to_strbuf(), |foo: String| -> () println!(\"{}\", foo) );\n+    as_buf(\"foo\".to_string(), |foo: String| -> () println!(\"{}\", foo) );\n }"}, {"sha": "75b54b1af86bd4e45eb8a4b5becbe7254e17adc2", "filename": "src/test/run-pass/borrowed-ptr-pattern-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-2.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -16,6 +16,6 @@ fn foo(s: &String) -> bool {\n }\n \n pub fn main() {\n-    assert!(foo(&\"kitty\".to_strbuf()));\n-    assert!(!foo(&\"gata\".to_strbuf()));\n+    assert!(foo(&\"kitty\".to_string()));\n+    assert!(!foo(&\"gata\".to_string()));\n }"}, {"sha": "ba41b1ffe9d037386847c7bbb105d1763a6ff500", "filename": "src/test/run-pass/box-compare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fbox-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fbox-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-compare.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -12,6 +12,6 @@\n \n pub fn main() {\n     assert!((@1 < @3));\n-    assert!((@@\"hello \".to_owned() > @@\"hello\".to_owned()));\n-    assert!((@@@\"hello\".to_owned() != @@@\"there\".to_owned()));\n+    assert!((@@\"hello \".to_string() > @@\"hello\".to_string()));\n+    assert!((@@@\"hello\".to_string() != @@@\"there\".to_string()));\n }"}, {"sha": "7ed5f5aef9fb767c1e566b9d90ca0c0ad2938e47", "filename": "src/test/run-pass/bug-7183-generics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fbug-7183-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fbug-7183-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbug-7183-generics.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -34,11 +34,11 @@ impl<T: Speak> Speak for Option<T> {\n \n \n pub fn main() {\n-    assert_eq!(3.hi(), \"hello: 3\".to_strbuf());\n+    assert_eq!(3.hi(), \"hello: 3\".to_string());\n     assert_eq!(Some(Some(3)).hi(),\n-               \"something!something!hello: 3\".to_strbuf());\n-    assert_eq!(None::<int>.hi(), \"hello - none\".to_strbuf());\n+               \"something!something!hello: 3\".to_string());\n+    assert_eq!(None::<int>.hi(), \"hello - none\".to_string());\n \n-    assert_eq!(Some(None::<int>).hi(), \"something!hello - none\".to_strbuf());\n-    assert_eq!(Some(3).hi(), \"something!hello: 3\".to_strbuf());\n+    assert_eq!(Some(None::<int>).hi(), \"something!hello - none\".to_string());\n+    assert_eq!(Some(3).hi(), \"something!hello: 3\".to_string());\n }"}, {"sha": "540a00d3a3122b5b4c767a58de2916ba8d42a05a", "filename": "src/test/run-pass/c-stack-returning-int64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -30,7 +30,7 @@ fn atoll(s: String) -> i64 {\n }\n \n pub fn main() {\n-    assert_eq!(atol(\"1024\".to_strbuf()) * 10, atol(\"10240\".to_strbuf()));\n-    assert!((atoll(\"11111111111111111\".to_strbuf()) * 10) ==\n-             atoll(\"111111111111111110\".to_strbuf()));\n+    assert_eq!(atol(\"1024\".to_string()) * 10, atol(\"10240\".to_string()));\n+    assert!((atoll(\"11111111111111111\".to_string()) * 10) ==\n+             atoll(\"111111111111111110\".to_string()));\n }"}, {"sha": "beffc171cd5cdb1723791d6fc71f1db1c1da0a28", "filename": "src/test/run-pass/cci_nested_exe.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fcci_nested_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fcci_nested_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_nested_exe.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -17,14 +17,14 @@ use cci_nested_lib::*;\n \n pub fn main() {\n     let lst = new_int_alist();\n-    alist_add(&lst, 22, \"hi\".to_owned());\n-    alist_add(&lst, 44, \"ho\".to_owned());\n-    assert_eq!(alist_get(&lst, 22), \"hi\".to_owned());\n-    assert_eq!(alist_get(&lst, 44), \"ho\".to_owned());\n+    alist_add(&lst, 22, \"hi\".to_string());\n+    alist_add(&lst, 44, \"ho\".to_string());\n+    assert_eq!(alist_get(&lst, 22), \"hi\".to_string());\n+    assert_eq!(alist_get(&lst, 44), \"ho\".to_string());\n \n     let lst = new_int_alist_2();\n-    alist_add(&lst, 22, \"hi\".to_owned());\n-    alist_add(&lst, 44, \"ho\".to_owned());\n-    assert_eq!(alist_get(&lst, 22), \"hi\".to_owned());\n-    assert_eq!(alist_get(&lst, 44), \"ho\".to_owned());\n+    alist_add(&lst, 22, \"hi\".to_string());\n+    alist_add(&lst, 44, \"ho\".to_string());\n+    assert_eq!(alist_get(&lst, 22), \"hi\".to_string());\n+    assert_eq!(alist_get(&lst, 44), \"ho\".to_string());\n }"}, {"sha": "82855729fa882ac69f19344332b27cd7ac7d180a", "filename": "src/test/run-pass/child-outlives-parent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -15,5 +15,5 @@ use std::task;\n fn child2(_s: String) { }\n \n pub fn main() {\n-    let _x = task::spawn(proc() child2(\"hi\".to_strbuf()));\n+    let _x = task::spawn(proc() child2(\"hi\".to_string()));\n }"}, {"sha": "28081e5292aaae022b0a8bc039e9cc2690f93be2", "filename": "src/test/run-pass/class-attributes-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -24,4 +24,4 @@ impl Drop for cat {\n #[cat_maker]\n fn cat(name: String) -> cat { cat{name: name,} }\n \n-pub fn main() { let _kitty = cat(\"Spotty\".to_strbuf()); }\n+pub fn main() { let _kitty = cat(\"Spotty\".to_string()); }"}, {"sha": "bd62f838444afad24580d6f230e23f6c7238d5cd", "filename": "src/test/run-pass/class-attributes-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-attributes-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-attributes-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-attributes-2.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -34,5 +34,5 @@ fn cat(name: String) -> cat {\n }\n \n pub fn main() {\n-  let _kitty = cat(\"Spotty\".to_strbuf());\n+  let _kitty = cat(\"Spotty\".to_string());\n }"}, {"sha": "f3d12d21684e4f9324d9746bf96df4cd7bd712c3", "filename": "src/test/run-pass/class-cast-to-trait-cross-crate-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -17,10 +17,10 @@ use cci_class_cast::kitty::cat;\n fn print_out(thing: Box<ToStr>, expected: String) {\n   let actual = thing.to_str();\n   println!(\"{}\", actual);\n-  assert_eq!(actual.to_strbuf(), expected);\n+  assert_eq!(actual.to_string(), expected);\n }\n \n pub fn main() {\n-  let nyan: Box<ToStr> = box cat(0u, 2, \"nyan\".to_strbuf()) as Box<ToStr>;\n-  print_out(nyan, \"nyan\".to_strbuf());\n+  let nyan: Box<ToStr> = box cat(0u, 2, \"nyan\".to_string()) as Box<ToStr>;\n+  print_out(nyan, \"nyan\".to_string());\n }"}, {"sha": "982b8f1d900fd20b1216afa6792c751e36919ac1", "filename": "src/test/run-pass/class-cast-to-trait-multiple-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -93,7 +93,7 @@ fn annoy_neighbors(critter: &mut noisy) {\n }\n \n pub fn main() {\n-  let mut nyan: cat = cat(0u, 2, \"nyan\".to_strbuf());\n+  let mut nyan: cat = cat(0u, 2, \"nyan\".to_string());\n   let mut whitefang: dog = dog();\n   annoy_neighbors(&mut nyan);\n   annoy_neighbors(&mut whitefang);"}, {"sha": "2525066ed6bdfc18bd1e0fb4e1ff7145a6255d11", "filename": "src/test/run-pass/class-cast-to-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -60,7 +60,7 @@ fn cat(in_x : uint, in_y : int, in_name: String) -> cat {\n \n \n pub fn main() {\n-    let mut nyan = cat(0u, 2, \"nyan\".to_strbuf());\n+    let mut nyan = cat(0u, 2, \"nyan\".to_string());\n     let mut nyan: &mut noisy = &mut nyan;\n     nyan.speak();\n }"}, {"sha": "80f8ed936370b5b9f51f3d7076d7b3bd7e3baf85", "filename": "src/test/run-pass/class-exports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-exports.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -33,6 +33,6 @@ mod kitty {\n }\n \n pub fn main() {\n-  assert_eq!(cat(\"Spreckles\".to_strbuf()).get_name(),\n-                 \"Spreckles\".to_strbuf());\n+  assert_eq!(cat(\"Spreckles\".to_string()).get_name(),\n+                 \"Spreckles\".to_string());\n }"}, {"sha": "285566570b185956cae9bdedc7c23c10cf43cb1e", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -114,9 +114,9 @@ impl<T> cat<T> {\n }\n \n pub fn main() {\n-    let mut nyan: cat<String> = cat::new(0, 2, \"nyan\".to_strbuf());\n+    let mut nyan: cat<String> = cat::new(0, 2, \"nyan\".to_string());\n     for _ in range(1u, 5) { nyan.speak(); }\n-    assert!(*nyan.find(&1).unwrap() == \"nyan\".to_strbuf());\n+    assert!(*nyan.find(&1).unwrap() == \"nyan\".to_string());\n     assert_eq!(nyan.find(&10), None);\n     let mut spotty: cat<cat_type> = cat::new(2, 57, tuxedo);\n     for _ in range(0u, 6) { spotty.speak(); }"}, {"sha": "8c36174d5f1ca42ef197c6ab1411892a9769ab7d", "filename": "src/test/run-pass/class-implement-trait-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-implement-trait-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-implement-trait-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-trait-cross-crate.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -57,7 +57,7 @@ fn cat(in_x : uint, in_y : int, in_name: String) -> cat {\n \n \n pub fn main() {\n-  let mut nyan = cat(0u, 2, \"nyan\".to_strbuf());\n+  let mut nyan = cat(0u, 2, \"nyan\".to_string());\n   nyan.eat();\n   assert!((!nyan.eat()));\n   for _ in range(1u, 10u) { nyan.speak(); };"}, {"sha": "034ce8626d0873f1bedea1cbdc096d05a0202ff6", "filename": "src/test/run-pass/class-implement-traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -62,7 +62,7 @@ fn make_speak<C:noisy>(mut c: C) {\n }\n \n pub fn main() {\n-    let mut nyan = cat(0u, 2, \"nyan\".to_strbuf());\n+    let mut nyan = cat(0u, 2, \"nyan\".to_string());\n     nyan.eat();\n     assert!((!nyan.eat()));\n     for _ in range(1u, 10u) {"}, {"sha": "94c78522df40e39600a109fb546888c92617bf36", "filename": "src/test/run-pass/class-poly-methods-cross-crate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-poly-methods-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-poly-methods-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-poly-methods-cross-crate.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -14,11 +14,11 @@ use cci_class_6::kitties::cat;\n \n pub fn main() {\n   let mut nyan : cat<char> = cat::<char>(52u, 99, vec!('p'));\n-  let mut kitty = cat(1000u, 2, vec!(\"tabby\".to_owned()));\n+  let mut kitty = cat(1000u, 2, vec!(\"tabby\".to_string()));\n   assert_eq!(nyan.how_hungry, 99);\n   assert_eq!(kitty.how_hungry, 2);\n   nyan.speak(vec!(1u,2u,3u));\n   assert_eq!(nyan.meow_count(), 55u);\n-  kitty.speak(vec!(\"meow\".to_owned(), \"mew\".to_owned(), \"purr\".to_owned(), \"chirp\".to_owned()));\n+  kitty.speak(vec!(\"meow\".to_string(), \"mew\".to_string(), \"purr\".to_string(), \"chirp\".to_string()));\n   assert_eq!(kitty.meow_count(), 1004u);\n }"}, {"sha": "4f94673a2c027ef7b647f15527afc8b7cb26babb", "filename": "src/test/run-pass/class-poly-methods.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -33,11 +33,11 @@ fn cat<U>(in_x : uint, in_y : int, in_info: Vec<U> ) -> cat<U> {\n \n pub fn main() {\n   let mut nyan : cat<int> = cat::<int>(52u, 99, vec!(9));\n-  let mut kitty = cat(1000u, 2, vec!(\"tabby\".to_owned()));\n+  let mut kitty = cat(1000u, 2, vec!(\"tabby\".to_string()));\n   assert_eq!(nyan.how_hungry, 99);\n   assert_eq!(kitty.how_hungry, 2);\n   nyan.speak(vec!(1,2,3));\n   assert_eq!(nyan.meow_count(), 55u);\n-  kitty.speak(vec!(\"meow\".to_owned(), \"mew\".to_owned(), \"purr\".to_owned(), \"chirp\".to_owned()));\n+  kitty.speak(vec!(\"meow\".to_string(), \"mew\".to_string(), \"purr\".to_string(), \"chirp\".to_string()));\n   assert_eq!(kitty.meow_count(), 1004u);\n }"}, {"sha": "3d486144c3eed8005743ab72f61ce5f117b73210", "filename": "src/test/run-pass/class-separate-impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -60,10 +60,10 @@ impl fmt::Show for cat {\n fn print_out(thing: Box<ToStr>, expected: String) {\n   let actual = thing.to_str();\n   println!(\"{}\", actual);\n-  assert_eq!(actual.to_strbuf(), expected);\n+  assert_eq!(actual.to_string(), expected);\n }\n \n pub fn main() {\n-  let nyan: Box<ToStr> = box cat(0u, 2, \"nyan\".to_strbuf()) as Box<ToStr>;\n-  print_out(nyan, \"nyan\".to_strbuf());\n+  let nyan: Box<ToStr> = box cat(0u, 2, \"nyan\".to_string()) as Box<ToStr>;\n+  print_out(nyan, \"nyan\".to_string());\n }"}, {"sha": "2fb8610092bf993859092ba881d1a1bd1806e805", "filename": "src/test/run-pass/class-str-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-str-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclass-str-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-str-field.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -21,5 +21,5 @@ fn cat(in_name: String) -> cat {\n }\n \n pub fn main() {\n-  let _nyan = cat(\"nyan\".to_strbuf());\n+  let _nyan = cat(\"nyan\".to_string());\n }"}, {"sha": "61ed0016d09a188c6369c366f207edac6862eb57", "filename": "src/test/run-pass/classes-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclasses-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclasses-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses-cross-crate.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -13,7 +13,7 @@ extern crate cci_class_4;\n use cci_class_4::kitties::cat;\n \n pub fn main() {\n-    let mut nyan = cat(0u, 2, \"nyan\".to_strbuf());\n+    let mut nyan = cat(0u, 2, \"nyan\".to_string());\n     nyan.eat();\n     assert!((!nyan.eat()));\n     for _ in range(1u, 10u) { nyan.speak(); };"}, {"sha": "5d1296cf46e3f9a94c8067440be3ad2ab7206dde", "filename": "src/test/run-pass/classes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -49,7 +49,7 @@ fn cat(in_x : uint, in_y : int, in_name: String) -> cat {\n }\n \n pub fn main() {\n-  let mut nyan = cat(0u, 2, \"nyan\".to_strbuf());\n+  let mut nyan = cat(0u, 2, \"nyan\".to_string());\n   nyan.eat();\n   assert!((!nyan.eat()));\n   for _ in range(1u, 10u) { nyan.speak(); };"}, {"sha": "5597d5fa01135c42d1c89667ffb6ff598cc18851", "filename": "src/test/run-pass/cleanup-shortcircuit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fcleanup-shortcircuit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fcleanup-shortcircuit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-shortcircuit.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -26,9 +26,9 @@ pub fn main() {\n     let args = os::args();\n     let args = args.as_slice();\n \n-    // Here, the rvalue `\"signal\".to_owned()` requires cleanup. Older versions\n+    // Here, the rvalue `\"signal\".to_string()` requires cleanup. Older versions\n     // of the code had a problem that the cleanup scope for this\n-    // expression was the end of the `if`, and as the `\"signal\".to_owned()`\n+    // expression was the end of the `if`, and as the `\"signal\".to_string()`\n     // expression was never evaluated, we wound up trying to clean\n     // uninitialized memory.\n "}, {"sha": "5de7aee4aa4866aadb00c3642185a3d5e1f41e41", "filename": "src/test/run-pass/closure-reform.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-reform.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -15,7 +15,7 @@ use std::mem;\n use std::io::stdio::println;\n \n fn call_it(f: proc(String) -> String) {\n-    println!(\"{}\", f(\"Fred\".to_strbuf()))\n+    println!(\"{}\", f(\"Fred\".to_string()))\n }\n \n fn call_a_thunk(f: ||) {\n@@ -48,15 +48,15 @@ fn call_bare_again(f: extern \"Rust\" fn(&str)) {\n pub fn main() {\n     // Procs\n \n-    let greeting = \"Hello \".to_strbuf();\n+    let greeting = \"Hello \".to_string();\n     call_it(proc(s) {\n         format_strbuf!(\"{}{}\", greeting, s)\n     });\n \n-    let greeting = \"Goodbye \".to_strbuf();\n+    let greeting = \"Goodbye \".to_string();\n     call_it(proc(s) format_strbuf!(\"{}{}\", greeting, s));\n \n-    let greeting = \"How's life, \".to_strbuf();\n+    let greeting = \"How's life, \".to_string();\n     call_it(proc(s: String) -> String {\n         format_strbuf!(\"{}{}\", greeting, s)\n     });"}, {"sha": "f8c8ac20d72af92370db00d36e143a9dd6442d3f", "filename": "src/test/run-pass/complex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomplex.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -19,14 +19,14 @@ fn putstr(_s: String) { }\n \n fn putint(_i: int) {\n     let mut i: int = 33;\n-    while i < 36 { putstr(\"hi\".to_strbuf()); i = i + 1; }\n+    while i < 36 { putstr(\"hi\".to_string()); i = i + 1; }\n }\n \n fn zerg(i: int) -> int { return i; }\n \n fn foo(x: int) -> int {\n     let mut y: t = x + 2;\n-    putstr(\"hello\".to_strbuf());\n+    putstr(\"hello\".to_string());\n     while y < 10 { putint(y); if y * 3 == 4 { y = y + 2; nothing(); } }\n     let mut z: t;\n     z = 0x55;"}, {"sha": "64209f2446099db21e5b2bd46e721e267a8b1afe", "filename": "src/test/run-pass/concat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconcat.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n pub fn main() {\n-    assert_eq!(format!(concat!(\"foo\", \"bar\", \"{}\"), \"baz\"), \"foobarbaz\".to_strbuf());\n-    assert_eq!(format!(concat!()), \"\".to_strbuf());\n+    assert_eq!(format!(concat!(\"foo\", \"bar\", \"{}\"), \"baz\"), \"foobarbaz\".to_string());\n+    assert_eq!(format!(concat!()), \"\".to_string());\n \n     assert_eq!(\n         concat!(1, 2i, 3u, 4f32, 4.0, 'a', true, ()),"}, {"sha": "7ca4e25a74d339e1d4ed5935066469f86ff016d0", "filename": "src/test/run-pass/const-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fconst-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fconst-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-bound.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -18,7 +18,7 @@ struct F { field: int }\n \n pub fn main() {\n     /*foo(1);\n-    foo(\"hi\".to_owned());\n+    foo(\"hi\".to_string());\n     foo(~[1, 2, 3]);\n     foo(F{field: 42});\n     foo((1, 2u));"}, {"sha": "77c7a08f4ca1761db87023b3ffa9ab2ec1cfed03", "filename": "src/test/run-pass/const-str-ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -18,12 +18,12 @@ pub fn main() {\n     unsafe {\n         let foo = &A as *u8;\n         assert_eq!(str::raw::from_utf8(A), \"hi\");\n-        assert_eq!(str::raw::from_buf_len(foo, A.len()), \"hi\".to_owned());\n-        assert_eq!(str::raw::from_buf_len(C, B.len()), \"hi\".to_owned());\n+        assert_eq!(str::raw::from_buf_len(foo, A.len()), \"hi\".to_string());\n+        assert_eq!(str::raw::from_buf_len(C, B.len()), \"hi\".to_string());\n         assert!(*C == A[0]);\n         assert!(*(&B[0] as *u8) == A[0]);\n \n         let bar = str::raw::from_utf8(A).to_c_str();\n-        assert_eq!(bar.with_ref(|buf| str::raw::from_c_str(buf)), \"hi\".to_owned());\n+        assert_eq!(bar.with_ref(|buf| str::raw::from_c_str(buf)), \"hi\".to_string());\n     }\n }"}, {"sha": "456f7ec3e99f3e66c4e2e47cb1b57c77d559e5ca", "filename": "src/test/run-pass/crate-method-reexport-grrrrrrr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fcrate-method-reexport-grrrrrrr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fcrate-method-reexport-grrrrrrr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrate-method-reexport-grrrrrrr.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -24,5 +24,5 @@ pub fn main() {\n     let x = @();\n     x.cx();\n     let y = ();\n-    y.add(\"hi\".to_strbuf());\n+    y.add(\"hi\".to_string());\n }"}, {"sha": "a7211e77cd05dd854ead4304a5811ecd35240ba6", "filename": "src/test/run-pass/deriving-hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fderiving-hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fderiving-hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-hash.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -22,12 +22,12 @@ struct Person {\n fn main() {\n     let person1 = Person {\n         id: 5,\n-        name: \"Janet\".to_strbuf(),\n+        name: \"Janet\".to_string(),\n         phone: 555_666_7777\n     };\n     let person2 = Person {\n         id: 5,\n-        name: \"Bob\".to_strbuf(),\n+        name: \"Bob\".to_string(),\n         phone: 555_666_7777\n     };\n     assert!(hash::hash(&person1) == hash::hash(&person1));"}, {"sha": "a5e86dee18e8cadd5d35dc95dc5c5c0229f782bc", "filename": "src/test/run-pass/deriving-show-2.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -41,15 +41,15 @@ impl fmt::Show for Custom {\n }\n \n pub fn main() {\n-    assert_eq!(B1.to_str(), \"B1\".to_strbuf());\n-    assert_eq!(B2.to_str(), \"B2\".to_strbuf());\n-    assert_eq!(C1(3).to_str(), \"C1(3)\".to_strbuf());\n-    assert_eq!(C2(B2).to_str(), \"C2(B2)\".to_strbuf());\n-    assert_eq!(D1{ a: 2 }.to_str(), \"D1 { a: 2 }\".to_strbuf());\n-    assert_eq!(E.to_str(), \"E\".to_strbuf());\n-    assert_eq!(F(3).to_str(), \"F(3)\".to_strbuf());\n-    assert_eq!(G(3, 4).to_str(), \"G(3, 4)\".to_strbuf());\n-    assert_eq!(G(3, 4).to_str(), \"G(3, 4)\".to_strbuf());\n-    assert_eq!(I{ a: 2, b: 4 }.to_str(), \"I { a: 2, b: 4 }\".to_strbuf());\n-    assert_eq!(J(Custom).to_str(), \"J(yay)\".to_strbuf());\n+    assert_eq!(B1.to_str(), \"B1\".to_string());\n+    assert_eq!(B2.to_str(), \"B2\".to_string());\n+    assert_eq!(C1(3).to_str(), \"C1(3)\".to_string());\n+    assert_eq!(C2(B2).to_str(), \"C2(B2)\".to_string());\n+    assert_eq!(D1{ a: 2 }.to_str(), \"D1 { a: 2 }\".to_string());\n+    assert_eq!(E.to_str(), \"E\".to_string());\n+    assert_eq!(F(3).to_str(), \"F(3)\".to_string());\n+    assert_eq!(G(3, 4).to_str(), \"G(3, 4)\".to_string());\n+    assert_eq!(G(3, 4).to_str(), \"G(3, 4)\".to_string());\n+    assert_eq!(I{ a: 2, b: 4 }.to_str(), \"I { a: 2, b: 4 }\".to_string());\n+    assert_eq!(J(Custom).to_str(), \"J(yay)\".to_string());\n }"}, {"sha": "a44bb61a1ccd86e1c9b592bfff57cbb1ff877c03", "filename": "src/test/run-pass/deriving-show.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fderiving-show.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fderiving-show.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-show.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -28,7 +28,7 @@ enum Enum {\n \n macro_rules! t {\n     ($x:expr, $expected:expr) => {\n-        assert_eq!(format!(\"{}\", $x), $expected.to_strbuf())\n+        assert_eq!(format!(\"{}\", $x), $expected.to_string())\n     }\n }\n "}, {"sha": "edb0272dfeeb2ed3308d978fa3041f7505570344", "filename": "src/test/run-pass/deriving-via-extension-struct-tuple.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-tuple.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -12,9 +12,9 @@\n struct Foo(int, int, String);\n \n pub fn main() {\n-  let a1 = Foo(5, 6, \"abc\".to_strbuf());\n-  let a2 = Foo(5, 6, \"abc\".to_strbuf());\n-  let b = Foo(5, 7, \"def\".to_strbuf());\n+  let a1 = Foo(5, 6, \"abc\".to_string());\n+  let a2 = Foo(5, 6, \"abc\".to_string());\n+  let b = Foo(5, 7, \"def\".to_string());\n \n   assert!(a1 == a1);\n   assert!(a2 == a1);"}, {"sha": "0786974e112071b9dbde077a3fe536a2ca15fd35", "filename": "src/test/run-pass/drop-on-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fdrop-on-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fdrop-on-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-on-ret.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -13,7 +13,7 @@\n \n fn f() -> int {\n     if true {\n-        let _s: String = \"should not leak\".to_strbuf();\n+        let _s: String = \"should not leak\".to_string();\n         return 1;\n     }\n     return 0;"}, {"sha": "85da586a72c0185a1a3c3bbbb8c43cc51e5ead69", "filename": "src/test/run-pass/enum-discrim-width-stuff.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -23,8 +23,8 @@ macro_rules! check {\n                 assert_eq!(size_of::<E>(), size_of::<$t>());\n                 assert_eq!(V as $t, $v);\n                 assert_eq!(C as $t, $v);\n-                assert_eq!(format!(\"{:?}\", V), \"V\".to_strbuf());\n-                assert_eq!(format!(\"{:?}\", C), \"V\".to_strbuf());\n+                assert_eq!(format!(\"{:?}\", V), \"V\".to_string());\n+                assert_eq!(format!(\"{:?}\", C), \"V\".to_string());\n             }\n         }\n         $m::check();"}, {"sha": "66b11aefd324bab9159cb9b136f1c0b8ec795f70", "filename": "src/test/run-pass/enum-disr-val-pretty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fenum-disr-val-pretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fenum-disr-val-pretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-disr-val-pretty.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -13,10 +13,10 @@\n enum color { red = 1, green, blue, imaginary = -1, }\n \n pub fn main() {\n-    test_color(red, 1, \"red\".to_strbuf());\n-    test_color(green, 2, \"green\".to_strbuf());\n-    test_color(blue, 3, \"blue\".to_strbuf());\n-    test_color(imaginary, -1, \"imaginary\".to_strbuf());\n+    test_color(red, 1, \"red\".to_string());\n+    test_color(green, 2, \"green\".to_string());\n+    test_color(blue, 3, \"blue\".to_string());\n+    test_color(imaginary, -1, \"imaginary\".to_string());\n }\n \n fn test_color(color: color, val: int, _name: String) {"}, {"sha": "4e283b54808498ce432f0c547b276ca7f2efa051", "filename": "src/test/run-pass/enum-variants.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fenum-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fenum-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-variants.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -18,8 +18,8 @@ enum Animal {\n }\n \n pub fn main() {\n-    let mut a: Animal = Dog(\"Cocoa\".to_strbuf(), 37.2);\n-    a = Cat{ name: \"Spotty\".to_strbuf(), weight: 2.7 };\n+    let mut a: Animal = Dog(\"Cocoa\".to_string(), 37.2);\n+    a = Cat{ name: \"Spotty\".to_string(), weight: 2.7 };\n     // permuting the fields should work too\n-    let _c = Cat { weight: 3.1, name: \"Spreckles\".to_strbuf() };\n+    let _c = Cat { weight: 3.1, name: \"Spreckles\".to_string() };\n }"}, {"sha": "1652016b51b069151aaaa6195b2a4133c738ee60", "filename": "src/test/run-pass/estr-uniq.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Festr-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Festr-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Festr-uniq.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -11,9 +11,9 @@\n #![allow(dead_assignment)]\n \n pub fn main() {\n-    let x : String = \"hello\".to_strbuf();\n-    let _y : String = \"there\".to_strbuf();\n-    let mut z = \"thing\".to_strbuf();\n+    let x : String = \"hello\".to_string();\n+    let _y : String = \"there\".to_string();\n+    let mut z = \"thing\".to_string();\n     z = x;\n     assert_eq!(z.as_slice()[0], ('h' as u8));\n     assert_eq!(z.as_slice()[4], ('o' as u8));"}, {"sha": "8775cb6da2ed232408c75ba2c9491679cb3bac45", "filename": "src/test/run-pass/exec-env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fexec-env.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fexec-env.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexec-env.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -13,5 +13,5 @@\n use std::os;\n \n pub fn main() {\n-    assert_eq!(os::getenv(\"TEST_EXEC_ENV\"), Some(\"22\".to_strbuf()));\n+    assert_eq!(os::getenv(\"TEST_EXEC_ENV\"), Some(\"22\".to_string()));\n }"}, {"sha": "ee74fc0b0a3262dd34057eaaf0d54929da19bc05", "filename": "src/test/run-pass/explicit_self_xcrate_exe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fexplicit_self_xcrate_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fexplicit_self_xcrate_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit_self_xcrate_exe.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -14,6 +14,6 @@ extern crate explicit_self_xcrate;\n use explicit_self_xcrate::{Foo, Bar};\n \n pub fn main() {\n-    let x = Bar { x: \"hello\".to_strbuf() };\n+    let x = Bar { x: \"hello\".to_string() };\n     x.f();\n }"}, {"sha": "7d79815f7780db42c353fcfd7a0d2b94ef6a1725", "filename": "src/test/run-pass/exponential-notation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexponential-notation.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -13,7 +13,7 @@\n use s = std::num::strconv;\n use to_str = std::num::strconv::float_to_str_common;\n \n-macro_rules! t(($a:expr, $b:expr) => { { let (r, _) = $a; assert_eq!(r, $b.to_strbuf()) } })\n+macro_rules! t(($a:expr, $b:expr) => { { let (r, _) = $a; assert_eq!(r, $b.to_string()) } })\n \n pub fn main() {\n     // Basic usage"}, {"sha": "3918f7eb73d805f16364879c6917a9ba910fd90d", "filename": "src/test/run-pass/expr-if-box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fexpr-if-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fexpr-if-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-box.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -17,8 +17,8 @@ fn test_box() {\n }\n \n fn test_str() {\n-    let rs = if true { \"happy\".to_owned() } else { \"sad\".to_owned() };\n-    assert_eq!(rs, \"happy\".to_owned());\n+    let rs = if true { \"happy\".to_string() } else { \"sad\".to_string() };\n+    assert_eq!(rs, \"happy\".to_string());\n }\n \n pub fn main() { test_box(); test_str(); }"}, {"sha": "457d3e8d98642d6e83a8b9faeeb8fdcbc40849ae", "filename": "src/test/run-pass/expr-match-box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fexpr-match-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fexpr-match-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-box.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -17,9 +17,9 @@ fn test_box() {\n }\n \n fn test_str() {\n-    let res = match true { true => { \"happy\".to_owned() },\n+    let res = match true { true => { \"happy\".to_string() },\n                          _ => fail!(\"not happy at all\") };\n-    assert_eq!(res, \"happy\".to_owned());\n+    assert_eq!(res, \"happy\".to_string());\n }\n \n pub fn main() { test_box(); test_str(); }"}, {"sha": "a40ab713c2d6c4c9170b03b1b5ddb8b318f4a855", "filename": "src/test/run-pass/fixed_length_vec_glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Ffixed_length_vec_glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Ffixed_length_vec_glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffixed_length_vec_glue.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -17,5 +17,5 @@ pub fn main() {\n     let arr = [1,2,3];\n     let struc = Struc {a: 13u8, b: arr, c: 42};\n     let s = repr::repr_to_str(&struc);\n-    assert_eq!(s, \"Struc{a: 13u8, b: [1, 2, 3], c: 42}\".to_strbuf());\n+    assert_eq!(s, \"Struc{a: 13u8, b: [1, 2, 3], c: 42}\".to_string());\n }"}, {"sha": "890f5158a65ffb0663753c09f826d93576ede7a2", "filename": "src/test/run-pass/foreign-fn-linkname.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -32,6 +32,6 @@ fn strlen(str: String) -> uint {\n }\n \n pub fn main() {\n-    let len = strlen(\"Rust\".to_strbuf());\n+    let len = strlen(\"Rust\".to_string());\n     assert_eq!(len, 4u);\n }"}, {"sha": "520735c05c33b978eae0fe3088ad51e6f14b7bc9", "filename": "src/test/run-pass/format-ref-cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fformat-ref-cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fformat-ref-cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fformat-ref-cell.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -14,5 +14,5 @@ pub fn main() {\n     let name = RefCell::new(\"rust\");\n     let what = RefCell::new(\"rocks\");\n     let msg = format!(\"{name:?} {:?}\", &*what.borrow(), name=&*name.borrow());\n-    assert_eq!(msg, \"&\\\"rust\\\" &\\\"rocks\\\"\".to_strbuf());\n+    assert_eq!(msg, \"&\\\"rust\\\" &\\\"rocks\\\"\".to_string());\n }"}, {"sha": "52d7c4cb170ebe1b5cc6ce311de6bd6d3fd8a319", "filename": "src/test/run-pass/generic-tag-corruption.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fgeneric-tag-corruption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fgeneric-tag-corruption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag-corruption.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -14,4 +14,4 @@\n // This used to cause memory corruption in stage 0.\n enum thing<K> { some(K), }\n \n-pub fn main() { let _x = some(\"hi\".to_owned()); }\n+pub fn main() { let _x = some(\"hi\".to_string()); }"}, {"sha": "d7eb2de36b03457256445de12a405087f6164b6e", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -21,7 +21,7 @@ extern crate collections;\n */\n \n pub fn map(filename: String, emit: map_reduce::putter) {\n-    emit(filename, \"1\".to_strbuf());\n+    emit(filename, \"1\".to_string());\n }\n \n mod map_reduce {\n@@ -86,7 +86,7 @@ mod map_reduce {\n               find_reducer(k, cc) => {\n                 let mut c;\n                 match reducers.find(&str::from_utf8(\n-                        k.as_slice()).unwrap().to_strbuf()) {\n+                        k.as_slice()).unwrap().to_string()) {\n                   Some(&_c) => { c = _c; }\n                   None => { c = 0; }\n                 }\n@@ -99,5 +99,5 @@ mod map_reduce {\n \n pub fn main() {\n     map_reduce::map_reduce(\n-        vec!(\"../src/test/run-pass/hashmap-memory.rs\".to_strbuf()));\n+        vec!(\"../src/test/run-pass/hashmap-memory.rs\".to_string()));\n }"}, {"sha": "c8163f08c6f893aa4f8f5ea571017e2b4a5e1c87", "filename": "src/test/run-pass/html-literals.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fhtml-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fhtml-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhtml-literals.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -41,7 +41,7 @@ macro_rules! parse_node (\n     ) => (\n         parse_node!(\n             [$(: $tags ($(:$tag_nodes),*))*];\n-            [$(:$head_nodes,)* :tag(stringify!($head).to_strbuf(),\n+            [$(:$head_nodes,)* :tag(stringify!($head).to_string(),\n                                     vec!($($nodes),*))];\n             $($rest)*\n         )\n@@ -66,7 +66,7 @@ macro_rules! parse_node (\n     ) => (\n         parse_node!(\n             [$(: $tags ($(:$tag_nodes),*))*];\n-            [$(:$nodes,)* :text(\".\".to_strbuf())];\n+            [$(:$nodes,)* :text(\".\".to_string())];\n             $($rest)*\n         )\n     );\n@@ -78,7 +78,7 @@ macro_rules! parse_node (\n     ) => (\n         parse_node!(\n             [$(: $tags ($(:$tag_nodes),*))*];\n-            [$(:$nodes,)* :text(stringify!($word).to_strbuf())];\n+            [$(:$nodes,)* :text(stringify!($word).to_string())];\n             $($rest)*\n         )\n     );"}, {"sha": "6d875a7ff9b558469737c3161439a0179bf74911", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -52,7 +52,7 @@ pub fn main() {\n     t!(format!(\"{}\", 1.0f32), \"1\");\n     t!(format!(\"{}\", 1.0f64), \"1\");\n     t!(format!(\"{}\", \"a\"), \"a\");\n-    t!(format!(\"{}\", \"a\".to_owned()), \"a\");\n+    t!(format!(\"{}\", \"a\".to_string()), \"a\");\n     t!(format!(\"{}\", false), \"false\");\n     t!(format!(\"{}\", 'a'), \"a\");\n \n@@ -66,7 +66,7 @@ pub fn main() {\n     t!(format!(\"{:x}\", 10u), \"a\");\n     t!(format!(\"{:X}\", 10u), \"A\");\n     t!(format!(\"{:s}\", \"foo\"), \"foo\");\n-    t!(format!(\"{:s}\", \"foo\".to_owned()), \"foo\");\n+    t!(format!(\"{:s}\", \"foo\".to_string()), \"foo\");\n     t!(format!(\"{:p}\", 0x1234 as *int), \"0x1234\");\n     t!(format!(\"{:p}\", 0x1234 as *mut int), \"0x1234\");\n     t!(format!(\"{:d}\", A), \"aloha\");\n@@ -175,7 +175,7 @@ fn test_write() {\n         writeln!(w, \"{foo}\", foo=\"bar\");\n     }\n \n-    let s = str::from_utf8(buf.unwrap().as_slice()).unwrap().to_owned();\n+    let s = str::from_utf8(buf.unwrap().as_slice()).unwrap().to_string();\n     t!(s, \"34helloline\\nbar\\n\");\n }\n \n@@ -199,7 +199,7 @@ fn test_format_args() {\n         format_args!(|args| { write!(w, \"{}\", args); }, \"test\");\n         format_args!(|args| { write!(w, \"{}\", args); }, \"{test}\", test=3);\n     }\n-    let s = str::from_utf8(buf.unwrap().as_slice()).unwrap().to_owned();\n+    let s = str::from_utf8(buf.unwrap().as_slice()).unwrap().to_string();\n     t!(s, \"1test3\");\n \n     let s = format_args!(fmt::format, \"hello {}\", \"world\");\n@@ -222,5 +222,5 @@ fn test_order() {\n     }\n     assert_eq!(format!(\"{} {} {a} {b} {} {c}\",\n                        foo(), foo(), foo(), a=foo(), b=foo(), c=foo()),\n-               \"1 2 4 5 3 6\".to_strbuf());\n+               \"1 2 4 5 3 6\".to_string());\n }"}, {"sha": "b2b16c4ef84201229444bce76a2f29037727d7c4", "filename": "src/test/run-pass/inferred-suffix-in-pattern-range.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Finferred-suffix-in-pattern-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cc9c35234ab12a4b9a6fc1cb35b52556f242d/src%2Ftest%2Frun-pass%2Finferred-suffix-in-pattern-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finferred-suffix-in-pattern-range.rs?ref=911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "patch": "@@ -11,22 +11,22 @@\n pub fn main() {\n     let x = 2;\n     let x_message = match x {\n-      0 .. 1     => { \"not many\".to_owned() }\n-      _          => { \"lots\".to_owned() }\n+      0 .. 1     => { \"not many\".to_string() }\n+      _          => { \"lots\".to_string() }\n     };\n-    assert_eq!(x_message, \"lots\".to_owned());\n+    assert_eq!(x_message, \"lots\".to_string());\n \n     let y = 2i;\n     let y_message = match y {\n-      0 .. 1     => { \"not many\".to_owned() }\n-      _          => { \"lots\".to_owned() }\n+      0 .. 1     => { \"not many\".to_string() }\n+      _          => { \"lots\".to_string() }\n     };\n-    assert_eq!(y_message, \"lots\".to_owned());\n+    assert_eq!(y_message, \"lots\".to_string());\n \n     let z = 1u64;\n     let z_message = match z {\n-      0 .. 1     => { \"not many\".to_owned() }\n-      _          => { \"lots\".to_owned() }\n+      0 .. 1     => { \"not many\".to_string() }\n+      _          => { \"lots\".to_string() }\n     };\n-    assert_eq!(z_message, \"not many\".to_owned());\n+    assert_eq!(z_message, \"not many\".to_string());\n }"}]}