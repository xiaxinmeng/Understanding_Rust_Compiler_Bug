{"sha": "b619dcdaeb223bd4df6896e808f53ffa295c3ed0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2MTlkY2RhZWIyMjNiZDRkZjY4OTZlODA4ZjUzZmZhMjk1YzNlZDA=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-12T08:38:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-12T08:38:40Z"}, "message": "Rollup merge of #37613 - DanielKeep:eww-you-got-printf-in-your-format, r=alexcrichton\n\nAdd foreign formatting directive detection.\n\nThis teaches `format_args!` how to interpret format printf- and\nshell-style format directives.  This is used in cases where there are\nunused formatting arguments, and the reason for that *might* be because\nthe programmer is trying to use the wrong kind of formatting string.\n\nThis was prompted by an issue encountered by simulacrum on the #rust IRC\nchannel.  In short: although `println!` told them that they weren't using\nall of the conversion arguments, the problem was in using printf-syle\ndirectives rather than ones `println!` would undertand.\n\nWhere possible, `format_args!` will tell the programmer what they should\nuse instead.  For example, it will suggest replacing `%05d` with `{:0>5}`,\nor `%2$.*3$s` with `{1:.3$}`.  Even if it cannot suggest a replacement,\nit will explicitly note that Rust does not support that style of directive,\nand direct the user to the `std::fmt` documentation.\n\n-----\n\n**Example**: given:\n\n```rust\nfn main() {\n    println!(\"%.*3$s %s!\\n\", \"Hello,\", \"World\", 4);\n    println!(\"%1$*2$.*3$f\", 123.456);\n}\n```\n\nThe compiler outputs the following:\n\n```text\nerror: multiple unused formatting arguments\n --> local/fmt.rs:2:5\n  |\n2 |     println!(\"%.*3$s %s!\\n\", \"Hello,\", \"World\", 4);\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\nnote: argument never used\n --> local/fmt.rs:2:30\n  |\n2 |     println!(\"%.*3$s %s!\\n\", \"Hello,\", \"World\", 4);\n  |                              ^^^^^^^^\nnote: argument never used\n --> local/fmt.rs:2:40\n  |\n2 |     println!(\"%.*3$s %s!\\n\", \"Hello,\", \"World\", 4);\n  |                                        ^^^^^^^\nnote: argument never used\n --> local/fmt.rs:2:49\n  |\n2 |     println!(\"%.*3$s %s!\\n\", \"Hello,\", \"World\", 4);\n  |                                                 ^\n  = help: `%.*3$s` should be written as `{:.2$}`\n  = help: `%s` should be written as `{}`\n  = note: printf formatting not supported; see the documentation for `std::fmt`\n  = note: this error originates in a macro outside of the current crate\n\nerror: argument never used\n --> local/fmt.rs:6:29\n  |\n6 |     println!(\"%1$*2$.*3$f\", 123.456);\n  |                             ^^^^^^^\n  |\n  = help: `%1$*2$.*3$f` should be written as `{0:1$.2$}`\n  = note: printf formatting not supported; see the documentation for `std::fmt`\n```", "tree": {"sha": "86c9e9e4c0b2e7fe06c1a90b6b1d442b6409baba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86c9e9e4c0b2e7fe06c1a90b6b1d442b6409baba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b619dcdaeb223bd4df6896e808f53ffa295c3ed0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b619dcdaeb223bd4df6896e808f53ffa295c3ed0", "html_url": "https://github.com/rust-lang/rust/commit/b619dcdaeb223bd4df6896e808f53ffa295c3ed0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b619dcdaeb223bd4df6896e808f53ffa295c3ed0/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25f1deee520a752dbc87fe04d639d50411b5c475", "url": "https://api.github.com/repos/rust-lang/rust/commits/25f1deee520a752dbc87fe04d639d50411b5c475", "html_url": "https://github.com/rust-lang/rust/commit/25f1deee520a752dbc87fe04d639d50411b5c475"}, {"sha": "455723c638b0e9db34d427a82bc13f95b75a304d", "url": "https://api.github.com/repos/rust-lang/rust/commits/455723c638b0e9db34d427a82bc13f95b75a304d", "html_url": "https://github.com/rust-lang/rust/commit/455723c638b0e9db34d427a82bc13f95b75a304d"}], "stats": {"total": 1165, "additions": 1163, "deletions": 2}, "files": [{"sha": "117bb39f8e789217b73525fc8af39f562295cedc", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 74, "deletions": 2, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b619dcdaeb223bd4df6896e808f53ffa295c3ed0/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b619dcdaeb223bd4df6896e808f53ffa295c3ed0/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=b619dcdaeb223bd4df6896e808f53ffa295c3ed0", "patch": "@@ -22,7 +22,7 @@ use syntax::ptr::P;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::tokenstream;\n \n-use std::collections::HashMap;\n+use std::collections::{HashMap, HashSet};\n use std::collections::hash_map::Entry;\n \n #[derive(PartialEq)]\n@@ -767,6 +767,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n \n     // Make sure that all arguments were used and all arguments have types.\n     let num_pos_args = cx.args.len() - cx.names.len();\n+    let mut errs = vec![];\n     for (i, ty) in cx.arg_types.iter().enumerate() {\n         if ty.len() == 0 {\n             if cx.count_positions.contains_key(&i) {\n@@ -779,9 +780,80 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n                 // positional argument\n                 \"argument never used\"\n             };\n-            cx.ecx.span_err(cx.args[i].span, msg);\n+            errs.push((cx.args[i].span, msg));\n         }\n     }\n+    if errs.len() > 0 {\n+        let args_used = cx.arg_types.len() - errs.len();\n+        let args_unused = errs.len();\n+\n+        let mut diag = {\n+            if errs.len() == 1 {\n+                let (sp, msg) = errs.into_iter().next().unwrap();\n+                cx.ecx.struct_span_err(sp, msg)\n+            } else {\n+                let mut diag = cx.ecx.struct_span_err(cx.fmtsp,\n+                    \"multiple unused formatting arguments\");\n+                for (sp, msg) in errs {\n+                    diag.span_note(sp, msg);\n+                }\n+                diag\n+            }\n+        };\n+\n+        // Decide if we want to look for foreign formatting directives.\n+        if args_used < args_unused {\n+            use super::format_foreign as foreign;\n+            let fmt_str = &fmt.node.0[..];\n+\n+            // The set of foreign substitutions we've explained.  This prevents spamming the user\n+            // with `%d should be written as {}` over and over again.\n+            let mut explained = HashSet::new();\n+\n+            // Used to ensure we only report translations for *one* kind of foreign format.\n+            let mut found_foreign = false;\n+\n+            macro_rules! check_foreign {\n+                ($kind:ident) => {{\n+                    let mut show_doc_note = false;\n+\n+                    for sub in foreign::$kind::iter_subs(fmt_str) {\n+                        let trn = match sub.translate() {\n+                            Some(trn) => trn,\n+\n+                            // If it has no translation, don't call it out specifically.\n+                            None => continue,\n+                        };\n+\n+                        let sub = String::from(sub.as_str());\n+                        if explained.contains(&sub) {\n+                            continue;\n+                        }\n+                        explained.insert(sub.clone());\n+\n+                        if !found_foreign {\n+                            found_foreign = true;\n+                            show_doc_note = true;\n+                        }\n+\n+                        diag.help(&format!(\"`{}` should be written as `{}`\", sub, trn));\n+                    }\n+\n+                    if show_doc_note {\n+                        diag.note(concat!(stringify!($kind), \" formatting not supported; see \\\n+                                the documentation for `std::fmt`\"));\n+                    }\n+                }};\n+            }\n+\n+            check_foreign!(printf);\n+            if !found_foreign {\n+                check_foreign!(shell);\n+            }\n+        }\n+\n+        diag.emit();\n+    }\n \n     cx.into_expr()\n }"}, {"sha": "3c802e8334dafd8c96197823f535bf3998647f47", "filename": "src/libsyntax_ext/format_foreign.rs", "status": "added", "additions": 1013, "deletions": 0, "changes": 1013, "blob_url": "https://github.com/rust-lang/rust/blob/b619dcdaeb223bd4df6896e808f53ffa295c3ed0/src%2Flibsyntax_ext%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b619dcdaeb223bd4df6896e808f53ffa295c3ed0/src%2Flibsyntax_ext%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat_foreign.rs?ref=b619dcdaeb223bd4df6896e808f53ffa295c3ed0", "patch": "@@ -0,0 +1,1013 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! try_opt {\n+    ($e:expr) => {\n+        match $e {\n+            Some(v) => v,\n+            None => return None,\n+        }\n+    };\n+}\n+\n+pub mod printf {\n+    use super::strcursor::StrCursor as Cur;\n+\n+    /// Represents a single `printf`-style substitution.\n+    #[derive(Clone, Eq, PartialEq, Debug)]\n+    pub enum Substitution<'a> {\n+        /// A formatted output substitution.\n+        Format(Format<'a>),\n+        /// A literal `%%` escape.\n+        Escape,\n+    }\n+\n+    impl<'a> Substitution<'a> {\n+        pub fn as_str(&self) -> &str {\n+            match *self {\n+                Substitution::Format(ref fmt) => fmt.span,\n+                Substitution::Escape => \"%%\",\n+            }\n+        }\n+\n+        /// Translate this substitution into an equivalent Rust formatting directive.\n+        ///\n+        /// This ignores cases where the substitution does not have an exact equivalent, or where\n+        /// the substitution would be unnecessary.\n+        pub fn translate(&self) -> Option<String> {\n+            match *self {\n+                Substitution::Format(ref fmt) => fmt.translate(),\n+                Substitution::Escape => None,\n+            }\n+        }\n+    }\n+\n+    #[derive(Clone, Eq, PartialEq, Debug)]\n+    /// A single `printf`-style formatting directive.\n+    pub struct Format<'a> {\n+        /// The entire original formatting directive.\n+        pub span: &'a str,\n+        /// The (1-based) parameter to be converted.\n+        pub parameter: Option<u16>,\n+        /// Formatting flags.\n+        pub flags: &'a str,\n+        /// Minimum width of the output.\n+        pub width: Option<Num>,\n+        /// Precision of the conversion.\n+        pub precision: Option<Num>,\n+        /// Length modifier for the conversion.\n+        pub length: Option<&'a str>,\n+        /// Type of parameter being converted.\n+        pub type_: &'a str,\n+    }\n+\n+    impl<'a> Format<'a> {\n+        /// Translate this directive into an equivalent Rust formatting directive.\n+        ///\n+        /// Returns `None` in cases where the `printf` directive does not have an exact Rust\n+        /// equivalent, rather than guessing.\n+        pub fn translate(&self) -> Option<String> {\n+            use std::fmt::Write;\n+\n+            let (c_alt, c_zero, c_left, c_plus) = {\n+                let mut c_alt = false;\n+                let mut c_zero = false;\n+                let mut c_left = false;\n+                let mut c_plus = false;\n+                for c in self.flags.chars() {\n+                    match c {\n+                        '#' => c_alt = true,\n+                        '0' => c_zero = true,\n+                        '-' => c_left = true,\n+                        '+' => c_plus = true,\n+                        _ => return None\n+                    }\n+                }\n+                (c_alt, c_zero, c_left, c_plus)\n+            };\n+\n+            // Has a special form in Rust for numbers.\n+            let fill = if c_zero { Some(\"0\") } else { None };\n+\n+            let align = if c_left { Some(\"<\") } else { None };\n+\n+            // Rust doesn't have an equivalent to the `' '` flag.\n+            let sign = if c_plus { Some(\"+\") } else { None };\n+\n+            // Not *quite* the same, depending on the type...\n+            let alt = c_alt;\n+\n+            let width = match self.width {\n+                Some(Num::Next) => {\n+                    // NOTE: Rust doesn't support this.\n+                    return None;\n+                }\n+                w @ Some(Num::Arg(_)) => w,\n+                w @ Some(Num::Num(_)) => w,\n+                None => None,\n+            };\n+\n+            let precision = self.precision;\n+\n+            // NOTE: although length *can* have an effect, we can't duplicate the effect in Rust, so\n+            // we just ignore it.\n+\n+            let (type_, use_zero_fill, is_int) = match self.type_ {\n+                \"d\" | \"i\" | \"u\" => (None, true, true),\n+                \"f\" | \"F\" => (None, false, false),\n+                \"s\" | \"c\" => (None, false, false),\n+                \"e\" | \"E\" => (Some(self.type_), true, false),\n+                \"x\" | \"X\" | \"o\" => (Some(self.type_), true, true),\n+                \"p\" => (Some(self.type_), false, true),\n+                \"g\" => (Some(\"e\"), true, false),\n+                \"G\" => (Some(\"E\"), true, false),\n+                _ => return None,\n+            };\n+\n+            let (fill, width, precision) = match (is_int, width, precision) {\n+                (true, Some(_), Some(_)) => {\n+                    // Rust can't duplicate this insanity.\n+                    return None;\n+                },\n+                (true, None, Some(p)) => (Some(\"0\"), Some(p), None),\n+                (true, w, None) => (fill, w, None),\n+                (false, w, p) => (fill, w, p),\n+            };\n+\n+            let align = match (self.type_, width.is_some(), align.is_some()) {\n+                (\"s\", true, false) => Some(\">\"),\n+                _ => align,\n+            };\n+\n+            let (fill, zero_fill) = match (fill, use_zero_fill) {\n+                (Some(\"0\"), true) => (None, true),\n+                (fill, _) => (fill, false),\n+            };\n+\n+            let alt = match type_ {\n+                Some(\"x\") | Some(\"X\") => alt,\n+                _ => false,\n+            };\n+\n+            let has_options = fill.is_some()\n+                || align.is_some()\n+                || sign.is_some()\n+                || alt\n+                || zero_fill\n+                || width.is_some()\n+                || precision.is_some()\n+                || type_.is_some()\n+                ;\n+\n+            // Initialise with a rough guess.\n+            let cap = self.span.len() + if has_options { 2 } else { 0 };\n+            let mut s = String::with_capacity(cap);\n+\n+            s.push_str(\"{\");\n+\n+            if let Some(arg) = self.parameter {\n+                try_opt!(write!(s, \"{}\", try_opt!(arg.checked_sub(1))).ok());\n+            }\n+\n+            if has_options {\n+                s.push_str(\":\");\n+\n+                let align = if let Some(fill) = fill {\n+                    s.push_str(fill);\n+                    align.or(Some(\">\"))\n+                } else {\n+                    align\n+                };\n+\n+                if let Some(align) = align {\n+                    s.push_str(align);\n+                }\n+\n+                if let Some(sign) = sign {\n+                    s.push_str(sign);\n+                }\n+\n+                if alt {\n+                    s.push_str(\"#\");\n+                }\n+\n+                if zero_fill {\n+                    s.push_str(\"0\");\n+                }\n+\n+                if let Some(width) = width {\n+                    try_opt!(width.translate(&mut s).ok());\n+                }\n+\n+                if let Some(precision) = precision {\n+                    s.push_str(\".\");\n+                    try_opt!(precision.translate(&mut s).ok());\n+                }\n+\n+                if let Some(type_) = type_ {\n+                    s.push_str(type_);\n+                }\n+            }\n+\n+            s.push_str(\"}\");\n+            Some(s)\n+        }\n+    }\n+\n+    /// A general number used in a `printf` formatting directive.\n+    #[derive(Copy, Clone, Eq, PartialEq, Debug)]\n+    pub enum Num {\n+        // The range of these values is technically bounded by `NL_ARGMAX`... but, at least for GNU\n+        // libc, it apparently has no real fixed limit.  A `u16` is used here on the basis that it\n+        // is *vanishingly* unlikely that *anyone* is going to try formatting something wider, or\n+        // with more precision, than 32 thousand positions which is so wide it couldn't possibly fit\n+        // on a screen.\n+\n+        /// A specific, fixed value.\n+        Num(u16),\n+        /// The value is derived from a positional argument.\n+        Arg(u16),\n+        /// The value is derived from the \"next\" unconverted argument.\n+        Next,\n+    }\n+\n+    impl Num {\n+        fn from_str(s: &str, arg: Option<&str>) -> Self {\n+            if let Some(arg) = arg {\n+                Num::Arg(arg.parse().expect(&format!(\"invalid format arg `{:?}`\", arg)))\n+            } else if s == \"*\" {\n+                Num::Next\n+            } else {\n+                Num::Num(s.parse().expect(&format!(\"invalid format num `{:?}`\", s)))\n+            }\n+        }\n+\n+        fn translate(&self, s: &mut String) -> ::std::fmt::Result {\n+            use std::fmt::Write;\n+            match *self {\n+                Num::Num(n) => write!(s, \"{}\", n),\n+                Num::Arg(n) => {\n+                    let n = try!(n.checked_sub(1).ok_or(::std::fmt::Error));\n+                    write!(s, \"{}$\", n)\n+                },\n+                Num::Next => write!(s, \"*\"),\n+            }\n+        }\n+    }\n+\n+    /// Returns an iterator over all substitutions in a given string.\n+    pub fn iter_subs(s: &str) -> Substitutions {\n+        Substitutions {\n+            s: s,\n+        }\n+    }\n+\n+    /// Iterator over substitutions in a string.\n+    pub struct Substitutions<'a> {\n+        s: &'a str,\n+    }\n+\n+    impl<'a> Iterator for Substitutions<'a> {\n+        type Item = Substitution<'a>;\n+        fn next(&mut self) -> Option<Self::Item> {\n+            match parse_next_substitution(self.s) {\n+                Some((sub, tail)) => {\n+                    self.s = tail;\n+                    Some(sub)\n+                },\n+                None => None,\n+            }\n+        }\n+    }\n+\n+    enum State {\n+        Start,\n+        Flags,\n+        Width,\n+        WidthArg,\n+        Prec,\n+        PrecInner,\n+        Length,\n+        Type,\n+    }\n+\n+    /// Parse the next substitution from the input string.\n+    pub fn parse_next_substitution(s: &str) -> Option<(Substitution, &str)> {\n+        use self::State::*;\n+\n+        let at = {\n+            let start = try_opt!(s.find('%'));\n+            match s[start+1..].chars().next() {\n+                Some('%') => return Some((Substitution::Escape, &s[start+2..])),\n+                Some(_) => {/* fall-through */},\n+                None => return None,\n+            }\n+\n+            Cur::new_at_start(&s[start..])\n+        };\n+\n+        // This is meant to be a translation of the following regex:\n+        //\n+        // ```regex\n+        // (?x)\n+        // ^ %\n+        // (?: (?P<parameter> \\d+) \\$ )?\n+        // (?P<flags> [-+ 0\\#']* )\n+        // (?P<width> \\d+ | \\* (?: (?P<widtha> \\d+) \\$ )? )?\n+        // (?: \\. (?P<precision> \\d+ | \\* (?: (?P<precisiona> \\d+) \\$ )? ) )?\n+        // (?P<length>\n+        //     # Standard\n+        //     hh | h | ll | l | L | z | j | t\n+        //\n+        //     # Other\n+        //     | I32 | I64 | I | q\n+        // )?\n+        // (?P<type> . )\n+        // ```\n+\n+        // Used to establish the full span at the end.\n+        let start = at;\n+        // The current position within the string.\n+        let mut at = try_opt!(at.at_next_cp());\n+        // `c` is the next codepoint, `next` is a cursor after it.\n+        let (mut c, mut next) = try_opt!(at.next_cp());\n+\n+        // Update `at`, `c`, and `next`, exiting if we're out of input.\n+        macro_rules! move_to {\n+            ($cur:expr) => {\n+                {\n+                    at = $cur;\n+                    let (c_, next_) = try_opt!(at.next_cp());\n+                    c = c_;\n+                    next = next_;\n+                }\n+            };\n+        }\n+\n+        // Constructs a result when parsing fails.\n+        //\n+        // Note: `move` used to capture copies of the cursors as they are *now*.\n+        let fallback = move || {\n+            return Some((\n+                Substitution::Format(Format {\n+                    span: start.slice_between(next).unwrap(),\n+                    parameter: None,\n+                    flags: \"\",\n+                    width: None,\n+                    precision: None,\n+                    length: None,\n+                    type_: at.slice_between(next).unwrap(),\n+                }),\n+                next.slice_after()\n+            ));\n+        };\n+\n+        // Next parsing state.\n+        let mut state = Start;\n+\n+        // Sadly, Rust isn't *quite* smart enough to know these *must* be initialised by the end.\n+        let mut parameter: Option<u16> = None;\n+        let mut flags: &str = \"\";\n+        let mut width: Option<Num> = None;\n+        let mut precision: Option<Num> = None;\n+        let mut length: Option<&str> = None;\n+        let mut type_: &str = \"\";\n+        let end: Cur;\n+\n+        if let Start = state {\n+            match c {\n+                '1'...'9' => {\n+                    let end = at_next_cp_while(next, is_digit);\n+                    match end.next_cp() {\n+                        // Yes, this *is* the parameter.\n+                        Some(('$', end2)) => {\n+                            state = Flags;\n+                            parameter = Some(at.slice_between(end).unwrap().parse().unwrap());\n+                            move_to!(end2);\n+                        },\n+                        // Wait, no, actually, it's the width.\n+                        Some(_) => {\n+                            state = Prec;\n+                            parameter = None;\n+                            flags = \"\";\n+                            width = Some(Num::from_str(at.slice_between(end).unwrap(), None));\n+                            move_to!(end);\n+                        },\n+                        // It's invalid, is what it is.\n+                        None => return fallback(),\n+                    }\n+                },\n+                _ => {\n+                    state = Flags;\n+                    parameter = None;\n+                    move_to!(at);\n+                }\n+            }\n+        }\n+\n+        if let Flags = state {\n+            let end = at_next_cp_while(at, is_flag);\n+            state = Width;\n+            flags = at.slice_between(end).unwrap();\n+            move_to!(end);\n+        }\n+\n+        if let Width = state {\n+            match c {\n+                '*' => {\n+                    state = WidthArg;\n+                    move_to!(next);\n+                },\n+                '1' ... '9' => {\n+                    let end = at_next_cp_while(next, is_digit);\n+                    state = Prec;\n+                    width = Some(Num::from_str(at.slice_between(end).unwrap(), None));\n+                    move_to!(end);\n+                },\n+                _ => {\n+                    state = Prec;\n+                    width = None;\n+                    move_to!(at);\n+                }\n+            }\n+        }\n+\n+        if let WidthArg = state {\n+            let end = at_next_cp_while(at, is_digit);\n+            match end.next_cp() {\n+                Some(('$', end2)) => {\n+                    state = Prec;\n+                    width = Some(Num::from_str(\"\", Some(at.slice_between(end).unwrap())));\n+                    move_to!(end2);\n+                },\n+                _ => {\n+                    state = Prec;\n+                    width = Some(Num::Next);\n+                    move_to!(end);\n+                }\n+            }\n+        }\n+\n+        if let Prec = state {\n+            match c {\n+                '.' => {\n+                    state = PrecInner;\n+                    move_to!(next);\n+                },\n+                _ => {\n+                    state = Length;\n+                    precision = None;\n+                    move_to!(at);\n+                }\n+            }\n+        }\n+\n+        if let PrecInner = state {\n+            match c {\n+                '*' => {\n+                    let end = at_next_cp_while(next, is_digit);\n+                    match end.next_cp() {\n+                        Some(('$', end2)) => {\n+                            state = Length;\n+                            precision = Some(Num::from_str(\"*\", next.slice_between(end)));\n+                            move_to!(end2);\n+                        },\n+                        _ => {\n+                            state = Length;\n+                            precision = Some(Num::Next);\n+                            move_to!(end);\n+                        }\n+                    }\n+                },\n+                '0' ... '9' => {\n+                    let end = at_next_cp_while(next, is_digit);\n+                    state = Length;\n+                    precision = Some(Num::from_str(at.slice_between(end).unwrap(), None));\n+                    move_to!(end);\n+                },\n+                _ => return fallback(),\n+            }\n+        }\n+\n+        if let Length = state {\n+            let c1_next1 = next.next_cp();\n+            match (c, c1_next1) {\n+                ('h', Some(('h', next1)))\n+                | ('l', Some(('l', next1)))\n+                => {\n+                    state = Type;\n+                    length = Some(at.slice_between(next1).unwrap());\n+                    move_to!(next1);\n+                },\n+\n+                ('h', _) | ('l', _) | ('L', _)\n+                | ('z', _) | ('j', _) | ('t', _)\n+                | ('q', _)\n+                => {\n+                    state = Type;\n+                    length = Some(at.slice_between(next).unwrap());\n+                    move_to!(next);\n+                },\n+\n+                ('I', _) => {\n+                    let end = next.at_next_cp()\n+                        .and_then(|end| end.at_next_cp())\n+                        .map(|end| (next.slice_between(end).unwrap(), end));\n+                    let end = match end {\n+                        Some((\"32\", end)) => end,\n+                        Some((\"64\", end)) => end,\n+                        _ => next\n+                    };\n+                    state = Type;\n+                    length = Some(at.slice_between(end).unwrap());\n+                    move_to!(end);\n+                },\n+\n+                _ => {\n+                    state = Type;\n+                    length = None;\n+                    move_to!(at);\n+                }\n+            }\n+        }\n+\n+        if let Type = state {\n+            drop(c);\n+            type_ = at.slice_between(next).unwrap();\n+\n+            // Don't use `move_to!` here, as we *can* be at the end of the input.\n+            at = next;\n+        }\n+\n+        drop(c);\n+        drop(next);\n+\n+        end = at;\n+\n+        let f = Format {\n+            span: start.slice_between(end).unwrap(),\n+            parameter: parameter,\n+            flags: flags,\n+            width: width,\n+            precision: precision,\n+            length: length,\n+            type_: type_,\n+        };\n+        Some((Substitution::Format(f), end.slice_after()))\n+    }\n+\n+    fn at_next_cp_while<F>(mut cur: Cur, mut pred: F) -> Cur\n+    where F: FnMut(char) -> bool {\n+        loop {\n+            match cur.next_cp() {\n+                Some((c, next)) => if pred(c) {\n+                    cur = next;\n+                } else {\n+                    return cur;\n+                },\n+                None => return cur,\n+            }\n+        }\n+    }\n+\n+    fn is_digit(c: char) -> bool {\n+        match c {\n+            '0' ... '9' => true,\n+            _ => false\n+        }\n+    }\n+\n+    fn is_flag(c: char) -> bool {\n+        match c {\n+            '0' | '-' | '+' | ' ' | '#' | '\\'' => true,\n+            _ => false\n+        }\n+    }\n+\n+    #[cfg(test)]\n+    mod tests {\n+        use super::{\n+            Format as F,\n+            Num as N,\n+            Substitution as S,\n+            iter_subs,\n+            parse_next_substitution as pns,\n+        };\n+\n+        macro_rules! assert_eq_pnsat {\n+            ($lhs:expr, $rhs:expr) => {\n+                assert_eq!(\n+                    pns($lhs).and_then(|(s, _)| s.translate()),\n+                    $rhs.map(<String as From<&str>>::from)\n+                )\n+            };\n+        }\n+\n+        #[test]\n+        fn test_escape() {\n+            assert_eq!(pns(\"has no escapes\"), None);\n+            assert_eq!(pns(\"has no escapes, either %\"), None);\n+            assert_eq!(pns(\"*so* has a %% escape\"), Some((S::Escape,\" escape\")));\n+            assert_eq!(pns(\"%% leading escape\"), Some((S::Escape, \" leading escape\")));\n+            assert_eq!(pns(\"trailing escape %%\"), Some((S::Escape, \"\")));\n+        }\n+\n+        #[test]\n+        fn test_parse() {\n+            macro_rules! assert_pns_eq_sub {\n+                ($in_:expr, {\n+                    $param:expr, $flags:expr,\n+                    $width:expr, $prec:expr, $len:expr, $type_:expr,\n+                }) => {\n+                    assert_eq!(\n+                        pns(concat!($in_, \"!\")),\n+                        Some((\n+                            S::Format(F {\n+                                span: $in_,\n+                                parameter: $param,\n+                                flags: $flags,\n+                                width: $width,\n+                                precision: $prec,\n+                                length: $len,\n+                                type_: $type_,\n+                            }),\n+                            \"!\"\n+                        ))\n+                    )\n+                };\n+            }\n+\n+            assert_pns_eq_sub!(\"%!\",\n+                { None, \"\", None, None, None, \"!\", });\n+            assert_pns_eq_sub!(\"%c\",\n+                { None, \"\", None, None, None, \"c\", });\n+            assert_pns_eq_sub!(\"%s\",\n+                { None, \"\", None, None, None, \"s\", });\n+            assert_pns_eq_sub!(\"%06d\",\n+                { None, \"0\", Some(N::Num(6)), None, None, \"d\", });\n+            assert_pns_eq_sub!(\"%4.2f\",\n+                { None, \"\", Some(N::Num(4)), Some(N::Num(2)), None, \"f\", });\n+            assert_pns_eq_sub!(\"%#x\",\n+                { None, \"#\", None, None, None, \"x\", });\n+            assert_pns_eq_sub!(\"%-10s\",\n+                { None, \"-\", Some(N::Num(10)), None, None, \"s\", });\n+            assert_pns_eq_sub!(\"%*s\",\n+                { None, \"\", Some(N::Next), None, None, \"s\", });\n+            assert_pns_eq_sub!(\"%-10.*s\",\n+                { None, \"-\", Some(N::Num(10)), Some(N::Next), None, \"s\", });\n+            assert_pns_eq_sub!(\"%-*.*s\",\n+                { None, \"-\", Some(N::Next), Some(N::Next), None, \"s\", });\n+            assert_pns_eq_sub!(\"%.6i\",\n+                { None, \"\", None, Some(N::Num(6)), None, \"i\", });\n+            assert_pns_eq_sub!(\"%+i\",\n+                { None, \"+\", None, None, None, \"i\", });\n+            assert_pns_eq_sub!(\"%08X\",\n+                { None, \"0\", Some(N::Num(8)), None, None, \"X\", });\n+            assert_pns_eq_sub!(\"%lu\",\n+                { None, \"\", None, None, Some(\"l\"), \"u\", });\n+            assert_pns_eq_sub!(\"%Iu\",\n+                { None, \"\", None, None, Some(\"I\"), \"u\", });\n+            assert_pns_eq_sub!(\"%I32u\",\n+                { None, \"\", None, None, Some(\"I32\"), \"u\", });\n+            assert_pns_eq_sub!(\"%I64u\",\n+                { None, \"\", None, None, Some(\"I64\"), \"u\", });\n+            assert_pns_eq_sub!(\"%'d\",\n+                { None, \"'\", None, None, None, \"d\", });\n+            assert_pns_eq_sub!(\"%10s\",\n+                { None, \"\", Some(N::Num(10)), None, None, \"s\", });\n+            assert_pns_eq_sub!(\"%-10.10s\",\n+                { None, \"-\", Some(N::Num(10)), Some(N::Num(10)), None, \"s\", });\n+            assert_pns_eq_sub!(\"%1$d\",\n+                { Some(1), \"\", None, None, None, \"d\", });\n+            assert_pns_eq_sub!(\"%2$.*3$d\",\n+                { Some(2), \"\", None, Some(N::Arg(3)), None, \"d\", });\n+            assert_pns_eq_sub!(\"%1$*2$.*3$d\",\n+                { Some(1), \"\", Some(N::Arg(2)), Some(N::Arg(3)), None, \"d\", });\n+            assert_pns_eq_sub!(\"%-8ld\",\n+                { None, \"-\", Some(N::Num(8)), None, Some(\"l\"), \"d\", });\n+        }\n+\n+        #[test]\n+        fn test_iter() {\n+            let s = \"The %d'th word %% is: `%.*s` %!\\n\";\n+            let subs: Vec<_> = iter_subs(s).map(|sub| sub.translate()).collect();\n+            assert_eq!(\n+                subs.iter().map(|ms| ms.as_ref().map(|s| &s[..])).collect::<Vec<_>>(),\n+                vec![Some(\"{}\"), None, Some(\"{:.*}\"), None]\n+            );\n+        }\n+\n+        /// Check that the translations are what we expect.\n+        #[test]\n+        fn test_trans() {\n+            assert_eq_pnsat!(\"%c\", Some(\"{}\"));\n+            assert_eq_pnsat!(\"%d\", Some(\"{}\"));\n+            assert_eq_pnsat!(\"%u\", Some(\"{}\"));\n+            assert_eq_pnsat!(\"%x\", Some(\"{:x}\"));\n+            assert_eq_pnsat!(\"%X\", Some(\"{:X}\"));\n+            assert_eq_pnsat!(\"%e\", Some(\"{:e}\"));\n+            assert_eq_pnsat!(\"%E\", Some(\"{:E}\"));\n+            assert_eq_pnsat!(\"%f\", Some(\"{}\"));\n+            assert_eq_pnsat!(\"%g\", Some(\"{:e}\"));\n+            assert_eq_pnsat!(\"%G\", Some(\"{:E}\"));\n+            assert_eq_pnsat!(\"%s\", Some(\"{}\"));\n+            assert_eq_pnsat!(\"%p\", Some(\"{:p}\"));\n+\n+            assert_eq_pnsat!(\"%06d\",        Some(\"{:06}\"));\n+            assert_eq_pnsat!(\"%4.2f\",       Some(\"{:4.2}\"));\n+            assert_eq_pnsat!(\"%#x\",         Some(\"{:#x}\"));\n+            assert_eq_pnsat!(\"%-10s\",       Some(\"{:<10}\"));\n+            assert_eq_pnsat!(\"%*s\",         None);\n+            assert_eq_pnsat!(\"%-10.*s\",     Some(\"{:<10.*}\"));\n+            assert_eq_pnsat!(\"%-*.*s\",      None);\n+            assert_eq_pnsat!(\"%.6i\",        Some(\"{:06}\"));\n+            assert_eq_pnsat!(\"%+i\",         Some(\"{:+}\"));\n+            assert_eq_pnsat!(\"%08X\",        Some(\"{:08X}\"));\n+            assert_eq_pnsat!(\"%lu\",         Some(\"{}\"));\n+            assert_eq_pnsat!(\"%Iu\",         Some(\"{}\"));\n+            assert_eq_pnsat!(\"%I32u\",       Some(\"{}\"));\n+            assert_eq_pnsat!(\"%I64u\",       Some(\"{}\"));\n+            assert_eq_pnsat!(\"%'d\",         None);\n+            assert_eq_pnsat!(\"%10s\",        Some(\"{:>10}\"));\n+            assert_eq_pnsat!(\"%-10.10s\",    Some(\"{:<10.10}\"));\n+            assert_eq_pnsat!(\"%1$d\",        Some(\"{0}\"));\n+            assert_eq_pnsat!(\"%2$.*3$d\",    Some(\"{1:02$}\"));\n+            assert_eq_pnsat!(\"%1$*2$.*3$s\", Some(\"{0:>1$.2$}\"));\n+            assert_eq_pnsat!(\"%-8ld\",       Some(\"{:<8}\"));\n+        }\n+    }\n+}\n+\n+pub mod shell {\n+    use super::strcursor::StrCursor as Cur;\n+\n+    #[derive(Clone, Eq, PartialEq, Debug)]\n+    pub enum Substitution<'a> {\n+        Ordinal(u8),\n+        Name(&'a str),\n+        Escape,\n+    }\n+\n+    impl<'a> Substitution<'a> {\n+        pub fn as_str(&self) -> String {\n+            match *self {\n+                Substitution::Ordinal(n) => format!(\"${}\", n),\n+                Substitution::Name(n) => format!(\"${}\", n),\n+                Substitution::Escape => \"$$\".into(),\n+            }\n+        }\n+\n+        pub fn translate(&self) -> Option<String> {\n+            match *self {\n+                Substitution::Ordinal(n) => Some(format!(\"{{{}}}\", n)),\n+                Substitution::Name(n) => Some(format!(\"{{{}}}\", n)),\n+                Substitution::Escape => None,\n+            }\n+        }\n+    }\n+\n+    /// Returns an iterator over all substitutions in a given string.\n+    pub fn iter_subs(s: &str) -> Substitutions {\n+        Substitutions {\n+            s: s,\n+        }\n+    }\n+\n+    /// Iterator over substitutions in a string.\n+    pub struct Substitutions<'a> {\n+        s: &'a str,\n+    }\n+\n+    impl<'a> Iterator for Substitutions<'a> {\n+        type Item = Substitution<'a>;\n+        fn next(&mut self) -> Option<Self::Item> {\n+            match parse_next_substitution(self.s) {\n+                Some((sub, tail)) => {\n+                    self.s = tail;\n+                    Some(sub)\n+                },\n+                None => None,\n+            }\n+        }\n+    }\n+\n+    /// Parse the next substitution from the input string.\n+    pub fn parse_next_substitution(s: &str) -> Option<(Substitution, &str)> {\n+        let at = {\n+            let start = try_opt!(s.find('$'));\n+            match s[start+1..].chars().next() {\n+                Some('$') => return Some((Substitution::Escape, &s[start+2..])),\n+                Some(c @ '0' ... '9') => {\n+                    let n = (c as u8) - b'0';\n+                    return Some((Substitution::Ordinal(n), &s[start+2..]));\n+                },\n+                Some(_) => {/* fall-through */},\n+                None => return None,\n+            }\n+\n+            Cur::new_at_start(&s[start..])\n+        };\n+\n+        let at = try_opt!(at.at_next_cp());\n+        match at.next_cp() {\n+            Some((c, inner)) => {\n+                if !is_ident_head(c) {\n+                    None\n+                } else {\n+                    let end = at_next_cp_while(inner, is_ident_tail);\n+                    Some((Substitution::Name(at.slice_between(end).unwrap()), end.slice_after()))\n+                }\n+            },\n+            _ => None\n+        }\n+    }\n+\n+    fn at_next_cp_while<F>(mut cur: Cur, mut pred: F) -> Cur\n+    where F: FnMut(char) -> bool {\n+        loop {\n+            match cur.next_cp() {\n+                Some((c, next)) => if pred(c) {\n+                    cur = next;\n+                } else {\n+                    return cur;\n+                },\n+                None => return cur,\n+            }\n+        }\n+    }\n+\n+    fn is_ident_head(c: char) -> bool {\n+        match c {\n+            'a' ... 'z' | 'A' ... 'Z' | '_' => true,\n+            _ => false\n+        }\n+    }\n+\n+    fn is_ident_tail(c: char) -> bool {\n+        match c {\n+            '0' ... '9' => true,\n+            c => is_ident_head(c)\n+        }\n+    }\n+\n+    #[cfg(test)]\n+    mod tests {\n+        use super::{\n+            Substitution as S,\n+            parse_next_substitution as pns,\n+        };\n+\n+        macro_rules! assert_eq_pnsat {\n+            ($lhs:expr, $rhs:expr) => {\n+                assert_eq!(\n+                    pns($lhs).and_then(|(f, _)| f.translate()),\n+                    $rhs.map(<String as From<&str>>::from)\n+                )\n+            };\n+        }\n+\n+        #[test]\n+        fn test_escape() {\n+            assert_eq!(pns(\"has no escapes\"), None);\n+            assert_eq!(pns(\"has no escapes, either $\"), None);\n+            assert_eq!(pns(\"*so* has a $$ escape\"), Some((S::Escape, \" escape\")));\n+            assert_eq!(pns(\"$$ leading escape\"), Some((S::Escape, \" leading escape\")));\n+            assert_eq!(pns(\"trailing escape $$\"), Some((S::Escape, \"\")));\n+        }\n+\n+        #[test]\n+        fn test_parse() {\n+            macro_rules! assert_pns_eq_sub {\n+                ($in_:expr, $kind:ident($arg:expr)) => {\n+                    assert_eq!(pns(concat!($in_, \"!\")), Some((S::$kind($arg.into()), \"!\")))\n+                };\n+            }\n+\n+            assert_pns_eq_sub!(\"$0\", Ordinal(0));\n+            assert_pns_eq_sub!(\"$1\", Ordinal(1));\n+            assert_pns_eq_sub!(\"$9\", Ordinal(9));\n+            assert_pns_eq_sub!(\"$N\", Name(\"N\"));\n+            assert_pns_eq_sub!(\"$NAME\", Name(\"NAME\"));\n+        }\n+\n+        #[test]\n+        fn test_iter() {\n+            use super::iter_subs;\n+            let s = \"The $0'th word $$ is: `$WORD` $!\\n\";\n+            let subs: Vec<_> = iter_subs(s).map(|sub| sub.translate()).collect();\n+            assert_eq!(\n+                subs.iter().map(|ms| ms.as_ref().map(|s| &s[..])).collect::<Vec<_>>(),\n+                vec![Some(\"{0}\"), None, Some(\"{WORD}\")]\n+            );\n+        }\n+\n+        #[test]\n+        fn test_trans() {\n+            assert_eq_pnsat!(\"$0\", Some(\"{0}\"));\n+            assert_eq_pnsat!(\"$9\", Some(\"{9}\"));\n+            assert_eq_pnsat!(\"$1\", Some(\"{1}\"));\n+            assert_eq_pnsat!(\"$10\", Some(\"{1}\"));\n+            assert_eq_pnsat!(\"$stuff\", Some(\"{stuff}\"));\n+            assert_eq_pnsat!(\"$NAME\", Some(\"{NAME}\"));\n+            assert_eq_pnsat!(\"$PREFIX/bin\", Some(\"{PREFIX}\"));\n+        }\n+\n+    }\n+}\n+\n+mod strcursor {\n+    use std;\n+\n+    pub struct StrCursor<'a> {\n+        s: &'a str,\n+        at: usize,\n+    }\n+\n+    impl<'a> StrCursor<'a> {\n+        pub fn new_at_start(s: &'a str) -> StrCursor<'a> {\n+            StrCursor {\n+                s: s,\n+                at: 0,\n+            }\n+        }\n+\n+        pub fn at_next_cp(mut self) -> Option<StrCursor<'a>> {\n+            match self.try_seek_right_cp() {\n+                true => Some(self),\n+                false => None\n+            }\n+        }\n+\n+        pub fn next_cp(mut self) -> Option<(char, StrCursor<'a>)> {\n+            let cp = match self.cp_after() {\n+                Some(cp) => cp,\n+                None => return None,\n+            };\n+            self.seek_right(cp.len_utf8());\n+            Some((cp, self))\n+        }\n+\n+        fn slice_before(&self) -> &'a str {\n+            &self.s[0..self.at]\n+        }\n+\n+        pub fn slice_after(&self) -> &'a str {\n+            &self.s[self.at..]\n+        }\n+\n+        pub fn slice_between(&self, until: StrCursor<'a>) -> Option<&'a str> {\n+            if !str_eq_literal(self.s, until.s) {\n+                None\n+            } else {\n+                use std::cmp::{max, min};\n+                let beg = min(self.at, until.at);\n+                let end = max(self.at, until.at);\n+                Some(&self.s[beg..end])\n+            }\n+        }\n+\n+        fn cp_after(&self) -> Option<char> {\n+            self.slice_after().chars().next()\n+        }\n+\n+        fn try_seek_right_cp(&mut self) -> bool {\n+            match self.slice_after().chars().next() {\n+                Some(c) => {\n+                    self.at += c.len_utf8();\n+                    true\n+                },\n+                None => false,\n+            }\n+        }\n+\n+        fn seek_right(&mut self, bytes: usize) {\n+            self.at += bytes;\n+        }\n+    }\n+\n+    impl<'a> Copy for StrCursor<'a> {}\n+\n+    impl<'a> Clone for StrCursor<'a> {\n+        fn clone(&self) -> StrCursor<'a> {\n+            *self\n+        }\n+    }\n+\n+    impl<'a> std::fmt::Debug for StrCursor<'a> {\n+        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> Result<(), std::fmt::Error> {\n+            write!(fmt, \"StrCursor({:?} | {:?})\", self.slice_before(), self.slice_after())\n+        }\n+    }\n+\n+    fn str_eq_literal(a: &str, b: &str) -> bool {\n+        a.as_bytes().as_ptr() == b.as_bytes().as_ptr()\n+            && a.len() == b.len()\n+    }\n+}"}, {"sha": "1ebac19b4f029ddab1bddc2199fb90e67371f263", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b619dcdaeb223bd4df6896e808f53ffa295c3ed0/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b619dcdaeb223bd4df6896e808f53ffa295c3ed0/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=b619dcdaeb223bd4df6896e808f53ffa295c3ed0", "patch": "@@ -40,6 +40,7 @@ mod concat;\n mod concat_idents;\n mod env;\n mod format;\n+mod format_foreign;\n mod log_syntax;\n mod trace_macros;\n "}, {"sha": "a23b4b077410c20dcdd0c45e3a36cf03cfbae29b", "filename": "src/test/compile-fail/ifmt-bad-arg.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b619dcdaeb223bd4df6896e808f53ffa295c3ed0/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b619dcdaeb223bd4df6896e808f53ffa295c3ed0/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs?ref=b619dcdaeb223bd4df6896e808f53ffa295c3ed0", "patch": "@@ -17,6 +17,7 @@ fn main() {\n                             //~^ ERROR: argument never used\n     format!(\"{foo}\");         //~ ERROR: no argument named `foo`\n \n+    format!(\"\", 1, 2);                 //~ ERROR: multiple unused formatting arguments\n     format!(\"{}\", 1, 2);               //~ ERROR: argument never used\n     format!(\"{1}\", 1, 2);              //~ ERROR: argument never used\n     format!(\"{}\", 1, foo=2);           //~ ERROR: named argument never used\n@@ -53,4 +54,6 @@ fn main() {\n \n     format!(\"foo } bar\"); //~ ERROR: unmatched `}` found\n     format!(\"foo }\"); //~ ERROR: unmatched `}` found\n+\n+    format!(\"foo %s baz\", \"bar\"); //~ ERROR: argument never used\n }"}, {"sha": "cca45ca9ecdd9fe6a4f62005995269e93f0d116b", "filename": "src/test/ui/macros/format-foreign.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b619dcdaeb223bd4df6896e808f53ffa295c3ed0/src%2Ftest%2Fui%2Fmacros%2Fformat-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b619dcdaeb223bd4df6896e808f53ffa295c3ed0/src%2Ftest%2Fui%2Fmacros%2Fformat-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fformat-foreign.rs?ref=b619dcdaeb223bd4df6896e808f53ffa295c3ed0", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    println!(\"%.*3$s %s!\\n\", \"Hello,\", \"World\", 4);\n+    println!(\"%1$*2$.*3$f\", 123.456);\n+\n+    // This should *not* produce hints, on the basis that there's equally as\n+    // many \"correct\" format specifiers.  It's *probably* just an actual typo.\n+    println!(\"{} %f\", \"one\", 2.0);\n+\n+    println!(\"Hi there, $NAME.\", NAME=\"Tim\");\n+}"}, {"sha": "0283052a89f53d19a128cd8cb4836f7dbae769c2", "filename": "src/test/ui/macros/format-foreign.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b619dcdaeb223bd4df6896e808f53ffa295c3ed0/src%2Ftest%2Fui%2Fmacros%2Fformat-foreign.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b619dcdaeb223bd4df6896e808f53ffa295c3ed0/src%2Ftest%2Fui%2Fmacros%2Fformat-foreign.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fformat-foreign.stderr?ref=b619dcdaeb223bd4df6896e808f53ffa295c3ed0", "patch": "@@ -0,0 +1,52 @@\n+error: multiple unused formatting arguments\n+  --> $DIR/format-foreign.rs:12:5\n+   |\n+12 |     println!(\"%.*3$s %s!/n\", \"Hello,\", \"World\", 4);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: argument never used\n+  --> $DIR/format-foreign.rs:12:30\n+   |\n+12 |     println!(\"%.*3$s %s!/n\", \"Hello,\", \"World\", 4);\n+   |                              ^^^^^^^^\n+note: argument never used\n+  --> $DIR/format-foreign.rs:12:40\n+   |\n+12 |     println!(\"%.*3$s %s!/n\", \"Hello,\", \"World\", 4);\n+   |                                        ^^^^^^^\n+note: argument never used\n+  --> $DIR/format-foreign.rs:12:49\n+   |\n+12 |     println!(\"%.*3$s %s!/n\", \"Hello,\", \"World\", 4);\n+   |                                                 ^\n+   = help: `%.*3$s` should be written as `{:.2$}`\n+   = help: `%s` should be written as `{}`\n+   = note: printf formatting not supported; see the documentation for `std::fmt`\n+   = note: this error originates in a macro outside of the current crate\n+\n+error: argument never used\n+  --> $DIR/format-foreign.rs:13:29\n+   |\n+13 |     println!(\"%1$*2$.*3$f\", 123.456);\n+   |                             ^^^^^^^\n+   |\n+   = help: `%1$*2$.*3$f` should be written as `{0:1$.2$}`\n+   = note: printf formatting not supported; see the documentation for `std::fmt`\n+\n+error: argument never used\n+  --> $DIR/format-foreign.rs:17:30\n+   |\n+17 |     println!(\"{} %f\", \"one\", 2.0);\n+   |                              ^^^\n+\n+error: named argument never used\n+  --> $DIR/format-foreign.rs:19:39\n+   |\n+19 |     println!(\"Hi there, $NAME.\", NAME=\"Tim\");\n+   |                                       ^^^^^\n+   |\n+   = help: `$NAME` should be written as `{NAME}`\n+   = note: shell formatting not supported; see the documentation for `std::fmt`\n+\n+error: aborting due to 4 previous errors\n+"}]}