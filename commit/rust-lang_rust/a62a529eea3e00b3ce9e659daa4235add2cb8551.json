{"sha": "a62a529eea3e00b3ce9e659daa4235add2cb8551", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2MmE1MjllZWEzZTAwYjNjZTllNjU5ZGFhNDIzNWFkZDJjYjg1NTE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-10-06T19:26:22Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-10-09T08:44:44Z"}, "message": "review comments", "tree": {"sha": "31206a669cf4f72b72deef90ef8cc160f50053d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31206a669cf4f72b72deef90ef8cc160f50053d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a62a529eea3e00b3ce9e659daa4235add2cb8551", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a62a529eea3e00b3ce9e659daa4235add2cb8551", "html_url": "https://github.com/rust-lang/rust/commit/a62a529eea3e00b3ce9e659daa4235add2cb8551", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a62a529eea3e00b3ce9e659daa4235add2cb8551/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87b0cf4541c319b6626c5583bfbeed6ece7306c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/87b0cf4541c319b6626c5583bfbeed6ece7306c1", "html_url": "https://github.com/rust-lang/rust/commit/87b0cf4541c319b6626c5583bfbeed6ece7306c1"}], "stats": {"total": 320, "additions": 255, "deletions": 65}, "files": [{"sha": "6673b9b28e7163a3c71e0fdd41dec83bd224a08d", "filename": "mk/crates.mk", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a62a529eea3e00b3ce9e659daa4235add2cb8551/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/a62a529eea3e00b3ce9e659daa4235add2cb8551/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=a62a529eea3e00b3ce9e659daa4235add2cb8551", "patch": "@@ -61,51 +61,55 @@ HOST_CRATES := syntax $(RUSTC_CRATES) rustdoc fmt_macros\n TOOLS := compiletest rustdoc rustc rustbook error-index-generator\n \n DEPS_core :=\n+DEPS_alloc := core libc alloc_system\n+DEPS_alloc_system := core libc\n+DEPS_collections := core alloc rustc_unicode\n DEPS_libc := core\n+DEPS_rand := core\n+DEPS_rustc_bitflags := core\n DEPS_rustc_unicode := core\n-DEPS_alloc := core libc alloc_system\n+\n DEPS_std := core libc rand alloc collections rustc_unicode \\\n \tnative:rust_builtin native:backtrace \\\n \talloc_system\n+DEPS_arena := std\n+DEPS_glob := std\n+DEPS_flate := std native:miniz\n+DEPS_fmt_macros = std\n+DEPS_getopts := std\n DEPS_graphviz := std\n+DEPS_log := std\n+DEPS_num := std\n+DEPS_rbml := std log serialize\n+DEPS_serialize := std log\n+DEPS_term := std log\n+DEPS_test := std getopts serialize rbml term native:rust_test_helpers\n+\n DEPS_syntax := std term serialize log fmt_macros arena libc rustc_bitflags\n+\n+DEPS_rustc := syntax flate arena serialize getopts rbml rustc_front\\\n+              log graphviz rustc_llvm rustc_back rustc_data_structures\n+DEPS_rustc_back := std syntax rustc_llvm rustc_front flate log libc\n+DEPS_rustc_borrowck := rustc rustc_front log graphviz syntax\n+DEPS_rustc_data_structures := std log serialize\n DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_borrowck \\\n                      rustc_typeck rustc_mir rustc_resolve log syntax serialize rustc_llvm \\\n \t\t             rustc_trans rustc_privacy rustc_lint rustc_front\n \n-DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back \\\n-\t                log syntax serialize rustc_llvm rustc_front rustc_platform_intrinsics\n-DEPS_rustc_mir := rustc rustc_front syntax\n-DEPS_rustc_typeck := rustc syntax rustc_front rustc_platform_intrinsics\n-DEPS_rustc_borrowck := rustc rustc_front log graphviz syntax\n-DEPS_rustc_resolve := rustc rustc_front log syntax\n-DEPS_rustc_privacy := rustc rustc_front log syntax\n DEPS_rustc_front := std syntax log serialize\n DEPS_rustc_lint := rustc log syntax\n-DEPS_rustc := syntax flate arena serialize getopts rbml rustc_front\\\n-              log graphviz rustc_llvm rustc_back rustc_data_structures\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags\n+DEPS_rustc_mir := rustc rustc_front syntax\n+DEPS_rustc_resolve := rustc rustc_front log syntax\n DEPS_rustc_platform_intrinsics := rustc rustc_llvm\n-DEPS_rustc_back := std syntax rustc_llvm rustc_front flate log libc\n-DEPS_rustc_data_structures := std log serialize\n+DEPS_rustc_privacy := rustc rustc_front log syntax\n+DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back \\\n+                    log syntax serialize rustc_llvm rustc_front rustc_platform_intrinsics\n+DEPS_rustc_typeck := rustc syntax rustc_front rustc_platform_intrinsics\n+\n DEPS_rustdoc := rustc rustc_driver native:hoedown serialize getopts \\\n                 test rustc_lint rustc_front\n-DEPS_rustc_bitflags := core\n-DEPS_flate := std native:miniz\n-DEPS_arena := std\n-DEPS_graphviz := std\n-DEPS_glob := std\n-DEPS_serialize := std log\n-DEPS_rbml := std log serialize\n-DEPS_term := std log\n-DEPS_getopts := std\n-DEPS_collections := core alloc rustc_unicode\n-DEPS_num := std\n-DEPS_test := std getopts serialize rbml term native:rust_test_helpers\n-DEPS_rand := core\n-DEPS_log := std\n-DEPS_fmt_macros = std\n-DEPS_alloc_system := core libc\n+\n \n TOOL_DEPS_compiletest := test getopts\n TOOL_DEPS_rustdoc := rustdoc"}, {"sha": "98f35ca5280086a3c4e79196f3dc43491bb48ee0", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a62a529eea3e00b3ce9e659daa4235add2cb8551/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a62a529eea3e00b3ce9e659daa4235add2cb8551/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=a62a529eea3e00b3ce9e659daa4235add2cb8551", "patch": "@@ -1379,7 +1379,7 @@ impl FakeExtCtxt for parse::ParseSess {\n struct FakeNodeIdAssigner;\n \n #[cfg(test)]\n-// It should go without sayingt that this may give unexpected results. Avoid\n+// It should go without saying that this may give unexpected results. Avoid\n // lowering anything which needs new nodes.\n impl NodeIdAssigner for FakeNodeIdAssigner {\n     fn next_node_id(&self) -> NodeId {"}, {"sha": "57186cb6ce837f0eab2411fc879b2234166d4a6b", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a62a529eea3e00b3ce9e659daa4235add2cb8551/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a62a529eea3e00b3ce9e659daa4235add2cb8551/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=a62a529eea3e00b3ce9e659daa4235add2cb8551", "patch": "@@ -224,12 +224,12 @@ trait HirPrinterSupport<'ast>: pprust_hir::PpAnn {\n     fn pp_ann<'a>(&'a self) -> &'a pprust_hir::PpAnn;\n }\n \n-struct NoAnn<'ast, 'tcx> {\n-    sess: &'tcx Session,\n+struct NoAnn<'ast> {\n+    sess: &'ast Session,\n     ast_map: Option<hir_map::Map<'ast>>\n }\n \n-impl<'ast, 'tcx> PrinterSupport<'ast> for NoAnn<'ast, 'tcx> {\n+impl<'ast> PrinterSupport<'ast> for NoAnn<'ast> {\n     fn sess<'a>(&'a self) -> &'a Session { self.sess }\n \n     fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n@@ -239,7 +239,7 @@ impl<'ast, 'tcx> PrinterSupport<'ast> for NoAnn<'ast, 'tcx> {\n     fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n }\n \n-impl<'ast, 'tcx> HirPrinterSupport<'ast> for NoAnn<'ast, 'tcx> {\n+impl<'ast> HirPrinterSupport<'ast> for NoAnn<'ast> {\n     fn sess<'a>(&'a self) -> &'a Session { self.sess }\n \n     fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n@@ -249,15 +249,15 @@ impl<'ast, 'tcx> HirPrinterSupport<'ast> for NoAnn<'ast, 'tcx> {\n     fn pp_ann<'a>(&'a self) -> &'a pprust_hir::PpAnn { self }\n }\n \n-impl<'ast, 'tcx> pprust::PpAnn for NoAnn<'ast, 'tcx> {}\n-impl<'ast, 'tcx> pprust_hir::PpAnn for NoAnn<'ast, 'tcx> {}\n+impl<'ast> pprust::PpAnn for NoAnn<'ast> {}\n+impl<'ast> pprust_hir::PpAnn for NoAnn<'ast> {}\n \n-struct IdentifiedAnnotation<'ast, 'tcx> {\n-    sess: &'tcx Session,\n+struct IdentifiedAnnotation<'ast> {\n+    sess: &'ast Session,\n     ast_map: Option<hir_map::Map<'ast>>,\n }\n \n-impl<'ast, 'tcx> PrinterSupport<'ast> for IdentifiedAnnotation<'ast, 'tcx> {\n+impl<'ast> PrinterSupport<'ast> for IdentifiedAnnotation<'ast> {\n     fn sess<'a>(&'a self) -> &'a Session { self.sess }\n \n     fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n@@ -267,7 +267,7 @@ impl<'ast, 'tcx> PrinterSupport<'ast> for IdentifiedAnnotation<'ast, 'tcx> {\n     fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n }\n \n-impl<'ast, 'tcx> pprust::PpAnn for IdentifiedAnnotation<'ast, 'tcx> {\n+impl<'ast> pprust::PpAnn for IdentifiedAnnotation<'ast> {\n     fn pre(&self,\n            s: &mut pprust::State,\n            node: pprust::AnnNode) -> io::Result<()> {\n@@ -307,7 +307,7 @@ impl<'ast, 'tcx> pprust::PpAnn for IdentifiedAnnotation<'ast, 'tcx> {\n     }\n }\n \n-impl<'ast, 'tcx> HirPrinterSupport<'ast> for IdentifiedAnnotation<'ast, 'tcx> {\n+impl<'ast> HirPrinterSupport<'ast> for IdentifiedAnnotation<'ast> {\n     fn sess<'a>(&'a self) -> &'a Session { self.sess }\n \n     fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n@@ -317,7 +317,7 @@ impl<'ast, 'tcx> HirPrinterSupport<'ast> for IdentifiedAnnotation<'ast, 'tcx> {\n     fn pp_ann<'a>(&'a self) -> &'a pprust_hir::PpAnn { self }\n }\n \n-impl<'ast, 'tcx> pprust_hir::PpAnn for IdentifiedAnnotation<'ast, 'tcx> {\n+impl<'ast> pprust_hir::PpAnn for IdentifiedAnnotation<'ast> {\n     fn pre(&self,\n            s: &mut pprust_hir::State,\n            node: pprust_hir::AnnNode) -> io::Result<()> {\n@@ -356,12 +356,12 @@ impl<'ast, 'tcx> pprust_hir::PpAnn for IdentifiedAnnotation<'ast, 'tcx> {\n     }\n }\n \n-struct HygieneAnnotation<'ast, 'tcx> {\n-    sess: &'tcx Session,\n+struct HygieneAnnotation<'ast> {\n+    sess: &'ast Session,\n     ast_map: Option<hir_map::Map<'ast>>,\n }\n \n-impl<'ast, 'tcx> PrinterSupport<'ast> for HygieneAnnotation<'ast, 'tcx> {\n+impl<'ast> PrinterSupport<'ast> for HygieneAnnotation<'ast> {\n     fn sess<'a>(&'a self) -> &'a Session { self.sess }\n \n     fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n@@ -371,7 +371,7 @@ impl<'ast, 'tcx> PrinterSupport<'ast> for HygieneAnnotation<'ast, 'tcx> {\n     fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n }\n \n-impl<'ast, 'tcx> pprust::PpAnn for HygieneAnnotation<'ast, 'tcx> {\n+impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n     fn post(&self,\n             s: &mut pprust::State,\n             node: pprust::AnnNode) -> io::Result<()> {"}, {"sha": "9066b93262cd64639fb0e8b4dfa1177b1395d596", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a62a529eea3e00b3ce9e659daa4235add2cb8551/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a62a529eea3e00b3ce9e659daa4235add2cb8551/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=a62a529eea3e00b3ce9e659daa4235add2cb8551", "patch": "@@ -586,7 +586,7 @@ pub enum UnsafeSource {\n }\n \n /// An expression\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash,)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub struct Expr {\n     pub id: NodeId,\n     pub node: Expr_,"}, {"sha": "4ee5fa2c1e9b5389c894dcfd4249f1e8f61e28a7", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 154, "deletions": 14, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/a62a529eea3e00b3ce9e659daa4235add2cb8551/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a62a529eea3e00b3ce9e659daa4235add2cb8551/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=a62a529eea3e00b3ce9e659daa4235add2cb8551", "patch": "@@ -25,13 +25,13 @@\n // 'folding' an existing one), then you create a new id using `next_id()`.\n //\n // You must ensure that ids are unique. That means that you should only use the\n-// is from an AST node in a single HIR node (you can assume that AST node ids\n+// id from an AST node in a single HIR node (you can assume that AST node ids\n // are unique). Every new node must have a unique id. Avoid cloning HIR nodes.\n-// If you do, you must then set one of the node's id to a fresh one.\n+// If you do, you must then set the new node's id to a fresh one.\n //\n // Lowering must be reproducable (the compiler only lowers once, but tools and\n // custom lints may lower an AST node to a HIR node to interact with the\n-// compiler). The only interesting bit of this is ids - if you lower an AST node\n+// compiler). The most interesting bit of this is ids - if you lower an AST node\n // and create new HIR nodes with fresh ids, when re-lowering the same node, you\n // must ensure you get the same ids! To do this, we keep track of the next id\n // when we translate a node which requires new ids. By checking this cache and\n@@ -44,6 +44,12 @@\n // all increments being for lowering. This means that you should not call any\n // non-lowering function which will use new node ids.\n //\n+// We must also cache gensym'ed Idents to ensure that we get the same Ident\n+// every time we lower a node with gensym'ed names. One consequence of this is\n+// that you can only gensym a name once in a lowering (you don't need to worry\n+// about nested lowering though). That's because we cache based on the name and\n+// the currently cached node id, which is unique per lowered node.\n+//\n // Spans are used for error messages and for tools to map semantics back to\n // source code. It is therefore not as important with spans as ids to be strict\n // about use (you can't break the compiler by screwing up a span). Obviously, a\n@@ -77,6 +83,10 @@ pub struct LoweringContext<'a> {\n     // 0 == no cached id. Must be incremented to align with previous id\n     // incrementing.\n     cached_id: Cell<u32>,\n+    // Keep track of gensym'ed idents.\n+    gensym_cache: RefCell<HashMap<(NodeId, &'static str), Ident>>,\n+    // A copy of cached_id, but is also set to an id while it is being cached.\n+    gensym_key: Cell<u32>,\n }\n \n impl<'a, 'hir> LoweringContext<'a> {\n@@ -96,6 +106,8 @@ impl<'a, 'hir> LoweringContext<'a> {\n             id_cache: RefCell::new(HashMap::new()),\n             id_assigner: id_assigner,\n             cached_id: Cell::new(0),\n+            gensym_cache: RefCell::new(HashMap::new()),\n+            gensym_key: Cell::new(0),\n         }\n     }\n \n@@ -108,6 +120,22 @@ impl<'a, 'hir> LoweringContext<'a> {\n         self.cached_id.set(cached + 1);\n         cached\n     }\n+\n+    fn str_to_ident(&self, s: &'static str) -> Ident {\n+        let cached_id = self.gensym_key.get();\n+        if cached_id == 0 {\n+            return token::gensym_ident(s);\n+        }\n+\n+        let cached = self.gensym_cache.borrow().contains_key(&(cached_id, s));\n+        if cached {\n+            self.gensym_cache.borrow()[&(cached_id, s)]\n+        } else {\n+            let result = token::gensym_ident(s);\n+            self.gensym_cache.borrow_mut().insert((cached_id, s), result);\n+            result\n+        }\n+    }\n }\n \n pub fn lower_view_path(_lctx: &LoweringContext, view_path: &ViewPath) -> P<hir::ViewPath> {\n@@ -861,6 +889,11 @@ struct CachedIdSetter<'a> {\n \n impl<'a> CachedIdSetter<'a> {\n     fn new(lctx: &'a LoweringContext, expr_id: NodeId) -> CachedIdSetter<'a> {\n+        // Only reset the id if it was previously 0, i.e., was not cached.\n+        // If it was cached, we are in a nested node, but our id count will\n+        // still count towards the parent's count.\n+        let reset_cached_id = lctx.cached_id.get() == 0;\n+\n         let id_cache: &mut HashMap<_, _> = &mut lctx.id_cache.borrow_mut();\n \n         if id_cache.contains_key(&expr_id) {\n@@ -869,20 +902,20 @@ impl<'a> CachedIdSetter<'a> {\n                 // We're entering a node where we need to track ids, but are not\n                 // yet tracking.\n                 lctx.cached_id.set(id_cache[&expr_id]);\n+                lctx.gensym_key.set(id_cache[&expr_id]);\n             } else {\n                 // We're already tracking - check that the tracked id is the same\n                 // as the expected id.\n                 assert!(cached_id == id_cache[&expr_id], \"id mismatch\");\n             }\n         } else {\n-            id_cache.insert(expr_id, lctx.id_assigner.peek_node_id());\n+            let next_id = lctx.id_assigner.peek_node_id();\n+            id_cache.insert(expr_id, next_id);\n+            lctx.gensym_key.set(next_id);\n         }\n \n         CachedIdSetter {\n-            // Only reset the id if it was previously 0, i.e., was not cached.\n-            // If it was cached, we are in a nested node, but our id count will\n-            // still count towards the parent's count.\n-            reset: lctx.cached_id.get() == 0,\n+            reset: reset_cached_id,\n             lctx: lctx,\n         }\n     }\n@@ -892,6 +925,7 @@ impl<'a> Drop for CachedIdSetter<'a> {\n     fn drop(&mut self) {\n         if self.reset {\n             self.lctx.cached_id.set(0);\n+            self.lctx.gensym_key.set(0);\n         }\n     }\n }\n@@ -936,9 +970,9 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 let placer_expr = lower_expr(lctx, placer);\n                 let value_expr = lower_expr(lctx, value_expr);\n \n-                let placer_ident = token::gensym_ident(\"placer\");\n-                let agent_ident = token::gensym_ident(\"place\");\n-                let p_ptr_ident = token::gensym_ident(\"p_ptr\");\n+                let placer_ident = lctx.str_to_ident(\"placer\");\n+                let agent_ident = lctx.str_to_ident(\"place\");\n+                let p_ptr_ident = lctx.str_to_ident(\"p_ptr\");\n \n                 let make_place = [\"ops\", \"Placer\", \"make_place\"];\n                 let place_pointer = [\"ops\", \"Place\", \"pointer\"];\n@@ -955,7 +989,13 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 let mk_stmt_let_mut = |lctx, bind, expr| stmt_let(lctx, e.span, true, bind, expr);\n \n                 // let placer = <placer_expr> ;\n-                let s1 = mk_stmt_let(lctx, placer_ident, placer_expr);\n+                let s1 = mk_stmt_let(lctx,\n+                                     placer_ident,\n+                                     signal_block_expr(lctx,\n+                                                       vec![],\n+                                                       placer_expr,\n+                                                       e.span,\n+                                                       hir::PopUnstableBlock));\n \n                 // let mut place = Placer::make_place(placer);\n                 let s2 = {\n@@ -1310,7 +1350,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 // expand <head>\n                 let head = lower_expr(lctx, head);\n \n-                let iter = token::gensym_ident(\"iter\");\n+                let iter = lctx.str_to_ident(\"iter\");\n \n                 // `::std::option::Option::Some(<pat>) => <body>`\n                 let pat_arm = {\n@@ -1385,7 +1425,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 let match_expr = expr_match(lctx, e.span, into_iter_expr, vec![iter_arm]);\n \n                 // `{ let result = ...; result }`\n-                let result_ident = token::gensym_ident(\"result\");\n+                let result_ident = lctx.str_to_ident(\"result\");\n                 return expr_block(lctx,\n                                   block_all(lctx,\n                                             e.span,\n@@ -1722,3 +1762,103 @@ fn signal_block_expr(lctx: &LoweringContext,\n                    expr: Some(expr),\n                }))\n }\n+\n+\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use syntax::ast::{self, NodeId, NodeIdAssigner};\n+    use syntax::{parse, codemap};\n+    use syntax::fold::Folder;\n+    use std::cell::Cell;\n+\n+    struct MockAssigner {\n+        next_id: Cell<NodeId>,\n+    }\n+\n+    impl MockAssigner {\n+        fn new() -> MockAssigner {\n+            MockAssigner {\n+                next_id: Cell::new(0),\n+            }\n+        }\n+    }\n+\n+    trait FakeExtCtxt {\n+        fn call_site(&self) -> codemap::Span;\n+        fn cfg(&self) -> ast::CrateConfig;\n+        fn ident_of(&self, st: &str) -> ast::Ident;\n+        fn name_of(&self, st: &str) -> ast::Name;\n+        fn parse_sess(&self) -> &parse::ParseSess;\n+    }\n+\n+    impl FakeExtCtxt for parse::ParseSess {\n+        fn call_site(&self) -> codemap::Span {\n+            codemap::Span {\n+                lo: codemap::BytePos(0),\n+                hi: codemap::BytePos(0),\n+                expn_id: codemap::NO_EXPANSION,\n+            }\n+        }\n+        fn cfg(&self) -> ast::CrateConfig { Vec::new() }\n+        fn ident_of(&self, st: &str) -> ast::Ident {\n+            parse::token::str_to_ident(st)\n+        }\n+        fn name_of(&self, st: &str) -> ast::Name {\n+            parse::token::intern(st)\n+        }\n+        fn parse_sess(&self) -> &parse::ParseSess { self }\n+    }\n+\n+    impl NodeIdAssigner for MockAssigner {\n+        fn next_node_id(&self) -> NodeId {\n+            let result = self.next_id.get();\n+            self.next_id.set(result + 1);\n+            result\n+        }\n+\n+        fn peek_node_id(&self) -> NodeId {\n+            self.next_id.get()\n+        }\n+    }\n+\n+    impl Folder for MockAssigner {\n+        fn new_id(&mut self, old_id: NodeId) -> NodeId {\n+            assert_eq!(old_id, ast::DUMMY_NODE_ID);\n+            self.next_node_id()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_preserves_ids() {\n+        let cx = parse::ParseSess::new();\n+        let mut assigner = MockAssigner::new();\n+\n+        let ast_if_let = quote_expr!(&cx, if let Some(foo) = baz { bar(foo); });\n+        let ast_if_let = assigner.fold_expr(ast_if_let);\n+        let ast_while_let = quote_expr!(&cx, while let Some(foo) = baz { bar(foo); });\n+        let ast_while_let = assigner.fold_expr(ast_while_let);\n+        let ast_for = quote_expr!(&cx, for i in 0..10 { foo(i); });\n+        let ast_for = assigner.fold_expr(ast_for);\n+        let ast_in = quote_expr!(&cx, in HEAP { foo() });\n+        let ast_in = assigner.fold_expr(ast_in);\n+\n+        let lctx = LoweringContext::new(&assigner, None);\n+        let hir1 = lower_expr(&lctx, &ast_if_let);\n+        let hir2 = lower_expr(&lctx, &ast_if_let);\n+        assert!(hir1 == hir2);\n+\n+        let hir1 = lower_expr(&lctx, &ast_while_let);\n+        let hir2 = lower_expr(&lctx, &ast_while_let);\n+        assert!(hir1 == hir2);\n+\n+        let hir1 = lower_expr(&lctx, &ast_for);\n+        let hir2 = lower_expr(&lctx, &ast_for);\n+        assert!(hir1 == hir2);\n+\n+        let hir1 = lower_expr(&lctx, &ast_in);\n+        let hir2 = lower_expr(&lctx, &ast_in);\n+        assert!(hir1 == hir2);\n+    }\n+}"}, {"sha": "d6114737ab5a2bfab0eadcb8b44453457267ef18", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a62a529eea3e00b3ce9e659daa4235add2cb8551/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a62a529eea3e00b3ce9e659daa4235add2cb8551/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=a62a529eea3e00b3ce9e659daa4235add2cb8551", "patch": "@@ -92,13 +92,8 @@ pub fn run(input: &str,\n     let map = hir_map::map_crate(&mut forest);\n \n     let ctx = core::DocContext {\n-<<<<<<< HEAD\n         map: &map,\n-        maybe_typed: core::NotTyped(sess),\n-=======\n-        krate: &krate,\n         maybe_typed: core::NotTyped(&sess),\n->>>>>>> Fixes to rustdoc, etc.\n         input: input,\n         external_paths: RefCell::new(Some(HashMap::new())),\n         external_traits: RefCell::new(None),"}, {"sha": "50a840e6c9b7f8407ee256106718926b449ef930", "filename": "src/test/compile-fail/placement-expr-unsafe.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a62a529eea3e00b3ce9e659daa4235add2cb8551/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a62a529eea3e00b3ce9e659daa4235add2cb8551/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unsafe.rs?ref=a62a529eea3e00b3ce9e659daa4235add2cb8551", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that placement in respects unsafe code checks.\n+\n+#![feature(box_heap)]\n+#![feature(placement_in_syntax)]\n+\n+fn main() {\n+    use std::boxed::HEAP;\n+\n+    let p: *const i32 = &42;\n+    let _ = in HEAP { *p }; //~ ERROR requires unsafe\n+\n+    let p: *const _ = &HEAP;\n+    let _ = in *p { 42 }; //~ ERROR requires unsafe\n+}"}, {"sha": "d981b71a8132ddb4269c71361aee8928637c2b83", "filename": "src/test/compile-fail/placement-expr-unstable.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a62a529eea3e00b3ce9e659daa4235add2cb8551/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a62a529eea3e00b3ce9e659daa4235add2cb8551/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unstable.rs?ref=a62a529eea3e00b3ce9e659daa4235add2cb8551", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that placement in respects unstable code checks.\n+\n+#![feature(placement_in_syntax)]\n+#![feature(core)]\n+\n+extern crate core;\n+\n+fn main() {\n+    use std::boxed::HEAP; //~ ERROR use of unstable library feature\n+\n+    let _ = in HEAP { //~ ERROR use of unstable library feature\n+        ::core::raw::Slice { //~ ERROR use of unstable library feature\n+            data: &42, //~ ERROR use of unstable library feature\n+            len: 1 //~ ERROR use of unstable library feature\n+        }\n+    };\n+}"}]}