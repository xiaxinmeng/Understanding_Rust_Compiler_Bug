{"sha": "dfd751303ec6336a4a78776eb8030790b7b0b000", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmZDc1MTMwM2VjNjMzNmE0YTc4Nzc2ZWI4MDMwNzkwYjdiMGIwMDA=", "commit": {"author": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-02-05T13:36:07Z"}, "committer": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-02-05T13:36:07Z"}, "message": "Move `find_struct_impl` to assist utils", "tree": {"sha": "bdacccec9a3df5694b2efaa76bc993af5761c50c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdacccec9a3df5694b2efaa76bc993af5761c50c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfd751303ec6336a4a78776eb8030790b7b0b000", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfd751303ec6336a4a78776eb8030790b7b0b000", "html_url": "https://github.com/rust-lang/rust/commit/dfd751303ec6336a4a78776eb8030790b7b0b000", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfd751303ec6336a4a78776eb8030790b7b0b000/comments", "author": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13d663dd16430cec18d7eccd214c3d4891b1a9a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/13d663dd16430cec18d7eccd214c3d4891b1a9a1", "html_url": "https://github.com/rust-lang/rust/commit/13d663dd16430cec18d7eccd214c3d4891b1a9a1"}], "stats": {"total": 239, "additions": 85, "deletions": 154}, "files": [{"sha": "270b438b705b1c0f2a3da576cb58a1795173526f", "filename": "crates/assists/src/handlers/generate_enum_match_method.rs", "status": "modified", "additions": 10, "deletions": 90, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/dfd751303ec6336a4a78776eb8030790b7b0b000/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_enum_match_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd751303ec6336a4a78776eb8030790b7b0b000/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_enum_match_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_enum_match_method.rs?ref=dfd751303ec6336a4a78776eb8030790b7b0b000", "patch": "@@ -1,10 +1,9 @@\n-use hir::Adt;\n-use stdx::format_to;\n+use stdx::{format_to, to_lower_snake_case};\n use syntax::ast::{self, AstNode, NameOwner};\n use syntax::{ast::VisibilityOwner, T};\n use test_utils::mark;\n \n-use crate::{AssistContext, AssistId, AssistKind, Assists};\n+use crate::{utils::find_struct_impl, AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: generate_enum_match_method\n //\n@@ -40,10 +39,14 @@ pub(crate) fn generate_enum_match_method(acc: &mut Assists, ctx: &AssistContext)\n         return None;\n     }\n \n-    let fn_name = to_lower_snake_case(&format!(\"{}\", variant_name));\n+    let fn_name = to_lower_snake_case(&variant_name.to_string());\n \n     // Return early if we've found an existing new fn\n-    let impl_def = find_struct_impl(&ctx, &parent_enum, format!(\"is_{}\", fn_name).as_str())?;\n+    let impl_def = find_struct_impl(\n+        &ctx,\n+        &ast::AdtDef::Enum(parent_enum.clone()),\n+        format!(\"is_{}\", fn_name).as_str(),\n+    )?;\n \n     let target = variant.syntax().text_range();\n     acc.add(\n@@ -95,104 +98,22 @@ pub(crate) fn generate_enum_match_method(acc: &mut Assists, ctx: &AssistContext)\n // parameters\n fn generate_impl_text(strukt: &ast::Enum, code: &str) -> String {\n     let mut buf = String::with_capacity(code.len());\n-    buf.push_str(\"\\n\\nimpl\");\n-    buf.push_str(\" \");\n+    buf.push_str(\"\\n\\nimpl \");\n     buf.push_str(strukt.name().unwrap().text());\n     format_to!(buf, \" {{\\n{}\\n}}\", code);\n     buf\n }\n \n-fn to_lower_snake_case(s: &str) -> String {\n-    let mut buf = String::with_capacity(s.len());\n-    let mut prev = false;\n-    for c in s.chars() {\n-        if c.is_ascii_uppercase() && prev {\n-            buf.push('_')\n-        }\n-        prev = true;\n-\n-        buf.push(c.to_ascii_lowercase());\n-    }\n-    buf\n-}\n-\n-// Uses a syntax-driven approach to find any impl blocks for the struct that\n-// exist within the module/file\n-//\n-// Returns `None` if we've found an existing `new` fn\n-//\n-// FIXME: change the new fn checking to a more semantic approach when that's more\n-// viable (e.g. we process proc macros, etc)\n-fn find_struct_impl(\n-    ctx: &AssistContext,\n-    strukt: &ast::Enum,\n-    name: &str,\n-) -> Option<Option<ast::Impl>> {\n-    let db = ctx.db();\n-    let module = strukt.syntax().ancestors().find(|node| {\n-        ast::Module::can_cast(node.kind()) || ast::SourceFile::can_cast(node.kind())\n-    })?;\n-\n-    let struct_def = ctx.sema.to_def(strukt)?;\n-\n-    let block = module.descendants().filter_map(ast::Impl::cast).find_map(|impl_blk| {\n-        let blk = ctx.sema.to_def(&impl_blk)?;\n-\n-        // FIXME: handle e.g. `struct S<T>; impl<U> S<U> {}`\n-        // (we currently use the wrong type parameter)\n-        // also we wouldn't want to use e.g. `impl S<u32>`\n-        let same_ty = match blk.target_ty(db).as_adt() {\n-            Some(def) => def == Adt::Enum(struct_def),\n-            None => false,\n-        };\n-        let not_trait_impl = blk.target_trait(db).is_none();\n-\n-        if !(same_ty && not_trait_impl) {\n-            None\n-        } else {\n-            Some(impl_blk)\n-        }\n-    });\n-\n-    if let Some(ref impl_blk) = block {\n-        if has_fn(impl_blk, name) {\n-            mark::hit!(test_gen_enum_match_impl_already_exists);\n-            return None;\n-        }\n-    }\n-\n-    Some(block)\n-}\n-\n-fn has_fn(imp: &ast::Impl, rhs_name: &str) -> bool {\n-    if let Some(il) = imp.assoc_item_list() {\n-        for item in il.assoc_items() {\n-            if let ast::AssocItem::Fn(f) = item {\n-                if let Some(name) = f.name() {\n-                    if name.text().eq_ignore_ascii_case(rhs_name) {\n-                        return true;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    false\n-}\n-\n #[cfg(test)]\n mod tests {\n-    use ide_db::helpers::FamousDefs;\n     use test_utils::mark;\n \n     use crate::tests::{check_assist, check_assist_not_applicable};\n \n     use super::*;\n \n     fn check_not_applicable(ra_fixture: &str) {\n-        let fixture =\n-            format!(\"//- /main.rs crate:main deps:core\\n{}\\n{}\", ra_fixture, FamousDefs::FIXTURE);\n-        check_assist_not_applicable(generate_enum_match_method, &fixture)\n+        check_assist_not_applicable(generate_enum_match_method, ra_fixture)\n     }\n \n     #[test]\n@@ -221,7 +142,6 @@ impl Variant {\n \n     #[test]\n     fn test_generate_enum_match_already_implemented() {\n-        mark::check!(test_gen_enum_match_impl_already_exists);\n         check_not_applicable(\n             r#\"\n enum Variant {"}, {"sha": "84832273f491da9ffd57c532702d77760bc2016e", "filename": "crates/assists/src/handlers/generate_new.rs", "status": "modified", "additions": 2, "deletions": 62, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/dfd751303ec6336a4a78776eb8030790b7b0b000/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd751303ec6336a4a78776eb8030790b7b0b000/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_new.rs?ref=dfd751303ec6336a4a78776eb8030790b7b0b000", "patch": "@@ -1,12 +1,11 @@\n-use hir::Adt;\n use itertools::Itertools;\n use stdx::format_to;\n use syntax::{\n     ast::{self, AstNode, GenericParamsOwner, NameOwner, StructKind, VisibilityOwner},\n     SmolStr, T,\n };\n \n-use crate::{AssistContext, AssistId, AssistKind, Assists};\n+use crate::{utils::find_struct_impl, AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: generate_new\n //\n@@ -38,7 +37,7 @@ pub(crate) fn generate_new(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     };\n \n     // Return early if we've found an existing new fn\n-    let impl_def = find_struct_impl(&ctx, &strukt)?;\n+    let impl_def = find_struct_impl(&ctx, &ast::AdtDef::Struct(strukt.clone()), \"new\")?;\n \n     let target = strukt.syntax().text_range();\n     acc.add(AssistId(\"generate_new\", AssistKind::Generate), \"Generate `new`\", target, |builder| {\n@@ -111,65 +110,6 @@ fn generate_impl_text(strukt: &ast::Struct, code: &str) -> String {\n     buf\n }\n \n-// Uses a syntax-driven approach to find any impl blocks for the struct that\n-// exist within the module/file\n-//\n-// Returns `None` if we've found an existing `new` fn\n-//\n-// FIXME: change the new fn checking to a more semantic approach when that's more\n-// viable (e.g. we process proc macros, etc)\n-fn find_struct_impl(ctx: &AssistContext, strukt: &ast::Struct) -> Option<Option<ast::Impl>> {\n-    let db = ctx.db();\n-    let module = strukt.syntax().ancestors().find(|node| {\n-        ast::Module::can_cast(node.kind()) || ast::SourceFile::can_cast(node.kind())\n-    })?;\n-\n-    let struct_def = ctx.sema.to_def(strukt)?;\n-\n-    let block = module.descendants().filter_map(ast::Impl::cast).find_map(|impl_blk| {\n-        let blk = ctx.sema.to_def(&impl_blk)?;\n-\n-        // FIXME: handle e.g. `struct S<T>; impl<U> S<U> {}`\n-        // (we currently use the wrong type parameter)\n-        // also we wouldn't want to use e.g. `impl S<u32>`\n-        let same_ty = match blk.target_ty(db).as_adt() {\n-            Some(def) => def == Adt::Struct(struct_def),\n-            None => false,\n-        };\n-        let not_trait_impl = blk.target_trait(db).is_none();\n-\n-        if !(same_ty && not_trait_impl) {\n-            None\n-        } else {\n-            Some(impl_blk)\n-        }\n-    });\n-\n-    if let Some(ref impl_blk) = block {\n-        if has_new_fn(impl_blk) {\n-            return None;\n-        }\n-    }\n-\n-    Some(block)\n-}\n-\n-fn has_new_fn(imp: &ast::Impl) -> bool {\n-    if let Some(il) = imp.assoc_item_list() {\n-        for item in il.assoc_items() {\n-            if let ast::AssocItem::Fn(f) = item {\n-                if let Some(name) = f.name() {\n-                    if name.text().eq_ignore_ascii_case(\"new\") {\n-                        return true;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    false\n-}\n-\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};"}, {"sha": "3842558d8dafb47e0b35c314897fbbdf3dc52a0f", "filename": "crates/assists/src/utils.rs", "status": "modified", "additions": 73, "deletions": 2, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/dfd751303ec6336a4a78776eb8030790b7b0b000/crates%2Fassists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd751303ec6336a4a78776eb8030790b7b0b000/crates%2Fassists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils.rs?ref=dfd751303ec6336a4a78776eb8030790b7b0b000", "patch": "@@ -2,7 +2,7 @@\n \n use std::ops;\n \n-use hir::HasSource;\n+use hir::{Adt, HasSource};\n use ide_db::{helpers::SnippetCap, RootDatabase};\n use itertools::Itertools;\n use syntax::{\n@@ -15,7 +15,10 @@ use syntax::{\n     SyntaxNode, TextSize, T,\n };\n \n-use crate::ast_transform::{self, AstTransform, QualifyPaths, SubstituteTypeParams};\n+use crate::{\n+    assist_context::AssistContext,\n+    ast_transform::{self, AstTransform, QualifyPaths, SubstituteTypeParams},\n+};\n \n pub(crate) fn unwrap_trivial_block(block: ast::BlockExpr) -> ast::Expr {\n     extract_trivial_expression(&block)\n@@ -267,3 +270,71 @@ pub(crate) fn does_pat_match_variant(pat: &ast::Pat, var: &ast::Pat) -> bool {\n \n     pat_head == var_head\n }\n+\n+// Uses a syntax-driven approach to find any impl blocks for the struct that\n+// exist within the module/file\n+//\n+// Returns `None` if we've found an existing `new` fn\n+//\n+// FIXME: change the new fn checking to a more semantic approach when that's more\n+// viable (e.g. we process proc macros, etc)\n+pub(crate) fn find_struct_impl(\n+    ctx: &AssistContext,\n+    strukt: &ast::AdtDef,\n+    name: &str,\n+) -> Option<Option<ast::Impl>> {\n+    let db = ctx.db();\n+    let module = strukt.syntax().ancestors().find(|node| {\n+        ast::Module::can_cast(node.kind()) || ast::SourceFile::can_cast(node.kind())\n+    })?;\n+\n+    let struct_def = match strukt {\n+        ast::AdtDef::Enum(e) => Adt::Enum(ctx.sema.to_def(e)?),\n+        ast::AdtDef::Struct(s) => Adt::Struct(ctx.sema.to_def(s)?),\n+        ast::AdtDef::Union(u) => Adt::Union(ctx.sema.to_def(u)?),\n+    };\n+\n+    let block = module.descendants().filter_map(ast::Impl::cast).find_map(|impl_blk| {\n+        let blk = ctx.sema.to_def(&impl_blk)?;\n+\n+        // FIXME: handle e.g. `struct S<T>; impl<U> S<U> {}`\n+        // (we currently use the wrong type parameter)\n+        // also we wouldn't want to use e.g. `impl S<u32>`\n+\n+        let same_ty = match blk.target_ty(db).as_adt() {\n+            Some(def) => def == struct_def,\n+            None => false,\n+        };\n+        let not_trait_impl = blk.target_trait(db).is_none();\n+\n+        if !(same_ty && not_trait_impl) {\n+            None\n+        } else {\n+            Some(impl_blk)\n+        }\n+    });\n+\n+    if let Some(ref impl_blk) = block {\n+        if has_fn(impl_blk, name) {\n+            return None;\n+        }\n+    }\n+\n+    Some(block)\n+}\n+\n+fn has_fn(imp: &ast::Impl, rhs_name: &str) -> bool {\n+    if let Some(il) = imp.assoc_item_list() {\n+        for item in il.assoc_items() {\n+            if let ast::AssocItem::Fn(f) = item {\n+                if let Some(name) = f.name() {\n+                    if name.text().eq_ignore_ascii_case(rhs_name) {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    false\n+}"}]}