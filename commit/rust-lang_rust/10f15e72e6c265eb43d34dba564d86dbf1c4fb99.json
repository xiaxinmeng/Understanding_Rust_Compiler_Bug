{"sha": "10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwZjE1ZTcyZTZjMjY1ZWI0M2QzNGRiYTU2NGQ4NmRiZjFjNGZiOTk=", "commit": {"author": {"name": "Tamir Duberstein", "email": "tamird@gmail.com", "date": "2015-03-24T23:54:09Z"}, "committer": {"name": "Tamir Duberstein", "email": "tamird@gmail.com", "date": "2015-04-15T03:26:03Z"}, "message": "Negative case of `len()` -> `is_empty()`\n\n`s/([^\\(\\s]+\\.)len\\(\\) [(?:!=)>] 0/!$1is_empty()/g`", "tree": {"sha": "d7032704f432c471748b1259d03975fef6e80eb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7032704f432c471748b1259d03975fef6e80eb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "html_url": "https://github.com/rust-lang/rust/commit/10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/comments", "author": {"login": "tamird", "id": 1535036, "node_id": "MDQ6VXNlcjE1MzUwMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1535036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tamird", "html_url": "https://github.com/tamird", "followers_url": "https://api.github.com/users/tamird/followers", "following_url": "https://api.github.com/users/tamird/following{/other_user}", "gists_url": "https://api.github.com/users/tamird/gists{/gist_id}", "starred_url": "https://api.github.com/users/tamird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tamird/subscriptions", "organizations_url": "https://api.github.com/users/tamird/orgs", "repos_url": "https://api.github.com/users/tamird/repos", "events_url": "https://api.github.com/users/tamird/events{/privacy}", "received_events_url": "https://api.github.com/users/tamird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tamird", "id": 1535036, "node_id": "MDQ6VXNlcjE1MzUwMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1535036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tamird", "html_url": "https://github.com/tamird", "followers_url": "https://api.github.com/users/tamird/followers", "following_url": "https://api.github.com/users/tamird/following{/other_user}", "gists_url": "https://api.github.com/users/tamird/gists{/gist_id}", "starred_url": "https://api.github.com/users/tamird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tamird/subscriptions", "organizations_url": "https://api.github.com/users/tamird/orgs", "repos_url": "https://api.github.com/users/tamird/repos", "events_url": "https://api.github.com/users/tamird/events{/privacy}", "received_events_url": "https://api.github.com/users/tamird/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29ac04402d53d358a1f6200bea45a301ff05b2d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/29ac04402d53d358a1f6200bea45a301ff05b2d1", "html_url": "https://github.com/rust-lang/rust/commit/29ac04402d53d358a1f6200bea45a301ff05b2d1"}], "stats": {"total": 284, "additions": 142, "deletions": 142}, "files": [{"sha": "d014512666f90dd3156fbbd089cda7329da56d98", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -368,7 +368,7 @@ pub fn make_metrics_test_closure(config: &Config, testfile: &Path) -> test::Test\n fn extract_gdb_version(full_version_line: Option<String>) -> Option<String> {\n     match full_version_line {\n         Some(ref full_version_line)\n-          if full_version_line.trim().len() > 0 => {\n+          if !full_version_line.trim().is_empty() => {\n             let full_version_line = full_version_line.trim();\n \n             // used to be a regex \"(^|[^0-9])([0-9]\\.[0-9])([^0-9]|$)\"\n@@ -408,7 +408,7 @@ fn extract_lldb_version(full_version_line: Option<String>) -> Option<String> {\n \n     match full_version_line {\n         Some(ref full_version_line)\n-          if full_version_line.trim().len() > 0 => {\n+          if !full_version_line.trim().is_empty() => {\n             let full_version_line = full_version_line.trim();\n \n             for (pos, l) in full_version_line.char_indices() {\n@@ -426,7 +426,7 @@ fn extract_lldb_version(full_version_line: Option<String>) -> Option<String> {\n                 let vers = full_version_line[pos + 5..].chars().take_while(|c| {\n                     c.is_digit(10)\n                 }).collect::<String>();\n-                if vers.len() > 0 { return Some(vers) }\n+                if !vers.is_empty() { return Some(vers) }\n             }\n             println!(\"Could not extract LLDB version from line '{}'\",\n                      full_version_line);"}, {"sha": "581cfa3f09bf4d020e19148e0a5aeccfcaab7e2d", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -1225,7 +1225,7 @@ impl<K, V> Node<K, V> {\n     /// because we have one too many, and our parent now has one too few\n     fn split(&mut self) -> (K, V, Node<K, V>) {\n         // Necessary for correctness, but in a private function\n-        debug_assert!(self.len() > 0);\n+        debug_assert!(!self.is_empty());\n \n         let mut right = if self.is_leaf() {\n             Node::new_leaf(self.capacity())"}, {"sha": "740fa3eb19e86db086df0d081e17c7e3171c88bc", "filename": "src/libcore/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -227,7 +227,7 @@ impl CharExt for char {\n #[inline]\n pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<usize> {\n     // Marked #[inline] to allow llvm optimizing it away\n-    if code < MAX_ONE_B && dst.len() >= 1 {\n+    if code < MAX_ONE_B && !dst.is_empty() {\n         dst[0] = code as u8;\n         Some(1)\n     } else if code < MAX_TWO_B && dst.len() >= 2 {\n@@ -258,7 +258,7 @@ pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<usize> {\n #[inline]\n pub fn encode_utf16_raw(mut ch: u32, dst: &mut [u16]) -> Option<usize> {\n     // Marked #[inline] to allow llvm optimizing it away\n-    if (ch & 0xFFFF) == ch  && dst.len() >= 1 {\n+    if (ch & 0xFFFF) == ch && !dst.is_empty() {\n         // The BMP falls through (assuming non-surrogate, as it should)\n         dst[0] = ch as u16;\n         Some(1)"}, {"sha": "fa2ae79688d72a89d429601e241a221fe960e22b", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -371,7 +371,7 @@ impl<'a> Parser<'a> {\n             None => {\n                 let tmp = self.cur.clone();\n                 match self.word() {\n-                    word if word.len() > 0 => {\n+                    word if !word.is_empty() => {\n                         if self.consume('$') {\n                             CountIsName(word)\n                         } else {\n@@ -463,7 +463,7 @@ mod tests {\n     fn musterr(s: &str) {\n         let mut p = Parser::new(s);\n         p.next();\n-        assert!(p.errors.len() != 0);\n+        assert!(!p.errors.is_empty());\n     }\n \n     #[test]"}, {"sha": "02c4a2339966f9352379519bc5f91898cbf8ee20", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -804,7 +804,7 @@ fn format_option(opt: &OptGroup) -> String {\n     }\n \n     // Use short_name is possible, but fallback to long_name.\n-    if opt.short_name.len() > 0 {\n+    if !opt.short_name.is_empty() {\n         line.push('-');\n         line.push_str(&opt.short_name[..]);\n     } else {"}, {"sha": "29270bd6c624bac0aa02705a1526f09742da3be3", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -469,7 +469,7 @@ fn each_auxiliary_node_id<F>(item: &ast::Item, callback: F) -> bool where\n         ast::ItemStruct(ref struct_def, _) => {\n             // If this is a newtype struct, return the constructor.\n             match struct_def.ctor_id {\n-                Some(ctor_id) if struct_def.fields.len() > 0 &&\n+                Some(ctor_id) if !struct_def.fields.is_empty() &&\n                         struct_def.fields[0].node.kind.is_unnamed() => {\n                     continue_ = callback(ctor_id);\n                 }"}, {"sha": "375e116c6d3e01ee45b9d58f5d3e63df6ed90757", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -307,13 +307,13 @@ impl<'a> Context<'a> {\n     }\n \n     pub fn report_load_errs(&mut self) {\n-        let message = if self.rejected_via_hash.len() > 0 {\n+        let message = if !self.rejected_via_hash.is_empty() {\n             format!(\"found possibly newer version of crate `{}`\",\n                     self.ident)\n-        } else if self.rejected_via_triple.len() > 0 {\n+        } else if !self.rejected_via_triple.is_empty() {\n             format!(\"couldn't find crate `{}` with expected target triple {}\",\n                     self.ident, self.triple)\n-        } else if self.rejected_via_kind.len() > 0 {\n+        } else if !self.rejected_via_kind.is_empty() {\n             format!(\"found staticlib `{}` instead of rlib or dylib\", self.ident)\n         } else {\n             format!(\"can't find crate for `{}`\", self.ident)\n@@ -325,15 +325,15 @@ impl<'a> Context<'a> {\n         };\n         self.sess.span_err(self.span, &message[..]);\n \n-        if self.rejected_via_triple.len() > 0 {\n+        if !self.rejected_via_triple.is_empty() {\n             let mismatches = self.rejected_via_triple.iter();\n             for (i, &CrateMismatch{ ref path, ref got }) in mismatches.enumerate() {\n                 self.sess.fileline_note(self.span,\n                     &format!(\"crate `{}`, path #{}, triple {}: {}\",\n                             self.ident, i+1, got, path.display()));\n             }\n         }\n-        if self.rejected_via_hash.len() > 0 {\n+        if !self.rejected_via_hash.is_empty() {\n             self.sess.span_note(self.span, \"perhaps this crate needs \\\n                                             to be recompiled?\");\n             let mismatches = self.rejected_via_hash.iter();\n@@ -353,7 +353,7 @@ impl<'a> Context<'a> {\n                 }\n             }\n         }\n-        if self.rejected_via_kind.len() > 0 {\n+        if !self.rejected_via_kind.is_empty() {\n             self.sess.fileline_help(self.span, \"please recompile this crate using \\\n                                             --crate-type lib\");\n             let mismatches = self.rejected_via_kind.iter();"}, {"sha": "2befbf9924577dd7a61905074daa235922e2a2f6", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -182,7 +182,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn mark_live_symbols(&mut self) {\n         let mut scanned = HashSet::new();\n-        while self.worklist.len() > 0 {\n+        while !self.worklist.is_empty() {\n             let id = self.worklist.pop().unwrap();\n             if scanned.contains(&id) {\n                 continue"}, {"sha": "3dbbcce27b6eac3382a6dce15767ab790dee0a0f", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -966,7 +966,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     fn pick_lifetime(&self,\n                      region_names: &HashSet<ast::Name>)\n                      -> (ast::Lifetime, FreshOrKept) {\n-        if region_names.len() > 0 {\n+        if !region_names.is_empty() {\n             // It's not necessary to convert the set of region names to a\n             // vector of string and then sort them. However, it makes the\n             // choice of lifetime name deterministic and thus easier to test."}, {"sha": "c6be97e6dbe0dc46f6db6108d227310e963ef274", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -246,7 +246,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     fn in_snapshot(&self) -> bool {\n-        self.undo_log.borrow().len() > 0\n+        !self.undo_log.borrow().is_empty()\n     }\n \n     pub fn start_snapshot(&self) -> RegionSnapshot {"}, {"sha": "d4136637e585c5391a76fde2bf3b79759aa1875e", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -1527,7 +1527,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     // for nil return types, it is ok to not return a value expl.\n                 } else {\n                     let ends_with_stmt = match body.expr {\n-                        None if body.stmts.len() > 0 =>\n+                        None if !body.stmts.is_empty() =>\n                             match body.stmts.first().unwrap().node {\n                                 ast::StmtSemi(ref e, _) => {\n                                     ty::expr_ty(self.ir.tcx, &**e) == t_ret"}, {"sha": "a9da92a768fe64c43644c22799012336e6f1e47e", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -227,7 +227,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                                                                                ref bounds,\n                                                                                ref bound_lifetimes,\n                                                                                .. }) => {\n-                    if bound_lifetimes.len() > 0 {\n+                    if !bound_lifetimes.is_empty() {\n                         self.trait_ref_hack = true;\n                         let result = self.with(LateScope(bound_lifetimes, self.scope),\n                                                |old_scope, this| {\n@@ -267,7 +267,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                             _modifier: &ast::TraitBoundModifier) {\n         debug!(\"visit_poly_trait_ref trait_ref={:?}\", trait_ref);\n \n-        if !self.trait_ref_hack || trait_ref.bound_lifetimes.len() > 0 {\n+        if !self.trait_ref_hack || !trait_ref.bound_lifetimes.is_empty() {\n             if self.trait_ref_hack {\n                 println!(\"{:?}\", trait_ref.span);\n                 span_err!(self.sess, trait_ref.span, E0316,"}, {"sha": "1e817890440f2ac2b7539afbdf296da32d15a345", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -3665,7 +3665,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                     res = res | TC::OwnsDtor;\n                 }\n \n-                if variants.len() != 0 {\n+                if !variants.is_empty() {\n                     let repr_hints = lookup_repr_hints(cx, did);\n                     if repr_hints.len() > 1 {\n                         // this is an error later on, but this type isn't safe\n@@ -4654,7 +4654,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n             match resolve_expr(tcx, expr) {\n                 def::DefVariant(tid, vid, _) => {\n                     let variant_info = enum_variant_with_id(tcx, tid, vid);\n-                    if variant_info.args.len() > 0 {\n+                    if !variant_info.args.is_empty() {\n                         // N-ary variant.\n                         RvalueDatumExpr\n                     } else {\n@@ -5259,7 +5259,7 @@ impl<'tcx> VariantInfo<'tcx> {\n \n         match ast_variant.node.kind {\n             ast::TupleVariantKind(ref args) => {\n-                let arg_tys = if args.len() > 0 {\n+                let arg_tys = if !args.is_empty() {\n                     // the regions in the argument types come from the\n                     // enum def'n, and hence will all be early bound\n                     ty::no_late_bound_regions(cx, &ty_fn_args(ctor_ty)).unwrap()\n@@ -5280,7 +5280,7 @@ impl<'tcx> VariantInfo<'tcx> {\n             ast::StructVariantKind(ref struct_def) => {\n                 let fields: &[StructField] = &struct_def.fields;\n \n-                assert!(fields.len() > 0);\n+                assert!(!fields.is_empty());\n \n                 let arg_tys = struct_def.fields.iter()\n                     .map(|field| node_id_to_type(cx, field.node.id)).collect();"}, {"sha": "1c414d3d5f3910ec51afbd64f5e02cbbe40d0ebe", "filename": "src/librustc/middle/ty_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -544,7 +544,7 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n                                  .map(|(a, b)| relation.relate(a, b))\n                                  .collect::<Result<_, _>>());\n                 Ok(ty::mk_tup(tcx, ts))\n-            } else if as_.len() != 0 && bs.len() != 0 {\n+            } else if !(as_.is_empty() || bs.is_empty()) {\n                 Err(ty::terr_tuple_size(\n                     expected_found(relation, &as_.len(), &bs.len())))\n             } else {"}, {"sha": "fe076b904caef65d03557b74d5234883149379df", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -558,7 +558,7 @@ pub fn parameterized<'tcx,GG>(cx: &ctxt<'tcx>,\n                     &strs[0][..]\n                 },\n                 tail)\n-    } else if strs.len() > 0 {\n+    } else if !strs.is_empty() {\n         format!(\"{}<{}>\", base, strs.connect(\", \"))\n     } else {\n         format!(\"{}\", base)"}, {"sha": "de934cf65ac21c0d0b8ff60becd52fa11fe54b40", "filename": "src/librustc_back/tempdir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_back%2Ftempdir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_back%2Ftempdir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftempdir.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -50,7 +50,7 @@ impl TempDir {\n         let mut rng = thread_rng();\n         for _ in 0..NUM_RETRIES {\n             let suffix: String = rng.gen_ascii_chars().take(NUM_RAND_CHARS).collect();\n-            let leaf = if prefix.len() > 0 {\n+            let leaf = if !prefix.is_empty() {\n                 format!(\"{}.{}\", prefix, suffix)\n             } else {\n                 // If we're given an empty string for a prefix, then creating a"}, {"sha": "bdc3fdcfc1415ae0cc9398d2991a0090740b024c", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -778,7 +778,7 @@ impl NonCamelCaseTypes {\n \n             // start with a non-lowercase letter rather than non-uppercase\n             // ones (some scripts don't have a concept of upper/lowercase)\n-            ident.len() > 0 && !ident.char_at(0).is_lowercase() && !ident.contains('_')\n+            !ident.is_empty() && !ident.char_at(0).is_lowercase() && !ident.contains('_')\n         }\n \n         fn to_camel_case(s: &str) -> String {\n@@ -1900,7 +1900,7 @@ impl LintPass for UnconditionalRecursion {\n         // doesn't return (e.g. calls a `-> !` function or `loop { /*\n         // no break */ }`) shouldn't be linted unless it actually\n         // recurs.\n-        if !reached_exit_without_self_call && self_call_spans.len() > 0 {\n+        if !reached_exit_without_self_call && !self_call_spans.is_empty() {\n             cx.span_lint(UNCONDITIONAL_RECURSION, sp,\n                          \"function cannot return without recurring\");\n "}, {"sha": "70c824a67a0efbd6d621c6e4533d390fe3221610", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -1055,7 +1055,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n         let check_inherited = |sp: Span, vis: ast::Visibility, note: &str| {\n             if vis != ast::Inherited {\n                 tcx.sess.span_err(sp, \"unnecessary visibility qualifier\");\n-                if note.len() > 0 {\n+                if !note.is_empty() {\n                     tcx.sess.span_note(sp, note);\n                 }\n             }"}, {"sha": "0058b31088b92b220a84d079fcd38a198ba0cc85", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -3072,7 +3072,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n-        if values.len() > 0 &&\n+        if !values.is_empty() &&\n             values[smallest] != usize::MAX &&\n             values[smallest] < name.len() + 2 &&\n             values[smallest] <= max_distance &&\n@@ -3228,7 +3228,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         format!(\"to call `{}::{}`\", path_str, path_name)\n                                 };\n \n-                                if msg.len() > 0 {\n+                                if !msg.is_empty() {\n                                     msg = format!(\". Did you mean {}?\", msg)\n                                 }\n "}, {"sha": "b53be98a06cc30198f16c20db0234319c5fde7af", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -269,7 +269,7 @@ pub fn sanitize(s: &str) -> String {\n     }\n \n     // Underscore-qualify anything that didn't start as an ident.\n-    if result.len() > 0 &&\n+    if !result.is_empty() &&\n         result.as_bytes()[0] != '_' as u8 &&\n         ! (result.as_bytes()[0] as char).is_xid_start() {\n         return format!(\"_{}\", &result[..]);"}, {"sha": "57dba30723f9cfeada05c0827494de10bf7160f7", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -1119,7 +1119,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                         let glob_map = glob_map.as_ref().unwrap();\n                         if glob_map.contains_key(&item.id) {\n                             for n in glob_map.get(&item.id).unwrap() {\n-                                if name_string.len() > 0 {\n+                                if !name_string.is_empty() {\n                                     name_string.push_str(\", \");\n                                 }\n                                 name_string.push_str(n.as_str());"}, {"sha": "744ec5a616841eae4706f156b00f2ba5514725d6", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -1112,7 +1112,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let mut kind = NoBranch;\n     let mut test_val = val;\n     debug!(\"test_val={}\", bcx.val_to_string(test_val));\n-    if opts.len() > 0 {\n+    if !opts.is_empty() {\n         match opts[0] {\n             ConstantValue(..) | ConstantRange(..) => {\n                 test_val = load_if_immediate(bcx, val, left_ty);"}, {"sha": "93eb24a47de679c38744079d1e0528e723b3384c", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -2392,7 +2392,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     ccx.sess().bug(\"struct variant kind unexpected in get_item_val\")\n                 }\n             };\n-            assert!(args.len() != 0);\n+            assert!(!args.is_empty());\n             let ty = ty::node_id_to_type(ccx.tcx(), id);\n             let parent = ccx.tcx().map.get_parent(id);\n             let enm = ccx.tcx().map.expect_item(parent);"}, {"sha": "0e8c33cd93a5b36e36aa126413960af23eb55aec", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -184,7 +184,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                                                     bcx.fcx.param_substs);\n \n                 // Nullary variants are not callable\n-                assert!(vinfo.args.len() > 0);\n+                assert!(!vinfo.args.is_empty());\n \n                 Callee {\n                     bcx: bcx,\n@@ -495,7 +495,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n \n         match map_node {\n             ast_map::NodeVariant(v) => match v.node.kind {\n-                ast::TupleVariantKind(ref args) => args.len() > 0,\n+                ast::TupleVariantKind(ref args) => !args.is_empty(),\n                 _ => false\n             },\n             ast_map::NodeStructCtor(_) => true,"}, {"sha": "38136b03a214191122270774087afcbf2394333c", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -781,7 +781,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                          enum_did,\n                                                          variant_did);\n-                    if vinfo.args.len() > 0 {\n+                    if !vinfo.args.is_empty() {\n                         // N-ary variant.\n                         expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n                     } else {"}, {"sha": "159b101e85e5ff28e34d9d6219ceb1dbf13704ec", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -532,7 +532,7 @@ impl<'tcx> TypeMap<'tcx> {\n             // Maybe check that there is no self type here.\n \n             let tps = substs.types.get_slice(subst::TypeSpace);\n-            if tps.len() > 0 {\n+            if !tps.is_empty() {\n                 output.push('<');\n \n                 for &type_parameter in tps {\n@@ -1102,7 +1102,7 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         if let Ok(code_snippet) = code_snippet {\n             let bytes = code_snippet.as_bytes();\n \n-            if bytes.len() > 0 && &bytes[bytes.len()-1..] == b\"}\" {\n+            if !bytes.is_empty() && &bytes[bytes.len()-1..] == b\"}\" {\n                 cleanup_span = Span {\n                     lo: node_span.hi - codemap::BytePos(1),\n                     hi: node_span.hi,\n@@ -3834,7 +3834,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             output.push_str(\"fn(\");\n \n             let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n-            if sig.inputs.len() > 0 {\n+            if !sig.inputs.is_empty() {\n                 for &parameter_type in &sig.inputs {\n                     push_debuginfo_type_name(cx, parameter_type, true, output);\n                     output.push_str(\", \");\n@@ -3844,7 +3844,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n \n             if sig.variadic {\n-                if sig.inputs.len() > 0 {\n+                if !sig.inputs.is_empty() {\n                     output.push_str(\", ...\");\n                 } else {\n                     output.push_str(\"...\");"}, {"sha": "b91f50222a27f4d4ea5627faca110b0a47407c49", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -1135,7 +1135,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     match def {\n         def::DefVariant(tid, vid, _) => {\n             let variant_info = ty::enum_variant_with_id(bcx.tcx(), tid, vid);\n-            if variant_info.args.len() > 0 {\n+            if !variant_info.args.is_empty() {\n                 // N-ary variant.\n                 let llfn = callee::trans_fn_ref(bcx.ccx(), vid,\n                                                 ExprId(ref_expr.id),"}, {"sha": "e37e9c970185c5e0dcdd3344f9dec25b076b6060", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -2025,7 +2025,7 @@ fn compute_object_lifetime_bound<'tcx>(\n             \"only a single explicit lifetime bound is permitted\");\n     }\n \n-    if explicit_region_bounds.len() != 0 {\n+    if !explicit_region_bounds.is_empty() {\n         // Explicitly specified region bound. Use that.\n         let r = explicit_region_bounds[0];\n         return ast_region_to_region(tcx, r);\n@@ -2130,11 +2130,11 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n                                                      &mut builtin_bounds) {\n                             let segments = &b.trait_ref.path.segments;\n                             let parameters = &segments[segments.len() - 1].parameters;\n-                            if parameters.types().len() > 0 {\n+                            if !parameters.types().is_empty() {\n                                 check_type_argument_count(tcx, b.trait_ref.path.span,\n                                                           parameters.types().len(), 0, 0);\n                             }\n-                            if parameters.lifetimes().len() > 0 {\n+                            if !parameters.lifetimes().is_empty() {\n                                 report_lifetime_number_error(tcx, b.trait_ref.path.span,\n                                                              parameters.lifetimes().len(), 0);\n                             }"}, {"sha": "a4175fe8325b2c1d703372cc3938826aa1febdab", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -67,7 +67,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 }\n             }\n \n-            if static_sources.len() > 0 {\n+            if !static_sources.is_empty() {\n                 fcx.tcx().sess.fileline_note(\n                     span,\n                     \"found defined static methods, maybe a `self` is missing?\");\n@@ -200,7 +200,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         })\n         .collect::<Vec<_>>();\n \n-    if candidates.len() > 0 {\n+    if !candidates.is_empty() {\n         // sort from most relevant to least relevant\n         candidates.sort_by(|a, b| a.cmp(b).reverse());\n         candidates.dedup();"}, {"sha": "2830090e09871f8dc5ecf33072b04f03811bdcaf", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -4258,7 +4258,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     //\n     // The first step then is to categorize the segments appropriately.\n \n-    assert!(segments.len() >= 1);\n+    assert!(!segments.is_empty());\n \n     let mut ufcs_method = None;\n     let mut segment_spaces: Vec<_>;\n@@ -4480,7 +4480,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n         }\n \n-        if data.bindings.len() > 0 {\n+        if !data.bindings.is_empty() {\n             span_err!(fcx.tcx().sess, data.bindings[0].span, E0182,\n                       \"unexpected binding of associated item in expression path \\\n                        (only allowed in type paths)\");"}, {"sha": "7f2af1d1b6262b63152c37d0dfc997b9f20251e0", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -174,7 +174,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 }\n \n                 // For DST, all intermediate types must be sized.\n-                if variant.fields.len() > 0 {\n+                if !variant.fields.is_empty() {\n                     for field in variant.fields.init() {\n                         fcx.register_builtin_bound(\n                             field.ty,\n@@ -658,7 +658,7 @@ fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     enum_def.variants.iter()\n         .map(|variant| {\n             match variant.node.kind {\n-                ast::TupleVariantKind(ref args) if args.len() > 0 => {\n+                ast::TupleVariantKind(ref args) if !args.is_empty() => {\n                     let ctor_ty = ty::node_id_to_type(fcx.tcx(), variant.node.id);\n \n                     // the regions in the argument types come from the"}, {"sha": "e5022b98918f7d0d5b6f5cce06005f124cf46939", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -576,7 +576,7 @@ fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         // Nullary enum constructors get turned into constants; n-ary enum\n         // constructors get turned into functions.\n         let result_ty = match variant.node.kind {\n-            ast::TupleVariantKind(ref args) if args.len() > 0 => {\n+            ast::TupleVariantKind(ref args) if !args.is_empty() => {\n                 let rs = ExplicitRscope;\n                 let input_tys: Vec<_> = args.iter().map(|va| icx.to_ty(&rs, &*va.ty)).collect();\n                 ty::mk_ctor_fn(tcx, variant_def_id, &input_tys, enum_scheme.ty)"}, {"sha": "72702dc8d9472f31937721939b3c0af3c5ab638d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -712,7 +712,7 @@ impl<'tcx> Clean<Option<Vec<TyParamBound>>> for subst::Substs<'tcx> {\n             trait_: t.clean(cx),\n             lifetimes: vec![]\n         }, ast::TraitBoundModifier::None)));\n-        if v.len() > 0 {Some(v)} else {None}\n+        if !v.is_empty() {Some(v)} else {None}\n     }\n }\n "}, {"sha": "d2dccca362ef81fa80f32024636a48c101846dad", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -104,8 +104,8 @@ impl fmt::Display for clean::Generics {\n             try!(write!(f, \"{}\", *life));\n         }\n \n-        if self.type_params.len() > 0 {\n-            if self.lifetimes.len() > 0 {\n+        if !self.type_params.is_empty() {\n+            if !self.lifetimes.is_empty() {\n                 try!(f.write_str(\", \"));\n             }\n             for (i, tp) in self.type_params.iter().enumerate() {\n@@ -114,7 +114,7 @@ impl fmt::Display for clean::Generics {\n                 }\n                 try!(f.write_str(&tp.name));\n \n-                if tp.bounds.len() > 0 {\n+                if !tp.bounds.is_empty() {\n                     try!(write!(f, \": {}\", TyParamBounds(&tp.bounds)));\n                 }\n \n@@ -175,7 +175,7 @@ impl fmt::Display for clean::Lifetime {\n \n impl fmt::Display for clean::PolyTrait {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if self.lifetimes.len() > 0 {\n+        if !self.lifetimes.is_empty() {\n             try!(f.write_str(\"for&lt;\"));\n             for (i, lt) in self.lifetimes.iter().enumerate() {\n                 if i > 0 {\n@@ -212,7 +212,7 @@ impl fmt::Display for clean::PathParameters {\n             clean::PathParameters::AngleBracketed {\n                 ref lifetimes, ref types, ref bindings\n             } => {\n-                if lifetimes.len() > 0 || types.len() > 0 || bindings.len() > 0 {\n+                if !lifetimes.is_empty() || !types.is_empty() || !bindings.is_empty() {\n                     try!(f.write_str(\"&lt;\"));\n                     let mut comma = false;\n                     for lifetime in lifetimes {\n@@ -541,7 +541,7 @@ impl fmt::Display for clean::Arguments {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for (i, input) in self.values.iter().enumerate() {\n             if i > 0 { try!(write!(f, \", \")); }\n-            if input.name.len() > 0 {\n+            if !input.name.is_empty() {\n                 try!(write!(f, \"{}: \", input.name));\n             }\n             try!(write!(f, \"{}\", input.type_));\n@@ -585,8 +585,8 @@ impl<'a> fmt::Display for Method<'a> {\n             }\n         }\n         for (i, input) in d.inputs.values.iter().enumerate() {\n-            if i > 0 || args.len() > 0 { args.push_str(\", \"); }\n-            if input.name.len() > 0 {\n+            if i > 0 || !args.is_empty() { args.push_str(\", \"); }\n+            if !input.name.is_empty() {\n                 args.push_str(&format!(\"{}: \", input.name));\n             }\n             args.push_str(&format!(\"{}\", input.type_));\n@@ -734,7 +734,7 @@ impl<'a> fmt::Display for ConciseStability<'a> {\n                 };\n                 write!(f, \"<a class='stability {lvl}' title='{lvl}{colon}{reason}'></a>\",\n                        lvl = Escape(&*lvl),\n-                       colon = if stability.reason.len() > 0 { \": \" } else { \"\" },\n+                       colon = if !stability.reason.is_empty() { \": \" } else { \"\" },\n                        reason = Escape(&*stability.reason))\n             }\n             None => {"}, {"sha": "5f4a3e74b6589bb54a2abeeb7794b2faffd6491d", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -973,7 +973,7 @@ impl DocFolder for Cache {\n         // Keep track of the fully qualified path for this item.\n         let pushed = if item.name.is_some() {\n             let n = item.name.as_ref().unwrap();\n-            if n.len() > 0 {\n+            if !n.is_empty() {\n                 self.stack.push(n.to_string());\n                 true\n             } else { false }\n@@ -1208,7 +1208,7 @@ impl Context {\n \n             let mut title = cx.current.connect(\"::\");\n             if pushname {\n-                if title.len() > 0 {\n+                if !title.is_empty() {\n                     title.push_str(\"::\");\n                 }\n                 title.push_str(it.name.as_ref().unwrap());\n@@ -1736,8 +1736,8 @@ fn item_function(w: &mut fmt::Formatter, it: &clean::Item,\n fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n               t: &clean::Trait) -> fmt::Result {\n     let mut bounds = String::new();\n-    if t.bounds.len() > 0 {\n-        if bounds.len() > 0 {\n+    if !t.bounds.is_empty() {\n+        if !bounds.is_empty() {\n             bounds.push(' ');\n         }\n         bounds.push_str(\": \");\n@@ -1775,15 +1775,15 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             try!(render_method(w, t, MethodLink::Anchor));\n             try!(write!(w, \";\\n\"));\n         }\n-        if types.len() > 0 && required.len() > 0 {\n+        if !types.is_empty() && !required.is_empty() {\n             try!(w.write_str(\"\\n\"));\n         }\n         for m in &required {\n             try!(write!(w, \"    \"));\n             try!(render_method(w, m, MethodLink::Anchor));\n             try!(write!(w, \";\\n\"));\n         }\n-        if required.len() > 0 && provided.len() > 0 {\n+        if !required.is_empty() && !provided.is_empty() {\n             try!(w.write_str(\"\\n\"));\n         }\n         for m in &provided {\n@@ -1810,7 +1810,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         Ok(())\n     }\n \n-    if types.len() > 0 {\n+    if !types.is_empty() {\n         try!(write!(w, \"\n             <h2 id='associated-types'>Associated Types</h2>\n             <div class='methods'>\n@@ -1822,7 +1822,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     }\n \n     // Output the documentation for each function individually\n-    if required.len() > 0 {\n+    if !required.is_empty() {\n         try!(write!(w, \"\n             <h2 id='required-methods'>Required Methods</h2>\n             <div class='methods'>\n@@ -1832,7 +1832,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         }\n         try!(write!(w, \"</div>\"));\n     }\n-    if provided.len() > 0 {\n+    if !provided.is_empty() {\n         try!(write!(w, \"\n             <h2 id='provided-methods'>Provided Methods</h2>\n             <div class='methods'>\n@@ -1882,7 +1882,7 @@ fn assoc_type(w: &mut fmt::Formatter, it: &clean::Item,\n               default: &Option<clean::Type>)\n               -> fmt::Result {\n     try!(write!(w, \"type {}\", it.name.as_ref().unwrap()));\n-    if bounds.len() > 0 {\n+    if !bounds.is_empty() {\n         try!(write!(w, \": {}\", TyParamBounds(bounds)))\n     }\n     if let Some(ref default) = *default {\n@@ -2031,7 +2031,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n     try!(write!(w, \"</pre>\"));\n \n     try!(document(w, it));\n-    if e.variants.len() > 0 {\n+    if !e.variants.is_empty() {\n         try!(write!(w, \"<h2 class='variants'>Variants</h2>\\n<table>\"));\n         for variant in &e.variants {\n             try!(write!(w, \"<tr><td id='variant.{name}'>{stab}<code>{name}</code></td><td>\",\n@@ -2170,13 +2170,13 @@ fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n     };\n     let (non_trait, traits): (Vec<_>, _) = v.into_iter()\n         .partition(|i| i.impl_.trait_.is_none());\n-    if non_trait.len() > 0 {\n+    if !non_trait.is_empty() {\n         try!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n         for i in &non_trait {\n             try!(render_impl(w, i, MethodLink::Anchor));\n         }\n     }\n-    if traits.len() > 0 {\n+    if !traits.is_empty() {\n         try!(write!(w, \"<h2 id='implementations'>Trait \\\n                           Implementations</h2>\"));\n         let (derived, manual): (Vec<_>, _) = traits.into_iter()\n@@ -2185,7 +2185,7 @@ fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n             let did = i.trait_did().unwrap();\n             try!(render_impl(w, i, MethodLink::GotoSource(did)));\n         }\n-        if derived.len() > 0 {\n+        if !derived.is_empty() {\n             try!(write!(w, \"<h3 id='derived_implementations'>\\\n                 Derived Implementations \\\n             </h3>\"));"}, {"sha": "53cfbb3efdda528aa39ca1a45b390ba0e7724542", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -294,7 +294,7 @@ pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n                 &clean::NameValue(ref x, _) if \"doc\" == *x => false,\n                 _ => true\n             }).cloned().collect();\n-            if docstr.len() > 0 {\n+            if !docstr.is_empty() {\n                 a.push(clean::NameValue(\"doc\".to_string(), docstr));\n             }\n             i.attrs = a;\n@@ -350,7 +350,7 @@ pub fn unindent(s: &str) -> String {\n         }\n     });\n \n-    if lines.len() >= 1 {\n+    if !lines.is_empty() {\n         let mut unindented = vec![ lines[0].trim().to_string() ];\n         unindented.push_all(&lines.tail().iter().map(|&line| {\n             if line.chars().all(|c| c.is_whitespace()) {"}, {"sha": "e674ddf41dc1790b2f6c9003de4121a22c2f853e", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -349,7 +349,7 @@ pub trait Write {\n     /// This function will return the first error that `write` returns.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write_all(&mut self, mut buf: &[u8]) -> Result<()> {\n-        while buf.len() > 0 {\n+        while !buf.is_empty() {\n             match self.write(buf) {\n                 Ok(0) => return Err(Error::new(ErrorKind::WriteZero,\n                                                \"failed to write whole buffer\")),"}, {"sha": "cb78fc56bf20c2b7ac5425fc5ddae341fd78a101", "filename": "src/libstd/path.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -218,7 +218,7 @@ mod platform {\n                     return Some(DeviceNS(u8_slice_as_os_str(slice)));\n                 }\n                 match parse_two_comps(path, is_sep_byte) {\n-                    Some((server, share)) if server.len() > 0 && share.len() > 0 => {\n+                    Some((server, share)) if !server.is_empty() && !share.is_empty() => {\n                         // \\\\server\\share\n                         return Some(UNC(u8_slice_as_os_str(server),\n                                         u8_slice_as_os_str(share)));\n@@ -401,7 +401,7 @@ unsafe fn u8_slice_as_os_str(s: &[u8]) -> &OsStr {\n /// Says whether the first byte after the prefix is a separator.\n fn has_physical_root(s: &[u8], prefix: Option<Prefix>) -> bool {\n     let path = if let Some(p) = prefix { &s[p.len()..] } else { s };\n-    path.len() > 0 && is_sep_byte(path[0])\n+    !path.is_empty() && is_sep_byte(path[0])\n }\n \n // basic workhorse for splitting stem and extension\n@@ -810,15 +810,15 @@ impl<'a> Iterator for Components<'a> {\n                 State::StartDir => {\n                     self.front = State::Body;\n                     if self.has_physical_root {\n-                        debug_assert!(self.path.len() > 0);\n+                        debug_assert!(!self.path.is_empty());\n                         self.path = &self.path[1..];\n                         return Some(Component::RootDir)\n                     } else if let Some(p) = self.prefix {\n                         if p.has_implicit_root() && !p.is_verbatim() {\n                             return Some(Component::RootDir)\n                         }\n                     } else if self.include_cur_dir() {\n-                        debug_assert!(self.path.len() > 0);\n+                        debug_assert!(!self.path.is_empty());\n                         self.path = &self.path[1..];\n                         return Some(Component::CurDir)\n                     }\n@@ -1055,7 +1055,7 @@ impl PathBuf {\n         };\n \n         let extension = extension.as_ref();\n-        if os_str_as_u8_slice(extension).len() > 0 {\n+        if !os_str_as_u8_slice(extension).is_empty() {\n             stem.push(\".\");\n             stem.push(extension);\n         }"}, {"sha": "f8dd6a00c7f1d9c21577cbbc7e2804d38c9242f8", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -51,7 +51,7 @@ impl<R: Read> Rng for ReaderRng<R> {\n         unsafe { *(bytes.as_ptr() as *const u64) }\n     }\n     fn fill_bytes(&mut self, mut v: &mut [u8]) {\n-        while v.len() > 0 {\n+        while !v.is_empty() {\n             let t = v;\n             match self.reader.read(t) {\n                 Ok(0) => panic!(\"ReaderRng.fill_bytes: EOF reached\"),"}, {"sha": "580d970af0c3da3d77a1a484da9c7497ea085e93", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -76,7 +76,7 @@ pub fn demangle(writer: &mut Write, s: &str) -> io::Result<()> {\n         try!(writer.write_all(s.as_bytes()));\n     } else {\n         let mut first = true;\n-        while inner.len() > 0 {\n+        while !inner.is_empty() {\n             if !first {\n                 try!(writer.write_all(b\"::\"));\n             } else {\n@@ -89,7 +89,7 @@ pub fn demangle(writer: &mut Write, s: &str) -> io::Result<()> {\n             let i: usize = inner[.. (inner.len() - rest.len())].parse().unwrap();\n             inner = &rest[i..];\n             rest = &rest[..i];\n-            while rest.len() > 0 {\n+            while !rest.is_empty() {\n                 if rest.starts_with(\"$\") {\n                     macro_rules! demangle {\n                         ($($pat:expr, => $demangled:expr),*) => ({"}, {"sha": "26463df1871225f08e193d3ed15c3cf925a9e620", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -429,14 +429,14 @@ pub struct Generics {\n }\n \n impl Generics {\n-    pub fn is_parameterized(&self) -> bool {\n-        self.lifetimes.len() + self.ty_params.len() > 0\n-    }\n     pub fn is_lt_parameterized(&self) -> bool {\n-        self.lifetimes.len() > 0\n+        !self.lifetimes.is_empty()\n     }\n     pub fn is_type_parameterized(&self) -> bool {\n-        self.ty_params.len() > 0\n+        !self.ty_params.is_empty()\n+    }\n+    pub fn is_parameterized(&self) -> bool {\n+        self.is_lt_parameterized() || self.is_type_parameterized()\n     }\n }\n "}, {"sha": "a0bde8f6c525e9dfadedaff51974a3ebd2f6091c", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -360,7 +360,7 @@ impl Encodable for FileMap {\n                     // store the length\n                     try! { s.emit_u32(lines.len() as u32) };\n \n-                    if lines.len() > 0 {\n+                    if !lines.is_empty() {\n                         // In order to preserve some space, we exploit the fact that\n                         // the lines list is sorted and individual lines are\n                         // probably not that long. Because of that we can store lines\n@@ -569,7 +569,7 @@ impl CodeMap {\n         // accidentally overflowing into the next filemap in case the last byte\n         // of span is also the last byte of filemap, which leads to incorrect\n         // results from CodeMap.span_to_*.\n-        if src.len() > 0 && !src.ends_with(\"\\n\") {\n+        if !src.is_empty() && !src.ends_with(\"\\n\") {\n             src.push('\\n');\n         }\n \n@@ -808,7 +808,7 @@ impl CodeMap {\n         loop {\n             let lines = files[a].lines.borrow();\n             let lines = lines;\n-            if lines.len() > 0 {\n+            if !lines.is_empty() {\n                 break;\n             }\n             if a == 0 {"}, {"sha": "6915969032810cf3830234f50b99c6aafadb157f", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -90,7 +90,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                       p.token != token::Colon &&\n                       p.token != token::ModSep {\n \n-                    if outputs.len() != 0 {\n+                    if !outputs.is_empty() {\n                         panictry!(p.eat(&token::Comma));\n                     }\n \n@@ -130,7 +130,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                       p.token != token::Colon &&\n                       p.token != token::ModSep {\n \n-                    if inputs.len() != 0 {\n+                    if !inputs.is_empty() {\n                         panictry!(p.eat(&token::Comma));\n                     }\n \n@@ -154,7 +154,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                       p.token != token::Colon &&\n                       p.token != token::ModSep {\n \n-                    if clobs.len() != 0 {\n+                    if !clobs.is_empty() {\n                         panictry!(p.eat(&token::Comma));\n                     }\n "}, {"sha": "9e36c75dda4289c2b4f410dd9eae91aaa74bfc1f", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -774,7 +774,7 @@ pub fn check_zero_tts(cx: &ExtCtxt,\n                       sp: Span,\n                       tts: &[ast::TokenTree],\n                       name: &str) {\n-    if tts.len() != 0 {\n+    if !tts.is_empty() {\n         cx.span_err(sp, &format!(\"{} takes no arguments\", name));\n     }\n }"}, {"sha": "95eb68ca0d37dc34dde66c2e9cf199a41365492a", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -89,7 +89,7 @@ fn cs_clone(\n         }\n     }\n \n-    if all_fields.len() >= 1 && all_fields[0].name.is_none() {\n+    if !all_fields.is_empty() && all_fields[0].name.is_none() {\n         // enum-like\n         let subcalls = all_fields.iter().map(subcall).collect();\n         let path = cx.expr_path(ctor_path);"}, {"sha": "6425e6a28ece00f03c03184302a59962925caad8", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -240,7 +240,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             let encoder = cx.expr_ident(trait_span, blkarg);\n             let emit_variant_arg = cx.ident_of(\"emit_enum_variant_arg\");\n             let mut stmts = Vec::new();\n-            if fields.len() > 0 {\n+            if !fields.is_empty() {\n                 let last = fields.len() - 1;\n                 for (i, &FieldInfo { ref self_, span, .. }) in fields.iter().enumerate() {\n                     let enc = cx.expr_method_call(span, self_.clone(),"}, {"sha": "7f6f29df530a73ae340f041a506f6fb83a725aa0", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -912,7 +912,7 @@ impl<'a> MethodDef<'a> {\n         }\n \n         // transpose raw_fields\n-        let fields = if raw_fields.len() > 0 {\n+        let fields = if !raw_fields.is_empty() {\n             let mut raw_fields = raw_fields.into_iter().map(|v| v.into_iter());\n             let first_field = raw_fields.next().unwrap();\n             let mut other_fields: Vec<vec::IntoIter<(Span, Option<Ident>, P<Expr>)>>"}, {"sha": "4fe5ab1554500877aa1e2f99e00b62d93d65ebab", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -688,7 +688,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n     loop {\n         match parser.next() {\n             Some(piece) => {\n-                if parser.errors.len() > 0 { break }\n+                if !parser.errors.is_empty() { break }\n                 cx.verify_piece(&piece);\n                 match cx.trans_piece(&piece) {\n                     Some(piece) => {"}, {"sha": "ce83b84efee805ac9d129d921a54b0e4296bbe3f", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -266,7 +266,7 @@ pub fn outer_mark(ctxt: SyntaxContext) -> Mrk {\n /// Push a name... unless it matches the one on top, in which\n /// case pop and discard (so two of the same marks cancel)\n fn xor_push(marks: &mut Vec<Mrk>, mark: Mrk) {\n-    if (marks.len() > 0) && (*marks.last().unwrap() == mark) {\n+    if (!marks.is_empty()) && (*marks.last().unwrap() == mark) {\n         marks.pop().unwrap();\n     } else {\n         marks.push(mark);"}, {"sha": "9c3a556b210f9edb84f0910a90413bd697bca545", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -457,7 +457,7 @@ pub fn parse(sess: &ParseSess,\n                 return Failure(sp, \"unexpected end of macro invocation\".to_string());\n             }\n         } else {\n-            if (bb_eis.len() > 0 && next_eis.len() > 0)\n+            if (!bb_eis.is_empty() && !next_eis.is_empty())\n                 || bb_eis.len() > 1 {\n                 let nts = bb_eis.iter().map(|ei| {\n                     match ei.top_elts.get_tt(ei.idx) {\n@@ -475,9 +475,9 @@ pub fn parse(sess: &ParseSess,\n             } else if bb_eis.is_empty() && next_eis.is_empty() {\n                 return Failure(sp, format!(\"no rules expected the token `{}`\",\n                             pprust::token_to_string(&tok)).to_string());\n-            } else if next_eis.len() > 0 {\n+            } else if !next_eis.is_empty() {\n                 /* Now process the next token */\n-                while next_eis.len() > 0 {\n+                while !next_eis.is_empty() {\n                     cur_eis.push(next_eis.pop().unwrap());\n                 }\n                 rdr.next_token();\n@@ -504,7 +504,7 @@ pub fn parse(sess: &ParseSess,\n             }\n         }\n \n-        assert!(cur_eis.len() > 0);\n+        assert!(!cur_eis.is_empty());\n     }\n }\n "}, {"sha": "bda01d5a6541c72822ea517c21ad2e3858376f2d", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -63,7 +63,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n         let mut i = 0;\n         let mut j = lines.len();\n         // first line of all-stars should be omitted\n-        if lines.len() > 0 &&\n+        if !lines.is_empty() &&\n                 lines[0].chars().all(|c| c == '*') {\n             i += 1;\n         }\n@@ -294,7 +294,7 @@ fn read_block_comment(rdr: &mut StringReader,\n                 }\n             }\n         }\n-        if curr_line.len() != 0 {\n+        if !curr_line.is_empty() {\n             trim_whitespace_prefix_and_push_line(&mut lines,\n                                                  curr_line,\n                                                  col);"}, {"sha": "071e5a69240120365a9aa4fc0f2933a79c56237e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -2254,7 +2254,7 @@ impl<'a> Parser<'a> {\n                         (Vec::new(), Vec::new(), Vec::new())\n                     };\n \n-                    if bindings.len() > 0 {\n+                    if !bindings.is_empty() {\n                         let last_span = self.last_span;\n                         self.span_err(last_span, \"type bindings are only permitted on trait paths\");\n                     }\n@@ -3024,7 +3024,7 @@ impl<'a> Parser<'a> {\n                 try!(self.expect(&token::Comma));\n \n                 if self.token == token::CloseDelim(token::Bracket)\n-                        && (before_slice || after.len() != 0) {\n+                        && (before_slice || !after.is_empty()) {\n                     break\n                 }\n             }"}, {"sha": "3fd4e31b4771ee8aac8ea64fa38453e8cf52ca7c", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -565,7 +565,7 @@ impl<'a> Printer<'a> {\n           Token::End => {\n             debug!(\"print End -> pop End\");\n             let print_stack = &mut self.print_stack;\n-            assert!((print_stack.len() != 0));\n+            assert!((!print_stack.is_empty()));\n             print_stack.pop().unwrap();\n             Ok(())\n           }"}, {"sha": "c51b5d039784d4009ff091d183485fdd0e0906c7", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -1656,7 +1656,7 @@ impl<'a> State<'a> {\n         try!(self.print_expr(&*args[0]));\n         try!(word(&mut self.s, \".\"));\n         try!(self.print_ident(ident.node));\n-        if tys.len() > 0 {\n+        if !tys.is_empty() {\n             try!(word(&mut self.s, \"::<\"));\n             try!(self.commasep(Inconsistent, tys,\n                                |s, ty| s.print_type(&**ty)));\n@@ -1956,7 +1956,7 @@ impl<'a> State<'a> {\n                     options.push(\"intel\");\n                 }\n \n-                if options.len() > 0 {\n+                if !options.is_empty() {\n                     try!(space(&mut self.s));\n                     try!(self.word_space(\":\"));\n                     try!(self.commasep(Inconsistent, &*options,\n@@ -2214,7 +2214,7 @@ impl<'a> State<'a> {\n                     },\n                     |f| f.node.pat.span));\n                 if etc {\n-                    if fields.len() != 0 { try!(self.word_space(\",\")); }\n+                    if !fields.is_empty() { try!(self.word_space(\",\")); }\n                     try!(word(&mut self.s, \"..\"));\n                 }\n                 try!(space(&mut self.s));\n@@ -2727,7 +2727,7 @@ impl<'a> State<'a> {\n                        opt_explicit_self: Option<&ast::ExplicitSelf_>)\n                        -> io::Result<()> {\n         try!(self.ibox(indent_unit));\n-        if generics.lifetimes.len() > 0 || generics.ty_params.len() > 0 {\n+        if !generics.lifetimes.is_empty() || !generics.ty_params.is_empty() {\n             try!(word(&mut self.s, \"for\"));\n             try!(self.print_generics(generics));\n         }"}, {"sha": "c9ad08bb8523485ae9eb9478dfe97fd71fd8a493", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -123,7 +123,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             Percent => {\n                 match cur {\n                     '%' => { output.push(c); state = Nothing },\n-                    'c' => if stack.len() > 0 {\n+                    'c' => if !stack.is_empty() {\n                         match stack.pop().unwrap() {\n                             // if c is 0, use 0200 (128) for ncurses compatibility\n                             Number(c) => {\n@@ -141,7 +141,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     'g' => state = GetVar,\n                     '\\'' => state = CharConstant,\n                     '{' => state = IntConstant(0),\n-                    'l' => if stack.len() > 0 {\n+                    'l' => if !stack.is_empty() {\n                         match stack.pop().unwrap() {\n                             Words(s) => stack.push(Number(s.len() as isize)),\n                             _        => return Err(\"a non-str was used with %l\".to_string())\n@@ -231,14 +231,14 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                             _ => return Err(\"non-numbers on stack with logical or\".to_string())\n                         }\n                     } else { return Err(\"stack is empty\".to_string()) },\n-                    '!' => if stack.len() > 0 {\n+                    '!' => if !stack.is_empty() {\n                         match stack.pop().unwrap() {\n                             Number(0) => stack.push(Number(1)),\n                             Number(_) => stack.push(Number(0)),\n                             _ => return Err(\"non-number on stack with logical not\".to_string())\n                         }\n                     } else { return Err(\"stack is empty\".to_string()) },\n-                    '~' => if stack.len() > 0 {\n+                    '~' => if !stack.is_empty() {\n                         match stack.pop().unwrap() {\n                             Number(x) => stack.push(Number(!x)),\n                             _         => return Err(\"non-number on stack with %~\".to_string())\n@@ -253,7 +253,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     },\n \n                     // printf-style support for %doxXs\n-                    'd'|'o'|'x'|'X'|'s' => if stack.len() > 0 {\n+                    'd'|'o'|'x'|'X'|'s' => if !stack.is_empty() {\n                         let flags = Flags::new();\n                         let res = format(stack.pop().unwrap(), FormatOp::from_char(cur), flags);\n                         if res.is_err() { return res }\n@@ -278,7 +278,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n \n                     // conditionals\n                     '?' => (),\n-                    't' => if stack.len() > 0 {\n+                    't' => if !stack.is_empty() {\n                         match stack.pop().unwrap() {\n                             Number(0) => state = SeekIfElse(0),\n                             Number(_) => (),\n@@ -303,12 +303,12 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             },\n             SetVar => {\n                 if cur >= 'A' && cur <= 'Z' {\n-                    if stack.len() > 0 {\n+                    if !stack.is_empty() {\n                         let idx = (cur as u8) - b'A';\n                         vars.sta[idx as usize] = stack.pop().unwrap();\n                     } else { return Err(\"stack is empty\".to_string()) }\n                 } else if cur >= 'a' && cur <= 'z' {\n-                    if stack.len() > 0 {\n+                    if !stack.is_empty() {\n                         let idx = (cur as u8) - b'a';\n                         vars.dyn[idx as usize] = stack.pop().unwrap();\n                     } else { return Err(\"stack is empty\".to_string()) }\n@@ -352,7 +352,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             FormatPattern(ref mut flags, ref mut fstate) => {\n                 old_state = Nothing;\n                 match (*fstate, cur) {\n-                    (_,'d')|(_,'o')|(_,'x')|(_,'X')|(_,'s') => if stack.len() > 0 {\n+                    (_,'d')|(_,'o')|(_,'x')|(_,'X')|(_,'s') => if !stack.is_empty() {\n                         let res = format(stack.pop().unwrap(), FormatOp::from_char(cur), *flags);\n                         if res.is_err() { return res }\n                         output.push_all(&res.unwrap());"}, {"sha": "a9624840f676d21918cad381b935f5bd457648ce", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -373,7 +373,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n \n     if matches.opt_present(\"h\") { usage(&args[0]); return None; }\n \n-    let filter = if matches.free.len() > 0 {\n+    let filter = if !matches.free.is_empty() {\n         Some(matches.free[0].clone())\n     } else {\n         None\n@@ -588,14 +588,14 @@ impl<T: Write> ConsoleTestState<T> {\n         let mut fail_out = String::new();\n         for &(ref f, ref stdout) in &self.failures {\n             failures.push(f.name.to_string());\n-            if stdout.len() > 0 {\n+            if !stdout.is_empty() {\n                 fail_out.push_str(&format!(\"---- {} stdout ----\\n\\t\", f.name));\n                 let output = String::from_utf8_lossy(stdout);\n                 fail_out.push_str(&output);\n                 fail_out.push_str(\"\\n\");\n             }\n         }\n-        if fail_out.len() > 0 {\n+        if !fail_out.is_empty() {\n             try!(self.write_plain(\"\\n\"));\n             try!(self.write_plain(&fail_out));\n         }"}, {"sha": "06e0de76eafd8df7cc69c3449b99b23f5635cf79", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -196,17 +196,17 @@ impl<T: Float + FromPrimitive> Stats<T> for [T] {\n     }\n \n     fn min(&self) -> T {\n-        assert!(self.len() != 0);\n+        assert!(!self.is_empty());\n         self.iter().fold(self[0], |p, q| p.min(*q))\n     }\n \n     fn max(&self) -> T {\n-        assert!(self.len() != 0);\n+        assert!(!self.is_empty());\n         self.iter().fold(self[0], |p, q| p.max(*q))\n     }\n \n     fn mean(&self) -> T {\n-        assert!(self.len() != 0);\n+        assert!(!self.is_empty());\n         self.sum() / FromPrimitive::from_usize(self.len()).unwrap()\n     }\n \n@@ -284,7 +284,7 @@ impl<T: Float + FromPrimitive> Stats<T> for [T] {\n // linear interpolation. If samples are not sorted, return nonsensical value.\n fn percentile_of_sorted<T: Float + FromPrimitive>(sorted_samples: &[T],\n                                                              pct: T) -> T {\n-    assert!(sorted_samples.len() != 0);\n+    assert!(!sorted_samples.is_empty());\n     if sorted_samples.len() == 1 {\n         return sorted_samples[0];\n     }"}, {"sha": "46caed6f9f5f59c482bf879de7af0abdf2427c47", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -43,7 +43,7 @@ fn maybe_run_test<F>(argv: &[String], name: String, test: F) where F: FnOnce() {\n \n     if env::var_os(\"RUST_BENCH\").is_some() {\n         run_test = true\n-    } else if argv.len() > 0 {\n+    } else if !argv.is_empty() {\n         run_test = argv.iter().any(|x| x == &\"all\".to_string()) || argv.iter().any(|x| x == &name)\n     }\n \n@@ -60,7 +60,7 @@ fn shift_push() {\n     let mut v1 = repeat(1).take(30000).collect::<Vec<_>>();\n     let mut v2 = Vec::new();\n \n-    while v1.len() > 0 {\n+    while !v1.is_empty() {\n         v2.push(v1.remove(0));\n     }\n }"}, {"sha": "c4af33da50c9462811ca99b143269b0454d5c877", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -252,7 +252,7 @@ fn generate_frequencies(mut input: &[u8], frame: usize) -> Table {\n     }\n     frequencies.lookup(code, BumpCallback);\n \n-    while input.len() != 0 && input[0] != ('>' as u8) {\n+    while !input.is_empty() && input[0] != ('>' as u8) {\n         code = code.rotate(input[0], frame);\n         frequencies.lookup(code, BumpCallback);\n         input = &input[1..];"}, {"sha": "c854747bcf7bd2343a79762ab8ea3c8874662747", "filename": "src/test/run-pass/issue-12860.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Ftest%2Frun-pass%2Fissue-12860.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Ftest%2Frun-pass%2Fissue-12860.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12860.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -30,7 +30,7 @@ fn main() {\n     let middle = XYZ{x: 0, y: 0, z: 0};\n     border.insert(middle);\n \n-    while border.len() > 0 && connected.len() < 10000 {\n+    while !border.is_empty() && connected.len() < 10000 {\n         let choice = *(border.iter().next().unwrap());\n         border.remove(&choice);\n         connected.insert(choice);"}, {"sha": "0efa85e232bae4f1b3a50d7fe78756218386fc37", "filename": "src/test/run-pass/issue-3556.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Ftest%2Frun-pass%2Fissue-3556.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f15e72e6c265eb43d34dba564d86dbf1c4fb99/src%2Ftest%2Frun-pass%2Fissue-3556.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3556.rs?ref=10f15e72e6c265eb43d34dba564d86dbf1c4fb99", "patch": "@@ -44,5 +44,5 @@ pub fn main()\n                     \"foo\".to_string(), \"foo\".to_string(), \"foo\".to_string(),\n                     \"foo\".to_string());\n     let v = format!(\"{:?}\", u);    // this is the line that causes the seg fault\n-    assert!(v.len() > 0);\n+    assert!(!v.is_empty());\n }"}]}