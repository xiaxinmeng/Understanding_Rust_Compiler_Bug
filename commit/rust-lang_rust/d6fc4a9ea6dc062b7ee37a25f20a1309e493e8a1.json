{"sha": "d6fc4a9ea6dc062b7ee37a25f20a1309e493e8a1", "node_id": "C_kwDOAAsO6NoAKGQ2ZmM0YTllYTZkYzA2MmI3ZWUzN2EyNWYyMGExMzA5ZTQ5M2U4YTE", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-09-01T12:13:08Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-09-01T12:41:37Z"}, "message": "Simplify breakables handling", "tree": {"sha": "79087673d8b95cfc65bb05741b961f0418a3afb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79087673d8b95cfc65bb05741b961f0418a3afb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6fc4a9ea6dc062b7ee37a25f20a1309e493e8a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6fc4a9ea6dc062b7ee37a25f20a1309e493e8a1", "html_url": "https://github.com/rust-lang/rust/commit/d6fc4a9ea6dc062b7ee37a25f20a1309e493e8a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6fc4a9ea6dc062b7ee37a25f20a1309e493e8a1/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "643c3a54de9da45f07ba9282c2ec7917d9ee7225", "url": "https://api.github.com/repos/rust-lang/rust/commits/643c3a54de9da45f07ba9282c2ec7917d9ee7225", "html_url": "https://github.com/rust-lang/rust/commit/643c3a54de9da45f07ba9282c2ec7917d9ee7225"}], "stats": {"total": 94, "additions": 48, "deletions": 46}, "files": [{"sha": "ba18d0c5ea6b689dbccc1edb46eb67a88bc64d48", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6fc4a9ea6dc062b7ee37a25f20a1309e493e8a1/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6fc4a9ea6dc062b7ee37a25f20a1309e493e8a1/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=d6fc4a9ea6dc062b7ee37a25f20a1309e493e8a1", "patch": "@@ -418,8 +418,11 @@ pub(crate) struct InferenceContext<'a> {\n \n #[derive(Clone, Debug)]\n struct BreakableContext {\n+    /// Whether this context contains at least one break expression.\n     may_break: bool,\n+    /// The coercion target of the context.\n     coerce: CoerceMany,\n+    /// The optional label of the context.\n     label: Option<name::Name>,\n }\n "}, {"sha": "a29e15ec5cba477975071e1191588a965bd35993", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 45, "deletions": 46, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/d6fc4a9ea6dc062b7ee37a25f20a1309e493e8a1/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6fc4a9ea6dc062b7ee37a25f20a1309e493e8a1/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=d6fc4a9ea6dc062b7ee37a25f20a1309e493e8a1", "patch": "@@ -10,7 +10,7 @@ use chalk_ir::{\n     cast::Cast, fold::Shift, DebruijnIndex, GenericArgData, Mutability, TyVariableKind,\n };\n use hir_def::{\n-    expr::{ArithOp, Array, BinaryOp, CmpOp, Expr, ExprId, Literal, Statement, UnaryOp},\n+    expr::{ArithOp, Array, BinaryOp, CmpOp, Expr, ExprId, LabelId, Literal, Statement, UnaryOp},\n     generics::TypeOrConstParamData,\n     path::{GenericArg, GenericArgs},\n     resolver::resolver_for_expr,\n@@ -120,20 +120,16 @@ impl<'a> InferenceContext<'a> {\n                 let ty = match label {\n                     Some(_) => {\n                         let break_ty = self.table.new_type_var();\n-                        self.breakables.push(BreakableContext {\n-                            may_break: false,\n-                            coerce: CoerceMany::new(break_ty.clone()),\n-                            label: label.map(|label| self.body[label].name.clone()),\n+                        let (ctx, ty) = self.with_breakable_ctx(break_ty.clone(), *label, |this| {\n+                            this.infer_block(\n+                                tgt_expr,\n+                                statements,\n+                                *tail,\n+                                &Expectation::has_type(break_ty),\n+                            )\n                         });\n-                        let ty = self.infer_block(\n-                            tgt_expr,\n-                            statements,\n-                            *tail,\n-                            &Expectation::has_type(break_ty),\n-                        );\n-                        let ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n-                        if ctxt.may_break {\n-                            ctxt.coerce.complete()\n+                        if ctx.may_break {\n+                            ctx.coerce.complete()\n                         } else {\n                             ty\n                         }\n@@ -166,54 +162,42 @@ impl<'a> InferenceContext<'a> {\n                 TyKind::OpaqueType(opaque_ty_id, Substitution::from1(Interner, inner_ty))\n                     .intern(Interner)\n             }\n-            Expr::Loop { body, label } => {\n-                self.breakables.push(BreakableContext {\n-                    may_break: false,\n-                    coerce: CoerceMany::new(self.table.new_type_var()),\n-                    label: label.map(|label| self.body[label].name.clone()),\n+            &Expr::Loop { body, label } => {\n+                let ty = self.table.new_type_var();\n+                let (ctx, ()) = self.with_breakable_ctx(ty, label, |this| {\n+                    this.infer_expr(body, &Expectation::has_type(TyBuilder::unit()));\n                 });\n-                self.infer_expr(*body, &Expectation::has_type(TyBuilder::unit()));\n \n-                let ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n-\n-                if ctxt.may_break {\n+                if ctx.may_break {\n                     self.diverges = Diverges::Maybe;\n-                    ctxt.coerce.complete()\n+                    ctx.coerce.complete()\n                 } else {\n                     TyKind::Never.intern(Interner)\n                 }\n             }\n-            Expr::While { condition, body, label } => {\n-                self.breakables.push(BreakableContext {\n-                    may_break: false,\n-                    coerce: CoerceMany::new(self.err_ty()),\n-                    label: label.map(|label| self.body[label].name.clone()),\n+            &Expr::While { condition, body, label } => {\n+                self.with_breakable_ctx(self.err_ty(), label, |this| {\n+                    this.infer_expr(\n+                        condition,\n+                        &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(Interner)),\n+                    );\n+                    this.infer_expr(body, &Expectation::has_type(TyBuilder::unit()));\n                 });\n-                self.infer_expr(\n-                    *condition,\n-                    &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(Interner)),\n-                );\n-                self.infer_expr(*body, &Expectation::has_type(TyBuilder::unit()));\n-                let _ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n+\n                 // the body may not run, so it diverging doesn't mean we diverge\n                 self.diverges = Diverges::Maybe;\n                 TyBuilder::unit()\n             }\n-            Expr::For { iterable, body, pat, label } => {\n-                let iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n-\n-                self.breakables.push(BreakableContext {\n-                    may_break: false,\n-                    coerce: CoerceMany::new(self.err_ty()),\n-                    label: label.map(|label| self.body[label].name.clone()),\n-                });\n+            &Expr::For { iterable, body, pat, label } => {\n+                let iterable_ty = self.infer_expr(iterable, &Expectation::none());\n                 let pat_ty =\n                     self.resolve_associated_type(iterable_ty, self.resolve_into_iter_item());\n \n-                self.infer_pat(*pat, &pat_ty, BindingMode::default());\n+                self.infer_pat(pat, &pat_ty, BindingMode::default());\n+                let (_ctx, ()) = self.with_breakable_ctx(self.err_ty(), label, |this| {\n+                    this.infer_expr(body, &Expectation::has_type(TyBuilder::unit()));\n+                });\n \n-                self.infer_expr(*body, &Expectation::has_type(TyBuilder::unit()));\n-                let _ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n                 // the body may not run, so it diverging doesn't mean we diverge\n                 self.diverges = Diverges::Maybe;\n                 TyBuilder::unit()\n@@ -1472,4 +1456,19 @@ impl<'a> InferenceContext<'a> {\n             },\n         })\n     }\n+\n+    fn with_breakable_ctx<T>(\n+        &mut self,\n+        ty: Ty,\n+        label: Option<LabelId>,\n+        cb: impl FnOnce(&mut Self) -> T,\n+    ) -> (BreakableContext, T) {\n+        self.breakables.push({\n+            let label = label.map(|label| self.body[label].name.clone());\n+            BreakableContext { may_break: false, coerce: CoerceMany::new(ty), label }\n+        });\n+        let res = cb(self);\n+        let ctx = self.breakables.pop().expect(\"breakable stack broken\");\n+        (ctx, res)\n+    }\n }"}]}