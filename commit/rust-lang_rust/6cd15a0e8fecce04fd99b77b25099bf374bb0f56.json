{"sha": "6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjZDE1YTBlOGZlY2NlMDRmZDk5Yjc3YjI1MDk5YmYzNzRiYjBmNTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-06T01:00:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-06T01:00:15Z"}, "message": "Auto merge of #41098 - arielb1:rollup, r=arielb1\n\nRollup of 12 pull requests\n\n- Successful merges: #40479, #40561, #40709, #40815, #40909, #40927, #40943, #41015, #41028, #41052, #41054, #41065\n- Failed merges:", "tree": {"sha": "47828ad744694e7cfeed50af05ee9d6c8f1b3779", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47828ad744694e7cfeed50af05ee9d6c8f1b3779"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "html_url": "https://github.com/rust-lang/rust/commit/6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91ae22a012fae7fa7589b1bba77bf4579708ee33", "url": "https://api.github.com/repos/rust-lang/rust/commits/91ae22a012fae7fa7589b1bba77bf4579708ee33", "html_url": "https://github.com/rust-lang/rust/commit/91ae22a012fae7fa7589b1bba77bf4579708ee33"}, {"sha": "d8b61091f619be7c4605e56561eba58a3618447b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8b61091f619be7c4605e56561eba58a3618447b", "html_url": "https://github.com/rust-lang/rust/commit/d8b61091f619be7c4605e56561eba58a3618447b"}], "stats": {"total": 2362, "additions": 1275, "deletions": 1087}, "files": [{"sha": "25082e3a9d095645d68c8528c1a1fb915d62ddcc", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -49,12 +49,17 @@ pub fn install(build: &Build, stage: u32, host: &str) {\n         install_sh(&build, \"docs\", \"rust-docs\", stage, host, &prefix,\n                    &docdir, &libdir, &mandir, &empty_dir);\n     }\n+\n+    for target in build.config.target.iter() {\n+        install_sh(&build, \"std\", \"rust-std\", stage, target, &prefix,\n+                   &docdir, &libdir, &mandir, &empty_dir);\n+    }\n+\n     if build.config.rust_save_analysis {\n         install_sh(&build, \"analysis\", \"rust-analysis\", stage, host, &prefix,\n                    &docdir, &libdir, &mandir, &empty_dir);\n     }\n-    install_sh(&build, \"std\", \"rust-std\", stage, host, &prefix,\n-               &docdir, &libdir, &mandir, &empty_dir);\n+\n     install_sh(&build, \"rustc\", \"rustc\", stage, host, &prefix,\n                &docdir, &libdir, &mandir, &empty_dir);\n     t!(fs::remove_dir_all(&empty_dir));"}, {"sha": "9ce097e78a4e530a6afd1979b2b4eb30ba43e09c", "filename": "src/doc/unstable-book/src/SUMMARY.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -123,6 +123,7 @@\n - [no_debug](no-debug.md)\n - [non_ascii_idents](non-ascii-idents.md)\n - [nonzero](nonzero.md)\n+- [offset_to](offset-to.md)\n - [omit_gdb_pretty_printer_section](omit-gdb-pretty-printer-section.md)\n - [on_unimplemented](on-unimplemented.md)\n - [once_poison](once-poison.md)\n@@ -171,6 +172,7 @@\n - [slice_concat_ext](slice-concat-ext.md)\n - [slice_get_slice](slice-get-slice.md)\n - [slice_patterns](slice-patterns.md)\n+- [slice_rsplit](slice-rsplit.md)\n - [sort_internals](sort-internals.md)\n - [sort_unstable](sort-unstable.md)\n - [specialization](specialization.md)"}, {"sha": "03d990eb4ae970421d5bdea89b0d6c76ba71076a", "filename": "src/doc/unstable-book/src/offset-to.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Fdoc%2Funstable-book%2Fsrc%2Foffset-to.md", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Fdoc%2Funstable-book%2Fsrc%2Foffset-to.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Foffset-to.md?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -0,0 +1,7 @@\n+# `offset_to`\n+\n+The tracking issue for this feature is: [#41079]\n+\n+[#41079]: https://github.com/rust-lang/rust/issues/41079\n+\n+------------------------"}, {"sha": "8c2954f7294e02b666e4ad15244be99048f15867", "filename": "src/doc/unstable-book/src/slice-rsplit.md", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Fdoc%2Funstable-book%2Fsrc%2Fslice-rsplit.md", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Fdoc%2Funstable-book%2Fsrc%2Fslice-rsplit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fslice-rsplit.md?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -0,0 +1,10 @@\n+# `slice_rsplit`\n+\n+The tracking issue for this feature is: [#41020]\n+\n+[#41020]: https://github.com/rust-lang/rust/issues/41020\n+\n+------------------------\n+\n+The `slice_rsplit` feature enables two methods on slices:\n+`slice.rsplit(predicate)` and `slice.rsplit_mut(predicate)`."}, {"sha": "75ab3f1a17be43f4e3669d6eb347ce6e7c56e4cb", "filename": "src/etc/char_private.py", "status": "modified", "additions": 98, "deletions": 34, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Fetc%2Fchar_private.py", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Fetc%2Fchar_private.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fchar_private.py?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -76,6 +76,66 @@ def get_codepoints(f):\n     for c in range(prev_codepoint + 1, NUM_CODEPOINTS):\n         yield Codepoint(c, None)\n \n+def compress_singletons(singletons):\n+    uppers = [] # (upper, # items in lowers)\n+    lowers = []\n+\n+    for i in singletons:\n+        upper = i >> 8\n+        lower = i & 0xff\n+        if len(uppers) == 0 or uppers[-1][0] != upper:\n+            uppers.append((upper, 1))\n+        else:\n+            upper, count = uppers[-1]\n+            uppers[-1] = upper, count + 1\n+        lowers.append(lower)\n+\n+    return uppers, lowers\n+\n+def compress_normal(normal):\n+    # lengths 0x00..0x7f are encoded as 00, 01, ..., 7e, 7f\n+    # lengths 0x80..0x7fff are encoded as 80 80, 80 81, ..., ff fe, ff ff\n+    compressed = [] # [truelen, (truelenaux), falselen, (falselenaux)]\n+\n+    prev_start = 0\n+    for start, count in normal:\n+        truelen = start - prev_start\n+        falselen = count\n+        prev_start = start + count\n+\n+        assert truelen < 0x8000 and falselen < 0x8000\n+        entry = []\n+        if truelen > 0x7f:\n+            entry.append(0x80 | (truelen >> 8))\n+            entry.append(truelen & 0xff)\n+        else:\n+            entry.append(truelen & 0x7f)\n+        if falselen > 0x7f:\n+            entry.append(0x80 | (falselen >> 8))\n+            entry.append(falselen & 0xff)\n+        else:\n+            entry.append(falselen & 0x7f)\n+\n+        compressed.append(entry)\n+\n+    return compressed\n+\n+def print_singletons(uppers, lowers, uppersname, lowersname):\n+    print(\"const {}: &'static [(u8, u8)] = &[\".format(uppersname))\n+    for u, c in uppers:\n+        print(\"    ({:#04x}, {}),\".format(u, c))\n+    print(\"];\")\n+    print(\"const {}: &'static [u8] = &[\".format(lowersname))\n+    for i in range(0, len(lowers), 8):\n+        print(\"    {}\".format(\" \".join(\"{:#04x},\".format(l) for l in lowers[i:i+8])))\n+    print(\"];\")\n+\n+def print_normal(normal, normalname):\n+    print(\"const {}: &'static [u8] = &[\".format(normalname))\n+    for v in normal:\n+        print(\"    {}\".format(\" \".join(\"{:#04x},\".format(i) for i in v)))\n+    print(\"];\")\n+\n def main():\n     file = get_file(\"http://www.unicode.org/Public/UNIDATA/UnicodeData.txt\")\n \n@@ -111,6 +171,11 @@ def main():\n             else:\n                 normal0.append((a, b - a))\n \n+    singletons0u, singletons0l = compress_singletons(singletons0)\n+    singletons1u, singletons1l = compress_singletons(singletons1)\n+    normal0 = compress_normal(normal0)\n+    normal1 = compress_normal(normal1)\n+\n     print(\"\"\"\\\n // Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n@@ -125,38 +190,49 @@ def main():\n // NOTE: The following code was generated by \"src/etc/char_private.py\",\n //       do not edit directly!\n \n-use slice::SliceExt;\n-\n-fn check(x: u16, singletons: &[u16], normal: &[u16]) -> bool {\n-    for &s in singletons {\n-        if x == s {\n-            return false;\n-        } else if x < s {\n+fn check(x: u16, singletonuppers: &[(u8, u8)], singletonlowers: &[u8],\n+         normal: &[u8]) -> bool {\n+    let xupper = (x >> 8) as u8;\n+    let mut lowerstart = 0;\n+    for &(upper, lowercount) in singletonuppers {\n+        let lowerend = lowerstart + lowercount as usize;\n+        if xupper == upper {\n+            for &lower in &singletonlowers[lowerstart..lowerend] {\n+                if lower == x as u8 {\n+                    return false;\n+                }\n+            }\n+        } else if xupper < upper {\n             break;\n         }\n+        lowerstart = lowerend;\n     }\n-    for w in normal.chunks(2) {\n-        let start = w[0];\n-        let len = w[1];\n-        let difference = (x as i32) - (start as i32);\n-        if 0 <= difference {\n-            if difference < len as i32 {\n-                return false;\n-            }\n+\n+    let mut x = x as i32;\n+    let mut normal = normal.iter().cloned();\n+    let mut current = true;\n+    while let Some(v) = normal.next() {\n+        let len = if v & 0x80 != 0 {\n+            ((v & 0x7f) as i32) << 8 | normal.next().unwrap() as i32\n         } else {\n+            v as i32\n+        };\n+        x -= len;\n+        if x < 0 {\n             break;\n         }\n+        current = !current;\n     }\n-    true\n+    current\n }\n \n pub fn is_printable(x: char) -> bool {\n     let x = x as u32;\n     let lower = x as u16;\n     if x < 0x10000 {\n-        check(lower, SINGLETONS0, NORMAL0)\n+        check(lower, SINGLETONS0U, SINGLETONS0L, NORMAL0)\n     } else if x < 0x20000 {\n-        check(lower, SINGLETONS1, NORMAL1)\n+        check(lower, SINGLETONS1U, SINGLETONS1L, NORMAL1)\n     } else {\\\n \"\"\")\n     for a, b in extra:\n@@ -169,22 +245,10 @@ def main():\n }\\\n \"\"\")\n     print()\n-    print(\"const SINGLETONS0: &'static [u16] = &[\")\n-    for s in singletons0:\n-        print(\"    0x{:x},\".format(s))\n-    print(\"];\")\n-    print(\"const SINGLETONS1: &'static [u16] = &[\")\n-    for s in singletons1:\n-        print(\"    0x{:x},\".format(s))\n-    print(\"];\")\n-    print(\"const NORMAL0: &'static [u16] = &[\")\n-    for a, b in normal0:\n-        print(\"    0x{:x}, 0x{:x},\".format(a, b))\n-    print(\"];\")\n-    print(\"const NORMAL1: &'static [u16] = &[\")\n-    for a, b in normal1:\n-        print(\"    0x{:x}, 0x{:x},\".format(a, b))\n-    print(\"];\")\n+    print_singletons(singletons0u, singletons0l, 'SINGLETONS0U', 'SINGLETONS0L')\n+    print_singletons(singletons1u, singletons1l, 'SINGLETONS1U', 'SINGLETONS1L')\n+    print_normal(normal0, 'NORMAL0')\n+    print_normal(normal1, 'NORMAL1')\n \n if __name__ == '__main__':\n     main()"}, {"sha": "248c15e96f8f65f3b432fbe7db9dc7645823c1d5", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -52,6 +52,7 @@\n #![feature(shared)]\n #![feature(slice_get_slice)]\n #![feature(slice_patterns)]\n+#![feature(slice_rsplit)]\n #![cfg_attr(not(test), feature(sort_unstable))]\n #![feature(specialization)]\n #![feature(staged_api)]\n@@ -62,6 +63,7 @@\n #![feature(untagged_unions)]\n #![cfg_attr(not(test), feature(str_checked_slicing))]\n #![cfg_attr(test, feature(rand, test))]\n+#![feature(offset_to)]\n \n #![no_std]\n "}, {"sha": "6cff315a6ccd9eb28083d2b1f5b2afa9e8dc2430", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -115,6 +115,8 @@ pub use core::slice::{Iter, IterMut};\n pub use core::slice::{SplitMut, ChunksMut, Split};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+pub use core::slice::{RSplit, RSplitMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n #[unstable(feature = \"slice_get_slice\", issue = \"35729\")]\n@@ -779,6 +781,72 @@ impl<T> [T] {\n         core_slice::SliceExt::split_mut(self, pred)\n     }\n \n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`, starting at the end of the slice and working backwards.\n+    /// The matched element is not contained in the subslices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_rsplit)]\n+    ///\n+    /// let slice = [11, 22, 33, 0, 44, 55];\n+    /// let mut iter = slice.rsplit(|num| *num == 0);\n+    ///\n+    /// assert_eq!(iter.next().unwrap(), &[44, 55]);\n+    /// assert_eq!(iter.next().unwrap(), &[11, 22, 33]);\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// As with `split()`, if the first or last element is matched, an empty\n+    /// slice will be the first (or last) item returned by the iterator.\n+    ///\n+    /// ```\n+    /// #![feature(slice_rsplit)]\n+    ///\n+    /// let v = &[0, 1, 1, 2, 3, 5, 8];\n+    /// let mut it = v.rsplit(|n| *n % 2 == 0);\n+    /// assert_eq!(it.next().unwrap(), &[]);\n+    /// assert_eq!(it.next().unwrap(), &[3, 5]);\n+    /// assert_eq!(it.next().unwrap(), &[1, 1]);\n+    /// assert_eq!(it.next().unwrap(), &[]);\n+    /// assert_eq!(it.next(), None);\n+    /// ```\n+    #[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+    #[inline]\n+    pub fn rsplit<F>(&self, pred: F) -> RSplit<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n+        core_slice::SliceExt::rsplit(self, pred)\n+    }\n+\n+    /// Returns an iterator over mutable subslices separated by elements that\n+    /// match `pred`, starting at the end of the slice and working\n+    /// backwards. The matched element is not contained in the subslices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_rsplit)]\n+    ///\n+    /// let mut v = [100, 400, 300, 200, 600, 500];\n+    ///\n+    /// let mut count = 0;\n+    /// for group in v.rsplit_mut(|num| *num % 3 == 0) {\n+    ///     count += 1;\n+    ///     group[0] = count;\n+    /// }\n+    /// assert_eq!(v, [3, 400, 300, 2, 600, 1]);\n+    /// ```\n+    ///\n+    #[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+    #[inline]\n+    pub fn rsplit_mut<F>(&mut self, pred: F) -> RSplitMut<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n+        core_slice::SliceExt::rsplit_mut(self, pred)\n+    }\n+\n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to returning at most `n` items. The matched element is\n     /// not contained in the subslices."}, {"sha": "c258ac2bdea9be0a81930b2d5bbb56cd1935c340", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -973,6 +973,29 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    /// Returns a place for insertion at the back of the `Vec`.\n+    ///\n+    /// Using this method with placement syntax is equivalent to [`push`](#method.push),\n+    /// but may be more efficient.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(collection_placement)]\n+    /// #![feature(placement_in_syntax)]\n+    ///\n+    /// let mut vec = vec![1, 2];\n+    /// vec.place_back() <- 3;\n+    /// vec.place_back() <- 4;\n+    /// assert_eq!(&vec, &[1, 2, 3, 4]);\n+    /// ```\n+    #[unstable(feature = \"collection_placement\",\n+               reason = \"placement protocol is subject to change\",\n+               issue = \"30172\")]\n+    pub fn place_back(&mut self) -> PlaceBack<T> {\n+        PlaceBack { vec: self }\n+    }\n+\n     /// Removes the last element from a vector and returns it, or [`None`] if it\n     /// is empty.\n     ///\n@@ -1267,29 +1290,6 @@ impl<T: Clone> Vec<T> {\n     pub fn extend_from_slice(&mut self, other: &[T]) {\n         self.spec_extend(other.iter())\n     }\n-\n-    /// Returns a place for insertion at the back of the `Vec`.\n-    ///\n-    /// Using this method with placement syntax is equivalent to [`push`](#method.push),\n-    /// but may be more efficient.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(collection_placement)]\n-    /// #![feature(placement_in_syntax)]\n-    ///\n-    /// let mut vec = vec![1, 2];\n-    /// vec.place_back() <- 3;\n-    /// vec.place_back() <- 4;\n-    /// assert_eq!(&vec, &[1, 2, 3, 4]);\n-    /// ```\n-    #[unstable(feature = \"collection_placement\",\n-               reason = \"placement protocol is subject to change\",\n-               issue = \"30172\")]\n-    pub fn place_back(&mut self) -> PlaceBack<T> {\n-        PlaceBack { vec: self }\n-    }\n }\n \n // Set the length of the vec when the `SetLenOnDrop` value goes out of scope.\n@@ -2074,14 +2074,10 @@ impl<T> Iterator for IntoIter<T> {\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let diff = (self.end as usize) - (self.ptr as usize);\n-        let size = mem::size_of::<T>();\n-        let exact = diff /\n-                    (if size == 0 {\n-                         1\n-                     } else {\n-                         size\n-                     });\n+        let exact = match self.ptr.offset_to(self.end) {\n+            Some(x) => x as usize,\n+            None => (self.end as usize).wrapping_sub(self.ptr as usize),\n+        };\n         (exact, Some(exact))\n     }\n "}, {"sha": "2c0f449b27601405bdcb1014552944c36b2461e7", "filename": "src/libcore/char_private.rs", "status": "modified", "additions": 467, "deletions": 771, "changes": 1238, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibcore%2Fchar_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibcore%2Fchar_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar_private.rs?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -11,38 +11,49 @@\n // NOTE: The following code was generated by \"src/etc/char_private.py\",\n //       do not edit directly!\n \n-use slice::SliceExt;\n-\n-fn check(x: u16, singletons: &[u16], normal: &[u16]) -> bool {\n-    for &s in singletons {\n-        if x == s {\n-            return false;\n-        } else if x < s {\n+fn check(x: u16, singletonuppers: &[(u8, u8)], singletonlowers: &[u8],\n+         normal: &[u8]) -> bool {\n+    let xupper = (x >> 8) as u8;\n+    let mut lowerstart = 0;\n+    for &(upper, lowercount) in singletonuppers {\n+        let lowerend = lowerstart + lowercount as usize;\n+        if xupper == upper {\n+            for &lower in &singletonlowers[lowerstart..lowerend] {\n+                if lower == x as u8 {\n+                    return false;\n+                }\n+            }\n+        } else if xupper < upper {\n             break;\n         }\n+        lowerstart = lowerend;\n     }\n-    for w in normal.chunks(2) {\n-        let start = w[0];\n-        let len = w[1];\n-        let difference = (x as i32) - (start as i32);\n-        if 0 <= difference {\n-            if difference < len as i32 {\n-                return false;\n-            }\n+\n+    let mut x = x as i32;\n+    let mut normal = normal.iter().cloned();\n+    let mut current = true;\n+    while let Some(v) = normal.next() {\n+        let len = if v & 0x80 != 0 {\n+            ((v & 0x7f) as i32) << 8 | normal.next().unwrap() as i32\n         } else {\n+            v as i32\n+        };\n+        x -= len;\n+        if x < 0 {\n             break;\n         }\n+        current = !current;\n     }\n-    true\n+    current\n }\n \n pub fn is_printable(x: char) -> bool {\n     let x = x as u32;\n     let lower = x as u16;\n     if x < 0x10000 {\n-        check(lower, SINGLETONS0, NORMAL0)\n+        check(lower, SINGLETONS0U, SINGLETONS0L, NORMAL0)\n     } else if x < 0x20000 {\n-        check(lower, SINGLETONS1, NORMAL1)\n+        check(lower, SINGLETONS1U, SINGLETONS1L, NORMAL1)\n     } else {\n         if 0x2a6d7 <= x && x < 0x2a700 {\n             return false;\n@@ -66,761 +77,446 @@ pub fn is_printable(x: char) -> bool {\n     }\n }\n \n-const SINGLETONS0: &'static [u16] = &[\n-    0xad,\n-    0x378,\n-    0x379,\n-    0x38b,\n-    0x38d,\n-    0x3a2,\n-    0x530,\n-    0x557,\n-    0x558,\n-    0x560,\n-    0x588,\n-    0x58b,\n-    0x58c,\n-    0x590,\n-    0x61c,\n-    0x61d,\n-    0x6dd,\n-    0x70e,\n-    0x70f,\n-    0x74b,\n-    0x74c,\n-    0x82e,\n-    0x82f,\n-    0x83f,\n-    0x85c,\n-    0x85d,\n-    0x8b5,\n-    0x8e2,\n-    0x984,\n-    0x98d,\n-    0x98e,\n-    0x991,\n-    0x992,\n-    0x9a9,\n-    0x9b1,\n-    0x9ba,\n-    0x9bb,\n-    0x9c5,\n-    0x9c6,\n-    0x9c9,\n-    0x9ca,\n-    0x9de,\n-    0x9e4,\n-    0x9e5,\n-    0xa04,\n-    0xa11,\n-    0xa12,\n-    0xa29,\n-    0xa31,\n-    0xa34,\n-    0xa37,\n-    0xa3a,\n-    0xa3b,\n-    0xa3d,\n-    0xa49,\n-    0xa4a,\n-    0xa5d,\n-    0xa84,\n-    0xa8e,\n-    0xa92,\n-    0xaa9,\n-    0xab1,\n-    0xab4,\n-    0xaba,\n-    0xabb,\n-    0xac6,\n-    0xaca,\n-    0xace,\n-    0xacf,\n-    0xae4,\n-    0xae5,\n-    0xb04,\n-    0xb0d,\n-    0xb0e,\n-    0xb11,\n-    0xb12,\n-    0xb29,\n-    0xb31,\n-    0xb34,\n-    0xb3a,\n-    0xb3b,\n-    0xb45,\n-    0xb46,\n-    0xb49,\n-    0xb4a,\n-    0xb5e,\n-    0xb64,\n-    0xb65,\n-    0xb84,\n-    0xb91,\n-    0xb9b,\n-    0xb9d,\n-    0xbc9,\n-    0xbce,\n-    0xbcf,\n-    0xc04,\n-    0xc0d,\n-    0xc11,\n-    0xc29,\n-    0xc45,\n-    0xc49,\n-    0xc57,\n-    0xc64,\n-    0xc65,\n-    0xc84,\n-    0xc8d,\n-    0xc91,\n-    0xca9,\n-    0xcb4,\n-    0xcba,\n-    0xcbb,\n-    0xcc5,\n-    0xcc9,\n-    0xcdf,\n-    0xce4,\n-    0xce5,\n-    0xcf0,\n-    0xd04,\n-    0xd0d,\n-    0xd11,\n-    0xd3b,\n-    0xd3c,\n-    0xd45,\n-    0xd49,\n-    0xd64,\n-    0xd65,\n-    0xd80,\n-    0xd81,\n-    0xd84,\n-    0xdb2,\n-    0xdbc,\n-    0xdbe,\n-    0xdbf,\n-    0xdd5,\n-    0xdd7,\n-    0xdf0,\n-    0xdf1,\n-    0xe83,\n-    0xe85,\n-    0xe86,\n-    0xe89,\n-    0xe8b,\n-    0xe8c,\n-    0xe98,\n-    0xea0,\n-    0xea4,\n-    0xea6,\n-    0xea8,\n-    0xea9,\n-    0xeac,\n-    0xeba,\n-    0xebe,\n-    0xebf,\n-    0xec5,\n-    0xec7,\n-    0xece,\n-    0xecf,\n-    0xeda,\n-    0xedb,\n-    0xf48,\n-    0xf98,\n-    0xfbd,\n-    0xfcd,\n-    0x10c6,\n-    0x10ce,\n-    0x10cf,\n-    0x1249,\n-    0x124e,\n-    0x124f,\n-    0x1257,\n-    0x1259,\n-    0x125e,\n-    0x125f,\n-    0x1289,\n-    0x128e,\n-    0x128f,\n-    0x12b1,\n-    0x12b6,\n-    0x12b7,\n-    0x12bf,\n-    0x12c1,\n-    0x12c6,\n-    0x12c7,\n-    0x12d7,\n-    0x1311,\n-    0x1316,\n-    0x1317,\n-    0x135b,\n-    0x135c,\n-    0x13f6,\n-    0x13f7,\n-    0x13fe,\n-    0x13ff,\n-    0x1680,\n-    0x170d,\n-    0x176d,\n-    0x1771,\n-    0x17de,\n-    0x17df,\n-    0x180e,\n-    0x180f,\n-    0x191f,\n-    0x196e,\n-    0x196f,\n-    0x1a1c,\n-    0x1a1d,\n-    0x1a5f,\n-    0x1a7d,\n-    0x1a7e,\n-    0x1aae,\n-    0x1aaf,\n-    0x1cf7,\n-    0x1f16,\n-    0x1f17,\n-    0x1f1e,\n-    0x1f1f,\n-    0x1f46,\n-    0x1f47,\n-    0x1f4e,\n-    0x1f4f,\n-    0x1f58,\n-    0x1f5a,\n-    0x1f5c,\n-    0x1f5e,\n-    0x1f7e,\n-    0x1f7f,\n-    0x1fb5,\n-    0x1fc5,\n-    0x1fd4,\n-    0x1fd5,\n-    0x1fdc,\n-    0x1ff0,\n-    0x1ff1,\n-    0x1ff5,\n-    0x2072,\n-    0x2073,\n-    0x208f,\n-    0x23ff,\n-    0x2b74,\n-    0x2b75,\n-    0x2b96,\n-    0x2b97,\n-    0x2bc9,\n-    0x2c2f,\n-    0x2c5f,\n-    0x2d26,\n-    0x2d2e,\n-    0x2d2f,\n-    0x2da7,\n-    0x2daf,\n-    0x2db7,\n-    0x2dbf,\n-    0x2dc7,\n-    0x2dcf,\n-    0x2dd7,\n-    0x2ddf,\n-    0x2e9a,\n-    0x3040,\n-    0x3097,\n-    0x3098,\n-    0x318f,\n-    0x321f,\n-    0x32ff,\n-    0xa7af,\n-    0xa8fe,\n-    0xa8ff,\n-    0xa9ce,\n-    0xa9ff,\n-    0xaa4e,\n-    0xaa4f,\n-    0xaa5a,\n-    0xaa5b,\n-    0xab07,\n-    0xab08,\n-    0xab0f,\n-    0xab10,\n-    0xab27,\n-    0xab2f,\n-    0xabee,\n-    0xabef,\n-    0xfa6e,\n-    0xfa6f,\n-    0xfb37,\n-    0xfb3d,\n-    0xfb3f,\n-    0xfb42,\n-    0xfb45,\n-    0xfd90,\n-    0xfd91,\n-    0xfdfe,\n-    0xfdff,\n-    0xfe53,\n-    0xfe67,\n-    0xfe75,\n-    0xffc8,\n-    0xffc9,\n-    0xffd0,\n-    0xffd1,\n-    0xffd8,\n-    0xffd9,\n-    0xffe7,\n-    0xfffe,\n-    0xffff,\n+const SINGLETONS0U: &'static [(u8, u8)] = &[\n+    (0x00, 1),\n+    (0x03, 5),\n+    (0x05, 8),\n+    (0x06, 3),\n+    (0x07, 4),\n+    (0x08, 7),\n+    (0x09, 16),\n+    (0x0a, 27),\n+    (0x0b, 24),\n+    (0x0c, 22),\n+    (0x0d, 20),\n+    (0x0e, 22),\n+    (0x0f, 4),\n+    (0x10, 3),\n+    (0x12, 18),\n+    (0x13, 9),\n+    (0x16, 1),\n+    (0x17, 5),\n+    (0x18, 2),\n+    (0x19, 3),\n+    (0x1a, 7),\n+    (0x1c, 1),\n+    (0x1f, 22),\n+    (0x20, 3),\n+    (0x23, 1),\n+    (0x2b, 5),\n+    (0x2c, 2),\n+    (0x2d, 11),\n+    (0x2e, 1),\n+    (0x30, 3),\n+    (0x31, 1),\n+    (0x32, 2),\n+    (0xa7, 1),\n+    (0xa8, 2),\n+    (0xa9, 2),\n+    (0xaa, 4),\n+    (0xab, 8),\n+    (0xfa, 2),\n+    (0xfb, 5),\n+    (0xfd, 4),\n+    (0xfe, 3),\n+    (0xff, 9),\n ];\n-const SINGLETONS1: &'static [u16] = &[\n-    0xc,\n-    0x27,\n-    0x3b,\n-    0x3e,\n-    0x4e,\n-    0x4f,\n-    0x18f,\n-    0x39e,\n-    0x49e,\n-    0x49f,\n-    0x806,\n-    0x807,\n-    0x809,\n-    0x836,\n-    0x83d,\n-    0x83e,\n-    0x856,\n-    0x8f3,\n-    0x9d0,\n-    0x9d1,\n-    0xa04,\n-    0xa14,\n-    0xa18,\n-    0xb56,\n-    0xb57,\n-    0x10bd,\n-    0x1135,\n-    0x11ce,\n-    0x11cf,\n-    0x11e0,\n-    0x1212,\n-    0x1287,\n-    0x1289,\n-    0x128e,\n-    0x129e,\n-    0x1304,\n-    0x130d,\n-    0x130e,\n-    0x1311,\n-    0x1312,\n-    0x1329,\n-    0x1331,\n-    0x1334,\n-    0x133a,\n-    0x133b,\n-    0x1345,\n-    0x1346,\n-    0x1349,\n-    0x134a,\n-    0x134e,\n-    0x134f,\n-    0x1364,\n-    0x1365,\n-    0x145a,\n-    0x145c,\n-    0x15b6,\n-    0x15b7,\n-    0x1c09,\n-    0x1c37,\n-    0x1c90,\n-    0x1c91,\n-    0x1ca8,\n-    0x246f,\n-    0x6a5f,\n-    0x6aee,\n-    0x6aef,\n-    0x6b5a,\n-    0x6b62,\n-    0xbc9a,\n-    0xbc9b,\n-    0xd127,\n-    0xd128,\n-    0xd455,\n-    0xd49d,\n-    0xd4a0,\n-    0xd4a1,\n-    0xd4a3,\n-    0xd4a4,\n-    0xd4a7,\n-    0xd4a8,\n-    0xd4ad,\n-    0xd4ba,\n-    0xd4bc,\n-    0xd4c4,\n-    0xd506,\n-    0xd50b,\n-    0xd50c,\n-    0xd515,\n-    0xd51d,\n-    0xd53a,\n-    0xd53f,\n-    0xd545,\n-    0xd551,\n-    0xd6a6,\n-    0xd6a7,\n-    0xd7cc,\n-    0xd7cd,\n-    0xdaa0,\n-    0xe007,\n-    0xe019,\n-    0xe01a,\n-    0xe022,\n-    0xe025,\n-    0xe8c5,\n-    0xe8c6,\n-    0xee04,\n-    0xee20,\n-    0xee23,\n-    0xee25,\n-    0xee26,\n-    0xee28,\n-    0xee33,\n-    0xee38,\n-    0xee3a,\n-    0xee48,\n-    0xee4a,\n-    0xee4c,\n-    0xee50,\n-    0xee53,\n-    0xee55,\n-    0xee56,\n-    0xee58,\n-    0xee5a,\n-    0xee5c,\n-    0xee5e,\n-    0xee60,\n-    0xee63,\n-    0xee65,\n-    0xee66,\n-    0xee6b,\n-    0xee73,\n-    0xee78,\n-    0xee7d,\n-    0xee7f,\n-    0xee8a,\n-    0xeea4,\n-    0xeeaa,\n-    0xf0af,\n-    0xf0b0,\n-    0xf0c0,\n-    0xf0d0,\n-    0xf12f,\n-    0xf91f,\n-    0xf931,\n-    0xf932,\n-    0xf93f,\n+const SINGLETONS0L: &'static [u8] = &[\n+    0xad, 0x78, 0x79, 0x8b, 0x8d, 0xa2, 0x30, 0x57,\n+    0x58, 0x60, 0x88, 0x8b, 0x8c, 0x90, 0x1c, 0x1d,\n+    0xdd, 0x0e, 0x0f, 0x4b, 0x4c, 0x2e, 0x2f, 0x3f,\n+    0x5c, 0x5d, 0xb5, 0xe2, 0x84, 0x8d, 0x8e, 0x91,\n+    0x92, 0xa9, 0xb1, 0xba, 0xbb, 0xc5, 0xc6, 0xc9,\n+    0xca, 0xde, 0xe4, 0xe5, 0x04, 0x11, 0x12, 0x29,\n+    0x31, 0x34, 0x37, 0x3a, 0x3b, 0x3d, 0x49, 0x4a,\n+    0x5d, 0x84, 0x8e, 0x92, 0xa9, 0xb1, 0xb4, 0xba,\n+    0xbb, 0xc6, 0xca, 0xce, 0xcf, 0xe4, 0xe5, 0x04,\n+    0x0d, 0x0e, 0x11, 0x12, 0x29, 0x31, 0x34, 0x3a,\n+    0x3b, 0x45, 0x46, 0x49, 0x4a, 0x5e, 0x64, 0x65,\n+    0x84, 0x91, 0x9b, 0x9d, 0xc9, 0xce, 0xcf, 0x04,\n+    0x0d, 0x11, 0x29, 0x45, 0x49, 0x57, 0x64, 0x65,\n+    0x84, 0x8d, 0x91, 0xa9, 0xb4, 0xba, 0xbb, 0xc5,\n+    0xc9, 0xdf, 0xe4, 0xe5, 0xf0, 0x04, 0x0d, 0x11,\n+    0x3b, 0x3c, 0x45, 0x49, 0x64, 0x65, 0x80, 0x81,\n+    0x84, 0xb2, 0xbc, 0xbe, 0xbf, 0xd5, 0xd7, 0xf0,\n+    0xf1, 0x83, 0x85, 0x86, 0x89, 0x8b, 0x8c, 0x98,\n+    0xa0, 0xa4, 0xa6, 0xa8, 0xa9, 0xac, 0xba, 0xbe,\n+    0xbf, 0xc5, 0xc7, 0xce, 0xcf, 0xda, 0xdb, 0x48,\n+    0x98, 0xbd, 0xcd, 0xc6, 0xce, 0xcf, 0x49, 0x4e,\n+    0x4f, 0x57, 0x59, 0x5e, 0x5f, 0x89, 0x8e, 0x8f,\n+    0xb1, 0xb6, 0xb7, 0xbf, 0xc1, 0xc6, 0xc7, 0xd7,\n+    0x11, 0x16, 0x17, 0x5b, 0x5c, 0xf6, 0xf7, 0xfe,\n+    0xff, 0x80, 0x0d, 0x6d, 0x71, 0xde, 0xdf, 0x0e,\n+    0x0f, 0x1f, 0x6e, 0x6f, 0x1c, 0x1d, 0x5f, 0x7d,\n+    0x7e, 0xae, 0xaf, 0xf7, 0x16, 0x17, 0x1e, 0x1f,\n+    0x46, 0x47, 0x4e, 0x4f, 0x58, 0x5a, 0x5c, 0x5e,\n+    0x7e, 0x7f, 0xb5, 0xc5, 0xd4, 0xd5, 0xdc, 0xf0,\n+    0xf1, 0xf5, 0x72, 0x73, 0x8f, 0xff, 0x74, 0x75,\n+    0x96, 0x97, 0xc9, 0x2f, 0x5f, 0x26, 0x2e, 0x2f,\n+    0xa7, 0xaf, 0xb7, 0xbf, 0xc7, 0xcf, 0xd7, 0xdf,\n+    0x9a, 0x40, 0x97, 0x98, 0x8f, 0x1f, 0xff, 0xaf,\n+    0xfe, 0xff, 0xce, 0xff, 0x4e, 0x4f, 0x5a, 0x5b,\n+    0x07, 0x08, 0x0f, 0x10, 0x27, 0x2f, 0xee, 0xef,\n+    0x6e, 0x6f, 0x37, 0x3d, 0x3f, 0x42, 0x45, 0x90,\n+    0x91, 0xfe, 0xff, 0x53, 0x67, 0x75, 0xc8, 0xc9,\n+    0xd0, 0xd1, 0xd8, 0xd9, 0xe7, 0xfe, 0xff,\n ];\n-const NORMAL0: &'static [u16] = &[\n-    0x0, 0x20,\n-    0x7f, 0x22,\n-    0x380, 0x4,\n-    0x5c8, 0x8,\n-    0x5eb, 0x5,\n-    0x5f5, 0x11,\n-    0x7b2, 0xe,\n-    0x7fb, 0x5,\n-    0x85f, 0x41,\n-    0x8be, 0x16,\n-    0x9b3, 0x3,\n-    0x9cf, 0x8,\n-    0x9d8, 0x4,\n-    0x9fc, 0x5,\n-    0xa0b, 0x4,\n-    0xa43, 0x4,\n-    0xa4e, 0x3,\n-    0xa52, 0x7,\n-    0xa5f, 0x7,\n-    0xa76, 0xb,\n-    0xad1, 0xf,\n-    0xaf2, 0x7,\n-    0xafa, 0x7,\n-    0xb4e, 0x8,\n-    0xb58, 0x4,\n-    0xb78, 0xa,\n-    0xb8b, 0x3,\n-    0xb96, 0x3,\n-    0xba0, 0x3,\n-    0xba5, 0x3,\n-    0xbab, 0x3,\n-    0xbba, 0x4,\n-    0xbc3, 0x3,\n-    0xbd1, 0x6,\n-    0xbd8, 0xe,\n-    0xbfb, 0x5,\n-    0xc3a, 0x3,\n-    0xc4e, 0x7,\n-    0xc5b, 0x5,\n-    0xc70, 0x8,\n-    0xcce, 0x7,\n-    0xcd7, 0x7,\n-    0xcf3, 0xe,\n-    0xd50, 0x4,\n-    0xd97, 0x3,\n-    0xdc7, 0x3,\n-    0xdcb, 0x4,\n-    0xde0, 0x6,\n-    0xdf5, 0xc,\n-    0xe3b, 0x4,\n-    0xe5c, 0x25,\n-    0xe8e, 0x6,\n-    0xee0, 0x20,\n-    0xf6d, 0x4,\n-    0xfdb, 0x25,\n-    0x10c8, 0x5,\n-    0x137d, 0x3,\n-    0x139a, 0x6,\n-    0x169d, 0x3,\n-    0x16f9, 0x7,\n-    0x1715, 0xb,\n-    0x1737, 0x9,\n-    0x1754, 0xc,\n-    0x1774, 0xc,\n-    0x17ea, 0x6,\n-    0x17fa, 0x6,\n-    0x181a, 0x6,\n-    0x1878, 0x8,\n-    0x18ab, 0x5,\n-    0x18f6, 0xa,\n-    0x192c, 0x4,\n-    0x193c, 0x4,\n-    0x1941, 0x3,\n-    0x1975, 0xb,\n-    0x19ac, 0x4,\n-    0x19ca, 0x6,\n-    0x19db, 0x3,\n-    0x1a8a, 0x6,\n-    0x1a9a, 0x6,\n-    0x1abf, 0x41,\n-    0x1b4c, 0x4,\n-    0x1b7d, 0x3,\n-    0x1bf4, 0x8,\n-    0x1c38, 0x3,\n-    0x1c4a, 0x3,\n-    0x1c89, 0x37,\n-    0x1cc8, 0x8,\n-    0x1cfa, 0x6,\n-    0x1df6, 0x5,\n-    0x1fff, 0x11,\n-    0x2028, 0x8,\n-    0x205f, 0x11,\n-    0x209d, 0x3,\n-    0x20bf, 0x11,\n-    0x20f1, 0xf,\n-    0x218c, 0x4,\n-    0x2427, 0x19,\n-    0x244b, 0x15,\n-    0x2bba, 0x3,\n-    0x2bd2, 0x1a,\n-    0x2bf0, 0x10,\n-    0x2cf4, 0x5,\n-    0x2d28, 0x5,\n-    0x2d68, 0x7,\n-    0x2d71, 0xe,\n-    0x2d97, 0x9,\n-    0x2e45, 0x3b,\n-    0x2ef4, 0xc,\n-    0x2fd6, 0x1a,\n-    0x2ffc, 0x5,\n-    0x3100, 0x5,\n-    0x312e, 0x3,\n-    0x31bb, 0x5,\n-    0x31e4, 0xc,\n-    0x4db6, 0xa,\n-    0x9fd6, 0x2a,\n-    0xa48d, 0x3,\n-    0xa4c7, 0x9,\n-    0xa62c, 0x14,\n-    0xa6f8, 0x8,\n-    0xa7b8, 0x3f,\n-    0xa82c, 0x4,\n-    0xa83a, 0x6,\n-    0xa878, 0x8,\n-    0xa8c6, 0x8,\n-    0xa8da, 0x6,\n-    0xa954, 0xb,\n-    0xa97d, 0x3,\n-    0xa9da, 0x4,\n-    0xaa37, 0x9,\n-    0xaac3, 0x18,\n-    0xaaf7, 0xa,\n-    0xab17, 0x9,\n-    0xab66, 0xa,\n-    0xabfa, 0x6,\n-    0xd7a4, 0xc,\n-    0xd7c7, 0x4,\n-    0xd7fc, 0x2104,\n-    0xfada, 0x26,\n-    0xfb07, 0xc,\n-    0xfb18, 0x5,\n-    0xfbc2, 0x11,\n-    0xfd40, 0x10,\n-    0xfdc8, 0x28,\n-    0xfe1a, 0x6,\n-    0xfe6c, 0x4,\n-    0xfefd, 0x4,\n-    0xffbf, 0x3,\n-    0xffdd, 0x3,\n-    0xffef, 0xd,\n+const SINGLETONS1U: &'static [(u8, u8)] = &[\n+    (0x00, 6),\n+    (0x01, 1),\n+    (0x03, 1),\n+    (0x04, 2),\n+    (0x08, 8),\n+    (0x09, 2),\n+    (0x0a, 3),\n+    (0x0b, 2),\n+    (0x10, 1),\n+    (0x11, 4),\n+    (0x12, 5),\n+    (0x13, 18),\n+    (0x14, 2),\n+    (0x15, 2),\n+    (0x1c, 5),\n+    (0x24, 1),\n+    (0x6a, 3),\n+    (0x6b, 2),\n+    (0xbc, 2),\n+    (0xd1, 2),\n+    (0xd4, 12),\n+    (0xd5, 9),\n+    (0xd6, 2),\n+    (0xd7, 2),\n+    (0xda, 1),\n+    (0xe0, 5),\n+    (0xe8, 2),\n+    (0xee, 32),\n+    (0xf0, 4),\n+    (0xf1, 1),\n+    (0xf9, 4),\n ];\n-const NORMAL1: &'static [u16] = &[\n+const SINGLETONS1L: &'static [u8] = &[\n+    0x0c, 0x27, 0x3b, 0x3e, 0x4e, 0x4f, 0x8f, 0x9e,\n+    0x9e, 0x9f, 0x06, 0x07, 0x09, 0x36, 0x3d, 0x3e,\n+    0x56, 0xf3, 0xd0, 0xd1, 0x04, 0x14, 0x18, 0x56,\n+    0x57, 0xbd, 0x35, 0xce, 0xcf, 0xe0, 0x12, 0x87,\n+    0x89, 0x8e, 0x9e, 0x04, 0x0d, 0x0e, 0x11, 0x12,\n+    0x29, 0x31, 0x34, 0x3a, 0x3b, 0x45, 0x46, 0x49,\n+    0x4a, 0x4e, 0x4f, 0x64, 0x65, 0x5a, 0x5c, 0xb6,\n+    0xb7, 0x09, 0x37, 0x90, 0x91, 0xa8, 0x6f, 0x5f,\n+    0xee, 0xef, 0x5a, 0x62, 0x9a, 0x9b, 0x27, 0x28,\n+    0x55, 0x9d, 0xa0, 0xa1, 0xa3, 0xa4, 0xa7, 0xa8,\n+    0xad, 0xba, 0xbc, 0xc4, 0x06, 0x0b, 0x0c, 0x15,\n+    0x1d, 0x3a, 0x3f, 0x45, 0x51, 0xa6, 0xa7, 0xcc,\n+    0xcd, 0xa0, 0x07, 0x19, 0x1a, 0x22, 0x25, 0xc5,\n+    0xc6, 0x04, 0x20, 0x23, 0x25, 0x26, 0x28, 0x33,\n+    0x38, 0x3a, 0x48, 0x4a, 0x4c, 0x50, 0x53, 0x55,\n+    0x56, 0x58, 0x5a, 0x5c, 0x5e, 0x60, 0x63, 0x65,\n+    0x66, 0x6b, 0x73, 0x78, 0x7d, 0x7f, 0x8a, 0xa4,\n+    0xaa, 0xaf, 0xb0, 0xc0, 0xd0, 0x2f, 0x1f, 0x31,\n+    0x32, 0x3f,\n+];\n+const NORMAL0: &'static [u8] = &[\n+    0x00, 0x20,\n+    0x5f, 0x22,\n+    0x82, 0xdf, 0x04,\n+    0x82, 0x44, 0x08,\n+    0x1b, 0x05,\n+    0x05, 0x11,\n+    0x81, 0xac, 0x0e,\n+    0x3b, 0x05,\n+    0x5f, 0x41,\n+    0x1e, 0x16,\n+    0x80, 0xdf, 0x03,\n+    0x19, 0x08,\n+    0x01, 0x04,\n+    0x20, 0x05,\n+    0x0a, 0x04,\n+    0x34, 0x04,\n+    0x07, 0x03,\n+    0x01, 0x07,\n+    0x06, 0x07,\n+    0x10, 0x0b,\n+    0x50, 0x0f,\n+    0x12, 0x07,\n+    0x01, 0x07,\n+    0x4d, 0x08,\n+    0x02, 0x04,\n+    0x1c, 0x0a,\n+    0x09, 0x03,\n+    0x08, 0x03,\n+    0x07, 0x03,\n+    0x02, 0x03,\n+    0x03, 0x03,\n+    0x0c, 0x04,\n+    0x05, 0x03,\n+    0x0b, 0x06,\n+    0x01, 0x0e,\n+    0x15, 0x05,\n+    0x3a, 0x03,\n+    0x11, 0x07,\n+    0x06, 0x05,\n+    0x10, 0x08,\n+    0x56, 0x07,\n+    0x02, 0x07,\n+    0x15, 0x0e,\n+    0x4f, 0x04,\n+    0x43, 0x03,\n+    0x2d, 0x03,\n+    0x01, 0x04,\n+    0x11, 0x06,\n+    0x0f, 0x0c,\n+    0x3a, 0x04,\n+    0x1d, 0x25,\n+    0x0d, 0x06,\n+    0x4c, 0x20,\n+    0x6d, 0x04,\n+    0x6a, 0x25,\n+    0x80, 0xc8, 0x05,\n+    0x82, 0xb0, 0x03,\n+    0x1a, 0x06,\n+    0x82, 0xfd, 0x03,\n+    0x59, 0x07,\n+    0x15, 0x0b,\n+    0x17, 0x09,\n+    0x14, 0x0c,\n+    0x14, 0x0c,\n+    0x6a, 0x06,\n+    0x0a, 0x06,\n+    0x1a, 0x06,\n+    0x58, 0x08,\n+    0x2b, 0x05,\n+    0x46, 0x0a,\n+    0x2c, 0x04,\n+    0x0c, 0x04,\n+    0x01, 0x03,\n+    0x31, 0x0b,\n+    0x2c, 0x04,\n+    0x1a, 0x06,\n+    0x0b, 0x03,\n+    0x80, 0xac, 0x06,\n+    0x0a, 0x06,\n+    0x1f, 0x41,\n+    0x4c, 0x04,\n+    0x2d, 0x03,\n+    0x74, 0x08,\n+    0x3c, 0x03,\n+    0x0f, 0x03,\n+    0x3c, 0x37,\n+    0x08, 0x08,\n+    0x2a, 0x06,\n+    0x80, 0xf6, 0x05,\n+    0x82, 0x04, 0x11,\n+    0x18, 0x08,\n+    0x2f, 0x11,\n+    0x2d, 0x03,\n+    0x1f, 0x11,\n+    0x21, 0x0f,\n+    0x80, 0x8c, 0x04,\n+    0x82, 0x97, 0x19,\n+    0x0b, 0x15,\n+    0x87, 0x5a, 0x03,\n+    0x15, 0x1a,\n+    0x04, 0x10,\n+    0x80, 0xf4, 0x05,\n+    0x2f, 0x05,\n+    0x3b, 0x07,\n+    0x02, 0x0e,\n+    0x18, 0x09,\n+    0x80, 0xa5, 0x3b,\n+    0x74, 0x0c,\n+    0x80, 0xd6, 0x1a,\n+    0x0c, 0x05,\n+    0x80, 0xff, 0x05,\n+    0x29, 0x03,\n+    0x80, 0x8a, 0x05,\n+    0x24, 0x0c,\n+    0x9b, 0xc6, 0x0a,\n+    0xd2, 0x16, 0x2a,\n+    0x84, 0x8d, 0x03,\n+    0x37, 0x09,\n+    0x81, 0x5c, 0x14,\n+    0x80, 0xb8, 0x08,\n+    0x80, 0xb8, 0x3f,\n+    0x35, 0x04,\n+    0x0a, 0x06,\n+    0x38, 0x08,\n+    0x46, 0x08,\n+    0x0c, 0x06,\n+    0x74, 0x0b,\n+    0x1e, 0x03,\n+    0x5a, 0x04,\n+    0x59, 0x09,\n+    0x80, 0x83, 0x18,\n+    0x1c, 0x0a,\n+    0x16, 0x09,\n+    0x46, 0x0a,\n+    0x80, 0x8a, 0x06,\n+    0xab, 0xa4, 0x0c,\n+    0x17, 0x04,\n+    0x31, 0xa1, 0x04,\n+    0x81, 0xda, 0x26,\n+    0x07, 0x0c,\n+    0x05, 0x05,\n+    0x80, 0xa5, 0x11,\n+    0x81, 0x6d, 0x10,\n+    0x78, 0x28,\n+    0x2a, 0x06,\n+    0x4c, 0x04,\n+    0x80, 0x8d, 0x04,\n+    0x80, 0xbe, 0x03,\n+    0x1b, 0x03,\n+    0x0f, 0x0d,\n+];\n+const NORMAL1: &'static [u8] = &[\n+    0x5e, 0x22,\n+    0x7b, 0x05,\n+    0x03, 0x04,\n+    0x2d, 0x03,\n+    0x65, 0x04,\n+    0x01, 0x2f,\n+    0x2e, 0x80, 0x82,\n+    0x1d, 0x03,\n+    0x31, 0x0f,\n+    0x1c, 0x04,\n+    0x24, 0x0c,\n+    0x1b, 0x05,\n+    0x2b, 0x05,\n+    0x44, 0x04,\n+    0x0e, 0x2a,\n+    0x80, 0xaa, 0x06,\n+    0x24, 0x04,\n+    0x24, 0x04,\n+    0x28, 0x08,\n+    0x34, 0x0b,\n+    0x01, 0x80, 0x90,\n+    0x81, 0x37, 0x09,\n+    0x16, 0x0a,\n+    0x08, 0x80, 0x98,\n+    0x39, 0x03,\n+    0x63, 0x08,\n+    0x09, 0x30,\n+    0x16, 0x05,\n+    0x21, 0x03,\n+    0x1b, 0x05,\n+    0x01, 0x40,\n+    0x38, 0x04,\n+    0x4b, 0x05,\n+    0x28, 0x04,\n+    0x03, 0x04,\n+    0x09, 0x08,\n+    0x09, 0x07,\n+    0x40, 0x20,\n+    0x27, 0x04,\n+    0x0c, 0x09,\n+    0x36, 0x03,\n+    0x3a, 0x05,\n+    0x1a, 0x07,\n+    0x04, 0x0c,\n+    0x07, 0x50,\n+    0x49, 0x37,\n+    0x33, 0x0d,\n+    0x33, 0x07,\n+    0x06, 0x81, 0x60,\n+    0x1f, 0x81, 0x81,\n+    0x4e, 0x04,\n+    0x1e, 0x0f,\n+    0x43, 0x0e,\n+    0x19, 0x07,\n+    0x0a, 0x06,\n+    0x44, 0x0c,\n+    0x27, 0x09,\n+    0x75, 0x0b,\n+    0x3f, 0x41,\n+    0x2a, 0x06,\n+    0x3b, 0x05,\n+    0x0a, 0x06,\n+    0x51, 0x06,\n+    0x01, 0x05,\n+    0x10, 0x03,\n+    0x05, 0x80, 0x8b,\n+    0x5e, 0x22,\n+    0x48, 0x08,\n+    0x0a, 0x80, 0xa6,\n     0x5e, 0x22,\n-    0xfb, 0x5,\n-    0x103, 0x4,\n-    0x134, 0x3,\n-    0x19c, 0x4,\n-    0x1a1, 0x2f,\n-    0x1fe, 0x82,\n-    0x29d, 0x3,\n-    0x2d1, 0xf,\n-    0x2fc, 0x4,\n-    0x324, 0xc,\n-    0x34b, 0x5,\n-    0x37b, 0x5,\n-    0x3c4, 0x4,\n-    0x3d6, 0x2a,\n-    0x4aa, 0x6,\n-    0x4d4, 0x4,\n-    0x4fc, 0x4,\n-    0x528, 0x8,\n-    0x564, 0xb,\n-    0x570, 0x90,\n-    0x737, 0x9,\n-    0x756, 0xa,\n-    0x768, 0x98,\n-    0x839, 0x3,\n-    0x89f, 0x8,\n-    0x8b0, 0x30,\n-    0x8f6, 0x5,\n-    0x91c, 0x3,\n-    0x93a, 0x5,\n-    0x940, 0x40,\n-    0x9b8, 0x4,\n-    0xa07, 0x5,\n-    0xa34, 0x4,\n-    0xa3b, 0x4,\n-    0xa48, 0x8,\n-    0xa59, 0x7,\n-    0xaa0, 0x20,\n-    0xae7, 0x4,\n-    0xaf7, 0x9,\n-    0xb36, 0x3,\n-    0xb73, 0x5,\n-    0xb92, 0x7,\n-    0xb9d, 0xc,\n-    0xbb0, 0x50,\n-    0xc49, 0x37,\n-    0xcb3, 0xd,\n-    0xcf3, 0x7,\n-    0xd00, 0x160,\n-    0xe7f, 0x181,\n-    0x104e, 0x4,\n-    0x1070, 0xf,\n-    0x10c2, 0xe,\n-    0x10e9, 0x7,\n-    0x10fa, 0x6,\n-    0x1144, 0xc,\n-    0x1177, 0x9,\n-    0x11f5, 0xb,\n-    0x123f, 0x41,\n-    0x12aa, 0x6,\n-    0x12eb, 0x5,\n-    0x12fa, 0x6,\n-    0x1351, 0x6,\n-    0x1358, 0x5,\n-    0x136d, 0x3,\n-    0x1375, 0x8b,\n-    0x145e, 0x22,\n-    0x14c8, 0x8,\n-    0x14da, 0xa6,\n-    0x15de, 0x22,\n-    0x1645, 0xb,\n-    0x165a, 0x6,\n-    0x166d, 0x13,\n-    0x16b8, 0x8,\n-    0x16ca, 0x36,\n-    0x171a, 0x3,\n-    0x172c, 0x4,\n-    0x1740, 0x160,\n-    0x18f3, 0xc,\n-    0x1900, 0x1c0,\n-    0x1af9, 0x107,\n-    0x1c46, 0xa,\n-    0x1c6d, 0x3,\n-    0x1cb7, 0x349,\n-    0x239a, 0x66,\n-    0x2475, 0xb,\n-    0x2544, 0xabc,\n-    0x342f, 0xfd1,\n-    0x4647, 0x21b9,\n-    0x6a39, 0x7,\n-    0x6a6a, 0x4,\n-    0x6a70, 0x60,\n-    0x6af6, 0xa,\n-    0x6b46, 0xa,\n-    0x6b78, 0x5,\n-    0x6b90, 0x370,\n-    0x6f45, 0xb,\n-    0x6f7f, 0x10,\n-    0x6fa0, 0x40,\n-    0x6fe1, 0x1f,\n-    0x87ed, 0x13,\n-    0x8af3, 0x250d,\n-    0xb002, 0xbfe,\n-    0xbc6b, 0x5,\n-    0xbc7d, 0x3,\n-    0xbc89, 0x7,\n-    0xbca0, 0x1360,\n-    0xd0f6, 0xa,\n-    0xd173, 0x8,\n-    0xd1e9, 0x17,\n-    0xd246, 0xba,\n-    0xd357, 0x9,\n-    0xd372, 0x8e,\n-    0xd547, 0x3,\n-    0xda8c, 0xf,\n-    0xdab0, 0x550,\n-    0xe02b, 0x7d5,\n-    0xe8d7, 0x29,\n-    0xe94b, 0x5,\n-    0xe95a, 0x4,\n-    0xe960, 0x4a0,\n-    0xee3c, 0x6,\n-    0xee43, 0x4,\n-    0xee9c, 0x5,\n-    0xeebc, 0x34,\n-    0xeef2, 0x10e,\n-    0xf02c, 0x4,\n-    0xf094, 0xc,\n-    0xf0f6, 0xa,\n-    0xf10d, 0x3,\n-    0xf16c, 0x4,\n-    0xf1ad, 0x39,\n-    0xf203, 0xd,\n-    0xf23c, 0x4,\n-    0xf249, 0x7,\n-    0xf252, 0xae,\n-    0xf6d3, 0xd,\n-    0xf6ed, 0x3,\n-    0xf6f7, 0x9,\n-    0xf774, 0xc,\n-    0xf7d5, 0x2b,\n-    0xf80c, 0x4,\n-    0xf848, 0x8,\n-    0xf85a, 0x6,\n-    0xf888, 0x8,\n-    0xf8ae, 0x62,\n-    0xf928, 0x8,\n-    0xf94c, 0x4,\n-    0xf95f, 0x21,\n-    0xf992, 0x2e,\n-    0xf9c1, 0x63f,\n+    0x45, 0x0b,\n+    0x0a, 0x06,\n+    0x0d, 0x13,\n+    0x38, 0x08,\n+    0x0a, 0x36,\n+    0x1a, 0x03,\n+    0x0f, 0x04,\n+    0x10, 0x81, 0x60,\n+    0x53, 0x0c,\n+    0x01, 0x81, 0xc0,\n+    0x39, 0x81, 0x07,\n+    0x46, 0x0a,\n+    0x1d, 0x03,\n+    0x47, 0x83, 0x49,\n+    0x83, 0x9a, 0x66,\n+    0x75, 0x0b,\n+    0x80, 0xc4, 0x8a, 0xbc,\n+    0x84, 0x2f, 0x8f, 0xd1,\n+    0x82, 0x47, 0xa1, 0xb9,\n+    0x82, 0x39, 0x07,\n+    0x2a, 0x04,\n+    0x02, 0x60,\n+    0x26, 0x0a,\n+    0x46, 0x0a,\n+    0x28, 0x05,\n+    0x13, 0x83, 0x70,\n+    0x45, 0x0b,\n+    0x2f, 0x10,\n+    0x11, 0x40,\n+    0x01, 0x1f,\n+    0x97, 0xed, 0x13,\n+    0x82, 0xf3, 0xa5, 0x0d,\n+    0x02, 0x8b, 0xfe,\n+    0x6b, 0x05,\n+    0x0d, 0x03,\n+    0x09, 0x07,\n+    0x10, 0x93, 0x60,\n+    0x80, 0xf6, 0x0a,\n+    0x73, 0x08,\n+    0x6e, 0x17,\n+    0x46, 0x80, 0xba,\n+    0x57, 0x09,\n+    0x12, 0x80, 0x8e,\n+    0x81, 0x47, 0x03,\n+    0x85, 0x42, 0x0f,\n+    0x15, 0x85, 0x50,\n+    0x2b, 0x87, 0xd5,\n+    0x80, 0xd7, 0x29,\n+    0x4b, 0x05,\n+    0x0a, 0x04,\n+    0x02, 0x84, 0xa0,\n+    0x3c, 0x06,\n+    0x01, 0x04,\n+    0x55, 0x05,\n+    0x1b, 0x34,\n+    0x02, 0x81, 0x0e,\n+    0x2c, 0x04,\n+    0x64, 0x0c,\n+    0x56, 0x0a,\n+    0x0d, 0x03,\n+    0x5c, 0x04,\n+    0x3d, 0x39,\n+    0x1d, 0x0d,\n+    0x2c, 0x04,\n+    0x09, 0x07,\n+    0x02, 0x80, 0xae,\n+    0x83, 0xd3, 0x0d,\n+    0x0d, 0x03,\n+    0x07, 0x09,\n+    0x74, 0x0c,\n+    0x55, 0x2b,\n+    0x0c, 0x04,\n+    0x38, 0x08,\n+    0x0a, 0x06,\n+    0x28, 0x08,\n+    0x1e, 0x62,\n+    0x18, 0x08,\n+    0x1c, 0x04,\n+    0x0f, 0x21,\n+    0x12, 0x2e,\n+    0x01, 0x86, 0x3f,\n ];"}, {"sha": "273f9d0e6f6d31cf9581cbafb0fde73d7f569f96", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -358,12 +358,24 @@ impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     fn next(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next_back() }\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+\n+    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n+        where P: FnMut(&Self::Item) -> bool\n+    {\n+        self.iter.rfind(predicate)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n+\n+    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n+        where P: FnMut(&Self::Item) -> bool\n+    {\n+        self.iter.find(predicate)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "798dda199281310a58c3740c084803a41fa37a5e", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -467,7 +467,7 @@ pub trait DoubleEndedIterator: Iterator {\n         Self: Sized,\n         P: FnMut(&Self::Item) -> bool\n     {\n-        for x in self.by_ref().rev() {\n+        while let Some(x) = self.next_back() {\n             if predicate(&x) { return Some(x) }\n         }\n         None"}, {"sha": "04480fc5d31da2e53d5479850fbf0ce9a560fcdb", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -500,6 +500,44 @@ impl<T: ?Sized> *const T {\n             intrinsics::arith_offset(self, count)\n         }\n     }\n+\n+    /// Calculates the distance between two pointers. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// If the address different between the two pointers ia not a multiple of\n+    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n+    /// zero.\n+    ///\n+    /// This function returns `None` if `T` is a zero-sized typed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(offset_to)]\n+    ///\n+    /// fn main() {\n+    ///     let a = [0; 5];\n+    ///     let ptr1: *const i32 = &a[1];\n+    ///     let ptr2: *const i32 = &a[3];\n+    ///     assert_eq!(ptr1.offset_to(ptr2), Some(2));\n+    ///     assert_eq!(ptr2.offset_to(ptr1), Some(-2));\n+    ///     assert_eq!(unsafe { ptr1.offset(2) }, ptr2);\n+    ///     assert_eq!(unsafe { ptr2.offset(-2) }, ptr1);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"offset_to\", issue = \"41079\")]\n+    #[inline]\n+    pub fn offset_to(self, other: *const T) -> Option<isize> where T: Sized {\n+        let size = mem::size_of::<T>();\n+        if size == 0 {\n+            None\n+        } else {\n+            let diff = (other as isize).wrapping_sub(self as isize);\n+            Some(diff / size as isize)\n+        }\n+    }\n }\n \n #[lang = \"mut_ptr\"]\n@@ -653,6 +691,44 @@ impl<T: ?Sized> *mut T {\n             Some(&mut *self)\n         }\n     }\n+\n+    /// Calculates the distance between two pointers. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// If the address different between the two pointers ia not a multiple of\n+    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n+    /// zero.\n+    ///\n+    /// This function returns `None` if `T` is a zero-sized typed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(offset_to)]\n+    ///\n+    /// fn main() {\n+    ///     let mut a = [0; 5];\n+    ///     let ptr1: *mut i32 = &mut a[1];\n+    ///     let ptr2: *mut i32 = &mut a[3];\n+    ///     assert_eq!(ptr1.offset_to(ptr2), Some(2));\n+    ///     assert_eq!(ptr2.offset_to(ptr1), Some(-2));\n+    ///     assert_eq!(unsafe { ptr1.offset(2) }, ptr2);\n+    ///     assert_eq!(unsafe { ptr2.offset(-2) }, ptr1);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"offset_to\", issue = \"41079\")]\n+    #[inline]\n+    pub fn offset_to(self, other: *const T) -> Option<isize> where T: Sized {\n+        let size = mem::size_of::<T>();\n+        if size == 0 {\n+            None\n+        } else {\n+            let diff = (other as isize).wrapping_sub(self as isize);\n+            Some(diff / size as isize)\n+        }\n+    }\n }\n \n // Equality for pointers"}, {"sha": "6d598677c9ba4f0cad90dc5bf1458d1d94433f58", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 152, "deletions": 20, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -81,6 +81,10 @@ pub trait SliceExt {\n     fn split<P>(&self, pred: P) -> Split<Self::Item, P>\n         where P: FnMut(&Self::Item) -> bool;\n \n+    #[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+    fn rsplit<P>(&self, pred: P) -> RSplit<Self::Item, P>\n+        where P: FnMut(&Self::Item) -> bool;\n+\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn splitn<P>(&self, n: usize, pred: P) -> SplitN<Self::Item, P>\n         where P: FnMut(&Self::Item) -> bool;\n@@ -159,6 +163,10 @@ pub trait SliceExt {\n     fn split_mut<P>(&mut self, pred: P) -> SplitMut<Self::Item, P>\n         where P: FnMut(&Self::Item) -> bool;\n \n+    #[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+    fn rsplit_mut<P>(&mut self, pred: P) -> RSplitMut<Self::Item, P>\n+        where P: FnMut(&Self::Item) -> bool;\n+\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn splitn_mut<P>(&mut self, n: usize, pred: P) -> SplitNMut<Self::Item, P>\n         where P: FnMut(&Self::Item) -> bool;\n@@ -293,15 +301,21 @@ impl<T> SliceExt for [T] {\n         }\n     }\n \n+    #[inline]\n+    fn rsplit<P>(&self, pred: P) -> RSplit<T, P>\n+        where P: FnMut(&T) -> bool\n+    {\n+        RSplit { inner: self.split(pred) }\n+    }\n+\n     #[inline]\n     fn splitn<P>(&self, n: usize, pred: P) -> SplitN<T, P>\n         where P: FnMut(&T) -> bool\n     {\n         SplitN {\n             inner: GenericSplitN {\n                 iter: self.split(pred),\n-                count: n,\n-                invert: false\n+                count: n\n             }\n         }\n     }\n@@ -312,9 +326,8 @@ impl<T> SliceExt for [T] {\n     {\n         RSplitN {\n             inner: GenericSplitN {\n-                iter: self.split(pred),\n-                count: n,\n-                invert: true\n+                iter: self.rsplit(pred),\n+                count: n\n             }\n         }\n     }\n@@ -475,15 +488,21 @@ impl<T> SliceExt for [T] {\n         SplitMut { v: self, pred: pred, finished: false }\n     }\n \n+    #[inline]\n+    fn rsplit_mut<P>(&mut self, pred: P) -> RSplitMut<T, P>\n+        where P: FnMut(&T) -> bool\n+    {\n+        RSplitMut { inner: self.split_mut(pred) }\n+    }\n+\n     #[inline]\n     fn splitn_mut<P>(&mut self, n: usize, pred: P) -> SplitNMut<T, P>\n         where P: FnMut(&T) -> bool\n     {\n         SplitNMut {\n             inner: GenericSplitN {\n                 iter: self.split_mut(pred),\n-                count: n,\n-                invert: false\n+                count: n\n             }\n         }\n     }\n@@ -494,9 +513,8 @@ impl<T> SliceExt for [T] {\n     {\n         RSplitNMut {\n             inner: GenericSplitN {\n-                iter: self.split_mut(pred),\n-                count: n,\n-                invert: true\n+                iter: self.rsplit_mut(pred),\n+                count: n\n             }\n         }\n     }\n@@ -1498,9 +1516,10 @@ unsafe impl<'a, T> TrustedLen for IterMut<'a, T> {}\n // Return the arithmetic difference if `T` is zero size.\n #[inline(always)]\n fn ptrdistance<T>(start: *const T, end: *const T) -> usize {\n-    let diff = (end as usize).wrapping_sub(start as usize);\n-    let size = mem::size_of::<T>();\n-    diff / (if size == 0 { 1 } else { size })\n+    match start.offset_to(end) {\n+        Some(x) => x as usize,\n+        None => (end as usize).wrapping_sub(start as usize),\n+    }\n }\n \n // Extension methods for raw pointers, used by the iterators\n@@ -1735,14 +1754,130 @@ impl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P> where\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T, P> FusedIterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {}\n \n+/// An iterator over subslices separated by elements that match a predicate\n+/// function, starting from the end of the slice.\n+///\n+/// This struct is created by the [`rsplit`] method on [slices].\n+///\n+/// [`rsplit`]: ../../std/primitive.slice.html#method.rsplit\n+/// [slices]: ../../std/primitive.slice.html\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+#[derive(Clone)] // Is this correct, or does it incorrectly require `T: Clone`?\n+pub struct RSplit<'a, T:'a, P> where P: FnMut(&T) -> bool {\n+    inner: Split<'a, T, P>\n+}\n+\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T: 'a + fmt::Debug, P> fmt::Debug for RSplit<'a, T, P> where P: FnMut(&T) -> bool {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"RSplit\")\n+            .field(\"v\", &self.inner.v)\n+            .field(\"finished\", &self.inner.finished)\n+            .finish()\n+    }\n+}\n+\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T, P> Iterator for RSplit<'a, T, P> where P: FnMut(&T) -> bool {\n+    type Item = &'a [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        self.inner.next_back()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T, P> DoubleEndedIterator for RSplit<'a, T, P> where P: FnMut(&T) -> bool {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        self.inner.next()\n+    }\n+}\n+\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T, P> SplitIter for RSplit<'a, T, P> where P: FnMut(&T) -> bool {\n+    #[inline]\n+    fn finish(&mut self) -> Option<&'a [T]> {\n+        self.inner.finish()\n+    }\n+}\n+\n+//#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T, P> FusedIterator for RSplit<'a, T, P> where P: FnMut(&T) -> bool {}\n+\n+/// An iterator over the subslices of the vector which are separated\n+/// by elements that match `pred`, starting from the end of the slice.\n+///\n+/// This struct is created by the [`rsplit_mut`] method on [slices].\n+///\n+/// [`rsplit_mut`]: ../../std/primitive.slice.html#method.rsplit_mut\n+/// [slices]: ../../std/primitive.slice.html\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+pub struct RSplitMut<'a, T:'a, P> where P: FnMut(&T) -> bool {\n+    inner: SplitMut<'a, T, P>\n+}\n+\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T: 'a + fmt::Debug, P> fmt::Debug for RSplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"RSplitMut\")\n+            .field(\"v\", &self.inner.v)\n+            .field(\"finished\", &self.inner.finished)\n+            .finish()\n+    }\n+}\n+\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T, P> SplitIter for RSplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n+    #[inline]\n+    fn finish(&mut self) -> Option<&'a mut [T]> {\n+        self.inner.finish()\n+    }\n+}\n+\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T, P> Iterator for RSplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n+    type Item = &'a mut [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        self.inner.next_back()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T, P> DoubleEndedIterator for RSplitMut<'a, T, P> where\n+    P: FnMut(&T) -> bool,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        self.inner.next()\n+    }\n+}\n+\n+//#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T, P> FusedIterator for RSplitMut<'a, T, P> where P: FnMut(&T) -> bool {}\n+\n /// An private iterator over subslices separated by elements that\n /// match a predicate function, splitting at most a fixed number of\n /// times.\n #[derive(Debug)]\n struct GenericSplitN<I> {\n     iter: I,\n     count: usize,\n-    invert: bool\n }\n \n impl<T, I: SplitIter<Item=T>> Iterator for GenericSplitN<I> {\n@@ -1753,10 +1888,7 @@ impl<T, I: SplitIter<Item=T>> Iterator for GenericSplitN<I> {\n         match self.count {\n             0 => None,\n             1 => { self.count -= 1; self.iter.finish() }\n-            _ => {\n-                self.count -= 1;\n-                if self.invert {self.iter.next_back()} else {self.iter.next()}\n-            }\n+            _ => { self.count -= 1; self.iter.next() }\n         }\n     }\n \n@@ -1798,7 +1930,7 @@ impl<'a, T: 'a + fmt::Debug, P> fmt::Debug for SplitN<'a, T, P> where P: FnMut(&\n /// [slices]: ../../std/primitive.slice.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RSplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n-    inner: GenericSplitN<Split<'a, T, P>>\n+    inner: GenericSplitN<RSplit<'a, T, P>>\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n@@ -1841,7 +1973,7 @@ impl<'a, T: 'a + fmt::Debug, P> fmt::Debug for SplitNMut<'a, T, P> where P: FnMu\n /// [slices]: ../../std/primitive.slice.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RSplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n-    inner: GenericSplitN<SplitMut<'a, T, P>>\n+    inner: GenericSplitN<RSplitMut<'a, T, P>>\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]"}, {"sha": "4e5ddfb541e8913aafa28a928b7a43f91be7fa25", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -321,7 +321,7 @@ impl AtomicBool {\n         }\n     }\n \n-    /// Stores a value into the bool, returning the old value.\n+    /// Stores a value into the bool, returning the previous value.\n     ///\n     /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n     /// of this operation.\n@@ -732,7 +732,7 @@ impl<T> AtomicPtr<T> {\n         }\n     }\n \n-    /// Stores a value into the pointer, returning the old value.\n+    /// Stores a value into the pointer, returning the previous value.\n     ///\n     /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n     /// of this operation.\n@@ -1047,7 +1047,7 @@ macro_rules! atomic_int {\n                 unsafe { atomic_store(self.v.get(), val, order); }\n             }\n \n-            /// Stores a value into the atomic integer, returning the old value.\n+            /// Stores a value into the atomic integer, returning the previous value.\n             ///\n             /// `swap` takes an [`Ordering`] argument which describes the memory ordering of this\n             /// operation.\n@@ -1201,7 +1201,9 @@ macro_rules! atomic_int {\n                 }\n             }\n \n-            /// Add to the current value, returning the previous value.\n+            /// Adds to the current value, returning the previous value.\n+            ///\n+            /// This operation wraps around on overflow.\n             ///\n             /// # Examples\n             ///\n@@ -1218,7 +1220,9 @@ macro_rules! atomic_int {\n                 unsafe { atomic_add(self.v.get(), val, order) }\n             }\n \n-            /// Subtract from the current value, returning the previous value.\n+            /// Subtracts from the current value, returning the previous value.\n+            ///\n+            /// This operation wraps around on overflow.\n             ///\n             /// # Examples\n             ///\n@@ -1235,7 +1239,12 @@ macro_rules! atomic_int {\n                 unsafe { atomic_sub(self.v.get(), val, order) }\n             }\n \n-            /// Bitwise and with the current value, returning the previous value.\n+            /// Bitwise \"and\" with the current value.\n+            ///\n+            /// Performs a bitwise \"and\" operation on the current value and the argument `val`, and\n+            /// sets the new value to the result.\n+            ///\n+            /// Returns the previous value.\n             ///\n             /// # Examples\n             ///\n@@ -1251,7 +1260,12 @@ macro_rules! atomic_int {\n                 unsafe { atomic_and(self.v.get(), val, order) }\n             }\n \n-            /// Bitwise or with the current value, returning the previous value.\n+            /// Bitwise \"or\" with the current value.\n+            ///\n+            /// Performs a bitwise \"or\" operation on the current value and the argument `val`, and\n+            /// sets the new value to the result.\n+            ///\n+            /// Returns the previous value.\n             ///\n             /// # Examples\n             ///\n@@ -1267,7 +1281,12 @@ macro_rules! atomic_int {\n                 unsafe { atomic_or(self.v.get(), val, order) }\n             }\n \n-            /// Bitwise xor with the current value, returning the previous value.\n+            /// Bitwise \"xor\" with the current value.\n+            ///\n+            /// Performs a bitwise \"xor\" operation on the current value and the argument `val`, and\n+            /// sets the new value to the result.\n+            ///\n+            /// Returns the previous value.\n             ///\n             /// # Examples\n             ///\n@@ -1415,7 +1434,7 @@ unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     }\n }\n \n-/// Returns the old value (like __sync_fetch_and_add).\n+/// Returns the previous value (like __sync_fetch_and_add).\n #[inline]\n unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n@@ -1428,7 +1447,7 @@ unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     }\n }\n \n-/// Returns the old value (like __sync_fetch_and_sub).\n+/// Returns the previous value (like __sync_fetch_and_sub).\n #[inline]\n unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {"}, {"sha": "c503b8c7fe06f7bb9c58ed0fce452203e35551e0", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -25,6 +25,9 @@ impl<'tcx> CFG<'tcx> {\n         &mut self.basic_blocks[blk]\n     }\n \n+    // llvm.org/PR32488 makes this function use an excess of stack space. Mark\n+    // it as #[inline(never)] to keep rustc's stack use in check.\n+    #[inline(never)]\n     pub fn start_new_block(&mut self) -> BasicBlock {\n         self.basic_blocks.push(BasicBlockData::new(None))\n     }"}, {"sha": "33280fb931aafebb0fd7431e6fb09d69ffb20adf", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -11,7 +11,6 @@\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::lint;\n use rustc::traits::{self, Reveal};\n use rustc::ty::{self, TyCtxt};\n \n@@ -53,12 +52,16 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n \n             for &item2 in &impl_items2[..] {\n                 if (name, namespace) == name_and_namespace(item2) {\n-                    let msg = format!(\"duplicate definitions with name `{}`\", name);\n-                    let node_id = self.tcx.hir.as_local_node_id(item1).unwrap();\n-                    self.tcx.sess.add_lint(lint::builtin::OVERLAPPING_INHERENT_IMPLS,\n-                                           node_id,\n-                                           self.tcx.span_of_impl(item1).unwrap(),\n-                                           msg);\n+                    struct_span_err!(self.tcx.sess,\n+                                     self.tcx.span_of_impl(item1).unwrap(),\n+                                     E0592,\n+                                     \"duplicate definitions with name `{}`\",\n+                                     name)\n+                        .span_label(self.tcx.span_of_impl(item1).unwrap(),\n+                                    &format!(\"duplicate definitions for `{}`\", name))\n+                        .span_label(self.tcx.span_of_impl(item2).unwrap(),\n+                                    &format!(\"other definition for `{}`\", name))\n+                        .emit();\n                 }\n             }\n         }"}, {"sha": "a06299eaefe0ad47ac8068c65747bb1396fdbd5d", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -472,7 +472,7 @@ fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>)\n     }\n \n     // Now we've done all our shifting. Return the value we grabbed earlier.\n-    (retkey, retval, gap.into_bucket().into_table())\n+    (retkey, retval, gap.into_table())\n }\n \n /// Perform robin hood bucket stealing at the given `bucket`. You must\n@@ -485,14 +485,14 @@ fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n                                 mut key: K,\n                                 mut val: V)\n                                 -> FullBucketMut<'a, K, V> {\n-    let start_index = bucket.index();\n     let size = bucket.table().size();\n-    // Save the *starting point*.\n-    let mut bucket = bucket.stash();\n+    let raw_capacity = bucket.table().capacity();\n     // There can be at most `size - dib` buckets to displace, because\n     // in the worst case, there are `size` elements and we already are\n     // `displacement` buckets away from the initial one.\n-    let idx_end = start_index + size - bucket.displacement();\n+    let idx_end = (bucket.index() + size - bucket.displacement()) % raw_capacity;\n+    // Save the *starting point*.\n+    let mut bucket = bucket.stash();\n \n     loop {\n         let (old_hash, old_key, old_val) = bucket.replace(hash, key, val);\n@@ -568,11 +568,8 @@ impl<K, V, S> HashMap<K, V, S>\n     // The caller should ensure that invariants by Robin Hood Hashing hold\n     // and that there's space in the underlying table.\n     fn insert_hashed_ordered(&mut self, hash: SafeHash, k: K, v: V) {\n-        let raw_cap = self.raw_capacity();\n         let mut buckets = Bucket::new(&mut self.table, hash);\n-        // note that buckets.index() keeps increasing\n-        // even if the pointer wraps back to the first bucket.\n-        let limit_bucket = buckets.index() + raw_cap;\n+        let start_index = buckets.index();\n \n         loop {\n             // We don't need to compare hashes for value swap.\n@@ -585,7 +582,7 @@ impl<K, V, S> HashMap<K, V, S>\n                 Full(b) => b.into_bucket(),\n             };\n             buckets.next();\n-            debug_assert!(buckets.index() < limit_bucket);\n+            debug_assert!(buckets.index() != start_index);\n         }\n     }\n }\n@@ -1244,24 +1241,25 @@ impl<K, V, S> HashMap<K, V, S>\n     pub fn retain<F>(&mut self, mut f: F)\n         where F: FnMut(&K, &mut V) -> bool\n     {\n-        if self.table.capacity() == 0 || self.table.size() == 0 {\n+        if self.table.size() == 0 {\n             return;\n         }\n+        let mut elems_left = self.table.size();\n         let mut bucket = Bucket::head_bucket(&mut self.table);\n         bucket.prev();\n-        let tail = bucket.index();\n-        loop {\n+        let start_index = bucket.index();\n+        while elems_left != 0 {\n             bucket = match bucket.peek() {\n                 Full(mut full) => {\n+                    elems_left -= 1;\n                     let should_remove = {\n                         let (k, v) = full.read_mut();\n                         !f(k, v)\n                     };\n                     if should_remove {\n-                        let prev_idx = full.index();\n                         let prev_raw = full.raw();\n                         let (_, _, t) = pop_internal(full);\n-                        Bucket::new_from(prev_raw, prev_idx, t)\n+                        Bucket::new_from(prev_raw, t)\n                     } else {\n                         full.into_bucket()\n                     }\n@@ -1271,9 +1269,7 @@ impl<K, V, S> HashMap<K, V, S>\n                 }\n             };\n             bucket.prev();  // reverse iteration\n-            if bucket.index() == tail {\n-                break;\n-            }\n+            debug_assert!(elems_left == 0 || bucket.index() != start_index);\n         }\n     }\n }"}, {"sha": "9623706548b322d32c9e2a887e92cf6dbedd810d", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 151, "deletions": 173, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -113,7 +113,7 @@ impl TaggedHashUintPtr {\n /// when the RawTable is created and is accessible with the `tag` and `set_tag`\n /// functions.\n pub struct RawTable<K, V> {\n-    capacity: usize,\n+    capacity_mask: usize,\n     size: usize,\n     hashes: TaggedHashUintPtr,\n \n@@ -125,10 +125,13 @@ pub struct RawTable<K, V> {\n unsafe impl<K: Send, V: Send> Send for RawTable<K, V> {}\n unsafe impl<K: Sync, V: Sync> Sync for RawTable<K, V> {}\n \n+// An unsafe view of a RawTable bucket\n+// Valid indexes are within [0..table_capacity)\n pub struct RawBucket<K, V> {\n-    hash: *mut HashUint,\n+    hash_start: *mut HashUint,\n     // We use *const to ensure covariance with respect to K and V\n-    pair: *const (K, V),\n+    pair_start: *const (K, V),\n+    idx: usize,\n     _marker: marker::PhantomData<(K, V)>,\n }\n \n@@ -141,7 +144,6 @@ impl<K, V> Clone for RawBucket<K, V> {\n \n pub struct Bucket<K, V, M> {\n     raw: RawBucket<K, V>,\n-    idx: usize,\n     table: M,\n }\n \n@@ -154,13 +156,11 @@ impl<K, V, M: Copy> Clone for Bucket<K, V, M> {\n \n pub struct EmptyBucket<K, V, M> {\n     raw: RawBucket<K, V>,\n-    idx: usize,\n     table: M,\n }\n \n pub struct FullBucket<K, V, M> {\n     raw: RawBucket<K, V>,\n-    idx: usize,\n     table: M,\n }\n \n@@ -232,13 +232,17 @@ fn can_alias_safehash_as_hash() {\n     assert_eq!(size_of::<SafeHash>(), size_of::<HashUint>())\n }\n \n+// RawBucket methods are unsafe as it's possible to\n+// make a RawBucket point to invalid memory using safe code.\n impl<K, V> RawBucket<K, V> {\n-    unsafe fn offset(self, count: isize) -> RawBucket<K, V> {\n-        RawBucket {\n-            hash: self.hash.offset(count),\n-            pair: self.pair.offset(count),\n-            _marker: marker::PhantomData,\n-        }\n+    unsafe fn hash(&self) -> *mut HashUint {\n+        self.hash_start.offset(self.idx as isize)\n+    }\n+    unsafe fn pair(&self) -> *mut (K, V) {\n+        self.pair_start.offset(self.idx as isize) as *mut (K, V)\n+    }\n+    unsafe fn hash_pair(&self) -> (*mut HashUint, *mut (K, V)) {\n+        (self.hash(), self.pair())\n     }\n }\n \n@@ -258,7 +262,7 @@ impl<K, V, M> FullBucket<K, V, M> {\n     }\n     /// Get the raw index.\n     pub fn index(&self) -> usize {\n-        self.idx\n+        self.raw.idx\n     }\n     /// Get the raw bucket.\n     pub fn raw(&self) -> RawBucket<K, V> {\n@@ -280,7 +284,7 @@ impl<K, V, M> EmptyBucket<K, V, M> {\n impl<K, V, M> Bucket<K, V, M> {\n     /// Get the raw index.\n     pub fn index(&self) -> usize {\n-        self.idx\n+        self.raw.idx\n     }\n     /// get the table.\n     pub fn into_table(self) -> M {\n@@ -331,12 +335,11 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> Bucket<K, V, M> {\n         Bucket::at_index(table, hash.inspect() as usize)\n     }\n \n-    pub fn new_from(r: RawBucket<K, V>, i: usize, t: M)\n+    pub fn new_from(r: RawBucket<K, V>, t: M)\n         -> Bucket<K, V, M>\n     {\n         Bucket {\n             raw: r,\n-            idx: i,\n             table: t,\n         }\n     }\n@@ -346,18 +349,16 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> Bucket<K, V, M> {\n         // This is an uncommon case though, so avoid it in release builds.\n         debug_assert!(table.capacity() > 0,\n                       \"Table should have capacity at this point\");\n-        let ib_index = ib_index & (table.capacity() - 1);\n+        let ib_index = ib_index & table.capacity_mask;\n         Bucket {\n-            raw: unsafe { table.first_bucket_raw().offset(ib_index as isize) },\n-            idx: ib_index,\n+            raw: table.raw_bucket_at(ib_index),\n             table: table,\n         }\n     }\n \n     pub fn first(table: M) -> Bucket<K, V, M> {\n         Bucket {\n-            raw: table.first_bucket_raw(),\n-            idx: 0,\n+            raw: table.raw_bucket_at(0),\n             table: table,\n         }\n     }\n@@ -401,48 +402,30 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> Bucket<K, V, M> {\n     /// the appropriate types to call most of the other functions in\n     /// this module.\n     pub fn peek(self) -> BucketState<K, V, M> {\n-        match unsafe { *self.raw.hash } {\n+        match unsafe { *self.raw.hash() } {\n             EMPTY_BUCKET => {\n                 Empty(EmptyBucket {\n                     raw: self.raw,\n-                    idx: self.idx,\n                     table: self.table,\n                 })\n             }\n             _ => {\n                 Full(FullBucket {\n                     raw: self.raw,\n-                    idx: self.idx,\n                     table: self.table,\n                 })\n             }\n         }\n     }\n \n-    /// Modifies the bucket pointer in place to make it point to the next slot.\n+    /// Modifies the bucket in place to make it point to the next slot.\n     pub fn next(&mut self) {\n-        self.idx += 1;\n-        let range = self.table.capacity();\n-        // This code is branchless thanks to a conditional move.\n-        let dist = if self.idx & (range - 1) == 0 {\n-            1 - range as isize\n-        } else {\n-            1\n-        };\n-        unsafe {\n-            self.raw = self.raw.offset(dist);\n-        }\n+        self.raw.idx = self.raw.idx.wrapping_add(1) & self.table.capacity_mask;\n     }\n \n-    /// Modifies the bucket pointer in place to make it point to the previous slot.\n+    /// Modifies the bucket in place to make it point to the previous slot.\n     pub fn prev(&mut self) {\n-        let range = self.table.capacity();\n-        let new_idx = self.idx.wrapping_sub(1) & (range - 1);\n-        let dist = (new_idx as isize).wrapping_sub(self.idx as isize);\n-        self.idx = new_idx;\n-        unsafe {\n-            self.raw = self.raw.offset(dist);\n-        }\n+        self.raw.idx = self.raw.idx.wrapping_sub(1) & self.table.capacity_mask;\n     }\n }\n \n@@ -458,15 +441,13 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> EmptyBucket<K, V, M> {\n     pub fn into_bucket(self) -> Bucket<K, V, M> {\n         Bucket {\n             raw: self.raw,\n-            idx: self.idx,\n             table: self.table,\n         }\n     }\n \n     pub fn gap_peek(self) -> Result<GapThenFull<K, V, M>, Bucket<K, V, M>> {\n         let gap = EmptyBucket {\n             raw: self.raw,\n-            idx: self.idx,\n             table: (),\n         };\n \n@@ -494,31 +475,29 @@ impl<K, V, M> EmptyBucket<K, V, M>\n     /// Use `make_hash` to construct a `SafeHash` to pass to this function.\n     pub fn put(mut self, hash: SafeHash, key: K, value: V) -> FullBucket<K, V, M> {\n         unsafe {\n-            *self.raw.hash = hash.inspect();\n-            ptr::write(self.raw.pair as *mut (K, V), (key, value));\n+            *self.raw.hash() = hash.inspect();\n+            ptr::write(self.raw.pair(), (key, value));\n \n             self.table.borrow_table_mut().size += 1;\n         }\n \n         FullBucket {\n             raw: self.raw,\n-            idx: self.idx,\n             table: self.table,\n         }\n     }\n \n     /// Puts given key, remain value uninitialized.\n     /// It is only used for inplacement insertion.\n     pub unsafe fn put_key(mut self, hash: SafeHash, key: K) -> FullBucket<K, V, M> {\n-        *self.raw.hash = hash.inspect();\n-        let pair_mut = self.raw.pair as *mut (K, V);\n-        ptr::write(&mut (*pair_mut).0, key);\n+        *self.raw.hash() = hash.inspect();\n+        let pair_ptr = self.raw.pair();\n+        ptr::write(&mut (*pair_ptr).0, key);\n \n         self.table.borrow_table_mut().size += 1;\n \n         FullBucket {\n             raw: self.raw,\n-            idx: self.idx,\n             table: self.table,\n         }\n     }\n@@ -536,7 +515,6 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> FullBucket<K, V, M> {\n     pub fn into_bucket(self) -> Bucket<K, V, M> {\n         Bucket {\n             raw: self.raw,\n-            idx: self.idx,\n             table: self.table,\n         }\n     }\n@@ -546,7 +524,6 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> FullBucket<K, V, M> {\n     pub fn stash(self) -> FullBucket<K, V, Self> {\n         FullBucket {\n             raw: self.raw,\n-            idx: self.idx,\n             table: self,\n         }\n     }\n@@ -560,17 +537,20 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> FullBucket<K, V, M> {\n         // Calculates the distance one has to travel when going from\n         // `hash mod capacity` onwards to `idx mod capacity`, wrapping around\n         // if the destination is not reached before the end of the table.\n-        (self.idx.wrapping_sub(self.hash().inspect() as usize)) & (self.table.capacity() - 1)\n+        (self.raw.idx.wrapping_sub(self.hash().inspect() as usize)) & self.table.capacity_mask\n     }\n \n     #[inline]\n     pub fn hash(&self) -> SafeHash {\n-        unsafe { SafeHash { hash: *self.raw.hash } }\n+        unsafe { SafeHash { hash: *self.raw.hash() } }\n     }\n \n     /// Gets references to the key and value at a given index.\n     pub fn read(&self) -> (&K, &V) {\n-        unsafe { (&(*self.raw.pair).0, &(*self.raw.pair).1) }\n+        unsafe {\n+            let pair_ptr = self.raw.pair();\n+            (&(*pair_ptr).0, &(*pair_ptr).1)\n+        }\n     }\n }\n \n@@ -586,11 +566,10 @@ impl<'t, K, V> FullBucket<K, V, &'t mut RawTable<K, V>> {\n         self.table.size -= 1;\n \n         unsafe {\n-            *self.raw.hash = EMPTY_BUCKET;\n-            let (k, v) = ptr::read(self.raw.pair);\n+            *self.raw.hash() = EMPTY_BUCKET;\n+            let (k, v) = ptr::read(self.raw.pair());\n             (EmptyBucket {\n                  raw: self.raw,\n-                 idx: self.idx,\n                  table: self.table,\n              },\n             k,\n@@ -604,9 +583,9 @@ impl<'t, K, V> FullBucket<K, V, &'t mut RawTable<K, V>> {\n     pub unsafe fn remove_key(&mut self) {\n         self.table.size -= 1;\n \n-        *self.raw.hash = EMPTY_BUCKET;\n-        let pair_mut = self.raw.pair as *mut (K, V);\n-        ptr::drop_in_place(&mut (*pair_mut).0); // only drop key\n+        *self.raw.hash() = EMPTY_BUCKET;\n+        let pair_ptr = self.raw.pair();\n+        ptr::drop_in_place(&mut (*pair_ptr).0); // only drop key\n     }\n }\n \n@@ -617,8 +596,8 @@ impl<K, V, M> FullBucket<K, V, M>\n {\n     pub fn replace(&mut self, h: SafeHash, k: K, v: V) -> (SafeHash, K, V) {\n         unsafe {\n-            let old_hash = ptr::replace(self.raw.hash as *mut SafeHash, h);\n-            let (old_key, old_val) = ptr::replace(self.raw.pair as *mut (K, V), (k, v));\n+            let old_hash = ptr::replace(self.raw.hash() as *mut SafeHash, h);\n+            let (old_key, old_val) = ptr::replace(self.raw.pair(), (k, v));\n \n             (old_hash, old_key, old_val)\n         }\n@@ -630,8 +609,10 @@ impl<K, V, M> FullBucket<K, V, M>\n {\n     /// Gets mutable references to the key and value at a given index.\n     pub fn read_mut(&mut self) -> (&mut K, &mut V) {\n-        let pair_mut = self.raw.pair as *mut (K, V);\n-        unsafe { (&mut (*pair_mut).0, &mut (*pair_mut).1) }\n+        unsafe {\n+            let pair_ptr = self.raw.pair();\n+            (&mut (*pair_ptr).0, &mut (*pair_ptr).1)\n+        }\n     }\n }\n \n@@ -644,7 +625,10 @@ impl<'t, K, V, M> FullBucket<K, V, M>\n     /// in exchange for this, the returned references have a longer lifetime\n     /// than the references returned by `read()`.\n     pub fn into_refs(self) -> (&'t K, &'t V) {\n-        unsafe { (&(*self.raw.pair).0, &(*self.raw.pair).1) }\n+        unsafe {\n+            let pair_ptr = self.raw.pair();\n+            (&(*pair_ptr).0, &(*pair_ptr).1)\n+        }\n     }\n }\n \n@@ -654,8 +638,10 @@ impl<'t, K, V, M> FullBucket<K, V, M>\n     /// This works similarly to `into_refs`, exchanging a bucket state\n     /// for mutable references into the table.\n     pub fn into_mut_refs(self) -> (&'t mut K, &'t mut V) {\n-        let pair_mut = self.raw.pair as *mut (K, V);\n-        unsafe { (&mut (*pair_mut).0, &mut (*pair_mut).1) }\n+        unsafe {\n+            let pair_ptr = self.raw.pair();\n+            (&mut (*pair_ptr).0, &mut (*pair_ptr).1)\n+        }\n     }\n }\n \n@@ -667,22 +653,23 @@ impl<K, V, M> GapThenFull<K, V, M>\n         &self.full\n     }\n \n-    pub fn into_bucket(self) -> Bucket<K, V, M> {\n-        self.full.into_bucket()\n+    pub fn into_table(self) -> M {\n+        self.full.into_table()\n     }\n \n     pub fn shift(mut self) -> Result<GapThenFull<K, V, M>, Bucket<K, V, M>> {\n         unsafe {\n-            *self.gap.raw.hash = mem::replace(&mut *self.full.raw.hash, EMPTY_BUCKET);\n-            ptr::copy_nonoverlapping(self.full.raw.pair, self.gap.raw.pair as *mut (K, V), 1);\n+            let (gap_hash, gap_pair) = self.gap.raw.hash_pair();\n+            let (full_hash, full_pair) = self.full.raw.hash_pair();\n+            *gap_hash = mem::replace(&mut *full_hash, EMPTY_BUCKET);\n+            ptr::copy_nonoverlapping(full_pair, gap_pair, 1);\n         }\n \n-        let FullBucket { raw: prev_raw, idx: prev_idx, .. } = self.full;\n+        let FullBucket { raw: prev_raw, .. } = self.full;\n \n         match self.full.next().peek() {\n             Full(bucket) => {\n                 self.gap.raw = prev_raw;\n-                self.gap.idx = prev_idx;\n \n                 self.full = bucket;\n \n@@ -761,7 +748,7 @@ impl<K, V> RawTable<K, V> {\n         if capacity == 0 {\n             return RawTable {\n                 size: 0,\n-                capacity: 0,\n+                capacity_mask: capacity.wrapping_sub(1),\n                 hashes: TaggedHashUintPtr::new(EMPTY as *mut HashUint),\n                 marker: marker::PhantomData,\n             };\n@@ -801,25 +788,27 @@ impl<K, V> RawTable<K, V> {\n         let hashes = buffer.offset(hash_offset as isize) as *mut HashUint;\n \n         RawTable {\n-            capacity: capacity,\n+            capacity_mask: capacity.wrapping_sub(1),\n             size: 0,\n             hashes: TaggedHashUintPtr::new(hashes),\n             marker: marker::PhantomData,\n         }\n     }\n \n-    fn first_bucket_raw(&self) -> RawBucket<K, V> {\n-        let hashes_size = self.capacity * size_of::<HashUint>();\n-        let pairs_size = self.capacity * size_of::<(K, V)>();\n+    fn raw_bucket_at(&self, index: usize) -> RawBucket<K, V> {\n+        let hashes_size = self.capacity() * size_of::<HashUint>();\n+        let pairs_size = self.capacity() * size_of::<(K, V)>();\n \n-        let buffer = self.hashes.ptr() as *mut u8;\n         let (pairs_offset, _, oflo) =\n             calculate_offsets(hashes_size, pairs_size, align_of::<(K, V)>());\n         debug_assert!(!oflo, \"capacity overflow\");\n+\n+        let buffer = self.hashes.ptr() as *mut u8;\n         unsafe {\n             RawBucket {\n-                hash: self.hashes.ptr(),\n-                pair: buffer.offset(pairs_offset as isize) as *const _,\n+                hash_start: buffer as *mut HashUint,\n+                pair_start: buffer.offset(pairs_offset as isize) as *const (K, V),\n+                idx: index,\n                 _marker: marker::PhantomData,\n             }\n         }\n@@ -837,7 +826,7 @@ impl<K, V> RawTable<K, V> {\n \n     /// The hashtable's capacity, similar to a vector's.\n     pub fn capacity(&self) -> usize {\n-        self.capacity\n+        self.capacity_mask.wrapping_add(1)\n     }\n \n     /// The number of elements ever `put` in the hashtable, minus the number\n@@ -848,47 +837,45 @@ impl<K, V> RawTable<K, V> {\n \n     fn raw_buckets(&self) -> RawBuckets<K, V> {\n         RawBuckets {\n-            raw: self.first_bucket_raw(),\n-            hashes_end: unsafe { self.hashes.ptr().offset(self.capacity as isize) },\n+            raw: self.raw_bucket_at(0),\n+            elems_left: self.size,\n             marker: marker::PhantomData,\n         }\n     }\n \n     pub fn iter(&self) -> Iter<K, V> {\n         Iter {\n             iter: self.raw_buckets(),\n-            elems_left: self.size(),\n         }\n     }\n \n     pub fn iter_mut(&mut self) -> IterMut<K, V> {\n         IterMut {\n             iter: self.raw_buckets(),\n-            elems_left: self.size(),\n             _marker: marker::PhantomData,\n         }\n     }\n \n     pub fn into_iter(self) -> IntoIter<K, V> {\n-        let RawBuckets { raw, hashes_end, .. } = self.raw_buckets();\n+        let RawBuckets { raw, elems_left, .. } = self.raw_buckets();\n         // Replace the marker regardless of lifetime bounds on parameters.\n         IntoIter {\n             iter: RawBuckets {\n                 raw: raw,\n-                hashes_end: hashes_end,\n+                elems_left: elems_left,\n                 marker: marker::PhantomData,\n             },\n             table: self,\n         }\n     }\n \n     pub fn drain(&mut self) -> Drain<K, V> {\n-        let RawBuckets { raw, hashes_end, .. } = self.raw_buckets();\n+        let RawBuckets { raw, elems_left, .. } = self.raw_buckets();\n         // Replace the marker regardless of lifetime bounds on parameters.\n         Drain {\n             iter: RawBuckets {\n                 raw: raw,\n-                hashes_end: hashes_end,\n+                elems_left: elems_left,\n                 marker: marker::PhantomData,\n             },\n             table: unsafe { Shared::new(self) },\n@@ -900,18 +887,16 @@ impl<K, V> RawTable<K, V> {\n     /// state and should only be used for dropping the table's remaining\n     /// entries. It's used in the implementation of Drop.\n     unsafe fn rev_drop_buckets(&mut self) {\n-        let first_raw = self.first_bucket_raw();\n-        let mut raw = first_raw.offset(self.capacity as isize);\n+        // initialize the raw bucket past the end of the table\n+        let mut raw = self.raw_bucket_at(self.capacity());\n         let mut elems_left = self.size;\n \n         while elems_left != 0 {\n-            debug_assert!(raw.hash != first_raw.hash);\n+            raw.idx -= 1;\n \n-            raw = raw.offset(-1);\n-\n-            if *raw.hash != EMPTY_BUCKET {\n+            if *raw.hash() != EMPTY_BUCKET {\n                 elems_left -= 1;\n-                ptr::drop_in_place(raw.pair as *mut (K, V));\n+                ptr::drop_in_place(raw.pair());\n             }\n         }\n     }\n@@ -931,7 +916,7 @@ impl<K, V> RawTable<K, V> {\n /// this interface is safe, it's not used outside this module.\n struct RawBuckets<'a, K, V> {\n     raw: RawBucket<K, V>,\n-    hashes_end: *mut HashUint,\n+    elems_left: usize,\n \n     // Strictly speaking, this should be &'a (K,V), but that would\n     // require that K:'a, and we often use RawBuckets<'static...> for\n@@ -946,7 +931,7 @@ impl<'a, K, V> Clone for RawBuckets<'a, K, V> {\n     fn clone(&self) -> RawBuckets<'a, K, V> {\n         RawBuckets {\n             raw: self.raw,\n-            hashes_end: self.hashes_end,\n+            elems_left: self.elems_left,\n             marker: marker::PhantomData,\n         }\n     }\n@@ -957,25 +942,36 @@ impl<'a, K, V> Iterator for RawBuckets<'a, K, V> {\n     type Item = RawBucket<K, V>;\n \n     fn next(&mut self) -> Option<RawBucket<K, V>> {\n-        while self.raw.hash != self.hashes_end {\n+        if self.elems_left == 0 {\n+            return None;\n+        }\n+\n+        loop {\n             unsafe {\n-                // We are swapping out the pointer to a bucket and replacing\n-                // it with the pointer to the next one.\n-                let prev = ptr::replace(&mut self.raw, self.raw.offset(1));\n-                if *prev.hash != EMPTY_BUCKET {\n-                    return Some(prev);\n+                let item = self.raw;\n+                self.raw.idx += 1;\n+                if *item.hash() != EMPTY_BUCKET {\n+                    self.elems_left -= 1;\n+                    return Some(item);\n                 }\n             }\n         }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (self.elems_left, Some(self.elems_left))\n+    }\n+}\n \n-        None\n+impl<'a, K, V> ExactSizeIterator for RawBuckets<'a, K, V> {\n+    fn len(&self) -> usize {\n+        self.elems_left\n     }\n }\n \n /// Iterator over shared references to entries in a table.\n pub struct Iter<'a, K: 'a, V: 'a> {\n     iter: RawBuckets<'a, K, V>,\n-    elems_left: usize,\n }\n \n unsafe impl<'a, K: Sync, V: Sync> Sync for Iter<'a, K, V> {}\n@@ -986,16 +982,13 @@ impl<'a, K, V> Clone for Iter<'a, K, V> {\n     fn clone(&self) -> Iter<'a, K, V> {\n         Iter {\n             iter: self.iter.clone(),\n-            elems_left: self.elems_left,\n         }\n     }\n }\n \n-\n /// Iterator over mutable references to entries in a table.\n pub struct IterMut<'a, K: 'a, V: 'a> {\n     iter: RawBuckets<'a, K, V>,\n-    elems_left: usize,\n     // To ensure invariance with respect to V\n     _marker: marker::PhantomData<&'a mut V>,\n }\n@@ -1009,7 +1002,6 @@ impl<'a, K: 'a, V: 'a> IterMut<'a, K, V> {\n     pub fn iter(&self) -> Iter<K, V> {\n         Iter {\n             iter: self.iter.clone(),\n-            elems_left: self.elems_left,\n         }\n     }\n }\n@@ -1027,7 +1019,6 @@ impl<K, V> IntoIter<K, V> {\n     pub fn iter(&self) -> Iter<K, V> {\n         Iter {\n             iter: self.iter.clone(),\n-            elems_left: self.table.size,\n         }\n     }\n }\n@@ -1044,11 +1035,8 @@ unsafe impl<'a, K: Send, V: Send> Send for Drain<'a, K, V> {}\n \n impl<'a, K, V> Drain<'a, K, V> {\n     pub fn iter(&self) -> Iter<K, V> {\n-        unsafe {\n-            Iter {\n-                iter: self.iter.clone(),\n-                elems_left: (**self.table).size,\n-            }\n+        Iter {\n+            iter: self.iter.clone(),\n         }\n     }\n }\n@@ -1057,64 +1045,65 @@ impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a V)> {\n-        self.iter.next().map(|bucket| {\n-            self.elems_left -= 1;\n-            unsafe { (&(*bucket.pair).0, &(*bucket.pair).1) }\n+        self.iter.next().map(|raw| unsafe {\n+            let pair_ptr = raw.pair();\n+            (&(*pair_ptr).0, &(*pair_ptr).1)\n         })\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (self.elems_left, Some(self.elems_left))\n+        self.iter.size_hint()\n     }\n }\n+\n impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {\n     fn len(&self) -> usize {\n-        self.elems_left\n+        self.iter.len()\n     }\n }\n \n impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        self.iter.next().map(|bucket| {\n-            self.elems_left -= 1;\n-            let pair_mut = bucket.pair as *mut (K, V);\n-            unsafe { (&(*pair_mut).0, &mut (*pair_mut).1) }\n+        self.iter.next().map(|raw| unsafe {\n+            let pair_ptr = raw.pair();\n+            (&(*pair_ptr).0, &mut (*pair_ptr).1)\n         })\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (self.elems_left, Some(self.elems_left))\n+        self.iter.size_hint()\n     }\n }\n+\n impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {\n     fn len(&self) -> usize {\n-        self.elems_left\n+        self.iter.len()\n     }\n }\n \n impl<K, V> Iterator for IntoIter<K, V> {\n     type Item = (SafeHash, K, V);\n \n     fn next(&mut self) -> Option<(SafeHash, K, V)> {\n-        self.iter.next().map(|bucket| {\n+        self.iter.next().map(|raw| {\n             self.table.size -= 1;\n             unsafe {\n-                let (k, v) = ptr::read(bucket.pair);\n-                (SafeHash { hash: *bucket.hash }, k, v)\n+                let (k, v) = ptr::read(raw.pair());\n+                (SafeHash { hash: *raw.hash() }, k, v)\n             }\n         })\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let size = self.table.size();\n-        (size, Some(size))\n+        self.iter.size_hint()\n     }\n }\n+\n impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n     fn len(&self) -> usize {\n-        self.table.size()\n+        self.iter().len()\n     }\n }\n \n@@ -1123,23 +1112,21 @@ impl<'a, K, V> Iterator for Drain<'a, K, V> {\n \n     #[inline]\n     fn next(&mut self) -> Option<(SafeHash, K, V)> {\n-        self.iter.next().map(|bucket| {\n-            unsafe {\n-                (*self.table.as_mut_ptr()).size -= 1;\n-                let (k, v) = ptr::read(bucket.pair);\n-                (SafeHash { hash: ptr::replace(bucket.hash, EMPTY_BUCKET) }, k, v)\n-            }\n+        self.iter.next().map(|raw| unsafe {\n+            (*self.table.as_mut_ptr()).size -= 1;\n+            let (k, v) = ptr::read(raw.pair());\n+            (SafeHash { hash: ptr::replace(&mut *raw.hash(), EMPTY_BUCKET) }, k, v)\n         })\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let size = unsafe { (**self.table).size() };\n-        (size, Some(size))\n+        self.iter.size_hint()\n     }\n }\n+\n impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n     fn len(&self) -> usize {\n-        unsafe { (**self.table).size() }\n+        self.iter.len()\n     }\n }\n \n@@ -1152,30 +1139,21 @@ impl<'a, K: 'a, V: 'a> Drop for Drain<'a, K, V> {\n impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n     fn clone(&self) -> RawTable<K, V> {\n         unsafe {\n-            let mut new_ht = RawTable::new_uninitialized(self.capacity());\n-\n-            {\n-                let cap = self.capacity();\n-                let mut new_buckets = Bucket::first(&mut new_ht);\n-                let mut buckets = Bucket::first(self);\n-                while buckets.index() != cap {\n-                    match buckets.peek() {\n-                        Full(full) => {\n-                            let (h, k, v) = {\n-                                let (k, v) = full.read();\n-                                (full.hash(), k.clone(), v.clone())\n-                            };\n-                            *new_buckets.raw.hash = h.inspect();\n-                            ptr::write(new_buckets.raw.pair as *mut (K, V), (k, v));\n-                        }\n-                        Empty(..) => {\n-                            *new_buckets.raw.hash = EMPTY_BUCKET;\n-                        }\n-                    }\n-                    new_buckets.next();\n-                    buckets.next();\n+            let cap = self.capacity();\n+            let mut new_ht = RawTable::new_uninitialized(cap);\n+\n+            let mut new_buckets = new_ht.raw_bucket_at(0);\n+            let mut buckets = self.raw_bucket_at(0);\n+            while buckets.idx < cap {\n+                *new_buckets.hash() = *buckets.hash();\n+                if *new_buckets.hash() != EMPTY_BUCKET {\n+                    let pair_ptr = buckets.pair();\n+                    let kv = ((*pair_ptr).0.clone(), (*pair_ptr).1.clone());\n+                    ptr::write(new_buckets.pair(), kv);\n                 }\n-            };\n+                buckets.idx += 1;\n+                new_buckets.idx += 1;\n+            }\n \n             new_ht.size = self.size();\n \n@@ -1186,7 +1164,7 @@ impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n \n unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for RawTable<K, V> {\n     fn drop(&mut self) {\n-        if self.capacity == 0 {\n+        if self.capacity() == 0 {\n             return;\n         }\n \n@@ -1202,8 +1180,8 @@ unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for RawTable<K, V> {\n             }\n         }\n \n-        let hashes_size = self.capacity * size_of::<HashUint>();\n-        let pairs_size = self.capacity * size_of::<(K, V)>();\n+        let hashes_size = self.capacity() * size_of::<HashUint>();\n+        let pairs_size = self.capacity() * size_of::<(K, V)>();\n         let (align, _, size, oflo) = calculate_allocation(hashes_size,\n                                                           align_of::<HashUint>(),\n                                                           pairs_size,"}, {"sha": "854d380d128c9d18d500297b7ecaa07badce30a3", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -92,7 +92,7 @@ pub fn init() {\n \n     #[cfg(not(any(target_os = \"nacl\", target_os = \"emscripten\", target_os=\"fuchsia\")))]\n     unsafe fn reset_sigpipe() {\n-        assert!(signal(libc::SIGPIPE, libc::SIG_IGN) != !0);\n+        assert!(signal(libc::SIGPIPE, libc::SIG_IGN) != libc::SIG_ERR);\n     }\n     #[cfg(any(target_os = \"nacl\", target_os = \"emscripten\", target_os=\"fuchsia\"))]\n     unsafe fn reset_sigpipe() {}"}, {"sha": "8595bfc9f79c338fcff59b45315f24ff4aab5418", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 42, "deletions": 15, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -4657,25 +4657,30 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn complain_if_pub_macro(&mut self, visa: &Visibility, span: Span) {\n-        match *visa {\n-            Visibility::Inherited => (),\n+    fn complain_if_pub_macro(&mut self, vis: &Visibility, sp: Span) {\n+        if let Err(mut err) = self.complain_if_pub_macro_diag(vis, sp) {\n+            err.emit();\n+        }\n+    }\n+\n+    fn complain_if_pub_macro_diag(&mut self, vis: &Visibility, sp: Span) -> PResult<'a, ()> {\n+        match *vis {\n+            Visibility::Inherited => Ok(()),\n             _ => {\n                 let is_macro_rules: bool = match self.token {\n                     token::Ident(sid) => sid.name == Symbol::intern(\"macro_rules\"),\n                     _ => false,\n                 };\n                 if is_macro_rules {\n-                    self.diagnostic().struct_span_err(span, \"can't qualify macro_rules \\\n-                                                             invocation with `pub`\")\n-                                     .help(\"did you mean #[macro_export]?\")\n-                                     .emit();\n+                    let mut err = self.diagnostic()\n+                        .struct_span_err(sp, \"can't qualify macro_rules invocation with `pub`\");\n+                    err.help(\"did you mean #[macro_export]?\");\n+                    Err(err)\n                 } else {\n-                    self.diagnostic().struct_span_err(span, \"can't qualify macro \\\n-                                                             invocation with `pub`\")\n-                                     .help(\"try adjusting the macro to put `pub` \\\n-                                            inside the invocation\")\n-                                     .emit();\n+                    let mut err = self.diagnostic()\n+                        .struct_span_err(sp, \"can't qualify macro invocation with `pub`\");\n+                    err.help(\"try adjusting the macro to put `pub` inside the invocation\");\n+                    Err(err)\n                 }\n             }\n         }\n@@ -4686,14 +4691,36 @@ impl<'a> Parser<'a> {\n                          -> PResult<'a, (Ident, Vec<ast::Attribute>, ast::ImplItemKind)> {\n         // code copied from parse_macro_use_or_failure... abstraction!\n         if self.token.is_path_start() {\n-            // method macro.\n+            // Method macro.\n \n             let prev_span = self.prev_span;\n-            self.complain_if_pub_macro(&vis, prev_span);\n+            // Before complaining about trying to set a macro as `pub`,\n+            // check if `!` comes after the path.\n+            let err = self.complain_if_pub_macro_diag(&vis, prev_span);\n \n             let lo = self.span;\n             let pth = self.parse_path(PathStyle::Mod)?;\n-            self.expect(&token::Not)?;\n+            let bang_err = self.expect(&token::Not);\n+            if let Err(mut err) = err {\n+                if let Err(mut bang_err) = bang_err {\n+                    // Given this code `pub path(`, it seems like this is not setting the\n+                    // visibility of a macro invocation, but rather a mistyped method declaration.\n+                    // Create a diagnostic pointing out that `fn` is missing.\n+                    //\n+                    // x |     pub path(&self) {\n+                    //   |        ^ missing `fn` for method declaration\n+\n+                    err.cancel();\n+                    bang_err.cancel();\n+                    //     pub  path(\n+                    //        ^^ `sp` below will point to this\n+                    let sp = prev_span.between(self.prev_span);\n+                    err = self.diagnostic()\n+                        .struct_span_err(sp, \"missing `fn` for method declaration\");\n+                    err.span_label(sp, &\"missing `fn`\");\n+                }\n+                return Err(err);\n+            }\n \n             // eat a matched-delimiter token tree:\n             let (delim, tts) = self.expect_delimited_token_tree()?;"}, {"sha": "9b88b9f7696fb3a35f68c5165d3f5ccc59ce610f", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -189,6 +189,30 @@ impl Span {\n             Span { hi: end.hi, ..self }\n         }\n     }\n+\n+    pub fn between(self, end: Span) -> Span {\n+        Span {\n+            lo: self.hi,\n+            hi: end.lo,\n+            ctxt: if end.ctxt == SyntaxContext::empty() {\n+                end.ctxt\n+            } else {\n+                self.ctxt\n+            }\n+        }\n+    }\n+\n+    pub fn until(self, end: Span) -> Span {\n+        Span {\n+            lo: self.lo,\n+            hi: end.lo,\n+            ctxt: if end.ctxt == SyntaxContext::empty() {\n+                end.ctxt\n+            } else {\n+                self.ctxt\n+            }\n+        }\n+    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "a72ad0351e33baa323e44be565320ae08e6356ab", "filename": "src/test/ui/codemap_tests/coherence-overlapping-inherent-impl-trait.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Ftest%2Fui%2Fcodemap_tests%2Fcoherence-overlapping-inherent-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Ftest%2Fui%2Fcodemap_tests%2Fcoherence-overlapping-inherent-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fcoherence-overlapping-inherent-impl-trait.rs?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -11,6 +11,6 @@\n #![allow(dead_code)]\n \n trait C {}\n-impl C { fn f() {} } //~ ERROR duplicate definitions with name `f`\n+impl C { fn f() {} }\n impl C { fn f() {} }\n fn main() { }", "previous_filename": "src/test/compile-fail/coherence-overlapping-inherent-impl-trait.rs"}, {"sha": "7f1ab929c6fc2b32fcbd4e0a18cd4341d08da5e8", "filename": "src/test/ui/codemap_tests/coherence-overlapping-inherent-impl-trait.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Ftest%2Fui%2Fcodemap_tests%2Fcoherence-overlapping-inherent-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Ftest%2Fui%2Fcodemap_tests%2Fcoherence-overlapping-inherent-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fcoherence-overlapping-inherent-impl-trait.stderr?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -0,0 +1,10 @@\n+error[E0592]: duplicate definitions with name `f`\n+  --> $DIR/coherence-overlapping-inherent-impl-trait.rs:14:10\n+   |\n+14 | impl C { fn f() {} }\n+   |          ^^^^^^^^^ duplicate definitions for `f`\n+15 | impl C { fn f() {} }\n+   |          --------- other definition for `f`\n+\n+error: aborting due to previous error\n+"}, {"sha": "a626b63b31ba0586fc3ef57105780f3f57e569cd", "filename": "src/test/ui/codemap_tests/overlapping_inherent_impls.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_inherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_inherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_inherent_impls.rs?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -16,7 +16,7 @@\n struct Foo;\n \n impl Foo {\n-    fn id() {} //~ ERROR duplicate definitions\n+    fn id() {}\n }\n \n impl Foo {\n@@ -26,7 +26,7 @@ impl Foo {\n struct Bar<T>(T);\n \n impl<T> Bar<T> {\n-    fn bar(&self) {} //~ ERROR duplicate definitions\n+    fn bar(&self) {}\n }\n \n impl Bar<u32> {\n@@ -36,7 +36,7 @@ impl Bar<u32> {\n struct Baz<T>(T);\n \n impl<T: Copy> Baz<T> {\n-    fn baz(&self) {} //~ ERROR duplicate definitions\n+    fn baz(&self) {}\n }\n \n impl<T> Baz<Vec<T>> {", "previous_filename": "src/test/compile-fail/inherent-overlap.rs"}, {"sha": "de8a24cf33f44c12f0e70d3dbf57e99101a67e09", "filename": "src/test/ui/codemap_tests/overlapping_inherent_impls.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_inherent_impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_inherent_impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_inherent_impls.stderr?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -0,0 +1,29 @@\n+error[E0592]: duplicate definitions with name `id`\n+  --> $DIR/overlapping_inherent_impls.rs:19:5\n+   |\n+19 |     fn id() {}\n+   |     ^^^^^^^^^^ duplicate definitions for `id`\n+...\n+23 |     fn id() {}\n+   |     ---------- other definition for `id`\n+\n+error[E0592]: duplicate definitions with name `bar`\n+  --> $DIR/overlapping_inherent_impls.rs:29:5\n+   |\n+29 |     fn bar(&self) {}\n+   |     ^^^^^^^^^^^^^^^^ duplicate definitions for `bar`\n+...\n+33 |     fn bar(&self) {}\n+   |     ---------------- other definition for `bar`\n+\n+error[E0592]: duplicate definitions with name `baz`\n+  --> $DIR/overlapping_inherent_impls.rs:39:5\n+   |\n+39 |     fn baz(&self) {}\n+   |     ^^^^^^^^^^^^^^^^ duplicate definitions for `baz`\n+...\n+43 |     fn baz(&self) {}\n+   |     ---------------- other definition for `baz`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "cf75929bae20ca35e53731b22138ad5492910929", "filename": "src/test/ui/did_you_mean/issue-40006.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.rs?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S;\n+\n+impl S {\n+    pub hello_method(&self) {\n+        println!(\"Hello\");\n+    }\n+}\n+\n+fn main() {\n+    S.hello_method();\n+}"}, {"sha": "460958027ad0f2d574d68d3698ae32a80b01fd7f", "filename": "src/test/ui/did_you_mean/issue-40006.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6cd15a0e8fecce04fd99b77b25099bf374bb0f56/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr?ref=6cd15a0e8fecce04fd99b77b25099bf374bb0f56", "patch": "@@ -0,0 +1,8 @@\n+error: missing `fn` for method declaration\n+  --> $DIR/issue-40006.rs:14:8\n+   |\n+14 |     pub hello_method(&self) {\n+   |        ^ missing `fn`\n+\n+error: aborting due to previous error\n+"}]}