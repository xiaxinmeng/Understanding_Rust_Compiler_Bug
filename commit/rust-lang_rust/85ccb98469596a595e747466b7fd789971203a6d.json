{"sha": "85ccb98469596a595e747466b7fd789971203a6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1Y2NiOTg0Njk1OTZhNTk1ZTc0NzQ2NmI3ZmQ3ODk5NzEyMDNhNmQ=", "commit": {"author": {"name": "David Alber", "email": "alber.david@gmail.com", "date": "2017-12-13T08:40:07Z"}, "committer": {"name": "David Alber", "email": "alber.david@gmail.com", "date": "2018-01-04T08:01:18Z"}, "message": "Adding test to verify code block idempotency in Configurations.md", "tree": {"sha": "e91d1c2eca636358b5b9525994ed7ad03363600b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e91d1c2eca636358b5b9525994ed7ad03363600b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85ccb98469596a595e747466b7fd789971203a6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85ccb98469596a595e747466b7fd789971203a6d", "html_url": "https://github.com/rust-lang/rust/commit/85ccb98469596a595e747466b7fd789971203a6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85ccb98469596a595e747466b7fd789971203a6d/comments", "author": {"login": "davidalber", "id": 933552, "node_id": "MDQ6VXNlcjkzMzU1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/933552?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidalber", "html_url": "https://github.com/davidalber", "followers_url": "https://api.github.com/users/davidalber/followers", "following_url": "https://api.github.com/users/davidalber/following{/other_user}", "gists_url": "https://api.github.com/users/davidalber/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidalber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidalber/subscriptions", "organizations_url": "https://api.github.com/users/davidalber/orgs", "repos_url": "https://api.github.com/users/davidalber/repos", "events_url": "https://api.github.com/users/davidalber/events{/privacy}", "received_events_url": "https://api.github.com/users/davidalber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidalber", "id": 933552, "node_id": "MDQ6VXNlcjkzMzU1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/933552?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidalber", "html_url": "https://github.com/davidalber", "followers_url": "https://api.github.com/users/davidalber/followers", "following_url": "https://api.github.com/users/davidalber/following{/other_user}", "gists_url": "https://api.github.com/users/davidalber/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidalber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidalber/subscriptions", "organizations_url": "https://api.github.com/users/davidalber/orgs", "repos_url": "https://api.github.com/users/davidalber/repos", "events_url": "https://api.github.com/users/davidalber/events{/privacy}", "received_events_url": "https://api.github.com/users/davidalber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91a332483bfeac25db9d0dd315b01cf2d05250c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/91a332483bfeac25db9d0dd315b01cf2d05250c0", "html_url": "https://github.com/rust-lang/rust/commit/91a332483bfeac25db9d0dd315b01cf2d05250c0"}], "stats": {"total": 308, "additions": 288, "deletions": 20}, "files": [{"sha": "3349ad3410a5b1e22d3e4b601b16f88bc3842719", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/85ccb98469596a595e747466b7fd789971203a6d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/85ccb98469596a595e747466b7fd789971203a6d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=85ccb98469596a595e747466b7fd789971203a6d", "patch": "@@ -191,6 +191,7 @@ dependencies = [\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.34 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "dd748d4685467cbad5d34d381678fab2591042c5", "filename": "Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/85ccb98469596a595e747466b7fd789971203a6d/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/85ccb98469596a595e747466b7fd789971203a6d/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=85ccb98469596a595e747466b7fd789971203a6d", "patch": "@@ -45,6 +45,9 @@ getopts = \"0.2\"\n derive-new = \"0.5\"\n cargo_metadata = \"0.4\"\n \n+[dev-dependencies]\n+lazy_static = \"1.0.0\"\n+\n [target.'cfg(unix)'.dependencies]\n libc = \"0.2.11\"\n "}, {"sha": "b91f39f31ca7a0159313705c83c0ace2180fc190", "filename": "Configurations.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85ccb98469596a595e747466b7fd789971203a6d/Configurations.md", "raw_url": "https://github.com/rust-lang/rust/raw/85ccb98469596a595e747466b7fd789971203a6d/Configurations.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Configurations.md?ref=85ccb98469596a595e747466b7fd789971203a6d", "patch": "@@ -511,12 +511,12 @@ Maximum length of comments. No effect unless`wrap_comments = true`.\n \n **Note:** A value of `0` results in [`wrap_comments`](#wrap_comments) being applied regardless of a line's width.\n \n-#### Comments shorter than `comment_width`:\n+#### `80` (default; comments shorter than `comment_width`):\n ```rust\n // Lorem ipsum dolor sit amet, consectetur adipiscing elit.\n ```\n \n-#### Comments longer than `comment_width`:\n+#### `60` (comments longer than `comment_width`):\n ```rust\n // Lorem ipsum dolor sit amet,\n // consectetur adipiscing elit."}, {"sha": "f37ab5c16ef5e5b9f5254f42e3b10ffd3ad89692", "filename": "src/rustfmt_diff.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/85ccb98469596a595e747466b7fd789971203a6d/src%2Frustfmt_diff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ccb98469596a595e747466b7fd789971203a6d/src%2Frustfmt_diff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustfmt_diff.rs?ref=85ccb98469596a595e747466b7fd789971203a6d", "patch": "@@ -97,15 +97,28 @@ pub fn make_diff(expected: &str, actual: &str, context_size: usize) -> Vec<Misma\n     results\n }\n \n+// A representation of how to write output.\n+pub enum PrintType {\n+    Fancy, // want to output color and the terminal supports it\n+    Basic, // do not want to output color or the terminal does not support color\n+}\n+\n+impl PrintType {\n+    pub fn get(color: Color) -> Self {\n+        match term::stdout() {\n+            Some(ref t) if use_colored_tty(color) && t.supports_color() => PrintType::Fancy,\n+            _ => PrintType::Basic,\n+        }\n+    }\n+}\n+\n pub fn print_diff<F>(diff: Vec<Mismatch>, get_section_title: F, color: Color)\n where\n     F: Fn(u32) -> String,\n {\n-    match term::stdout() {\n-        Some(ref t) if use_colored_tty(color) && t.supports_color() => {\n-            print_diff_fancy(diff, get_section_title, term::stdout().unwrap())\n-        }\n-        _ => print_diff_basic(diff, get_section_title),\n+    match PrintType::get(color) {\n+        PrintType::Fancy => print_diff_fancy(diff, get_section_title, term::stdout().unwrap()),\n+        PrintType::Basic => print_diff_basic(diff, get_section_title),\n     }\n }\n "}, {"sha": "a551ca67eae4651e6d01786eee5fdc812c36ef7f", "filename": "tests/system.rs", "status": "modified", "additions": 264, "deletions": 13, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/85ccb98469596a595e747466b7fd789971203a6d/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ccb98469596a595e747466b7fd789971203a6d/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=85ccb98469596a595e747466b7fd789971203a6d", "patch": "@@ -10,6 +10,8 @@\n \n #![feature(rustc_private)]\n \n+#[macro_use]\n+extern crate lazy_static;\n #[macro_use]\n extern crate log;\n extern crate regex;\n@@ -19,7 +21,7 @@ extern crate term;\n use std::collections::HashMap;\n use std::fs;\n use std::io::{self, BufRead, BufReader, Read};\n-use std::iter::Peekable;\n+use std::iter::{Enumerate, Peekable};\n use std::path::{Path, PathBuf};\n use std::str::Chars;\n \n@@ -29,6 +31,7 @@ use rustfmt::filemap::{write_system_newlines, FileMap};\n use rustfmt::rustfmt_diff::*;\n \n const DIFF_CONTEXT_SIZE: usize = 3;\n+const CONFIGURATIONS_FILE_NAME: &str = \"Configurations.md\";\n \n // Returns a `Vec` containing `PathBuf`s of files with a rs extension in the\n // given path. The `recursive` argument controls if files from subdirectories\n@@ -98,6 +101,17 @@ fn verify_config_test_names() {\n     }\n }\n \n+// This writes to the terminal using the same approach (via term::stdout or\n+// println!) that is used by `rustfmt::rustfmt_diff::print_diff`. Writing\n+// using only one or the other will cause the output order to differ when\n+// `print_diff` selects the approach not used.\n+fn write_message(msg: String) {\n+    match PrintType::get(Color::Auto) {\n+        PrintType::Fancy => writeln!(term::stdout().unwrap(), \"{}\", msg).unwrap(),\n+        PrintType::Basic => println!(\"{}\", msg),\n+    }\n+}\n+\n // Integration tests. The files in the tests/source are formatted and compared\n // to their equivalent in tests/target. The target file and config can be\n // overridden by annotations in the source file. The input and output must match\n@@ -152,7 +166,7 @@ fn assert_output(source: &Path, expected_filename: &Path) {\n     if !compare.is_empty() {\n         let mut failures = HashMap::new();\n         failures.insert(source.to_owned(), compare);\n-        print_mismatches(failures);\n+        print_mismatches_default_message(failures, source.display());\n         assert!(false, \"Text does not match expected output\");\n     }\n }\n@@ -259,15 +273,15 @@ fn check_files(files: Vec<PathBuf>) -> (Vec<FormatReport>, u32, u32) {\n     for file_name in files {\n         debug!(\"Testing '{}'...\", file_name.display());\n \n-        match idempotent_check(file_name) {\n+        match idempotent_check(&file_name) {\n             Ok(ref report) if report.has_warnings() => {\n                 print!(\"{}\", report);\n                 fails += 1;\n             }\n             Ok(report) => reports.push(report),\n             Err(err) => {\n                 if let IdempotentCheckError::Mismatch(msg) = err {\n-                    print_mismatches(msg);\n+                    print_mismatches_default_message(msg, file_name.display());\n                 }\n                 fails += 1;\n             }\n@@ -279,15 +293,22 @@ fn check_files(files: Vec<PathBuf>) -> (Vec<FormatReport>, u32, u32) {\n     (reports, count, fails)\n }\n \n-fn print_mismatches(result: HashMap<PathBuf, Vec<Mismatch>>) {\n-    let mut t = term::stdout().unwrap();\n+fn print_mismatches_default_message(\n+    result: HashMap<PathBuf, Vec<Mismatch>>,\n+    file_name: std::path::Display,\n+) {\n+    print_mismatches(result, |line_num| {\n+        format!(\"\\nMismatch at {}:{}:\", file_name, line_num)\n+    });\n+}\n \n-    for (file_name, diff) in result {\n-        print_diff(\n-            diff,\n-            |line_num| format!(\"\\nMismatch at {}:{}:\", file_name.display(), line_num),\n-            Color::Auto,\n-        );\n+fn print_mismatches<T: Fn(u32) -> String>(\n+    result: HashMap<PathBuf, Vec<Mismatch>>,\n+    mismatch_msg_formatter: T,\n+) {\n+    let mut t = term::stdout().unwrap();\n+    for (_file_name, diff) in result {\n+        print_diff(diff, &mismatch_msg_formatter, Color::Auto);\n     }\n \n     t.reset().unwrap();\n@@ -327,7 +348,7 @@ pub enum IdempotentCheckError {\n     Parse,\n }\n \n-pub fn idempotent_check(filename: PathBuf) -> Result<FormatReport, IdempotentCheckError> {\n+pub fn idempotent_check(filename: &PathBuf) -> Result<FormatReport, IdempotentCheckError> {\n     let sig_comments = read_significant_comments(&filename);\n     let config = read_config(&filename);\n     let (error_summary, file_map, format_report) = format_file(filename, &config);\n@@ -536,3 +557,233 @@ fn string_eq_ignore_newline_repr_test() {\n     assert!(string_eq_ignore_newline_repr(\"a\\r\\n\\r\\n\\r\\nb\", \"a\\n\\n\\nb\"));\n     assert!(!string_eq_ignore_newline_repr(\"a\\r\\nbcd\", \"a\\nbcdefghijk\"));\n }\n+\n+// This enum is used to represent one of three text features in Configurations.md: a block of code\n+// with its starting line number, the name of a rustfmt configuration option, or the value of a\n+// rustfmt configuration option.\n+enum ConfigurationSection {\n+    CodeBlock((String, u32)), // (String: block of code, u32: line number of code block start)\n+    ConfigName(String),\n+    ConfigValue(String),\n+}\n+\n+impl ConfigurationSection {\n+    fn get_section<I: Iterator<Item = String>>(\n+        file: &mut Enumerate<I>,\n+    ) -> Option<ConfigurationSection> {\n+        lazy_static! {\n+            static ref CONFIG_NAME_REGEX: regex::Regex = regex::Regex::new(r\"^## `([^`]+)`\").expect(\"Failed creating configuration pattern\");\n+            static ref CONFIG_VALUE_REGEX: regex::Regex = regex::Regex::new(r#\"^#### `\"?([^`\"]+)\"?`\"#).expect(\"Failed creating configuration value pattern\");\n+        }\n+\n+        loop {\n+            match file.next() {\n+                Some((i, line)) => {\n+                    if line.starts_with(\"```rust\") {\n+                        // Get the lines of the code block.\n+                        let lines: Vec<String> = file.map(|(_i, l)| l)\n+                            .take_while(|l| !l.starts_with(\"```\"))\n+                            .collect();\n+                        let block = format!(\"{}\\n\", lines.join(\"\\n\"));\n+\n+                        // +1 to translate to one-based indexing\n+                        // +1 to get to first line of code (line after \"```\")\n+                        let start_line = (i + 2) as u32;\n+\n+                        return Some(ConfigurationSection::CodeBlock((block, start_line)));\n+                    } else if let Some(c) = CONFIG_NAME_REGEX.captures(&line) {\n+                        return Some(ConfigurationSection::ConfigName(String::from(&c[1])));\n+                    } else if let Some(c) = CONFIG_VALUE_REGEX.captures(&line) {\n+                        return Some(ConfigurationSection::ConfigValue(String::from(&c[1])));\n+                    }\n+                }\n+                None => return None, // reached the end of the file\n+            }\n+        }\n+    }\n+}\n+\n+// This struct stores the information about code blocks in the configurations\n+// file, formats the code blocks, and prints formatting errors.\n+struct ConfigCodeBlock {\n+    config_name: Option<String>,\n+    config_value: Option<String>,\n+    code_block: Option<String>,\n+    code_block_start: Option<u32>,\n+}\n+\n+impl ConfigCodeBlock {\n+    fn new() -> ConfigCodeBlock {\n+        ConfigCodeBlock {\n+            config_name: None,\n+            config_value: None,\n+            code_block: None,\n+            code_block_start: None,\n+        }\n+    }\n+\n+    fn set_config_name(&mut self, name: Option<String>) {\n+        self.config_name = name;\n+        self.config_value = None;\n+    }\n+\n+    fn set_config_value(&mut self, value: Option<String>) {\n+        self.config_value = value;\n+    }\n+\n+    fn set_code_block(&mut self, code_block: String, code_block_start: u32) {\n+        self.code_block = Some(code_block);\n+        self.code_block_start = Some(code_block_start);\n+    }\n+\n+    fn get_block_config(&self) -> Config {\n+        let mut config = Config::default();\n+        config.override_value(\n+            self.config_name.as_ref().unwrap(),\n+            self.config_value.as_ref().unwrap(),\n+        );\n+        config\n+    }\n+\n+    fn code_block_valid(&self) -> bool {\n+        // We never expect to not have a code block.\n+        assert!(self.code_block.is_some() && self.code_block_start.is_some());\n+\n+        if self.config_name.is_none() {\n+            write_message(format!(\n+                \"configuration name not found for block beginning at line {}\",\n+                self.code_block_start.unwrap()\n+            ));\n+            return false;\n+        }\n+        if self.config_value.is_none() {\n+            write_message(format!(\n+                \"configuration value not found for block beginning at line {}\",\n+                self.code_block_start.unwrap()\n+            ));\n+            return false;\n+        }\n+        true\n+    }\n+\n+    fn has_parsing_errors(&self, error_summary: Summary) -> bool {\n+        if error_summary.has_parsing_errors() {\n+            write_message(format!(\n+                \"\\u{261d}\\u{1f3fd} Failed to format block starting at Line {} in {}\",\n+                self.code_block_start.unwrap(),\n+                CONFIGURATIONS_FILE_NAME\n+            ));\n+            return true;\n+        }\n+\n+        false\n+    }\n+\n+    fn print_diff(&self, compare: Vec<Mismatch>) {\n+        let mut mismatches = HashMap::new();\n+        mismatches.insert(PathBuf::from(CONFIGURATIONS_FILE_NAME), compare);\n+        print_mismatches(mismatches, |line_num| {\n+            format!(\n+                \"\\nMismatch at {}:{}:\",\n+                CONFIGURATIONS_FILE_NAME,\n+                line_num + self.code_block_start.unwrap() - 1\n+            )\n+        });\n+    }\n+\n+    fn formatted_has_diff(&self, file_map: FileMap) -> bool {\n+        let &(ref _file_name, ref text) = file_map.first().unwrap();\n+        let compare = make_diff(self.code_block.as_ref().unwrap(), text, DIFF_CONTEXT_SIZE);\n+        if !compare.is_empty() {\n+            self.print_diff(compare);\n+            return true;\n+        }\n+\n+        false\n+    }\n+\n+    // Return a bool indicating if formatting this code block is an idempotent\n+    // operation. This function also triggers printing any formatting failure\n+    // messages.\n+    fn formatted_is_idempotent(&self) -> bool {\n+        // Verify that we have all of the expected information.\n+        if !self.code_block_valid() {\n+            return false;\n+        }\n+\n+        let input = Input::Text(self.code_block.as_ref().unwrap().to_owned());\n+        let config = self.get_block_config();\n+\n+        let (error_summary, file_map, _report) =\n+            format_input::<io::Stdout>(input, &config, None).unwrap();\n+\n+        !self.has_parsing_errors(error_summary) && !self.formatted_has_diff(file_map)\n+    }\n+\n+    // Extract a code block from the iterator. Behavior:\n+    // - Rust code blocks are identifed by lines beginning with \"```rust\".\n+    // - One explicit configuration setting is supported per code block.\n+    // - Rust code blocks with no configuration setting are illegal and cause an\n+    //   assertion failure.\n+    // - Configuration names in Configurations.md must be in the form of\n+    //   \"## `NAME`\".\n+    // - Configuration values in Configurations.md must be in the form of\n+    //   \"#### `VALUE`\".\n+    fn extract<I: Iterator<Item = String>>(\n+        file: &mut Enumerate<I>,\n+        prev: Option<&ConfigCodeBlock>,\n+    ) -> Option<ConfigCodeBlock> {\n+        let mut code_block = ConfigCodeBlock::new();\n+        code_block.config_name = prev.map_or(None, |cb| cb.config_name.clone());\n+\n+        loop {\n+            match ConfigurationSection::get_section(file) {\n+                Some(ConfigurationSection::CodeBlock((block, start_line))) => {\n+                    code_block.set_code_block(block, start_line);\n+                    break;\n+                }\n+                Some(ConfigurationSection::ConfigName(name)) => {\n+                    code_block.set_config_name(Some(name));\n+                }\n+                Some(ConfigurationSection::ConfigValue(value)) => {\n+                    code_block.set_config_value(Some(value));\n+                }\n+                None => return None, // end of file was reached\n+            }\n+        }\n+\n+        Some(code_block)\n+    }\n+}\n+\n+#[test]\n+#[ignore]\n+fn configuration_snippet_tests() {\n+    // Read Configurations.md and build a `Vec` of `ConfigCodeBlock` structs with one\n+    // entry for each Rust code block found.\n+    fn get_code_blocks() -> Vec<ConfigCodeBlock> {\n+        let mut file_iter = BufReader::new(\n+            fs::File::open(CONFIGURATIONS_FILE_NAME)\n+                .expect(&format!(\"Couldn't read file {}\", CONFIGURATIONS_FILE_NAME)),\n+        ).lines()\n+            .map(|l| l.unwrap())\n+            .enumerate();\n+        let mut code_blocks: Vec<ConfigCodeBlock> = Vec::new();\n+\n+        while let Some(cb) = ConfigCodeBlock::extract(&mut file_iter, code_blocks.last()) {\n+            code_blocks.push(cb);\n+        }\n+\n+        code_blocks\n+    }\n+\n+    let blocks = get_code_blocks();\n+    let failures = blocks\n+        .iter()\n+        .map(|b| b.formatted_is_idempotent())\n+        .fold(0, |acc, r| acc + (!r as u32));\n+\n+    // Display results.\n+    println!(\"Ran {} configurations tests.\", blocks.len());\n+    assert_eq!(failures, 0, \"{} configurations tests failed\", failures);\n+}"}]}