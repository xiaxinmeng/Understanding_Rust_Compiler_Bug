{"sha": "d1a82af23575dad3d7af2760dac6db0132b9a2d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxYTgyYWYyMzU3NWRhZDNkN2FmMjc2MGRhYzZkYjAxMzJiOWEyZDE=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-06-25T18:52:50Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-19T19:02:32Z"}, "message": "Refactor mod/check (part i)", "tree": {"sha": "b4979a759793d5503d40f6ce7acf5095e8d37576", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4979a759793d5503d40f6ce7acf5095e8d37576"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1a82af23575dad3d7af2760dac6db0132b9a2d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1a82af23575dad3d7af2760dac6db0132b9a2d1", "html_url": "https://github.com/rust-lang/rust/commit/d1a82af23575dad3d7af2760dac6db0132b9a2d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1a82af23575dad3d7af2760dac6db0132b9a2d1/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2317abdd019cce8137c857160fc4cd78431f565c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2317abdd019cce8137c857160fc4cd78431f565c", "html_url": "https://github.com/rust-lang/rust/commit/2317abdd019cce8137c857160fc4cd78431f565c"}], "stats": {"total": 268, "additions": 166, "deletions": 102}, "files": [{"sha": "a48552f9dcff8453ee3a44bd6cd210ce4e1a4c8e", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1a82af23575dad3d7af2760dac6db0132b9a2d1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a82af23575dad3d7af2760dac6db0132b9a2d1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=d1a82af23575dad3d7af2760dac6db0132b9a2d1", "patch": "@@ -315,9 +315,9 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // If they were not explicitly supplied, just construct fresh\n         // variables.\n         let method_generics = self.tcx.generics_of(pick.item.def_id);\n-        let mut fn_segment = Some((segment, method_generics));\n+        let fn_segment = Some((segment, method_generics));\n         let supress_mismatch = self.fcx.check_impl_trait(self.span, fn_segment);\n-        self.fcx.check_generic_arg_count(self.span, &mut fn_segment, true, supress_mismatch);\n+        self.fcx.check_generic_arg_count(self.span, &segment, &method_generics, true, supress_mismatch);\n \n         // Create subst for early-bound lifetime parameters, combining\n         // parameters from the type and those from the method."}, {"sha": "d8617149def7acfe42239198e9d1d404799a25bf", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 164, "deletions": 100, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/d1a82af23575dad3d7af2760dac6db0132b9a2d1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a82af23575dad3d7af2760dac6db0132b9a2d1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d1a82af23575dad3d7af2760dac6db0132b9a2d1", "patch": "@@ -113,7 +113,7 @@ use util::nodemap::{DefIdMap, DefIdSet, FxHashMap, NodeMap};\n \n use std::cell::{Cell, RefCell, Ref, RefMut};\n use rustc_data_structures::sync::Lrc;\n-use std::collections::hash_map::Entry;\n+use std::collections::{hash_map::Entry, HashSet};\n use std::cmp;\n use std::fmt::Display;\n use std::iter;\n@@ -505,6 +505,9 @@ impl<'gcx, 'tcx> EnclosingBreakables<'gcx, 'tcx> {\n     }\n }\n \n+#[derive(Debug)]\n+struct PathSeg(DefId, usize);\n+\n pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     body_id: ast::NodeId,\n \n@@ -4770,20 +4773,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         err.span_suggestion(span_semi, \"consider removing this semicolon\", \"\".to_string());\n     }\n \n-    // Instantiates the given path, which must refer to an item with the given\n-    // number of type parameters and type.\n-    pub fn instantiate_value_path(&self,\n-                                  segments: &[hir::PathSegment],\n-                                  opt_self_ty: Option<Ty<'tcx>>,\n-                                  def: Def,\n-                                  span: Span,\n-                                  node_id: ast::NodeId)\n-                                  -> Ty<'tcx> {\n-        debug!(\"instantiate_value_path(path={:?}, def={:?}, node_id={})\",\n-               segments,\n-               def,\n-               node_id);\n-\n+    fn def_ids_for_path_segments(&self,\n+                                 segments: &[hir::PathSegment],\n+                                 def: Def)\n+                                 -> Vec<PathSeg> {\n         // We need to extract the type parameters supplied by the user in\n         // the path `path`. Due to the current setup, this is a bit of a\n         // tricky-process; the problem is that resolve only tells us the\n@@ -4829,33 +4822,69 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // The first step then is to categorize the segments appropriately.\n \n         assert!(!segments.is_empty());\n+        let last = segments.len() - 1;\n+\n+        let mut path_segs = vec![];\n \n-        let mut ufcs_associated = None;\n-        let mut type_segment = None;\n-        let mut fn_segment = None;\n         match def {\n             // Case 1. Reference to a struct/variant constructor.\n             Def::StructCtor(def_id, ..) |\n             Def::VariantCtor(def_id, ..) => {\n                 // Everything but the final segment should have no\n                 // parameters at all.\n                 let mut generics = self.tcx.generics_of(def_id);\n-                if let Some(def_id) = generics.parent {\n-                    // Variant and struct constructors use the\n-                    // generics of their parent type definition.\n-                    generics = self.tcx.generics_of(def_id);\n-                }\n-                type_segment = Some((segments.last().unwrap(), generics));\n+                // Variant and struct constructors use the\n+                // generics of their parent type definition.\n+                let generics_def_id = generics.parent.unwrap_or(def_id);\n+                path_segs.push(PathSeg(generics_def_id, last));\n             }\n \n             // Case 2. Reference to a top-level value.\n             Def::Fn(def_id) |\n             Def::Const(def_id) |\n             Def::Static(def_id, _) => {\n-                fn_segment = Some((segments.last().unwrap(), self.tcx.generics_of(def_id)));\n+                path_segs.push(PathSeg(def_id, last));\n             }\n \n             // Case 3. Reference to a method or associated const.\n+            Def::Method(def_id) |\n+            Def::AssociatedConst(def_id) => {\n+                if segments.len() >= 2 {\n+                    let generics = self.tcx.generics_of(def_id);\n+                    path_segs.push(PathSeg(generics.parent.unwrap(), last - 1));\n+                }\n+                path_segs.push(PathSeg(def_id, last));\n+            }\n+\n+            // Case 4. Local variable, no generics.\n+            Def::Local(..) | Def::Upvar(..) => {}\n+\n+            _ => bug!(\"unexpected definition: {:?}\", def),\n+        }\n+\n+        debug!(\"path_segs = {:?}\", path_segs);\n+\n+        path_segs\n+    }\n+\n+    // Instantiates the given path, which must refer to an item with the given\n+    // number of type parameters and type.\n+    pub fn instantiate_value_path(&self,\n+                                  segments: &[hir::PathSegment],\n+                                  opt_self_ty: Option<Ty<'tcx>>,\n+                                  def: Def,\n+                                  span: Span,\n+                                  node_id: ast::NodeId)\n+                                  -> Ty<'tcx> {\n+        debug!(\"instantiate_value_path(path={:?}, def={:?}, node_id={})\",\n+               segments,\n+               def,\n+               node_id);\n+\n+        let path_segs = self.def_ids_for_path_segments(segments, def);\n+\n+        let mut ufcs_associated = None;\n+        match def {\n             Def::Method(def_id) |\n             Def::AssociatedConst(def_id) => {\n                 let container = self.tcx.associated_item(def_id).container;\n@@ -4865,34 +4894,36 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                     ty::ImplContainer(_) => {}\n                 }\n-\n-                let generics = self.tcx.generics_of(def_id);\n-                if segments.len() >= 2 {\n-                    let parent_generics = self.tcx.generics_of(generics.parent.unwrap());\n-                    type_segment = Some((&segments[segments.len() - 2], parent_generics));\n-                } else {\n+                if segments.len() == 1 {\n                     // `<T>::assoc` will end up here, and so can `T::assoc`.\n                     let self_ty = opt_self_ty.expect(\"UFCS sugared assoc missing Self\");\n                     ufcs_associated = Some((container, self_ty));\n                 }\n-                fn_segment = Some((segments.last().unwrap(), generics));\n             }\n-\n-            // Case 4. Local variable, no generics.\n-            Def::Local(..) | Def::Upvar(..) => {}\n-\n-            _ => bug!(\"unexpected definition: {:?}\", def),\n+            _ => {}\n         }\n \n-        debug!(\"type_segment={:?} fn_segment={:?}\", type_segment, fn_segment);\n-\n         // Now that we have categorized what space the parameters for each\n         // segment belong to, let's sort out the parameters that the user\n         // provided (if any) into their appropriate spaces. We'll also report\n         // errors if type parameters are provided in an inappropriate place.\n-        let poly_segments = type_segment.is_some() as usize +\n-                            fn_segment.is_some() as usize;\n-        AstConv::prohibit_generics(self, &segments[..segments.len() - poly_segments]);\n+        let mut generic_segs = HashSet::new();\n+        for PathSeg(_, index) in &path_segs {\n+            generic_segs.insert(index);\n+        }\n+        let segs: Vec<_> = segments\n+            .iter()\n+            .enumerate()\n+            .filter_map(|(index, seg)| {\n+                if !generic_segs.contains(&index) {\n+                    Some(seg)\n+                } else {\n+                    None\n+                }\n+            })\n+            .cloned()\n+            .collect();\n+        AstConv::prohibit_generics(self, &segs);\n \n         match def {\n             Def::Local(nid) | Def::Upvar(nid, ..) => {\n@@ -4904,24 +4935,66 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => {}\n         }\n \n+        let mut type_segment = None;\n+        let mut fn_segment = None;\n+        match def {\n+            // Case 1. Reference to a struct/variant constructor.\n+            Def::StructCtor(def_id, ..) |\n+            Def::VariantCtor(def_id, ..) => {\n+                // Everything but the final segment should have no\n+                // parameters at all.\n+                let mut generics = self.tcx.generics_of(def_id);\n+                if let Some(def_id) = generics.parent {\n+                    // Variant and struct constructors use the\n+                    // generics of their parent type definition.\n+                    generics = self.tcx.generics_of(def_id);\n+                }\n+                type_segment = Some((segments.last().unwrap(), generics));\n+            }\n+\n+            // Case 2. Reference to a top-level value.\n+            Def::Fn(def_id) |\n+            Def::Const(def_id) |\n+            Def::Static(def_id, _) => {\n+                fn_segment = Some((segments.last().unwrap(), self.tcx.generics_of(def_id)));\n+            }\n+\n+            // Case 3. Reference to a method or associated const.\n+            Def::Method(def_id) |\n+            Def::AssociatedConst(def_id) => {\n+                let generics = self.tcx.generics_of(def_id);\n+                if segments.len() >= 2 {\n+                    let parent_generics = self.tcx.generics_of(generics.parent.unwrap());\n+                    type_segment = Some((&segments[segments.len() - 2], parent_generics));\n+                }\n+                fn_segment = Some((segments.last().unwrap(), generics));\n+            }\n+\n+            _ => {}\n+        }\n+\n+        debug!(\"type_segment={:?} fn_segment={:?}\", type_segment, fn_segment);\n+\n         // Now we have to compare the types that the user *actually*\n         // provided against the types that were *expected*. If the user\n         // did not provide any types, then we want to substitute inference\n         // variables. If the user provided some types, we may still need\n         // to add defaults. If the user provided *too many* types, that's\n         // a problem.\n         let supress_mismatch = self.check_impl_trait(span, fn_segment);\n-        self.check_generic_arg_count(span, &mut type_segment, false, supress_mismatch);\n-        self.check_generic_arg_count(span, &mut fn_segment, false, supress_mismatch);\n+        for &PathSeg(def_id, index) in &path_segs {\n+            let generics = self.tcx.generics_of(def_id);\n+            self.check_generic_arg_count(span, &segments[index], &generics, false, supress_mismatch);\n+        }\n \n-        let (fn_start, has_self) = match (type_segment, fn_segment) {\n-            (_, Some((_, generics))) => {\n-                (generics.parent_count, generics.has_self)\n-            }\n-            (Some((_, generics)), None) => {\n-                (generics.params.len(), generics.has_self)\n-            }\n-            (None, None) => (0, false)\n+        let has_self = path_segs.last().map(|PathSeg(def_id, _)| {\n+            self.tcx.generics_of(*def_id).has_self\n+        }).unwrap_or(false);\n+\n+        let fn_start = match (type_segment, fn_segment) {\n+            (_, Some((_, generics))) => generics.parent_count,\n+            (Some((_, generics)), None) => generics.params.len(),\n+            (None, None) => 0,\n         };\n         // FIXME(varkor): Separating out the parameters is messy.\n         let mut lifetimes_type_seg = vec![];\n@@ -5091,64 +5164,55 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// Report errors if the provided parameters are too few or too many.\n     fn check_generic_arg_count(&self,\n                                span: Span,\n-                               segment: &mut Option<(&hir::PathSegment, &ty::Generics)>,\n+                               segment: &hir::PathSegment,\n+                               generics: &ty::Generics,\n                                is_method_call: bool,\n                                supress_mismatch_error: bool) {\n-        let (lifetimes, types, infer_types, bindings) = segment.map_or(\n-            (vec![], vec![], true, &[][..]),\n-            |(s, _)| {\n-                s.args.as_ref().map_or(\n-                    (vec![], vec![], s.infer_types, &[][..]),\n-                    |data| {\n-                        let (mut lifetimes, mut types) = (vec![], vec![]);\n-                        data.args.iter().for_each(|arg| match arg {\n-                            GenericArg::Lifetime(lt) => lifetimes.push(lt),\n-                            GenericArg::Type(ty) => types.push(ty),\n-                        });\n-                        (lifetimes, types, s.infer_types, &data.bindings[..])\n-                    }\n-                )\n+        let (mut lifetimes, mut types) = (vec![], vec![]);\n+        let infer_types = segment.infer_types;\n+        let mut bindings = vec![];\n+        if let Some(ref data) = segment.args {\n+            data.args.iter().for_each(|arg| match arg {\n+                GenericArg::Lifetime(lt) => lifetimes.push(lt.clone()),\n+                GenericArg::Type(ty) => types.push(ty.clone()),\n             });\n+            bindings = data.bindings.clone().to_vec();\n+        }\n \n-        // Check provided parameters.\n-        let ((ty_required, ty_accepted), lt_accepted) =\n-            segment.map_or(((0, 0), 0), |(_, generics)| {\n-                struct ParamRange {\n-                    required: usize,\n-                    accepted: usize\n-                };\n+        struct ParamRange {\n+            required: usize,\n+            accepted: usize\n+        };\n \n-                let mut lt_accepted = 0;\n-                let mut ty_params = ParamRange { required: 0, accepted: 0 };\n-                for param in &generics.params {\n-                    match param.kind {\n-                        GenericParamDefKind::Lifetime => lt_accepted += 1,\n-                        GenericParamDefKind::Type { has_default, .. } => {\n-                            ty_params.accepted += 1;\n-                            if !has_default {\n-                                ty_params.required += 1;\n-                            }\n-                        }\n-                    };\n-                }\n-                if generics.parent.is_none() && generics.has_self {\n-                    ty_params.required -= 1;\n-                    ty_params.accepted -= 1;\n+        let mut lt_accepted = 0;\n+        let mut ty_params = ParamRange { required: 0, accepted: 0 };\n+        for param in &generics.params {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => lt_accepted += 1,\n+                GenericParamDefKind::Type { has_default, .. } => {\n+                    ty_params.accepted += 1;\n+                    if !has_default {\n+                        ty_params.required += 1;\n+                    }\n                 }\n+            };\n+        }\n+        if generics.parent.is_none() && generics.has_self {\n+            ty_params.required -= 1;\n+            ty_params.accepted -= 1;\n+        }\n+        let ty_accepted = ty_params.accepted;\n+        let ty_required = ty_params.required;\n \n-                ((ty_params.required, ty_params.accepted), lt_accepted)\n-            });\n-\n-        let count_type_params = |n| {\n-            format!(\"{} type parameter{}\", n, if n == 1 { \"\" } else { \"s\" })\n-        };\n+        let count_type_params = |n| format!(\"{} type parameter{}\", n, if n == 1 { \"\" } else { \"s\" });\n         let expected_text = count_type_params(ty_accepted);\n         let actual_text = count_type_params(types.len());\n         if let Some((mut err, span)) = if types.len() > ty_accepted {\n             // To prevent derived errors to accumulate due to extra\n             // type parameters, we force instantiate_value_path to\n             // use inference variables instead of the provided types.\n-            *segment = None;\n+            // FIXME(varkor)\n+            // *segment = None;\n             let span = types[ty_accepted].span;\n             Some((struct_span_err!(self.tcx.sess, span, E0087,\n                                   \"too many type parameters provided: \\\n@@ -5172,8 +5236,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let infer_lifetimes = lifetimes.len() == 0;\n         // Prohibit explicit lifetime arguments if late bound lifetime parameters are present.\n-        let has_late_bound_lifetime_defs =\n-            segment.map_or(None, |(_, generics)| generics.has_late_bound_regions);\n+        let has_late_bound_lifetime_defs = generics.has_late_bound_regions;\n         if let (Some(span_late), false) = (has_late_bound_lifetime_defs, lifetimes.is_empty()) {\n             // Report this as a lint only if no error was reported previously.\n             let primary_msg = \"cannot specify lifetime arguments explicitly \\\n@@ -5184,7 +5247,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let mut err = self.tcx.sess.struct_span_err(lifetimes[0].span, primary_msg);\n                 err.span_note(span_late, note_msg);\n                 err.emit();\n-                *segment = None;\n+                // FIXME(varkor)\n+                // *segment = None;\n             } else {\n                 let mut multispan = MultiSpan::from_span(lifetimes[0].span);\n                 multispan.push_span_label(span_late, note_msg.to_string());"}]}