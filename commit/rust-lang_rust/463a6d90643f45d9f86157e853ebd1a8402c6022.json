{"sha": "463a6d90643f45d9f86157e853ebd1a8402c6022", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2M2E2ZDkwNjQzZjQ1ZDlmODYxNTdlODUzZWJkMWE4NDAyYzYwMjI=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-01-05T13:40:53Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-01-05T13:42:29Z"}, "message": "extra::treemap: add mutable-value iterators.", "tree": {"sha": "5dd0be29e996267b905f4ac5c253770a9302c934", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5dd0be29e996267b905f4ac5c253770a9302c934"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/463a6d90643f45d9f86157e853ebd1a8402c6022", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/463a6d90643f45d9f86157e853ebd1a8402c6022", "html_url": "https://github.com/rust-lang/rust/commit/463a6d90643f45d9f86157e853ebd1a8402c6022", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/463a6d90643f45d9f86157e853ebd1a8402c6022/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf9a9afc7ca086f7ef2fafa7eb791c2ca92e0ddf", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf9a9afc7ca086f7ef2fafa7eb791c2ca92e0ddf", "html_url": "https://github.com/rust-lang/rust/commit/bf9a9afc7ca086f7ef2fafa7eb791c2ca92e0ddf"}], "stats": {"total": 279, "additions": 278, "deletions": 1}, "files": [{"sha": "49ee1ebebcc91c0a5c70686170e0844636880179", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 278, "deletions": 1, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/463a6d90643f45d9f86157e853ebd1a8402c6022/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/463a6d90643f45d9f86157e853ebd1a8402c6022/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=463a6d90643f45d9f86157e853ebd1a8402c6022", "patch": "@@ -12,10 +12,10 @@\n //! trees. The only requirement for the types is that the key implements\n //! `TotalOrd`.\n \n-\n use std::util::{swap, replace};\n use std::iter::{Peekable};\n use std::cmp::Ordering;\n+use std::ptr;\n \n // This is implemented as an AA tree, which is a simplified variation of\n // a red-black tree where red (horizontal) nodes can only be added\n@@ -157,6 +157,23 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n         TreeMapRevIterator{iter: self.iter()}\n     }\n \n+    /// Get a lazy forward iterator over the key-value pairs in the\n+    /// map, with the values being mutable.\n+    pub fn mut_iter<'a>(&'a mut self) -> TreeMapMutIterator<'a, K, V> {\n+        TreeMapMutIterator {\n+            stack: ~[],\n+            node: mut_deref(&mut self.root),\n+            remaining_min: self.length,\n+            remaining_max: self.length\n+        }\n+    }\n+    /// Get a lazy reverse iterator over the key-value pairs in the\n+    /// map, with the values being mutable.\n+    pub fn mut_rev_iter<'a>(&'a mut self) -> TreeMapMutRevIterator<'a, K, V> {\n+        TreeMapMutRevIterator{iter: self.mut_iter()}\n+    }\n+\n+\n     /// Get a lazy iterator that should be initialized using\n     /// `iter_traverse_left`/`iter_traverse_right`/`iter_traverse_complete`.\n     fn iter_for_traversal<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n@@ -212,6 +229,63 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n             }\n         }\n     }\n+    /// Get a lazy iterator that should be initialized using\n+    /// `mut_iter_traverse_left`/`mut_iter_traverse_right`/`mut_iter_traverse_complete`.\n+    fn mut_iter_for_traversal<'a>(&'a mut self) -> TreeMapMutIterator<'a, K, V> {\n+        TreeMapMutIterator {\n+            stack: ~[],\n+            node: mut_deref(&mut self.root),\n+            remaining_min: 0,\n+            remaining_max: self.length\n+        }\n+    }\n+\n+    /// Return a lazy value iterator to the first key-value pair (with\n+    /// the value being mutable) whose key is not less than `k`.\n+    ///\n+    /// If all keys in map are less than `k` an empty iterator is\n+    /// returned.\n+    pub fn mut_lower_bound<'a>(&'a mut self, k: &K) -> TreeMapMutIterator<'a, K, V> {\n+        let mut iter = self.mut_iter_for_traversal();\n+        loop {\n+            if !iter.node.is_null() {\n+                let node_k = unsafe {&(*iter.node).key};\n+                match k.cmp(node_k) {\n+                    Less => mut_iter_traverse_left(&mut iter),\n+                    Greater => mut_iter_traverse_right(&mut iter),\n+                    Equal => {\n+                        mut_iter_traverse_complete(&mut iter);\n+                        return iter;\n+                    }\n+                }\n+            } else {\n+                mut_iter_traverse_complete(&mut iter);\n+                return iter;\n+            }\n+        }\n+    }\n+\n+    /// Return a lazy iterator to the first key-value pair (with the\n+    /// value being mutable) whose key is greater than `k`.\n+    ///\n+    /// If all keys in map are not greater than `k` an empty iterator\n+    /// is returned.\n+    pub fn mut_upper_bound<'a>(&'a mut self, k: &K) -> TreeMapMutIterator<'a, K, V> {\n+        let mut iter = self.mut_iter_for_traversal();\n+        loop {\n+            if !iter.node.is_null() {\n+                let node_k = unsafe {&(*iter.node).key};\n+                match k.cmp(node_k) {\n+                  Less => mut_iter_traverse_left(&mut iter),\n+                  Greater => mut_iter_traverse_right(&mut iter),\n+                  Equal => mut_iter_traverse_right(&mut iter)\n+                }\n+            } else {\n+                mut_iter_traverse_complete(&mut iter);\n+                return iter;\n+            }\n+        }\n+    }\n \n     /// Get a lazy iterator that consumes the treemap.\n     pub fn move_iter(self) -> TreeMapMoveIterator<K, V> {\n@@ -340,6 +414,146 @@ fn iter_traverse_complete<'a, K, V>(it: &mut TreeMapIterator<'a, K, V>) {\n     }\n }\n \n+\n+fn mut_deref<K, V>(x: &mut Option<~TreeNode<K, V>>) -> *mut TreeNode<K, V> {\n+    match *x {\n+        Some(ref mut n) => {\n+            let n: &mut TreeNode<K, V> = *n;\n+            n as *mut TreeNode<K, V>\n+        }\n+        None => ptr::mut_null()\n+    }\n+}\n+\n+/// Lazy forward iterator over a map that allows for the mutation of\n+/// the values.\n+pub struct TreeMapMutIterator<'a, K, V> {\n+    priv stack: ~[&'a mut TreeNode<K, V>],\n+    // Unfortunately, we require some unsafe-ness to get around the\n+    // fact that we would be storing a reference *into* one of the\n+    // nodes in the stack.\n+    //\n+    // As far as the compiler knows, this would let us invalidate the\n+    // reference by assigning a new value to this node's position in\n+    // its parent, which would cause this current one to be\n+    // deallocated so this reference would be invalid. (i.e. the\n+    // compilers complaints are 100% correct.)\n+    //\n+    // However, as far as you humans reading this code know (or are\n+    // about to know, if you haven't read far enough down yet), we are\n+    // only reading from the TreeNode.{left,right} fields. the only\n+    // thing that is ever mutated is the .value field (although any\n+    // actual mutation that happens is done externally, by the\n+    // iterator consumer). So, don't be so concerned, rustc, we've got\n+    // it under control.\n+    //\n+    // (This field can legitimately be null.)\n+    priv node: *mut TreeNode<K, V>,\n+    priv remaining_min: uint,\n+    priv remaining_max: uint\n+}\n+\n+impl<'a, K, V> TreeMapMutIterator<'a, K, V> {\n+    #[inline(always)]\n+    fn next_(&mut self, forward: bool) -> Option<(&'a K, &'a mut V)> {\n+        while !self.stack.is_empty() || !self.node.is_null() {\n+            let node = self.node;\n+            if !node.is_null() {\n+                let node = unsafe {&mut *node};\n+                {\n+                    let next_node = if forward { &mut node.left } else { &mut node.right };\n+                    self.node = mut_deref(next_node);\n+                }\n+                self.stack.push(node);\n+            } else {\n+                let node = self.stack.pop();\n+                self.node = mut_deref(if forward { &mut node.right } else { &mut node.left });\n+                self.remaining_max -= 1;\n+                if self.remaining_min > 0 {\n+                    self.remaining_min -= 1;\n+                }\n+                return Some((&node.key, &mut node.value));\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for TreeMapMutIterator<'a, K, V> {\n+    /// Advance the iterator to the next node (in order) and return a\n+    /// tuple with a reference to the key and value. If there are no\n+    /// more nodes, return `None`.\n+    fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n+        self.next_(true)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (self.remaining_min, Some(self.remaining_max))\n+    }\n+}\n+\n+/// Lazy backward iterator over a map\n+pub struct TreeMapMutRevIterator<'a, K, V> {\n+    priv iter: TreeMapMutIterator<'a, K, V>,\n+}\n+\n+impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for TreeMapMutRevIterator<'a, K, V> {\n+    /// Advance the iterator to the next node (in order) and return a\n+    /// tuple with a reference to the key and value. If there are no\n+    /// more nodes, return `None`.\n+    fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n+        self.iter.next_(false)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n+/// iter_traverse_left, iter_traverse_right and iter_traverse_complete are used to\n+/// initialize TreeMapMutIterator pointing to element inside tree structure.\n+///\n+/// They should be used in following manner:\n+///   - create iterator using TreeMap::iter_for_traversal\n+///   - find required node using `iter_traverse_left`/`iter_traverse_right`\n+///     (current node is `TreeMapMutIterator::node` field)\n+///   - complete initialization with `iter_traverse_complete`\n+#[inline]\n+fn mut_iter_traverse_left<'a, K, V>(it: &mut TreeMapMutIterator<'a, K, V>) {\n+    // guaranteed to be non-null\n+    let node = unsafe {&mut *it.node};\n+    it.node = mut_deref(&mut node.left);\n+    it.stack.push(node);\n+}\n+\n+#[inline]\n+fn mut_iter_traverse_right<'a, K, V>(it: &mut TreeMapMutIterator<'a, K, V>) {\n+    // guaranteed to be non-null\n+    let node = unsafe {&mut *it.node};\n+    it.node = mut_deref(&mut node.right);\n+}\n+\n+/// iter_traverse_left, iter_traverse_right and iter_traverse_complete are used to\n+/// initialize TreeMapMutIterator pointing to element inside tree structure.\n+///\n+/// Completes traversal. Should be called before using iterator.\n+/// Iteration will start from `self.node`.\n+/// If `self.node` is None iteration will start from last node from which we\n+/// traversed left.\n+#[inline]\n+fn mut_iter_traverse_complete<'a, K, V>(it: &mut TreeMapMutIterator<'a, K, V>) {\n+    if !it.node.is_null() {\n+        unsafe {\n+            it.stack.push(&mut *it.node);\n+        }\n+        it.node = ptr::mut_null();\n+    }\n+}\n+\n+\n+\n /// Lazy forward iterator over a map that consumes the map while iterating\n pub struct TreeMapMoveIterator<K, V> {\n     priv stack: ~[TreeNode<K, V>],\n@@ -1129,6 +1343,69 @@ mod test_treemap {\n         }\n     }\n \n+    #[test]\n+    fn test_mut_iter() {\n+        let mut m = TreeMap::new();\n+        for i in range(0u, 10) {\n+            assert!(m.insert(i, 100 * i));\n+        }\n+\n+        for (i, (&k, v)) in m.mut_iter().enumerate() {\n+            *v += k * 10 + i; // 000 + 00 + 0, 100 + 10 + 1, ...\n+        }\n+\n+        for (&k, &v) in m.iter() {\n+            assert_eq!(v, 111 * k);\n+        }\n+    }\n+    #[test]\n+    fn test_mut_rev_iter() {\n+        let mut m = TreeMap::new();\n+        for i in range(0u, 10) {\n+            assert!(m.insert(i, 100 * i));\n+        }\n+\n+        for (i, (&k, v)) in m.mut_rev_iter().enumerate() {\n+            *v += k * 10 + (9 - i); // 900 + 90 + (9 - 0), 800 + 80 + (9 - 1), ...\n+        }\n+\n+        for (&k, &v) in m.iter() {\n+            assert_eq!(v, 111 * k);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_mut_interval_iter() {\n+        let mut m_lower = TreeMap::new();\n+        let mut m_upper = TreeMap::new();\n+        for i in range(1, 100) {\n+            assert!(m_lower.insert(i * 2, i * 4));\n+            assert!(m_upper.insert(i * 2, i * 4));\n+        }\n+\n+        for i in range(1, 199) {\n+            let mut lb_it = m_lower.mut_lower_bound(&i);\n+            let (&k, v) = lb_it.next().unwrap();\n+            let lb = i + i % 2;\n+            assert_eq!(lb, k);\n+            *v -= k;\n+        }\n+        for i in range(0, 198) {\n+            let mut ub_it = m_upper.mut_upper_bound(&i);\n+            let (&k, v) = ub_it.next().unwrap();\n+            let ub = i + 2 - i % 2;\n+            assert_eq!(ub, k);\n+            *v -= k;\n+        }\n+\n+        assert!(m_lower.mut_lower_bound(&199).next().is_none());\n+\n+        assert!(m_upper.mut_upper_bound(&198).next().is_none());\n+\n+        assert!(m_lower.iter().all(|(_, &x)| x == 0));\n+        assert!(m_upper.iter().all(|(_, &x)| x == 0));\n+    }\n+\n     #[test]\n     fn test_eq() {\n         let mut a = TreeMap::new();"}]}