{"sha": "83d44f87e5fe8935c1f8a5f26409a99286675650", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzZDQ0Zjg3ZTVmZTg5MzVjMWY4YTVmMjY0MDlhOTkyODY2NzU2NTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-15T08:04:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-15T08:04:05Z"}, "message": "auto merge of #7125 : alexcrichton/rust/rusti-issues, r=brson\n\nThis un-reverts the reverts of the rusti commits made awhile back. These were reverted for an LLVM failure in rustpkg. I believe that this is not a problem with these commits, but rather that rustc is being used in parallel for rustpkg tests (in-process). This is not working yet (almost! see #7011), so I serialized all the tests to run one after another.\r\n\r\n@brson, I'm mainly just guessing as to the cause of the LLVM failures in rustpkg tests. I'm confident that running tests in parallel is more likely to be the problem than those commits I made.\r\n\r\nAdditionally, this fixes two recently reported issues with rusti.", "tree": {"sha": "39c02f29ab7f9a40bd2ed2015279a806d5956657", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39c02f29ab7f9a40bd2ed2015279a806d5956657"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83d44f87e5fe8935c1f8a5f26409a99286675650", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83d44f87e5fe8935c1f8a5f26409a99286675650", "html_url": "https://github.com/rust-lang/rust/commit/83d44f87e5fe8935c1f8a5f26409a99286675650", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83d44f87e5fe8935c1f8a5f26409a99286675650/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d1065e913e6d50ddb1a157f81bb7752caeca329", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d1065e913e6d50ddb1a157f81bb7752caeca329", "html_url": "https://github.com/rust-lang/rust/commit/7d1065e913e6d50ddb1a157f81bb7752caeca329"}, {"sha": "9c3b1cbc19b31537ef1a0a904806ad46c9923f75", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c3b1cbc19b31537ef1a0a904806ad46c9923f75", "html_url": "https://github.com/rust-lang/rust/commit/9c3b1cbc19b31537ef1a0a904806ad46c9923f75"}], "stats": {"total": 455, "additions": 241, "deletions": 214}, "files": [{"sha": "c22a432ad78de50417187bd64171be3b9a735233", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 55, "deletions": 51, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=83d44f87e5fe8935c1f8a5f26409a99286675650", "patch": "@@ -101,34 +101,21 @@ pub mod jit {\n     use back::link::llvm_err;\n     use driver::session::Session;\n     use lib::llvm::llvm;\n-    use lib::llvm::{ModuleRef, PassManagerRef};\n+    use lib::llvm::{ModuleRef, ContextRef};\n     use metadata::cstore;\n \n     use core::cast;\n-    use core::libc::c_int;\n     use core::ptr;\n     use core::str;\n-\n-    pub mod rusti {\n-        #[nolink]\n-        #[abi = \"rust-intrinsic\"]\n-        pub extern \"rust-intrinsic\" {\n-            pub fn morestack_addr() -> *();\n-        }\n-    }\n-\n-    pub struct Closure {\n-        code: *(),\n-        env: *(),\n-    }\n+    use core::sys;\n+    use core::unstable::intrinsics;\n \n     pub fn exec(sess: Session,\n-                pm: PassManagerRef,\n+                c: ContextRef,\n                 m: ModuleRef,\n-                opt: c_int,\n                 stacks: bool) {\n         unsafe {\n-            let manager = llvm::LLVMRustPrepareJIT(rusti::morestack_addr());\n+            let manager = llvm::LLVMRustPrepareJIT(intrinsics::morestack_addr());\n \n             // We need to tell JIT where to resolve all linked\n             // symbols from. The equivalent of -lstd, -lcore, etc.\n@@ -152,26 +139,43 @@ pub mod jit {\n                     });\n             }\n \n-            // The execute function will return a void pointer\n-            // to the _rust_main function. We can do closure\n-            // magic here to turn it straight into a callable rust\n-            // closure. It will also cleanup the memory manager\n-            // for us.\n-\n-            let entry = llvm::LLVMRustExecuteJIT(manager,\n-                                                 pm, m, opt, stacks);\n-\n-            if ptr::is_null(entry) {\n-                llvm_err(sess, ~\"Could not JIT\");\n-            } else {\n-                let closure = Closure {\n-                    code: entry,\n-                    env: ptr::null()\n-                };\n-                let func: &fn() = cast::transmute(closure);\n+            // We custom-build a JIT execution engine via some rust wrappers\n+            // first. This wrappers takes ownership of the module passed in.\n+            let ee = llvm::LLVMRustBuildJIT(manager, m, stacks);\n+            if ee.is_null() {\n+                llvm::LLVMContextDispose(c);\n+                llvm_err(sess, ~\"Could not create the JIT\");\n+            }\n \n-                func();\n+            // Next, we need to get a handle on the _rust_main function by\n+            // looking up it's corresponding ValueRef and then requesting that\n+            // the execution engine compiles the function.\n+            let fun = do str::as_c_str(\"_rust_main\") |entry| {\n+                llvm::LLVMGetNamedFunction(m, entry)\n+            };\n+            if fun.is_null() {\n+                llvm::LLVMDisposeExecutionEngine(ee);\n+                llvm::LLVMContextDispose(c);\n+                llvm_err(sess, ~\"Could not find _rust_main in the JIT\");\n             }\n+\n+            // Finally, once we have the pointer to the code, we can do some\n+            // closure magic here to turn it straight into a callable rust\n+            // closure\n+            let code = llvm::LLVMGetPointerToGlobal(ee, fun);\n+            assert!(!code.is_null());\n+            let closure = sys::Closure {\n+                code: code,\n+                env: ptr::null()\n+            };\n+            let func: &fn() = cast::transmute(closure);\n+            func();\n+\n+            // Sadly, there currently is no interface to re-use this execution\n+            // engine, so it's disposed of here along with the context to\n+            // prevent leaks.\n+            llvm::LLVMDisposeExecutionEngine(ee);\n+            llvm::LLVMContextDispose(c);\n         }\n     }\n }\n@@ -188,6 +192,7 @@ pub mod write {\n     use driver::session;\n     use lib::llvm::llvm;\n     use lib::llvm::{ModuleRef, mk_pass_manager, mk_target_data};\n+    use lib::llvm::{ContextRef};\n     use lib;\n \n     use back::passes;\n@@ -206,6 +211,7 @@ pub mod write {\n     }\n \n     pub fn run_passes(sess: Session,\n+                      llcx: ContextRef,\n                       llmod: ModuleRef,\n                       output_type: output_type,\n                       output: &Path) {\n@@ -261,7 +267,17 @@ pub mod write {\n             debug!(\"Running Module Optimization Pass\");\n             mpm.run(llmod);\n \n-            if is_object_or_assembly_or_exe(output_type) || opts.jit {\n+            if opts.jit {\n+                // If we are using JIT, go ahead and create and execute the\n+                // engine now.  JIT execution takes ownership of the module and\n+                // context, so don't dispose and return.\n+                jit::exec(sess, llcx, llmod, true);\n+\n+                if sess.time_llvm_passes() {\n+                    llvm::LLVMRustPrintPassTimings();\n+                }\n+                return;\n+            } else if is_object_or_assembly_or_exe(output_type) {\n                 let LLVMOptNone       = 0 as c_int; // -O0\n                 let LLVMOptLess       = 1 as c_int; // -O1\n                 let LLVMOptDefault    = 2 as c_int; // -O2, -Os\n@@ -274,20 +290,6 @@ pub mod write {\n                   session::Aggressive => LLVMOptAggressive\n                 };\n \n-                if opts.jit {\n-                    // If we are using JIT, go ahead and create and\n-                    // execute the engine now.\n-                    // JIT execution takes ownership of the module,\n-                    // so don't dispose and return.\n-\n-                    jit::exec(sess, pm.llpm, llmod, CodeGenOptLevel, true);\n-\n-                    if sess.time_llvm_passes() {\n-                        llvm::LLVMRustPrintPassTimings();\n-                    }\n-                    return;\n-                }\n-\n                 let FileType;\n                 if output_type == output_type_object ||\n                        output_type == output_type_exe {\n@@ -348,6 +350,7 @@ pub mod write {\n                 // Clean up and return\n \n                 llvm::LLVMDisposeModule(llmod);\n+                llvm::LLVMContextDispose(llcx);\n                 if sess.time_llvm_passes() {\n                     llvm::LLVMRustPrintPassTimings();\n                 }\n@@ -366,6 +369,7 @@ pub mod write {\n             }\n \n             llvm::LLVMDisposeModule(llmod);\n+            llvm::LLVMContextDispose(llcx);\n             if sess.time_llvm_passes() { llvm::LLVMRustPrintPassTimings(); }\n         }\n     }"}, {"sha": "9274eb879f1ea7f85da42307fe63cf687dbf2783", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=83d44f87e5fe8935c1f8a5f26409a99286675650", "patch": "@@ -215,7 +215,7 @@ pub fn compile_rest(sess: Session,\n \n     let mut crate = crate_opt.unwrap();\n \n-    let (llmod, link_meta) = {\n+    let (llcx, llmod, link_meta) = {\n     crate = time(time_passes, ~\"intrinsic injection\", ||\n                  front::intrinsic_inject::inject_intrinsic(sess, crate));\n \n@@ -338,14 +338,14 @@ pub fn compile_rest(sess: Session,\n         let obj_filename = outputs.obj_filename.with_filetype(\"s\");\n \n         time(time_passes, ~\"LLVM passes\", ||\n-            link::write::run_passes(sess, llmod, output_type,\n-                            &obj_filename));\n+            link::write::run_passes(sess, llcx, llmod, output_type,\n+                                    &obj_filename));\n \n         link::write::run_ndk(sess, &obj_filename, &outputs.obj_filename);\n     } else {\n         time(time_passes, ~\"LLVM passes\", ||\n-            link::write::run_passes(sess, llmod, sess.opts.output_type,\n-                                &outputs.obj_filename));\n+            link::write::run_passes(sess, llcx, llmod, sess.opts.output_type,\n+                                    &outputs.obj_filename));\n     }\n \n     let stop_after_codegen ="}, {"sha": "289bb4f63f59e164dcb589293e17638cce3bef14", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 18, "deletions": 69, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=83d44f87e5fe8935c1f8a5f26409a99286675650", "patch": "@@ -205,6 +205,8 @@ pub enum BasicBlock_opaque {}\n pub type BasicBlockRef = *BasicBlock_opaque;\n pub enum Builder_opaque {}\n pub type BuilderRef = *Builder_opaque;\n+pub enum ExecutionEngine_opaque {}\n+pub type ExecutionEngineRef = *ExecutionEngine_opaque;\n pub enum MemoryBuffer_opaque {}\n pub type MemoryBufferRef = *MemoryBuffer_opaque;\n pub enum PassManager_opaque {}\n@@ -223,7 +225,7 @@ pub enum Pass_opaque {}\n pub type PassRef = *Pass_opaque;\n \n pub mod llvm {\n-    use super::{AtomicBinOp, AtomicOrdering, BasicBlockRef};\n+    use super::{AtomicBinOp, AtomicOrdering, BasicBlockRef, ExecutionEngineRef};\n     use super::{Bool, BuilderRef, ContextRef, MemoryBufferRef, ModuleRef};\n     use super::{ObjectFileRef, Opcode, PassManagerRef, PassManagerBuilderRef};\n     use super::{SectionIteratorRef, TargetDataRef, TypeKind, TypeRef, UseRef};\n@@ -239,23 +241,21 @@ pub mod llvm {\n         #[fast_ffi]\n         pub unsafe fn LLVMContextCreate() -> ContextRef;\n         #[fast_ffi]\n-        pub unsafe fn LLVMGetGlobalContext() -> ContextRef;\n-        #[fast_ffi]\n         pub unsafe fn LLVMContextDispose(C: ContextRef);\n         #[fast_ffi]\n         pub unsafe fn LLVMGetMDKindIDInContext(C: ContextRef,\n                                            Name: *c_char,\n                                            SLen: c_uint)\n                                         -> c_uint;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMGetMDKindID(Name: *c_char, SLen: c_uint) -> c_uint;\n \n         /* Create and destroy modules. */\n         #[fast_ffi]\n         pub unsafe fn LLVMModuleCreateWithNameInContext(ModuleID: *c_char,\n                                                     C: ContextRef)\n                                                  -> ModuleRef;\n         #[fast_ffi]\n+        pub unsafe fn LLVMGetModuleContext(M: ModuleRef) -> ContextRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMDisposeModule(M: ModuleRef);\n \n         /** Data layout. See Module::getDataLayout. */\n@@ -300,18 +300,6 @@ pub mod llvm {\n         pub unsafe fn LLVMIntTypeInContext(C: ContextRef,\n                                            NumBits: c_uint) -> TypeRef;\n \n-        #[fast_ffi]\n-        pub unsafe fn LLVMInt1Type() -> TypeRef;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMInt8Type() -> TypeRef;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMInt16Type() -> TypeRef;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMInt32Type() -> TypeRef;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMInt64Type() -> TypeRef;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMIntType(NumBits: c_uint) -> TypeRef;\n         #[fast_ffi]\n         pub unsafe fn LLVMGetIntTypeWidth(IntegerTy: TypeRef) -> c_uint;\n \n@@ -327,17 +315,6 @@ pub mod llvm {\n         #[fast_ffi]\n         pub unsafe fn LLVMPPCFP128TypeInContext(C: ContextRef) -> TypeRef;\n \n-        #[fast_ffi]\n-        pub unsafe fn LLVMFloatType() -> TypeRef;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMDoubleType() -> TypeRef;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMX86FP80Type() -> TypeRef;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMFP128Type() -> TypeRef;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMPPCFP128Type() -> TypeRef;\n-\n         /* Operations on function types */\n         #[fast_ffi]\n         pub unsafe fn LLVMFunctionType(ReturnType: TypeRef,\n@@ -361,11 +338,6 @@ pub mod llvm {\n                                               ElementCount: c_uint,\n                                               Packed: Bool) -> TypeRef;\n         #[fast_ffi]\n-        pub unsafe fn LLVMStructType(ElementTypes: *TypeRef,\n-                                     ElementCount: c_uint,\n-                                     Packed: Bool)\n-                                  -> TypeRef;\n-        #[fast_ffi]\n         pub unsafe fn LLVMCountStructElementTypes(StructTy: TypeRef)\n                                                -> c_uint;\n         #[fast_ffi]\n@@ -393,6 +365,10 @@ pub mod llvm {\n         pub unsafe fn LLVMGetPointerAddressSpace(PointerTy: TypeRef)\n                                               -> c_uint;\n         #[fast_ffi]\n+        pub unsafe fn LLVMGetPointerToGlobal(EE: ExecutionEngineRef,\n+                                             V: ValueRef)\n+                                              -> *();\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetVectorSize(VectorTy: TypeRef) -> c_uint;\n \n         /* Operations on other types */\n@@ -403,13 +379,6 @@ pub mod llvm {\n         #[fast_ffi]\n         pub unsafe fn LLVMMetadataTypeInContext(C: ContextRef) -> TypeRef;\n \n-        #[fast_ffi]\n-        pub unsafe fn LLVMVoidType() -> TypeRef;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMLabelType() -> TypeRef;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMMetadataType() -> TypeRef;\n-\n         /* Operations on all values */\n         #[fast_ffi]\n         pub unsafe fn LLVMTypeOf(Val: ValueRef) -> TypeRef;\n@@ -482,15 +451,11 @@ pub mod llvm {\n                                         SLen: c_uint)\n                                      -> ValueRef;\n         #[fast_ffi]\n-        pub unsafe fn LLVMMDString(Str: *c_char, SLen: c_uint) -> ValueRef;\n-        #[fast_ffi]\n         pub unsafe fn LLVMMDNodeInContext(C: ContextRef,\n                                       Vals: *ValueRef,\n                                       Count: c_uint)\n                                    -> ValueRef;\n         #[fast_ffi]\n-        pub unsafe fn LLVMMDNode(Vals: *ValueRef, Count: c_uint) -> ValueRef;\n-        #[fast_ffi]\n         pub unsafe fn LLVMAddNamedMetadataOperand(M: ModuleRef, Str: *c_char,\n                                        Val: ValueRef);\n \n@@ -544,20 +509,11 @@ pub mod llvm {\n                                                Packed: Bool) -> ValueRef;\n \n         #[fast_ffi]\n-        pub unsafe fn LLVMConstString(Str: *c_char,\n-                                      Length: c_uint,\n-                                      DontNullTerminate: Bool)\n-                                   -> ValueRef;\n-        #[fast_ffi]\n         pub unsafe fn LLVMConstArray(ElementTy: TypeRef,\n                                      ConstantVals: *ValueRef,\n                                      Length: c_uint)\n                                   -> ValueRef;\n         #[fast_ffi]\n-        pub unsafe fn LLVMConstStruct(ConstantVals: *ValueRef,\n-                                      Count: c_uint,\n-                                      Packed: Bool) -> ValueRef;\n-        #[fast_ffi]\n         pub unsafe fn LLVMConstVector(ScalarConstantVals: *ValueRef,\n                                       Size: c_uint) -> ValueRef;\n \n@@ -970,15 +926,6 @@ pub mod llvm {\n                                                     BB: BasicBlockRef,\n                                                     Name: *c_char)\n                                                  -> BasicBlockRef;\n-\n-        #[fast_ffi]\n-        pub unsafe fn LLVMAppendBasicBlock(Fn: ValueRef,\n-                                       Name: *c_char)\n-                                    -> BasicBlockRef;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMInsertBasicBlock(InsertBeforeBB: BasicBlockRef,\n-                                       Name: *c_char)\n-                                    -> BasicBlockRef;\n         #[fast_ffi]\n         pub unsafe fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n \n@@ -1039,8 +986,6 @@ pub mod llvm {\n         #[fast_ffi]\n         pub unsafe fn LLVMCreateBuilderInContext(C: ContextRef) -> BuilderRef;\n         #[fast_ffi]\n-        pub unsafe fn LLVMCreateBuilder() -> BuilderRef;\n-        #[fast_ffi]\n         pub unsafe fn LLVMPositionBuilder(Builder: BuilderRef,\n                                           Block: BasicBlockRef,\n                                           Instr: ValueRef);\n@@ -1064,6 +1009,8 @@ pub mod llvm {\n                                                 Name: *c_char);\n         #[fast_ffi]\n         pub unsafe fn LLVMDisposeBuilder(Builder: BuilderRef);\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDisposeExecutionEngine(EE: ExecutionEngineRef);\n \n         /* Metadata */\n         #[fast_ffi]\n@@ -1880,11 +1827,9 @@ pub mod llvm {\n \n         /** Execute the JIT engine. */\n         #[fast_ffi]\n-        pub unsafe fn LLVMRustExecuteJIT(MM: *(),\n-                              PM: PassManagerRef,\n+        pub unsafe fn LLVMRustBuildJIT(MM: *(),\n                               M: ModuleRef,\n-                              OptLevel: c_int,\n-                              EnableSegmentedStacks: bool) -> *();\n+                              EnableSegmentedStacks: bool) -> ExecutionEngineRef;\n \n         /** Parses the bitcode in the given memory buffer. */\n         #[fast_ffi]\n@@ -1893,7 +1838,8 @@ pub mod llvm {\n \n         /** Parses LLVM asm in the given file */\n         #[fast_ffi]\n-        pub unsafe fn LLVMRustParseAssemblyFile(Filename: *c_char)\n+        pub unsafe fn LLVMRustParseAssemblyFile(Filename: *c_char,\n+                                                C: ContextRef)\n                                              -> ModuleRef;\n \n         #[fast_ffi]\n@@ -1909,6 +1855,9 @@ pub mod llvm {\n         #[fast_ffi]\n         pub unsafe fn LLVMRustPrintPassTimings();\n \n+        #[fast_ffi]\n+        pub unsafe fn LLVMRustStartMultithreading() -> bool;\n+\n         #[fast_ffi]\n         pub unsafe fn LLVMStructCreateNamed(C: ContextRef, Name: *c_char)\n                                          -> TypeRef;"}, {"sha": "1eb5936e314b2bc5cd39f6283f9126607c12df88", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=83d44f87e5fe8935c1f8a5f26409a99286675650", "patch": "@@ -29,7 +29,7 @@ use back::link::{mangle_exported_name};\n use back::{link, abi, upcall};\n use driver::session;\n use driver::session::Session;\n-use lib::llvm::{ModuleRef, ValueRef, TypeRef, BasicBlockRef};\n+use lib::llvm::{ContextRef, ModuleRef, ValueRef, TypeRef, BasicBlockRef};\n use lib::llvm::{True, False};\n use lib::llvm::{llvm, mk_target_data, mk_type_names};\n use lib;\n@@ -72,6 +72,7 @@ use core::libc::c_uint;\n use core::str;\n use core::uint;\n use core::vec;\n+use core::local_data;\n use extra::time;\n use syntax::ast::ident;\n use syntax::ast_map::{path, path_elt_to_str, path_name};\n@@ -1186,7 +1187,7 @@ pub fn new_block(cx: fn_ctxt, parent: Option<block>, kind: block_kind,\n     };\n     unsafe {\n         let llbb = str::as_c_str(cx.ccx.sess.str_of(s), |buf| {\n-            llvm::LLVMAppendBasicBlock(cx.llfn, buf)\n+            llvm::LLVMAppendBasicBlockInContext(cx.ccx.llcx, cx.llfn, buf)\n         });\n         let bcx = mk_block(llbb,\n                            parent,\n@@ -1553,11 +1554,12 @@ pub struct BasicBlocks {\n // Creates the standard set of basic blocks for a function\n pub fn mk_standard_basic_blocks(llfn: ValueRef) -> BasicBlocks {\n     unsafe {\n+        let cx = task_llcx();\n         BasicBlocks {\n             sa: str::as_c_str(\"static_allocas\",\n-                           |buf| llvm::LLVMAppendBasicBlock(llfn, buf)),\n+                           |buf| llvm::LLVMAppendBasicBlockInContext(cx, llfn, buf)),\n             rt: str::as_c_str(\"return\",\n-                           |buf| llvm::LLVMAppendBasicBlock(llfn, buf))\n+                           |buf| llvm::LLVMAppendBasicBlockInContext(cx, llfn, buf))\n         }\n     }\n }\n@@ -2340,7 +2342,7 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n         };\n         let llbb = str::as_c_str(\"top\", |buf| {\n             unsafe {\n-                llvm::LLVMAppendBasicBlock(llfn, buf)\n+                llvm::LLVMAppendBasicBlockInContext(ccx.llcx, llfn, buf)\n             }\n         });\n         let bld = ccx.builder.B;\n@@ -2658,10 +2660,10 @@ pub fn declare_intrinsics(llmod: ModuleRef) -> HashMap<&'static str, ValueRef> {\n                            T_void()));\n     let memcpy32 =\n         decl_cdecl_fn(llmod, \"llvm.memcpy.p0i8.p0i8.i32\",\n-                      T_fn(copy T_memcpy32_args, T_void()));\n+                      T_fn(T_memcpy32_args, T_void()));\n     let memcpy64 =\n         decl_cdecl_fn(llmod, \"llvm.memcpy.p0i8.p0i8.i64\",\n-                      T_fn(copy T_memcpy64_args, T_void()));\n+                      T_fn(T_memcpy64_args, T_void()));\n     let memmove32 =\n         decl_cdecl_fn(llmod, \"llvm.memmove.p0i8.p0i8.i32\",\n                       T_fn(T_memcpy32_args, T_void()));\n@@ -3015,7 +3017,7 @@ pub fn trans_crate(sess: session::Session,\n                    tcx: ty::ctxt,\n                    output: &Path,\n                    emap2: resolve::ExportMap2,\n-                   maps: astencode::Maps) -> (ModuleRef, LinkMeta) {\n+                   maps: astencode::Maps) -> (ContextRef, ModuleRef, LinkMeta) {\n \n     let symbol_hasher = @mut hash::default_state();\n     let link_meta = link::build_link_meta(sess, crate, output, symbol_hasher);\n@@ -3037,9 +3039,15 @@ pub fn trans_crate(sess: session::Session,\n     let llmod_id = link_meta.name.to_owned() + \".rc\";\n \n     unsafe {\n+        // FIXME(#6511): get LLVM building with --enable-threads so this\n+        //               function can be called\n+        // if !llvm::LLVMRustStartMultithreading() {\n+        //     sess.bug(\"couldn't enable multi-threaded LLVM\");\n+        // }\n+        let llcx = llvm::LLVMContextCreate();\n+        set_task_llcx(llcx);\n         let llmod = str::as_c_str(llmod_id, |buf| {\n-            llvm::LLVMModuleCreateWithNameInContext\n-                (buf, llvm::LLVMGetGlobalContext())\n+            llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n         });\n         let data_layout: &str = sess.targ_cfg.target_strs.data_layout;\n         let targ_triple: &str = sess.targ_cfg.target_strs.target_triple;\n@@ -3070,6 +3078,7 @@ pub fn trans_crate(sess: session::Session,\n         let ccx = @CrateContext {\n               sess: sess,\n               llmod: llmod,\n+              llcx: llcx,\n               td: td,\n               tn: tn,\n               externs: @mut HashMap::new(),\n@@ -3124,7 +3133,9 @@ pub fn trans_crate(sess: session::Session,\n               int_type: int_type,\n               float_type: float_type,\n               opaque_vec_type: T_opaque_vec(targ_cfg),\n-              builder: BuilderRef_res(unsafe { llvm::LLVMCreateBuilder() }),\n+              builder: BuilderRef_res(unsafe {\n+                  llvm::LLVMCreateBuilderInContext(llcx)\n+              }),\n               shape_cx: mk_ctxt(llmod),\n               crate_map: crate_map,\n               uses_gc: @mut false,\n@@ -3169,6 +3180,22 @@ pub fn trans_crate(sess: session::Session,\n                 io::println(fmt!(\"%-7u %s\", v, k));\n             }\n         }\n-        return (llmod, link_meta);\n+        unset_task_llcx();\n+        return (llcx, llmod, link_meta);\n     }\n }\n+\n+fn task_local_llcx_key(_v: @ContextRef) {}\n+\n+pub fn task_llcx() -> ContextRef {\n+    let opt = unsafe { local_data::local_data_get(task_local_llcx_key) };\n+    *opt.expect(\"task-local LLVMContextRef wasn't ever set!\")\n+}\n+\n+unsafe fn set_task_llcx(c: ContextRef) {\n+    local_data::local_data_set(task_local_llcx_key, @c);\n+}\n+\n+unsafe fn unset_task_llcx() {\n+    local_data::local_data_pop(task_local_llcx_key);\n+}"}, {"sha": "af10845181008cd1f779879eae2704a2d615125a", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=83d44f87e5fe8935c1f8a5f26409a99286675650", "patch": "@@ -564,7 +564,8 @@ pub fn LoadRangeAssert(cx: block, PointerVal: ValueRef, lo: c_ulonglong,\n \n         do vec::as_imm_buf([min, max]) |ptr, len| {\n             llvm::LLVMSetMetadata(value, lib::llvm::MD_range as c_uint,\n-                                  llvm::LLVMMDNode(ptr, len as c_uint));\n+                                  llvm::LLVMMDNodeInContext(cx.fcx.ccx.llcx,\n+                                                            ptr, len as c_uint));\n         }\n     }\n "}, {"sha": "3dd59c054357dde514b8b265859905fe2d2cc292", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=83d44f87e5fe8935c1f8a5f26409a99286675650", "patch": "@@ -18,6 +18,7 @@ use lib::llvm::{llvm, TypeRef, Integer, Pointer, Float, Double};\n use lib::llvm::{Struct, Array, Attribute};\n use lib::llvm::{StructRetAttribute};\n use lib::llvm::True;\n+use middle::trans::base::task_llcx;\n use middle::trans::common::*;\n use middle::trans::cabi::*;\n \n@@ -165,7 +166,7 @@ fn coerce_to_int(size: uint) -> ~[TypeRef] {\n     let r = size % 32;\n     if r > 0 {\n         unsafe {\n-            args.push(llvm::LLVMIntType(r as c_uint))\n+            args.push(llvm::LLVMIntTypeInContext(task_llcx(), r as c_uint))\n         }\n     }\n "}, {"sha": "ad591336a71708bedc38fbccbb0d16010a0db866", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=83d44f87e5fe8935c1f8a5f26409a99286675650", "patch": "@@ -326,7 +326,9 @@ pub fn load_environment(fcx: fn_ctxt,\n                 str::as_c_str(\"load_env\",\n                               |buf|\n                               unsafe {\n-                                llvm::LLVMAppendBasicBlock(fcx.llfn, buf)\n+                                llvm::LLVMAppendBasicBlockInContext(fcx.ccx.llcx,\n+                                                                    fcx.llfn,\n+                                                                    buf)\n                               });\n             fcx.llloadenv = Some(ll);\n             ll"}, {"sha": "ff2f3841040d1fa0d35f32b37d4120b0e6c3c9a6", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 47, "deletions": 26, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=83d44f87e5fe8935c1f8a5f26409a99286675650", "patch": "@@ -16,7 +16,7 @@ use back::{abi, upcall};\n use driver::session;\n use driver::session::Session;\n use lib::llvm::{ModuleRef, ValueRef, TypeRef, BasicBlockRef, BuilderRef};\n-use lib::llvm::{True, False, Bool};\n+use lib::llvm::{ContextRef, True, False, Bool};\n use lib::llvm::{llvm, TargetData, TypeNames, associate_type, name_has_type};\n use lib;\n use metadata::common::LinkMeta;\n@@ -160,6 +160,7 @@ pub type ExternMap = @mut HashMap<@str, ValueRef>;\n pub struct CrateContext {\n      sess: session::Session,\n      llmod: ModuleRef,\n+     llcx: ContextRef,\n      td: TargetData,\n      tn: @TypeNames,\n      externs: ExternMap,\n@@ -799,30 +800,44 @@ impl block_ {\n \n // LLVM type constructors.\n pub fn T_void() -> TypeRef {\n-    unsafe {\n-        return llvm::LLVMVoidType();\n-    }\n+    unsafe { return llvm::LLVMVoidTypeInContext(base::task_llcx()); }\n }\n \n pub fn T_nil() -> TypeRef {\n     return T_struct([], false)\n }\n \n-pub fn T_metadata() -> TypeRef { unsafe { return llvm::LLVMMetadataType(); } }\n+pub fn T_metadata() -> TypeRef {\n+    unsafe { return llvm::LLVMMetadataTypeInContext(base::task_llcx()); }\n+}\n \n-pub fn T_i1() -> TypeRef { unsafe { return llvm::LLVMInt1Type(); } }\n+pub fn T_i1() -> TypeRef {\n+    unsafe { return llvm::LLVMInt1TypeInContext(base::task_llcx()); }\n+}\n \n-pub fn T_i8() -> TypeRef { unsafe { return llvm::LLVMInt8Type(); } }\n+pub fn T_i8() -> TypeRef {\n+    unsafe { return llvm::LLVMInt8TypeInContext(base::task_llcx()); }\n+}\n \n-pub fn T_i16() -> TypeRef { unsafe { return llvm::LLVMInt16Type(); } }\n+pub fn T_i16() -> TypeRef {\n+    unsafe { return llvm::LLVMInt16TypeInContext(base::task_llcx()); }\n+}\n \n-pub fn T_i32() -> TypeRef { unsafe { return llvm::LLVMInt32Type(); } }\n+pub fn T_i32() -> TypeRef {\n+    unsafe { return llvm::LLVMInt32TypeInContext(base::task_llcx()); }\n+}\n \n-pub fn T_i64() -> TypeRef { unsafe { return llvm::LLVMInt64Type(); } }\n+pub fn T_i64() -> TypeRef {\n+    unsafe { return llvm::LLVMInt64TypeInContext(base::task_llcx()); }\n+}\n \n-pub fn T_f32() -> TypeRef { unsafe { return llvm::LLVMFloatType(); } }\n+pub fn T_f32() -> TypeRef {\n+    unsafe { return llvm::LLVMFloatTypeInContext(base::task_llcx()); }\n+}\n \n-pub fn T_f64() -> TypeRef { unsafe { return llvm::LLVMDoubleType(); } }\n+pub fn T_f64() -> TypeRef {\n+    unsafe { return llvm::LLVMDoubleTypeInContext(base::task_llcx()); }\n+}\n \n pub fn T_bool() -> TypeRef { return T_i8(); }\n \n@@ -882,8 +897,8 @@ pub fn T_size_t(targ_cfg: @session::config) -> TypeRef {\n pub fn T_fn(inputs: &[TypeRef], output: TypeRef) -> TypeRef {\n     unsafe {\n         return llvm::LLVMFunctionType(output, to_ptr(inputs),\n-                                   inputs.len() as c_uint,\n-                                   False);\n+                                      inputs.len() as c_uint,\n+                                      False);\n     }\n }\n \n@@ -905,16 +920,18 @@ pub fn T_root(t: TypeRef, addrspace: addrspace) -> TypeRef {\n \n pub fn T_struct(elts: &[TypeRef], packed: bool) -> TypeRef {\n     unsafe {\n-        return llvm::LLVMStructType(to_ptr(elts),\n-                                    elts.len() as c_uint,\n-                                    packed as Bool);\n+        return llvm::LLVMStructTypeInContext(base::task_llcx(),\n+                                             to_ptr(elts),\n+                                             elts.len() as c_uint,\n+                                             packed as Bool);\n     }\n }\n \n pub fn T_named_struct(name: &str) -> TypeRef {\n     unsafe {\n-        let c = llvm::LLVMGetGlobalContext();\n-        return str::as_c_str(name, |buf| llvm::LLVMStructCreateNamed(c, buf));\n+        return str::as_c_str(name, |buf| {\n+            llvm::LLVMStructCreateNamed(base::task_llcx(), buf)\n+        });\n     }\n }\n \n@@ -1168,7 +1185,8 @@ pub fn C_cstr(cx: @CrateContext, s: @str) -> ValueRef {\n         }\n \n         let sc = do str::as_c_str(s) |buf| {\n-            llvm::LLVMConstString(buf, s.len() as c_uint, False)\n+            llvm::LLVMConstStringInContext(cx.llcx, buf, s.len() as c_uint,\n+                                           False)\n         };\n         let g =\n             str::as_c_str(fmt!(\"str%u\", (cx.names)(\"str\").name),\n@@ -1197,7 +1215,8 @@ pub fn C_estr_slice(cx: @CrateContext, s: @str) -> ValueRef {\n pub fn C_postr(s: &str) -> ValueRef {\n     unsafe {\n         return do str::as_c_str(s) |buf| {\n-            llvm::LLVMConstString(buf, s.len() as c_uint, False)\n+            llvm::LLVMConstStringInContext(base::task_llcx(),\n+                                           buf, s.len() as c_uint, False)\n         };\n     }\n }\n@@ -1216,15 +1235,17 @@ pub fn C_zero_byte_arr(size: uint) -> ValueRef {\n pub fn C_struct(elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n         do vec::as_imm_buf(elts) |ptr, len| {\n-            llvm::LLVMConstStruct(ptr, len as c_uint, False)\n+            llvm::LLVMConstStructInContext(base::task_llcx(),\n+                                           ptr, len as c_uint, False)\n         }\n     }\n }\n \n pub fn C_packed_struct(elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n         do vec::as_imm_buf(elts) |ptr, len| {\n-            llvm::LLVMConstStruct(ptr, len as c_uint, True)\n+            llvm::LLVMConstStructInContext(base::task_llcx(),\n+                                           ptr, len as c_uint, True)\n         }\n     }\n }\n@@ -1240,21 +1261,21 @@ pub fn C_named_struct(T: TypeRef, elts: &[ValueRef]) -> ValueRef {\n pub fn C_array(ty: TypeRef, elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstArray(ty, vec::raw::to_ptr(elts),\n-                                 elts.len() as c_uint);\n+                                    elts.len() as c_uint);\n     }\n }\n \n pub fn C_bytes(bytes: &[u8]) -> ValueRef {\n     unsafe {\n-        return llvm::LLVMConstString(\n+        return llvm::LLVMConstStringInContext(base::task_llcx(),\n             cast::transmute(vec::raw::to_ptr(bytes)),\n             bytes.len() as c_uint, True);\n     }\n }\n \n pub fn C_bytes_plus_null(bytes: &[u8]) -> ValueRef {\n     unsafe {\n-        return llvm::LLVMConstString(\n+        return llvm::LLVMConstStringInContext(base::task_llcx(),\n             cast::transmute(vec::raw::to_ptr(bytes)),\n             bytes.len() as c_uint, False);\n     }"}, {"sha": "3bb9d4abab0f7b0de404e7c0c86b72f06c5c95c5", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=83d44f87e5fe8935c1f8a5f26409a99286675650", "patch": "@@ -13,6 +13,7 @@ use core::prelude::*;\n use driver::session;\n use lib::llvm::ValueRef;\n use lib::llvm::llvm;\n+use middle::trans::base::task_llcx;\n use middle::trans::common::*;\n use middle::trans::machine;\n use middle::trans::type_of;\n@@ -61,7 +62,9 @@ static DW_ATE_unsigned_char: int = 0x08;\n fn llstr(s: &str) -> ValueRef {\n     do str::as_c_str(s) |sbuf| {\n         unsafe {\n-            llvm::LLVMMDString(sbuf, s.len() as libc::c_uint)\n+            llvm::LLVMMDStringInContext(task_llcx(),\n+                                        sbuf,\n+                                        s.len() as libc::c_uint)\n         }\n     }\n }\n@@ -79,7 +82,9 @@ fn lli1(bval: bool) -> ValueRef {\n }\n fn llmdnode(elems: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        llvm::LLVMMDNode(vec::raw::to_ptr(elems), elems.len() as libc::c_uint)\n+        llvm::LLVMMDNodeInContext(task_llcx(),\n+                                  vec::raw::to_ptr(elems),\n+                                  elems.len() as libc::c_uint)\n     }\n }\n fn llunused() -> ValueRef {"}, {"sha": "2fff45678bcb54b203524770e8fd20c64f8a0d6e", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=83d44f87e5fe8935c1f8a5f26409a99286675650", "patch": "@@ -58,7 +58,7 @@ pub fn type_of_fn(cx: @CrateContext, inputs: &[ty::t], output: ty::t)\n         if output_is_immediate {\n             T_fn(atys, lloutputtype)\n         } else {\n-            T_fn(atys, llvm::LLVMVoidType())\n+            T_fn(atys, llvm::LLVMVoidTypeInContext(cx.llcx))\n         }\n     }\n }"}, {"sha": "06ec6769385c267a3f90666a730a7848c6cbb2d3", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=83d44f87e5fe8935c1f8a5f26409a99286675650", "patch": "@@ -421,7 +421,7 @@ pub fn run_line(repl: &mut Repl, in: @io::Reader, out: @io::Writer, line: ~str,\n     -> Option<Repl> {\n     if line.starts_with(\":\") {\n         // drop the : and the \\n (one byte each)\n-        let full = line.slice(1, line.len() - 1);\n+        let full = line.slice(1, line.len());\n         let split: ~[~str] = full.word_iter().transform(|s| s.to_owned()).collect();\n         let len = split.len();\n \n@@ -538,7 +538,7 @@ mod tests {\n \n     #[test]\n     fn run_all() {\n-        // FIXME(#6511):\n+        // FIXME(#7071):\n         // By default, unit tests are run in parallel. Rusti, on the other hand,\n         // does not enjoy doing this. I suspect that it is because the LLVM\n         // bindings are not thread-safe (when running parallel tests, some tests\n@@ -646,4 +646,14 @@ mod tests {\n             f()\n         \");\n     }\n+\n+    #[test]\n+    fn exit_quits() {\n+        let mut r = repl();\n+        assert!(r.running);\n+        let result = run_line(&mut r, io::stdin(), io::stdout(),\n+                              ~\":exit\", false);\n+        assert!(result.is_none());\n+        assert!(!r.running);\n+    }\n }"}, {"sha": "3b68fc030f5c935857006aadfd0950350ef698d8", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=83d44f87e5fe8935c1f8a5f26409a99286675650", "patch": "@@ -114,6 +114,17 @@ fn test_sysroot() -> Path {\n }\n \n #[test]\n+fn test_all() {\n+    // FIXME(#7071): these tests use rustc, so they can't be run in parallel\n+    //               until this issue is resolved\n+    test_make_dir_rwx();\n+    test_install_valid();\n+    test_install_invalid();\n+    test_install_url();\n+    test_package_ids_must_be_relative_path_like();\n+    test_package_version();\n+}\n+\n fn test_make_dir_rwx() {\n     let temp = &os::tmpdir();\n     let dir = temp.push(\"quux\");\n@@ -126,7 +137,6 @@ fn test_make_dir_rwx() {\n     assert!(os::remove_dir_recursive(&dir));\n }\n \n-#[test]\n fn test_install_valid() {\n     use path_util::installed_library_in_workspace;\n \n@@ -155,7 +165,6 @@ fn test_install_valid() {\n     assert!(!os::path_exists(&bench));\n }\n \n-#[test]\n fn test_install_invalid() {\n     use conditions::nonexistent_package::cond;\n     use cond1 = conditions::missing_pkg_files::cond;\n@@ -178,7 +187,6 @@ fn test_install_invalid() {\n     assert!(error_occurred && error1_occurred);\n }\n \n-#[test]\n fn test_install_url() {\n     let workspace = mkdtemp(&os::tmpdir(), \"test\").expect(\"couldn't create temp dir\");\n     let sysroot = test_sysroot();\n@@ -214,7 +222,6 @@ fn test_install_url() {\n     assert!(!os::path_exists(&bench));\n }\n \n-#[test]\n fn test_package_ids_must_be_relative_path_like() {\n     use conditions::bad_pkg_id::cond;\n \n@@ -255,7 +262,6 @@ fn test_package_ids_must_be_relative_path_like() {\n \n }\n \n-#[test]\n fn test_package_version() {\n     let temp_pkg_id = PkgId::new(\"github.com/catamorphism/test_pkg_version\");\n     match temp_pkg_id.version {"}, {"sha": "ba87624e2dde35d4740399d6317c0cacc6ea0edd", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=83d44f87e5fe8935c1f8a5f26409a99286675650", "patch": "@@ -329,12 +329,10 @@ LLVMRustLoadCrate(void* mem, const char* crate) {\n   return true;\n }\n \n-extern \"C\" void*\n-LLVMRustExecuteJIT(void* mem,\n-                   LLVMPassManagerRef PMR,\n-                   LLVMModuleRef M,\n-                   CodeGenOpt::Level OptLevel,\n-                   bool EnableSegmentedStacks) {\n+extern \"C\" LLVMExecutionEngineRef\n+LLVMRustBuildJIT(void* mem,\n+                 LLVMModuleRef M,\n+                 bool EnableSegmentedStacks) {\n \n   InitializeNativeTarget();\n   InitializeNativeTargetAsmPrinter();\n@@ -346,46 +344,28 @@ LLVMRustExecuteJIT(void* mem,\n   Options.JITEmitDebugInfo = true;\n   Options.NoFramePointerElim = true;\n   Options.EnableSegmentedStacks = EnableSegmentedStacks;\n-  PassManager *PM = unwrap<PassManager>(PMR);\n   RustMCJITMemoryManager* MM = (RustMCJITMemoryManager*) mem;\n-\n   assert(MM);\n \n-  PM->add(createBasicAliasAnalysisPass());\n-  PM->add(createInstructionCombiningPass());\n-  PM->add(createReassociatePass());\n-  PM->add(createGVNPass());\n-  PM->add(createCFGSimplificationPass());\n-  PM->add(createFunctionInliningPass());\n-  PM->add(createPromoteMemoryToRegisterPass());\n-  PM->run(*unwrap(M));\n-\n   ExecutionEngine* EE = EngineBuilder(unwrap(M))\n     .setErrorStr(&Err)\n     .setTargetOptions(Options)\n     .setJITMemoryManager(MM)\n-    .setOptLevel(OptLevel)\n     .setUseMCJIT(true)\n     .setAllocateGVsWithCode(false)\n     .create();\n \n   if(!EE || Err != \"\") {\n     LLVMRustError = Err.c_str();\n-    return 0;\n+    // The EngineBuilder only takes ownership of these two structures if the\n+    // create() call is successful, but here it wasn't successful.\n+    LLVMDisposeModule(M);\n+    delete MM;\n+    return NULL;\n   }\n \n   MM->invalidateInstructionCache();\n-  Function* func = EE->FindFunctionNamed(\"_rust_main\");\n-\n-  if(!func || Err != \"\") {\n-    LLVMRustError = Err.c_str();\n-    return 0;\n-  }\n-\n-  void* entry = EE->getPointerToFunction(func);\n-  assert(entry);\n-\n-  return entry;\n+  return wrap(EE);\n }\n \n extern \"C\" bool\n@@ -447,9 +427,10 @@ LLVMRustWriteOutputFile(LLVMPassManagerRef PMR,\n   return true;\n }\n \n-extern \"C\" LLVMModuleRef LLVMRustParseAssemblyFile(const char *Filename) {\n+extern \"C\" LLVMModuleRef LLVMRustParseAssemblyFile(LLVMContextRef C,\n+                                                   const char *Filename) {\n   SMDiagnostic d;\n-  Module *m = ParseAssemblyFile(Filename, d, getGlobalContext());\n+  Module *m = ParseAssemblyFile(Filename, d, *unwrap(C));\n   if (m) {\n     return wrap(m);\n   } else {\n@@ -499,9 +480,6 @@ extern \"C\" LLVMValueRef LLVMGetOrInsertFunction(LLVMModuleRef M,\n extern \"C\" LLVMTypeRef LLVMMetadataTypeInContext(LLVMContextRef C) {\n   return wrap(Type::getMetadataTy(*unwrap(C)));\n }\n-extern \"C\" LLVMTypeRef LLVMMetadataType(void) {\n-  return LLVMMetadataTypeInContext(LLVMGetGlobalContext());\n-}\n \n extern \"C\" LLVMValueRef LLVMBuildAtomicLoad(LLVMBuilderRef B,\n                                             LLVMValueRef source,\n@@ -561,3 +539,24 @@ extern \"C\" LLVMValueRef LLVMInlineAsm(LLVMTypeRef Ty,\n                                Constraints, HasSideEffects,\n                                IsAlignStack, (InlineAsm::AsmDialect) Dialect));\n }\n+\n+/**\n+ * This function is intended to be a threadsafe interface into enabling a\n+ * multithreaded LLVM. This is invoked at the start of the translation phase of\n+ * compilation to ensure that LLVM is ready.\n+ *\n+ * All of trans properly isolates LLVM with the use of a different\n+ * LLVMContextRef per task, thus allowing parallel compilation of different\n+ * crates in the same process. At the time of this writing, the use case for\n+ * this is unit tests for rusti, but there are possible other applications.\n+ */\n+extern \"C\" bool LLVMRustStartMultithreading() {\n+    static Mutex lock;\n+    bool ret = true;\n+    assert(lock.acquire());\n+    if (!LLVMIsMultithreaded()) {\n+        ret = LLVMStartMultithreaded();\n+    }\n+    assert(lock.release());\n+    return ret;\n+}"}, {"sha": "f5397165781995237b06337944d4a45128db3a36", "filename": "src/rustllvm/rustllvm.def.in", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Frustllvm%2Frustllvm.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Frustllvm%2Frustllvm.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.def.in?ref=83d44f87e5fe8935c1f8a5f26409a99286675650", "patch": "@@ -6,12 +6,14 @@ LLVMRustConstSmallInt\n LLVMRustConstInt\n LLVMRustLoadCrate\n LLVMRustPrepareJIT\n-LLVMRustExecuteJIT\n+LLVMRustBuildJIT\n LLVMRustParseBitcode\n LLVMRustParseAssemblyFile\n LLVMRustPrintPassTimings\n+LLVMRustStartMultithreading\n LLVMCreateObjectFile\n LLVMDisposeObjectFile\n+LLVMDisposeExecutionEngine\n LLVMGetSections\n LLVMDisposeSectionIterator\n LLVMIsSectionIteratorAtEnd\n@@ -319,7 +321,6 @@ LLVMGetFunctionAttr\n LLVMGetFunctionCallConv\n LLVMGetGC\n LLVMGetGlobalContext\n-LLVMGetGlobalContext\n LLVMGetGlobalParent\n LLVMGetGlobalPassRegistry\n LLVMGetIncomingBlock\n@@ -356,6 +357,7 @@ LLVMGetParamParent\n LLVMGetParamTypes\n LLVMGetParams\n LLVMGetPointerAddressSpace\n+LLVMGetPointerToGlobal\n LLVMGetPreviousBasicBlock\n LLVMGetPreviousFunction\n LLVMGetPreviousGlobal\n@@ -500,7 +502,6 @@ LLVMMDNode\n LLVMMDNodeInContext\n LLVMMDString\n LLVMMDStringInContext\n-LLVMMetadataType\n LLVMMetadataTypeInContext\n LLVMModuleCreateWithName\n LLVMModuleCreateWithNameInContext"}, {"sha": "6f11202800cd7de9dd60f414f6ec85ac1381dcb0", "filename": "src/rustllvm/rustllvm.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Frustllvm%2Frustllvm.h", "raw_url": "https://github.com/rust-lang/rust/raw/83d44f87e5fe8935c1f8a5f26409a99286675650/src%2Frustllvm%2Frustllvm.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.h?ref=83d44f87e5fe8935c1f8a5f26409a99286675650", "patch": "@@ -45,6 +45,7 @@\n #include \"llvm/Transforms/Vectorize.h\"\n #include \"llvm-c/Core.h\"\n #include \"llvm-c/BitReader.h\"\n+#include \"llvm-c/ExecutionEngine.h\"\n #include \"llvm-c/Object.h\"\n \n // Used by RustMCJITMemoryManager::getPointerToNamedFunction()"}]}