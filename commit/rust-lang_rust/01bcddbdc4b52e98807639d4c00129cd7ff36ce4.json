{"sha": "01bcddbdc4b52e98807639d4c00129cd7ff36ce4", "node_id": "C_kwDOAAsO6NoAKDAxYmNkZGJkYzRiNTJlOTg4MDc2MzlkNGMwMDEyOWNkN2ZmMzZjZTQ", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2021-09-17T07:13:16Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2021-09-21T06:24:23Z"}, "message": "`crates` is already deterministic", "tree": {"sha": "bbd76d2cb4075d4451a4df67552524b55b99185c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbd76d2cb4075d4451a4df67552524b55b99185c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01bcddbdc4b52e98807639d4c00129cd7ff36ce4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01bcddbdc4b52e98807639d4c00129cd7ff36ce4", "html_url": "https://github.com/rust-lang/rust/commit/01bcddbdc4b52e98807639d4c00129cd7ff36ce4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01bcddbdc4b52e98807639d4c00129cd7ff36ce4/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b9cc2068f3b4062d6cd2ff53c16617a1a4c0b0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b9cc2068f3b4062d6cd2ff53c16617a1a4c0b0e", "html_url": "https://github.com/rust-lang/rust/commit/5b9cc2068f3b4062d6cd2ff53c16617a1a4c0b0e"}], "stats": {"total": 72, "additions": 29, "deletions": 43}, "files": [{"sha": "cd368b8c56da6e720f025f982ca01627ebff47c5", "filename": "compiler/rustc_metadata/src/dependency_format.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/01bcddbdc4b52e98807639d4c00129cd7ff36ce4/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bcddbdc4b52e98807639d4c00129cd7ff36ce4/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs?ref=01bcddbdc4b52e98807639d4c00129cd7ff36ce4", "patch": "@@ -277,7 +277,7 @@ fn attempt_static(tcx: TyCtxt<'_>) -> Option<DependencyList> {\n     let all_crates_available_as_rlib = tcx\n         .crates(())\n         .iter()\n-        .cloned()\n+        .copied()\n         .filter_map(|cnum| {\n             if tcx.dep_kind(cnum).macros_only() {\n                 return None;\n@@ -291,10 +291,11 @@ fn attempt_static(tcx: TyCtxt<'_>) -> Option<DependencyList> {\n \n     // All crates are available in an rlib format, so we're just going to link\n     // everything in explicitly so long as it's actually required.\n-    let last_crate = tcx.crates(()).len();\n-    let mut ret = (1..last_crate + 1)\n-        .map(|cnum| {\n-            if tcx.dep_kind(CrateNum::new(cnum)) == CrateDepKind::Explicit {\n+    let mut ret = tcx\n+        .crates(())\n+        .iter()\n+        .map(|&cnum| {\n+            if tcx.dep_kind(cnum) == CrateDepKind::Explicit {\n                 Linkage::Static\n             } else {\n                 Linkage::NotLinked"}, {"sha": "7be0e32ef38dca3c9753defe7730ee817123e067", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 20, "deletions": 34, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/01bcddbdc4b52e98807639d4c00129cd7ff36ce4/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bcddbdc4b52e98807639d4c00129cd7ff36ce4/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=01bcddbdc4b52e98807639d4c00129cd7ff36ce4", "patch": "@@ -304,17 +304,7 @@ pub fn provide(providers: &mut Providers) {\n             // traversal, but not globally minimal across all crates.\n             let bfs_queue = &mut VecDeque::new();\n \n-            // Preferring shortest paths alone does not guarantee a\n-            // deterministic result; so sort by crate num to avoid\n-            // hashtable iteration non-determinism. This only makes\n-            // things as deterministic as crate-nums assignment is,\n-            // which is to say, its not deterministic in general. But\n-            // we believe that libstd is consistently assigned crate\n-            // num 1, so it should be enough to resolve #46112.\n-            let mut crates: Vec<CrateNum> = (*tcx.crates(())).to_owned();\n-            crates.sort();\n-\n-            for &cnum in crates.iter() {\n+            for &cnum in tcx.crates(()) {\n                 // Ignore crates without a corresponding local `extern crate` item.\n                 if tcx.missing_extern_crate_item(cnum) {\n                     continue;\n@@ -323,35 +313,31 @@ pub fn provide(providers: &mut Providers) {\n                 bfs_queue.push_back(DefId { krate: cnum, index: CRATE_DEF_INDEX });\n             }\n \n-            // (restrict scope of mutable-borrow of `visible_parent_map`)\n-            {\n-                let visible_parent_map = &mut visible_parent_map;\n-                let mut add_child = |bfs_queue: &mut VecDeque<_>, child: &Export, parent: DefId| {\n-                    if child.vis != ty::Visibility::Public {\n-                        return;\n-                    }\n+            let mut add_child = |bfs_queue: &mut VecDeque<_>, child: &Export, parent: DefId| {\n+                if child.vis != ty::Visibility::Public {\n+                    return;\n+                }\n \n-                    if let Some(child) = child.res.opt_def_id() {\n-                        match visible_parent_map.entry(child) {\n-                            Entry::Occupied(mut entry) => {\n-                                // If `child` is defined in crate `cnum`, ensure\n-                                // that it is mapped to a parent in `cnum`.\n-                                if child.is_local() && entry.get().is_local() {\n-                                    entry.insert(parent);\n-                                }\n-                            }\n-                            Entry::Vacant(entry) => {\n+                if let Some(child) = child.res.opt_def_id() {\n+                    match visible_parent_map.entry(child) {\n+                        Entry::Occupied(mut entry) => {\n+                            // If `child` is defined in crate `cnum`, ensure\n+                            // that it is mapped to a parent in `cnum`.\n+                            if child.is_local() && entry.get().is_local() {\n                                 entry.insert(parent);\n-                                bfs_queue.push_back(child);\n                             }\n                         }\n+                        Entry::Vacant(entry) => {\n+                            entry.insert(parent);\n+                            bfs_queue.push_back(child);\n+                        }\n                     }\n-                };\n+                }\n+            };\n \n-                while let Some(def) = bfs_queue.pop_front() {\n-                    for child in tcx.item_children(def).iter() {\n-                        add_child(bfs_queue, child, def);\n-                    }\n+            while let Some(def) = bfs_queue.pop_front() {\n+                for child in tcx.item_children(def).iter() {\n+                    add_child(bfs_queue, child, def);\n                 }\n             }\n "}, {"sha": "8509aa00bc0225de605385211c021cf16ab8f98e", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/01bcddbdc4b52e98807639d4c00129cd7ff36ce4/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bcddbdc4b52e98807639d4c00129cd7ff36ce4/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=01bcddbdc4b52e98807639d4c00129cd7ff36ce4", "patch": "@@ -1708,9 +1708,10 @@ impl EncodeContext<'a, 'tcx> {\n \n     fn encode_crate_deps(&mut self) -> Lazy<[CrateDep]> {\n         empty_proc_macro!(self);\n-        let crates = self.tcx.crates(());\n \n-        let mut deps = crates\n+        let deps = self\n+            .tcx\n+            .crates(())\n             .iter()\n             .map(|&cnum| {\n                 let dep = CrateDep {\n@@ -1724,8 +1725,6 @@ impl EncodeContext<'a, 'tcx> {\n             })\n             .collect::<Vec<_>>();\n \n-        deps.sort_by_key(|&(cnum, _)| cnum);\n-\n         {\n             // Sanity-check the crate numbers\n             let mut expected_cnum = 1;"}]}