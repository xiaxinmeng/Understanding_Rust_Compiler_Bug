{"sha": "87b064b249657c8e65079d01beb77409f69d49cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3YjA2NGIyNDk2NTdjOGU2NTA3OWQwMWJlYjc3NDA5ZjY5ZDQ5Y2Q=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-26T11:26:14Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-26T13:25:06Z"}, "message": "First stab at operator overloading\n\nWhen no built-in interpretation is found for one of the operators\nmentioned below, the typechecker will try to turn it into a method\ncall with the name written next to it. For binary operators, the\nmethod will be called on the LHS with the RHS as only parameter.\n\nBinary:\n\n    +   op_add\n    -   op_sub\n    *   op_mul\n    /   op_div\n    %   op_rem\n    &   op_and\n    |   op_or\n    ^   op_xor\n    <<  op_shift_left\n    >>  op_shift_right\n    >>> op_ashift_right\n\nUnary:\n\n    -   op_neg\n    !   op_not\n\nOverloading of the indexing ([]) operator isn't finished yet.\n\nIssue #1520", "tree": {"sha": "cecb525f7ddf7312521d1a65e93ea8531f23426e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cecb525f7ddf7312521d1a65e93ea8531f23426e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87b064b249657c8e65079d01beb77409f69d49cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87b064b249657c8e65079d01beb77409f69d49cd", "html_url": "https://github.com/rust-lang/rust/commit/87b064b249657c8e65079d01beb77409f69d49cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87b064b249657c8e65079d01beb77409f69d49cd/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1792d9ec96d680cb3ec257bfef84baffea352d80", "url": "https://api.github.com/repos/rust-lang/rust/commits/1792d9ec96d680cb3ec257bfef84baffea352d80", "html_url": "https://github.com/rust-lang/rust/commit/1792d9ec96d680cb3ec257bfef84baffea352d80"}], "stats": {"total": 411, "additions": 269, "deletions": 142}, "files": [{"sha": "41130766035327dd4af28f7c005e9444514b93c2", "filename": "src/comp/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87b064b249657c8e65079d01beb77409f69d49cd/src%2Fcomp%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87b064b249657c8e65079d01beb77409f69d49cd/src%2Fcomp%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fdriver.rs?ref=87b064b249657c8e65079d01beb77409f69d49cd", "patch": "@@ -162,12 +162,12 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n     let freevars =\n         time(time_passes, \"freevar finding\",\n              bind freevars::annotate_freevars(def_map, crate));\n-    time(time_passes, \"const checking\",\n-         bind middle::check_const::check_crate(sess, crate));\n     let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars);\n     let (method_map, dict_map) =\n         time(time_passes, \"typechecking\",\n              bind typeck::check_crate(ty_cx, impl_map, crate));\n+    time(time_passes, \"const checking\",\n+         bind middle::check_const::check_crate(sess, crate, method_map));\n \n     if upto == cu_typeck { ret {crate: crate, tcx: some(ty_cx)}; }\n "}, {"sha": "eec014a47f7271c166892f010befcd5c276bb76f", "filename": "src/comp/middle/check_const.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/87b064b249657c8e65079d01beb77409f69d49cd/src%2Fcomp%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87b064b249657c8e65079d01beb77409f69d49cd/src%2Fcomp%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_const.rs?ref=87b064b249657c8e65079d01beb77409f69d49cd", "patch": "@@ -2,11 +2,11 @@ import syntax::ast::*;\n import syntax::{visit, ast_util};\n import driver::session::session;\n \n-fn check_crate(sess: session, crate: @crate) {\n+fn check_crate(sess: session, crate: @crate, method_map: typeck::method_map) {\n     visit::visit_crate(*crate, false, visit::mk_vt(@{\n         visit_item: check_item,\n         visit_pat: check_pat,\n-        visit_expr: bind check_expr(sess, _, _, _)\n+        visit_expr: bind check_expr(sess, method_map, _, _, _)\n         with *visit::default_visitor()\n     }));\n     sess.abort_if_errors();\n@@ -41,7 +41,8 @@ fn check_pat(p: @pat, &&_is_const: bool, v: visit::vt<bool>) {\n     }\n }\n \n-fn check_expr(sess: session, e: @expr, &&is_const: bool, v: visit::vt<bool>) {\n+fn check_expr(sess: session, method_map: typeck::method_map, e: @expr,\n+              &&is_const: bool, v: visit::vt<bool>) {\n     if is_const {\n         alt e.node {\n           expr_unary(box(_), _) | expr_unary(uniq(_), _) |\n@@ -54,7 +55,13 @@ fn check_expr(sess: session, e: @expr, &&is_const: bool, v: visit::vt<bool>) {\n             sess.span_err(e.span,\n                           \"string constants are not supported\");\n           }\n-          expr_lit(_) | expr_binary(_, _, _) | expr_unary(_, _) {}\n+          expr_binary(_, _, _) | expr_unary(_, _) {\n+            if method_map.contains_key(e.id) {\n+                sess.span_err(e.span, \"user-defined operators are not \\\n+                                       allowed in constant expressions\");\n+            }\n+          }\n+          expr_lit(_) {}\n           _ {\n             sess.span_err(e.span,\n                           \"constant contains unimplemented expression type\");"}, {"sha": "8c3375796f85a7e50c7971c46e51f16d59bdb75d", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87b064b249657c8e65079d01beb77409f69d49cd/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87b064b249657c8e65079d01beb77409f69d49cd/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=87b064b249657c8e65079d01beb77409f69d49cd", "patch": "@@ -1983,9 +1983,9 @@ fn visit_mod_with_impl_scope(e: @env, m: ast::_mod, s: span, sc: iscopes,\n \n fn resolve_impl_in_expr(e: @env, x: @ast::expr, sc: iscopes, v: vt<iscopes>) {\n     alt x.node {\n-      ast::expr_field(_, _, _) | ast::expr_path(_) | ast::expr_cast(_, _) {\n-        e.impl_map.insert(x.id, sc);\n-      }\n+      ast::expr_field(_, _, _) | ast::expr_path(_) | ast::expr_cast(_, _) |\n+      ast::expr_binary(_, _, _) | ast::expr_unary(_, _) |\n+      ast::expr_assign_op(_, _, _) { e.impl_map.insert(x.id, sc); }\n       _ {}\n     }\n     visit::visit_expr(x, sc, v);"}, {"sha": "045cbfdc28d919219700871d1fcf5b3c45e3c88d", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 66, "deletions": 24, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/87b064b249657c8e65079d01beb77409f69d49cd/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87b064b249657c8e65079d01beb77409f69d49cd/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=87b064b249657c8e65079d01beb77409f69d49cd", "patch": "@@ -2072,7 +2072,19 @@ fn node_type(cx: @crate_ctxt, sp: span, id: ast::node_id) -> TypeRef {\n }\n \n fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n-               id: ast::node_id, dest: dest) -> @block_ctxt {\n+               un_expr: @ast::expr, dest: dest) -> @block_ctxt {\n+    // Check for user-defined method call\n+    alt bcx_ccx(bcx).method_map.find(un_expr.id) {\n+      some(origin) {\n+        let callee_id = ast_util::op_expr_callee_id(un_expr);\n+        let fty = ty::node_id_to_monotype(bcx_tcx(bcx), callee_id);\n+        ret trans_call_inner(bcx, fty, {|bcx|\n+            trans_impl::trans_method_callee(bcx, callee_id, e, origin)\n+        }, [], un_expr.id, dest);\n+      }\n+      _ {}\n+    }\n+\n     if dest == ignore { ret trans_expr(bcx, e, ignore); }\n     let e_ty = ty::expr_ty(bcx_tcx(bcx), e);\n     alt op {\n@@ -2104,7 +2116,7 @@ fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n         ret store_in_dest(bcx, box, dest);\n       }\n       ast::uniq(_) {\n-        ret trans_uniq::trans_uniq(bcx, e, id, dest);\n+        ret trans_uniq::trans_uniq(bcx, e, un_expr.id, dest);\n       }\n       ast::deref {\n         bcx_ccx(bcx).sess.bug(\"deref expressions should have been \\\n@@ -2193,12 +2205,26 @@ fn trans_eager_binop(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n     ret store_in_dest(cx, val, dest);\n }\n \n-fn trans_assign_op(bcx: @block_ctxt, op: ast::binop, dst: @ast::expr,\n-                   src: @ast::expr) -> @block_ctxt {\n+fn trans_assign_op(bcx: @block_ctxt, ex: @ast::expr, op: ast::binop,\n+                   dst: @ast::expr, src: @ast::expr) -> @block_ctxt {\n     let tcx = bcx_tcx(bcx);\n     let t = ty::expr_ty(tcx, src);\n     let lhs_res = trans_lval(bcx, dst);\n     assert (lhs_res.kind == owned);\n+\n+    // A user-defined operator method\n+    alt bcx_ccx(bcx).method_map.find(ex.id) {\n+      some(origin) {\n+        let callee_id = ast_util::op_expr_callee_id(ex);\n+        let fty = ty::node_id_to_monotype(bcx_tcx(bcx), callee_id);\n+        ret trans_call_inner(bcx, fty, {|bcx|\n+            // FIXME provide the already-computed address, not the expr\n+            trans_impl::trans_method_callee(bcx, callee_id, src, origin)\n+        }, [dst], ex.id, save_in(lhs_res.val));\n+      }\n+      _ {}\n+    }\n+\n     // Special case for `+= [x]`\n     alt ty::struct(tcx, t) {\n       ty::ty_vec(_) {\n@@ -2305,20 +2331,34 @@ fn trans_lazy_binop(bcx: @block_ctxt, op: ast::binop, a: @ast::expr,\n     ret store_in_dest(join_cx, phi, dest);\n }\n \n-fn trans_binary(cx: @block_ctxt, op: ast::binop, a: @ast::expr, b: @ast::expr,\n-                dest: dest) -> @block_ctxt {\n+\n+\n+fn trans_binary(bcx: @block_ctxt, op: ast::binop, a: @ast::expr,\n+                b: @ast::expr, dest: dest, ex: @ast::expr) -> @block_ctxt {\n+    // User-defined operators\n+    alt bcx_ccx(bcx).method_map.find(ex.id) {\n+      some(origin) {\n+        let callee_id = ast_util::op_expr_callee_id(ex);\n+        let fty = ty::node_id_to_monotype(bcx_tcx(bcx), callee_id);\n+        ret trans_call_inner(bcx, fty, {|bcx|\n+            trans_impl::trans_method_callee(bcx, callee_id, a, origin)\n+        }, [b], ex.id, dest);\n+      }\n+      _ {}\n+    }\n+\n     // First couple cases are lazy:\n     alt op {\n       ast::and | ast::or {\n-        ret trans_lazy_binop(cx, op, a, b, dest);\n+        ret trans_lazy_binop(bcx, op, a, b, dest);\n       }\n       _ {\n         // Remaining cases are eager:\n-        let lhs = trans_temp_expr(cx, a);\n+        let lhs = trans_temp_expr(bcx, a);\n         let rhs = trans_temp_expr(lhs.bcx, b);\n         ret trans_eager_binop(rhs.bcx, op, lhs.val,\n-                              ty::expr_ty(bcx_tcx(cx), a), rhs.val,\n-                              ty::expr_ty(bcx_tcx(cx), b), dest);\n+                              ty::expr_ty(bcx_tcx(bcx), a), rhs.val,\n+                              ty::expr_ty(bcx_tcx(bcx), b), dest);\n       }\n     }\n }\n@@ -2746,15 +2786,8 @@ fn trans_callee(bcx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n         // Lval means this is a record field, so not a method\n         if !expr_is_lval(bcx, e) {\n             alt bcx_ccx(bcx).method_map.find(e.id) {\n-              some(typeck::method_static(did)) { // An impl method\n-                ret trans_impl::trans_static_callee(bcx, e, base, did);\n-              }\n-              some(typeck::method_param(iid, off, p, b)) {\n-                ret trans_impl::trans_param_callee(\n-                    bcx, e, base, iid, off, p, b);\n-              }\n-              some(typeck::method_iface(off)) {\n-                ret trans_impl::trans_iface_callee(bcx, e, base, off);\n+              some(origin) { // An impl method\n+                ret trans_impl::trans_method_callee(bcx, e.id, base, origin);\n               }\n             }\n         }\n@@ -3132,15 +3165,22 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef,\n fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n               args: [@ast::expr], id: ast::node_id, dest: dest)\n     -> @block_ctxt {\n+    trans_call_inner(in_cx, ty::expr_ty(bcx_tcx(in_cx), f),\n+                     {|cx| trans_callee(cx, f)}, args, id, dest)\n+}\n+\n+fn trans_call_inner(in_cx: @block_ctxt, fn_expr_ty: ty::t,\n+                    get_callee: fn(@block_ctxt) -> lval_maybe_callee,\n+                    args: [@ast::expr], id: ast::node_id, dest: dest)\n+    -> @block_ctxt {\n     // NB: 'f' isn't necessarily a function; it might be an entire self-call\n     // expression because of the hack that allows us to process self-calls\n     // with trans_call.\n     let tcx = bcx_tcx(in_cx);\n-    let fn_expr_ty = ty::expr_ty(tcx, f);\n \n     let cx = new_scope_block_ctxt(in_cx, \"call\");\n     Br(in_cx, cx.llbb);\n-    let f_res = trans_callee(cx, f);\n+    let f_res = get_callee(cx);\n     let bcx = f_res.bcx;\n \n     let faddr = f_res.val;\n@@ -3478,10 +3518,12 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n       ast::expr_tup(args) { ret trans_tup(bcx, args, e.id, dest); }\n       ast::expr_lit(lit) { ret trans_lit(bcx, *lit, dest); }\n       ast::expr_vec(args, _) { ret tvec::trans_vec(bcx, args, e.id, dest); }\n-      ast::expr_binary(op, x, y) { ret trans_binary(bcx, op, x, y, dest); }\n+      ast::expr_binary(op, x, y) {\n+        ret trans_binary(bcx, op, x, y, dest, e);\n+      }\n       ast::expr_unary(op, x) {\n         assert op != ast::deref; // lvals are handled above\n-        ret trans_unary(bcx, op, x, e.id, dest);\n+        ret trans_unary(bcx, op, x, e, dest);\n       }\n       ast::expr_fn(proto, decl, body, cap_clause) {\n         ret trans_closure::trans_expr_fn(\n@@ -3620,7 +3662,7 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n       }\n       ast::expr_assign_op(op, dst, src) {\n         assert dest == ignore;\n-        ret trans_assign_op(bcx, op, dst, src);\n+        ret trans_assign_op(bcx, e, op, dst, src);\n       }\n     }\n }"}, {"sha": "b454ca729bbd84040681bb2b3140348a3d8f8a90", "filename": "src/comp/middle/trans_impl.rs", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/87b064b249657c8e65079d01beb77409f69d49cd/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87b064b249657c8e65079d01beb77409f69d49cd/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs?ref=87b064b249657c8e65079d01beb77409f69d49cd", "patch": "@@ -62,11 +62,28 @@ fn trans_self_arg(bcx: @block_ctxt, base: @ast::expr) -> result {\n     rslt(bcx, PointerCast(bcx, val, T_opaque_cbox_ptr(bcx_ccx(bcx))))\n }\n \n+fn trans_method_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n+                       self: @ast::expr, origin: typeck::method_origin)\n+    -> lval_maybe_callee {\n+    alt origin {\n+      typeck::method_static(did) {\n+        trans_static_callee(bcx, callee_id, self, did)\n+      }\n+      typeck::method_param(iid, off, p, b) {\n+        trans_param_callee(bcx, callee_id, self, iid, off, p, b)\n+      }\n+      typeck::method_iface(off) {\n+        trans_iface_callee(bcx, callee_id, self, off)\n+      }\n+    }\n+}\n+\n // Method callee where the method is statically known\n-fn trans_static_callee(bcx: @block_ctxt, e: @ast::expr, base: @ast::expr,\n-                       did: ast::def_id) -> lval_maybe_callee {\n+fn trans_static_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n+                       base: @ast::expr, did: ast::def_id)\n+    -> lval_maybe_callee {\n     let {bcx, val} = trans_self_arg(bcx, base);\n-    {env: self_env(val) with lval_static_fn(bcx, did, e.id)}\n+    {env: self_env(val) with lval_static_fn(bcx, did, callee_id)}\n }\n \n fn wrapper_fn_ty(ccx: @crate_ctxt, dict_ty: TypeRef, m: ty::method)\n@@ -79,7 +96,7 @@ fn wrapper_fn_ty(ccx: @crate_ctxt, dict_ty: TypeRef, m: ty::method)\n }\n \n fn trans_vtable_callee(bcx: @block_ctxt, self: ValueRef, dict: ValueRef,\n-                       fld_expr: @ast::expr, iface_id: ast::def_id,\n+                       callee_id: ast::node_id, iface_id: ast::def_id,\n                        n_method: uint) -> lval_maybe_callee {\n     let bcx = bcx, ccx = bcx_ccx(bcx), tcx = ccx.tcx;\n     let method = ty::iface_methods(tcx, iface_id)[n_method];\n@@ -90,7 +107,7 @@ fn trans_vtable_callee(bcx: @block_ctxt, self: ValueRef, dict: ValueRef,\n     let generic = none;\n     if vec::len(*method.tps) > 0u || ty::type_contains_params(tcx, fty) {\n         let tydescs = [], tis = [];\n-        let tptys = ty::node_id_to_type_params(tcx, fld_expr.id);\n+        let tptys = ty::node_id_to_type_params(tcx, callee_id);\n         for t in vec::tail_n(tptys, vec::len(tptys) - vec::len(*method.tps)) {\n             let ti = none;\n             let td = get_tydesc(bcx, t, true, ti).result;\n@@ -102,24 +119,24 @@ fn trans_vtable_callee(bcx: @block_ctxt, self: ValueRef, dict: ValueRef,\n                         static_tis: tis,\n                         tydescs: tydescs,\n                         param_bounds: method.tps,\n-                        origins: bcx_ccx(bcx).dict_map.find(fld_expr.id)});\n+                        origins: bcx_ccx(bcx).dict_map.find(callee_id)});\n     }\n     {bcx: bcx, val: mptr, kind: owned,\n      env: dict_env(dict, self),\n      generic: generic}\n }\n \n // Method callee where the dict comes from a type param\n-fn trans_param_callee(bcx: @block_ctxt, fld_expr: @ast::expr,\n+fn trans_param_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n                       base: @ast::expr, iface_id: ast::def_id, n_method: uint,\n                       n_param: uint, n_bound: uint) -> lval_maybe_callee {\n     let {bcx, val} = trans_self_arg(bcx, base);\n     let dict = option::get(bcx.fcx.lltyparams[n_param].dicts)[n_bound];\n-    trans_vtable_callee(bcx, val, dict, fld_expr, iface_id, n_method)\n+    trans_vtable_callee(bcx, val, dict, callee_id, iface_id, n_method)\n }\n \n // Method callee where the dict comes from a boxed iface\n-fn trans_iface_callee(bcx: @block_ctxt, fld_expr: @ast::expr,\n+fn trans_iface_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n                       base: @ast::expr, n_method: uint)\n     -> lval_maybe_callee {\n     let tcx = bcx_tcx(bcx);\n@@ -133,7 +150,7 @@ fn trans_iface_callee(bcx: @block_ctxt, fld_expr: @ast::expr,\n     let iface_id = alt ty::struct(tcx, ty::expr_ty(tcx, base)) {\n         ty::ty_iface(did, _) { did }\n     };\n-    trans_vtable_callee(bcx, self, dict, fld_expr, iface_id, n_method)\n+    trans_vtable_callee(bcx, self, dict, callee_id, iface_id, n_method)\n }\n \n fn llfn_arg_tys(ft: TypeRef) -> {inputs: [TypeRef], output: TypeRef} {"}, {"sha": "6ae92ee6538aaf4acfdcadd3b8d6cd7e582c917c", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 133, "deletions": 98, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/87b064b249657c8e65079d01beb77409f69d49cd/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87b064b249657c8e65079d01beb77409f69d49cd/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=87b064b249657c8e65079d01beb77409f69d49cd", "patch": "@@ -429,14 +429,14 @@ fn ty_of_native_item(tcx: ty::ctxt, mode: mode, it: @ast::native_item)\n     alt it.node {\n       ast::native_item_fn(fn_decl, params) {\n         ret ty_of_native_fn_decl(tcx, mode, fn_decl, params,\n-                                 ast_util::local_def(it.id));\n+                                 local_def(it.id));\n       }\n       ast::native_item_ty {\n         alt tcx.tcache.find(local_def(it.id)) {\n           some(tpt) { ret tpt; }\n           none { }\n         }\n-        let t = ty::mk_native(tcx, ast_util::local_def(it.id));\n+        let t = ty::mk_native(tcx, local_def(it.id));\n         let t = ty::mk_named(tcx, t, @it.ident);\n         let tpt = {bounds: @[], ty: t};\n         tcx.tcache.insert(local_def(it.id), tpt);\n@@ -1613,45 +1613,30 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n \n     // A generic function to factor out common logic from call and bind\n     // expressions.\n-    fn check_call_or_bind(fcx: @fn_ctxt, sp: span, f: @ast::expr,\n+    fn check_call_or_bind(fcx: @fn_ctxt, sp: span, fty: ty::t,\n                           args: [option::t<@ast::expr>]) -> bool {\n-        // Check the function.\n-        let bot = check_expr(fcx, f);\n-\n-        // Get the function type.\n-        let fty = expr_ty(fcx.ccx.tcx, f);\n-\n         let sty = structure_of(fcx, sp, fty);\n-\n         // Grab the argument types\n-        let arg_tys =\n-            alt sty {\n-              ty::ty_fn({inputs: arg_tys, _}) {\n-                arg_tys\n-              }\n-              _ {\n-                fcx.ccx.tcx.sess.span_fatal(f.span,\n-                                            \"mismatched types: \\\n-                     expected function or native \\\n-                     function but found \"\n-                                                + ty_to_str(fcx.ccx.tcx, fty))\n-              }\n-            };\n+        let arg_tys = alt sty {\n+          ty::ty_fn({inputs: arg_tys, _}) { arg_tys }\n+          _ {\n+            fcx.ccx.tcx.sess.span_fatal(sp, \"mismatched types: \\\n+                                             expected function or native \\\n+                                             function but found \"\n+                                        + ty_to_str(fcx.ccx.tcx, fty))\n+          }\n+        };\n \n         // Check that the correct number of arguments were supplied.\n         let expected_arg_count = vec::len(arg_tys);\n         let supplied_arg_count = vec::len(args);\n         if expected_arg_count != supplied_arg_count {\n-            fcx.ccx.tcx.sess.span_err(sp,\n-                                      #fmt[\"this function takes %u \\\n-                      parameter%s but %u parameter%s supplied\",\n-                                           expected_arg_count,\n-                                           if expected_arg_count == 1u {\n-                                               \"\"\n-                                           } else { \"s\" }, supplied_arg_count,\n-                                           if supplied_arg_count == 1u {\n-                                               \" was\"\n-                                           } else { \"s were\" }]);\n+            fcx.ccx.tcx.sess.span_err(\n+                sp, #fmt[\"this function takes %u parameter%s but %u \\\n+                          parameter%s supplied\", expected_arg_count,\n+                         expected_arg_count == 1u ? \"\" : \"s\",\n+                         supplied_arg_count,\n+                         supplied_arg_count == 1u ? \" was\" : \"s were\"]);\n             // HACK: build an arguments list with dummy arguments to\n             // check against\n             let dummy = {mode: ast::by_ref, ty: ty::mk_bot(fcx.ccx.tcx)};\n@@ -1665,33 +1650,27 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         // of arguments when we typecheck the functions. This isn't really the\n         // right way to do this.\n         let check_args = fn@(check_blocks: bool) -> bool {\n-                let i = 0u;\n-                let bot = false;\n-                for a_opt: option::t<@ast::expr> in args {\n-                    alt a_opt {\n-                      some(a) {\n-                        let is_block =\n-                            alt a.node {\n-                              ast::expr_fn_block(_, _) { true }\n-                              _ { false }\n-                            };\n-                        if is_block == check_blocks {\n-                            bot |=\n-                                check_expr_with_unifier(fcx, a,\n-                                                        demand::simple,\n-                                                        arg_tys[i].ty);\n-                        }\n-                      }\n-                      none { }\n+            let i = 0u;\n+            let bot = false;\n+            for a_opt in args {\n+                alt a_opt {\n+                  some(a) {\n+                    let is_block = alt a.node {\n+                      ast::expr_fn_block(_, _) { true }\n+                      _ { false }\n+                    };\n+                    if is_block == check_blocks {\n+                        bot |= check_expr_with_unifier(\n+                            fcx, a, demand::simple, arg_tys[i].ty);\n                     }\n-                    i += 1u;\n+                  }\n+                  none { }\n                 }\n-                ret bot;\n-            };\n-        bot |= check_args(false);\n-        bot |= check_args(true);\n-\n-        ret bot;\n+                i += 1u;\n+            }\n+            ret bot;\n+        };\n+        check_args(false) | check_args(true)\n     }\n \n     // A generic function for checking assignment expressions\n@@ -1711,8 +1690,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             args_opt_0 += [some::<@ast::expr>(arg)];\n         }\n \n+        let bot = check_expr(fcx, f);\n         // Call the generic checker.\n-        ret check_call_or_bind(fcx, sp, f, args_opt_0);\n+        bot | check_call_or_bind(fcx, sp, expr_ty(fcx.ccx.tcx, f), args_opt_0)\n     }\n \n     // A generic function for doing all of the checking for call expressions\n@@ -1784,18 +1764,76 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         ret if_bot;\n     }\n \n-    // Checks the compatibility\n-    fn check_binop_type_compat(fcx: @fn_ctxt, span: span, ty: ty::t,\n-                               binop: ast::binop) {\n-        let resolved_t = resolve_type_vars_if_possible(fcx, ty);\n-        if !ty::is_binopable(fcx.ccx.tcx, resolved_t, binop) {\n-            let binopstr = ast_util::binop_to_str(binop);\n-            let t_str = ty_to_str(fcx.ccx.tcx, resolved_t);\n-            let errmsg =\n-                \"binary operation \" + binopstr +\n-                    \" cannot be applied to type `\" + t_str + \"`\";\n-            fcx.ccx.tcx.sess.span_err(span, errmsg);\n+    fn binop_method(op: ast::binop) -> option::t<str> {\n+        alt op {\n+          ast::add { some(\"op_add\") }\n+          ast::subtract { some(\"op_sub\") }\n+          ast::mul { some(\"op_mul\") }\n+          ast::div { some(\"op_div\") }\n+          ast::rem { some(\"op_rem\") }\n+          ast::bitxor { some(\"op_xor\") }\n+          ast::bitand { some(\"op_and\") }\n+          ast::bitor { some(\"op_or\") }\n+          ast::lsl { some(\"op_shift_left\") }\n+          ast::lsr { some(\"op_shift_right\") }\n+          ast::asr { some(\"op_ashift_right\") }\n+          _ { none }\n+        }\n+    }\n+    fn check_binop(fcx: @fn_ctxt, ex: @ast::expr, ty: ty::t,\n+                   op: ast::binop, rhs: @ast::expr) -> ty::t {\n+        let resolved_t = structurally_resolved_type(fcx, ex.span, ty);\n+        let tcx = fcx.ccx.tcx;\n+        if ty::is_binopable(tcx, resolved_t, op) {\n+            ret alt op {\n+              ast::eq | ast::lt | ast::le | ast::ne | ast::ge |\n+              ast::gt { ty::mk_bool(tcx) }\n+              _ { resolved_t }\n+            };\n+        }\n+\n+        let isc = fcx.ccx.impl_map.get(ex.id);\n+        alt binop_method(op) {\n+          some(name) {\n+            alt lookup_method(fcx, isc, name, resolved_t, ex.span) {\n+              some({method_ty, n_tps: 0u, substs, origin}) {\n+                let callee_id = ast_util::op_expr_callee_id(ex);\n+                write::ty_fixup(fcx, callee_id, {substs: some(substs),\n+                                                 ty: method_ty});\n+                check_call_or_bind(fcx, ex.span, method_ty, [some(rhs)]);\n+                fcx.ccx.method_map.insert(ex.id, origin);\n+                ret ty::ty_fn_ret(tcx, method_ty);\n+              }\n+              _ {}\n+            }\n+          }\n+          none {}\n+        }\n+        tcx.sess.span_err(\n+            ex.span, \"binary operation \" + ast_util::binop_to_str(op) +\n+            \" cannot be applied to type `\" + ty_to_str(tcx, resolved_t) +\n+            \"`\");\n+        resolved_t\n+    }\n+    fn check_user_unop(fcx: @fn_ctxt, op_str: str, mname: str,\n+                       ex: @ast::expr, rhs_t: ty::t) -> ty::t {\n+        let isc = fcx.ccx.impl_map.get(ex.id);\n+        let tcx = fcx.ccx.tcx;\n+        alt lookup_method(fcx, isc, mname, rhs_t, ex.span) {\n+          some({method_ty, n_tps: 0u, substs, origin}) {\n+            let callee_id = ast_util::op_expr_callee_id(ex);\n+            write::ty_fixup(fcx, callee_id, {substs: some(substs),\n+                                             ty: method_ty});\n+            check_call_or_bind(fcx, ex.span, method_ty, []);\n+            fcx.ccx.method_map.insert(ex.id, origin);\n+            ret ty::ty_fn_ret(tcx, method_ty);\n+          }\n+          _ {}\n         }\n+        tcx.sess.span_err(\n+            ex.span, #fmt[\"can not apply unary operator `%s` to type `%s`\",\n+                          op_str, ty_to_str(tcx, rhs_t)]);\n+        rhs_t\n     }\n \n     let tcx = fcx.ccx.tcx;\n@@ -1813,14 +1851,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let rhs_bot = check_expr_with(fcx, rhs, lhs_t);\n         if !ast_util::lazy_binop(binop) { bot |= rhs_bot; }\n \n-        check_binop_type_compat(fcx, expr.span, lhs_t, binop);\n-\n-        let t = alt binop {\n-          ast::eq | ast::lt | ast::le | ast::ne | ast::ge |\n-          ast::gt { ty::mk_bool(tcx) }\n-          _ { lhs_t }\n-        };\n-        write::ty_only_fixup(fcx, id, t);\n+        let result = check_binop(fcx, expr, lhs_t, binop, rhs);\n+        write::ty_only_fixup(fcx, id, result);\n+      }\n+      ast::expr_assign_op(op, lhs, rhs) {\n+        require_impure(tcx.sess, fcx.purity, expr.span);\n+        bot = check_assignment(fcx, expr.span, lhs, rhs, id);\n+        let lhs_t = ty::expr_ty(tcx, lhs);\n+        let result = check_binop(fcx, expr, lhs_t, op, rhs);\n+        demand::simple(fcx, expr.span, result, lhs_t);\n       }\n       ast::expr_unary(unop, oper) {\n         bot = check_expr(fcx, oper);\n@@ -1860,22 +1899,17 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             }\n           }\n           ast::not {\n-            if !type_is_integral(fcx, oper.span, oper_t) &&\n-                   structure_of(fcx, oper.span, oper_t) != ty::ty_bool {\n-                tcx.sess.span_err(expr.span,\n-                                  #fmt[\"mismatched types: expected `bool` \\\n-                          or `integer` but found `%s`\",\n-                                       ty_to_str(tcx, oper_t)]);\n+            oper_t = structurally_resolved_type(fcx, oper.span, oper_t);\n+            if !(ty::type_is_integral(tcx, oper_t) ||\n+                 ty::struct(tcx, oper_t) == ty::ty_bool) {\n+                oper_t = check_user_unop(fcx, \"!\", \"op_not\", expr, oper_t);\n             }\n           }\n           ast::neg {\n             oper_t = structurally_resolved_type(fcx, oper.span, oper_t);\n             if !(ty::type_is_integral(tcx, oper_t) ||\n-                     ty::type_is_fp(tcx, oper_t)) {\n-                tcx.sess.span_err(expr.span,\n-                                  \"applying unary minus to \\\n-                   non-numeric type `\"\n-                                      + ty_to_str(tcx, oper_t) + \"`\");\n+                 ty::type_is_fp(tcx, oper_t)) {\n+                oper_t = check_user_unop(fcx, \"-\", \"op_neg\", expr, oper_t);\n             }\n           }\n         }\n@@ -1971,11 +2005,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         require_impure(tcx.sess, fcx.purity, expr.span);\n         bot = check_assignment(fcx, expr.span, lhs, rhs, id);\n       }\n-      ast::expr_assign_op(op, lhs, rhs) {\n-        require_impure(tcx.sess, fcx.purity, expr.span);\n-        bot = check_assignment(fcx, expr.span, lhs, rhs, id);\n-        check_binop_type_compat(fcx, expr.span, expr_ty(tcx, lhs), op);\n-      }\n       ast::expr_if(cond, thn, elsopt) {\n         bot =\n             check_expr_with(fcx, cond, ty::mk_bool(tcx)) |\n@@ -2069,7 +2098,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       }\n       ast::expr_bind(f, args) {\n         // Call the generic checker.\n-        bot = check_call_or_bind(fcx, expr.span, f, args);\n+        bot = check_expr(fcx, f);\n+        bot |= check_call_or_bind(fcx, expr.span, expr_ty(tcx, f), args);\n \n         // Pull the argument and return types out.\n         let proto, arg_tys, rt, cf, constrs;\n@@ -2891,14 +2921,19 @@ mod dict {\n             }\n           }\n           // Must resolve bounds on methods with bounded params\n-          ast::expr_field(_, _, _) {\n+          ast::expr_field(_, _, _) | ast::expr_binary(_, _, _) |\n+          ast::expr_unary(_, _) | ast::expr_assign_op(_, _, _) {\n             alt cx.method_map.find(ex.id) {\n               some(method_static(did)) {\n                 let bounds = ty::lookup_item_type(cx.tcx, did).bounds;\n                 if has_iface_bounds(*bounds) {\n-                    let ts = ty::node_id_to_type_params(cx.tcx, ex.id);\n+                    let callee_id = alt ex.node {\n+                      ast::expr_field(_, _, _) { ex.id }\n+                      _ { ast_util::op_expr_callee_id(ex) }\n+                    };\n+                    let ts = ty::node_id_to_type_params(cx.tcx, callee_id);\n                     let iscs = cx.impl_map.get(ex.id);\n-                    cx.dict_map.insert(ex.id, lookup_dicts(\n+                    cx.dict_map.insert(callee_id, lookup_dicts(\n                         fcx, iscs, ex.span, bounds, ts));\n                 }\n               }"}, {"sha": "65c117cfa6bf5ea9699ebe04ead4cb6f389e8593", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/87b064b249657c8e65079d01beb77409f69d49cd/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87b064b249657c8e65079d01beb77409f69d49cd/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=87b064b249657c8e65079d01beb77409f69d49cd", "patch": "@@ -326,6 +326,11 @@ fn ident_to_path(s: span, i: ident) -> @path {\n     @respan(s, {global: false, idents: [i], types: []})\n }\n \n+// Provides an extra node_id to hang callee information on, in case the\n+// operator is deferred to a user-supplied method. The parser is responsible\n+// for reserving this id.\n+fn op_expr_callee_id(e: @expr) -> node_id { e.id - 1 }\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "1e892eb43b109cfddfb3f374ffe1de088e3f5d93", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87b064b249657c8e65079d01beb77409f69d49cd/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87b064b249657c8e65079d01beb77409f69d49cd/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=87b064b249657c8e65079d01beb77409f69d49cd", "patch": "@@ -1048,6 +1048,7 @@ fn parse_prefix_expr(p: parser) -> pexpr {\n         p.bump();\n         let e = to_expr(parse_prefix_expr(p));\n         hi = e.span.hi;\n+        p.get_id(); // see ast_util::op_expr_callee_id\n         ex = ast::expr_unary(ast::not, e);\n       }\n       token::BINOP(b) {\n@@ -1056,6 +1057,7 @@ fn parse_prefix_expr(p: parser) -> pexpr {\n             p.bump();\n             let e = to_expr(parse_prefix_expr(p));\n             hi = e.span.hi;\n+            p.get_id(); // see ast_util::op_expr_callee_id\n             ex = ast::expr_unary(ast::neg, e);\n           }\n           token::STAR {\n@@ -1146,6 +1148,7 @@ fn parse_more_binops(p: parser, plhs: pexpr, min_prec: int) ->\n             p.bump();\n             let expr = parse_prefix_expr(p);\n             let rhs = parse_more_binops(p, expr, cur.prec);\n+            p.get_id(); // see ast_util::op_expr_callee_id\n             let bin = mk_pexpr(p, lhs.span.lo, rhs.span.hi,\n                               ast::expr_binary(cur.op, lhs, rhs));\n             ret parse_more_binops(p, bin, min_prec);\n@@ -1186,6 +1189,7 @@ fn parse_assign_expr(p: parser) -> @ast::expr {\n           token::LSR { aop = ast::lsr; }\n           token::ASR { aop = ast::asr; }\n         }\n+        p.get_id(); // see ast_util::op_expr_callee_id\n         ret mk_expr(p, lo, rhs.span.hi, ast::expr_assign_op(aop, lhs, rhs));\n       }\n       token::LARROW {"}, {"sha": "776d82bf492b4698648d9687f74ae6320fdd3689", "filename": "src/test/compile-fail/minus-string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87b064b249657c8e65079d01beb77409f69d49cd/src%2Ftest%2Fcompile-fail%2Fminus-string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87b064b249657c8e65079d01beb77409f69d49cd/src%2Ftest%2Fcompile-fail%2Fminus-string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fminus-string.rs?ref=87b064b249657c8e65079d01beb77409f69d49cd", "patch": "@@ -1,3 +1,3 @@\n-// error-pattern:applying unary minus to non-numeric type `str`\n+// error-pattern:can not apply unary operator `-` to type `str`\n \n fn main() { -\"foo\"; }"}, {"sha": "4265f0023b7a36f4e91a38cdb0dd2b608f41ee76", "filename": "src/test/run-pass/operator-overloading.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/87b064b249657c8e65079d01beb77409f69d49cd/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87b064b249657c8e65079d01beb77409f69d49cd/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-overloading.rs?ref=87b064b249657c8e65079d01beb77409f69d49cd", "patch": "@@ -0,0 +1,17 @@\n+type point = {x: int, y: int};\n+\n+impl add_point for point {\n+    fn op_add(other: point) -> point {\n+        {x: self.x + other.x, y: self.y + other.y}\n+    }\n+    fn op_neg() -> point {\n+        {x: -self.x, y: -self.y}\n+    }\n+}\n+\n+fn main() {\n+    let p = {x: 10, y: 20};\n+    p += {x: 1, y: 2};\n+    assert p + {x: 5, y: 5} == {x: 16, y: 27};\n+    assert -p == {x: -11, y: -22};\n+}"}]}