{"sha": "6eeb4fd23050d531293580dc83ca19e0fd7244e4", "node_id": "C_kwDOAAsO6NoAKDZlZWI0ZmQyMzA1MGQ1MzEyOTM1ODBkYzgzY2ExOWUwZmQ3MjQ0ZTQ", "commit": {"author": {"name": "Caleb Cartwright", "email": "calebcartwright@users.noreply.github.com", "date": "2023-01-24T04:13:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-24T04:13:01Z"}, "message": "Merge pull request #5670 from calebcartwright/subtree-sync-2023-01-24\n\nSubtree sync 2023-01-24", "tree": {"sha": "e7e1c87690c405a77183e330de95bcdd9d49f243", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7e1c87690c405a77183e330de95bcdd9d49f243"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6eeb4fd23050d531293580dc83ca19e0fd7244e4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjz1rNCRBK7hj4Ov3rIwAABuQIABEEIvKXo8UI68uOA9tc3Mbb\nsZDa2TCXRbNjsVlp2hvUTv01x5JtlllXQOa2UxRh39D5oxEZwJroUvmcpG0Z4HYF\nkBgmvkrdX4QVaEFqOsMlmkGv8iy3lGX05topB5QKKSHdDGaSW9SH53ho6BlKXzHt\nsYRUD0QPycJjExIqAEncSIYdEsH3RbRlazdyCzZk4Q6YoXG4tJ1T2m4mv6DMGMGw\nM3EaQ1lWfXD6/PsLXR0iLPg/mxKFdg9JppIGfnQsk0mGmMeA25Y/xNmPDIScWkxg\nbqcVlgSc7wDX5cJjB4EWKeEntdkSCe92ktDevQTLYov4y4KhlrEoQueuiD5w454=\n=RTxP\n-----END PGP SIGNATURE-----\n", "payload": "tree e7e1c87690c405a77183e330de95bcdd9d49f243\nparent aae222c974a982e878f279b95bd1a9d0166ff229\nparent 18dd0757dbef84611fc0f1f522b15913248b8541\nauthor Caleb Cartwright <calebcartwright@users.noreply.github.com> 1674533581 -0600\ncommitter GitHub <noreply@github.com> 1674533581 -0600\n\nMerge pull request #5670 from calebcartwright/subtree-sync-2023-01-24\n\nSubtree sync 2023-01-24"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6eeb4fd23050d531293580dc83ca19e0fd7244e4", "html_url": "https://github.com/rust-lang/rust/commit/6eeb4fd23050d531293580dc83ca19e0fd7244e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6eeb4fd23050d531293580dc83ca19e0fd7244e4/comments", "author": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aae222c974a982e878f279b95bd1a9d0166ff229", "url": "https://api.github.com/repos/rust-lang/rust/commits/aae222c974a982e878f279b95bd1a9d0166ff229", "html_url": "https://github.com/rust-lang/rust/commit/aae222c974a982e878f279b95bd1a9d0166ff229"}, {"sha": "18dd0757dbef84611fc0f1f522b15913248b8541", "url": "https://api.github.com/repos/rust-lang/rust/commits/18dd0757dbef84611fc0f1f522b15913248b8541", "html_url": "https://github.com/rust-lang/rust/commit/18dd0757dbef84611fc0f1f522b15913248b8541"}], "stats": {"total": 370, "additions": 204, "deletions": 166}, "files": [{"sha": "61abc87eec9ffffbb40b92d471ba65c24dad0412", "filename": "Processes.md", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/Processes.md", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/Processes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Processes.md?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -51,7 +51,3 @@ git tag -s v1.2.3 -m \"Release 1.2.3\"\n `cargo publish`\n \n ## 5. Create a PR to rust-lang/rust to update the rustfmt submodule\n-\n-Note that if you are updating `rustc-ap-*` crates, then you need to update **every** submodules in the rust-lang/rust repository that depend on the crates to use the same version of those.\n-\n-As of 2019/05, there are two such crates: `rls` and `racer` (`racer` depends on `rustc-ap-syntax` and `rls` depends on `racer`, and `rls` is one of submodules of the rust-lang/rust repository)."}, {"sha": "0f9652aecf9c2c9642d7cd31ba3197b3a9eff66a", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -135,7 +135,7 @@ completed without error (whether or not changes were made).\n * [Emacs](https://github.com/rust-lang/rust-mode)\n * [Sublime Text 3](https://packagecontrol.io/packages/RustFmt)\n * [Atom](atom.md)\n-* Visual Studio Code using [vscode-rust](https://github.com/editor-rs/vscode-rust), [vsc-rustfmt](https://github.com/Connorcpu/vsc-rustfmt) or [rls_vscode](https://github.com/jonathandturner/rls_vscode) through RLS.\n+* [Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer)\n * [IntelliJ or CLion](intellij.md)\n \n "}, {"sha": "c7e3a991a5f0352e4f3d0876d49f83776ded57c8", "filename": "atom.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/atom.md", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/atom.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/atom.md?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -1,8 +1,8 @@\n # Running Rustfmt from Atom\n \n-## RLS\n+## rust-analyzer\n \n-Rustfmt is included with the Rust Language Server, itself provided by [ide-rust](https://atom.io/packages/ide-rust).\n+Rustfmt can be utilized from [rust-analyzer](https://rust-analyzer.github.io/) which is provided by [ide-rust](https://atom.io/packages/ide-rust).\n \n `apm install ide-rust`\n "}, {"sha": "22283b3d62002019b88b0a47441cb7d6a0a874d1", "filename": "rust-toolchain", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-08-06\"\n-components = [\"rustc-dev\"]\n+channel = \"nightly-2023-01-24\"\n+components = [\"llvm-tools\", \"rustc-dev\"]"}, {"sha": "5648e1254ed7cd14d947a117d071bb7572fbdd61", "filename": "src/attr.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattr.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -49,10 +49,7 @@ pub(crate) fn get_span_without_attrs(stmt: &ast::Stmt) -> Span {\n }\n \n /// Returns attributes that are within `outer_span`.\n-pub(crate) fn filter_inline_attrs(\n-    attrs: &[ast::Attribute],\n-    outer_span: Span,\n-) -> Vec<ast::Attribute> {\n+pub(crate) fn filter_inline_attrs(attrs: &[ast::Attribute], outer_span: Span) -> ast::AttrVec {\n     attrs\n         .iter()\n         .filter(|a| outer_span.lo() <= a.span.lo() && a.span.hi() <= outer_span.hi())\n@@ -263,7 +260,9 @@ impl Rewrite for ast::NestedMetaItem {\n     fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         match self {\n             ast::NestedMetaItem::MetaItem(ref meta_item) => meta_item.rewrite(context, shape),\n-            ast::NestedMetaItem::Literal(ref l) => rewrite_literal(context, l, shape),\n+            ast::NestedMetaItem::Lit(ref l) => {\n+                rewrite_literal(context, l.as_token_lit(), l.span, shape)\n+            }\n         }\n     }\n }\n@@ -291,10 +290,10 @@ impl Rewrite for ast::MetaItem {\n     fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         Some(match self.kind {\n             ast::MetaItemKind::Word => {\n-                rewrite_path(context, PathContext::Type, None, &self.path, shape)?\n+                rewrite_path(context, PathContext::Type, &None, &self.path, shape)?\n             }\n             ast::MetaItemKind::List(ref list) => {\n-                let path = rewrite_path(context, PathContext::Type, None, &self.path, shape)?;\n+                let path = rewrite_path(context, PathContext::Type, &None, &self.path, shape)?;\n                 let has_trailing_comma = crate::expr::span_ends_with_comma(context, self.span);\n                 overflow::rewrite_with_parens(\n                     context,\n@@ -311,18 +310,18 @@ impl Rewrite for ast::MetaItem {\n                     }),\n                 )?\n             }\n-            ast::MetaItemKind::NameValue(ref literal) => {\n-                let path = rewrite_path(context, PathContext::Type, None, &self.path, shape)?;\n+            ast::MetaItemKind::NameValue(ref lit) => {\n+                let path = rewrite_path(context, PathContext::Type, &None, &self.path, shape)?;\n                 // 3 = ` = `\n                 let lit_shape = shape.shrink_left(path.len() + 3)?;\n-                // `rewrite_literal` returns `None` when `literal` exceeds max\n+                // `rewrite_literal` returns `None` when `lit` exceeds max\n                 // width. Since a literal is basically unformattable unless it\n                 // is a string literal (and only if `format_strings` is set),\n                 // we might be better off ignoring the fact that the attribute\n                 // is longer than the max width and continue on formatting.\n                 // See #2479 for example.\n-                let value = rewrite_literal(context, literal, lit_shape)\n-                    .unwrap_or_else(|| context.snippet(literal.span).to_owned());\n+                let value = rewrite_literal(context, lit.as_token_lit(), lit.span, lit_shape)\n+                    .unwrap_or_else(|| context.snippet(lit.span).to_owned());\n                 format!(\"{} = {}\", path, value)\n             }\n         })\n@@ -528,14 +527,19 @@ pub(crate) trait MetaVisitor<'ast> {\n \n     fn visit_meta_word(&mut self, _meta_item: &'ast ast::MetaItem) {}\n \n-    fn visit_meta_name_value(&mut self, _meta_item: &'ast ast::MetaItem, _lit: &'ast ast::Lit) {}\n+    fn visit_meta_name_value(\n+        &mut self,\n+        _meta_item: &'ast ast::MetaItem,\n+        _lit: &'ast ast::MetaItemLit,\n+    ) {\n+    }\n \n     fn visit_nested_meta_item(&mut self, nm: &'ast ast::NestedMetaItem) {\n         match nm {\n             ast::NestedMetaItem::MetaItem(ref meta_item) => self.visit_meta_item(meta_item),\n-            ast::NestedMetaItem::Literal(ref lit) => self.visit_literal(lit),\n+            ast::NestedMetaItem::Lit(ref lit) => self.visit_meta_item_lit(lit),\n         }\n     }\n \n-    fn visit_literal(&mut self, _lit: &'ast ast::Lit) {}\n+    fn visit_meta_item_lit(&mut self, _lit: &'ast ast::MetaItemLit) {}\n }"}, {"sha": "39b8d6878097d369df7f8ab52f3be00d77a2312d", "filename": "src/chains.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -199,8 +199,8 @@ impl ChainItemKind {\n \n     fn from_ast(context: &RewriteContext<'_>, expr: &ast::Expr) -> (ChainItemKind, Span) {\n         let (kind, span) = match expr.kind {\n-            ast::ExprKind::MethodCall(ref segment, ref expressions, _) => {\n-                let types = if let Some(ref generic_args) = segment.args {\n+            ast::ExprKind::MethodCall(ref call) => {\n+                let types = if let Some(ref generic_args) = call.seg.args {\n                     if let ast::GenericArgs::AngleBracketed(ref data) = **generic_args {\n                         data.args\n                             .iter()\n@@ -217,8 +217,8 @@ impl ChainItemKind {\n                 } else {\n                     vec![]\n                 };\n-                let span = mk_sp(expressions[0].span.hi(), expr.span.hi());\n-                let kind = ChainItemKind::MethodCall(segment.clone(), types, expressions.clone());\n+                let span = mk_sp(call.receiver.span.hi(), expr.span.hi());\n+                let kind = ChainItemKind::MethodCall(call.seg.clone(), types, call.args.clone());\n                 (kind, span)\n             }\n             ast::ExprKind::Field(ref nested, field) => {\n@@ -307,7 +307,7 @@ impl ChainItem {\n             format!(\"::<{}>\", type_list.join(\", \"))\n         };\n         let callee_str = format!(\".{}{}\", rewrite_ident(context, method_name), type_str);\n-        rewrite_call(context, &callee_str, &args[1..], span, shape)\n+        rewrite_call(context, &callee_str, &args, span, shape)\n     }\n }\n \n@@ -454,9 +454,7 @@ impl Chain {\n     // is a try! macro, we'll convert it to shorthand when the option is set.\n     fn pop_expr_chain(expr: &ast::Expr, context: &RewriteContext<'_>) -> Option<ast::Expr> {\n         match expr.kind {\n-            ast::ExprKind::MethodCall(_, ref expressions, _) => {\n-                Some(Self::convert_try(&expressions[0], context))\n-            }\n+            ast::ExprKind::MethodCall(ref call) => Some(Self::convert_try(&call.receiver, context)),\n             ast::ExprKind::Field(ref subexpr, _)\n             | ast::ExprKind::Try(ref subexpr)\n             | ast::ExprKind::Await(ref subexpr) => Some(Self::convert_try(subexpr, context)),"}, {"sha": "8fd0fcf8f5c2c83ca8668700b0ec121e38d7953f", "filename": "src/closures.rs", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fclosures.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -26,6 +26,7 @@ use crate::utils::{last_line_width, left_most_sub_expr, stmt_expr, NodeIdExt};\n \n pub(crate) fn rewrite_closure(\n     binder: &ast::ClosureBinder,\n+    constness: ast::Const,\n     capture: ast::CaptureBy,\n     is_async: &ast::Async,\n     movability: ast::Movability,\n@@ -38,7 +39,7 @@ pub(crate) fn rewrite_closure(\n     debug!(\"rewrite_closure {:?}\", body);\n \n     let (prefix, extra_offset) = rewrite_closure_fn_decl(\n-        binder, capture, is_async, movability, fn_decl, body, span, context, shape,\n+        binder, constness, capture, is_async, movability, fn_decl, body, span, context, shape,\n     )?;\n     // 1 = space between `|...|` and body.\n     let body_shape = shape.offset_left(extra_offset)?;\n@@ -230,6 +231,7 @@ fn rewrite_closure_block(\n // Return type is (prefix, extra_offset)\n fn rewrite_closure_fn_decl(\n     binder: &ast::ClosureBinder,\n+    constness: ast::Const,\n     capture: ast::CaptureBy,\n     asyncness: &ast::Async,\n     movability: ast::Movability,\n@@ -250,6 +252,12 @@ fn rewrite_closure_fn_decl(\n         ast::ClosureBinder::NotPresent => \"\".to_owned(),\n     };\n \n+    let const_ = if matches!(constness, ast::Const::Yes(_)) {\n+        \"const \"\n+    } else {\n+        \"\"\n+    };\n+\n     let immovable = if movability == ast::Movability::Static {\n         \"static \"\n     } else {\n@@ -264,7 +272,7 @@ fn rewrite_closure_fn_decl(\n     // 4 = \"|| {\".len(), which is overconservative when the closure consists of\n     // a single expression.\n     let nested_shape = shape\n-        .shrink_left(binder.len() + immovable.len() + is_async.len() + mover.len())?\n+        .shrink_left(binder.len() + const_.len() + immovable.len() + is_async.len() + mover.len())?\n         .sub_width(4)?;\n \n     // 1 = |\n@@ -302,7 +310,10 @@ fn rewrite_closure_fn_decl(\n         .tactic(tactic)\n         .preserve_newline(true);\n     let list_str = write_list(&item_vec, &fmt)?;\n-    let mut prefix = format!(\"{}{}{}{}|{}|\", binder, immovable, is_async, mover, list_str);\n+    let mut prefix = format!(\n+        \"{}{}{}{}{}|{}|\",\n+        binder, const_, immovable, is_async, mover, list_str\n+    );\n \n     if !ret_str.is_empty() {\n         if prefix.contains('\\n') {\n@@ -326,16 +337,18 @@ pub(crate) fn rewrite_last_closure(\n     expr: &ast::Expr,\n     shape: Shape,\n ) -> Option<String> {\n-    if let ast::ExprKind::Closure(\n-        ref binder,\n-        capture,\n-        ref is_async,\n-        movability,\n-        ref fn_decl,\n-        ref body,\n-        _,\n-    ) = expr.kind\n-    {\n+    if let ast::ExprKind::Closure(ref closure) = expr.kind {\n+        let ast::Closure {\n+            ref binder,\n+            constness,\n+            capture_clause,\n+            ref asyncness,\n+            movability,\n+            ref fn_decl,\n+            ref body,\n+            fn_decl_span: _,\n+            fn_arg_span: _,\n+        } = **closure;\n         let body = match body.kind {\n             ast::ExprKind::Block(ref block, _)\n                 if !is_unsafe_block(block)\n@@ -347,7 +360,16 @@ pub(crate) fn rewrite_last_closure(\n             _ => body,\n         };\n         let (prefix, extra_offset) = rewrite_closure_fn_decl(\n-            binder, capture, is_async, movability, fn_decl, body, expr.span, context, shape,\n+            binder,\n+            constness,\n+            capture_clause,\n+            asyncness,\n+            movability,\n+            fn_decl,\n+            body,\n+            expr.span,\n+            context,\n+            shape,\n         )?;\n         // If the closure goes multi line before its body, do not overflow the closure.\n         if prefix.contains('\\n') {"}, {"sha": "54ca7676dfc8bd9c7f1a01ef7c4a94d8c6f1bc4b", "filename": "src/config/config_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fconfig%2Fconfig_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fconfig%2Fconfig_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fconfig_type.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -5,7 +5,7 @@ use crate::config::options::{IgnoreList, WidthHeuristics};\n /// Trait for types that can be used in `Config`.\n pub(crate) trait ConfigType: Sized {\n     /// Returns hint text for use in `Config::print_docs()`. For enum types, this is a\n-    /// pipe-separated list of variants; for other types it returns \"<type>\".\n+    /// pipe-separated list of variants; for other types it returns `<type>`.\n     fn doc_hint() -> String;\n \n     /// Return `true` if the variant (i.e. value of this type) is stable."}, {"sha": "0be4c3cf168cc19c833a29cc3b6e9129509d5e69", "filename": "src/expr.rs", "status": "modified", "additions": 39, "deletions": 32, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -3,7 +3,7 @@ use std::cmp::min;\n \n use itertools::Itertools;\n use rustc_ast::token::{Delimiter, LitKind};\n-use rustc_ast::{ast, ptr};\n+use rustc_ast::{ast, ptr, token};\n use rustc_span::{BytePos, Span};\n \n use crate::chains::rewrite_chain;\n@@ -75,12 +75,12 @@ pub(crate) fn format_expr(\n             choose_separator_tactic(context, expr.span),\n             None,\n         ),\n-        ast::ExprKind::Lit(ref l) => {\n-            if let Some(expr_rw) = rewrite_literal(context, l, shape) {\n+        ast::ExprKind::Lit(token_lit) => {\n+            if let Some(expr_rw) = rewrite_literal(context, token_lit, expr.span, shape) {\n                 Some(expr_rw)\n             } else {\n-                if let LitKind::StrRaw(_) = l.token.kind {\n-                    Some(context.snippet(l.span).trim().into())\n+                if let LitKind::StrRaw(_) = token_lit.kind {\n+                    Some(context.snippet(expr.span).trim().into())\n                 } else {\n                     None\n                 }\n@@ -116,7 +116,7 @@ pub(crate) fn format_expr(\n             rewrite_struct_lit(\n                 context,\n                 path,\n-                qself.as_ref(),\n+                qself,\n                 fields,\n                 rest,\n                 &expr.attrs,\n@@ -169,7 +169,7 @@ pub(crate) fn format_expr(\n             rewrite_match(context, cond, arms, shape, expr.span, &expr.attrs)\n         }\n         ast::ExprKind::Path(ref qself, ref path) => {\n-            rewrite_path(context, PathContext::Expr, qself.as_ref(), path, shape)\n+            rewrite_path(context, PathContext::Expr, qself, path, shape)\n         }\n         ast::ExprKind::Assign(ref lhs, ref rhs, _) => {\n             rewrite_assignment(context, lhs, rhs, None, shape)\n@@ -203,16 +203,17 @@ pub(crate) fn format_expr(\n                 Some(\"yield\".to_string())\n             }\n         }\n-        ast::ExprKind::Closure(\n-            ref binder,\n-            capture,\n-            ref is_async,\n-            movability,\n-            ref fn_decl,\n-            ref body,\n-            _,\n-        ) => closures::rewrite_closure(\n-            binder, capture, is_async, movability, fn_decl, body, expr.span, context, shape,\n+        ast::ExprKind::Closure(ref cl) => closures::rewrite_closure(\n+            &cl.binder,\n+            cl.constness,\n+            cl.capture_clause,\n+            &cl.asyncness,\n+            cl.movability,\n+            &cl.fn_decl,\n+            &cl.body,\n+            expr.span,\n+            context,\n+            shape,\n         ),\n         ast::ExprKind::Try(..)\n         | ast::ExprKind::Field(..)\n@@ -274,9 +275,9 @@ pub(crate) fn format_expr(\n \n             fn needs_space_before_range(context: &RewriteContext<'_>, lhs: &ast::Expr) -> bool {\n                 match lhs.kind {\n-                    ast::ExprKind::Lit(ref lit) => match lit.kind {\n-                        ast::LitKind::Float(_, ast::LitFloatType::Unsuffixed) => {\n-                            context.snippet(lit.span).ends_with('.')\n+                    ast::ExprKind::Lit(token_lit) => match token_lit.kind {\n+                        token::LitKind::Float if token_lit.suffix.is_none() => {\n+                            context.snippet(lhs.span).ends_with('.')\n                         }\n                         _ => false,\n                     },\n@@ -399,6 +400,7 @@ pub(crate) fn format_expr(\n             }\n         }\n         ast::ExprKind::Underscore => Some(\"_\".to_owned()),\n+        ast::ExprKind::IncludedBytes(..) => unreachable!(),\n         ast::ExprKind::Err => None,\n     };\n \n@@ -659,7 +661,7 @@ fn to_control_flow(expr: &ast::Expr, expr_type: ExprType) -> Option<ControlFlow<\n         ast::ExprKind::ForLoop(ref pat, ref cond, ref block, label) => {\n             Some(ControlFlow::new_for(pat, cond, block, label, expr.span))\n         }\n-        ast::ExprKind::Loop(ref block, label) => {\n+        ast::ExprKind::Loop(ref block, label, _) => {\n             Some(ControlFlow::new_loop(block, label, expr.span))\n         }\n         ast::ExprKind::While(ref cond, ref block, label) => {\n@@ -1184,14 +1186,15 @@ pub(crate) fn is_unsafe_block(block: &ast::Block) -> bool {\n \n pub(crate) fn rewrite_literal(\n     context: &RewriteContext<'_>,\n-    l: &ast::Lit,\n+    token_lit: token::Lit,\n+    span: Span,\n     shape: Shape,\n ) -> Option<String> {\n-    match l.kind {\n-        ast::LitKind::Str(_, ast::StrStyle::Cooked) => rewrite_string_lit(context, l.span, shape),\n-        ast::LitKind::Int(..) => rewrite_int_lit(context, l, shape),\n+    match token_lit.kind {\n+        token::LitKind::Str => rewrite_string_lit(context, span, shape),\n+        token::LitKind::Integer => rewrite_int_lit(context, token_lit, span, shape),\n         _ => wrap_str(\n-            context.snippet(l.span).to_owned(),\n+            context.snippet(span).to_owned(),\n             context.config.max_width(),\n             shape,\n         ),\n@@ -1224,9 +1227,13 @@ fn rewrite_string_lit(context: &RewriteContext<'_>, span: Span, shape: Shape) ->\n     )\n }\n \n-fn rewrite_int_lit(context: &RewriteContext<'_>, lit: &ast::Lit, shape: Shape) -> Option<String> {\n-    let span = lit.span;\n-    let symbol = lit.token.symbol.as_str();\n+fn rewrite_int_lit(\n+    context: &RewriteContext<'_>,\n+    token_lit: token::Lit,\n+    span: Span,\n+    shape: Shape,\n+) -> Option<String> {\n+    let symbol = token_lit.symbol.as_str();\n \n     if let Some(symbol_stripped) = symbol.strip_prefix(\"0x\") {\n         let hex_lit = match context.config.hex_literal_case() {\n@@ -1239,7 +1246,7 @@ fn rewrite_int_lit(context: &RewriteContext<'_>, lit: &ast::Lit, shape: Shape) -\n                 format!(\n                     \"0x{}{}\",\n                     hex_lit,\n-                    lit.token.suffix.map_or(String::new(), |s| s.to_string())\n+                    token_lit.suffix.map_or(String::new(), |s| s.to_string())\n                 ),\n                 context.config.max_width(),\n                 shape,\n@@ -1335,7 +1342,7 @@ pub(crate) fn can_be_overflowed_expr(\n         }\n         ast::ExprKind::MacCall(ref mac) => {\n             match (\n-                rustc_ast::ast::MacDelimiter::from_token(mac.args.delim().unwrap()),\n+                rustc_ast::ast::MacDelimiter::from_token(mac.args.delim.to_token()),\n                 context.config.overflow_delimited_expr(),\n             ) {\n                 (Some(ast::MacDelimiter::Bracket), true)\n@@ -1531,7 +1538,7 @@ fn struct_lit_can_be_aligned(fields: &[ast::ExprField], has_base: bool) -> bool\n fn rewrite_struct_lit<'a>(\n     context: &RewriteContext<'_>,\n     path: &ast::Path,\n-    qself: Option<&ast::QSelf>,\n+    qself: &Option<ptr::P<ast::QSelf>>,\n     fields: &'a [ast::ExprField],\n     struct_rest: &ast::StructRest,\n     attrs: &[ast::Attribute],"}, {"sha": "339e5cef5af911675d0346344f662862c45c642a", "filename": "src/imports.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -116,7 +116,7 @@ pub(crate) struct UseTree {\n     // Additional fields for top level use items.\n     // Should we have another struct for top-level use items rather than reusing this?\n     visibility: Option<ast::Visibility>,\n-    attrs: Option<Vec<ast::Attribute>>,\n+    attrs: Option<ast::AttrVec>,\n }\n \n impl PartialEq for UseTree {\n@@ -417,7 +417,7 @@ impl UseTree {\n         list_item: Option<ListItem>,\n         visibility: Option<ast::Visibility>,\n         opt_lo: Option<BytePos>,\n-        attrs: Option<Vec<ast::Attribute>>,\n+        attrs: Option<ast::AttrVec>,\n     ) -> UseTree {\n         let span = if let Some(lo) = opt_lo {\n             mk_sp(lo, a.span.hi())\n@@ -490,7 +490,7 @@ impl UseTree {\n                 );\n                 result.path.push(UseSegment { kind, version });\n             }\n-            UseTreeKind::Simple(ref rename, ..) => {\n+            UseTreeKind::Simple(ref rename) => {\n                 // If the path has leading double colons and is composed of only 2 segments, then we\n                 // bypass the call to path_to_imported_ident which would get only the ident and\n                 // lose the path root, e.g., `that` in `::that`."}, {"sha": "25e8a024857ce9a5c541018aacb519c32ca13f0a", "filename": "src/items.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -594,7 +594,7 @@ impl<'a> FmtVisitor<'a> {\n             let both_type = |l: &TyOpt, r: &TyOpt| is_type(l) && is_type(r);\n             let both_opaque = |l: &TyOpt, r: &TyOpt| is_opaque(l) && is_opaque(r);\n             let need_empty_line = |a: &ast::AssocItemKind, b: &ast::AssocItemKind| match (a, b) {\n-                (TyAlias(lty), TyAlias(rty))\n+                (Type(lty), Type(rty))\n                     if both_type(&lty.ty, &rty.ty) || both_opaque(&lty.ty, &rty.ty) =>\n                 {\n                     false\n@@ -612,7 +612,7 @@ impl<'a> FmtVisitor<'a> {\n             }\n \n             buffer.sort_by(|(_, a), (_, b)| match (&a.kind, &b.kind) {\n-                (TyAlias(lty), TyAlias(rty))\n+                (Type(lty), Type(rty))\n                     if both_type(&lty.ty, &rty.ty) || both_opaque(&lty.ty, &rty.ty) =>\n                 {\n                     a.ident.as_str().cmp(b.ident.as_str())\n@@ -621,10 +621,10 @@ impl<'a> FmtVisitor<'a> {\n                     a.ident.as_str().cmp(b.ident.as_str())\n                 }\n                 (Fn(..), Fn(..)) => a.span.lo().cmp(&b.span.lo()),\n-                (TyAlias(ty), _) if is_type(&ty.ty) => Ordering::Less,\n-                (_, TyAlias(ty)) if is_type(&ty.ty) => Ordering::Greater,\n-                (TyAlias(..), _) => Ordering::Less,\n-                (_, TyAlias(..)) => Ordering::Greater,\n+                (Type(ty), _) if is_type(&ty.ty) => Ordering::Less,\n+                (_, Type(ty)) if is_type(&ty.ty) => Ordering::Greater,\n+                (Type(..), _) => Ordering::Less,\n+                (_, Type(..)) => Ordering::Greater,\n                 (Const(..), _) => Ordering::Less,\n                 (_, Const(..)) => Ordering::Greater,\n                 (MacCall(..), _) => Ordering::Less,"}, {"sha": "487fcc3a0df1a416acc07440f653285d746a1cbd", "filename": "src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -23,6 +23,11 @@ extern crate rustc_parse;\n extern crate rustc_session;\n extern crate rustc_span;\n \n+// Necessary to pull in object code as the rest of the rustc crates are shipped only as rmeta\n+// files.\n+#[allow(unused_extern_crates)]\n+extern crate rustc_driver;\n+\n use std::cell::RefCell;\n use std::collections::HashMap;\n use std::fmt;"}, {"sha": "d58f7547fefb3364f9cae0c308c6bff8d2ca94cf", "filename": "src/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -209,7 +209,7 @@ fn rewrite_macro_inner(\n         original_style\n     };\n \n-    let ts = mac.args.inner_tokens();\n+    let ts = mac.args.tokens.clone();\n     let has_comment = contains_comment(context.snippet(mac.span()));\n     if ts.is_empty() && !has_comment {\n         return match style {\n@@ -393,7 +393,7 @@ pub(crate) fn rewrite_macro_def(\n         return snippet;\n     }\n \n-    let ts = def.body.inner_tokens();\n+    let ts = def.body.tokens.clone();\n     let mut parser = MacroParser::new(ts.into_trees());\n     let parsed_def = match parser.parse() {\n         Some(def) => def,\n@@ -1088,7 +1088,7 @@ pub(crate) fn convert_try_mac(\n ) -> Option<ast::Expr> {\n     let path = &pprust::path_to_string(&mac.path);\n     if path == \"try\" || path == \"r#try\" {\n-        let ts = mac.args.inner_tokens();\n+        let ts = mac.args.tokens.clone();\n \n         Some(ast::Expr {\n             id: ast::NodeId::root(), // dummy value"}, {"sha": "7a0d1736c59a66ae729b9305bb049c71921d925c", "filename": "src/modules.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -26,7 +26,7 @@ type FileModMap<'ast> = BTreeMap<FileName, Module<'ast>>;\n pub(crate) struct Module<'a> {\n     ast_mod_kind: Option<Cow<'a, ast::ModKind>>,\n     pub(crate) items: Cow<'a, Vec<rustc_ast::ptr::P<ast::Item>>>,\n-    inner_attr: Vec<ast::Attribute>,\n+    inner_attr: ast::AttrVec,\n     pub(crate) span: Span,\n }\n \n@@ -35,7 +35,7 @@ impl<'a> Module<'a> {\n         mod_span: Span,\n         ast_mod_kind: Option<Cow<'a, ast::ModKind>>,\n         mod_items: Cow<'a, Vec<rustc_ast::ptr::P<ast::Item>>>,\n-        mod_attrs: Cow<'a, Vec<ast::Attribute>>,\n+        mod_attrs: Cow<'a, ast::AttrVec>,\n     ) -> Self {\n         let inner_attr = mod_attrs\n             .iter()\n@@ -158,7 +158,7 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n                         module_item.item.span,\n                         Some(Cow::Owned(sub_mod_kind.clone())),\n                         Cow::Owned(vec![]),\n-                        Cow::Owned(vec![]),\n+                        Cow::Owned(ast::AttrVec::new()),\n                     ),\n                 )?;\n             }\n@@ -185,7 +185,7 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n                         span,\n                         Some(Cow::Owned(sub_mod_kind.clone())),\n                         Cow::Owned(vec![]),\n-                        Cow::Owned(vec![]),\n+                        Cow::Owned(ast::AttrVec::new()),\n                     ),\n                 )?;\n             }"}, {"sha": "48431693332a619211a269c29da2669ed3d78ae3", "filename": "src/modules/visitor.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fmodules%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fmodules%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules%2Fvisitor.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -84,23 +84,27 @@ impl PathVisitor {\n }\n \n impl<'ast> MetaVisitor<'ast> for PathVisitor {\n-    fn visit_meta_name_value(&mut self, meta_item: &'ast ast::MetaItem, lit: &'ast ast::Lit) {\n+    fn visit_meta_name_value(\n+        &mut self,\n+        meta_item: &'ast ast::MetaItem,\n+        lit: &'ast ast::MetaItemLit,\n+    ) {\n         if meta_item.has_name(Symbol::intern(\"path\")) && lit.kind.is_str() {\n-            self.paths.push(lit_to_str(lit));\n+            self.paths.push(meta_item_lit_to_str(lit));\n         }\n     }\n }\n \n #[cfg(not(windows))]\n-fn lit_to_str(lit: &ast::Lit) -> String {\n+fn meta_item_lit_to_str(lit: &ast::MetaItemLit) -> String {\n     match lit.kind {\n         ast::LitKind::Str(symbol, ..) => symbol.to_string(),\n         _ => unreachable!(),\n     }\n }\n \n #[cfg(windows)]\n-fn lit_to_str(lit: &ast::Lit) -> String {\n+fn meta_item_lit_to_str(lit: &ast::MetaItemLit) -> String {\n     match lit.kind {\n         ast::LitKind::Str(symbol, ..) => symbol.as_str().replace(\"/\", \"\\\\\"),\n         _ => unreachable!(),"}, {"sha": "af0b95430a1979c9098d3facf79987cf453121ad", "filename": "src/overflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foverflow.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -125,7 +125,7 @@ impl<'a> OverflowableItem<'a> {\n             OverflowableItem::MacroArg(MacroArg::Keyword(..)) => true,\n             OverflowableItem::MacroArg(MacroArg::Expr(expr)) => is_simple_expr(expr),\n             OverflowableItem::NestedMetaItem(nested_meta_item) => match nested_meta_item {\n-                ast::NestedMetaItem::Literal(..) => true,\n+                ast::NestedMetaItem::Lit(..) => true,\n                 ast::NestedMetaItem::MetaItem(ref meta_item) => {\n                     matches!(meta_item.kind, ast::MetaItemKind::Word)\n                 }\n@@ -169,7 +169,7 @@ impl<'a> OverflowableItem<'a> {\n             },\n             OverflowableItem::NestedMetaItem(nested_meta_item) if len == 1 => {\n                 match nested_meta_item {\n-                    ast::NestedMetaItem::Literal(..) => false,\n+                    ast::NestedMetaItem::Lit(..) => false,\n                     ast::NestedMetaItem::MetaItem(..) => true,\n                 }\n             }"}, {"sha": "01edfab36547cc615f6f0f8e2e3a7de60cc78d9d", "filename": "src/parse/macros/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fparse%2Fmacros%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fparse%2Fmacros%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparse%2Fmacros%2Fasm.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -5,7 +5,7 @@ use crate::rewrite::RewriteContext;\n \n #[allow(dead_code)]\n pub(crate) fn parse_asm(context: &RewriteContext<'_>, mac: &ast::MacCall) -> Option<AsmArgs> {\n-    let ts = mac.args.inner_tokens();\n+    let ts = mac.args.tokens.clone();\n     let mut parser = super::build_parser(context, ts);\n     parse_asm_args(&mut parser, context.parse_sess.inner(), mac.span(), false).ok()\n }"}, {"sha": "ace1a76b3fe7d12babfb0530b105279e7b81abe2", "filename": "src/parse/macros/cfg_if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fparse%2Fmacros%2Fcfg_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fparse%2Fmacros%2Fcfg_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparse%2Fmacros%2Fcfg_if.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -23,7 +23,7 @@ fn parse_cfg_if_inner<'a>(\n     sess: &'a ParseSess,\n     mac: &'a ast::MacCall,\n ) -> Result<Vec<ast::Item>, &'static str> {\n-    let ts = mac.args.inner_tokens();\n+    let ts = mac.args.tokens.clone();\n     let mut parser = build_stream_parser(sess.inner(), ts);\n \n     let mut items = vec![];"}, {"sha": "e0bd065518b3db5f7e9016ba428e755086c8a923", "filename": "src/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparse%2Fparser.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -109,7 +109,7 @@ impl<'a> Parser<'a> {\n         sess: &'a ParseSess,\n         path: &Path,\n         span: Span,\n-    ) -> Result<(Vec<ast::Attribute>, Vec<ptr::P<ast::Item>>, Span), ParserError> {\n+    ) -> Result<(ast::AttrVec, Vec<ptr::P<ast::Item>>, Span), ParserError> {\n         let result = catch_unwind(AssertUnwindSafe(|| {\n             let mut parser = new_parser_from_file(sess.inner(), path, Some(span));\n             match parser.parse_mod(&TokenKind::Eof) {"}, {"sha": "6bfec79cd7030a5bfe921b5a24b33e1daf68b2fc", "filename": "src/parse/session.rs", "status": "modified", "additions": 34, "deletions": 19, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fparse%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fparse%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparse%2Fsession.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -3,6 +3,7 @@ use std::sync::atomic::{AtomicBool, Ordering};\n \n use rustc_data_structures::sync::{Lrc, Send};\n use rustc_errors::emitter::{Emitter, EmitterWriter};\n+use rustc_errors::translation::Translate;\n use rustc_errors::{ColorConfig, Diagnostic, Handler, Level as DiagnosticLevel};\n use rustc_session::parse::ParseSess as RawParseSess;\n use rustc_span::{\n@@ -28,19 +29,24 @@ pub(crate) struct ParseSess {\n /// Emitter which discards every error.\n struct SilentEmitter;\n \n-impl Emitter for SilentEmitter {\n-    fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n-        None\n-    }\n-    fn emit_diagnostic(&mut self, _db: &Diagnostic) {}\n+impl Translate for SilentEmitter {\n     fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n         None\n     }\n+\n     fn fallback_fluent_bundle(&self) -> &rustc_errors::FluentBundle {\n         panic!(\"silent emitter attempted to translate a diagnostic\");\n     }\n }\n \n+impl Emitter for SilentEmitter {\n+    fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n+        None\n+    }\n+\n+    fn emit_diagnostic(&mut self, _db: &Diagnostic) {}\n+}\n+\n fn silent_emitter() -> Box<dyn Emitter + Send> {\n     Box::new(SilentEmitter {})\n }\n@@ -62,10 +68,21 @@ impl SilentOnIgnoredFilesEmitter {\n     }\n }\n \n+impl Translate for SilentOnIgnoredFilesEmitter {\n+    fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n+        self.emitter.fluent_bundle()\n+    }\n+\n+    fn fallback_fluent_bundle(&self) -> &rustc_errors::FluentBundle {\n+        self.emitter.fallback_fluent_bundle()\n+    }\n+}\n+\n impl Emitter for SilentOnIgnoredFilesEmitter {\n     fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n         None\n     }\n+\n     fn emit_diagnostic(&mut self, db: &Diagnostic) {\n         if db.level() == DiagnosticLevel::Fatal {\n             return self.handle_non_ignoreable_error(db);\n@@ -88,14 +105,6 @@ impl Emitter for SilentOnIgnoredFilesEmitter {\n         }\n         self.handle_non_ignoreable_error(db);\n     }\n-\n-    fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n-        self.emitter.fluent_bundle()\n-    }\n-\n-    fn fallback_fluent_bundle(&self) -> &rustc_errors::FluentBundle {\n-        self.emitter.fallback_fluent_bundle()\n-    }\n }\n \n fn default_handler(\n@@ -125,6 +134,7 @@ fn default_handler(\n             false,\n             None,\n             false,\n+            false,\n         ))\n     };\n     Handler::with_emitter(\n@@ -340,19 +350,24 @@ mod tests {\n             num_emitted_errors: Lrc<AtomicU32>,\n         }\n \n+        impl Translate for TestEmitter {\n+            fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n+                None\n+            }\n+\n+            fn fallback_fluent_bundle(&self) -> &rustc_errors::FluentBundle {\n+                panic!(\"test emitter attempted to translate a diagnostic\");\n+            }\n+        }\n+\n         impl Emitter for TestEmitter {\n             fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n                 None\n             }\n+\n             fn emit_diagnostic(&mut self, _db: &Diagnostic) {\n                 self.num_emitted_errors.fetch_add(1, Ordering::Release);\n             }\n-            fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n-                None\n-            }\n-            fn fallback_fluent_bundle(&self) -> &rustc_errors::FluentBundle {\n-                panic!(\"test emitter attempted to translate a diagnostic\");\n-            }\n         }\n \n         fn build_diagnostic(level: DiagnosticLevel, span: Option<MultiSpan>) -> Diagnostic {"}, {"sha": "3f335172590ec808e44a3a667905e1764cd01aba", "filename": "src/patterns.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -1,4 +1,6 @@\n-use rustc_ast::ast::{self, BindingMode, Pat, PatField, PatKind, RangeEnd, RangeSyntax};\n+use rustc_ast::ast::{\n+    self, BindingAnnotation, ByRef, Pat, PatField, PatKind, RangeEnd, RangeSyntax,\n+};\n use rustc_ast::ptr;\n use rustc_span::{BytePos, Span};\n \n@@ -99,10 +101,10 @@ impl Rewrite for Pat {\n                 write_list(&items, &fmt)\n             }\n             PatKind::Box(ref pat) => rewrite_unary_prefix(context, \"box \", &**pat, shape),\n-            PatKind::Ident(binding_mode, ident, ref sub_pat) => {\n-                let (prefix, mutability) = match binding_mode {\n-                    BindingMode::ByRef(mutability) => (\"ref\", mutability),\n-                    BindingMode::ByValue(mutability) => (\"\", mutability),\n+            PatKind::Ident(BindingAnnotation(by_ref, mutability), ident, ref sub_pat) => {\n+                let prefix = match by_ref {\n+                    ByRef::Yes => \"ref\",\n+                    ByRef::No => \"\",\n                 };\n                 let mut_infix = format_mutability(mutability).trim();\n                 let id_str = rewrite_ident(context, ident);\n@@ -225,11 +227,10 @@ impl Rewrite for Pat {\n             }\n             PatKind::Tuple(ref items) => rewrite_tuple_pat(items, None, self.span, context, shape),\n             PatKind::Path(ref q_self, ref path) => {\n-                rewrite_path(context, PathContext::Expr, q_self.as_ref(), path, shape)\n+                rewrite_path(context, PathContext::Expr, q_self, path, shape)\n             }\n             PatKind::TupleStruct(ref q_self, ref path, ref pat_vec) => {\n-                let path_str =\n-                    rewrite_path(context, PathContext::Expr, q_self.as_ref(), path, shape)?;\n+                let path_str = rewrite_path(context, PathContext::Expr, q_self, path, shape)?;\n                 rewrite_tuple_pat(pat_vec, Some(path_str), self.span, context, shape)\n             }\n             PatKind::Lit(ref expr) => expr.rewrite(context, shape),\n@@ -269,7 +270,7 @@ impl Rewrite for Pat {\n }\n \n fn rewrite_struct_pat(\n-    qself: &Option<ast::QSelf>,\n+    qself: &Option<ptr::P<ast::QSelf>>,\n     path: &ast::Path,\n     fields: &[ast::PatField],\n     ellipsis: bool,\n@@ -279,7 +280,7 @@ fn rewrite_struct_pat(\n ) -> Option<String> {\n     // 2 =  ` {`\n     let path_shape = shape.sub_width(2)?;\n-    let path_str = rewrite_path(context, PathContext::Expr, qself.as_ref(), path, path_shape)?;\n+    let path_str = rewrite_path(context, PathContext::Expr, qself, path, path_shape)?;\n \n     if fields.is_empty() && !ellipsis {\n         return Some(format!(\"{} {{}}\", path_str));"}, {"sha": "68f85b2ade48a6191bd1110aa6dce2964ed39b41", "filename": "src/skip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fskip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fskip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fskip.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -109,8 +109,8 @@ fn get_skip_names(kind: &str, attrs: &[ast::Attribute]) -> Vec<String> {\n     for attr in attrs {\n         // rustc_ast::ast::Path is implemented partialEq\n         // but it is designed for segments.len() == 1\n-        if let ast::AttrKind::Normal(attr_item, _) = &attr.kind {\n-            if pprust::path_to_string(&attr_item.path) != path {\n+        if let ast::AttrKind::Normal(normal) = &attr.kind {\n+            if pprust::path_to_string(&normal.item.path) != path {\n                 continue;\n             }\n         }"}, {"sha": "2cae5498107512d99a7909f8f6622be3fb49c34f", "filename": "src/types.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -38,11 +38,11 @@ pub(crate) enum PathContext {\n pub(crate) fn rewrite_path(\n     context: &RewriteContext<'_>,\n     path_context: PathContext,\n-    qself: Option<&ast::QSelf>,\n+    qself: &Option<ptr::P<ast::QSelf>>,\n     path: &ast::Path,\n     shape: Shape,\n ) -> Option<String> {\n-    let skip_count = qself.map_or(0, |x| x.position);\n+    let skip_count = qself.as_ref().map_or(0, |x| x.position);\n \n     let mut result = if path.is_global() && qself.is_none() && path_context != PathContext::Import {\n         \"::\".to_owned()\n@@ -655,7 +655,7 @@ impl Rewrite for ast::PolyTraitRef {\n \n impl Rewrite for ast::TraitRef {\n     fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n-        rewrite_path(context, PathContext::Type, None, &self.path, shape)\n+        rewrite_path(context, PathContext::Type, &None, &self.path, shape)\n     }\n }\n \n@@ -688,7 +688,7 @@ impl Rewrite for ast::Ty {\n \n                 rewrite_unary_prefix(context, prefix, &*mt.ty, shape)\n             }\n-            ast::TyKind::Rptr(ref lifetime, ref mt) => {\n+            ast::TyKind::Ref(ref lifetime, ref mt) => {\n                 let mut_str = format_mutability(mt.mutbl);\n                 let mut_len = mut_str.len();\n                 let mut result = String::with_capacity(128);\n@@ -800,7 +800,7 @@ impl Rewrite for ast::Ty {\n                 rewrite_tuple(context, items.iter(), self.span, shape, items.len() == 1)\n             }\n             ast::TyKind::Path(ref q_self, ref path) => {\n-                rewrite_path(context, PathContext::Type, q_self.as_ref(), path, shape)\n+                rewrite_path(context, PathContext::Type, q_self, path, shape)\n             }\n             ast::TyKind::Array(ref ty, ref repeats) => rewrite_pair(\n                 &**ty,\n@@ -1094,7 +1094,7 @@ pub(crate) fn can_be_overflowed_type(\n ) -> bool {\n     match ty.kind {\n         ast::TyKind::Tup(..) => context.use_block_indent() && len == 1,\n-        ast::TyKind::Rptr(_, ref mutty) | ast::TyKind::Ptr(ref mutty) => {\n+        ast::TyKind::Ref(_, ref mutty) | ast::TyKind::Ptr(ref mutty) => {\n             can_be_overflowed_type(context, &*mutty.ty, len)\n         }\n         _ => false,"}, {"sha": "f681f55b37b9d80587610573d13ec2153060dd48", "filename": "src/utils.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -263,7 +263,7 @@ fn is_skip(meta_item: &MetaItem) -> bool {\n fn is_skip_nested(meta_item: &NestedMetaItem) -> bool {\n     match meta_item {\n         NestedMetaItem::MetaItem(ref mi) => is_skip(mi),\n-        NestedMetaItem::Literal(_) => false,\n+        NestedMetaItem::Lit(_) => false,\n     }\n }\n \n@@ -480,9 +480,9 @@ pub(crate) fn is_block_expr(context: &RewriteContext<'_>, expr: &ast::Expr, repr\n         | ast::ExprKind::Binary(_, _, ref expr)\n         | ast::ExprKind::Index(_, ref expr)\n         | ast::ExprKind::Unary(_, ref expr)\n-        | ast::ExprKind::Closure(_, _, _, _, _, ref expr, _)\n         | ast::ExprKind::Try(ref expr)\n         | ast::ExprKind::Yield(Some(ref expr)) => is_block_expr(context, expr, repr),\n+        ast::ExprKind::Closure(ref closure) => is_block_expr(context, &closure.body, repr),\n         // This can only be a string lit\n         ast::ExprKind::Lit(_) => {\n             repr.contains('\\n') && trimmed_last_line_width(repr) <= context.config.tab_spaces()\n@@ -497,6 +497,7 @@ pub(crate) fn is_block_expr(context: &RewriteContext<'_>, expr: &ast::Expr, repr\n         | ast::ExprKind::Continue(..)\n         | ast::ExprKind::Err\n         | ast::ExprKind::Field(..)\n+        | ast::ExprKind::IncludedBytes(..)\n         | ast::ExprKind::InlineAsm(..)\n         | ast::ExprKind::Let(..)\n         | ast::ExprKind::Path(..)"}, {"sha": "f4d84d1381fc0c3745ec463ae839204a3bf8f644", "filename": "src/visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -660,7 +660,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                     self.push_rewrite(ai.span, rewrite);\n                 }\n             }\n-            (ast::AssocItemKind::TyAlias(ref ty_alias), _) => {\n+            (ast::AssocItemKind::Type(ref ty_alias), _) => {\n                 self.visit_ty_alias_kind(ty_alias, visitor_kind, ai.span);\n             }\n             (ast::AssocItemKind::MacCall(ref mac), _) => {\n@@ -820,8 +820,8 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                 );\n             } else {\n                 match &attr.kind {\n-                    ast::AttrKind::Normal(ref attribute_item, _)\n-                        if self.is_unknown_rustfmt_attr(&attribute_item.path.segments) =>\n+                    ast::AttrKind::Normal(ref normal)\n+                        if self.is_unknown_rustfmt_attr(&normal.item.path.segments) =>\n                     {\n                         let file_name = self.parse_sess.span_to_filename(attr.span);\n                         self.report.append("}, {"sha": "deef429dbee08b2d154b9fd35861f7eb51636409", "filename": "tests/source/issue-2445.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/tests%2Fsource%2Fissue-2445.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/tests%2Fsource%2Fissue-2445.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-2445.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -1,6 +1,6 @@\n test!(RunPassPretty {\n             // comment\n-    path: \"src/test/run-pass/pretty\",\n+    path: \"tests/run-pass/pretty\",\n     mode: \"pretty\",\n     suite: \"run-pass\",\n     default: false,\n@@ -9,7 +9,7 @@ test!(RunPassPretty {\n \n test!(RunPassPretty {\n             // comment\n-    path: \"src/test/run-pass/pretty\",\n+    path: \"tests/run-pass/pretty\",\n     mode: \"pretty\",\n     suite: \"run-pass\",\n     default: false,"}, {"sha": "e68ca2c5907fcc55c1b36cabcb781d49d5ab48c3", "filename": "tests/source/issue-3217.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/tests%2Fsource%2Fissue-3217.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/tests%2Fsource%2Fissue-3217.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-3217.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -1,5 +1,3 @@\n-#![feature(label_break_value)]\n-\n fn main() {\n     let mut res = 0;\n     's_39: { if res == 0i32 { println!(\"Hello, world!\"); } }"}, {"sha": "9482512efca0a4dd94062b992478ddc6a95e1795", "filename": "tests/source/issue_4257.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/tests%2Fsource%2Fissue_4257.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/tests%2Fsource%2Fissue_4257.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue_4257.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -1,6 +1,3 @@\n-#![feature(generic_associated_types)]\n-#![allow(incomplete_features)]\n-\n trait Trait<T> {\n     type Type<'a> where T: 'a;\n     fn foo(x: &T) -> Self::Type<'_>;"}, {"sha": "c254db7b509cc765189cacc188f56a28490dae3f", "filename": "tests/source/issue_4911.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/tests%2Fsource%2Fissue_4911.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/tests%2Fsource%2Fissue_4911.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue_4911.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -1,4 +1,3 @@\n-#![feature(generic_associated_types)]\n #![feature(min_type_alias_impl_trait)]\n \n impl SomeTrait for SomeType {"}, {"sha": "307d9a4a1aba195c5a342d9e2ae7bcf8e20c28ba", "filename": "tests/source/issue_4943.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/tests%2Fsource%2Fissue_4943.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/tests%2Fsource%2Fissue_4943.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue_4943.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -1,5 +1,3 @@\n-#![feature(generic_associated_types)]\n-\n impl SomeStruct {\n     fn process<T>(v: T) -> <Self as GAT>::R<T>\n     where Self: GAT<R<T> = T>"}, {"sha": "463c5d4957686470d7d91bcf10cd6a47a599e2f3", "filename": "tests/target/issue-2445.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/tests%2Ftarget%2Fissue-2445.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/tests%2Ftarget%2Fissue-2445.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-2445.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -1,6 +1,6 @@\n test!(RunPassPretty {\n     // comment\n-    path: \"src/test/run-pass/pretty\",\n+    path: \"tests/run-pass/pretty\",\n     mode: \"pretty\",\n     suite: \"run-pass\",\n     default: false,\n@@ -9,7 +9,7 @@ test!(RunPassPretty {\n \n test!(RunPassPretty {\n     // comment\n-    path: \"src/test/run-pass/pretty\",\n+    path: \"tests/run-pass/pretty\",\n     mode: \"pretty\",\n     suite: \"run-pass\",\n     default: false,"}, {"sha": "403bf4c340a4eaf58e3958795bc85dd0df98056d", "filename": "tests/target/issue-3217.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/tests%2Ftarget%2Fissue-3217.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/tests%2Ftarget%2Fissue-3217.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-3217.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -1,5 +1,3 @@\n-#![feature(label_break_value)]\n-\n fn main() {\n     let mut res = 0;\n     's_39: {"}, {"sha": "d3734e90b7ffa97c47633d0a0b6909356ea26160", "filename": "tests/target/issue_4110.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/tests%2Ftarget%2Fissue_4110.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/tests%2Ftarget%2Fissue_4110.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue_4110.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -20,6 +20,7 @@ fn bindings() {\n                 category,\n                 span,\n                 &format!(\"`{}`\", name),\n+                \"function\",\n             ),\n         (\n             ref name,"}, {"sha": "309a66c8dc3ccfb6e7782a36bb483a213926203d", "filename": "tests/target/issue_4257.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/tests%2Ftarget%2Fissue_4257.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/tests%2Ftarget%2Fissue_4257.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue_4257.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -1,6 +1,3 @@\n-#![feature(generic_associated_types)]\n-#![allow(incomplete_features)]\n-\n trait Trait<T> {\n     type Type<'a>\n     where"}, {"sha": "0f64aa7f766fd649518262618f634d9e12f43d6e", "filename": "tests/target/issue_4911.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/tests%2Ftarget%2Fissue_4911.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/tests%2Ftarget%2Fissue_4911.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue_4911.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -1,4 +1,3 @@\n-#![feature(generic_associated_types)]\n #![feature(min_type_alias_impl_trait)]\n \n impl SomeTrait for SomeType {"}, {"sha": "bc8f1a366da29d75c30ab1ee13af05d1d2ff30ee", "filename": "tests/target/issue_4943.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6eeb4fd23050d531293580dc83ca19e0fd7244e4/tests%2Ftarget%2Fissue_4943.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeb4fd23050d531293580dc83ca19e0fd7244e4/tests%2Ftarget%2Fissue_4943.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue_4943.rs?ref=6eeb4fd23050d531293580dc83ca19e0fd7244e4", "patch": "@@ -1,5 +1,3 @@\n-#![feature(generic_associated_types)]\n-\n impl SomeStruct {\n     fn process<T>(v: T) -> <Self as GAT>::R<T>\n     where"}]}