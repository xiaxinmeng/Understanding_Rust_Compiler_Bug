{"sha": "6589d794927451ed5d503b108e0e6900bbf91d3d", "node_id": "C_kwDOAAsO6NoAKDY1ODlkNzk0OTI3NDUxZWQ1ZDUwM2IxMDhlMGU2OTAwYmJmOTFkM2Q", "commit": {"author": {"name": "Alex Macleod", "email": "alex@macleod.io", "date": "2023-03-28T21:28:57Z"}, "committer": {"name": "Alex Macleod", "email": "alex@macleod.io", "date": "2023-03-28T21:28:57Z"}, "message": "Replace remaining usage of `FormatArgsExpn`", "tree": {"sha": "aa353b846b2d744cea7b7ed76728920c47536fce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa353b846b2d744cea7b7ed76728920c47536fce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6589d794927451ed5d503b108e0e6900bbf91d3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6589d794927451ed5d503b108e0e6900bbf91d3d", "html_url": "https://github.com/rust-lang/rust/commit/6589d794927451ed5d503b108e0e6900bbf91d3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6589d794927451ed5d503b108e0e6900bbf91d3d/comments", "author": {"login": "Alexendoo", "id": 1830331, "node_id": "MDQ6VXNlcjE4MzAzMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1830331?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Alexendoo", "html_url": "https://github.com/Alexendoo", "followers_url": "https://api.github.com/users/Alexendoo/followers", "following_url": "https://api.github.com/users/Alexendoo/following{/other_user}", "gists_url": "https://api.github.com/users/Alexendoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/Alexendoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Alexendoo/subscriptions", "organizations_url": "https://api.github.com/users/Alexendoo/orgs", "repos_url": "https://api.github.com/users/Alexendoo/repos", "events_url": "https://api.github.com/users/Alexendoo/events{/privacy}", "received_events_url": "https://api.github.com/users/Alexendoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Alexendoo", "id": 1830331, "node_id": "MDQ6VXNlcjE4MzAzMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1830331?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Alexendoo", "html_url": "https://github.com/Alexendoo", "followers_url": "https://api.github.com/users/Alexendoo/followers", "following_url": "https://api.github.com/users/Alexendoo/following{/other_user}", "gists_url": "https://api.github.com/users/Alexendoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/Alexendoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Alexendoo/subscriptions", "organizations_url": "https://api.github.com/users/Alexendoo/orgs", "repos_url": "https://api.github.com/users/Alexendoo/repos", "events_url": "https://api.github.com/users/Alexendoo/events{/privacy}", "received_events_url": "https://api.github.com/users/Alexendoo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84e42fb363d295c87e9b191b3e2816e25b6cb42e", "url": "https://api.github.com/repos/rust-lang/rust/commits/84e42fb363d295c87e9b191b3e2816e25b6cb42e", "html_url": "https://github.com/rust-lang/rust/commit/84e42fb363d295c87e9b191b3e2816e25b6cb42e"}], "stats": {"total": 935, "additions": 132, "deletions": 803}, "files": [{"sha": "315df6c714ffc4681d7189552347f773c4bca68f", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6589d794927451ed5d503b108e0e6900bbf91d3d/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6589d794927451ed5d503b108e0e6900bbf91d3d/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=6589d794927451ed5d503b108e0e6900bbf91d3d", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::macros::FormatArgsExpn;\n+use clippy_utils::macros::{find_format_args, format_args_inputs_span};\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{is_expn_of, match_function_call, paths};\n use if_chain::if_chain;\n@@ -8,7 +8,7 @@ use rustc_hir::def::Res;\n use rustc_hir::{BindingAnnotation, Block, BlockCheckMode, Expr, ExprKind, Node, PatKind, QPath, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n+use rustc_span::{sym, ExpnId};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -43,23 +43,22 @@ declare_lint_pass!(ExplicitWrite => [EXPLICIT_WRITE]);\n \n impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            // match call to unwrap\n-            if let ExprKind::MethodCall(unwrap_fun, write_call, [], _) = expr.kind;\n-            if unwrap_fun.ident.name == sym::unwrap;\n+        // match call to unwrap\n+        if let ExprKind::MethodCall(unwrap_fun, write_call, [], _) = expr.kind\n+            && unwrap_fun.ident.name == sym::unwrap\n             // match call to write_fmt\n-            if let ExprKind::MethodCall(write_fun, write_recv, [write_arg], _) = look_in_block(cx, &write_call.kind);\n-            if write_fun.ident.name == sym!(write_fmt);\n+            && let ExprKind::MethodCall(write_fun, write_recv, [write_arg], _) = look_in_block(cx, &write_call.kind)\n+            && write_fun.ident.name == sym!(write_fmt)\n             // match calls to std::io::stdout() / std::io::stderr ()\n-            if let Some(dest_name) = if match_function_call(cx, write_recv, &paths::STDOUT).is_some() {\n+            && let Some(dest_name) = if match_function_call(cx, write_recv, &paths::STDOUT).is_some() {\n                 Some(\"stdout\")\n             } else if match_function_call(cx, write_recv, &paths::STDERR).is_some() {\n                 Some(\"stderr\")\n             } else {\n                 None\n-            };\n-            if let Some(format_args) = FormatArgsExpn::parse(cx, write_arg);\n-            then {\n+            }\n+        {\n+            find_format_args(cx, write_arg, ExpnId::root(), |format_args| {\n                 let calling_macro =\n                     // ordering is important here, since `writeln!` uses `write!` internally\n                     if is_expn_of(write_call.span, \"writeln\").is_some() {\n@@ -92,7 +91,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let inputs_snippet = snippet_with_applicability(\n                     cx,\n-                    format_args.inputs_span(),\n+                    format_args_inputs_span(format_args),\n                     \"..\",\n                     &mut applicability,\n                 );\n@@ -104,8 +103,8 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n                     \"try this\",\n                     format!(\"{prefix}{sugg_mac}!({inputs_snippet})\"),\n                     applicability,\n-                )\n-            }\n+                );\n+            });\n         }\n     }\n }"}, {"sha": "d34d6e9279e4dde86fff5f9f0c5d82cec7685471", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 44, "deletions": 47, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/6589d794927451ed5d503b108e0e6900bbf91d3d/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6589d794927451ed5d503b108e0e6900bbf91d3d/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=6589d794927451ed5d503b108e0e6900bbf91d3d", "patch": "@@ -1,14 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::macros::{root_macro_call_first_node, FormatArgsExpn};\n-use clippy_utils::source::snippet_with_context;\n+use clippy_utils::macros::{find_format_arg_expr, find_format_args, root_macro_call_first_node};\n+use clippy_utils::source::{snippet_opt, snippet_with_context};\n use clippy_utils::sugg::Sugg;\n-use if_chain::if_chain;\n+use rustc_ast::{FormatArgsPiece, FormatOptions, FormatTrait};\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::symbol::kw;\n use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n@@ -44,55 +43,53 @@ declare_lint_pass!(UselessFormat => [USELESS_FORMAT]);\n \n impl<'tcx> LateLintPass<'tcx> for UselessFormat {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        let (format_args, call_site) = if_chain! {\n-            if let Some(macro_call) = root_macro_call_first_node(cx, expr);\n-            if cx.tcx.is_diagnostic_item(sym::format_macro, macro_call.def_id);\n-            if let Some(format_args) = FormatArgsExpn::find_nested(cx, expr, macro_call.expn);\n-            then {\n-                (format_args, macro_call.span)\n-            } else {\n-                return\n-            }\n-        };\n+        let Some(macro_call) = root_macro_call_first_node(cx, expr) else { return };\n+        if !cx.tcx.is_diagnostic_item(sym::format_macro, macro_call.def_id) {\n+            return;\n+        }\n+\n+        find_format_args(cx, expr, macro_call.expn, |format_args| {\n+            let mut applicability = Applicability::MachineApplicable;\n+            let call_site = macro_call.span;\n \n-        let mut applicability = Applicability::MachineApplicable;\n-        if format_args.args.is_empty() {\n-            match *format_args.format_string.parts {\n-                [] => span_useless_format_empty(cx, call_site, \"String::new()\".to_owned(), applicability),\n-                [_] => {\n+            match (format_args.arguments.all_args(), &format_args.template[..]) {\n+                ([], []) => span_useless_format_empty(cx, call_site, \"String::new()\".to_owned(), applicability),\n+                ([], [_]) => {\n                     // Simulate macro expansion, converting {{ and }} to { and }.\n-                    let s_expand = format_args.format_string.snippet.replace(\"{{\", \"{\").replace(\"}}\", \"}\");\n+                    let Some(snippet) = snippet_opt(cx, format_args.span) else { return };\n+                    let s_expand = snippet.replace(\"{{\", \"{\").replace(\"}}\", \"}\");\n                     let sugg = format!(\"{s_expand}.to_string()\");\n                     span_useless_format(cx, call_site, sugg, applicability);\n                 },\n-                [..] => {},\n-            }\n-        } else if let [arg] = &*format_args.args {\n-            let value = arg.param.value;\n-            if_chain! {\n-                if format_args.format_string.parts == [kw::Empty];\n-                if arg.format.is_default();\n-                if match cx.typeck_results().expr_ty(value).peel_refs().kind() {\n-                    ty::Adt(adt, _) => Some(adt.did()) == cx.tcx.lang_items().string(),\n-                    ty::Str => true,\n-                    _ => false,\n-                };\n-                then {\n-                    let is_new_string = match value.kind {\n-                        ExprKind::Binary(..) => true,\n-                        ExprKind::MethodCall(path, ..) => path.ident.name == sym::to_string,\n-                        _ => false,\n-                    };\n-                    let sugg = if is_new_string {\n-                        snippet_with_context(cx, value.span, call_site.ctxt(), \"..\", &mut applicability).0.into_owned()\n-                    } else {\n-                        let sugg = Sugg::hir_with_context(cx, value, call_site.ctxt(), \"<arg>\", &mut applicability);\n-                        format!(\"{}.to_string()\", sugg.maybe_par())\n-                    };\n-                    span_useless_format(cx, call_site, sugg, applicability);\n-                }\n+                ([arg], [piece]) => {\n+                    if let Ok(value) = find_format_arg_expr(expr, arg)\n+                        && let FormatArgsPiece::Placeholder(placeholder) = piece\n+                        && placeholder.format_trait == FormatTrait::Display\n+                        && placeholder.format_options == FormatOptions::default()\n+                        && match cx.typeck_results().expr_ty(value).peel_refs().kind() {\n+                            ty::Adt(adt, _) => Some(adt.did()) == cx.tcx.lang_items().string(),\n+                            ty::Str => true,\n+                            _ => false,\n+                        }\n+                    {\n+                        let is_new_string = match value.kind {\n+                            ExprKind::Binary(..) => true,\n+                            ExprKind::MethodCall(path, ..) => path.ident.name == sym::to_string,\n+                            _ => false,\n+                        };\n+                        let sugg = if is_new_string {\n+                            snippet_with_context(cx, value.span, call_site.ctxt(), \"..\", &mut applicability).0.into_owned()\n+                        } else {\n+                            let sugg = Sugg::hir_with_context(cx, value, call_site.ctxt(), \"<arg>\", &mut applicability);\n+                            format!(\"{}.to_string()\", sugg.maybe_par())\n+                        };\n+                        span_useless_format(cx, call_site, sugg, applicability);\n+\n+                    }\n+                },\n+                _ => {},\n             }\n-        };\n+        });\n     }\n }\n "}, {"sha": "e3ddbfb5981f8fd1e1425b9cc85625caa5e36e91", "filename": "clippy_lints/src/format_impl.rs", "status": "modified", "additions": 38, "deletions": 22, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6589d794927451ed5d503b108e0e6900bbf91d3d/clippy_lints%2Fsrc%2Fformat_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6589d794927451ed5d503b108e0e6900bbf91d3d/clippy_lints%2Fsrc%2Fformat_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_impl.rs?ref=6589d794927451ed5d503b108e0e6900bbf91d3d", "patch": "@@ -1,11 +1,13 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n-use clippy_utils::macros::{is_format_macro, root_macro_call_first_node, FormatArg, FormatArgsExpn};\n+use clippy_utils::macros::{find_format_arg_expr, find_format_args, is_format_macro, root_macro_call_first_node};\n use clippy_utils::{get_parent_as_impl, is_diag_trait_item, path_to_local, peel_ref_operators};\n use if_chain::if_chain;\n+use rustc_ast::{FormatArgsPiece, FormatTrait};\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, Impl, ImplItem, ImplItemKind, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::Span;\n use rustc_span::{sym, symbol::kw, Symbol};\n \n declare_clippy_lint! {\n@@ -89,7 +91,7 @@ declare_clippy_lint! {\n }\n \n #[derive(Clone, Copy)]\n-struct FormatTrait {\n+struct FormatTraitNames {\n     /// e.g. `sym::Display`\n     name: Symbol,\n     /// `f` in `fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {}`\n@@ -99,7 +101,7 @@ struct FormatTrait {\n #[derive(Default)]\n pub struct FormatImpl {\n     // Whether we are inside Display or Debug trait impl - None for neither\n-    format_trait_impl: Option<FormatTrait>,\n+    format_trait_impl: Option<FormatTraitNames>,\n }\n \n impl FormatImpl {\n@@ -161,43 +163,57 @@ fn check_to_string_in_display(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     }\n }\n \n-fn check_self_in_format_args<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, impl_trait: FormatTrait) {\n+fn check_self_in_format_args<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, impl_trait: FormatTraitNames) {\n     // Check each arg in format calls - do we ever use Display on self (directly or via deref)?\n-    if_chain! {\n-        if let Some(outer_macro) = root_macro_call_first_node(cx, expr);\n-        if let macro_def_id = outer_macro.def_id;\n-        if let Some(format_args) = FormatArgsExpn::find_nested(cx, expr, outer_macro.expn);\n-        if is_format_macro(cx, macro_def_id);\n-        then {\n-            for arg in format_args.args {\n-                if arg.format.r#trait != impl_trait.name {\n-                    continue;\n+    if let Some(outer_macro) = root_macro_call_first_node(cx, expr)\n+        && let macro_def_id = outer_macro.def_id\n+        && is_format_macro(cx, macro_def_id)\n+    {\n+        find_format_args(cx, expr, outer_macro.expn, |format_args| {\n+            for piece in &format_args.template {\n+                if let FormatArgsPiece::Placeholder(placeholder) = piece\n+                    && let trait_name = match placeholder.format_trait {\n+                        FormatTrait::Display => sym::Display,\n+                        FormatTrait::Debug => sym::Debug,\n+                        FormatTrait::LowerExp => sym!(LowerExp),\n+                        FormatTrait::UpperExp => sym!(UpperExp),\n+                        FormatTrait::Octal => sym!(Octal),\n+                        FormatTrait::Pointer => sym::Pointer,\n+                        FormatTrait::Binary => sym!(Binary),\n+                        FormatTrait::LowerHex => sym!(LowerHex),\n+                        FormatTrait::UpperHex => sym!(UpperHex),\n+                    }\n+                    && trait_name == impl_trait.name\n+                    && let Ok(index) = placeholder.argument.index\n+                    && let Some(arg) = format_args.arguments.all_args().get(index)\n+                    && let Ok(arg_expr) = find_format_arg_expr(expr, arg)\n+                {\n+                    check_format_arg_self(cx, expr.span, arg_expr, impl_trait);\n                 }\n-                check_format_arg_self(cx, expr, &arg, impl_trait);\n             }\n-        }\n+        });\n     }\n }\n \n-fn check_format_arg_self(cx: &LateContext<'_>, expr: &Expr<'_>, arg: &FormatArg<'_>, impl_trait: FormatTrait) {\n+fn check_format_arg_self(cx: &LateContext<'_>, span: Span, arg: &Expr<'_>, impl_trait: FormatTraitNames) {\n     // Handle multiple dereferencing of references e.g. &&self\n     // Handle dereference of &self -> self that is equivalent (i.e. via *self in fmt() impl)\n     // Since the argument to fmt is itself a reference: &self\n-    let reference = peel_ref_operators(cx, arg.param.value);\n+    let reference = peel_ref_operators(cx, arg);\n     let map = cx.tcx.hir();\n     // Is the reference self?\n     if path_to_local(reference).map(|x| map.name(x)) == Some(kw::SelfLower) {\n-        let FormatTrait { name, .. } = impl_trait;\n+        let FormatTraitNames { name, .. } = impl_trait;\n         span_lint(\n             cx,\n             RECURSIVE_FORMAT_IMPL,\n-            expr.span,\n+            span,\n             &format!(\"using `self` as `{name}` in `impl {name}` will cause infinite recursion\"),\n         );\n     }\n }\n \n-fn check_print_in_format_impl(cx: &LateContext<'_>, expr: &Expr<'_>, impl_trait: FormatTrait) {\n+fn check_print_in_format_impl(cx: &LateContext<'_>, expr: &Expr<'_>, impl_trait: FormatTraitNames) {\n     if_chain! {\n         if let Some(macro_call) = root_macro_call_first_node(cx, expr);\n         if let Some(name) = cx.tcx.get_diagnostic_name(macro_call.def_id);\n@@ -227,7 +243,7 @@ fn check_print_in_format_impl(cx: &LateContext<'_>, expr: &Expr<'_>, impl_trait:\n     }\n }\n \n-fn is_format_trait_impl(cx: &LateContext<'_>, impl_item: &ImplItem<'_>) -> Option<FormatTrait> {\n+fn is_format_trait_impl(cx: &LateContext<'_>, impl_item: &ImplItem<'_>) -> Option<FormatTraitNames> {\n     if_chain! {\n         if impl_item.ident.name == sym::fmt;\n         if let ImplItemKind::Fn(_, body_id) = impl_item.kind;\n@@ -241,7 +257,7 @@ fn is_format_trait_impl(cx: &LateContext<'_>, impl_item: &ImplItem<'_>) -> Optio\n                 .and_then(|param| param.pat.simple_ident())\n                 .map(|ident| ident.name);\n \n-            Some(FormatTrait {\n+            Some(FormatTraitNames {\n                 name,\n                 formatter_name,\n             })"}, {"sha": "92d21bb893262af134609248e159380ca1d88efe", "filename": "clippy_lints/src/methods/expect_fun_call.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6589d794927451ed5d503b108e0e6900bbf91d3d/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6589d794927451ed5d503b108e0e6900bbf91d3d/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs?ref=6589d794927451ed5d503b108e0e6900bbf91d3d", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::macros::{root_macro_call_first_node, FormatArgsExpn};\n+use clippy_utils::macros::{find_format_args, format_args_inputs_span, root_macro_call_first_node};\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\n use rustc_errors::Applicability;\n@@ -136,18 +136,19 @@ pub(super) fn check<'tcx>(\n         if !cx.tcx.is_diagnostic_item(sym::format_macro, macro_call.def_id) {\n             return;\n         }\n-        let Some(format_args) = FormatArgsExpn::find_nested(cx, arg_root, macro_call.expn) else { return };\n-        let span = format_args.inputs_span();\n-        let sugg = snippet_with_applicability(cx, span, \"..\", &mut applicability);\n-        span_lint_and_sugg(\n-            cx,\n-            EXPECT_FUN_CALL,\n-            span_replace_word,\n-            &format!(\"use of `{name}` followed by a function call\"),\n-            \"try this\",\n-            format!(\"unwrap_or_else({closure_args} panic!({sugg}))\"),\n-            applicability,\n-        );\n+        find_format_args(cx, arg_root, macro_call.expn, |format_args| {\n+            let span = format_args_inputs_span(format_args);\n+            let sugg = snippet_with_applicability(cx, span, \"..\", &mut applicability);\n+            span_lint_and_sugg(\n+                cx,\n+                EXPECT_FUN_CALL,\n+                span_replace_word,\n+                &format!(\"use of `{name}` followed by a function call\"),\n+                \"try this\",\n+                format!(\"unwrap_or_else({closure_args} panic!({sugg}))\"),\n+                applicability,\n+            );\n+        });\n         return;\n     }\n "}, {"sha": "f4af00599cd26cea6f53b82ea4ec73426bdfc473", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6589d794927451ed5d503b108e0e6900bbf91d3d/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6589d794927451ed5d503b108e0e6900bbf91d3d/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=6589d794927451ed5d503b108e0e6900bbf91d3d", "patch": "@@ -33,7 +33,6 @@ extern crate rustc_lexer;\n extern crate rustc_lint;\n extern crate rustc_middle;\n extern crate rustc_mir_dataflow;\n-extern crate rustc_parse_format;\n extern crate rustc_session;\n extern crate rustc_span;\n extern crate rustc_target;"}, {"sha": "62d388a5ece8d00fbd5979162997fdd611610f85", "filename": "clippy_utils/src/macros.rs", "status": "modified", "additions": 22, "deletions": 705, "changes": 727, "blob_url": "https://github.com/rust-lang/rust/blob/6589d794927451ed5d503b108e0e6900bbf91d3d/clippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6589d794927451ed5d503b108e0e6900bbf91d3d/clippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmacros.rs?ref=6589d794927451ed5d503b108e0e6900bbf91d3d", "patch": "@@ -1,24 +1,16 @@\n #![allow(clippy::similar_names)] // `expr` and `expn`\n \n-use crate::source::snippet_opt;\n use crate::visitors::{for_each_expr, Descend};\n \n use arrayvec::ArrayVec;\n-use itertools::{izip, Either, Itertools};\n-use rustc_ast::ast::LitKind;\n use rustc_ast::{FormatArgs, FormatArgument, FormatPlaceholder};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_hir::{self as hir, Expr, ExprField, ExprKind, HirId, LangItem, Node, QPath, TyKind};\n-use rustc_lexer::unescape::unescape_literal;\n-use rustc_lexer::{tokenize, unescape, LiteralKind, TokenKind};\n+use rustc_hir::{self as hir, Expr, ExprKind, HirId, Node, QPath};\n use rustc_lint::LateContext;\n-use rustc_parse_format::{self as rpf, Alignment};\n use rustc_span::def_id::DefId;\n use rustc_span::hygiene::{self, MacroKind, SyntaxContext};\n-use rustc_span::{sym, BytePos, ExpnData, ExpnId, ExpnKind, Pos, Span, SpanData, Symbol};\n+use rustc_span::{sym, BytePos, ExpnData, ExpnId, ExpnKind, Span, Symbol};\n use std::cell::RefCell;\n-use std::iter::{once, zip};\n use std::ops::ControlFlow;\n use std::sync::atomic::{AtomicBool, Ordering};\n \n@@ -226,11 +218,11 @@ pub enum PanicExpn<'a> {\n     /// A single argument that implements `Display` - `panic!(\"{}\", object)`\n     Display(&'a Expr<'a>),\n     /// Anything else - `panic!(\"error {}: {}\", a, b)`\n-    Format(FormatArgsExpn<'a>),\n+    Format(&'a Expr<'a>),\n }\n \n impl<'a> PanicExpn<'a> {\n-    pub fn parse(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<Self> {\n+    pub fn parse(expr: &'a Expr<'a>) -> Option<Self> {\n         let ExprKind::Call(callee, [arg, rest @ ..]) = &expr.kind else { return None };\n         let ExprKind::Path(QPath::Resolved(_, path)) = &callee.kind else { return None };\n         let result = match path.segments.last().unwrap().ident.as_str() {\n@@ -240,7 +232,7 @@ impl<'a> PanicExpn<'a> {\n                 let ExprKind::AddrOf(_, _, e) = &arg.kind else { return None };\n                 Self::Display(e)\n             },\n-            \"panic_fmt\" => Self::Format(FormatArgsExpn::parse(cx, arg)?),\n+            \"panic_fmt\" => Self::Format(arg),\n             // Since Rust 1.52, `assert_{eq,ne}` macros expand to use:\n             // `core::panicking::assert_failed(.., left_val, right_val, None | Some(format_args!(..)));`\n             \"assert_failed\" => {\n@@ -252,7 +244,7 @@ impl<'a> PanicExpn<'a> {\n                 // `msg_arg` is either `None` (no custom message) or `Some(format_args!(..))` (custom message)\n                 let msg_arg = &rest[2];\n                 match msg_arg.kind {\n-                    ExprKind::Call(_, [fmt_arg]) => Self::Format(FormatArgsExpn::parse(cx, fmt_arg)?),\n+                    ExprKind::Call(_, [fmt_arg]) => Self::Format(fmt_arg),\n                     _ => Self::Empty,\n                 }\n             },\n@@ -304,7 +296,7 @@ fn find_assert_args_inner<'a, const N: usize>(\n     let mut args = ArrayVec::new();\n     let panic_expn = for_each_expr(expr, |e| {\n         if args.is_full() {\n-            match PanicExpn::parse(cx, e) {\n+            match PanicExpn::parse(e) {\n                 Some(expn) => ControlFlow::Break(expn),\n                 None => ControlFlow::Continue(Descend::Yes),\n             }\n@@ -452,6 +444,21 @@ pub fn format_placeholder_format_span(placeholder: &FormatPlaceholder) -> Option\n     ))\n }\n \n+/// Span covering the format string and values\n+///\n+/// ```ignore\n+/// format(\"{}.{}\", 10, 11)\n+/// //     ^^^^^^^^^^^^^^^\n+/// ```\n+pub fn format_args_inputs_span(format_args: &FormatArgs) -> Span {\n+    match format_args.arguments.explicit_args() {\n+        [] => format_args.span,\n+        [.., last] => format_args\n+            .span\n+            .to(hygiene::walk_chain(last.expr.span, format_args.span.ctxt())),\n+    }\n+}\n+\n /// Returns the [`Span`] of the value at `index` extended to the previous comma, e.g. for the value\n /// `10`\n ///\n@@ -473,251 +480,6 @@ pub fn format_arg_removal_span(format_args: &FormatArgs, index: usize) -> Option\n     Some(current.with_lo(prev.hi()))\n }\n \n-/// The format string doesn't exist in the HIR, so we reassemble it from source code\n-#[derive(Debug)]\n-pub struct FormatString {\n-    /// Span of the whole format string literal, including `[r#]\"`.\n-    pub span: Span,\n-    /// Snippet of the whole format string literal, including `[r#]\"`.\n-    pub snippet: String,\n-    /// If the string is raw `r\"...\"`/`r#\"\"#`, how many `#`s does it have on each side.\n-    pub style: Option<usize>,\n-    /// The unescaped value of the format string, e.g. `\"val \u2013 {}\"` for the literal\n-    /// `\"val \\u{2013} {}\"`.\n-    pub unescaped: String,\n-    /// The format string split by format args like `{..}`.\n-    pub parts: Vec<Symbol>,\n-}\n-\n-impl FormatString {\n-    fn new(cx: &LateContext<'_>, pieces: &Expr<'_>) -> Option<Self> {\n-        // format_args!(r\"a {} b \\\", 1);\n-        //\n-        // expands to\n-        //\n-        // ::core::fmt::Arguments::new_v1(&[\"a \", \" b \\\\\"],\n-        //      &[::core::fmt::ArgumentV1::new_display(&1)]);\n-        //\n-        // where `pieces` is the expression `&[\"a \", \" b \\\\\"]`. It has the span of `r\"a {} b \\\"`\n-        let span = pieces.span;\n-        let snippet = snippet_opt(cx, span)?;\n-\n-        let (inner, style) = match tokenize(&snippet).next()?.kind {\n-            TokenKind::Literal { kind, .. } => {\n-                let style = match kind {\n-                    LiteralKind::Str { .. } => None,\n-                    LiteralKind::RawStr { n_hashes: Some(n), .. } => Some(n.into()),\n-                    _ => return None,\n-                };\n-\n-                let start = style.map_or(1, |n| 2 + n);\n-                let end = snippet.len() - style.map_or(1, |n| 1 + n);\n-\n-                (&snippet[start..end], style)\n-            },\n-            _ => return None,\n-        };\n-\n-        let mode = if style.is_some() {\n-            unescape::Mode::RawStr\n-        } else {\n-            unescape::Mode::Str\n-        };\n-\n-        let mut unescaped = String::with_capacity(inner.len());\n-        // Sometimes the original string comes from a macro which accepts a malformed string, such as in a\n-        // #[display(\"\"somestring)] attribute (accepted by the `displaythis` crate). Reconstructing the\n-        // string from the span will not be possible, so we will just return None here.\n-        let mut unparsable = false;\n-        unescape_literal(inner, mode, &mut |_, ch| match ch {\n-            Ok(ch) => unescaped.push(ch),\n-            Err(e) if !e.is_fatal() => (),\n-            Err(_) => unparsable = true,\n-        });\n-        if unparsable {\n-            return None;\n-        }\n-\n-        let mut parts = Vec::new();\n-        let _: Option<!> = for_each_expr(pieces, |expr| {\n-            if let ExprKind::Lit(lit) = &expr.kind\n-                && let LitKind::Str(symbol, _) = lit.node\n-            {\n-                parts.push(symbol);\n-            }\n-            ControlFlow::Continue(())\n-        });\n-\n-        Some(Self {\n-            span,\n-            snippet,\n-            style,\n-            unescaped,\n-            parts,\n-        })\n-    }\n-}\n-\n-struct FormatArgsValues<'tcx> {\n-    /// Values passed after the format string and implicit captures. `[1, z + 2, x]` for\n-    /// `format!(\"{x} {} {}\", 1, z + 2)`.\n-    value_args: Vec<&'tcx Expr<'tcx>>,\n-    /// Maps an `rt::v1::Argument::position` or an `rt::v1::Count::Param` to its index in\n-    /// `value_args`\n-    pos_to_value_index: Vec<usize>,\n-    /// Used to check if a value is declared inline & to resolve `InnerSpan`s.\n-    format_string_span: SpanData,\n-}\n-\n-impl<'tcx> FormatArgsValues<'tcx> {\n-    fn new_empty(format_string_span: SpanData) -> Self {\n-        Self {\n-            value_args: Vec::new(),\n-            pos_to_value_index: Vec::new(),\n-            format_string_span,\n-        }\n-    }\n-\n-    fn new(args: &'tcx Expr<'tcx>, format_string_span: SpanData) -> Self {\n-        let mut pos_to_value_index = Vec::new();\n-        let mut value_args = Vec::new();\n-        let _: Option<!> = for_each_expr(args, |expr| {\n-            if expr.span.ctxt() == args.span.ctxt() {\n-                // ArgumentV1::new_<format_trait>(<val>)\n-                // ArgumentV1::from_usize(<val>)\n-                if let ExprKind::Call(callee, [val]) = expr.kind\n-                    && let ExprKind::Path(QPath::TypeRelative(ty, _)) = callee.kind\n-                    && let TyKind::Path(QPath::LangItem(LangItem::FormatArgument, _, _)) = ty.kind\n-                {\n-                    let val_idx = if val.span.ctxt() == expr.span.ctxt()\n-                        && let ExprKind::Field(_, field) = val.kind\n-                        && let Ok(idx) = field.name.as_str().parse()\n-                    {\n-                        // tuple index\n-                        idx\n-                    } else {\n-                        // assume the value expression is passed directly\n-                        pos_to_value_index.len()\n-                    };\n-\n-                    pos_to_value_index.push(val_idx);\n-                }\n-                ControlFlow::Continue(Descend::Yes)\n-            } else {\n-                // assume that any expr with a differing span is a value\n-                value_args.push(expr);\n-                ControlFlow::Continue(Descend::No)\n-            }\n-        });\n-\n-        Self {\n-            value_args,\n-            pos_to_value_index,\n-            format_string_span,\n-        }\n-    }\n-}\n-\n-/// The positions of a format argument's value, precision and width\n-///\n-/// A position is an index into the second argument of `Arguments::new_v1[_formatted]`\n-#[derive(Debug, Default, Copy, Clone)]\n-struct ParamPosition {\n-    /// The position stored in `rt::v1::Argument::position`.\n-    value: usize,\n-    /// The position stored in `rt::v1::FormatSpec::width` if it is a `Count::Param`.\n-    width: Option<usize>,\n-    /// The position stored in `rt::v1::FormatSpec::precision` if it is a `Count::Param`.\n-    precision: Option<usize>,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for ParamPosition {\n-    fn visit_expr_field(&mut self, field: &'tcx ExprField<'tcx>) {\n-        match field.ident.name {\n-            sym::position => {\n-                if let ExprKind::Lit(lit) = &field.expr.kind\n-                    && let LitKind::Int(pos, _) = lit.node\n-                {\n-                    self.value = pos as usize;\n-                }\n-            },\n-            sym::precision => {\n-                self.precision = parse_count(field.expr);\n-            },\n-            sym::width => {\n-                self.width = parse_count(field.expr);\n-            },\n-            _ => walk_expr(self, field.expr),\n-        }\n-    }\n-}\n-\n-fn parse_count(expr: &Expr<'_>) -> Option<usize> {\n-    // <::core::fmt::rt::v1::Count>::Param(1usize),\n-    if let ExprKind::Call(ctor, [val]) = expr.kind\n-        && let ExprKind::Path(QPath::TypeRelative(_, path)) = ctor.kind\n-            && path.ident.name == sym::Param\n-            && let ExprKind::Lit(lit) = &val.kind\n-            && let LitKind::Int(pos, _) = lit.node\n-    {\n-        Some(pos as usize)\n-    } else {\n-        None\n-    }\n-}\n-\n-/// Parses the `fmt` arg of `Arguments::new_v1_formatted(pieces, args, fmt, _)`\n-fn parse_rt_fmt<'tcx>(fmt_arg: &'tcx Expr<'tcx>) -> Option<impl Iterator<Item = ParamPosition> + 'tcx> {\n-    if let ExprKind::AddrOf(.., array) = fmt_arg.kind\n-        && let ExprKind::Array(specs) = array.kind\n-    {\n-        Some(specs.iter().map(|spec| {\n-            if let ExprKind::Call(f, args) = spec.kind\n-                && let ExprKind::Path(QPath::TypeRelative(ty, f)) = f.kind\n-                && let TyKind::Path(QPath::LangItem(LangItem::FormatPlaceholder, _, _)) = ty.kind\n-                && f.ident.name == sym::new\n-                && let [position, _fill, _align, _flags, precision, width] = args\n-                && let ExprKind::Lit(position) = &position.kind\n-                && let LitKind::Int(position, _) = position.node {\n-                    ParamPosition {\n-                        value: position as usize,\n-                        width: parse_count(width),\n-                        precision: parse_count(precision),\n-                    }\n-            } else {\n-                ParamPosition::default()\n-            }\n-        }))\n-    } else {\n-        None\n-    }\n-}\n-\n-/// `Span::from_inner`, but for `rustc_parse_format`'s `InnerSpan`\n-fn span_from_inner(base: SpanData, inner: rpf::InnerSpan) -> Span {\n-    Span::new(\n-        base.lo + BytePos::from_usize(inner.start),\n-        base.lo + BytePos::from_usize(inner.end),\n-        base.ctxt,\n-        base.parent,\n-    )\n-}\n-\n-/// How a format parameter is used in the format string\n-#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-pub enum FormatParamKind {\n-    /// An implicit parameter , such as `{}` or `{:?}`.\n-    Implicit,\n-    /// A parameter with an explicit number, e.g. `{1}`, `{0:?}`, or `{:.0$}`\n-    Numbered,\n-    /// A parameter with an asterisk precision. e.g. `{:.*}`.\n-    Starred,\n-    /// A named parameter with a named `value_arg`, such as the `x` in `format!(\"{x}\", x = 1)`.\n-    Named(Symbol),\n-    /// An implicit named parameter, such as the `y` in `format!(\"{y}\")`.\n-    NamedInline(Symbol),\n-}\n-\n /// Where a format parameter is being used in the format string\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub enum FormatParamUsage {\n@@ -729,451 +491,6 @@ pub enum FormatParamUsage {\n     Precision,\n }\n \n-/// A `FormatParam` is any place in a `FormatArgument` that refers to a supplied value, e.g.\n-///\n-/// ```\n-/// let precision = 2;\n-/// format!(\"{:.precision$}\", 0.1234);\n-/// ```\n-///\n-/// has two `FormatParam`s, a [`FormatParamKind::Implicit`] `.kind` with a `.value` of `0.1234`\n-/// and a [`FormatParamKind::NamedInline(\"precision\")`] `.kind` with a `.value` of `2`\n-#[derive(Debug, Copy, Clone)]\n-pub struct FormatParam<'tcx> {\n-    /// The expression this parameter refers to.\n-    pub value: &'tcx Expr<'tcx>,\n-    /// How this parameter refers to its `value`.\n-    pub kind: FormatParamKind,\n-    /// Where this format param is being used - argument/width/precision\n-    pub usage: FormatParamUsage,\n-    /// Span of the parameter, may be zero width. Includes the whitespace of implicit parameters.\n-    ///\n-    /// ```text\n-    /// format!(\"{}, {  }, {0}, {name}\", ...);\n-    ///          ^    ~~    ~    ~~~~\n-    /// ```\n-    pub span: Span,\n-}\n-\n-impl<'tcx> FormatParam<'tcx> {\n-    fn new(\n-        mut kind: FormatParamKind,\n-        usage: FormatParamUsage,\n-        position: usize,\n-        inner: rpf::InnerSpan,\n-        values: &FormatArgsValues<'tcx>,\n-    ) -> Option<Self> {\n-        let value_index = *values.pos_to_value_index.get(position)?;\n-        let value = *values.value_args.get(value_index)?;\n-        let span = span_from_inner(values.format_string_span, inner);\n-\n-        // if a param is declared inline, e.g. `format!(\"{x}\")`, the generated expr's span points\n-        // into the format string\n-        if let FormatParamKind::Named(name) = kind && values.format_string_span.contains(value.span.data()) {\n-            kind = FormatParamKind::NamedInline(name);\n-        }\n-\n-        Some(Self {\n-            value,\n-            kind,\n-            usage,\n-            span,\n-        })\n-    }\n-}\n-\n-/// Used by [width](https://doc.rust-lang.org/std/fmt/#width) and\n-/// [precision](https://doc.rust-lang.org/std/fmt/#precision) specifiers.\n-#[derive(Debug, Copy, Clone)]\n-pub enum Count<'tcx> {\n-    /// Specified with a literal number, stores the value.\n-    Is(usize, Span),\n-    /// Specified using `$` and `*` syntaxes. The `*` format is still considered to be\n-    /// `FormatParamKind::Numbered`.\n-    Param(FormatParam<'tcx>),\n-    /// Not specified.\n-    Implied(Option<Span>),\n-}\n-\n-impl<'tcx> Count<'tcx> {\n-    fn new(\n-        usage: FormatParamUsage,\n-        count: rpf::Count<'_>,\n-        position: Option<usize>,\n-        inner: Option<rpf::InnerSpan>,\n-        values: &FormatArgsValues<'tcx>,\n-    ) -> Option<Self> {\n-        let span = inner.map(|inner| span_from_inner(values.format_string_span, inner));\n-\n-        Some(match count {\n-            rpf::Count::CountIs(val) => Self::Is(val, span?),\n-            rpf::Count::CountIsName(name, _) => Self::Param(FormatParam::new(\n-                FormatParamKind::Named(Symbol::intern(name)),\n-                usage,\n-                position?,\n-                inner?,\n-                values,\n-            )?),\n-            rpf::Count::CountIsParam(_) => Self::Param(FormatParam::new(\n-                FormatParamKind::Numbered,\n-                usage,\n-                position?,\n-                inner?,\n-                values,\n-            )?),\n-            rpf::Count::CountIsStar(_) => Self::Param(FormatParam::new(\n-                FormatParamKind::Starred,\n-                usage,\n-                position?,\n-                inner?,\n-                values,\n-            )?),\n-            rpf::Count::CountImplied => Self::Implied(span),\n-        })\n-    }\n-\n-    pub fn is_implied(self) -> bool {\n-        matches!(self, Count::Implied(_))\n-    }\n-\n-    pub fn param(self) -> Option<FormatParam<'tcx>> {\n-        match self {\n-            Count::Param(param) => Some(param),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn span(self) -> Option<Span> {\n-        match self {\n-            Count::Is(_, span) => Some(span),\n-            Count::Param(param) => Some(param.span),\n-            Count::Implied(span) => span,\n-        }\n-    }\n-}\n-\n-/// Specification for the formatting of an argument in the format string. See\n-/// <https://doc.rust-lang.org/std/fmt/index.html#formatting-parameters> for the precise meanings.\n-#[derive(Debug)]\n-pub struct FormatSpec<'tcx> {\n-    /// Optionally specified character to fill alignment with.\n-    pub fill: Option<char>,\n-    /// Optionally specified alignment.\n-    pub align: Alignment,\n-    /// Whether all flag options are set to default (no flags specified).\n-    pub no_flags: bool,\n-    /// Represents either the maximum width or the integer precision.\n-    pub precision: Count<'tcx>,\n-    /// The minimum width, will be padded according to `width`/`align`\n-    pub width: Count<'tcx>,\n-    /// The formatting trait used by the argument, e.g. `sym::Display` for `{}`, `sym::Debug` for\n-    /// `{:?}`.\n-    pub r#trait: Symbol,\n-    pub trait_span: Option<Span>,\n-}\n-\n-impl<'tcx> FormatSpec<'tcx> {\n-    fn new(spec: rpf::FormatSpec<'_>, positions: ParamPosition, values: &FormatArgsValues<'tcx>) -> Option<Self> {\n-        Some(Self {\n-            fill: spec.fill,\n-            align: spec.align,\n-            no_flags: spec.sign.is_none() && !spec.alternate && !spec.zero_pad && spec.debug_hex.is_none(),\n-            precision: Count::new(\n-                FormatParamUsage::Precision,\n-                spec.precision,\n-                positions.precision,\n-                spec.precision_span,\n-                values,\n-            )?,\n-            width: Count::new(\n-                FormatParamUsage::Width,\n-                spec.width,\n-                positions.width,\n-                spec.width_span,\n-                values,\n-            )?,\n-            r#trait: match spec.ty {\n-                \"\" => sym::Display,\n-                \"?\" => sym::Debug,\n-                \"o\" => sym!(Octal),\n-                \"x\" => sym!(LowerHex),\n-                \"X\" => sym!(UpperHex),\n-                \"p\" => sym::Pointer,\n-                \"b\" => sym!(Binary),\n-                \"e\" => sym!(LowerExp),\n-                \"E\" => sym!(UpperExp),\n-                _ => return None,\n-            },\n-            trait_span: spec\n-                .ty_span\n-                .map(|span| span_from_inner(values.format_string_span, span)),\n-        })\n-    }\n-\n-    /// Returns true if this format spec is unchanged from the default. e.g. returns true for `{}`,\n-    /// `{foo}` and `{2}`, but false for `{:?}`, `{foo:5}` and `{3:.5}`\n-    pub fn is_default(&self) -> bool {\n-        self.r#trait == sym::Display && self.is_default_for_trait()\n-    }\n-\n-    /// Has no other formatting specifiers than setting the format trait. returns true for `{}`,\n-    /// `{foo}`, `{:?}`, but false for `{foo:5}`, `{3:.5?}`\n-    pub fn is_default_for_trait(&self) -> bool {\n-        self.width.is_implied() && self.precision.is_implied() && self.align == Alignment::AlignUnknown && self.no_flags\n-    }\n-}\n-\n-/// A format argument, such as `{}`, `{foo:?}`.\n-#[derive(Debug)]\n-pub struct FormatArg<'tcx> {\n-    /// The parameter the argument refers to.\n-    pub param: FormatParam<'tcx>,\n-    /// How to format `param`.\n-    pub format: FormatSpec<'tcx>,\n-    /// span of the whole argument, `{..}`.\n-    pub span: Span,\n-}\n-\n-/// A parsed `format_args!` expansion.\n-#[derive(Debug)]\n-pub struct FormatArgsExpn<'tcx> {\n-    /// The format string literal.\n-    pub format_string: FormatString,\n-    /// The format arguments, such as `{:?}`.\n-    pub args: Vec<FormatArg<'tcx>>,\n-    /// Has an added newline due to `println!()`/`writeln!()`/etc. The last format string part will\n-    /// include this added newline.\n-    pub newline: bool,\n-    /// Spans of the commas between the format string and explicit values, excluding any trailing\n-    /// comma\n-    ///\n-    /// ```ignore\n-    /// format!(\"..\", 1, 2, 3,)\n-    /// //          ^  ^  ^\n-    /// ```\n-    comma_spans: Vec<Span>,\n-    /// Explicit values passed after the format string, ignoring implicit captures. `[1, z + 2]` for\n-    /// `format!(\"{x} {} {y}\", 1, z + 2)`.\n-    explicit_values: Vec<&'tcx Expr<'tcx>>,\n-}\n-\n-impl<'tcx> FormatArgsExpn<'tcx> {\n-    /// Gets the spans of the commas inbetween the format string and explicit args, not including\n-    /// any trailing comma\n-    ///\n-    /// ```ignore\n-    /// format!(\"{} {}\", a, b)\n-    /// //             ^  ^\n-    /// ```\n-    ///\n-    /// Ensures that the format string and values aren't coming from a proc macro that sets the\n-    /// output span to that of its input\n-    fn comma_spans(cx: &LateContext<'_>, explicit_values: &[&Expr<'_>], fmt_span: Span) -> Option<Vec<Span>> {\n-        // `format!(\"{} {} {c}\", \"one\", \"two\", c = \"three\")`\n-        //                       ^^^^^  ^^^^^      ^^^^^^^\n-        let value_spans = explicit_values\n-            .iter()\n-            .map(|val| hygiene::walk_chain(val.span, fmt_span.ctxt()));\n-\n-        // `format!(\"{} {} {c}\", \"one\", \"two\", c = \"three\")`\n-        //                     ^^     ^^     ^^^^^^\n-        let between_spans = once(fmt_span)\n-            .chain(value_spans)\n-            .tuple_windows()\n-            .map(|(start, end)| start.between(end));\n-\n-        let mut comma_spans = Vec::new();\n-        for between_span in between_spans {\n-            let mut offset = 0;\n-            let mut seen_comma = false;\n-\n-            for token in tokenize(&snippet_opt(cx, between_span)?) {\n-                match token.kind {\n-                    TokenKind::LineComment { .. } | TokenKind::BlockComment { .. } | TokenKind::Whitespace => {},\n-                    TokenKind::Comma if !seen_comma => {\n-                        seen_comma = true;\n-\n-                        let base = between_span.data();\n-                        comma_spans.push(Span::new(\n-                            base.lo + BytePos(offset),\n-                            base.lo + BytePos(offset + 1),\n-                            base.ctxt,\n-                            base.parent,\n-                        ));\n-                    },\n-                    // named arguments, `start_val, name = end_val`\n-                    //                            ^^^^^^^^^ between_span\n-                    TokenKind::Ident | TokenKind::Eq if seen_comma => {},\n-                    // An unexpected token usually indicates the format string or a value came from a proc macro output\n-                    // that sets the span of its output to an input, e.g. `println!(some_proc_macro!(\"input\"), ..)` that\n-                    // emits a string literal with the span set to that of `\"input\"`\n-                    _ => return None,\n-                }\n-                offset += token.len;\n-            }\n-\n-            if !seen_comma {\n-                return None;\n-            }\n-        }\n-\n-        Some(comma_spans)\n-    }\n-\n-    pub fn parse(cx: &LateContext<'_>, expr: &'tcx Expr<'tcx>) -> Option<Self> {\n-        let macro_name = macro_backtrace(expr.span)\n-            .map(|macro_call| cx.tcx.item_name(macro_call.def_id))\n-            .find(|&name| matches!(name, sym::const_format_args | sym::format_args | sym::format_args_nl))?;\n-        let newline = macro_name == sym::format_args_nl;\n-\n-        // ::core::fmt::Arguments::new_const(pieces)\n-        // ::core::fmt::Arguments::new_v1(pieces, args)\n-        // ::core::fmt::Arguments::new_v1_formatted(pieces, args, fmt, _unsafe_arg)\n-        if let ExprKind::Call(callee, [pieces, rest @ ..]) = expr.kind\n-            && let ExprKind::Path(QPath::TypeRelative(ty, seg)) = callee.kind\n-            && let TyKind::Path(QPath::LangItem(LangItem::FormatArguments, _, _)) = ty.kind\n-            && matches!(seg.ident.as_str(), \"new_const\" | \"new_v1\" | \"new_v1_formatted\")\n-        {\n-            let format_string = FormatString::new(cx, pieces)?;\n-\n-            let mut parser = rpf::Parser::new(\n-                &format_string.unescaped,\n-                format_string.style,\n-                Some(format_string.snippet.clone()),\n-                // `format_string.unescaped` does not contain the appended newline\n-                false,\n-                rpf::ParseMode::Format,\n-            );\n-\n-            let parsed_args = parser\n-                .by_ref()\n-                .filter_map(|piece| match piece {\n-                    rpf::Piece::NextArgument(a) => Some(a),\n-                    rpf::Piece::String(_) => None,\n-                })\n-                .collect_vec();\n-            if !parser.errors.is_empty() {\n-                return None;\n-            }\n-\n-            let positions = if let Some(fmt_arg) = rest.get(1) {\n-                // If the argument contains format specs, `new_v1_formatted(_, _, fmt, _)`, parse\n-                // them.\n-\n-                Either::Left(parse_rt_fmt(fmt_arg)?)\n-            } else {\n-                // If no format specs are given, the positions are in the given order and there are\n-                // no `precision`/`width`s to consider.\n-\n-                Either::Right((0..).map(|n| ParamPosition {\n-                    value: n,\n-                    width: None,\n-                    precision: None,\n-                }))\n-            };\n-\n-            let values = if let Some(args) = rest.first() {\n-                FormatArgsValues::new(args, format_string.span.data())\n-            } else {\n-                FormatArgsValues::new_empty(format_string.span.data())\n-            };\n-\n-            let args = izip!(positions, parsed_args, parser.arg_places)\n-                .map(|(position, parsed_arg, arg_span)| {\n-                    Some(FormatArg {\n-                        param: FormatParam::new(\n-                            match parsed_arg.position {\n-                                rpf::Position::ArgumentImplicitlyIs(_) => FormatParamKind::Implicit,\n-                                rpf::Position::ArgumentIs(_) => FormatParamKind::Numbered,\n-                                // NamedInline is handled by `FormatParam::new()`\n-                                rpf::Position::ArgumentNamed(name) => FormatParamKind::Named(Symbol::intern(name)),\n-                            },\n-                            FormatParamUsage::Argument,\n-                            position.value,\n-                            parsed_arg.position_span,\n-                            &values,\n-                        )?,\n-                        format: FormatSpec::new(parsed_arg.format, position, &values)?,\n-                        span: span_from_inner(values.format_string_span, arg_span),\n-                    })\n-                })\n-                .collect::<Option<Vec<_>>>()?;\n-\n-            let mut explicit_values = values.value_args;\n-            // remove values generated for implicitly captured vars\n-            let len = explicit_values\n-                .iter()\n-                .take_while(|val| !format_string.span.contains(val.span))\n-                .count();\n-            explicit_values.truncate(len);\n-\n-            let comma_spans = Self::comma_spans(cx, &explicit_values, format_string.span)?;\n-\n-            Some(Self {\n-                format_string,\n-                args,\n-                newline,\n-                comma_spans,\n-                explicit_values,\n-            })\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn find_nested(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, expn_id: ExpnId) -> Option<Self> {\n-        for_each_expr(expr, |e| {\n-            let e_ctxt = e.span.ctxt();\n-            if e_ctxt == expr.span.ctxt() {\n-                ControlFlow::Continue(Descend::Yes)\n-            } else if e_ctxt.outer_expn().is_descendant_of(expn_id) {\n-                if let Some(args) = FormatArgsExpn::parse(cx, e) {\n-                    ControlFlow::Break(args)\n-                } else {\n-                    ControlFlow::Continue(Descend::No)\n-                }\n-            } else {\n-                ControlFlow::Continue(Descend::No)\n-            }\n-        })\n-    }\n-\n-    /// Source callsite span of all inputs\n-    pub fn inputs_span(&self) -> Span {\n-        match *self.explicit_values {\n-            [] => self.format_string.span,\n-            [.., last] => self\n-                .format_string\n-                .span\n-                .to(hygiene::walk_chain(last.span, self.format_string.span.ctxt())),\n-        }\n-    }\n-\n-    /// Get the span of a value expanded to the previous comma, e.g. for the value `10`\n-    ///\n-    /// ```ignore\n-    /// format(\"{}.{}\", 10, 11)\n-    /// //            ^^^^\n-    /// ```\n-    pub fn value_with_prev_comma_span(&self, value_id: HirId) -> Option<Span> {\n-        for (comma_span, value) in zip(&self.comma_spans, &self.explicit_values) {\n-            if value.hir_id == value_id {\n-                return Some(comma_span.to(hygiene::walk_chain(value.span, comma_span.ctxt())));\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    /// Iterator of all format params, both values and those referenced by `width`/`precision`s.\n-    pub fn params(&'tcx self) -> impl Iterator<Item = FormatParam<'tcx>> {\n-        self.args\n-            .iter()\n-            .flat_map(|arg| [Some(arg.param), arg.format.precision.param(), arg.format.width.param()])\n-            .flatten()\n-    }\n-}\n-\n /// A node with a `HirId` and a `Span`\n pub trait HirNode {\n     fn hir_id(&self) -> HirId;"}]}