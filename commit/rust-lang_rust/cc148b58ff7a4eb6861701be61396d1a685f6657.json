{"sha": "cc148b58ff7a4eb6861701be61396d1a685f6657", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjMTQ4YjU4ZmY3YTRlYjY4NjE3MDFiZTYxMzk2ZDFhNjg1ZjY2NTc=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-04-03T13:28:36Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-04-03T14:30:36Z"}, "message": "rename Linear{Map,Set} => Hash{Map,Set}", "tree": {"sha": "69bb3a4fc9ad6bb1a28e592a492c2720353968f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69bb3a4fc9ad6bb1a28e592a492c2720353968f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc148b58ff7a4eb6861701be61396d1a685f6657", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc148b58ff7a4eb6861701be61396d1a685f6657", "html_url": "https://github.com/rust-lang/rust/commit/cc148b58ff7a4eb6861701be61396d1a685f6657", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc148b58ff7a4eb6861701be61396d1a685f6657/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf", "html_url": "https://github.com/rust-lang/rust/commit/44029a5bbc4812f7144ee8d0d4ee95d52aeca6cf"}], "stats": {"total": 1046, "additions": 523, "deletions": 523}, "files": [{"sha": "66280b1b9723e2660f8704af6ba36914dd0023aa", "filename": "doc/rust.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -441,10 +441,10 @@ expression context, the final namespace qualifier is omitted.\n Two examples of paths with type arguments:\n \n ~~~~\n-# use core::hashmap::LinearMap;\n+# use core::hashmap::HashMap;\n # fn f() {\n # fn id<T:Copy>(t: T) -> T { t }\n-type t = LinearMap<int,~str>;  // Type arguments used in a type expression\n+type t = HashMap<int,~str>;  // Type arguments used in a type expression\n let x = id::<int>(10);         // Type arguments used in a call expression\n # }\n ~~~~"}, {"sha": "42c3a7a8d664f0d3306783f1f728222561624a88", "filename": "doc/tutorial.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -1888,8 +1888,8 @@ illegal to copy and pass by value.\n Generic `type`, `struct`, and `enum` declarations follow the same pattern:\n \n ~~~~\n-# use core::hashmap::LinearMap;\n-type Set<T> = LinearMap<T, ()>;\n+# use core::hashmap::HashMap;\n+type Set<T> = HashMap<T, ()>;\n \n struct Stack<T> {\n     elements: ~[T]"}, {"sha": "9fd9ac3a8c8ec0338eb5e8fadbfcf1ed334db9dd", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -43,7 +43,7 @@ use io;\n use libc::{size_t, uintptr_t};\n use option::{None, Option, Some};\n use ptr;\n-use hashmap::LinearSet;\n+use hashmap::HashSet;\n use stackwalk;\n use sys;\n \n@@ -344,7 +344,7 @@ pub fn cleanup_stack_for_failure() {\n             ptr::null()\n         };\n \n-        let mut roots = LinearSet::new();\n+        let mut roots = HashSet::new();\n         for walk_gc_roots(need_cleanup, sentinel) |root, tydesc| {\n             // Track roots to avoid double frees.\n             if roots.contains(&*root) {"}, {"sha": "5dbf085f097192b71aa4ee79c4efbbbd911b54df", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -35,7 +35,7 @@ struct Bucket<K,V> {\n     value: V,\n }\n \n-pub struct LinearMap<K,V> {\n+pub struct HashMap<K,V> {\n     priv k0: u64,\n     priv k1: u64,\n     priv resize_at: uint,\n@@ -55,24 +55,24 @@ fn resize_at(capacity: uint) -> uint {\n }\n \n pub fn linear_map_with_capacity<K:Eq + Hash,V>(\n-    initial_capacity: uint) -> LinearMap<K, V> {\n+    initial_capacity: uint) -> HashMap<K, V> {\n     let r = rand::task_rng();\n     linear_map_with_capacity_and_keys(r.gen_u64(), r.gen_u64(),\n                                       initial_capacity)\n }\n \n fn linear_map_with_capacity_and_keys<K:Eq + Hash,V>(\n     k0: u64, k1: u64,\n-    initial_capacity: uint) -> LinearMap<K, V> {\n-    LinearMap {\n+    initial_capacity: uint) -> HashMap<K, V> {\n+    HashMap {\n         k0: k0, k1: k1,\n         resize_at: resize_at(initial_capacity),\n         size: 0,\n         buckets: vec::from_fn(initial_capacity, |_| None)\n     }\n }\n \n-priv impl<K:Hash + IterBytes + Eq,V> LinearMap<K, V> {\n+priv impl<K:Hash + IterBytes + Eq,V> HashMap<K, V> {\n     #[inline(always)]\n     fn to_bucket(&self, h: uint) -> uint {\n         // A good hash function with entropy spread over all of the\n@@ -190,7 +190,7 @@ priv impl<K:Hash + IterBytes + Eq,V> LinearMap<K, V> {\n     fn value_for_bucket(&self, idx: uint) -> &'self V {\n         match self.buckets[idx] {\n             Some(ref bkt) => &bkt.value,\n-            None => fail!(~\"LinearMap::find: internal logic error\"),\n+            None => fail!(~\"HashMap::find: internal logic error\"),\n         }\n     }\n \n@@ -280,7 +280,7 @@ priv impl<K:Hash + IterBytes + Eq,V> LinearMap<K, V> {\n }\n \n impl<'self,K:Hash + IterBytes + Eq,V>\n-        BaseIter<(&'self K, &'self V)> for LinearMap<K, V> {\n+        BaseIter<(&'self K, &'self V)> for HashMap<K, V> {\n     /// Visit all key-value pairs\n     fn each(&self, blk: &fn(&(&'self K, &'self V)) -> bool) {\n         for uint::range(0, self.buckets.len()) |i| {\n@@ -297,15 +297,15 @@ impl<'self,K:Hash + IterBytes + Eq,V>\n }\n \n \n-impl<K:Hash + IterBytes + Eq,V> Container for LinearMap<K, V> {\n+impl<K:Hash + IterBytes + Eq,V> Container for HashMap<K, V> {\n     /// Return the number of elements in the map\n     fn len(&const self) -> uint { self.size }\n \n     /// Return true if the map contains no elements\n     fn is_empty(&const self) -> bool { self.len() == 0 }\n }\n \n-impl<K:Hash + IterBytes + Eq,V> Mutable for LinearMap<K, V> {\n+impl<K:Hash + IterBytes + Eq,V> Mutable for HashMap<K, V> {\n     /// Clear the map, removing all key-value pairs.\n     fn clear(&mut self) {\n         for uint::range(0, self.buckets.len()) |idx| {\n@@ -315,7 +315,7 @@ impl<K:Hash + IterBytes + Eq,V> Mutable for LinearMap<K, V> {\n     }\n }\n \n-impl<'self,K:Hash + IterBytes + Eq,V> Map<K, V> for LinearMap<K, V> {\n+impl<'self,K:Hash + IterBytes + Eq,V> Map<K, V> for HashMap<K, V> {\n     /// Return true if the map contains a value for the specified key\n     fn contains_key(&self, k: &K) -> bool {\n         match self.bucket_for_key(k) {\n@@ -391,15 +391,15 @@ impl<'self,K:Hash + IterBytes + Eq,V> Map<K, V> for LinearMap<K, V> {\n     }\n }\n \n-pub impl<K: Hash + IterBytes + Eq, V> LinearMap<K, V> {\n-    /// Create an empty LinearMap\n-    fn new() -> LinearMap<K, V> {\n-        LinearMap::with_capacity(INITIAL_CAPACITY)\n+pub impl<K: Hash + IterBytes + Eq, V> HashMap<K, V> {\n+    /// Create an empty HashMap\n+    fn new() -> HashMap<K, V> {\n+        HashMap::with_capacity(INITIAL_CAPACITY)\n     }\n \n-    /// Create an empty LinearMap with space for at least `n` elements in\n+    /// Create an empty HashMap with space for at least `n` elements in\n     /// the hash table.\n-    fn with_capacity(capacity: uint) -> LinearMap<K, V> {\n+    fn with_capacity(capacity: uint) -> HashMap<K, V> {\n         linear_map_with_capacity(capacity)\n     }\n \n@@ -541,8 +541,8 @@ pub impl<K: Hash + IterBytes + Eq, V> LinearMap<K, V> {\n     }\n }\n \n-impl<K:Hash + IterBytes + Eq,V:Eq> Eq for LinearMap<K, V> {\n-    fn eq(&self, other: &LinearMap<K, V>) -> bool {\n+impl<K:Hash + IterBytes + Eq,V:Eq> Eq for HashMap<K, V> {\n+    fn eq(&self, other: &HashMap<K, V>) -> bool {\n         if self.len() != other.len() { return false; }\n \n         for self.each |&(key, value)| {\n@@ -555,38 +555,38 @@ impl<K:Hash + IterBytes + Eq,V:Eq> Eq for LinearMap<K, V> {\n         true\n     }\n \n-    fn ne(&self, other: &LinearMap<K, V>) -> bool { !self.eq(other) }\n+    fn ne(&self, other: &HashMap<K, V>) -> bool { !self.eq(other) }\n }\n \n-pub struct LinearSet<T> {\n-    priv map: LinearMap<T, ()>\n+pub struct HashSet<T> {\n+    priv map: HashMap<T, ()>\n }\n \n-impl<T:Hash + IterBytes + Eq> BaseIter<T> for LinearSet<T> {\n+impl<T:Hash + IterBytes + Eq> BaseIter<T> for HashSet<T> {\n     /// Visit all values in order\n     fn each(&self, f: &fn(&T) -> bool) { self.map.each_key(f) }\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n-impl<T:Hash + IterBytes + Eq> Eq for LinearSet<T> {\n-    fn eq(&self, other: &LinearSet<T>) -> bool { self.map == other.map }\n-    fn ne(&self, other: &LinearSet<T>) -> bool { self.map != other.map }\n+impl<T:Hash + IterBytes + Eq> Eq for HashSet<T> {\n+    fn eq(&self, other: &HashSet<T>) -> bool { self.map == other.map }\n+    fn ne(&self, other: &HashSet<T>) -> bool { self.map != other.map }\n }\n \n-impl<T:Hash + IterBytes + Eq> Container for LinearSet<T> {\n+impl<T:Hash + IterBytes + Eq> Container for HashSet<T> {\n     /// Return the number of elements in the set\n     fn len(&const self) -> uint { self.map.len() }\n \n     /// Return true if the set contains no elements\n     fn is_empty(&const self) -> bool { self.map.is_empty() }\n }\n \n-impl<T:Hash + IterBytes + Eq> Mutable for LinearSet<T> {\n+impl<T:Hash + IterBytes + Eq> Mutable for HashSet<T> {\n     /// Clear the set, removing all values.\n     fn clear(&mut self) { self.map.clear() }\n }\n \n-impl<T:Hash + IterBytes + Eq> Set<T> for LinearSet<T> {\n+impl<T:Hash + IterBytes + Eq> Set<T> for HashSet<T> {\n     /// Return true if the set contains a value\n     fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n \n@@ -600,22 +600,22 @@ impl<T:Hash + IterBytes + Eq> Set<T> for LinearSet<T> {\n \n     /// Return true if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n-    fn is_disjoint(&self, other: &LinearSet<T>) -> bool {\n+    fn is_disjoint(&self, other: &HashSet<T>) -> bool {\n         iter::all(self, |v| !other.contains(v))\n     }\n \n     /// Return true if the set is a subset of another\n-    fn is_subset(&self, other: &LinearSet<T>) -> bool {\n+    fn is_subset(&self, other: &HashSet<T>) -> bool {\n         iter::all(self, |v| other.contains(v))\n     }\n \n     /// Return true if the set is a superset of another\n-    fn is_superset(&self, other: &LinearSet<T>) -> bool {\n+    fn is_superset(&self, other: &HashSet<T>) -> bool {\n         other.is_subset(self)\n     }\n \n     /// Visit the values representing the difference\n-    fn difference(&self, other: &LinearSet<T>, f: &fn(&T) -> bool) {\n+    fn difference(&self, other: &HashSet<T>, f: &fn(&T) -> bool) {\n         for self.each |v| {\n             if !other.contains(v) {\n                 if !f(v) { return }\n@@ -625,14 +625,14 @@ impl<T:Hash + IterBytes + Eq> Set<T> for LinearSet<T> {\n \n     /// Visit the values representing the symmetric difference\n     fn symmetric_difference(&self,\n-                            other: &LinearSet<T>,\n+                            other: &HashSet<T>,\n                             f: &fn(&T) -> bool) {\n         self.difference(other, f);\n         other.difference(self, f);\n     }\n \n     /// Visit the values representing the intersection\n-    fn intersection(&self, other: &LinearSet<T>, f: &fn(&T) -> bool) {\n+    fn intersection(&self, other: &HashSet<T>, f: &fn(&T) -> bool) {\n         for self.each |v| {\n             if other.contains(v) {\n                 if !f(v) { return }\n@@ -641,7 +641,7 @@ impl<T:Hash + IterBytes + Eq> Set<T> for LinearSet<T> {\n     }\n \n     /// Visit the values representing the union\n-    fn union(&self, other: &LinearSet<T>, f: &fn(&T) -> bool) {\n+    fn union(&self, other: &HashSet<T>, f: &fn(&T) -> bool) {\n         for self.each |v| {\n             if !f(v) { return }\n         }\n@@ -654,16 +654,16 @@ impl<T:Hash + IterBytes + Eq> Set<T> for LinearSet<T> {\n     }\n }\n \n-pub impl <T:Hash + IterBytes + Eq> LinearSet<T> {\n-    /// Create an empty LinearSet\n-    fn new() -> LinearSet<T> {\n-        LinearSet::with_capacity(INITIAL_CAPACITY)\n+pub impl <T:Hash + IterBytes + Eq> HashSet<T> {\n+    /// Create an empty HashSet\n+    fn new() -> HashSet<T> {\n+        HashSet::with_capacity(INITIAL_CAPACITY)\n     }\n \n-    /// Create an empty LinearSet with space for at least `n` elements in\n+    /// Create an empty HashSet with space for at least `n` elements in\n     /// the hash table.\n-    fn with_capacity(capacity: uint) -> LinearSet<T> {\n-        LinearSet { map: LinearMap::with_capacity(capacity) }\n+    fn with_capacity(capacity: uint) -> HashSet<T> {\n+        HashSet { map: HashMap::with_capacity(capacity) }\n     }\n \n     /// Reserve space for at least `n` elements in the hash table.\n@@ -686,7 +686,7 @@ mod test_map {\n \n     #[test]\n     pub fn test_insert() {\n-        let mut m = LinearMap::new();\n+        let mut m = HashMap::new();\n         assert!(m.insert(1, 2));\n         assert!(m.insert(2, 4));\n         assert!(*m.get(&1) == 2);\n@@ -695,7 +695,7 @@ mod test_map {\n \n     #[test]\n     fn test_find_mut() {\n-        let mut m = LinearMap::new();\n+        let mut m = HashMap::new();\n         assert!(m.insert(1, 12));\n         assert!(m.insert(2, 8));\n         assert!(m.insert(5, 14));\n@@ -708,7 +708,7 @@ mod test_map {\n \n     #[test]\n     pub fn test_insert_overwrite() {\n-        let mut m = LinearMap::new();\n+        let mut m = HashMap::new();\n         assert!(m.insert(1, 2));\n         assert!(*m.get(&1) == 2);\n         assert!(!m.insert(1, 3));\n@@ -748,40 +748,40 @@ mod test_map {\n \n     #[test]\n     pub fn test_pop() {\n-        let mut m = LinearMap::new();\n+        let mut m = HashMap::new();\n         m.insert(1, 2);\n         assert!(m.pop(&1) == Some(2));\n         assert!(m.pop(&1) == None);\n     }\n \n     #[test]\n     pub fn test_swap() {\n-        let mut m = LinearMap::new();\n+        let mut m = HashMap::new();\n         assert!(m.swap(1, 2) == None);\n         assert!(m.swap(1, 3) == Some(2));\n         assert!(m.swap(1, 4) == Some(3));\n     }\n \n     #[test]\n     pub fn test_find_or_insert() {\n-        let mut m = LinearMap::new::<int, int>();\n+        let mut m = HashMap::new::<int, int>();\n         assert!(m.find_or_insert(1, 2) == &2);\n         assert!(m.find_or_insert(1, 3) == &2);\n     }\n \n     #[test]\n     pub fn test_find_or_insert_with() {\n-        let mut m = LinearMap::new::<int, int>();\n+        let mut m = HashMap::new::<int, int>();\n         assert!(m.find_or_insert_with(1, |_| 2) == &2);\n         assert!(m.find_or_insert_with(1, |_| 3) == &2);\n     }\n \n     #[test]\n     pub fn test_consume() {\n-        let mut m = LinearMap::new();\n+        let mut m = HashMap::new();\n         assert!(m.insert(1, 2));\n         assert!(m.insert(2, 3));\n-        let mut m2 = LinearMap::new();\n+        let mut m2 = HashMap::new();\n         do m.consume |k, v| {\n             m2.insert(k, v);\n         }\n@@ -807,7 +807,7 @@ mod test_map {\n \n     #[test]\n     pub fn test_find() {\n-        let mut m = LinearMap::new();\n+        let mut m = HashMap::new();\n         assert!(m.find(&1).is_none());\n         m.insert(1, 2);\n         match m.find(&1) {\n@@ -818,12 +818,12 @@ mod test_map {\n \n     #[test]\n     pub fn test_eq() {\n-        let mut m1 = LinearMap::new();\n+        let mut m1 = HashMap::new();\n         m1.insert(1, 2);\n         m1.insert(2, 3);\n         m1.insert(3, 4);\n \n-        let mut m2 = LinearMap::new();\n+        let mut m2 = HashMap::new();\n         m2.insert(1, 2);\n         m2.insert(2, 3);\n \n@@ -836,7 +836,7 @@ mod test_map {\n \n     #[test]\n     pub fn test_expand() {\n-        let mut m = LinearMap::new();\n+        let mut m = HashMap::new();\n \n         assert!(m.len() == 0);\n         assert!(m.is_empty());\n@@ -861,8 +861,8 @@ mod test_set {\n \n     #[test]\n     fn test_disjoint() {\n-        let mut xs = LinearSet::new();\n-        let mut ys = LinearSet::new();\n+        let mut xs = HashSet::new();\n+        let mut ys = HashSet::new();\n         assert!(xs.is_disjoint(&ys));\n         assert!(ys.is_disjoint(&xs));\n         assert!(xs.insert(5));\n@@ -883,13 +883,13 @@ mod test_set {\n \n     #[test]\n     fn test_subset_and_superset() {\n-        let mut a = LinearSet::new();\n+        let mut a = HashSet::new();\n         assert!(a.insert(0));\n         assert!(a.insert(5));\n         assert!(a.insert(11));\n         assert!(a.insert(7));\n \n-        let mut b = LinearSet::new();\n+        let mut b = HashSet::new();\n         assert!(b.insert(0));\n         assert!(b.insert(7));\n         assert!(b.insert(19));\n@@ -912,8 +912,8 @@ mod test_set {\n \n     #[test]\n     fn test_intersection() {\n-        let mut a = LinearSet::new();\n-        let mut b = LinearSet::new();\n+        let mut a = HashSet::new();\n+        let mut b = HashSet::new();\n \n         assert!(a.insert(11));\n         assert!(a.insert(1));\n@@ -942,8 +942,8 @@ mod test_set {\n \n     #[test]\n     fn test_difference() {\n-        let mut a = LinearSet::new();\n-        let mut b = LinearSet::new();\n+        let mut a = HashSet::new();\n+        let mut b = HashSet::new();\n \n         assert!(a.insert(1));\n         assert!(a.insert(3));\n@@ -965,8 +965,8 @@ mod test_set {\n \n     #[test]\n     fn test_symmetric_difference() {\n-        let mut a = LinearSet::new();\n-        let mut b = LinearSet::new();\n+        let mut a = HashSet::new();\n+        let mut b = HashSet::new();\n \n         assert!(a.insert(1));\n         assert!(a.insert(3));\n@@ -991,8 +991,8 @@ mod test_set {\n \n     #[test]\n     fn test_union() {\n-        let mut a = LinearSet::new();\n-        let mut b = LinearSet::new();\n+        let mut a = HashSet::new();\n+        let mut b = HashSet::new();\n \n         assert!(a.insert(1));\n         assert!(a.insert(3));"}, {"sha": "e1b645cd5627295affd495bfb3965682fab9b7a3", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -79,7 +79,7 @@ use comm::{Chan, GenericChan};\n use prelude::*;\n use unstable;\n use ptr;\n-use hashmap::LinearSet;\n+use hashmap::HashSet;\n use task::local_data_priv::{local_get, local_set};\n use task::rt::rust_task;\n use task::rt;\n@@ -96,10 +96,10 @@ macro_rules! move_it (\n     { $x:expr } => ( unsafe { let y = *ptr::addr_of(&($x)); y } )\n )\n \n-type TaskSet = LinearSet<*rust_task>;\n+type TaskSet = HashSet<*rust_task>;\n \n fn new_taskset() -> TaskSet {\n-    LinearSet::new()\n+    HashSet::new()\n }\n fn taskset_insert(tasks: &mut TaskSet, task: *rust_task) {\n     let didnt_overwrite = tasks.insert(task);"}, {"sha": "41d0842002f678817e0669f325db1529c0d7415a", "filename": "src/libcore/unstable/global.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibcore%2Funstable%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibcore%2Funstable%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fglobal.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -34,7 +34,7 @@ use ops::Drop;\n use unstable::{Exclusive, exclusive};\n use unstable::at_exit::at_exit;\n use unstable::intrinsics::atomic_cxchg;\n-use hashmap::LinearMap;\n+use hashmap::HashMap;\n use sys::Closure;\n \n #[cfg(test)] use unstable::{SharedMutableState, shared_mutable_state};\n@@ -144,7 +144,7 @@ pub unsafe fn global_data_clone<T:Owned + Clone>(\n // destructor. Keys are pointers derived from the type of the\n // global value.  There is a single GlobalState instance per runtime.\n struct GlobalState {\n-    map: LinearMap<uint, (*c_void, ~fn())>\n+    map: HashMap<uint, (*c_void, ~fn())>\n }\n \n impl Drop for GlobalState {\n@@ -171,7 +171,7 @@ fn get_global_state() -> Exclusive<GlobalState> {\n \n         // The global state object\n         let state = GlobalState {\n-            map: LinearMap::new()\n+            map: HashMap::new()\n         };\n \n         // It's under a reference-counted mutex"}, {"sha": "6eabb0629d1fcd21b1fdf6ab6e012b00dfa4e56b", "filename": "src/libcore/unstable/weak_task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibcore%2Funstable%2Fweak_task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibcore%2Funstable%2Fweak_task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fweak_task.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -21,7 +21,7 @@ is trying to shut down.\n use cell::Cell;\n use comm::{GenericSmartChan, stream};\n use comm::{Port, Chan, SharedChan, GenericChan, GenericPort};\n-use hashmap::LinearMap;\n+use hashmap::HashMap;\n use option::{Some, None};\n use unstable::at_exit::at_exit;\n use unstable::finally::Finally;\n@@ -97,7 +97,7 @@ fn create_global_service() -> ~WeakTaskService {\n \n fn run_weak_task_service(port: Port<ServiceMsg>) {\n \n-    let mut shutdown_map = LinearMap::new();\n+    let mut shutdown_map = HashMap::new();\n \n     loop {\n         match port.recv() {"}, {"sha": "cc1168bd79ddd9f91e16103a2ac3e83ad203993d", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -18,7 +18,7 @@ use core::os;\n use core::uint;\n use core::util;\n use core::vec;\n-use core::hashmap::LinearSet;\n+use core::hashmap::HashSet;\n \n fn not_win32(os: session::os) -> bool {\n   match os {\n@@ -186,7 +186,7 @@ pub fn get_install_prefix_rpath(target_triple: &str) -> Path {\n }\n \n pub fn minimize_rpaths(rpaths: &[Path]) -> ~[Path] {\n-    let mut set = LinearSet::new();\n+    let mut set = HashSet::new();\n     let mut minimized = ~[];\n     for rpaths.each |rpath| {\n         if set.insert(rpath.to_str()) {"}, {"sha": "b6d3fce7e75469d664910c4f960e7c01173e6f50", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -10,7 +10,7 @@\n \n use core::prelude::*;\n \n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n use core::libc::c_uint;\n use core::option;\n use core::ptr;\n@@ -1467,8 +1467,8 @@ pub fn SetLinkage(Global: ValueRef, Link: Linkage) {\n /* Memory-managed object interface to type handles. */\n \n pub struct TypeNames {\n-    type_names: @mut LinearMap<TypeRef, @str>,\n-    named_types: @mut LinearMap<@str, TypeRef>\n+    type_names: @mut HashMap<TypeRef, @str>,\n+    named_types: @mut HashMap<@str, TypeRef>\n }\n \n pub fn associate_type(tn: @TypeNames, s: @str, t: TypeRef) {\n@@ -1486,8 +1486,8 @@ pub fn name_has_type(tn: @TypeNames, s: @str) -> Option<TypeRef> {\n \n pub fn mk_type_names() -> @TypeNames {\n     @TypeNames {\n-        type_names: @mut LinearMap::new(),\n-        named_types: @mut LinearMap::new()\n+        type_names: @mut HashMap::new(),\n+        named_types: @mut HashMap::new()\n     }\n }\n "}, {"sha": "8609434e6df29a5fa9fa40df0ed34e49c535cbb8", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -18,7 +18,7 @@ use metadata::decoder;\n use metadata::filesearch::FileSearch;\n use metadata::loader;\n \n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n use core::vec;\n use syntax::attr;\n use syntax::codemap::{span, dummy_sp};\n@@ -302,7 +302,7 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n     debug!(\"resolving deps of external crate\");\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers\n-    let mut cnum_map = LinearMap::new();\n+    let mut cnum_map = HashMap::new();\n     for decoder::get_crate_deps(e.intr, cdata).each |dep| {\n         let extrn_cnum = dep.cnum;\n         let cname = dep.name;"}, {"sha": "65bd37236b7146d7a230c951f236eceb22923e46", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -17,7 +17,7 @@ use core::prelude::*;\n use metadata::cstore;\n use metadata::decoder;\n \n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n use core::vec;\n use std;\n use syntax::ast;\n@@ -27,7 +27,7 @@ use syntax::parse::token::ident_interner;\n // local crate numbers (as generated during this session). Each external\n // crate may refer to types in other external crates, and each has their\n // own crate numbers.\n-pub type cnum_map = @mut LinearMap<ast::crate_num, ast::crate_num>;\n+pub type cnum_map = @mut HashMap<ast::crate_num, ast::crate_num>;\n \n pub struct crate_metadata {\n     name: @~str,\n@@ -37,7 +37,7 @@ pub struct crate_metadata {\n }\n \n pub struct CStore {\n-    priv metas: LinearMap <ast::crate_num, @crate_metadata>,\n+    priv metas: HashMap <ast::crate_num, @crate_metadata>,\n     priv extern_mod_crate_map: extern_mod_crate_map,\n     priv used_crate_files: ~[Path],\n     priv used_libraries: ~[~str],\n@@ -46,12 +46,12 @@ pub struct CStore {\n }\n \n // Map from node_id's of local extern mod statements to crate numbers\n-type extern_mod_crate_map = LinearMap<ast::node_id, ast::crate_num>;\n+type extern_mod_crate_map = HashMap<ast::node_id, ast::crate_num>;\n \n pub fn mk_cstore(intr: @ident_interner) -> CStore {\n     return CStore {\n-        metas: LinearMap::new(),\n-        extern_mod_crate_map: LinearMap::new(),\n+        metas: HashMap::new(),\n+        extern_mod_crate_map: HashMap::new(),\n         used_crate_files: ~[],\n         used_libraries: ~[],\n         used_link_args: ~[],"}, {"sha": "6000e559554f3ea757c2107b1a258f59d61b2d6e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -25,7 +25,7 @@ use util::ppaux::ty_to_str;\n \n use core::flate;\n use core::hash::HashUtil;\n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n use core::int;\n use core::io::{Writer, WriterUtil};\n use core::io;\n@@ -50,7 +50,7 @@ use syntax;\n use writer = std::ebml::writer;\n \n // used by astencode:\n-type abbrev_map = @mut LinearMap<ty::t, tyencode::ty_abbrev>;\n+type abbrev_map = @mut HashMap<ty::t, tyencode::ty_abbrev>;\n \n pub type encode_inlined_item = @fn(ecx: @EncodeContext,\n                                    ebml_w: writer::Encoder,\n@@ -62,8 +62,8 @@ pub struct EncodeParams {\n     tcx: ty::ctxt,\n     reachable: reachable::map,\n     reexports2: middle::resolve::ExportMap2,\n-    item_symbols: @mut LinearMap<ast::node_id, ~str>,\n-    discrim_symbols: @mut LinearMap<ast::node_id, ~str>,\n+    item_symbols: @mut HashMap<ast::node_id, ~str>,\n+    discrim_symbols: @mut HashMap<ast::node_id, ~str>,\n     link_meta: LinkMeta,\n     cstore: @mut cstore::CStore,\n     encode_inlined_item: encode_inlined_item\n@@ -89,8 +89,8 @@ pub struct EncodeContext {\n     stats: @mut Stats,\n     reachable: reachable::map,\n     reexports2: middle::resolve::ExportMap2,\n-    item_symbols: @mut LinearMap<ast::node_id, ~str>,\n-    discrim_symbols: @mut LinearMap<ast::node_id, ~str>,\n+    item_symbols: @mut HashMap<ast::node_id, ~str>,\n+    discrim_symbols: @mut HashMap<ast::node_id, ~str>,\n     link_meta: LinkMeta,\n     cstore: @mut cstore::CStore,\n     encode_inlined_item: encode_inlined_item,\n@@ -1345,7 +1345,7 @@ pub fn encode_metadata(+parms: EncodeParams, crate: &crate) -> ~[u8] {\n         link_meta: link_meta,\n         cstore: cstore,\n         encode_inlined_item: encode_inlined_item,\n-        type_abbrevs: @mut LinearMap::new()\n+        type_abbrevs: @mut HashMap::new()\n      };\n \n     let ebml_w = writer::Encoder(wr as @io::Writer);"}, {"sha": "251ba9b35cbd9457a7f5822453da251386d7b81c", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -16,7 +16,7 @@ use core::prelude::*;\n use middle::ty::param_ty;\n use middle::ty;\n \n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n use core::io::WriterUtil;\n use core::io;\n use core::uint;\n@@ -47,7 +47,7 @@ pub struct ty_abbrev {\n \n pub enum abbrev_ctxt {\n     ac_no_abbrevs,\n-    ac_use_abbrevs(@mut LinearMap<ty::t, ty_abbrev>),\n+    ac_use_abbrevs(@mut HashMap<ty::t, ty_abbrev>),\n }\n \n fn cx_uses_abbrevs(cx: @ctxt) -> bool {"}, {"sha": "160356567421d76c209809abc68ce0c47a4969f4", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -31,7 +31,7 @@ use middle::mem_categorization::{lp_comp, lp_deref, lp_local};\n use middle::ty;\n use util::ppaux::ty_to_str;\n \n-use core::hashmap::LinearSet;\n+use core::hashmap::HashSet;\n use core::uint;\n use syntax::ast::m_mutbl;\n use syntax::ast;\n@@ -44,7 +44,7 @@ struct CheckLoanCtxt {\n     bccx: @BorrowckCtxt,\n     req_maps: ReqMaps,\n \n-    reported: LinearSet<ast::node_id>,\n+    reported: HashSet<ast::node_id>,\n \n     declared_purity: @mut ast::purity,\n     fn_args: @mut @~[ast::node_id]\n@@ -68,7 +68,7 @@ pub fn check_loans(bccx: @BorrowckCtxt,\n     let clcx = @mut CheckLoanCtxt {\n         bccx: bccx,\n         req_maps: req_maps,\n-        reported: LinearSet::new(),\n+        reported: HashSet::new(),\n         declared_purity: @mut ast::impure_fn,\n         fn_args: @mut @~[]\n     };"}, {"sha": "122e2c64b213310da7b5e720923ceb5090421938", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -31,7 +31,7 @@ use middle::ty;\n use util::common::indenter;\n use util::ppaux::{expr_repr, region_to_str};\n \n-use core::hashmap::{LinearSet, LinearMap};\n+use core::hashmap::{HashSet, HashMap};\n use core::vec;\n use syntax::ast::{m_const, m_imm, m_mutbl};\n use syntax::ast;\n@@ -72,17 +72,17 @@ struct GatherLoanCtxt {\n     req_maps: ReqMaps,\n     item_ub: ast::node_id,\n     root_ub: ast::node_id,\n-    ignore_adjustments: LinearSet<ast::node_id>\n+    ignore_adjustments: HashSet<ast::node_id>\n }\n \n pub fn gather_loans(bccx: @BorrowckCtxt, crate: @ast::crate) -> ReqMaps {\n     let glcx = @mut GatherLoanCtxt {\n         bccx: bccx,\n-        req_maps: ReqMaps { req_loan_map: LinearMap::new(),\n-                            pure_map: LinearMap::new() },\n+        req_maps: ReqMaps { req_loan_map: HashMap::new(),\n+                            pure_map: HashMap::new() },\n         item_ub: 0,\n         root_ub: 0,\n-        ignore_adjustments: LinearSet::new()\n+        ignore_adjustments: HashSet::new()\n     };\n     let v = visit::mk_vt(@visit::Visitor {visit_expr: req_loans_in_expr,\n                                           visit_fn: req_loans_in_fn,"}, {"sha": "5e7903f66102fcb3fd73a68425322bab4ba02d05", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -234,7 +234,7 @@ use middle::moves;\n use util::common::stmt_set;\n use util::ppaux::note_and_explain_region;\n \n-use core::hashmap::{LinearSet, LinearMap};\n+use core::hashmap::{HashSet, HashMap};\n use core::io;\n use core::result::{Result, Ok, Err};\n use core::to_bytes;\n@@ -260,9 +260,9 @@ pub fn check_crate(\n         moves_map: moves_map,\n         capture_map: capture_map,\n         root_map: root_map(),\n-        mutbl_map: @mut LinearSet::new(),\n-        write_guard_map: @mut LinearSet::new(),\n-        stmt_map: @mut LinearSet::new(),\n+        mutbl_map: @mut HashSet::new(),\n+        write_guard_map: @mut HashSet::new(),\n+        stmt_map: @mut HashSet::new(),\n         stats: @mut BorrowStats {\n             loaned_paths_same: 0,\n             loaned_paths_imm: 0,\n@@ -333,7 +333,7 @@ pub struct RootInfo {\n // a map mapping id's of expressions of gc'd type (@T, @[], etc) where\n // the box needs to be kept live to the id of the scope for which they\n // must stay live.\n-pub type root_map = @mut LinearMap<root_map_key, RootInfo>;\n+pub type root_map = @mut HashMap<root_map_key, RootInfo>;\n \n // the keys to the root map combine the `id` of the expression with\n // the number of types that it is autodereferenced.  So, for example,\n@@ -348,11 +348,11 @@ pub struct root_map_key {\n \n // set of ids of local vars / formal arguments that are modified / moved.\n // this is used in trans for optimization purposes.\n-pub type mutbl_map = @mut LinearSet<ast::node_id>;\n+pub type mutbl_map = @mut HashSet<ast::node_id>;\n \n // A set containing IDs of expressions of gc'd type that need to have a write\n // guard.\n-pub type write_guard_map = @mut LinearSet<root_map_key>;\n+pub type write_guard_map = @mut HashSet<root_map_key>;\n \n // Errors that can occur\n #[deriving(Eq)]\n@@ -405,8 +405,8 @@ pub struct Loan {\n /// - `pure_map`: map from block/expr that must be pure to the error message\n ///   that should be reported if they are not pure\n pub struct ReqMaps {\n-    req_loan_map: LinearMap<ast::node_id, @mut ~[Loan]>,\n-    pure_map: LinearMap<ast::node_id, bckerr>\n+    req_loan_map: HashMap<ast::node_id, @mut ~[Loan]>,\n+    pure_map: HashMap<ast::node_id, bckerr>\n }\n \n pub fn save_and_restore<T:Copy,U>(save_and_restore_t: &mut T,\n@@ -450,7 +450,7 @@ impl to_bytes::IterBytes for root_map_key {\n }\n \n pub fn root_map() -> root_map {\n-    return @mut LinearMap::new();\n+    return @mut HashMap::new();\n }\n \n // ___________________________________________________________________________"}, {"sha": "d6434e469b2d16f612c70f72ef39df8cdc9dc4a6", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -20,7 +20,7 @@ use core::vec;\n use syntax::{ast, ast_map, ast_util, visit};\n use syntax::ast::*;\n \n-use core::hashmap::{LinearMap, LinearSet};\n+use core::hashmap::{HashMap, HashSet};\n \n //\n // This pass classifies expressions by their constant-ness.\n@@ -189,14 +189,14 @@ pub fn lookup_const_by_id(tcx: ty::ctxt,\n         }\n     } else {\n         let maps = astencode::Maps {\n-            mutbl_map: @mut LinearSet::new(),\n-            root_map: @mut LinearMap::new(),\n-            last_use_map: @mut LinearMap::new(),\n-            method_map: @mut LinearMap::new(),\n-            vtable_map: @mut LinearMap::new(),\n-            write_guard_map: @mut LinearSet::new(),\n-            moves_map: @mut LinearSet::new(),\n-            capture_map: @mut LinearMap::new()\n+            mutbl_map: @mut HashSet::new(),\n+            root_map: @mut HashMap::new(),\n+            last_use_map: @mut HashMap::new(),\n+            method_map: @mut HashMap::new(),\n+            vtable_map: @mut HashMap::new(),\n+            write_guard_map: @mut HashSet::new(),\n+            moves_map: @mut HashSet::new(),\n+            capture_map: @mut HashMap::new()\n         };\n         match csearch::maybe_get_item_ast(tcx, def_id,\n             |a, b, c, d| astencode::decode_inlined_item(a, b, maps, /*bar*/ copy c, d)) {"}, {"sha": "e6e9f3be85d21bb8ebb3a0980db8484a7cdf9cb1", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -17,7 +17,7 @@ use core::prelude::*;\n use middle::resolve;\n use middle::ty;\n \n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n use syntax::codemap::span;\n use syntax::{ast, ast_util, visit};\n \n@@ -30,7 +30,7 @@ pub struct freevar_entry {\n     span: span     //< First span where it is accessed (there can be multiple)\n }\n pub type freevar_info = @~[@freevar_entry];\n-pub type freevar_map = @mut LinearMap<ast::node_id, freevar_info>;\n+pub type freevar_map = @mut HashMap<ast::node_id, freevar_info>;\n \n // Searches through part of the AST for all references to locals or\n // upvars in this frame and returns the list of definition IDs thus found.\n@@ -39,7 +39,7 @@ pub type freevar_map = @mut LinearMap<ast::node_id, freevar_info>;\n // in order to start the search.\n fn collect_freevars(def_map: resolve::DefMap, blk: &ast::blk)\n     -> freevar_info {\n-    let seen = @mut LinearMap::new();\n+    let seen = @mut HashMap::new();\n     let refs = @mut ~[];\n \n     fn ignore_item(_i: @ast::item, &&_depth: int, _v: visit::vt<int>) { }\n@@ -92,7 +92,7 @@ fn collect_freevars(def_map: resolve::DefMap, blk: &ast::blk)\n // one pass. This could be improved upon if it turns out to matter.\n pub fn annotate_freevars(def_map: resolve::DefMap, crate: @ast::crate) ->\n    freevar_map {\n-    let freevars = @mut LinearMap::new();\n+    let freevars = @mut HashMap::new();\n \n     let walk_fn: @fn(&visit::fn_kind,\n                      &ast::fn_decl,"}, {"sha": "ab9b8ca0db624c730963540d329d061dd0e583bd", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -31,7 +31,7 @@ use syntax::ast_util::local_def;\n use syntax::visit::{default_simple_visitor, mk_simple_visitor, SimpleVisitor};\n use syntax::visit::visit_crate;\n \n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n use core::ptr;\n \n pub enum LangItem {\n@@ -259,7 +259,7 @@ fn LanguageItemCollector<'r>(crate: @crate,\n                              session: Session,\n                              items: &'r mut LanguageItems)\n                           -> LanguageItemCollector<'r> {\n-    let mut item_refs = LinearMap::new();\n+    let mut item_refs = HashMap::new();\n \n     item_refs.insert(@~\"const\", ConstTraitLangItem as uint);\n     item_refs.insert(@~\"copy\", CopyTraitLangItem as uint);\n@@ -317,7 +317,7 @@ struct LanguageItemCollector<'self> {\n     crate: @crate,\n     session: Session,\n \n-    item_refs: LinearMap<@~str, uint>,\n+    item_refs: HashMap<@~str, uint>,\n }\n \n pub impl<'self> LanguageItemCollector<'self> {"}, {"sha": "a21cc26bd91244c1a45bf70558d675471ed289af", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -15,7 +15,7 @@ use driver::session;\n use middle::ty;\n use util::ppaux::{ty_to_str};\n \n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n use core::char;\n use core::cmp;\n use core::i8;\n@@ -108,7 +108,7 @@ struct LintSpec {\n     default: level\n }\n \n-pub type LintDict = @LinearMap<~str, LintSpec>;\n+pub type LintDict = @HashMap<~str, LintSpec>;\n \n /*\n   Pass names should not contain a '-', as the compiler normalizes\n@@ -273,7 +273,7 @@ pub fn get_lint_dict() -> LintDict {\n          }),\n         */\n     ];\n-    let mut map = LinearMap::new();\n+    let mut map = HashMap::new();\n     do vec::consume(v) |_, (k, v)| {\n         map.insert(k, v);\n     }\n@@ -282,7 +282,7 @@ pub fn get_lint_dict() -> LintDict {\n \n // This is a highly not-optimal set of data structure decisions.\n type LintModes = @mut SmallIntMap<level>;\n-type LintModeMap = @mut LinearMap<ast::node_id, LintModes>;\n+type LintModeMap = @mut HashMap<ast::node_id, LintModes>;\n \n // settings_map maps node ids of items with non-default lint settings\n // to their settings; default_settings contains the settings for everything\n@@ -295,7 +295,7 @@ pub struct LintSettings {\n pub fn mk_lint_settings() -> LintSettings {\n     LintSettings {\n         default_settings: @mut SmallIntMap::new(),\n-        settings_map: @mut LinearMap::new()\n+        settings_map: @mut HashMap::new()\n     }\n }\n "}, {"sha": "01598b118518d2894e83ac9459e3cf03a6e27644", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -111,7 +111,7 @@ use middle::typeck;\n use middle::moves;\n use util::ppaux::ty_to_str;\n \n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n use core::io::WriterUtil;\n use core::io;\n use core::ptr;\n@@ -134,7 +134,7 @@ use syntax::{visit, ast_util};\n //\n // Very subtle (#2633): borrowck will remove entries from this table\n // if it detects an outstanding loan (that is, the addr is taken).\n-pub type last_use_map = @mut LinearMap<node_id, @mut ~[node_id]>;\n+pub type last_use_map = @mut HashMap<node_id, @mut ~[node_id]>;\n \n #[deriving(Eq)]\n struct Variable(uint);\n@@ -172,7 +172,7 @@ pub fn check_crate(tcx: ty::ctxt,\n         .. *visit::default_visitor()\n     });\n \n-    let last_use_map = @mut LinearMap::new();\n+    let last_use_map = @mut HashMap::new();\n     let initial_maps = @mut IrMaps(tcx,\n                                    method_map,\n                                    variable_moves_map,\n@@ -264,9 +264,9 @@ struct IrMaps {\n \n     num_live_nodes: uint,\n     num_vars: uint,\n-    live_node_map: LinearMap<node_id, LiveNode>,\n-    variable_map: LinearMap<node_id, Variable>,\n-    capture_info_map: LinearMap<node_id, @~[CaptureInfo]>,\n+    live_node_map: HashMap<node_id, LiveNode>,\n+    variable_map: HashMap<node_id, Variable>,\n+    capture_info_map: HashMap<node_id, @~[CaptureInfo]>,\n     var_kinds: ~[VarKind],\n     lnks: ~[LiveNodeKind],\n }\n@@ -285,9 +285,9 @@ fn IrMaps(tcx: ty::ctxt,\n         last_use_map: last_use_map,\n         num_live_nodes: 0,\n         num_vars: 0,\n-        live_node_map: LinearMap::new(),\n-        variable_map: LinearMap::new(),\n-        capture_info_map: LinearMap::new(),\n+        live_node_map: HashMap::new(),\n+        variable_map: HashMap::new(),\n+        capture_info_map: HashMap::new(),\n         var_kinds: ~[],\n         lnks: ~[]\n     }\n@@ -612,7 +612,7 @@ static ACC_READ: uint = 1u;\n static ACC_WRITE: uint = 2u;\n static ACC_USE: uint = 4u;\n \n-type LiveNodeMap = @mut LinearMap<node_id, LiveNode>;\n+type LiveNodeMap = @mut HashMap<node_id, LiveNode>;\n \n struct Liveness {\n     tcx: ty::ctxt,\n@@ -639,8 +639,8 @@ fn Liveness(ir: @mut IrMaps, specials: Specials) -> Liveness {\n         users: @mut vec::from_elem(ir.num_live_nodes * ir.num_vars,\n                                    invalid_users()),\n         loop_scope: @mut ~[],\n-        break_ln: @mut LinearMap::new(),\n-        cont_ln: @mut LinearMap::new()\n+        break_ln: @mut HashMap::new(),\n+        cont_ln: @mut HashMap::new()\n     }\n }\n "}, {"sha": "2f379ece5d374d7611da5739a31af1746b144c5c", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -215,7 +215,7 @@ use middle::typeck::method_map;\n use util::ppaux;\n use util::common::indenter;\n \n-use core::hashmap::{LinearSet, LinearMap};\n+use core::hashmap::{HashSet, HashMap};\n use core::vec;\n use syntax::ast::*;\n use syntax::ast_util;\n@@ -240,14 +240,14 @@ pub struct CaptureVar {\n     mode: CaptureMode // How variable is being accessed\n }\n \n-pub type CaptureMap = @mut LinearMap<node_id, @[CaptureVar]>;\n+pub type CaptureMap = @mut HashMap<node_id, @[CaptureVar]>;\n \n-pub type MovesMap = @mut LinearSet<node_id>;\n+pub type MovesMap = @mut HashSet<node_id>;\n \n /**\n  * For each variable which will be moved, links to the\n  * expression */\n-pub type VariableMovesMap = @mut LinearMap<node_id, @expr>;\n+pub type VariableMovesMap = @mut HashMap<node_id, @expr>;\n \n /** See the section Output on the module comment for explanation. */\n pub struct MoveMaps {\n@@ -280,9 +280,9 @@ pub fn compute_moves(tcx: ty::ctxt,\n         tcx: tcx,\n         method_map: method_map,\n         move_maps: MoveMaps {\n-            moves_map: @mut LinearSet::new(),\n-            variable_moves_map: @mut LinearMap::new(),\n-            capture_map: @mut LinearMap::new()\n+            moves_map: @mut HashSet::new(),\n+            variable_moves_map: @mut HashMap::new(),\n+            capture_map: @mut HashMap::new()\n         }\n     };\n     visit::visit_crate(*crate, visit_cx, visitor);"}, {"sha": "2e2048b7ae4cd06880d391d5ffb072fdeec8174e", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -12,17 +12,17 @@ use core::prelude::*;\n \n use middle::resolve;\n \n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n use syntax::ast::*;\n use syntax::ast_util::{path_to_ident, walk_pat};\n use syntax::codemap::span;\n \n-pub type PatIdMap = LinearMap<ident, node_id>;\n+pub type PatIdMap = HashMap<ident, node_id>;\n \n // This is used because same-named variables in alternative patterns need to\n // use the node_id of their namesake in the first pattern.\n pub fn pat_id_map(dm: resolve::DefMap, pat: @pat) -> PatIdMap {\n-    let mut map = LinearMap::new();\n+    let mut map = HashMap::new();\n     do pat_bindings(dm, pat) |_bm, p_id, _s, n| {\n       map.insert(path_to_ident(n), p_id);\n     };"}, {"sha": "75eb8ef1a85802889cc4616b9b87f087ebdf1d87", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -26,7 +26,7 @@ use middle::ty::{region_variance, rv_covariant, rv_invariant};\n use middle::ty::{rv_contravariant};\n use middle::ty;\n \n-use core::hashmap::{LinearMap, LinearSet};\n+use core::hashmap::{HashMap, HashSet};\n use core::vec;\n use syntax::ast_map;\n use syntax::codemap::span;\n@@ -46,7 +46,7 @@ Encodes the bounding lifetime for a given AST node:\n - Variables and bindings are mapped to the block in which they are declared.\n \n */\n-pub type region_map = @mut LinearMap<ast::node_id, ast::node_id>;\n+pub type region_map = @mut HashMap<ast::node_id, ast::node_id>;\n \n pub struct ctxt {\n     sess: Session,\n@@ -62,7 +62,7 @@ pub struct ctxt {\n     // the condition in a while loop is always a parent.  In those\n     // cases, we add the node id of such an expression to this set so\n     // that when we visit it we can view it as a parent.\n-    root_exprs: @mut LinearSet<ast::node_id>,\n+    root_exprs: @mut HashSet<ast::node_id>,\n \n     // The parent scope is the innermost block, statement, call, or match\n     // expression during the execution of which the current expression\n@@ -350,8 +350,8 @@ pub fn resolve_crate(sess: Session,\n                   -> region_map {\n     let cx: ctxt = ctxt {sess: sess,\n                          def_map: def_map,\n-                         region_map: @mut LinearMap::new(),\n-                         root_exprs: @mut LinearSet::new(),\n+                         region_map: @mut HashMap::new(),\n+                         root_exprs: @mut HashSet::new(),\n                          parent: None};\n     let visitor = visit::mk_vt(@visit::Visitor {\n         visit_block: resolve_block,\n@@ -387,15 +387,15 @@ pub fn resolve_crate(sess: Session,\n // a worklist.  We can then process the worklist, propagating indirect\n // dependencies until a fixed point is reached.\n \n-pub type region_paramd_items = @mut LinearMap<ast::node_id, region_variance>;\n+pub type region_paramd_items = @mut HashMap<ast::node_id, region_variance>;\n \n #[deriving(Eq)]\n pub struct region_dep {\n     ambient_variance: region_variance,\n     id: ast::node_id\n }\n \n-pub type dep_map = @mut LinearMap<ast::node_id, @mut ~[region_dep]>;\n+pub type dep_map = @mut HashMap<ast::node_id, @mut ~[region_dep]>;\n \n pub struct DetermineRpCtxt {\n     sess: Session,\n@@ -790,8 +790,8 @@ pub fn determine_rp_in_crate(sess: Session,\n         sess: sess,\n         ast_map: ast_map,\n         def_map: def_map,\n-        region_paramd_items: @mut LinearMap::new(),\n-        dep_map: @mut LinearMap::new(),\n+        region_paramd_items: @mut HashMap::new(),\n+        dep_map: @mut HashMap::new(),\n         worklist: ~[],\n         item_id: 0,\n         anon_implies_rp: false,"}, {"sha": "08542301e238fdc62a8326cb67373894c7b11e87", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -77,18 +77,18 @@ use syntax::opt_vec::OptVec;\n \n use core::option::Some;\n use core::str::each_split_str;\n-use core::hashmap::{LinearMap, LinearSet};\n+use core::hashmap::{HashMap, HashSet};\n \n // Definition mapping\n-pub type DefMap = @mut LinearMap<node_id,def>;\n+pub type DefMap = @mut HashMap<node_id,def>;\n \n pub struct binding_info {\n     span: span,\n     binding_mode: binding_mode,\n }\n \n // Map from the name in a pattern to its binding mode.\n-pub type BindingMap = LinearMap<ident,binding_info>;\n+pub type BindingMap = HashMap<ident,binding_info>;\n \n // Implementation resolution\n //\n@@ -109,11 +109,11 @@ pub struct Impl {\n }\n \n // Trait method resolution\n-pub type TraitMap = LinearMap<node_id,@mut ~[def_id]>;\n+pub type TraitMap = HashMap<node_id,@mut ~[def_id]>;\n \n // This is the replacement export map. It maps a module to all of the exports\n // within.\n-pub type ExportMap2 = @mut LinearMap<node_id, ~[Export2]>;\n+pub type ExportMap2 = @mut HashMap<node_id, ~[Export2]>;\n \n pub struct Export2 {\n     name: @~str,        // The name of the target.\n@@ -328,13 +328,13 @@ pub fn namespace_for_duplicate_checking_mode(mode: DuplicateCheckingMode)\n \n /// One local scope.\n pub struct Rib {\n-    bindings: @mut LinearMap<ident,def_like>,\n+    bindings: @mut HashMap<ident,def_like>,\n     kind: RibKind,\n }\n \n pub fn Rib(kind: RibKind) -> Rib {\n     Rib {\n-        bindings: @mut LinearMap::new(),\n+        bindings: @mut HashMap::new(),\n         kind: kind\n     }\n }\n@@ -450,12 +450,12 @@ pub struct Module {\n     def_id: Option<def_id>,\n     kind: ModuleKind,\n \n-    children: @mut LinearMap<ident, @mut NameBindings>,\n+    children: @mut HashMap<ident, @mut NameBindings>,\n     imports: @mut ~[@ImportDirective],\n \n     // The external module children of this node that were declared with\n     // `extern mod`.\n-    external_module_children: @mut LinearMap<ident, @mut Module>,\n+    external_module_children: @mut HashMap<ident, @mut Module>,\n \n     // The anonymous children of this node. Anonymous children are pseudo-\n     // modules that are implicitly created around items contained within\n@@ -472,10 +472,10 @@ pub struct Module {\n     // There will be an anonymous module created around `g` with the ID of the\n     // entry block for `f`.\n \n-    anonymous_children: @mut LinearMap<node_id,@mut Module>,\n+    anonymous_children: @mut HashMap<node_id,@mut Module>,\n \n     // The status of resolving each import in this module.\n-    import_resolutions: @mut LinearMap<ident, @mut ImportResolution>,\n+    import_resolutions: @mut HashMap<ident, @mut ImportResolution>,\n \n     // The number of unresolved globs that this module exports.\n     glob_count: uint,\n@@ -492,11 +492,11 @@ pub fn Module(parent_link: ParentLink,\n         parent_link: parent_link,\n         def_id: def_id,\n         kind: kind,\n-        children: @mut LinearMap::new(),\n+        children: @mut HashMap::new(),\n         imports: @mut ~[],\n-        external_module_children: @mut LinearMap::new(),\n-        anonymous_children: @mut LinearMap::new(),\n-        import_resolutions: @mut LinearMap::new(),\n+        external_module_children: @mut HashMap::new(),\n+        anonymous_children: @mut HashMap::new(),\n+        import_resolutions: @mut HashMap::new(),\n         glob_count: 0,\n         resolved_import_count: 0\n     }\n@@ -707,7 +707,7 @@ pub fn NameBindings() -> NameBindings {\n \n /// Interns the names of the primitive types.\n pub struct PrimitiveTypeTable {\n-    primitive_types: LinearMap<ident,prim_ty>,\n+    primitive_types: HashMap<ident,prim_ty>,\n }\n \n pub impl PrimitiveTypeTable {\n@@ -720,7 +720,7 @@ pub impl PrimitiveTypeTable {\n \n pub fn PrimitiveTypeTable(intr: @ident_interner) -> PrimitiveTypeTable {\n     let mut table = PrimitiveTypeTable {\n-        primitive_types: LinearMap::new()\n+        primitive_types: HashMap::new()\n     };\n \n     table.intern(intr, @~\"bool\",    ty_bool);\n@@ -775,8 +775,8 @@ pub fn Resolver(session: Session,\n \n         graph_root: graph_root,\n \n-        trait_info: LinearMap::new(),\n-        structs: LinearSet::new(),\n+        trait_info: HashMap::new(),\n+        structs: HashSet::new(),\n \n         unresolved_imports: 0,\n \n@@ -799,9 +799,9 @@ pub fn Resolver(session: Session,\n         attr_main_fn: None,\n         main_fns: ~[],\n \n-        def_map: @mut LinearMap::new(),\n-        export_map2: @mut LinearMap::new(),\n-        trait_map: LinearMap::new(),\n+        def_map: @mut HashMap::new(),\n+        export_map2: @mut HashMap::new(),\n+        trait_map: HashMap::new(),\n \n         intr: session.intr()\n     };\n@@ -819,8 +819,8 @@ pub struct Resolver {\n \n     graph_root: @mut NameBindings,\n \n-    trait_info: LinearMap<def_id, LinearSet<ident>>,\n-    structs: LinearSet<def_id>,\n+    trait_info: HashMap<def_id, HashSet<ident>>,\n+    structs: HashSet<def_id>,\n \n     // The number of imports that are currently unresolved.\n     unresolved_imports: uint,\n@@ -1309,7 +1309,7 @@ pub impl Resolver {\n                 }\n \n                 // Add the names of all the methods to the trait info.\n-                let mut method_names = LinearSet::new();\n+                let mut method_names = HashSet::new();\n                 for methods.each |method| {\n                     let ty_m = trait_method_to_ty_method(method);\n \n@@ -1543,7 +1543,7 @@ pub impl Resolver {\n \n     fn handle_external_def(@mut self,\n                            def: def,\n-                           modules: &mut LinearMap<def_id, @mut Module>,\n+                           modules: &mut HashMap<def_id, @mut Module>,\n                            child_name_bindings: @mut NameBindings,\n                            final_ident: &str,\n                            ident: ident,\n@@ -1623,7 +1623,7 @@ pub impl Resolver {\n                 // Nothing to do.\n               }\n               Some(method_names) => {\n-                let mut interned_method_names = LinearSet::new();\n+                let mut interned_method_names = HashSet::new();\n                 for method_names.each |method_data| {\n                     let (method_name, self_ty) = *method_data;\n                     debug!(\"(building reduced graph for \\\n@@ -1663,7 +1663,7 @@ pub impl Resolver {\n      * crate.\n      */\n     fn build_reduced_graph_for_external_crate(@mut self, root: @mut Module) {\n-        let mut modules = LinearMap::new();\n+        let mut modules = HashMap::new();\n \n         // Create all the items reachable by paths.\n         for each_path(self.session.cstore, root.def_id.get().crate)\n@@ -3906,7 +3906,7 @@ pub impl Resolver {\n     }\n \n     fn binding_mode_map(@mut self, pat: @pat) -> BindingMap {\n-        let mut result = LinearMap::new();\n+        let mut result = HashMap::new();\n         do pat_bindings(self.def_map, pat) |binding_mode, _id, sp, path| {\n             let ident = path_to_ident(path);\n             result.insert(ident,\n@@ -3958,7 +3958,7 @@ pub impl Resolver {\n     fn resolve_arm(@mut self, arm: &arm, visitor: ResolveVisitor) {\n         self.value_ribs.push(@Rib(NormalRibKind));\n \n-        let bindings_list = @mut LinearMap::new();\n+        let bindings_list = @mut HashMap::new();\n         for arm.pats.each |pattern| {\n             self.resolve_pattern(*pattern, RefutableMode, Immutable,\n                                  Some(bindings_list), visitor);\n@@ -4078,7 +4078,7 @@ pub impl Resolver {\n                        mutability: Mutability,\n                        // Maps idents to the node ID for the (outermost)\n                        // pattern that binds them\n-                       bindings_list: Option<@mut LinearMap<ident,node_id>>,\n+                       bindings_list: Option<@mut HashMap<ident,node_id>>,\n                        visitor: ResolveVisitor) {\n         let pat_id = pattern.id;\n         do walk_pat(pattern) |pattern| {\n@@ -4282,7 +4282,7 @@ pub impl Resolver {\n                 }\n \n                 pat_struct(path, _, _) => {\n-                    let structs: &mut LinearSet<def_id> = &mut self.structs;\n+                    let structs: &mut HashSet<def_id> = &mut self.structs;\n                     match self.resolve_path(path, TypeNS, false, visitor) {\n                         Some(def_ty(class_id))\n                                 if structs.contains(&class_id) => {\n@@ -4791,7 +4791,7 @@ pub impl Resolver {\n \n             expr_struct(path, _, _) => {\n                 // Resolve the path to the structure it goes to.\n-                let structs: &mut LinearSet<def_id> = &mut self.structs;\n+                let structs: &mut HashSet<def_id> = &mut self.structs;\n                 match self.resolve_path(path, TypeNS, false, visitor) {\n                     Some(def_ty(class_id)) | Some(def_struct(class_id))\n                             if structs.contains(&class_id) => {"}, {"sha": "32c9189ad2d7d7797892c5fb1559af16a50a23d4", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -167,7 +167,7 @@ use middle::trans::type_of;\n use middle::ty;\n use util::common::indenter;\n \n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n use syntax::ast;\n use syntax::ast::ident;\n use syntax::ast_util::path_to_ident;\n@@ -323,7 +323,7 @@ pub struct BindingInfo {\n     ty: ty::t,\n }\n \n-pub type BindingsMap = LinearMap<ident, BindingInfo>;\n+pub type BindingsMap = HashMap<ident, BindingInfo>;\n \n pub struct ArmData<'self> {\n     bodycx: block,\n@@ -1620,7 +1620,7 @@ pub fn trans_match_inner(scope_cx: block,\n         // to an alloca() that will be the value for that local variable.\n         // Note that we use the names because each binding will have many ids\n         // from the various alternatives.\n-        let mut bindings_map = LinearMap::new();\n+        let mut bindings_map = HashMap::new();\n         do pat_bindings(tcx.def_map, arm.pats[0]) |bm, p_id, _s, path| {\n             let ident = path_to_ident(path);\n             let variable_ty = node_id_type(bcx, p_id);"}, {"sha": "aa97c287b4c0543ae2b4f6876a1ebd19ef8adff6", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -67,7 +67,7 @@ use util::ppaux::ty_to_str;\n use util::ppaux;\n \n use core::hash;\n-use core::hashmap::{LinearMap, LinearSet};\n+use core::hashmap::{HashMap, HashSet};\n use core::int;\n use core::io;\n use core::libc::{c_uint, c_ulonglong};\n@@ -1609,9 +1609,9 @@ pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n           llself: None,\n           personality: None,\n           loop_ret: None,\n-          llargs: @mut LinearMap::new(),\n-          lllocals: @mut LinearMap::new(),\n-          llupvars: @mut LinearMap::new(),\n+          llargs: @mut HashMap::new(),\n+          lllocals: @mut HashMap::new(),\n+          llupvars: @mut HashMap::new(),\n           id: id,\n           impl_id: impl_id,\n           param_substs: param_substs,\n@@ -2610,7 +2610,7 @@ pub fn p2i(ccx: @CrateContext, v: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn declare_intrinsics(llmod: ModuleRef) -> LinearMap<~str, ValueRef> {\n+pub fn declare_intrinsics(llmod: ModuleRef) -> HashMap<~str, ValueRef> {\n     let T_memcpy32_args: ~[TypeRef] =\n         ~[T_ptr(T_i8()), T_ptr(T_i8()), T_i32(), T_i32(), T_i1()];\n     let T_memcpy64_args: ~[TypeRef] =\n@@ -2743,7 +2743,7 @@ pub fn declare_intrinsics(llmod: ModuleRef) -> LinearMap<~str, ValueRef> {\n     let bswap64 = decl_cdecl_fn(llmod, ~\"llvm.bswap.i64\",\n                                 T_fn(~[T_i64()], T_i64()));\n \n-    let mut intrinsics = LinearMap::new();\n+    let mut intrinsics = HashMap::new();\n     intrinsics.insert(~\"llvm.gcroot\", gcroot);\n     intrinsics.insert(~\"llvm.gcread\", gcread);\n     intrinsics.insert(~\"llvm.memcpy.p0i8.p0i8.i32\", memcpy32);\n@@ -2804,7 +2804,7 @@ pub fn declare_intrinsics(llmod: ModuleRef) -> LinearMap<~str, ValueRef> {\n }\n \n pub fn declare_dbg_intrinsics(llmod: ModuleRef,\n-                              intrinsics: &mut LinearMap<~str, ValueRef>) {\n+                              intrinsics: &mut HashMap<~str, ValueRef>) {\n     let declare =\n         decl_cdecl_fn(llmod, ~\"llvm.dbg.declare\",\n                       T_fn(~[T_metadata(), T_metadata()], T_void()));\n@@ -3052,37 +3052,37 @@ pub fn trans_crate(sess: session::Session,\n               llmod: llmod,\n               td: td,\n               tn: tn,\n-              externs: @mut LinearMap::new(),\n+              externs: @mut HashMap::new(),\n               intrinsics: intrinsics,\n-              item_vals: @mut LinearMap::new(),\n+              item_vals: @mut HashMap::new(),\n               exp_map2: emap2,\n               reachable: reachable,\n-              item_symbols: @mut LinearMap::new(),\n+              item_symbols: @mut HashMap::new(),\n               link_meta: link_meta,\n-              enum_sizes: @mut LinearMap::new(),\n-              discrims: @mut LinearMap::new(),\n-              discrim_symbols: @mut LinearMap::new(),\n-              tydescs: @mut LinearMap::new(),\n+              enum_sizes: @mut HashMap::new(),\n+              discrims: @mut HashMap::new(),\n+              discrim_symbols: @mut HashMap::new(),\n+              tydescs: @mut HashMap::new(),\n               finished_tydescs: @mut false,\n-              external: @mut LinearMap::new(),\n-              monomorphized: @mut LinearMap::new(),\n-              monomorphizing: @mut LinearMap::new(),\n-              type_use_cache: @mut LinearMap::new(),\n-              vtables: @mut LinearMap::new(),\n-              const_cstr_cache: @mut LinearMap::new(),\n-              const_globals: @mut LinearMap::new(),\n-              const_values: @mut LinearMap::new(),\n-              extern_const_values: @mut LinearMap::new(),\n-              module_data: @mut LinearMap::new(),\n-              lltypes: @mut LinearMap::new(),\n-              llsizingtypes: @mut LinearMap::new(),\n-              adt_reprs: @mut LinearMap::new(),\n+              external: @mut HashMap::new(),\n+              monomorphized: @mut HashMap::new(),\n+              monomorphizing: @mut HashMap::new(),\n+              type_use_cache: @mut HashMap::new(),\n+              vtables: @mut HashMap::new(),\n+              const_cstr_cache: @mut HashMap::new(),\n+              const_globals: @mut HashMap::new(),\n+              const_values: @mut HashMap::new(),\n+              extern_const_values: @mut HashMap::new(),\n+              module_data: @mut HashMap::new(),\n+              lltypes: @mut HashMap::new(),\n+              llsizingtypes: @mut HashMap::new(),\n+              adt_reprs: @mut HashMap::new(),\n               names: new_namegen(sess.parse_sess.interner),\n               next_addrspace: new_addrspace_gen(),\n               symbol_hasher: symbol_hasher,\n-              type_hashcodes: @mut LinearMap::new(),\n-              type_short_names: @mut LinearMap::new(),\n-              all_llvm_symbols: @mut LinearSet::new(),\n+              type_hashcodes: @mut HashMap::new(),\n+              type_short_names: @mut HashMap::new(),\n+              all_llvm_symbols: @mut HashSet::new(),\n               tcx: tcx,\n               maps: maps,\n               stats: @mut Stats {\n@@ -3095,7 +3095,7 @@ pub fn trans_crate(sess: session::Session,\n                 n_inlines: 0u,\n                 n_closures: 0u,\n                 llvm_insn_ctxt: @mut ~[],\n-                llvm_insns: @mut LinearMap::new(),\n+                llvm_insns: @mut HashMap::new(),\n                 fn_times: @mut ~[]\n               },\n               upcalls: upcall::declare_upcalls(targ_cfg, llmod),"}, {"sha": "fa2be2f415f9519f447c056d030f3bb0af40420b", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -18,7 +18,7 @@ use syntax::codemap::span;\n \n use core::prelude::*;\n use core::cast;\n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n use core::libc::{c_uint, c_ulonglong, c_char};\n use core::libc;\n use core::option::Some;\n@@ -55,7 +55,7 @@ pub fn count_insn(cx: block, category: &str) {\n         // Build version of path with cycles removed.\n \n         // Pass 1: scan table mapping str -> rightmost pos.\n-        let mut mm = LinearMap::new();\n+        let mut mm = HashMap::new();\n         let len = vec::len(*v);\n         let mut i = 0u;\n         while i < len {"}, {"sha": "f0c17a6f80d7b915cc8e31484e9330ff2e7c4a36", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -45,7 +45,7 @@ use util::ppaux::{expr_repr, ty_to_str};\n \n use core::cast;\n use core::hash;\n-use core::hashmap::{LinearMap, LinearSet};\n+use core::hashmap::{HashMap, HashSet};\n use core::libc::{c_uint, c_longlong, c_ulonglong};\n use core::ptr;\n use core::str;\n@@ -134,7 +134,7 @@ pub struct Stats {\n     n_inlines: uint,\n     n_closures: uint,\n     llvm_insn_ctxt: @mut ~[~str],\n-    llvm_insns: @mut LinearMap<~str, uint>,\n+    llvm_insns: @mut HashMap<~str, uint>,\n     fn_times: @mut ~[(~str, int)] // (ident, time)\n }\n \n@@ -156,7 +156,7 @@ pub fn BuilderRef_res(B: BuilderRef) -> BuilderRef_res {\n     }\n }\n \n-pub type ExternMap = @mut LinearMap<@str, ValueRef>;\n+pub type ExternMap = @mut HashMap<@str, ValueRef>;\n \n // Crate context.  Every crate we compile has one of these.\n pub struct CrateContext {\n@@ -165,30 +165,30 @@ pub struct CrateContext {\n      td: TargetData,\n      tn: @TypeNames,\n      externs: ExternMap,\n-     intrinsics: LinearMap<~str, ValueRef>,\n-     item_vals: @mut LinearMap<ast::node_id, ValueRef>,\n+     intrinsics: HashMap<~str, ValueRef>,\n+     item_vals: @mut HashMap<ast::node_id, ValueRef>,\n      exp_map2: resolve::ExportMap2,\n      reachable: reachable::map,\n-     item_symbols: @mut LinearMap<ast::node_id, ~str>,\n+     item_symbols: @mut HashMap<ast::node_id, ~str>,\n      link_meta: LinkMeta,\n-     enum_sizes: @mut LinearMap<ty::t, uint>,\n-     discrims: @mut LinearMap<ast::def_id, ValueRef>,\n-     discrim_symbols: @mut LinearMap<ast::node_id, ~str>,\n-     tydescs: @mut LinearMap<ty::t, @mut tydesc_info>,\n+     enum_sizes: @mut HashMap<ty::t, uint>,\n+     discrims: @mut HashMap<ast::def_id, ValueRef>,\n+     discrim_symbols: @mut HashMap<ast::node_id, ~str>,\n+     tydescs: @mut HashMap<ty::t, @mut tydesc_info>,\n      // Set when running emit_tydescs to enforce that no more tydescs are\n      // created.\n      finished_tydescs: @mut bool,\n      // Track mapping of external ids to local items imported for inlining\n-     external: @mut LinearMap<ast::def_id, Option<ast::node_id>>,\n+     external: @mut HashMap<ast::def_id, Option<ast::node_id>>,\n      // Cache instances of monomorphized functions\n-     monomorphized: @mut LinearMap<mono_id, ValueRef>,\n-     monomorphizing: @mut LinearMap<ast::def_id, uint>,\n+     monomorphized: @mut HashMap<mono_id, ValueRef>,\n+     monomorphizing: @mut HashMap<ast::def_id, uint>,\n      // Cache computed type parameter uses (see type_use.rs)\n-     type_use_cache: @mut LinearMap<ast::def_id, ~[type_use::type_uses]>,\n+     type_use_cache: @mut HashMap<ast::def_id, ~[type_use::type_uses]>,\n      // Cache generated vtables\n-     vtables: @mut LinearMap<mono_id, ValueRef>,\n+     vtables: @mut HashMap<mono_id, ValueRef>,\n      // Cache of constant strings,\n-     const_cstr_cache: @mut LinearMap<@~str, ValueRef>,\n+     const_cstr_cache: @mut HashMap<@~str, ValueRef>,\n \n      // Reverse-direction for const ptrs cast from globals.\n      // Key is an int, cast from a ValueRef holding a *T,\n@@ -198,24 +198,24 @@ pub struct CrateContext {\n      // when we ptrcast, and we have to ptrcast during translation\n      // of a [T] const because we form a slice, a [*T,int] pair, not\n      // a pointer to an LLVM array type.\n-     const_globals: @mut LinearMap<int, ValueRef>,\n+     const_globals: @mut HashMap<int, ValueRef>,\n \n      // Cache of emitted const values\n-     const_values: @mut LinearMap<ast::node_id, ValueRef>,\n+     const_values: @mut HashMap<ast::node_id, ValueRef>,\n \n      // Cache of external const values\n-     extern_const_values: @mut LinearMap<ast::def_id, ValueRef>,\n+     extern_const_values: @mut HashMap<ast::def_id, ValueRef>,\n \n-     module_data: @mut LinearMap<~str, ValueRef>,\n-     lltypes: @mut LinearMap<ty::t, TypeRef>,\n-     llsizingtypes: @mut LinearMap<ty::t, TypeRef>,\n-     adt_reprs: @mut LinearMap<ty::t, @adt::Repr>,\n+     module_data: @mut HashMap<~str, ValueRef>,\n+     lltypes: @mut HashMap<ty::t, TypeRef>,\n+     llsizingtypes: @mut HashMap<ty::t, TypeRef>,\n+     adt_reprs: @mut HashMap<ty::t, @adt::Repr>,\n      names: namegen,\n      next_addrspace: addrspace_gen,\n      symbol_hasher: @hash::State,\n-     type_hashcodes: @mut LinearMap<ty::t, @str>,\n-     type_short_names: @mut LinearMap<ty::t, ~str>,\n-     all_llvm_symbols: @mut LinearSet<~str>,\n+     type_hashcodes: @mut HashMap<ty::t, @str>,\n+     type_short_names: @mut HashMap<ty::t, ~str>,\n+     all_llvm_symbols: @mut HashSet<~str>,\n      tcx: ty::ctxt,\n      maps: astencode::Maps,\n      stats: @mut Stats,\n@@ -314,12 +314,12 @@ pub struct fn_ctxt_ {\n     loop_ret: Option<(ValueRef, ValueRef)>,\n \n     // Maps arguments to allocas created for them in llallocas.\n-    llargs: @mut LinearMap<ast::node_id, local_val>,\n+    llargs: @mut HashMap<ast::node_id, local_val>,\n     // Maps the def_ids for local variables to the allocas created for\n     // them in llallocas.\n-    lllocals: @mut LinearMap<ast::node_id, local_val>,\n+    lllocals: @mut HashMap<ast::node_id, local_val>,\n     // Same as above, but for closure upvars\n-    llupvars: @mut LinearMap<ast::node_id, ValueRef>,\n+    llupvars: @mut HashMap<ast::node_id, ValueRef>,\n \n     // The node_id of the function, or -1 if it doesn't correspond to\n     // a user-defined function."}, {"sha": "277d529c8462fbd758504e6c2d2c0d1d93db7aa6", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -20,7 +20,7 @@ use middle::trans;\n use middle::ty;\n use util::ppaux::ty_to_str;\n \n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n use core::libc;\n use core::option;\n use core::sys;\n@@ -106,7 +106,7 @@ pub struct DebugContext {\n \n pub fn mk_ctxt(+crate: ~str, intr: @ident_interner) -> DebugContext {\n     DebugContext {\n-        llmetadata: @mut LinearMap::new(),\n+        llmetadata: @mut HashMap::new(),\n         names: new_namegen(intr),\n         crate_file: crate\n     }\n@@ -151,7 +151,7 @@ struct RetvalMetadata {\n     id: ast::node_id\n }\n \n-type metadata_cache = @mut LinearMap<int, ~[debug_metadata]>;\n+type metadata_cache = @mut HashMap<int, ~[debug_metadata]>;\n \n enum debug_metadata {\n     file_metadata(@Metadata<FileMetadata>),"}, {"sha": "5afdd1b027188d1c73f2130439a746cb43011314", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -153,7 +153,7 @@ use util::common::indenter;\n use util::ppaux::ty_to_str;\n \n use core::cast::transmute;\n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n use syntax::print::pprust::{expr_to_str};\n use syntax::ast;\n use syntax::codemap;\n@@ -1091,7 +1091,7 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n     };\n \n     fn take_local(bcx: block,\n-                  table: &LinearMap<ast::node_id, local_val>,\n+                  table: &HashMap<ast::node_id, local_val>,\n                   nid: ast::node_id) -> Datum {\n         let (v, mode) = match table.find(&nid) {\n             Some(&local_mem(v)) => (v, ByRef),"}, {"sha": "9f9323bf9f788d435701b0e46318cd1a1bb1de7d", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -21,7 +21,7 @@ use middle::ty;\n use middle::typeck;\n \n use core::prelude::*;\n-use core::hashmap::LinearSet;\n+use core::hashmap::HashSet;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::ast_util::def_id_of_def;\n@@ -30,18 +30,18 @@ use syntax::codemap;\n use syntax::print::pprust::expr_to_str;\n use syntax::{visit, ast_map};\n \n-pub type map = @LinearSet<node_id>;\n+pub type map = @HashSet<node_id>;\n \n struct ctx<'self> {\n     exp_map2: resolve::ExportMap2,\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n-    rmap: &'self mut LinearSet<node_id>,\n+    rmap: &'self mut HashSet<node_id>,\n }\n \n pub fn find_reachable(crate_mod: &_mod, exp_map2: resolve::ExportMap2,\n                       tcx: ty::ctxt, method_map: typeck::method_map) -> map {\n-    let mut rmap = LinearSet::new();\n+    let mut rmap = HashSet::new();\n     {\n         let cx = ctx {\n             exp_map2: exp_map2,\n@@ -96,7 +96,7 @@ fn traverse_public_mod(cx: ctx, mod_id: node_id, m: &_mod) {\n \n fn traverse_public_item(cx: ctx, item: @item) {\n     // XXX: it shouldn't be necessary to do this\n-    let rmap: &mut LinearSet<node_id> = cx.rmap;\n+    let rmap: &mut HashSet<node_id> = cx.rmap;\n     if rmap.contains(&item.id) { return; }\n     rmap.insert(item.id);\n     match item.node {\n@@ -154,7 +154,7 @@ fn mk_ty_visitor() -> visit::vt<ctx> {\n \n fn traverse_ty<'a>(ty: @Ty, cx: ctx<'a>, v: visit::vt<ctx<'a>>) {\n     // XXX: it shouldn't be necessary to do this\n-    let rmap: &mut LinearSet<node_id> = cx.rmap;\n+    let rmap: &mut HashSet<node_id> = cx.rmap;\n     if rmap.contains(&ty.id) { return; }\n     rmap.insert(ty.id);\n "}, {"sha": "30b933061e215a70d3e13323d75a3f3d1559cf8a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -36,7 +36,7 @@ use core::result;\n use core::to_bytes;\n use core::uint;\n use core::vec;\n-use core::hashmap::{LinearMap, LinearSet};\n+use core::hashmap::{HashMap, HashSet};\n use std::smallintmap::SmallIntMap;\n use syntax::ast::*;\n use syntax::ast_util::{is_local, local_def};\n@@ -119,7 +119,7 @@ pub struct creader_cache_key {\n     len: uint\n }\n \n-type creader_cache = @mut LinearMap<creader_cache_key, t>;\n+type creader_cache = @mut HashMap<creader_cache_key, t>;\n \n impl to_bytes::IterBytes for creader_cache_key {\n     fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n@@ -210,7 +210,7 @@ pub enum AutoRefKind {\n // This is a map from ID of each implementation to the method info and trait\n // method ID of each of the default methods belonging to the trait that that\n // implementation implements.\n-pub type ProvidedMethodsMap = @mut LinearMap<def_id,@mut ~[@ProvidedMethodInfo]>;\n+pub type ProvidedMethodsMap = @mut HashMap<def_id,@mut ~[@ProvidedMethodInfo]>;\n \n // Stores the method info and definition ID of the associated trait method for\n // each instantiation of each provided method.\n@@ -233,7 +233,7 @@ pub type ctxt = @ctxt_;\n \n struct ctxt_ {\n     diag: @syntax::diagnostic::span_handler,\n-    interner: @mut LinearMap<intern_key, t_box>,\n+    interner: @mut HashMap<intern_key, t_box>,\n     next_id: @mut uint,\n     vecs_implicitly_copyable: bool,\n     legacy_modes: bool,\n@@ -253,43 +253,43 @@ struct ctxt_ {\n     // of this node.  This only applies to nodes that refer to entities\n     // parameterized by type parameters, such as generic fns, types, or\n     // other items.\n-    node_type_substs: @mut LinearMap<node_id, ~[t]>,\n+    node_type_substs: @mut HashMap<node_id, ~[t]>,\n \n     items: ast_map::map,\n-    intrinsic_defs: @mut LinearMap<ast::ident, (ast::def_id, t)>,\n+    intrinsic_defs: @mut HashMap<ast::ident, (ast::def_id, t)>,\n     freevars: freevars::freevar_map,\n     tcache: type_cache,\n     rcache: creader_cache,\n     ccache: constness_cache,\n-    short_names_cache: @mut LinearMap<t, @~str>,\n-    needs_unwind_cleanup_cache: @mut LinearMap<t, bool>,\n-    tc_cache: @mut LinearMap<uint, TypeContents>,\n-    ast_ty_to_ty_cache: @mut LinearMap<node_id, ast_ty_to_ty_cache_entry>,\n-    enum_var_cache: @mut LinearMap<def_id, @~[VariantInfo]>,\n-    trait_method_cache: @mut LinearMap<def_id, @~[method]>,\n-    ty_param_bounds: @mut LinearMap<ast::node_id, param_bounds>,\n-    inferred_modes: @mut LinearMap<ast::node_id, ast::mode>,\n-    adjustments: @mut LinearMap<ast::node_id, @AutoAdjustment>,\n-    normalized_cache: @mut LinearMap<t, t>,\n+    short_names_cache: @mut HashMap<t, @~str>,\n+    needs_unwind_cleanup_cache: @mut HashMap<t, bool>,\n+    tc_cache: @mut HashMap<uint, TypeContents>,\n+    ast_ty_to_ty_cache: @mut HashMap<node_id, ast_ty_to_ty_cache_entry>,\n+    enum_var_cache: @mut HashMap<def_id, @~[VariantInfo]>,\n+    trait_method_cache: @mut HashMap<def_id, @~[method]>,\n+    ty_param_bounds: @mut HashMap<ast::node_id, param_bounds>,\n+    inferred_modes: @mut HashMap<ast::node_id, ast::mode>,\n+    adjustments: @mut HashMap<ast::node_id, @AutoAdjustment>,\n+    normalized_cache: @mut HashMap<t, t>,\n     lang_items: middle::lang_items::LanguageItems,\n     // A mapping from an implementation ID to the method info and trait\n     // method ID of the provided (a.k.a. default) methods in the traits that\n     // that implementation implements.\n     provided_methods: ProvidedMethodsMap,\n-    provided_method_sources: @mut LinearMap<ast::def_id, ProvidedMethodSource>,\n-    supertraits: @mut LinearMap<ast::def_id, @~[InstantiatedTraitRef]>,\n+    provided_method_sources: @mut HashMap<ast::def_id, ProvidedMethodSource>,\n+    supertraits: @mut HashMap<ast::def_id, @~[InstantiatedTraitRef]>,\n \n     // A mapping from the def ID of an enum or struct type to the def ID\n     // of the method that implements its destructor. If the type is not\n     // present in this map, it does not have a destructor. This map is\n     // populated during the coherence phase of typechecking.\n-    destructor_for_type: @mut LinearMap<ast::def_id, ast::def_id>,\n+    destructor_for_type: @mut HashMap<ast::def_id, ast::def_id>,\n \n     // A method will be in this list if and only if it is a destructor.\n-    destructors: @mut LinearSet<ast::def_id>,\n+    destructors: @mut HashSet<ast::def_id>,\n \n     // Maps a trait onto a mapping from self-ty to impl\n-    trait_impls: @mut LinearMap<ast::def_id, @mut LinearMap<t, @Impl>>\n+    trait_impls: @mut HashMap<ast::def_id, @mut HashMap<t, @Impl>>\n }\n \n enum tbox_flag {\n@@ -771,18 +771,18 @@ pub struct ty_param_substs_and_ty {\n     ty: ty::t\n }\n \n-type type_cache = @mut LinearMap<ast::def_id, ty_param_bounds_and_ty>;\n+type type_cache = @mut HashMap<ast::def_id, ty_param_bounds_and_ty>;\n \n-type constness_cache = @mut LinearMap<ast::def_id, const_eval::constness>;\n+type constness_cache = @mut HashMap<ast::def_id, const_eval::constness>;\n \n pub type node_type_table = @mut SmallIntMap<t>;\n \n fn mk_rcache() -> creader_cache {\n-    return @mut LinearMap::new();\n+    return @mut HashMap::new();\n }\n \n-pub fn new_ty_hash<V:Copy>() -> @mut LinearMap<t, V> {\n-    @mut LinearMap::new()\n+pub fn new_ty_hash<V:Copy>() -> @mut HashMap<t, V> {\n+    @mut HashMap::new()\n }\n \n pub fn mk_ctxt(s: session::Session,\n@@ -809,7 +809,7 @@ pub fn mk_ctxt(s: session::Session,\n                        lint::vecs_implicitly_copyable) == allow;\n     @ctxt_ {\n         diag: s.diagnostic(),\n-        interner: @mut LinearMap::new(),\n+        interner: @mut HashMap::new(),\n         next_id: @mut 0,\n         vecs_implicitly_copyable: vecs_implicitly_copyable,\n         legacy_modes: legacy_modes,\n@@ -819,30 +819,30 @@ pub fn mk_ctxt(s: session::Session,\n         region_map: region_map,\n         region_paramd_items: region_paramd_items,\n         node_types: @mut SmallIntMap::new(),\n-        node_type_substs: @mut LinearMap::new(),\n+        node_type_substs: @mut HashMap::new(),\n         items: amap,\n-        intrinsic_defs: @mut LinearMap::new(),\n+        intrinsic_defs: @mut HashMap::new(),\n         freevars: freevars,\n-        tcache: @mut LinearMap::new(),\n+        tcache: @mut HashMap::new(),\n         rcache: mk_rcache(),\n-        ccache: @mut LinearMap::new(),\n+        ccache: @mut HashMap::new(),\n         short_names_cache: new_ty_hash(),\n         needs_unwind_cleanup_cache: new_ty_hash(),\n-        tc_cache: @mut LinearMap::new(),\n-        ast_ty_to_ty_cache: @mut LinearMap::new(),\n-        enum_var_cache: @mut LinearMap::new(),\n-        trait_method_cache: @mut LinearMap::new(),\n-        ty_param_bounds: @mut LinearMap::new(),\n-        inferred_modes: @mut LinearMap::new(),\n-        adjustments: @mut LinearMap::new(),\n+        tc_cache: @mut HashMap::new(),\n+        ast_ty_to_ty_cache: @mut HashMap::new(),\n+        enum_var_cache: @mut HashMap::new(),\n+        trait_method_cache: @mut HashMap::new(),\n+        ty_param_bounds: @mut HashMap::new(),\n+        inferred_modes: @mut HashMap::new(),\n+        adjustments: @mut HashMap::new(),\n         normalized_cache: new_ty_hash(),\n         lang_items: lang_items,\n-        provided_methods: @mut LinearMap::new(),\n-        provided_method_sources: @mut LinearMap::new(),\n-        supertraits: @mut LinearMap::new(),\n-        destructor_for_type: @mut LinearMap::new(),\n-        destructors: @mut LinearSet::new(),\n-        trait_impls: @mut LinearMap::new()\n+        provided_methods: @mut HashMap::new(),\n+        provided_method_sources: @mut HashMap::new(),\n+        supertraits: @mut HashMap::new(),\n+        destructor_for_type: @mut HashMap::new(),\n+        destructors: @mut HashSet::new(),\n+        trait_impls: @mut HashMap::new()\n      }\n }\n \n@@ -1620,15 +1620,15 @@ pub fn type_needs_unwind_cleanup(cx: ctxt, ty: t) -> bool {\n       None => ()\n     }\n \n-    let mut tycache = LinearSet::new();\n+    let mut tycache = HashSet::new();\n     let needs_unwind_cleanup =\n         type_needs_unwind_cleanup_(cx, ty, &mut tycache, false);\n     cx.needs_unwind_cleanup_cache.insert(ty, needs_unwind_cleanup);\n     return needs_unwind_cleanup;\n }\n \n fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n-                              tycache: &mut LinearSet<t>,\n+                              tycache: &mut HashSet<t>,\n                               encountered_box: bool) -> bool {\n \n     // Prevent infinite recursion\n@@ -1855,14 +1855,14 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         None => {}\n     }\n \n-    let mut cache = LinearMap::new();\n+    let mut cache = HashMap::new();\n     let result = tc_ty(cx, ty, &mut cache);\n     cx.tc_cache.insert(ty_id, result);\n     return result;\n \n     fn tc_ty(cx: ctxt,\n              ty: t,\n-             cache: &mut LinearMap<uint, TypeContents>) -> TypeContents\n+             cache: &mut HashMap<uint, TypeContents>) -> TypeContents\n     {\n         // Subtle: Note that we are *not* using cx.tc_cache here but rather a\n         // private cache for this walk.  This is needed in the case of cyclic\n@@ -2054,7 +2054,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n \n     fn tc_mt(cx: ctxt,\n              mt: mt,\n-             cache: &mut LinearMap<uint, TypeContents>) -> TypeContents\n+             cache: &mut HashMap<uint, TypeContents>) -> TypeContents\n     {\n         let mc = if mt.mutbl == m_mutbl {TC_MUTABLE} else {TC_NONE};\n         mc + tc_ty(cx, mt.ty, cache)\n@@ -3258,7 +3258,7 @@ pub fn occurs_check(tcx: ctxt, sp: span, vid: TyVid, rt: t) {\n \n // Maintains a little union-set tree for inferred modes.  `canon()` returns\n // the current head value for `m0`.\n-fn canon<T:Copy + cmp::Eq>(tbl: &mut LinearMap<ast::node_id, ast::inferable<T>>,\n+fn canon<T:Copy + cmp::Eq>(tbl: &mut HashMap<ast::node_id, ast::inferable<T>>,\n                          +m0: ast::inferable<T>) -> ast::inferable<T> {\n     match m0 {\n         ast::infer(id) => {\n@@ -4286,7 +4286,7 @@ pub fn iter_bound_traits_and_supertraits(tcx: ctxt,\n             }\n         };\n \n-        let mut supertrait_map = LinearMap::new();\n+        let mut supertrait_map = HashMap::new();\n         let mut seen_def_ids = ~[];\n         let mut i = 0;\n         let trait_ty_id = ty_to_def_id(bound_trait_ty).expect("}, {"sha": "f2d0ef22970b40571e00a5096f489f705cd92290", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -18,7 +18,7 @@ use middle::typeck::check::{instantiate_path, lookup_def};\n use middle::typeck::check::{structure_of, valid_range_bounds};\n use middle::typeck::require_same_types;\n \n-use core::hashmap::{LinearMap, LinearSet};\n+use core::hashmap::{HashMap, HashSet};\n use core::vec;\n use syntax::ast;\n use syntax::ast_util;\n@@ -228,7 +228,7 @@ pub fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n /// `class_fields` describes the type of each field of the struct.\n /// `class_id` is the ID of the struct.\n /// `substitutions` are the type substitutions applied to this struct type\n-/// (e.g. K,V in LinearMap<K,V>).\n+/// (e.g. K,V in HashMap<K,V>).\n /// `etc` is true if the pattern said '...' and false otherwise.\n pub fn check_struct_pat_fields(pcx: pat_ctxt,\n                                span: span,\n@@ -241,13 +241,13 @@ pub fn check_struct_pat_fields(pcx: pat_ctxt,\n     let tcx = pcx.fcx.ccx.tcx;\n \n     // Index the class fields.\n-    let mut field_map = LinearMap::new();\n+    let mut field_map = HashMap::new();\n     for class_fields.eachi |i, class_field| {\n         field_map.insert(class_field.ident, i);\n     }\n \n     // Typecheck each field.\n-    let mut found_fields = LinearSet::new();\n+    let mut found_fields = HashSet::new();\n     for fields.each |field| {\n         match field_map.find(&field.ident) {\n             Some(&index) => {"}, {"sha": "3b01f0e839ab9ae63370b7e74064f499723716cd", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -95,7 +95,7 @@ use middle::typeck::{method_self, method_static, method_trait, method_super};\n use util::common::indenter;\n use util::ppaux::expr_repr;\n \n-use core::hashmap::LinearSet;\n+use core::hashmap::HashSet;\n use core::result;\n use core::uint;\n use core::vec;\n@@ -131,7 +131,7 @@ pub fn lookup(\n         check_traits: CheckTraitsFlag,      // Whether we check traits only.\n         autoderef_receiver: AutoderefReceiverFlag)\n      -> Option<method_map_entry> {\n-    let mut impl_dups = LinearSet::new();\n+    let mut impl_dups = HashSet::new();\n     let lcx = LookupContext {\n         fcx: fcx,\n         expr: expr,\n@@ -159,7 +159,7 @@ pub struct LookupContext<'self> {\n     callee_id: node_id,\n     m_name: ast::ident,\n     supplied_tps: &'self [ty::t],\n-    impl_dups: &'self mut LinearSet<def_id>,\n+    impl_dups: &'self mut HashSet<def_id>,\n     inherent_candidates: @mut ~[Candidate],\n     extension_candidates: @mut ~[Candidate],\n     deref_args: check::DerefArgs,"}, {"sha": "eba207f978b6e88e26d9ac0efc494b2d09a89e9f", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -110,7 +110,7 @@ use util::common::{block_query, indenter, loop_query};\n use util::ppaux::{bound_region_to_str, expr_repr, pat_repr};\n use util::ppaux;\n \n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n use core::ptr;\n use core::result::{Result, Ok, Err};\n use core::result;\n@@ -158,12 +158,12 @@ pub struct SelfInfo {\n /// share the inherited fields.\n pub struct inherited {\n     infcx: @mut infer::InferCtxt,\n-    locals: @mut LinearMap<ast::node_id, ty::t>,\n+    locals: @mut HashMap<ast::node_id, ty::t>,\n \n     // Temporary tables:\n-    node_types: @mut LinearMap<ast::node_id, ty::t>,\n-    node_type_substs: @mut LinearMap<ast::node_id, ty::substs>,\n-    adjustments: @mut LinearMap<ast::node_id, @ty::AutoAdjustment>,\n+    node_types: @mut HashMap<ast::node_id, ty::t>,\n+    node_type_substs: @mut HashMap<ast::node_id, ty::substs>,\n+    adjustments: @mut HashMap<ast::node_id, @ty::AutoAdjustment>,\n     method_map: method_map,\n     vtable_map: vtable_map,\n }\n@@ -220,12 +220,12 @@ pub struct FnCtxt {\n pub fn blank_inherited(ccx: @mut CrateCtxt) -> @inherited {\n     @inherited {\n         infcx: infer::new_infer_ctxt(ccx.tcx),\n-        locals: @mut LinearMap::new(),\n-        node_types: @mut LinearMap::new(),\n-        node_type_substs: @mut LinearMap::new(),\n-        adjustments: @mut LinearMap::new(),\n-        method_map: @mut LinearMap::new(),\n-        vtable_map: @mut LinearMap::new(),\n+        locals: @mut HashMap::new(),\n+        node_types: @mut HashMap::new(),\n+        node_type_substs: @mut HashMap::new(),\n+        adjustments: @mut HashMap::new(),\n+        method_map: @mut HashMap::new(),\n+        vtable_map: @mut HashMap::new(),\n     }\n }\n \n@@ -504,7 +504,7 @@ pub fn check_method(ccx: @mut CrateCtxt,\n \n pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n                                  fields: ~[(ast::ident, span)]) {\n-    let mut field_names = LinearMap::new();\n+    let mut field_names = HashMap::new();\n \n     for fields.each |p| {\n         let (id, sp) = *p;\n@@ -1761,7 +1761,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                       check_completeness: bool)  {\n         let tcx = fcx.ccx.tcx;\n \n-        let mut class_field_map = LinearMap::new();\n+        let mut class_field_map = HashMap::new();\n         let mut fields_found = 0;\n         for field_types.each |field| {\n             // XXX: Check visibility here."}, {"sha": "51f54d21ec4afe329f32e94757c67858bbb403b9", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -28,7 +28,7 @@ use core::result::{Ok, Err};\n use core::result;\n use core::uint;\n use core::vec;\n-use core::hashmap::LinearSet;\n+use core::hashmap::HashSet;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::span;\n@@ -234,7 +234,7 @@ pub fn lookup_vtable(vcx: &VtableContext,\n         _ => {\n             let mut found = ~[];\n \n-            let mut impls_seen = LinearSet::new();\n+            let mut impls_seen = HashSet::new();\n \n             match vcx.ccx.coherence_info.extension_methods.find(&trait_id) {\n                 None => {"}, {"sha": "466cb8ed54f2b83552cfe910bdb406d8d36d380b", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -53,7 +53,7 @@ use syntax::visit::{visit_mod};\n use util::ppaux::ty_to_str;\n \n use core::result::Ok;\n-use core::hashmap::{LinearMap, LinearSet};\n+use core::hashmap::{HashMap, HashSet};\n use core::uint;\n \n pub struct UniversalQuantificationResult {\n@@ -164,17 +164,17 @@ pub fn method_to_MethodInfo(ast_method: @method) -> @MethodInfo {\n pub struct CoherenceInfo {\n     // Contains implementations of methods that are inherent to a type.\n     // Methods in these implementations don't need to be exported.\n-    inherent_methods: @mut LinearMap<def_id, @mut ~[@Impl]>,\n+    inherent_methods: @mut HashMap<def_id, @mut ~[@Impl]>,\n \n     // Contains implementations of methods associated with a trait. For these,\n     // the associated trait must be imported at the call site.\n-    extension_methods: @mut LinearMap<def_id, @mut ~[@Impl]>,\n+    extension_methods: @mut HashMap<def_id, @mut ~[@Impl]>,\n }\n \n pub fn CoherenceInfo() -> CoherenceInfo {\n     CoherenceInfo {\n-        inherent_methods: @mut LinearMap::new(),\n-        extension_methods: @mut LinearMap::new(),\n+        inherent_methods: @mut HashMap::new(),\n+        extension_methods: @mut HashMap::new(),\n     }\n }\n \n@@ -183,7 +183,7 @@ pub fn CoherenceChecker(crate_context: @mut CrateCtxt) -> CoherenceChecker {\n         crate_context: crate_context,\n         inference_context: new_infer_ctxt(crate_context.tcx),\n \n-        base_type_def_ids: @mut LinearMap::new(),\n+        base_type_def_ids: @mut HashMap::new(),\n     }\n }\n \n@@ -194,7 +194,7 @@ pub struct CoherenceChecker {\n     // A mapping from implementations to the corresponding base type\n     // definition ID.\n \n-    base_type_def_ids: @mut LinearMap<def_id,def_id>,\n+    base_type_def_ids: @mut HashMap<def_id,def_id>,\n }\n \n pub impl CoherenceChecker {\n@@ -471,7 +471,7 @@ pub impl CoherenceChecker {\n                ty_to_str(self.crate_context.tcx, self_t));\n         match self.crate_context.tcx.trait_impls.find(&trait_t) {\n             None => {\n-                let m = @mut LinearMap::new();\n+                let m = @mut HashMap::new();\n                 m.insert(self_t, the_impl);\n                 self.crate_context.tcx.trait_impls.insert(trait_t, m);\n             }\n@@ -501,7 +501,7 @@ pub impl CoherenceChecker {\n             f: &fn(x: &ty::method) -> bool) {\n         // Make a list of all the names of the provided methods.\n         // XXX: This is horrible.\n-        let mut provided_method_idents = LinearSet::new();\n+        let mut provided_method_idents = HashSet::new();\n         let tcx = self.crate_context.tcx;\n         for ty::provided_trait_methods(tcx, trait_did).each |ident| {\n             provided_method_idents.insert(*ident);\n@@ -705,7 +705,7 @@ pub impl CoherenceChecker {\n \n         let tcx = self.crate_context.tcx;\n \n-        let mut provided_names = LinearSet::new();\n+        let mut provided_names = HashSet::new();\n         // Implemented methods\n         for uint::range(0, all_methods.len()) |i| {\n             provided_names.insert(all_methods[i].ident);\n@@ -812,7 +812,7 @@ pub impl CoherenceChecker {\n \n     // External crate handling\n \n-    fn add_impls_for_module(&self, impls_seen: &mut LinearSet<def_id>,\n+    fn add_impls_for_module(&self, impls_seen: &mut HashSet<def_id>,\n                             crate_store: @mut CStore,\n                             module_def_id: def_id) {\n         let implementations = get_impls_for_mod(crate_store,\n@@ -931,7 +931,7 @@ pub impl CoherenceChecker {\n     // Adds implementations and traits from external crates to the coherence\n     // info.\n     fn add_external_crates(&self) {\n-        let mut impls_seen = LinearSet::new();\n+        let mut impls_seen = HashSet::new();\n \n         let crate_store = self.crate_context.tcx.sess.cstore;\n         do iter_crate_data(crate_store) |crate_number, _crate_metadata| {"}, {"sha": "98d12bea6a4297619fb659fab9298def2ec0e597", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -548,7 +548,7 @@ use util::common::indenter;\n use util::ppaux::note_and_explain_region;\n \n use core::cell::{Cell, empty_cell};\n-use core::hashmap::{LinearMap, LinearSet};\n+use core::hashmap::{HashMap, HashSet};\n use core::result::{Err, Ok};\n use core::to_bytes;\n use core::uint;\n@@ -600,12 +600,12 @@ enum CombineMapType {\n     Lub, Glb\n }\n \n-type CombineMap = LinearMap<TwoRegions, RegionVid>;\n+type CombineMap = HashMap<TwoRegions, RegionVid>;\n \n pub struct RegionVarBindings {\n     tcx: ty::ctxt,\n     var_spans: ~[span],\n-    constraints: LinearMap<Constraint, span>,\n+    constraints: HashMap<Constraint, span>,\n     lubs: CombineMap,\n     glbs: CombineMap,\n     skolemization_count: uint,\n@@ -632,9 +632,9 @@ pub fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n         tcx: tcx,\n         var_spans: ~[],\n         values: empty_cell(),\n-        constraints: LinearMap::new(),\n-        lubs: LinearMap::new(),\n-        glbs: LinearMap::new(),\n+        constraints: HashMap::new(),\n+        lubs: HashMap::new(),\n+        glbs: HashMap::new(),\n         skolemization_count: 0,\n         bound_count: 0,\n         undo_log: ~[]\n@@ -1194,7 +1194,7 @@ struct SpannedRegion {\n     span: span,\n }\n \n-type TwoRegionsMap = LinearSet<TwoRegions>;\n+type TwoRegionsMap = HashSet<TwoRegions>;\n \n pub impl RegionVarBindings {\n     fn infer_variable_values(&mut self) -> ~[GraphNodeValue] {\n@@ -1423,7 +1423,7 @@ pub impl RegionVarBindings {\n         &mut self,\n         graph: &Graph) -> ~[GraphNodeValue]\n     {\n-        let mut dup_map = LinearSet::new();\n+        let mut dup_map = HashSet::new();\n         graph.nodes.mapi(|idx, node| {\n             match node.value {\n                 Value(_) => {\n@@ -1598,7 +1598,7 @@ pub impl RegionVarBindings {\n                                 orig_node_idx: RegionVid,\n                                 dir: Direction)\n                              -> ~[SpannedRegion] {\n-        let mut set = LinearSet::new();\n+        let mut set = HashSet::new();\n         let mut stack = ~[orig_node_idx];\n         set.insert(orig_node_idx.to_uint());\n         let mut result = ~[];"}, {"sha": "d829b0d2a0d51c5027165e97f1b282e61ca5b0af", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -55,7 +55,7 @@ use middle::ty;\n use util::common::time;\n use util::ppaux;\n \n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n use core::result;\n use core::vec;\n use std::list::List;\n@@ -129,7 +129,7 @@ pub struct method_map_entry {\n \n // maps from an expression id that corresponds to a method call to the details\n // of the method to be invoked\n-pub type method_map = @mut LinearMap<ast::node_id, method_map_entry>;\n+pub type method_map = @mut HashMap<ast::node_id, method_map_entry>;\n \n // Resolutions for bounds of all parameters, left to right, for a given path.\n pub type vtable_res = @~[vtable_origin];\n@@ -170,7 +170,7 @@ pub impl vtable_origin {\n     }\n }\n \n-pub type vtable_map = @mut LinearMap<ast::node_id, vtable_res>;\n+pub type vtable_map = @mut HashMap<ast::node_id, vtable_res>;\n \n pub struct CrateCtxt {\n     // A mapping from method call sites to traits that have that method.\n@@ -342,8 +342,8 @@ pub fn check_crate(tcx: ty::ctxt,\n     let time_passes = tcx.sess.time_passes();\n     let ccx = @mut CrateCtxt {\n         trait_map: trait_map,\n-        method_map: @mut LinearMap::new(),\n-        vtable_map: @mut LinearMap::new(),\n+        method_map: @mut HashMap::new(),\n+        vtable_map: @mut HashMap::new(),\n         coherence_info: @coherence::CoherenceInfo(),\n         tcx: tcx\n     };"}, {"sha": "30152c22845743897eaf4529d33f024221c1a2c7", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -14,7 +14,7 @@ use syntax::ast;\n use syntax::codemap::{span};\n use syntax::visit;\n \n-use core::hashmap::LinearSet;\n+use core::hashmap::HashSet;\n use core::str;\n use std;\n \n@@ -114,7 +114,7 @@ pub fn pluralize(n: uint, +s: ~str) -> ~str {\n }\n \n // A set of node IDs (used to keep track of which node IDs are for statements)\n-pub type stmt_set = @mut LinearSet<ast::node_id>;\n+pub type stmt_set = @mut HashSet<ast::node_id>;\n \n //\n // Local Variables:"}, {"sha": "bf1301868af54fe062649e7df6e76efa69c5f8da", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -28,7 +28,7 @@ extern mod syntax(vers = \"0.6\");\n \n use core::*;\n use core::container::Map;\n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n use core::io::WriterUtil;\n use rustc::driver::{driver, session};\n use rustc::metadata::filesearch;\n@@ -253,7 +253,7 @@ impl PackageScript {\n struct Ctx {\n     cfgs: ~[~str],\n     json: bool,\n-    dep_cache: @mut LinearMap<~str, bool>\n+    dep_cache: @mut HashMap<~str, bool>\n }\n \n impl Ctx {\n@@ -483,14 +483,14 @@ impl Ctx {\n         if self.json {\n             match PackageScript::parse(&os::getcwd()) {\n                 result::Ok(script) => {\n-                    let mut map = ~LinearMap::new();\n+                    let mut map = ~HashMap::new();\n \n                     map.insert(~\"id\", json::String(script.id));\n                     map.insert(~\"name\", json::String(script.name));\n                     map.insert(~\"vers\", json::String(script.vers.to_str()));\n                     map.insert(~\"deps\", json::List(do script.deps.map |&dep| {\n                         let (url, target) = dep;\n-                        let mut inner = ~LinearMap::new();\n+                        let mut inner = ~HashMap::new();\n \n                         inner.insert(~\"url\", json::String(url));\n \n@@ -921,7 +921,7 @@ pub fn main() {\n     Ctx {\n         cfgs: cfgs,\n         json: json,\n-        dep_cache: @mut LinearMap::new()\n+        dep_cache: @mut HashMap::new()\n     }.run(cmd, args);\n }\n "}, {"sha": "9d3751c3de297e519fc30231ce5ffb58ce5be253", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -10,7 +10,7 @@\n \n use core::*;\n use core::hash::Streaming;\n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n use rustc::driver::{driver, session};\n use rustc::metadata::filesearch;\n use std::getopts::groups::getopts;\n@@ -337,7 +337,7 @@ fn _add_pkg(packages: ~[json::Json], pkg: &Package) -> ~[json::Json] {\n         }\n     }\n \n-    let mut map = ~LinearMap::new();\n+    let mut map = ~HashMap::new();\n \n     map.insert(~\"id\", json::String(pkg.id));\n     map.insert(~\"vers\", json::String(pkg.vers.to_str()));"}, {"sha": "f426b74736ad3a44950111b553139d1ce045ea96", "filename": "src/libstd/json.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -16,7 +16,7 @@\n \n use core::prelude::*;\n use core::io::{WriterUtil, ReaderUtil};\n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n \n use serialize::Encodable;\n use serialize;\n@@ -33,7 +33,7 @@ pub enum Json {\n }\n \n pub type List = ~[Json];\n-pub type Object = LinearMap<~str, Json>;\n+pub type Object = HashMap<~str, Json>;\n \n #[deriving(Eq)]\n pub struct Error {\n@@ -677,7 +677,7 @@ priv impl Parser {\n         self.bump();\n         self.parse_whitespace();\n \n-        let mut values = ~LinearMap::new();\n+        let mut values = ~HashMap::new();\n \n         if self.ch == '}' {\n           self.bump();\n@@ -1127,9 +1127,9 @@ impl<A:ToJson> ToJson for ~[A] {\n     fn to_json(&self) -> Json { List(self.map(|elt| elt.to_json())) }\n }\n \n-impl<A:ToJson + Copy> ToJson for LinearMap<~str, A> {\n+impl<A:ToJson + Copy> ToJson for HashMap<~str, A> {\n     fn to_json(&self) -> Json {\n-        let mut d = LinearMap::new();\n+        let mut d = HashMap::new();\n         for self.each |&(key, value)| {\n             d.insert(copy *key, value.to_json());\n         }\n@@ -1161,7 +1161,7 @@ mod tests {\n     use super::*;\n \n     use core::prelude::*;\n-    use core::hashmap::LinearMap;\n+    use core::hashmap::HashMap;\n \n     use std::serialize::Decodable;\n \n@@ -1190,7 +1190,7 @@ mod tests {\n     }\n \n     fn mk_object(items: &[(~str, Json)]) -> Json {\n-        let mut d = ~LinearMap::new();\n+        let mut d = ~HashMap::new();\n \n         for items.each |item| {\n             match *item {\n@@ -1755,7 +1755,7 @@ mod tests {\n     fn test_decode_map() {\n         let s = ~\"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": [\\\"Frog\\\", \\\"Henry\\\", 349]}\";\n         let decoder = Decoder(from_str(s).unwrap());\n-        let mut map: LinearMap<~str, Animal> = Decodable::decode(&decoder);\n+        let mut map: HashMap<~str, Animal> = Decodable::decode(&decoder);\n \n         assert_eq!(map.pop(&~\"a\"), Some(Dog));\n         assert_eq!(map.pop(&~\"b\"), Some(Frog(~\"Henry\", 349)));"}, {"sha": "81598f17aed161bca2859dec8e9455418735e838", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -17,7 +17,7 @@ use core::from_str::FromStr;\n use core::io::{Reader, ReaderUtil};\n use core::io;\n use core::prelude::*;\n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n use core::str;\n use core::to_bytes::IterBytes;\n use core::to_bytes;\n@@ -212,7 +212,7 @@ fn encode_plus(s: &str) -> ~str {\n /**\n  * Encode a hashmap to the 'application/x-www-form-urlencoded' media type.\n  */\n-pub fn encode_form_urlencoded(m: &LinearMap<~str, ~[~str]>) -> ~str {\n+pub fn encode_form_urlencoded(m: &HashMap<~str, ~[~str]>) -> ~str {\n     let mut out = ~\"\";\n     let mut first = true;\n \n@@ -238,9 +238,9 @@ pub fn encode_form_urlencoded(m: &LinearMap<~str, ~[~str]>) -> ~str {\n  * Decode a string encoded with the 'application/x-www-form-urlencoded' media\n  * type into a hashmap.\n  */\n-pub fn decode_form_urlencoded(s: &[u8]) -> LinearMap<~str, ~[~str]> {\n+pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, ~[~str]> {\n     do io::with_bytes_reader(s) |rdr| {\n-        let mut m = LinearMap::new();\n+        let mut m = HashMap::new();\n         let mut key = ~\"\";\n         let mut value = ~\"\";\n         let mut parsing_key = true;\n@@ -818,7 +818,7 @@ mod tests {\n \n     use net_url::*;\n \n-    use core::hashmap::LinearMap;\n+    use core::hashmap::HashMap;\n \n     #[test]\n     pub fn test_url_parse() {\n@@ -1053,18 +1053,18 @@ mod tests {\n \n     #[test]\n     pub fn test_encode_form_urlencoded() {\n-        let mut m = LinearMap::new();\n+        let mut m = HashMap::new();\n         assert!(encode_form_urlencoded(&m) == ~\"\");\n \n         m.insert(~\"\", ~[]);\n         m.insert(~\"foo\", ~[]);\n         assert!(encode_form_urlencoded(&m) == ~\"\");\n \n-        let mut m = LinearMap::new();\n+        let mut m = HashMap::new();\n         m.insert(~\"foo\", ~[~\"bar\", ~\"123\"]);\n         assert!(encode_form_urlencoded(&m) == ~\"foo=bar&foo=123\");\n \n-        let mut m = LinearMap::new();\n+        let mut m = HashMap::new();\n         m.insert(~\"foo bar\", ~[~\"abc\", ~\"12 = 34\"]);\n         assert!(encode_form_urlencoded(&m) ==\n             ~\"foo+bar=abc&foo+bar=12+%3D+34\");"}, {"sha": "e1ab59fb2b3aecaf793aedd84b9d23450b63a3e5", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -17,7 +17,7 @@ Core encoding and decoding interfaces.\n #[forbid(non_camel_case_types)];\n \n use core::prelude::*;\n-use core::hashmap::{LinearMap, LinearSet};\n+use core::hashmap::{HashMap, HashSet};\n use core::trie::{TrieMap, TrieSet};\n use deque::Deque;\n use dlist::DList;\n@@ -591,7 +591,7 @@ impl<\n     E: Encoder,\n     K: Encodable<E> + Hash + IterBytes + Eq,\n     V: Encodable<E>\n-> Encodable<E> for LinearMap<K, V> {\n+> Encodable<E> for HashMap<K, V> {\n     fn encode(&self, e: &E) {\n         do e.emit_map(self.len()) {\n             let mut i = 0;\n@@ -608,10 +608,10 @@ impl<\n     D: Decoder,\n     K: Decodable<D> + Hash + IterBytes + Eq,\n     V: Decodable<D>\n-> Decodable<D> for LinearMap<K, V> {\n-    fn decode(d: &D) -> LinearMap<K, V> {\n+> Decodable<D> for HashMap<K, V> {\n+    fn decode(d: &D) -> HashMap<K, V> {\n         do d.read_map |len| {\n-            let mut map = LinearMap::with_capacity(len);\n+            let mut map = HashMap::with_capacity(len);\n             for uint::range(0, len) |i| {\n                 let key = d.read_map_elt_key(i, || Decodable::decode(d));\n                 let val = d.read_map_elt_val(i, || Decodable::decode(d));\n@@ -625,7 +625,7 @@ impl<\n impl<\n     S: Encoder,\n     T: Encodable<S> + Hash + IterBytes + Eq\n-> Encodable<S> for LinearSet<T> {\n+> Encodable<S> for HashSet<T> {\n     fn encode(&self, s: &S) {\n         do s.emit_seq(self.len()) {\n             let mut i = 0;\n@@ -640,10 +640,10 @@ impl<\n impl<\n     D: Decoder,\n     T: Decodable<D> + Hash + IterBytes + Eq\n-> Decodable<D> for LinearSet<T> {\n-    fn decode(d: &D) -> LinearSet<T> {\n+> Decodable<D> for HashSet<T> {\n+    fn decode(d: &D) -> HashSet<T> {\n         do d.read_seq |len| {\n-            let mut set = LinearSet::with_capacity(len);\n+            let mut set = HashSet::with_capacity(len);\n             for uint::range(0, len) |i| {\n                 set.insert(d.read_seq_elt(i, || Decodable::decode(d)));\n             }"}, {"sha": "3e494d0236e9716c86104d787e97b39a8fc623a3", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -24,7 +24,7 @@ use core::pipes::recv;\n use core::prelude::*;\n use core::result;\n use core::run;\n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n use core::task;\n use core::to_bytes;\n \n@@ -136,10 +136,10 @@ pub impl WorkKey {\n     }\n }\n \n-struct WorkMap(LinearMap<WorkKey, ~str>);\n+struct WorkMap(HashMap<WorkKey, ~str>);\n \n impl WorkMap {\n-    fn new() -> WorkMap { WorkMap(LinearMap::new()) }\n+    fn new() -> WorkMap { WorkMap(HashMap::new()) }\n }\n \n impl<S:Encoder> Encodable<S> for WorkMap {\n@@ -166,7 +166,7 @@ impl<D:Decoder> Decodable<D> for WorkMap {\n \n struct Database {\n     db_filename: Path,\n-    db_cache: LinearMap<~str, ~str>,\n+    db_cache: HashMap<~str, ~str>,\n     db_dirty: bool\n }\n \n@@ -212,7 +212,7 @@ struct Context {\n     db: @mut Database,\n     logger: @mut Logger,\n     cfg: @json::Object,\n-    freshness: LinearMap<~str,@fn(&str,&str)->bool>\n+    freshness: HashMap<~str,@fn(&str,&str)->bool>\n }\n \n struct Prep {\n@@ -267,7 +267,7 @@ pub impl Context {\n             db: db,\n             logger: lg,\n             cfg: cfg,\n-            freshness: LinearMap::new()\n+            freshness: HashMap::new()\n         }\n     }\n \n@@ -411,10 +411,10 @@ fn test() {\n     use core::io::WriterUtil;\n \n     let db = @mut Database { db_filename: Path(\"db.json\"),\n-                             db_cache: LinearMap::new(),\n+                             db_cache: HashMap::new(),\n                              db_dirty: false };\n     let lg = @mut Logger { a: () };\n-    let cfg = @LinearMap::new();\n+    let cfg = @HashMap::new();\n     let cx = @Context::new(db, lg, cfg);\n     let w:Work<~str> = do cx.prep(\"test1\") |prep| {\n         let pth = Path(\"foo.c\");"}, {"sha": "147d8227b81ea8964a348294872263db285c597b", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -23,7 +23,7 @@ use print::pprust;\n use visit;\n \n use core::cmp;\n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n use core::str;\n use core::vec;\n \n@@ -104,7 +104,7 @@ pub enum ast_node {\n     node_struct_ctor(@struct_def, @item, @path),\n }\n \n-pub type map = @mut LinearMap<node_id, ast_node>;\n+pub type map = @mut HashMap<node_id, ast_node>;\n \n pub struct Ctx {\n     map: map,\n@@ -134,7 +134,7 @@ pub fn mk_ast_map_visitor() -> vt {\n \n pub fn map_crate(diag: @span_handler, c: crate) -> map {\n     let cx = @mut Ctx {\n-        map: @mut LinearMap::new(),\n+        map: @mut HashMap::new(),\n         path: ~[],\n         local_id: 0u,\n         diag: diag,"}, {"sha": "5063a0381e7822d23da88e9953acdc55f7b6cd8e", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -20,7 +20,7 @@ use diagnostic::span_handler;\n use parse::comments::{doc_comment_style, strip_doc_comment_decoration};\n \n use core::vec;\n-use core::hashmap::LinearSet;\n+use core::hashmap::HashSet;\n use std;\n \n /* Constructors */\n@@ -333,7 +333,7 @@ pub fn find_inline_attr(attrs: &[ast::attribute]) -> inline_attr {\n \n pub fn require_unique_names(diagnostic: @span_handler,\n                             metas: &[@ast::meta_item]) {\n-    let mut set = LinearSet::new();\n+    let mut set = HashSet::new();\n     for metas.each |meta| {\n         let name = get_meta_item_name(*meta);\n "}, {"sha": "92f0c7c7679a9e4d93821cf4863bcb4b170df78d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -20,7 +20,7 @@ use parse;\n use parse::token;\n \n use core::vec;\n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n \n // new-style macro! tt code:\n //\n@@ -125,7 +125,7 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n     fn builtin_item_tt(f: SyntaxExpanderTTItemFun) -> @Transformer {\n         @SE(IdentTT(SyntaxExpanderTTItem{expander: f, span: None}))\n     }\n-    let mut syntax_expanders = LinearMap::new();\n+    let mut syntax_expanders = HashMap::new();\n     // NB identifier starts with space, and can't conflict with legal idents\n     syntax_expanders.insert(@~\" block\",\n                             @ScopeMacros(true));\n@@ -430,22 +430,22 @@ pub fn get_exprs_from_tts(cx: @ext_ctxt, tts: &[ast::token_tree])\n // a transformer env is either a base map or a map on top\n // of another chain.\n pub enum MapChain<K,V> {\n-    BaseMapChain(~LinearMap<K,@V>),\n-    ConsMapChain(~LinearMap<K,@V>,@mut MapChain<K,V>)\n+    BaseMapChain(~HashMap<K,@V>),\n+    ConsMapChain(~HashMap<K,@V>,@mut MapChain<K,V>)\n }\n \n \n // get the map from an env frame\n impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n \n     // Constructor. I don't think we need a zero-arg one.\n-    fn new(+init: ~LinearMap<K,@V>) -> @mut MapChain<K,V> {\n+    fn new(+init: ~HashMap<K,@V>) -> @mut MapChain<K,V> {\n         @mut BaseMapChain(init)\n     }\n \n     // add a new frame to the environment (functionally)\n     fn push_frame (@mut self) -> @mut MapChain<K,V> {\n-        @mut ConsMapChain(~LinearMap::new() ,self)\n+        @mut ConsMapChain(~HashMap::new() ,self)\n     }\n \n // no need for pop, it'll just be functional.\n@@ -454,7 +454,7 @@ impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n \n     // ugh: can't get this to compile with mut because of the\n     // lack of flow sensitivity.\n-    fn get_map(&self) -> &'self LinearMap<K,@V> {\n+    fn get_map(&self) -> &'self HashMap<K,@V> {\n         match *self {\n             BaseMapChain (~ref map) => map,\n             ConsMapChain (~ref map,_) => map\n@@ -509,10 +509,10 @@ impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n #[cfg(test)]\n mod test {\n     use super::MapChain;\n-    use core::hashmap::LinearMap;\n+    use core::hashmap::HashMap;\n \n     #[test] fn testenv () {\n-        let mut a = LinearMap::new();\n+        let mut a = HashMap::new();\n         a.insert (@~\"abc\",@15);\n         let m = MapChain::new(~a);\n         m.insert (@~\"def\",@16);"}, {"sha": "afb7e04a532042b57a4cad23c3617188ac28ffb2", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -20,7 +20,7 @@ use parse::token::{Token, EOF, to_str, nonterminal};\n use parse::token;\n \n use core::prelude::*;\n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n \n /* This is an Earley-like parser, without support for in-grammar nonterminals,\n only by calling out to the main rust parser for named nonterminals (which it\n@@ -186,9 +186,9 @@ pub enum named_match {\n pub type earley_item = ~MatcherPos;\n \n pub fn nameize(p_s: @mut ParseSess, ms: ~[matcher], res: ~[@named_match])\n-            -> LinearMap<ident,@named_match> {\n+            -> HashMap<ident,@named_match> {\n     fn n_rec(p_s: @mut ParseSess, m: matcher, res: ~[@named_match],\n-             ret_val: &mut LinearMap<ident, @named_match>) {\n+             ret_val: &mut HashMap<ident, @named_match>) {\n         match m {\n           codemap::spanned {node: match_tok(_), _} => (),\n           codemap::spanned {node: match_seq(ref more_ms, _, _, _, _), _} => {\n@@ -207,13 +207,13 @@ pub fn nameize(p_s: @mut ParseSess, ms: ~[matcher], res: ~[@named_match])\n           }\n         }\n     }\n-    let mut ret_val = LinearMap::new();\n+    let mut ret_val = HashMap::new();\n     for ms.each() |m| { n_rec(p_s, *m, res, &mut ret_val) }\n     return ret_val;\n }\n \n pub enum parse_result {\n-    success(LinearMap<ident, @named_match>),\n+    success(HashMap<ident, @named_match>),\n     failure(codemap::span, ~str),\n     error(codemap::span, ~str)\n }\n@@ -223,7 +223,7 @@ pub fn parse_or_else(\n     +cfg: ast::crate_cfg,\n     rdr: @reader,\n     ms: ~[matcher]\n-) -> LinearMap<ident, @named_match> {\n+) -> HashMap<ident, @named_match> {\n     match parse(sess, cfg, rdr, ms) {\n       success(m) => m,\n       failure(sp, str) => sess.span_diagnostic.span_fatal(sp, str),"}, {"sha": "0a74b6a94354a05b7c1ce8f73f3a7fb02c91d63d", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -18,7 +18,7 @@ use ext::tt::macro_parser::{named_match, matched_seq, matched_nonterminal};\n use parse::token::{EOF, INTERPOLATED, IDENT, Token, nt_ident, ident_interner};\n use parse::lexer::TokenAndSpan;\n \n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n use core::option;\n use core::vec;\n \n@@ -39,7 +39,7 @@ pub struct TtReader {\n     // the unzipped tree:\n     cur: @mut TtFrame,\n     /* for MBE-style macro transcription */\n-    interpolations: LinearMap<ident, @named_match>,\n+    interpolations: HashMap<ident, @named_match>,\n     repeat_idx: ~[uint],\n     repeat_len: ~[uint],\n     /* cached: */\n@@ -52,7 +52,7 @@ pub struct TtReader {\n  *  should) be none. */\n pub fn new_tt_reader(sp_diag: @span_handler,\n                      itr: @ident_interner,\n-                     interp: Option<LinearMap<ident,@named_match>>,\n+                     interp: Option<HashMap<ident,@named_match>>,\n                      +src: ~[ast::token_tree])\n                   -> @mut TtReader {\n     let r = @mut TtReader {\n@@ -66,7 +66,7 @@ pub fn new_tt_reader(sp_diag: @span_handler,\n             up: option::None\n         },\n         interpolations: match interp { /* just a convienience */\n-            None => LinearMap::new(),\n+            None => HashMap::new(),\n             Some(x) => x\n         },\n         repeat_idx: ~[],"}, {"sha": "f36d8f42f2ac6622ecd9f9ce05d4ba0cbc9e33b1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -94,7 +94,7 @@ use opt_vec::OptVec;\n \n use core::either::Either;\n use core::either;\n-use core::hashmap::LinearSet;\n+use core::hashmap::HashSet;\n use core::vec;\n \n #[deriving(Eq)]\n@@ -243,7 +243,7 @@ pub fn Parser(sess: @mut ParseSess,\n         keywords: token::keyword_table(),\n         strict_keywords: token::strict_keyword_table(),\n         reserved_keywords: token::reserved_keyword_table(),\n-        obsolete_set: @mut LinearSet::new(),\n+        obsolete_set: @mut HashSet::new(),\n         mod_path_stack: @mut ~[],\n     }\n }\n@@ -262,12 +262,12 @@ pub struct Parser {\n     quote_depth: @mut uint, // not (yet) related to the quasiquoter\n     reader: @reader,\n     interner: @token::ident_interner,\n-    keywords: LinearSet<~str>,\n-    strict_keywords: LinearSet<~str>,\n-    reserved_keywords: LinearSet<~str>,\n+    keywords: HashSet<~str>,\n+    strict_keywords: HashSet<~str>,\n+    reserved_keywords: HashSet<~str>,\n     /// The set of seen errors about obsolete syntax. Used to suppress\n     /// extra detail when the same error is seen twice\n-    obsolete_set: @mut LinearSet<ObsoleteSyntax>,\n+    obsolete_set: @mut HashSet<ObsoleteSyntax>,\n     /// Used to determine the path to externally loaded source files\n     mod_path_stack: @mut ~[~str],\n "}, {"sha": "713a6e89475549d5cb3e2301c11f5bad56712ff0", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -18,7 +18,7 @@ use util::interner;\n \n use core::cast;\n use core::char;\n-use core::hashmap::LinearSet;\n+use core::hashmap::HashSet;\n use core::str;\n use core::task;\n \n@@ -458,8 +458,8 @@ pub fn mk_fake_ident_interner() -> @ident_interner {\n  * appear as identifiers at all. Reserved keywords are not used anywhere in\n  * the language and may not appear as identifiers.\n  */\n-pub fn keyword_table() -> LinearSet<~str> {\n-    let mut keywords = LinearSet::new();\n+pub fn keyword_table() -> HashSet<~str> {\n+    let mut keywords = HashSet::new();\n     let mut tmp = temporary_keyword_table();\n     let mut strict = strict_keyword_table();\n     let mut reserved = reserved_keyword_table();\n@@ -471,8 +471,8 @@ pub fn keyword_table() -> LinearSet<~str> {\n }\n \n /// Keywords that may be used as identifiers\n-pub fn temporary_keyword_table() -> LinearSet<~str> {\n-    let mut words = LinearSet::new();\n+pub fn temporary_keyword_table() -> HashSet<~str> {\n+    let mut words = HashSet::new();\n     let keys = ~[\n         ~\"self\", ~\"static\",\n     ];\n@@ -483,8 +483,8 @@ pub fn temporary_keyword_table() -> LinearSet<~str> {\n }\n \n /// Full keywords. May not appear anywhere else.\n-pub fn strict_keyword_table() -> LinearSet<~str> {\n-    let mut words = LinearSet::new();\n+pub fn strict_keyword_table() -> HashSet<~str> {\n+    let mut words = HashSet::new();\n     let keys = ~[\n         ~\"as\",\n         ~\"break\",\n@@ -509,8 +509,8 @@ pub fn strict_keyword_table() -> LinearSet<~str> {\n     return words;\n }\n \n-pub fn reserved_keyword_table() -> LinearSet<~str> {\n-    let mut words = LinearSet::new();\n+pub fn reserved_keyword_table() -> HashSet<~str> {\n+    let mut words = HashSet::new();\n     let keys = ~[\n         ~\"be\"\n     ];"}, {"sha": "4108871d0089cb0a1b67a16cc0d678a2a5d4cc42", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -13,18 +13,18 @@\n // type, and vice versa.\n \n use core::prelude::*;\n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n \n pub struct Interner<T> {\n-    priv map: @mut LinearMap<T, uint>,\n+    priv map: @mut HashMap<T, uint>,\n     priv vect: @mut ~[T],\n }\n \n // when traits can extend traits, we should extend index<uint,T> to get []\n pub impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n     fn new() -> Interner<T> {\n         Interner {\n-            map: @mut LinearMap::new(),\n+            map: @mut HashMap::new(),\n             vect: @mut ~[],\n         }\n     }"}, {"sha": "bee754f5bd448d9287d94457db384ce70705929b", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -13,9 +13,9 @@\n \n extern mod std;\n \n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n \n-pub type header_map = LinearMap<~str, @mut ~[@~str]>;\n+pub type header_map = HashMap<~str, @mut ~[@~str]>;\n \n // the unused ty param is necessary so this gets monomorphized\n pub fn request<T:Copy>(req: &header_map) {"}, {"sha": "8a8962fb9d637ab9f3179865ca81bf22d7934559", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -13,7 +13,7 @@ extern mod std;\n use core::io;\n use std::time;\n use std::treemap::TreeMap;\n-use core::hashmap::{LinearMap, LinearSet};\n+use core::hashmap::{HashMap, HashSet};\n use core::trie::TrieMap;\n \n fn timed(label: &str, f: &fn()) {\n@@ -102,7 +102,7 @@ fn main() {\n \n     {\n         let rng = core::rand::seeded_rng([1, 1, 1, 1, 1, 1, 1]);\n-        let mut set = LinearSet::new();\n+        let mut set = HashSet::new();\n         while set.len() != n_keys {\n             let next = rng.next() as uint;\n             if set.insert(next) {\n@@ -131,21 +131,21 @@ fn main() {\n         vector(&mut map, n_keys, rand);\n     }\n \n-    io::println(\"\\nLinearMap:\");\n+    io::println(\"\\nHashMap:\");\n \n     {\n-        let mut map = LinearMap::new::<uint, uint>();\n+        let mut map = HashMap::new::<uint, uint>();\n         ascending(&mut map, n_keys);\n     }\n \n     {\n-        let mut map = LinearMap::new::<uint, uint>();\n+        let mut map = HashMap::new::<uint, uint>();\n         descending(&mut map, n_keys);\n     }\n \n     {\n         io::println(\" Random integers:\");\n-        let mut map = LinearMap::new::<uint, uint>();\n+        let mut map = HashMap::new::<uint, uint>();\n         vector(&mut map, n_keys, rand);\n     }\n "}, {"sha": "5f8f13896fb956197ffb54fa87aadda72f7b0021", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n extern mod std;\n-use core::hashmap::LinearSet;\n+use core::hashmap::HashSet;\n use std::bitv::BitvSet;\n use std::treemap::TreeSet;\n use core::io::WriterUtil;\n@@ -158,9 +158,9 @@ fn main() {\n     {\n         let rng = rand::seeded_rng(seed);\n         let mut results = empty_results();\n-        results.bench_int(rng, num_keys, max, || LinearSet::new::<uint>());\n-        results.bench_str(rng, num_keys, || LinearSet::new::<~str>());\n-        write_results(\"core::hashmap::LinearSet\", &results);\n+        results.bench_int(rng, num_keys, max, || HashSet::new::<uint>());\n+        results.bench_str(rng, num_keys, || HashSet::new::<~str>());\n+        write_results(\"core::hashmap::HashSet\", &results);\n     }\n \n     {"}, {"sha": "396ea081362810d49d2b06753d7a51216e269d0e", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -24,7 +24,7 @@ use std::arc;\n use std::time;\n use std::deque::Deque;\n use std::par;\n-use core::hashmap::{LinearMap, LinearSet};\n+use core::hashmap::{HashMap, HashSet};\n use core::io::WriterUtil;\n use core::int::abs;\n use core::rand::RngUtil;\n@@ -81,7 +81,7 @@ fn make_edges(scale: uint, edgefactor: uint) -> ~[(node_id, node_id)] {\n \n fn make_graph(N: uint, edges: ~[(node_id, node_id)]) -> graph {\n     let mut graph = do vec::from_fn(N) |_i| {\n-        LinearSet::new()\n+        HashSet::new()\n     };\n \n     do vec::each(edges) |e| {\n@@ -104,7 +104,7 @@ fn make_graph(N: uint, edges: ~[(node_id, node_id)]) -> graph {\n }\n \n fn gen_search_keys(graph: &[~[node_id]], n: uint) -> ~[node_id] {\n-    let mut keys = LinearSet::new();\n+    let mut keys = HashSet::new();\n     let r = rand::Rng();\n \n     while keys.len() < n {"}, {"sha": "6ba1caa0d1e1ae7bcd73cf9d23135f6703cd7f77", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -15,13 +15,13 @@\n \n extern mod std;\n use std::sort;\n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n use core::io::ReaderUtil;\n use core::comm::{stream, Port, Chan};\n use core::cmp::Ord;\n \n // given a map, print a sorted version of it\n-fn sort_and_fmt(mm: &LinearMap<~[u8], uint>, total: uint) -> ~str {\n+fn sort_and_fmt(mm: &HashMap<~[u8], uint>, total: uint) -> ~str {\n    fn pct(xx: uint, yy: uint) -> float {\n       return (xx as float) * 100f / (yy as float);\n    }\n@@ -67,15 +67,15 @@ fn sort_and_fmt(mm: &LinearMap<~[u8], uint>, total: uint) -> ~str {\n }\n \n // given a map, search for the frequency of a pattern\n-fn find(mm: &LinearMap<~[u8], uint>, key: ~str) -> uint {\n+fn find(mm: &HashMap<~[u8], uint>, key: ~str) -> uint {\n    match mm.find(&str::to_bytes(str::to_lower(key))) {\n       option::None      => { return 0u; }\n       option::Some(&num) => { return num; }\n    }\n }\n \n // given a map, increment the counter for a key\n-fn update_freq(mm: &mut LinearMap<~[u8], uint>, key: &[u8]) {\n+fn update_freq(mm: &mut HashMap<~[u8], uint>, key: &[u8]) {\n     let key = vec::slice(key, 0, key.len()).to_vec();\n     let newval = match mm.pop(&key) {\n         Some(v) => v + 1,\n@@ -103,7 +103,7 @@ fn windows_with_carry(bb: &[u8], nn: uint,\n fn make_sequence_processor(sz: uint, from_parent: comm::Port<~[u8]>,\n                            to_parent: comm::Chan<~str>) {\n \n-   let mut freqs: LinearMap<~[u8], uint> = LinearMap::new();\n+   let mut freqs: HashMap<~[u8], uint> = HashMap::new();\n    let mut carry: ~[u8] = ~[];\n    let mut total: uint = 0u;\n "}, {"sha": "f5d1661fa52bddf6d9ff924dd9de9d3292dcca9f", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -25,7 +25,7 @@\n //  writes pbm image to output path\n \n use core::io::WriterUtil;\n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n \n struct cmplx {\n     re: f64,\n@@ -125,7 +125,7 @@ fn writer(path: ~str, pport: comm::Port<Line>, size: uint)\n     };\n     cout.write_line(\"P4\");\n     cout.write_line(fmt!(\"%u %u\", size, size));\n-    let mut lines: LinearMap<uint, Line> = LinearMap::new();\n+    let mut lines: HashMap<uint, Line> = HashMap::new();\n     let mut done = 0_u;\n     let mut i = 0_u;\n     while i < size {"}, {"sha": "bda659aa7b97e4dd41ef1e41c0fb7158b44344db", "filename": "src/test/compile-fail/borrowck-borrowed-uniq-rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -10,11 +10,11 @@\n \n //buggy.rs\n \n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n \n fn main() {\n-    let mut buggy_map :LinearMap<uint, &uint> =\n-      LinearMap::new::<uint, &uint>();\n+    let mut buggy_map :HashMap<uint, &uint> =\n+      HashMap::new::<uint, &uint>();\n     buggy_map.insert(42, &*~1); //~ ERROR illegal borrow\n \n     // but it is ok if we use a temporary"}, {"sha": "17c0efe225e4d6dfabb5665f75f48ae1b80d2a7e", "filename": "src/test/compile-fail/borrowck-insert-during-each.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::hashmap::LinearSet;\n+use core::hashmap::HashSet;\n \n struct Foo {\n-  n: LinearSet<int>,\n+  n: HashSet<int>,\n }\n \n pub impl Foo {\n@@ -29,6 +29,6 @@ fn bar(f: &mut Foo) {\n }\n \n fn main() {\n-  let mut f = Foo { n: LinearSet::new() };\n+  let mut f = Foo { n: HashSet::new() };\n   bar(&mut f);\n }"}, {"sha": "de28d72677728c658209e01672996e246285d102", "filename": "src/test/compile-fail/for-loop-decl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -11,10 +11,10 @@\n // error-pattern: mismatched types\n extern mod std;\n use std::bitv;\n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n \n struct FnInfo {\n-    vars: LinearMap<uint, VarInfo>\n+    vars: HashMap<uint, VarInfo>\n }\n \n struct VarInfo {"}, {"sha": "ebc5b015d27526373a1098071858bd090ea56aba", "filename": "src/test/compile-fail/map-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmap-types.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n use core::container::Map;\n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n \n // Test that trait types printed in error msgs include the type arguments.\n \n fn main() {\n-    let x: @Map<~str, ~str> = @LinearMap::new::<~str, ~str>() as\n+    let x: @Map<~str, ~str> = @HashMap::new::<~str, ~str>() as\n         @Map<~str, ~str>;\n     let y: @Map<uint, ~str> = @x;\n     //~^ ERROR mismatched types: expected `@core::container::Map<uint,~str>`"}, {"sha": "7e3318f865228863b786708705d417ce618a4335", "filename": "src/test/run-fail/unwind-misc-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -14,7 +14,7 @@\n \n fn main() {\n     let count = @mut 0u;\n-    let mut map = core::hashmap::LinearMap::new();\n+    let mut map = core::hashmap::HashMap::new();\n     let mut arr = ~[];\n     for uint::range(0u, 10u) |i| {\n         arr += ~[@~\"key stuff\"];"}, {"sha": "1a2a8cab3032cb7354de51338322dc52206a6e1d", "filename": "src/test/run-pass/explicit-self-generic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -20,17 +20,17 @@ type EqFn<K> = ~fn(K, K) -> bool;\n \n struct LM { resize_at: uint, size: uint }\n \n-enum LinearMap<K,V> {\n-    LinearMap_(LM)\n+enum HashMap<K,V> {\n+    HashMap_(LM)\n }\n \n-fn linear_map<K,V>() -> LinearMap<K,V> {\n-    LinearMap_(LM{\n+fn linear_map<K,V>() -> HashMap<K,V> {\n+    HashMap_(LM{\n         resize_at: 32,\n         size: 0})\n }\n \n-pub impl<K,V> LinearMap<K,V> {\n+pub impl<K,V> HashMap<K,V> {\n     fn len(&mut self) -> uint {\n         self.size\n     }"}, {"sha": "910708b71060250549279764edb032f315a39337", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -19,7 +19,7 @@\n pub fn map(filename: ~str, emit: map_reduce::putter) { emit(filename, ~\"1\"); }\n \n mod map_reduce {\n-    use core::hashmap::LinearMap;\n+    use core::hashmap::HashMap;\n     use core::comm::*;\n \n     pub type putter = @fn(~str, ~str);\n@@ -37,9 +37,9 @@ mod map_reduce {\n     }\n \n     fn map_task(ctrl: SharedChan<ctrl_proto>, input: ~str) {\n-        let intermediates = @mut LinearMap::new();\n+        let intermediates = @mut HashMap::new();\n \n-        fn emit(im: &mut LinearMap<~str, int>, ctrl: SharedChan<ctrl_proto>, key: ~str,\n+        fn emit(im: &mut HashMap<~str, int>, ctrl: SharedChan<ctrl_proto>, key: ~str,\n                 _val: ~str) {\n             if im.contains_key(&key) {\n                 return;\n@@ -65,9 +65,9 @@ mod map_reduce {\n         // This task becomes the master control task. It spawns others\n         // to do the rest.\n \n-        let mut reducers: LinearMap<~str, int>;\n+        let mut reducers: HashMap<~str, int>;\n \n-        reducers = LinearMap::new();\n+        reducers = HashMap::new();\n \n         start_mappers(ctrl_chan, inputs.clone());\n "}, {"sha": "5b40d0abff818d2de182002cfcd005fe4252aad1", "filename": "src/test/run-pass/issue-1696.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Frun-pass%2Fissue-1696.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Frun-pass%2Fissue-1696.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1696.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -10,10 +10,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n \n pub fn main() {\n-    let mut m = LinearMap::new();\n+    let mut m = HashMap::new();\n     m.insert(str::to_bytes(~\"foo\"), str::to_bytes(~\"bar\"));\n     error!(m);\n }"}, {"sha": "f6e40fa247d5e35d7a0328028ce6d1d8de72dacf", "filename": "src/test/run-pass/issue-2631-b.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Frun-pass%2Fissue-2631-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Frun-pass%2Fissue-2631-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2631-b.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -14,11 +14,11 @@\n extern mod req;\n \n use req::*;\n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n \n pub fn main() {\n   let v = ~[@~\"hi\"];\n-  let mut m: req::header_map = LinearMap::new();\n+  let mut m: req::header_map = HashMap::new();\n   m.insert(~\"METHOD\", @mut v);\n   request::<int>(&m);\n }"}, {"sha": "b25e4095b185ed3c027c3f2ab380a9b46d0f3bf9", "filename": "src/test/run-pass/issue-2804-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -13,9 +13,9 @@\n // Minimized version of issue-2804.rs. Both check that callee IDs don't\n // clobber the previous node ID in a macro expr\n \n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n \n-fn add_interfaces(managed_ip: ~str, device: LinearMap<~str, int>)  {\n+fn add_interfaces(managed_ip: ~str, device: HashMap<~str, int>)  {\n      error!(\"%s, %?\", managed_ip, device.get(&~\"interfaces\"));\n }\n "}, {"sha": "4614c26fa5fc8f348ae90a151ad43acf408146ce", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -11,7 +11,7 @@\n // except according to those terms.\n \n extern mod std;\n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n use std::json;\n \n enum object {\n@@ -58,7 +58,7 @@ fn add_interface(store: int, managed_ip: ~str, data: std::json::Json) -> (~str,\n     }\n }\n \n-fn add_interfaces(store: int, managed_ip: ~str, device: LinearMap<~str, std::json::Json>) -> ~[(~str, object)]\n+fn add_interfaces(store: int, managed_ip: ~str, device: HashMap<~str, std::json::Json>) -> ~[(~str, object)]\n {\n     match device.get(&~\"interfaces\")\n     {"}, {"sha": "16e9b4753f83007d72aad1b3f73292acad59eca4", "filename": "src/test/run-pass/issue-3026.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Frun-pass%2Fissue-3026.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Frun-pass%2Fissue-3026.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3026.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -10,10 +10,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n \n pub fn main() {\n-    let mut buggy_map: LinearMap<uint, &uint> = LinearMap::new::<uint, &uint>();\n+    let mut buggy_map: HashMap<uint, &uint> = HashMap::new::<uint, &uint>();\n     let x = ~1;\n     buggy_map.insert(42, &*x);\n }"}, {"sha": "334831fea4d03147d5476e8b598a4cc3ff9af5fc", "filename": "src/test/run-pass/issue-3559.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Frun-pass%2Fissue-3559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Frun-pass%2Fissue-3559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3559.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -29,7 +29,7 @@ fn check_strs(actual: &str, expected: &str) -> bool\n #[test]\n fn tester()\n {\n-    let mut table = core::hashmap::LinearMap();\n+    let mut table = core::hashmap::HashMap();\n     table.insert(@~\"one\", 1);\n     table.insert(@~\"two\", 2);\n     assert!(check_strs(table.to_str(), ~\"xxx\"));   // not sure what expected should be"}, {"sha": "e129e0a88687a3b8a63cdaa51ef94e0af4a4fd0e", "filename": "src/test/run-pass/issue-4092.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Frun-pass%2Fissue-4092.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc148b58ff7a4eb6861701be61396d1a685f6657/src%2Ftest%2Frun-pass%2Fissue-4092.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4092.rs?ref=cc148b58ff7a4eb6861701be61396d1a685f6657", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::hashmap::LinearMap;\n+use core::hashmap::HashMap;\n \n pub fn main() {\n-    let mut x = LinearMap::new();\n+    let mut x = HashMap::new();\n     x.insert((@\"abc\", 0), 0);\n }"}]}