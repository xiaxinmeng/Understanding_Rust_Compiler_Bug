{"sha": "5f331c05853983001a1319d4d2116c44a087e5a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmMzMxYzA1ODUzOTgzMDAxYTEzMTlkNGQyMTE2YzQ0YTA4N2U1YTQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-08-07T06:04:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-07T06:04:02Z"}, "message": "Rollup merge of #74774 - oliver-giersch:set_data_ptr, r=dtolnay\n\nadds [*mut|*const] ptr::set_ptr_value\n\nI propose the addition of these two functions to `*mut T` and `*const T`, respectively. The motivation for this is primarily byte-wise pointer arithmetic on (potentially) fat pointers, i.e. for types with a `T: ?Sized` bound. A concrete use-case has been discussed in [this](https://internals.rust-lang.org/t/byte-wise-fat-pointer-arithmetic/12739) thread.\nTL;DR: Currently, byte-wise pointer arithmetic with potentially fat pointers in not possible in either stable or nightly Rust without making assumptions about the layout of fat pointers, which is currently still an implementation detail and not formally stabilized. This PR adds one function to `*mut T` and `*const T` each, allowing to circumvent this restriction without exposing any internal implementation details.\nOne possible alternative would be to add specific byte-wise pointer arithmetic functions to the two pointer types in addition to the already existing count-wise functions. However, I feel this fairly niche use case does not warrant adding a whole set of new functions like `add_bytes`, `offset_bytes`, `wrapping_offset_bytes`, etc. (times two, one for each pointer type) to `libcore`.", "tree": {"sha": "96d630a44d97537ea2e1a287b162859f9a12c3df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96d630a44d97537ea2e1a287b162859f9a12c3df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f331c05853983001a1319d4d2116c44a087e5a4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfLO7SCRBK7hj4Ov3rIwAAdHIIABvuXxIDZXI7P6BnCz3JU/Kt\nlOqS4kvT2dT0va5xFu+ZpODaNfsz02pPkoddvEd0F/iYZTHLkC6zYwoFbyJ8ju/e\n9s5wxSoKXulb4OgbEOQ5yaSw7QRXfyn+zq1oUL/iLjjzpawKTJIQkEnWiEGtsd0t\nActOa+zovO6h/AmMxkN1+0hP67vrX4OgUDG1AYg4LBcTdMG5qEPTbD4D+Z/CxA+d\nnbLrsJKCqj7vunzB9CQF9k+VejHv55zwPFCovdUkSDlE3M/uGYPbxKxGYOaST/pi\nbHAqxlUFtASRYGMosFmVoyDHwm5B5W1x9DPlc7jIwGz77+3tV3DA2brFGLrASw8=\n=lIWd\n-----END PGP SIGNATURE-----\n", "payload": "tree 96d630a44d97537ea2e1a287b162859f9a12c3df\nparent 63e34422bbaf4ae4ed5ae7309183185aa2aa13a4\nparent 6c81556a36ac5507fe1f9cd8ee699e6fa2b11077\nauthor Manish Goregaokar <manishsmail@gmail.com> 1596780242 -0700\ncommitter GitHub <noreply@github.com> 1596780242 -0700\n\nRollup merge of #74774 - oliver-giersch:set_data_ptr, r=dtolnay\n\nadds [*mut|*const] ptr::set_ptr_value\n\nI propose the addition of these two functions to `*mut T` and `*const T`, respectively. The motivation for this is primarily byte-wise pointer arithmetic on (potentially) fat pointers, i.e. for types with a `T: ?Sized` bound. A concrete use-case has been discussed in [this](https://internals.rust-lang.org/t/byte-wise-fat-pointer-arithmetic/12739) thread.\nTL;DR: Currently, byte-wise pointer arithmetic with potentially fat pointers in not possible in either stable or nightly Rust without making assumptions about the layout of fat pointers, which is currently still an implementation detail and not formally stabilized. This PR adds one function to `*mut T` and `*const T` each, allowing to circumvent this restriction without exposing any internal implementation details.\nOne possible alternative would be to add specific byte-wise pointer arithmetic functions to the two pointer types in addition to the already existing count-wise functions. However, I feel this fairly niche use case does not warrant adding a whole set of new functions like `add_bytes`, `offset_bytes`, `wrapping_offset_bytes`, etc. (times two, one for each pointer type) to `libcore`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f331c05853983001a1319d4d2116c44a087e5a4", "html_url": "https://github.com/rust-lang/rust/commit/5f331c05853983001a1319d4d2116c44a087e5a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f331c05853983001a1319d4d2116c44a087e5a4/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63e34422bbaf4ae4ed5ae7309183185aa2aa13a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/63e34422bbaf4ae4ed5ae7309183185aa2aa13a4", "html_url": "https://github.com/rust-lang/rust/commit/63e34422bbaf4ae4ed5ae7309183185aa2aa13a4"}, {"sha": "6c81556a36ac5507fe1f9cd8ee699e6fa2b11077", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c81556a36ac5507fe1f9cd8ee699e6fa2b11077", "html_url": "https://github.com/rust-lang/rust/commit/6c81556a36ac5507fe1f9cd8ee699e6fa2b11077"}], "stats": {"total": 64, "additions": 64, "deletions": 0}, "files": [{"sha": "a16970e9fd1802863411b74ac32da08acf1a24b2", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5f331c05853983001a1319d4d2116c44a087e5a4/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f331c05853983001a1319d4d2116c44a087e5a4/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=5f331c05853983001a1319d4d2116c44a087e5a4", "patch": "@@ -656,6 +656,38 @@ impl<T: ?Sized> *const T {\n         self.wrapping_offset((count as isize).wrapping_neg())\n     }\n \n+    /// Sets the pointer value to `ptr`.\n+    ///\n+    /// In case `self` is a (fat) pointer to an unsized type, this operation\n+    /// will only affect the pointer part, whereas for (thin) pointers to\n+    /// sized types, this has the same effect as a simple assignment.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This function is primarily useful for allowing byte-wise pointer\n+    /// arithmetic on potentially fat pointers:\n+    ///\n+    /// ```\n+    /// #![feature(set_ptr_value)]\n+    /// # use core::fmt::Debug;\n+    /// let arr: [i32; 3] = [1, 2, 3];\n+    /// let mut ptr = &arr[0] as *const dyn Debug;\n+    /// let thin = ptr as *const u8;\n+    /// ptr = ptr.set_ptr_value(unsafe { thin.add(8).cast() });\n+    /// assert_eq!(unsafe { *(ptr as *const i32) }, 3);\n+    /// ```\n+    #[unstable(feature = \"set_ptr_value\", issue = \"75091\")]\n+    #[inline]\n+    pub fn set_ptr_value(mut self, val: *const ()) -> Self {\n+        let thin = &mut self as *mut *const T as *mut *const ();\n+        // SAFETY: In case of a thin pointer, this operations is identical\n+        // to a simple assignment. In case of a fat pointer, with the current\n+        // fat pointer layout implementation, the first field of such a\n+        // pointer is always the data pointer, which is likewise assigned.\n+        unsafe { *thin = val };\n+        self\n+    }\n+\n     /// Reads the value from `self` without moving it. This leaves the\n     /// memory in `self` unchanged.\n     ///"}, {"sha": "b47f90c59962926462cd306ac87baf8d4f05f580", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5f331c05853983001a1319d4d2116c44a087e5a4/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f331c05853983001a1319d4d2116c44a087e5a4/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=5f331c05853983001a1319d4d2116c44a087e5a4", "patch": "@@ -712,6 +712,38 @@ impl<T: ?Sized> *mut T {\n         self.wrapping_offset((count as isize).wrapping_neg())\n     }\n \n+    /// Sets the pointer value to `ptr`.\n+    ///\n+    /// In case `self` is a (fat) pointer to an unsized type, this operation\n+    /// will only affect the pointer part, whereas for (thin) pointers to\n+    /// sized types, this has the same effect as a simple assignment.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This function is primarily useful for allowing byte-wise pointer\n+    /// arithmetic on potentially fat pointers:\n+    ///\n+    /// ```\n+    /// #![feature(set_ptr_value)]\n+    /// # use core::fmt::Debug;\n+    /// let mut arr: [i32; 3] = [1, 2, 3];\n+    /// let mut ptr = &mut arr[0] as *mut dyn Debug;\n+    /// let thin = ptr as *mut u8;\n+    /// ptr = ptr.set_ptr_value(unsafe { thin.add(8).cast() });\n+    /// assert_eq!(unsafe { *(ptr as *mut i32) }, 3);\n+    /// ```\n+    #[unstable(feature = \"set_ptr_value\", issue = \"75091\")]\n+    #[inline]\n+    pub fn set_ptr_value(mut self, val: *mut ()) -> Self {\n+        let thin = &mut self as *mut *mut T as *mut *mut ();\n+        // SAFETY: In case of a thin pointer, this operations is identical\n+        // to a simple assignment. In case of a fat pointer, with the current\n+        // fat pointer layout implementation, the first field of such a\n+        // pointer is always the data pointer, which is likewise assigned.\n+        unsafe { *thin = val };\n+        self\n+    }\n+\n     /// Reads the value from `self` without moving it. This leaves the\n     /// memory in `self` unchanged.\n     ///"}]}