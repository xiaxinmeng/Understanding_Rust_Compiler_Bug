{"sha": "6a20f7df5755d8c6b68110d2d0391a7b03268e77", "node_id": "C_kwDOAAsO6NoAKDZhMjBmN2RmNTc1NWQ4YzZiNjgxMTBkMmQwMzkxYTdiMDMyNjhlNzc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-28T10:10:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-28T10:10:09Z"}, "message": "Auto merge of #106209 - fee1-dead-contrib:rollup-47ysdcu, r=fee1-dead\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #94145 (Test leaking of BinaryHeap Drain iterators)\n - #103945 (Remove `iter::Empty` hack)\n - #104024 (Fix `unused_must_use` warning for `Box::from_raw`)\n - #104708 (Fix backoff doc to match implementation)\n - #105347 (Account for `match` expr in single line)\n - #105484 (Implement allow-by-default `multiple_supertrait_upcastable` lint)\n - #106184 (Fix `core::any` docs)\n - #106201 (Emit fewer errors on invalid `#[repr(transparent)]` on `enum`)\n - #106205 (Remove some totally duplicated files in `rustc_infer`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "6fcaf75739aa1e39e0bb21c76d7e60e235370e5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fcaf75739aa1e39e0bb21c76d7e60e235370e5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a20f7df5755d8c6b68110d2d0391a7b03268e77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a20f7df5755d8c6b68110d2d0391a7b03268e77", "html_url": "https://github.com/rust-lang/rust/commit/6a20f7df5755d8c6b68110d2d0391a7b03268e77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a20f7df5755d8c6b68110d2d0391a7b03268e77/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b889e53e78a186a861a8407c225f9d8e0d436f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b889e53e78a186a861a8407c225f9d8e0d436f5", "html_url": "https://github.com/rust-lang/rust/commit/9b889e53e78a186a861a8407c225f9d8e0d436f5"}, {"sha": "5e9c91c6dd8c7d822434d8b7b0182363e2b93598", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e9c91c6dd8c7d822434d8b7b0182363e2b93598", "html_url": "https://github.com/rust-lang/rust/commit/5e9c91c6dd8c7d822434d8b7b0182363e2b93598"}], "stats": {"total": 1027, "additions": 321, "deletions": 706}, "files": [{"sha": "060306d88bea8363694e6486b619f11442b9d4a6", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -160,6 +160,8 @@ declare_features! (\n     (active, intrinsics, \"1.0.0\", None, None),\n     /// Allows using `#[lang = \"..\"]` attribute for linking items to special compiler logic.\n     (active, lang_items, \"1.0.0\", None, None),\n+    /// Allows the `multiple_supertrait_upcastable` lint.\n+    (active, multiple_supertrait_upcastable, \"CURRENT_RUSTC_VERSION\", None, None),\n     /// Allows using `#[omit_gdb_pretty_printer_section]`.\n     (active, omit_gdb_pretty_printer_section, \"1.5.0\", None, None),\n     /// Allows using `#[prelude_import]` on glob `use` items."}, {"sha": "87cc69757b07c4ed89643ff77f454ec787e77f3e", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -1060,10 +1060,8 @@ pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, adt: ty::AdtDef<'tcx>)\n \n     if adt.variants().len() != 1 {\n         bad_variant_count(tcx, adt, tcx.def_span(adt.did()), adt.did());\n-        if adt.variants().is_empty() {\n-            // Don't bother checking the fields. No variants (and thus no fields) exist.\n-            return;\n-        }\n+        // Don't bother checking the fields.\n+        return;\n     }\n \n     // For each field, figure out if it's known to be a ZST and align(1), with \"known\""}, {"sha": "e5823660e3fbd27f3cc769567dcf0822f3fa7ca8", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -729,15 +729,15 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                             format!(\"this and all prior arms are found to be of type `{}`\", t),\n                         );\n                     }\n-                    let outer_error_span = if any_multiline_arm {\n+                    let outer = if any_multiline_arm || !source_map.is_multiline(cause.span) {\n                         // Cover just `match` and the scrutinee expression, not\n                         // the entire match body, to reduce diagram noise.\n                         cause.span.shrink_to_lo().to(scrut_span)\n                     } else {\n                         cause.span\n                     };\n                     let msg = \"`match` arms have incompatible types\";\n-                    err.span_label(outer_error_span, msg);\n+                    err.span_label(outer, msg);\n                     self.suggest_remove_semi_or_return_binding(\n                         err,\n                         prior_arm_block_id,"}, {"sha": "41b115f3377ac879d7287aa3910dcdf492221fc7", "filename": "compiler/rustc_infer/src/infer/error_reporting/note_region.rs", "status": "removed", "additions": 0, "deletions": 427, "changes": 427, "blob_url": "https://github.com/rust-lang/rust/blob/9b889e53e78a186a861a8407c225f9d8e0d436f5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b889e53e78a186a861a8407c225f9d8e0d436f5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_region.rs?ref=9b889e53e78a186a861a8407c225f9d8e0d436f5", "patch": "@@ -1,427 +0,0 @@\n-use crate::errors::RegionOriginNote;\n-use crate::infer::error_reporting::{note_and_explain_region, TypeErrCtxt};\n-use crate::infer::{self, SubregionOrigin};\n-use rustc_errors::{\n-    fluent, struct_span_err, AddToDiagnostic, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n-};\n-use rustc_middle::traits::ObligationCauseCode;\n-use rustc_middle::ty::error::TypeError;\n-use rustc_middle::ty::{self, Region};\n-\n-use super::ObligationCauseAsDiagArg;\n-\n-impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n-    pub(super) fn note_region_origin(&self, err: &mut Diagnostic, origin: &SubregionOrigin<'tcx>) {\n-        match *origin {\n-            infer::Subtype(ref trace) => RegionOriginNote::WithRequirement {\n-                span: trace.cause.span,\n-                requirement: ObligationCauseAsDiagArg(trace.cause.clone()),\n-                expected_found: self.values_str(trace.values),\n-            }\n-            .add_to_diagnostic(err),\n-            infer::Reborrow(span) => {\n-                RegionOriginNote::Plain { span, msg: fluent::infer_reborrow }.add_to_diagnostic(err)\n-            }\n-            infer::ReborrowUpvar(span, ref upvar_id) => {\n-                let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n-                RegionOriginNote::WithName {\n-                    span,\n-                    msg: fluent::infer_reborrow,\n-                    name: &var_name.to_string(),\n-                    continues: false,\n-                }\n-                .add_to_diagnostic(err);\n-            }\n-            infer::RelateObjectBound(span) => {\n-                RegionOriginNote::Plain { span, msg: fluent::infer_relate_object_bound }\n-                    .add_to_diagnostic(err);\n-            }\n-            infer::DataBorrowed(ty, span) => {\n-                RegionOriginNote::WithName {\n-                    span,\n-                    msg: fluent::infer_data_borrowed,\n-                    name: &self.ty_to_string(ty),\n-                    continues: false,\n-                }\n-                .add_to_diagnostic(err);\n-            }\n-            infer::ReferenceOutlivesReferent(ty, span) => {\n-                RegionOriginNote::WithName {\n-                    span,\n-                    msg: fluent::infer_reference_outlives_referent,\n-                    name: &self.ty_to_string(ty),\n-                    continues: false,\n-                }\n-                .add_to_diagnostic(err);\n-            }\n-            infer::RelateParamBound(span, ty, opt_span) => {\n-                RegionOriginNote::WithName {\n-                    span,\n-                    msg: fluent::infer_relate_param_bound,\n-                    name: &self.ty_to_string(ty),\n-                    continues: opt_span.is_some(),\n-                }\n-                .add_to_diagnostic(err);\n-                if let Some(span) = opt_span {\n-                    RegionOriginNote::Plain { span, msg: fluent::infer_relate_param_bound_2 }\n-                        .add_to_diagnostic(err);\n-                }\n-            }\n-            infer::RelateRegionParamBound(span) => {\n-                RegionOriginNote::Plain { span, msg: fluent::infer_relate_region_param_bound }\n-                    .add_to_diagnostic(err);\n-            }\n-            infer::CompareImplItemObligation { span, .. } => {\n-                RegionOriginNote::Plain { span, msg: fluent::infer_compare_impl_item_obligation }\n-                    .add_to_diagnostic(err);\n-            }\n-            infer::CheckAssociatedTypeBounds { ref parent, .. } => {\n-                self.note_region_origin(err, &parent);\n-            }\n-            infer::AscribeUserTypeProvePredicate(span) => {\n-                RegionOriginNote::Plain {\n-                    span,\n-                    msg: fluent::infer_ascribe_user_type_prove_predicate,\n-                }\n-                .add_to_diagnostic(err);\n-            }\n-        }\n-    }\n-\n-    pub(super) fn report_concrete_failure(\n-        &self,\n-        origin: SubregionOrigin<'tcx>,\n-        sub: Region<'tcx>,\n-        sup: Region<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        match origin {\n-            infer::Subtype(box trace) => {\n-                let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n-                let mut err = self.report_and_explain_type_error(trace, terr);\n-                match (*sub, *sup) {\n-                    (ty::RePlaceholder(_), ty::RePlaceholder(_)) => {}\n-                    (ty::RePlaceholder(_), _) => {\n-                        note_and_explain_region(\n-                            self.tcx,\n-                            &mut err,\n-                            \"\",\n-                            sup,\n-                            \" doesn't meet the lifetime requirements\",\n-                            None,\n-                        );\n-                    }\n-                    (_, ty::RePlaceholder(_)) => {\n-                        note_and_explain_region(\n-                            self.tcx,\n-                            &mut err,\n-                            \"the required lifetime does not necessarily outlive \",\n-                            sub,\n-                            \"\",\n-                            None,\n-                        );\n-                    }\n-                    _ => {\n-                        note_and_explain_region(self.tcx, &mut err, \"\", sup, \"...\", None);\n-                        note_and_explain_region(\n-                            self.tcx,\n-                            &mut err,\n-                            \"...does not necessarily outlive \",\n-                            sub,\n-                            \"\",\n-                            None,\n-                        );\n-                    }\n-                }\n-                err\n-            }\n-            infer::Reborrow(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0312,\n-                    \"lifetime of reference outlives lifetime of borrowed content...\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"...the reference is valid for \",\n-                    sub,\n-                    \"...\",\n-                    None,\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"...but the borrowed content is only valid for \",\n-                    sup,\n-                    \"\",\n-                    None,\n-                );\n-                err\n-            }\n-            infer::ReborrowUpvar(span, ref upvar_id) => {\n-                let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0313,\n-                    \"lifetime of borrowed pointer outlives lifetime of captured variable `{}`...\",\n-                    var_name\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"...the borrowed pointer is valid for \",\n-                    sub,\n-                    \"...\",\n-                    None,\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    &format!(\"...but `{}` is only valid for \", var_name),\n-                    sup,\n-                    \"\",\n-                    None,\n-                );\n-                err\n-            }\n-            infer::RelateObjectBound(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0476,\n-                    \"lifetime of the source pointer does not outlive lifetime bound of the \\\n-                     object type\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"object type is valid for \",\n-                    sub,\n-                    \"\",\n-                    None,\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"source pointer is only valid for \",\n-                    sup,\n-                    \"\",\n-                    None,\n-                );\n-                err\n-            }\n-            infer::RelateParamBound(span, ty, opt_span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0477,\n-                    \"the type `{}` does not fulfill the required lifetime\",\n-                    self.ty_to_string(ty)\n-                );\n-                match *sub {\n-                    ty::ReStatic => note_and_explain_region(\n-                        self.tcx,\n-                        &mut err,\n-                        \"type must satisfy \",\n-                        sub,\n-                        if opt_span.is_some() { \" as required by this binding\" } else { \"\" },\n-                        opt_span,\n-                    ),\n-                    _ => note_and_explain_region(\n-                        self.tcx,\n-                        &mut err,\n-                        \"type must outlive \",\n-                        sub,\n-                        if opt_span.is_some() { \" as required by this binding\" } else { \"\" },\n-                        opt_span,\n-                    ),\n-                }\n-                err\n-            }\n-            infer::RelateRegionParamBound(span) => {\n-                let mut err =\n-                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"lifetime parameter instantiated with \",\n-                    sup,\n-                    \"\",\n-                    None,\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"but lifetime parameter must outlive \",\n-                    sub,\n-                    \"\",\n-                    None,\n-                );\n-                err\n-            }\n-            infer::DataBorrowed(ty, span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0490,\n-                    \"a value of type `{}` is borrowed for too long\",\n-                    self.ty_to_string(ty)\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"the type is valid for \",\n-                    sub,\n-                    \"\",\n-                    None,\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"but the borrow lasts for \",\n-                    sup,\n-                    \"\",\n-                    None,\n-                );\n-                err\n-            }\n-            infer::ReferenceOutlivesReferent(ty, span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0491,\n-                    \"in type `{}`, reference has a longer lifetime than the data it references\",\n-                    self.ty_to_string(ty)\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"the pointer is valid for \",\n-                    sub,\n-                    \"\",\n-                    None,\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"but the referenced data is only valid for \",\n-                    sup,\n-                    \"\",\n-                    None,\n-                );\n-                err\n-            }\n-            infer::CompareImplItemObligation { span, impl_item_def_id, trait_item_def_id } => self\n-                .report_extra_impl_obligation(\n-                    span,\n-                    impl_item_def_id,\n-                    trait_item_def_id,\n-                    &format!(\"`{}: {}`\", sup, sub),\n-                ),\n-            infer::CheckAssociatedTypeBounds { impl_item_def_id, trait_item_def_id, parent } => {\n-                let mut err = self.report_concrete_failure(*parent, sub, sup);\n-\n-                let trait_item_span = self.tcx.def_span(trait_item_def_id);\n-                let item_name = self.tcx.item_name(impl_item_def_id.to_def_id());\n-                err.span_label(\n-                    trait_item_span,\n-                    format!(\"definition of `{}` from trait\", item_name),\n-                );\n-\n-                let trait_predicates = self.tcx.explicit_predicates_of(trait_item_def_id);\n-                let impl_predicates = self.tcx.explicit_predicates_of(impl_item_def_id);\n-\n-                let impl_predicates: rustc_data_structures::fx::FxHashSet<_> =\n-                    impl_predicates.predicates.into_iter().map(|(pred, _)| pred).collect();\n-                let clauses: Vec<_> = trait_predicates\n-                    .predicates\n-                    .into_iter()\n-                    .filter(|&(pred, _)| !impl_predicates.contains(pred))\n-                    .map(|(pred, _)| format!(\"{}\", pred))\n-                    .collect();\n-\n-                if !clauses.is_empty() {\n-                    let generics = self.tcx.hir().get_generics(impl_item_def_id).unwrap();\n-                    let where_clause_span = generics.tail_span_for_predicate_suggestion();\n-\n-                    let suggestion = format!(\n-                        \"{} {}\",\n-                        generics.add_where_or_trailing_comma(),\n-                        clauses.join(\", \"),\n-                    );\n-                    err.span_suggestion(\n-                        where_clause_span,\n-                        &format!(\n-                            \"try copying {} from the trait\",\n-                            if clauses.len() > 1 { \"these clauses\" } else { \"this clause\" }\n-                        ),\n-                        suggestion,\n-                        rustc_errors::Applicability::MaybeIncorrect,\n-                    );\n-                }\n-\n-                err\n-            }\n-            infer::AscribeUserTypeProvePredicate(span) => {\n-                let mut err =\n-                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"lifetime instantiated with \",\n-                    sup,\n-                    \"\",\n-                    None,\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"but lifetime must outlive \",\n-                    sub,\n-                    \"\",\n-                    None,\n-                );\n-                err\n-            }\n-        }\n-    }\n-\n-    pub(super) fn report_placeholder_failure(\n-        &self,\n-        placeholder_origin: SubregionOrigin<'tcx>,\n-        sub: Region<'tcx>,\n-        sup: Region<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        // I can't think how to do better than this right now. -nikomatsakis\n-        debug!(?placeholder_origin, ?sub, ?sup, \"report_placeholder_failure\");\n-        match placeholder_origin {\n-            infer::Subtype(box ref trace)\n-                if matches!(\n-                    &trace.cause.code().peel_derives(),\n-                    ObligationCauseCode::BindingObligation(..)\n-                        | ObligationCauseCode::ExprBindingObligation(..)\n-                ) =>\n-            {\n-                // Hack to get around the borrow checker because trace.cause has an `Rc`.\n-                if let ObligationCauseCode::BindingObligation(_, span)\n-                | ObligationCauseCode::ExprBindingObligation(_, span, ..) =\n-                    &trace.cause.code().peel_derives()\n-                {\n-                    let span = *span;\n-                    let mut err = self.report_concrete_failure(placeholder_origin, sub, sup);\n-                    err.span_note(span, \"the lifetime requirement is introduced here\");\n-                    err\n-                } else {\n-                    unreachable!()\n-                }\n-            }\n-            infer::Subtype(box trace) => {\n-                let terr = TypeError::RegionsPlaceholderMismatch;\n-                return self.report_and_explain_type_error(trace, terr);\n-            }\n-            _ => return self.report_concrete_failure(placeholder_origin, sub, sup),\n-        }\n-    }\n-}"}, {"sha": "2ccbd164faaf16d1926814d2319190848bb0cee7", "filename": "compiler/rustc_infer/src/infer/note.rs", "status": "removed", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/9b889e53e78a186a861a8407c225f9d8e0d436f5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b889e53e78a186a861a8407c225f9d8e0d436f5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnote.rs?ref=9b889e53e78a186a861a8407c225f9d8e0d436f5", "patch": "@@ -1,203 +0,0 @@\n-impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n-    fn note_error_origin(\n-        &self,\n-        err: &mut Diagnostic,\n-        cause: &ObligationCause<'tcx>,\n-        exp_found: Option<ty::error::ExpectedFound<Ty<'tcx>>>,\n-        terr: TypeError<'tcx>,\n-    ) {\n-        match *cause.code() {\n-            ObligationCauseCode::Pattern { origin_expr: true, span: Some(span), root_ty } => {\n-                let ty = self.resolve_vars_if_possible(root_ty);\n-                if !matches!(ty.kind(), ty::Infer(ty::InferTy::TyVar(_) | ty::InferTy::FreshTy(_)))\n-                {\n-                    // don't show type `_`\n-                    if span.desugaring_kind() == Some(DesugaringKind::ForLoop)\n-                        && let ty::Adt(def, substs) = ty.kind()\n-                        && Some(def.did()) == self.tcx.get_diagnostic_item(sym::Option)\n-                    {\n-                        err.span_label(span, format!(\"this is an iterator with items of type `{}`\", substs.type_at(0)));\n-                    } else {\n-                    err.span_label(span, format!(\"this expression has type `{}`\", ty));\n-                }\n-                }\n-                if let Some(ty::error::ExpectedFound { found, .. }) = exp_found\n-                    && ty.is_box() && ty.boxed_ty() == found\n-                    && let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n-                {\n-                    err.span_suggestion(\n-                        span,\n-                        \"consider dereferencing the boxed value\",\n-                        format!(\"*{}\", snippet),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-            ObligationCauseCode::Pattern { origin_expr: false, span: Some(span), .. } => {\n-                err.span_label(span, \"expected due to this\");\n-            }\n-            ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n-                arm_block_id,\n-                arm_span,\n-                arm_ty,\n-                prior_arm_block_id,\n-                prior_arm_span,\n-                prior_arm_ty,\n-                source,\n-                ref prior_arms,\n-                scrut_hir_id,\n-                opt_suggest_box_span,\n-                scrut_span,\n-                ..\n-            }) => match source {\n-                hir::MatchSource::TryDesugar => {\n-                    if let Some(ty::error::ExpectedFound { expected, .. }) = exp_found {\n-                        let scrut_expr = self.tcx.hir().expect_expr(scrut_hir_id);\n-                        let scrut_ty = if let hir::ExprKind::Call(_, args) = &scrut_expr.kind {\n-                            let arg_expr = args.first().expect(\"try desugaring call w/out arg\");\n-                            self.typeck_results.as_ref().and_then(|typeck_results| {\n-                                typeck_results.expr_ty_opt(arg_expr)\n-                            })\n-                        } else {\n-                            bug!(\"try desugaring w/out call expr as scrutinee\");\n-                        };\n-\n-                        match scrut_ty {\n-                            Some(ty) if expected == ty => {\n-                                let source_map = self.tcx.sess.source_map();\n-                                err.span_suggestion(\n-                                    source_map.end_point(cause.span),\n-                                    \"try removing this `?`\",\n-                                    \"\",\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            }\n-                            _ => {}\n-                        }\n-                    }\n-                }\n-                _ => {\n-                    // `prior_arm_ty` can be `!`, `expected` will have better info when present.\n-                    let t = self.resolve_vars_if_possible(match exp_found {\n-                        Some(ty::error::ExpectedFound { expected, .. }) => expected,\n-                        _ => prior_arm_ty,\n-                    });\n-                    let source_map = self.tcx.sess.source_map();\n-                    let mut any_multiline_arm = source_map.is_multiline(arm_span);\n-                    if prior_arms.len() <= 4 {\n-                        for sp in prior_arms {\n-                            any_multiline_arm |= source_map.is_multiline(*sp);\n-                            err.span_label(*sp, format!(\"this is found to be of type `{}`\", t));\n-                        }\n-                    } else if let Some(sp) = prior_arms.last() {\n-                        any_multiline_arm |= source_map.is_multiline(*sp);\n-                        err.span_label(\n-                            *sp,\n-                            format!(\"this and all prior arms are found to be of type `{}`\", t),\n-                        );\n-                    }\n-                    let outer_error_span = if any_multiline_arm {\n-                        // Cover just `match` and the scrutinee expression, not\n-                        // the entire match body, to reduce diagram noise.\n-                        cause.span.shrink_to_lo().to(scrut_span)\n-                    } else {\n-                        cause.span\n-                    };\n-                    let msg = \"`match` arms have incompatible types\";\n-                    err.span_label(outer_error_span, msg);\n-                    self.suggest_remove_semi_or_return_binding(\n-                        err,\n-                        prior_arm_block_id,\n-                        prior_arm_ty,\n-                        prior_arm_span,\n-                        arm_block_id,\n-                        arm_ty,\n-                        arm_span,\n-                    );\n-                    if let Some(ret_sp) = opt_suggest_box_span {\n-                        // Get return type span and point to it.\n-                        self.suggest_boxing_for_return_impl_trait(\n-                            err,\n-                            ret_sp,\n-                            prior_arms.iter().chain(std::iter::once(&arm_span)).map(|s| *s),\n-                        );\n-                    }\n-                }\n-            },\n-            ObligationCauseCode::IfExpression(box IfExpressionCause {\n-                then_id,\n-                else_id,\n-                then_ty,\n-                else_ty,\n-                outer_span,\n-                opt_suggest_box_span,\n-            }) => {\n-                let then_span = self.find_block_span_from_hir_id(then_id);\n-                let else_span = self.find_block_span_from_hir_id(else_id);\n-                err.span_label(then_span, \"expected because of this\");\n-                if let Some(sp) = outer_span {\n-                    err.span_label(sp, \"`if` and `else` have incompatible types\");\n-                }\n-                self.suggest_remove_semi_or_return_binding(\n-                    err,\n-                    Some(then_id),\n-                    then_ty,\n-                    then_span,\n-                    Some(else_id),\n-                    else_ty,\n-                    else_span,\n-                );\n-                if let Some(ret_sp) = opt_suggest_box_span {\n-                    self.suggest_boxing_for_return_impl_trait(\n-                        err,\n-                        ret_sp,\n-                        [then_span, else_span].into_iter(),\n-                    );\n-                }\n-            }\n-            ObligationCauseCode::LetElse => {\n-                err.help(\"try adding a diverging expression, such as `return` or `panic!(..)`\");\n-                err.help(\"...or use `match` instead of `let...else`\");\n-            }\n-            _ => {\n-                if let ObligationCauseCode::BindingObligation(_, span)\n-                | ObligationCauseCode::ExprBindingObligation(_, span, ..)\n-                = cause.code().peel_derives()\n-                    && let TypeError::RegionsPlaceholderMismatch = terr\n-                {\n-                    err.span_note( * span,\n-                    \"the lifetime requirement is introduced here\");\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> InferCtxt<'tcx> {\n-    /// Given a [`hir::Block`], get the span of its last expression or\n-    /// statement, peeling off any inner blocks.\n-    pub fn find_block_span(&self, block: &'tcx hir::Block<'tcx>) -> Span {\n-        let block = block.innermost_block();\n-        if let Some(expr) = &block.expr {\n-            expr.span\n-        } else if let Some(stmt) = block.stmts.last() {\n-            // possibly incorrect trailing `;` in the else arm\n-            stmt.span\n-        } else {\n-            // empty block; point at its entirety\n-            block.span\n-        }\n-    }\n-\n-    /// Given a [`hir::HirId`] for a block, get the span of its last expression\n-    /// or statement, peeling off any inner blocks.\n-    pub fn find_block_span_from_hir_id(&self, hir_id: hir::HirId) -> Span {\n-        match self.tcx.hir().get(hir_id) {\n-            hir::Node::Block(blk) => self.find_block_span(blk),\n-            // The parser was in a weird state if either of these happen, but\n-            // it's better not to panic.\n-            hir::Node::Expr(e) => e.span,\n-            _ => rustc_span::DUMMY_SP,\n-        }\n-    }\n-}"}, {"sha": "44ee4172675e0cad8517323d9dcd8d10dba32760", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -61,6 +61,7 @@ mod late;\n mod let_underscore;\n mod levels;\n mod methods;\n+mod multiple_supertrait_upcastable;\n mod non_ascii_idents;\n mod non_fmt_panic;\n mod nonstandard_style;\n@@ -95,6 +96,7 @@ use hidden_unicode_codepoints::*;\n use internal::*;\n use let_underscore::*;\n use methods::*;\n+use multiple_supertrait_upcastable::*;\n use non_ascii_idents::*;\n use non_fmt_panic::NonPanicFmt;\n use nonstandard_style::*;\n@@ -229,6 +231,7 @@ late_lint_methods!(\n             InvalidAtomicOrdering: InvalidAtomicOrdering,\n             NamedAsmLabels: NamedAsmLabels,\n             OpaqueHiddenInferredBound: OpaqueHiddenInferredBound,\n+            MultipleSupertraitUpcastable: MultipleSupertraitUpcastable,\n         ]\n     ]\n );"}, {"sha": "5861b826b1ca337309631b1ed4c5e0947f9adaf7", "filename": "compiler/rustc_lint/src/multiple_supertrait_upcastable.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/compiler%2Frustc_lint%2Fsrc%2Fmultiple_supertrait_upcastable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/compiler%2Frustc_lint%2Fsrc%2Fmultiple_supertrait_upcastable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fmultiple_supertrait_upcastable.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -0,0 +1,63 @@\n+use crate::{LateContext, LateLintPass, LintContext};\n+\n+use rustc_errors::DelayDm;\n+use rustc_hir as hir;\n+use rustc_span::sym;\n+\n+declare_lint! {\n+    /// The `multiple_supertrait_upcastable` lint detects when an object-safe trait has multiple\n+    /// supertraits.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// trait A {}\n+    /// trait B {}\n+    ///\n+    /// #[warn(multiple_supertrait_upcastable)]\n+    /// trait C: A + B {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// To support upcasting with multiple supertraits, we need to store multiple vtables and this\n+    /// can result in extra space overhead, even if no code actually uses upcasting.\n+    /// This lint allows users to identify when such scenarios occur and to decide whether the\n+    /// additional overhead is justified.\n+    pub MULTIPLE_SUPERTRAIT_UPCASTABLE,\n+    Allow,\n+    \"detect when an object-safe trait has multiple supertraits\",\n+    @feature_gate = sym::multiple_supertrait_upcastable;\n+}\n+\n+declare_lint_pass!(MultipleSupertraitUpcastable => [MULTIPLE_SUPERTRAIT_UPCASTABLE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for MultipleSupertraitUpcastable {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n+        let def_id = item.owner_id.to_def_id();\n+        if let hir::ItemKind::Trait(_, _, _, _, _) = item.kind\n+            && cx.tcx.is_object_safe(def_id)\n+        {\n+            let direct_super_traits_iter = cx.tcx\n+                    .super_predicates_of(def_id)\n+                    .predicates\n+                    .into_iter()\n+                    .filter_map(|(pred, _)| pred.to_opt_poly_trait_pred());\n+            if direct_super_traits_iter.count() > 1 {\n+                cx.struct_span_lint(\n+                    MULTIPLE_SUPERTRAIT_UPCASTABLE,\n+                    cx.tcx.def_span(def_id),\n+                    DelayDm(|| {\n+                        format!(\n+                            \"`{}` is object-safe and has multiple supertraits\",\n+                            item.ident,\n+                        )\n+                    }),\n+                    |diag| diag,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "da37dab6a9caec8ef8edbdcce6781d2e445fba37", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -943,6 +943,7 @@ symbols! {\n         mul,\n         mul_assign,\n         mul_with_overflow,\n+        multiple_supertrait_upcastable,\n         must_not_suspend,\n         must_use,\n         naked,"}, {"sha": "b5fe8d72f7d2440be0fb824a4dc96d8c102e010d", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -954,7 +954,7 @@ impl<T: ?Sized> Box<T> {\n     /// [`Layout`]: crate::Layout\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n-    #[must_use = \"call `drop(from_raw(ptr))` if you intend to drop the `Box`\"]\n+    #[must_use = \"call `drop(Box::from_raw(ptr))` if you intend to drop the `Box`\"]\n     pub unsafe fn from_raw(raw: *mut T) -> Self {\n         unsafe { Self::from_raw_in(raw, Global) }\n     }"}, {"sha": "fe08e0e10e818440c1e1cc9f3b05ae25748c18bb", "filename": "library/alloc/src/collections/binary_heap/tests.rs", "status": "modified", "additions": 74, "deletions": 24, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Ftests.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -1,8 +1,8 @@\n use super::*;\n use crate::boxed::Box;\n+use crate::testing::crash_test::{CrashTestDummy, Panic};\n use std::iter::TrustedLen;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n-use std::sync::atomic::{AtomicU32, Ordering};\n \n #[test]\n fn test_iterator() {\n@@ -291,33 +291,83 @@ fn test_drain_sorted() {\n \n #[test]\n fn test_drain_sorted_leak() {\n-    static DROPS: AtomicU32 = AtomicU32::new(0);\n-\n-    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n-    struct D(u32, bool);\n-\n-    impl Drop for D {\n-        fn drop(&mut self) {\n-            DROPS.fetch_add(1, Ordering::SeqCst);\n-\n-            if self.1 {\n-                panic!(\"panic in `drop`\");\n-            }\n-        }\n-    }\n-\n+    let d0 = CrashTestDummy::new(0);\n+    let d1 = CrashTestDummy::new(1);\n+    let d2 = CrashTestDummy::new(2);\n+    let d3 = CrashTestDummy::new(3);\n+    let d4 = CrashTestDummy::new(4);\n+    let d5 = CrashTestDummy::new(5);\n     let mut q = BinaryHeap::from(vec![\n-        D(0, false),\n-        D(1, false),\n-        D(2, false),\n-        D(3, true),\n-        D(4, false),\n-        D(5, false),\n+        d0.spawn(Panic::Never),\n+        d1.spawn(Panic::Never),\n+        d2.spawn(Panic::Never),\n+        d3.spawn(Panic::InDrop),\n+        d4.spawn(Panic::Never),\n+        d5.spawn(Panic::Never),\n     ]);\n \n-    catch_unwind(AssertUnwindSafe(|| drop(q.drain_sorted()))).ok();\n+    catch_unwind(AssertUnwindSafe(|| drop(q.drain_sorted()))).unwrap_err();\n+\n+    assert_eq!(d0.dropped(), 1);\n+    assert_eq!(d1.dropped(), 1);\n+    assert_eq!(d2.dropped(), 1);\n+    assert_eq!(d3.dropped(), 1);\n+    assert_eq!(d4.dropped(), 1);\n+    assert_eq!(d5.dropped(), 1);\n+    assert!(q.is_empty());\n+}\n \n-    assert_eq!(DROPS.load(Ordering::SeqCst), 6);\n+#[test]\n+fn test_drain_forget() {\n+    let a = CrashTestDummy::new(0);\n+    let b = CrashTestDummy::new(1);\n+    let c = CrashTestDummy::new(2);\n+    let mut q =\n+        BinaryHeap::from(vec![a.spawn(Panic::Never), b.spawn(Panic::Never), c.spawn(Panic::Never)]);\n+\n+    catch_unwind(AssertUnwindSafe(|| {\n+        let mut it = q.drain();\n+        it.next();\n+        mem::forget(it);\n+    }))\n+    .unwrap();\n+    // Behaviour after leaking is explicitly unspecified and order is arbitrary,\n+    // so it's fine if these start failing, but probably worth knowing.\n+    assert!(q.is_empty());\n+    assert_eq!(a.dropped() + b.dropped() + c.dropped(), 1);\n+    assert_eq!(a.dropped(), 0);\n+    assert_eq!(b.dropped(), 0);\n+    assert_eq!(c.dropped(), 1);\n+    drop(q);\n+    assert_eq!(a.dropped(), 0);\n+    assert_eq!(b.dropped(), 0);\n+    assert_eq!(c.dropped(), 1);\n+}\n+\n+#[test]\n+fn test_drain_sorted_forget() {\n+    let a = CrashTestDummy::new(0);\n+    let b = CrashTestDummy::new(1);\n+    let c = CrashTestDummy::new(2);\n+    let mut q =\n+        BinaryHeap::from(vec![a.spawn(Panic::Never), b.spawn(Panic::Never), c.spawn(Panic::Never)]);\n+\n+    catch_unwind(AssertUnwindSafe(|| {\n+        let mut it = q.drain_sorted();\n+        it.next();\n+        mem::forget(it);\n+    }))\n+    .unwrap();\n+    // Behaviour after leaking is explicitly unspecified,\n+    // so it's fine if these start failing, but probably worth knowing.\n+    assert_eq!(q.len(), 2);\n+    assert_eq!(a.dropped(), 0);\n+    assert_eq!(b.dropped(), 0);\n+    assert_eq!(c.dropped(), 1);\n+    drop(q);\n+    assert_eq!(a.dropped(), 1);\n+    assert_eq!(b.dropped(), 1);\n+    assert_eq!(c.dropped(), 1);\n }\n \n #[test]"}, {"sha": "700b1463bfd51f961e8b7bb2cb43e991c9473d4e", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -1,12 +1,12 @@\n-use super::super::testing::crash_test::{CrashTestDummy, Panic};\n-use super::super::testing::ord_chaos::{Cyclic3, Governed, Governor};\n-use super::super::testing::rng::DeterministicRng;\n use super::Entry::{Occupied, Vacant};\n use super::*;\n use crate::boxed::Box;\n use crate::fmt::Debug;\n use crate::rc::Rc;\n use crate::string::{String, ToString};\n+use crate::testing::crash_test::{CrashTestDummy, Panic};\n+use crate::testing::ord_chaos::{Cyclic3, Governed, Governor};\n+use crate::testing::rng::DeterministicRng;\n use crate::vec::Vec;\n use std::cmp::Ordering;\n use std::convert::TryFrom;"}, {"sha": "7552f2fc04ce8baf63f9db30ff7c7e07b254e542", "filename": "library/alloc/src/collections/btree/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -21,6 +21,3 @@ trait Recover<Q: ?Sized> {\n     fn take(&mut self, key: &Q) -> Option<Self::Key>;\n     fn replace(&mut self, key: Self::Key) -> Option<Self::Key>;\n }\n-\n-#[cfg(test)]\n-mod testing;"}, {"sha": "7b8d41a603176b07a1e3a6b648ab9cbac577f14d", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -1,6 +1,6 @@\n-use super::super::testing::crash_test::{CrashTestDummy, Panic};\n-use super::super::testing::rng::DeterministicRng;\n use super::*;\n+use crate::testing::crash_test::{CrashTestDummy, Panic};\n+use crate::testing::rng::DeterministicRng;\n use crate::vec::Vec;\n use std::cmp::Ordering;\n use std::hash::{Hash, Hasher};"}, {"sha": "5d5af22bb292fcecb63aa65bf80c3f9a551c6732", "filename": "library/alloc/src/collections/linked_list/tests.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -1,4 +1,5 @@\n use super::*;\n+use crate::testing::crash_test::{CrashTestDummy, Panic};\n use crate::vec::Vec;\n \n use std::panic::{catch_unwind, AssertUnwindSafe};\n@@ -984,35 +985,34 @@ fn drain_filter_complex() {\n \n #[test]\n fn drain_filter_drop_panic_leak() {\n-    static mut DROPS: i32 = 0;\n-\n-    struct D(bool);\n-\n-    impl Drop for D {\n-        fn drop(&mut self) {\n-            unsafe {\n-                DROPS += 1;\n-            }\n-\n-            if self.0 {\n-                panic!(\"panic in `drop`\");\n-            }\n-        }\n-    }\n-\n+    let d0 = CrashTestDummy::new(0);\n+    let d1 = CrashTestDummy::new(1);\n+    let d2 = CrashTestDummy::new(2);\n+    let d3 = CrashTestDummy::new(3);\n+    let d4 = CrashTestDummy::new(4);\n+    let d5 = CrashTestDummy::new(5);\n+    let d6 = CrashTestDummy::new(6);\n+    let d7 = CrashTestDummy::new(7);\n     let mut q = LinkedList::new();\n-    q.push_back(D(false));\n-    q.push_back(D(false));\n-    q.push_back(D(false));\n-    q.push_back(D(false));\n-    q.push_back(D(false));\n-    q.push_front(D(false));\n-    q.push_front(D(true));\n-    q.push_front(D(false));\n-\n-    catch_unwind(AssertUnwindSafe(|| drop(q.drain_filter(|_| true)))).ok();\n-\n-    assert_eq!(unsafe { DROPS }, 8);\n+    q.push_back(d3.spawn(Panic::Never));\n+    q.push_back(d4.spawn(Panic::Never));\n+    q.push_back(d5.spawn(Panic::Never));\n+    q.push_back(d6.spawn(Panic::Never));\n+    q.push_back(d7.spawn(Panic::Never));\n+    q.push_front(d2.spawn(Panic::Never));\n+    q.push_front(d1.spawn(Panic::InDrop));\n+    q.push_front(d0.spawn(Panic::Never));\n+\n+    catch_unwind(AssertUnwindSafe(|| drop(q.drain_filter(|_| true)))).unwrap_err();\n+\n+    assert_eq!(d0.dropped(), 1);\n+    assert_eq!(d1.dropped(), 1);\n+    assert_eq!(d2.dropped(), 1);\n+    assert_eq!(d3.dropped(), 1);\n+    assert_eq!(d4.dropped(), 1);\n+    assert_eq!(d5.dropped(), 1);\n+    assert_eq!(d6.dropped(), 1);\n+    assert_eq!(d7.dropped(), 1);\n     assert!(q.is_empty());\n }\n "}, {"sha": "fb1664ba7a24858858aab3f7a83c5a797f9c63a1", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -87,6 +87,7 @@\n #![warn(missing_debug_implementations)]\n #![warn(missing_docs)]\n #![allow(explicit_outlives_requirements)]\n+#![cfg_attr(not(bootstrap), warn(multiple_supertrait_upcastable))]\n //\n // Library features:\n #![feature(alloc_layout_extra)]\n@@ -190,6 +191,7 @@\n #![feature(unsized_fn_params)]\n #![feature(c_unwind)]\n #![feature(with_negative_coherence)]\n+#![cfg_attr(not(bootstrap), feature(multiple_supertrait_upcastable))]\n //\n // Rustdoc features:\n #![feature(doc_cfg)]\n@@ -206,6 +208,8 @@\n extern crate std;\n #[cfg(test)]\n extern crate test;\n+#[cfg(test)]\n+mod testing;\n \n // Module with internal macros used by other modules (needs to be included before other modules).\n #[macro_use]"}, {"sha": "bcf5f5f72510e199093cf978e87411166e3003bc", "filename": "library/alloc/src/testing/crash_test.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Falloc%2Fsrc%2Ftesting%2Fcrash_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Falloc%2Fsrc%2Ftesting%2Fcrash_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Ftesting%2Fcrash_test.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "previous_filename": "library/alloc/src/collections/btree/testing/crash_test.rs"}, {"sha": "7a094f8a59522216ad1891e2beac432695737300", "filename": "library/alloc/src/testing/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Falloc%2Fsrc%2Ftesting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Falloc%2Fsrc%2Ftesting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Ftesting%2Fmod.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "previous_filename": "library/alloc/src/collections/btree/testing/mod.rs"}, {"sha": "96ce7c15790463b3770285f6395859d64ea9afdc", "filename": "library/alloc/src/testing/ord_chaos.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Falloc%2Fsrc%2Ftesting%2Ford_chaos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Falloc%2Fsrc%2Ftesting%2Ford_chaos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Ftesting%2Ford_chaos.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "previous_filename": "library/alloc/src/collections/btree/testing/ord_chaos.rs"}, {"sha": "ecf543bee035a38a9adc7f08360c5c57876290c7", "filename": "library/alloc/src/testing/rng.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Falloc%2Fsrc%2Ftesting%2Frng.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Falloc%2Fsrc%2Ftesting%2Frng.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Ftesting%2Frng.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "previous_filename": "library/alloc/src/collections/btree/testing/rng.rs"}, {"sha": "9ca4947ed8f8bb7978870a8a6c01880f7b1d8bdc", "filename": "library/core/src/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Fcore%2Fsrc%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Fcore%2Fsrc%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fany.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -148,7 +148,7 @@\n //! ```\n //!\n //! In this example, if the concrete type of `obj` in `use_my_trait` is `SomeConcreteType`, then\n-//! the `get_context_ref` call will return a reference to `obj.some_string` with type `&String`.\n+//! the `get_context_by_ref` call will return a reference to `obj.some_string` with type `&String`.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "d2fac23ff18be7542729e0b6793d796daad17dd5", "filename": "library/core/src/error.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Fcore%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Fcore%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ferror.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -28,6 +28,7 @@ use crate::fmt::{Debug, Display};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"Error\")]\n #[rustc_has_incoherent_inherent_impls]\n+#[cfg_attr(not(bootstrap), allow(multiple_supertrait_upcastable))]\n pub trait Error: Debug + Display {\n     /// The lower-level source of this error, if any.\n     ///"}, {"sha": "617dfd12383fb649e9e76ab8f9fed16e06ecec6b", "filename": "library/core/src/iter/sources/empty.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fempty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fempty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fempty.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -22,17 +22,12 @@ pub const fn empty<T>() -> Empty<T> {\n     Empty(marker::PhantomData)\n }\n \n-// Newtype for use in `PhantomData` to avoid\n-// > error: const-stable function cannot use `#[feature(const_fn_fn_ptr_basics)]`\n-// in `const fn empty<T>()` above.\n-struct FnReturning<T>(fn() -> T);\n-\n /// An iterator that yields nothing.\n ///\n /// This `struct` is created by the [`empty()`] function. See its documentation for more.\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-pub struct Empty<T>(marker::PhantomData<FnReturning<T>>);\n+pub struct Empty<T>(marker::PhantomData<fn() -> T>);\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n impl<T> fmt::Debug for Empty<T> {"}, {"sha": "825c8541f0d18de0196d0ad9562be68c8cb16438", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -95,6 +95,7 @@\n #![warn(missing_docs)]\n #![allow(explicit_outlives_requirements)]\n #![allow(incomplete_features)]\n+#![cfg_attr(not(bootstrap), warn(multiple_supertrait_upcastable))]\n //\n // Library features:\n #![feature(const_align_offset)]\n@@ -231,6 +232,7 @@\n #![feature(unsized_fn_params)]\n #![feature(asm_const)]\n #![feature(const_transmute_copy)]\n+#![cfg_attr(not(bootstrap), feature(multiple_supertrait_upcastable))]\n //\n // Target features:\n #![feature(arm_target_feature)]"}, {"sha": "e030c55ce8f6161753b3e517535fef6f49861344", "filename": "library/std/src/sync/mpmc/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -136,7 +136,7 @@ impl Backoff {\n         }\n     }\n \n-    /// Returns `true` if exponential backoff has completed and blocking the thread is advised.\n+    /// Returns `true` if quadratic backoff has completed and blocking the thread is advised.\n     #[inline]\n     pub fn is_completed(&self) -> bool {\n         self.step.get() > YIELD_LIMIT"}, {"sha": "0467dea621b4c2a063b4de2f83ba99ac4905bfb8", "filename": "src/test/ui/feature-gates/feature-gate-multiple_supertrait_upcastable.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-multiple_supertrait_upcastable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-multiple_supertrait_upcastable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-multiple_supertrait_upcastable.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+\n+#![deny(multiple_supertrait_upcastable)]\n+//~^ WARNING unknown lint: `multiple_supertrait_upcastable`\n+//~| WARNING unknown lint: `multiple_supertrait_upcastable`\n+//~| WARNING unknown lint: `multiple_supertrait_upcastable`\n+#![warn(multiple_supertrait_upcastable)]\n+//~^ WARNING unknown lint: `multiple_supertrait_upcastable`\n+//~| WARNING unknown lint: `multiple_supertrait_upcastable`\n+//~| WARNING unknown lint: `multiple_supertrait_upcastable`\n+\n+fn main() {}"}, {"sha": "1f725f35417785e05aad434e5797fa07f181ec32", "filename": "src/test/ui/feature-gates/feature-gate-multiple_supertrait_upcastable.stderr", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-multiple_supertrait_upcastable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-multiple_supertrait_upcastable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-multiple_supertrait_upcastable.stderr?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -0,0 +1,57 @@\n+warning: unknown lint: `multiple_supertrait_upcastable`\n+  --> $DIR/feature-gate-multiple_supertrait_upcastable.rs:3:1\n+   |\n+LL | #![deny(multiple_supertrait_upcastable)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the `multiple_supertrait_upcastable` lint is unstable\n+   = help: add `#![feature(multiple_supertrait_upcastable)]` to the crate attributes to enable\n+   = note: `#[warn(unknown_lints)]` on by default\n+\n+warning: unknown lint: `multiple_supertrait_upcastable`\n+  --> $DIR/feature-gate-multiple_supertrait_upcastable.rs:7:1\n+   |\n+LL | #![warn(multiple_supertrait_upcastable)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the `multiple_supertrait_upcastable` lint is unstable\n+   = help: add `#![feature(multiple_supertrait_upcastable)]` to the crate attributes to enable\n+\n+warning: unknown lint: `multiple_supertrait_upcastable`\n+  --> $DIR/feature-gate-multiple_supertrait_upcastable.rs:3:1\n+   |\n+LL | #![deny(multiple_supertrait_upcastable)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the `multiple_supertrait_upcastable` lint is unstable\n+   = help: add `#![feature(multiple_supertrait_upcastable)]` to the crate attributes to enable\n+\n+warning: unknown lint: `multiple_supertrait_upcastable`\n+  --> $DIR/feature-gate-multiple_supertrait_upcastable.rs:7:1\n+   |\n+LL | #![warn(multiple_supertrait_upcastable)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the `multiple_supertrait_upcastable` lint is unstable\n+   = help: add `#![feature(multiple_supertrait_upcastable)]` to the crate attributes to enable\n+\n+warning: unknown lint: `multiple_supertrait_upcastable`\n+  --> $DIR/feature-gate-multiple_supertrait_upcastable.rs:3:1\n+   |\n+LL | #![deny(multiple_supertrait_upcastable)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the `multiple_supertrait_upcastable` lint is unstable\n+   = help: add `#![feature(multiple_supertrait_upcastable)]` to the crate attributes to enable\n+\n+warning: unknown lint: `multiple_supertrait_upcastable`\n+  --> $DIR/feature-gate-multiple_supertrait_upcastable.rs:7:1\n+   |\n+LL | #![warn(multiple_supertrait_upcastable)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the `multiple_supertrait_upcastable` lint is unstable\n+   = help: add `#![feature(multiple_supertrait_upcastable)]` to the crate attributes to enable\n+\n+warning: 6 warnings emitted\n+"}, {"sha": "47ab613bec21c1b5f0e64522a27a2f085ca0e2f2", "filename": "src/test/ui/lint/unused/must-use-box-from-raw.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/src%2Ftest%2Fui%2Flint%2Funused%2Fmust-use-box-from-raw.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/src%2Ftest%2Fui%2Flint%2Funused%2Fmust-use-box-from-raw.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Fmust-use-box-from-raw.stderr?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -4,7 +4,7 @@ warning: unused return value of `Box::<T>::from_raw` that must be used\n LL |     Box::from_raw(ptr);\n    |     ^^^^^^^^^^^^^^^^^^\n    |\n-   = note: call `drop(from_raw(ptr))` if you intend to drop the `Box`\n+   = note: call `drop(Box::from_raw(ptr))` if you intend to drop the `Box`\n note: the lint level is defined here\n   --> $DIR/must-use-box-from-raw.rs:5:9\n    |"}, {"sha": "0f69d089f9a89a558659f2dda7f7a3040da0be14", "filename": "src/test/ui/match/single-line.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/src%2Ftest%2Fui%2Fmatch%2Fsingle-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/src%2Ftest%2Fui%2Fmatch%2Fsingle-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fsingle-line.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    let _ = match Some(42) { Some(x) => x, None => \"\" }; //~ ERROR E0308\n+}"}, {"sha": "ec3b76e3f4d5eb4f9d2cb3762bc88150c0db974c", "filename": "src/test/ui/match/single-line.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/src%2Ftest%2Fui%2Fmatch%2Fsingle-line.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/src%2Ftest%2Fui%2Fmatch%2Fsingle-line.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fsingle-line.stderr?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -0,0 +1,12 @@\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/single-line.rs:2:52\n+   |\n+LL |     let _ = match Some(42) { Some(x) => x, None => \"\" };\n+   |             --------------              -          ^^ expected integer, found `&str`\n+   |             |                           |\n+   |             |                           this is found to be of type `{integer}`\n+   |             `match` arms have incompatible types\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "0dd4b4e68469938e7b4f0426abb0186097e27686", "filename": "src/test/ui/repr/transparent-enum-too-many-variants.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/src%2Ftest%2Fui%2Frepr%2Ftransparent-enum-too-many-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/src%2Ftest%2Fui%2Frepr%2Ftransparent-enum-too-many-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepr%2Ftransparent-enum-too-many-variants.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -0,0 +1,10 @@\n+use std::mem::size_of;\n+\n+#[repr(transparent)]\n+enum Foo { //~ ERROR E0731\n+    A(u8), B(u8),\n+}\n+\n+fn main() {\n+    println!(\"Foo: {}\", size_of::<Foo>());\n+}"}, {"sha": "fb44757efaf13694c2fbb10cb6e837ab4df47efe", "filename": "src/test/ui/repr/transparent-enum-too-many-variants.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/src%2Ftest%2Fui%2Frepr%2Ftransparent-enum-too-many-variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/src%2Ftest%2Fui%2Frepr%2Ftransparent-enum-too-many-variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepr%2Ftransparent-enum-too-many-variants.stderr?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -0,0 +1,11 @@\n+error[E0731]: transparent enum needs exactly one variant, but has 2\n+  --> $DIR/transparent-enum-too-many-variants.rs:4:1\n+   |\n+LL | enum Foo {\n+   | ^^^^^^^^ needs exactly one variant, but has 2\n+LL |     A(u8), B(u8),\n+   |     -      - too many variants in `Foo`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0731`."}, {"sha": "3c6ab86e4c65ce205360978cd76a534124bad1e0", "filename": "src/test/ui/traits/trait-upcasting/multiple_supertrait_upcastable.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmultiple_supertrait_upcastable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmultiple_supertrait_upcastable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmultiple_supertrait_upcastable.rs?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -0,0 +1,10 @@\n+#![feature(multiple_supertrait_upcastable)]\n+#![deny(multiple_supertrait_upcastable)]\n+\n+trait A {}\n+trait B {}\n+\n+trait C: A + B {}\n+//~^ ERROR `C` is object-safe and has multiple supertraits\n+\n+fn main() {}"}, {"sha": "ad80a009ece80674a72773efc993d868bdecea2a", "filename": "src/test/ui/traits/trait-upcasting/multiple_supertrait_upcastable.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a20f7df5755d8c6b68110d2d0391a7b03268e77/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmultiple_supertrait_upcastable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6a20f7df5755d8c6b68110d2d0391a7b03268e77/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmultiple_supertrait_upcastable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmultiple_supertrait_upcastable.stderr?ref=6a20f7df5755d8c6b68110d2d0391a7b03268e77", "patch": "@@ -0,0 +1,14 @@\n+error: `C` is object-safe and has multiple supertraits\n+  --> $DIR/multiple_supertrait_upcastable.rs:7:1\n+   |\n+LL | trait C: A + B {}\n+   | ^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/multiple_supertrait_upcastable.rs:2:9\n+   |\n+LL | #![deny(multiple_supertrait_upcastable)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}]}