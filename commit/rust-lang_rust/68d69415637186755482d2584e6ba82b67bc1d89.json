{"sha": "68d69415637186755482d2584e6ba82b67bc1d89", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4ZDY5NDE1NjM3MTg2NzU1NDgyZDI1ODRlNmJhODJiNjdiYzFkODk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-20T20:19:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-20T20:19:42Z"}, "message": "Auto merge of #23267 - alexcrichton:issue-20012, r=aturon\n\nThis reverts commit aec67c2.\r\n\r\nCloses #20012\r\n\r\nThis is temporarily rebased on #23245 as it would otherwise conflict, the last commit is the only one relevant to this PR though.", "tree": {"sha": "702068026393f26edf8b134f8dca0219dd1c0255", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/702068026393f26edf8b134f8dca0219dd1c0255"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68d69415637186755482d2584e6ba82b67bc1d89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68d69415637186755482d2584e6ba82b67bc1d89", "html_url": "https://github.com/rust-lang/rust/commit/68d69415637186755482d2584e6ba82b67bc1d89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68d69415637186755482d2584e6ba82b67bc1d89/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3900c089a1305f06c6dbb15d07127b4e3a8f040c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3900c089a1305f06c6dbb15d07127b4e3a8f040c", "html_url": "https://github.com/rust-lang/rust/commit/3900c089a1305f06c6dbb15d07127b4e3a8f040c"}, {"sha": "1cc9718fdef63476ffdf3f0bcd74b554b083f378", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cc9718fdef63476ffdf3f0bcd74b554b083f378", "html_url": "https://github.com/rust-lang/rust/commit/1cc9718fdef63476ffdf3f0bcd74b554b083f378"}], "stats": {"total": 137, "additions": 86, "deletions": 51}, "files": [{"sha": "4537fc763c9536caa7a6ba3ba6312cdff8b71ef4", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/68d69415637186755482d2584e6ba82b67bc1d89/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d69415637186755482d2584e6ba82b67bc1d89/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=68d69415637186755482d2584e6ba82b67bc1d89", "patch": "@@ -183,10 +183,9 @@ use std::io::{self, Stderr};\n use std::io::prelude::*;\n use std::mem;\n use std::env;\n-use std::ptr;\n use std::rt;\n use std::slice;\n-use std::sync::{Once, ONCE_INIT};\n+use std::sync::{Once, ONCE_INIT, StaticMutex, MUTEX_INIT};\n \n use directive::LOG_LEVEL_NAMES;\n \n@@ -202,6 +201,8 @@ pub const MAX_LOG_LEVEL: u32 = 255;\n /// The default logging level of a crate if no other is specified.\n const DEFAULT_LOG_LEVEL: u32 = 1;\n \n+static LOCK: StaticMutex = MUTEX_INIT;\n+\n /// An unsafe constant that is the maximum logging level of any module\n /// specified. This is the first line of defense to determining whether a\n /// logging statement should be run.\n@@ -286,9 +287,18 @@ impl Drop for DefaultLogger {\n pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n     // Test the literal string from args against the current filter, if there\n     // is one.\n-    match unsafe { FILTER.as_ref() } {\n-        Some(filter) if !args.to_string().contains(&filter[..]) => return,\n-        _ => {}\n+    unsafe {\n+        let _g = LOCK.lock();\n+        match FILTER as uint {\n+            0 => {}\n+            1 => panic!(\"cannot log after main thread has exited\"),\n+            n => {\n+                let filter = mem::transmute::<_, &String>(n);\n+                if !args.to_string().contains(&filter[..]) {\n+                    return\n+                }\n+            }\n+        }\n     }\n \n     // Completely remove the local logger from TLS in case anyone attempts to\n@@ -370,9 +380,15 @@ pub fn mod_enabled(level: u32, module: &str) -> bool {\n \n     // This assertion should never get tripped unless we're in an at_exit\n     // handler after logging has been torn down and a logging attempt was made.\n-    assert!(unsafe { !DIRECTIVES.is_null() });\n \n-    enabled(level, module, unsafe { (*DIRECTIVES).iter() })\n+    let _g = LOCK.lock();\n+    unsafe {\n+        assert!(DIRECTIVES as uint != 0);\n+        assert!(DIRECTIVES as uint != 1,\n+                \"cannot log after the main thread has exited\");\n+\n+        enabled(level, module, (*DIRECTIVES).iter())\n+    }\n }\n \n fn enabled(level: u32,\n@@ -428,14 +444,14 @@ fn init() {\n \n         // Schedule the cleanup for the globals for when the runtime exits.\n         rt::at_exit(move || {\n+            let _g = LOCK.lock();\n             assert!(!DIRECTIVES.is_null());\n-            let _directives: Box<Vec<directive::LogDirective>> =\n-                Box::from_raw(DIRECTIVES);\n-            DIRECTIVES = ptr::null_mut();\n+            let _directives = Box::from_raw(DIRECTIVES);\n+            DIRECTIVES = 1 as *mut _;\n \n             if !FILTER.is_null() {\n-                let _filter: Box<String> = Box::from_raw(FILTER);\n-                FILTER = 0 as *mut _;\n+                let _filter = Box::from_raw(FILTER);\n+                FILTER = 1 as *mut _;\n             }\n         });\n     }"}, {"sha": "e52e68dad23faec8358bd4c7f63b501eb1e39e49", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/68d69415637186755482d2584e6ba82b67bc1d89/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d69415637186755482d2584e6ba82b67bc1d89/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=68d69415637186755482d2584e6ba82b67bc1d89", "patch": "@@ -147,20 +147,14 @@ fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n     }\n }\n \n-/// Enqueues a procedure to run when the runtime is cleaned up\n-///\n-/// The procedure passed to this function will be executed as part of the\n-/// runtime cleanup phase. For normal rust programs, this means that it will run\n-/// after all other threads have exited.\n-///\n-/// The procedure is *not* executed with a local `Thread` available to it, so\n-/// primitives like logging, I/O, channels, spawning, etc, are *not* available.\n-/// This is meant for \"bare bones\" usage to clean up runtime details, this is\n-/// not meant as a general-purpose \"let's clean everything up\" function.\n+/// Enqueues a procedure to run when the main thread exits.\n ///\n /// It is forbidden for procedures to register more `at_exit` handlers when they\n /// are running, and doing so will lead to a process abort.\n-pub fn at_exit<F:FnOnce()+Send+'static>(f: F) {\n+///\n+/// Note that other threads may still be running when `at_exit` routines start\n+/// running.\n+pub fn at_exit<F: FnOnce() + Send + 'static>(f: F) {\n     at_exit_imp::push(Thunk::new(f));\n }\n \n@@ -176,8 +170,5 @@ pub fn at_exit<F:FnOnce()+Send+'static>(f: F) {\n pub unsafe fn cleanup() {\n     args::cleanup();\n     sys::stack_overflow::cleanup();\n-    // FIXME: (#20012): the resources being cleaned up by at_exit\n-    // currently are not prepared for cleanup to happen asynchronously\n-    // with detached threads using the resources; for now, we leak.\n-    // at_exit_imp::cleanup();\n+    at_exit_imp::cleanup();\n }"}, {"sha": "3ee3954ed64343c477afa61cb2963d691be9ebea", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/68d69415637186755482d2584e6ba82b67bc1d89/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d69415637186755482d2584e6ba82b67bc1d89/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=68d69415637186755482d2584e6ba82b67bc1d89", "patch": "@@ -69,7 +69,7 @@ use intrinsics;\n use libc::c_void;\n use mem;\n use sync::atomic::{self, Ordering};\n-use sync::{Once, ONCE_INIT};\n+use sys_common::mutex::{Mutex, MUTEX_INIT};\n \n use rt::libunwind as uw;\n \n@@ -534,11 +534,22 @@ pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, uint)) ->\n /// Doing this split took the LLVM IR line counts of `fn main() { panic!()\n /// }` from ~1900/3700 (-O/no opts) to 180/590.\n #[inline(never)] #[cold] // this is the slow path, please never inline this\n-fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) -> ! {\n-    // Make sure the default panic handler is registered before we look at the\n-    // callbacks.\n-    static INIT: Once = ONCE_INIT;\n-    INIT.call_once(|| unsafe { register(panicking::on_panic); });\n+fn begin_unwind_inner(msg: Box<Any + Send>,\n+                      file_line: &(&'static str, uint)) -> ! {\n+    // Make sure the default failure handler is registered before we look at the\n+    // callbacks. We also use a raw sys-based mutex here instead of a\n+    // `std::sync` one as accessing TLS can cause weird recursive problems (and\n+    // we don't need poison checking).\n+    unsafe {\n+        static LOCK: Mutex = MUTEX_INIT;\n+        static mut INIT: bool = false;\n+        LOCK.lock();\n+        if !INIT {\n+            register(panicking::on_panic);\n+            INIT = true;\n+        }\n+        LOCK.unlock();\n+    }\n \n     // First, invoke call the user-defined callbacks triggered on thread panic.\n     //"}, {"sha": "2a852fbcd57e37d3a9399776d34015d83e486f84", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/68d69415637186755482d2584e6ba82b67bc1d89/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d69415637186755482d2584e6ba82b67bc1d89/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=68d69415637186755482d2584e6ba82b67bc1d89", "patch": "@@ -24,7 +24,6 @@ use prelude::v1::*;\n \n use boxed;\n use cell::UnsafeCell;\n-use ptr;\n use rt;\n use sync::{StaticMutex, StaticCondvar};\n use sync::mpsc::{channel, Sender, Receiver};\n@@ -97,7 +96,7 @@ impl<M: Send> Helper<M> {\n     {\n         unsafe {\n             let _guard = self.lock.lock().unwrap();\n-            if !*self.initialized.get() {\n+            if *self.chan.get() as uint == 0 {\n                 let (tx, rx) = channel();\n                 *self.chan.get() = boxed::into_raw(box tx);\n                 let (receive, send) = helper_signal::new();\n@@ -113,8 +112,10 @@ impl<M: Send> Helper<M> {\n                     self.cond.notify_one()\n                 });\n \n-                rt::at_exit(move|| { self.shutdown() });\n+                rt::at_exit(move || { self.shutdown() });\n                 *self.initialized.get() = true;\n+            } else if *self.chan.get() as uint == 1 {\n+                panic!(\"cannot continue usage after shutdown\");\n             }\n         }\n     }\n@@ -129,7 +130,9 @@ impl<M: Send> Helper<M> {\n             // Must send and *then* signal to ensure that the child receives the\n             // message. Otherwise it could wake up and go to sleep before we\n             // send the message.\n-            assert!(!self.chan.get().is_null());\n+            assert!(*self.chan.get() as uint != 0);\n+            assert!(*self.chan.get() as uint != 1,\n+                    \"cannot continue usage after shutdown\");\n             (**self.chan.get()).send(msg).unwrap();\n             helper_signal::signal(*self.signal.get() as helper_signal::signal);\n         }\n@@ -142,9 +145,13 @@ impl<M: Send> Helper<M> {\n             // returns.\n             let mut guard = self.lock.lock().unwrap();\n \n+            let ptr = *self.chan.get();\n+            if ptr as uint == 1 {\n+                panic!(\"cannot continue usage after shutdown\");\n+            }\n             // Close the channel by destroying it\n-            let chan: Box<Sender<M>> = Box::from_raw(*self.chan.get());\n-            *self.chan.get() = ptr::null_mut();\n+            let chan = Box::from_raw(*self.chan.get());\n+            *self.chan.get() = 1 as *mut Sender<M>;\n             drop(chan);\n             helper_signal::signal(*self.signal.get() as helper_signal::signal);\n "}, {"sha": "5e2a138fa63bacb208d23d83b9e6cba0159c84b2", "filename": "src/libstd/sys/common/thread_local.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68d69415637186755482d2584e6ba82b67bc1d89/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d69415637186755482d2584e6ba82b67bc1d89/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs?ref=68d69415637186755482d2584e6ba82b67bc1d89", "patch": "@@ -61,7 +61,6 @@\n use prelude::v1::*;\n \n use sync::atomic::{self, AtomicUsize, Ordering};\n-use sync::{Mutex, Once, ONCE_INIT};\n \n use sys::thread_local as imp;\n \n@@ -142,9 +141,6 @@ pub const INIT_INNER: StaticKeyInner = StaticKeyInner {\n     key: atomic::ATOMIC_USIZE_INIT,\n };\n \n-static INIT_KEYS: Once = ONCE_INIT;\n-static mut KEYS: *mut Mutex<Vec<imp::Key>> = 0 as *mut _;\n-\n impl StaticKey {\n     /// Gets the value associated with this TLS key\n     ///"}, {"sha": "ef175d68fc43fa9966dfa01c7b5cab6c4e690590", "filename": "src/libstd/sys/unix/timer.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/68d69415637186755482d2584e6ba82b67bc1d89/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d69415637186755482d2584e6ba82b67bc1d89/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=68d69415637186755482d2584e6ba82b67bc1d89", "patch": "@@ -170,8 +170,15 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n             1 => {\n                 loop {\n                     match messages.try_recv() {\n+                        // Once we've been disconnected it means the main thread\n+                        // is exiting (at_exit has run). We could still have\n+                        // active timers for other threads, so we're just going\n+                        // to drop them all on the floor. This is all we can\n+                        // really do, however, to prevent resource leakage. The\n+                        // remaining timers will likely start panicking quickly\n+                        // as they attempt to re-use this thread but are\n+                        // disallowed to do so.\n                         Err(TryRecvError::Disconnected) => {\n-                            assert!(active.len() == 0);\n                             break 'outer;\n                         }\n "}, {"sha": "1359803070af384d03033e2df2fd0a229cae48e7", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/68d69415637186755482d2584e6ba82b67bc1d89/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d69415637186755482d2584e6ba82b67bc1d89/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=68d69415637186755482d2584e6ba82b67bc1d89", "patch": "@@ -138,23 +138,29 @@ unsafe fn init_dtors() {\n     rt::at_exit(move|| {\n         DTOR_LOCK.lock();\n         let dtors = DTORS;\n-        DTORS = ptr::null_mut();\n+        DTORS = 1 as *mut _;\n         Box::from_raw(dtors);\n-        assert!(DTORS.is_null()); // can't re-init after destructing\n+        assert!(DTORS as uint == 1); // can't re-init after destructing\n         DTOR_LOCK.unlock();\n     });\n }\n \n unsafe fn register_dtor(key: Key, dtor: Dtor) {\n     DTOR_LOCK.lock();\n     init_dtors();\n+    assert!(DTORS as uint != 0);\n+    assert!(DTORS as uint != 1,\n+            \"cannot create new TLS keys after the main thread has exited\");\n     (*DTORS).push((key, dtor));\n     DTOR_LOCK.unlock();\n }\n \n unsafe fn unregister_dtor(key: Key) -> bool {\n     DTOR_LOCK.lock();\n     init_dtors();\n+    assert!(DTORS as uint != 0);\n+    assert!(DTORS as uint != 1,\n+            \"cannot unregister destructors after the main thread has exited\");\n     let ret = {\n         let dtors = &mut *DTORS;\n         let before = dtors.len();\n@@ -241,7 +247,7 @@ unsafe fn run_dtors() {\n         any_run = false;\n         let dtors = {\n             DTOR_LOCK.lock();\n-            let ret = if DTORS.is_null() {\n+            let ret = if DTORS as usize <= 1 {\n                 Vec::new()\n             } else {\n                 (*DTORS).iter().map(|s| *s).collect()"}, {"sha": "9bcae926eeabfca420ad56eb343ddabea3bf1973", "filename": "src/libstd/sys/windows/timer.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/68d69415637186755482d2584e6ba82b67bc1d89/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d69415637186755482d2584e6ba82b67bc1d89/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs?ref=68d69415637186755482d2584e6ba82b67bc1d89", "patch": "@@ -80,9 +80,10 @@ fn helper(input: libc::HANDLE, messages: Receiver<Req>, _: ()) {\n                             None => {}\n                         }\n                     }\n+                    // See the comment in unix::timer for why we don't have any\n+                    // asserts here and why we're likely just leaving timers on\n+                    // the floor as we exit.\n                     Err(TryRecvError::Disconnected) => {\n-                        assert_eq!(objs.len(), 1);\n-                        assert_eq!(chans.len(), 0);\n                         break 'outer;\n                     }\n                     Err(..) => break"}, {"sha": "fb1e03c234d76a3fafe2ecb151ab2d82b54e65d9", "filename": "src/test/run-fail/rt-set-exit-status-panic2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68d69415637186755482d2584e6ba82b67bc1d89/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d69415637186755482d2584e6ba82b67bc1d89/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs?ref=68d69415637186755482d2584e6ba82b67bc1d89", "patch": "@@ -35,7 +35,7 @@ fn r(x:int) -> r {\n \n fn main() {\n     error!(\"whatever\");\n-    let _t = thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n       let _i = r(5);\n     });\n     panic!();"}, {"sha": "e0785779ab3c29667665c77b94aac8c7b21cc6db", "filename": "src/test/run-pass/unique-send-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68d69415637186755482d2584e6ba82b67bc1d89/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d69415637186755482d2584e6ba82b67bc1d89/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send-2.rs?ref=68d69415637186755482d2584e6ba82b67bc1d89", "patch": "@@ -25,7 +25,7 @@ pub fn main() {\n     let _t = (0..n).map(|i| {\n         expected += i;\n         let tx = tx.clone();\n-        thread::spawn(move|| {\n+        thread::scoped(move|| {\n             child(&tx, i)\n         })\n     }).collect::<Vec<_>>();"}]}