{"sha": "8cf6c23d66ce4d80d6d76291c10cbbe6cab9cb00", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjZjZjMjNkNjZjZTRkODBkNmQ3NjI5MWMxMGNiYmU2Y2FiOWNiMDA=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2019-09-15T16:08:09Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2019-10-18T23:16:49Z"}, "message": "Cleanup const_prop() some", "tree": {"sha": "acb4021104b2da9e2db919ead51378edcff1f2e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/acb4021104b2da9e2db919ead51378edcff1f2e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cf6c23d66ce4d80d6d76291c10cbbe6cab9cb00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cf6c23d66ce4d80d6d76291c10cbbe6cab9cb00", "html_url": "https://github.com/rust-lang/rust/commit/8cf6c23d66ce4d80d6d76291c10cbbe6cab9cb00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cf6c23d66ce4d80d6d76291c10cbbe6cab9cb00/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d22063e4c6fbdb61ce2a2dd9ce50d12fe9f0e9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d22063e4c6fbdb61ce2a2dd9ce50d12fe9f0e9b", "html_url": "https://github.com/rust-lang/rust/commit/2d22063e4c6fbdb61ce2a2dd9ce50d12fe9f0e9b"}], "stats": {"total": 147, "additions": 75, "deletions": 72}, "files": [{"sha": "abb880fd62419b342e8514a08ca7092ef78caeec", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 75, "deletions": 72, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/8cf6c23d66ce4d80d6d76291c10cbbe6cab9cb00/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf6c23d66ce4d80d6d76291c10cbbe6cab9cb00/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=8cf6c23d66ce4d80d6d76291c10cbbe6cab9cb00", "patch": "@@ -118,7 +118,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n struct ConstPropMachine;\n \n impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n-    type MemoryKinds= !;\n+    type MemoryKinds = !;\n     type PointerTag = ();\n     type ExtraFnVal = !;\n \n@@ -435,79 +435,80 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let span = source_info.span;\n \n         // perform any special checking for specific Rvalue types\n-        if let Rvalue::UnaryOp(op, arg) = rvalue {\n-            trace!(\"checking UnaryOp(op = {:?}, arg = {:?})\", op, arg);\n-            let overflow_check = self.tcx.sess.overflow_checks();\n-\n-            self.use_ecx(source_info, |this| {\n-                // We check overflow in debug mode already\n-                // so should only check in release mode.\n-                if *op == UnOp::Neg && !overflow_check {\n-                    let ty = arg.ty(&this.local_decls, this.tcx);\n-\n-                    if ty.is_integral() {\n-                        let arg = this.ecx.eval_operand(arg, None)?;\n-                        let prim = this.ecx.read_immediate(arg)?;\n-                        // Need to do overflow check here: For actual CTFE, MIR\n-                        // generation emits code that does this before calling the op.\n-                        if prim.to_bits()? == (1 << (prim.layout.size.bits() - 1)) {\n-                            throw_panic!(OverflowNeg)\n+        match rvalue {\n+            Rvalue::UnaryOp(UnOp::Neg, arg) => {\n+                trace!(\"checking UnaryOp(op = Neg, arg = {:?})\", arg);\n+                let overflow_check = self.tcx.sess.overflow_checks();\n+\n+                self.use_ecx(source_info, |this| {\n+                    // We check overflow in debug mode already\n+                    // so should only check in release mode.\n+                    if !overflow_check {\n+                        let ty = arg.ty(&this.local_decls, this.tcx);\n+\n+                        if ty.is_integral() {\n+                            let arg = this.ecx.eval_operand(arg, None)?;\n+                            let prim = this.ecx.read_immediate(arg)?;\n+                            // Need to do overflow check here: For actual CTFE, MIR\n+                            // generation emits code that does this before calling the op.\n+                            if prim.to_bits()? == (1 << (prim.layout.size.bits() - 1)) {\n+                                throw_panic!(OverflowNeg)\n+                            }\n                         }\n                     }\n-                }\n \n-                Ok(())\n-            })?;\n-        } else if let Rvalue::BinaryOp(op, left, right) = rvalue {\n-            trace!(\"checking BinaryOp(op = {:?}, left = {:?}, right = {:?})\", op, left, right);\n-\n-            let r = self.use_ecx(source_info, |this| {\n-                this.ecx.read_immediate(this.ecx.eval_operand(right, None)?)\n-            })?;\n-            if *op == BinOp::Shr || *op == BinOp::Shl {\n-                let left_bits = place_layout.size.bits();\n-                let right_size = r.layout.size;\n-                let r_bits = r.to_scalar().and_then(|r| r.to_bits(right_size));\n-                if r_bits.ok().map_or(false, |b| b >= left_bits as u128) {\n-                    let source_scope_local_data = match self.source_scope_local_data {\n-                        ClearCrossCrate::Set(ref data) => data,\n-                        ClearCrossCrate::Clear => return None,\n-                    };\n-                    let dir = if *op == BinOp::Shr {\n-                        \"right\"\n-                    } else {\n-                        \"left\"\n-                    };\n-                    let hir_id = source_scope_local_data[source_info.scope].lint_root;\n-                    self.tcx.lint_hir(\n-                        ::rustc::lint::builtin::EXCEEDING_BITSHIFTS,\n-                        hir_id,\n-                        span,\n-                        &format!(\"attempt to shift {} with overflow\", dir));\n-                    return None;\n-                }\n+                    Ok(())\n+                })?;\n             }\n-            self.use_ecx(source_info, |this| {\n-                let l = this.ecx.read_immediate(this.ecx.eval_operand(left, None)?)?;\n-                let (_, overflow, _ty) = this.ecx.overflowing_binary_op(*op, l, r)?;\n-\n-                // We check overflow in debug mode already\n-                // so should only check in release mode.\n-                if !this.tcx.sess.overflow_checks() && overflow {\n-                    let err = err_panic!(Overflow(*op)).into();\n-                    return Err(err);\n+\n+            Rvalue::BinaryOp(op, left, right) => {\n+                trace!(\"checking BinaryOp(op = {:?}, left = {:?}, right = {:?})\", op, left, right);\n+\n+                let r = self.use_ecx(source_info, |this| {\n+                    this.ecx.read_immediate(this.ecx.eval_operand(right, None)?)\n+                })?;\n+                if *op == BinOp::Shr || *op == BinOp::Shl {\n+                    let left_bits = place_layout.size.bits();\n+                    let right_size = r.layout.size;\n+                    let r_bits = r.to_scalar().and_then(|r| r.to_bits(right_size));\n+                    if r_bits.ok().map_or(false, |b| b >= left_bits as u128) {\n+                        let source_scope_local_data = match self.source_scope_local_data {\n+                            ClearCrossCrate::Set(ref data) => data,\n+                            ClearCrossCrate::Clear => return None,\n+                        };\n+                        let dir = if *op == BinOp::Shr {\n+                            \"right\"\n+                        } else {\n+                            \"left\"\n+                        };\n+                        let hir_id = source_scope_local_data[source_info.scope].lint_root;\n+                        self.tcx.lint_hir(\n+                            ::rustc::lint::builtin::EXCEEDING_BITSHIFTS,\n+                            hir_id,\n+                            span,\n+                            &format!(\"attempt to shift {} with overflow\", dir));\n+                        return None;\n+                    }\n                 }\n+                self.use_ecx(source_info, |this| {\n+                    let l = this.ecx.read_immediate(this.ecx.eval_operand(left, None)?)?;\n+                    let (_, overflow, _ty) = this.ecx.overflowing_binary_op(*op, l, r)?;\n+\n+                    // We check overflow in debug mode already\n+                    // so should only check in release mode.\n+                    if !this.tcx.sess.overflow_checks() && overflow {\n+                        let err = err_panic!(Overflow(*op)).into();\n+                        return Err(err);\n+                    }\n \n-                Ok(())\n-            })?;\n-        } else if let Rvalue::Ref(_, _, place) = rvalue {\n-            trace!(\"checking Ref({:?})\", place);\n-            // FIXME(wesleywiser) we don't currently handle the case where we try to make a ref\n-            // from a function argument that hasn't been assigned to in this function.\n-            if let Place {\n-                base: PlaceBase::Local(local),\n-                projection: box []\n-            } = place {\n+                    Ok(())\n+                })?;\n+            }\n+\n+            Rvalue::Ref(_, _, Place { base: PlaceBase::Local(local), projection: box [] }) => {\n+                trace!(\"checking Ref({:?})\", place);\n+                // FIXME(wesleywiser) we don't currently handle the case where we try to make a ref\n+                // from a function argument that hasn't been assigned to in this function.\n                 let alive =\n                     if let LocalValue::Live(_) = self.ecx.frame().locals[*local].value {\n                         true\n@@ -518,12 +519,14 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     return None;\n                 }\n             }\n-        } else if let Rvalue::Aggregate(_, operands) = rvalue {\n-            // FIXME(wesleywiser): const eval will turn this into a `const Scalar(<ZST>)` that\n-            // `SimplifyLocals` doesn't know it can remove.\n-            if operands.len() == 0 {\n+\n+            Rvalue::Aggregate(_, operands) if operands.len() == 0 => {\n+                // FIXME(wesleywiser): const eval will turn this into a `const Scalar(<ZST>)` that\n+                // `SimplifyLocals` doesn't know it can remove.\n                 return None;\n             }\n+\n+            _ => { }\n         }\n \n         self.use_ecx(source_info, |this| {"}]}