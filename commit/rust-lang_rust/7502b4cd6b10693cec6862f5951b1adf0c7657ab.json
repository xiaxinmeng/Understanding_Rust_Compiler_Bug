{"sha": "7502b4cd6b10693cec6862f5951b1adf0c7657ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1MDJiNGNkNmIxMDY5M2NlYzY4NjJmNTk1MWIxYWRmMGM3NjU3YWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-18T18:26:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-18T18:26:34Z"}, "message": "auto merge of #15742 : pnkfelix/rust/fsk-fix-15019, r=pcwalton\n\nRemoved `index_to_bitset` field and `_frozen` methods.\r\n\r\nDrive-by: Added some missing docs on the `each_bit` method.\r\n\r\nDrive-by: Put in a regular pattern: when calling `compute_id_range`, ensure `words_per_id > 0` by either asserting it or checking and returning early.  (The prior code did the latter in a few cases where necessary, but debugging is much aided by the asserts.)\r\n\r\nFix #15019.", "tree": {"sha": "8396c6a07e702e1a87dfbde52b026f89f3e1033b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8396c6a07e702e1a87dfbde52b026f89f3e1033b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7502b4cd6b10693cec6862f5951b1adf0c7657ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7502b4cd6b10693cec6862f5951b1adf0c7657ab", "html_url": "https://github.com/rust-lang/rust/commit/7502b4cd6b10693cec6862f5951b1adf0c7657ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7502b4cd6b10693cec6862f5951b1adf0c7657ab/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c9bdfd1c5e34f6f04266f695664ef82c672c143", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c9bdfd1c5e34f6f04266f695664ef82c672c143", "html_url": "https://github.com/rust-lang/rust/commit/9c9bdfd1c5e34f6f04266f695664ef82c672c143"}, {"sha": "8f5042843280e17d0af4e9d35f2602f1785e10cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f5042843280e17d0af4e9d35f2602f1785e10cd", "html_url": "https://github.com/rust-lang/rust/commit/8f5042843280e17d0af4e9d35f2602f1785e10cd"}], "stats": {"total": 159, "additions": 55, "deletions": 104}, "files": [{"sha": "2aa0818b177cf49abe2bdffafeaa06498e7f21c9", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7502b4cd6b10693cec6862f5951b1adf0c7657ab/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7502b4cd6b10693cec6862f5951b1adf0c7657ab/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=7502b4cd6b10693cec6862f5951b1adf0c7657ab", "patch": "@@ -172,7 +172,7 @@ impl<'a> CheckLoanCtxt<'a> {\n         //! are issued for future scopes and thus they may have been\n         //! *issued* but not yet be in effect.\n \n-        self.dfcx_loans.each_bit_on_entry_frozen(scope_id, |loan_index| {\n+        self.dfcx_loans.each_bit_on_entry(scope_id, |loan_index| {\n             let loan = &self.all_loans[loan_index];\n             op(loan)\n         })\n@@ -271,7 +271,7 @@ impl<'a> CheckLoanCtxt<'a> {\n         //! we encounter `scope_id`.\n \n         let mut result = Vec::new();\n-        self.dfcx_loans.each_gen_bit_frozen(scope_id, |loan_index| {\n+        self.dfcx_loans.each_gen_bit(scope_id, |loan_index| {\n             result.push(loan_index);\n             true\n         });"}, {"sha": "6ec3f82ad68e74ffb00d40b0734377d516e5d394", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7502b4cd6b10693cec6862f5951b1adf0c7657ab/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7502b4cd6b10693cec6862f5951b1adf0c7657ab/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=7502b4cd6b10693cec6862f5951b1adf0c7657ab", "patch": "@@ -576,7 +576,7 @@ impl<'a> FlowedMoveData<'a> {\n          * Iterates through each path moved by `id`\n          */\n \n-        self.dfcx_moves.each_gen_bit_frozen(id, |index| {\n+        self.dfcx_moves.each_gen_bit(id, |index| {\n             let move = self.move_data.moves.borrow();\n             let move = move.get(index);\n             let moved_path = move.path;\n@@ -592,7 +592,7 @@ impl<'a> FlowedMoveData<'a> {\n \n         let mut ret = None;\n         for loan_path_index in self.move_data.path_map.borrow().find(&*loan_path).iter() {\n-            self.dfcx_moves.each_gen_bit_frozen(id, |move_index| {\n+            self.dfcx_moves.each_gen_bit(id, |move_index| {\n                 let move = self.move_data.moves.borrow();\n                 let move = move.get(move_index);\n                 if move.path == **loan_path_index {\n@@ -637,7 +637,7 @@ impl<'a> FlowedMoveData<'a> {\n \n         let mut ret = true;\n \n-        self.dfcx_moves.each_bit_on_entry_frozen(id, |index| {\n+        self.dfcx_moves.each_bit_on_entry(id, |index| {\n             let move = self.move_data.moves.borrow();\n             let move = move.get(index);\n             let moved_path = move.path;\n@@ -693,7 +693,7 @@ impl<'a> FlowedMoveData<'a> {\n             }\n         };\n \n-        self.dfcx_assign.each_bit_on_entry_frozen(id, |index| {\n+        self.dfcx_assign.each_bit_on_entry(id, |index| {\n             let assignment = self.move_data.var_assignments.borrow();\n             let assignment = assignment.get(index);\n             if assignment.path == loan_path_index && !f(assignment) {"}, {"sha": "7c5b001354dbbf296c67fd59cd2c296fd32bcf13", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 49, "deletions": 98, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/7502b4cd6b10693cec6862f5951b1adf0c7657ab/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7502b4cd6b10693cec6862f5951b1adf0c7657ab/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=7502b4cd6b10693cec6862f5951b1adf0c7657ab", "patch": "@@ -48,9 +48,6 @@ pub struct DataFlowContext<'a, O> {\n     /// equal to bits_per_id/uint::BITS rounded up.\n     words_per_id: uint,\n \n-    // mapping from cfg node index to bitset index.\n-    index_to_bitset: Vec<Option<uint>>,\n-\n     // mapping from node to cfg node index\n     // FIXME (#6298): Shouldn't this go with CFG?\n     nodeid_to_index: NodeMap<CFGIndex>,\n@@ -98,58 +95,7 @@ fn to_cfgidx_or_die(id: ast::NodeId, index: &NodeMap<CFGIndex>) -> CFGIndex {\n impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n     fn has_bitset_for_nodeid(&self, n: ast::NodeId) -> bool {\n         assert!(n != ast::DUMMY_NODE_ID);\n-        match self.nodeid_to_index.find(&n) {\n-            None => false,\n-            Some(&cfgidx) => self.has_bitset_for_cfgidx(cfgidx),\n-        }\n-    }\n-    fn has_bitset_for_cfgidx(&self, cfgidx: CFGIndex) -> bool {\n-        let node_id = cfgidx.node_id();\n-        node_id < self.index_to_bitset.len() &&\n-            self.index_to_bitset.get(node_id).is_some()\n-    }\n-    fn get_bitset_index(&self, cfgidx: CFGIndex) -> uint {\n-        let node_id = cfgidx.node_id();\n-        self.index_to_bitset.get(node_id).unwrap()\n-    }\n-    fn get_or_create_bitset_index(&mut self, cfgidx: CFGIndex) -> uint {\n-        assert!(self.words_per_id > 0);\n-        let len = self.gens.len() / self.words_per_id;\n-        let expanded;\n-        let n;\n-        if self.index_to_bitset.len() <= cfgidx.node_id() {\n-            self.index_to_bitset.grow_set(cfgidx.node_id(), &None, Some(len));\n-            expanded = true;\n-            n = len;\n-        } else {\n-            let entry = self.index_to_bitset.get_mut(cfgidx.node_id());\n-            match *entry {\n-                None => {\n-                    *entry = Some(len);\n-                    expanded = true;\n-                    n = len;\n-                }\n-                Some(bitidx) => {\n-                    expanded = false;\n-                    n = bitidx;\n-                }\n-            }\n-        }\n-        if expanded {\n-            let entry = if self.oper.initial_value() { uint::MAX } else {0};\n-            for _ in range(0, self.words_per_id) {\n-                self.gens.push(0);\n-                self.kills.push(0);\n-                self.on_entry.push(entry);\n-            }\n-        }\n-\n-        let start = n * self.words_per_id;\n-        let end = start + self.words_per_id;\n-        let len = self.gens.len();\n-        assert!(start < len);\n-        assert!(end <= len);\n-        n\n+        self.nodeid_to_index.contains_key(&n)\n     }\n }\n \n@@ -165,8 +111,9 @@ impl<'a, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, O> {\n         };\n \n         if self.has_bitset_for_nodeid(id) {\n+            assert!(self.bits_per_id > 0);\n             let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n-            let (start, end) = self.compute_id_range_frozen(cfgidx);\n+            let (start, end) = self.compute_id_range(cfgidx);\n             let on_entry = self.on_entry.slice(start, end);\n             let entry_str = bits_to_string(on_entry);\n \n@@ -243,22 +190,26 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n                id_range: IdRange,\n                bits_per_id: uint) -> DataFlowContext<'a, O> {\n         let words_per_id = (bits_per_id + uint::BITS - 1) / uint::BITS;\n+        let num_nodes = cfg.graph.all_nodes().len();\n \n         debug!(\"DataFlowContext::new(analysis_name: {:s}, id_range={:?}, \\\n-                                     bits_per_id={:?}, words_per_id={:?})\",\n-               analysis_name, id_range, bits_per_id, words_per_id);\n+                                     bits_per_id={:?}, words_per_id={:?}) \\\n+                                     num_nodes: {}\",\n+               analysis_name, id_range, bits_per_id, words_per_id,\n+               num_nodes);\n \n-        let gens = Vec::new();\n-        let kills = Vec::new();\n-        let on_entry = Vec::new();\n+        let entry = if oper.initial_value() { uint::MAX } else {0};\n+\n+        let gens = Vec::from_elem(num_nodes * words_per_id, 0);\n+        let kills = Vec::from_elem(num_nodes * words_per_id, 0);\n+        let on_entry = Vec::from_elem(num_nodes * words_per_id, entry);\n \n         let nodeid_to_index = build_nodeid_to_index(decl, cfg);\n \n         DataFlowContext {\n             tcx: tcx,\n             analysis_name: analysis_name,\n             words_per_id: words_per_id,\n-            index_to_bitset: Vec::new(),\n             nodeid_to_index: nodeid_to_index,\n             bits_per_id: bits_per_id,\n             oper: oper,\n@@ -273,6 +224,8 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n         debug!(\"{:s} add_gen(id={:?}, bit={:?})\",\n                self.analysis_name, id, bit);\n         assert!(self.nodeid_to_index.contains_key(&id));\n+        assert!(self.bits_per_id > 0);\n+\n         let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n         let (start, end) = self.compute_id_range(cfgidx);\n         let gens = self.gens.mut_slice(start, end);\n@@ -284,32 +237,21 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n         debug!(\"{:s} add_kill(id={:?}, bit={:?})\",\n                self.analysis_name, id, bit);\n         assert!(self.nodeid_to_index.contains_key(&id));\n+        assert!(self.bits_per_id > 0);\n+\n         let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n         let (start, end) = self.compute_id_range(cfgidx);\n         let kills = self.kills.mut_slice(start, end);\n         set_bit(kills, bit);\n     }\n \n-    fn apply_gen_kill(&mut self, cfgidx: CFGIndex, bits: &mut [uint]) {\n+    fn apply_gen_kill(&self, cfgidx: CFGIndex, bits: &mut [uint]) {\n         //! Applies the gen and kill sets for `cfgidx` to `bits`\n         debug!(\"{:s} apply_gen_kill(cfgidx={}, bits={}) [before]\",\n                self.analysis_name, cfgidx, mut_bits_to_string(bits));\n-        let (start, end) = self.compute_id_range(cfgidx);\n-        let gens = self.gens.slice(start, end);\n-        bitwise(bits, gens, &Union);\n-        let kills = self.kills.slice(start, end);\n-        bitwise(bits, kills, &Subtract);\n-\n-        debug!(\"{:s} apply_gen_kill(cfgidx={}, bits={}) [after]\",\n-               self.analysis_name, cfgidx, mut_bits_to_string(bits));\n-    }\n+        assert!(self.bits_per_id > 0);\n \n-    fn apply_gen_kill_frozen(&self, cfgidx: CFGIndex, bits: &mut [uint]) {\n-        //! Applies the gen and kill sets for `cfgidx` to `bits`\n-        //! Only useful after `propagate()` has been called.\n-        debug!(\"{:s} apply_gen_kill(cfgidx={}, bits={}) [before]\",\n-               self.analysis_name, cfgidx, mut_bits_to_string(bits));\n-        let (start, end) = self.compute_id_range_frozen(cfgidx);\n+        let (start, end) = self.compute_id_range(cfgidx);\n         let gens = self.gens.slice(start, end);\n         bitwise(bits, gens, &Union);\n         let kills = self.kills.slice(start, end);\n@@ -319,15 +261,8 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n                self.analysis_name, cfgidx, mut_bits_to_string(bits));\n     }\n \n-    fn compute_id_range_frozen(&self, cfgidx: CFGIndex) -> (uint, uint) {\n-        let n = self.get_bitset_index(cfgidx);\n-        let start = n * self.words_per_id;\n-        let end = start + self.words_per_id;\n-        (start, end)\n-    }\n-\n-    fn compute_id_range(&mut self, cfgidx: CFGIndex) -> (uint, uint) {\n-        let n = self.get_or_create_bitset_index(cfgidx);\n+    fn compute_id_range(&self, cfgidx: CFGIndex) -> (uint, uint) {\n+        let n = cfgidx.node_id();\n         let start = n * self.words_per_id;\n         let end = start + self.words_per_id;\n \n@@ -340,10 +275,10 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n     }\n \n \n-    pub fn each_bit_on_entry_frozen(&self,\n-                                    id: ast::NodeId,\n-                                    f: |uint| -> bool)\n-                                    -> bool {\n+    pub fn each_bit_on_entry(&self,\n+                             id: ast::NodeId,\n+                             f: |uint| -> bool)\n+                             -> bool {\n         //! Iterates through each bit that is set on entry to `id`.\n         //! Only useful after `propagate()` has been called.\n         if !self.has_bitset_for_nodeid(id) {\n@@ -360,17 +295,21 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n                              -> bool {\n         //! Iterates through each bit that is set on entry/exit to `cfgidx`.\n         //! Only useful after `propagate()` has been called.\n-        if !self.has_bitset_for_cfgidx(cfgidx) {\n+\n+        if self.bits_per_id == 0 {\n+            // Skip the surprisingly common degenerate case.  (Note\n+            // compute_id_range requires self.words_per_id > 0.)\n             return true;\n         }\n-        let (start, end) = self.compute_id_range_frozen(cfgidx);\n+\n+        let (start, end) = self.compute_id_range(cfgidx);\n         let on_entry = self.on_entry.slice(start, end);\n         let temp_bits;\n         let slice = match e {\n             Entry => on_entry,\n             Exit => {\n                 let mut t = on_entry.to_vec();\n-                self.apply_gen_kill_frozen(cfgidx, t.as_mut_slice());\n+                self.apply_gen_kill(cfgidx, t.as_mut_slice());\n                 temp_bits = t;\n                 temp_bits.as_slice()\n             }\n@@ -380,15 +319,21 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n         self.each_bit(slice, f)\n     }\n \n-    pub fn each_gen_bit_frozen(&self, id: ast::NodeId, f: |uint| -> bool)\n-                               -> bool {\n+    pub fn each_gen_bit(&self, id: ast::NodeId, f: |uint| -> bool)\n+                        -> bool {\n         //! Iterates through each bit in the gen set for `id`.\n-        //! Only useful after `propagate()` has been called.\n         if !self.has_bitset_for_nodeid(id) {\n             return true;\n         }\n+\n+        if self.bits_per_id == 0 {\n+            // Skip the surprisingly common degenerate case.  (Note\n+            // compute_id_range requires self.words_per_id > 0.)\n+            return true;\n+        }\n+\n         let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n-        let (start, end) = self.compute_id_range_frozen(cfgidx);\n+        let (start, end) = self.compute_id_range(cfgidx);\n         let gens = self.gens.slice(start, end);\n         debug!(\"{:s} each_gen_bit(id={:?}, gens={})\",\n                self.analysis_name, id, bits_to_string(gens));\n@@ -397,6 +342,8 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n \n     fn each_bit(&self, words: &[uint], f: |uint| -> bool) -> bool {\n         //! Helper for iterating over the bits in a bit set.\n+        //! Returns false on the first call to `f` that returns false;\n+        //! if all calls to `f` return true, then returns true.\n \n         for (word_index, &word) in words.iter().enumerate() {\n             if word != 0 {\n@@ -527,6 +474,8 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n                 in_out: &mut [uint]) {\n         debug!(\"DataFlowContext::walk_cfg(in_out={}) {:s}\",\n                bits_to_string(in_out), self.dfcx.analysis_name);\n+        assert!(self.dfcx.bits_per_id > 0);\n+\n         cfg.graph.each_node(|node_index, node| {\n             debug!(\"DataFlowContext::walk_cfg idx={} id={} begin in_out={}\",\n                    node_index, node.data.id, bits_to_string(in_out));\n@@ -570,6 +519,8 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n         let cfgidx = edge.target();\n         debug!(\"{:s} propagate_bits_into_entry_set_for(pred_bits={}, {} to {})\",\n                self.dfcx.analysis_name, bits_to_string(pred_bits), source, cfgidx);\n+        assert!(self.dfcx.bits_per_id > 0);\n+\n         let (start, end) = self.dfcx.compute_id_range(cfgidx);\n         let changed = {\n             // (scoping mutable borrow of self.dfcx.on_entry)"}]}