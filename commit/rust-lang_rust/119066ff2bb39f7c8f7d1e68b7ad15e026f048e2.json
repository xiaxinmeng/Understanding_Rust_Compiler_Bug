{"sha": "119066ff2bb39f7c8f7d1e68b7ad15e026f048e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExOTA2NmZmMmJiMzlmN2M4ZjdkMWU2OGI3YWQxNWUwMjZmMDQ4ZTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-15T06:52:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-15T06:52:42Z"}, "message": "Auto merge of #42625 - michaelwoerister:dep-node-debug, r=nikomatsakis\n\nincr.comp.: Make DepNode's std::fmt::Debug implementation useful again.\n\nWith #42537 a regular `DepNode` only contains an opaque hash as its identifier. In most cases, this hash is actually a `DefPathHash` and we can reconstruct the `DefId` it came from via a table lookup --- and then use that to print something intelligible for debug outputs. For cases where we cannot reconstruct information from the DepNode's hash, this PR will cache a string representation of the `DepNode` in a side-table. This string is later used for debug outputs.\n\nr? @nikomatsakis", "tree": {"sha": "b5bf1dd466b6faa4a4522dd13b186c0379a4f2fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5bf1dd466b6faa4a4522dd13b186c0379a4f2fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/119066ff2bb39f7c8f7d1e68b7ad15e026f048e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/119066ff2bb39f7c8f7d1e68b7ad15e026f048e2", "html_url": "https://github.com/rust-lang/rust/commit/119066ff2bb39f7c8f7d1e68b7ad15e026f048e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/119066ff2bb39f7c8f7d1e68b7ad15e026f048e2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0189cec5d4e782ca17dd510934e93a7bd327ba86", "url": "https://api.github.com/repos/rust-lang/rust/commits/0189cec5d4e782ca17dd510934e93a7bd327ba86", "html_url": "https://github.com/rust-lang/rust/commit/0189cec5d4e782ca17dd510934e93a7bd327ba86"}, {"sha": "e32365272872d9bd69dd3f89113f2a47158960c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e32365272872d9bd69dd3f89113f2a47158960c5", "html_url": "https://github.com/rust-lang/rust/commit/e32365272872d9bd69dd3f89113f2a47158960c5"}], "stats": {"total": 160, "additions": 156, "deletions": 4}, "files": [{"sha": "1c9ecdca0e2672c79ce0d2387fe7e7eb31eb6c35", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 126, "deletions": 4, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/119066ff2bb39f7c8f7d1e68b7ad15e026f048e2/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119066ff2bb39f7c8f7d1e68b7ad15e026f048e2/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=119066ff2bb39f7c8f7d1e68b7ad15e026f048e2", "patch": "@@ -67,6 +67,7 @@ use ich::Fingerprint;\n use ty::TyCtxt;\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use ich::StableHashingContext;\n+use std::fmt;\n use std::hash::Hash;\n \n // erase!() just makes tokens go away. It's used to specify which macro argument\n@@ -145,7 +146,7 @@ macro_rules! define_dep_nodes {\n             ),*\n         }\n \n-        #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,\n+        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash,\n                  RustcEncodable, RustcDecodable)]\n         pub struct DepNode {\n             pub kind: DepKind,\n@@ -166,21 +167,45 @@ macro_rules! define_dep_nodes {\n                                 let tupled_args = ( $($tuple_arg,)* );\n                                 let hash = DepNodeParams::to_fingerprint(&tupled_args,\n                                                                          tcx);\n-                                return DepNode {\n+                                let dep_node = DepNode {\n                                     kind: DepKind::$variant,\n                                     hash\n                                 };\n+\n+                                if cfg!(debug_assertions) &&\n+                                   !dep_node.kind.can_reconstruct_query_key() &&\n+                                   (tcx.sess.opts.debugging_opts.incremental_info ||\n+                                    tcx.sess.opts.debugging_opts.query_dep_graph)\n+                                {\n+                                    tcx.dep_graph.register_dep_node_debug_str(dep_node, || {\n+                                        tupled_args.to_debug_str(tcx)\n+                                    });\n+                                }\n+\n+                                return dep_node;\n                             })*\n \n                             // struct args\n                             $({\n                                 let tupled_args = ( $($struct_arg_name,)* );\n                                 let hash = DepNodeParams::to_fingerprint(&tupled_args,\n                                                                          tcx);\n-                                return DepNode {\n+                                let dep_node = DepNode {\n                                     kind: DepKind::$variant,\n                                     hash\n                                 };\n+\n+                                if cfg!(debug_assertions) &&\n+                                   !dep_node.kind.can_reconstruct_query_key() &&\n+                                   (tcx.sess.opts.debugging_opts.incremental_info ||\n+                                    tcx.sess.opts.debugging_opts.query_dep_graph)\n+                                {\n+                                    tcx.dep_graph.register_dep_node_debug_str(dep_node, || {\n+                                        tupled_args.to_debug_str(tcx)\n+                                    });\n+                                }\n+\n+                                return dep_node;\n                             })*\n \n                             DepNode {\n@@ -267,6 +292,36 @@ macro_rules! define_dep_nodes {\n     );\n }\n \n+impl fmt::Debug for DepNode {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{:?}\", self.kind)?;\n+\n+        if !self.kind.has_params() {\n+            return Ok(());\n+        }\n+\n+        write!(f, \"(\")?;\n+\n+        ::ty::tls::with_opt(|opt_tcx| {\n+            if let Some(tcx) = opt_tcx {\n+                if let Some(def_id) = self.extract_def_id(tcx) {\n+                    write!(f, \"{}\", tcx.item_path_str(def_id))?;\n+                } else if let Some(ref s) = tcx.dep_graph.dep_node_debug_str(*self) {\n+                    write!(f, \"{}\", s)?;\n+                } else {\n+                    write!(f, \"{:?}\", self.hash)?;\n+                }\n+            } else {\n+                write!(f, \"{:?}\", self.hash)?;\n+            }\n+            Ok(())\n+        })?;\n+\n+        write!(f, \")\")\n+    }\n+}\n+\n+\n impl DefPathHash {\n     #[inline]\n     pub fn to_dep_node(self, kind: DepKind) -> DepNode {\n@@ -426,10 +481,11 @@ define_dep_nodes!(\n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool;\n     fn to_fingerprint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Fingerprint;\n+    fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String;\n }\n \n impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a, T> DepNodeParams<'a, 'gcx, 'tcx> for T\n-    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>> + fmt::Debug\n {\n     default const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n \n@@ -441,6 +497,10 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a, T> DepNodeParams<'a, 'gcx, 'tcx> for T\n \n         hasher.finish()\n     }\n+\n+    default fn to_debug_str(&self, _: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+        format!(\"{:?}\", *self)\n+    }\n }\n \n impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId,) {\n@@ -449,6 +509,68 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId,) {\n     fn to_fingerprint(&self, tcx: TyCtxt) -> Fingerprint {\n         tcx.def_path_hash(self.0).0\n     }\n+\n+    fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+        tcx.item_path_str(self.0)\n+    }\n+}\n+\n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId, DefId) {\n+    const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n+\n+    // We actually would not need to specialize the implementation of this\n+    // method but it's faster to combine the hashes than to instantiate a full\n+    // hashing context and stable-hashing state.\n+    fn to_fingerprint(&self, tcx: TyCtxt) -> Fingerprint {\n+        let (def_id_0, def_id_1) = *self;\n+\n+        let def_path_hash_0 = tcx.def_path_hash(def_id_0);\n+        let def_path_hash_1 = tcx.def_path_hash(def_id_1);\n+\n+        def_path_hash_0.0.combine(def_path_hash_1.0)\n+    }\n+\n+    fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+        let (def_id_0, def_id_1) = *self;\n+\n+        format!(\"({}, {})\",\n+                tcx.def_path(def_id_0).to_string(tcx),\n+                tcx.def_path(def_id_1).to_string(tcx))\n+    }\n+}\n+\n+\n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefIdList,) {\n+    const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n+\n+    // We actually would not need to specialize the implementation of this\n+    // method but it's faster to combine the hashes than to instantiate a full\n+    // hashing context and stable-hashing state.\n+    fn to_fingerprint(&self, tcx: TyCtxt) -> Fingerprint {\n+        let mut fingerprint = Fingerprint::zero();\n+\n+        for &def_id in self.0.iter() {\n+            let def_path_hash = tcx.def_path_hash(def_id);\n+            fingerprint = fingerprint.combine(def_path_hash.0);\n+        }\n+\n+        fingerprint\n+    }\n+\n+    fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+        use std::fmt::Write;\n+\n+        let mut s = String::new();\n+        write!(&mut s, \"[\").unwrap();\n+\n+        for &def_id in self.0.iter() {\n+            write!(&mut s, \"{}\", tcx.def_path(def_id).to_string(tcx)).unwrap();\n+        }\n+\n+        write!(&mut s, \"]\").unwrap();\n+\n+        s\n+    }\n }\n \n /// A \"work product\" corresponds to a `.o` (or other) file that we"}, {"sha": "e48e61d803510468d1c2b622034254246b078e5a", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/119066ff2bb39f7c8f7d1e68b7ad15e026f048e2/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119066ff2bb39f7c8f7d1e68b7ad15e026f048e2/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=119066ff2bb39f7c8f7d1e68b7ad15e026f048e2", "patch": "@@ -37,6 +37,8 @@ struct DepGraphData {\n \n     /// Work-products that we generate in this run.\n     work_products: RefCell<FxHashMap<WorkProductId, WorkProduct>>,\n+\n+    dep_node_debug: RefCell<FxHashMap<DepNode, String>>,\n }\n \n impl DepGraph {\n@@ -46,6 +48,7 @@ impl DepGraph {\n                 thread: DepGraphThreadData::new(enabled),\n                 previous_work_products: RefCell::new(FxHashMap()),\n                 work_products: RefCell::new(FxHashMap()),\n+                dep_node_debug: RefCell::new(FxHashMap()),\n             })\n         }\n     }\n@@ -152,6 +155,22 @@ impl DepGraph {\n     pub fn previous_work_products(&self) -> Ref<FxHashMap<WorkProductId, WorkProduct>> {\n         self.data.previous_work_products.borrow()\n     }\n+\n+    #[inline(always)]\n+    pub(super) fn register_dep_node_debug_str<F>(&self,\n+                                                 dep_node: DepNode,\n+                                                 debug_str_gen: F)\n+        where F: FnOnce() -> String\n+    {\n+        let mut dep_node_debug = self.data.dep_node_debug.borrow_mut();\n+\n+        dep_node_debug.entry(dep_node)\n+                      .or_insert_with(debug_str_gen);\n+    }\n+\n+    pub(super) fn dep_node_debug_str(&self, dep_node: DepNode) -> Option<String> {\n+        self.data.dep_node_debug.borrow().get(&dep_node).cloned()\n+    }\n }\n \n /// A \"work product\" is an intermediate result that we save into the"}, {"sha": "2391b61253aa98883a2e9778bfe3c3971e17f8f1", "filename": "src/librustc/ich/fingerprint.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/119066ff2bb39f7c8f7d1e68b7ad15e026f048e2/src%2Flibrustc%2Fich%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119066ff2bb39f7c8f7d1e68b7ad15e026f048e2/src%2Flibrustc%2Fich%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Ffingerprint.rs?ref=119066ff2bb39f7c8f7d1e68b7ad15e026f048e2", "patch": "@@ -31,9 +31,20 @@ impl Fingerprint {\n         self.0\n     }\n \n+    #[inline]\n+    pub fn combine(self, other: Fingerprint) -> Fingerprint {\n+        // See https://stackoverflow.com/a/27952689 on why this function is\n+        // implemented this way.\n+        Fingerprint(\n+            self.0.wrapping_mul(3).wrapping_add(other.0),\n+            self.1.wrapping_mul(3).wrapping_add(other.1)\n+        )\n+    }\n+\n     pub fn to_hex(&self) -> String {\n         format!(\"{:x}{:x}\", self.0, self.1)\n     }\n+\n }\n \n impl ::std::fmt::Display for Fingerprint {"}]}