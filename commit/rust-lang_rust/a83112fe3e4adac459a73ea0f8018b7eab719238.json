{"sha": "a83112fe3e4adac459a73ea0f8018b7eab719238", "node_id": "C_kwDOAAsO6NoAKGE4MzExMmZlM2U0YWRhYzQ1OWE3M2VhMGY4MDE4YjdlYWI3MTkyMzg", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-08-27T02:16:58Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-09-30T20:52:58Z"}, "message": "Remove temporary `GetDefId` impl for `Path`", "tree": {"sha": "bae7bace590b2a952ab4db72d1cdf0d6f58f2704", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bae7bace590b2a952ab4db72d1cdf0d6f58f2704"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a83112fe3e4adac459a73ea0f8018b7eab719238", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a83112fe3e4adac459a73ea0f8018b7eab719238", "html_url": "https://github.com/rust-lang/rust/commit/a83112fe3e4adac459a73ea0f8018b7eab719238", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a83112fe3e4adac459a73ea0f8018b7eab719238/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4128a3dc1fe1324cdc127901d8ccecfc4fe61984", "url": "https://api.github.com/repos/rust-lang/rust/commits/4128a3dc1fe1324cdc127901d8ccecfc4fe61984", "html_url": "https://github.com/rust-lang/rust/commit/4128a3dc1fe1324cdc127901d8ccecfc4fe61984"}], "stats": {"total": 156, "additions": 63, "deletions": 93}, "files": [{"sha": "5fb3a98ca5b87c9127e6fdeaa0a87c728d958606", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a83112fe3e4adac459a73ea0f8018b7eab719238/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a83112fe3e4adac459a73ea0f8018b7eab719238/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=a83112fe3e4adac459a73ea0f8018b7eab719238", "patch": "@@ -447,7 +447,7 @@ crate fn build_impl(\n     };\n     let polarity = tcx.impl_polarity(did);\n     let trait_ = associated_trait.clean(cx);\n-    if trait_.def_id() == tcx.lang_items().deref_trait() {\n+    if trait_.as_ref().map(|t| t.def_id()) == tcx.lang_items().deref_trait() {\n         super::build_deref_target_impls(cx, &trait_items, ret);\n     }\n \n@@ -481,7 +481,7 @@ crate fn build_impl(\n     let (merged_attrs, cfg) = merge_attrs(cx, parent_module.into(), load_attrs(cx, did), attrs);\n     trace!(\"merged_attrs={:?}\", merged_attrs);\n \n-    trace!(\"build_impl: impl {:?} for {:?}\", trait_.def_id(), for_.def_id());\n+    trace!(\"build_impl: impl {:?} for {:?}\", trait_.as_ref().map(|t| t.def_id()), for_.def_id());\n     ret.push(clean::Item::from_def_id_and_attrs_and_parts(\n         did,\n         None,"}, {"sha": "c52953573ac6517ed7dc5cc73130af6570d42d12", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a83112fe3e4adac459a73ea0f8018b7eab719238/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a83112fe3e4adac459a73ea0f8018b7eab719238/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a83112fe3e4adac459a73ea0f8018b7eab719238", "patch": "@@ -1883,7 +1883,7 @@ fn clean_impl(impl_: &hir::Impl<'_>, hir_id: hir::HirId, cx: &mut DocContext<'_>\n \n     // If this impl block is an implementation of the Deref trait, then we\n     // need to try inlining the target's inherent impl blocks as well.\n-    if trait_.def_id() == tcx.lang_items().deref_trait() {\n+    if trait_.as_ref().map(|t| t.def_id()) == tcx.lang_items().deref_trait() {\n         build_deref_target_impls(cx, &items, &mut ret);\n     }\n "}, {"sha": "a7a7f05ecfedcf41c6f9ed455087aa25578e2fee", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a83112fe3e4adac459a73ea0f8018b7eab719238/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a83112fe3e4adac459a73ea0f8018b7eab719238/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=a83112fe3e4adac459a73ea0f8018b7eab719238", "patch": "@@ -1122,7 +1122,7 @@ impl GenericBound {\n     crate fn is_sized_bound(&self, cx: &DocContext<'_>) -> bool {\n         use rustc_hir::TraitBoundModifier as TBM;\n         if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self {\n-            if trait_.def_id() == cx.tcx.lang_items().sized_trait() {\n+            if Some(trait_.def_id()) == cx.tcx.lang_items().sized_trait() {\n                 return true;\n             }\n         }\n@@ -1942,6 +1942,10 @@ crate struct Path {\n }\n \n impl Path {\n+    crate fn def_id(&self) -> DefId {\n+        self.res.def_id()\n+    }\n+\n     crate fn last(&self) -> Symbol {\n         self.segments.last().expect(\"segments were empty\").name\n     }\n@@ -1992,17 +1996,6 @@ impl Path {\n     }\n }\n \n-// FIXME: this is temporary\n-impl GetDefId for Path {\n-    fn def_id(&self) -> Option<DefId> {\n-        Some(self.res.def_id())\n-    }\n-\n-    fn def_id_full(&self, _: &Cache) -> Option<DefId> {\n-        self.def_id()\n-    }\n-}\n-\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n crate enum GenericArg {\n     Lifetime(Lifetime),\n@@ -2155,7 +2148,8 @@ crate struct Impl {\n impl Impl {\n     crate fn provided_trait_methods(&self, tcx: TyCtxt<'_>) -> FxHashSet<Symbol> {\n         self.trait_\n-            .def_id()\n+            .as_ref()\n+            .map(|t| t.def_id())\n             .map(|did| tcx.provided_trait_methods(did).map(|meth| meth.ident.name).collect())\n             .unwrap_or_default()\n     }"}, {"sha": "dd1cf2a866dd4c71f644c0fd9b78c463699caf64", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a83112fe3e4adac459a73ea0f8018b7eab719238/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a83112fe3e4adac459a73ea0f8018b7eab719238/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=a83112fe3e4adac459a73ea0f8018b7eab719238", "patch": "@@ -201,7 +201,9 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n         // masked crate then remove it completely.\n         if let clean::ImplItem(ref i) = *item.kind {\n             if self.cache.masked_crates.contains(&item.def_id.krate())\n-                || i.trait_.def_id().map_or(false, |d| self.cache.masked_crates.contains(&d.krate))\n+                || i.trait_\n+                    .as_ref()\n+                    .map_or(false, |t| self.cache.masked_crates.contains(&t.def_id().krate))\n                 || i.for_.def_id().map_or(false, |d| self.cache.masked_crates.contains(&d.krate))\n             {\n                 return None;\n@@ -221,11 +223,11 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n \n         // Collect all the implementors of traits.\n         if let clean::ImplItem(ref i) = *item.kind {\n-            if let Some(did) = i.trait_.def_id() {\n+            if let Some(trait_) = &i.trait_ {\n                 if i.blanket_impl.is_none() {\n                     self.cache\n                         .implementors\n-                        .entry(did)\n+                        .entry(trait_.def_id())\n                         .or_default()\n                         .push(Impl { impl_item: item.clone() });\n                 }\n@@ -400,12 +402,8 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                     }\n                     clean::DynTrait(ref bounds, _)\n                     | clean::BorrowedRef { type_: box clean::DynTrait(ref bounds, _), .. } => {\n-                        if let Some(did) = bounds[0].trait_.def_id() {\n-                            self.cache.parent_stack.push(did);\n-                            true\n-                        } else {\n-                            false\n-                        }\n+                        self.cache.parent_stack.push(bounds[0].trait_.def_id());\n+                        true\n                     }\n                     ref t => {\n                         let prim_did = t\n@@ -439,9 +437,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                 }\n                 clean::DynTrait(ref bounds, _)\n                 | clean::BorrowedRef { type_: box clean::DynTrait(ref bounds, _), .. } => {\n-                    if let Some(did) = bounds[0].trait_.def_id() {\n-                        dids.insert(did);\n-                    }\n+                    dids.insert(bounds[0].trait_.def_id());\n                 }\n                 ref t => {\n                     let did = t"}, {"sha": "4f0c5a9edee7185581c71bd1846d0151105f015a", "filename": "src/librustdoc/formats/mod.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a83112fe3e4adac459a73ea0f8018b7eab719238/src%2Flibrustdoc%2Fformats%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a83112fe3e4adac459a73ea0f8018b7eab719238/src%2Flibrustdoc%2Fformats%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fmod.rs?ref=a83112fe3e4adac459a73ea0f8018b7eab719238", "patch": "@@ -7,8 +7,6 @@ use rustc_hir::def_id::DefId;\n crate use renderer::{run_format, FormatRenderer};\n \n use crate::clean;\n-use crate::clean::types::GetDefId;\n-use crate::formats::cache::Cache;\n \n /// Specifies whether rendering directly implemented trait items or ones from a certain Deref\n /// impl.\n@@ -40,10 +38,6 @@ impl Impl {\n     }\n \n     crate fn trait_did(&self) -> Option<DefId> {\n-        self.inner_impl().trait_.def_id()\n-    }\n-\n-    crate fn trait_did_full(&self, cache: &Cache) -> Option<DefId> {\n-        self.inner_impl().trait_.def_id_full(cache)\n+        self.inner_impl().trait_.as_ref().map(|t| t.def_id())\n     }\n }"}, {"sha": "e936750c6d37f1fdf511abc133af9e01b496234d", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 40, "deletions": 56, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/a83112fe3e4adac459a73ea0f8018b7eab719238/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a83112fe3e4adac459a73ea0f8018b7eab719238/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=a83112fe3e4adac459a73ea0f8018b7eab719238", "patch": "@@ -687,18 +687,12 @@ fn short_item_info(\n \n // Render the list of items inside one of the sections \"Trait Implementations\",\n // \"Auto Trait Implementations,\" \"Blanket Trait Implementations\" (on struct/enum pages).\n-fn render_impls(\n-    cx: &Context<'_>,\n-    w: &mut Buffer,\n-    traits: &[&&Impl],\n-    containing_item: &clean::Item,\n-) {\n-    let cache = cx.cache();\n+fn render_impls(cx: &Context<'_>, w: &mut Buffer, impls: &[&&Impl], containing_item: &clean::Item) {\n     let tcx = cx.tcx();\n-    let mut impls = traits\n+    let mut rendered_impls = impls\n         .iter()\n         .map(|i| {\n-            let did = i.trait_did_full(cache).unwrap();\n+            let did = i.trait_did().unwrap();\n             let provided_trait_methods = i.inner_impl().provided_trait_methods(tcx);\n             let assoc_link = AssocItemLink::GotoSource(did.into(), &provided_trait_methods);\n             let mut buffer = if w.is_for_html() { Buffer::html() } else { Buffer::new() };\n@@ -722,8 +716,8 @@ fn render_impls(\n             buffer.into_inner()\n         })\n         .collect::<Vec<_>>();\n-    impls.sort();\n-    w.write_str(&impls.join(\"\"));\n+    rendered_impls.sort();\n+    w.write_str(&rendered_impls.join(\"\"));\n }\n \n fn naive_assoc_href(it: &clean::Item, link: AssocItemLink<'_>, cx: &Context<'_>) -> String {\n@@ -1068,13 +1062,11 @@ fn render_assoc_items(\n         return;\n     }\n     if !traits.is_empty() {\n-        let deref_impl = traits.iter().find(|t| {\n-            t.inner_impl().trait_.def_id_full(cache) == cx.tcx().lang_items().deref_trait()\n-        });\n+        let deref_impl =\n+            traits.iter().find(|t| t.trait_did() == cx.tcx().lang_items().deref_trait());\n         if let Some(impl_) = deref_impl {\n-            let has_deref_mut = traits.iter().any(|t| {\n-                t.inner_impl().trait_.def_id_full(cache) == cx.tcx().lang_items().deref_mut_trait()\n-            });\n+            let has_deref_mut =\n+                traits.iter().any(|t| t.trait_did() == cx.tcx().lang_items().deref_mut_trait());\n             render_deref_methods(w, cx, impl_, containing_item, has_deref_mut);\n         }\n         let (synthetic, concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n@@ -1192,45 +1184,39 @@ fn should_render_item(item: &clean::Item, deref_mut_: bool, tcx: TyCtxt<'_>) ->\n \n fn notable_traits_decl(decl: &clean::FnDecl, cx: &Context<'_>) -> String {\n     let mut out = Buffer::html();\n-    let mut trait_ = String::new();\n \n     if let Some(did) = decl.output.def_id_full(cx.cache()) {\n         if let Some(impls) = cx.cache().impls.get(&did) {\n             for i in impls {\n                 let impl_ = i.inner_impl();\n-                if impl_.trait_.def_id().map_or(false, |d| {\n-                    cx.cache().traits.get(&d).map(|t| t.is_notable).unwrap_or(false)\n-                }) {\n-                    if out.is_empty() {\n-                        write!(\n-                            &mut out,\n-                            \"<div class=\\\"notable\\\">Notable traits for {}</div>\\\n-                             <code class=\\\"content\\\">\",\n-                            impl_.for_.print(cx)\n-                        );\n-                        trait_.push_str(&impl_.for_.print(cx).to_string());\n-                    }\n+                if let Some(trait_) = &impl_.trait_ {\n+                    let trait_did = trait_.def_id();\n \n-                    //use the \"where\" class here to make it small\n-                    write!(\n-                        &mut out,\n-                        \"<span class=\\\"where fmt-newline\\\">{}</span>\",\n-                        impl_.print(false, cx)\n-                    );\n-                    let t_did = impl_.trait_.def_id_full(cx.cache()).unwrap();\n-                    for it in &impl_.items {\n-                        if let clean::TypedefItem(ref tydef, _) = *it.kind {\n-                            out.push_str(\"<span class=\\\"where fmt-newline\\\">    \");\n-                            assoc_type(\n+                    if cx.cache().traits.get(&trait_did).map_or(false, |t| t.is_notable) {\n+                        if out.is_empty() {\n+                            write!(\n                                 &mut out,\n-                                it,\n-                                &[],\n-                                Some(&tydef.type_),\n-                                AssocItemLink::GotoSource(t_did.into(), &FxHashSet::default()),\n-                                \"\",\n-                                cx,\n+                                \"<div class=\\\"notable\\\">Notable traits for {}</div>\\\n+                             <code class=\\\"content\\\">\",\n+                                impl_.for_.print(cx)\n                             );\n-                            out.push_str(\";</span>\");\n+                        }\n+\n+                        //use the \"where\" class here to make it small\n+                        write!(\n+                            &mut out,\n+                            \"<span class=\\\"where fmt-newline\\\">{}</span>\",\n+                            impl_.print(false, cx)\n+                        );\n+                        for it in &impl_.items {\n+                            if let clean::TypedefItem(ref tydef, _) = *it.kind {\n+                                out.push_str(\"<span class=\\\"where fmt-newline\\\">    \");\n+                                let empty_set = FxHashSet::default();\n+                                let src_link =\n+                                    AssocItemLink::GotoSource(trait_did.into(), &empty_set);\n+                                assoc_type(&mut out, it, &[], Some(&tydef.type_), src_link, \"\", cx);\n+                                out.push_str(\";</span>\");\n+                            }\n                         }\n                     }\n                 }\n@@ -1273,7 +1259,7 @@ fn render_impl(\n ) {\n     let cache = cx.cache();\n     let traits = &cache.traits;\n-    let trait_ = i.trait_did_full(cache).map(|did| &traits[&did]);\n+    let trait_ = i.trait_did().map(|did| &traits[&did]);\n     let mut close_tags = String::new();\n \n     // For trait implementations, the `interesting` output contains all methods that have doc\n@@ -1503,7 +1489,7 @@ fn render_impl(\n             if i.items.iter().any(|m| m.name == n) {\n                 continue;\n             }\n-            let did = i.trait_.as_ref().unwrap().def_id_full(cx.cache()).unwrap();\n+            let did = i.trait_.as_ref().unwrap().def_id();\n             let provided_methods = i.provided_trait_methods(cx.tcx());\n             let assoc_link = AssocItemLink::GotoSource(did.into(), &provided_methods);\n \n@@ -1887,9 +1873,9 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n         }\n \n         if v.iter().any(|i| i.inner_impl().trait_.is_some()) {\n-            if let Some(impl_) = v.iter().filter(|i| i.inner_impl().trait_.is_some()).find(|i| {\n-                i.inner_impl().trait_.def_id_full(cache) == cx.tcx().lang_items().deref_trait()\n-            }) {\n+            if let Some(impl_) =\n+                v.iter().find(|i| i.trait_did() == cx.tcx().lang_items().deref_trait())\n+            {\n                 sidebar_deref_methods(cx, out, impl_, v);\n             }\n \n@@ -1987,9 +1973,7 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &V\n                 }\n             }\n         }\n-        let deref_mut = v.iter().filter(|i| i.inner_impl().trait_.is_some()).any(|i| {\n-            i.inner_impl().trait_.def_id_full(c) == cx.tcx().lang_items().deref_mut_trait()\n-        });\n+        let deref_mut = v.iter().any(|i| i.trait_did() == cx.tcx().lang_items().deref_mut_trait());\n         let inner_impl = target\n             .def_id_full(c)\n             .or_else(|| {"}, {"sha": "72e631df89a59c81bf9799812f131bba0dedbe4f", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a83112fe3e4adac459a73ea0f8018b7eab719238/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a83112fe3e4adac459a73ea0f8018b7eab719238/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=a83112fe3e4adac459a73ea0f8018b7eab719238", "patch": "@@ -57,7 +57,9 @@ crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     // scan through included items ahead of time to splice in Deref targets to the \"valid\" sets\n     for it in &new_items {\n         if let ImplItem(Impl { ref for_, ref trait_, ref items, .. }) = *it.kind {\n-            if cleaner.keep_impl(for_) && trait_.def_id() == cx.tcx.lang_items().deref_trait() {\n+            if cleaner.keep_impl(for_)\n+                && trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait()\n+            {\n                 let target = items\n                     .iter()\n                     .find_map(|item| match *item.kind {"}, {"sha": "8b1fd662f85fdef57602ae5c3891b28af3547076", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a83112fe3e4adac459a73ea0f8018b7eab719238/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a83112fe3e4adac459a73ea0f8018b7eab719238/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=a83112fe3e4adac459a73ea0f8018b7eab719238", "patch": "@@ -134,7 +134,7 @@ impl<'a> DocFolder for ImplStripper<'a> {\n                     return None;\n                 }\n             }\n-            if let Some(did) = imp.trait_.def_id() {\n+            if let Some(did) = imp.trait_.as_ref().map(|t| t.def_id()) {\n                 if did.is_local() && !self.retained.contains(&did.into()) {\n                     debug!(\"ImplStripper: impl item for stripped trait; removing\");\n                     return None;"}]}