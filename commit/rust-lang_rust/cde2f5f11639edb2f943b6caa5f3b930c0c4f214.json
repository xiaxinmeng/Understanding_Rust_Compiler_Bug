{"sha": "cde2f5f11639edb2f943b6caa5f3b930c0c4f214", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkZTJmNWYxMTYzOWVkYjJmOTQzYjZjYWE1ZjNiOTMwYzBjNGYyMTQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-04-15T14:11:24Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-07T04:14:54Z"}, "message": "mir: factor out the parts of MIR building which are not fn-specific.", "tree": {"sha": "4418cb00a2f3ec654be13b58aa63c0e6a6b9af11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4418cb00a2f3ec654be13b58aa63c0e6a6b9af11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cde2f5f11639edb2f943b6caa5f3b930c0c4f214", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cde2f5f11639edb2f943b6caa5f3b930c0c4f214", "html_url": "https://github.com/rust-lang/rust/commit/cde2f5f11639edb2f943b6caa5f3b930c0c4f214", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cde2f5f11639edb2f943b6caa5f3b930c0c4f214/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbc41aa9a674b80c4423ca6196fb334fd4d17776", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbc41aa9a674b80c4423ca6196fb334fd4d17776", "html_url": "https://github.com/rust-lang/rust/commit/bbc41aa9a674b80c4423ca6196fb334fd4d17776"}], "stats": {"total": 338, "additions": 157, "deletions": 181}, "files": [{"sha": "004a2aada6a538cf84012126e7f948fbd1707c8b", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 116, "deletions": 112, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/cde2f5f11639edb2f943b6caa5f3b930c0c4f214/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde2f5f11639edb2f943b6caa5f3b930c0c4f214/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=cde2f5f11639edb2f943b6caa5f3b930c0c4f214", "patch": "@@ -10,12 +10,13 @@\n \n use hair::cx::Cx;\n use rustc::middle::region::{CodeExtent, CodeExtentData};\n-use rustc::ty::{self, FnOutput, Ty};\n+use rustc::ty::{self, Ty};\n use rustc::mir::repr::*;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc::hir;\n use rustc::hir::pat_util::pat_is_binding;\n use std::ops::{Index, IndexMut};\n+use syntax::abi::Abi;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token::keywords;\n@@ -159,74 +160,51 @@ macro_rules! unpack {\n ///////////////////////////////////////////////////////////////////////////\n /// the main entry point for building MIR for a function\n \n-pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n-                          span: Span,\n-                          fn_id: ast::NodeId,\n-                          body_id: ast::NodeId,\n-                          implicit_arguments: Vec<Ty<'tcx>>,\n-                          explicit_arguments: Vec<(Ty<'tcx>, &'tcx hir::Pat)>,\n-                          return_ty: FnOutput<'tcx>,\n-                          ast_block: &'tcx hir::Block)\n-                          -> (Mir<'tcx>, ScopeAuxiliaryVec) {\n+pub fn construct_fn<'a, 'tcx, A>(hir: Cx<'a,'tcx>,\n+                                 fn_id: ast::NodeId,\n+                                 arguments: A,\n+                                 return_ty: ty::FnOutput<'tcx>,\n+                                 ast_block: &'tcx hir::Block)\n+                                 -> (Mir<'tcx>, ScopeAuxiliaryVec)\n+    where A: Iterator<Item=(Ty<'tcx>, Option<&'tcx hir::Pat>)>\n+{\n     let tcx = hir.tcx();\n-    let cfg = CFG { basic_blocks: vec![] };\n-\n-    let mut builder = Builder {\n-        hir: hir,\n-        cfg: cfg,\n-        fn_span: span,\n-        scopes: vec![],\n-        scope_datas: vec![],\n-        scope_auxiliary: ScopeAuxiliaryVec { vec: vec![] },\n-        loop_scopes: vec![],\n-        temp_decls: vec![],\n-        var_decls: vec![],\n-        var_indices: FnvHashMap(),\n-        unit_temp: None,\n-        cached_resume_block: None,\n-        cached_return_block: None\n-    };\n-\n-    assert_eq!(builder.cfg.start_new_block(), START_BLOCK);\n+    let span = tcx.map.span(fn_id);\n+    let mut builder = Builder::new(hir, span);\n \n-    let mut arg_decls = None; // assigned to `Some` in closures below\n+    let body_id = ast_block.id;\n     let call_site_extent =\n         tcx.region_maps.lookup_code_extent(\n             CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body_id });\n-    let _ = builder.in_scope(call_site_extent, START_BLOCK, |builder, call_site_scope_id| {\n-        let mut block = START_BLOCK;\n-        let arg_extent =\n-            tcx.region_maps.lookup_code_extent(\n-                CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body_id });\n-        unpack!(block = builder.in_scope(arg_extent, block, |builder, arg_scope_id| {\n-            arg_decls = Some(unpack!(block = builder.args_and_body(block,\n-                                                                   return_ty,\n-                                                                   implicit_arguments,\n-                                                                   explicit_arguments,\n-                                                                   arg_scope_id,\n-                                                                   ast_block)));\n-            block.unit()\n+    let arg_extent =\n+        tcx.region_maps.lookup_code_extent(\n+            CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body_id });\n+    let mut block = START_BLOCK;\n+    let mut arg_decls = unpack!(block = builder.in_scope(call_site_extent, block,\n+                                                         |builder, call_site_scope_id| {\n+        let arg_decls = unpack!(block = builder.in_scope(arg_extent, block,\n+                                                         |builder, arg_scope_id| {\n+            builder.args_and_body(block, return_ty, arguments, arg_scope_id, ast_block)\n         }));\n \n         let return_block = builder.return_block();\n         builder.cfg.terminate(block, call_site_scope_id, span,\n                               TerminatorKind::Goto { target: return_block });\n         builder.cfg.terminate(return_block, call_site_scope_id, span,\n                               TerminatorKind::Return);\n-        return_block.unit()\n-    });\n-\n-    assert!(\n-        builder.cfg.basic_blocks\n-                   .iter()\n-                   .enumerate()\n-                   .all(|(index, block)| {\n-                       if block.terminator.is_none() {\n-                           bug!(\"no terminator on block {:?} in fn {:?}\",\n-                                index, fn_id)\n-                       }\n-                       true\n-                   }));\n+        return_block.and(arg_decls)\n+    }));\n+    assert_eq!(block, builder.return_block());\n+\n+    match tcx.node_id_to_type(fn_id).sty {\n+        ty::TyFnDef(_, _, f) if f.abi == Abi::RustCall => {\n+            // RustCall pseudo-ABI untuples the last argument.\n+            if let Some(arg_decl) = arg_decls.last_mut() {\n+                arg_decl.spread = true;\n+            }\n+        }\n+        _ => {}\n+    }\n \n     // Gather the upvars of a closure, if any.\n     let upvar_decls: Vec<_> = tcx.with_freevars(fn_id, |freevars| {\n@@ -251,72 +229,98 @@ pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n         }).collect()\n     });\n \n-    (\n-        Mir {\n-            basic_blocks: builder.cfg.basic_blocks,\n-            scopes: builder.scope_datas,\n-            var_decls: builder.var_decls,\n-            arg_decls: arg_decls.take().expect(\"args never built?\"),\n-            temp_decls: builder.temp_decls,\n-            upvar_decls: upvar_decls,\n-            return_ty: return_ty,\n-            span: span\n-        },\n-        builder.scope_auxiliary,\n-    )\n+    builder.finish(upvar_decls, arg_decls, return_ty)\n }\n \n impl<'a,'tcx> Builder<'a,'tcx> {\n-    fn args_and_body(&mut self,\n-                     mut block: BasicBlock,\n-                     return_ty: FnOutput<'tcx>,\n-                     implicit_arguments: Vec<Ty<'tcx>>,\n-                     explicit_arguments: Vec<(Ty<'tcx>, &'tcx hir::Pat)>,\n-                     argument_scope_id: ScopeId,\n-                     ast_block: &'tcx hir::Block)\n-                     -> BlockAnd<Vec<ArgDecl<'tcx>>>\n+    fn new(hir: Cx<'a, 'tcx>, span: Span) -> Builder<'a, 'tcx> {\n+        let mut builder = Builder {\n+            hir: hir,\n+            cfg: CFG { basic_blocks: vec![] },\n+            fn_span: span,\n+            scopes: vec![],\n+            scope_datas: vec![],\n+            scope_auxiliary: ScopeAuxiliaryVec { vec: vec![] },\n+            loop_scopes: vec![],\n+            temp_decls: vec![],\n+            var_decls: vec![],\n+            var_indices: FnvHashMap(),\n+            unit_temp: None,\n+            cached_resume_block: None,\n+            cached_return_block: None\n+        };\n+\n+        assert_eq!(builder.cfg.start_new_block(), START_BLOCK);\n+\n+        builder\n+    }\n+\n+    fn finish(self,\n+              upvar_decls: Vec<UpvarDecl>,\n+              arg_decls: Vec<ArgDecl<'tcx>>,\n+              return_ty: ty::FnOutput<'tcx>)\n+              -> (Mir<'tcx>, ScopeAuxiliaryVec) {\n+        for (index, block) in self.cfg.basic_blocks.iter().enumerate() {\n+            if block.terminator.is_none() {\n+                span_bug!(self.fn_span, \"no terminator on block {:?}\", index);\n+            }\n+        }\n+\n+        (Mir {\n+            basic_blocks: self.cfg.basic_blocks,\n+            scopes: self.scope_datas,\n+            var_decls: self.var_decls,\n+            arg_decls: arg_decls,\n+            temp_decls: self.temp_decls,\n+            upvar_decls: upvar_decls,\n+            return_ty: return_ty,\n+            span: self.fn_span\n+        }, self.scope_auxiliary)\n+    }\n+\n+    fn args_and_body<A>(&mut self,\n+                        mut block: BasicBlock,\n+                        return_ty: ty::FnOutput<'tcx>,\n+                        arguments: A,\n+                        argument_scope_id: ScopeId,\n+                        ast_block: &'tcx hir::Block)\n+                        -> BlockAnd<Vec<ArgDecl<'tcx>>>\n+        where A: Iterator<Item=(Ty<'tcx>, Option<&'tcx hir::Pat>)>\n     {\n         // to start, translate the argument patterns and collect the argument types.\n-        let implicits = implicit_arguments.into_iter().map(|ty| (ty, None));\n-        let explicits = explicit_arguments.into_iter().map(|(ty, pat)| (ty, Some(pat)));\n-            let arg_decls =\n-            implicits\n-            .chain(explicits)\n-            .enumerate()\n-            .map(|(index, (ty, pattern))| {\n-                let lvalue = Lvalue::Arg(index as u32);\n-                if let Some(pattern) = pattern {\n-                    let pattern = self.hir.irrefutable_pat(pattern);\n-                    unpack!(block = self.lvalue_into_pattern(block,\n-                                                             argument_scope_id,\n-                                                             pattern,\n-                                                             &lvalue));\n-                }\n+        let arg_decls = arguments.enumerate().map(|(index, (ty, pattern))| {\n+            let lvalue = Lvalue::Arg(index as u32);\n+            if let Some(pattern) = pattern {\n+                let pattern = self.hir.irrefutable_pat(pattern);\n+                unpack!(block = self.lvalue_into_pattern(block,\n+                                                         argument_scope_id,\n+                                                         pattern,\n+                                                         &lvalue));\n+            }\n \n-                // Make sure we drop (parts of) the argument even when not matched on.\n-                let argument_extent = self.scope_auxiliary[argument_scope_id].extent;\n-                self.schedule_drop(pattern.as_ref().map_or(ast_block.span, |pat| pat.span),\n-                                   argument_extent, &lvalue, ty);\n-\n-                let mut name = keywords::Invalid.name();\n-                if let Some(pat) = pattern {\n-                    if let hir::PatKind::Ident(_, ref ident, _) = pat.node {\n-                        if pat_is_binding(&self.hir.tcx().def_map.borrow(), pat) {\n-                            name = ident.node.name;\n-                        }\n+            // Make sure we drop (parts of) the argument even when not matched on.\n+            let argument_extent = self.scope_auxiliary[argument_scope_id].extent;\n+            self.schedule_drop(pattern.as_ref().map_or(ast_block.span, |pat| pat.span),\n+                               argument_extent, &lvalue, ty);\n+\n+            let mut name = keywords::Invalid.name();\n+            if let Some(pat) = pattern {\n+                if let hir::PatKind::Ident(_, ref ident, _) = pat.node {\n+                    if pat_is_binding(&self.hir.tcx().def_map.borrow(), pat) {\n+                        name = ident.node.name;\n                     }\n                 }\n+            }\n \n-                ArgDecl {\n-                    ty: ty,\n-                    spread: false,\n-                    debug_name: name\n-                }\n-            })\n-            .collect();\n+            ArgDecl {\n+                ty: ty,\n+                spread: false,\n+                debug_name: name\n+            }\n+        }).collect();\n \n         // FIXME(#32959): temporary hack for the issue at hand\n-        let return_is_unit = if let FnOutput::FnConverging(t) = return_ty {\n+        let return_is_unit = if let ty::FnConverging(t) = return_ty {\n             t.is_nil()\n         } else {\n             false"}, {"sha": "dad1f1572881c76df179f0053394cb169f7fa8a8", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 41, "deletions": 69, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/cde2f5f11639edb2f943b6caa5f3b930c0c4f214/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde2f5f11639edb2f943b6caa5f3b930c0c4f214/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=cde2f5f11639edb2f943b6caa5f3b930c0c4f214", "patch": "@@ -28,11 +28,9 @@ use rustc::mir::mir_map::MirMap;\n use rustc::infer;\n use rustc::traits::ProjectionMode;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::NodeMap;\n use rustc::hir;\n use rustc::hir::intravisit::{self, Visitor};\n-use syntax::abi::Abi;\n use syntax::ast;\n use syntax::codemap::Span;\n \n@@ -58,89 +56,63 @@ struct BuildMir<'a, 'tcx: 'a> {\n     map: &'a mut MirMap<'tcx>,\n }\n \n+impl<'a, 'tcx> BuildMir<'a, 'tcx> {\n+    fn build<F>(&mut self, id: ast::NodeId, f: F)\n+        where F: for<'b> FnOnce(Cx<'b, 'tcx>) -> (Mir<'tcx>, build::ScopeAuxiliaryVec)\n+    {\n+        let param_env = ty::ParameterEnvironment::for_item(self.tcx, id);\n+        let infcx = infer::new_infer_ctxt(self.tcx,\n+                                          &self.tcx.tables,\n+                                          Some(param_env),\n+                                          ProjectionMode::AnyFinal);\n+\n+        let (mir, scope_auxiliary) = f(Cx::new(&infcx));\n+\n+        pretty::dump_mir(self.tcx, \"mir_map\", &0, id, &mir, Some(&scope_auxiliary));\n+\n+        assert!(self.map.map.insert(id, mir).is_none())\n+    }\n+}\n+\n impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n     fn visit_fn(&mut self,\n                 fk: intravisit::FnKind<'tcx>,\n                 decl: &'tcx hir::FnDecl,\n                 body: &'tcx hir::Block,\n                 span: Span,\n                 id: ast::NodeId) {\n-        let implicit_arg_tys = if let intravisit::FnKind::Closure(..) = fk {\n-            vec![closure_self_ty(&self.tcx, id, body.id)]\n+        // fetch the fully liberated fn signature (that is, all bound\n+        // types/lifetimes replaced)\n+        let fn_sig = match self.tcx.tables.borrow().liberated_fn_sigs.get(&id) {\n+            Some(f) => f.clone(),\n+            None => {\n+                span_bug!(span, \"no liberated fn sig for {:?}\", id);\n+            }\n+        };\n+\n+        let implicit_argument = if let intravisit::FnKind::Closure(..) = fk {\n+            Some((closure_self_ty(&self.tcx, id, body.id), None))\n         } else {\n-            vec![]\n+            None\n         };\n \n-        let param_env = ty::ParameterEnvironment::for_item(self.tcx, id);\n-        let infcx = infer::new_infer_ctxt(self.tcx,\n-                                          &self.tcx.tables,\n-                                          Some(param_env),\n-                                          ProjectionMode::AnyFinal);\n+        let explicit_arguments =\n+            decl.inputs\n+                .iter()\n+                .enumerate()\n+                .map(|(index, arg)| {\n+                    (fn_sig.inputs[index], Some(&*arg.pat))\n+                });\n \n-        match build_mir(Cx::new(&infcx), implicit_arg_tys, id, span, decl, body) {\n-            Ok(mir) => assert!(self.map.map.insert(id, mir).is_none()),\n-            Err(ErrorReported) => {}\n-        }\n+        self.build(id, |cx| {\n+            let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n+            build::construct_fn(cx, id, arguments, fn_sig.output, body)\n+        });\n \n         intravisit::walk_fn(self, fk, decl, body, span);\n     }\n }\n \n-fn build_mir<'a,'tcx:'a>(cx: Cx<'a,'tcx>,\n-                         implicit_arg_tys: Vec<Ty<'tcx>>,\n-                         fn_id: ast::NodeId,\n-                         span: Span,\n-                         decl: &'tcx hir::FnDecl,\n-                         body: &'tcx hir::Block)\n-                         -> Result<Mir<'tcx>, ErrorReported> {\n-    // fetch the fully liberated fn signature (that is, all bound\n-    // types/lifetimes replaced)\n-    let fn_sig = match cx.tcx().tables.borrow().liberated_fn_sigs.get(&fn_id) {\n-        Some(f) => f.clone(),\n-        None => {\n-            span_bug!(span, \"no liberated fn sig for {:?}\", fn_id);\n-        }\n-    };\n-\n-    let arguments =\n-        decl.inputs\n-            .iter()\n-            .enumerate()\n-            .map(|(index, arg)| {\n-                (fn_sig.inputs[index], &*arg.pat)\n-            })\n-            .collect();\n-\n-    let (mut mir, scope_auxiliary) =\n-        build::construct(cx,\n-                         span,\n-                         fn_id,\n-                         body.id,\n-                         implicit_arg_tys,\n-                         arguments,\n-                         fn_sig.output,\n-                         body);\n-\n-    match cx.tcx().node_id_to_type(fn_id).sty {\n-        ty::TyFnDef(_, _, f) if f.abi == Abi::RustCall => {\n-            // RustCall pseudo-ABI untuples the last argument.\n-            if let Some(arg_decl) = mir.arg_decls.last_mut() {\n-                arg_decl.spread = true;\n-            }\n-        }\n-        _ => {}\n-    }\n-\n-    pretty::dump_mir(cx.tcx(),\n-                     \"mir_map\",\n-                     &0,\n-                     fn_id,\n-                     &mir,\n-                     Some(&scope_auxiliary));\n-\n-    Ok(mir)\n-}\n-\n fn closure_self_ty<'a, 'tcx>(tcx: &TyCtxt<'tcx>,\n                              closure_expr_id: ast::NodeId,\n                              body_id: ast::NodeId)"}]}