{"sha": "9eb19d92dd8d3200f3530faefa7a4048f58d280d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllYjE5ZDkyZGQ4ZDMyMDBmMzUzMGZhZWZhN2E0MDQ4ZjU4ZDI4MGQ=", "commit": {"author": {"name": "Vladyslav Katasonov", "email": "cpud47@gmail.com", "date": "2021-02-10T16:26:42Z"}, "committer": {"name": "Vladyslav Katasonov", "email": "cpud47@gmail.com", "date": "2021-02-13T19:04:52Z"}, "message": "allow try expr? when extacting function", "tree": {"sha": "2414b2478255d2856ccffb168e6092145bde8fbd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2414b2478255d2856ccffb168e6092145bde8fbd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9eb19d92dd8d3200f3530faefa7a4048f58d280d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9eb19d92dd8d3200f3530faefa7a4048f58d280d", "html_url": "https://github.com/rust-lang/rust/commit/9eb19d92dd8d3200f3530faefa7a4048f58d280d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9eb19d92dd8d3200f3530faefa7a4048f58d280d/comments", "author": {"login": "cpud36", "id": 4218373, "node_id": "MDQ6VXNlcjQyMTgzNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4218373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpud36", "html_url": "https://github.com/cpud36", "followers_url": "https://api.github.com/users/cpud36/followers", "following_url": "https://api.github.com/users/cpud36/following{/other_user}", "gists_url": "https://api.github.com/users/cpud36/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpud36/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpud36/subscriptions", "organizations_url": "https://api.github.com/users/cpud36/orgs", "repos_url": "https://api.github.com/users/cpud36/repos", "events_url": "https://api.github.com/users/cpud36/events{/privacy}", "received_events_url": "https://api.github.com/users/cpud36/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cpud36", "id": 4218373, "node_id": "MDQ6VXNlcjQyMTgzNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4218373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpud36", "html_url": "https://github.com/cpud36", "followers_url": "https://api.github.com/users/cpud36/followers", "following_url": "https://api.github.com/users/cpud36/following{/other_user}", "gists_url": "https://api.github.com/users/cpud36/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpud36/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpud36/subscriptions", "organizations_url": "https://api.github.com/users/cpud36/orgs", "repos_url": "https://api.github.com/users/cpud36/repos", "events_url": "https://api.github.com/users/cpud36/events{/privacy}", "received_events_url": "https://api.github.com/users/cpud36/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f345d1772ab3827fbc3e31428b0d9479cab0ea39", "url": "https://api.github.com/repos/rust-lang/rust/commits/f345d1772ab3827fbc3e31428b0d9479cab0ea39", "html_url": "https://github.com/rust-lang/rust/commit/f345d1772ab3827fbc3e31428b0d9479cab0ea39"}], "stats": {"total": 380, "additions": 350, "deletions": 30}, "files": [{"sha": "225a50d2d00d3caf5d27abf7eaae599dd588cf6e", "filename": "crates/assists/src/handlers/extract_function.rs", "status": "modified", "additions": 347, "deletions": 30, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/9eb19d92dd8d3200f3530faefa7a4048f58d280d/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb19d92dd8d3200f3530faefa7a4048f58d280d/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=9eb19d92dd8d3200f3530faefa7a4048f58d280d", "patch": "@@ -84,7 +84,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         // We should not have variables that outlive body if we have expression block\n         return None;\n     }\n-    let control_flow = external_control_flow(&body)?;\n+    let control_flow = external_control_flow(ctx, &body)?;\n \n     let target_range = body.text_range();\n \n@@ -117,7 +117,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n     )\n }\n \n-fn external_control_flow(body: &FunctionBody) -> Option<ControlFlow> {\n+fn external_control_flow(ctx: &AssistContext, body: &FunctionBody) -> Option<ControlFlow> {\n     let mut ret_expr = None;\n     let mut try_expr = None;\n     let mut break_expr = None;\n@@ -180,35 +180,71 @@ fn external_control_flow(body: &FunctionBody) -> Option<ControlFlow> {\n         }\n     }\n \n-    if try_expr.is_some() {\n-        // FIXME: support try\n-        return None;\n-    }\n+    let kind = match (try_expr, ret_expr, break_expr, continue_expr) {\n+        (Some(e), None, None, None) => {\n+            let func = e.syntax().ancestors().find_map(ast::Fn::cast)?;\n+            let def = ctx.sema.to_def(&func)?;\n+            let ret_ty = def.ret_type(ctx.db());\n+            let kind = try_kind_of_ty(ret_ty, ctx)?;\n \n-    let kind = match (ret_expr, break_expr, continue_expr) {\n-        (Some(r), None, None) => match r.expr() {\n+            Some(FlowKind::Try { kind })\n+        }\n+        (Some(_), Some(r), None, None) => match r.expr() {\n+            Some(expr) => {\n+                if let Some(kind) = expr_err_kind(&expr, ctx) {\n+                    Some(FlowKind::TryReturn { expr, kind })\n+                } else {\n+                    mark::hit!(external_control_flow_try_and_return_non_err);\n+                    return None;\n+                }\n+            }\n+            None => return None,\n+        },\n+        (Some(_), _, _, _) => {\n+            mark::hit!(external_control_flow_try_and_bc);\n+            return None;\n+        }\n+        (None, Some(r), None, None) => match r.expr() {\n             Some(expr) => Some(FlowKind::ReturnValue(expr)),\n             None => Some(FlowKind::Return),\n         },\n-        (Some(_), _, _) => {\n+        (None, Some(_), _, _) => {\n             mark::hit!(external_control_flow_return_and_bc);\n             return None;\n         }\n-        (None, Some(_), Some(_)) => {\n+        (None, None, Some(_), Some(_)) => {\n             mark::hit!(external_control_flow_break_and_continue);\n             return None;\n         }\n-        (None, Some(b), None) => match b.expr() {\n+        (None, None, Some(b), None) => match b.expr() {\n             Some(expr) => Some(FlowKind::BreakValue(expr)),\n             None => Some(FlowKind::Break),\n         },\n-        (None, None, Some(_)) => Some(FlowKind::Continue),\n-        (None, None, None) => None,\n+        (None, None, None, Some(_)) => Some(FlowKind::Continue),\n+        (None, None, None, None) => None,\n     };\n \n     Some(ControlFlow { kind })\n }\n \n+/// Checks is expr is `Err(_)` or `None`\n+fn expr_err_kind(expr: &ast::Expr, ctx: &AssistContext) -> Option<TryKind> {\n+    let call_expr = match expr {\n+        ast::Expr::CallExpr(call_expr) => call_expr,\n+        _ => return None,\n+    };\n+    let func = call_expr.expr()?;\n+    let text = func.syntax().text();\n+\n+    if text == \"Err\" {\n+        Some(TryKind::Result { ty: ctx.sema.type_of_expr(expr)? })\n+    } else if text == \"None\" {\n+        Some(TryKind::Option)\n+    } else {\n+        None\n+    }\n+}\n+\n #[derive(Debug)]\n struct Function {\n     name: String,\n@@ -330,6 +366,13 @@ enum FlowKind {\n     Return,\n     /// Return with value (`return $expr;`)\n     ReturnValue(ast::Expr),\n+    Try {\n+        kind: TryKind,\n+    },\n+    TryReturn {\n+        expr: ast::Expr,\n+        kind: TryKind,\n+    },\n     /// Break without value (`return;`)\n     Break,\n     /// Break with value (`break $expr;`)\n@@ -338,11 +381,21 @@ enum FlowKind {\n     Continue,\n }\n \n+#[derive(Debug, Clone)]\n+enum TryKind {\n+    Option,\n+    Result { ty: hir::Type },\n+}\n+\n impl FlowKind {\n-    fn make_expr(&self, expr: Option<ast::Expr>) -> ast::Expr {\n+    fn make_result_handler(&self, expr: Option<ast::Expr>) -> ast::Expr {\n         match self {\n             FlowKind::Return | FlowKind::ReturnValue(_) => make::expr_return(expr),\n             FlowKind::Break | FlowKind::BreakValue(_) => make::expr_break(expr),\n+            FlowKind::Try { .. } | FlowKind::TryReturn { .. } => {\n+                stdx::never!(\"cannot have result handler with try\");\n+                expr.unwrap_or_else(|| make::expr_return(None))\n+            }\n             FlowKind::Continue => {\n                 stdx::always!(expr.is_none(), \"continue with value is not possible\");\n                 make::expr_continue()\n@@ -352,12 +405,34 @@ impl FlowKind {\n \n     fn expr_ty(&self, ctx: &AssistContext) -> Option<hir::Type> {\n         match self {\n-            FlowKind::ReturnValue(expr) | FlowKind::BreakValue(expr) => ctx.sema.type_of_expr(expr),\n+            FlowKind::ReturnValue(expr)\n+            | FlowKind::BreakValue(expr)\n+            | FlowKind::TryReturn { expr, .. } => ctx.sema.type_of_expr(expr),\n+            FlowKind::Try { .. } => {\n+                stdx::never!(\"try does not have defined expr_ty\");\n+                None\n+            }\n             FlowKind::Return | FlowKind::Break | FlowKind::Continue => None,\n         }\n     }\n }\n \n+fn try_kind_of_ty(ty: hir::Type, ctx: &AssistContext) -> Option<TryKind> {\n+    if ty.is_unknown() {\n+        // We favour Result for `expr?`\n+        return Some(TryKind::Result { ty });\n+    }\n+    let adt = ty.as_adt()?;\n+    let name = adt.name(ctx.db());\n+    // FIXME: use lang items to determine if it is std type or user defined\n+    //        E.g. if user happens to define type named `Option`, we would have false positive\n+    match name.to_string().as_str() {\n+        \"Option\" => Some(TryKind::Option),\n+        \"Result\" => Some(TryKind::Result { ty }),\n+        _ => None,\n+    }\n+}\n+\n #[derive(Debug)]\n enum RetType {\n     Expr(hir::Type),\n@@ -851,7 +926,7 @@ fn format_replacement(ctx: &AssistContext, fun: &Function, indent: IndentLevel)\n \n     let handler = FlowHandler::from_ret_ty(fun, &ret_ty);\n \n-    let expr = handler.make_expr(call_expr).indent(indent);\n+    let expr = handler.make_call_expr(call_expr).indent(indent);\n \n     let mut buf = String::new();\n     match fun.vars_defined_in_body_and_outlive.as_slice() {\n@@ -877,6 +952,7 @@ fn format_replacement(ctx: &AssistContext, fun: &Function, indent: IndentLevel)\n \n enum FlowHandler {\n     None,\n+    Try { kind: TryKind },\n     If { action: FlowKind },\n     IfOption { action: FlowKind },\n     MatchOption { none: FlowKind },\n@@ -897,6 +973,9 @@ impl FlowHandler {\n                         FlowKind::ReturnValue(_) | FlowKind::BreakValue(_) => {\n                             FlowHandler::IfOption { action }\n                         }\n+                        FlowKind::Try { kind } | FlowKind::TryReturn { kind, .. } => {\n+                            FlowHandler::Try { kind: kind.clone() }\n+                        }\n                     }\n                 } else {\n                     match flow_kind {\n@@ -906,17 +985,21 @@ impl FlowHandler {\n                         FlowKind::ReturnValue(_) | FlowKind::BreakValue(_) => {\n                             FlowHandler::MatchResult { err: action }\n                         }\n+                        FlowKind::Try { kind } | FlowKind::TryReturn { kind, .. } => {\n+                            FlowHandler::Try { kind: kind.clone() }\n+                        }\n                     }\n                 }\n             }\n         }\n     }\n \n-    fn make_expr(&self, call_expr: ast::Expr) -> ast::Expr {\n+    fn make_call_expr(&self, call_expr: ast::Expr) -> ast::Expr {\n         match self {\n             FlowHandler::None => call_expr,\n+            FlowHandler::Try { kind: _ } => make::expr_try(call_expr),\n             FlowHandler::If { action } => {\n-                let action = action.make_expr(None);\n+                let action = action.make_result_handler(None);\n                 let stmt = make::expr_stmt(action);\n                 let block = make::block_expr(iter::once(stmt.into()), None);\n                 let condition = make::condition(call_expr, None);\n@@ -928,7 +1011,7 @@ impl FlowHandler {\n                 let pattern = make::tuple_struct_pat(path, iter::once(value_pat.into()));\n                 let cond = make::condition(call_expr, Some(pattern.into()));\n                 let value = make::expr_path(make_path_from_text(\"value\"));\n-                let action_expr = action.make_expr(Some(value));\n+                let action_expr = action.make_result_handler(Some(value));\n                 let action_stmt = make::expr_stmt(action_expr);\n                 let then = make::block_expr(iter::once(action_stmt.into()), None);\n                 make::expr_if(cond, then, None)\n@@ -946,7 +1029,7 @@ impl FlowHandler {\n                 let none_arm = {\n                     let path = make_path_from_text(\"None\");\n                     let pat = make::path_pat(path);\n-                    make::match_arm(iter::once(pat), none.make_expr(None))\n+                    make::match_arm(iter::once(pat), none.make_result_handler(None))\n                 };\n                 let arms = make::match_arm_list(vec![some_arm, none_arm]);\n                 make::expr_match(call_expr, arms)\n@@ -967,7 +1050,7 @@ impl FlowHandler {\n                     let value_pat = make::ident_pat(make::name(err_name));\n                     let pat = make::tuple_struct_pat(path, iter::once(value_pat.into()));\n                     let value = make::expr_path(make_path_from_text(err_name));\n-                    make::match_arm(iter::once(pat.into()), err.make_expr(Some(value)))\n+                    make::match_arm(iter::once(pat.into()), err.make_result_handler(Some(value)))\n                 };\n                 let arms = make::match_arm_list(vec![ok_arm, err_arm]);\n                 make::expr_match(call_expr, arms)\n@@ -1035,14 +1118,25 @@ impl FunType {\n }\n \n fn make_ret_ty(ctx: &AssistContext, module: hir::Module, fun: &Function) -> Option<ast::RetType> {\n-    let ty = fun.return_type(ctx);\n-    let handler = FlowHandler::from_ret_ty(fun, &ty);\n+    let fun_ty = fun.return_type(ctx);\n+    let handler = FlowHandler::from_ret_ty(fun, &fun_ty);\n     let ret_ty = match &handler {\n         FlowHandler::None => {\n-            if matches!(ty, FunType::Unit) {\n+            if matches!(fun_ty, FunType::Unit) {\n                 return None;\n             }\n-            ty.make_ty(ctx, module)\n+            fun_ty.make_ty(ctx, module)\n+        }\n+        FlowHandler::Try { kind: TryKind::Option } => {\n+            make::ty_generic(make::name_ref(\"Option\"), iter::once(fun_ty.make_ty(ctx, module)))\n+        }\n+        FlowHandler::Try { kind: TryKind::Result { ty: parent_ret_ty } } => {\n+            let handler_ty =\n+                result_err_ty(parent_ret_ty, ctx, module).unwrap_or_else(make::ty_unit);\n+            make::ty_generic(\n+                make::name_ref(\"Result\"),\n+                vec![fun_ty.make_ty(ctx, module), handler_ty],\n+            )\n         }\n         FlowHandler::If { .. } => make::ty(\"bool\"),\n         FlowHandler::IfOption { action } => {\n@@ -1053,17 +1147,42 @@ fn make_ret_ty(ctx: &AssistContext, module: hir::Module, fun: &Function) -> Opti\n             make::ty_generic(make::name_ref(\"Option\"), iter::once(handler_ty))\n         }\n         FlowHandler::MatchOption { .. } => {\n-            make::ty_generic(make::name_ref(\"Option\"), iter::once(ty.make_ty(ctx, module)))\n+            make::ty_generic(make::name_ref(\"Option\"), iter::once(fun_ty.make_ty(ctx, module)))\n         }\n         FlowHandler::MatchResult { err } => {\n             let handler_ty =\n                 err.expr_ty(ctx).map(|ty| make_ty(&ty, ctx, module)).unwrap_or_else(make::ty_unit);\n-            make::ty_generic(make::name_ref(\"Result\"), vec![ty.make_ty(ctx, module), handler_ty])\n+            make::ty_generic(\n+                make::name_ref(\"Result\"),\n+                vec![fun_ty.make_ty(ctx, module), handler_ty],\n+            )\n         }\n     };\n     Some(make::ret_type(ret_ty))\n }\n \n+/// Extract `E` type from `Result<T, E>`\n+fn result_err_ty(\n+    parent_ret_ty: &hir::Type,\n+    ctx: &AssistContext,\n+    module: hir::Module,\n+) -> Option<ast::Type> {\n+    // FIXME: use hir to extract argument information\n+    //        currently we use `format -> take part -> parse`\n+    let path_ty = match make_ty(&parent_ret_ty, ctx, module) {\n+        ast::Type::PathType(path_ty) => path_ty,\n+        _ => return None,\n+    };\n+    let arg_list = path_ty.path()?.segment()?.generic_arg_list()?;\n+    let err_arg = arg_list.generic_args().nth(1)?;\n+    let type_arg = match err_arg {\n+        ast::GenericArg::TypeArg(type_arg) => type_arg,\n+        _ => return None,\n+    };\n+\n+    type_arg.ty()\n+}\n+\n fn make_body(\n     ctx: &AssistContext,\n     old_indent: IndentLevel,\n@@ -1128,6 +1247,18 @@ fn make_body(\n \n     let block = match &handler {\n         FlowHandler::None => block,\n+        FlowHandler::Try { kind } => {\n+            let block = with_default_tail_expr(block, make::expr_unit());\n+            map_tail_expr(block, |tail_expr| {\n+                let constructor = match kind {\n+                    TryKind::Option => \"Some\",\n+                    TryKind::Result { .. } => \"Ok\",\n+                };\n+                let func = make::expr_path(make_path_from_text(constructor));\n+                let args = make::arg_list(iter::once(tail_expr));\n+                make::expr_call(func, args)\n+            })\n+        }\n         FlowHandler::If { .. } => {\n             let lit_false = ast::Literal::cast(make::tokens::literal(\"false\").parent()).unwrap();\n             with_tail_expr(block, lit_false.into())\n@@ -1142,9 +1273,9 @@ fn make_body(\n             make::expr_call(some, args)\n         }),\n         FlowHandler::MatchResult { .. } => map_tail_expr(block, |tail_expr| {\n-            let some = make::expr_path(make_path_from_text(\"Ok\"));\n+            let ok = make::expr_path(make_path_from_text(\"Ok\"));\n             let args = make::arg_list(iter::once(tail_expr));\n-            make::expr_call(some, args)\n+            make::expr_call(ok, args)\n         }),\n     };\n \n@@ -1159,6 +1290,13 @@ fn map_tail_expr(block: ast::BlockExpr, f: impl FnOnce(ast::Expr) -> ast::Expr)\n     make::block_expr(block.statements(), Some(f(tail_expr)))\n }\n \n+fn with_default_tail_expr(block: ast::BlockExpr, tail_expr: ast::Expr) -> ast::BlockExpr {\n+    match block.tail_expr() {\n+        Some(_) => block,\n+        None => make::block_expr(block.statements(), Some(tail_expr)),\n+    }\n+}\n+\n fn with_tail_expr(block: ast::BlockExpr, tail_expr: ast::Expr) -> ast::BlockExpr {\n     let stmt_tail = block.tail_expr().map(|expr| make::expr_stmt(expr).into());\n     let stmts = block.statements().chain(stmt_tail);\n@@ -1295,7 +1433,7 @@ fn update_external_control_flow(handler: &FlowHandler, syntax: &SyntaxNode) -> S\n \n fn make_rewritten_flow(handler: &FlowHandler, arg_expr: Option<ast::Expr>) -> Option<ast::Expr> {\n     let value = match handler {\n-        FlowHandler::None => return None,\n+        FlowHandler::None | FlowHandler::Try { .. } => return None,\n         FlowHandler::If { .. } => {\n             ast::Literal::cast(make::tokens::literal(\"true\").parent()).unwrap().into()\n         }\n@@ -3036,6 +3174,185 @@ fn $0fun_name() -> Result<i32, i64> {\n     }\n     let m = k + 1;\n     Ok(m)\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn try_option() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+enum Option<T> { None, Some(T), }\n+use Option::*;\n+fn bar() -> Option<i32> { None }\n+fn foo() -> Option<()> {\n+    let n = bar()?;\n+    $0let k = foo()?;\n+    let m = k + 1;$0\n+    let h = 1 + m;\n+    Some(())\n+}\"##,\n+            r##\"\n+enum Option<T> { None, Some(T), }\n+use Option::*;\n+fn bar() -> Option<i32> { None }\n+fn foo() -> Option<()> {\n+    let n = bar()?;\n+    let m = fun_name()?;\n+    let h = 1 + m;\n+    Some(())\n+}\n+\n+fn $0fun_name() -> Option<i32> {\n+    let k = foo()?;\n+    let m = k + 1;\n+    Some(m)\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn try_option_unit() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+enum Option<T> { None, Some(T), }\n+use Option::*;\n+fn foo() -> Option<()> {\n+    let n = 1;\n+    $0let k = foo()?;\n+    let m = k + 1;$0\n+    let h = 1 + n;\n+    Some(())\n+}\"##,\n+            r##\"\n+enum Option<T> { None, Some(T), }\n+use Option::*;\n+fn foo() -> Option<()> {\n+    let n = 1;\n+    fun_name()?;\n+    let h = 1 + n;\n+    Some(())\n+}\n+\n+fn $0fun_name() -> Option<()> {\n+    let k = foo()?;\n+    let m = k + 1;\n+    Some(())\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn try_result() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+enum Result<T, E> { Ok(T), Err(E), }\n+use Result::*;\n+fn foo() -> Result<(), i64> {\n+    let n = 1;\n+    $0let k = foo()?;\n+    let m = k + 1;$0\n+    let h = 1 + m;\n+    Ok(())\n+}\"##,\n+            r##\"\n+enum Result<T, E> { Ok(T), Err(E), }\n+use Result::*;\n+fn foo() -> Result<(), i64> {\n+    let n = 1;\n+    let m = fun_name()?;\n+    let h = 1 + m;\n+    Ok(())\n+}\n+\n+fn $0fun_name() -> Result<i32, i64> {\n+    let k = foo()?;\n+    let m = k + 1;\n+    Ok(m)\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn try_result_with_return() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+enum Result<T, E> { Ok(T), Err(E), }\n+use Result::*;\n+fn foo() -> Result<(), i64> {\n+    let n = 1;\n+    $0let k = foo()?;\n+    if k == 42 {\n+        return Err(1);\n+    }\n+    let m = k + 1;$0\n+    let h = 1 + m;\n+    Ok(())\n+}\"##,\n+            r##\"\n+enum Result<T, E> { Ok(T), Err(E), }\n+use Result::*;\n+fn foo() -> Result<(), i64> {\n+    let n = 1;\n+    let m = fun_name()?;\n+    let h = 1 + m;\n+    Ok(())\n+}\n+\n+fn $0fun_name() -> Result<i32, i64> {\n+    let k = foo()?;\n+    if k == 42 {\n+        return Err(1);\n+    }\n+    let m = k + 1;\n+    Ok(m)\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn try_and_break() {\n+        mark::check!(external_control_flow_try_and_bc);\n+        check_assist_not_applicable(\n+            extract_function,\n+            r##\"\n+enum Option<T> { None, Some(T) }\n+use Option::*;\n+fn foo() -> Option<()> {\n+    loop {\n+        let n = Some(1);\n+        $0let m = n? + 1;\n+        break;\n+        let k = 2;\n+        let k = k + 1;$0\n+        let r = n + k;\n+    }\n+    Some(())\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn try_and_return_ok() {\n+        mark::check!(external_control_flow_try_and_return_non_err);\n+        check_assist_not_applicable(\n+            extract_function,\n+            r##\"\n+enum Result<T, E> { Ok(T), Err(E), }\n+use Result::*;\n+fn foo() -> Result<(), i64> {\n+    let n = 1;\n+    $0let k = foo()?;\n+    if k == 42 {\n+        return Ok(1);\n+    }\n+    let m = k + 1;$0\n+    let h = 1 + m;\n+    Ok(())\n }\"##,\n         );\n     }"}, {"sha": "5eee335458eb3795afc2d2dc23222d8311c18ef3", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9eb19d92dd8d3200f3530faefa7a4048f58d280d/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb19d92dd8d3200f3530faefa7a4048f58d280d/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=9eb19d92dd8d3200f3530faefa7a4048f58d280d", "patch": "@@ -200,6 +200,9 @@ pub fn expr_return(expr: Option<ast::Expr>) -> ast::Expr {\n         None => expr_from_text(\"return\"),\n     }\n }\n+pub fn expr_try(expr: ast::Expr) -> ast::Expr {\n+    expr_from_text(&format!(\"{}?\", expr))\n+}\n pub fn expr_match(expr: ast::Expr, match_arm_list: ast::MatchArmList) -> ast::Expr {\n     expr_from_text(&format!(\"match {} {}\", expr, match_arm_list))\n }"}]}