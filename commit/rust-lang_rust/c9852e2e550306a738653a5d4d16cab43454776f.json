{"sha": "c9852e2e550306a738653a5d4d16cab43454776f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5ODUyZTJlNTUwMzA2YTczODY1M2E1ZDRkMTZjYWI0MzQ1NDc3NmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-25T09:38:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-25T09:38:51Z"}, "message": "Auto merge of #31882 - Manishearth:rollup, r=Manishearth\n\n- Successful merges: #31362, #31793, #31800, #31809, #31818, #31827, #31831, #31835, #31837, #31846\n- Failed merges:", "tree": {"sha": "544a36b22415f5c81da44d6fc5963dbed8e916af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/544a36b22415f5c81da44d6fc5963dbed8e916af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9852e2e550306a738653a5d4d16cab43454776f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9852e2e550306a738653a5d4d16cab43454776f", "html_url": "https://github.com/rust-lang/rust/commit/c9852e2e550306a738653a5d4d16cab43454776f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9852e2e550306a738653a5d4d16cab43454776f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6f050d09003a4c7895f44fed3a7c6cdce8f2949", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6f050d09003a4c7895f44fed3a7c6cdce8f2949", "html_url": "https://github.com/rust-lang/rust/commit/f6f050d09003a4c7895f44fed3a7c6cdce8f2949"}, {"sha": "e584a492f340a73b6d9e546b9708fcb48315bfc8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e584a492f340a73b6d9e546b9708fcb48315bfc8", "html_url": "https://github.com/rust-lang/rust/commit/e584a492f340a73b6d9e546b9708fcb48315bfc8"}], "stats": {"total": 633, "additions": 441, "deletions": 192}, "files": [{"sha": "f66ad04eefe8e3d00246476a3d170d077d7ca5ae", "filename": "mk/cfg/arm-unknown-linux-gnueabi.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/mk%2Fcfg%2Farm-unknown-linux-gnueabi.mk", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/mk%2Fcfg%2Farm-unknown-linux-gnueabi.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farm-unknown-linux-gnueabi.mk?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -8,8 +8,8 @@ CFG_LIB_NAME_arm-unknown-linux-gnueabi=lib$(1).so\n CFG_STATIC_LIB_NAME_arm-unknown-linux-gnueabi=lib$(1).a\n CFG_LIB_GLOB_arm-unknown-linux-gnueabi=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_arm-unknown-linux-gnueabi=lib$(1)-*.dylib.dSYM\n-CFG_JEMALLOC_CFLAGS_arm-unknown-linux-gnueabi := -D__arm__ -mfloat-abi=soft $(CFLAGS)\n-CFG_GCCISH_CFLAGS_arm-unknown-linux-gnueabi := -Wall -g -fPIC -D__arm__ -mfloat-abi=soft $(CFLAGS)\n+CFG_JEMALLOC_CFLAGS_arm-unknown-linux-gnueabi := -D__arm__ -mfloat-abi=soft $(CFLAGS) -march=armv6 -marm\n+CFG_GCCISH_CFLAGS_arm-unknown-linux-gnueabi := -Wall -g -fPIC -D__arm__ -mfloat-abi=soft $(CFLAGS) -march=armv6 -marm\n CFG_GCCISH_CXXFLAGS_arm-unknown-linux-gnueabi := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_arm-unknown-linux-gnueabi := -shared -fPIC -g\n CFG_GCCISH_DEF_FLAG_arm-unknown-linux-gnueabi := -Wl,--export-dynamic,--dynamic-list="}, {"sha": "defe0dc3e70eb6e92ceea365143d56054b3c3874", "filename": "mk/cfg/arm-unknown-linux-gnueabihf.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/mk%2Fcfg%2Farm-unknown-linux-gnueabihf.mk", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/mk%2Fcfg%2Farm-unknown-linux-gnueabihf.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farm-unknown-linux-gnueabihf.mk?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -8,8 +8,8 @@ CFG_LIB_NAME_arm-unknown-linux-gnueabihf=lib$(1).so\n CFG_STATIC_LIB_NAME_arm-unknown-linux-gnueabihf=lib$(1).a\n CFG_LIB_GLOB_arm-unknown-linux-gnueabihf=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_arm-unknown-linux-gnueabihf=lib$(1)-*.dylib.dSYM\n-CFG_JEMALLOC_CFLAGS_arm-unknown-linux-gnueabihf := -D__arm__ $(CFLAGS)\n-CFG_GCCISH_CFLAGS_arm-unknown-linux-gnueabihf := -Wall -g -fPIC -D__arm__ $(CFLAGS)\n+CFG_JEMALLOC_CFLAGS_arm-unknown-linux-gnueabihf := -D__arm__ $(CFLAGS) -march=armv6 -marm\n+CFG_GCCISH_CFLAGS_arm-unknown-linux-gnueabihf := -Wall -g -fPIC -D__arm__ $(CFLAGS) -march=armv6 -marm\n CFG_GCCISH_CXXFLAGS_arm-unknown-linux-gnueabihf := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_arm-unknown-linux-gnueabihf := -shared -fPIC -g\n CFG_GCCISH_DEF_FLAG_arm-unknown-linux-gnueabihf := -Wl,--export-dynamic,--dynamic-list="}, {"sha": "7325d448962cf229a9aac6443895466d0ce89d24", "filename": "src/doc/book/patterns.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/src%2Fdoc%2Fbook%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/src%2Fdoc%2Fbook%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fpatterns.md?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -303,7 +303,7 @@ struct Person {\n }\n \n let name = \"Steve\".to_string();\n-let mut x: Option<Person> = Some(Person { name: Some(name) });\n+let x: Option<Person> = Some(Person { name: Some(name) });\n match x {\n     Some(Person { name: ref a @ Some(_), .. }) => println!(\"{:?}\", a),\n     _ => {}"}, {"sha": "bd256d19b6725653a302f979089fbc389c62d620", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -51,7 +51,7 @@ extern crate getopts;\n extern crate graphviz;\n extern crate libc;\n extern crate rbml;\n-extern crate rustc_llvm;\n+pub extern crate rustc_llvm as llvm;\n extern crate rustc_back;\n extern crate rustc_front;\n extern crate rustc_data_structures;\n@@ -66,8 +66,6 @@ extern crate serialize as rustc_serialize; // used by deriving\n #[cfg(test)]\n extern crate test;\n \n-pub use rustc_llvm as llvm;\n-\n #[macro_use]\n mod macros;\n "}, {"sha": "4bb69a2688a41ded0c12a090929b61d422f093e5", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -124,6 +124,12 @@ declare_lint! {\n     \"detect private items in public interfaces not caught by the old implementation\"\n }\n \n+declare_lint! {\n+    pub INACCESSIBLE_EXTERN_CRATE,\n+    Warn,\n+    \"use of inaccessible extern crate erroneously allowed\"\n+}\n+\n declare_lint! {\n     pub INVALID_TYPE_PARAM_DEFAULT,\n     Warn,\n@@ -167,6 +173,7 @@ impl LintPass for HardwiredLints {\n             TRIVIAL_CASTS,\n             TRIVIAL_NUMERIC_CASTS,\n             PRIVATE_IN_PUBLIC,\n+            INACCESSIBLE_EXTERN_CRATE,\n             INVALID_TYPE_PARAM_DEFAULT,\n             MATCH_OF_UNIT_VARIANT_VIA_PAREN_DOTDOT,\n             CONST_ERR,"}, {"sha": "6cbb90627eab5ee12dc6e153d24d292f51dffcab", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -184,10 +184,13 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n         // Check for duplicates.\n         match self.items.items[item_index] {\n             Some(original_def_id) if original_def_id != item_def_id => {\n+                let cstore = &self.session.cstore;\n                 span_err!(self.session, span, E0152,\n-                    \"duplicate entry for `{}`\", LanguageItems::item_name(item_index));\n+                          \"duplicate entry for `{}`, first definition found in `{}`\",\n+                          LanguageItems::item_name(item_index),\n+                          cstore.crate_name(item_def_id.krate));\n             }\n-            Some(_) | None => {\n+            _ => {\n                 // OK.\n             }\n         }"}, {"sha": "ea08bf021fbba3b464c1ce50c0ecb9cb8cee0542", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 117, "deletions": 64, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -749,24 +749,20 @@ pub fn build_target_config(opts: &Options, sp: &Handler) -> Config {\n     }\n }\n \n-/// Returns the \"short\" subset of the stable rustc command line options.\n-pub fn short_optgroups() -> Vec<getopts::OptGroup> {\n-    rustc_short_optgroups().into_iter()\n-        .filter(|g|g.is_stable())\n-        .map(|g|g.opt_group)\n-        .collect()\n-}\n-\n-/// Returns all of the stable rustc command line options.\n-pub fn optgroups() -> Vec<getopts::OptGroup> {\n-    rustc_optgroups().into_iter()\n-        .filter(|g|g.is_stable())\n-        .map(|g|g.opt_group)\n-        .collect()\n-}\n-\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum OptionStability { Stable, Unstable }\n+pub enum OptionStability {\n+    Stable,\n+\n+    // FIXME: historically there were some options which were either `-Z` or\n+    //        required the `-Z unstable-options` flag, which were all intended\n+    //        to be unstable. Unfortunately we didn't actually gate usage of\n+    //        these options on the stable compiler, so we still allow them there\n+    //        today. There are some warnings printed out about this in the\n+    //        driver.\n+    UnstableButNotReally,\n+\n+    Unstable,\n+}\n \n #[derive(Clone, PartialEq, Eq)]\n pub struct RustcOptGroup {\n@@ -783,9 +779,17 @@ impl RustcOptGroup {\n         RustcOptGroup { opt_group: g, stability: OptionStability::Stable }\n     }\n \n+    #[allow(dead_code)] // currently we have no \"truly unstable\" options\n     fn unstable(g: getopts::OptGroup) -> RustcOptGroup {\n         RustcOptGroup { opt_group: g, stability: OptionStability::Unstable }\n     }\n+\n+    fn unstable_bnr(g: getopts::OptGroup) -> RustcOptGroup {\n+        RustcOptGroup {\n+            opt_group: g,\n+            stability: OptionStability::UnstableButNotReally,\n+        }\n+    }\n }\n \n // The `opt` local module holds wrappers around the `getopts` API that\n@@ -807,69 +811,102 @@ mod opt {\n \n     fn stable(g: getopts::OptGroup) -> R { RustcOptGroup::stable(g) }\n     fn unstable(g: getopts::OptGroup) -> R { RustcOptGroup::unstable(g) }\n+    fn unstable_bnr(g: getopts::OptGroup) -> R { RustcOptGroup::unstable_bnr(g) }\n \n-    // FIXME (pnkfelix): We default to stable since the current set of\n-    // options is defacto stable.  However, it would be good to revise the\n-    // code so that a stable option is the thing that takes extra effort\n-    // to encode.\n-\n-    pub fn     opt(a: S, b: S, c: S, d: S) -> R { stable(getopts::optopt(a, b, c, d)) }\n-    pub fn   multi(a: S, b: S, c: S, d: S) -> R { stable(getopts::optmulti(a, b, c, d)) }\n-    pub fn    flag(a: S, b: S, c: S)       -> R { stable(getopts::optflag(a, b, c)) }\n-    pub fn flagopt(a: S, b: S, c: S, d: S) -> R { stable(getopts::optflagopt(a, b, c, d)) }\n-    pub fn flagmulti(a: S, b: S, c: S)     -> R { stable(getopts::optflagmulti(a, b, c)) }\n+    pub fn opt_s(a: S, b: S, c: S, d: S) -> R {\n+        stable(getopts::optopt(a, b, c, d))\n+    }\n+    pub fn multi_s(a: S, b: S, c: S, d: S) -> R {\n+        stable(getopts::optmulti(a, b, c, d))\n+    }\n+    pub fn flag_s(a: S, b: S, c: S) -> R {\n+        stable(getopts::optflag(a, b, c))\n+    }\n+    pub fn flagopt_s(a: S, b: S, c: S, d: S) -> R {\n+        stable(getopts::optflagopt(a, b, c, d))\n+    }\n+    pub fn flagmulti_s(a: S, b: S, c: S) -> R {\n+        stable(getopts::optflagmulti(a, b, c))\n+    }\n \n+    pub fn opt(a: S, b: S, c: S, d: S) -> R {\n+        unstable(getopts::optopt(a, b, c, d))\n+    }\n+    pub fn multi(a: S, b: S, c: S, d: S) -> R {\n+        unstable(getopts::optmulti(a, b, c, d))\n+    }\n+    pub fn flag(a: S, b: S, c: S) -> R {\n+        unstable(getopts::optflag(a, b, c))\n+    }\n+    pub fn flagopt(a: S, b: S, c: S, d: S) -> R {\n+        unstable(getopts::optflagopt(a, b, c, d))\n+    }\n+    pub fn flagmulti(a: S, b: S, c: S) -> R {\n+        unstable(getopts::optflagmulti(a, b, c))\n+    }\n \n-    pub fn     opt_u(a: S, b: S, c: S, d: S) -> R { unstable(getopts::optopt(a, b, c, d)) }\n-    pub fn   multi_u(a: S, b: S, c: S, d: S) -> R { unstable(getopts::optmulti(a, b, c, d)) }\n-    pub fn    flag_u(a: S, b: S, c: S)       -> R { unstable(getopts::optflag(a, b, c)) }\n-    pub fn flagopt_u(a: S, b: S, c: S, d: S) -> R { unstable(getopts::optflagopt(a, b, c, d)) }\n-    pub fn flagmulti_u(a: S, b: S, c: S)     -> R { unstable(getopts::optflagmulti(a, b, c)) }\n+    // Do not use these functions for any new options added to the compiler, all\n+    // new options should use the `*_u` variants above to be truly unstable.\n+    pub fn opt_ubnr(a: S, b: S, c: S, d: S) -> R {\n+        unstable_bnr(getopts::optopt(a, b, c, d))\n+    }\n+    pub fn multi_ubnr(a: S, b: S, c: S, d: S) -> R {\n+        unstable_bnr(getopts::optmulti(a, b, c, d))\n+    }\n+    pub fn flag_ubnr(a: S, b: S, c: S) -> R {\n+        unstable_bnr(getopts::optflag(a, b, c))\n+    }\n+    pub fn flagopt_ubnr(a: S, b: S, c: S, d: S) -> R {\n+        unstable_bnr(getopts::optflagopt(a, b, c, d))\n+    }\n+    pub fn flagmulti_ubnr(a: S, b: S, c: S) -> R {\n+        unstable_bnr(getopts::optflagmulti(a, b, c))\n+    }\n }\n \n /// Returns the \"short\" subset of the rustc command line options,\n /// including metadata for each option, such as whether the option is\n /// part of the stable long-term interface for rustc.\n pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n     vec![\n-        opt::flag(\"h\", \"help\", \"Display this message\"),\n-        opt::multi(\"\", \"cfg\", \"Configure the compilation environment\", \"SPEC\"),\n-        opt::multi(\"L\", \"\",   \"Add a directory to the library search path\",\n+        opt::flag_s(\"h\", \"help\", \"Display this message\"),\n+        opt::multi_s(\"\", \"cfg\", \"Configure the compilation environment\", \"SPEC\"),\n+        opt::multi_s(\"L\", \"\",   \"Add a directory to the library search path\",\n                    \"[KIND=]PATH\"),\n-        opt::multi(\"l\", \"\",   \"Link the generated crate(s) to the specified native\n+        opt::multi_s(\"l\", \"\",   \"Link the generated crate(s) to the specified native\n                              library NAME. The optional KIND can be one of,\n                              static, dylib, or framework. If omitted, dylib is\n                              assumed.\", \"[KIND=]NAME\"),\n-        opt::multi(\"\", \"crate-type\", \"Comma separated list of types of crates\n+        opt::multi_s(\"\", \"crate-type\", \"Comma separated list of types of crates\n                                     for the compiler to emit\",\n                    \"[bin|lib|rlib|dylib|staticlib]\"),\n-        opt::opt(\"\", \"crate-name\", \"Specify the name of the crate being built\",\n+        opt::opt_s(\"\", \"crate-name\", \"Specify the name of the crate being built\",\n                \"NAME\"),\n-        opt::multi(\"\", \"emit\", \"Comma separated list of types of output for \\\n+        opt::multi_s(\"\", \"emit\", \"Comma separated list of types of output for \\\n                               the compiler to emit\",\n                  \"[asm|llvm-bc|llvm-ir|obj|link|dep-info]\"),\n-        opt::multi(\"\", \"print\", \"Comma separated list of compiler information to \\\n+        opt::multi_s(\"\", \"print\", \"Comma separated list of compiler information to \\\n                                print on stdout\",\n                  \"[crate-name|file-names|sysroot|target-list]\"),\n-        opt::flagmulti(\"g\",  \"\",  \"Equivalent to -C debuginfo=2\"),\n-        opt::flagmulti(\"O\", \"\", \"Equivalent to -C opt-level=2\"),\n-        opt::opt(\"o\", \"\", \"Write output to <filename>\", \"FILENAME\"),\n-        opt::opt(\"\",  \"out-dir\", \"Write output to compiler-chosen filename \\\n+        opt::flagmulti_s(\"g\",  \"\",  \"Equivalent to -C debuginfo=2\"),\n+        opt::flagmulti_s(\"O\", \"\", \"Equivalent to -C opt-level=2\"),\n+        opt::opt_s(\"o\", \"\", \"Write output to <filename>\", \"FILENAME\"),\n+        opt::opt_s(\"\",  \"out-dir\", \"Write output to compiler-chosen filename \\\n                                 in <dir>\", \"DIR\"),\n-        opt::opt(\"\", \"explain\", \"Provide a detailed explanation of an error \\\n+        opt::opt_s(\"\", \"explain\", \"Provide a detailed explanation of an error \\\n                                message\", \"OPT\"),\n-        opt::flag(\"\", \"test\", \"Build a test harness\"),\n-        opt::opt(\"\", \"target\", \"Target triple for which the code is compiled\", \"TARGET\"),\n-        opt::multi(\"W\", \"warn\", \"Set lint warnings\", \"OPT\"),\n-        opt::multi(\"A\", \"allow\", \"Set lint allowed\", \"OPT\"),\n-        opt::multi(\"D\", \"deny\", \"Set lint denied\", \"OPT\"),\n-        opt::multi(\"F\", \"forbid\", \"Set lint forbidden\", \"OPT\"),\n-        opt::multi(\"\", \"cap-lints\", \"Set the most restrictive lint level. \\\n+        opt::flag_s(\"\", \"test\", \"Build a test harness\"),\n+        opt::opt_s(\"\", \"target\", \"Target triple for which the code is compiled\", \"TARGET\"),\n+        opt::multi_s(\"W\", \"warn\", \"Set lint warnings\", \"OPT\"),\n+        opt::multi_s(\"A\", \"allow\", \"Set lint allowed\", \"OPT\"),\n+        opt::multi_s(\"D\", \"deny\", \"Set lint denied\", \"OPT\"),\n+        opt::multi_s(\"F\", \"forbid\", \"Set lint forbidden\", \"OPT\"),\n+        opt::multi_s(\"\", \"cap-lints\", \"Set the most restrictive lint level. \\\n                                      More restrictive lints are capped at this \\\n                                      level\", \"LEVEL\"),\n-        opt::multi(\"C\", \"codegen\", \"Set a codegen option\", \"OPT[=VALUE]\"),\n-        opt::flag(\"V\", \"version\", \"Print version info and exit\"),\n-        opt::flag(\"v\", \"verbose\", \"Use verbose output\"),\n+        opt::multi_s(\"C\", \"codegen\", \"Set a codegen option\", \"OPT[=VALUE]\"),\n+        opt::flag_s(\"V\", \"version\", \"Print version info and exit\"),\n+        opt::flag_s(\"v\", \"verbose\", \"Use verbose output\"),\n     ]\n }\n \n@@ -879,31 +916,41 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n     let mut opts = rustc_short_optgroups();\n     opts.extend_from_slice(&[\n-        opt::multi(\"\", \"extern\", \"Specify where an external rust library is \\\n+        opt::multi_s(\"\", \"extern\", \"Specify where an external rust library is \\\n                                 located\",\n                  \"NAME=PATH\"),\n-        opt::opt(\"\", \"sysroot\", \"Override the system root\", \"PATH\"),\n-        opt::multi(\"Z\", \"\", \"Set internal debugging options\", \"FLAG\"),\n-        opt::opt_u(\"\", \"error-format\", \"How errors and other messages are produced\", \"human|json\"),\n-        opt::opt(\"\", \"color\", \"Configure coloring of output:\n+        opt::opt_s(\"\", \"sysroot\", \"Override the system root\", \"PATH\"),\n+        opt::multi_ubnr(\"Z\", \"\", \"Set internal debugging options\", \"FLAG\"),\n+        opt::opt_ubnr(\"\", \"error-format\",\n+                      \"How errors and other messages are produced\",\n+                      \"human|json\"),\n+        opt::opt_s(\"\", \"color\", \"Configure coloring of output:\n             auto   = colorize, if output goes to a tty (default);\n             always = always colorize output;\n             never  = never colorize output\", \"auto|always|never\"),\n \n-        opt::flagopt_u(\"\", \"pretty\",\n+        opt::flagopt_ubnr(\"\", \"pretty\",\n                    \"Pretty-print the input instead of compiling;\n                    valid types are: `normal` (un-annotated source),\n                    `expanded` (crates expanded), or\n                    `expanded,identified` (fully parenthesized, AST nodes with IDs).\",\n                  \"TYPE\"),\n-        opt::flagopt_u(\"\", \"unpretty\",\n+        opt::flagopt_ubnr(\"\", \"unpretty\",\n                      \"Present the input source, unstable (and less-pretty) variants;\n                       valid types are any of the types for `--pretty`, as well as:\n                       `flowgraph=<nodeid>` (graphviz formatted flowgraph for node),\n                       `everybody_loops` (all function bodies replaced with `loop {}`),\n                       `hir` (the HIR), `hir,identified`, or\n                       `hir,typed` (HIR with types for each node).\",\n                      \"TYPE\"),\n+\n+        // new options here should **not** use the `_ubnr` functions, all new\n+        // unstable options should use the short variants to indicate that they\n+        // are truly unstable. All `_ubnr` flags are just that way because they\n+        // were so historically.\n+        //\n+        // You may also wish to keep this comment at the bottom of this list to\n+        // ensure that others see it.\n     ]);\n     opts\n }\n@@ -1242,15 +1289,21 @@ impl fmt::Display for CrateType {\n #[cfg(test)]\n mod tests {\n     use middle::cstore::DummyCrateStore;\n-    use session::config::{build_configuration, optgroups, build_session_options};\n+    use session::config::{build_configuration, build_session_options};\n     use session::build_session;\n \n     use std::rc::Rc;\n-    use getopts::getopts;\n+    use getopts::{getopts, OptGroup};\n     use syntax::attr;\n     use syntax::attr::AttrMetaMethods;\n     use syntax::diagnostics;\n \n+    fn optgroups() -> Vec<OptGroup> {\n+        super::rustc_optgroups().into_iter()\n+                                .map(|a| a.opt_group)\n+                                .collect()\n+    }\n+\n     // When the user supplies --test we should implicitly supply --cfg test\n     #[test]\n     fn test_switch_implies_cfg_test() {"}, {"sha": "d0f86cfcb46babaa030404ced5026709f17ead45", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 98, "deletions": 52, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -65,6 +65,7 @@ use rustc_trans::back::link;\n use rustc_trans::save;\n use rustc::session::{config, Session, build_session, CompileResult};\n use rustc::session::config::{Input, PrintRequest, OutputType, ErrorOutputType};\n+use rustc::session::config::{get_unstable_features_setting, OptionStability};\n use rustc::middle::cstore::CrateStore;\n use rustc::lint::Lint;\n use rustc::lint;\n@@ -85,14 +86,15 @@ use std::str;\n use std::sync::{Arc, Mutex};\n use std::thread;\n \n-use rustc::session::early_error;\n+use rustc::session::{early_error, early_warn};\n \n use syntax::ast;\n use syntax::parse;\n use syntax::errors;\n use syntax::errors::emitter::Emitter;\n use syntax::diagnostics;\n use syntax::parse::token;\n+use syntax::feature_gate::UnstableFeatures;\n \n #[cfg(test)]\n pub mod test;\n@@ -819,8 +821,31 @@ fn print_flag_list<T>(cmdline_opt: &str,\n }\n \n /// Process command line options. Emits messages as appropriate. If compilation\n-/// should continue, returns a getopts::Matches object parsed from args, otherwise\n-/// returns None.\n+/// should continue, returns a getopts::Matches object parsed from args,\n+/// otherwise returns None.\n+///\n+/// The compiler's handling of options is a little complication as it ties into\n+/// our stability story, and it's even *more* complicated by historical\n+/// accidents. The current intention of each compiler option is to have one of\n+/// three modes:\n+///\n+/// 1. An option is stable and can be used everywhere.\n+/// 2. An option is unstable, but was historically allowed on the stable\n+///    channel.\n+/// 3. An option is unstable, and can only be used on nightly.\n+///\n+/// Like unstable library and language features, however, unstable options have\n+/// always required a form of \"opt in\" to indicate that you're using them. This\n+/// provides the easy ability to scan a code base to check to see if anything\n+/// unstable is being used. Currently, this \"opt in\" is the `-Z` \"zed\" flag.\n+///\n+/// All options behind `-Z` are considered unstable by default. Other top-level\n+/// options can also be considered unstable, and they were unlocked through the\n+/// `-Z unstable-options` flag. Note that `-Z` remains to be the root of\n+/// instability in both cases, though.\n+///\n+/// So with all that in mind, the comments below have some more detail about the\n+/// contortions done here to get things to work out correctly.\n pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     // Throw away the first argument, the name of the binary\n     let _binary = args.remove(0);\n@@ -832,62 +857,83 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n         return None;\n     }\n \n-    fn allows_unstable_options(matches: &getopts::Matches) -> bool {\n-        let r = matches.opt_strs(\"Z\");\n-        r.iter().any(|x| *x == \"unstable-options\")\n-    }\n+    // Parse with *all* options defined in the compiler, we don't worry about\n+    // option stability here we just want to parse as much as possible.\n+    let all_groups: Vec<getopts::OptGroup> = config::rustc_optgroups()\n+                                                 .into_iter()\n+                                                 .map(|x| x.opt_group)\n+                                                 .collect();\n+    let matches = match getopts::getopts(&args[..], &all_groups) {\n+        Ok(m) => m,\n+        Err(f) => early_error(ErrorOutputType::default(), &f.to_string()),\n+    };\n \n-    fn parse_all_options(args: &Vec<String>) -> getopts::Matches {\n-        let all_groups: Vec<getopts::OptGroup> = config::rustc_optgroups()\n-                                                     .into_iter()\n-                                                     .map(|x| x.opt_group)\n-                                                     .collect();\n-        match getopts::getopts(&args[..], &all_groups) {\n-            Ok(m) => {\n-                if !allows_unstable_options(&m) {\n-                    // If -Z unstable-options was not specified, verify that\n-                    // no unstable options were present.\n-                    for opt in config::rustc_optgroups().into_iter().filter(|x| !x.is_stable()) {\n-                        let opt_name = if !opt.opt_group.long_name.is_empty() {\n-                            &opt.opt_group.long_name\n-                        } else {\n-                            &opt.opt_group.short_name\n-                        };\n-                        if m.opt_present(opt_name) {\n-                            early_error(ErrorOutputType::default(),\n-                                        &format!(\"use of unstable option '{}' requires -Z \\\n-                                                  unstable-options\",\n-                                                 opt_name));\n-                        }\n-                    }\n-                }\n-                m\n-            }\n-            Err(f) => early_error(ErrorOutputType::default(), &f.to_string()),\n+    // For all options we just parsed, we check a few aspects:\n+    //\n+    // * If the option is stable, we're all good\n+    // * If the option wasn't passed, we're all good\n+    // * If `-Z unstable-options` wasn't passed (and we're not a -Z option\n+    //   ourselves), then we require the `-Z unstable-options` flag to unlock\n+    //   this option that was passed.\n+    // * If we're a nightly compiler, then unstable options are now unlocked, so\n+    //   we're good to go.\n+    // * Otherwise, if we're a truly unstable option then we generate an error\n+    //   (unstable option being used on stable)\n+    // * If we're a historically stable-but-should-be-unstable option then we\n+    //   emit a warning that we're going to turn this into an error soon.\n+    let has_z_unstable_options = matches.opt_strs(\"Z\")\n+                                        .iter()\n+                                        .any(|x| *x == \"unstable-options\");\n+    let really_allows_unstable_options = match get_unstable_features_setting() {\n+        UnstableFeatures::Disallow => false,\n+        _ => true,\n+    };\n+    for opt in config::rustc_optgroups() {\n+        if opt.stability == OptionStability::Stable {\n+            continue\n         }\n-    }\n-\n-    // As a speed optimization, first try to parse the command-line using just\n-    // the stable options.\n-    let matches = match getopts::getopts(&args[..], &config::optgroups()) {\n-        Ok(ref m) if allows_unstable_options(m) => {\n-            // If -Z unstable-options was specified, redo parsing with the\n-            // unstable options to ensure that unstable options are defined\n-            // in the returned getopts::Matches.\n-            parse_all_options(&args)\n+        let opt_name = if !opt.opt_group.long_name.is_empty() {\n+            &opt.opt_group.long_name\n+        } else {\n+            &opt.opt_group.short_name\n+        };\n+        if !matches.opt_present(opt_name) {\n+            continue\n         }\n-        Ok(m) => m,\n-        Err(_) => {\n-            // redo option parsing, including unstable options this time,\n-            // in anticipation that the mishandled option was one of the\n-            // unstable ones.\n-            parse_all_options(&args)\n+        if opt_name != \"Z\" && !has_z_unstable_options {\n+            let msg = format!(\"the `-Z unstable-options` flag must also be \\\n+                               passed to enable the flag `{}`\", opt_name);\n+            early_error(ErrorOutputType::default(), &msg);\n         }\n-    };\n+        if really_allows_unstable_options {\n+            continue\n+        }\n+        match opt.stability {\n+            OptionStability::Unstable => {\n+                let msg = format!(\"the option `{}` is only accepted on the \\\n+                                   nightly compiler\", opt_name);\n+                early_error(ErrorOutputType::default(), &msg);\n+            }\n+            OptionStability::UnstableButNotReally => {\n+                let msg = format!(\"the option `{}` is is unstable and should \\\n+                                   only be used on the nightly compiler, but \\\n+                                   it is currently accepted for backwards \\\n+                                   compatibility; this will soon change, \\\n+                                   see issue #31847 for more details\",\n+                                  opt_name);\n+                early_warn(ErrorOutputType::default(), &msg);\n+            }\n+            OptionStability::Stable => {}\n+        }\n+    }\n \n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n+        // Only show unstable options in --help if we *really* accept unstable\n+        // options, which catches the case where we got `-Z unstable-options` on\n+        // the stable channel of Rust which was accidentally allowed\n+        // historically.\n         usage(matches.opt_present(\"verbose\"),\n-              allows_unstable_options(&matches));\n+              has_z_unstable_options && really_allows_unstable_options);\n         return None;\n     }\n "}, {"sha": "1cf0339c086e5137269a141fe784d630e033f1b9", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -158,6 +158,10 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(PRIVATE_IN_PUBLIC),\n             reference: \"the explanation for E0446 (`--explain E0446`)\",\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(INACCESSIBLE_EXTERN_CRATE),\n+            reference: \"PR 31362 <https://github.com/rust-lang/rust/pull/31362>\",\n+        },\n         FutureIncompatibleInfo {\n             id: LintId::of(INVALID_TYPE_PARAM_DEFAULT),\n             reference: \"PR 30742 <https://github.com/rust-lang/rust/pull/30724>\","}, {"sha": "8908dac7a36dd72c9cd355cd6e94e3da09c9a13a", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -743,6 +743,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                      source_did: Option<DefId>,\n                      msg: &str)\n                      -> CheckResult {\n+        use rustc_front::hir::Item_::ItemExternCrate;\n         debug!(\"ensure_public(span={:?}, to_check={:?}, source_did={:?}, msg={:?})\",\n                span, to_check, source_did, msg);\n         let def_privacy = self.def_privacy(to_check);\n@@ -763,6 +764,21 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         // be local.)\n         let def_id = source_did.unwrap_or(to_check);\n         let node_id = self.tcx.map.as_local_node_id(def_id);\n+\n+        // Warn when using a inaccessible extern crate.\n+        if let Some(node_id) = self.tcx.map.as_local_node_id(to_check) {\n+            match self.tcx.map.get(node_id) {\n+                ast_map::Node::NodeItem(&hir::Item { node: ItemExternCrate(_), name, .. }) => {\n+                    self.tcx.sess.add_lint(lint::builtin::INACCESSIBLE_EXTERN_CRATE,\n+                                           node_id,\n+                                           span,\n+                                           format!(\"extern crate `{}` is private\", name));\n+                    return None;\n+                }\n+                _ => {}\n+            }\n+        }\n+\n         let (err_span, err_msg) = if Some(id) == node_id {\n             return Some((span, format!(\"{} is private\", msg), None));\n         } else {"}, {"sha": "385fae46cbae8672a5dc3101736df813a50f88b6", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -293,9 +293,19 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     self.external_exports.insert(def_id);\n                     let parent_link = ModuleParentLink(parent, name);\n                     let def = Def::Mod(def_id);\n-                    let external_module = self.new_extern_crate_module(parent_link, def);\n+                    let local_def_id = self.ast_map.local_def_id(item.id);\n+                    let external_module =\n+                        self.new_extern_crate_module(parent_link, def, is_public, local_def_id);\n                     self.define(parent, name, TypeNS, (external_module, sp));\n \n+                    if is_public {\n+                        let export = Export { name: name, def_id: def_id };\n+                        if let Some(def_id) = parent.def_id() {\n+                            let node_id = self.resolver.ast_map.as_local_node_id(def_id).unwrap();\n+                            self.export_map.entry(node_id).or_insert(Vec::new()).push(export);\n+                        }\n+                    }\n+\n                     self.build_reduced_graph_for_external_crate(external_module);\n                 }\n                 parent"}, {"sha": "3e2837f023ddb1200ea4dd8c72ed0a5dc313b6d3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 37, "deletions": 10, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -806,7 +806,10 @@ pub struct ModuleS<'a> {\n     parent_link: ParentLink<'a>,\n     def: Option<Def>,\n     is_public: bool,\n-    is_extern_crate: bool,\n+\n+    // If the module is an extern crate, `def` is root of the external crate and `extern_crate_did`\n+    // is the DefId of the local `extern crate` item (otherwise, `extern_crate_did` is None).\n+    extern_crate_did: Option<DefId>,\n \n     resolutions: RefCell<HashMap<(Name, Namespace), NameResolution<'a>>>,\n     unresolved_imports: RefCell<Vec<ImportDirective>>,\n@@ -853,7 +856,7 @@ impl<'a> ModuleS<'a> {\n             parent_link: parent_link,\n             def: def,\n             is_public: is_public,\n-            is_extern_crate: false,\n+            extern_crate_did: None,\n             resolutions: RefCell::new(HashMap::new()),\n             unresolved_imports: RefCell::new(Vec::new()),\n             module_children: RefCell::new(NodeMap()),\n@@ -917,6 +920,16 @@ impl<'a> ModuleS<'a> {\n         self.def.as_ref().map(Def::def_id)\n     }\n \n+    // This returns the DefId of the crate local item that controls this module's visibility.\n+    // It is only used to compute `LastPrivate` data, and it differs from `def_id` only for extern\n+    // crates, whose `def_id` is the external crate's root, not the local `extern crate` item.\n+    fn local_def_id(&self) -> Option<DefId> {\n+        match self.extern_crate_did {\n+            Some(def_id) => Some(def_id),\n+            None => self.def_id(),\n+        }\n+    }\n+\n     fn is_normal(&self) -> bool {\n         match self.def {\n             Some(Def::Mod(_)) | Some(Def::ForeignMod(_)) => true,\n@@ -1027,6 +1040,14 @@ impl<'a> NameBinding<'a> {\n         }\n     }\n \n+    fn local_def_id(&self) -> Option<DefId> {\n+        match self.kind {\n+            NameBindingKind::Def(def) => Some(def.def_id()),\n+            NameBindingKind::Module(ref module) => module.local_def_id(),\n+            NameBindingKind::Import { binding, .. } => binding.local_def_id(),\n+        }\n+    }\n+\n     fn defined_with(&self, modifiers: DefModifiers) -> bool {\n         self.modifiers.contains(modifiers)\n     }\n@@ -1038,11 +1059,12 @@ impl<'a> NameBinding<'a> {\n     fn def_and_lp(&self) -> (Def, LastPrivate) {\n         let def = self.def().unwrap();\n         if let Def::Err = def { return (def, LastMod(AllPublic)) }\n-        (def, LastMod(if self.is_public() { AllPublic } else { DependsOn(def.def_id()) }))\n+        let lp = if self.is_public() { AllPublic } else { DependsOn(self.local_def_id().unwrap()) };\n+        (def, LastMod(lp))\n     }\n \n     fn is_extern_crate(&self) -> bool {\n-        self.module().map(|module| module.is_extern_crate).unwrap_or(false)\n+        self.module().and_then(|module| module.extern_crate_did).is_some()\n     }\n \n     fn is_import(&self) -> bool {\n@@ -1236,9 +1258,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         self.arenas.name_bindings.alloc(name_binding)\n     }\n \n-    fn new_extern_crate_module(&self, parent_link: ParentLink<'a>, def: Def) -> Module<'a> {\n-        let mut module = ModuleS::new(parent_link, Some(def), false, true);\n-        module.is_extern_crate = true;\n+    fn new_extern_crate_module(&self,\n+                               parent_link: ParentLink<'a>,\n+                               def: Def,\n+                               is_public: bool,\n+                               local_def: DefId)\n+                               -> Module<'a> {\n+        let mut module = ModuleS::new(parent_link, Some(def), false, is_public);\n+        module.extern_crate_did = Some(local_def);\n         self.arenas.modules.alloc(module)\n     }\n \n@@ -1357,7 +1384,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // Keep track of the closest private module used\n                         // when resolving this import chain.\n                         if !binding.is_public() {\n-                            if let Some(did) = search_module.def_id() {\n+                            if let Some(did) = search_module.local_def_id() {\n                                 closest_private = LastMod(DependsOn(did));\n                             }\n                         }\n@@ -1462,7 +1489,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Success(PrefixFound(ref containing_module, index)) => {\n                 search_module = containing_module;\n                 start_index = index;\n-                last_private = LastMod(DependsOn(containing_module.def_id()\n+                last_private = LastMod(DependsOn(containing_module.local_def_id()\n                                                                   .unwrap()));\n             }\n         }\n@@ -3571,7 +3598,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                     if !in_module_is_extern || name_binding.is_public() {\n                         // add the module to the lookup\n-                        let is_extern = in_module_is_extern || module.is_extern_crate;\n+                        let is_extern = in_module_is_extern || name_binding.is_extern_crate();\n                         worklist.push((module, path_segments, is_extern));\n                     }\n                 }"}, {"sha": "c068ff258b0e7b9c783c253aee887bcce4f1d1b4", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -394,7 +394,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                            directive.is_public &&\n                                            !name_binding.is_public() => {\n                 let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n-                let note_msg = format!(\"Consider marking `{}` as `pub` in the imported module\",\n+                let note_msg = format!(\"consider marking `{}` as `pub` in the imported module\",\n                                         source);\n                 struct_span_err!(self.resolver.session, directive.span, E0364, \"{}\", &msg)\n                     .span_note(directive.span, &note_msg)\n@@ -403,12 +403,22 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n             (_, &Success(name_binding)) if !name_binding.is_import() && directive.is_public => {\n                 if !name_binding.is_public() {\n-                    let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n-                    let note_msg =\n-                        format!(\"Consider declaring type or module `{}` with `pub`\", source);\n-                    struct_span_err!(self.resolver.session, directive.span, E0365, \"{}\", &msg)\n-                        .span_note(directive.span, &note_msg)\n-                        .emit();\n+                    if name_binding.is_extern_crate() {\n+                        let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n+                                           (error E0364), consider declaring with `pub`\",\n+                                           source);\n+                        self.resolver.session.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n+                                                       directive.id,\n+                                                       directive.span,\n+                                                       msg);\n+                    } else {\n+                        let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n+                        let note_msg =\n+                            format!(\"consider declaring type or module `{}` with `pub`\", source);\n+                        struct_span_err!(self.resolver.session, directive.span, E0365, \"{}\", &msg)\n+                            .span_note(directive.span, &note_msg)\n+                            .emit();\n+                    }\n                 } else if name_binding.defined_with(DefModifiers::PRIVATE_VARIANT) {\n                     let msg = format!(\"variant `{}` is private, and cannot be reexported \\\n                                        (error E0364), consider declaring its enum as `pub`\",\n@@ -441,9 +451,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         module_.decrement_outstanding_references_for(target, TypeNS);\n \n         let def_and_priv = |binding: &NameBinding| {\n-            let def = binding.def().unwrap();\n-            let last_private = if binding.is_public() { lp } else { DependsOn(def.def_id()) };\n-            (def, last_private)\n+            let last_private =\n+                if binding.is_public() { lp } else { DependsOn(binding.local_def_id().unwrap()) };\n+            (binding.def().unwrap(), last_private)\n         };\n         let value_def_and_priv = value_result.success().map(&def_and_priv);\n         let type_def_and_priv = type_result.success().map(&def_and_priv);\n@@ -493,7 +503,6 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         build_reduced_graph::populate_module_if_necessary(self.resolver, target_module);\n         target_module.for_each_child(|name, ns, binding| {\n             if !binding.defined_with(DefModifiers::IMPORTABLE | DefModifiers::PUBLIC) { return }\n-            if binding.is_extern_crate() { return }\n             self.define(module_, name, ns, directive.import(binding));\n \n             if ns == TypeNS && directive.is_public &&"}, {"sha": "6f596b15b9214fd29b4832f76314021760aa6b54", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -46,7 +46,7 @@ extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_data_structures;\n extern crate rustc_front;\n-extern crate rustc_llvm as llvm;\n+pub extern crate rustc_llvm as llvm;\n extern crate rustc_mir;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate serialize;"}, {"sha": "115002867555d7e40540b767e0e544f7ca7dd0b4", "filename": "src/librustc_unicode/char.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustc_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustc_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fchar.rs?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -457,26 +457,26 @@ impl char {\n     ///\n     /// # Examples\n     ///\n-    /// In both of these examples, '\u00df' takes one `u16` to encode.\n+    /// In both of these examples, '\ud835\udd4a' takes two `u16`s to encode.\n     ///\n     /// ```\n     /// #![feature(unicode)]\n     ///\n-    /// let mut b = [0; 1];\n+    /// let mut b = [0; 2];\n     ///\n-    /// let result = '\u00df'.encode_utf16(&mut b);\n+    /// let result = '\ud835\udd4a'.encode_utf16(&mut b);\n     ///\n-    /// assert_eq!(result, Some(1));\n+    /// assert_eq!(result, Some(2));\n     /// ```\n     ///\n     /// A buffer that's too small:\n     ///\n     /// ```\n     /// #![feature(unicode)]\n     ///\n-    /// let mut b = [0; 0];\n+    /// let mut b = [0; 1];\n     ///\n-    /// let result = '\u00df'.encode_utf8(&mut b);\n+    /// let result = '\ud835\udd4a'.encode_utf16(&mut b);\n     ///\n     /// assert_eq!(result, None);\n     /// ```"}, {"sha": "1ff88f1d12758ae8c76a32cf7f2e0091e53365bc", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -48,6 +48,7 @@ use std::collections::HashMap;\n use std::path::PathBuf;\n use std::rc::Rc;\n use std::u32;\n+use std::env::current_dir;\n \n use core::DocContext;\n use doctree;\n@@ -201,7 +202,13 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n         }\n \n         let src = match cx.input {\n-            Input::File(ref path) => path.clone(),\n+            Input::File(ref path) => {\n+                if path.is_absolute() {\n+                    path.clone()\n+                } else {\n+                    current_dir().unwrap().join(path)\n+                }\n+            },\n             Input::Str(_) => PathBuf::new() // FIXME: this is wrong\n         };\n "}, {"sha": "d7100f9f2204684c8a6c41d12f9951c98a9212b6", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -46,7 +46,7 @@ use std::io::prelude::*;\n use std::io::{self, BufWriter, BufReader};\n use std::iter::repeat;\n use std::mem;\n-use std::path::{PathBuf, Path};\n+use std::path::{PathBuf, Path, Component};\n use std::str;\n use std::sync::Arc;\n \n@@ -243,6 +243,7 @@ pub struct Cache {\n \n     stack: Vec<String>,\n     parent_stack: Vec<DefId>,\n+    parent_is_trait_impl: bool,\n     search_index: Vec<IndexItem>,\n     privmod: bool,\n     remove_priv: bool,\n@@ -487,6 +488,7 @@ pub fn run(mut krate: clean::Crate,\n         stack: Vec::new(),\n         parent_stack: Vec::new(),\n         search_index: Vec::new(),\n+        parent_is_trait_impl: false,\n         extern_locations: HashMap::new(),\n         primitive_locations: HashMap::new(),\n         remove_priv: cx.passes.contains(\"strip-private\"),\n@@ -810,16 +812,17 @@ fn clean_srcpath<F>(src_root: &Path, p: &Path, keep_filename: bool, mut f: F) wh\n     // make it relative, if possible\n     let p = p.strip_prefix(src_root).unwrap_or(p);\n \n-    let mut iter = p.iter().map(|x| x.to_str().unwrap()).peekable();\n+    let mut iter = p.components().peekable();\n+\n     while let Some(c) = iter.next() {\n         if !keep_filename && iter.peek().is_none() {\n             break;\n         }\n \n-        if \"..\" == c {\n-            f(\"up\");\n-        } else {\n-            f(c)\n+        match c {\n+            Component::ParentDir => f(\"up\"),\n+            Component::Normal(c) => f(c.to_str().unwrap()),\n+            _ => continue,\n         }\n     }\n }\n@@ -871,7 +874,7 @@ impl<'a> DocFolder for SourceCollector<'a> {\n             // entire crate. The other option is maintaining this mapping on a\n             // per-file basis, but that's probably not worth it...\n             self.cx\n-                .include_sources = match self.emit_source(&item.source .filename) {\n+                .include_sources = match self.emit_source(&item.source.filename) {\n                 Ok(()) => true,\n                 Err(e) => {\n                     println!(\"warning: source code was requested to be rendered, \\\n@@ -995,6 +998,11 @@ impl DocFolder for Cache {\n         // Index this method for searching later on\n         if let Some(ref s) = item.name {\n             let (parent, is_method) = match item.inner {\n+                clean::AssociatedConstItem(..) |\n+                clean::TypedefItem(_, true) if self.parent_is_trait_impl => {\n+                    // skip associated items in trait impls\n+                    ((None, None), false)\n+                }\n                 clean::AssociatedTypeItem(..) |\n                 clean::AssociatedConstItem(..) |\n                 clean::TyMethodItem(..) |\n@@ -1026,10 +1034,6 @@ impl DocFolder for Cache {\n                         ((Some(*last), path), true)\n                     }\n                 }\n-                clean::TypedefItem(_, true) => {\n-                    // skip associated types in impls\n-                    ((None, None), false)\n-                }\n                 _ => ((None, Some(&*self.stack)), false)\n             };\n             let hidden_field = match item.inner {\n@@ -1115,12 +1119,15 @@ impl DocFolder for Cache {\n         }\n \n         // Maintain the parent stack\n+        let orig_parent_is_trait_impl = self.parent_is_trait_impl;\n         let parent_pushed = match item.inner {\n             clean::TraitItem(..) | clean::EnumItem(..) | clean::StructItem(..) => {\n                 self.parent_stack.push(item.def_id);\n+                self.parent_is_trait_impl = false;\n                 true\n             }\n             clean::ImplItem(ref i) => {\n+                self.parent_is_trait_impl = i.trait_.is_some();\n                 match i.for_ {\n                     clean::ResolvedPath{ did, .. } => {\n                         self.parent_stack.push(did);\n@@ -1201,6 +1208,7 @@ impl DocFolder for Cache {\n         if pushed { self.stack.pop().unwrap(); }\n         if parent_pushed { self.parent_stack.pop().unwrap(); }\n         self.privmod = orig_privmod;\n+        self.parent_is_trait_impl = orig_parent_is_trait_impl;\n         return ret;\n     }\n }\n@@ -1489,9 +1497,11 @@ impl<'a> Item<'a> {\n                           true, |component| {\n                 path.push(component.to_string());\n             });\n+\n             // If the span points into an external macro the\n             // source-file will be bogus, i.e `<foo macros>`\n-            if Path::new(&self.item.source.filename).is_file() {\n+            let filename = &self.item.source.filename;\n+            if !(filename.starts_with(\"<\") && filename.ends_with(\"macros>\")) {\n                 Some(format!(\"{root}src/{krate}/{path}.html#{href}\",\n                              root = self.cx.root_path,\n                              krate = self.cx.layout.krate,"}, {"sha": "16c369674f0a2e2bf90f8f80952135480fff1328", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -21,7 +21,7 @@ use sys_common::net::{getsockopt, setsockopt};\n use time::Duration;\n \n pub use sys::{cvt, cvt_r};\n-pub use libc as netc;\n+pub extern crate libc as netc;\n \n pub type wrlen_t = size_t;\n "}, {"sha": "b5d29a0d6dbaf11f3e335bd5f7d1f2e3f8baf574", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -5487,13 +5487,6 @@ impl<'a> Parser<'a> {\n         try!(self.expect(&token::Semi));\n \n         let last_span = self.last_span;\n-\n-        if visibility == ast::Visibility::Public {\n-            self.span_warn(mk_sp(lo, last_span.hi),\n-                           \"`pub extern crate` does not work as expected and should not be used. \\\n-                            Likely to become an error. Prefer `extern crate` and `pub use`.\");\n-        }\n-\n         Ok(self.mk_item(lo,\n                         last_span.hi,\n                         ident,"}, {"sha": "fd97f210a551419d954808670eafc1509ed0a91e", "filename": "src/test/auxiliary/privacy_reexport.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/src%2Ftest%2Fauxiliary%2Fprivacy_reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/src%2Ftest%2Fauxiliary%2Fprivacy_reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fprivacy_reexport.rs?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+pub extern crate core;\n pub use foo as bar;\n \n pub mod foo {"}, {"sha": "d39553a7267e0fc16e1af759adeb26500d7de496", "filename": "src/test/compile-fail/duplicate_entry_error.rs", "status": "renamed", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/src%2Ftest%2Fcompile-fail%2Fduplicate_entry_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/src%2Ftest%2Fcompile-fail%2Fduplicate_entry_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fduplicate_entry_error.rs?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -8,9 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n+// Test for issue #31788\n \n-pub extern crate core; //~WARN `pub extern crate` does not work\n+// error-pattern: duplicate entry for `panic_fmt`, first definition found in `std`\n \n-#[rustc_error]\n-fn main() {} //~ ERROR: compilation successful\n+#![feature(lang_items)]\n+\n+#[lang = \"panic_fmt\"]\n+fn panic_fmt() -> ! {\n+    loop {}\n+}\n+\n+fn main() {}\n\\ No newline at end of file", "previous_filename": "src/test/compile-fail/warn-pub-extern-crate.rs"}, {"sha": "56a41a15ab3c0b63317895c62c3295fd3c884779", "filename": "src/test/compile-fail/extern-crate-visibility.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/src%2Ftest%2Fcompile-fail%2Fextern-crate-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/src%2Ftest%2Fcompile-fail%2Fextern-crate-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextern-crate-visibility.rs?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+#![allow(unused_imports)]\n+\n+mod foo {\n+    extern crate core;\n+}\n+\n+// Check that private crates can be used from outside their modules, albeit with warnings\n+use foo::core; //~ WARN extern crate `core` is private\n+//~^ WARN this was previously accepted by the compiler but is being phased out\n+use foo::core::cell; //~ WARN extern crate `core` is private\n+//~^ WARN this was previously accepted by the compiler but is being phased out\n+\n+fn f() {\n+    foo::core::cell::Cell::new(0); //~ WARN extern crate `core` is private\n+    //~^ WARN this was previously accepted by the compiler but is being phased out\n+\n+    use foo::*;\n+    mod core {} // Check that private crates are not glob imported\n+}\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful"}, {"sha": "5811d82681e6b80ee0ccb10a2d436931efb39634", "filename": "src/test/compile-fail/private-variant-and-crate-reexport.rs", "status": "renamed", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/src%2Ftest%2Fcompile-fail%2Fprivate-variant-and-crate-reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/src%2Ftest%2Fcompile-fail%2Fprivate-variant-and-crate-reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-variant-and-crate-reexport.rs?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -11,6 +11,10 @@\n #![feature(rustc_attrs)]\n #![allow(dead_code)]\n \n+extern crate core;\n+pub use core as reexported_core; //~ WARN extern crate `core` is private, and cannot be reexported\n+//~^ WARNING hard error\n+\n mod m1 {\n     pub use ::E::V; //~ WARN variant `V` is private, and cannot be reexported\n     //~^ WARNING hard error", "previous_filename": "src/test/compile-fail/private-variant-reexport.rs"}, {"sha": "15c977afe2a6c71d107a581d49a01dfd6bf19de1", "filename": "src/test/run-pass/privacy-reexport.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/src%2Ftest%2Frun-pass%2Fprivacy-reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/src%2Ftest%2Frun-pass%2Fprivacy-reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprivacy-reexport.rs?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -15,5 +15,8 @@\n extern crate privacy_reexport;\n \n pub fn main() {\n+    // Check that public extern crates are visible to outside crates\n+    privacy_reexport::core::cell::Cell::new(0);\n+\n     privacy_reexport::bar::frob();\n }"}, {"sha": "bfb440a18392e9b310e9aa12886fba6a2cfa816b", "filename": "src/test/rustdoc/issue-26995.rs", "status": "renamed", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/src%2Ftest%2Frustdoc%2Fissue-26995.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/src%2Ftest%2Frustdoc%2Fissue-26995.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-26995.rs?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,15 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Check that extern crate declarations are excluded from glob imports.\n+// ignore-windows\n+// compile-flags: --no-defaults\n \n-#![feature(core)]\n-extern crate core;\n-\n-mod T {\n-    pub use super::*;\n-}\n-\n-fn main() {\n-    use T::core; //~ ERROR unresolved import `T::core`\n-}\n+// @has src/issue_26995/dev/null.html\n+// @has issue_26995/null/index.html '//a/@href' '../../src/issue_26995/dev/null.html'\n+#[path=\"/dev/null\"]\n+pub mod null;", "previous_filename": "src/test/compile-fail/no-extern-crate-in-glob-import.rs"}, {"sha": "46be8229d7c651ba2982fb01a88dc8d1b381a84b", "filename": "src/test/rustdoc/issue-31808.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c9852e2e550306a738653a5d4d16cab43454776f/src%2Ftest%2Frustdoc%2Fissue-31808.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9852e2e550306a738653a5d4d16cab43454776f/src%2Ftest%2Frustdoc%2Fissue-31808.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-31808.rs?ref=c9852e2e550306a738653a5d4d16cab43454776f", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts, associated_types)]\n+\n+// Test that associated item impls on primitive types don't crash rustdoc\n+\n+pub trait Foo {\n+    const BAR: usize;\n+    type BAZ;\n+}\n+\n+impl Foo for () {\n+    const BAR: usize = 0;\n+    type BAZ = usize;\n+}"}]}