{"sha": "28691a0852854a9996d07ab92bb55e92beef2c98", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4NjkxYTA4NTI4NTRhOTk5NmQwN2FiOTJiYjU1ZTkyYmVlZjJjOTg=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-25T04:51:56Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-26T10:14:01Z"}, "message": "libsyntax: more minor cleanup", "tree": {"sha": "f2557892421370abd122c1f881c0847c749a0862", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2557892421370abd122c1f881c0847c749a0862"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28691a0852854a9996d07ab92bb55e92beef2c98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28691a0852854a9996d07ab92bb55e92beef2c98", "html_url": "https://github.com/rust-lang/rust/commit/28691a0852854a9996d07ab92bb55e92beef2c98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28691a0852854a9996d07ab92bb55e92beef2c98/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff36986fa490917bcacfb4e5010e304d5e82f3bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff36986fa490917bcacfb4e5010e304d5e82f3bb", "html_url": "https://github.com/rust-lang/rust/commit/ff36986fa490917bcacfb4e5010e304d5e82f3bb"}], "stats": {"total": 64, "additions": 32, "deletions": 32}, "files": [{"sha": "56e350db47ba125e29e1a1f71060e8c6e373b195", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28691a0852854a9996d07ab92bb55e92beef2c98/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28691a0852854a9996d07ab92bb55e92beef2c98/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=28691a0852854a9996d07ab92bb55e92beef2c98", "patch": "@@ -161,8 +161,8 @@ impl parser_attr for Parser {\n \n     fn parse_optional_meta() -> ~[@ast::meta_item] {\n         match *self.token {\n-          token::LPAREN => return self.parse_meta_seq(),\n-          _ => return ~[]\n+            token::LPAREN => self.parse_meta_seq(),\n+            _ => ~[]\n         }\n     }\n }"}, {"sha": "4632ceb6e7d40404b8de00f27a0121e9727e350a", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28691a0852854a9996d07ab92bb55e92beef2c98/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28691a0852854a9996d07ab92bb55e92beef2c98/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=28691a0852854a9996d07ab92bb55e92beef2c98", "patch": "@@ -139,8 +139,8 @@ pub impl Parser {\n \n     fn token_is_word(word: &~str, tok: &token::Token) -> bool {\n         match *tok {\n-          token::IDENT(sid, false) => { *self.id_to_str(sid) == *word }\n-          _ => { false }\n+            token::IDENT(sid, false) => { *self.id_to_str(sid) == *word }\n+             _ => { false }\n         }\n     }\n \n@@ -165,8 +165,8 @@ pub impl Parser {\n     fn eat_keyword(word: &~str) -> bool {\n         self.require_keyword(word);\n         let is_kw = match *self.token {\n-          token::IDENT(sid, false) => *word == *self.id_to_str(sid),\n-          _ => false\n+            token::IDENT(sid, false) => *word == *self.id_to_str(sid),\n+            _ => false\n         };\n         if is_kw { self.bump() }\n         is_kw"}, {"sha": "9b825512c39d9a2e755d810463b6a3b65f2c19b9", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/28691a0852854a9996d07ab92bb55e92beef2c98/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28691a0852854a9996d07ab92bb55e92beef2c98/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=28691a0852854a9996d07ab92bb55e92beef2c98", "patch": "@@ -633,7 +633,7 @@ pub impl Parser {\n                 seq_sep_trailing_allowed(token::COMMA),\n                 |p| p.parse_ty_field()\n             );\n-            if vec::len(elems) == 0u {\n+            if elems.len() == 0 {\n                 self.unexpected_last(token::RBRACE);\n             }\n             ty_rec(elems)\n@@ -858,17 +858,17 @@ pub impl Parser {\n         }\n     }\n \n-    fn lit_from_token(tok: token::Token) -> lit_ {\n-        match tok {\n-          token::LIT_INT(i, it) => lit_int(i, it),\n-          token::LIT_UINT(u, ut) => lit_uint(u, ut),\n-          token::LIT_INT_UNSUFFIXED(i) => lit_int_unsuffixed(i),\n-          token::LIT_FLOAT(s, ft) => lit_float(self.id_to_str(s), ft),\n-          token::LIT_FLOAT_UNSUFFIXED(s) =>\n-            lit_float_unsuffixed(self.id_to_str(s)),\n-          token::LIT_STR(s) => lit_str(self.id_to_str(s)),\n-          token::LPAREN => { self.expect(&token::RPAREN); lit_nil },\n-          _ => { self.unexpected_last(tok); }\n+    fn lit_from_token(tok: &token::Token) -> lit_ {\n+        match *tok {\n+            token::LIT_INT(i, it) => lit_int(i, it),\n+            token::LIT_UINT(u, ut) => lit_uint(u, ut),\n+            token::LIT_INT_UNSUFFIXED(i) => lit_int_unsuffixed(i),\n+            token::LIT_FLOAT(s, ft) => lit_float(self.id_to_str(s), ft),\n+            token::LIT_FLOAT_UNSUFFIXED(s) =>\n+                lit_float_unsuffixed(self.id_to_str(s)),\n+            token::LIT_STR(s) => lit_str(self.id_to_str(s)),\n+            token::LPAREN => { self.expect(&token::RPAREN); lit_nil },\n+            _ => { self.unexpected_last(*tok); }\n         }\n     }\n \n@@ -882,7 +882,7 @@ pub impl Parser {\n             // XXX: This is a really bad copy!\n             let tok = copy *self.token;\n             self.bump();\n-            self.lit_from_token(tok)\n+            self.lit_from_token(&tok)\n         };\n         codemap::spanned { node: lit, span: mk_sp(lo, self.last_span.hi) }\n     }\n@@ -1240,8 +1240,8 @@ pub impl Parser {\n             if *self.token == token::NOT {\n                 self.bump();\n                 match *self.token {\n-                  token::LPAREN | token::LBRACE => {}\n-                  _ => self.fatal(~\"expected open delimiter\")\n+                    token::LPAREN | token::LBRACE => {}\n+                    _ => self.fatal(~\"expected open delimiter\")\n                 };\n \n                 let ket = token::flip_delimiter(&*self.token);\n@@ -2554,7 +2554,8 @@ pub impl Parser {\n         self.expect(&token::LBRACE);\n         let (inner, next) =\n             maybe_parse_inner_attrs_and_next(self, parse_attrs);\n-        return (inner, self.parse_block_tail_(lo, default_blk, next));\n+\n+        (inner, self.parse_block_tail_(lo, default_blk, next))\n     }\n \n     fn parse_block_no_value() -> blk {\n@@ -2624,10 +2625,7 @@ pub impl Parser {\n                                             fmt!(\n                                                 \"expected `;` or `}` after \\\n                                                 expression but found `%s`\",\n-                                                token_to_str(\n-                                                    self.reader,\n-                                                    &t\n-                                                )\n+                                                token_to_str(self.reader, &t)\n                                             )\n                                         );\n                                     }\n@@ -2823,12 +2821,14 @@ pub impl Parser {\n         self.bump();\n     }\n \n-    fn parse_fn_decl_with_self(parse_arg_fn:\n-                               fn(Parser) -> arg_or_capture_item)\n-                            -> (self_ty, fn_decl) {\n-\n-        fn maybe_parse_self_ty(cnstr: fn(+v: mutability) -> ast::self_ty_,\n-                               p: Parser) -> ast::self_ty_ {\n+    fn parse_fn_decl_with_self(\n+        parse_arg_fn:\n+        fn(Parser) -> arg_or_capture_item\n+    ) -> (self_ty, fn_decl) {\n+        fn maybe_parse_self_ty(\n+            cnstr: fn(+v: mutability) -> ast::self_ty_,\n+            p: Parser\n+        ) -> ast::self_ty_ {\n             // We need to make sure it isn't a mode or a type\n             if p.token_is_keyword(&~\"self\", &p.look_ahead(1)) ||\n                 ((p.token_is_keyword(&~\"const\", &p.look_ahead(1)) ||"}]}