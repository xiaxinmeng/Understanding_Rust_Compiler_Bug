{"sha": "896570a3a9fe5c5e4a457f7cfea5917eb547d5ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5NjU3MGEzYTlmZTVjNWU0YTQ1N2Y3Y2ZlYTU5MTdlYjU0N2Q1Y2U=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-11-04T02:05:46Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-11-04T02:15:16Z"}, "message": "rustboot: When resolving recursively, build up error messages recursively as well", "tree": {"sha": "c00a5b73b9527ae450897c462f701124c16544ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c00a5b73b9527ae450897c462f701124c16544ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/896570a3a9fe5c5e4a457f7cfea5917eb547d5ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/896570a3a9fe5c5e4a457f7cfea5917eb547d5ce", "html_url": "https://github.com/rust-lang/rust/commit/896570a3a9fe5c5e4a457f7cfea5917eb547d5ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/896570a3a9fe5c5e4a457f7cfea5917eb547d5ce/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db955d33b7a54df6ba90bef713110bc2f85b2830", "url": "https://api.github.com/repos/rust-lang/rust/commits/db955d33b7a54df6ba90bef713110bc2f85b2830", "html_url": "https://github.com/rust-lang/rust/commit/db955d33b7a54df6ba90bef713110bc2f85b2830"}], "stats": {"total": 60, "additions": 35, "deletions": 25}, "files": [{"sha": "86246cfbf913263034faf7ff1782ce5a2f18e8aa", "filename": "src/boot/me/resolve.ml", "status": "modified", "additions": 35, "deletions": 25, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/896570a3a9fe5c5e4a457f7cfea5917eb547d5ce/src%2Fboot%2Fme%2Fresolve.ml", "raw_url": "https://github.com/rust-lang/rust/raw/896570a3a9fe5c5e4a457f7cfea5917eb547d5ce/src%2Fboot%2Fme%2Fresolve.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fresolve.ml?ref=896570a3a9fe5c5e4a457f7cfea5917eb547d5ce", "patch": "@@ -14,6 +14,7 @@ open Common;;\n  *\n  *)\n \n+exception Resolution_failure of (Ast.name * Ast.name) list\n \n let log cx = Session.log \"resolve\"\n   (should_log cx cx.ctxt_sess.Session.sess_log_resolve)\n@@ -228,14 +229,6 @@ let all_item_collecting_visitor\n         Walk.visit_stmt_pre = visit_stmt_pre; }\n ;;\n \n-let report_error (full_name:Ast.name) (unbound_name:Ast.name) =\n-  if full_name = unbound_name then\n-    err None \"unbound name '%a'\" Ast.sprintf_name full_name\n-  else\n-    err None \"unbound name '%a' in name '%a'\" Ast.sprintf_name unbound_name\n-      Ast.sprintf_name full_name\n-;;\n-\n let lookup_type_node_by_name\n     (cx:ctxt)\n     (scopes:scope list)\n@@ -245,7 +238,7 @@ let lookup_type_node_by_name\n               log cx \"lookup_simple_type_by_name %a\"\n                 Ast.sprintf_name name);\n   match lookup_by_name cx [] scopes name with\n-      RES_failed name' -> report_error name name'\n+      RES_failed name' -> raise (Resolution_failure [ name', name ])\n     | RES_ok (_, id) ->\n         match htab_search cx.ctxt_all_defns id with\n             Some (DEFN_item { Ast.decl_item = Ast.MOD_ITEM_type _;\n@@ -270,6 +263,24 @@ let push_node r n =\n   { recur_all_nodes = n :: r.recur_all_nodes }\n \n \n+let report_resolution_failure type_names =\n+  let rec recur type_names str =\n+    let stringify_pair (part, whole) =\n+      if part = whole then\n+        Printf.sprintf \"'%a'\" Ast.sprintf_name part\n+      else\n+        Printf.sprintf \"'%a' in name '%a'\" Ast.sprintf_name part\n+          Ast.sprintf_name whole\n+    in\n+    match type_names with\n+        [] -> bug () \"no name in resolution failure\"\n+      | [ pair ] -> err None \"unbound name %s%s\" (stringify_pair pair) str\n+      | pair::pairs ->\n+          recur pairs\n+            (Printf.sprintf \" while resolving %s\" (stringify_pair pair))\n+  in \n+  recur type_names \"\" \n+\n let rec lookup_type_by_name\n     ?loc:loc\n     (cx:ctxt)\n@@ -281,7 +292,7 @@ let rec lookup_type_by_name\n               log cx \"+++ lookup_type_by_name %a\"\n                 Ast.sprintf_name name);\n   match lookup_by_name cx [] scopes name with\n-      RES_failed name' -> report_error name name'\n+      RES_failed name' -> raise (Resolution_failure [ name', name ])\n     | RES_ok (scopes', id) ->\n         let ty, params =\n           match htab_search cx.ctxt_all_defns id with\n@@ -358,15 +369,19 @@ and resolve_type\n     in\n       iflog cx (fun _ ->\n                   log cx \"resolved type name '%a' to item %d with ty %a\"\n-                  Ast.sprintf_name name (int_of_node node) Ast.sprintf_ty t);\n+                  Ast.sprintf_name name (int_of_node node)\n+                  Ast.sprintf_ty t);\n       if List.mem node recur.recur_all_nodes\n       then (err (Some node) \"infinite recursive type definition: '%a'\"\n               Ast.sprintf_name name)\n       else\n         let recur = push_node recur node in\n           iflog cx (fun _ -> log cx \"recursively resolving type %a\"\n                       Ast.sprintf_ty t);\n-          resolve_type ?loc:loc cx scopes recur t\n+          try\n+            resolve_type ?loc:loc cx scopes recur t\n+          with Resolution_failure names ->\n+            raise (Resolution_failure ((name, name)::names))\n   in\n   let fold =\n     { base with\n@@ -388,9 +403,11 @@ let type_resolving_visitor\n \n   let tinfos = Hashtbl.create 0 in\n \n-  let resolve_ty (t:Ast.ty) : Ast.ty =\n-    resolve_type ~loc:(id_of_scope (List.hd (!scopes)))\n-      cx (!scopes) empty_recur_info t\n+  let resolve_ty ?(loc=id_of_scope (List.hd (!scopes))) (t:Ast.ty) : Ast.ty =\n+    try\n+      resolve_type ~loc:loc cx (!scopes) empty_recur_info t\n+    with Resolution_failure pairs ->\n+      report_resolution_failure pairs\n   in\n \n   let resolve_slot (s:Ast.slot) : Ast.slot =\n@@ -422,19 +439,15 @@ let type_resolving_visitor\n   let visit_mod_item_pre id params item =\n     let resolve_and_store_type _ =\n       let t = ty_of_mod_item item in\n-      let ty =\n-        resolve_type ~loc:item.id cx (!scopes) empty_recur_info t\n-      in\n+      let ty = resolve_ty ~loc:item.id t in\n         log cx \"resolved item %s, type as %a\" id Ast.sprintf_ty ty;\n         htab_put cx.ctxt_all_item_types item.id ty;\n     in\n     begin\n       try\n         match item.node.Ast.decl_item with\n             Ast.MOD_ITEM_type (_, ty) ->\n-              let ty =\n-                resolve_type ~loc:item.id cx (!scopes) empty_recur_info ty\n-              in\n+              let ty = resolve_ty ~loc:item.id ty in\n                 log cx \"resolved item %s, defining type %a\"\n                   id Ast.sprintf_ty ty;\n                 htab_put cx.ctxt_all_type_items item.id ty;\n@@ -478,10 +491,7 @@ let type_resolving_visitor\n   in\n \n   let visit_obj_fn_pre obj ident fn =\n-    let fty =\n-      resolve_type ~loc:fn.id cx (!scopes)\n-        empty_recur_info (Ast.TY_fn (ty_fn_of_fn fn.node))\n-    in\n+    let fty = resolve_ty ~loc:fn.id (Ast.TY_fn (ty_fn_of_fn fn.node)) in\n       log cx \"resolved obj fn %s as %a\" ident Ast.sprintf_ty fty;\n       htab_put cx.ctxt_all_item_types fn.id fty;\n       inner.Walk.visit_obj_fn_pre obj ident fn"}]}