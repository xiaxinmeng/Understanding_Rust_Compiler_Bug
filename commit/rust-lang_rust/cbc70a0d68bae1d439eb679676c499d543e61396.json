{"sha": "cbc70a0d68bae1d439eb679676c499d543e61396", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiYzcwYTBkNjhiYWUxZDQzOWViNjc5Njc2YzQ5OWQ1NDNlNjEzOTY=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2018-05-30T05:31:00Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2018-06-05T15:48:55Z"}, "message": "Improve diagnostics for incorrect `..` usage\n\nWhen using `..` somewhere other than the end, parse the rest of the\npattern correctly while still emitting an error.\n\nAdd suggestions to either remove trailing `,` or moving the `..` to the\nend.", "tree": {"sha": "a9efe540a57f11894d8127b4686abb377a4b3178", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9efe540a57f11894d8127b4686abb377a4b3178"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbc70a0d68bae1d439eb679676c499d543e61396", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbc70a0d68bae1d439eb679676c499d543e61396", "html_url": "https://github.com/rust-lang/rust/commit/cbc70a0d68bae1d439eb679676c499d543e61396", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbc70a0d68bae1d439eb679676c499d543e61396/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f4a5429c2cf7ce1f0a63f821484744024b364f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f4a5429c2cf7ce1f0a63f821484744024b364f1", "html_url": "https://github.com/rust-lang/rust/commit/8f4a5429c2cf7ce1f0a63f821484744024b364f1"}], "stats": {"total": 252, "additions": 170, "deletions": 82}, "files": [{"sha": "fb2aa0e9d5afc84c460757d312252d8a01c3c13f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 135, "deletions": 79, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/cbc70a0d68bae1d439eb679676c499d543e61396/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc70a0d68bae1d439eb679676c499d543e61396/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=cbc70a0d68bae1d439eb679676c499d543e61396", "patch": "@@ -3710,26 +3710,89 @@ impl<'a> Parser<'a> {\n         Ok((before, slice, after))\n     }\n \n+    fn parse_pat_field(\n+        &mut self,\n+        lo: Span,\n+        attrs: Vec<Attribute>\n+    ) -> PResult<'a, codemap::Spanned<ast::FieldPat>> {\n+        // Check if a colon exists one ahead. This means we're parsing a fieldname.\n+        let hi;\n+        let (subpat, fieldname, is_shorthand) = if self.look_ahead(1, |t| t == &token::Colon) {\n+            // Parsing a pattern of the form \"fieldname: pat\"\n+            let fieldname = self.parse_field_name()?;\n+            self.bump();\n+            let pat = self.parse_pat()?;\n+            hi = pat.span;\n+            (pat, fieldname, false)\n+        } else {\n+            // Parsing a pattern of the form \"(box) (ref) (mut) fieldname\"\n+            let is_box = self.eat_keyword(keywords::Box);\n+            let boxed_span = self.span;\n+            let is_ref = self.eat_keyword(keywords::Ref);\n+            let is_mut = self.eat_keyword(keywords::Mut);\n+            let fieldname = self.parse_ident()?;\n+            hi = self.prev_span;\n+\n+            let bind_type = match (is_ref, is_mut) {\n+                (true, true) => BindingMode::ByRef(Mutability::Mutable),\n+                (true, false) => BindingMode::ByRef(Mutability::Immutable),\n+                (false, true) => BindingMode::ByValue(Mutability::Mutable),\n+                (false, false) => BindingMode::ByValue(Mutability::Immutable),\n+            };\n+            let fieldpat = P(Pat {\n+                id: ast::DUMMY_NODE_ID,\n+                node: PatKind::Ident(bind_type, fieldname, None),\n+                span: boxed_span.to(hi),\n+            });\n+\n+            let subpat = if is_box {\n+                P(Pat {\n+                    id: ast::DUMMY_NODE_ID,\n+                    node: PatKind::Box(fieldpat),\n+                    span: lo.to(hi),\n+                })\n+            } else {\n+                fieldpat\n+            };\n+            (subpat, fieldname, true)\n+        };\n+\n+        Ok(codemap::Spanned {\n+            span: lo.to(hi),\n+            node: ast::FieldPat {\n+                ident: fieldname,\n+                pat: subpat,\n+                is_shorthand,\n+                attrs: attrs.into(),\n+           }\n+        })\n+    }\n+\n     /// Parse the fields of a struct-like pattern\n     fn parse_pat_fields(&mut self) -> PResult<'a, (Vec<codemap::Spanned<ast::FieldPat>>, bool)> {\n         let mut fields = Vec::new();\n         let mut etc = false;\n-        let mut first = true;\n-        while self.token != token::CloseDelim(token::Brace) {\n-            if first {\n-                first = false;\n-            } else {\n-                self.expect(&token::Comma)?;\n-                // accept trailing commas\n-                if self.check(&token::CloseDelim(token::Brace)) { break }\n-            }\n+        let mut ate_comma = true;\n+        let mut delayed_err: Option<DiagnosticBuilder<'a>> = None;\n+        let mut etc_span = None;\n \n+        while self.token != token::CloseDelim(token::Brace) {\n             let attrs = self.parse_outer_attributes()?;\n             let lo = self.span;\n-            let hi;\n+\n+            // check that a comma comes after every field\n+            if !ate_comma {\n+                let err = self.struct_span_err(self.prev_span, \"expected `,`\");\n+                return Err(err);\n+            }\n+            ate_comma = false;\n \n             if self.check(&token::DotDot) || self.token == token::DotDotDot {\n+                etc = true;\n+                let mut etc_sp = self.span;\n+\n                 if self.token == token::DotDotDot { // Issue #46718\n+                    // Accept `...` as if it were `..` to avoid further errors\n                     let mut err = self.struct_span_err(self.span,\n                                                        \"expected field pattern, found `...`\");\n                     err.span_suggestion_with_applicability(\n@@ -3740,83 +3803,76 @@ impl<'a> Parser<'a> {\n                     );\n                     err.emit();\n                 }\n+                self.bump();  // `..` || `...`:w\n \n-                self.bump();\n-                if self.token != token::CloseDelim(token::Brace) {\n-                    let token_str = self.this_token_to_string();\n-                    let mut err = self.fatal(&format!(\"expected `{}`, found `{}`\", \"}\", token_str));\n-                    if self.token == token::Comma { // Issue #49257\n-                        err.span_label(self.span,\n-                                       \"`..` must be in the last position, \\\n-                                        and cannot have a trailing comma\");\n-                        if self.look_ahead(1, |t| {\n-                            t == &token::CloseDelim(token::Brace) || t.is_ident()\n-                        }) {\n-                            // If the struct looks otherwise well formed, recover and continue.\n-                            // This way we avoid \"pattern missing fields\" errors afterwards.\n-                            err.emit();\n-                            self.bump();\n-                            etc = true;\n-                            break;\n-                        }\n+                if self.token == token::CloseDelim(token::Brace) {\n+                    etc_span = Some(etc_sp);\n+                    break;\n+                }\n+                let token_str = self.this_token_to_string();\n+                let mut err = self.fatal(&format!(\"expected `}}`, found `{}`\", token_str));\n+\n+                err.span_label(self.span, \"expected `}`\");\n+                let mut comma_sp = None;\n+                if self.token == token::Comma { // Issue #49257\n+                    etc_sp = etc_sp.to(self.sess.codemap().span_until_non_whitespace(self.span));\n+                    err.span_label(etc_sp,\n+                                   \"`..` must be at the end and cannot have a trailing comma\");\n+                    comma_sp = Some(self.span);\n+                    self.bump();\n+                    ate_comma = true;\n+                }\n+\n+                etc_span = Some(etc_sp);\n+                if self.token == token::CloseDelim(token::Brace) {\n+                    // If the struct looks otherwise well formed, recover and continue.\n+                    if let Some(sp) = comma_sp {\n+                        err.span_suggestion_short(sp, \"remove this comma\", \"\".into());\n+                    }\n+                    err.emit();\n+                    break;\n+                } else if self.token.is_ident() && ate_comma {\n+                    // Accept fields coming after `..,`.\n+                    // This way we avoid \"pattern missing fields\" errors afterwards.\n+                    // We delay this error until the end in order to have a span for a\n+                    // suggested fix.\n+                    if let Some(mut delayed_err) = delayed_err {\n+                        delayed_err.emit();\n+                        return Err(err);\n                     } else {\n-                        err.span_label(self.span, \"expected `}`\");\n+                        delayed_err = Some(err);\n+                    }\n+                } else {\n+                    if let Some(mut err) = delayed_err {\n+                        err.emit();\n                     }\n                     return Err(err);\n                 }\n-                etc = true;\n-                break;\n             }\n \n-            // Check if a colon exists one ahead. This means we're parsing a fieldname.\n-            let (subpat, fieldname, is_shorthand) = if self.look_ahead(1, |t| t == &token::Colon) {\n-                // Parsing a pattern of the form \"fieldname: pat\"\n-                let fieldname = self.parse_field_name()?;\n-                self.bump();\n-                let pat = self.parse_pat()?;\n-                hi = pat.span;\n-                (pat, fieldname, false)\n-            } else {\n-                // Parsing a pattern of the form \"(box) (ref) (mut) fieldname\"\n-                let is_box = self.eat_keyword(keywords::Box);\n-                let boxed_span = self.span;\n-                let is_ref = self.eat_keyword(keywords::Ref);\n-                let is_mut = self.eat_keyword(keywords::Mut);\n-                let fieldname = self.parse_ident()?;\n-                hi = self.prev_span;\n-\n-                let bind_type = match (is_ref, is_mut) {\n-                    (true, true) => BindingMode::ByRef(Mutability::Mutable),\n-                    (true, false) => BindingMode::ByRef(Mutability::Immutable),\n-                    (false, true) => BindingMode::ByValue(Mutability::Mutable),\n-                    (false, false) => BindingMode::ByValue(Mutability::Immutable),\n-                };\n-                let fieldpat = P(Pat {\n-                    id: ast::DUMMY_NODE_ID,\n-                    node: PatKind::Ident(bind_type, fieldname, None),\n-                    span: boxed_span.to(hi),\n-                });\n-\n-                let subpat = if is_box {\n-                    P(Pat {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: PatKind::Box(fieldpat),\n-                        span: lo.to(hi),\n-                    })\n-                } else {\n-                    fieldpat\n-                };\n-                (subpat, fieldname, true)\n-            };\n-\n-            fields.push(codemap::Spanned { span: lo.to(hi),\n-                                           node: ast::FieldPat {\n-                                               ident: fieldname,\n-                                               pat: subpat,\n-                                               is_shorthand,\n-                                               attrs: attrs.into(),\n-                                           }\n+            fields.push(match self.parse_pat_field(lo, attrs) {\n+                Ok(field) => field,\n+                Err(err) => {\n+                    if let Some(mut delayed_err) = delayed_err {\n+                        delayed_err.emit();\n+                    }\n+                    return Err(err);\n+                }\n             });\n+            ate_comma = self.eat(&token::Comma);\n+        }\n+\n+        if let Some(mut err) = delayed_err {\n+            if let Some(etc_span) = etc_span {\n+                err.multipart_suggestion(\n+                    \"move the `..` to the end of the field list\",\n+                    vec![\n+                        (etc_span, \"\".into()),\n+                        (self.span, \", .. }\".into()),\n+                    ],\n+                );\n+            }\n+            err.emit();\n         }\n         return Ok((fields, etc));\n     }"}, {"sha": "f288a2b2174289b506c5f0171d7914334c0fcc51", "filename": "src/test/ui/issue-49257.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbc70a0d68bae1d439eb679676c499d543e61396/src%2Ftest%2Fui%2Fissue-49257.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc70a0d68bae1d439eb679676c499d543e61396/src%2Ftest%2Fui%2Fissue-49257.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-49257.rs?ref=cbc70a0d68bae1d439eb679676c499d543e61396", "patch": "@@ -17,5 +17,8 @@ struct Point { x: u8, y: u8 }\n \n fn main() {\n     let p = Point { x: 0, y: 0 };\n+    let Point { .., y, } = p; //~ ERROR expected `}`, found `,`\n     let Point { .., y } = p; //~ ERROR expected `}`, found `,`\n+    let Point { .., } = p; //~ ERROR expected `}`, found `,`\n+    let Point { .. } = p;\n }"}, {"sha": "7c3e7df4a1f327eeea3926a9300d8ec919d29424", "filename": "src/test/ui/issue-49257.stderr", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cbc70a0d68bae1d439eb679676c499d543e61396/src%2Ftest%2Fui%2Fissue-49257.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbc70a0d68bae1d439eb679676c499d543e61396/src%2Ftest%2Fui%2Fissue-49257.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-49257.stderr?ref=cbc70a0d68bae1d439eb679676c499d543e61396", "patch": "@@ -1,9 +1,38 @@\n error: expected `}`, found `,`\n   --> $DIR/issue-49257.rs:20:19\n    |\n+LL |     let Point { .., y, } = p; //~ ERROR expected `}`, found `,`\n+   |                 --^\n+   |                 | |\n+   |                 | expected `}`\n+   |                 `..` must be at the end and cannot have a trailing comma\n+help: move the `..` to the end of the field list\n+   |\n+LL |     let Point {  y, , .. } = p; //~ ERROR expected `}`, found `,`\n+   |                --   ^^^^^^\n+\n+error: expected `}`, found `,`\n+  --> $DIR/issue-49257.rs:21:19\n+   |\n LL |     let Point { .., y } = p; //~ ERROR expected `}`, found `,`\n-   |                   ^ `..` must be in the last position, and cannot have a trailing comma\n+   |                 --^\n+   |                 | |\n+   |                 | expected `}`\n+   |                 `..` must be at the end and cannot have a trailing comma\n+help: move the `..` to the end of the field list\n+   |\n+LL |     let Point {  y , .. } = p; //~ ERROR expected `}`, found `,`\n+   |                --  ^^^^^^\n+\n+error: expected `}`, found `,`\n+  --> $DIR/issue-49257.rs:22:19\n+   |\n+LL |     let Point { .., } = p; //~ ERROR expected `}`, found `,`\n+   |                 --^\n+   |                 | |\n+   |                 | expected `}`\n+   |                 | help: remove this comma\n+   |                 `..` must be at the end and cannot have a trailing comma\n \n-error: aborting due to previous error\n+error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0027`."}]}