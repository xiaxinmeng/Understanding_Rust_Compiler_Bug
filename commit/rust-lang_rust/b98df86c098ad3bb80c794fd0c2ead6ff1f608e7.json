{"sha": "b98df86c098ad3bb80c794fd0c2ead6ff1f608e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5OGRmODZjMDk4YWQzYmI4MGM3OTRmZDBjMmVhZDZmZjFmNjA4ZTc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-09T02:29:15Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-10T03:00:15Z"}, "message": "rt: Move some stack manipulation functions into rust_task", "tree": {"sha": "35ce040aceb5544332e20034730f72ab37e78c83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35ce040aceb5544332e20034730f72ab37e78c83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b98df86c098ad3bb80c794fd0c2ead6ff1f608e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b98df86c098ad3bb80c794fd0c2ead6ff1f608e7", "html_url": "https://github.com/rust-lang/rust/commit/b98df86c098ad3bb80c794fd0c2ead6ff1f608e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b98df86c098ad3bb80c794fd0c2ead6ff1f608e7/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bd8f8d9368945fdbe42aecde2e5a68ac6fc42de", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bd8f8d9368945fdbe42aecde2e5a68ac6fc42de", "html_url": "https://github.com/rust-lang/rust/commit/4bd8f8d9368945fdbe42aecde2e5a68ac6fc42de"}], "stats": {"total": 273, "additions": 136, "deletions": 137}, "files": [{"sha": "dc8b911778a89a502e70c9460ebf011bb41177a9", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 130, "deletions": 137, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/b98df86c098ad3bb80c794fd0c2ead6ff1f608e7/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b98df86c098ad3bb80c794fd0c2ead6ff1f608e7/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=b98df86c098ad3bb80c794fd0c2ead6ff1f608e7", "patch": "@@ -57,133 +57,8 @@\n #endif\n #endif\n \n-static size_t\n-get_next_stk_size(rust_task_thread *thread, rust_task *task,\n-                  size_t min, size_t current, size_t requested) {\n-    LOG(task, mem, \"calculating new stack size for 0x%\" PRIxPTR, task);\n-    LOG(task, mem,\n-        \"min: %\" PRIdPTR \" current: %\" PRIdPTR \" requested: %\" PRIdPTR,\n-        min, current, requested);\n-\n-    // Allocate at least enough to accomodate the next frame\n-    size_t sz = std::max(min, requested);\n-\n-    // And double the stack size each allocation\n-    const size_t max = 1024 * 1024;\n-    size_t next = std::min(max, current * 2);\n-\n-    sz = std::max(sz, next);\n-\n-    LOG(task, mem, \"next stack size: %\" PRIdPTR, sz);\n-    I(thread, requested <= sz);\n-    return sz;\n-}\n-\n-// Task stack segments. Heap allocated and chained together.\n-\n-// The amount of stack in a segment available to Rust code\n-static size_t\n-user_stack_size(stk_seg *stk) {\n-    return (size_t)(stk->end\n-                    - (uintptr_t)&stk->data[0]\n-                    - RED_ZONE_SIZE);\n-}\n-\n-static void\n-free_stk(rust_task *task, stk_seg *stk) {\n-    LOGPTR(task->thread, \"freeing stk segment\", (uintptr_t)stk);\n-    task->total_stack_sz -= user_stack_size(stk);\n-    task->free(stk);\n-}\n-\n-static stk_seg*\n-new_stk(rust_task_thread *thread, rust_task *task, size_t requested_sz)\n-{\n-    LOG(task, mem, \"creating new stack for task %\" PRIxPTR, task);\n-    if (task->stk) {\n-        check_stack_canary(task->stk);\n-    }\n-\n-    // The minimum stack size, in bytes, of a Rust stack, excluding red zone\n-    size_t min_sz = thread->min_stack_size;\n-\n-    // Try to reuse an existing stack segment\n-    if (task->stk != NULL && task->stk->prev != NULL) {\n-        size_t prev_sz = user_stack_size(task->stk->prev);\n-        if (min_sz <= prev_sz && requested_sz <= prev_sz) {\n-            LOG(task, mem, \"reusing existing stack\");\n-            task->stk = task->stk->prev;\n-            A(thread, task->stk->prev == NULL, \"Bogus stack ptr\");\n-            config_valgrind_stack(task->stk);\n-            return task->stk;\n-        } else {\n-            LOG(task, mem, \"existing stack is not big enough\");\n-            free_stk(task, task->stk->prev);\n-            task->stk->prev = NULL;\n-        }\n-    }\n-\n-    // The size of the current stack segment, excluding red zone\n-    size_t current_sz = 0;\n-    if (task->stk != NULL) {\n-        current_sz = user_stack_size(task->stk);\n-    }\n-    // The calculated size of the new stack, excluding red zone\n-    size_t rust_stk_sz = get_next_stk_size(thread, task, min_sz,\n-                                           current_sz, requested_sz);\n-\n-    if (task->total_stack_sz + rust_stk_sz > thread->env->max_stack_size) {\n-        LOG_ERR(task, task, \"task %\" PRIxPTR \" ran out of stack\", task);\n-        task->fail();\n-    }\n-\n-    size_t sz = sizeof(stk_seg) + rust_stk_sz + RED_ZONE_SIZE;\n-    stk_seg *stk = (stk_seg *)task->malloc(sz, \"stack\");\n-    LOGPTR(task->thread, \"new stk\", (uintptr_t)stk);\n-    memset(stk, 0, sizeof(stk_seg));\n-    add_stack_canary(stk);\n-    stk->prev = NULL;\n-    stk->next = task->stk;\n-    stk->end = (uintptr_t) &stk->data[rust_stk_sz + RED_ZONE_SIZE];\n-    LOGPTR(task->thread, \"stk end\", stk->end);\n-\n-    task->stk = stk;\n-    config_valgrind_stack(task->stk);\n-    task->total_stack_sz += user_stack_size(stk);\n-    return stk;\n-}\n-\n-static void\n-del_stk(rust_task *task, stk_seg *stk)\n-{\n-    assert(stk == task->stk && \"Freeing stack segments out of order!\");\n-    check_stack_canary(stk);\n-\n-    task->stk = stk->next;\n-\n-    bool delete_stack = false;\n-    if (task->stk != NULL) {\n-        // Don't actually delete this stack. Save it to reuse later,\n-        // preventing the pathological case where we repeatedly reallocate\n-        // the stack for the next frame.\n-        task->stk->prev = stk;\n-    } else {\n-        // This is the last stack, delete it.\n-        delete_stack = true;\n-    }\n-\n-    // Delete the previous previous stack\n-    if (stk->prev != NULL) {\n-        free_stk(task, stk->prev);\n-        stk->prev = NULL;\n-    }\n-\n-    unconfig_valgrind_stack(stk);\n-    if (delete_stack) {\n-        free_stk(task, stk);\n-        A(task->thread, task->total_stack_sz == 0, \"Stack size should be 0\");\n-    }\n-}\n+extern \"C\" CDECL void\n+record_sp(void *limit);\n \n // Tasks\n rust_task::rust_task(rust_task_thread *thread, rust_task_list *state,\n@@ -218,7 +93,7 @@ rust_task::rust_task(rust_task_thread *thread, rust_task_list *state,\n     LOGPTR(thread, \"new task\", (uintptr_t)this);\n     DLOG(thread, task, \"sizeof(task) = %d (0x%x)\", sizeof *this, sizeof *this);\n \n-    stk = new_stk(thread, this, init_stack_sz);\n+    new_stack(init_stack_sz);\n     if (supervisor) {\n         supervisor->ref();\n     }\n@@ -246,7 +121,7 @@ rust_task::delete_this()\n     // and no landing pads stopped to clean up.\n     // FIXME: We should do this when the task exits, not in the destructor\n     while (stk != NULL) {\n-        del_stk(this, stk);\n+        del_stack();\n     }\n \n     thread->release_task(this);\n@@ -630,16 +505,134 @@ rust_task::notify(bool success) {\n     }\n }\n \n-extern \"C\" CDECL void\n-record_sp(void *limit);\n+size_t\n+rust_task::get_next_stack_size(size_t min, size_t current, size_t requested) {\n+    LOG(this, mem, \"calculating new stack size for 0x%\" PRIxPTR, this);\n+    LOG(this, mem,\n+        \"min: %\" PRIdPTR \" current: %\" PRIdPTR \" requested: %\" PRIdPTR,\n+        min, current, requested);\n+\n+    // Allocate at least enough to accomodate the next frame\n+    size_t sz = std::max(min, requested);\n+\n+    // And double the stack size each allocation\n+    const size_t max = 1024 * 1024;\n+    size_t next = std::min(max, current * 2);\n+\n+    sz = std::max(sz, next);\n+\n+    LOG(this, mem, \"next stack size: %\" PRIdPTR, sz);\n+    I(thread, requested <= sz);\n+    return sz;\n+}\n+\n+// The amount of stack in a segment available to Rust code\n+static size_t\n+user_stack_size(stk_seg *stk) {\n+    return (size_t)(stk->end\n+                    - (uintptr_t)&stk->data[0]\n+                    - RED_ZONE_SIZE);\n+}\n+\n+void\n+rust_task::free_stack(stk_seg *stk) {\n+    LOGPTR(thread, \"freeing stk segment\", (uintptr_t)stk);\n+    total_stack_sz -= user_stack_size(stk);\n+    free(stk);\n+}\n+\n+void\n+rust_task::new_stack(size_t requested_sz) {\n+    LOG(this, mem, \"creating new stack for task %\" PRIxPTR, this);\n+    if (stk) {\n+        ::check_stack_canary(stk);\n+    }\n+\n+    // The minimum stack size, in bytes, of a Rust stack, excluding red zone\n+    size_t min_sz = thread->min_stack_size;\n+\n+    // Try to reuse an existing stack segment\n+    if (stk != NULL && stk->prev != NULL) {\n+        size_t prev_sz = user_stack_size(stk->prev);\n+        if (min_sz <= prev_sz && requested_sz <= prev_sz) {\n+            LOG(this, mem, \"reusing existing stack\");\n+            stk = stk->prev;\n+            A(thread, stk->prev == NULL, \"Bogus stack ptr\");\n+            config_valgrind_stack(stk);\n+            return;\n+        } else {\n+            LOG(this, mem, \"existing stack is not big enough\");\n+            free_stack(stk->prev);\n+            stk->prev = NULL;\n+        }\n+    }\n+\n+    // The size of the current stack segment, excluding red zone\n+    size_t current_sz = 0;\n+    if (stk != NULL) {\n+        current_sz = user_stack_size(stk);\n+    }\n+    // The calculated size of the new stack, excluding red zone\n+    size_t rust_stk_sz = get_next_stack_size(min_sz,\n+                                             current_sz, requested_sz);\n+\n+    if (total_stack_sz + rust_stk_sz > thread->env->max_stack_size) {\n+        LOG_ERR(this, task, \"task %\" PRIxPTR \" ran out of stack\", this);\n+        fail();\n+    }\n+\n+    size_t sz = sizeof(stk_seg) + rust_stk_sz + RED_ZONE_SIZE;\n+    stk_seg *new_stk = (stk_seg *)malloc(sz, \"stack\");\n+    LOGPTR(thread, \"new stk\", (uintptr_t)new_stk);\n+    memset(new_stk, 0, sizeof(stk_seg));\n+    add_stack_canary(new_stk);\n+    new_stk->prev = NULL;\n+    new_stk->next = stk;\n+    new_stk->end = (uintptr_t) &new_stk->data[rust_stk_sz + RED_ZONE_SIZE];\n+    LOGPTR(thread, \"stk end\", new_stk->end);\n+\n+    stk = new_stk;\n+    config_valgrind_stack(stk);\n+    total_stack_sz += user_stack_size(new_stk);\n+}\n+\n+void\n+rust_task::del_stack() {\n+    stk_seg *old_stk = stk;\n+    ::check_stack_canary(old_stk);\n+\n+    stk = old_stk->next;\n+\n+    bool delete_stack = false;\n+    if (stk != NULL) {\n+        // Don't actually delete this stack. Save it to reuse later,\n+        // preventing the pathological case where we repeatedly reallocate\n+        // the stack for the next frame.\n+        stk->prev = old_stk;\n+    } else {\n+        // This is the last stack, delete it.\n+        delete_stack = true;\n+    }\n+\n+    // Delete the previous previous stack\n+    if (old_stk->prev != NULL) {\n+        free_stack(old_stk->prev);\n+        old_stk->prev = NULL;\n+    }\n+\n+    unconfig_valgrind_stack(old_stk);\n+    if (delete_stack) {\n+        free_stack(old_stk);\n+        A(thread, total_stack_sz == 0, \"Stack size should be 0\");\n+    }\n+}\n \n void *\n rust_task::next_stack(size_t stk_sz, void *args_addr, size_t args_sz) {\n-\n-    stk_seg *stk_seg = new_stk(thread, this, stk_sz + args_sz);\n-    A(thread, stk_seg->end - (uintptr_t)stk_seg->data >= stk_sz + args_sz,\n+    new_stack(stk_sz + args_sz);\n+    A(thread, stk->end - (uintptr_t)stk->data >= stk_sz + args_sz,\n       \"Did not receive enough stack\");\n-    uint8_t *new_sp = (uint8_t*)stk_seg->end;\n+    uint8_t *new_sp = (uint8_t*)stk->end;\n     // Push the function arguments to the new stack\n     new_sp = align_down(new_sp - args_sz);\n     memcpy(new_sp, args_addr, args_sz);\n@@ -651,7 +644,7 @@ rust_task::next_stack(size_t stk_sz, void *args_addr, size_t args_sz) {\n \n void\n rust_task::prev_stack() {\n-    del_stk(this, stk);\n+    del_stack();\n     A(thread, rust_task_thread::get_task() == this,\n       \"Recording the stack limit for the wrong thread\");\n     record_stack_limit();\n@@ -695,7 +688,7 @@ void\n rust_task::reset_stack_limit() {\n     uintptr_t sp = get_sp();\n     while (!sp_in_stk_seg(sp, stk)) {\n-        del_stk(this, stk);\n+        del_stack();\n         A(thread, stk != NULL, \"Failed to find the current stack\");\n     }\n     record_stack_limit();"}, {"sha": "7f270f88826eb076b6429b2cde4eadfc917ab4f5", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b98df86c098ad3bb80c794fd0c2ead6ff1f608e7/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/b98df86c098ad3bb80c794fd0c2ead6ff1f608e7/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=b98df86c098ad3bb80c794fd0c2ead6ff1f608e7", "patch": "@@ -106,6 +106,12 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n private:\n     // Called when the atomic refcount reaches zero\n     void delete_this();\n+\n+    void new_stack(size_t sz);\n+    void del_stack();\n+    void free_stack(stk_seg *stk);\n+    size_t get_next_stack_size(size_t min, size_t current, size_t requested);\n+\n public:\n \n     // Only a pointer to 'name' is kept, so it must live as long as this task."}]}