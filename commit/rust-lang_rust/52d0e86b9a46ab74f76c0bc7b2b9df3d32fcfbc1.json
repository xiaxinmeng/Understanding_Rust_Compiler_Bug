{"sha": "52d0e86b9a46ab74f76c0bc7b2b9df3d32fcfbc1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyZDBlODZiOWE0NmFiNzRmNzZjMGJjN2IyYjlkZjNkMzJmY2ZiYzE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-09T01:23:10Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-15T07:25:56Z"}, "message": "syntax: extract sess.rs for ParseSess", "tree": {"sha": "db57bde7aa884d0fad1ff676d7b773b50af5b1e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db57bde7aa884d0fad1ff676d7b773b50af5b1e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52d0e86b9a46ab74f76c0bc7b2b9df3d32fcfbc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52d0e86b9a46ab74f76c0bc7b2b9df3d32fcfbc1", "html_url": "https://github.com/rust-lang/rust/commit/52d0e86b9a46ab74f76c0bc7b2b9df3d32fcfbc1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52d0e86b9a46ab74f76c0bc7b2b9df3d32fcfbc1/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c29fe81ec42a89a5aadd8496855dc7dc43be7668", "url": "https://api.github.com/repos/rust-lang/rust/commits/c29fe81ec42a89a5aadd8496855dc7dc43be7668", "html_url": "https://github.com/rust-lang/rust/commit/c29fe81ec42a89a5aadd8496855dc7dc43be7668"}], "stats": {"total": 251, "additions": 132, "deletions": 119}, "files": [{"sha": "53ba9b20690a2efcab36ab0f1037230dcc9977da", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 7, "deletions": 118, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/52d0e86b9a46ab74f76c0bc7b2b9df3d32fcfbc1/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52d0e86b9a46ab74f76c0bc7b2b9df3d32fcfbc1/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=52d0e86b9a46ab74f76c0bc7b2b9df3d32fcfbc1", "patch": "@@ -1,26 +1,19 @@\n //! The main parser interface.\n \n-use crate::ast::{self, CrateConfig, NodeId};\n-use crate::early_buffered_lints::{BufferedEarlyLint, BufferedEarlyLintId};\n-use crate::source_map::{SourceMap, FilePathMapping};\n-use crate::feature_gate::UnstableFeatures;\n+use crate::ast;\n use crate::parse::parser::{Parser, emit_unclosed_delims};\n use crate::parse::token::{Nonterminal, TokenKind};\n use crate::tokenstream::{self, TokenStream, TokenTree};\n use crate::print::pprust;\n-use crate::symbol::Symbol;\n \n-use errors::{Applicability, FatalError, Level, Handler, ColorConfig, Diagnostic, DiagnosticBuilder};\n-use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n+use errors::{FatalError, Level, Diagnostic, DiagnosticBuilder};\n #[cfg(target_arch = \"x86_64\")]\n use rustc_data_structures::static_assert_size;\n-use rustc_data_structures::sync::{Lrc, Lock, Once};\n-use syntax_pos::{Span, SourceFile, FileName, MultiSpan};\n-use syntax_pos::edition::Edition;\n-use syntax_pos::hygiene::ExpnId;\n+use rustc_data_structures::sync::Lrc;\n+use syntax_pos::{Span, SourceFile, FileName};\n \n use std::borrow::Cow;\n-use std::path::{Path, PathBuf};\n+use std::path::Path;\n use std::str;\n \n use log::info;\n@@ -33,6 +26,8 @@ pub mod parser;\n pub mod attr;\n pub mod lexer;\n pub mod token;\n+mod sess;\n+pub use sess::ParseSess;\n \n crate mod classify;\n crate mod diagnostics;\n@@ -46,112 +41,6 @@ pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a>>;\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(PResult<'_, bool>, 16);\n \n-/// Collected spans during parsing for places where a certain feature was\n-/// used and should be feature gated accordingly in `check_crate`.\n-#[derive(Default)]\n-pub struct GatedSpans {\n-    /// Spans collected for gating `let_chains`, e.g. `if a && let b = c {}`.\n-    pub let_chains: Lock<Vec<Span>>,\n-    /// Spans collected for gating `async_closure`, e.g. `async || ..`.\n-    pub async_closure: Lock<Vec<Span>>,\n-    /// Spans collected for gating `yield e?` expressions (`generators` gate).\n-    pub yields: Lock<Vec<Span>>,\n-    /// Spans collected for gating `or_patterns`, e.g. `Some(Foo | Bar)`.\n-    pub or_patterns: Lock<Vec<Span>>,\n-    /// Spans collected for gating `const_extern_fn`, e.g. `const extern fn foo`.\n-    pub const_extern_fn: Lock<Vec<Span>>,\n-}\n-\n-/// Info about a parsing session.\n-pub struct ParseSess {\n-    pub span_diagnostic: Handler,\n-    pub unstable_features: UnstableFeatures,\n-    pub config: CrateConfig,\n-    pub edition: Edition,\n-    pub missing_fragment_specifiers: Lock<FxHashSet<Span>>,\n-    /// Places where raw identifiers were used. This is used for feature-gating raw identifiers.\n-    pub raw_identifier_spans: Lock<Vec<Span>>,\n-    /// Used to determine and report recursive module inclusions.\n-    included_mod_stack: Lock<Vec<PathBuf>>,\n-    source_map: Lrc<SourceMap>,\n-    pub buffered_lints: Lock<Vec<BufferedEarlyLint>>,\n-    /// Contains the spans of block expressions that could have been incomplete based on the\n-    /// operation token that followed it, but that the parser cannot identify without further\n-    /// analysis.\n-    pub ambiguous_block_expr_parse: Lock<FxHashMap<Span, Span>>,\n-    pub injected_crate_name: Once<Symbol>,\n-    pub gated_spans: GatedSpans,\n-}\n-\n-impl ParseSess {\n-    pub fn new(file_path_mapping: FilePathMapping) -> Self {\n-        let cm = Lrc::new(SourceMap::new(file_path_mapping));\n-        let handler = Handler::with_tty_emitter(\n-            ColorConfig::Auto,\n-            true,\n-            None,\n-            Some(cm.clone()),\n-        );\n-        ParseSess::with_span_handler(handler, cm)\n-    }\n-\n-    pub fn with_span_handler(handler: Handler, source_map: Lrc<SourceMap>) -> Self {\n-        Self {\n-            span_diagnostic: handler,\n-            unstable_features: UnstableFeatures::from_environment(),\n-            config: FxHashSet::default(),\n-            edition: ExpnId::root().expn_data().edition,\n-            missing_fragment_specifiers: Lock::new(FxHashSet::default()),\n-            raw_identifier_spans: Lock::new(Vec::new()),\n-            included_mod_stack: Lock::new(vec![]),\n-            source_map,\n-            buffered_lints: Lock::new(vec![]),\n-            ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),\n-            injected_crate_name: Once::new(),\n-            gated_spans: GatedSpans::default(),\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn source_map(&self) -> &SourceMap {\n-        &self.source_map\n-    }\n-\n-    pub fn buffer_lint<S: Into<MultiSpan>>(&self,\n-        lint_id: BufferedEarlyLintId,\n-        span: S,\n-        id: NodeId,\n-        msg: &str,\n-    ) {\n-        self.buffered_lints.with_lock(|buffered_lints| {\n-            buffered_lints.push(BufferedEarlyLint{\n-                span: span.into(),\n-                id,\n-                msg: msg.into(),\n-                lint_id,\n-            });\n-        });\n-    }\n-\n-    /// Extend an error with a suggestion to wrap an expression with parentheses to allow the\n-    /// parser to continue parsing the following operation as part of the same expression.\n-    pub fn expr_parentheses_needed(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        span: Span,\n-        alt_snippet: Option<String>,\n-    ) {\n-        if let Some(snippet) = self.source_map().span_to_snippet(span).ok().or(alt_snippet) {\n-            err.span_suggestion(\n-                span,\n-                \"parentheses are required to parse this as an expression\",\n-                format!(\"({})\", snippet),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-    }\n-}\n-\n #[derive(Clone)]\n pub struct Directory<'a> {\n     pub path: Cow<'a, Path>,"}, {"sha": "2b97347983362dd734234873060a4f05b689fd9c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52d0e86b9a46ab74f76c0bc7b2b9df3d32fcfbc1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52d0e86b9a46ab74f76c0bc7b2b9df3d32fcfbc1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=52d0e86b9a46ab74f76c0bc7b2b9df3d32fcfbc1", "patch": "@@ -1366,7 +1366,7 @@ impl<'a> Parser<'a> {\n             ],\n             Applicability::MaybeIncorrect,\n         ).span_suggestion(\n-            self.sess.source_map.next_point(self.prev_span),\n+            self.sess.source_map().next_point(self.prev_span),\n             \"add a semicolon\",\n             ';'.to_string(),\n             Applicability::MaybeIncorrect,"}, {"sha": "e49d3954f8e6976e76f5d57ac271f1d8c2a89114", "filename": "src/libsyntax/parse/sess.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/52d0e86b9a46ab74f76c0bc7b2b9df3d32fcfbc1/src%2Flibsyntax%2Fparse%2Fsess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52d0e86b9a46ab74f76c0bc7b2b9df3d32fcfbc1/src%2Flibsyntax%2Fparse%2Fsess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fsess.rs?ref=52d0e86b9a46ab74f76c0bc7b2b9df3d32fcfbc1", "patch": "@@ -0,0 +1,124 @@\n+//! Contains `ParseSess` which holds state living beyond what one `Parser` might.\n+//! It also serves as an input to the parser itself.\n+\n+use crate::ast::{CrateConfig, NodeId};\n+use crate::early_buffered_lints::{BufferedEarlyLint, BufferedEarlyLintId};\n+use crate::source_map::{SourceMap, FilePathMapping};\n+use crate::feature_gate::UnstableFeatures;\n+\n+use errors::{Applicability, Handler, ColorConfig, DiagnosticBuilder};\n+use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n+use rustc_data_structures::sync::{Lrc, Lock, Once};\n+use syntax_pos::{Symbol, Span, MultiSpan};\n+use syntax_pos::edition::Edition;\n+use syntax_pos::hygiene::ExpnId;\n+\n+use std::path::PathBuf;\n+use std::str;\n+\n+/// Collected spans during parsing for places where a certain feature was\n+/// used and should be feature gated accordingly in `check_crate`.\n+#[derive(Default)]\n+crate struct GatedSpans {\n+    /// Spans collected for gating `let_chains`, e.g. `if a && let b = c {}`.\n+    crate let_chains: Lock<Vec<Span>>,\n+    /// Spans collected for gating `async_closure`, e.g. `async || ..`.\n+    crate async_closure: Lock<Vec<Span>>,\n+    /// Spans collected for gating `yield e?` expressions (`generators` gate).\n+    crate yields: Lock<Vec<Span>>,\n+    /// Spans collected for gating `or_patterns`, e.g. `Some(Foo | Bar)`.\n+    crate or_patterns: Lock<Vec<Span>>,\n+    /// Spans collected for gating `const_extern_fn`, e.g. `const extern fn foo`.\n+    crate const_extern_fn: Lock<Vec<Span>>,\n+}\n+\n+/// Info about a parsing session.\n+pub struct ParseSess {\n+    pub span_diagnostic: Handler,\n+    crate unstable_features: UnstableFeatures,\n+    pub config: CrateConfig,\n+    pub edition: Edition,\n+    pub missing_fragment_specifiers: Lock<FxHashSet<Span>>,\n+    /// Places where raw identifiers were used. This is used for feature-gating raw identifiers.\n+    pub raw_identifier_spans: Lock<Vec<Span>>,\n+    /// Used to determine and report recursive module inclusions.\n+    pub(super) included_mod_stack: Lock<Vec<PathBuf>>,\n+    source_map: Lrc<SourceMap>,\n+    pub buffered_lints: Lock<Vec<BufferedEarlyLint>>,\n+    /// Contains the spans of block expressions that could have been incomplete based on the\n+    /// operation token that followed it, but that the parser cannot identify without further\n+    /// analysis.\n+    pub ambiguous_block_expr_parse: Lock<FxHashMap<Span, Span>>,\n+    pub injected_crate_name: Once<Symbol>,\n+    crate gated_spans: GatedSpans,\n+}\n+\n+impl ParseSess {\n+    pub fn new(file_path_mapping: FilePathMapping) -> Self {\n+        let cm = Lrc::new(SourceMap::new(file_path_mapping));\n+        let handler = Handler::with_tty_emitter(\n+            ColorConfig::Auto,\n+            true,\n+            None,\n+            Some(cm.clone()),\n+        );\n+        ParseSess::with_span_handler(handler, cm)\n+    }\n+\n+    pub fn with_span_handler(handler: Handler, source_map: Lrc<SourceMap>) -> Self {\n+        Self {\n+            span_diagnostic: handler,\n+            unstable_features: UnstableFeatures::from_environment(),\n+            config: FxHashSet::default(),\n+            edition: ExpnId::root().expn_data().edition,\n+            missing_fragment_specifiers: Lock::new(FxHashSet::default()),\n+            raw_identifier_spans: Lock::new(Vec::new()),\n+            included_mod_stack: Lock::new(vec![]),\n+            source_map,\n+            buffered_lints: Lock::new(vec![]),\n+            ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),\n+            injected_crate_name: Once::new(),\n+            gated_spans: GatedSpans::default(),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn source_map(&self) -> &SourceMap {\n+        &self.source_map\n+    }\n+\n+    pub fn buffer_lint(\n+        &self,\n+        lint_id: BufferedEarlyLintId,\n+        span: impl Into<MultiSpan>,\n+        id: NodeId,\n+        msg: &str,\n+    ) {\n+        self.buffered_lints.with_lock(|buffered_lints| {\n+            buffered_lints.push(BufferedEarlyLint{\n+                span: span.into(),\n+                id,\n+                msg: msg.into(),\n+                lint_id,\n+            });\n+        });\n+    }\n+\n+    /// Extend an error with a suggestion to wrap an expression with parentheses to allow the\n+    /// parser to continue parsing the following operation as part of the same expression.\n+    pub fn expr_parentheses_needed(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        span: Span,\n+        alt_snippet: Option<String>,\n+    ) {\n+        if let Some(snippet) = self.source_map().span_to_snippet(span).ok().or(alt_snippet) {\n+            err.span_suggestion(\n+                span,\n+                \"parentheses are required to parse this as an expression\",\n+                format!(\"({})\", snippet),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}"}]}