{"sha": "8a92718b64307236514a16c5f69cd5c02d40dd6b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhOTI3MThiNjQzMDcyMzY1MTRhMTZjNWY2OWNkNWMwMmQ0MGRkNmI=", "commit": {"author": {"name": "Prabakaran Kumaresshan", "email": "4676330+nixphix@users.noreply.github.com", "date": "2020-08-27T01:13:19Z"}, "committer": {"name": "Prabakaran Kumaresshan", "email": "4676330+nixphix@users.noreply.github.com", "date": "2020-08-30T00:10:47Z"}, "message": "Switch to intra-doc links in core/src/{convert,iter}/mod.rs", "tree": {"sha": "acb111a3084009d407d6871c83a55013cadfd85f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/acb111a3084009d407d6871c83a55013cadfd85f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a92718b64307236514a16c5f69cd5c02d40dd6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a92718b64307236514a16c5f69cd5c02d40dd6b", "html_url": "https://github.com/rust-lang/rust/commit/8a92718b64307236514a16c5f69cd5c02d40dd6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a92718b64307236514a16c5f69cd5c02d40dd6b/comments", "author": {"login": "nixphix", "id": 4676330, "node_id": "MDQ6VXNlcjQ2NzYzMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/4676330?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nixphix", "html_url": "https://github.com/nixphix", "followers_url": "https://api.github.com/users/nixphix/followers", "following_url": "https://api.github.com/users/nixphix/following{/other_user}", "gists_url": "https://api.github.com/users/nixphix/gists{/gist_id}", "starred_url": "https://api.github.com/users/nixphix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nixphix/subscriptions", "organizations_url": "https://api.github.com/users/nixphix/orgs", "repos_url": "https://api.github.com/users/nixphix/repos", "events_url": "https://api.github.com/users/nixphix/events{/privacy}", "received_events_url": "https://api.github.com/users/nixphix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nixphix", "id": 4676330, "node_id": "MDQ6VXNlcjQ2NzYzMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/4676330?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nixphix", "html_url": "https://github.com/nixphix", "followers_url": "https://api.github.com/users/nixphix/followers", "following_url": "https://api.github.com/users/nixphix/following{/other_user}", "gists_url": "https://api.github.com/users/nixphix/gists{/gist_id}", "starred_url": "https://api.github.com/users/nixphix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nixphix/subscriptions", "organizations_url": "https://api.github.com/users/nixphix/orgs", "repos_url": "https://api.github.com/users/nixphix/repos", "events_url": "https://api.github.com/users/nixphix/events{/privacy}", "received_events_url": "https://api.github.com/users/nixphix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c27700b88ba2accfca978c3f6b0c35333e9e778", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c27700b88ba2accfca978c3f6b0c35333e9e778", "html_url": "https://github.com/rust-lang/rust/commit/5c27700b88ba2accfca978c3f6b0c35333e9e778"}], "stats": {"total": 93, "additions": 26, "deletions": 67}, "files": [{"sha": "31761017dcf4a62152d4f49eb1bd5b2cd1b27070", "filename": "library/core/src/convert/mod.rs", "status": "modified", "additions": 17, "deletions": 41, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/8a92718b64307236514a16c5f69cd5c02d40dd6b/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a92718b64307236514a16c5f69cd5c02d40dd6b/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs?ref=8a92718b64307236514a16c5f69cd5c02d40dd6b", "patch": "@@ -31,13 +31,6 @@\n //!   `into` themselves and `from` themselves\n //!\n //! See each trait for usage examples.\n-//!\n-//! [`Into`]: trait.Into.html\n-//! [`From`]: trait.From.html\n-//! [`TryFrom`]: trait.TryFrom.html\n-//! [`TryInto`]: trait.TryInto.html\n-//! [`AsRef`]: trait.AsRef.html\n-//! [`AsMut`]: trait.AsMut.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -141,13 +134,11 @@ pub const fn identity<T>(x: T) -> T {\n /// want to accept all references that can be converted to [`&str`] as an argument.\n /// Since both [`String`] and [`&str`] implement `AsRef<str>` we can accept both as input argument.\n ///\n-/// [`Option<T>`]: ../../std/option/enum.Option.html\n-/// [`Result<T, E>`]: ../../std/result/enum.Result.html\n-/// [`Borrow`]: ../../std/borrow/trait.Borrow.html\n-/// [`Hash`]: ../../std/hash/trait.Hash.html\n-/// [`Eq`]: ../../std/cmp/trait.Eq.html\n-/// [`Ord`]: ../../std/cmp/trait.Ord.html\n-/// [`&str`]: ../../std/primitive.str.html\n+/// [`Option<T>`]: crate::option::Option\n+/// [`Result<T, E>`]: crate::result::Result\n+/// [`Borrow`]: crate::borrow::Borrow\n+/// [`Eq`]: crate::cmp::Eq\n+/// [`Ord`]: crate::cmp::Ord\n /// [`String`]: ../../std/string/struct.String.html\n ///\n /// ```\n@@ -177,8 +168,8 @@ pub trait AsRef<T: ?Sized> {\n /// **Note: This trait must not fail**. If the conversion can fail, use a\n /// dedicated method which returns an [`Option<T>`] or a [`Result<T, E>`].\n ///\n-/// [`Option<T>`]: ../../std/option/enum.Option.html\n-/// [`Result<T, E>`]: ../../std/result/enum.Result.html\n+/// [`Option<T>`]: crate::option::Option\n+/// [`Result<T, E>`]: crate::result::Result\n ///\n /// # Generic Implementations\n ///\n@@ -204,7 +195,7 @@ pub trait AsRef<T: ?Sized> {\n /// assert_eq!(*boxed_num, 1);\n /// ```\n ///\n-/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n+/// [`Box<T>`]: crate::boxed::Box<T>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait AsMut<T: ?Sized> {\n     /// Performs the conversion.\n@@ -278,13 +269,10 @@ pub trait AsMut<T: ?Sized> {\n /// is_hello(s);\n /// ```\n ///\n-/// [`TryInto`]: trait.TryInto.html\n-/// [`Option<T>`]: ../../std/option/enum.Option.html\n-/// [`Result<T, E>`]: ../../std/result/enum.Result.html\n+/// [`Option<T>`]: crate::option::Option\n+/// [`Result<T, E>`]: crate::result::Result\n /// [`String`]: ../../std/string/struct.String.html\n-/// [`From`]: trait.From.html\n-/// [`Into`]: trait.Into.html\n-/// [`Vec`]: ../../std/vec/struct.Vec.html\n+/// [`Vec`]: crate::vec::Vec<T>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Into<T>: Sized {\n     /// Performs the conversion.\n@@ -370,12 +358,9 @@ pub trait Into<T>: Sized {\n /// }\n /// ```\n ///\n-/// [`TryFrom`]: trait.TryFrom.html\n-/// [`Option<T>`]: ../../std/option/enum.Option.html\n-/// [`Result<T, E>`]: ../../std/result/enum.Result.html\n+/// [`Option<T>`]: crate::option::Option\n+/// [`Result<T, E>`]: crate::result::Result\n /// [`String`]: ../../std/string/struct.String.html\n-/// [`Into`]: trait.Into.html\n-/// [`from`]: trait.From.html#tymethod.from\n /// [book]: ../../book/ch09-00-error-handling.html\n #[rustc_diagnostic_item = \"from_trait\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -404,9 +389,6 @@ pub trait From<T>: Sized {\n ///\n /// This suffers the same restrictions and reasoning as implementing\n /// [`Into`], see there for details.\n-///\n-/// [`TryFrom`]: trait.TryFrom.html\n-/// [`Into`]: trait.Into.html\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n pub trait TryInto<T>: Sized {\n     /// The type returned in the event of a conversion error.\n@@ -436,7 +418,7 @@ pub trait TryInto<T>: Sized {\n /// # Generic Implementations\n ///\n /// - `TryFrom<T> for U` implies [`TryInto`]`<U> for T`\n-/// - [`try_from`] is reflexive, which means that `TryFrom<T> for T`\n+/// - [`TryFrom::try_from`] is reflexive, which means that `TryFrom<T> for T`\n /// is implemented and cannot fail -- the associated `Error` type for\n /// calling `T::try_from()` on a value of type `T` is [`Infallible`].\n /// When the [`!`] type is stabilized [`Infallible`] and [`!`] will be\n@@ -485,11 +467,8 @@ pub trait TryInto<T>: Sized {\n /// assert!(try_successful_smaller_number.is_ok());\n /// ```\n ///\n-/// [`try_from`]: trait.TryFrom.html#tymethod.try_from\n-/// [`TryInto`]: trait.TryInto.html\n-/// [`i32::MAX`]: ../../std/i32/constant.MAX.html\n+/// [`i32::MAX`]: crate::i32::MAX\n /// [`!`]: ../../std/primitive.never.html\n-/// [`Infallible`]: enum.Infallible.html\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n pub trait TryFrom<T>: Sized {\n     /// The type returned in the event of a conversion error.\n@@ -676,7 +655,6 @@ impl AsRef<str> for str {\n ///\n /// \u2026 and eventually deprecate `Infallible`.\n ///\n-///\n /// However there is one case where `!` syntax can be used\n /// before `!` is stabilized as a full-fledged type: in the position of a function\u2019s return type.\n /// Specifically, it is possible implementations for two different function pointer types:\n@@ -692,10 +670,8 @@ impl AsRef<str> for str {\n /// the two `impl`s will start to overlap\n /// and therefore will be disallowed by the language\u2019s trait coherence rules.\n ///\n-/// [`Ok`]: ../result/enum.Result.html#variant.Ok\n-/// [`Result`]: ../result/enum.Result.html\n-/// [`TryFrom`]: trait.TryFrom.html\n-/// [`Into`]: trait.Into.html\n+/// [`Ok`]: super::result::Result::Ok\n+/// [`Result`]: super::result::Result\n /// [never]: ../../std/primitive.never.html\n #[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n #[derive(Copy)]"}, {"sha": "a2e200ef63d223234647dc5cbbf50c89eacf867d", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 9, "deletions": 26, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8a92718b64307236514a16c5f69cd5c02d40dd6b/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a92718b64307236514a16c5f69cd5c02d40dd6b/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=8a92718b64307236514a16c5f69cd5c02d40dd6b", "patch": "@@ -53,9 +53,7 @@\n //! more complex forms of processing. See the [Adapters](#adapters) section\n //! below for more details.\n //!\n-//! [`Some(Item)`]: Some\n-//! [`Iterator`]: trait.Iterator.html\n-//! [`next`]: trait.Iterator.html#tymethod.next\n+//! [`next`]: Iterator::next\n //! [`TryIter`]: ../../std/sync/mpsc/struct.TryIter.html\n //!\n //! # The three forms of iteration\n@@ -154,14 +152,11 @@\n //! produce an iterator. What gives?\n //!\n //! There's a trait in the standard library for converting something into an\n-//! iterator: [`IntoIterator`]. This trait has one method, [`into_iter`],\n+//! iterator: [`IntoIterator`]. This trait has one method, [`IntoIterator::into_iter`],\n //! which converts the thing implementing [`IntoIterator`] into an iterator.\n //! Let's take a look at that `for` loop again, and what the compiler converts\n //! it into:\n //!\n-//! [`IntoIterator`]: trait.IntoIterator.html\n-//! [`into_iter`]: trait.IntoIterator.html#tymethod.into_iter\n-//!\n //! ```\n //! let values = vec![1, 2, 3, 4, 5];\n //!\n@@ -214,24 +209,20 @@\n //! often called 'iterator adapters', as they're a form of the 'adapter\n //! pattern'.\n //!\n-//! Common iterator adapters include [`map`], [`take`], and [`filter`].\n+//! Common iterator adapters include [`Iterator::map`], [`Iterator::take`], and [`Iterator::filter`].\n //! For more, see their documentation.\n //!\n //! If an iterator adapter panics, the iterator will be in an unspecified (but\n //! memory safe) state.  This state is also not guaranteed to stay the same\n //! across versions of Rust, so you should avoid relying on the exact values\n //! returned by an iterator which panicked.\n //!\n-//! [`map`]: trait.Iterator.html#method.map\n-//! [`take`]: trait.Iterator.html#method.take\n-//! [`filter`]: trait.Iterator.html#method.filter\n-//!\n //! # Laziness\n //!\n //! Iterators (and iterator [adapters](#adapters)) are *lazy*. This means that\n //! just creating an iterator doesn't _do_ a whole lot. Nothing really happens\n //! until you call [`next`]. This is sometimes a source of confusion when\n-//! creating an iterator solely for its side effects. For example, the [`map`]\n+//! creating an iterator solely for its side effects. For example, the [`Iterator::map`]\n //! method calls a closure on each element it iterates over:\n //!\n //! ```\n@@ -248,8 +239,8 @@\n //! do nothing unless consumed\n //! ```\n //!\n-//! The idiomatic way to write a [`map`] for its side effects is to use a\n-//! `for` loop or call the [`for_each`] method:\n+//! The idiomatic way to write a [`Iterator::map`] for its side effects is to use a\n+//! `for` loop or call the [`Iterator::for_each`] method:\n //!\n //! ```\n //! let v = vec![1, 2, 3, 4, 5];\n@@ -261,14 +252,9 @@\n //! }\n //! ```\n //!\n-//! [`map`]: trait.Iterator.html#method.map\n-//! [`for_each`]: trait.Iterator.html#method.for_each\n-//!\n-//! Another common way to evaluate an iterator is to use the [`collect`]\n+//! Another common way to evaluate an iterator is to use the [`Iterator::collect`]\n //! method to produce a new collection.\n //!\n-//! [`collect`]: trait.Iterator.html#method.collect\n-//!\n //! # Infinity\n //!\n //! Iterators do not have to be finite. As an example, an open-ended range is\n@@ -278,7 +264,7 @@\n //! let numbers = 0..;\n //! ```\n //!\n-//! It is common to use the [`take`] iterator adapter to turn an infinite\n+//! It is common to use the [`Iterator::take`] iterator adapter to turn an infinite\n //! iterator into a finite one:\n //!\n //! ```\n@@ -294,7 +280,7 @@\n //!\n //! Bear in mind that methods on infinite iterators, even those for which a\n //! result can be determined mathematically in finite time, may not terminate.\n-//! Specifically, methods such as [`min`], which in the general case require\n+//! Specifically, methods such as [`Iterator::min`], which in the general case require\n //! traversing every element in the iterator, are likely not to return\n //! successfully for any infinite iterators.\n //!\n@@ -304,9 +290,6 @@\n //! // `ones.min()` causes an infinite loop, so we won't reach this point!\n //! println!(\"The smallest number one is {}.\", least);\n //! ```\n-//!\n-//! [`take`]: trait.Iterator.html#method.take\n-//! [`min`]: trait.Iterator.html#method.min\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}]}