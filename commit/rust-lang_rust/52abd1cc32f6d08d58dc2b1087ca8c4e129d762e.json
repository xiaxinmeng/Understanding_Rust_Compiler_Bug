{"sha": "52abd1cc32f6d08d58dc2b1087ca8c4e129d762e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyYWJkMWNjMzJmNmQwOGQ1OGRjMmIxMDg3Y2E4YzRlMTI5ZDc2MmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-07T18:16:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-07T18:16:59Z"}, "message": "auto merge of #7636 : dotdash/rust/scope_cleanup, r=graydon\n\nCurrently, scopes are tied to LLVM basic blocks. For each scope, there\r\nare two new basic blocks, which means two extra jumps in the unoptimized\r\nIR. These blocks aren't actually required, but only used to act as the\r\nboundary for cleanups.\r\n\r\nBy keeping track of the current scope within a single basic block, we\r\ncan avoid those extra blocks and jumps, shrinking the pre-optimization\r\nIR quite considerably. For example, the IR for trans_intrinsic goes\r\nfrom ~22k lines to ~16k lines, almost 30% less.\r\n\r\nThe impact on the build times of optimized builds is rather small (about\r\n1%), but unoptimized builds are about 11% faster. The testsuite for\r\nunoptimized builds runs between 15% (CPU time) and 7.5% (wallclock time on\r\nmy i7) faster.\r\n\r\nAlso, in some situations this helps LLVM to generate better code by\r\ninlining functions that it previously considered to be too large.\r\nLikely because of the pointless blocks/jumps that were still present at\r\nthe time the inlining pass runs.\r\n\r\nRefs #7462", "tree": {"sha": "e5c264b66e36713dc8bd49f75a061eec534947a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5c264b66e36713dc8bd49f75a061eec534947a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52abd1cc32f6d08d58dc2b1087ca8c4e129d762e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52abd1cc32f6d08d58dc2b1087ca8c4e129d762e", "html_url": "https://github.com/rust-lang/rust/commit/52abd1cc32f6d08d58dc2b1087ca8c4e129d762e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52abd1cc32f6d08d58dc2b1087ca8c4e129d762e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c44265d8791d54fa64550c60dc820eef87f9cf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c44265d8791d54fa64550c60dc820eef87f9cf5", "html_url": "https://github.com/rust-lang/rust/commit/3c44265d8791d54fa64550c60dc820eef87f9cf5"}, {"sha": "e41e4358516190bf84172f21d9e25e45da81caf4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e41e4358516190bf84172f21d9e25e45da81caf4", "html_url": "https://github.com/rust-lang/rust/commit/e41e4358516190bf84172f21d9e25e45da81caf4"}], "stats": {"total": 364, "additions": 203, "deletions": 161}, "files": [{"sha": "999fa000f884f4667b7685168cce1256f7d35721", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 109, "deletions": 87, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/52abd1cc32f6d08d58dc2b1087ca8c4e129d762e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52abd1cc32f6d08d58dc2b1087ca8c4e129d762e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=52abd1cc32f6d08d58dc2b1087ca8c4e129d762e", "patch": "@@ -863,10 +863,10 @@ pub fn need_invoke(bcx: block) -> bool {\n \n     // Walk the scopes to look for cleanups\n     let mut cur = bcx;\n+    let mut cur_scope = cur.scope;\n     loop {\n-        match cur.kind {\n-            block_scope(inf) => {\n-                let inf = &mut *inf; // FIXME(#5074) workaround old borrowck\n+        cur_scope = match cur_scope {\n+            Some(inf) => {\n                 for inf.cleanups.iter().advance |cleanup| {\n                     match *cleanup {\n                         clean(_, cleanup_type) | clean_temp(_, _, cleanup_type) => {\n@@ -876,12 +876,15 @@ pub fn need_invoke(bcx: block) -> bool {\n                         }\n                     }\n                 }\n+                inf.parent\n+            }\n+            None => {\n+                cur = match cur.parent {\n+                    Some(next) => next,\n+                    None => return false\n+                };\n+                cur.scope\n             }\n-            _ => ()\n-        }\n-        cur = match cur.parent {\n-          Some(next) => next,\n-          None => return false\n         }\n     }\n }\n@@ -899,23 +902,21 @@ pub fn have_cached_lpad(bcx: block) -> bool {\n \n pub fn in_lpad_scope_cx(bcx: block, f: &fn(si: &mut scope_info)) {\n     let mut bcx = bcx;\n+    let mut cur_scope = bcx.scope;\n     loop {\n-        {\n-            match bcx.kind {\n-                block_scope(inf) => {\n-                    let len = { // FIXME(#5074) workaround old borrowck\n-                        let inf = &mut *inf;\n-                        inf.cleanups.len()\n-                    };\n-                    if len > 0u || bcx.parent.is_none() {\n-                        f(inf);\n-                        return;\n-                    }\n+        cur_scope = match cur_scope {\n+            Some(inf) => {\n+                if !inf.empty_cleanups() || (inf.parent.is_none() && bcx.parent.is_none()) {\n+                    f(inf);\n+                    return;\n                 }\n-                _ => ()\n+                inf.parent\n+            }\n+            None => {\n+                bcx = block_parent(bcx);\n+                bcx.scope\n             }\n         }\n-        bcx = block_parent(bcx);\n     }\n }\n \n@@ -972,27 +973,31 @@ pub fn get_landing_pad(bcx: block) -> BasicBlockRef {\n \n pub fn find_bcx_for_scope(bcx: block, scope_id: ast::node_id) -> block {\n     let mut bcx_sid = bcx;\n+    let mut cur_scope = bcx_sid.scope;\n     loop {\n-        bcx_sid = match bcx_sid.node_info {\n-            Some(NodeInfo { id, _ }) if id == scope_id => {\n-                return bcx_sid\n-              }\n-\n-                // FIXME(#6268, #6248) hacky cleanup for nested method calls\n-                Some(NodeInfo { callee_id: Some(id), _ }) if id == scope_id => {\n-                    return bcx_sid\n-                }\n-\n-                _ => {\n-                    match bcx_sid.parent {\n-                        None => bcx.tcx().sess.bug(\n-                            fmt!(\"no enclosing scope with id %d\", scope_id)),\n-                        Some(bcx_par) => bcx_par\n+        cur_scope = match cur_scope {\n+            Some(inf) => {\n+                match inf.node_info {\n+                    Some(NodeInfo { id, _ }) if id == scope_id => {\n+                        return bcx_sid\n                     }\n+                    // FIXME(#6268, #6248) hacky cleanup for nested method calls\n+                    Some(NodeInfo { callee_id: Some(id), _ }) if id == scope_id => {\n+                        return bcx_sid\n+                    }\n+                    _ => inf.parent\n                 }\n             }\n+            None => {\n+                bcx_sid = match bcx_sid.parent {\n+                    None => bcx.tcx().sess.bug(fmt!(\"no enclosing scope with id %d\", scope_id)),\n+                    Some(bcx_par) => bcx_par\n+                };\n+                bcx_sid.scope\n+            }\n         }\n     }\n+}\n \n \n pub fn do_spill(bcx: block, v: ValueRef, t: ty::t) -> ValueRef {\n@@ -1145,7 +1150,7 @@ pub fn trans_stmt(cx: block, s: &ast::stmt) -> block {\n \n // You probably don't want to use this one. See the\n // next three functions instead.\n-pub fn new_block(cx: fn_ctxt, parent: Option<block>, kind: block_kind,\n+pub fn new_block(cx: fn_ctxt, parent: Option<block>, scope: Option<@mut scope_info>,\n                  is_lpad: bool, name: &str, opt_node_info: Option<NodeInfo>)\n     -> block {\n \n@@ -1155,10 +1160,10 @@ pub fn new_block(cx: fn_ctxt, parent: Option<block>, kind: block_kind,\n         };\n         let bcx = mk_block(llbb,\n                            parent,\n-                           kind,\n                            is_lpad,\n                            opt_node_info,\n                            cx);\n+        bcx.scope = scope;\n         for parent.iter().advance |cx| {\n             if cx.unreachable {\n                 Unreachable(bcx);\n@@ -1169,27 +1174,30 @@ pub fn new_block(cx: fn_ctxt, parent: Option<block>, kind: block_kind,\n     }\n }\n \n-pub fn simple_block_scope() -> block_kind {\n-    block_scope(@mut scope_info {\n+pub fn simple_block_scope(parent: Option<@mut scope_info>,\n+                          node_info: Option<NodeInfo>) -> @mut scope_info {\n+    @mut scope_info {\n+        parent: parent,\n         loop_break: None,\n         loop_label: None,\n         cleanups: ~[],\n         cleanup_paths: ~[],\n-        landing_pad: None\n-    })\n+        landing_pad: None,\n+        node_info: node_info,\n+    }\n }\n \n // Use this when you're at the top block of a function or the like.\n pub fn top_scope_block(fcx: fn_ctxt, opt_node_info: Option<NodeInfo>)\n                     -> block {\n-    return new_block(fcx, None, simple_block_scope(), false,\n+    return new_block(fcx, None, Some(simple_block_scope(None, opt_node_info)), false,\n                   \"function top level\", opt_node_info);\n }\n \n pub fn scope_block(bcx: block,\n                    opt_node_info: Option<NodeInfo>,\n                    n: &str) -> block {\n-    return new_block(bcx.fcx, Some(bcx), simple_block_scope(), bcx.is_lpad,\n+    return new_block(bcx.fcx, Some(bcx), Some(simple_block_scope(None, opt_node_info)), bcx.is_lpad,\n                   n, opt_node_info);\n }\n \n@@ -1198,27 +1206,29 @@ pub fn loop_scope_block(bcx: block,\n                         loop_label: Option<ident>,\n                         n: &str,\n                         opt_node_info: Option<NodeInfo>) -> block {\n-    return new_block(bcx.fcx, Some(bcx), block_scope(@mut scope_info {\n+    return new_block(bcx.fcx, Some(bcx), Some(@mut scope_info {\n+        parent: None,\n         loop_break: Some(loop_break),\n         loop_label: loop_label,\n         cleanups: ~[],\n         cleanup_paths: ~[],\n-        landing_pad: None\n+        landing_pad: None,\n+        node_info: opt_node_info,\n     }), bcx.is_lpad, n, opt_node_info);\n }\n \n // Use this when creating a block for the inside of a landing pad.\n pub fn lpad_block(bcx: block, n: &str) -> block {\n-    new_block(bcx.fcx, Some(bcx), block_non_scope, true, n, None)\n+    new_block(bcx.fcx, Some(bcx), None, true, n, None)\n }\n \n // Use this when you're making a general CFG BB within a scope.\n pub fn sub_block(bcx: block, n: &str) -> block {\n-    new_block(bcx.fcx, Some(bcx), block_non_scope, bcx.is_lpad, n, None)\n+    new_block(bcx.fcx, Some(bcx), None, bcx.is_lpad, n, None)\n }\n \n pub fn raw_block(fcx: fn_ctxt, is_lpad: bool, llbb: BasicBlockRef) -> block {\n-    mk_block(llbb, None, block_non_scope, is_lpad, None, fcx)\n+    mk_block(llbb, None, is_lpad, None, fcx)\n }\n \n \n@@ -1277,42 +1287,47 @@ pub fn cleanup_and_leave(bcx: block,\n                 (fmt!(\"cleanup_and_leave(%s)\", cur.to_str())).to_managed());\n         }\n \n-        match cur.kind {\n-            block_scope(inf) if !inf.empty_cleanups() => {\n-                let (sub_cx, dest, inf_cleanups) = {\n-                    let inf = &mut *inf;\n-                    let mut skip = 0;\n-                    let mut dest = None;\n-                    {\n-                        let r = (*inf).cleanup_paths.rev_iter().find_(|cp| cp.target == leave);\n-                        for r.iter().advance |cp| {\n-                            if cp.size == inf.cleanups.len() {\n-                                Br(bcx, cp.dest);\n-                                return;\n+        let mut cur_scope = cur.scope;\n+        loop {\n+            cur_scope = match cur_scope {\n+                Some (inf) if !inf.empty_cleanups() => {\n+                    let (sub_cx, dest, inf_cleanups) = {\n+                        let inf = &mut *inf;\n+                        let mut skip = 0;\n+                        let mut dest = None;\n+                        {\n+                            let r = (*inf).cleanup_paths.rev_iter().find_(|cp| cp.target == leave);\n+                            for r.iter().advance |cp| {\n+                                if cp.size == inf.cleanups.len() {\n+                                    Br(bcx, cp.dest);\n+                                    return;\n+                                }\n+\n+                                skip = cp.size;\n+                                dest = Some(cp.dest);\n                             }\n-\n-                            skip = cp.size;\n-                            dest = Some(cp.dest);\n                         }\n+                        let sub_cx = sub_block(bcx, \"cleanup\");\n+                        Br(bcx, sub_cx.llbb);\n+                        inf.cleanup_paths.push(cleanup_path {\n+                            target: leave,\n+                            size: inf.cleanups.len(),\n+                            dest: sub_cx.llbb\n+                        });\n+                        (sub_cx, dest, inf.cleanups.tailn(skip).to_owned())\n+                    };\n+                    bcx = trans_block_cleanups_(sub_cx,\n+                                                inf_cleanups,\n+                                                is_lpad);\n+                    for dest.iter().advance |&dest| {\n+                        Br(bcx, dest);\n+                        return;\n                     }\n-                    let sub_cx = sub_block(bcx, \"cleanup\");\n-                    Br(bcx, sub_cx.llbb);\n-                    inf.cleanup_paths.push(cleanup_path {\n-                        target: leave,\n-                        size: inf.cleanups.len(),\n-                        dest: sub_cx.llbb\n-                    });\n-                    (sub_cx, dest, inf.cleanups.tailn(skip).to_owned())\n-                };\n-                bcx = trans_block_cleanups_(sub_cx,\n-                                            inf_cleanups,\n-                                            is_lpad);\n-                for dest.iter().advance |&dest| {\n-                    Br(bcx, dest);\n-                    return;\n+                    inf.parent\n                 }\n+                Some(inf) => inf.parent,\n+                None => break\n             }\n-            _ => ()\n         }\n \n         match upto {\n@@ -1353,20 +1368,27 @@ pub fn with_scope(bcx: block,\n            bcx.to_str(), opt_node_info, name);\n     let _indenter = indenter();\n \n-    let scope_cx = scope_block(bcx, opt_node_info, name);\n-    Br(bcx, scope_cx.llbb);\n-    leave_block(f(scope_cx), scope_cx)\n+    let scope = simple_block_scope(bcx.scope, opt_node_info);\n+    bcx.scope = Some(scope);\n+    let ret = f(bcx);\n+    let ret = trans_block_cleanups_(ret, /*bad*/copy scope.cleanups, false);\n+    bcx.scope = scope.parent;\n+    ret\n }\n \n pub fn with_scope_result(bcx: block,\n                          opt_node_info: Option<NodeInfo>,\n                          name: &str,\n                          f: &fn(block) -> Result) -> Result {\n     let _icx = push_ctxt(\"with_scope_result\");\n-    let scope_cx = scope_block(bcx, opt_node_info, name);\n-    Br(bcx, scope_cx.llbb);\n-    let Result {bcx, val} = f(scope_cx);\n-    rslt(leave_block(bcx, scope_cx), val)\n+\n+    let scope = simple_block_scope(bcx.scope, opt_node_info);\n+    bcx.scope = Some(scope);\n+    let Result { bcx: out_bcx, val } = f(bcx);\n+    let out_bcx = trans_block_cleanups_(out_bcx, /*bad*/copy scope.cleanups, false);\n+    bcx.scope = scope.parent;\n+\n+    rslt(out_bcx, val)\n }\n \n pub fn with_scope_datumblock(bcx: block, opt_node_info: Option<NodeInfo>,"}, {"sha": "60165d317d1061162158e2c6d307dd9f667d33cd", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 52, "deletions": 38, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/52abd1cc32f6d08d58dc2b1087ca8c4e129d762e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52abd1cc32f6d08d58dc2b1087ca8c4e129d762e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=52abd1cc32f6d08d58dc2b1087ca8c4e129d762e", "patch": "@@ -318,7 +318,7 @@ pub fn add_clean(bcx: block, val: ValueRef, t: ty::t) {\n     debug!(\"add_clean(%s, %s, %s)\", bcx.to_str(), bcx.val_to_str(val), t.repr(bcx.tcx()));\n \n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n-    do in_scope_cx(bcx) |scope_info| {\n+    do in_scope_cx(bcx, None) |scope_info| {\n         scope_info.cleanups.push(clean(|a| glue::drop_ty(a, val, t), cleanup_type));\n         grow_scope_clean(scope_info);\n     }\n@@ -330,25 +330,36 @@ pub fn add_clean_temp_immediate(cx: block, val: ValueRef, ty: ty::t) {\n            cx.to_str(), cx.val_to_str(val),\n            ty.repr(cx.tcx()));\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n-    do in_scope_cx(cx) |scope_info| {\n+    do in_scope_cx(cx, None) |scope_info| {\n         scope_info.cleanups.push(\n             clean_temp(val, |a| glue::drop_ty_immediate(a, val, ty),\n                        cleanup_type));\n         grow_scope_clean(scope_info);\n     }\n }\n+\n pub fn add_clean_temp_mem(bcx: block, val: ValueRef, t: ty::t) {\n+    add_clean_temp_mem_in_scope_(bcx, None, val, t);\n+}\n+\n+pub fn add_clean_temp_mem_in_scope(bcx: block, scope_id: ast::node_id, val: ValueRef, t: ty::t) {\n+    add_clean_temp_mem_in_scope_(bcx, Some(scope_id), val, t);\n+}\n+\n+pub fn add_clean_temp_mem_in_scope_(bcx: block, scope_id: Option<ast::node_id>,\n+                                    val: ValueRef, t: ty::t) {\n     if !ty::type_needs_drop(bcx.tcx(), t) { return; }\n     debug!(\"add_clean_temp_mem(%s, %s, %s)\",\n            bcx.to_str(), bcx.val_to_str(val),\n            t.repr(bcx.tcx()));\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n-    do in_scope_cx(bcx) |scope_info| {\n+    do in_scope_cx(bcx, scope_id) |scope_info| {\n         scope_info.cleanups.push(clean_temp(val, |a| glue::drop_ty(a, val, t), cleanup_type));\n         grow_scope_clean(scope_info);\n     }\n }\n pub fn add_clean_return_to_mut(bcx: block,\n+                               scope_id: ast::node_id,\n                                root_key: root_map_key,\n                                frozen_val_ref: ValueRef,\n                                bits_val_ref: ValueRef,\n@@ -366,7 +377,7 @@ pub fn add_clean_return_to_mut(bcx: block,\n            bcx.to_str(),\n            bcx.val_to_str(frozen_val_ref),\n            bcx.val_to_str(bits_val_ref));\n-    do in_scope_cx(bcx) |scope_info| {\n+    do in_scope_cx(bcx, Some(scope_id)) |scope_info| {\n         scope_info.cleanups.push(\n             clean_temp(\n                 frozen_val_ref,\n@@ -387,7 +398,7 @@ pub fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n         f\n       }\n     };\n-    do in_scope_cx(cx) |scope_info| {\n+    do in_scope_cx(cx, None) |scope_info| {\n         scope_info.cleanups.push(clean_temp(ptr, free_fn,\n                                       normal_exit_and_unwind));\n         grow_scope_clean(scope_info);\n@@ -399,7 +410,7 @@ pub fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n // this will be more involved. For now, we simply zero out the local, and the\n // drop glue checks whether it is zero.\n pub fn revoke_clean(cx: block, val: ValueRef) {\n-    do in_scope_cx(cx) |scope_info| {\n+    do in_scope_cx(cx, None) |scope_info| {\n         let cleanup_pos = scope_info.cleanups.iter().position_(\n             |cu| match *cu {\n                 clean_temp(v, _, _) if v == val => true,\n@@ -416,27 +427,14 @@ pub fn revoke_clean(cx: block, val: ValueRef) {\n }\n \n pub fn block_cleanups(bcx: block) -> ~[cleanup] {\n-    match bcx.kind {\n-       block_non_scope  => ~[],\n-       block_scope(inf) => /*bad*/copy inf.cleanups\n+    match bcx.scope {\n+       None  => ~[],\n+       Some(inf) => /*bad*/copy inf.cleanups\n     }\n }\n \n-pub enum block_kind {\n-    // A scope at the end of which temporary values created inside of it are\n-    // cleaned up. May correspond to an actual block in the language, but also\n-    // to an implicit scope, for example, calls introduce an implicit scope in\n-    // which the arguments are evaluated and cleaned up.\n-    block_scope(@mut scope_info),\n-\n-    // A non-scope block is a basic block created as a translation artifact\n-    // from translating code that expresses conditional logic rather than by\n-    // explicit { ... } block structure in the source language.  It's called a\n-    // non-scope block because it doesn't introduce a new variable scope.\n-    block_non_scope,\n-}\n-\n pub struct scope_info {\n+    parent: Option<@mut scope_info>,\n     loop_break: Option<block>,\n     loop_label: Option<ident>,\n     // A list of functions that must be run at when leaving this\n@@ -448,6 +446,8 @@ pub struct scope_info {\n     cleanup_paths: ~[cleanup_path],\n     // Unwinding landing pad. Also cleared when cleanups change.\n     landing_pad: Option<BasicBlockRef>,\n+    // info about the AST node this scope originated from, if any\n+    node_info: Option<NodeInfo>,\n }\n \n impl scope_info {\n@@ -503,8 +503,8 @@ pub struct block_ {\n     terminated: bool,\n     unreachable: bool,\n     parent: Option<block>,\n-    // The 'kind' of basic block this is.\n-    kind: block_kind,\n+    // The current scope within this basic block\n+    scope: Option<@mut scope_info>,\n     // Is this block part of a landing pad?\n     is_lpad: bool,\n     // info about the AST node this block originated from, if any\n@@ -514,7 +514,7 @@ pub struct block_ {\n     fcx: fn_ctxt\n }\n \n-pub fn block_(llbb: BasicBlockRef, parent: Option<block>, kind: block_kind,\n+pub fn block_(llbb: BasicBlockRef, parent: Option<block>,\n               is_lpad: bool, node_info: Option<NodeInfo>, fcx: fn_ctxt)\n     -> block_ {\n \n@@ -523,7 +523,7 @@ pub fn block_(llbb: BasicBlockRef, parent: Option<block>, kind: block_kind,\n         terminated: false,\n         unreachable: false,\n         parent: parent,\n-        kind: kind,\n+        scope: None,\n         is_lpad: is_lpad,\n         node_info: node_info,\n         fcx: fcx\n@@ -532,10 +532,10 @@ pub fn block_(llbb: BasicBlockRef, parent: Option<block>, kind: block_kind,\n \n pub type block = @mut block_;\n \n-pub fn mk_block(llbb: BasicBlockRef, parent: Option<block>, kind: block_kind,\n+pub fn mk_block(llbb: BasicBlockRef, parent: Option<block>,\n             is_lpad: bool, node_info: Option<NodeInfo>, fcx: fn_ctxt)\n     -> block {\n-    @mut block_(llbb, parent, kind, is_lpad, node_info, fcx)\n+    @mut block_(llbb, parent, is_lpad, node_info, fcx)\n }\n \n pub struct Result {\n@@ -560,19 +560,33 @@ pub fn val_ty(v: ValueRef) -> Type {\n     }\n }\n \n-pub fn in_scope_cx(cx: block, f: &fn(si: &mut scope_info)) {\n+pub fn in_scope_cx(cx: block, scope_id: Option<ast::node_id>, f: &fn(si: &mut scope_info)) {\n     let mut cur = cx;\n+    let mut cur_scope = cur.scope;\n     loop {\n-        match cur.kind {\n-            block_scope(inf) => {\n-                debug!(\"in_scope_cx: selected cur=%s (cx=%s)\",\n-                       cur.to_str(), cx.to_str());\n-                f(inf);\n-                return;\n+        cur_scope = match cur_scope {\n+            Some(inf) => match scope_id {\n+                Some(wanted) => match inf.node_info {\n+                    Some(NodeInfo { id: actual, _ }) if wanted == actual => {\n+                        debug!(\"in_scope_cx: selected cur=%s (cx=%s)\",\n+                               cur.to_str(), cx.to_str());\n+                        f(inf);\n+                        return;\n+                    },\n+                    _ => inf.parent,\n+                },\n+                None => {\n+                    debug!(\"in_scope_cx: selected cur=%s (cx=%s)\",\n+                           cur.to_str(), cx.to_str());\n+                    f(inf);\n+                    return;\n+                }\n+            },\n+            None => {\n+                cur = block_parent(cur);\n+                cur.scope\n             }\n-            _ => ()\n         }\n-        cur = block_parent(cur);\n     }\n }\n "}, {"sha": "db6a954ee911200c0e883be03ff75021ee8a1ee5", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 40, "deletions": 34, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/52abd1cc32f6d08d58dc2b1087ca8c4e129d762e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52abd1cc32f6d08d58dc2b1087ca8c4e129d762e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=52abd1cc32f6d08d58dc2b1087ca8c4e129d762e", "patch": "@@ -249,42 +249,48 @@ pub fn trans_break_cont(bcx: block,\n     let _icx = push_ctxt(\"trans_break_cont\");\n     // Locate closest loop block, outputting cleanup as we go.\n     let mut unwind = bcx;\n-    let mut target;\n+    let mut cur_scope = unwind.scope;\n+    let mut target = unwind;\n+    let mut quit = false;\n     loop {\n-        match unwind.kind {\n-          block_scope(@scope_info {\n-            loop_break: Some(brk),\n-            loop_label: l,\n-            _\n-          }) => {\n-              // If we're looking for a labeled loop, check the label...\n-              target = if to_end {\n-                  brk\n-              } else {\n-                  unwind\n-              };\n-              match opt_label {\n-                  Some(desired) => match l {\n-                      Some(actual) if actual == desired => break,\n-                      // If it doesn't match the one we want,\n-                      // don't break\n-                      _ => ()\n-                  },\n-                  None => break\n-              }\n-          }\n-          _ => ()\n+        cur_scope = match cur_scope {\n+            Some(@scope_info {\n+                loop_break: Some(brk),\n+                loop_label: l,\n+                parent,\n+                _\n+            }) => {\n+                // If we're looking for a labeled loop, check the label...\n+                target = if to_end {\n+                    brk\n+                } else {\n+                    unwind\n+                };\n+                match opt_label {\n+                    Some(desired) => match l {\n+                        Some(actual) if actual == desired => break,\n+                        // If it doesn't match the one we want,\n+                        // don't break\n+                        _ => parent,\n+                    },\n+                    None => break,\n+                }\n+            }\n+            Some(inf) => inf.parent,\n+            None => {\n+                unwind = match unwind.parent {\n+                    Some(bcx) => bcx,\n+                        // This is a return from a loop body block\n+                        None => {\n+                            Store(bcx, C_bool(!to_end), bcx.fcx.llretptr.get());\n+                            cleanup_and_leave(bcx, None, Some(bcx.fcx.llreturn));\n+                            Unreachable(bcx);\n+                            return bcx;\n+                        }\n+                };\n+                unwind.scope\n+            }\n         }\n-        unwind = match unwind.parent {\n-          Some(bcx) => bcx,\n-          // This is a return from a loop body block\n-          None => {\n-            Store(bcx, C_bool(!to_end), bcx.fcx.llretptr.get());\n-            cleanup_and_leave(bcx, None, Some(bcx.fcx.llreturn));\n-            Unreachable(bcx);\n-            return bcx;\n-          }\n-        };\n     }\n     cleanup_and_Br(bcx, unwind, target.llbb);\n     Unreachable(bcx);"}, {"sha": "0db770b6c8bc3f77066df11424c650f0c7500d62", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52abd1cc32f6d08d58dc2b1087ca8c4e129d762e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52abd1cc32f6d08d58dc2b1087ca8c4e129d762e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=52abd1cc32f6d08d58dc2b1087ca8c4e129d762e", "patch": "@@ -123,7 +123,7 @@ fn root(datum: &Datum,\n     let scratch = scratch_datum(bcx, datum.ty, true);\n     datum.copy_to_datum(bcx, INIT, scratch);\n     let cleanup_bcx = find_bcx_for_scope(bcx, root_info.scope);\n-    add_clean_temp_mem(cleanup_bcx, scratch.val, scratch.ty);\n+    add_clean_temp_mem_in_scope(cleanup_bcx, root_info.scope, scratch.val, scratch.ty);\n \n     // Now, consider also freezing it.\n     match root_info.freeze {\n@@ -168,7 +168,7 @@ fn root(datum: &Datum,\n             }\n \n             add_clean_return_to_mut(\n-                cleanup_bcx, root_key, scratch.val, scratch_bits.val,\n+                cleanup_bcx, root_info.scope, root_key, scratch.val, scratch_bits.val,\n                 filename, line);\n         }\n     }"}]}