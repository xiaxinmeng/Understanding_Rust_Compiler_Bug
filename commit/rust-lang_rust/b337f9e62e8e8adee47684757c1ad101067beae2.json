{"sha": "b337f9e62e8e8adee47684757c1ad101067beae2", "node_id": "C_kwDOAAsO6NoAKGIzMzdmOWU2MmU4ZThhZGVlNDc2ODQ3NTdjMWFkMTAxMDY3YmVhZTI", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-03T16:29:54Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-03T23:09:49Z"}, "message": "Merge `ManualUnwrapOr` into `Matches` lint pass", "tree": {"sha": "2933b1dc221af2a369b5d80e695ddbaf0af8bdf8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2933b1dc221af2a369b5d80e695ddbaf0af8bdf8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b337f9e62e8e8adee47684757c1ad101067beae2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b337f9e62e8e8adee47684757c1ad101067beae2", "html_url": "https://github.com/rust-lang/rust/commit/b337f9e62e8e8adee47684757c1ad101067beae2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b337f9e62e8e8adee47684757c1ad101067beae2/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81e44502ac2e86258dbc880bdf702eab0030c4fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/81e44502ac2e86258dbc880bdf702eab0030c4fb", "html_url": "https://github.com/rust-lang/rust/commit/81e44502ac2e86258dbc880bdf702eab0030c4fb"}], "stats": {"total": 249, "additions": 120, "deletions": 129}, "files": [{"sha": "46af1d8fb09c3539eccfa0a893250dfee6ac5057", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b337f9e62e8e8adee47684757c1ad101067beae2/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b337f9e62e8e8adee47684757c1ad101067beae2/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=b337f9e62e8e8adee47684757c1ad101067beae2", "patch": "@@ -136,14 +136,14 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(manual_map::MANUAL_MAP),\n     LintId::of(manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n     LintId::of(manual_strip::MANUAL_STRIP),\n-    LintId::of(manual_unwrap_or::MANUAL_UNWRAP_OR),\n     LintId::of(map_clone::MAP_CLONE),\n     LintId::of(map_unit_fn::OPTION_MAP_UNIT_FN),\n     LintId::of(map_unit_fn::RESULT_MAP_UNIT_FN),\n     LintId::of(match_result_ok::MATCH_RESULT_OK),\n     LintId::of(match_str_case_mismatch::MATCH_STR_CASE_MISMATCH),\n     LintId::of(matches::COLLAPSIBLE_MATCH),\n     LintId::of(matches::INFALLIBLE_DESTRUCTURING_MATCH),\n+    LintId::of(matches::MANUAL_UNWRAP_OR),\n     LintId::of(matches::MATCH_AS_REF),\n     LintId::of(matches::MATCH_LIKE_MATCHES_MACRO),\n     LintId::of(matches::MATCH_OVERLAPPING_ARM),"}, {"sha": "4f1c3673f853cd9cf8fb451c2f3a2c8ac4e01985", "filename": "clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b337f9e62e8e8adee47684757c1ad101067beae2/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b337f9e62e8e8adee47684757c1ad101067beae2/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=b337f9e62e8e8adee47684757c1ad101067beae2", "patch": "@@ -25,9 +25,9 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(loops::SINGLE_ELEMENT_LOOP),\n     LintId::of(loops::WHILE_LET_LOOP),\n     LintId::of(manual_strip::MANUAL_STRIP),\n-    LintId::of(manual_unwrap_or::MANUAL_UNWRAP_OR),\n     LintId::of(map_unit_fn::OPTION_MAP_UNIT_FN),\n     LintId::of(map_unit_fn::RESULT_MAP_UNIT_FN),\n+    LintId::of(matches::MANUAL_UNWRAP_OR),\n     LintId::of(matches::MATCH_AS_REF),\n     LintId::of(matches::MATCH_SINGLE_BINDING),\n     LintId::of(matches::NEEDLESS_MATCH),"}, {"sha": "cb52000fa55a244a3dc5eefbc575860b263a06d0", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b337f9e62e8e8adee47684757c1ad101067beae2/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b337f9e62e8e8adee47684757c1ad101067beae2/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=b337f9e62e8e8adee47684757c1ad101067beae2", "patch": "@@ -254,7 +254,6 @@ store.register_lints(&[\n     manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n     manual_ok_or::MANUAL_OK_OR,\n     manual_strip::MANUAL_STRIP,\n-    manual_unwrap_or::MANUAL_UNWRAP_OR,\n     map_clone::MAP_CLONE,\n     map_err_ignore::MAP_ERR_IGNORE,\n     map_unit_fn::OPTION_MAP_UNIT_FN,\n@@ -264,6 +263,7 @@ store.register_lints(&[\n     match_str_case_mismatch::MATCH_STR_CASE_MISMATCH,\n     matches::COLLAPSIBLE_MATCH,\n     matches::INFALLIBLE_DESTRUCTURING_MATCH,\n+    matches::MANUAL_UNWRAP_OR,\n     matches::MATCH_AS_REF,\n     matches::MATCH_BOOL,\n     matches::MATCH_LIKE_MATCHES_MACRO,"}, {"sha": "3fdd0db81879065d7fdf8d938303852162dbf5d7", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b337f9e62e8e8adee47684757c1ad101067beae2/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b337f9e62e8e8adee47684757c1ad101067beae2/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=b337f9e62e8e8adee47684757c1ad101067beae2", "patch": "@@ -283,7 +283,6 @@ mod manual_map;\n mod manual_non_exhaustive;\n mod manual_ok_or;\n mod manual_strip;\n-mod manual_unwrap_or;\n mod map_clone;\n mod map_err_ignore;\n mod map_unit_fn;\n@@ -834,7 +833,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(repeat_once::RepeatOnce));\n     store.register_late_pass(|| Box::new(unwrap_in_result::UnwrapInResult));\n     store.register_late_pass(|| Box::new(self_assignment::SelfAssignment));\n-    store.register_late_pass(|| Box::new(manual_unwrap_or::ManualUnwrapOr));\n     store.register_late_pass(|| Box::new(manual_ok_or::ManualOkOr));\n     store.register_late_pass(|| Box::new(float_equality_without_abs::FloatEqualityWithoutAbs));\n     store.register_late_pass(|| Box::new(semicolon_if_nothing_returned::SemicolonIfNothingReturned));"}, {"sha": "b3a91d9f18f5d94ff4d782900996310d161ed6f9", "filename": "clippy_lints/src/manual_unwrap_or.rs", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/81e44502ac2e86258dbc880bdf702eab0030c4fb/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81e44502ac2e86258dbc880bdf702eab0030c4fb/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs?ref=81e44502ac2e86258dbc880bdf702eab0030c4fb", "patch": "@@ -1,123 +0,0 @@\n-use clippy_utils::consts::constant_simple;\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::{indent_of, reindent_multiline, snippet_opt};\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::usage::contains_return_break_continue_macro;\n-use clippy_utils::{in_constant, is_lang_ctor, path_to_local_id, sugg};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{OptionNone, OptionSome, ResultErr, ResultOk};\n-use rustc_hir::{Arm, Expr, ExprKind, PatKind};\n-use rustc_lint::LintContext;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::lint::in_external_macro;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Finds patterns that reimplement `Option::unwrap_or` or `Result::unwrap_or`.\n-    ///\n-    /// ### Why is this bad?\n-    /// Concise code helps focusing on behavior instead of boilerplate.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let foo: Option<i32> = None;\n-    /// match foo {\n-    ///     Some(v) => v,\n-    ///     None => 1,\n-    /// };\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// let foo: Option<i32> = None;\n-    /// foo.unwrap_or(1);\n-    /// ```\n-    #[clippy::version = \"1.49.0\"]\n-    pub MANUAL_UNWRAP_OR,\n-    complexity,\n-    \"finds patterns that can be encoded more concisely with `Option::unwrap_or` or `Result::unwrap_or`\"\n-}\n-\n-declare_lint_pass!(ManualUnwrapOr => [MANUAL_UNWRAP_OR]);\n-\n-impl<'tcx> LateLintPass<'tcx> for ManualUnwrapOr {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if in_external_macro(cx.sess(), expr.span) || in_constant(cx, expr.hir_id) {\n-            return;\n-        }\n-        lint_manual_unwrap_or(cx, expr);\n-    }\n-}\n-\n-fn lint_manual_unwrap_or<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-    fn applicable_or_arm<'a>(cx: &LateContext<'_>, arms: &'a [Arm<'a>]) -> Option<&'a Arm<'a>> {\n-        if_chain! {\n-            if arms.len() == 2;\n-            if arms.iter().all(|arm| arm.guard.is_none());\n-            if let Some((idx, or_arm)) = arms.iter().enumerate().find(|(_, arm)| {\n-                match arm.pat.kind {\n-                    PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n-                    PatKind::TupleStruct(ref qpath, [pat], _) =>\n-                        matches!(pat.kind, PatKind::Wild) && is_lang_ctor(cx, qpath, ResultErr),\n-                    _ => false,\n-                }\n-            });\n-            let unwrap_arm = &arms[1 - idx];\n-            if let PatKind::TupleStruct(ref qpath, [unwrap_pat], _) = unwrap_arm.pat.kind;\n-            if is_lang_ctor(cx, qpath, OptionSome) || is_lang_ctor(cx, qpath, ResultOk);\n-            if let PatKind::Binding(_, binding_hir_id, ..) = unwrap_pat.kind;\n-            if path_to_local_id(unwrap_arm.body, binding_hir_id);\n-            if cx.typeck_results().expr_adjustments(unwrap_arm.body).is_empty();\n-            if !contains_return_break_continue_macro(or_arm.body);\n-            then {\n-                Some(or_arm)\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-\n-    if_chain! {\n-        if let ExprKind::Match(scrutinee, match_arms, _) = expr.kind;\n-        let ty = cx.typeck_results().expr_ty(scrutinee);\n-        if let Some(ty_name) = if is_type_diagnostic_item(cx, ty, sym::Option) {\n-            Some(\"Option\")\n-        } else if is_type_diagnostic_item(cx, ty, sym::Result) {\n-            Some(\"Result\")\n-        } else {\n-            None\n-        };\n-        if let Some(or_arm) = applicable_or_arm(cx, match_arms);\n-        if let Some(or_body_snippet) = snippet_opt(cx, or_arm.body.span);\n-        if let Some(indent) = indent_of(cx, expr.span);\n-        if constant_simple(cx, cx.typeck_results(), or_arm.body).is_some();\n-        then {\n-            let reindented_or_body =\n-                reindent_multiline(or_body_snippet.into(), true, Some(indent));\n-\n-            let suggestion = if scrutinee.span.from_expansion() {\n-                    // we don't want parentheses around macro, e.g. `(some_macro!()).unwrap_or(0)`\n-                    sugg::Sugg::hir_with_macro_callsite(cx, scrutinee, \"..\")\n-                }\n-                else {\n-                    sugg::Sugg::hir(cx, scrutinee, \"..\").maybe_par()\n-                };\n-\n-            span_lint_and_sugg(\n-                cx,\n-                MANUAL_UNWRAP_OR, expr.span,\n-                &format!(\"this pattern reimplements `{}::unwrap_or`\", ty_name),\n-                \"replace with\",\n-                format!(\n-                    \"{}.unwrap_or({})\",\n-                    suggestion,\n-                    reindented_or_body,\n-                ),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-    }\n-}"}, {"sha": "e1111c80f2fe287712dd64b73b656060b9038e3f", "filename": "clippy_lints/src/matches/manual_unwrap_or.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/b337f9e62e8e8adee47684757c1ad101067beae2/clippy_lints%2Fsrc%2Fmatches%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b337f9e62e8e8adee47684757c1ad101067beae2/clippy_lints%2Fsrc%2Fmatches%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmanual_unwrap_or.rs?ref=b337f9e62e8e8adee47684757c1ad101067beae2", "patch": "@@ -0,0 +1,83 @@\n+use clippy_utils::consts::constant_simple;\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::{indent_of, reindent_multiline, snippet_opt};\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::usage::contains_return_break_continue_macro;\n+use clippy_utils::{is_lang_ctor, path_to_local_id, sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::LangItem::{OptionNone, OptionSome, ResultErr, ResultOk};\n+use rustc_hir::{Arm, Expr, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::MANUAL_UNWRAP_OR;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>, scrutinee: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) {\n+    let ty = cx.typeck_results().expr_ty(scrutinee);\n+    if_chain! {\n+        if let Some(ty_name) = if is_type_diagnostic_item(cx, ty, sym::Option) {\n+            Some(\"Option\")\n+        } else if is_type_diagnostic_item(cx, ty, sym::Result) {\n+            Some(\"Result\")\n+        } else {\n+            None\n+        };\n+        if let Some(or_arm) = applicable_or_arm(cx, arms);\n+        if let Some(or_body_snippet) = snippet_opt(cx, or_arm.body.span);\n+        if let Some(indent) = indent_of(cx, expr.span);\n+        if constant_simple(cx, cx.typeck_results(), or_arm.body).is_some();\n+        then {\n+            let reindented_or_body =\n+                reindent_multiline(or_body_snippet.into(), true, Some(indent));\n+\n+            let suggestion = if scrutinee.span.from_expansion() {\n+                    // we don't want parentheses around macro, e.g. `(some_macro!()).unwrap_or(0)`\n+                    sugg::Sugg::hir_with_macro_callsite(cx, scrutinee, \"..\")\n+                }\n+                else {\n+                    sugg::Sugg::hir(cx, scrutinee, \"..\").maybe_par()\n+                };\n+\n+            span_lint_and_sugg(\n+                cx,\n+                MANUAL_UNWRAP_OR, expr.span,\n+                &format!(\"this pattern reimplements `{}::unwrap_or`\", ty_name),\n+                \"replace with\",\n+                format!(\n+                    \"{}.unwrap_or({})\",\n+                    suggestion,\n+                    reindented_or_body,\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}\n+\n+fn applicable_or_arm<'a>(cx: &LateContext<'_>, arms: &'a [Arm<'a>]) -> Option<&'a Arm<'a>> {\n+    if_chain! {\n+        if arms.len() == 2;\n+        if arms.iter().all(|arm| arm.guard.is_none());\n+        if let Some((idx, or_arm)) = arms.iter().enumerate().find(|(_, arm)| {\n+            match arm.pat.kind {\n+                PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n+                PatKind::TupleStruct(ref qpath, [pat], _) =>\n+                    matches!(pat.kind, PatKind::Wild) && is_lang_ctor(cx, qpath, ResultErr),\n+                _ => false,\n+            }\n+        });\n+        let unwrap_arm = &arms[1 - idx];\n+        if let PatKind::TupleStruct(ref qpath, [unwrap_pat], _) = unwrap_arm.pat.kind;\n+        if is_lang_ctor(cx, qpath, OptionSome) || is_lang_ctor(cx, qpath, ResultOk);\n+        if let PatKind::Binding(_, binding_hir_id, ..) = unwrap_pat.kind;\n+        if path_to_local_id(unwrap_arm.body, binding_hir_id);\n+        if cx.typeck_results().expr_adjustments(unwrap_arm.body).is_empty();\n+        if !contains_return_break_continue_macro(or_arm.body);\n+        then {\n+            Some(or_arm)\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "ade47b1ed88e325b99ef919e4c95c99e3b84d91c", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b337f9e62e8e8adee47684757c1ad101067beae2/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b337f9e62e8e8adee47684757c1ad101067beae2/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=b337f9e62e8e8adee47684757c1ad101067beae2", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::source::{snippet_opt, span_starts_with, walk_span_to_context};\n-use clippy_utils::{higher, meets_msrv, msrvs};\n+use clippy_utils::{higher, in_constant, meets_msrv, msrvs};\n use rustc_hir::{Arm, Expr, ExprKind, Local, MatchSource, Pat};\n use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -10,6 +10,7 @@ use rustc_span::{Span, SpanData, SyntaxContext};\n \n mod collapsible_match;\n mod infallible_destructuring_match;\n+mod manual_unwrap_or;\n mod match_as_ref;\n mod match_bool;\n mod match_like_matches;\n@@ -650,6 +651,33 @@ declare_clippy_lint! {\n     \"Nested `match` or `if let` expressions where the patterns may be \\\"collapsed\\\" together.\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Finds patterns that reimplement `Option::unwrap_or` or `Result::unwrap_or`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Concise code helps focusing on behavior instead of boilerplate.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let foo: Option<i32> = None;\n+    /// match foo {\n+    ///     Some(v) => v,\n+    ///     None => 1,\n+    /// };\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// let foo: Option<i32> = None;\n+    /// foo.unwrap_or(1);\n+    /// ```\n+    #[clippy::version = \"1.49.0\"]\n+    pub MANUAL_UNWRAP_OR,\n+    complexity,\n+    \"finds patterns that can be encoded more concisely with `Option::unwrap_or` or `Result::unwrap_or`\"\n+}\n+\n #[derive(Default)]\n pub struct Matches {\n     msrv: Option<RustcVersion>,\n@@ -685,6 +713,7 @@ impl_lint_pass!(Matches => [\n     MATCH_SAME_ARMS,\n     NEEDLESS_MATCH,\n     COLLAPSIBLE_MATCH,\n+    MANUAL_UNWRAP_OR,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Matches {\n@@ -722,6 +751,10 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                     match_as_ref::check(cx, ex, arms, expr);\n                     needless_match::check_match(cx, ex, arms, expr);\n \n+                    if !in_constant(cx, expr.hir_id) {\n+                        manual_unwrap_or::check(cx, expr, ex, arms);\n+                    }\n+\n                     if self.infallible_destructuring_match_linted {\n                         self.infallible_destructuring_match_linted = false;\n                     } else {"}]}