{"sha": "5cfa7d1dfb8a83c24ba3220d6740388546c664b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjZmE3ZDFkZmI4YTgzYzI0YmEzMjIwZDY3NDAzODg1NDZjNjY0Yjk=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-01-08T21:20:38Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-02-14T22:40:03Z"}, "message": "Handle equal regions in opaque type inference", "tree": {"sha": "45541b298bc584e2ffe8c30880f983cbc9c2f7f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45541b298bc584e2ffe8c30880f983cbc9c2f7f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5cfa7d1dfb8a83c24ba3220d6740388546c664b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5cfa7d1dfb8a83c24ba3220d6740388546c664b9", "html_url": "https://github.com/rust-lang/rust/commit/5cfa7d1dfb8a83c24ba3220d6740388546c664b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5cfa7d1dfb8a83c24ba3220d6740388546c664b9/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "728224d1e08f4d28fdc8d9c94b8a553750534435", "url": "https://api.github.com/repos/rust-lang/rust/commits/728224d1e08f4d28fdc8d9c94b8a553750534435", "html_url": "https://github.com/rust-lang/rust/commit/728224d1e08f4d28fdc8d9c94b8a553750534435"}], "stats": {"total": 145, "additions": 127, "deletions": 18}, "files": [{"sha": "f3f392683f68f05884ef247e361ac3341a59dafb", "filename": "src/librustc_mir/borrow_check/region_infer/opaque_types.rs", "status": "modified", "additions": 68, "deletions": 18, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/5cfa7d1dfb8a83c24ba3220d6740388546c664b9/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cfa7d1dfb8a83c24ba3220d6740388546c664b9/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs?ref=5cfa7d1dfb8a83c24ba3220d6740388546c664b9", "patch": "@@ -1,14 +1,50 @@\n-use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n use rustc::ty;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def_id::DefId;\n use rustc_span::Span;\n \n use super::RegionInferenceContext;\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Resolve any opaque types that were encountered while borrow checking\n     /// this item. This is then used to get the type in the `type_of` query.\n+    ///\n+    /// For example consider `fn f<'a>(x: &'a i32) -> impl Sized + 'a { x }`.\n+    /// This is lowered to give HIR something like\n+    ///\n+    /// type _Return<'_a> = impl Sized + '_a;\n+    /// fn f<'a>(x: &'a i32) -> _Return<'a> { x }\n+    ///\n+    /// When checking the return type record the type from the return and the\n+    /// type used in the return value. In this case they might be `_Return<'1>`\n+    /// and `&'2 i32` respectively.\n+    ///\n+    /// Once we to this method, we have completed region inference and want to\n+    /// call `infer_opaque_definition_from_instantiation` to get the inferred\n+    /// type of `_Return<'_a>`. `infer_opaque_definition_from_instantiation`\n+    /// compares lifetimes directly, so we need to map the inference variables\n+    /// back to concrete lifetimes: `'static`, `ReEarlyBound` or `ReFree`.\n+    ///\n+    /// First we map all the lifetimes in the concrete type to an equal\n+    /// universal region that occurs in the concrete type's substs, in this case\n+    /// this would result in `&'1 i32`. We only consider regions in the substs\n+    /// in case there is an equal region that does not. For example, this should\n+    /// be allowed:\n+    /// `fn f<'a: 'b, 'b: 'a>(x: *mut &'b i32) -> impl Sized + 'a { x }`\n+    ///\n+    /// Then we map the regions in both the type and the subst to their\n+    /// `external_name` giving `concrete_type = &'a i32, substs = ['a]`. This\n+    /// will then allow `infer_opaque_definition_from_instantiation` to\n+    /// determine that `_Return<'_a> = &'_a i32`.\n+    ///\n+    /// There's a slight complication around closures. Given\n+    /// `fn f<'a: 'a>() { || {} }` the closure's type is something like\n+    /// `f::<'a>::{{closure}}`. The region parameter from f is essentially\n+    /// ignored by type checking so ends up being inferred to an empty region.\n+    /// Calling `universal_upper_bound` for such a region gives `fr_fn_body`,\n+    /// which has no `external_name` in which case we use `'empty` as the\n+    /// region to pass to `infer_opaque_definition_from_instantiation`.\n     pub(in crate::borrow_check) fn infer_opaque_types(\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n@@ -23,32 +59,46 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     concrete_type, substs\n                 );\n \n-                // Map back to \"concrete\" regions so that errors in\n-                // `infer_opaque_definition_from_instantiation` can show\n-                // sensible region names.\n-                let universal_concrete_type =\n-                    infcx.tcx.fold_regions(&concrete_type, &mut false, |region, _| match region {\n-                        &ty::ReVar(vid) => {\n-                            let universal_bound = self.universal_upper_bound(vid);\n-                            self.definitions[universal_bound]\n-                                .external_name\n-                                .filter(|_| self.eval_equal(universal_bound, vid))\n-                                .unwrap_or(infcx.tcx.lifetimes.re_empty)\n-                        }\n-                        concrete => concrete,\n-                    });\n+                let mut subst_regions = vec![self.universal_regions.fr_static];\n                 let universal_substs =\n-                    infcx.tcx.fold_regions(&substs, &mut false, |region, _| match region {\n+                    infcx.tcx.fold_regions(&substs, &mut false, |region, _| match *region {\n                         ty::ReVar(vid) => {\n-                            self.definitions[*vid].external_name.unwrap_or_else(|| {\n+                            subst_regions.push(vid);\n+                            self.definitions[vid].external_name.unwrap_or_else(|| {\n                                 infcx.tcx.sess.delay_span_bug(\n                                     span,\n                                     \"opaque type with non-universal region substs\",\n                                 );\n                                 infcx.tcx.lifetimes.re_static\n                             })\n                         }\n-                        concrete => concrete,\n+                        _ => {\n+                            infcx.tcx.sess.delay_span_bug(\n+                                span,\n+                                &format!(\"unexpected concrete region in borrowck: {:?}\", region),\n+                            );\n+                            region\n+                        }\n+                    });\n+\n+                subst_regions.sort();\n+                subst_regions.dedup();\n+\n+                let universal_concrete_type =\n+                    infcx.tcx.fold_regions(&concrete_type, &mut false, |region, _| match *region {\n+                        ty::ReVar(vid) => subst_regions\n+                            .iter()\n+                            .find(|ur_vid| self.eval_equal(vid, **ur_vid))\n+                            .and_then(|ur_vid| self.definitions[*ur_vid].external_name)\n+                            .unwrap_or(infcx.tcx.lifetimes.re_root_empty),\n+                        ty::ReLateBound(..) => region,\n+                        _ => {\n+                            infcx.tcx.sess.delay_span_bug(\n+                                span,\n+                                &format!(\"unexpected concrete region in borrowck: {:?}\", region),\n+                            );\n+                            region\n+                        }\n                     });\n \n                 debug!("}, {"sha": "85bc032606f2a155bf3a9922154ec55b1efac09d", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5cfa7d1dfb8a83c24ba3220d6740388546c664b9/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cfa7d1dfb8a83c24ba3220d6740388546c664b9/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=5cfa7d1dfb8a83c24ba3220d6740388546c664b9", "patch": "@@ -1275,6 +1275,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         );\n \n                         if !concrete_is_opaque {\n+                            // Equate concrete_ty (an inference variable) with\n+                            // the renumbered type from typeck.\n                             obligations.add(\n                                 infcx\n                                     .at(&ObligationCause::dummy(), param_env)"}, {"sha": "79db88828b9affb20621ca4f18df140ab994d9d4", "filename": "src/test/ui/impl-trait/equal-hidden-lifetimes.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5cfa7d1dfb8a83c24ba3220d6740388546c664b9/src%2Ftest%2Fui%2Fimpl-trait%2Fequal-hidden-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cfa7d1dfb8a83c24ba3220d6740388546c664b9/src%2Ftest%2Fui%2Fimpl-trait%2Fequal-hidden-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequal-hidden-lifetimes.rs?ref=5cfa7d1dfb8a83c24ba3220d6740388546c664b9", "patch": "@@ -0,0 +1,49 @@\n+// Test that we consider equal regions when checking for hidden regions in\n+// opaque types\n+\n+// check-pass\n+\n+// `'a == 'static` so `&'a i32` is fine as the return type\n+fn equal_regions_static<'a: 'static>(x: &'a i32) -> impl Sized {\n+    //~^ WARNING unnecessary lifetime parameter `'a`\n+    x\n+}\n+\n+// `'a == 'b` so `&'b i32` is fine as the return type\n+fn equal_regions<'a: 'b, 'b: 'a>(x: &'b i32) -> impl Sized + 'a {\n+    let y: &'a i32 = x;\n+    let z: &'b i32 = y;\n+    x\n+}\n+\n+// `'a == 'b` so `&'a i32` is fine as the return type\n+fn equal_regions_rev<'a: 'b, 'b: 'a>(x: &'a i32) -> impl Sized + 'b {\n+    let y: &'a i32 = x;\n+    let z: &'b i32 = y;\n+    x\n+}\n+\n+// `'a == 'b` so `*mut &'b i32` is fine as the return type\n+fn equal_regions_inv<'a: 'b, 'b: 'a>(x: *mut &'b i32) -> impl Sized + 'a {\n+    let y: *mut &'a i32 = x;\n+    let z: *mut &'b i32 = y;\n+    x\n+}\n+\n+// `'a == 'b` so `*mut &'a i32` is fine as the return type\n+fn equal_regions_inv_rev<'a: 'b, 'b: 'a>(x: *mut &'a i32) -> impl Sized + 'b {\n+    let y: *mut &'a i32 = x;\n+    let z: *mut &'b i32 = y;\n+    x\n+}\n+\n+// Should be able to infer `fn(&'static ())` as the return type.\n+fn contravariant_lub<'a, 'b: 'a, 'c: 'a, 'd: 'b + 'c>(\n+    x: fn(&'b ()),\n+    y: fn(&'c ()),\n+    c: bool,\n+) -> impl Sized + 'a {\n+    if c { x } else { y }\n+}\n+\n+fn main() {}"}, {"sha": "eb064b4e14a5e6db9d3205a5b4b94c2daff4d44a", "filename": "src/test/ui/impl-trait/equal-hidden-lifetimes.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5cfa7d1dfb8a83c24ba3220d6740388546c664b9/src%2Ftest%2Fui%2Fimpl-trait%2Fequal-hidden-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5cfa7d1dfb8a83c24ba3220d6740388546c664b9/src%2Ftest%2Fui%2Fimpl-trait%2Fequal-hidden-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequal-hidden-lifetimes.stderr?ref=5cfa7d1dfb8a83c24ba3220d6740388546c664b9", "patch": "@@ -0,0 +1,8 @@\n+warning: unnecessary lifetime parameter `'a`\n+  --> $DIR/equal-hidden-lifetimes.rs:7:25\n+   |\n+LL | fn equal_regions_static<'a: 'static>(x: &'a i32) -> impl Sized {\n+   |                         ^^^^^^^^^^^\n+   |\n+   = help: you can use the `'static` lifetime directly, in place of `'a`\n+"}]}