{"sha": "eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViNzkzNjE2ZGNmMGIxZTRjYzQxNmRlYTNiZWMwZWY1YjgwODM0YTk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-03T23:29:29Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-03T23:55:58Z"}, "message": "rollup merge of #18506 : nikomatsakis/assoc-type-bounds", "tree": {"sha": "5f05f6f406b139dc8b58271b806d0f4811e47d10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f05f6f406b139dc8b58271b806d0f4811e47d10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "html_url": "https://github.com/rust-lang/rust/commit/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8494368d568da3303179cf2d523fc673067540d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8494368d568da3303179cf2d523fc673067540d4", "html_url": "https://github.com/rust-lang/rust/commit/8494368d568da3303179cf2d523fc673067540d4"}, {"sha": "3c84e317210d0eaa9014179c9a998449571ad8aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c84e317210d0eaa9014179c9a998449571ad8aa", "html_url": "https://github.com/rust-lang/rust/commit/3c84e317210d0eaa9014179c9a998449571ad8aa"}], "stats": {"total": 954, "additions": 520, "deletions": 434}, "files": [{"sha": "0074c15defb0e28aa30fc95187aab024eb1fc618", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "patch": "@@ -79,7 +79,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n         e::IIForeignRef(i) => i.id,\n         e::IITraitItemRef(_, &ast::ProvidedMethod(ref m)) => m.id,\n         e::IITraitItemRef(_, &ast::RequiredMethod(ref m)) => m.id,\n-        e::IITraitItemRef(_, &ast::TypeTraitItem(ref ti)) => ti.id,\n+        e::IITraitItemRef(_, &ast::TypeTraitItem(ref ti)) => ti.ty_param.id,\n         e::IIImplItemRef(_, &ast::MethodImplItem(ref m)) => m.id,\n         e::IIImplItemRef(_, &ast::TypeImplItem(ref ti)) => ti.id,\n     };\n@@ -154,7 +154,7 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n                 match *ti {\n                     ast::ProvidedMethod(ref m) => m.pe_ident(),\n                     ast::RequiredMethod(ref ty_m) => ty_m.ident,\n-                    ast::TypeTraitItem(ref ti) => ti.ident,\n+                    ast::TypeTraitItem(ref ti) => ti.ty_param.ident,\n                 }\n             },\n             ast::IIImplItem(_, ref m) => {\n@@ -709,8 +709,9 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n     {\n         let types = self.read_to_vec(|this| Ok(f(this))).unwrap();\n         let selfs = self.read_to_vec(|this| Ok(f(this))).unwrap();\n+        let assocs = self.read_to_vec(|this| Ok(f(this))).unwrap();\n         let fns = self.read_to_vec(|this| Ok(f(this))).unwrap();\n-        VecPerParamSpace::new(types, selfs, fns)\n+        VecPerParamSpace::new(types, selfs, assocs, fns)\n     }\n \n     fn read_vtable_res_with_key(&mut self,"}, {"sha": "4fbffa2a819d55f9b4a74b751d05f73293d6d3c2", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "patch": "@@ -296,8 +296,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                             self.exported_items.insert(m.id);\n                         }\n                         ast::TypeTraitItem(ref t) => {\n-                            debug!(\"typedef {}\", t.id);\n-                            self.exported_items.insert(t.id);\n+                            debug!(\"typedef {}\", t.ty_param.id);\n+                            self.exported_items.insert(t.ty_param.id);\n                         }\n                     }\n                 }"}, {"sha": "ed7d9296c701d2db5773998767ba2c3727a32677", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 34, "deletions": 28, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "patch": "@@ -1564,19 +1564,19 @@ impl<'a> Resolver<'a> {\n                         }\n                         ast::TypeTraitItem(ref associated_type) => {\n                             let def = DefAssociatedTy(local_def(\n-                                    associated_type.id));\n+                                    associated_type.ty_param.id));\n \n                             let name_bindings =\n-                                self.add_child(associated_type.ident.name,\n+                                self.add_child(associated_type.ty_param.ident.name,\n                                                module_parent.clone(),\n                                                ForbidDuplicateTypesAndValues,\n-                                               associated_type.span);\n+                                               associated_type.ty_param.span);\n                             // NB: not IMPORTABLE\n                             name_bindings.define_type(def,\n-                                                      associated_type.span,\n+                                                      associated_type.ty_param.span,\n                                                       PUBLIC);\n \n-                            (associated_type.ident.name, TypeTraitItemKind)\n+                            (associated_type.ty_param.ident.name, TypeTraitItemKind)\n                         }\n                     };\n \n@@ -4223,7 +4223,7 @@ impl<'a> Resolver<'a> {\n                                             impl_items.as_slice());\n             }\n \n-            ItemTrait(ref generics, ref unbound, ref bounds, ref methods) => {\n+            ItemTrait(ref generics, ref unbound, ref bounds, ref trait_items) => {\n                 // Create a new rib for the self type.\n                 let mut self_type_rib = Rib::new(ItemRibKind);\n \n@@ -4251,13 +4251,13 @@ impl<'a> Resolver<'a> {\n                         _ => {}\n                     }\n \n-                    for method in (*methods).iter() {\n-                        // Create a new rib for the method-specific type\n+                    for trait_item in (*trait_items).iter() {\n+                        // Create a new rib for the trait_item-specific type\n                         // parameters.\n                         //\n                         // FIXME #4951: Do we need a node ID here?\n \n-                        match *method {\n+                        match *trait_item {\n                           ast::RequiredMethod(ref ty_m) => {\n                             this.with_type_parameter_rib\n                                 (HasTypeParameters(&ty_m.generics,\n@@ -4292,8 +4292,9 @@ impl<'a> Resolver<'a> {\n                                                                 ProvidedMethod(m.id)),\n                                                   &**m)\n                           }\n-                          ast::TypeTraitItem(_) => {\n-                              visit::walk_trait_item(this, method);\n+                          ast::TypeTraitItem(ref data) => {\n+                              this.resolve_type_parameter(&data.ty_param);\n+                              visit::walk_trait_item(this, trait_item);\n                           }\n                         }\n                     }\n@@ -4482,20 +4483,25 @@ impl<'a> Resolver<'a> {\n     fn resolve_type_parameters(&mut self,\n                                type_parameters: &OwnedSlice<TyParam>) {\n         for type_parameter in type_parameters.iter() {\n-            for bound in type_parameter.bounds.iter() {\n-                self.resolve_type_parameter_bound(type_parameter.id, bound,\n-                                                  TraitBoundingTypeParameter);\n-            }\n-            match &type_parameter.unbound {\n-                &Some(ref unbound) =>\n-                    self.resolve_type_parameter_bound(\n-                        type_parameter.id, unbound, TraitBoundingTypeParameter),\n-                &None => {}\n-            }\n-            match type_parameter.default {\n-                Some(ref ty) => self.resolve_type(&**ty),\n-                None => {}\n-            }\n+            self.resolve_type_parameter(type_parameter);\n+        }\n+    }\n+\n+    fn resolve_type_parameter(&mut self,\n+                              type_parameter: &TyParam) {\n+        for bound in type_parameter.bounds.iter() {\n+            self.resolve_type_parameter_bound(type_parameter.id, bound,\n+                                              TraitBoundingTypeParameter);\n+        }\n+        match &type_parameter.unbound {\n+            &Some(ref unbound) =>\n+                self.resolve_type_parameter_bound(\n+                    type_parameter.id, unbound, TraitBoundingTypeParameter),\n+            &None => {}\n+        }\n+        match type_parameter.default {\n+            Some(ref ty) => self.resolve_type(&**ty),\n+            None => {}\n         }\n     }\n \n@@ -4582,14 +4588,14 @@ impl<'a> Resolver<'a> {\n                         self.resolve_error(trait_reference.path.span,\n                                            format!(\"`{}` is not a trait\",\n                                                    self.path_names_to_string(\n-                                                        &trait_reference.path)));\n+                                                       &trait_reference.path)));\n \n                         // If it's a typedef, give a note\n                         match def {\n                             DefTy(..) => {\n                                 self.session.span_note(\n-                                                trait_reference.path.span,\n-                                                format!(\"`type` aliases cannot \\\n+                                    trait_reference.path.span,\n+                                    format!(\"`type` aliases cannot \\\n                                                         be used for traits\")\n                                                         .as_slice());\n                             }"}, {"sha": "7f6a73c83fa76fb804422d6e371001da8ac06063", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "patch": "@@ -86,7 +86,7 @@ impl<'v> Visitor<'v> for Annotator {\n                 }\n             }\n \n-            TypeTraitItem(ref typedef) => (typedef.id, &typedef.attrs),\n+            TypeTraitItem(ref typedef) => (typedef.ty_param.id, &typedef.attrs),\n         };\n         self.annotate(id, attrs, |v| visit::walk_trait_item(v, t));\n     }"}, {"sha": "a29f99236e0cdf91561ec4ea65a7a876ed5e3db6", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 74, "deletions": 45, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "patch": "@@ -56,17 +56,18 @@ impl Substs {\n                     r: Vec<ty::Region>)\n                     -> Substs\n     {\n-        Substs::new(VecPerParamSpace::new(t, Vec::new(), Vec::new()),\n-                    VecPerParamSpace::new(r, Vec::new(), Vec::new()))\n+        Substs::new(VecPerParamSpace::new(t, Vec::new(), Vec::new(), Vec::new()),\n+                    VecPerParamSpace::new(r, Vec::new(), Vec::new(), Vec::new()))\n     }\n \n     pub fn new_trait(t: Vec<ty::t>,\n                      r: Vec<ty::Region>,\n+                     a: Vec<ty::t>,\n                      s: ty::t)\n                     -> Substs\n     {\n-        Substs::new(VecPerParamSpace::new(t, vec!(s), Vec::new()),\n-                    VecPerParamSpace::new(r, Vec::new(), Vec::new()))\n+        Substs::new(VecPerParamSpace::new(t, vec!(s), a, Vec::new()),\n+                    VecPerParamSpace::new(r, Vec::new(), Vec::new(), Vec::new()))\n     }\n \n     pub fn erased(t: VecPerParamSpace<ty::t>) -> Substs\n@@ -170,29 +171,32 @@ impl RegionSubsts {\n #[deriving(PartialOrd, Ord, PartialEq, Eq,\n            Clone, Hash, Encodable, Decodable, Show)]\n pub enum ParamSpace {\n-    TypeSpace, // Type parameters attached to a type definition, trait, or impl\n-    SelfSpace, // Self parameter on a trait\n-    FnSpace,   // Type parameters attached to a method or fn\n+    TypeSpace,  // Type parameters attached to a type definition, trait, or impl\n+    SelfSpace,  // Self parameter on a trait\n+    AssocSpace, // Assoc types defined in a trait/impl\n+    FnSpace,    // Type parameters attached to a method or fn\n }\n \n impl ParamSpace {\n-    pub fn all() -> [ParamSpace, ..3] {\n-        [TypeSpace, SelfSpace, FnSpace]\n+    pub fn all() -> [ParamSpace, ..4] {\n+        [TypeSpace, SelfSpace, AssocSpace, FnSpace]\n     }\n \n     pub fn to_uint(self) -> uint {\n         match self {\n             TypeSpace => 0,\n             SelfSpace => 1,\n-            FnSpace => 2,\n+            AssocSpace => 2,\n+            FnSpace => 3,\n         }\n     }\n \n     pub fn from_uint(u: uint) -> ParamSpace {\n         match u {\n             0 => TypeSpace,\n             1 => SelfSpace,\n-            2 => FnSpace,\n+            2 => AssocSpace,\n+            3 => FnSpace,\n             _ => panic!(\"Invalid ParamSpace: {}\", u)\n         }\n     }\n@@ -212,14 +216,27 @@ pub struct VecPerParamSpace<T> {\n     // Here is how the representation corresponds to the abstraction\n     // i.e. the \"abstraction function\" AF:\n     //\n-    // AF(self) = (self.content.slice_to(self.type_limit),\n-    //             self.content.slice(self.type_limit, self.self_limit),\n-    //             self.content.slice_from(self.self_limit))\n+    // AF(self) = (self.content[..self.type_limit],\n+    //             self.content[self.type_limit..self.self_limit],\n+    //             self.content[self.self_limit..self.assoc_limit],\n+    //             self.content[self.assoc_limit..])\n     type_limit: uint,\n     self_limit: uint,\n+    assoc_limit: uint,\n     content: Vec<T>,\n }\n \n+/**\n+ * The `split` function converts one `VecPerParamSpace` into this\n+ * `SeparateVecsPerParamSpace` structure.\n+ */\n+pub struct SeparateVecsPerParamSpace<T> {\n+    pub types: Vec<T>,\n+    pub selfs: Vec<T>,\n+    pub assocs: Vec<T>,\n+    pub fns: Vec<T>,\n+}\n+\n impl<T:fmt::Show> fmt::Show for VecPerParamSpace<T> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"VecPerParamSpace {{\"));\n@@ -236,14 +253,16 @@ impl<T> VecPerParamSpace<T> {\n         match space {\n             TypeSpace => (0, self.type_limit),\n             SelfSpace => (self.type_limit, self.self_limit),\n-            FnSpace => (self.self_limit, self.content.len()),\n+            AssocSpace => (self.self_limit, self.assoc_limit),\n+            FnSpace => (self.assoc_limit, self.content.len()),\n         }\n     }\n \n     pub fn empty() -> VecPerParamSpace<T> {\n         VecPerParamSpace {\n             type_limit: 0,\n             self_limit: 0,\n+            assoc_limit: 0,\n             content: Vec::new()\n         }\n     }\n@@ -254,26 +273,33 @@ impl<T> VecPerParamSpace<T> {\n \n     /// `t` is the type space.\n     /// `s` is the self space.\n+    /// `a` is the assoc space.\n     /// `f` is the fn space.\n-    pub fn new(t: Vec<T>, s: Vec<T>, f: Vec<T>) -> VecPerParamSpace<T> {\n+    pub fn new(t: Vec<T>, s: Vec<T>, a: Vec<T>, f: Vec<T>) -> VecPerParamSpace<T> {\n         let type_limit = t.len();\n-        let self_limit = t.len() + s.len();\n+        let self_limit = type_limit + s.len();\n+        let assoc_limit = self_limit + a.len();\n+\n         let mut content = t;\n         content.extend(s.into_iter());\n+        content.extend(a.into_iter());\n         content.extend(f.into_iter());\n+\n         VecPerParamSpace {\n             type_limit: type_limit,\n             self_limit: self_limit,\n+            assoc_limit: assoc_limit,\n             content: content,\n         }\n     }\n \n-    fn new_internal(content: Vec<T>, type_limit: uint, self_limit: uint)\n+    fn new_internal(content: Vec<T>, type_limit: uint, self_limit: uint, assoc_limit: uint)\n                     -> VecPerParamSpace<T>\n     {\n         VecPerParamSpace {\n             type_limit: type_limit,\n             self_limit: self_limit,\n+            assoc_limit: assoc_limit,\n             content: content,\n         }\n     }\n@@ -285,9 +311,10 @@ impl<T> VecPerParamSpace<T> {\n     pub fn push(&mut self, space: ParamSpace, value: T) {\n         let (_, limit) = self.limits(space);\n         match space {\n-            TypeSpace => { self.type_limit += 1; self.self_limit += 1; }\n-            SelfSpace => { self.self_limit += 1; }\n-            FnSpace   => {}\n+            TypeSpace => { self.type_limit += 1; self.self_limit += 1; self.assoc_limit += 1; }\n+            SelfSpace => { self.self_limit += 1; self.assoc_limit += 1; }\n+            AssocSpace => { self.assoc_limit += 1; }\n+            FnSpace => { }\n         }\n         self.content.insert(limit, value);\n     }\n@@ -298,9 +325,10 @@ impl<T> VecPerParamSpace<T> {\n             None\n         } else {\n             match space {\n-                TypeSpace => { self.type_limit -= 1; self.self_limit -= 1; }\n-                SelfSpace => { self.self_limit -= 1; }\n-                FnSpace   => {}\n+                TypeSpace => { self.type_limit -= 1; self.self_limit -= 1; self.assoc_limit -= 1; }\n+                SelfSpace => { self.self_limit -= 1; self.assoc_limit -= 1; }\n+                AssocSpace => { self.assoc_limit -= 1; }\n+                FnSpace => {}\n             }\n             self.content.remove(limit - 1)\n         }\n@@ -386,35 +414,35 @@ impl<T> VecPerParamSpace<T> {\n         let result = self.iter().map(pred).collect();\n         VecPerParamSpace::new_internal(result,\n                                        self.type_limit,\n-                                       self.self_limit)\n+                                       self.self_limit,\n+                                       self.assoc_limit)\n     }\n \n     pub fn map_move<U>(self, pred: |T| -> U) -> VecPerParamSpace<U> {\n-        let (t, s, f) = self.split();\n+        let SeparateVecsPerParamSpace {\n+            types: t,\n+            selfs: s,\n+            assocs: a,\n+            fns: f\n+        } = self.split();\n+\n         VecPerParamSpace::new(t.into_iter().map(|p| pred(p)).collect(),\n                               s.into_iter().map(|p| pred(p)).collect(),\n+                              a.into_iter().map(|p| pred(p)).collect(),\n                               f.into_iter().map(|p| pred(p)).collect())\n     }\n \n-    pub fn split(self) -> (Vec<T>, Vec<T>, Vec<T>) {\n-        // FIXME (#15418): this does two traversals when in principle\n-        // one would suffice.  i.e. change to use `move_iter`.\n-        let VecPerParamSpace { type_limit, self_limit, content } = self;\n-        let mut i = 0;\n-        let (prefix, fn_vec) = content.partition(|_| {\n-            let on_left = i < self_limit;\n-            i += 1;\n-            on_left\n-        });\n+    pub fn split(self) -> SeparateVecsPerParamSpace<T> {\n+        let VecPerParamSpace { type_limit, self_limit, assoc_limit, content } = self;\n \n-        let mut i = 0;\n-        let (type_vec, self_vec) = prefix.partition(|_| {\n-            let on_left = i < type_limit;\n-            i += 1;\n-            on_left\n-        });\n+        let mut content_iter = content.into_iter();\n \n-        (type_vec, self_vec, fn_vec)\n+        SeparateVecsPerParamSpace {\n+            types: content_iter.by_ref().take(type_limit).collect(),\n+            selfs: content_iter.by_ref().take(self_limit - type_limit).collect(),\n+            assocs: content_iter.by_ref().take(assoc_limit - self_limit).collect(),\n+            fns: content_iter.collect()\n+        }\n     }\n \n     pub fn with_vec(mut self, space: ParamSpace, vec: Vec<T>)\n@@ -560,12 +588,13 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                     this.tcx().sess.span_bug(\n                         span,\n                         format!(\"Type parameter `{}` ({}/{}/{}) out of range \\\n-                                 when substituting (root type={})\",\n+                                 when substituting (root type={}) substs={}\",\n                                 p.repr(this.tcx()),\n                                 source_ty.repr(this.tcx()),\n                                 space,\n                                 index,\n-                                this.root_ty.repr(this.tcx())).as_slice());\n+                                this.root_ty.repr(this.tcx()),\n+                                this.substs.repr(this.tcx())).as_slice());\n                 }\n             }\n         }"}, {"sha": "9a2d5b4d4dc0a44d209690893384acaaa3639a64", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "patch": "@@ -1618,7 +1618,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             Ok(o) => o,\n             Err(ErrorReported) => Vec::new()\n         };\n-        let obligations = VecPerParamSpace::new(obligations, Vec::new(), Vec::new());\n+        let obligations = VecPerParamSpace::new(obligations, Vec::new(),\n+                                                Vec::new(), Vec::new());\n         VtableBuiltinData { nested: obligations }\n     }\n \n@@ -1693,6 +1694,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 vec![arguments_tuple.subst(self.tcx(), substs),\n                      new_signature.output.unwrap().subst(self.tcx(), substs)],\n                 vec![],\n+                vec![],\n                 obligation.self_ty())\n         });\n "}, {"sha": "fbd4db959ce0cbbca74fb3b3f7e15ce841d3002c", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "patch": "@@ -205,7 +205,12 @@ pub fn trans_static_method_callee(bcx: Block,\n     // type parameters that belong to the trait but also some that\n     // belong to the method:\n     let rcvr_substs = node_id_substs(bcx, ExprId(expr_id));\n-    let (rcvr_type, rcvr_self, rcvr_method) = rcvr_substs.types.split();\n+    let subst::SeparateVecsPerParamSpace {\n+        types: rcvr_type,\n+        selfs: rcvr_self,\n+        assocs: rcvr_assoc,\n+        fns: rcvr_method\n+    } = rcvr_substs.types.split();\n \n     // Lookup the precise impl being called. To do that, we need to\n     // create a trait reference identifying the self type and other\n@@ -232,6 +237,7 @@ pub fn trans_static_method_callee(bcx: Block,\n     let trait_substs =\n         Substs::erased(VecPerParamSpace::new(rcvr_type,\n                                              rcvr_self,\n+                                             rcvr_assoc,\n                                              Vec::new()));\n     debug!(\"trait_substs={}\", trait_substs.repr(bcx.tcx()));\n     let trait_ref = Rc::new(ty::TraitRef { def_id: trait_id,\n@@ -265,10 +271,16 @@ pub fn trans_static_method_callee(bcx: Block,\n             // that with the `rcvr_method` from before, which tells us\n             // the type parameters from the *method*, to yield\n             // `callee_substs=[[T=int],[],[U=String]]`.\n-            let (impl_type, impl_self, _) = impl_substs.types.split();\n+            let subst::SeparateVecsPerParamSpace {\n+                types: impl_type,\n+                selfs: impl_self,\n+                assocs: impl_assoc,\n+                fns: _\n+            } = impl_substs.types.split();\n             let callee_substs =\n                 Substs::erased(VecPerParamSpace::new(impl_type,\n                                                      impl_self,\n+                                                     impl_assoc,\n                                                      rcvr_method));\n \n             let mth_id = method_with_name(ccx, impl_did, mname);\n@@ -397,12 +409,17 @@ fn combine_impl_and_methods_tps(bcx: Block,\n \n     // Break apart the type parameters from the node and type\n     // parameters from the receiver.\n-    let (_, _, node_method) = node_substs.types.split();\n-    let (rcvr_type, rcvr_self, rcvr_method) = rcvr_substs.types.clone().split();\n+    let node_method = node_substs.types.split().fns;\n+    let subst::SeparateVecsPerParamSpace {\n+        types: rcvr_type,\n+        selfs: rcvr_self,\n+        assocs: rcvr_assoc,\n+        fns: rcvr_method\n+    } = rcvr_substs.types.clone().split();\n     assert!(rcvr_method.is_empty());\n     subst::Substs {\n         regions: subst::ErasedRegions,\n-        types: subst::VecPerParamSpace::new(rcvr_type, rcvr_self, node_method)\n+        types: subst::VecPerParamSpace::new(rcvr_type, rcvr_self, rcvr_assoc, node_method)\n     }\n }\n "}, {"sha": "a94b188cb28bd55d52d8ed75468b29319c3fcc9f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "patch": "@@ -573,10 +573,6 @@ pub struct ctxt<'tcx> {\n     /// Maps def IDs to true if and only if they're associated types.\n     pub associated_types: RefCell<DefIdMap<bool>>,\n \n-    /// Maps def IDs of traits to information about their associated types.\n-    pub trait_associated_types:\n-        RefCell<DefIdMap<Rc<Vec<AssociatedTypeInfo>>>>,\n-\n     /// Caches the results of trait selection. This cache is used\n     /// for things that do not have to do with the parameters in scope.\n     pub selection_cache: traits::SelectionCache,\n@@ -1564,7 +1560,6 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         stability: RefCell::new(stability),\n         capture_modes: capture_modes,\n         associated_types: RefCell::new(DefIdMap::new()),\n-        trait_associated_types: RefCell::new(DefIdMap::new()),\n         selection_cache: traits::SelectionCache::new(),\n         repr_hint_cache: RefCell::new(DefIdMap::new()),\n    }\n@@ -1994,6 +1989,16 @@ impl ItemSubsts {\n     }\n }\n \n+impl ParamBounds {\n+    pub fn empty() -> ParamBounds {\n+        ParamBounds {\n+            builtin_bounds: empty_builtin_bounds(),\n+            trait_bounds: Vec::new(),\n+            region_bounds: Vec::new(),\n+        }\n+    }\n+}\n+\n // Type utilities\n \n pub fn type_is_nil(ty: t) -> bool {\n@@ -4155,18 +4160,6 @@ impl Ord for AssociatedTypeInfo {\n     }\n }\n \n-/// Returns the associated types belonging to the given trait, in parameter\n-/// order.\n-pub fn associated_types_for_trait(cx: &ctxt, trait_id: ast::DefId)\n-                                  -> Rc<Vec<AssociatedTypeInfo>> {\n-    cx.trait_associated_types\n-      .borrow()\n-      .find(&trait_id)\n-      .expect(\"associated_types_for_trait(): trait not found, try calling \\\n-               ensure_associated_types()\")\n-      .clone()\n-}\n-\n pub fn trait_item_def_ids(cx: &ctxt, id: ast::DefId)\n                           -> Rc<Vec<ImplOrTraitItemId>> {\n     lookup_locally_or_in_crate_store(\"trait_item_def_ids\","}, {"sha": "7c8d9309df3b823898f5328117a5991fb06cb9a1", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "patch": "@@ -54,7 +54,7 @@ use middle::def;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem};\n use middle::lang_items::{FnOnceTraitLangItem};\n use middle::resolve_lifetime as rl;\n-use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n+use middle::subst::{FnSpace, TypeSpace, AssocSpace, SelfSpace, Subst, Substs};\n use middle::subst::{VecPerParamSpace};\n use middle::ty;\n use middle::typeck::lookup_def_tcx;\n@@ -215,7 +215,8 @@ fn ast_path_substs<'tcx,AC,RS>(\n                    associated_ty: Option<ty::t>,\n                    path: &ast::Path)\n                    -> Substs\n-                   where AC: AstConv<'tcx>, RS: RegionScope {\n+                   where AC: AstConv<'tcx>, RS: RegionScope\n+{\n     /*!\n      * Given a path `path` that refers to an item `I` with the\n      * declared generics `decl_generics`, returns an appropriate\n@@ -338,17 +339,21 @@ fn ast_path_substs<'tcx,AC,RS>(\n                 substs.types.push(TypeSpace, default);\n             }\n             None => {\n-                // This is an associated type.\n-                substs.types.push(\n-                    TypeSpace,\n-                    this.associated_type_binding(path.span,\n-                                                 associated_ty,\n-                                                 decl_def_id,\n-                                                 param.def_id))\n+                tcx.sess.span_bug(path.span,\n+                                  \"extra parameter without default\");\n             }\n         }\n     }\n \n+    for param in decl_generics.types.get_slice(AssocSpace).iter() {\n+        substs.types.push(\n+            AssocSpace,\n+            this.associated_type_binding(path.span,\n+                                         associated_ty,\n+                                         decl_def_id,\n+                                         param.def_id))\n+    }\n+\n     substs\n }\n \n@@ -628,9 +633,13 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n         a_seq_ty: &ast::Ty,\n         ptr_ty: PointerTy,\n         constr: |ty::t| -> ty::t)\n-        -> ty::t {\n+        -> ty::t\n+{\n     let tcx = this.tcx();\n-    debug!(\"mk_pointer(ptr_ty={})\", ptr_ty);\n+\n+    debug!(\"mk_pointer(ptr_ty={}, a_seq_ty={})\",\n+           ptr_ty,\n+           a_seq_ty.repr(tcx));\n \n     match a_seq_ty.node {\n         ast::TyVec(ref ty) => {\n@@ -730,7 +739,13 @@ fn associated_ty_to_ty<'tcx,AC,RS>(this: &AC,\n                                    trait_type_id: ast::DefId,\n                                    span: Span)\n                                    -> ty::t\n-                                   where AC: AstConv<'tcx>, RS: RegionScope {\n+                                   where AC: AstConv<'tcx>, RS: RegionScope\n+{\n+    debug!(\"associated_ty_to_ty(trait_path={}, for_ast_type={}, trait_type_id={})\",\n+           trait_path.repr(this.tcx()),\n+           for_ast_type.repr(this.tcx()),\n+           trait_type_id.repr(this.tcx()));\n+\n     // Find the trait that this associated type belongs to.\n     let trait_did = match ty::impl_or_trait_item(this.tcx(),\n                                                  trait_type_id).container() {\n@@ -757,9 +772,16 @@ fn associated_ty_to_ty<'tcx,AC,RS>(this: &AC,\n                                           None,\n                                           Some(for_type),\n                                           trait_path);\n+\n+    debug!(\"associated_ty_to_ty(trait_ref={})\",\n+           trait_ref.repr(this.tcx()));\n+\n     let trait_def = this.get_trait_def(trait_did);\n     for type_parameter in trait_def.generics.types.iter() {\n         if type_parameter.def_id == trait_type_id {\n+            debug!(\"associated_ty_to_ty(type_parameter={} substs={})\",\n+                   type_parameter.repr(this.tcx()),\n+                   trait_ref.substs.repr(this.tcx()));\n             return *trait_ref.substs.types.get(type_parameter.space,\n                                                type_parameter.index)\n         }\n@@ -772,7 +794,10 @@ fn associated_ty_to_ty<'tcx,AC,RS>(this: &AC,\n // Parses the programmer's textual representation of a type into our\n // internal notion of a type.\n pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n-        this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> ty::t {\n+        this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> ty::t\n+{\n+    debug!(\"ast_ty_to_ty(ast_ty={})\",\n+           ast_ty.repr(this.tcx()));\n \n     let tcx = this.tcx();\n "}, {"sha": "863f09736ab2784f03de6aee31f8c11f0adc549f", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 192, "deletions": 235, "changes": 427, "blob_url": "https://github.com/rust-lang/rust/blob/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "patch": "@@ -298,13 +298,19 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n                                             &*m.pe_fn_decl())\n                                     }\n                                     ast::TypeTraitItem(ref at) => {\n-                                        tcx.sess.span_bug(at.span,\n+                                        tcx.sess.span_bug(at.ty_param.span,\n                                                           \"there shouldn't \\\n                                                            be a type trait \\\n                                                            item here\")\n                                     }\n                                 });\n \n+                                debug!(\"ty_method_of_trait_method yielded {} \\\n+                                        for method {} of trait {}\",\n+                                       ty_method.repr(ccx.tcx),\n+                                       trait_item.repr(ccx.tcx),\n+                                       local_def(trait_id).repr(ccx.tcx));\n+\n                                 make_method_ty(ccx, &*ty_method);\n \n                                 tcx.impl_or_trait_items\n@@ -315,9 +321,9 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n                             ast::TypeTraitItem(ref ast_associated_type) => {\n                                 let trait_did = local_def(trait_id);\n                                 let associated_type = ty::AssociatedType {\n-                                    name: ast_associated_type.ident.name,\n+                                    name: ast_associated_type.ty_param.ident.name,\n                                     vis: ast::Public,\n-                                    def_id: local_def(ast_associated_type.id),\n+                                    def_id: local_def(ast_associated_type.ty_param.id),\n                                     container: TraitContainer(trait_did),\n                                 };\n \n@@ -345,7 +351,7 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n                                             method.id))\n                                 }\n                                 ast::TypeTraitItem(ref typedef) => {\n-                                    ty::TypeTraitItemId(local_def(typedef.id))\n+                                    ty::TypeTraitItemId(local_def(typedef.ty_param.id))\n                                 }\n                             }\n                         }).collect());\n@@ -460,35 +466,35 @@ fn convert_associated_type(ccx: &CrateCtxt,\n     // associated type.\n     let type_parameter_def = trait_def.generics\n                                       .types\n-                                      .get_slice(subst::TypeSpace)\n+                                      .get_slice(subst::AssocSpace)\n                                       .iter()\n                                       .find(|def| {\n-        def.def_id == local_def(associated_type.id)\n+        def.def_id == local_def(associated_type.ty_param.id)\n     });\n     let type_parameter_def = match type_parameter_def {\n         Some(type_parameter_def) => type_parameter_def,\n         None => {\n-            ccx.tcx().sess.span_bug(associated_type.span,\n+            ccx.tcx().sess.span_bug(associated_type.ty_param.span,\n                                     \"`convert_associated_type()` didn't find \\\n                                      a type parameter ID corresponding to \\\n                                      this type\")\n         }\n     };\n     let param_type = ty::mk_param(ccx.tcx,\n-                                  subst::TypeSpace,\n+                                  type_parameter_def.space,\n                                   type_parameter_def.index,\n-                                  local_def(associated_type.id));\n-    ccx.tcx.tcache.borrow_mut().insert(local_def(associated_type.id),\n+                                  local_def(associated_type.ty_param.id));\n+    ccx.tcx.tcache.borrow_mut().insert(local_def(associated_type.ty_param.id),\n                                        Polytype {\n                                         generics: ty::Generics::empty(),\n                                         ty: param_type,\n                                        });\n-    write_ty_to_tcx(ccx.tcx, associated_type.id, param_type);\n+    write_ty_to_tcx(ccx.tcx, associated_type.ty_param.id, param_type);\n \n     let associated_type = Rc::new(ty::AssociatedType {\n-        name: associated_type.ident.name,\n+        name: associated_type.ty_param.ident.name,\n         vis: ast::Public,\n-        def_id: local_def(associated_type.id),\n+        def_id: local_def(associated_type.ty_param.id),\n         container: TraitContainer(trait_def.trait_ref.def_id),\n     });\n     ccx.tcx\n@@ -780,25 +786,18 @@ impl<'a,'tcx> AstConv<'tcx> for ImplCtxt<'a,'tcx> {\n                                ty: Option<ty::t>,\n                                trait_id: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> ty::t {\n-        ensure_associated_types(self, trait_id);\n-        let associated_type_ids = ty::associated_types_for_trait(self.ccx.tcx,\n-                                                                 trait_id);\n+                               -> ty::t\n+    {\n+        let trait_def = ty::lookup_trait_def(self.tcx(), trait_id);\n         match self.opt_trait_ref_id {\n             Some(trait_ref_id) if trait_ref_id == trait_id => {\n                 // It's an associated type on the trait that we're\n                 // implementing.\n-                let associated_type_id =\n-                    associated_type_ids.iter()\n-                                       .find(|id| {\n-                                           id.def_id == associated_type_id\n-                                       })\n-                                       .expect(\"associated_type_binding(): \\\n-                                                expected associated type ID \\\n-                                                in trait\");\n-                let associated_type =\n-                    ty::impl_or_trait_item(self.ccx.tcx,\n-                                           associated_type_id.def_id);\n+                assert!(trait_def.generics.types\n+                        .get_slice(subst::AssocSpace)\n+                        .iter()\n+                        .any(|type_param_def| type_param_def.def_id == associated_type_id));\n+                let associated_type = ty::impl_or_trait_item(self.ccx.tcx, associated_type_id);\n                 for impl_item in self.impl_items.iter() {\n                     match *impl_item {\n                         ast::MethodImplItem(_) => {}\n@@ -978,9 +977,9 @@ impl<'a,'tcx> AstConv<'tcx> for TraitMethodCtxt<'a,'tcx> {\n                 match *item {\n                     ast::RequiredMethod(_) | ast::ProvidedMethod(_) => {}\n                     ast::TypeTraitItem(ref item) => {\n-                        if local_def(item.id) == associated_type_id {\n+                        if local_def(item.ty_param.id) == associated_type_id {\n                             return ty::mk_param(self.tcx(),\n-                                                subst::TypeSpace,\n+                                                subst::AssocSpace,\n                                                 index,\n                                                 associated_type_id)\n                         }\n@@ -1451,7 +1450,8 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n                        trait_id: ast::NodeId,\n                        generics: &ast::Generics,\n                        items: &[ast::TraitItem])\n-                        -> subst::Substs {\n+                        -> subst::Substs\n+    {\n         // Creates a no-op substitution for the trait's type parameters.\n         let regions =\n             generics.lifetimes\n@@ -1464,32 +1464,35 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n                     .collect();\n \n         // Start with the generics in the type parameters...\n-        let mut types: Vec<_> =\n+        let types: Vec<_> =\n             generics.ty_params\n                     .iter()\n                     .enumerate()\n                     .map(|(i, def)| ty::mk_param(ccx.tcx, subst::TypeSpace,\n                                                  i, local_def(def.id)))\n                     .collect();\n \n-        // ...and add generics synthesized from the associated types.\n-        for item in items.iter() {\n-            match *item {\n+        // ...and also create generics synthesized from the associated types.\n+        let assoc_types: Vec<_> =\n+            items.iter()\n+            .flat_map(|item| match *item {\n                 ast::TypeTraitItem(ref trait_item) => {\n                     let index = types.len();\n-                    types.push(ty::mk_param(ccx.tcx,\n-                                            subst::TypeSpace,\n-                                            index,\n-                                            local_def(trait_item.id)))\n+                    Some(ty::mk_param(ccx.tcx,\n+                                      subst::AssocSpace,\n+                                      index,\n+                                      local_def(trait_item.ty_param.id))).into_iter()\n                 }\n-                ast::RequiredMethod(_) | ast::ProvidedMethod(_) => {}\n-            }\n-        }\n+                ast::RequiredMethod(_) | ast::ProvidedMethod(_) => {\n+                    None.into_iter()\n+                }\n+            })\n+            .collect();\n \n         let self_ty =\n             ty::mk_param(ccx.tcx, subst::SelfSpace, 0, local_def(trait_id));\n \n-        subst::Substs::new_trait(types, regions, self_ty)\n+        subst::Substs::new_trait(types, regions, assoc_types, self_ty)\n     }\n }\n \n@@ -1630,11 +1633,11 @@ fn ty_of_trait_item(ccx: &CrateCtxt, trait_item: &ast::TraitItem)\n                                   \"ty_of_trait_item() on provided method\")\n         }\n         ast::TypeTraitItem(ref associated_type) => {\n-            let parent = ccx.tcx.map.get_parent(associated_type.id);\n+            let parent = ccx.tcx.map.get_parent(associated_type.ty_param.id);\n             let trait_def = match ccx.tcx.map.get(parent) {\n                 ast_map::NodeItem(item) => trait_def_of_item(ccx, &*item),\n                 _ => {\n-                    ccx.tcx.sess.span_bug(associated_type.span,\n+                    ccx.tcx.sess.span_bug(associated_type.ty_param.span,\n                                           \"associated type's parent wasn't \\\n                                            an item?!\")\n                 }\n@@ -1661,38 +1664,33 @@ fn ty_generics_for_type(ccx: &CrateCtxt,\n fn ty_generics_for_trait(ccx: &CrateCtxt,\n                          trait_id: ast::NodeId,\n                          substs: &subst::Substs,\n-                         generics: &ast::Generics,\n+                         ast_generics: &ast::Generics,\n                          items: &[ast::TraitItem])\n                          -> ty::Generics {\n     let mut generics =\n         ty_generics(ccx,\n                     subst::TypeSpace,\n-                    generics.lifetimes.as_slice(),\n-                    generics.ty_params.as_slice(),\n+                    ast_generics.lifetimes.as_slice(),\n+                    ast_generics.ty_params.as_slice(),\n                     ty::Generics::empty(),\n-                    &generics.where_clause,\n+                    &ast_generics.where_clause,\n                     DontCreateTypeParametersForAssociatedTypes);\n \n     // Add in type parameters for any associated types.\n     for item in items.iter() {\n         match *item {\n             ast::TypeTraitItem(ref associated_type) => {\n-                let def = ty::TypeParameterDef {\n-                    space: subst::TypeSpace,\n-                    index: generics.types.len(subst::TypeSpace),\n-                    name: associated_type.ident.name,\n-                    def_id: local_def(associated_type.id),\n-                    bounds: ty::ParamBounds {\n-                        builtin_bounds: ty::empty_builtin_bounds(),\n-                        trait_bounds: Vec::new(),\n-                        region_bounds: Vec::new(),\n-                    },\n-                    associated_with: Some(local_def(trait_id)),\n-                    default: None,\n-                };\n-                ccx.tcx.ty_param_defs.borrow_mut().insert(associated_type.id,\n+                let def =\n+                    get_or_create_type_parameter_def(\n+                        ccx,\n+                        subst::AssocSpace,\n+                        &associated_type.ty_param,\n+                        generics.types.len(subst::TypeSpace),\n+                        &ast_generics.where_clause,\n+                        Some(local_def(trait_id)));\n+                ccx.tcx.ty_param_defs.borrow_mut().insert(associated_type.ty_param.id,\n                                                           def.clone());\n-                generics.types.push(subst::TypeSpace, def);\n+                generics.types.push(subst::AssocSpace, def);\n             }\n             ast::ProvidedMethod(_) | ast::RequiredMethod(_) => {}\n         }\n@@ -1791,86 +1789,17 @@ enum CreateTypeParametersForAssociatedTypesFlag {\n     CreateTypeParametersForAssociatedTypes,\n }\n \n-fn ensure_associated_types<'tcx,AC>(this: &AC, trait_id: ast::DefId)\n-                                    where AC: AstConv<'tcx> {\n-    if this.tcx().trait_associated_types.borrow().contains_key(&trait_id) {\n-        return\n-    }\n-\n-    if trait_id.krate == ast::LOCAL_CRATE {\n-        match this.tcx().map.find(trait_id.node) {\n-            Some(ast_map::NodeItem(item)) => {\n-                match item.node {\n-                    ast::ItemTrait(_, _, _, ref trait_items) => {\n-                        let mut result = Vec::new();\n-                        let mut index = 0;\n-                        for trait_item in trait_items.iter() {\n-                            match *trait_item {\n-                                ast::RequiredMethod(_) |\n-                                ast::ProvidedMethod(_) => {}\n-                                ast::TypeTraitItem(ref associated_type) => {\n-                                    let info = ty::AssociatedTypeInfo {\n-                                        def_id: local_def(associated_type.id),\n-                                        index: index,\n-                                        name: associated_type.ident.name,\n-                                    };\n-                                    result.push(info);\n-                                    index += 1;\n-                                }\n-                            }\n-                        }\n-                        this.tcx()\n-                            .trait_associated_types\n-                            .borrow_mut()\n-                            .insert(trait_id, Rc::new(result));\n-                        return\n-                    }\n-                    _ => {\n-                        this.tcx().sess.bug(\"ensure_associated_types() \\\n-                                             called on non-trait\")\n-                    }\n-                }\n-            }\n-            _ => {\n-                this.tcx().sess.bug(\"ensure_associated_types() called on \\\n-                                     non-trait\")\n-            }\n-        }\n-\n-    }\n-\n-    // Cross-crate case.\n-    let mut result = Vec::new();\n-    let mut index = 0;\n-    let trait_items = ty::trait_items(this.tcx(), trait_id);\n-    for trait_item in trait_items.iter() {\n-        match *trait_item {\n-            ty::MethodTraitItem(_) => {}\n-            ty::TypeTraitItem(ref associated_type) => {\n-                let info = ty::AssociatedTypeInfo {\n-                    def_id: associated_type.def_id,\n-                    index: index,\n-                    name: associated_type.name\n-                };\n-                result.push(info);\n-                index += 1;\n-            }\n-        }\n-    }\n-    this.tcx().trait_associated_types.borrow_mut().insert(trait_id,\n-                                                          Rc::new(result));\n-}\n-\n fn ty_generics<'tcx,AC>(this: &AC,\n                         space: subst::ParamSpace,\n                         lifetime_defs: &[ast::LifetimeDef],\n                         types: &[ast::TyParam],\n                         base_generics: ty::Generics,\n                         where_clause: &ast::WhereClause,\n-                        create_type_parameters_for_associated_types:\n+                        create_type_parameters_for_associated_types_flag:\n                         CreateTypeParametersForAssociatedTypesFlag)\n                         -> ty::Generics\n-                        where AC: AstConv<'tcx> {\n+                        where AC: AstConv<'tcx>\n+{\n     let mut result = base_generics;\n \n     for (i, l) in lifetime_defs.iter().enumerate() {\n@@ -1891,62 +1820,11 @@ fn ty_generics<'tcx,AC>(this: &AC,\n     // First, create the virtual type parameters for associated types if\n     // necessary.\n     let mut associated_types_generics = ty::Generics::empty();\n-    match create_type_parameters_for_associated_types {\n+    match create_type_parameters_for_associated_types_flag {\n         DontCreateTypeParametersForAssociatedTypes => {}\n         CreateTypeParametersForAssociatedTypes => {\n-            let mut index = 0;\n-            for param in types.iter() {\n-                for bound in param.bounds.iter() {\n-                    match *bound {\n-                        ast::TraitTyParamBound(ref trait_bound) => {\n-                            match lookup_def_tcx(this.tcx(),\n-                                                 trait_bound.path.span,\n-                                                 trait_bound.ref_id) {\n-                                def::DefTrait(trait_did) => {\n-                                    ensure_associated_types(this, trait_did);\n-                                    let associated_types =\n-                                        ty::associated_types_for_trait(\n-                                            this.tcx(),\n-                                            trait_did);\n-                                    for associated_type_info in\n-                                            associated_types.iter() {\n-                                        let associated_type_trait_item =\n-                                            ty::impl_or_trait_item(\n-                                                this.tcx(),\n-                                                associated_type_info.def_id);\n-                                        let def = ty::TypeParameterDef {\n-                                            name: associated_type_trait_item.name(),\n-                                            def_id: associated_type_info.def_id,\n-                                            space: space,\n-                                            index: types.len() + index,\n-                                            bounds: ty::ParamBounds {\n-                                                builtin_bounds:\n-                                                ty::empty_builtin_bounds(),\n-                                                trait_bounds: Vec::new(),\n-                                                region_bounds: Vec::new(),\n-                                            },\n-                                            associated_with: {\n-                                                Some(local_def(param.id))\n-                                            },\n-                                            default: None,\n-                                        };\n-                                        associated_types_generics.types\n-                                                                 .push(space,\n-                                                                       def);\n-                                        index += 1;\n-                                    }\n-                                }\n-                                _ => {\n-                                    this.tcx().sess.span_bug(trait_bound.path\n-                                                                        .span,\n-                                                             \"not a trait?!\")\n-                                }\n-                            }\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-            }\n+            create_type_parameters_for_associated_types(this, space, types,\n+                                                        &mut associated_types_generics);\n         }\n     }\n \n@@ -1960,7 +1838,8 @@ fn ty_generics<'tcx,AC>(this: &AC,\n                                                    space,\n                                                    param,\n                                                    i,\n-                                                   where_clause);\n+                                                   where_clause,\n+                                                   None);\n         debug!(\"ty_generics: def for type param: {}, {}\",\n                def.repr(this.tcx()),\n                space);\n@@ -1981,62 +1860,140 @@ fn ty_generics<'tcx,AC>(this: &AC,\n \n     return result;\n \n-    fn get_or_create_type_parameter_def<'tcx,AC>(\n-                                        this: &AC,\n-                                        space: subst::ParamSpace,\n-                                        param: &ast::TyParam,\n-                                        index: uint,\n-                                        where_clause: &ast::WhereClause)\n-                                        -> ty::TypeParameterDef\n-                                        where AC: AstConv<'tcx> {\n-        match this.tcx().ty_param_defs.borrow().find(&param.id) {\n-            Some(d) => { return (*d).clone(); }\n-            None => { }\n+    fn create_type_parameters_for_associated_types<'tcx,AC>(\n+        this: &AC,\n+        space: subst::ParamSpace,\n+        types: &[ast::TyParam],\n+        associated_types_generics: &mut ty::Generics)\n+        where AC: AstConv<'tcx>\n+    {\n+        // The idea here is roughly as follows. We start with\n+        // an item that is paramerized by various type parameters\n+        // with bounds:\n+        //\n+        //    fn foo<T:Iterator>(t: T) { ... }\n+        //\n+        // The traits in those bounds declare associated types:\n+        //\n+        //    trait Iterator { type Elem; ... }\n+        //\n+        // And we rewrite the original function so that every associated\n+        // type is bound to some fresh type parameter:\n+        //\n+        //    fn foo<A,T:Iterator<Elem=A>>(t: T) { ... }\n+\n+        // Number of synthetic type parameters created thus far\n+        let mut index = 0;\n+\n+        // Iterate over the each type parameter `T` (from the example)\n+        for param in types.iter() {\n+            // Iterate over the bound `Iterator`\n+            for bound in param.bounds.iter() {\n+                // In the above example, `ast_trait_ref` is `Iterator`.\n+                let ast_trait_ref = match *bound {\n+                    ast::TraitTyParamBound(ref r) => r,\n+                    ast::UnboxedFnTyParamBound(..) => { continue; }\n+                    ast::RegionTyParamBound(..) => { continue; }\n+                };\n+\n+                let trait_def_id =\n+                    match lookup_def_tcx(this.tcx(),\n+                                         ast_trait_ref.path.span,\n+                                         ast_trait_ref.ref_id) {\n+                        def::DefTrait(trait_def_id) => trait_def_id,\n+                        _ => {\n+                            this.tcx().sess.span_bug(ast_trait_ref.path.span,\n+                                                     \"not a trait?!\")\n+                        }\n+                    };\n+\n+                // trait_def_id is def-id of `Iterator`\n+                let trait_def = ty::lookup_trait_def(this.tcx(), trait_def_id);\n+                let associated_type_defs = trait_def.generics.types.get_slice(subst::AssocSpace);\n+\n+                // Iterate over each associated type `Elem`\n+                for associated_type_def in associated_type_defs.iter() {\n+                    // Create the fresh type parameter `A`\n+                    let def = ty::TypeParameterDef {\n+                        name: associated_type_def.name,\n+                        def_id: associated_type_def.def_id,\n+                        space: space,\n+                        index: types.len() + index,\n+                        bounds: ty::ParamBounds {\n+                            builtin_bounds: associated_type_def.bounds.builtin_bounds,\n+\n+                            // FIXME(#18178) -- we should add the other bounds, but\n+                            // that requires subst and more logic\n+                            trait_bounds: Vec::new(),\n+                            region_bounds: Vec::new(),\n+                        },\n+                        associated_with: Some(local_def(param.id)),\n+                        default: None,\n+                    };\n+                    associated_types_generics.types.push(space, def);\n+                    index += 1;\n+                }\n+            }\n         }\n+    }\n+}\n \n-        let param_ty = ty::ParamTy::new(space, index, local_def(param.id));\n-        let bounds = compute_bounds(this,\n-                                    param.ident.name,\n-                                    param_ty,\n-                                    param.bounds.as_slice(),\n-                                    &param.unbound,\n-                                    param.span,\n-                                    where_clause);\n-        let default = match param.default {\n-            None => None,\n-            Some(ref path) => {\n-                let ty = ast_ty_to_ty(this, &ExplicitRscope, &**path);\n-                let cur_idx = index;\n-\n-                ty::walk_ty(ty, |t| {\n-                    match ty::get(t).sty {\n-                        ty::ty_param(p) => if p.idx > cur_idx {\n+fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n+                                             space: subst::ParamSpace,\n+                                             param: &ast::TyParam,\n+                                             index: uint,\n+                                             where_clause: &ast::WhereClause,\n+                                             associated_with: Option<ast::DefId>)\n+                                             -> ty::TypeParameterDef\n+    where AC: AstConv<'tcx>\n+{\n+    match this.tcx().ty_param_defs.borrow().find(&param.id) {\n+        Some(d) => { return (*d).clone(); }\n+        None => { }\n+    }\n+\n+    let param_ty = ty::ParamTy::new(space, index, local_def(param.id));\n+    let bounds = compute_bounds(this,\n+                                param.ident.name,\n+                                param_ty,\n+                                param.bounds.as_slice(),\n+                                &param.unbound,\n+                                param.span,\n+                                where_clause);\n+    let default = match param.default {\n+        None => None,\n+        Some(ref path) => {\n+            let ty = ast_ty_to_ty(this, &ExplicitRscope, &**path);\n+            let cur_idx = index;\n+\n+            ty::walk_ty(ty, |t| {\n+                match ty::get(t).sty {\n+                    ty::ty_param(p) => if p.idx > cur_idx {\n                         span_err!(this.tcx().sess, path.span, E0128,\n                                   \"type parameters with a default cannot use \\\n                                    forward declared identifiers\");\n                         },\n                         _ => {}\n                     }\n-                });\n+            });\n \n-                Some(ty)\n-            }\n-        };\n+            Some(ty)\n+        }\n+    };\n \n-        let def = ty::TypeParameterDef {\n-            space: space,\n-            index: index,\n-            name: param.ident.name,\n-            def_id: local_def(param.id),\n-            associated_with: None,\n-            bounds: bounds,\n-            default: default\n-        };\n+    let def = ty::TypeParameterDef {\n+        space: space,\n+        index: index,\n+        name: param.ident.name,\n+        def_id: local_def(param.id),\n+        associated_with: associated_with,\n+        bounds: bounds,\n+        default: default\n+    };\n \n-        this.tcx().ty_param_defs.borrow_mut().insert(param.id, def.clone());\n+    this.tcx().ty_param_defs.borrow_mut().insert(param.id, def.clone());\n \n-        def\n-    }\n+    def\n }\n \n fn compute_bounds<'tcx,AC>(this: &AC,"}, {"sha": "55c3c23685357e31e0ecc54e2fbd1092004c4cfc", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "patch": "@@ -774,10 +774,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         assert!(generics.regions.len(subst::FnSpace) == 0);\n \n         let type_parameter_count = generics.types.len(subst::TypeSpace);\n+        let type_parameters = self.next_ty_vars(type_parameter_count);\n+\n         let region_param_defs = generics.regions.get_slice(subst::TypeSpace);\n         let regions = self.region_vars_for_defs(span, region_param_defs);\n-        let type_parameters = self.next_ty_vars(type_parameter_count);\n-        subst::Substs::new_trait(type_parameters, regions, self_ty)\n+\n+        let assoc_type_parameter_count = generics.types.len(subst::AssocSpace);\n+        let assoc_type_parameters = self.next_ty_vars(assoc_type_parameter_count);\n+\n+        subst::Substs::new_trait(type_parameters, regions, assoc_type_parameters, self_ty)\n     }\n \n     pub fn fresh_bound_region(&self, binder_id: ast::NodeId) -> ty::Region {\n@@ -791,7 +796,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn ty_to_string(&self, t: ty::t) -> String {\n         ty_to_string(self.tcx,\n-                  self.resolve_type_vars_if_possible(t))\n+                     self.resolve_type_vars_if_possible(t))\n     }\n \n     pub fn tys_to_string(&self, ts: &[ty::t]) -> String {"}, {"sha": "fb80b9f30f5df8a3f48b1b8c8f50f4ba432cb227", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 46, "deletions": 20, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "patch": "@@ -425,7 +425,13 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n         }\n         ty_infer(infer_ty) => infer_ty_to_string(cx, infer_ty),\n         ty_err => \"[type error]\".to_string(),\n-        ty_param(ref param_ty) => param_ty.repr(cx),\n+        ty_param(ref param_ty) => {\n+            if cx.sess.verbose() {\n+                param_ty.repr(cx)\n+            } else {\n+                param_ty.user_string(cx)\n+            }\n+        }\n         ty_enum(did, ref substs) | ty_struct(did, ref substs) => {\n             let base = ty::item_path_str(cx, did);\n             let generics = ty::lookup_item_type(cx, did).generics;\n@@ -481,6 +487,17 @@ pub fn parameterized(cx: &ctxt,\n                      generics: &ty::Generics)\n                      -> String\n {\n+    if cx.sess.verbose() {\n+        if substs.is_noop() {\n+            return format!(\"{}\", base);\n+        } else {\n+            return format!(\"{}<{},{}>\",\n+                           base,\n+                           substs.regions.repr(cx),\n+                           substs.types.repr(cx));\n+        }\n+    }\n+\n     let mut strs = Vec::new();\n \n     match substs.regions {\n@@ -505,7 +522,7 @@ pub fn parameterized(cx: &ctxt,\n     let tps = substs.types.get_slice(subst::TypeSpace);\n     let ty_params = generics.types.get_slice(subst::TypeSpace);\n     let has_defaults = ty_params.last().map_or(false, |def| def.default.is_some());\n-    let num_defaults = if has_defaults && !cx.sess.verbose() {\n+    let num_defaults = if has_defaults {\n         ty_params.iter().zip(tps.iter()).rev().take_while(|&(def, &actual)| {\n             match def.default {\n                 Some(default) => default.subst(cx, substs) == actual,\n@@ -520,18 +537,6 @@ pub fn parameterized(cx: &ctxt,\n         strs.push(ty_to_string(cx, *t))\n     }\n \n-    if cx.sess.verbose() {\n-        for t in substs.types.get_slice(subst::SelfSpace).iter() {\n-            strs.push(format!(\"self {}\", t.repr(cx)));\n-        }\n-\n-        // generally there shouldn't be any substs in the fn param\n-        // space, but in verbose mode, print them out.\n-        for t in substs.types.get_slice(subst::FnSpace).iter() {\n-            strs.push(format!(\"fn {}\", t.repr(cx)));\n-        }\n-    }\n-\n     if strs.len() > 0u {\n         format!(\"{}<{}>\", base, strs.connect(\", \"))\n     } else {\n@@ -668,10 +673,11 @@ impl Repr for subst::Substs {\n \n impl<T:Repr> Repr for subst::VecPerParamSpace<T> {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        format!(\"[{};{};{}]\",\n-                       self.get_slice(subst::TypeSpace).repr(tcx),\n-                       self.get_slice(subst::SelfSpace).repr(tcx),\n-                       self.get_slice(subst::FnSpace).repr(tcx))\n+        format!(\"[{};{};{};{}]\",\n+                self.get_slice(subst::TypeSpace).repr(tcx),\n+                self.get_slice(subst::SelfSpace).repr(tcx),\n+                self.get_slice(subst::AssocSpace).repr(tcx),\n+                self.get_slice(subst::FnSpace).repr(tcx))\n     }\n }\n \n@@ -726,7 +732,7 @@ impl Repr for ty::TraitRef {\n     fn repr(&self, tcx: &ctxt) -> String {\n         let base = ty::item_path_str(tcx, self.def_id);\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n-        format!(\"<{} as {}>\",\n+        format!(\"<{} : {}>\",\n                 self.substs.self_ty().repr(tcx),\n                 parameterized(tcx, base.as_slice(), &self.substs, &trait_def.generics))\n     }\n@@ -741,6 +747,19 @@ impl Repr for ty::TraitDef {\n     }\n }\n \n+impl Repr for ast::TraitItem {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n+        match *self {\n+            ast::RequiredMethod(ref data) => format!(\"RequiredMethod({}, id={})\",\n+                                                     data.ident, data.id),\n+            ast::ProvidedMethod(ref data) => format!(\"ProvidedMethod(id={})\",\n+                                                     data.id),\n+            ast::TypeTraitItem(ref data) => format!(\"TypeTraitItem({}, id={})\",\n+                                                     data.ty_param.ident, data.ty_param.id),\n+        }\n+    }\n+}\n+\n impl Repr for ast::Expr {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"expr({}: {})\", self.id, pprust::expr_to_string(self))\n@@ -759,6 +778,12 @@ impl UserString for ast::Path {\n     }\n }\n \n+impl Repr for ast::Ty {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n+        format!(\"type({})\", pprust::ty_to_string(self))\n+    }\n+}\n+\n impl Repr for ast::Item {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"item({})\", tcx.map.node_to_string(self.id))\n@@ -1262,7 +1287,8 @@ impl UserString for ParamTy {\n \n impl Repr for ParamTy {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        self.user_string(tcx)\n+        let ident = self.user_string(tcx);\n+        format!(\"{}/{}.{}\", ident, self.space, self.idx)\n     }\n }\n "}, {"sha": "f96b3916f06dee31cdf5a2f6ae16b2f4a680ac8f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "patch": "@@ -2203,12 +2203,12 @@ impl Clean<Stability> for attr::Stability {\n impl Clean<Item> for ast::AssociatedType {\n     fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n-            source: self.span.clean(cx),\n-            name: Some(self.ident.clean(cx)),\n+            source: self.ty_param.span.clean(cx),\n+            name: Some(self.ty_param.ident.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             inner: AssociatedTypeItem,\n             visibility: None,\n-            def_id: ast_util::local_def(self.id),\n+            def_id: ast_util::local_def(self.ty_param.id),\n             stability: None,\n         }\n     }"}, {"sha": "7fb93698219463bacbb87903b6ee877a760e172d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "patch": "@@ -861,10 +861,8 @@ pub enum ImplItem {\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct AssociatedType {\n-    pub id: NodeId,\n-    pub span: Span,\n-    pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n+    pub ty_param: TyParam,\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]"}, {"sha": "f049b964ff33d415d77acf27528c60ebd219de52", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "patch": "@@ -405,7 +405,9 @@ impl<'ast> Map<'ast> {\n                         MethMac(_) => panic!(\"no path elem for {}\", node),\n                     }\n                 }\n-                TypeTraitItem(ref m) => PathName(m.ident.name),\n+                TypeTraitItem(ref m) => {\n+                    PathName(m.ty_param.ident.name)\n+                }\n             },\n             NodeVariant(v) => PathName(v.node.name.name),\n             _ => panic!(\"no path elem for {}\", node)\n@@ -510,7 +512,7 @@ impl<'ast> Map<'ast> {\n                 match *trait_method {\n                     RequiredMethod(ref type_method) => type_method.span,\n                     ProvidedMethod(ref method) => method.span,\n-                    TypeTraitItem(ref typedef) => typedef.span,\n+                    TypeTraitItem(ref typedef) => typedef.ty_param.span,\n                 }\n             }\n             Some(NodeImplItem(ref impl_item)) => {\n@@ -650,7 +652,7 @@ impl Named for TraitItem {\n         match *self {\n             RequiredMethod(ref tm) => tm.ident.name,\n             ProvidedMethod(ref m) => m.name(),\n-            TypeTraitItem(ref at) => at.ident.name,\n+            TypeTraitItem(ref at) => at.ty_param.ident.name,\n         }\n     }\n }\n@@ -783,7 +785,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n                             self.insert(m.id, NodeTraitItem(tm));\n                         }\n                         TypeTraitItem(ref typ) => {\n-                            self.insert(typ.id, NodeTraitItem(tm));\n+                            self.insert(typ.ty_param.id, NodeTraitItem(tm));\n                         }\n                     }\n                 }\n@@ -976,7 +978,7 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n             let trait_item_id = match *trait_item {\n                 ProvidedMethod(ref m) => m.id,\n                 RequiredMethod(ref m) => m.id,\n-                TypeTraitItem(ref ty) => ty.id,\n+                TypeTraitItem(ref ty) => ty.ty_param.id,\n             };\n \n             collector.insert(trait_item_id, NodeTraitItem(trait_item));\n@@ -1080,7 +1082,7 @@ fn node_id_to_string(map: &Map, id: NodeId) -> String {\n                 }\n                 TypeTraitItem(ref t) => {\n                     format!(\"type item {} in {} (id={})\",\n-                            token::get_ident(t.ident),\n+                            token::get_ident(t.ty_param.ident),\n                             map.path_to_string(id),\n                             id)\n                 }"}, {"sha": "3aa60236d709a6f7f7822ab6f3a6e1a23fa097ba", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "patch": "@@ -524,7 +524,7 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n         match *tm {\n             ast::RequiredMethod(ref m) => self.operation.visit_id(m.id),\n             ast::ProvidedMethod(ref m) => self.operation.visit_id(m.id),\n-            ast::TypeTraitItem(ref typ) => self.operation.visit_id(typ.id),\n+            ast::TypeTraitItem(ref typ) => self.operation.visit_id(typ.ty_param.id),\n         }\n         visit::walk_trait_item(self, tm);\n     }"}, {"sha": "7701f495f726fcb72543f66d2761eb5901fc0607", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "patch": "@@ -260,7 +260,7 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n             ast::RequiredMethod(_) | ast::ProvidedMethod(_) => {}\n             ast::TypeTraitItem(ref ti) => {\n                 self.gate_feature(\"associated_types\",\n-                                  ti.span,\n+                                  ti.ty_param.span,\n                                   \"associated types are experimental\")\n             }\n         }"}, {"sha": "6535c8e89fd4e79c22a2ca7d5265169982fb505a", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "patch": "@@ -793,19 +793,16 @@ pub fn noop_fold_typedef<T>(t: Typedef, folder: &mut T)\n \n pub fn noop_fold_associated_type<T>(at: AssociatedType, folder: &mut T)\n                                     -> AssociatedType\n-                                    where T: Folder {\n-    let new_id = folder.new_id(at.id);\n-    let new_span = folder.new_span(at.span);\n-    let new_ident = folder.fold_ident(at.ident);\n+                                    where T: Folder\n+{\n     let new_attrs = at.attrs\n                       .iter()\n                       .map(|attr| folder.fold_attribute((*attr).clone()))\n                       .collect();\n+    let new_param = folder.fold_ty_param(at.ty_param);\n     ast::AssociatedType {\n-        ident: new_ident,\n         attrs: new_attrs,\n-        id: new_id,\n-        span: new_span,\n+        ty_param: new_param,\n     }\n }\n "}, {"sha": "37b9a0793b412696996442d488751a2a78454eb7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "patch": "@@ -1229,16 +1229,13 @@ impl<'a> Parser<'a> {\n     /// Parses `type Foo;` in a trait declaration only. The `type` keyword has\n     /// already been parsed.\n     fn parse_associated_type(&mut self, attrs: Vec<Attribute>)\n-                             -> AssociatedType {\n-        let lo = self.span.lo;\n-        let ident = self.parse_ident();\n-        let hi = self.span.hi;\n+                             -> AssociatedType\n+    {\n+        let ty_param = self.parse_ty_param();\n         self.expect(&token::Semi);\n         AssociatedType {\n-            id: ast::DUMMY_NODE_ID,\n-            span: mk_sp(lo, hi),\n-            ident: ident,\n             attrs: attrs,\n+            ty_param: ty_param,\n         }\n     }\n "}, {"sha": "4cae3691f2ab66605b1665facf5b231090f26ef7", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "patch": "@@ -815,9 +815,11 @@ impl<'a> State<'a> {\n     }\n \n     fn print_associated_type(&mut self, typedef: &ast::AssociatedType)\n-                             -> IoResult<()> {\n+                             -> IoResult<()>\n+    {\n+        try!(self.print_outer_attributes(typedef.attrs[]));\n         try!(self.word_space(\"type\"));\n-        try!(self.print_ident(typedef.ident));\n+        try!(self.print_ty_param(&typedef.ty_param));\n         word(&mut self.s, \";\")\n     }\n \n@@ -2431,30 +2433,34 @@ impl<'a> State<'a> {\n             } else {\n                 let idx = idx - generics.lifetimes.len();\n                 let param = generics.ty_params.get(idx);\n-                match param.unbound {\n-                    Some(TraitTyParamBound(ref tref)) => {\n-                        try!(s.print_trait_ref(tref));\n-                        try!(s.word_space(\"?\"));\n-                    }\n-                    _ => {}\n-                }\n-                try!(s.print_ident(param.ident));\n-                try!(s.print_bounds(\":\", &param.bounds));\n-                match param.default {\n-                    Some(ref default) => {\n-                        try!(space(&mut s.s));\n-                        try!(s.word_space(\"=\"));\n-                        s.print_type(&**default)\n-                    }\n-                    _ => Ok(())\n-                }\n+                s.print_ty_param(param)\n             }\n         }));\n \n         try!(word(&mut self.s, \">\"));\n         Ok(())\n     }\n \n+    pub fn print_ty_param(&mut self, param: &ast::TyParam) -> IoResult<()> {\n+        match param.unbound {\n+            Some(TraitTyParamBound(ref tref)) => {\n+                try!(self.print_trait_ref(tref));\n+                try!(self.word_space(\"?\"));\n+            }\n+            _ => {}\n+        }\n+        try!(self.print_ident(param.ident));\n+        try!(self.print_bounds(\":\", &param.bounds));\n+        match param.default {\n+            Some(ref default) => {\n+                try!(space(&mut self.s));\n+                try!(self.word_space(\"=\"));\n+                self.print_type(&**default)\n+            }\n+            _ => Ok(())\n+        }\n+    }\n+\n     pub fn print_where_clause(&mut self, generics: &ast::Generics)\n                               -> IoResult<()> {\n         if generics.where_clause.predicates.len() == 0 {"}, {"sha": "86ee23d71a6b22dbc733098b8cd9b6e3eac850cf", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "patch": "@@ -596,7 +596,8 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_method: &'v Tr\n         RequiredMethod(ref method_type) => visitor.visit_ty_method(method_type),\n         ProvidedMethod(ref method) => walk_method_helper(visitor, &**method),\n         TypeTraitItem(ref associated_type) => {\n-            visitor.visit_ident(associated_type.span, associated_type.ident)\n+            visitor.visit_ident(associated_type.ty_param.span,\n+                                associated_type.ty_param.ident)\n         }\n     }\n }"}, {"sha": "47ab09d279f62ab773d6bca5051af0ca9c80c307", "filename": "src/test/compile-fail/associated-types-unsized.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Ftest%2Fcompile-fail%2Fassociated-types-unsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Ftest%2Fcompile-fail%2Fassociated-types-unsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-unsized.rs?ref=eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_types)]\n+\n+trait Get {\n+    type Sized? Value;\n+    fn get(&self) -> <Self as Get>::Value;\n+}\n+\n+fn foo<T:Get>(t: T) {\n+    let x = t.get(); //~ ERROR the trait `core::kinds::Sized` is not implemented\n+}\n+\n+fn main() {\n+}\n+"}, {"sha": "48813ff142c1895c90d06c86e0fd3bf28a6ba71b", "filename": "src/test/compile-fail/variance-regions-direct.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs?ref=eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "patch": "@@ -14,7 +14,7 @@\n // Regions that just appear in normal spots are contravariant:\n \n #[rustc_variance]\n-struct Test2<'a, 'b, 'c> { //~ ERROR regions=[[-, -, -];[];[]]\n+struct Test2<'a, 'b, 'c> { //~ ERROR regions=[[-, -, -];[];[];[]]\n     x: &'a int,\n     y: &'b [int],\n     c: &'c str\n@@ -23,7 +23,7 @@ struct Test2<'a, 'b, 'c> { //~ ERROR regions=[[-, -, -];[];[]]\n // Those same annotations in function arguments become covariant:\n \n #[rustc_variance]\n-struct Test3<'a, 'b, 'c> { //~ ERROR regions=[[+, +, +];[];[]]\n+struct Test3<'a, 'b, 'c> { //~ ERROR regions=[[+, +, +];[];[];[]]\n     x: extern \"Rust\" fn(&'a int),\n     y: extern \"Rust\" fn(&'b [int]),\n     c: extern \"Rust\" fn(&'c str),\n@@ -32,15 +32,15 @@ struct Test3<'a, 'b, 'c> { //~ ERROR regions=[[+, +, +];[];[]]\n // Mutability induces invariance:\n \n #[rustc_variance]\n-struct Test4<'a, 'b:'a> { //~ ERROR regions=[[-, o];[];[]]\n+struct Test4<'a, 'b:'a> { //~ ERROR regions=[[-, o];[];[];[]]\n     x: &'a mut &'b int,\n }\n \n // Mutability induces invariance, even when in a\n // contravariant context:\n \n #[rustc_variance]\n-struct Test5<'a, 'b> { //~ ERROR regions=[[+, o];[];[]]\n+struct Test5<'a, 'b> { //~ ERROR regions=[[+, o];[];[];[]]\n     x: extern \"Rust\" fn(&'a mut &'b int),\n }\n \n@@ -50,21 +50,21 @@ struct Test5<'a, 'b> { //~ ERROR regions=[[+, o];[];[]]\n // argument list occurs in an invariant context.\n \n #[rustc_variance]\n-struct Test6<'a, 'b> { //~ ERROR regions=[[-, o];[];[]]\n+struct Test6<'a, 'b> { //~ ERROR regions=[[-, o];[];[];[]]\n     x: &'a mut extern \"Rust\" fn(&'b int),\n }\n \n // No uses at all is bivariant:\n \n #[rustc_variance]\n-struct Test7<'a> { //~ ERROR regions=[[*];[];[]]\n+struct Test7<'a> { //~ ERROR regions=[[*];[];[];[]]\n     x: int\n }\n \n // Try enums too.\n \n #[rustc_variance]\n-enum Test8<'a, 'b, 'c:'b> { //~ ERROR regions=[[+, -, o];[];[]]\n+enum Test8<'a, 'b, 'c:'b> { //~ ERROR regions=[[+, -, o];[];[];[]]\n     Test8A(extern \"Rust\" fn(&'a int)),\n     Test8B(&'b [int]),\n     Test8C(&'b mut &'c str),"}, {"sha": "0e8e52df456afc4142e5914821f5264bfae23565", "filename": "src/test/compile-fail/variance-regions-indirect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs?ref=eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "patch": "@@ -13,29 +13,29 @@\n // Try enums too.\n \n #[rustc_variance]\n-enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR regions=[[+, -, o, *];[];[]]\n+enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR regions=[[+, -, o, *];[];[];[]]\n     Test8A(extern \"Rust\" fn(&'a int)),\n     Test8B(&'b [int]),\n     Test8C(&'b mut &'c str),\n }\n \n #[rustc_variance]\n-struct Derived1<'w, 'x:'y, 'y, 'z> { //~ ERROR regions=[[*, o, -, +];[];[]]\n+struct Derived1<'w, 'x:'y, 'y, 'z> { //~ ERROR regions=[[*, o, -, +];[];[];[]]\n     f: Base<'z, 'y, 'x, 'w>\n }\n \n #[rustc_variance] // Combine - and + to yield o\n-struct Derived2<'a, 'b:'a, 'c> { //~ ERROR regions=[[o, o, *];[];[]]\n+struct Derived2<'a, 'b:'a, 'c> { //~ ERROR regions=[[o, o, *];[];[];[]]\n     f: Base<'a, 'a, 'b, 'c>\n }\n \n #[rustc_variance] // Combine + and o to yield o (just pay attention to 'a here)\n-struct Derived3<'a:'b, 'b, 'c> { //~ ERROR regions=[[o, -, *];[];[]]\n+struct Derived3<'a:'b, 'b, 'c> { //~ ERROR regions=[[o, -, *];[];[];[]]\n     f: Base<'a, 'b, 'a, 'c>\n }\n \n #[rustc_variance] // Combine + and * to yield + (just pay attention to 'a here)\n-struct Derived4<'a, 'b, 'c:'b> { //~ ERROR regions=[[+, -, o];[];[]]\n+struct Derived4<'a, 'b, 'c:'b> { //~ ERROR regions=[[+, -, o];[];[];[]]\n     f: Base<'a, 'b, 'c, 'a>\n }\n "}, {"sha": "c576c5e2edd6465e95111eef0b30c5422e32100c", "filename": "src/test/compile-fail/variance-trait-object-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs?ref=eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "patch": "@@ -19,7 +19,7 @@ use std::mem;\n trait T { fn foo(); }\n \n #[rustc_variance]\n-struct TOption<'a> { //~ ERROR regions=[[-];[];[]]\n+struct TOption<'a> { //~ ERROR regions=[[-];[];[];[]]\n     v: Option<Box<T + 'a>>,\n }\n "}]}