{"sha": "4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "node_id": "C_kwDOAAsO6NoAKDQxNDNiMTAxZjliMDk0OWM0YmM2ZGIxMTI0Zjg2ZWYwMmIxZWY3YWE", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-11-23T00:55:16Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-02-21T00:51:56Z"}, "message": "Use `ThinVec` in various AST types.\n\nThis commit changes the sequence parsers to produce `ThinVec`, which\ntriggers numerous conversions.", "tree": {"sha": "ccec1e793829bc4ce4095fc02cc647ba8b6f63f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ccec1e793829bc4ce4095fc02cc647ba8b6f63f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "html_url": "https://github.com/rust-lang/rust/commit/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a56c3a930733b7e000cc3ec54844b0522a8bd16", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a56c3a930733b7e000cc3ec54844b0522a8bd16", "html_url": "https://github.com/rust-lang/rust/commit/6a56c3a930733b7e000cc3ec54844b0522a8bd16"}], "stats": {"total": 643, "additions": 353, "deletions": 290}, "files": [{"sha": "62dd3c36c4214c65a964672345cb913895479f2b", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -3689,6 +3689,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"thin-vec\",\n  \"tracing\",\n ]\n \n@@ -4072,6 +4073,7 @@ dependencies = [\n  \"rustc_trait_selection\",\n  \"rustc_type_ir\",\n  \"smallvec\",\n+ \"thin-vec\",\n  \"tracing\",\n ]\n \n@@ -4128,6 +4130,7 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n+ \"thin-vec\",\n  \"tracing\",\n ]\n \n@@ -4826,7 +4829,6 @@ dependencies = [\n  \"serde_json\",\n  \"smallvec\",\n  \"tempfile\",\n- \"thin-vec\",\n  \"tracing\",\n  \"tracing-subscriber\",\n  \"tracing-tree\","}, {"sha": "b46d69a3758669ede9d84753a6b0f4112de7d872", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -253,7 +253,7 @@ pub struct ParenthesizedArgs {\n     pub span: Span,\n \n     /// `(A, B)`\n-    pub inputs: Vec<P<Ty>>,\n+    pub inputs: ThinVec<P<Ty>>,\n \n     /// ```text\n     /// Foo(A, B) -> C\n@@ -503,7 +503,7 @@ pub enum MetaItemKind {\n     /// List meta item.\n     ///\n     /// E.g., `#[derive(..)]`, where the field represents the `..`.\n-    List(Vec<NestedMetaItem>),\n+    List(ThinVec<NestedMetaItem>),\n \n     /// Name value meta item.\n     ///\n@@ -581,7 +581,7 @@ impl Pat {\n             // A tuple pattern `(P0, .., Pn)` can be reparsed as `(T0, .., Tn)`\n             // assuming `T0` to `Tn` are all syntactically valid as types.\n             PatKind::Tuple(pats) => {\n-                let mut tys = Vec::with_capacity(pats.len());\n+                let mut tys = ThinVec::with_capacity(pats.len());\n                 // FIXME(#48994) - could just be collected into an Option<Vec>\n                 for pat in pats {\n                     tys.push(pat.to_ty()?);\n@@ -725,11 +725,11 @@ pub enum PatKind {\n     Struct(Option<P<QSelf>>, Path, Vec<PatField>, /* recovered */ bool),\n \n     /// A tuple struct/variant pattern (`Variant(x, y, .., z)`).\n-    TupleStruct(Option<P<QSelf>>, Path, Vec<P<Pat>>),\n+    TupleStruct(Option<P<QSelf>>, Path, ThinVec<P<Pat>>),\n \n     /// An or-pattern `A | B | C`.\n     /// Invariant: `pats.len() >= 2`.\n-    Or(Vec<P<Pat>>),\n+    Or(ThinVec<P<Pat>>),\n \n     /// A possibly qualified path pattern.\n     /// Unqualified path patterns `A::B::C` can legally refer to variants, structs, constants\n@@ -738,7 +738,7 @@ pub enum PatKind {\n     Path(Option<P<QSelf>>, Path),\n \n     /// A tuple pattern (`(a, b)`).\n-    Tuple(Vec<P<Pat>>),\n+    Tuple(ThinVec<P<Pat>>),\n \n     /// A `box` pattern.\n     Box(P<Pat>),\n@@ -753,7 +753,7 @@ pub enum PatKind {\n     Range(Option<P<Expr>>, Option<P<Expr>>, Spanned<RangeEnd>),\n \n     /// A slice pattern `[a, b, c]`.\n-    Slice(Vec<P<Pat>>),\n+    Slice(ThinVec<P<Pat>>),\n \n     /// A rest pattern `..`.\n     ///\n@@ -1204,7 +1204,7 @@ impl Expr {\n             ExprKind::Array(exprs) if exprs.len() == 1 => exprs[0].to_ty().map(TyKind::Slice)?,\n \n             ExprKind::Tup(exprs) => {\n-                let tys = exprs.iter().map(|expr| expr.to_ty()).collect::<Option<Vec<_>>>()?;\n+                let tys = exprs.iter().map(|expr| expr.to_ty()).collect::<Option<ThinVec<_>>>()?;\n                 TyKind::Tup(tys)\n             }\n \n@@ -1337,7 +1337,7 @@ pub struct MethodCall {\n     /// The receiver, e.g. `x`.\n     pub receiver: P<Expr>,\n     /// The arguments, e.g. `a, b, c`.\n-    pub args: Vec<P<Expr>>,\n+    pub args: ThinVec<P<Expr>>,\n     /// The span of the function, without the dot and receiver e.g. `foo::<Bar,\n     /// Baz>(a, b, c)`.\n     pub span: Span,\n@@ -1366,7 +1366,7 @@ pub enum ExprKind {\n     /// A `box x` expression.\n     Box(P<Expr>),\n     /// An array (`[a, b, c, d]`)\n-    Array(Vec<P<Expr>>),\n+    Array(ThinVec<P<Expr>>),\n     /// Allow anonymous constants from an inline `const` block\n     ConstBlock(AnonConst),\n     /// A function call\n@@ -1375,11 +1375,11 @@ pub enum ExprKind {\n     /// and the second field is the list of arguments.\n     /// This also represents calling the constructor of\n     /// tuple-like ADTs such as tuple structs and enum variants.\n-    Call(P<Expr>, Vec<P<Expr>>),\n+    Call(P<Expr>, ThinVec<P<Expr>>),\n     /// A method call (e.g. `x.foo::<Bar, Baz>(a, b, c)`).\n     MethodCall(Box<MethodCall>),\n     /// A tuple (e.g., `(a, b, c, d)`).\n-    Tup(Vec<P<Expr>>),\n+    Tup(ThinVec<P<Expr>>),\n     /// A binary operation (e.g., `a + b`, `a * b`).\n     Binary(BinOp, P<Expr>, P<Expr>),\n     /// A unary operation (e.g., `!x`, `*x`).\n@@ -2078,7 +2078,7 @@ pub enum TyKind {\n     /// The never type (`!`).\n     Never,\n     /// A tuple (`(A, B, C, D,...)`).\n-    Tup(Vec<P<Ty>>),\n+    Tup(ThinVec<P<Ty>>),\n     /// A path (`module::module::...::Type`), optionally\n     /// \"qualified\", e.g., `<Vec<T> as SomeTrait>::SomeType`.\n     ///\n@@ -2363,7 +2363,7 @@ impl Param {\n /// which contains metadata about function safety, asyncness, constness and ABI.\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct FnDecl {\n-    pub inputs: Vec<Param>,\n+    pub inputs: ThinVec<Param>,\n     pub output: FnRetTy,\n }\n \n@@ -2532,7 +2532,7 @@ pub enum UseTreeKind {\n     /// `use prefix` or `use prefix as rename`\n     Simple(Option<Ident>),\n     /// `use prefix::{...}`\n-    Nested(Vec<(UseTree, NodeId)>),\n+    Nested(ThinVec<(UseTree, NodeId)>),\n     /// `use prefix::*`\n     Glob,\n }\n@@ -2695,11 +2695,11 @@ pub enum VariantData {\n     /// Struct variant.\n     ///\n     /// E.g., `Bar { .. }` as in `enum Foo { Bar { .. } }`.\n-    Struct(Vec<FieldDef>, bool),\n+    Struct(ThinVec<FieldDef>, bool),\n     /// Tuple variant.\n     ///\n     /// E.g., `Bar(..)` as in `enum Foo { Bar(..) }`.\n-    Tuple(Vec<FieldDef>, NodeId),\n+    Tuple(ThinVec<FieldDef>, NodeId),\n     /// Unit variant.\n     ///\n     /// E.g., `Bar = ..` as in `enum Foo { Bar = .. }`.\n@@ -3122,8 +3122,8 @@ mod size_asserts {\n     static_assert_size!(GenericBound, 56);\n     static_assert_size!(Generics, 40);\n     static_assert_size!(Impl, 136);\n-    static_assert_size!(Item, 152);\n-    static_assert_size!(ItemKind, 80);\n+    static_assert_size!(Item, 144);\n+    static_assert_size!(ItemKind, 72);\n     static_assert_size!(LitKind, 24);\n     static_assert_size!(Local, 72);\n     static_assert_size!(MetaItemLit, 40);"}, {"sha": "2e83b3e623f075c4f3ace79abb5f2c591e9eb8aa", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -20,7 +20,7 @@ use std::iter;\n use std::ops::BitXor;\n #[cfg(debug_assertions)]\n use std::sync::atomic::{AtomicU32, Ordering};\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub struct MarkedAttrs(GrowableBitSet<AttrId>);\n \n@@ -135,7 +135,7 @@ impl Attribute {\n         }\n     }\n \n-    pub fn meta_item_list(&self) -> Option<Vec<NestedMetaItem>> {\n+    pub fn meta_item_list(&self) -> Option<ThinVec<NestedMetaItem>> {\n         match &self.kind {\n             AttrKind::Normal(normal) => normal.item.meta_item_list(),\n             AttrKind::DocComment(..) => None,\n@@ -216,7 +216,7 @@ impl AttrItem {\n         self.args.span().map_or(self.path.span, |args_span| self.path.span.to(args_span))\n     }\n \n-    fn meta_item_list(&self) -> Option<Vec<NestedMetaItem>> {\n+    fn meta_item_list(&self) -> Option<ThinVec<NestedMetaItem>> {\n         match &self.args {\n             AttrArgs::Delimited(args) if args.delim == MacDelimiter::Parenthesis => {\n                 MetaItemKind::list_from_tokens(args.tokens.clone())\n@@ -375,9 +375,9 @@ impl MetaItemKind {\n         }\n     }\n \n-    fn list_from_tokens(tokens: TokenStream) -> Option<Vec<NestedMetaItem>> {\n+    fn list_from_tokens(tokens: TokenStream) -> Option<ThinVec<NestedMetaItem>> {\n         let mut tokens = tokens.into_trees().peekable();\n-        let mut result = Vec::new();\n+        let mut result = ThinVec::new();\n         while tokens.peek().is_some() {\n             let item = NestedMetaItem::from_tokens(&mut tokens)?;\n             result.push(item);"}, {"sha": "6fac99e6d89d0bbe584e6e76f55287c09ac37ee5", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -369,6 +369,11 @@ pub fn visit_exprs<T: MutVisitor>(exprs: &mut Vec<P<Expr>>, vis: &mut T) {\n     exprs.flat_map_in_place(|expr| vis.filter_map_expr(expr))\n }\n \n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n+pub fn visit_thin_exprs<T: MutVisitor>(exprs: &mut ThinVec<P<Expr>>, vis: &mut T) {\n+    exprs.flat_map_in_place(|expr| vis.filter_map_expr(expr))\n+}\n+\n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n pub fn visit_bounds<T: MutVisitor>(bounds: &mut GenericBounds, vis: &mut T) {\n     visit_vec(bounds, |bound| vis.visit_param_bound(bound));\n@@ -485,7 +490,7 @@ pub fn noop_visit_ty<T: MutVisitor>(ty: &mut P<Ty>, vis: &mut T) {\n             vis.visit_fn_decl(decl);\n             vis.visit_span(decl_span);\n         }\n-        TyKind::Tup(tys) => visit_vec(tys, |ty| vis.visit_ty(ty)),\n+        TyKind::Tup(tys) => visit_thin_vec(tys, |ty| vis.visit_ty(ty)),\n         TyKind::Paren(ty) => vis.visit_ty(ty),\n         TyKind::Path(qself, path) => {\n             vis.visit_qself(qself);\n@@ -584,7 +589,7 @@ pub fn noop_visit_parenthesized_parameter_data<T: MutVisitor>(\n     vis: &mut T,\n ) {\n     let ParenthesizedArgs { inputs, output, span, .. } = args;\n-    visit_vec(inputs, |input| vis.visit_ty(input));\n+    visit_thin_vec(inputs, |input| vis.visit_ty(input));\n     noop_visit_fn_ret_ty(output, vis);\n     vis.visit_span(span);\n }\n@@ -647,7 +652,7 @@ pub fn noop_visit_meta_item<T: MutVisitor>(mi: &mut MetaItem, vis: &mut T) {\n     let MetaItem { path: _, kind, span } = mi;\n     match kind {\n         MetaItemKind::Word => {}\n-        MetaItemKind::List(mis) => visit_vec(mis, |mi| vis.visit_meta_list_item(mi)),\n+        MetaItemKind::List(mis) => visit_thin_vec(mis, |mi| vis.visit_meta_list_item(mi)),\n         MetaItemKind::NameValue(_s) => {}\n     }\n     vis.visit_span(span);\n@@ -1236,7 +1241,7 @@ pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n         PatKind::TupleStruct(qself, path, elems) => {\n             vis.visit_qself(qself);\n             vis.visit_path(path);\n-            visit_vec(elems, |elem| vis.visit_pat(elem));\n+            visit_thin_vec(elems, |elem| vis.visit_pat(elem));\n         }\n         PatKind::Path(qself, path) => {\n             vis.visit_qself(qself);\n@@ -1255,7 +1260,7 @@ pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n             vis.visit_span(span);\n         }\n         PatKind::Tuple(elems) | PatKind::Slice(elems) | PatKind::Or(elems) => {\n-            visit_vec(elems, |elem| vis.visit_pat(elem))\n+            visit_thin_vec(elems, |elem| vis.visit_pat(elem))\n         }\n         PatKind::Paren(inner) => vis.visit_pat(inner),\n         PatKind::MacCall(mac) => vis.visit_mac_call(mac),\n@@ -1312,18 +1317,18 @@ pub fn noop_visit_expr<T: MutVisitor>(\n ) {\n     match kind {\n         ExprKind::Box(expr) => vis.visit_expr(expr),\n-        ExprKind::Array(exprs) => visit_exprs(exprs, vis),\n+        ExprKind::Array(exprs) => visit_thin_exprs(exprs, vis),\n         ExprKind::ConstBlock(anon_const) => {\n             vis.visit_anon_const(anon_const);\n         }\n         ExprKind::Repeat(expr, count) => {\n             vis.visit_expr(expr);\n             vis.visit_anon_const(count);\n         }\n-        ExprKind::Tup(exprs) => visit_exprs(exprs, vis),\n+        ExprKind::Tup(exprs) => visit_thin_exprs(exprs, vis),\n         ExprKind::Call(f, args) => {\n             vis.visit_expr(f);\n-            visit_exprs(args, vis);\n+            visit_thin_exprs(args, vis);\n         }\n         ExprKind::MethodCall(box MethodCall {\n             seg: PathSegment { ident, id, args: seg_args },\n@@ -1335,7 +1340,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n             vis.visit_id(id);\n             visit_opt(seg_args, |args| vis.visit_generic_args(args));\n             vis.visit_method_receiver_expr(receiver);\n-            visit_exprs(call_args, vis);\n+            visit_thin_exprs(call_args, vis);\n             vis.visit_span(span);\n         }\n         ExprKind::Binary(_binop, lhs, rhs) => {"}, {"sha": "511adbd5e6384208f678e1033da207b42c0d7efb", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -18,7 +18,7 @@ use rustc_session::errors::report_lit_error;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::DUMMY_SP;\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_exprs(&mut self, exprs: &[AstP<Expr>]) -> &'hir [hir::Expr<'hir>] {\n@@ -367,7 +367,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_legacy_const_generics(\n         &mut self,\n         mut f: Expr,\n-        args: Vec<AstP<Expr>>,\n+        args: ThinVec<AstP<Expr>>,\n         legacy_args_idx: &[usize],\n     ) -> hir::ExprKind<'hir> {\n         let ExprKind::Path(None, path) = &mut f.kind else {"}, {"sha": "8bd212073a65a8ada361244ff56b47a1624eb053", "filename": "compiler/rustc_ast_passes/Cargo.toml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_ast_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_ast_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2FCargo.toml?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -5,7 +5,7 @@ edition = \"2021\"\n \n [dependencies]\n itertools = \"0.10.1\"\n-tracing = \"0.1\"\n+rustc_ast = { path = \"../rustc_ast\" }\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n@@ -16,4 +16,5 @@ rustc_parse = { path = \"../rustc_parse\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n-rustc_ast = { path = \"../rustc_ast\" }\n+thin-vec = \"0.2.12\"\n+tracing = \"0.1\""}, {"sha": "6f7ba7a5ad77c5045491c5abdcef7fa3a82012de", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -10,6 +10,8 @@ use rustc_span::source_map::Spanned;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_target::spec::abi;\n+use thin_vec::ThinVec;\n+use tracing::debug;\n \n use crate::errors::ForbiddenLifetimeBound;\n \n@@ -250,7 +252,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n \n             ast::ItemKind::Struct(..) => {\n                 for attr in self.sess.filter_by_name(&i.attrs, sym::repr) {\n-                    for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n+                    for item in attr.meta_item_list().unwrap_or_else(ThinVec::new) {\n                         if item.has_name(sym::simd) {\n                             gate_feature_post!(\n                                 &self,"}, {"sha": "bbcbecd81313d4a3dd3103c52d55648ae68e2631", "filename": "compiler/rustc_ast_passes/src/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -11,9 +11,6 @@\n #![feature(let_chains)]\n #![recursion_limit = \"256\"]\n \n-#[macro_use]\n-extern crate tracing;\n-\n pub mod ast_validation;\n mod errors;\n pub mod feature_gate;"}, {"sha": "3b2b60a86f06e8d5728a6b0539290f6c9fd3c414", "filename": "compiler/rustc_ast_pretty/src/pprust/tests.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Ftests.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -3,6 +3,7 @@ use super::*;\n use rustc_ast as ast;\n use rustc_span::create_default_session_globals_then;\n use rustc_span::symbol::Ident;\n+use thin_vec::ThinVec;\n \n fn fun_to_string(\n     decl: &ast::FnDecl,\n@@ -27,8 +28,10 @@ fn test_fun_to_string() {\n     create_default_session_globals_then(|| {\n         let abba_ident = Ident::from_str(\"abba\");\n \n-        let decl =\n-            ast::FnDecl { inputs: Vec::new(), output: ast::FnRetTy::Default(rustc_span::DUMMY_SP) };\n+        let decl = ast::FnDecl {\n+            inputs: ThinVec::new(),\n+            output: ast::FnRetTy::Default(rustc_span::DUMMY_SP),\n+        };\n         let generics = ast::Generics::default();\n         assert_eq!(\n             fun_to_string(&decl, ast::FnHeader::default(), abba_ident, &generics),"}, {"sha": "df28d75f1d5744289ca2884fa39d5287421304fe", "filename": "compiler/rustc_builtin_macros/src/alloc_error_handler.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -6,7 +6,7 @@ use rustc_ast::{Fn, ItemKind, Stmt, TyKind, Unsafe};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub fn expand(\n     ecx: &mut ExtCtxt<'_>,\n@@ -42,7 +42,7 @@ pub fn expand(\n     let stmts = vec![generate_handler(ecx, item.ident, span, sig_span)];\n \n     // Generate anonymous constant serving as container for the allocator methods.\n-    let const_ty = ecx.ty(sig_span, TyKind::Tup(Vec::new()));\n+    let const_ty = ecx.ty(sig_span, TyKind::Tup(ThinVec::new()));\n     let const_body = ecx.expr_block(ecx.block(span, stmts));\n     let const_item = ecx.item_const(span, Ident::new(kw::Underscore, span), const_ty, const_body);\n     let const_item = if is_stmt {\n@@ -67,13 +67,16 @@ fn generate_handler(cx: &ExtCtxt<'_>, handler: Ident, span: Span, sig_span: Span\n \n     let layout_new = cx.std_path(&[sym::alloc, sym::Layout, sym::from_size_align_unchecked]);\n     let layout_new = cx.expr_path(cx.path(span, layout_new));\n-    let layout =\n-        cx.expr_call(span, layout_new, vec![cx.expr_ident(span, size), cx.expr_ident(span, align)]);\n+    let layout = cx.expr_call(\n+        span,\n+        layout_new,\n+        thin_vec![cx.expr_ident(span, size), cx.expr_ident(span, align)],\n+    );\n \n-    let call = cx.expr_call_ident(sig_span, handler, vec![layout]);\n+    let call = cx.expr_call_ident(sig_span, handler, thin_vec![layout]);\n \n     let never = ast::FnRetTy::Ty(cx.ty(span, TyKind::Never));\n-    let params = vec![cx.param(span, size, ty_usize.clone()), cx.param(span, align, ty_usize)];\n+    let params = thin_vec![cx.param(span, size, ty_usize.clone()), cx.param(span, align, ty_usize)];\n     let decl = cx.fn_decl(params, never);\n     let header = FnHeader { unsafety: Unsafe::Yes(span), ..FnHeader::default() };\n     let sig = FnSig { decl, header, span: span };"}, {"sha": "75af5e2b1fade53652b502ecfc35601f63c65c61", "filename": "compiler/rustc_builtin_macros/src/assert.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -11,6 +11,7 @@ use rustc_expand::base::{DummyResult, ExtCtxt, MacEager, MacResult};\n use rustc_parse::parser::Parser;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n+use thin_vec::thin_vec;\n \n pub fn expand_assert<'cx>(\n     cx: &'cx mut ExtCtxt<'_>,\n@@ -79,7 +80,7 @@ pub fn expand_assert<'cx>(\n         let then = cx.expr_call_global(\n             call_site_span,\n             cx.std_path(&[sym::panicking, sym::panic]),\n-            vec![cx.expr_str(\n+            thin_vec![cx.expr_str(\n                 DUMMY_SP,\n                 Symbol::intern(&format!(\n                     \"assertion failed: {}\","}, {"sha": "e0c6d7f42d1246f427e9e2e0146e7963c620c15c", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -12,7 +12,7 @@ use rustc_span::{\n     symbol::{sym, Ident, Symbol},\n     Span,\n };\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub(super) struct Context<'cx, 'a> {\n     // An optimization.\n@@ -120,7 +120,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n                 thin_vec![self.cx.attr_nested_word(sym::allow, sym::unused_imports, self.span)],\n                 ItemKind::Use(UseTree {\n                     prefix: self.cx.path(self.span, self.cx.std_path(&[sym::asserting])),\n-                    kind: UseTreeKind::Nested(vec![\n+                    kind: UseTreeKind::Nested(thin_vec![\n                         nested_tree(self, sym::TryCaptureGeneric),\n                         nested_tree(self, sym::TryCapturePrintable),\n                     ]),\n@@ -136,7 +136,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n         self.cx.expr_call(\n             self.span,\n             self.cx.expr_path(self.cx.path(self.span, unlikely_path)),\n-            vec![self.cx.expr(self.span, ExprKind::Unary(UnOp::Not, cond_expr))],\n+            thin_vec![self.cx.expr(self.span, ExprKind::Unary(UnOp::Not, cond_expr))],\n         )\n     }\n \n@@ -339,7 +339,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n         let init = self.cx.expr_call(\n             self.span,\n             self.cx.expr_path(self.cx.path(self.span, init_std_path)),\n-            vec![],\n+            ThinVec::new(),\n         );\n         let capture = Capture { decl: self.cx.stmt_let(self.span, true, ident, init), ident };\n         self.capture_decls.push(capture);\n@@ -366,7 +366,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n             self.cx.expr_path(\n                 self.cx.path(self.span, self.cx.std_path(&[sym::asserting, sym::Wrapper])),\n             ),\n-            vec![self.cx.expr_path(Path::from_ident(local_bind))],\n+            thin_vec![self.cx.expr_path(Path::from_ident(local_bind))],\n         );\n         let try_capture_call = self\n             .cx\n@@ -378,7 +378,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n                     ident: Ident::new(sym::try_capture, self.span),\n                 },\n                 expr_paren(self.cx, self.span, self.cx.expr_addr_of(self.span, wrapper)),\n-                vec![expr_addr_of_mut(\n+                thin_vec![expr_addr_of_mut(\n                     self.cx,\n                     self.span,\n                     self.cx.expr_path(Path::from_ident(capture)),\n@@ -441,7 +441,7 @@ fn expr_method_call(\n     cx: &ExtCtxt<'_>,\n     seg: PathSegment,\n     receiver: P<Expr>,\n-    args: Vec<P<Expr>>,\n+    args: ThinVec<P<Expr>>,\n     span: Span,\n ) -> P<Expr> {\n     cx.expr(span, ExprKind::MethodCall(Box::new(MethodCall { seg, receiver, args, span })))"}, {"sha": "bb4d8edfb47c5abcb7a1602347b2f402b8564038", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -162,7 +162,7 @@ fn cs_clone(\n     let all_fields;\n     let fn_path = cx.std_path(&[sym::clone, sym::Clone, sym::clone]);\n     let subcall = |cx: &mut ExtCtxt<'_>, field: &FieldInfo| {\n-        let args = vec![field.self_expr.clone()];\n+        let args = thin_vec![field.self_expr.clone()];\n         cx.expr_call_global(field.span, fn_path.clone(), args)\n     };\n "}, {"sha": "b4ea7883baa5834626e88cb86b050dbbe173c085", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -64,7 +64,7 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> Bl\n                 let [other_expr] = &field.other_selflike_exprs[..] else {\n                         cx.span_bug(field.span, \"not exactly 2 arguments in `derive(Ord)`\");\n                     };\n-                let args = vec![field.self_expr.clone(), other_expr.clone()];\n+                let args = thin_vec![field.self_expr.clone(), other_expr.clone()];\n                 cx.expr_call_global(field.span, cmp_path.clone(), args)\n             }\n             CsFold::Combine(span, expr1, expr2) => {"}, {"sha": "9a98ed4e735496378eec9dd38b4c43480bcc7976", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -98,7 +98,7 @@ fn cs_partial_cmp(\n                 let [other_expr] = &field.other_selflike_exprs[..] else {\n                         cx.span_bug(field.span, \"not exactly 2 arguments in `derive(Ord)`\");\n                     };\n-                let args = vec![field.self_expr.clone(), other_expr.clone()];\n+                let args = thin_vec![field.self_expr.clone(), other_expr.clone()];\n                 cx.expr_call_global(field.span, partial_cmp_path.clone(), args)\n             }\n             CsFold::Combine(span, mut expr1, expr2) => {"}, {"sha": "69f9bf550603a8d72e81057219f26eda5603de28", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -7,6 +7,7 @@ use rustc_ast::{self as ast, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub fn expand_deriving_debug(\n     cx: &mut ExtCtxt<'_>,\n@@ -94,7 +95,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     if fields.is_empty() {\n         // Special case for no fields.\n         let fn_path_write_str = cx.std_path(&[sym::fmt, sym::Formatter, sym::write_str]);\n-        let expr = cx.expr_call_global(span, fn_path_write_str, vec![fmt, name]);\n+        let expr = cx.expr_call_global(span, fn_path_write_str, thin_vec![fmt, name]);\n         BlockOrExpr::new_expr(expr)\n     } else if fields.len() <= CUTOFF {\n         // Few enough fields that we can use a specific-length method.\n@@ -105,7 +106,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         };\n         let fn_path_debug = cx.std_path(&[sym::fmt, sym::Formatter, Symbol::intern(&debug)]);\n \n-        let mut args = Vec::with_capacity(2 + fields.len() * args_per_field);\n+        let mut args = ThinVec::with_capacity(2 + fields.len() * args_per_field);\n         args.extend([fmt, name]);\n         for i in 0..fields.len() {\n             let field = &fields[i];\n@@ -121,8 +122,8 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         BlockOrExpr::new_expr(expr)\n     } else {\n         // Enough fields that we must use the any-length method.\n-        let mut name_exprs = Vec::with_capacity(fields.len());\n-        let mut value_exprs = Vec::with_capacity(fields.len());\n+        let mut name_exprs = ThinVec::with_capacity(fields.len());\n+        let mut value_exprs = ThinVec::with_capacity(fields.len());\n \n         for i in 0..fields.len() {\n             let field = &fields[i];\n@@ -177,7 +178,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         };\n         let fn_path_debug_internal = cx.std_path(&[sym::fmt, sym::Formatter, sym_debug]);\n \n-        let mut args = Vec::with_capacity(4);\n+        let mut args = ThinVec::with_capacity(4);\n         args.push(fmt);\n         args.push(name);\n         if is_struct {\n@@ -223,7 +224,7 @@ fn show_fieldless_enum(\n             let pat = match &v.data {\n                 ast::VariantData::Tuple(fields, _) => {\n                     debug_assert!(fields.is_empty());\n-                    cx.pat_tuple_struct(span, variant_path, vec![])\n+                    cx.pat_tuple_struct(span, variant_path, thin_vec![])\n                 }\n                 ast::VariantData::Struct(fields, _) => {\n                     debug_assert!(fields.is_empty());\n@@ -236,5 +237,5 @@ fn show_fieldless_enum(\n         .collect::<Vec<_>>();\n     let name = cx.expr_match(span, cx.expr_self(span), arms);\n     let fn_path_write_str = cx.std_path(&[sym::fmt, sym::Formatter, sym::write_str]);\n-    BlockOrExpr::new_expr(cx.expr_call_global(span, fn_path_write_str, vec![fmt, name]))\n+    BlockOrExpr::new_expr(cx.expr_call_global(span, fn_path_write_str, thin_vec![fmt, name]))\n }"}, {"sha": "7c324c54707da004e0fc5287a32fbe3ffa55986a", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -3,12 +3,12 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::pathvec_std;\n-\n use rustc_ast::ptr::P;\n use rustc_ast::{self as ast, Expr, MetaItem, Mutability};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub fn expand_deriving_rustc_decodable(\n     cx: &mut ExtCtxt<'_>,\n@@ -96,7 +96,7 @@ fn decodable_substructure(\n                         cx.expr_call_global(\n                             span,\n                             fn_read_struct_field_path.clone(),\n-                            vec![\n+                            thin_vec![\n                                 blkdecoder.clone(),\n                                 cx.expr_str(span, name),\n                                 cx.expr_usize(span, field),\n@@ -112,7 +112,7 @@ fn decodable_substructure(\n             cx.expr_call_global(\n                 trait_span,\n                 fn_read_struct_path,\n-                vec![\n+                thin_vec![\n                     decoder,\n                     cx.expr_str(trait_span, substr.type_ident.name),\n                     cx.expr_usize(trait_span, nfields),\n@@ -124,7 +124,7 @@ fn decodable_substructure(\n             let variant = Ident::new(sym::i, trait_span);\n \n             let mut arms = Vec::with_capacity(fields.len() + 1);\n-            let mut variants = Vec::with_capacity(fields.len());\n+            let mut variants = ThinVec::with_capacity(fields.len());\n \n             let fn_read_enum_variant_arg_path: Vec<_> =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Decoder, sym::read_enum_variant_arg]);\n@@ -141,7 +141,7 @@ fn decodable_substructure(\n                             cx.expr_call_global(\n                                 span,\n                                 fn_read_enum_variant_arg_path.clone(),\n-                                vec![blkdecoder.clone(), idx, exprdecode.clone()],\n+                                thin_vec![blkdecoder.clone(), idx, exprdecode.clone()],\n                             ),\n                         )\n                     });\n@@ -162,15 +162,15 @@ fn decodable_substructure(\n             let result = cx.expr_call_global(\n                 trait_span,\n                 fn_read_enum_variant_path,\n-                vec![blkdecoder, variant_array_ref, lambda],\n+                thin_vec![blkdecoder, variant_array_ref, lambda],\n             );\n             let fn_read_enum_path: Vec<_> =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Decoder, sym::read_enum]);\n \n             cx.expr_call_global(\n                 trait_span,\n                 fn_read_enum_path,\n-                vec![\n+                thin_vec![\n                     decoder,\n                     cx.expr_str(trait_span, substr.type_ident.name),\n                     cx.lambda1(trait_span, result, blkarg),"}, {"sha": "4d753a2ed805cb6aaeb03c605861bfaa5d6bfcce", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -8,7 +8,7 @@ use rustc_span::symbol::Ident;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::Span;\n use smallvec::SmallVec;\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub fn expand_deriving_default(\n     cx: &mut ExtCtxt<'_>,\n@@ -60,7 +60,7 @@ fn default_struct_substructure(\n ) -> BlockOrExpr {\n     // Note that `kw::Default` is \"default\" and `sym::Default` is \"Default\"!\n     let default_ident = cx.std_path(&[kw::Default, sym::Default, kw::Default]);\n-    let default_call = |span| cx.expr_call_global(span, default_ident.clone(), Vec::new());\n+    let default_call = |span| cx.expr_call_global(span, default_ident.clone(), ThinVec::new());\n \n     let expr = match summary {\n         Unnamed(_, false) => cx.expr_ident(trait_span, substr.type_ident),"}, {"sha": "fe69fa06018765921798ebc63e770a20bf597f8e", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -88,11 +88,11 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::pathvec_std;\n-\n use rustc_ast::{AttrVec, ExprKind, MetaItem, Mutability};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub fn expand_deriving_rustc_encodable(\n     cx: &mut ExtCtxt<'_>,\n@@ -176,12 +176,13 @@ fn encodable_substructure(\n                     None => Symbol::intern(&format!(\"_field{}\", i)),\n                 };\n                 let self_ref = cx.expr_addr_of(span, self_expr.clone());\n-                let enc = cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);\n+                let enc =\n+                    cx.expr_call(span, fn_path.clone(), thin_vec![self_ref, blkencoder.clone()]);\n                 let lambda = cx.lambda1(span, enc, blkarg);\n                 let call = cx.expr_call_global(\n                     span,\n                     fn_emit_struct_field_path.clone(),\n-                    vec![\n+                    thin_vec![\n                         blkencoder.clone(),\n                         cx.expr_str(span, name),\n                         cx.expr_usize(span, i),\n@@ -203,7 +204,7 @@ fn encodable_substructure(\n \n             // unit structs have no fields and need to return Ok()\n             let blk = if stmts.is_empty() {\n-                let ok = cx.expr_ok(trait_span, cx.expr_tuple(trait_span, vec![]));\n+                let ok = cx.expr_ok(trait_span, cx.expr_tuple(trait_span, ThinVec::new()));\n                 cx.lambda1(trait_span, ok, blkarg)\n             } else {\n                 cx.lambda_stmts_1(trait_span, stmts, blkarg)\n@@ -215,7 +216,7 @@ fn encodable_substructure(\n             let expr = cx.expr_call_global(\n                 trait_span,\n                 fn_emit_struct_path,\n-                vec![\n+                thin_vec![\n                     encoder,\n                     cx.expr_str(trait_span, substr.type_ident.name),\n                     cx.expr_usize(trait_span, fields.len()),\n@@ -241,14 +242,17 @@ fn encodable_substructure(\n                 let last = fields.len() - 1;\n                 for (i, &FieldInfo { ref self_expr, span, .. }) in fields.iter().enumerate() {\n                     let self_ref = cx.expr_addr_of(span, self_expr.clone());\n-                    let enc =\n-                        cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);\n+                    let enc = cx.expr_call(\n+                        span,\n+                        fn_path.clone(),\n+                        thin_vec![self_ref, blkencoder.clone()],\n+                    );\n                     let lambda = cx.lambda1(span, enc, blkarg);\n \n                     let call = cx.expr_call_global(\n                         span,\n                         fn_emit_enum_variant_arg_path.clone(),\n-                        vec![blkencoder.clone(), cx.expr_usize(span, i), lambda],\n+                        thin_vec![blkencoder.clone(), cx.expr_usize(span, i), lambda],\n                     );\n                     let call = if i != last {\n                         cx.expr_try(span, call)\n@@ -258,7 +262,7 @@ fn encodable_substructure(\n                     stmts.push(cx.stmt_expr(call));\n                 }\n             } else {\n-                let ok = cx.expr_ok(trait_span, cx.expr_tuple(trait_span, vec![]));\n+                let ok = cx.expr_ok(trait_span, cx.expr_tuple(trait_span, ThinVec::new()));\n                 let ret_ok = cx.expr(trait_span, ExprKind::Ret(Some(ok)));\n                 stmts.push(cx.stmt_expr(ret_ok));\n             }\n@@ -272,7 +276,7 @@ fn encodable_substructure(\n             let call = cx.expr_call_global(\n                 trait_span,\n                 fn_emit_enum_variant_path,\n-                vec![\n+                thin_vec![\n                     blkencoder,\n                     name,\n                     cx.expr_usize(trait_span, *idx),\n@@ -287,7 +291,7 @@ fn encodable_substructure(\n             let expr = cx.expr_call_global(\n                 trait_span,\n                 fn_emit_enum_path,\n-                vec![encoder, cx.expr_str(trait_span, substr.type_ident.name), blk],\n+                thin_vec![encoder, cx.expr_str(trait_span, substr.type_ident.name), blk],\n             );\n             BlockOrExpr::new_mixed(vec![me], Some(expr))\n         }"}, {"sha": "fcd7d7dc08dc8e1e559f49d7ea3e54a1b0ce186b", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -935,8 +935,8 @@ impl<'a> MethodDef<'a> {\n         trait_: &TraitDef<'_>,\n         type_ident: Ident,\n         generics: &Generics,\n-    ) -> (Option<ast::ExplicitSelf>, Vec<P<Expr>>, Vec<P<Expr>>, Vec<(Ident, P<ast::Ty>)>) {\n-        let mut selflike_args = Vec::new();\n+    ) -> (Option<ast::ExplicitSelf>, ThinVec<P<Expr>>, Vec<P<Expr>>, Vec<(Ident, P<ast::Ty>)>) {\n+        let mut selflike_args = ThinVec::new();\n         let mut nonselflike_args = Vec::new();\n         let mut nonself_arg_tys = Vec::new();\n         let span = trait_.span;\n@@ -1133,7 +1133,7 @@ impl<'a> MethodDef<'a> {\n         trait_: &TraitDef<'b>,\n         enum_def: &'b EnumDef,\n         type_ident: Ident,\n-        selflike_args: Vec<P<Expr>>,\n+        selflike_args: ThinVec<P<Expr>>,\n         nonselflike_args: &[P<Expr>],\n     ) -> BlockOrExpr {\n         let span = trait_.span;\n@@ -1188,7 +1188,7 @@ impl<'a> MethodDef<'a> {\n                         cx,\n                         span,\n                         sym::discriminant_value,\n-                        vec![selflike_arg.clone()],\n+                        thin_vec![selflike_arg.clone()],\n                     );\n                     cx.stmt_let(span, false, ident, variant_value)\n                 })\n@@ -1260,7 +1260,7 @@ impl<'a> MethodDef<'a> {\n                 let sp = variant.span.with_ctxt(trait_.span.ctxt());\n                 let variant_path = cx.path(sp, vec![type_ident, variant.ident]);\n                 let by_ref = ByRef::No; // because enums can't be repr(packed)\n-                let mut subpats: Vec<_> = trait_.create_struct_patterns(\n+                let mut subpats = trait_.create_struct_patterns(\n                     cx,\n                     variant_path,\n                     &variant.data,\n@@ -1336,7 +1336,7 @@ impl<'a> MethodDef<'a> {\n         //          ...\n         //          _ => ::core::intrinsics::unreachable()\n         //      }\n-        let get_match_expr = |mut selflike_args: Vec<P<Expr>>| {\n+        let get_match_expr = |mut selflike_args: ThinVec<P<Expr>>| {\n             let match_arg = if selflike_args.len() == 1 {\n                 selflike_args.pop().unwrap()\n             } else {\n@@ -1427,7 +1427,7 @@ impl<'a> TraitDef<'a> {\n         struct_def: &'a VariantData,\n         prefixes: &[String],\n         by_ref: ByRef,\n-    ) -> Vec<P<ast::Pat>> {\n+    ) -> ThinVec<P<ast::Pat>> {\n         prefixes\n             .iter()\n             .map(|prefix| {"}, {"sha": "26f91b714b46836d1c577dddc91af4463bc8170f", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -103,7 +103,7 @@ impl Ty {\n             Path(p) => p.to_ty(cx, span, self_ty, self_generics),\n             Self_ => cx.ty_path(self.to_path(cx, span, self_ty, self_generics)),\n             Unit => {\n-                let ty = ast::TyKind::Tup(vec![]);\n+                let ty = ast::TyKind::Tup(ThinVec::new());\n                 cx.ty(span, ty)\n             }\n         }"}, {"sha": "7660ca6ffd5466d2fef531eaf8a16b7cea7f73e6", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -1,11 +1,11 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::{path_std, pathvec_std};\n-\n use rustc_ast::{AttrVec, MetaItem, Mutability};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n+use thin_vec::thin_vec;\n \n pub fn expand_deriving_hash(\n     cx: &mut ExtCtxt<'_>,\n@@ -60,7 +60,7 @@ fn hash_substructure(\n \n             cx.expr_path(cx.path_global(span, strs))\n         };\n-        let expr = cx.expr_call(span, hash_path, vec![expr, state_expr.clone()]);\n+        let expr = cx.expr_call(span, hash_path, thin_vec![expr, state_expr.clone()]);\n         cx.stmt_expr(expr)\n     };\n "}, {"sha": "f0fa344d8304698980f25bbdce68f6551b2b49ec", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -93,7 +93,7 @@ fn call_intrinsic(\n     cx: &ExtCtxt<'_>,\n     span: Span,\n     intrinsic: Symbol,\n-    args: Vec<P<ast::Expr>>,\n+    args: ThinVec<P<ast::Expr>>,\n ) -> P<ast::Expr> {\n     let span = cx.with_def_site_ctxt(span);\n     let path = cx.std_path(&[sym::intrinsics, intrinsic]);\n@@ -104,7 +104,7 @@ fn call_intrinsic(\n fn call_unreachable(cx: &ExtCtxt<'_>, span: Span) -> P<ast::Expr> {\n     let span = cx.with_def_site_ctxt(span);\n     let path = cx.std_path(&[sym::intrinsics, sym::unreachable]);\n-    let call = cx.expr_call_global(span, path, vec![]);\n+    let call = cx.expr_call_global(span, path, ThinVec::new());\n \n     cx.expr_block(P(ast::Block {\n         stmts: vec![cx.stmt_expr(call)],"}, {"sha": "6aa900f020163415b5e703ea23dc342ff28dbac5", "filename": "compiler/rustc_builtin_macros/src/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -8,8 +8,8 @@ use rustc_ast::{self as ast, GenericArg};\n use rustc_expand::base::{self, *};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n-\n use std::env;\n+use thin_vec::thin_vec;\n \n pub fn expand_option_env<'cx>(\n     cx: &'cx mut ExtCtxt<'_>,\n@@ -41,7 +41,7 @@ pub fn expand_option_env<'cx>(\n         Some(value) => cx.expr_call_global(\n             sp,\n             cx.std_path(&[sym::option, sym::Option, sym::Some]),\n-            vec![cx.expr_str(sp, value)],\n+            thin_vec![cx.expr_str(sp, value)],\n         ),\n     };\n     MacEager::expr(e)"}, {"sha": "41b51bae73645bbcb6fe30a841d45e79586a18aa", "filename": "compiler/rustc_builtin_macros/src/global_allocator.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -9,7 +9,7 @@ use rustc_ast::{Fn, ItemKind, Mutability, Stmt, Ty, TyKind, Unsafe};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub fn expand(\n     ecx: &mut ExtCtxt<'_>,\n@@ -47,7 +47,7 @@ pub fn expand(\n     let stmts = ALLOCATOR_METHODS.iter().map(|method| f.allocator_fn(method)).collect();\n \n     // Generate anonymous constant serving as container for the allocator methods.\n-    let const_ty = ecx.ty(ty_span, TyKind::Tup(Vec::new()));\n+    let const_ty = ecx.ty(ty_span, TyKind::Tup(ThinVec::new()));\n     let const_body = ecx.expr_block(ecx.block(span, stmts));\n     let const_item = ecx.item_const(span, Ident::new(kw::Underscore, span), const_ty, const_body);\n     let const_item = if is_stmt {\n@@ -70,7 +70,7 @@ struct AllocFnFactory<'a, 'b> {\n \n impl AllocFnFactory<'_, '_> {\n     fn allocator_fn(&self, method: &AllocatorMethod) -> Stmt {\n-        let mut abi_args = Vec::new();\n+        let mut abi_args = ThinVec::new();\n         let mut i = 0;\n         let mut mk = || {\n             let name = Ident::from_str_and_span(&format!(\"arg{}\", i), self.span);\n@@ -99,7 +99,7 @@ impl AllocFnFactory<'_, '_> {\n         self.cx.stmt_item(self.ty_span, item)\n     }\n \n-    fn call_allocator(&self, method: Symbol, mut args: Vec<P<Expr>>) -> P<Expr> {\n+    fn call_allocator(&self, method: Symbol, mut args: ThinVec<P<Expr>>) -> P<Expr> {\n         let method = self.cx.std_path(&[sym::alloc, sym::GlobalAlloc, method]);\n         let method = self.cx.expr_path(self.cx.path(self.ty_span, method));\n         let allocator = self.cx.path_ident(self.ty_span, self.global);\n@@ -117,7 +117,7 @@ impl AllocFnFactory<'_, '_> {\n     fn arg_ty(\n         &self,\n         ty: &AllocatorTy,\n-        args: &mut Vec<Param>,\n+        args: &mut ThinVec<Param>,\n         ident: &mut dyn FnMut() -> Ident,\n     ) -> P<Expr> {\n         match *ty {\n@@ -134,7 +134,7 @@ impl AllocFnFactory<'_, '_> {\n                 let layout_new = self.cx.expr_path(self.cx.path(self.span, layout_new));\n                 let size = self.cx.expr_ident(self.span, size);\n                 let align = self.cx.expr_ident(self.span, align);\n-                let layout = self.cx.expr_call(self.span, layout_new, vec![size, align]);\n+                let layout = self.cx.expr_call(self.span, layout_new, thin_vec![size, align]);\n                 layout\n             }\n \n@@ -168,7 +168,7 @@ impl AllocFnFactory<'_, '_> {\n                 (self.ptr_u8(), expr)\n             }\n \n-            AllocatorTy::Unit => (self.cx.ty(self.span, TyKind::Tup(Vec::new())), expr),\n+            AllocatorTy::Unit => (self.cx.ty(self.span, TyKind::Tup(ThinVec::new())), expr),\n \n             AllocatorTy::Layout | AllocatorTy::Usize | AllocatorTy::Ptr => {\n                 panic!(\"can't convert `AllocatorTy` to an output\")"}, {"sha": "33b238e2c16ba5a77280682c793261ff843213f9", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -11,6 +11,7 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use smallvec::smallvec;\n use std::mem;\n+use thin_vec::{thin_vec, ThinVec};\n \n struct ProcMacroDerive {\n     id: NodeId,\n@@ -314,11 +315,14 @@ fn mk_decls(cx: &mut ExtCtxt<'_>, macros: &[ProcMacro]) -> P<ast::Item> {\n                     cx.expr_call(\n                         span,\n                         proc_macro_ty_method_path(cx, custom_derive),\n-                        vec![\n+                        thin_vec![\n                             cx.expr_str(span, cd.trait_name),\n                             cx.expr_array_ref(\n                                 span,\n-                                cd.attrs.iter().map(|&s| cx.expr_str(span, s)).collect::<Vec<_>>(),\n+                                cd.attrs\n+                                    .iter()\n+                                    .map(|&s| cx.expr_str(span, s))\n+                                    .collect::<ThinVec<_>>(),\n                             ),\n                             local_path(cx, cd.function_name),\n                         ],\n@@ -335,7 +339,7 @@ fn mk_decls(cx: &mut ExtCtxt<'_>, macros: &[ProcMacro]) -> P<ast::Item> {\n                     cx.expr_call(\n                         span,\n                         proc_macro_ty_method_path(cx, ident),\n-                        vec![\n+                        thin_vec![\n                             cx.expr_str(span, ca.function_name.name),\n                             local_path(cx, ca.function_name),\n                         ],\n@@ -377,7 +381,7 @@ fn mk_decls(cx: &mut ExtCtxt<'_>, macros: &[ProcMacro]) -> P<ast::Item> {\n     let anon_constant = cx.item_const(\n         span,\n         Ident::new(kw::Underscore, span),\n-        cx.ty(span, ast::TyKind::Tup(Vec::new())),\n+        cx.ty(span, ast::TyKind::Tup(ThinVec::new())),\n         block,\n     );\n "}, {"sha": "608d8c966682e4881bf2363b28475a4fd214b979", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -10,7 +10,7 @@ use rustc_session::Session;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n use std::iter;\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n /// #[test_case] is used by custom test authors to mark tests\n /// When building for test, it needs to make the item public and gensym the name\n@@ -179,19 +179,19 @@ pub fn expand_test_or_bench(\n         cx.expr_call(\n             sp,\n             cx.expr_path(test_path(\"StaticBenchFn\")),\n-            vec![\n+            thin_vec![\n                 // |b| self::test::assert_test_result(\n                 cx.lambda1(\n                     sp,\n                     cx.expr_call(\n                         sp,\n                         cx.expr_path(test_path(\"assert_test_result\")),\n-                        vec![\n+                        thin_vec![\n                             // super::$test_fn(b)\n                             cx.expr_call(\n                                 ret_ty_sp,\n                                 cx.expr_path(cx.path(sp, vec![item.ident])),\n-                                vec![cx.expr_ident(sp, b)],\n+                                thin_vec![cx.expr_ident(sp, b)],\n                             ),\n                         ],\n                     ),\n@@ -203,20 +203,20 @@ pub fn expand_test_or_bench(\n         cx.expr_call(\n             sp,\n             cx.expr_path(test_path(\"StaticTestFn\")),\n-            vec![\n+            thin_vec![\n                 // || {\n                 cx.lambda0(\n                     sp,\n                     // test::assert_test_result(\n                     cx.expr_call(\n                         sp,\n                         cx.expr_path(test_path(\"assert_test_result\")),\n-                        vec![\n+                        thin_vec![\n                             // $test_fn()\n                             cx.expr_call(\n                                 ret_ty_sp,\n                                 cx.expr_path(cx.path(sp, vec![item.ident])),\n-                                vec![],\n+                                ThinVec::new(),\n                             ), // )\n                         ],\n                     ), // }\n@@ -263,7 +263,7 @@ pub fn expand_test_or_bench(\n                                         cx.expr_call(\n                                             sp,\n                                             cx.expr_path(test_path(\"StaticTestName\")),\n-                                            vec![cx.expr_str(sp, test_path_symbol)],\n+                                            thin_vec![cx.expr_str(sp, test_path_symbol)],\n                                         ),\n                                     ),\n                                     // ignore: true | false\n@@ -300,7 +300,7 @@ pub fn expand_test_or_bench(\n                                             ShouldPanic::Yes(Some(sym)) => cx.expr_call(\n                                                 sp,\n                                                 cx.expr_path(should_panic_path(\"YesWithMessage\")),\n-                                                vec![cx.expr_str(sp, sym)],\n+                                                thin_vec![cx.expr_str(sp, sym)],\n                                             ),\n                                         },\n                                     ),"}, {"sha": "9d4233607b7b1c6d450729d44900e2e1d8120073", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -14,7 +14,8 @@ use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::PanicStrategy;\n use smallvec::{smallvec, SmallVec};\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n+use tracing::debug;\n \n use std::{iter, mem};\n \n@@ -299,7 +300,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     test_runner.span = sp;\n \n     let test_main_path_expr = ecx.expr_path(test_runner);\n-    let call_test_main = ecx.expr_call(sp, test_main_path_expr, vec![mk_tests_slice(cx, sp)]);\n+    let call_test_main = ecx.expr_call(sp, test_main_path_expr, thin_vec![mk_tests_slice(cx, sp)]);\n     let call_test_main = ecx.stmt_expr(call_test_main);\n \n     // extern crate test\n@@ -312,7 +313,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     let main_attr = ecx.attr_word(sym::rustc_main, sp);\n \n     // pub fn main() { ... }\n-    let main_ret_ty = ecx.ty(sp, ast::TyKind::Tup(vec![]));\n+    let main_ret_ty = ecx.ty(sp, ast::TyKind::Tup(ThinVec::new()));\n \n     // If no test runner is provided we need to import the test crate\n     let main_body = if cx.test_runner.is_none() {\n@@ -321,7 +322,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n         ecx.block(sp, vec![call_test_main])\n     };\n \n-    let decl = ecx.fn_decl(vec![], ast::FnRetTy::Ty(main_ret_ty));\n+    let decl = ecx.fn_decl(ThinVec::new(), ast::FnRetTy::Ty(main_ret_ty));\n     let sig = ast::FnSig { decl, header: ast::FnHeader::default(), span: sp };\n     let defaultness = ast::Defaultness::Final;\n     let main = ast::ItemKind::Fn(Box::new(ast::Fn {"}, {"sha": "22bc90f5cac2ee8e1d44d9ed19c71f30f98ad3b5", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -29,10 +29,11 @@ use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, FileName, Span, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n-\n+use std::default::Default;\n use std::iter;\n use std::path::{Path, PathBuf};\n use std::rc::Rc;\n+use thin_vec::ThinVec;\n \n pub(crate) use rustc_span::hygiene::MacroKind;\n \n@@ -554,7 +555,7 @@ impl DummyResult {\n     pub fn raw_expr(sp: Span, is_error: bool) -> P<ast::Expr> {\n         P(ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n-            kind: if is_error { ast::ExprKind::Err } else { ast::ExprKind::Tup(Vec::new()) },\n+            kind: if is_error { ast::ExprKind::Err } else { ast::ExprKind::Tup(ThinVec::new()) },\n             span: sp,\n             attrs: ast::AttrVec::new(),\n             tokens: None,\n@@ -570,7 +571,7 @@ impl DummyResult {\n     pub fn raw_ty(sp: Span, is_error: bool) -> P<ast::Ty> {\n         P(ast::Ty {\n             id: ast::DUMMY_NODE_ID,\n-            kind: if is_error { ast::TyKind::Err } else { ast::TyKind::Tup(Vec::new()) },\n+            kind: if is_error { ast::TyKind::Err } else { ast::TyKind::Tup(ThinVec::new()) },\n             span: sp,\n             tokens: None,\n         })"}, {"sha": "d1c4102d57945c7049380b79ede359dea2721c9e", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -5,7 +5,7 @@ use rustc_ast::{attr, token, util::literal};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n-use thin_vec::ThinVec;\n+use thin_vec::{thin_vec, ThinVec};\n \n impl<'a> ExtCtxt<'a> {\n     pub fn path(&self, span: Span, strs: Vec<Ident>) -> ast::Path {\n@@ -284,18 +284,23 @@ impl<'a> ExtCtxt<'a> {\n         &self,\n         span: Span,\n         expr: P<ast::Expr>,\n-        args: Vec<P<ast::Expr>>,\n+        args: ThinVec<P<ast::Expr>>,\n     ) -> P<ast::Expr> {\n         self.expr(span, ast::ExprKind::Call(expr, args))\n     }\n-    pub fn expr_call_ident(&self, span: Span, id: Ident, args: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n+    pub fn expr_call_ident(\n+        &self,\n+        span: Span,\n+        id: Ident,\n+        args: ThinVec<P<ast::Expr>>,\n+    ) -> P<ast::Expr> {\n         self.expr(span, ast::ExprKind::Call(self.expr_ident(span, id), args))\n     }\n     pub fn expr_call_global(\n         &self,\n         sp: Span,\n         fn_path: Vec<Ident>,\n-        args: Vec<P<ast::Expr>>,\n+        args: ThinVec<P<ast::Expr>>,\n     ) -> P<ast::Expr> {\n         let pathexpr = self.expr_path(self.path_global(sp, fn_path));\n         self.expr_call(sp, pathexpr, args)\n@@ -372,12 +377,12 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     /// `[expr1, expr2, ...]`\n-    pub fn expr_array(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n+    pub fn expr_array(&self, sp: Span, exprs: ThinVec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Array(exprs))\n     }\n \n     /// `&[expr1, expr2, ...]`\n-    pub fn expr_array_ref(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n+    pub fn expr_array_ref(&self, sp: Span, exprs: ThinVec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr_addr_of(sp, self.expr_array(sp, exprs))\n     }\n \n@@ -387,22 +392,22 @@ impl<'a> ExtCtxt<'a> {\n \n     pub fn expr_some(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let some = self.std_path(&[sym::option, sym::Option, sym::Some]);\n-        self.expr_call_global(sp, some, vec![expr])\n+        self.expr_call_global(sp, some, thin_vec![expr])\n     }\n \n     pub fn expr_none(&self, sp: Span) -> P<ast::Expr> {\n         let none = self.std_path(&[sym::option, sym::Option, sym::None]);\n         self.expr_path(self.path_global(sp, none))\n     }\n-    pub fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n+    pub fn expr_tuple(&self, sp: Span, exprs: ThinVec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Tup(exprs))\n     }\n \n     pub fn expr_fail(&self, span: Span, msg: Symbol) -> P<ast::Expr> {\n         self.expr_call_global(\n             span,\n             [sym::std, sym::rt, sym::begin_panic].iter().map(|s| Ident::new(*s, span)).collect(),\n-            vec![self.expr_str(span, msg)],\n+            thin_vec![self.expr_str(span, msg)],\n         )\n     }\n \n@@ -412,7 +417,7 @@ impl<'a> ExtCtxt<'a> {\n \n     pub fn expr_ok(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let ok = self.std_path(&[sym::result, sym::Result, sym::Ok]);\n-        self.expr_call_global(sp, ok, vec![expr])\n+        self.expr_call_global(sp, ok, thin_vec![expr])\n     }\n \n     pub fn expr_try(&self, sp: Span, head: P<ast::Expr>) -> P<ast::Expr> {\n@@ -426,12 +431,12 @@ impl<'a> ExtCtxt<'a> {\n         let binding_expr = self.expr_ident(sp, binding_variable);\n \n         // `Ok(__try_var)` pattern\n-        let ok_pat = self.pat_tuple_struct(sp, ok_path, vec![binding_pat.clone()]);\n+        let ok_pat = self.pat_tuple_struct(sp, ok_path, thin_vec![binding_pat.clone()]);\n \n         // `Err(__try_var)` (pattern and expression respectively)\n-        let err_pat = self.pat_tuple_struct(sp, err_path.clone(), vec![binding_pat]);\n+        let err_pat = self.pat_tuple_struct(sp, err_path.clone(), thin_vec![binding_pat]);\n         let err_inner_expr =\n-            self.expr_call(sp, self.expr_path(err_path), vec![binding_expr.clone()]);\n+            self.expr_call(sp, self.expr_path(err_path), thin_vec![binding_expr.clone()]);\n         // `return Err(__try_var)`\n         let err_expr = self.expr(sp, ast::ExprKind::Ret(Some(err_inner_expr)));\n \n@@ -473,7 +478,7 @@ impl<'a> ExtCtxt<'a> {\n         &self,\n         span: Span,\n         path: ast::Path,\n-        subpats: Vec<P<ast::Pat>>,\n+        subpats: ThinVec<P<ast::Pat>>,\n     ) -> P<ast::Pat> {\n         self.pat(span, PatKind::TupleStruct(None, path, subpats))\n     }\n@@ -485,14 +490,14 @@ impl<'a> ExtCtxt<'a> {\n     ) -> P<ast::Pat> {\n         self.pat(span, PatKind::Struct(None, path, field_pats, false))\n     }\n-    pub fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n+    pub fn pat_tuple(&self, span: Span, pats: ThinVec<P<ast::Pat>>) -> P<ast::Pat> {\n         self.pat(span, PatKind::Tuple(pats))\n     }\n \n     pub fn pat_some(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n         let some = self.std_path(&[sym::option, sym::Option, sym::Some]);\n         let path = self.path_global(span, some);\n-        self.pat_tuple_struct(span, path, vec![pat])\n+        self.pat_tuple_struct(span, path, thin_vec![pat])\n     }\n \n     pub fn arm(&self, span: Span, pat: P<ast::Pat>, expr: P<ast::Expr>) -> ast::Arm {\n@@ -579,7 +584,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     // `self` is unused but keep it as method for the convenience use.\n-    pub fn fn_decl(&self, inputs: Vec<ast::Param>, output: ast::FnRetTy) -> P<ast::FnDecl> {\n+    pub fn fn_decl(&self, inputs: ThinVec<ast::Param>, output: ast::FnRetTy) -> P<ast::FnDecl> {\n         P(ast::FnDecl { inputs, output })\n     }\n "}, {"sha": "fab16b80fb59ceac7f6298d616fe2d2c415a8d57", "filename": "compiler/rustc_hir_analysis/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_hir_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_hir_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2FCargo.toml?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -9,7 +9,6 @@ doctest = false\n \n [dependencies]\n rustc_arena = { path = \"../rustc_arena\" }\n-tracing = \"0.1\"\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_attr = { path = \"../rustc_attr\" }\n@@ -27,3 +26,5 @@ rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_lint = { path = \"../rustc_lint\" }\n rustc_type_ir = { path = \"../rustc_type_ir\" }\n rustc_feature = { path = \"../rustc_feature\" }\n+thin-vec = \"0.2.12\"\n+tracing = \"0.1\""}, {"sha": "ad89393956e680abf0f5333b671451c265c501e3", "filename": "compiler/rustc_incremental/Cargo.toml", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_incremental%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_incremental%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2FCargo.toml?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -6,16 +6,17 @@ edition = \"2021\"\n [lib]\n \n [dependencies]\n-rustc_graphviz = { path = \"../rustc_graphviz\" }\n-tracing = \"0.1\"\n rand = \"0.8.4\"\n-rustc_middle = { path = \"../rustc_middle\" }\n+rustc_ast = { path = \"../rustc_ast\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_errors = { path = \"../rustc_errors\" }\n+rustc_fs_util = { path = \"../rustc_fs_util\" }\n+rustc_graphviz = { path = \"../rustc_graphviz\" }\n rustc_hir = { path = \"../rustc_hir\" }\n-rustc_serialize = { path = \"../rustc_serialize\" }\n-rustc_ast = { path = \"../rustc_ast\" }\n rustc_macros = { path = \"../rustc_macros\" }\n-rustc_span = { path = \"../rustc_span\" }\n-rustc_fs_util = { path = \"../rustc_fs_util\" }\n+rustc_middle = { path = \"../rustc_middle\" }\n+rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }\n-rustc_errors = { path = \"../rustc_errors\" }\n+rustc_span = { path = \"../rustc_span\" }\n+thin-vec = \"0.2.12\"\n+tracing = \"0.1\""}, {"sha": "b4b0ea00c50c0d1eaf47e870eaaafb7b369b563f", "filename": "compiler/rustc_incremental/src/assert_module_sources.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -30,6 +30,7 @@ use rustc_middle::mir::mono::CodegenUnitNameBuilder;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::cgu_reuse_tracker::*;\n use rustc_span::symbol::{sym, Symbol};\n+use thin_vec::ThinVec;\n \n #[allow(missing_docs)]\n pub fn assert_module_sources(tcx: TyCtxt<'_>) {\n@@ -138,7 +139,7 @@ impl<'tcx> AssertModuleSource<'tcx> {\n     }\n \n     fn field(&self, attr: &ast::Attribute, name: Symbol) -> Symbol {\n-        for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n+        for item in attr.meta_item_list().unwrap_or_else(ThinVec::new) {\n             if item.has_name(name) {\n                 if let Some(value) = item.value_str() {\n                     return value;"}, {"sha": "b839416c9195714f5e2b7883edce8c963d7a84ad", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -31,6 +31,8 @@ use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n+use std::iter::FromIterator;\n+use thin_vec::ThinVec;\n \n const LOADED_FROM_DISK: Symbol = sym::loaded_from_disk;\n const EXCEPT: Symbol = sym::except;\n@@ -205,7 +207,7 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n \n     /// `loaded_from_disk=` attribute value\n     fn loaded_from_disk(&self, attr: &Attribute) -> Labels {\n-        for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n+        for item in attr.meta_item_list().unwrap_or_else(ThinVec::new) {\n             if item.has_name(LOADED_FROM_DISK) {\n                 let value = expect_associated_value(self.tcx, &item);\n                 return self.resolve_labels(&item, value);\n@@ -217,7 +219,7 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n \n     /// `except=` attribute value\n     fn except(&self, attr: &Attribute) -> Labels {\n-        for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n+        for item in attr.meta_item_list().unwrap_or_else(ThinVec::new) {\n             if item.has_name(EXCEPT) {\n                 let value = expect_associated_value(self.tcx, &item);\n                 return self.resolve_labels(&item, value);\n@@ -397,7 +399,7 @@ fn check_config(tcx: TyCtxt<'_>, attr: &Attribute) -> bool {\n     let config = &tcx.sess.parse_sess.config;\n     debug!(\"check_config: config={:?}\", config);\n     let mut cfg = None;\n-    for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n+    for item in attr.meta_item_list().unwrap_or_else(ThinVec::new) {\n         if item.has_name(CFG) {\n             let value = expect_associated_value(tcx, &item);\n             debug!(\"check_config: searching for cfg {:?}\", value);"}, {"sha": "9fa657e725cf2709b9cd367316f1665cc641cc87", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -6,6 +6,9 @@ use rustc_ast::attr;\n use rustc_ast::token::{self, Delimiter, Nonterminal};\n use rustc_errors::{error_code, fluent, Diagnostic, IntoDiagnostic, PResult};\n use rustc_span::{sym, BytePos, Span};\n+use std::convert::TryInto;\n+use thin_vec::ThinVec;\n+use tracing::debug;\n \n // Public for rustfmt usage\n #[derive(Debug)]\n@@ -346,9 +349,9 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Matches `COMMASEP(meta_item_inner)`.\n-    pub(crate) fn parse_meta_seq_top(&mut self) -> PResult<'a, Vec<ast::NestedMetaItem>> {\n+    pub(crate) fn parse_meta_seq_top(&mut self) -> PResult<'a, ThinVec<ast::NestedMetaItem>> {\n         // Presumably, the majority of the time there will only be one attr.\n-        let mut nmis = Vec::with_capacity(1);\n+        let mut nmis = ThinVec::with_capacity(1);\n         while self.token.kind != token::Eof {\n             nmis.push(self.parse_meta_item_inner()?);\n             if !self.eat(&token::Comma) {"}, {"sha": "e60333f46448a65748a197b24192a0b7af2e7a0d", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -2175,7 +2175,7 @@ impl<'a> Parser<'a> {\n     /// the parameters are *names* (so we don't emit errors about not being able to find `b` in\n     /// the local scope), but if we find the same name multiple times, like in `fn foo(i8, i8)`,\n     /// we deduplicate them to not complain about duplicated parameter names.\n-    pub(super) fn deduplicate_recovered_params_names(&self, fn_inputs: &mut Vec<Param>) {\n+    pub(super) fn deduplicate_recovered_params_names(&self, fn_inputs: &mut ThinVec<Param>) {\n         let mut seen_inputs = FxHashSet::default();\n         for input in fn_inputs.iter_mut() {\n             let opt_ident = if let (PatKind::Ident(_, ident, _), TyKind::Err) ="}, {"sha": "74c08f9776e018cce630b5f36a59db58984a60a0", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -31,6 +31,7 @@ use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_span::source_map::{self, Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, Pos};\n+use thin_vec::{thin_vec, ThinVec};\n \n /// Possibly accepts an `token::Interpolated` expression (a pre-parsed expression\n /// dropped into the token stream, which happens while parsing the result of\n@@ -124,7 +125,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a sequence of expressions delimited by parentheses.\n-    fn parse_paren_expr_seq(&mut self) -> PResult<'a, Vec<P<Expr>>> {\n+    fn parse_paren_expr_seq(&mut self) -> PResult<'a, ThinVec<P<Expr>>> {\n         self.parse_paren_comma_seq(|p| p.parse_expr_catch_underscore()).map(|(r, _)| r)\n     }\n \n@@ -1450,7 +1451,7 @@ impl<'a> Parser<'a> {\n         let close = &token::CloseDelim(close_delim);\n         let kind = if self.eat(close) {\n             // Empty vector\n-            ExprKind::Array(Vec::new())\n+            ExprKind::Array(ThinVec::new())\n         } else {\n             // Non-empty vector\n             let first_expr = self.parse_expr()?;\n@@ -1468,7 +1469,7 @@ impl<'a> Parser<'a> {\n             } else {\n                 // Vector with one element\n                 self.expect(close)?;\n-                ExprKind::Array(vec![first_expr])\n+                ExprKind::Array(thin_vec![first_expr])\n             }\n         };\n         let expr = self.mk_expr(lo.to(self.prev_token.span), kind);\n@@ -2187,7 +2188,7 @@ impl<'a> Parser<'a> {\n         let arg_start = self.token.span.lo();\n \n         let inputs = if self.eat(&token::OrOr) {\n-            Vec::new()\n+            ThinVec::new()\n         } else {\n             self.expect(&token::BinOp(token::Or))?;\n             let args = self\n@@ -3211,7 +3212,7 @@ impl<'a> Parser<'a> {\n         ExprKind::Index(expr, idx)\n     }\n \n-    fn mk_call(&self, f: P<Expr>, args: Vec<P<Expr>>) -> ExprKind {\n+    fn mk_call(&self, f: P<Expr>, args: ThinVec<P<Expr>>) -> ExprKind {\n         ExprKind::Call(f, args)\n     }\n "}, {"sha": "8d0f168e09d7efccc4339a440e40c35ffe697af4", "filename": "compiler/rustc_parse/src/parser/generics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -18,7 +18,7 @@ use thin_vec::ThinVec;\n \n enum PredicateOrStructBody {\n     Predicate(ast::WherePredicate),\n-    StructBody(Vec<ast::FieldDef>),\n+    StructBody(ThinVec<ast::FieldDef>),\n }\n \n impl<'a> Parser<'a> {\n@@ -278,14 +278,14 @@ impl<'a> Parser<'a> {\n         &mut self,\n         struct_name: Ident,\n         body_insertion_point: Span,\n-    ) -> PResult<'a, (WhereClause, Option<Vec<ast::FieldDef>>)> {\n+    ) -> PResult<'a, (WhereClause, Option<ThinVec<ast::FieldDef>>)> {\n         self.parse_where_clause_common(Some((struct_name, body_insertion_point)))\n     }\n \n     fn parse_where_clause_common(\n         &mut self,\n         struct_: Option<(Ident, Span)>,\n-    ) -> PResult<'a, (WhereClause, Option<Vec<ast::FieldDef>>)> {\n+    ) -> PResult<'a, (WhereClause, Option<ThinVec<ast::FieldDef>>)> {\n         let mut where_clause = WhereClause {\n             has_where_token: false,\n             predicates: ThinVec::new(),"}, {"sha": "4e338f52f5725afd5ba5fc663041174128f99241", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -26,7 +26,7 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::DUMMY_SP;\n use std::fmt::Write;\n use std::mem;\n-use thin_vec::ThinVec;\n+use thin_vec::{thin_vec, ThinVec};\n \n impl<'a> Parser<'a> {\n     /// Parses a source module as a crate. This is the main entry point for the parser.\n@@ -997,7 +997,7 @@ impl<'a> Parser<'a> {\n     /// ```text\n     /// USE_TREE_LIST = \u00d8 | (USE_TREE `,`)* USE_TREE [`,`]\n     /// ```\n-    fn parse_use_tree_list(&mut self) -> PResult<'a, Vec<(UseTree, ast::NodeId)>> {\n+    fn parse_use_tree_list(&mut self) -> PResult<'a, ThinVec<(UseTree, ast::NodeId)>> {\n         self.parse_delim_comma_seq(Delimiter::Brace, |p| {\n             p.recover_diff_marker();\n             Ok((p.parse_use_tree()?, DUMMY_NODE_ID))\n@@ -1288,7 +1288,7 @@ impl<'a> Parser<'a> {\n         let (variants, _) = if self.token == TokenKind::Semi {\n             self.sess.emit_err(errors::UseEmptyBlockNotSemi { span: self.token.span });\n             self.bump();\n-            (vec![], false)\n+            (thin_vec![], false)\n         } else {\n             self.parse_delim_comma_seq(Delimiter::Brace, |p| p.parse_enum_variant()).map_err(\n                 |mut e| {\n@@ -1457,8 +1457,8 @@ impl<'a> Parser<'a> {\n         adt_ty: &str,\n         ident_span: Span,\n         parsed_where: bool,\n-    ) -> PResult<'a, (Vec<FieldDef>, /* recovered */ bool)> {\n-        let mut fields = Vec::new();\n+    ) -> PResult<'a, (ThinVec<FieldDef>, /* recovered */ bool)> {\n+        let mut fields = ThinVec::new();\n         let mut recovered = false;\n         if self.eat(&token::OpenDelim(Delimiter::Brace)) {\n             while self.token != token::CloseDelim(Delimiter::Brace) {\n@@ -1498,7 +1498,7 @@ impl<'a> Parser<'a> {\n         Ok((fields, recovered))\n     }\n \n-    pub(super) fn parse_tuple_struct_body(&mut self) -> PResult<'a, Vec<FieldDef>> {\n+    pub(super) fn parse_tuple_struct_body(&mut self) -> PResult<'a, ThinVec<FieldDef>> {\n         // This is the case where we find `struct Foo<T>(T) where T: Copy;`\n         // Unit like structs are handled in parse_item_struct function\n         self.parse_paren_comma_seq(|p| {\n@@ -2374,7 +2374,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses the parameter list of a function, including the `(` and `)` delimiters.\n-    pub(super) fn parse_fn_params(&mut self, req_name: ReqName) -> PResult<'a, Vec<Param>> {\n+    pub(super) fn parse_fn_params(&mut self, req_name: ReqName) -> PResult<'a, ThinVec<Param>> {\n         let mut first_param = true;\n         // Parse the arguments, starting out with `self` being allowed...\n         let (mut params, _) = self.parse_paren_comma_seq(|p| {"}, {"sha": "623c82b37e07da8b0d39446089e5421477dc031a", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -36,9 +36,10 @@ use rustc_errors::{\n use rustc_session::parse::ParseSess;\n use rustc_span::source_map::{Span, DUMMY_SP};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-\n use std::ops::Range;\n use std::{cmp, mem, slice};\n+use thin_vec::ThinVec;\n+use tracing::debug;\n \n use crate::errors::{\n     DocCommentDoesNotDocumentAnything, IncorrectVisibilityRestriction, MismatchedClosingDelimiter,\n@@ -853,11 +854,11 @@ impl<'a> Parser<'a> {\n         sep: SeqSep,\n         expect: TokenExpectType,\n         mut f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n-    ) -> PResult<'a, (Vec<T>, bool /* trailing */, bool /* recovered */)> {\n+    ) -> PResult<'a, (ThinVec<T>, bool /* trailing */, bool /* recovered */)> {\n         let mut first = true;\n         let mut recovered = false;\n         let mut trailing = false;\n-        let mut v = vec![];\n+        let mut v = ThinVec::new();\n         let unclosed_delims = !self.unclosed_delims.is_empty();\n \n         while !self.expect_any_with_type(kets, expect) {\n@@ -1037,7 +1038,7 @@ impl<'a> Parser<'a> {\n         ket: &TokenKind,\n         sep: SeqSep,\n         f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n-    ) -> PResult<'a, (Vec<T>, bool, bool)> {\n+    ) -> PResult<'a, (ThinVec<T>, bool, bool)> {\n         self.parse_seq_to_before_tokens(&[ket], sep, TokenExpectType::Expect, f)\n     }\n \n@@ -1049,7 +1050,7 @@ impl<'a> Parser<'a> {\n         ket: &TokenKind,\n         sep: SeqSep,\n         f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n-    ) -> PResult<'a, (Vec<T>, bool /* trailing */)> {\n+    ) -> PResult<'a, (ThinVec<T>, bool /* trailing */)> {\n         let (val, trailing, recovered) = self.parse_seq_to_before_end(ket, sep, f)?;\n         if !recovered {\n             self.eat(ket);\n@@ -1066,7 +1067,7 @@ impl<'a> Parser<'a> {\n         ket: &TokenKind,\n         sep: SeqSep,\n         f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n-    ) -> PResult<'a, (Vec<T>, bool)> {\n+    ) -> PResult<'a, (ThinVec<T>, bool)> {\n         self.expect(bra)?;\n         self.parse_seq_to_end(ket, sep, f)\n     }\n@@ -1075,7 +1076,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         delim: Delimiter,\n         f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n-    ) -> PResult<'a, (Vec<T>, bool)> {\n+    ) -> PResult<'a, (ThinVec<T>, bool)> {\n         self.parse_unspanned_seq(\n             &token::OpenDelim(delim),\n             &token::CloseDelim(delim),\n@@ -1087,7 +1088,7 @@ impl<'a> Parser<'a> {\n     fn parse_paren_comma_seq<T>(\n         &mut self,\n         f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n-    ) -> PResult<'a, (Vec<T>, bool)> {\n+    ) -> PResult<'a, (ThinVec<T>, bool)> {\n         self.parse_delim_comma_seq(Delimiter::Parenthesis, f)\n     }\n "}, {"sha": "54fbd36ab28c8d51df8e9caaf98307bf2ffce5c4", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -23,6 +23,7 @@ use rustc_errors::{\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::source_map::{respan, Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident};\n+use thin_vec::thin_vec;\n \n #[derive(PartialEq, Copy, Clone)]\n pub enum Expected {\n@@ -155,15 +156,15 @@ impl<'a> Parser<'a> {\n                 // If there was a leading vert, treat this as an or-pattern. This improves\n                 // diagnostics.\n                 let span = leading_vert_span.to(self.prev_token.span);\n-                return Ok((self.mk_pat(span, PatKind::Or(vec![first_pat])), trailing_vert));\n+                return Ok((self.mk_pat(span, PatKind::Or(thin_vec![first_pat])), trailing_vert));\n             }\n \n             return Ok((first_pat, trailing_vert));\n         }\n \n         // Parse the patterns `p_1 | ... | p_n` where `n > 0`.\n         let lo = leading_vert_span.unwrap_or(first_pat.span);\n-        let mut pats = vec![first_pat];\n+        let mut pats = thin_vec![first_pat];\n         loop {\n             match self.eat_or_separator(Some(lo)) {\n                 EatOrResult::AteOr => {}"}, {"sha": "989a2bdca6d34ec385fd82954dd93bc61e442064", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -1046,7 +1046,7 @@ impl<'a> Parser<'a> {\n \n         // Parse `(T, U) -> R`.\n         let inputs_lo = self.token.span;\n-        let inputs: Vec<_> =\n+        let inputs: ThinVec<_> =\n             self.parse_fn_params(|_| false)?.into_iter().map(|input| input.ty).collect();\n         let inputs_span = inputs_lo.to(self.prev_token.span);\n         let output = self.parse_ret_ty(AllowPlus::No, RecoverQPath::No, RecoverReturnSign::No)?;"}, {"sha": "c48f7998c5a01b847b1656e3b6de37464a24364e", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -18,7 +18,6 @@ serde_json = \"1.0\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n smallvec = \"1.8.1\"\n tempfile = \"3\"\n-thin-vec = \"0.2.12\"\n tracing = \"0.1\"\n tracing-tree = \"0.2.0\"\n "}, {"sha": "bb62660e19494dc550cd8cb9f9533a3351a6c24d", "filename": "src/librustdoc/clean/cfg/tests.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -4,6 +4,7 @@ use rustc_ast::{LitKind, MetaItemLit, Path, StrStyle};\n use rustc_span::create_default_session_globals_then;\n use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::DUMMY_SP;\n+use thin_vec::thin_vec;\n \n fn word_cfg(s: &str) -> Cfg {\n     Cfg::Cfg(Symbol::intern(s), None)\n@@ -34,7 +35,7 @@ macro_rules! dummy_meta_item_list {\n     ($name:ident, [$($list:ident),* $(,)?]) => {\n         MetaItem {\n             path: Path::from_ident(Ident::from_str(stringify!($name))),\n-            kind: MetaItemKind::List(vec![\n+            kind: MetaItemKind::List(thin_vec![\n                 $(\n                     NestedMetaItem::MetaItem(\n                         dummy_meta_item_word(stringify!($list)),\n@@ -48,7 +49,7 @@ macro_rules! dummy_meta_item_list {\n     ($name:ident, [$($list:expr),* $(,)?]) => {\n         MetaItem {\n             path: Path::from_ident(Ident::from_str(stringify!($name))),\n-            kind: MetaItemKind::List(vec![\n+            kind: MetaItemKind::List(thin_vec![\n                 $(\n                     NestedMetaItem::MetaItem($list),\n                 )*"}, {"sha": "4fcf0873600ab5b4a3d623b16220fda56fc6dea7", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -20,6 +20,7 @@\n #![allow(clippy::collapsible_if, clippy::collapsible_else_if)]\n #![allow(rustc::potential_query_instability)]\n \n+extern crate thin_vec;\n #[macro_use]\n extern crate tracing;\n "}, {"sha": "9011f0896a057579c53965f3f10a4981d2936f5b", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -42,6 +42,7 @@ extern crate rustc_session;\n extern crate rustc_span;\n extern crate rustc_target;\n extern crate rustc_trait_selection;\n+extern crate thin_vec;\n \n #[macro_use]\n extern crate clippy_utils;"}, {"sha": "06d248204c1f4c5d26a23d4462f0eb977054c374", "filename": "src/tools/clippy/clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -12,9 +12,9 @@ use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::DUMMY_SP;\n-\n use std::cell::Cell;\n use std::mem;\n+use thin_vec::{thin_vec, ThinVec};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -214,7 +214,7 @@ macro_rules! always_pat {\n /// Focus on `focus_idx` in `alternatives`,\n /// attempting to extend it with elements of the same constructor `C`\n /// in `alternatives[focus_idx + 1..]`.\n-fn transform_with_focus_on_idx(alternatives: &mut Vec<P<Pat>>, focus_idx: usize) -> bool {\n+fn transform_with_focus_on_idx(alternatives: &mut ThinVec<P<Pat>>, focus_idx: usize) -> bool {\n     // Extract the kind; we'll need to make some changes in it.\n     let mut focus_kind = mem::replace(&mut alternatives[focus_idx].kind, PatKind::Wild);\n     // We'll focus on `alternatives[focus_idx]`,\n@@ -296,7 +296,7 @@ fn extend_with_struct_pat(\n     fps1: &mut [ast::PatField],\n     rest1: bool,\n     start: usize,\n-    alternatives: &mut Vec<P<Pat>>,\n+    alternatives: &mut ThinVec<P<Pat>>,\n ) -> bool {\n     (0..fps1.len()).any(|idx| {\n         let pos_in_2 = Cell::new(None); // The element `k`.\n@@ -336,9 +336,9 @@ fn extend_with_struct_pat(\n fn extend_with_matching_product(\n     targets: &mut [P<Pat>],\n     start: usize,\n-    alternatives: &mut Vec<P<Pat>>,\n+    alternatives: &mut ThinVec<P<Pat>>,\n     predicate: impl Fn(&PatKind, &[P<Pat>], usize) -> bool,\n-    extract: impl Fn(PatKind) -> Vec<P<Pat>>,\n+    extract: impl Fn(PatKind) -> ThinVec<P<Pat>>,\n ) -> bool {\n     (0..targets.len()).any(|idx| {\n         let tail_or = drain_matching(\n@@ -365,14 +365,14 @@ fn take_pat(from: &mut Pat) -> Pat {\n \n /// Extend `target` as an or-pattern with the alternatives\n /// in `tail_or` if there are any and return if there were.\n-fn extend_with_tail_or(target: &mut Pat, tail_or: Vec<P<Pat>>) -> bool {\n-    fn extend(target: &mut Pat, mut tail_or: Vec<P<Pat>>) {\n+fn extend_with_tail_or(target: &mut Pat, tail_or: ThinVec<P<Pat>>) -> bool {\n+    fn extend(target: &mut Pat, mut tail_or: ThinVec<P<Pat>>) {\n         match target {\n             // On an existing or-pattern in the target, append to it.\n             Pat { kind: Or(ps), .. } => ps.append(&mut tail_or),\n             // Otherwise convert the target to an or-pattern.\n             target => {\n-                let mut init_or = vec![P(take_pat(target))];\n+                let mut init_or = thin_vec![P(take_pat(target))];\n                 init_or.append(&mut tail_or);\n                 target.kind = Or(init_or);\n             },\n@@ -391,26 +391,42 @@ fn extend_with_tail_or(target: &mut Pat, tail_or: Vec<P<Pat>>) -> bool {\n // Only elements beginning with `start` are considered for extraction.\n fn drain_matching(\n     start: usize,\n-    alternatives: &mut Vec<P<Pat>>,\n+    alternatives: &mut ThinVec<P<Pat>>,\n     predicate: impl Fn(&PatKind) -> bool,\n     extract: impl Fn(PatKind) -> P<Pat>,\n-) -> Vec<P<Pat>> {\n-    let mut tail_or = vec![];\n+) -> ThinVec<P<Pat>> {\n+    let mut tail_or = ThinVec::new();\n     let mut idx = 0;\n-    for pat in alternatives.drain_filter(|p| {\n-        // Check if we should extract, but only if `idx >= start`.\n+\n+    // If `ThinVec` had the `drain_filter` method, this loop could be rewritten\n+    // like so:\n+    // \n+    //   for pat in alternatives.drain_filter(|p| {\n+    //       // Check if we should extract, but only if `idx >= start`.\n+    //       idx += 1;\n+    //       idx > start && predicate(&p.kind)\n+    //   }) {\n+    //       tail_or.push(extract(pat.into_inner().kind));\n+    //   }\n+    let mut i = 0;\n+    while i < alternatives.len() {\n         idx += 1;\n-        idx > start && predicate(&p.kind)\n-    }) {\n-        tail_or.push(extract(pat.into_inner().kind));\n+        // Check if we should extract, but only if `idx >= start`.\n+\tif idx > start && predicate(&alternatives[i].kind) {\n+\t    let pat = alternatives.remove(i);\n+            tail_or.push(extract(pat.into_inner().kind));\n+\t} else {\n+\t    i += 1;\n+\t}\n     }\n+\n     tail_or\n }\n \n fn extend_with_matching(\n     target: &mut Pat,\n     start: usize,\n-    alternatives: &mut Vec<P<Pat>>,\n+    alternatives: &mut ThinVec<P<Pat>>,\n     predicate: impl Fn(&PatKind) -> bool,\n     extract: impl Fn(PatKind) -> P<Pat>,\n ) -> bool {"}, {"sha": "d82098523e3bea2a967577714dc9f2929f89e892", "filename": "src/tools/clippy/clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -144,7 +144,8 @@ pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n         (_, Paren(r)) => eq_expr(l, r),\n         (Err, Err) => true,\n         (Box(l), Box(r)) | (Try(l), Try(r)) | (Await(l), Await(r)) => eq_expr(l, r),\n-        (Array(l), Array(r)) | (Tup(l), Tup(r)) => over(l, r, |l, r| eq_expr(l, r)),\n+        (Array(l), Array(r)) => over(l, r, |l, r| eq_expr(l, r)),\n+        (Tup(l), Tup(r)) => over(l, r, |l, r| eq_expr(l, r)),\n         (Repeat(le, ls), Repeat(re, rs)) => eq_expr(le, re) && eq_expr(&ls.value, &rs.value),\n         (Call(lc, la), Call(rc, ra)) => eq_expr(lc, rc) && over(la, ra, |l, r| eq_expr(l, r)),\n         ("}, {"sha": "cbe523c6c3ca98c743bfeb858eca540d84bf6919", "filename": "src/tools/rustfmt/src/chains.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/src%2Ftools%2Frustfmt%2Fsrc%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/src%2Ftools%2Frustfmt%2Fsrc%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fchains.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -74,6 +74,8 @@ use crate::utils::{\n     rewrite_ident, trimmed_last_line_width, wrap_str,\n };\n \n+use thin_vec::ThinVec;\n+\n /// Provides the original input contents from the span\n /// of a chain element with trailing spaces trimmed.\n fn format_overflow_style(span: Span, context: &RewriteContext<'_>) -> Option<String> {\n@@ -168,7 +170,7 @@ enum ChainItemKind {\n     MethodCall(\n         ast::PathSegment,\n         Vec<ast::GenericArg>,\n-        Vec<ptr::P<ast::Expr>>,\n+        ThinVec<ptr::P<ast::Expr>>,\n     ),\n     StructField(symbol::Ident),\n     TupleField(symbol::Ident, bool),"}, {"sha": "b27405efdb700ee2342a783e996ee1c4781e9846", "filename": "src/tools/rustfmt/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/src%2Ftools%2Frustfmt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/src%2Ftools%2Frustfmt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Flib.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -23,6 +23,7 @@ extern crate rustc_expand;\n extern crate rustc_parse;\n extern crate rustc_session;\n extern crate rustc_span;\n+extern crate thin_vec;\n \n // Necessary to pull in object code as the rest of the rustc crates are shipped only as rmeta\n // files."}, {"sha": "1f0e96b954b90da71f76a5f230942ef12695683f", "filename": "tests/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/tests%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/tests%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -76,17 +76,17 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n     for kind in 0..=19 {\n         match kind {\n             0 => iter_exprs(depth - 1, &mut |e| g(ExprKind::Box(e))),\n-            1 => iter_exprs(depth - 1, &mut |e| g(ExprKind::Call(e, vec![]))),\n+            1 => iter_exprs(depth - 1, &mut |e| g(ExprKind::Call(e, thin_vec![]))),\n             2 => {\n                 let seg = PathSegment::from_ident(Ident::from_str(\"x\"));\n                 iter_exprs(depth - 1, &mut |e| {\n                     g(ExprKind::MethodCall(Box::new(MethodCall {\n-                        seg: seg.clone(), receiver: e, args: vec![make_x()], span: DUMMY_SP\n+                        seg: seg.clone(), receiver: e, args: thin_vec![make_x()], span: DUMMY_SP\n                     }))\n                 )});\n                 iter_exprs(depth - 1, &mut |e| {\n                     g(ExprKind::MethodCall(Box::new(MethodCall {\n-                        seg: seg.clone(), receiver: make_x(), args: vec![e], span: DUMMY_SP\n+                        seg: seg.clone(), receiver: make_x(), args: thin_vec![e], span: DUMMY_SP\n                     }))\n                 )});\n             }\n@@ -121,7 +121,7 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::If(e, block.clone(), None)));\n             }\n             11 => {\n-                let decl = P(FnDecl { inputs: vec![], output: FnRetTy::Default(DUMMY_SP) });\n+                let decl = P(FnDecl { inputs: thin_vec![], output: FnRetTy::Default(DUMMY_SP) });\n                 iter_exprs(depth - 1, &mut |e| {\n                     g(ExprKind::Closure(Box::new(Closure {\n                         binder: ClosureBinder::NotPresent,"}, {"sha": "a46d725b94bf2d06e68fb735b4231639f7e48bec", "filename": "tests/ui/stats/hir-stats.stderr", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/tests%2Fui%2Fstats%2Fhir-stats.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4143b101f9b0949c4bc6db1124f86ef02b1ef7aa/tests%2Fui%2Fstats%2Fhir-stats.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstats%2Fhir-stats.stderr?ref=4143b101f9b0949c4bc6db1124f86ef02b1ef7aa", "patch": "@@ -1,119 +1,119 @@\n ast-stats-1 PRE EXPANSION AST STATS\n ast-stats-1 Name                Accumulated Size         Count     Item Size\n ast-stats-1 ----------------------------------------------------------------\n+ast-stats-1 GenericArgs               40 ( 0.6%)             1            40\n+ast-stats-1 - AngleBracketed            40 ( 0.6%)             1\n ast-stats-1 ExprField                 48 ( 0.7%)             1            48\n ast-stats-1 WherePredicate            56 ( 0.8%)             1            56\n ast-stats-1 - BoundPredicate            56 ( 0.8%)             1\n-ast-stats-1 GenericArgs               56 ( 0.8%)             1            56\n-ast-stats-1 - AngleBracketed            56 ( 0.8%)             1\n ast-stats-1 Crate                     56 ( 0.8%)             1            56\n ast-stats-1 Attribute                 64 ( 0.9%)             2            32\n ast-stats-1 - Normal                    32 ( 0.5%)             1\n ast-stats-1 - DocComment                32 ( 0.5%)             1\n-ast-stats-1 Local                     72 ( 1.0%)             1            72\n+ast-stats-1 Local                     72 ( 1.1%)             1            72\n ast-stats-1 Arm                       96 ( 1.4%)             2            48\n ast-stats-1 ForeignItem               96 ( 1.4%)             1            96\n ast-stats-1 - Fn                        96 ( 1.4%)             1\n+ast-stats-1 FnDecl                   120 ( 1.8%)             5            24\n ast-stats-1 FieldDef                 160 ( 2.3%)             2            80\n ast-stats-1 Stmt                     160 ( 2.3%)             5            32\n ast-stats-1 - Local                     32 ( 0.5%)             1\n ast-stats-1 - MacCall                   32 ( 0.5%)             1\n ast-stats-1 - Expr                      96 ( 1.4%)             3\n ast-stats-1 Param                    160 ( 2.3%)             4            40\n-ast-stats-1 FnDecl                   200 ( 2.8%)             5            40\n-ast-stats-1 GenericBound             224 ( 3.2%)             4            56\n-ast-stats-1 - Trait                    224 ( 3.2%)             4\n-ast-stats-1 Variant                  240 ( 3.4%)             2           120\n-ast-stats-1 Block                    288 ( 4.1%)             6            48\n-ast-stats-1 AssocItem                416 ( 5.9%)             4           104\n+ast-stats-1 Variant                  208 ( 3.0%)             2           104\n+ast-stats-1 GenericBound             224 ( 3.3%)             4            56\n+ast-stats-1 - Trait                    224 ( 3.3%)             4\n+ast-stats-1 Block                    288 ( 4.2%)             6            48\n+ast-stats-1 AssocItem                416 ( 6.1%)             4           104\n ast-stats-1 - Type                     208 ( 3.0%)             2\n ast-stats-1 - Fn                       208 ( 3.0%)             2\n-ast-stats-1 GenericParam             480 ( 6.8%)             5            96\n-ast-stats-1 Expr                     576 ( 8.2%)             8            72\n-ast-stats-1 - Path                      72 ( 1.0%)             1\n-ast-stats-1 - Match                     72 ( 1.0%)             1\n-ast-stats-1 - Struct                    72 ( 1.0%)             1\n-ast-stats-1 - Lit                      144 ( 2.0%)             2\n-ast-stats-1 - Block                    216 ( 3.1%)             3\n-ast-stats-1 Pat                      616 ( 8.7%)             7            88\n-ast-stats-1 - Struct                    88 ( 1.2%)             1\n-ast-stats-1 - Wild                      88 ( 1.2%)             1\n-ast-stats-1 - Ident                    440 ( 6.2%)             5\n-ast-stats-1 PathSegment              720 (10.2%)            30            24\n-ast-stats-1 Ty                       896 (12.7%)            14            64\n+ast-stats-1 GenericParam             480 ( 7.0%)             5            96\n+ast-stats-1 Expr                     576 ( 8.4%)             8            72\n+ast-stats-1 - Path                      72 ( 1.1%)             1\n+ast-stats-1 - Match                     72 ( 1.1%)             1\n+ast-stats-1 - Struct                    72 ( 1.1%)             1\n+ast-stats-1 - Lit                      144 ( 2.1%)             2\n+ast-stats-1 - Block                    216 ( 3.2%)             3\n+ast-stats-1 Pat                      616 ( 9.0%)             7            88\n+ast-stats-1 - Struct                    88 ( 1.3%)             1\n+ast-stats-1 - Wild                      88 ( 1.3%)             1\n+ast-stats-1 - Ident                    440 ( 6.4%)             5\n+ast-stats-1 PathSegment              720 (10.5%)            30            24\n+ast-stats-1 Ty                       896 (13.1%)            14            64\n ast-stats-1 - Ptr                       64 ( 0.9%)             1\n ast-stats-1 - Ref                       64 ( 0.9%)             1\n-ast-stats-1 - ImplicitSelf             128 ( 1.8%)             2\n-ast-stats-1 - Path                     640 ( 9.1%)            10\n-ast-stats-1 Item                   1_368 (19.4%)             9           152\n-ast-stats-1 - Trait                    152 ( 2.2%)             1\n-ast-stats-1 - Enum                     152 ( 2.2%)             1\n-ast-stats-1 - ForeignMod               152 ( 2.2%)             1\n-ast-stats-1 - Impl                     152 ( 2.2%)             1\n-ast-stats-1 - Fn                       304 ( 4.3%)             2\n-ast-stats-1 - Use                      456 ( 6.5%)             3\n+ast-stats-1 - ImplicitSelf             128 ( 1.9%)             2\n+ast-stats-1 - Path                     640 ( 9.3%)            10\n+ast-stats-1 Item                   1_296 (18.9%)             9           144\n+ast-stats-1 - Trait                    144 ( 2.1%)             1\n+ast-stats-1 - Enum                     144 ( 2.1%)             1\n+ast-stats-1 - ForeignMod               144 ( 2.1%)             1\n+ast-stats-1 - Impl                     144 ( 2.1%)             1\n+ast-stats-1 - Fn                       288 ( 4.2%)             2\n+ast-stats-1 - Use                      432 ( 6.3%)             3\n ast-stats-1 ----------------------------------------------------------------\n-ast-stats-1 Total                  7_048\n+ast-stats-1 Total                  6_848\n ast-stats-1\n ast-stats-2 POST EXPANSION AST STATS\n ast-stats-2 Name                Accumulated Size         Count     Item Size\n ast-stats-2 ----------------------------------------------------------------\n+ast-stats-2 GenericArgs               40 ( 0.5%)             1            40\n+ast-stats-2 - AngleBracketed            40 ( 0.5%)             1\n ast-stats-2 ExprField                 48 ( 0.6%)             1            48\n-ast-stats-2 WherePredicate            56 ( 0.7%)             1            56\n-ast-stats-2 - BoundPredicate            56 ( 0.7%)             1\n-ast-stats-2 GenericArgs               56 ( 0.7%)             1            56\n-ast-stats-2 - AngleBracketed            56 ( 0.7%)             1\n-ast-stats-2 Crate                     56 ( 0.7%)             1            56\n-ast-stats-2 Local                     72 ( 0.9%)             1            72\n-ast-stats-2 Arm                       96 ( 1.2%)             2            48\n-ast-stats-2 ForeignItem               96 ( 1.2%)             1            96\n-ast-stats-2 - Fn                        96 ( 1.2%)             1\n+ast-stats-2 WherePredicate            56 ( 0.8%)             1            56\n+ast-stats-2 - BoundPredicate            56 ( 0.8%)             1\n+ast-stats-2 Crate                     56 ( 0.8%)             1            56\n+ast-stats-2 Local                     72 ( 1.0%)             1            72\n+ast-stats-2 Arm                       96 ( 1.3%)             2            48\n+ast-stats-2 ForeignItem               96 ( 1.3%)             1            96\n+ast-stats-2 - Fn                        96 ( 1.3%)             1\n ast-stats-2 InlineAsm                120 ( 1.6%)             1           120\n+ast-stats-2 FnDecl                   120 ( 1.6%)             5            24\n ast-stats-2 Attribute                128 ( 1.7%)             4            32\n ast-stats-2 - DocComment                32 ( 0.4%)             1\n-ast-stats-2 - Normal                    96 ( 1.2%)             3\n+ast-stats-2 - Normal                    96 ( 1.3%)             3\n ast-stats-2 FieldDef                 160 ( 2.1%)             2            80\n ast-stats-2 Stmt                     160 ( 2.1%)             5            32\n ast-stats-2 - Local                     32 ( 0.4%)             1\n ast-stats-2 - Semi                      32 ( 0.4%)             1\n-ast-stats-2 - Expr                      96 ( 1.2%)             3\n+ast-stats-2 - Expr                      96 ( 1.3%)             3\n ast-stats-2 Param                    160 ( 2.1%)             4            40\n-ast-stats-2 FnDecl                   200 ( 2.6%)             5            40\n-ast-stats-2 GenericBound             224 ( 2.9%)             4            56\n-ast-stats-2 - Trait                    224 ( 2.9%)             4\n-ast-stats-2 Variant                  240 ( 3.1%)             2           120\n-ast-stats-2 Block                    288 ( 3.8%)             6            48\n-ast-stats-2 AssocItem                416 ( 5.4%)             4           104\n-ast-stats-2 - Type                     208 ( 2.7%)             2\n-ast-stats-2 - Fn                       208 ( 2.7%)             2\n-ast-stats-2 GenericParam             480 ( 6.2%)             5            96\n-ast-stats-2 Pat                      616 ( 8.0%)             7            88\n-ast-stats-2 - Struct                    88 ( 1.1%)             1\n-ast-stats-2 - Wild                      88 ( 1.1%)             1\n-ast-stats-2 - Ident                    440 ( 5.7%)             5\n-ast-stats-2 Expr                     648 ( 8.4%)             9            72\n-ast-stats-2 - Path                      72 ( 0.9%)             1\n-ast-stats-2 - Match                     72 ( 0.9%)             1\n-ast-stats-2 - Struct                    72 ( 0.9%)             1\n-ast-stats-2 - InlineAsm                 72 ( 0.9%)             1\n+ast-stats-2 Variant                  208 ( 2.8%)             2           104\n+ast-stats-2 GenericBound             224 ( 3.0%)             4            56\n+ast-stats-2 - Trait                    224 ( 3.0%)             4\n+ast-stats-2 Block                    288 ( 3.9%)             6            48\n+ast-stats-2 AssocItem                416 ( 5.6%)             4           104\n+ast-stats-2 - Type                     208 ( 2.8%)             2\n+ast-stats-2 - Fn                       208 ( 2.8%)             2\n+ast-stats-2 GenericParam             480 ( 6.4%)             5            96\n+ast-stats-2 Pat                      616 ( 8.3%)             7            88\n+ast-stats-2 - Struct                    88 ( 1.2%)             1\n+ast-stats-2 - Wild                      88 ( 1.2%)             1\n+ast-stats-2 - Ident                    440 ( 5.9%)             5\n+ast-stats-2 Expr                     648 ( 8.7%)             9            72\n+ast-stats-2 - Path                      72 ( 1.0%)             1\n+ast-stats-2 - Match                     72 ( 1.0%)             1\n+ast-stats-2 - Struct                    72 ( 1.0%)             1\n+ast-stats-2 - InlineAsm                 72 ( 1.0%)             1\n ast-stats-2 - Lit                      144 ( 1.9%)             2\n-ast-stats-2 - Block                    216 ( 2.8%)             3\n-ast-stats-2 PathSegment              792 (10.3%)            33            24\n-ast-stats-2 Ty                       896 (11.7%)            14            64\n-ast-stats-2 - Ptr                       64 ( 0.8%)             1\n-ast-stats-2 - Ref                       64 ( 0.8%)             1\n+ast-stats-2 - Block                    216 ( 2.9%)             3\n+ast-stats-2 PathSegment              792 (10.6%)            33            24\n+ast-stats-2 Ty                       896 (12.0%)            14            64\n+ast-stats-2 - Ptr                       64 ( 0.9%)             1\n+ast-stats-2 - Ref                       64 ( 0.9%)             1\n ast-stats-2 - ImplicitSelf             128 ( 1.7%)             2\n-ast-stats-2 - Path                     640 ( 8.3%)            10\n-ast-stats-2 Item                   1_672 (21.8%)            11           152\n-ast-stats-2 - Trait                    152 ( 2.0%)             1\n-ast-stats-2 - Enum                     152 ( 2.0%)             1\n-ast-stats-2 - ExternCrate              152 ( 2.0%)             1\n-ast-stats-2 - ForeignMod               152 ( 2.0%)             1\n-ast-stats-2 - Impl                     152 ( 2.0%)             1\n-ast-stats-2 - Fn                       304 ( 4.0%)             2\n-ast-stats-2 - Use                      608 ( 7.9%)             4\n+ast-stats-2 - Path                     640 ( 8.6%)            10\n+ast-stats-2 Item                   1_584 (21.2%)            11           144\n+ast-stats-2 - Trait                    144 ( 1.9%)             1\n+ast-stats-2 - Enum                     144 ( 1.9%)             1\n+ast-stats-2 - ExternCrate              144 ( 1.9%)             1\n+ast-stats-2 - ForeignMod               144 ( 1.9%)             1\n+ast-stats-2 - Impl                     144 ( 1.9%)             1\n+ast-stats-2 - Fn                       288 ( 3.9%)             2\n+ast-stats-2 - Use                      576 ( 7.7%)             4\n ast-stats-2 ----------------------------------------------------------------\n-ast-stats-2 Total                  7_680\n+ast-stats-2 Total                  7_464\n ast-stats-2\n hir-stats HIR STATS\n hir-stats Name                Accumulated Size         Count     Item Size"}]}