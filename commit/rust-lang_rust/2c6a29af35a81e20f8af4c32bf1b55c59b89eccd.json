{"sha": "2c6a29af35a81e20f8af4c32bf1b55c59b89eccd", "node_id": "C_kwDOAAsO6NoAKDJjNmEyOWFmMzVhODFlMjBmOGFmNGMzMmJmMWI1NWM1OWI4OWVjY2Q", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-11T21:44:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-11T21:44:06Z"}, "message": "Auto merge of #94860 - Dylan-DPC:rollup-n06j8h6, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #87618 (Add missing documentation for std::char types)\n - #94769 (Collapse blanket and auto-trait impls by default)\n - #94798 (`parse_tt` refactorings)\n - #94818 (Rename `IntoFuture::Future` to `IntoFuture::IntoFuture`)\n - #94827 (CTFE/Miri: detect out-of-bounds pointers in offset_from)\n - #94838 (Make float parsing docs more comprehensive)\n - #94839 (Suggest using double colon when a struct field type include single colon)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "60b96b37ebcd14063e0bdd6763d997486876af60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60b96b37ebcd14063e0bdd6763d997486876af60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd", "html_url": "https://github.com/rust-lang/rust/commit/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "335ffbfa547df94ac236f5c56130cecf99c8d82b", "url": "https://api.github.com/repos/rust-lang/rust/commits/335ffbfa547df94ac236f5c56130cecf99c8d82b", "html_url": "https://github.com/rust-lang/rust/commit/335ffbfa547df94ac236f5c56130cecf99c8d82b"}, {"sha": "298c9a0e14944872d1b919a21c7d84d0c6d6a713", "url": "https://api.github.com/repos/rust-lang/rust/commits/298c9a0e14944872d1b919a21c7d84d0c6d6a713", "html_url": "https://github.com/rust-lang/rust/commit/298c9a0e14944872d1b919a21c7d84d0c6d6a713"}], "stats": {"total": 517, "additions": 334, "deletions": 183}, "files": [{"sha": "a39ef22ec0834a561304aeba5fa0ac5ba668e71f", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 42, "deletions": 38, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=2c6a29af35a81e20f8af4c32bf1b55c59b89eccd", "patch": "@@ -307,53 +307,57 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_pointer(offset_ptr, dest)?;\n             }\n             sym::ptr_offset_from => {\n-                let a = self.read_immediate(&args[0])?.to_scalar()?;\n-                let b = self.read_immediate(&args[1])?.to_scalar()?;\n+                let a = self.read_pointer(&args[0])?;\n+                let b = self.read_pointer(&args[1])?;\n \n                 // Special case: if both scalars are *equal integers*\n                 // and not null, we pretend there is an allocation of size 0 right there,\n                 // and their offset is 0. (There's never a valid object at null, making it an\n                 // exception from the exception.)\n                 // This is the dual to the special exception for offset-by-0\n-                // in the inbounds pointer offset operation (see the Miri code, `src/operator.rs`).\n-                //\n-                // Control flow is weird because we cannot early-return (to reach the\n-                // `go_to_block` at the end).\n-                let done = if let (Ok(a), Ok(b)) = (a.try_to_int(), b.try_to_int()) {\n-                    let a = a.try_to_machine_usize(*self.tcx).unwrap();\n-                    let b = b.try_to_machine_usize(*self.tcx).unwrap();\n-                    if a == b && a != 0 {\n+                // in the inbounds pointer offset operation (see `ptr_offset_inbounds` below).\n+                match (self.memory.ptr_try_get_alloc(a), self.memory.ptr_try_get_alloc(b)) {\n+                    (Err(a), Err(b)) if a == b && a != 0 => {\n+                        // Both are the same non-null integer.\n                         self.write_scalar(Scalar::from_machine_isize(0, self), dest)?;\n-                        true\n-                    } else {\n-                        false\n                     }\n-                } else {\n-                    false\n-                };\n-\n-                if !done {\n-                    // General case: we need two pointers.\n-                    let a = self.scalar_to_ptr(a);\n-                    let b = self.scalar_to_ptr(b);\n-                    let (a_alloc_id, a_offset, _) = self.memory.ptr_get_alloc(a)?;\n-                    let (b_alloc_id, b_offset, _) = self.memory.ptr_get_alloc(b)?;\n-                    if a_alloc_id != b_alloc_id {\n-                        throw_ub_format!(\n-                            \"ptr_offset_from cannot compute offset of pointers into different \\\n-                            allocations.\",\n-                        );\n+                    (Err(offset), _) | (_, Err(offset)) => {\n+                        throw_ub!(DanglingIntPointer(offset, CheckInAllocMsg::OffsetFromTest));\n+                    }\n+                    (Ok((a_alloc_id, a_offset, _)), Ok((b_alloc_id, b_offset, _))) => {\n+                        // Both are pointers. They must be into the same allocation.\n+                        if a_alloc_id != b_alloc_id {\n+                            throw_ub_format!(\n+                                \"ptr_offset_from cannot compute offset of pointers into different \\\n+                                allocations.\",\n+                            );\n+                        }\n+                        // And they must both be valid for zero-sized accesses (\"in-bounds or one past the end\").\n+                        self.memory.check_ptr_access_align(\n+                            a,\n+                            Size::ZERO,\n+                            Align::ONE,\n+                            CheckInAllocMsg::OffsetFromTest,\n+                        )?;\n+                        self.memory.check_ptr_access_align(\n+                            b,\n+                            Size::ZERO,\n+                            Align::ONE,\n+                            CheckInAllocMsg::OffsetFromTest,\n+                        )?;\n+\n+                        // Compute offset.\n+                        let usize_layout = self.layout_of(self.tcx.types.usize)?;\n+                        let isize_layout = self.layout_of(self.tcx.types.isize)?;\n+                        let a_offset = ImmTy::from_uint(a_offset.bytes(), usize_layout);\n+                        let b_offset = ImmTy::from_uint(b_offset.bytes(), usize_layout);\n+                        let (val, _overflowed, _ty) =\n+                            self.overflowing_binary_op(BinOp::Sub, &a_offset, &b_offset)?;\n+                        let pointee_layout = self.layout_of(substs.type_at(0))?;\n+                        let val = ImmTy::from_scalar(val, isize_layout);\n+                        let size = ImmTy::from_int(pointee_layout.size.bytes(), isize_layout);\n+                        self.exact_div(&val, &size, dest)?;\n                     }\n-                    let usize_layout = self.layout_of(self.tcx.types.usize)?;\n-                    let isize_layout = self.layout_of(self.tcx.types.isize)?;\n-                    let a_offset = ImmTy::from_uint(a_offset.bytes(), usize_layout);\n-                    let b_offset = ImmTy::from_uint(b_offset.bytes(), usize_layout);\n-                    let (val, _overflowed, _ty) =\n-                        self.overflowing_binary_op(BinOp::Sub, &a_offset, &b_offset)?;\n-                    let pointee_layout = self.layout_of(substs.type_at(0))?;\n-                    let val = ImmTy::from_scalar(val, isize_layout);\n-                    let size = ImmTy::from_int(pointee_layout.size.bytes(), isize_layout);\n-                    self.exact_div(&val, &size, dest)?;\n                 }\n             }\n "}, {"sha": "6397fcaaf8d10844823f6990034488f4eeb25173", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=2c6a29af35a81e20f8af4c32bf1b55c59b89eccd", "patch": "@@ -388,9 +388,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 CheckInAllocMsg::DerefTest | CheckInAllocMsg::MemoryAccessTest => {\n                     AllocCheck::Dereferenceable\n                 }\n-                CheckInAllocMsg::PointerArithmeticTest | CheckInAllocMsg::InboundsTest => {\n-                    AllocCheck::Live\n-                }\n+                CheckInAllocMsg::PointerArithmeticTest\n+                | CheckInAllocMsg::OffsetFromTest\n+                | CheckInAllocMsg::InboundsTest => AllocCheck::Live,\n             };\n             let (size, align) = self.get_size_and_align(alloc_id, check)?;\n             Ok((size, align, ()))"}, {"sha": "dedfd779bb416d7af3459540a860919a7b7244e9", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 128, "deletions": 118, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=2c6a29af35a81e20f8af4c32bf1b55c59b89eccd", "patch": "@@ -122,7 +122,7 @@ impl<'tt> TokenTreeOrTokenTreeSlice<'tt> {\n \n /// An unzipping of `TokenTree`s... see the `stack` field of `MatcherPos`.\n ///\n-/// This is used by `inner_parse_loop` to keep track of delimited submatchers that we have\n+/// This is used by `parse_tt_inner` to keep track of delimited submatchers that we have\n /// descended into.\n #[derive(Clone)]\n struct MatcherTtFrame<'tt> {\n@@ -439,9 +439,8 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n                 }\n                 Occupied(..) => return Err((sp, format!(\"duplicated bind name: {}\", bind_name))),\n             },\n-            // FIXME(c410-f3r) MetaVar and MetaVarExpr should be handled instead of being ignored\n-            // https://github.com/rust-lang/rust/issues/9390\n-            TokenTree::MetaVar(..) | TokenTree::MetaVarExpr(..) | TokenTree::Token(..) => {}\n+            TokenTree::Token(..) => (),\n+            TokenTree::MetaVar(..) | TokenTree::MetaVarExpr(..) => unreachable!(),\n         }\n \n         Ok(())\n@@ -481,21 +480,24 @@ fn token_name_eq(t1: &Token, t2: &Token) -> bool {\n ///   successful execution of this function.\n /// - `next_items`: the set of newly generated items. These are used to replenish `cur_items` in\n ///   the function `parse`.\n-/// - `eof_items`: the set of items that would be valid if this was the EOF.\n /// - `bb_items`: the set of items that are waiting for the black-box parser.\n /// - `token`: the current token of the parser.\n ///\n /// # Returns\n ///\n-/// A `ParseResult`. Note that matches are kept track of through the items generated.\n-fn inner_parse_loop<'root, 'tt>(\n+/// `Some(result)` if everything is finished, `None` otherwise. Note that matches are kept track of\n+/// through the items generated.\n+fn parse_tt_inner<'root, 'tt>(\n     sess: &ParseSess,\n+    ms: &[TokenTree],\n     cur_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n-    next_items: &mut Vec<MatcherPosHandle<'root, 'tt>>,\n+    next_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n     bb_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n-    eof_items: &mut EofItems<'root, 'tt>,\n     token: &Token,\n-) -> Result<(), (rustc_span::Span, String)> {\n+) -> Option<NamedParseResult> {\n+    // Matcher positions that would be valid if the macro invocation was over now\n+    let mut eof_items = EofItems::None;\n+\n     // Pop items from `cur_items` until it is empty.\n     while let Some(mut item) = cur_items.pop() {\n         // When unzipped trees end, remove them. This corresponds to backtracking out of a\n@@ -522,6 +524,8 @@ fn inner_parse_loop<'root, 'tt>(\n             // then we could be at the end of a sequence or at the beginning of the next\n             // repetition.\n             if let Some(repetition) = &item.repetition {\n+                debug_assert!(matches!(item.top_elts, Tt(TokenTree::Sequence(..))));\n+\n                 // At this point, regardless of whether there is a separator, we should add all\n                 // matches from the complete repetition of the sequence to the shared, top-level\n                 // `matches` list (actually, `up.matches`, which could itself not be the top-level,\n@@ -565,7 +569,7 @@ fn inner_parse_loop<'root, 'tt>(\n             } else {\n                 // If we are not in a repetition, then being at the end of a matcher means that we\n                 // have reached the potential end of the input.\n-                *eof_items = match eof_items {\n+                eof_items = match eof_items {\n                     EofItems::None => EofItems::One(item),\n                     EofItems::One(_) | EofItems::Multiple => EofItems::Multiple,\n                 }\n@@ -613,7 +617,7 @@ fn inner_parse_loop<'root, 'tt>(\n                 // We need to match a metavar (but the identifier is invalid)... this is an error\n                 TokenTree::MetaVarDecl(span, _, None) => {\n                     if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n-                        return Err((span, \"missing fragment specifier\".to_string()));\n+                        return Some(Error(span, \"missing fragment specifier\".to_string()));\n                     }\n                 }\n \n@@ -655,13 +659,36 @@ fn inner_parse_loop<'root, 'tt>(\n                 // rules. NOTE that this is not necessarily an error unless _all_ items in\n                 // `cur_items` end up doing this. There may still be some other matchers that do\n                 // end up working out.\n-                TokenTree::Token(..) | TokenTree::MetaVar(..) | TokenTree::MetaVarExpr(..) => {}\n+                TokenTree::Token(..) => {}\n+\n+                TokenTree::MetaVar(..) | TokenTree::MetaVarExpr(..) => unreachable!(),\n             }\n         }\n     }\n \n-    // Yay a successful parse (so far)!\n-    Ok(())\n+    // If we reached the EOF, check that there is EXACTLY ONE possible matcher. Otherwise,\n+    // either the parse is ambiguous (which should never happen) or there is a syntax error.\n+    if *token == token::Eof {\n+        Some(match eof_items {\n+            EofItems::One(mut eof_item) => {\n+                let matches =\n+                    eof_item.matches.iter_mut().map(|dv| Lrc::make_mut(dv).pop().unwrap());\n+                nameize(sess, ms, matches)\n+            }\n+            EofItems::Multiple => {\n+                Error(token.span, \"ambiguity: multiple successful parses\".to_string())\n+            }\n+            EofItems::None => Failure(\n+                Token::new(\n+                    token::Eof,\n+                    if token.span.is_dummy() { token.span } else { token.span.shrink_to_hi() },\n+                ),\n+                \"missing tokens in macro arguments\",\n+            ),\n+        })\n+    } else {\n+        None\n+    }\n }\n \n /// Use the given sequence of token trees (`ms`) as a matcher. Match the token\n@@ -672,7 +699,7 @@ pub(super) fn parse_tt(\n     macro_name: Ident,\n ) -> NamedParseResult {\n     // A queue of possible matcher positions. We initialize it with the matcher position in which\n-    // the \"dot\" is before the first token of the first token tree in `ms`. `inner_parse_loop` then\n+    // the \"dot\" is before the first token of the first token tree in `ms`. `parse_tt_inner` then\n     // processes all of these possible matcher positions and produces possible next positions into\n     // `next_items`. After some post-processing, the contents of `next_items` replenish `cur_items`\n     // and we start over again.\n@@ -681,135 +708,118 @@ pub(super) fn parse_tt(\n     // there are frequently *no* others! -- are allocated on the heap.\n     let mut initial = MatcherPos::new(ms);\n     let mut cur_items = smallvec![MatcherPosHandle::Ref(&mut initial)];\n-    let mut next_items = Vec::new();\n \n     loop {\n-        assert!(next_items.is_empty());\n+        let mut next_items = SmallVec::new();\n \n         // Matcher positions black-box parsed by parser.rs (`parser`)\n         let mut bb_items = SmallVec::new();\n \n-        // Matcher positions that would be valid if the macro invocation was over now\n-        let mut eof_items = EofItems::None;\n-\n         // Process `cur_items` until either we have finished the input or we need to get some\n         // parsing from the black-box parser done. The result is that `next_items` will contain a\n         // bunch of possible next matcher positions in `next_items`.\n-        match inner_parse_loop(\n+        if let Some(result) = parse_tt_inner(\n             parser.sess,\n+            ms,\n             &mut cur_items,\n             &mut next_items,\n             &mut bb_items,\n-            &mut eof_items,\n             &parser.token,\n         ) {\n-            Ok(()) => {}\n-            Err((sp, msg)) => return Error(sp, msg),\n+            return result;\n         }\n \n-        // inner parse loop handled all cur_items, so it's empty\n+        // `parse_tt_inner` handled all cur_items, so it's empty.\n         assert!(cur_items.is_empty());\n \n-        // We need to do some post processing after the `inner_parse_loop`.\n+        // We need to do some post processing after the `parse_tt_inner`.\n         //\n         // Error messages here could be improved with links to original rules.\n \n-        // If we reached the EOF, check that there is EXACTLY ONE possible matcher. Otherwise,\n-        // either the parse is ambiguous (which should never happen) or there is a syntax error.\n-        if parser.token == token::Eof {\n-            return match eof_items {\n-                EofItems::One(mut eof_item) => {\n-                    let matches =\n-                        eof_item.matches.iter_mut().map(|dv| Lrc::make_mut(dv).pop().unwrap());\n-                    nameize(parser.sess, ms, matches)\n-                }\n-                EofItems::Multiple => {\n-                    Error(parser.token.span, \"ambiguity: multiple successful parses\".to_string())\n-                }\n-                EofItems::None => Failure(\n-                    Token::new(\n-                        token::Eof,\n-                        if parser.token.span.is_dummy() {\n-                            parser.token.span\n-                        } else {\n-                            parser.token.span.shrink_to_hi()\n-                        },\n-                    ),\n-                    \"missing tokens in macro arguments\",\n-                ),\n-            };\n-        }\n-        // Performance hack: `eof_items` may share matchers via `Rc` with other things that we want\n-        // to modify. Dropping `eof_items` now may drop these refcounts to 1, preventing an\n-        // unnecessary implicit clone later in `Rc::make_mut`.\n-        drop(eof_items);\n-\n-        // If there are no possible next positions AND we aren't waiting for the black-box parser,\n-        // then there is a syntax error.\n-        if bb_items.is_empty() && next_items.is_empty() {\n-            return Failure(parser.token.clone(), \"no rules expected this token in macro call\");\n-        }\n+        match (next_items.len(), bb_items.len()) {\n+            (0, 0) => {\n+                // There are no possible next positions AND we aren't waiting for the black-box\n+                // parser: syntax error.\n+                return Failure(parser.token.clone(), \"no rules expected this token in macro call\");\n+            }\n \n-        if (!bb_items.is_empty() && !next_items.is_empty()) || bb_items.len() > 1 {\n-            // We need to call out to parse some rust nonterminal (black-box) parser. But something\n-            // is wrong, because there is not EXACTLY ONE of these.\n-            let nts = bb_items\n-                .iter()\n-                .map(|item| match item.top_elts.get_tt(item.idx) {\n-                    TokenTree::MetaVarDecl(_, bind, Some(kind)) => format!(\"{} ('{}')\", kind, bind),\n-                    _ => panic!(),\n-                })\n-                .collect::<Vec<String>>()\n-                .join(\" or \");\n-\n-            return Error(\n-                parser.token.span,\n-                format!(\n-                    \"local ambiguity when calling macro `{macro_name}`: multiple parsing options: {}\",\n-                    match next_items.len() {\n-                        0 => format!(\"built-in NTs {}.\", nts),\n-                        1 => format!(\"built-in NTs {} or 1 other option.\", nts),\n-                        n => format!(\"built-in NTs {} or {} other options.\", nts, n),\n-                    }\n-                ),\n-            );\n-        }\n+            (_, 0) => {\n+                // Dump all possible `next_items` into `cur_items` for the next iteration. Then\n+                // process the next token.\n+                cur_items.extend(next_items.drain(..));\n+                parser.to_mut().bump();\n+            }\n \n-        if !next_items.is_empty() {\n-            // Dump all possible `next_items` into `cur_items` for the next iteration. Then process\n-            // the next token.\n-            cur_items.extend(next_items.drain(..));\n-            parser.to_mut().bump();\n-        } else {\n-            // Finally, we have the case where we need to call the black-box parser to get some\n-            // nonterminal.\n-            assert_eq!(bb_items.len(), 1);\n-\n-            let mut item = bb_items.pop().unwrap();\n-            if let TokenTree::MetaVarDecl(span, _, Some(kind)) = item.top_elts.get_tt(item.idx) {\n-                let match_cur = item.match_cur;\n-                // We use the span of the metavariable declaration to determine any\n-                // edition-specific matching behavior for non-terminals.\n-                let nt = match parser.to_mut().parse_nonterminal(kind) {\n-                    Err(mut err) => {\n-                        err.span_label(\n-                            span,\n-                            format!(\"while parsing argument for this `{}` macro fragment\", kind),\n-                        )\n-                        .emit();\n-                        return ErrorReported;\n-                    }\n-                    Ok(nt) => nt,\n-                };\n-                item.push_match(match_cur, MatchedNonterminal(Lrc::new(nt)));\n-                item.idx += 1;\n-                item.match_cur += 1;\n-            } else {\n-                unreachable!()\n+            (0, 1) => {\n+                // We need to call the black-box parser to get some nonterminal.\n+                let mut item = bb_items.pop().unwrap();\n+                if let TokenTree::MetaVarDecl(span, _, Some(kind)) = item.top_elts.get_tt(item.idx)\n+                {\n+                    let match_cur = item.match_cur;\n+                    // We use the span of the metavariable declaration to determine any\n+                    // edition-specific matching behavior for non-terminals.\n+                    let nt = match parser.to_mut().parse_nonterminal(kind) {\n+                        Err(mut err) => {\n+                            err.span_label(\n+                                span,\n+                                format!(\"while parsing argument for this `{kind}` macro fragment\"),\n+                            )\n+                            .emit();\n+                            return ErrorReported;\n+                        }\n+                        Ok(nt) => nt,\n+                    };\n+                    item.push_match(match_cur, MatchedNonterminal(Lrc::new(nt)));\n+                    item.idx += 1;\n+                    item.match_cur += 1;\n+                } else {\n+                    unreachable!()\n+                }\n+                cur_items.push(item);\n+            }\n+\n+            (_, _) => {\n+                // We need to call the black-box parser to get some nonterminal, but something is\n+                // wrong.\n+                return bb_items_ambiguity_error(\n+                    macro_name,\n+                    next_items,\n+                    bb_items,\n+                    parser.token.span,\n+                );\n             }\n-            cur_items.push(item);\n         }\n \n         assert!(!cur_items.is_empty());\n     }\n }\n+\n+fn bb_items_ambiguity_error<'root, 'tt>(\n+    macro_name: Ident,\n+    next_items: SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n+    bb_items: SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n+    token_span: rustc_span::Span,\n+) -> NamedParseResult {\n+    let nts = bb_items\n+        .iter()\n+        .map(|item| match item.top_elts.get_tt(item.idx) {\n+            TokenTree::MetaVarDecl(_, bind, Some(kind)) => {\n+                format!(\"{} ('{}')\", kind, bind)\n+            }\n+            _ => panic!(),\n+        })\n+        .collect::<Vec<String>>()\n+        .join(\" or \");\n+\n+    Error(\n+        token_span,\n+        format!(\n+            \"local ambiguity when calling macro `{macro_name}`: multiple parsing options: {}\",\n+            match next_items.len() {\n+                0 => format!(\"built-in NTs {}.\", nts),\n+                1 => format!(\"built-in NTs {} or 1 other option.\", nts),\n+                n => format!(\"built-in NTs {} or {} other options.\", nts, n),\n+            }\n+        ),\n+    )\n+}"}, {"sha": "c97865904769820f5793b94e54b6f98a8e09d4dc", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=2c6a29af35a81e20f8af4c32bf1b55c59b89eccd", "patch": "@@ -184,6 +184,8 @@ pub enum CheckInAllocMsg {\n     MemoryAccessTest,\n     /// We are doing pointer arithmetic.\n     PointerArithmeticTest,\n+    /// We are doing pointer offset_from.\n+    OffsetFromTest,\n     /// None of the above -- generic/unspecific inbounds test.\n     InboundsTest,\n }\n@@ -199,6 +201,7 @@ impl fmt::Display for CheckInAllocMsg {\n                 CheckInAllocMsg::DerefTest => \"dereferencing pointer failed: \",\n                 CheckInAllocMsg::MemoryAccessTest => \"memory access failed: \",\n                 CheckInAllocMsg::PointerArithmeticTest => \"pointer arithmetic failed: \",\n+                CheckInAllocMsg::OffsetFromTest => \"out-of-bounds offset_from: \",\n                 CheckInAllocMsg::InboundsTest => \"\",\n             }\n         )\n@@ -358,6 +361,9 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n             DanglingIntPointer(0, CheckInAllocMsg::InboundsTest) => {\n                 write!(f, \"null pointer is not a valid pointer for this operation\")\n             }\n+            DanglingIntPointer(0, msg) => {\n+                write!(f, \"{}null pointer is not a valid pointer\", msg)\n+            }\n             DanglingIntPointer(i, msg) => {\n                 write!(f, \"{}0x{:x} is not a valid pointer\", msg, i)\n             }"}, {"sha": "122fe10e80f8fb331ce3aab4cae7a15c923ec420", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=2c6a29af35a81e20f8af4c32bf1b55c59b89eccd", "patch": "@@ -1534,6 +1534,16 @@ impl<'a> Parser<'a> {\n         let name = self.parse_field_ident(adt_ty, lo)?;\n         self.expect_field_ty_separator()?;\n         let ty = self.parse_ty()?;\n+        if self.token.kind == token::Colon && self.look_ahead(1, |tok| tok.kind != token::Colon) {\n+            self.struct_span_err(self.token.span, \"found single colon in a struct field type path\")\n+                .span_suggestion_verbose(\n+                    self.token.span,\n+                    \"write a path separator here\",\n+                    \"::\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                )\n+                .emit();\n+        }\n         if self.token.kind == token::Eq {\n             self.bump();\n             let const_expr = self.parse_anon_const_expr()?;"}, {"sha": "4ee0310b361fbce6f0d34a41c8e1b67b138d825f", "filename": "library/core/src/char/convert.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs?ref=2c6a29af35a81e20f8af4c32bf1b55c59b89eccd", "patch": "@@ -218,6 +218,8 @@ impl const From<u8> for char {\n }\n \n /// An error which can be returned when parsing a char.\n+///\n+/// This `struct` is created when using the [`char::from_str`] method.\n #[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct ParseCharError {\n@@ -300,7 +302,10 @@ impl TryFrom<u32> for char {\n     }\n }\n \n-/// The error type returned when a conversion from u32 to char fails.\n+/// The error type returned when a conversion from [`prim@u32`] to [`prim@char`] fails.\n+///\n+/// This `struct` is created by the [`char::try_from<u32>`](char#impl-TryFrom<u32>) method.\n+/// See its documentation for more.\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct CharTryFromError(());"}, {"sha": "8014dacdd98da6887b938cd1b377582b28f3e4a3", "filename": "library/core/src/future/into_future.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/library%2Fcore%2Fsrc%2Ffuture%2Finto_future.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/library%2Fcore%2Fsrc%2Ffuture%2Finto_future.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Finto_future.rs?ref=2c6a29af35a81e20f8af4c32bf1b55c59b89eccd", "patch": "@@ -9,20 +9,20 @@ pub trait IntoFuture {\n \n     /// Which kind of future are we turning this into?\n     #[unstable(feature = \"into_future\", issue = \"67644\")]\n-    type Future: Future<Output = Self::Output>;\n+    type IntoFuture: Future<Output = Self::Output>;\n \n     /// Creates a future from a value.\n     #[unstable(feature = \"into_future\", issue = \"67644\")]\n     #[lang = \"into_future\"]\n-    fn into_future(self) -> Self::Future;\n+    fn into_future(self) -> Self::IntoFuture;\n }\n \n #[unstable(feature = \"into_future\", issue = \"67644\")]\n impl<F: Future> IntoFuture for F {\n     type Output = F::Output;\n-    type Future = F;\n+    type IntoFuture = F;\n \n-    fn into_future(self) -> Self::Future {\n+    fn into_future(self) -> Self::IntoFuture {\n         self\n     }\n }"}, {"sha": "541adb69b8e2b400b9cfb04184e0e895644222ac", "filename": "library/core/src/num/dec2flt/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fmod.rs?ref=2c6a29af35a81e20f8af4c32bf1b55c59b89eccd", "patch": "@@ -112,21 +112,24 @@ macro_rules! from_str_float_impl {\n             /// * '2.5E-10'\n             /// * '5.'\n             /// * '.5', or, equivalently, '0.5'\n-            /// * 'inf', '-inf', 'NaN'\n+            /// * 'inf', '-inf', '+infinity', 'NaN'\n+            ///\n+            /// Note that alphabetical characters are not case-sensitive.\n             ///\n             /// Leading and trailing whitespace represent an error.\n             ///\n             /// # Grammar\n             ///\n-            /// All strings that adhere to the following [EBNF] grammar\n-            /// will result in an [`Ok`] being returned:\n+            /// All strings that adhere to the following [EBNF] grammar when\n+            /// lowercased will result in an [`Ok`] being returned:\n             ///\n             /// ```txt\n-            /// Float  ::= Sign? ( 'inf' | 'NaN' | Number )\n+            /// Float  ::= Sign? ( 'inf' | 'infinity' | 'nan' | Number )\n             /// Number ::= ( Digit+ |\n+            ///              '.' Digit* |\n             ///              Digit+ '.' Digit* |\n             ///              Digit* '.' Digit+ ) Exp?\n-            /// Exp    ::= [eE] Sign? Digit+\n+            /// Exp    ::= 'e' Sign? Digit+\n             /// Sign   ::= [+-]\n             /// Digit  ::= [0-9]\n             /// ```"}, {"sha": "34d1268a7df61d28dc179605d71b7ff6c2daee5a", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=2c6a29af35a81e20f8af4c32bf1b55c59b89eccd", "patch": "@@ -699,7 +699,13 @@ fn short_item_info(\n \n // Render the list of items inside one of the sections \"Trait Implementations\",\n // \"Auto Trait Implementations,\" \"Blanket Trait Implementations\" (on struct/enum pages).\n-fn render_impls(cx: &Context<'_>, w: &mut Buffer, impls: &[&&Impl], containing_item: &clean::Item) {\n+fn render_impls(\n+    cx: &Context<'_>,\n+    w: &mut Buffer,\n+    impls: &[&&Impl],\n+    containing_item: &clean::Item,\n+    toggle_open_by_default: bool,\n+) {\n     let tcx = cx.tcx();\n     let mut rendered_impls = impls\n         .iter()\n@@ -722,7 +728,7 @@ fn render_impls(cx: &Context<'_>, w: &mut Buffer, impls: &[&&Impl], containing_i\n                     is_on_foreign_type: false,\n                     show_default_items: true,\n                     show_non_assoc_items: true,\n-                    toggle_open_by_default: true,\n+                    toggle_open_by_default,\n                 },\n             );\n             buffer.into_inner()\n@@ -1143,7 +1149,7 @@ fn render_assoc_items_inner(\n             concrete.into_iter().partition(|t| t.inner_impl().kind.is_blanket());\n \n         let mut impls = Buffer::empty_from(w);\n-        render_impls(cx, &mut impls, &concrete, containing_item);\n+        render_impls(cx, &mut impls, &concrete, containing_item, true);\n         let impls = impls.into_inner();\n         if !impls.is_empty() {\n             write!(\n@@ -1165,7 +1171,7 @@ fn render_assoc_items_inner(\n                  </h2>\\\n                  <div id=\\\"synthetic-implementations-list\\\">\",\n             );\n-            render_impls(cx, w, &synthetic, containing_item);\n+            render_impls(cx, w, &synthetic, containing_item, false);\n             w.write_str(\"</div>\");\n         }\n \n@@ -1177,7 +1183,7 @@ fn render_assoc_items_inner(\n                  </h2>\\\n                  <div id=\\\"blanket-implementations-list\\\">\",\n             );\n-            render_impls(cx, w, &blanket_impl, containing_item);\n+            render_impls(cx, w, &blanket_impl, containing_item, false);\n             w.write_str(\"</div>\");\n         }\n     }"}, {"sha": "bbc85ecd4ad49e3d75448c84bafb213644cbd601", "filename": "src/test/rustdoc-gui/toggle-docs.goml", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/src%2Ftest%2Frustdoc-gui%2Ftoggle-docs.goml", "raw_url": "https://github.com/rust-lang/rust/raw/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/src%2Ftest%2Frustdoc-gui%2Ftoggle-docs.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Ftoggle-docs.goml?ref=2c6a29af35a81e20f8af4c32bf1b55c59b89eccd", "patch": "@@ -17,7 +17,14 @@ assert-text: (\"#toggle-all-docs\", \"[\u2212]\")\n goto: file://|DOC_PATH|/test_docs/struct.Foo.html\n // We first check that everything is visible.\n assert-text: (\"#toggle-all-docs\", \"[\u2212]\")\n-assert-attribute: (\"details.rustdoc-toggle\", {\"open\": \"\"}, ALL)\n+assert-attribute: (\"#implementations-list details.rustdoc-toggle\", {\"open\": \"\"}, ALL)\n+assert-attribute: (\"#trait-implementations-list details.rustdoc-toggle\", {\"open\": \"\"}, ALL)\n+assert-attribute-false: (\n+    \"#blanket-implementations-list > details.rustdoc-toggle\",\n+    {\"open\": \"\"},\n+    ALL,\n+)\n+\n // We collapse them all.\n click: \"#toggle-all-docs\"\n wait-for: 50"}, {"sha": "6e1b155e181eea8cc84ef2580991e7754f4f3427", "filename": "src/test/ui/async-await/await-into-future.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/src%2Ftest%2Fui%2Fasync-await%2Fawait-into-future.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/src%2Ftest%2Fui%2Fasync-await%2Fawait-into-future.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fawait-into-future.rs?ref=2c6a29af35a81e20f8af4c32bf1b55c59b89eccd", "patch": "@@ -10,9 +10,9 @@ struct AwaitMe;\n \n impl IntoFuture for AwaitMe {\n     type Output = i32;\n-    type Future = Pin<Box<dyn Future<Output = i32>>>;\n+    type IntoFuture = Pin<Box<dyn Future<Output = i32>>>;\n \n-    fn into_future(self) -> Self::Future {\n+    fn into_future(self) -> Self::IntoFuture {\n         Box::pin(me())\n     }\n }"}, {"sha": "fee61907eb3caa8d593239a7c26c999a99a8fc3d", "filename": "src/test/ui/consts/offset_from_ub.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs?ref=2c6a29af35a81e20f8af4c32bf1b55c59b89eccd", "patch": "@@ -1,4 +1,4 @@\n-#![feature(const_ptr_offset_from)]\n+#![feature(const_ptr_offset_from, const_ptr_offset)]\n #![feature(core_intrinsics)]\n \n use std::intrinsics::ptr_offset_from;\n@@ -44,4 +44,30 @@ pub const DIFFERENT_INT: isize = { // offset_from with two different integers: l\n     //~| 0x10 is not a valid pointer\n };\n \n+const OUT_OF_BOUNDS_1: isize = {\n+    let start_ptr = &4 as *const _ as *const u8;\n+    let length = 10;\n+    let end_ptr = (start_ptr).wrapping_add(length);\n+    // First ptr is out of bounds\n+    unsafe { ptr_offset_from(end_ptr, start_ptr) } //~ERROR evaluation of constant value failed\n+    //~| pointer at offset 10 is out-of-bounds\n+};\n+\n+const OUT_OF_BOUNDS_2: isize = {\n+    let start_ptr = &4 as *const _ as *const u8;\n+    let length = 10;\n+    let end_ptr = (start_ptr).wrapping_add(length);\n+    // Second ptr is out of bounds\n+    unsafe { ptr_offset_from(start_ptr, end_ptr) } //~ERROR evaluation of constant value failed\n+    //~| pointer at offset 10 is out-of-bounds\n+};\n+\n+const OUT_OF_BOUNDS_SAME: isize = {\n+    let start_ptr = &4 as *const _ as *const u8;\n+    let length = 10;\n+    let end_ptr = (start_ptr).wrapping_add(length);\n+    unsafe { ptr_offset_from(end_ptr, end_ptr) } //~ERROR evaluation of constant value failed\n+    //~| pointer at offset 10 is out-of-bounds\n+};\n+\n fn main() {}"}, {"sha": "4d60d4df203b33d4659513cf21a07ae7a540a2a9", "filename": "src/test/ui/consts/offset_from_ub.stderr", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr?ref=2c6a29af35a81e20f8af4c32bf1b55c59b89eccd", "patch": "@@ -10,7 +10,7 @@ error[E0080]: evaluation of constant value failed\n LL |         unsafe { intrinsics::ptr_offset_from(self, origin) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  0x2a is not a valid pointer\n+   |                  out-of-bounds offset_from: 0x2a is not a valid pointer\n    |                  inside `ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n   ::: $DIR/offset_from_ub.rs:23:14\n@@ -28,14 +28,32 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:36:14\n    |\n LL |     unsafe { ptr_offset_from(ptr, ptr) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^ null pointer is not a valid pointer for this operation\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: null pointer is not a valid pointer\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:43:14\n    |\n LL |     unsafe { ptr_offset_from(ptr2, ptr1) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 0x10 is not a valid pointer\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: 0x10 is not a valid pointer\n \n-error: aborting due to 5 previous errors\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/offset_from_ub.rs:52:14\n+   |\n+LL |     unsafe { ptr_offset_from(end_ptr, start_ptr) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc18 has size 4, so pointer at offset 10 is out-of-bounds\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/offset_from_ub.rs:61:14\n+   |\n+LL |     unsafe { ptr_offset_from(start_ptr, end_ptr) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc21 has size 4, so pointer at offset 10 is out-of-bounds\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/offset_from_ub.rs:69:14\n+   |\n+LL |     unsafe { ptr_offset_from(end_ptr, end_ptr) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc24 has size 4, so pointer at offset 10 is out-of-bounds\n+\n+error: aborting due to 8 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "237950a30e841ba7fc56eb040446d91cf9775354", "filename": "src/test/ui/consts/offset_ub.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr?ref=2c6a29af35a81e20f8af4c32bf1b55c59b89eccd", "patch": "@@ -144,7 +144,7 @@ error[E0080]: evaluation of constant value failed\n LL |         unsafe { intrinsics::offset(self, count) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  pointer arithmetic failed: 0x0 is not a valid pointer\n+   |                  pointer arithmetic failed: null pointer is not a valid pointer\n    |                  inside `ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n   ::: $DIR/offset_ub.rs:22:50"}, {"sha": "b7ad6d996f1aba2129b7902d71305e814b675a56", "filename": "src/test/ui/suggestions/struct-field-type-including-single-colon.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/src%2Ftest%2Fui%2Fsuggestions%2Fstruct-field-type-including-single-colon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/src%2Ftest%2Fui%2Fsuggestions%2Fstruct-field-type-including-single-colon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fstruct-field-type-including-single-colon.rs?ref=2c6a29af35a81e20f8af4c32bf1b55c59b89eccd", "patch": "@@ -0,0 +1,20 @@\n+mod foo {\n+    struct A;\n+    mod bar {\n+        struct B;\n+    }\n+}\n+\n+struct Foo {\n+    a: foo:A,\n+    //~^ ERROR found single colon in a struct field type path\n+    //~| expected `,`, or `}`, found `:`\n+}\n+\n+struct Bar {\n+    b: foo::bar:B,\n+    //~^ ERROR found single colon in a struct field type path\n+    //~| expected `,`, or `}`, found `:`\n+}\n+\n+fn main() {}"}, {"sha": "189759d64fc4ee59d24e8e21d0121bd81e1ffc9c", "filename": "src/test/ui/suggestions/struct-field-type-including-single-colon.stderr", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/src%2Ftest%2Fui%2Fsuggestions%2Fstruct-field-type-including-single-colon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c6a29af35a81e20f8af4c32bf1b55c59b89eccd/src%2Ftest%2Fui%2Fsuggestions%2Fstruct-field-type-including-single-colon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fstruct-field-type-including-single-colon.stderr?ref=2c6a29af35a81e20f8af4c32bf1b55c59b89eccd", "patch": "@@ -0,0 +1,36 @@\n+error: found single colon in a struct field type path\n+  --> $DIR/struct-field-type-including-single-colon.rs:9:11\n+   |\n+LL |     a: foo:A,\n+   |           ^\n+   |\n+help: write a path separator here\n+   |\n+LL |     a: foo::A,\n+   |           ~~\n+\n+error: expected `,`, or `}`, found `:`\n+  --> $DIR/struct-field-type-including-single-colon.rs:9:11\n+   |\n+LL |     a: foo:A,\n+   |           ^\n+\n+error: found single colon in a struct field type path\n+  --> $DIR/struct-field-type-including-single-colon.rs:15:16\n+   |\n+LL |     b: foo::bar:B,\n+   |                ^\n+   |\n+help: write a path separator here\n+   |\n+LL |     b: foo::bar::B,\n+   |                ~~\n+\n+error: expected `,`, or `}`, found `:`\n+  --> $DIR/struct-field-type-including-single-colon.rs:15:16\n+   |\n+LL |     b: foo::bar:B,\n+   |                ^\n+\n+error: aborting due to 4 previous errors\n+"}]}