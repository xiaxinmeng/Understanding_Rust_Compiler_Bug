{"sha": "87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3YTNjMWVlNzAxNmJiZmI3ODJmMmZkOGFkYzc1YjQ2Njg3ZWY5Mjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-02T12:45:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-02T12:45:03Z"}, "message": "Auto merge of #55316 - RalfJung:retagging, r=oli-obk\n\nAdd Retagging statements\n\nThis adds a `Retag` statement kind to MIR, used to perform the retagging operation from [Stacked Borrows](https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html). It also kills the old `Validate` statements that I added last year.\n\nNOTE: This includes https://github.com/rust-lang/rust/pull/55270. Only [these commits are new](https://github.com/RalfJung/rust/compare/stacked-borrows-ng...RalfJung:retagging).", "tree": {"sha": "d1f5ce96602af0244456e01139806980d7730c8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1f5ce96602af0244456e01139806980d7730c8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "html_url": "https://github.com/rust-lang/rust/commit/87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0c869c323289c5ec4df83e1c9091fa0b3e2fc07", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0c869c323289c5ec4df83e1c9091fa0b3e2fc07", "html_url": "https://github.com/rust-lang/rust/commit/d0c869c323289c5ec4df83e1c9091fa0b3e2fc07"}, {"sha": "d10304eeb5c9e63597b9ee1094aca0f63c4f31ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/d10304eeb5c9e63597b9ee1094aca0f63c4f31ca", "html_url": "https://github.com/rust-lang/rust/commit/d10304eeb5c9e63597b9ee1094aca0f63c4f31ca"}], "stats": {"total": 1372, "additions": 450, "deletions": 922}, "files": [{"sha": "344eb789ff60adda16e8d81282363153d8331d7a", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -253,8 +253,15 @@ fn main() {\n \n         // When running miri tests, we need to generate MIR for all libraries\n         if env::var(\"TEST_MIRI\").ok().map_or(false, |val| val == \"true\") {\n+            // The flags here should be kept in sync with `add_miri_default_args`\n+            // in miri's `src/lib.rs`.\n             cmd.arg(\"-Zalways-encode-mir\");\n-            cmd.arg(\"-Zmir-emit-validate=1\");\n+            // These options are preferred by miri, to be able to perform better validation,\n+            // but the bootstrap compiler might not understand them.\n+            if stage != \"0\" {\n+                cmd.arg(\"-Zmir-emit-retag\");\n+                cmd.arg(\"-Zmir-opt-level=0\");\n+            }\n         }\n \n         // Force all crates compiled by this compiler to (a) be unstable and (b)"}, {"sha": "a73fe2b8a1ab31e6535a7059bce266a338d6cba1", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -257,9 +257,9 @@ for mir::StatementKind<'gcx> {\n             mir::StatementKind::EndRegion(ref region_scope) => {\n                 region_scope.hash_stable(hcx, hasher);\n             }\n-            mir::StatementKind::Validate(ref op, ref places) => {\n-                op.hash_stable(hcx, hasher);\n-                places.hash_stable(hcx, hasher);\n+            mir::StatementKind::Retag { fn_entry, ref place } => {\n+                fn_entry.hash_stable(hcx, hasher);\n+                place.hash_stable(hcx, hasher);\n             }\n             mir::StatementKind::AscribeUserType(ref place, ref variance, ref c_ty) => {\n                 place.hash_stable(hcx, hasher);\n@@ -278,23 +278,6 @@ for mir::StatementKind<'gcx> {\n \n impl_stable_hash_for!(enum mir::FakeReadCause { ForMatchGuard, ForMatchedPlace, ForLet });\n \n-impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>>\n-    for mir::ValidationOperand<'gcx, T>\n-    where T: HashStable<StableHashingContext<'a>>\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>)\n-    {\n-        self.place.hash_stable(hcx, hasher);\n-        self.ty.hash_stable(hcx, hasher);\n-        self.re.hash_stable(hcx, hasher);\n-        self.mutbl.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl_stable_hash_for!(enum mir::ValidationOp { Acquire, Release, Suspend(region_scope) });\n-\n impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Place<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,"}, {"sha": "636fe115746fb83d36564ff7cc0cf4d5cc55a26e", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 14, "deletions": 64, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -1754,10 +1754,17 @@ pub enum StatementKind<'tcx> {\n         inputs: Box<[Operand<'tcx>]>,\n     },\n \n-    /// Assert the given places to be valid inhabitants of their type.  These statements are\n-    /// currently only interpreted by miri and only generated when \"-Z mir-emit-validate\" is passed.\n-    /// See <https://internals.rust-lang.org/t/types-as-contracts/5562/73> for more details.\n-    Validate(ValidationOp, Vec<ValidationOperand<'tcx, Place<'tcx>>>),\n+    /// Retag references in the given place, ensuring they got fresh tags.  This is\n+    /// part of the Stacked Borrows model. These statements are currently only interpreted\n+    /// by miri and only generated when \"-Z mir-emit-retag\" is passed.\n+    /// See <https://internals.rust-lang.org/t/stacked-borrows-an-aliasing-model-for-rust/8153/>\n+    /// for more details.\n+    Retag {\n+        /// `fn_entry` indicates whether this is the initial retag that happens in the\n+        /// function prolog.\n+        fn_entry: bool,\n+        place: Place<'tcx>,\n+    },\n \n     /// Mark one terminating point of a region scope (i.e. static region).\n     /// (The starting point(s) arise implicitly from borrows.)\n@@ -1810,57 +1817,6 @@ pub enum FakeReadCause {\n     ForLet,\n }\n \n-/// The `ValidationOp` describes what happens with each of the operands of a\n-/// `Validate` statement.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, PartialEq, Eq)]\n-pub enum ValidationOp {\n-    /// Recursively traverse the place following the type and validate that all type\n-    /// invariants are maintained.  Furthermore, acquire exclusive/read-only access to the\n-    /// memory reachable from the place.\n-    Acquire,\n-    /// Recursive traverse the *mutable* part of the type and relinquish all exclusive\n-    /// access.\n-    Release,\n-    /// Recursive traverse the *mutable* part of the type and relinquish all exclusive\n-    /// access *until* the given region ends.  Then, access will be recovered.\n-    Suspend(region::Scope),\n-}\n-\n-impl Debug for ValidationOp {\n-    fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n-        use self::ValidationOp::*;\n-        match *self {\n-            Acquire => write!(fmt, \"Acquire\"),\n-            Release => write!(fmt, \"Release\"),\n-            // (reuse lifetime rendering policy from ppaux.)\n-            Suspend(ref ce) => write!(fmt, \"Suspend({})\", ty::ReScope(*ce)),\n-        }\n-    }\n-}\n-\n-// This is generic so that it can be reused by miri\n-#[derive(Clone, Hash, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n-pub struct ValidationOperand<'tcx, T> {\n-    pub place: T,\n-    pub ty: Ty<'tcx>,\n-    pub re: Option<region::Scope>,\n-    pub mutbl: hir::Mutability,\n-}\n-\n-impl<'tcx, T: Debug> Debug for ValidationOperand<'tcx, T> {\n-    fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n-        write!(fmt, \"{:?}: {:?}\", self.place, self.ty)?;\n-        if let Some(ce) = self.re {\n-            // (reuse lifetime rendering policy from ppaux.)\n-            write!(fmt, \"/{}\", ty::ReScope(ce))?;\n-        }\n-        if let hir::MutImmutable = self.mutbl {\n-            write!(fmt, \" (imm)\")?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n impl<'tcx> Debug for Statement<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         use self::StatementKind::*;\n@@ -1869,7 +1825,8 @@ impl<'tcx> Debug for Statement<'tcx> {\n             FakeRead(ref cause, ref place) => write!(fmt, \"FakeRead({:?}, {:?})\", cause, place),\n             // (reuse lifetime rendering policy from ppaux.)\n             EndRegion(ref ce) => write!(fmt, \"EndRegion({})\", ty::ReScope(*ce)),\n-            Validate(ref op, ref places) => write!(fmt, \"Validate({:?}, {:?})\", op, places),\n+            Retag { fn_entry, ref place } =>\n+                write!(fmt, \"Retag({}{:?})\", if fn_entry { \"[fn entry] \" } else { \"\" }, place),\n             StorageLive(ref place) => write!(fmt, \"StorageLive({:?})\", place),\n             StorageDead(ref place) => write!(fmt, \"StorageDead({:?})\", place),\n             SetDiscriminant {\n@@ -2944,7 +2901,6 @@ CloneTypeFoldableAndLiftImpls! {\n     SourceInfo,\n     UpvarDecl,\n     FakeReadCause,\n-    ValidationOp,\n     SourceScope,\n     SourceScopeData,\n     SourceScopeLocalData,\n@@ -2997,12 +2953,6 @@ BraceStructTypeFoldableImpl! {\n     }\n }\n \n-BraceStructTypeFoldableImpl! {\n-    impl<'tcx> TypeFoldable<'tcx> for ValidationOperand<'tcx, Place<'tcx>> {\n-        place, ty, re, mutbl\n-    }\n-}\n-\n BraceStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for Statement<'tcx> {\n         source_info, kind\n@@ -3017,7 +2967,7 @@ EnumTypeFoldableImpl! {\n         (StatementKind::StorageLive)(a),\n         (StatementKind::StorageDead)(a),\n         (StatementKind::InlineAsm) { asm, outputs, inputs },\n-        (StatementKind::Validate)(a, b),\n+        (StatementKind::Retag) { fn_entry, place },\n         (StatementKind::EndRegion)(a),\n         (StatementKind::AscribeUserType)(a, v, b),\n         (StatementKind::Nop),"}, {"sha": "4d3135f9d41cd4504b0563a699446a0abf852846", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -152,6 +152,13 @@ macro_rules! make_mir_visitor {\n                 self.super_ascribe_user_ty(place, variance, user_ty, location);\n             }\n \n+            fn visit_retag(&mut self,\n+                           fn_entry: & $($mutability)* bool,\n+                           place: & $($mutability)* Place<'tcx>,\n+                           location: Location) {\n+                self.super_retag(fn_entry, place, location);\n+            }\n+\n             fn visit_place(&mut self,\n                             place: & $($mutability)* Place<'tcx>,\n                             context: PlaceContext<'tcx>,\n@@ -371,17 +378,6 @@ macro_rules! make_mir_visitor {\n                         );\n                     }\n                     StatementKind::EndRegion(_) => {}\n-                    StatementKind::Validate(_, ref $($mutability)* places) => {\n-                        for operand in places {\n-                            self.visit_place(\n-                                & $($mutability)* operand.place,\n-                                PlaceContext::NonUse(NonUseContext::Validate),\n-                                location\n-                            );\n-                            self.visit_ty(& $($mutability)* operand.ty,\n-                                          TyContext::Location(location));\n-                        }\n-                    }\n                     StatementKind::SetDiscriminant{ ref $($mutability)* place, .. } => {\n                         self.visit_place(\n                             place,\n@@ -417,6 +413,10 @@ macro_rules! make_mir_visitor {\n                             self.visit_operand(input, location);\n                         }\n                     }\n+                    StatementKind::Retag { ref $($mutability)* fn_entry,\n+                                           ref $($mutability)* place } => {\n+                        self.visit_retag(fn_entry, place, location);\n+                    }\n                     StatementKind::AscribeUserType(\n                         ref $($mutability)* place,\n                         ref $($mutability)* variance,\n@@ -719,6 +719,17 @@ macro_rules! make_mir_visitor {\n                 self.visit_user_type_projection(user_ty);\n             }\n \n+            fn super_retag(&mut self,\n+                           _fn_entry: & $($mutability)* bool,\n+                           place: & $($mutability)* Place<'tcx>,\n+                           location: Location) {\n+                self.visit_place(\n+                    place,\n+                    PlaceContext::MutatingUse(MutatingUseContext::Retag),\n+                    location,\n+                );\n+            }\n+\n             fn super_place(&mut self,\n                             place: & $($mutability)* Place<'tcx>,\n                             context: PlaceContext<'tcx>,\n@@ -1010,6 +1021,8 @@ pub enum MutatingUseContext<'tcx> {\n     ///     f(&mut x.y);\n     ///\n     Projection,\n+    /// Retagging (updating the \"Stacked Borrows\" tag)\n+    Retag,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -1020,8 +1033,6 @@ pub enum NonUseContext {\n     StorageDead,\n     /// User type annotation assertions for NLL.\n     AscribeUserTy,\n-    /// Validation command.\n-    Validate,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]"}, {"sha": "76200777584012a60666a7d654ba7bd4e1dafbf5", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -1282,9 +1282,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"in addition to `.mir` files, create graphviz `.dot` files\"),\n     dump_mir_exclude_pass_number: bool = (false, parse_bool, [UNTRACKED],\n         \"if set, exclude the pass number when dumping MIR (used in tests)\"),\n-    mir_emit_validate: usize = (0, parse_uint, [TRACKED],\n-        \"emit Validate MIR statements, interpreted e.g. by miri (0: do not emit; 1: if function \\\n-         contains unsafe block, only validate arguments; 2: always emit full validation)\"),\n+    mir_emit_retag: bool = (false, parse_bool, [TRACKED],\n+        \"emit Retagging MIR statements, interpreted e.g. by miri; implies -Zmir-opt-level=0\"),\n     perf_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"print some performance-related statistics\"),\n     hir_stats: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "409665e47774529149696bc7423e70df2f0bf0b0", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -1547,11 +1547,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Should we emit EndRegion MIR statements? These are consumed by\n-    /// MIR borrowck, but not when NLL is used. They are also consumed\n-    /// by the validation stuff.\n+    /// MIR borrowck, but not when NLL is used.\n     pub fn emit_end_regions(self) -> bool {\n         self.sess.opts.debugging_opts.emit_end_regions ||\n-            self.sess.opts.debugging_opts.mir_emit_validate > 0 ||\n             self.use_mir_borrowck()\n     }\n "}, {"sha": "a93c6faaf7ba927658a0c6c030bc1b59d24e8ccf", "filename": "src/librustc_codegen_llvm/mir/analyze.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -219,7 +219,8 @@ impl Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n                 self.assign(local, location);\n             }\n \n-            PlaceContext::NonUse(_) => {}\n+            PlaceContext::NonUse(_) |\n+            PlaceContext::MutatingUse(MutatingUseContext::Retag) => {}\n \n             PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n             PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) => {"}, {"sha": "cc4e64e07881df684b48afc4c4f8b9dc385ef0a6", "filename": "src/librustc_codegen_llvm/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -109,7 +109,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n             }\n             mir::StatementKind::FakeRead(..) |\n             mir::StatementKind::EndRegion(_) |\n-            mir::StatementKind::Validate(..) |\n+            mir::StatementKind::Retag { .. } |\n             mir::StatementKind::AscribeUserType(..) |\n             mir::StatementKind::Nop => bx,\n         }"}, {"sha": "ccf7b75d878e3be960bc084aecfae008aa79ba4f", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -600,9 +600,9 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n             }\n             StatementKind::Nop\n             | StatementKind::AscribeUserType(..)\n-            | StatementKind::Validate(..)\n+            | StatementKind::Retag { .. }\n             | StatementKind::StorageLive(..) => {\n-                // `Nop`, `AscribeUserType`, `Validate`, and `StorageLive` are irrelevant\n+                // `Nop`, `AscribeUserType`, `Retag`, and `StorageLive` are irrelevant\n                 // to borrow check.\n             }\n             StatementKind::StorageDead(local) => {"}, {"sha": "0d0f5a60ed41486c8799b943cecab9878acdf142", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -136,9 +136,9 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n             StatementKind::EndRegion(..) |\n             StatementKind::Nop |\n             StatementKind::AscribeUserType(..) |\n-            StatementKind::Validate(..) |\n+            StatementKind::Retag { .. } |\n             StatementKind::StorageLive(..) => {\n-                // `Nop`, `AscribeUserType`, `Validate`, and `StorageLive` are irrelevant\n+                // `Nop`, `AscribeUserType`, `Retag`, and `StorageLive` are irrelevant\n                 // to borrow check.\n             }\n             StatementKind::StorageDead(local) => {"}, {"sha": "aa9564bdcaf030f21b4e2c3451857b8ae4075e45", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -1294,7 +1294,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             | StatementKind::StorageDead(_)\n             | StatementKind::InlineAsm { .. }\n             | StatementKind::EndRegion(_)\n-            | StatementKind::Validate(..)\n+            | StatementKind::Retag { .. }\n             | StatementKind::Nop => {}\n         }\n     }"}, {"sha": "69d2a89b5f237216732664bcfa033788c2275dae", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -338,7 +338,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n             mir::StatementKind::FakeRead(..) |\n             mir::StatementKind::SetDiscriminant { .. } |\n             mir::StatementKind::StorageLive(..) |\n-            mir::StatementKind::Validate(..) |\n+            mir::StatementKind::Retag { .. } |\n             mir::StatementKind::AscribeUserType(..) |\n             mir::StatementKind::Nop => {}\n "}, {"sha": "6fb7d18a2bf9333a63a9990f741cd9278c2d3ea2", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -302,7 +302,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n                           \"SetDiscriminant should not exist during borrowck\");\n             }\n             StatementKind::EndRegion(_) |\n-            StatementKind::Validate(..) |\n+            StatementKind::Retag { .. } |\n             StatementKind::AscribeUserType(..) |\n             StatementKind::Nop => {}\n         }"}, {"sha": "e9d181479e52e9962735625b392a825d6d05a8e6", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -24,13 +24,6 @@ use super::{\n     EvalContext, PlaceTy, OpTy, Pointer, MemPlace, MemoryKind,\n };\n \n-/// Classifying memory accesses\n-#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n-pub enum MemoryAccess {\n-    Read,\n-    Write,\n-}\n-\n /// Whether this kind of memory is allowed to leak\n pub trait MayLeak: Copy {\n     fn may_leak(self) -> bool;\n@@ -181,17 +174,22 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n         dest: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> EvalResult<'tcx>;\n \n-    /// Hook for performing extra checks on a memory access.\n-    ///\n-    /// Takes read-only access to the allocation so we can keep all the memory read\n-    /// operations take `&self`.  Use a `RefCell` in `AllocExtra` if you\n-    /// need to mutate.\n+    /// Hook for performing extra checks on a memory read access.\n     #[inline]\n-    fn memory_accessed(\n+    fn memory_read(\n         _alloc: &Allocation<Self::PointerTag, Self::AllocExtra>,\n         _ptr: Pointer<Self::PointerTag>,\n         _size: Size,\n-        _access: MemoryAccess,\n+    ) -> EvalResult<'tcx> {\n+        Ok(())\n+    }\n+\n+    /// Hook for performing extra checks on a memory write access.\n+    #[inline]\n+    fn memory_written(\n+        _alloc: &mut Allocation<Self::PointerTag, Self::AllocExtra>,\n+        _ptr: Pointer<Self::PointerTag>,\n+        _size: Size,\n     ) -> EvalResult<'tcx> {\n         Ok(())\n     }\n@@ -201,6 +199,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     fn memory_deallocated(\n         _alloc: &mut Allocation<Self::PointerTag, Self::AllocExtra>,\n         _ptr: Pointer<Self::PointerTag>,\n+        _size: Size,\n     ) -> EvalResult<'tcx> {\n         Ok(())\n     }\n@@ -242,10 +241,10 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n \n     /// Execute a validation operation\n     #[inline]\n-    fn validation_op(\n+    fn retag(\n         _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        _op: ::rustc::mir::ValidationOp,\n-        _operand: &::rustc::mir::ValidationOperand<'tcx, ::rustc::mir::Place<'tcx>>,\n+        _fn_entry: bool,\n+        _place: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> EvalResult<'tcx> {\n         Ok(())\n     }"}, {"sha": "a9ef35845fc82c41c67cb48bc167fbdefb7757e8", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -30,7 +30,7 @@ use syntax::ast::Mutability;\n use super::{\n     Pointer, AllocId, Allocation, ConstValue, GlobalId,\n     EvalResult, Scalar, EvalErrorKind, AllocType, PointerArithmetic,\n-    Machine, MemoryAccess, AllocMap, MayLeak, ScalarMaybeUndef, ErrorHandled,\n+    Machine, AllocMap, MayLeak, ScalarMaybeUndef, ErrorHandled,\n };\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n@@ -232,7 +232,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n \n         // Let the machine take some extra action\n-        M::memory_deallocated(&mut alloc, ptr)?;\n+        let size = Size::from_bytes(alloc.bytes.len() as u64);\n+        M::memory_deallocated(&mut alloc, ptr, size)?;\n \n         // Don't forget to remember size and align of this now-dead allocation\n         let old = self.dead_alloc_map.insert(\n@@ -644,7 +645,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n \n         let alloc = self.get(ptr.alloc_id)?;\n-        M::memory_accessed(alloc, ptr, size, MemoryAccess::Read)?;\n+        M::memory_read(alloc, ptr, size)?;\n \n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n@@ -690,7 +691,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         self.clear_relocations(ptr, size)?;\n \n         let alloc = self.get_mut(ptr.alloc_id)?;\n-        M::memory_accessed(alloc, ptr, size, MemoryAccess::Write)?;\n+        M::memory_written(alloc, ptr, size)?;\n \n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         assert_eq!(size.bytes() as usize as u64, size.bytes());"}, {"sha": "5620ea4cee25411ab3689386a172c9b52007f1c5", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -34,7 +34,7 @@ pub use self::place::{Place, PlaceTy, MemPlace, MPlaceTy};\n \n pub use self::memory::{Memory, MemoryKind};\n \n-pub use self::machine::{Machine, AllocMap, MemoryAccess, MayLeak};\n+pub use self::machine::{Machine, AllocMap, MayLeak};\n \n pub use self::operand::{ScalarMaybeUndef, Value, ValTy, Operand, OpTy};\n "}, {"sha": "3b104e2284fe2d51459f1c168209359ffc6f76c0", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -299,23 +299,17 @@ where\n \n     /// Turn a mplace into a (thin or fat) pointer, as a reference, pointing to the same space.\n     /// This is the inverse of `ref_to_mplace`.\n+    /// `mutbl` indicates whether we are create a shared or mutable ref, or a raw pointer (`None`).\n     pub fn create_ref(\n         &mut self,\n         place: MPlaceTy<'tcx, M::PointerTag>,\n-        borrow_kind: Option<mir::BorrowKind>,\n+        mutbl: Option<hir::Mutability>,\n     ) -> EvalResult<'tcx, Value<M::PointerTag>> {\n         // Pointer tag tracking might want to adjust the tag\n         let place = if M::ENABLE_PTR_TRACKING_HOOKS {\n             let (size, _) = self.size_and_align_of_mplace(place)?\n                 // for extern types, just cover what we can\n                 .unwrap_or_else(|| place.layout.size_and_align());\n-            let mutbl = match borrow_kind {\n-                Some(mir::BorrowKind::Mut { .. }) |\n-                Some(mir::BorrowKind::Unique) =>\n-                    Some(hir::MutMutable),\n-                Some(_) => Some(hir::MutImmutable),\n-                None => None,\n-            };\n             M::tag_reference(self, *place, place.layout.ty, size, mutbl)?\n         } else {\n             *place"}, {"sha": "97431cfe6808e1a0afab7e107db72190a00e6692", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -12,7 +12,7 @@\n //!\n //! The main entry point is the `step` method.\n \n-use rustc::mir;\n+use rustc::{hir, mir};\n use rustc::ty::layout::LayoutOf;\n use rustc::mir::interpret::{EvalResult, Scalar, PointerArithmetic};\n \n@@ -118,11 +118,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             // interpreter is solely intended for borrowck'ed code.\n             FakeRead(..) => {}\n \n-            // Validity checks.\n-            Validate(op, ref places) => {\n-                for operand in places {\n-                    M::validation_op(self, op, operand)?;\n-                }\n+            // Retagging.\n+            Retag { fn_entry, ref place } => {\n+                let dest = self.eval_place(place)?;\n+                M::retag(self, fn_entry, dest)?;\n             }\n \n             EndRegion(..) => {}\n@@ -251,7 +250,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             Ref(_, borrow_kind, ref place) => {\n                 let src = self.eval_place(place)?;\n                 let val = self.force_allocation(src)?;\n-                let val = self.create_ref(val, Some(borrow_kind))?;\n+                let mutbl = match borrow_kind {\n+                    mir::BorrowKind::Mut { .. } |\n+                    mir::BorrowKind::Unique =>\n+                        hir::MutMutable,\n+                    mir::BorrowKind::Shared |\n+                    mir::BorrowKind::Shallow =>\n+                        hir::MutImmutable,\n+                };\n+                let val = self.create_ref(val, Some(mutbl))?;\n                 self.write_value(val, dest)?;\n             }\n "}, {"sha": "a50011cf5a15e5c2c7a09db8de326078d9a33abe", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -0,0 +1,174 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This pass adds validation calls (AcquireValid, ReleaseValid) where appropriate.\n+//! It has to be run really early, before transformations like inlining, because\n+//! introducing these calls *adds* UB -- so, conceptually, this pass is actually part\n+//! of MIR building, and only after this pass we think of the program has having the\n+//! normal MIR semantics.\n+\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::mir::*;\n+use transform::{MirPass, MirSource};\n+\n+pub struct AddRetag;\n+\n+/// Determines whether this place is local: If it is part of a local variable.\n+/// We do not consider writes to pointers local, only writes that immediately assign\n+/// to a local variable.\n+/// One important property here is that evaluating the place immediately after\n+/// the assignment must produce the same place as what was used during the assignment.\n+fn is_local<'tcx>(\n+    place: &Place<'tcx>,\n+) -> bool {\n+    use rustc::mir::Place::*;\n+\n+    match *place {\n+        Local { .. } => true,\n+        Promoted(_) |\n+        Static(_) => false,\n+        Projection(ref proj) => {\n+            match proj.elem {\n+                ProjectionElem::Deref |\n+                ProjectionElem::Index(_) =>\n+                    // Which place these point to depends on external circumstances\n+                    // (a local storing the array index, the current value of\n+                    // the projection base), so we stop tracking here.\n+                    false,\n+                ProjectionElem::Field { .. } |\n+                ProjectionElem::ConstantIndex { .. } |\n+                ProjectionElem::Subslice { .. } |\n+                ProjectionElem::Downcast { .. } =>\n+                    // These just offset by a constant, entirely independent of everything else.\n+                    is_local(&proj.base),\n+            }\n+        }\n+    }\n+}\n+\n+/// Determine whether this type has a reference in it, recursing below compound types but\n+/// not below references.\n+fn has_reference<'a, 'gcx, 'tcx>(ty: Ty<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+    match ty.sty {\n+        // Primitive types that are not references\n+        ty::Bool | ty::Char |\n+        ty::Float(_) | ty::Int(_) | ty::Uint(_) |\n+        ty::RawPtr(..) | ty::FnPtr(..) |\n+        ty::Str | ty::FnDef(..) | ty::Never =>\n+            false,\n+        // References\n+        ty::Ref(..) => true,\n+        ty::Adt(..) if ty.is_box() => true,\n+        // Compound types\n+        ty::Array(ty, ..) | ty::Slice(ty) =>\n+            has_reference(ty, tcx),\n+        ty::Tuple(tys) =>\n+            tys.iter().any(|ty| has_reference(ty, tcx)),\n+        ty::Adt(adt, substs) =>\n+            adt.variants.iter().any(|v| v.fields.iter().any(|f|\n+                has_reference(f.ty(tcx, substs), tcx)\n+            )),\n+        // Conservative fallback\n+        _ => true,\n+    }\n+}\n+\n+impl MirPass for AddRetag {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _src: MirSource,\n+                          mir: &mut Mir<'tcx>)\n+    {\n+        if !tcx.sess.opts.debugging_opts.mir_emit_retag {\n+            return;\n+        }\n+        let (span, arg_count) = (mir.span, mir.arg_count);\n+        let (basic_blocks, local_decls) = mir.basic_blocks_and_local_decls_mut();\n+        let needs_retag = |place: &Place<'tcx>| {\n+            is_local(place) && has_reference(place.ty(&*local_decls, tcx).to_ty(tcx), tcx)\n+        };\n+\n+        // PART 1\n+        // Retag arguments at the beginning of the start block.\n+        {\n+            let source_info = SourceInfo {\n+                scope: OUTERMOST_SOURCE_SCOPE,\n+                span: span, // FIXME: Consider using just the span covering the function\n+                            // argument declaration.\n+            };\n+            // Gather all arguments, skip return value.\n+            let places = local_decls.iter_enumerated().skip(1).take(arg_count)\n+                    .map(|(local, _)| Place::Local(local))\n+                    .filter(needs_retag)\n+                    .collect::<Vec<_>>();\n+            // Emit their retags.\n+            basic_blocks[START_BLOCK].statements.splice(0..0,\n+                places.into_iter().map(|place| Statement {\n+                    source_info,\n+                    kind: StatementKind::Retag { fn_entry: true, place },\n+                })\n+            );\n+        }\n+\n+        // PART 2\n+        // Retag return values of functions.\n+        // We collect the return destinations because we cannot mutate while iterating.\n+        let mut returns: Vec<(SourceInfo, Place<'tcx>, BasicBlock)> = Vec::new();\n+        for block_data in basic_blocks.iter_mut() {\n+            match block_data.terminator {\n+                Some(Terminator { kind: TerminatorKind::Call { ref destination, .. },\n+                                  source_info }) => {\n+                    // Remember the return destination for later\n+                    if let Some(ref destination) = destination {\n+                        if needs_retag(&destination.0) {\n+                            returns.push((source_info, destination.0.clone(), destination.1));\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    // Not a block ending in a Call -> ignore.\n+                    // `Drop` is also a call, but it doesn't return anything so we are good.\n+                }\n+            }\n+        }\n+        // Now we go over the returns we collected to retag the return values.\n+        for (source_info, dest_place, dest_block) in returns {\n+            basic_blocks[dest_block].statements.insert(0, Statement {\n+                source_info,\n+                kind: StatementKind::Retag { fn_entry: false, place: dest_place },\n+            });\n+        }\n+\n+        // PART 3\n+        // Add retag after assignment.\n+        for block_data in basic_blocks {\n+            // We want to insert statements as we iterate.  To this end, we\n+            // iterate backwards using indices.\n+            for i in (0..block_data.statements.len()).rev() {\n+                match block_data.statements[i].kind {\n+                    // Assignments can make values obtained elsewhere \"local\".\n+                    // We could try to be smart here and e.g. only retag if the assignment\n+                    // loaded from memory, but that seems risky: We might miss a subtle corner\n+                    // case.\n+                    StatementKind::Assign(ref place, box Rvalue::Use(..))\n+                    if needs_retag(place) => {\n+                        // Insert a retag after the assignment.\n+                        let source_info = block_data.statements[i].source_info;\n+                        block_data.statements.insert(i+1,Statement {\n+                            source_info,\n+                            kind: StatementKind::Retag { fn_entry: false, place: place.clone() },\n+                        });\n+                    }\n+                    _ => {},\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "5b489b5db942b1916db954bb776b7faa486cbd04", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "removed", "additions": 0, "deletions": 395, "changes": 395, "blob_url": "https://github.com/rust-lang/rust/blob/d0c869c323289c5ec4df83e1c9091fa0b3e2fc07/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c869c323289c5ec4df83e1c9091fa0b3e2fc07/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=d0c869c323289c5ec4df83e1c9091fa0b3e2fc07", "patch": "@@ -1,395 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! This pass adds validation calls (AcquireValid, ReleaseValid) where appropriate.\n-//! It has to be run really early, before transformations like inlining, because\n-//! introducing these calls *adds* UB -- so, conceptually, this pass is actually part\n-//! of MIR building, and only after this pass we think of the program has having the\n-//! normal MIR semantics.\n-\n-use rustc::ty::{self, TyCtxt, RegionKind};\n-use rustc::hir;\n-use rustc::mir::*;\n-use rustc::middle::region;\n-use transform::{MirPass, MirSource};\n-\n-pub struct AddValidation;\n-\n-/// Determine the \"context\" of the place: Mutability and region.\n-fn place_context<'a, 'tcx, D>(\n-    place: &Place<'tcx>,\n-    local_decls: &D,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>\n-) -> (Option<region::Scope>, hir::Mutability)\n-    where D: HasLocalDecls<'tcx>\n-{\n-    use rustc::mir::Place::*;\n-\n-    match *place {\n-        Local { .. } => (None, hir::MutMutable),\n-        Promoted(_) |\n-        Static(_) => (None, hir::MutImmutable),\n-        Projection(ref proj) => {\n-            match proj.elem {\n-                ProjectionElem::Deref => {\n-                    // Computing the inside the recursion makes this quadratic.\n-                    // We don't expect deep paths though.\n-                    let ty = proj.base.ty(local_decls, tcx).to_ty(tcx);\n-                    // A Deref projection may restrict the context, this depends on the type\n-                    // being deref'd.\n-                    let context = match ty.sty {\n-                        ty::Ref(re, _, mutbl) => {\n-                            let re = match re {\n-                                &RegionKind::ReScope(ce) => Some(ce),\n-                                &RegionKind::ReErased =>\n-                                    bug!(\"AddValidation pass must be run before erasing lifetimes\"),\n-                                _ => None\n-                            };\n-                            (re, mutbl)\n-                        }\n-                        ty::RawPtr(_) =>\n-                            // There is no guarantee behind even a mutable raw pointer,\n-                            // no write locks are acquired there, so we also don't want to\n-                            // release any.\n-                            (None, hir::MutImmutable),\n-                        ty::Adt(adt, _) if adt.is_box() => (None, hir::MutMutable),\n-                        _ => bug!(\"Deref on a non-pointer type {:?}\", ty),\n-                    };\n-                    // \"Intersect\" this restriction with proj.base.\n-                    if let (Some(_), hir::MutImmutable) = context {\n-                        // This is already as restricted as it gets, no need to even recurse\n-                        context\n-                    } else {\n-                        let base_context = place_context(&proj.base, local_decls, tcx);\n-                        // The region of the outermost Deref is always most restrictive.\n-                        let re = context.0.or(base_context.0);\n-                        let mutbl = context.1.and(base_context.1);\n-                        (re, mutbl)\n-                    }\n-\n-                }\n-                _ => place_context(&proj.base, local_decls, tcx),\n-            }\n-        }\n-    }\n-}\n-\n-/// Check if this function contains an unsafe block or is an unsafe function.\n-fn fn_contains_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource) -> bool {\n-    use rustc::hir::intravisit::{self, Visitor, FnKind};\n-    use rustc::hir::map::blocks::FnLikeNode;\n-    use rustc::hir::Node;\n-\n-    /// Decide if this is an unsafe block\n-    fn block_is_unsafe(block: &hir::Block) -> bool {\n-        use rustc::hir::BlockCheckMode::*;\n-\n-        match block.rules {\n-            UnsafeBlock(_) | PushUnsafeBlock(_) => true,\n-            // For PopUnsafeBlock, we don't actually know -- but we will always also check all\n-            // parent blocks, so we can safely declare the PopUnsafeBlock to not be unsafe.\n-            DefaultBlock | PopUnsafeBlock(_) => false,\n-        }\n-    }\n-\n-    /// Decide if this FnLike is a closure\n-    fn fn_is_closure<'a>(fn_like: FnLikeNode<'a>) -> bool {\n-        match fn_like.kind() {\n-            FnKind::Closure(_) => true,\n-            FnKind::Method(..) | FnKind::ItemFn(..) => false,\n-        }\n-    }\n-\n-    let node_id = tcx.hir.as_local_node_id(src.def_id).unwrap();\n-    let fn_like = match tcx.hir.body_owner_kind(node_id) {\n-        hir::BodyOwnerKind::Fn => {\n-            match FnLikeNode::from_node(tcx.hir.get(node_id)) {\n-                Some(fn_like) => fn_like,\n-                None => return false, // e.g. struct ctor shims -- such auto-generated code cannot\n-                                      // contain unsafe.\n-            }\n-        },\n-        _ => return false, // only functions can have unsafe\n-    };\n-\n-    // Test if the function is marked unsafe.\n-    if fn_like.unsafety() == hir::Unsafety::Unsafe {\n-        return true;\n-    }\n-\n-    // For closures, we need to walk up the parents and see if we are inside an unsafe fn or\n-    // unsafe block.\n-    if fn_is_closure(fn_like) {\n-        let mut cur = fn_like.id();\n-        loop {\n-            // Go further upwards.\n-            cur = tcx.hir.get_parent_node(cur);\n-            let node = tcx.hir.get(cur);\n-            // Check if this is an unsafe function\n-            if let Some(fn_like) = FnLikeNode::from_node(node) {\n-                if !fn_is_closure(fn_like) {\n-                    if fn_like.unsafety() == hir::Unsafety::Unsafe {\n-                        return true;\n-                    }\n-                }\n-            }\n-            // Check if this is an unsafe block, or an item\n-            match node {\n-                Node::Expr(&hir::Expr { node: hir::ExprKind::Block(ref block, _), ..}) => {\n-                    if block_is_unsafe(&*block) {\n-                        // Found an unsafe block, we can bail out here.\n-                        return true;\n-                    }\n-                }\n-                Node::Item(..) => {\n-                    // No walking up beyond items.  This makes sure the loop always terminates.\n-                    break;\n-                }\n-                _ => {},\n-            }\n-        }\n-    }\n-\n-    // Visit the entire body of the function and check for unsafe blocks in there\n-    struct FindUnsafe {\n-        found_unsafe: bool,\n-    }\n-    let mut finder = FindUnsafe { found_unsafe: false };\n-    // Run the visitor on the NodeId we got.  Seems like there is no uniform way to do that.\n-    finder.visit_body(tcx.hir.body(fn_like.body()));\n-\n-    impl<'tcx> Visitor<'tcx> for FindUnsafe {\n-        fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n-            intravisit::NestedVisitorMap::None\n-        }\n-\n-        fn visit_block(&mut self, b: &'tcx hir::Block) {\n-            if self.found_unsafe { return; } // short-circuit\n-\n-            if block_is_unsafe(b) {\n-                // We found an unsafe block.  We can stop searching.\n-                self.found_unsafe = true;\n-            } else {\n-                // No unsafe block here, go on searching.\n-                intravisit::walk_block(self, b);\n-            }\n-        }\n-    }\n-\n-    finder.found_unsafe\n-}\n-\n-impl MirPass for AddValidation {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          src: MirSource,\n-                          mir: &mut Mir<'tcx>)\n-    {\n-        let emit_validate = tcx.sess.opts.debugging_opts.mir_emit_validate;\n-        if emit_validate == 0 {\n-            return;\n-        }\n-        let restricted_validation = emit_validate == 1 && fn_contains_unsafe(tcx, src);\n-        let (span, arg_count) = (mir.span, mir.arg_count);\n-        let (basic_blocks, local_decls) = mir.basic_blocks_and_local_decls_mut();\n-\n-        // Convert a place to a validation operand.\n-        let place_to_operand = |place: Place<'tcx>| -> ValidationOperand<'tcx, Place<'tcx>> {\n-            let (re, mutbl) = place_context(&place, local_decls, tcx);\n-            let ty = place.ty(local_decls, tcx).to_ty(tcx);\n-            ValidationOperand { place, ty, re, mutbl }\n-        };\n-\n-        // Emit an Acquire at the beginning of the given block.  If we are in restricted emission\n-        // mode (mir_emit_validate=1), also emit a Release immediately after the Acquire.\n-        let emit_acquire = |block: &mut BasicBlockData<'tcx>, source_info, operands: Vec<_>| {\n-            if operands.len() == 0 {\n-                return; // Nothing to do\n-            }\n-            // Emit the release first, to avoid cloning if we do not emit it\n-            if restricted_validation {\n-                let release_stmt = Statement {\n-                    source_info,\n-                    kind: StatementKind::Validate(ValidationOp::Release, operands.clone()),\n-                };\n-                block.statements.insert(0, release_stmt);\n-            }\n-            // Now, the acquire\n-            let acquire_stmt = Statement {\n-                source_info,\n-                kind: StatementKind::Validate(ValidationOp::Acquire, operands),\n-            };\n-            block.statements.insert(0, acquire_stmt);\n-        };\n-\n-        // PART 1\n-        // Add an AcquireValid at the beginning of the start block.\n-        {\n-            let source_info = SourceInfo {\n-                scope: OUTERMOST_SOURCE_SCOPE,\n-                span: span, // FIXME: Consider using just the span covering the function\n-                            // argument declaration.\n-            };\n-            // Gather all arguments, skip return value.\n-            let operands = local_decls.iter_enumerated().skip(1).take(arg_count)\n-                    .map(|(local, _)| place_to_operand(Place::Local(local))).collect();\n-            emit_acquire(&mut basic_blocks[START_BLOCK], source_info, operands);\n-        }\n-\n-        // PART 2\n-        // Add ReleaseValid/AcquireValid around function call terminators.  We don't use a visitor\n-        // because we need to access the block that a Call jumps to.\n-        let mut returns : Vec<(SourceInfo, Place<'tcx>, BasicBlock)> = Vec::new();\n-        for block_data in basic_blocks.iter_mut() {\n-            match block_data.terminator {\n-                Some(Terminator { kind: TerminatorKind::Call { ref args, ref destination, .. },\n-                                  source_info }) => {\n-                    // Before the call: Release all arguments *and* the return value.\n-                    // The callee may write into the return value!  Note that this relies\n-                    // on \"release of uninitialized\" to be a NOP.\n-                    if !restricted_validation {\n-                        let release_stmt = Statement {\n-                            source_info,\n-                            kind: StatementKind::Validate(ValidationOp::Release,\n-                                destination.iter().map(|dest| place_to_operand(dest.0.clone()))\n-                                .chain(\n-                                    args.iter().filter_map(|op| {\n-                                        match op {\n-                                            &Operand::Copy(ref place) |\n-                                            &Operand::Move(ref place) =>\n-                                                Some(place_to_operand(place.clone())),\n-                                            &Operand::Constant(..) => { None },\n-                                        }\n-                                    })\n-                                ).collect())\n-                        };\n-                        block_data.statements.push(release_stmt);\n-                    }\n-                    // Remember the return destination for later\n-                    if let &Some(ref destination) = destination {\n-                        returns.push((source_info, destination.0.clone(), destination.1));\n-                    }\n-                }\n-                Some(Terminator { kind: TerminatorKind::Drop { location: ref place, .. },\n-                                  source_info }) |\n-                Some(Terminator { kind: TerminatorKind::DropAndReplace { location: ref place, .. },\n-                                  source_info }) => {\n-                    // Before the call: Release all arguments\n-                    if !restricted_validation {\n-                        let release_stmt = Statement {\n-                            source_info,\n-                            kind: StatementKind::Validate(ValidationOp::Release,\n-                                    vec![place_to_operand(place.clone())]),\n-                        };\n-                        block_data.statements.push(release_stmt);\n-                    }\n-                    // drop doesn't return anything, so we need no acquire.\n-                }\n-                _ => {\n-                    // Not a block ending in a Call -> ignore.\n-                }\n-            }\n-        }\n-        // Now we go over the returns we collected to acquire the return values.\n-        for (source_info, dest_place, dest_block) in returns {\n-            emit_acquire(\n-                &mut basic_blocks[dest_block],\n-                source_info,\n-                vec![place_to_operand(dest_place)]\n-            );\n-        }\n-\n-        if restricted_validation {\n-            // No part 3 for us.\n-            return;\n-        }\n-\n-        // PART 3\n-        // Add ReleaseValid/AcquireValid around Ref and Cast.  Again an iterator does not seem very\n-        // suited as we need to add new statements before and after each Ref.\n-        for block_data in basic_blocks {\n-            // We want to insert statements around Ref commands as we iterate.  To this end, we\n-            // iterate backwards using indices.\n-            for i in (0..block_data.statements.len()).rev() {\n-                match block_data.statements[i].kind {\n-                    // When the borrow of this ref expires, we need to recover validation.\n-                    StatementKind::Assign(_, box Rvalue::Ref(_, _, _)) => {\n-                        // Due to a lack of NLL; we can't capture anything directly here.\n-                        // Instead, we have to re-match and clone there.\n-                        let (dest_place, re, src_place) = match block_data.statements[i].kind {\n-                            StatementKind::Assign(ref dest_place,\n-                                                  box Rvalue::Ref(re, _, ref src_place)) => {\n-                                (dest_place.clone(), re, src_place.clone())\n-                            },\n-                            _ => bug!(\"We already matched this.\"),\n-                        };\n-                        // So this is a ref, and we got all the data we wanted.\n-                        // Do an acquire of the result -- but only what it points to, so add a Deref\n-                        // projection.\n-                        let acquire_stmt = Statement {\n-                            source_info: block_data.statements[i].source_info,\n-                            kind: StatementKind::Validate(ValidationOp::Acquire,\n-                                    vec![place_to_operand(dest_place.deref())]),\n-                        };\n-                        block_data.statements.insert(i+1, acquire_stmt);\n-\n-                        // The source is released until the region of the borrow ends.\n-                        let op = match re {\n-                            &RegionKind::ReScope(ce) => ValidationOp::Suspend(ce),\n-                            &RegionKind::ReErased =>\n-                                bug!(\"AddValidation pass must be run before erasing lifetimes\"),\n-                            _ => ValidationOp::Release,\n-                        };\n-                        let release_stmt = Statement {\n-                            source_info: block_data.statements[i].source_info,\n-                            kind: StatementKind::Validate(op, vec![place_to_operand(src_place)]),\n-                        };\n-                        block_data.statements.insert(i, release_stmt);\n-                    }\n-                    // Casts can change what validation does (e.g. unsizing)\n-                    StatementKind::Assign(_, box Rvalue::Cast(kind, Operand::Copy(_), _)) |\n-                    StatementKind::Assign(_, box Rvalue::Cast(kind, Operand::Move(_), _))\n-                        if kind != CastKind::Misc =>\n-                    {\n-                        // Due to a lack of NLL; we can't capture anything directly here.\n-                        // Instead, we have to re-match and clone there.\n-                        let (dest_place, src_place) = match block_data.statements[i].kind {\n-                            StatementKind::Assign(ref dest_place,\n-                                    box Rvalue::Cast(_, Operand::Copy(ref src_place), _)) |\n-                            StatementKind::Assign(ref dest_place,\n-                                    box Rvalue::Cast(_, Operand::Move(ref src_place), _)) =>\n-                            {\n-                                (dest_place.clone(), src_place.clone())\n-                            },\n-                            _ => bug!(\"We already matched this.\"),\n-                        };\n-\n-                        // Acquire of the result\n-                        let acquire_stmt = Statement {\n-                            source_info: block_data.statements[i].source_info,\n-                            kind: StatementKind::Validate(ValidationOp::Acquire,\n-                                    vec![place_to_operand(dest_place)]),\n-                        };\n-                        block_data.statements.insert(i+1, acquire_stmt);\n-\n-                        // Release of the input\n-                        let release_stmt = Statement {\n-                            source_info: block_data.statements[i].source_info,\n-                            kind: StatementKind::Validate(ValidationOp::Release,\n-                                                            vec![place_to_operand(src_place)]),\n-                        };\n-                        block_data.statements.insert(i, release_stmt);\n-                    }\n-                    _ => {},\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "c28bb0ca35704b56d93378ec61474c32473d832b", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             StatementKind::StorageLive(..) |\n             StatementKind::StorageDead(..) |\n             StatementKind::EndRegion(..) |\n-            StatementKind::Validate(..) |\n+            StatementKind::Retag { .. } |\n             StatementKind::AscribeUserType(..) |\n             StatementKind::Nop => {\n                 // safe (at least as emitted during MIR construction)"}, {"sha": "6351a6b40cb03a9db2aad442e38cdffb55f778b2", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -22,23 +22,19 @@ use transform::{MirPass, MirSource};\n \n struct EraseRegionsVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    in_validation_statement: bool,\n }\n \n impl<'a, 'tcx> EraseRegionsVisitor<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n         EraseRegionsVisitor {\n             tcx,\n-            in_validation_statement: false,\n         }\n     }\n }\n \n impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, _: TyContext) {\n-        if !self.in_validation_statement {\n-            *ty = self.tcx.erase_regions(ty);\n-        }\n+        *ty = self.tcx.erase_regions(ty);\n         self.super_ty(ty);\n     }\n \n@@ -58,20 +54,11 @@ impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n                        block: BasicBlock,\n                        statement: &mut Statement<'tcx>,\n                        location: Location) {\n-        // Do NOT delete EndRegion if validation statements are emitted.\n-        // Validation needs EndRegion.\n-        if self.tcx.sess.opts.debugging_opts.mir_emit_validate == 0 {\n-            if let StatementKind::EndRegion(_) = statement.kind {\n-                statement.kind = StatementKind::Nop;\n-            }\n+        if let StatementKind::EndRegion(_) = statement.kind {\n+            statement.kind = StatementKind::Nop;\n         }\n \n-        self.in_validation_statement = match statement.kind {\n-            StatementKind::Validate(..) => true,\n-            _ => false,\n-        };\n         self.super_statement(block, statement, location);\n-        self.in_validation_statement = false;\n     }\n }\n "}, {"sha": "199cf5650fda8c2f6f5f82d2f239e26d56a1f560", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -691,6 +691,14 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n         self.in_cleanup_block = false;\n     }\n \n+    fn visit_retag(&mut self, fn_entry: &mut bool, place: &mut Place<'tcx>, loc: Location) {\n+        self.super_retag(fn_entry, place, loc);\n+\n+        // We have to patch all inlined retags to be aware that they are no longer\n+        // happening on function entry.\n+        *fn_entry = false;\n+    }\n+\n     fn visit_terminator_kind(&mut self, block: BasicBlock,\n                              kind: &mut TerminatorKind<'tcx>, loc: Location) {\n         self.super_terminator_kind(block, kind, loc);"}, {"sha": "92cfcb3fd56cb4d3f04898c972206ff9e07349fb", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -23,7 +23,7 @@ use std::borrow::Cow;\n use syntax::ast;\n use syntax_pos::Span;\n \n-pub mod add_validation;\n+pub mod add_retag;\n pub mod add_moves_for_packed_drops;\n pub mod cleanup_post_borrowck;\n pub mod check_unsafety;\n@@ -258,19 +258,21 @@ fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n         // Remove all `FakeRead` statements and the borrows that are only\n         // used for checking matches\n         &cleanup_post_borrowck::CleanFakeReadsAndBorrows,\n+\n         &simplify::SimplifyCfg::new(\"early-opt\"),\n \n         // These next passes must be executed together\n         &add_call_guards::CriticalCallEdges,\n         &elaborate_drops::ElaborateDrops,\n         &no_landing_pads::NoLandingPads,\n-        // AddValidation needs to run after ElaborateDrops and before EraseRegions, and it needs\n-        // an AllCallEdges pass right before it.\n-        &add_call_guards::AllCallEdges,\n-        &add_validation::AddValidation,\n         // AddMovesForPackedDrops needs to run after drop\n         // elaboration.\n         &add_moves_for_packed_drops::AddMovesForPackedDrops,\n+        // AddRetag needs to run after ElaborateDrops, and it needs\n+        // an AllCallEdges pass right before it.  Otherwise it should\n+        // run fairly late, but before optimizations begin.\n+        &add_call_guards::AllCallEdges,\n+        &add_retag::AddRetag,\n \n         &simplify::SimplifyCfg::new(\"elaborate-drops\"),\n "}, {"sha": "ca9c4eb9b8bb971f3d8bca1046c98d2afb4c30ee", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -1167,7 +1167,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 StatementKind::StorageDead(_) |\n                 StatementKind::InlineAsm {..} |\n                 StatementKind::EndRegion(_) |\n-                StatementKind::Validate(..) |\n+                StatementKind::Retag { .. } |\n                 StatementKind::AscribeUserType(..) |\n                 StatementKind::Nop => {}\n             }"}, {"sha": "1e193485950579bcae7671ca912c7b12cddad674", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -241,7 +241,7 @@ fn check_statement(\n         // These are all NOPs\n         | StatementKind::StorageLive(_)\n         | StatementKind::StorageDead(_)\n-        | StatementKind::Validate(..)\n+        | StatementKind::Retag { .. }\n         | StatementKind::EndRegion(_)\n         | StatementKind::AscribeUserType(..)\n         | StatementKind::Nop => Ok(()),"}, {"sha": "c1c127fa8d6484979f00ed3e383929c21f6d3a7c", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -68,7 +68,7 @@ impl RemoveNoopLandingPads {\n                 StatementKind::Assign(_, _) |\n                 StatementKind::SetDiscriminant { .. } |\n                 StatementKind::InlineAsm { .. } |\n-                StatementKind::Validate { .. } => {\n+                StatementKind::Retag { .. } => {\n                     return false;\n                 }\n             }"}, {"sha": "a5a19f04b7e8e49b1e61617ace060e2a29c07e94", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -162,7 +162,7 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             mir::StatementKind::StorageDead(_) |\n             mir::StatementKind::InlineAsm { .. } |\n             mir::StatementKind::EndRegion(_) |\n-            mir::StatementKind::Validate(..) |\n+            mir::StatementKind::Retag { .. } |\n             mir::StatementKind::AscribeUserType(..) |\n             mir::StatementKind::Nop => continue,\n             mir::StatementKind::SetDiscriminant{ .. } =>"}, {"sha": "12c13b8f81531b330bd08c1225cad594ba7d4f95", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -204,7 +204,7 @@ pub fn categorize<'tcx>(context: PlaceContext<'tcx>) -> Option<DefUse> {\n         PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n         PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) |\n         PlaceContext::NonUse(NonUseContext::AscribeUserTy) |\n-        PlaceContext::NonUse(NonUseContext::Validate) =>\n+        PlaceContext::MutatingUse(MutatingUseContext::Retag) =>\n             Some(DefUse::Use),\n \n         ///////////////////////////////////////////////////////////////////////////"}, {"sha": "ecfe7d13782de3dc2c0daa875d9e731dbcc0d44c", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -84,7 +84,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n             StatementKind::Assign(..) => \"StatementKind::Assign\",\n             StatementKind::FakeRead(..) => \"StatementKind::FakeRead\",\n             StatementKind::EndRegion(..) => \"StatementKind::EndRegion\",\n-            StatementKind::Validate(..) => \"StatementKind::Validate\",\n+            StatementKind::Retag { .. } => \"StatementKind::Retag\",\n             StatementKind::SetDiscriminant { .. } => \"StatementKind::SetDiscriminant\",\n             StatementKind::StorageLive(..) => \"StatementKind::StorageLive\",\n             StatementKind::StorageDead(..) => \"StatementKind::StorageDead\","}, {"sha": "4b3280ee5615177563158217234f2013b925571d", "filename": "src/test/mir-opt/inline-retag.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Ftest%2Fmir-opt%2Finline-retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Ftest%2Fmir-opt%2Finline-retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline-retag.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z span_free_formats -Z mir-emit-retag\n+\n+// Tests that MIR inliner fixes up `Retag`'s `fn_entry` flag\n+\n+fn main() {\n+    println!(\"{}\", bar());\n+}\n+\n+#[inline(always)]\n+fn foo(x: &i32, y: &i32) -> bool {\n+    *x == *y\n+}\n+\n+fn bar() -> bool {\n+    let f = foo;\n+    f(&1, &-1)\n+}\n+\n+// END RUST SOURCE\n+// START rustc.bar.Inline.after.mir\n+// ...\n+//     bb0: {\n+//         ...\n+//         Retag(_3);\n+//         Retag(_6);\n+//         StorageLive(_9);\n+//         _9 = (*_3);\n+//         StorageLive(_10);\n+//         _10 = (*_6);\n+//         _0 = Eq(move _9, move _10);\n+//         ...\n+//         return;\n+//     }\n+// ...\n+// END rustc.bar.Inline.after.mir"}, {"sha": "9c013008ab272b2971531315e454e7c89b11be49", "filename": "src/test/mir-opt/retag.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Ftest%2Fmir-opt%2Fretag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a3c1ee7016bbfb782f2fd8adc75b46687ef929/src%2Ftest%2Fmir-opt%2Fretag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.rs?ref=87a3c1ee7016bbfb782f2fd8adc75b46687ef929", "patch": "@@ -0,0 +1,106 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags: -Z mir-emit-retag -Z mir-opt-level=0 -Z span_free_formats\n+\n+#![allow(unused)]\n+\n+struct Test(i32);\n+\n+impl Test {\n+    // Make sure we run the pass on a method, not just on bare functions.\n+    fn foo<'x>(&self, x: &'x mut i32) -> &'x mut i32 { x }\n+    fn foo_shr<'x>(&self, x: &'x i32) -> &'x i32 { x }\n+}\n+\n+fn main() {\n+    let mut x = 0;\n+    {\n+        let v = Test(0).foo(&mut x); // just making sure we do not panic when there is a tuple struct ctor\n+        let w = { v }; // assignment\n+        let _w = w; // reborrow\n+    }\n+\n+    // Also test closures\n+    let c: fn(&i32) -> &i32 = |x: &i32| -> &i32 { let _y = x; x };\n+    let _w = c(&x);\n+\n+    // need to call `foo_shr` or it doesn't even get generated\n+    Test(0).foo_shr(&0);\n+}\n+\n+// END RUST SOURCE\n+// START rustc.{{impl}}-foo.EraseRegions.after.mir\n+//     bb0: {\n+//         Retag([fn entry] _1);\n+//         Retag([fn entry] _2);\n+//         ...\n+//         _0 = &mut (*_3);\n+//         ...\n+//         return;\n+//     }\n+// END rustc.{{impl}}-foo.EraseRegions.after.mir\n+// START rustc.{{impl}}-foo_shr.EraseRegions.after.mir\n+//     bb0: {\n+//         Retag([fn entry] _1);\n+//         Retag([fn entry] _2);\n+//         ...\n+//         _0 = _2;\n+//         Retag(_0);\n+//         ...\n+//         return;\n+//     }\n+// END rustc.{{impl}}-foo_shr.EraseRegions.after.mir\n+// START rustc.main.EraseRegions.after.mir\n+// fn main() -> () {\n+//     ...\n+//     bb0: {\n+//         ...\n+//         _3 = const Test::foo(move _4, move _6) -> bb1;\n+//     }\n+//\n+//     bb1: {\n+//         Retag(_3);\n+//         ...\n+//         _9 = move _3;\n+//         Retag(_9);\n+//         _8 = &mut (*_9);\n+//         StorageDead(_9);\n+//         StorageLive(_10);\n+//         _10 = move _8;\n+//         Retag(_10);\n+//         ...\n+//         _13 = move _14(move _15) -> bb2;\n+//     }\n+//\n+//     bb2: {\n+//         Retag(_13);\n+//         ...\n+//     }\n+//     ...\n+// }\n+// END rustc.main.EraseRegions.after.mir\n+// START rustc.main-{{closure}}.EraseRegions.after.mir\n+// fn main::{{closure}}(_1: &[closure@NodeId(117)], _2: &i32) -> &i32 {\n+//     ...\n+//     bb0: {\n+//         Retag([fn entry] _1);\n+//         Retag([fn entry] _2);\n+//         StorageLive(_3);\n+//         _3 = _2;\n+//         Retag(_3);\n+//         _0 = _2;\n+//         Retag(_0);\n+//         StorageDead(_3);\n+//         return;\n+//     }\n+// }\n+// END rustc.main-{{closure}}.EraseRegions.after.mir"}, {"sha": "f1544968adb6a2135afe4b3486db2191fb787d44", "filename": "src/test/mir-opt/validate_1.rs", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/d0c869c323289c5ec4df83e1c9091fa0b3e2fc07/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c869c323289c5ec4df83e1c9091fa0b3e2fc07/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs?ref=d0c869c323289c5ec4df83e1c9091fa0b3e2fc07", "patch": "@@ -1,76 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-tidy-linelength\n-// compile-flags: -Z verbose -Z mir-emit-validate=1 -Z span_free_formats\n-\n-struct Test(i32);\n-\n-impl Test {\n-    // Make sure we run the pass on a method, not just on bare functions.\n-    fn foo(&self, _x: &mut i32) {}\n-}\n-\n-fn main() {\n-    let mut x = 0;\n-    Test(0).foo(&mut x); // just making sure we do not panic when there is a tuple struct ctor\n-\n-    // Also test closures\n-    let c = |x: &mut i32| { let y = &*x; *y };\n-    c(&mut x);\n-}\n-\n-// END RUST SOURCE\n-// START rustc.{{impl}}-foo.EraseRegions.after.mir\n-//     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId(0/0:5 ~ validate_1[317d]::{{impl}}[0]::foo[0]), BrAnon(0)) Test, _2: &ReFree(DefId(0/0:5 ~ validate_1[317d]::{{impl}}[0]::foo[0]), BrAnon(1)) mut i32]);\n-//         ...\n-//         return;\n-//     }\n-// END rustc.{{impl}}-foo.EraseRegions.after.mir\n-// START rustc.main.EraseRegions.after.mir\n-// fn main() -> () {\n-//     ...\n-//     bb0: {\n-//         ...\n-//         Validate(Suspend(ReScope(Node(ItemLocalId(13)))), [_1: i32]);\n-//         _6 = &ReErased mut _1;\n-//         Validate(Acquire, [(*_6): i32/ReScope(Node(ItemLocalId(13)))]);\n-//         Validate(Suspend(ReScope(Node(ItemLocalId(13)))), [(*_6): i32/ReScope(Node(ItemLocalId(13)))]);\n-//         _5 = &ReErased mut (*_6);\n-//         Validate(Acquire, [(*_5): i32/ReScope(Node(ItemLocalId(13)))]);\n-//         Validate(Release, [_2: (), _3: &ReScope(Node(ItemLocalId(13))) Test, _5: &ReScope(Node(ItemLocalId(13))) mut i32]);\n-//         _2 = const Test::foo(move _3, move _5) -> bb1;\n-//     }\n-//\n-//     bb1: {\n-//         Validate(Acquire, [_2: ()]);\n-//         EndRegion(ReScope(Node(ItemLocalId(13))));\n-//         ...\n-//         return;\n-//     }\n-// }\n-// END rustc.main.EraseRegions.after.mir\n-// START rustc.main-{{closure}}.EraseRegions.after.mir\n-// fn main::{{closure}}(_1: &ReErased [closure@NodeId(65)], _2: &ReErased mut i32) -> i32 {\n-//     ...\n-//     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId(0/1:11 ~ validate_1[317d]::main[0]::{{closure}}[0]), BrEnv) [closure@NodeId(65)], _2: &ReFree(DefId(0/1:11 ~ validate_1[317d]::main[0]::{{closure}}[0]), BrAnon(0)) mut i32]);\n-//         StorageLive(_3);\n-//         Validate(Suspend(ReScope(Remainder { block: ItemLocalId(31), first_statement_index: 0 })), [(*_2): i32]);\n-//         _3 = &ReErased (*_2);\n-//         Validate(Acquire, [(*_3): i32/ReScope(Remainder { block: ItemLocalId(31), first_statement_index: 0 }) (imm)]);\n-//         _0 = (*_3);\n-//         EndRegion(ReScope(Remainder { block: ItemLocalId(31), first_statement_index: 0 }));\n-//         StorageDead(_3);\n-//         return;\n-//     }\n-// }\n-// END rustc.main-{{closure}}.EraseRegions.after.mir"}, {"sha": "3776a11b3ab825ceb53ad5241d1bfdd3be2b83f0", "filename": "src/test/mir-opt/validate_2.rs", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d0c869c323289c5ec4df83e1c9091fa0b3e2fc07/src%2Ftest%2Fmir-opt%2Fvalidate_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c869c323289c5ec4df83e1c9091fa0b3e2fc07/src%2Ftest%2Fmir-opt%2Fvalidate_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_2.rs?ref=d0c869c323289c5ec4df83e1c9091fa0b3e2fc07", "patch": "@@ -1,37 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-tidy-linelength\n-// ignore-wasm32-bare unwinding being disabled causes differences in output\n-// ignore-wasm64-bare unwinding being disabled causes differences in output\n-// compile-flags: -Z verbose -Z mir-emit-validate=1\n-\n-fn main() {\n-    let _x : Box<[i32]> = Box::new([1, 2, 3]);\n-}\n-\n-// END RUST SOURCE\n-// START rustc.main.EraseRegions.after.mir\n-// fn main() -> () {\n-//     ...\n-//     bb1: {\n-//         Validate(Acquire, [_2: std::boxed::Box<[i32; 3]>]);\n-//         Validate(Release, [_2: std::boxed::Box<[i32; 3]>]);\n-//         _1 = move _2 as std::boxed::Box<[i32]> (Unsize);\n-//         Validate(Acquire, [_1: std::boxed::Box<[i32]>]);\n-//         StorageDead(_2);\n-//         StorageDead(_3);\n-//         _0 = ();\n-//         Validate(Release, [_1: std::boxed::Box<[i32]>]);\n-//         drop(_1) -> [return: bb2, unwind: bb3];\n-//     }\n-//     ...\n-// }\n-// END rustc.main.EraseRegions.after.mir"}, {"sha": "ce840397713ad6031063f69b97a21552734f301c", "filename": "src/test/mir-opt/validate_3.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/d0c869c323289c5ec4df83e1c9091fa0b3e2fc07/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c869c323289c5ec4df83e1c9091fa0b3e2fc07/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs?ref=d0c869c323289c5ec4df83e1c9091fa0b3e2fc07", "patch": "@@ -1,77 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-tidy-linelength\n-// compile-flags: -Z verbose -Z mir-emit-validate=1\n-\n-struct Test {\n-    x: i32\n-}\n-\n-fn foo(_x: &i32) {}\n-\n-fn main() {\n-    // These internal unsafe functions should have no effect on the code generation.\n-    unsafe fn _unused1() {}\n-    fn _unused2(x: *const i32) -> i32 { unsafe { *x }}\n-\n-    let t = Test { x: 0 };\n-    let t = &t;\n-    foo(&t.x);\n-}\n-\n-// END RUST SOURCE\n-// START rustc.main.EraseRegions.after.mir\n-// fn main() -> (){\n-//     let mut _0: ();\n-//     scope 1 {\n-//         scope 3 {\n-//         }\n-//         scope 4 {\n-//             let _2: &ReErased Test;\n-//         }\n-//     }\n-//     scope 2 {\n-//         let _1: Test;\n-//     }\n-//     let mut _3: ();\n-//     let mut _4: &ReErased i32;\n-//     let mut _5: &ReErased i32;\n-//     bb0: {\n-//         StorageLive(_1);\n-//         _1 = Test { x: const 0i32 };\n-//         StorageLive(_2);\n-//         Validate(Suspend(ReScope(Remainder { block: ItemLocalId(24), first_statement_index: 3 })), [_1: Test]);\n-//         _2 = &ReErased _1;\n-//         Validate(Acquire, [(*_2): Test/ReScope(Remainder { block: ItemLocalId(24), first_statement_index: 3 }) (imm)]);\n-//         StorageLive(_4);\n-//         StorageLive(_5);\n-//         Validate(Suspend(ReScope(Node(ItemLocalId(22)))), [((*_2).0: i32): i32/ReScope(Remainder { block: ItemLocalId(24), first_statement_index: 3 }) (imm)]);\n-//         _5 = &ReErased ((*_2).0: i32);\n-//         Validate(Acquire, [(*_5): i32/ReScope(Node(ItemLocalId(22))) (imm)]);\n-//         Validate(Suspend(ReScope(Node(ItemLocalId(22)))), [(*_5): i32/ReScope(Node(ItemLocalId(22))) (imm)]);\n-//         _4 = &ReErased (*_5);\n-//         Validate(Acquire, [(*_4): i32/ReScope(Node(ItemLocalId(22))) (imm)]);\n-//         Validate(Release, [_3: (), _4: &ReScope(Node(ItemLocalId(22))) i32]);\n-//         _3 = const foo(move _4) -> bb1;\n-//     }\n-//     bb1: {\n-//         Validate(Acquire, [_3: ()]);\n-//         EndRegion(ReScope(Node(ItemLocalId(22))));\n-//         StorageDead(_4);\n-//         StorageDead(_5);\n-//         _0 = ();\n-//         EndRegion(ReScope(Remainder { block: ItemLocalId(24), first_statement_index: 3 }));\n-//         StorageDead(_2);\n-//         StorageDead(_1);\n-//         return;\n-//     }\n-// }\n-// END rustc.main.EraseRegions.after.mir"}, {"sha": "542ac8a42411f1d852565b6be9f87f31f00e7646", "filename": "src/test/mir-opt/validate_4.rs", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/d0c869c323289c5ec4df83e1c9091fa0b3e2fc07/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c869c323289c5ec4df83e1c9091fa0b3e2fc07/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs?ref=d0c869c323289c5ec4df83e1c9091fa0b3e2fc07", "patch": "@@ -1,90 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-tidy-linelength\n-// compile-flags: -Z verbose -Z mir-emit-validate=1 -Z span_free_formats\n-\n-// Make sure unsafe fns and fns with an unsafe block only get restricted validation.\n-\n-unsafe fn write_42(x: *mut i32) -> bool {\n-    let test_closure = |x: *mut i32| *x = 23;\n-    test_closure(x);\n-    *x = 42;\n-    true\n-}\n-\n-fn test(x: &mut i32) {\n-    unsafe { write_42(x) };\n-}\n-\n-fn main() {\n-    test(&mut 0);\n-\n-    let test_closure = unsafe { |x: &mut i32| write_42(x) };\n-    test_closure(&mut 0);\n-}\n-\n-// FIXME: Also test code generated inside the closure, make sure it only does restricted validation\n-// because it is entirely inside an unsafe block.  Unfortunately, the interesting lines of code also\n-// contain name of the source file, so we cannot test for it.\n-\n-// END RUST SOURCE\n-// START rustc.write_42.EraseRegions.after.mir\n-// fn write_42(_1: *mut i32) -> bool {\n-//     ...\n-//     bb0: {\n-//         Validate(Acquire, [_1: *mut i32]);\n-//         Validate(Release, [_1: *mut i32]);\n-//         ...\n-//         return;\n-//     }\n-// }\n-// END rustc.write_42.EraseRegions.after.mir\n-// START rustc.write_42-{{closure}}.EraseRegions.after.mir\n-// fn write_42::{{closure}}(_1: &ReErased [closure@NodeId(32)], _2: *mut i32) -> () {\n-//     ...\n-//     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId(0/1:9 ~ validate_4[317d]::write_42[0]::{{closure}}[0]), BrEnv) [closure@NodeId(32)], _2: *mut i32]);\n-//         Validate(Release, [_1: &ReFree(DefId(0/1:9 ~ validate_4[317d]::write_42[0]::{{closure}}[0]), BrEnv) [closure@NodeId(32)], _2: *mut i32]);\n-//         (*_2) = const 23i32;\n-//         _0 = ();\n-//         return;\n-//     }\n-// }\n-// END rustc.write_42-{{closure}}.EraseRegions.after.mir\n-// START rustc.test.EraseRegions.after.mir\n-// fn test(_1: &ReErased mut i32) -> () {\n-//     ...\n-//     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId(0/0:4 ~ validate_4[317d]::test[0]), BrAnon(0)) mut i32]);\n-//         Validate(Release, [_1: &ReFree(DefId(0/0:4 ~ validate_4[317d]::test[0]), BrAnon(0)) mut i32]);\n-//         ...\n-//         _2 = const write_42(move _3) -> bb1;\n-//     }\n-//     bb1: {\n-//         Validate(Acquire, [_2: bool]);\n-//         Validate(Release, [_2: bool]);\n-//         ...\n-//     }\n-// }\n-// END rustc.test.EraseRegions.after.mir\n-// START rustc.main-{{closure}}.EraseRegions.after.mir\n-// fn main::{{closure}}(_1: &ReErased [closure@NodeId(80)], _2: &ReErased mut i32) -> bool {\n-//     ...\n-//     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId(0/1:10 ~ validate_4[317d]::main[0]::{{closure}}[0]), BrEnv) [closure@NodeId(80)], _2: &ReFree(DefId(0/1:10 ~ validate_4[317d]::main[0]::{{closure}}[0]), BrAnon(0)) mut i32]);\n-//         Validate(Release, [_1: &ReFree(DefId(0/1:10 ~ validate_4[317d]::main[0]::{{closure}}[0]), BrEnv) [closure@NodeId(80)], _2: &ReFree(DefId(0/1:10 ~ validate_4[317d]::main[0]::{{closure}}[0]), BrAnon(0)) mut i32]);\n-//         StorageLive(_3);\n-//         ...\n-//         _0 = const write_42(move _3) -> bb1;\n-//     }\n-//     ...\n-// }\n-// END rustc.main-{{closure}}.EraseRegions.after.mir"}, {"sha": "955de0c3bad043e45d8d46c2722e6bc5199e87dc", "filename": "src/test/mir-opt/validate_5.rs", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/d0c869c323289c5ec4df83e1c9091fa0b3e2fc07/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c869c323289c5ec4df83e1c9091fa0b3e2fc07/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs?ref=d0c869c323289c5ec4df83e1c9091fa0b3e2fc07", "patch": "@@ -1,69 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-tidy-linelength\n-// compile-flags: -Z verbose -Z mir-emit-validate=2 -Z span_free_formats\n-\n-// Make sure unsafe fns and fns with an unsafe block still get full validation.\n-\n-unsafe fn write_42(x: *mut i32) -> bool {\n-    *x = 42;\n-    true\n-}\n-\n-fn test(x: &mut i32) {\n-    unsafe { write_42(x) };\n-}\n-\n-fn main() {\n-    test(&mut 0);\n-\n-    let test_closure = unsafe { |x: &mut i32| write_42(x) };\n-    // Note that validation will fail if this is executed: The closure keeps the lock on\n-    // x, so the write in write_42 fails.  This test just checks code generation,\n-    // so the UB doesn't matter.\n-    test_closure(&mut 0);\n-}\n-\n-// END RUST SOURCE\n-// START rustc.test.EraseRegions.after.mir\n-// fn test(_1: &ReErased mut i32) -> () {\n-//     ...\n-//     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId(0/0:4 ~ validate_5[317d]::test[0]), BrAnon(0)) mut i32]);\n-//         ...\n-//         Validate(Release, [_2: bool, _3: *mut i32]);\n-//         _2 = const write_42(move _3) -> bb1;\n-//     }\n-//     ...\n-// }\n-// END rustc.test.EraseRegions.after.mir\n-// START rustc.main-{{closure}}.EraseRegions.after.mir\n-// fn main::{{closure}}(_1: &ReErased [closure@NodeId(62)], _2: &ReErased mut i32) -> bool {\n-//     ...\n-//     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId(0/1:9 ~ validate_5[317d]::main[0]::{{closure}}[0]), BrEnv) [closure@NodeId(62)], _2: &ReFree(DefId(0/1:9 ~ validate_5[317d]::main[0]::{{closure}}[0]), BrAnon(0)) mut i32]);\n-//         StorageLive(_3);\n-//         StorageLive(_4);\n-//         StorageLive(_5);\n-//         Validate(Suspend(ReScope(Node(ItemLocalId(16)))), [(*_2): i32]);\n-//         _5 = &ReErased mut (*_2);\n-//         Validate(Acquire, [(*_5): i32/ReScope(Node(ItemLocalId(16)))]);\n-//         _4 = move _5 as *mut i32 (Misc);\n-//         _3 = move _4;\n-//         EndRegion(ReScope(Node(ItemLocalId(16))));\n-//         StorageDead(_4);\n-//         StorageDead(_5);\n-//         Validate(Release, [_0: bool, _3: *mut i32]);\n-//         _0 = const write_42(move _3) -> bb1;\n-//     }\n-//     ...\n-// }\n-// END rustc.main-{{closure}}.EraseRegions.after.mir"}]}