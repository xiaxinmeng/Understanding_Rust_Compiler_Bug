{"sha": "c213c68500f5fff51f26997d27a346c896232df7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyMTNjNjg1MDBmNWZmZjUxZjI2OTk3ZDI3YTM0NmM4OTYyMzJkZjc=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-09-11T17:29:55Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-09-11T17:29:55Z"}, "message": "box ResolutionFailures on the heap\n\nThis decreases the size of the `Result`s being returned,\nimproving performance in the common case.", "tree": {"sha": "c66cd6fda8d5beb4f5fd939c059d28d84391626b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c66cd6fda8d5beb4f5fd939c059d28d84391626b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c213c68500f5fff51f26997d27a346c896232df7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c213c68500f5fff51f26997d27a346c896232df7", "html_url": "https://github.com/rust-lang/rust/commit/c213c68500f5fff51f26997d27a346c896232df7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c213c68500f5fff51f26997d27a346c896232df7/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd72d9029ff5b2368e5c539f9b326a2eea855127", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd72d9029ff5b2368e5c539f9b326a2eea855127", "html_url": "https://github.com/rust-lang/rust/commit/cd72d9029ff5b2368e5c539f9b326a2eea855127"}], "stats": {"total": 69, "additions": 32, "deletions": 37}, "files": [{"sha": "7fea70253b3012b8073df4a120043bc5a8993536", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 32, "deletions": 37, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/c213c68500f5fff51f26997d27a346c896232df7/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c213c68500f5fff51f26997d27a346c896232df7/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=c213c68500f5fff51f26997d27a346c896232df7", "patch": "@@ -48,10 +48,16 @@ pub fn collect_intra_doc_links(krate: Crate, cx: &DocContext<'_>) -> Crate {\n }\n \n enum ErrorKind<'a> {\n-    Resolve(ResolutionFailure<'a>),\n+    Resolve(Box<ResolutionFailure<'a>>),\n     AnchorFailure(AnchorFailure),\n }\n \n+impl<'a> From<ResolutionFailure<'a>> for ErrorKind<'a> {\n+    fn from(err: ResolutionFailure<'a>) -> Self {\n+        ErrorKind::Resolve(box err)\n+    }\n+}\n+\n #[derive(Debug)]\n enum ResolutionFailure<'a> {\n     /// This resolved, but with the wrong namespace.\n@@ -142,10 +148,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             .expect(\"fold_item should ensure link is non-empty\");\n         let variant_name =\n             // we're not sure this is a variant at all, so use the full string\n-            split.next().map(|f| Symbol::intern(f)).ok_or(ErrorKind::Resolve(ResolutionFailure::NotInScope{\n+            split.next().map(|f| Symbol::intern(f)).ok_or_else(|| ResolutionFailure::NotInScope {\n                 module_id,\n                 name: path_str.into(),\n-            }))?;\n+            })?;\n         let path = split\n             .next()\n             .map(|f| {\n@@ -156,21 +162,18 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 }\n                 f.to_owned()\n             })\n-            .ok_or(ErrorKind::Resolve(ResolutionFailure::NotInScope {\n+            .ok_or_else(|| ResolutionFailure::NotInScope {\n                 module_id,\n                 name: variant_name.to_string().into(),\n-            }))?;\n+            })?;\n         let ty_res = cx\n             .enter_resolver(|resolver| {\n                 resolver.resolve_str_path_error(DUMMY_SP, &path, TypeNS, module_id)\n             })\n             .map(|(_, res)| res)\n             .unwrap_or(Res::Err);\n         if let Res::Err = ty_res {\n-            return Err(ErrorKind::Resolve(ResolutionFailure::NotInScope {\n-                module_id,\n-                name: path.into(),\n-            }));\n+            return Err(ResolutionFailure::NotInScope { module_id, name: path.into() }.into());\n         }\n         let ty_res = ty_res.map_id(|_| panic!(\"unexpected node_id\"));\n         match ty_res {\n@@ -184,7 +187,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 {\n                     // This is just to let `fold_item` know that this shouldn't be considered;\n                     // it's a bug for the error to make it to the user\n-                    return Err(ErrorKind::Resolve(ResolutionFailure::Dummy));\n+                    return Err(ResolutionFailure::Dummy.into());\n                 }\n                 match cx.tcx.type_of(did).kind() {\n                     ty::Adt(def, _) if def.is_enum() => {\n@@ -197,10 +200,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                 )),\n                             ))\n                         } else {\n-                            Err(ErrorKind::Resolve(ResolutionFailure::NotAVariant(\n-                                ty_res,\n-                                variant_field_name,\n-                            )))\n+                            Err(ResolutionFailure::NotAVariant(ty_res, variant_field_name).into())\n                         }\n                     }\n                     _ => unreachable!(),\n@@ -226,7 +226,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     // Even with the shorter path, it didn't resolve, so say that.\n                     ResolutionFailure::NoAssocItem(ty_res, variant_name)\n                 };\n-                Err(ErrorKind::Resolve(kind))\n+                Err(kind.into())\n             }\n         }\n     }\n@@ -344,7 +344,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 };\n \n                 if value != (ns == ValueNS) {\n-                    return Err(ErrorKind::Resolve(ResolutionFailure::WrongNamespace(res, ns)));\n+                    return Err(ResolutionFailure::WrongNamespace(res, ns).into());\n                 }\n             } else if let Some((path, prim)) = is_primitive(path_str, ns) {\n                 if extra_fragment.is_some() {\n@@ -373,16 +373,12 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 // So we can be sure that `rustc_resolve` was accurate when it said it wasn't resolved.\n                 .ok_or_else(|| {\n                     debug!(\"found no `::`, assumming {} was correctly not in scope\", item_name);\n-                    ErrorKind::Resolve(ResolutionFailure::NotInScope {\n-                        module_id,\n-                        name: item_name.to_string().into(),\n-                    })\n+                    ResolutionFailure::NotInScope { module_id, name: item_name.to_string().into() }\n                 })?;\n \n             if let Some((path, prim)) = is_primitive(&path_root, TypeNS) {\n-                let impls = primitive_impl(cx, &path).ok_or_else(|| {\n-                    ErrorKind::Resolve(ResolutionFailure::NoPrimitiveImpl(prim, path_root.into()))\n-                })?;\n+                let impls = primitive_impl(cx, &path)\n+                    .ok_or_else(|| ResolutionFailure::NoPrimitiveImpl(prim, path_root.into()))?;\n                 for &impl_ in impls {\n                     let link = cx\n                         .tcx\n@@ -409,11 +405,12 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     item_name,\n                     ns.descr()\n                 );\n-                return Err(ErrorKind::Resolve(ResolutionFailure::NoPrimitiveAssocItem {\n+                return Err(ResolutionFailure::NoPrimitiveAssocItem {\n                     res: prim,\n                     prim_name: path,\n                     assoc_item: item_name,\n-                }));\n+                }\n+                .into());\n             }\n \n             let ty_res = cx\n@@ -445,7 +442,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                             }\n                             ResolutionFailure::NotInScope { module_id, name: path_root.into() }\n                         });\n-                        Err(ErrorKind::Resolve(kind))\n+                        Err(kind.into())\n                     };\n                 }\n                 Ok(res) => res,\n@@ -548,9 +545,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         }\n                     } else {\n                         // We already know this isn't in ValueNS, so no need to check variant_field\n-                        return Err(ErrorKind::Resolve(ResolutionFailure::NoAssocItem(\n-                            ty_res, item_name,\n-                        )));\n+                        return Err(ResolutionFailure::NoAssocItem(ty_res, item_name).into());\n                     }\n                 }\n                 Res::Def(DefKind::Trait, did) => cx\n@@ -585,12 +580,12 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 if ns == Namespace::ValueNS {\n                     self.variant_field(path_str, current_item, module_id, extra_fragment)\n                 } else {\n-                    Err(ErrorKind::Resolve(ResolutionFailure::NoAssocItem(ty_res, item_name)))\n+                    Err(ResolutionFailure::NoAssocItem(ty_res, item_name).into())\n                 }\n             })\n         } else {\n             debug!(\"attempting to resolve item without parent module: {}\", path_str);\n-            Err(ErrorKind::Resolve(ResolutionFailure::NoParentItem))\n+            Err(ResolutionFailure::NoParentItem.into())\n         }\n     }\n \n@@ -611,7 +606,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         let check_full_res_inner = |this: &Self, result: Result<Res, ErrorKind<'_>>| {\n             let res = match result {\n                 Ok(res) => Some(res),\n-                Err(ErrorKind::Resolve(kind)) => kind.full_res(),\n+                Err(ErrorKind::Resolve(box kind)) => kind.full_res(),\n                 Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(res))) => {\n                     Some(res)\n                 }\n@@ -626,7 +621,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         };\n         let check_full_res_macro = |this: &Self| {\n             let result = this.macro_resolve(path_str, base_node);\n-            check_full_res_inner(this, result.map_err(ErrorKind::Resolve))\n+            check_full_res_inner(this, result.map_err(ErrorKind::from))\n         };\n         match ns {\n             Namespace::MacroNS => check_full_res_macro(self),\n@@ -970,7 +965,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         match self.resolve(path_str, ns, &current_item, base_node, &extra_fragment)\n                         {\n                             Ok(res) => res,\n-                            Err(ErrorKind::Resolve(mut kind)) => {\n+                            Err(ErrorKind::Resolve(box mut kind)) => {\n                                 // We only looked in one namespace. Try to give a better error if possible.\n                                 if kind.full_res().is_none() {\n                                     let other_ns = if ns == ValueNS { TypeNS } else { ValueNS };\n@@ -1028,7 +1023,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                                     anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n                                     continue;\n                                 }\n-                                Err(ErrorKind::Resolve(kind)) => Err(kind),\n+                                Err(ErrorKind::Resolve(box kind)) => Err(kind),\n                             },\n                             value_ns: match self.resolve(\n                                 path_str,\n@@ -1042,7 +1037,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                                     anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n                                     continue;\n                                 }\n-                                Err(ErrorKind::Resolve(kind)) => Err(kind),\n+                                Err(ErrorKind::Resolve(box kind)) => Err(kind),\n                             }\n                             .and_then(|(res, fragment)| {\n                                 // Constructors are picked up in the type namespace.\n@@ -1816,7 +1811,7 @@ fn handle_variant(\n     let parent = if let Some(parent) = cx.tcx.parent(res.def_id()) {\n         parent\n     } else {\n-        return Err(ErrorKind::Resolve(ResolutionFailure::NoParentItem));\n+        return Err(ResolutionFailure::NoParentItem.into());\n     };\n     let parent_def = Res::Def(DefKind::Enum, parent);\n     let variant = cx.tcx.expect_variant_res(res);"}]}