{"sha": "ab896e38e124676c4d0532b74f4d0d714b33b2f9", "node_id": "C_kwDOAAsO6NoAKGFiODk2ZTM4ZTEyNDY3NmM0ZDA1MzJiNzRmNGQwZDcxNGIzM2IyZjk", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-02-25T16:11:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-25T16:11:22Z"}, "message": "Merge #11550\n\n11550: Refactor autoderef/method resolution r=flodiebold a=flodiebold\n\n- don't return the receiver type from method resolution; instead just\r\n return the autorefs/autoderefs that happened and repeat them. This\r\n ensures all the effects like trait obligations and whatever we learned\r\n about type variables from derefing them are actually applied. Also, it\r\n allows us to get rid of `decanonicalize_ty`, which was just wrong in\r\n principle.\r\n\r\n - Autoderef itself now directly works with an inference table. Sadly\r\n this has the effect of making it harder to use as an iterator, often\r\n requiring manual `while let` loops. (rustc works around this by using\r\n inner mutability in the inference context, so that things like unifying\r\n types don't require a unique reference.)\r\n\r\n - We now record the adjustments (autoref/deref) for method receivers\r\n and index expressions, which we didn't before.\r\n\r\n - Removed the redundant crate parameter from method resolution, since\r\n the trait_env contains the crate as well.\r\n\r\n - in the HIR API, the methods now take a scope to determine the trait env.\r\n `Type` carries a trait env, but I think that's probably a bad decision\r\n because it's easy to create it with the wrong env, e.g. by using\r\n `Adt::ty`. This mostly didn't matter so far because\r\n `iterate_method_candidates` took a crate parameter and ignored\r\n `self.krate`, but the trait env would still have been wrong in those\r\n cases, which I think would give some wrong results in some edge cases.\r\n\r\nFixes #10058.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "9c5325fdb04ce15a5fae4a2f2c67e8375dee30f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c5325fdb04ce15a5fae4a2f2c67e8375dee30f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab896e38e124676c4d0532b74f4d0d714b33b2f9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiGP+qCRBK7hj4Ov3rIwAAJrEIAAtY/2y41WSF066ZL+y4y8mx\nRrrbrXq3NapTNww5Vd8rt8aVIm7n/BO6rHU8YbXM9cWsRITAEOf40L5ZsiSKlChf\nFkuV9owa0VxOAnpeEU2Nx3rIrYkDLWGPPoBkjata0TXSJHRdlG6ehxQIWiDbCqnk\n0FIACQQkqXVBWQnSVIzIVTWnery1zeRr/NEp37VTu+6tSXmNdEI0f0yi2DScttD9\n+wU0mBHK4jMNSIFYB37udDchH9dNrztdiud43Xou2Tk4IWdgQH2AF/RrQgSAEJPs\nHT3zEG3XYer4xjcGcXTvbNaabXHf1jqgDV8rQa8BPxsTb14lL6RJftagGI21XS0=\n=XrFa\n-----END PGP SIGNATURE-----\n", "payload": "tree 9c5325fdb04ce15a5fae4a2f2c67e8375dee30f5\nparent c8257488c178d1828159ae931a5539c9a10219f8\nparent 6fc3d3aa4cbf637d748c60cfdbb98b5f6a040576\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1645805482 +0000\ncommitter GitHub <noreply@github.com> 1645805482 +0000\n\nMerge #11550\n\n11550: Refactor autoderef/method resolution r=flodiebold a=flodiebold\n\n- don't return the receiver type from method resolution; instead just\r\n return the autorefs/autoderefs that happened and repeat them. This\r\n ensures all the effects like trait obligations and whatever we learned\r\n about type variables from derefing them are actually applied. Also, it\r\n allows us to get rid of `decanonicalize_ty`, which was just wrong in\r\n principle.\r\n\r\n - Autoderef itself now directly works with an inference table. Sadly\r\n this has the effect of making it harder to use as an iterator, often\r\n requiring manual `while let` loops. (rustc works around this by using\r\n inner mutability in the inference context, so that things like unifying\r\n types don't require a unique reference.)\r\n\r\n - We now record the adjustments (autoref/deref) for method receivers\r\n and index expressions, which we didn't before.\r\n\r\n - Removed the redundant crate parameter from method resolution, since\r\n the trait_env contains the crate as well.\r\n\r\n - in the HIR API, the methods now take a scope to determine the trait env.\r\n `Type` carries a trait env, but I think that's probably a bad decision\r\n because it's easy to create it with the wrong env, e.g. by using\r\n `Adt::ty`. This mostly didn't matter so far because\r\n `iterate_method_candidates` took a crate parameter and ignored\r\n `self.krate`, but the trait env would still have been wrong in those\r\n cases, which I think would give some wrong results in some edge cases.\r\n\r\nFixes #10058.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab896e38e124676c4d0532b74f4d0d714b33b2f9", "html_url": "https://github.com/rust-lang/rust/commit/ab896e38e124676c4d0532b74f4d0d714b33b2f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab896e38e124676c4d0532b74f4d0d714b33b2f9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8257488c178d1828159ae931a5539c9a10219f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8257488c178d1828159ae931a5539c9a10219f8", "html_url": "https://github.com/rust-lang/rust/commit/c8257488c178d1828159ae931a5539c9a10219f8"}, {"sha": "6fc3d3aa4cbf637d748c60cfdbb98b5f6a040576", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fc3d3aa4cbf637d748c60cfdbb98b5f6a040576", "html_url": "https://github.com/rust-lang/rust/commit/6fc3d3aa4cbf637d748c60cfdbb98b5f6a040576"}], "stats": {"total": 1438, "additions": 775, "deletions": 663}, "files": [{"sha": "54f35cf0a6ee9992b4739e49379fdfc500d0a7eb", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 45, "deletions": 47, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=ab896e38e124676c4d0532b74f4d0d714b33b2f9", "patch": "@@ -2440,7 +2440,7 @@ impl Impl {\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct Type {\n-    krate: CrateId,\n+    krate: CrateId, // FIXME this is probably redundant with the TraitEnvironment\n     env: Arc<TraitEnvironment>,\n     ty: Ty,\n }\n@@ -2533,36 +2533,25 @@ impl Type {\n     /// Checks that particular type `ty` implements `std::future::Future`.\n     /// This function is used in `.await` syntax completion.\n     pub fn impls_future(&self, db: &dyn HirDatabase) -> bool {\n-        // No special case for the type of async block, since Chalk can figure it out.\n-\n-        let krate = self.krate;\n-\n-        let std_future_trait =\n-            db.lang_item(krate, SmolStr::new_inline(\"future_trait\")).and_then(|it| it.as_trait());\n+        let std_future_trait = db\n+            .lang_item(self.krate, SmolStr::new_inline(\"future_trait\"))\n+            .and_then(|it| it.as_trait());\n         let std_future_trait = match std_future_trait {\n             Some(it) => it,\n             None => return false,\n         };\n \n         let canonical_ty =\n             Canonical { value: self.ty.clone(), binders: CanonicalVarKinds::empty(Interner) };\n-        method_resolution::implements_trait(\n-            &canonical_ty,\n-            db,\n-            self.env.clone(),\n-            krate,\n-            std_future_trait,\n-        )\n+        method_resolution::implements_trait(&canonical_ty, db, self.env.clone(), std_future_trait)\n     }\n \n     /// Checks that particular type `ty` implements `std::ops::FnOnce`.\n     ///\n     /// This function can be used to check if a particular type is callable, since FnOnce is a\n     /// supertrait of Fn and FnMut, so all callable types implements at least FnOnce.\n     pub fn impls_fnonce(&self, db: &dyn HirDatabase) -> bool {\n-        let krate = self.krate;\n-\n-        let fnonce_trait = match FnTrait::FnOnce.get_id(db, krate) {\n+        let fnonce_trait = match FnTrait::FnOnce.get_id(db, self.krate) {\n             Some(it) => it,\n             None => return false,\n         };\n@@ -2573,7 +2562,6 @@ impl Type {\n             &canonical_ty,\n             db,\n             self.env.clone(),\n-            krate,\n             fnonce_trait,\n         )\n     }\n@@ -2744,9 +2732,8 @@ impl Type {\n     pub fn autoderef_<'a>(&'a self, db: &'a dyn HirDatabase) -> impl Iterator<Item = Ty> + 'a {\n         // There should be no inference vars in types passed here\n         let canonical = hir_ty::replace_errors_with_variables(&self.ty);\n-        let environment = self.env.env.clone();\n-        let ty = InEnvironment { goal: canonical, environment };\n-        autoderef(db, Some(self.krate), ty).map(|canonical| canonical.value)\n+        let environment = self.env.clone();\n+        autoderef(db, environment, canonical).map(|canonical| canonical.value)\n     }\n \n     // This would be nicer if it just returned an iterator, but that runs into\n@@ -2801,24 +2788,26 @@ impl Type {\n     pub fn iterate_method_candidates<T>(\n         &self,\n         db: &dyn HirDatabase,\n-        krate: Crate,\n+        scope: &SemanticsScope,\n+        // FIXME this can be retrieved from `scope`, except autoimport uses this\n+        // to specify a different set, so the method needs to be split\n         traits_in_scope: &FxHashSet<TraitId>,\n         with_local_impls: Option<Module>,\n         name: Option<&Name>,\n-        mut callback: impl FnMut(Type, Function) -> Option<T>,\n+        mut callback: impl FnMut(Function) -> Option<T>,\n     ) -> Option<T> {\n         let _p = profile::span(\"iterate_method_candidates\");\n         let mut slot = None;\n \n         self.iterate_method_candidates_dyn(\n             db,\n-            krate,\n+            scope,\n             traits_in_scope,\n             with_local_impls,\n             name,\n-            &mut |ty, assoc_item_id| {\n+            &mut |assoc_item_id| {\n                 if let AssocItemId::FunctionId(func) = assoc_item_id {\n-                    if let Some(res) = callback(self.derived(ty.clone()), func.into()) {\n+                    if let Some(res) = callback(func.into()) {\n                         slot = Some(res);\n                         return ControlFlow::Break(());\n                     }\n@@ -2832,50 +2821,55 @@ impl Type {\n     fn iterate_method_candidates_dyn(\n         &self,\n         db: &dyn HirDatabase,\n-        krate: Crate,\n+        scope: &SemanticsScope,\n         traits_in_scope: &FxHashSet<TraitId>,\n         with_local_impls: Option<Module>,\n         name: Option<&Name>,\n-        callback: &mut dyn FnMut(&Ty, AssocItemId) -> ControlFlow<()>,\n+        callback: &mut dyn FnMut(AssocItemId) -> ControlFlow<()>,\n     ) {\n         // There should be no inference vars in types passed here\n         let canonical = hir_ty::replace_errors_with_variables(&self.ty);\n \n-        let env = self.env.clone();\n-        let krate = krate.id;\n+        let krate = match scope.krate() {\n+            Some(k) => k,\n+            None => return,\n+        };\n+        let environment = scope.resolver().generic_def().map_or_else(\n+            || Arc::new(TraitEnvironment::empty(krate.id)),\n+            |d| db.trait_environment(d),\n+        );\n \n         method_resolution::iterate_method_candidates_dyn(\n             &canonical,\n             db,\n-            env,\n-            krate,\n+            environment,\n             traits_in_scope,\n             with_local_impls.and_then(|b| b.id.containing_block()).into(),\n             name,\n             method_resolution::LookupMode::MethodCall,\n-            &mut |ty, id| callback(&ty.value, id),\n+            &mut |_adj, id| callback(id),\n         );\n     }\n \n     pub fn iterate_path_candidates<T>(\n         &self,\n         db: &dyn HirDatabase,\n-        krate: Crate,\n+        scope: &SemanticsScope,\n         traits_in_scope: &FxHashSet<TraitId>,\n         with_local_impls: Option<Module>,\n         name: Option<&Name>,\n-        mut callback: impl FnMut(Type, AssocItem) -> Option<T>,\n+        mut callback: impl FnMut(AssocItem) -> Option<T>,\n     ) -> Option<T> {\n         let _p = profile::span(\"iterate_path_candidates\");\n         let mut slot = None;\n         self.iterate_path_candidates_dyn(\n             db,\n-            krate,\n+            scope,\n             traits_in_scope,\n             with_local_impls,\n             name,\n-            &mut |ty, assoc_item_id| {\n-                if let Some(res) = callback(self.derived(ty.clone()), assoc_item_id.into()) {\n+            &mut |assoc_item_id| {\n+                if let Some(res) = callback(assoc_item_id.into()) {\n                     slot = Some(res);\n                     return ControlFlow::Break(());\n                 }\n@@ -2888,27 +2882,31 @@ impl Type {\n     fn iterate_path_candidates_dyn(\n         &self,\n         db: &dyn HirDatabase,\n-        krate: Crate,\n+        scope: &SemanticsScope,\n         traits_in_scope: &FxHashSet<TraitId>,\n         with_local_impls: Option<Module>,\n         name: Option<&Name>,\n-        callback: &mut dyn FnMut(&Ty, AssocItemId) -> ControlFlow<()>,\n+        callback: &mut dyn FnMut(AssocItemId) -> ControlFlow<()>,\n     ) {\n         let canonical = hir_ty::replace_errors_with_variables(&self.ty);\n \n-        let env = self.env.clone();\n-        let krate = krate.id;\n+        let krate = match scope.krate() {\n+            Some(k) => k,\n+            None => return,\n+        };\n+        let environment = scope.resolver().generic_def().map_or_else(\n+            || Arc::new(TraitEnvironment::empty(krate.id)),\n+            |d| db.trait_environment(d),\n+        );\n \n-        method_resolution::iterate_method_candidates_dyn(\n+        method_resolution::iterate_path_candidates(\n             &canonical,\n             db,\n-            env,\n-            krate,\n+            environment,\n             traits_in_scope,\n             with_local_impls.and_then(|b| b.id.containing_block()).into(),\n             name,\n-            method_resolution::LookupMode::Path,\n-            &mut |ty, id| callback(&ty.value, id),\n+            &mut |id| callback(id),\n         );\n     }\n "}, {"sha": "2e0dbf82b77773e6129ee5e6687e9a79fa12fe64", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=ab896e38e124676c4d0532b74f4d0d714b33b2f9", "patch": "@@ -1230,6 +1230,10 @@ impl<'a> SemanticsScope<'a> {\n         Some(Crate { id: self.resolver.krate()? })\n     }\n \n+    pub(crate) fn resolver(&self) -> &Resolver {\n+        &self.resolver\n+    }\n+\n     /// Note: `FxHashSet<TraitId>` should be treated as an opaque type, passed into `Type\n     pub fn visible_traits(&self) -> FxHashSet<TraitId> {\n         let resolver = &self.resolver;"}, {"sha": "dffb36b5de31bb1be7933a6f79522cd0daffcbbc", "filename": "crates/hir_ty/src/autoderef.rs", "status": "modified", "additions": 48, "deletions": 172, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs?ref=ab896e38e124676c4d0532b74f4d0d714b33b2f9", "patch": "@@ -3,20 +3,16 @@\n //! reference to a type with the field `bar`. This is an approximation of the\n //! logic in rustc (which lives in librustc_typeck/check/autoderef.rs).\n \n-use std::iter::successors;\n+use std::sync::Arc;\n \n-use base_db::CrateId;\n-use chalk_ir::{cast::Cast, fold::Fold, interner::HasInterner, VariableKind};\n-use hir_def::lang_item::LangItemTarget;\n+use chalk_ir::cast::Cast;\n use hir_expand::name::name;\n use limit::Limit;\n use syntax::SmolStr;\n-use tracing::{info, warn};\n \n use crate::{\n-    db::HirDatabase, static_lifetime, AliasEq, AliasTy, BoundVar, Canonical, CanonicalVarKinds,\n-    ConstrainedSubst, DebruijnIndex, Environment, Guidance, InEnvironment, Interner,\n-    ProjectionTyExt, Solution, Substitution, Ty, TyBuilder, TyKind,\n+    db::HirDatabase, infer::unify::InferenceTable, Canonical, Goal, Interner, ProjectionTyExt,\n+    TraitEnvironment, Ty, TyBuilder, TyKind,\n };\n \n static AUTODEREF_RECURSION_LIMIT: Limit = Limit::new(10);\n@@ -26,40 +22,34 @@ pub(crate) enum AutoderefKind {\n     Overloaded,\n }\n \n-pub(crate) struct Autoderef<'db> {\n-    db: &'db dyn HirDatabase,\n-    ty: Canonical<Ty>,\n+pub(crate) struct Autoderef<'a, 'db> {\n+    pub(crate) table: &'a mut InferenceTable<'db>,\n+    ty: Ty,\n     at_start: bool,\n-    krate: Option<CrateId>,\n-    environment: Environment,\n     steps: Vec<(AutoderefKind, Ty)>,\n }\n \n-impl<'db> Autoderef<'db> {\n-    pub(crate) fn new(\n-        db: &'db dyn HirDatabase,\n-        krate: Option<CrateId>,\n-        ty: InEnvironment<Canonical<Ty>>,\n-    ) -> Self {\n-        let InEnvironment { goal: ty, environment } = ty;\n-        Autoderef { db, ty, at_start: true, environment, krate, steps: Vec::new() }\n+impl<'a, 'db> Autoderef<'a, 'db> {\n+    pub(crate) fn new(table: &'a mut InferenceTable<'db>, ty: Ty) -> Self {\n+        let ty = table.resolve_ty_shallow(&ty);\n+        Autoderef { table, ty, at_start: true, steps: Vec::new() }\n     }\n \n     pub(crate) fn step_count(&self) -> usize {\n         self.steps.len()\n     }\n \n-    pub(crate) fn steps(&self) -> &[(AutoderefKind, chalk_ir::Ty<Interner>)] {\n+    pub(crate) fn steps(&self) -> &[(AutoderefKind, Ty)] {\n         &self.steps\n     }\n \n     pub(crate) fn final_ty(&self) -> Ty {\n-        self.ty.value.clone()\n+        self.ty.clone()\n     }\n }\n \n-impl Iterator for Autoderef<'_> {\n-    type Item = (Canonical<Ty>, usize);\n+impl Iterator for Autoderef<'_, '_> {\n+    type Item = (Ty, usize);\n \n     fn next(&mut self) -> Option<Self::Item> {\n         if self.at_start {\n@@ -71,54 +61,42 @@ impl Iterator for Autoderef<'_> {\n             return None;\n         }\n \n-        let (kind, new_ty) = if let Some(derefed) = builtin_deref(&self.ty.value) {\n-            (\n-                AutoderefKind::Builtin,\n-                Canonical { value: derefed.clone(), binders: self.ty.binders.clone() },\n-            )\n-        } else {\n-            (\n-                AutoderefKind::Overloaded,\n-                deref_by_trait(\n-                    self.db,\n-                    self.krate?,\n-                    InEnvironment { goal: &self.ty, environment: self.environment.clone() },\n-                )?,\n-            )\n-        };\n+        let (kind, new_ty) = autoderef_step(self.table, self.ty.clone())?;\n \n-        self.steps.push((kind, self.ty.value.clone()));\n+        self.steps.push((kind, self.ty.clone()));\n         self.ty = new_ty;\n \n         Some((self.ty.clone(), self.step_count()))\n     }\n }\n \n+pub(crate) fn autoderef_step(table: &mut InferenceTable, ty: Ty) -> Option<(AutoderefKind, Ty)> {\n+    if let Some(derefed) = builtin_deref(&ty) {\n+        Some((AutoderefKind::Builtin, table.resolve_ty_shallow(derefed)))\n+    } else {\n+        Some((AutoderefKind::Overloaded, deref_by_trait(table, ty)?))\n+    }\n+}\n+\n // FIXME: replace uses of this with Autoderef above\n pub fn autoderef<'a>(\n     db: &'a dyn HirDatabase,\n-    krate: Option<CrateId>,\n-    ty: InEnvironment<Canonical<Ty>>,\n+    env: Arc<TraitEnvironment>,\n+    ty: Canonical<Ty>,\n ) -> impl Iterator<Item = Canonical<Ty>> + 'a {\n-    let InEnvironment { goal: ty, environment } = ty;\n-    successors(Some(ty), move |ty| {\n-        deref(db, krate?, InEnvironment { goal: ty, environment: environment.clone() })\n-    })\n-    .take(AUTODEREF_RECURSION_LIMIT.inner())\n+    let mut table = InferenceTable::new(db, env);\n+    let ty = table.instantiate_canonical(ty);\n+    let mut autoderef = Autoderef::new(&mut table, ty);\n+    let mut v = Vec::new();\n+    while let Some((ty, _steps)) = autoderef.next() {\n+        v.push(autoderef.table.canonicalize(ty).value);\n+    }\n+    v.into_iter()\n }\n \n-pub(crate) fn deref(\n-    db: &dyn HirDatabase,\n-    krate: CrateId,\n-    ty: InEnvironment<&Canonical<Ty>>,\n-) -> Option<Canonical<Ty>> {\n+pub(crate) fn deref(table: &mut InferenceTable, ty: Ty) -> Option<Ty> {\n     let _p = profile::span(\"deref\");\n-    match builtin_deref(&ty.goal.value) {\n-        Some(derefed) => {\n-            Some(Canonical { value: derefed.clone(), binders: ty.goal.binders.clone() })\n-        }\n-        None => deref_by_trait(db, krate, ty),\n-    }\n+    autoderef_step(table, ty).map(|(_, ty)| ty)\n }\n \n fn builtin_deref(ty: &Ty) -> Option<&Ty> {\n@@ -129,16 +107,12 @@ fn builtin_deref(ty: &Ty) -> Option<&Ty> {\n     }\n }\n \n-fn deref_by_trait(\n-    db: &dyn HirDatabase,\n-    krate: CrateId,\n-    ty: InEnvironment<&Canonical<Ty>>,\n-) -> Option<Canonical<Ty>> {\n+fn deref_by_trait(table: &mut InferenceTable, ty: Ty) -> Option<Ty> {\n+    let db = table.db;\n     let _p = profile::span(\"deref_by_trait\");\n-    let deref_trait = match db.lang_item(krate, SmolStr::new_inline(\"deref\"))? {\n-        LangItemTarget::TraitId(it) => it,\n-        _ => return None,\n-    };\n+    let deref_trait = db\n+        .lang_item(table.trait_env.krate, SmolStr::new_inline(\"deref\"))\n+        .and_then(|l| l.as_trait())?;\n     let target = db.trait_data(deref_trait).associated_type_by_name(&name![Target])?;\n \n     let projection = {\n@@ -148,114 +122,16 @@ fn deref_by_trait(\n             // namely Deref's Self type\n             return None;\n         }\n-        b.push(ty.goal.value.clone()).build()\n+        b.push(ty).build()\n     };\n \n-    // FIXME make the Canonical / bound var handling nicer\n-\n     // Check that the type implements Deref at all\n     let trait_ref = projection.trait_ref(db);\n-    let implements_goal = Canonical {\n-        binders: ty.goal.binders.clone(),\n-        value: InEnvironment {\n-            goal: trait_ref.cast(Interner),\n-            environment: ty.environment.clone(),\n-        },\n-    };\n-    if db.trait_solve(krate, implements_goal).is_none() {\n-        return None;\n-    }\n+    let implements_goal: Goal = trait_ref.cast(Interner);\n+    table.try_obligation(implements_goal.clone())?;\n \n-    // Now do the assoc type projection\n-    let alias_eq = AliasEq {\n-        alias: AliasTy::Projection(projection),\n-        ty: TyKind::BoundVar(BoundVar::new(\n-            DebruijnIndex::INNERMOST,\n-            ty.goal.binders.len(Interner),\n-        ))\n-        .intern(Interner),\n-    };\n-\n-    let in_env = InEnvironment { goal: alias_eq.cast(Interner), environment: ty.environment };\n-\n-    let canonical = Canonical {\n-        value: in_env,\n-        binders: CanonicalVarKinds::from_iter(\n-            Interner,\n-            ty.goal.binders.iter(Interner).cloned().chain(Some(chalk_ir::WithKind::new(\n-                VariableKind::Ty(chalk_ir::TyVariableKind::General),\n-                chalk_ir::UniverseIndex::ROOT,\n-            ))),\n-        ),\n-    };\n-\n-    let solution = db.trait_solve(krate, canonical)?;\n-\n-    match &solution {\n-        Solution::Unique(Canonical { value: ConstrainedSubst { subst, .. }, binders })\n-        | Solution::Ambig(Guidance::Definite(Canonical { value: subst, binders })) => {\n-            // FIXME: vars may contain solutions for any inference variables\n-            // that happened to be inside ty. To correctly handle these, we\n-            // would have to pass the solution up to the inference context, but\n-            // that requires a larger refactoring (especially if the deref\n-            // happens during method resolution). So for the moment, we just\n-            // check that we're not in the situation where we would actually\n-            // need to handle the values of the additional variables, i.e.\n-            // they're just being 'passed through'. In the 'standard' case where\n-            // we have `impl<T> Deref for Foo<T> { Target = T }`, that should be\n-            // the case.\n-\n-            // FIXME: if the trait solver decides to truncate the type, these\n-            // assumptions will be broken. We would need to properly introduce\n-            // new variables in that case\n-\n-            for i in 1..binders.len(Interner) {\n-                if subst.at(Interner, i - 1).assert_ty_ref(Interner).kind(Interner)\n-                    != &TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, i - 1))\n-                {\n-                    warn!(\"complex solution for derefing {:?}: {:?}, ignoring\", ty.goal, solution);\n-                    return None;\n-                }\n-            }\n-            // FIXME: we remove lifetime variables here since they can confuse\n-            // the method resolution code later\n-            Some(fixup_lifetime_variables(Canonical {\n-                value: subst.at(Interner, subst.len(Interner) - 1).assert_ty_ref(Interner).clone(),\n-                binders: binders.clone(),\n-            }))\n-        }\n-        Solution::Ambig(_) => {\n-            info!(\"Ambiguous solution for derefing {:?}: {:?}\", ty.goal, solution);\n-            None\n-        }\n-    }\n-}\n+    table.register_obligation(implements_goal);\n \n-fn fixup_lifetime_variables<T: Fold<Interner, Result = T> + HasInterner<Interner = Interner>>(\n-    c: Canonical<T>,\n-) -> Canonical<T> {\n-    // Removes lifetime variables from the Canonical, replacing them by static lifetimes.\n-    let mut i = 0;\n-    let subst = Substitution::from_iter(\n-        Interner,\n-        c.binders.iter(Interner).map(|vk| match vk.kind {\n-            VariableKind::Ty(_) => {\n-                let index = i;\n-                i += 1;\n-                BoundVar::new(DebruijnIndex::INNERMOST, index).to_ty(Interner).cast(Interner)\n-            }\n-            VariableKind::Lifetime => static_lifetime().cast(Interner),\n-            VariableKind::Const(_) => unimplemented!(),\n-        }),\n-    );\n-    let binders = CanonicalVarKinds::from_iter(\n-        Interner,\n-        c.binders.iter(Interner).filter(|vk| match vk.kind {\n-            VariableKind::Ty(_) => true,\n-            VariableKind::Lifetime => false,\n-            VariableKind::Const(_) => true,\n-        }),\n-    );\n-    let value = subst.apply(c.value, Interner);\n-    Canonical { binders, value }\n+    let result = table.normalize_projection_ty(projection);\n+    Some(table.resolve_ty_shallow(&result))\n }"}, {"sha": "c84604d69bf87f6e313e1299a1d979a6dfd47f27", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=ab896e38e124676c4d0532b74f4d0d714b33b2f9", "patch": "@@ -13,8 +13,8 @@\n //! to certain types. To record this, we use the union-find implementation from\n //! the `ena` crate, which is extracted from rustc.\n \n+use std::ops::Index;\n use std::sync::Arc;\n-use std::{collections::hash_map::Entry, ops::Index};\n \n use chalk_ir::{cast::Cast, DebruijnIndex, Mutability, Safety, Scalar, TypeFlags};\n use hir_def::{\n@@ -46,7 +46,7 @@ use crate::{\n pub use unify::could_unify;\n pub(crate) use unify::unify;\n \n-mod unify;\n+pub(crate) mod unify;\n mod path;\n mod expr;\n mod pat;\n@@ -228,7 +228,7 @@ pub enum Adjust {\n /// The target type is `U` in both cases, with the region and mutability\n /// being those shared by both the receiver and the returned reference.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct OverloadedDeref(Mutability);\n+pub struct OverloadedDeref(pub Mutability);\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum AutoBorrow {\n@@ -455,16 +455,6 @@ impl<'a> InferenceContext<'a> {\n         self.result.method_resolutions.insert(expr, (func, subst));\n     }\n \n-    fn write_field_resolution(&mut self, expr: ExprId, field: FieldId) {\n-        self.result.field_resolutions.insert(expr, field);\n-    }\n-\n-    fn write_field_resolution_if_empty(&mut self, expr: ExprId, field: FieldId) {\n-        if let Entry::Vacant(entry) = self.result.field_resolutions.entry(expr) {\n-            entry.insert(field);\n-        }\n-    }\n-\n     fn write_variant_resolution(&mut self, id: ExprOrPatId, variant: VariantId) {\n         self.result.variant_resolutions.insert(id, variant);\n     }"}, {"sha": "c24772f29b428709973ee7a9b3675cfbd2e95737", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=ab896e38e124676c4d0532b74f4d0d714b33b2f9", "patch": "@@ -259,27 +259,19 @@ impl<'a> InferenceContext<'a> {\n         // details of coercion errors though, so I think it's useful to leave\n         // the structure like it is.\n \n-        let canonicalized = self.canonicalize(from_ty.clone());\n-        let mut autoderef = Autoderef::new(\n-            self.db,\n-            self.resolver.krate(),\n-            InEnvironment {\n-                goal: canonicalized.value.clone(),\n-                environment: self.trait_env.env.clone(),\n-            },\n-        );\n+        let snapshot = self.table.snapshot();\n+\n+        let mut autoderef = Autoderef::new(&mut self.table, from_ty.clone());\n         let mut first_error = None;\n         let mut found = None;\n \n-        for (referent_ty, autoderefs) in autoderef.by_ref() {\n+        while let Some((referent_ty, autoderefs)) = autoderef.next() {\n             if autoderefs == 0 {\n                 // Don't let this pass, otherwise it would cause\n                 // &T to autoref to &&T.\n                 continue;\n             }\n \n-            let referent_ty = canonicalized.decanonicalize_ty(&mut self.table, referent_ty);\n-\n             // At this point, we have deref'd `a` to `referent_ty`.  So\n             // imagine we are coercing from `&'a mut Vec<T>` to `&'b mut [T]`.\n             // In the autoderef loop for `&'a mut Vec<T>`, we would get\n@@ -304,7 +296,7 @@ impl<'a> InferenceContext<'a> {\n             // from `&mut T` to `&U`.\n             let lt = static_lifetime(); // FIXME: handle lifetimes correctly, see rustc\n             let derefd_from_ty = TyKind::Ref(to_mt, lt, referent_ty).intern(Interner);\n-            match self.table.try_unify(&derefd_from_ty, to_ty) {\n+            match autoderef.table.try_unify(&derefd_from_ty, to_ty) {\n                 Ok(result) => {\n                     found = Some(result.map(|()| derefd_from_ty));\n                     break;\n@@ -325,6 +317,7 @@ impl<'a> InferenceContext<'a> {\n         let InferOk { value: ty, goals } = match found {\n             Some(d) => d,\n             None => {\n+                self.table.rollback_to(snapshot);\n                 let err = first_error.expect(\"coerce_borrowed_pointer had no error\");\n                 return Err(err);\n             }\n@@ -345,29 +338,13 @@ impl<'a> InferenceContext<'a> {\n             return success(vec![], ty, goals);\n         }\n \n-        let mut adjustments = self.auto_deref_adjust_steps(&autoderef);\n+        let mut adjustments = auto_deref_adjust_steps(&autoderef);\n         adjustments\n             .push(Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(to_mt)), target: ty.clone() });\n \n         success(adjustments, ty, goals)\n     }\n \n-    pub(super) fn auto_deref_adjust_steps(&self, autoderef: &Autoderef<'_>) -> Vec<Adjustment> {\n-        let steps = autoderef.steps();\n-        let targets =\n-            steps.iter().skip(1).map(|(_, ty)| ty.clone()).chain(iter::once(autoderef.final_ty()));\n-        steps\n-            .iter()\n-            .map(|(kind, _source)| match kind {\n-                // We do not know what kind of deref we require at this point yet\n-                AutoderefKind::Overloaded => Some(OverloadedDeref(Mutability::Not)),\n-                AutoderefKind::Builtin => None,\n-            })\n-            .zip(targets)\n-            .map(|(autoderef, target)| Adjustment { kind: Adjust::Deref(autoderef), target })\n-            .collect()\n-    }\n-\n     /// Attempts to coerce from the type of a Rust function item into a function pointer.\n     fn coerce_from_fn_item(&mut self, from_ty: Ty, to_ty: &Ty) -> CoerceResult {\n         match to_ty.kind(Interner) {\n@@ -620,3 +597,19 @@ fn coerce_mutabilities(from: Mutability, to: Mutability) -> Result<(), TypeError\n         (Mutability::Not, Mutability::Mut) => Err(TypeError),\n     }\n }\n+\n+pub(super) fn auto_deref_adjust_steps(autoderef: &Autoderef<'_, '_>) -> Vec<Adjustment> {\n+    let steps = autoderef.steps();\n+    let targets =\n+        steps.iter().skip(1).map(|(_, ty)| ty.clone()).chain(iter::once(autoderef.final_ty()));\n+    steps\n+        .iter()\n+        .map(|(kind, _source)| match kind {\n+            // We do not know what kind of deref we require at this point yet\n+            AutoderefKind::Overloaded => Some(OverloadedDeref(Mutability::Not)),\n+            AutoderefKind::Builtin => None,\n+        })\n+        .zip(targets)\n+        .map(|(autoderef, target)| Adjustment { kind: Adjust::Deref(autoderef), target })\n+        .collect()\n+}"}, {"sha": "c305af2e912679c35da94ddb51bc0a2de9b37e71", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 88, "deletions": 181, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=ab896e38e124676c4d0532b74f4d0d714b33b2f9", "patch": "@@ -1,6 +1,7 @@\n //! Type inference for expressions.\n \n use std::{\n+    collections::hash_map::Entry,\n     iter::{repeat, repeat_with},\n     mem,\n     sync::Arc,\n@@ -26,15 +27,14 @@ use crate::{\n     method_resolution,\n     primitive::{self, UintTy},\n     static_lifetime, to_chalk_trait_id,\n-    traits::FnTrait,\n     utils::{generics, Generics},\n-    AdtId, Binders, CallableDefId, FnPointer, FnSig, FnSubst, InEnvironment, Interner,\n-    ProjectionTyExt, Rawness, Scalar, Substitution, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n+    AdtId, Binders, CallableDefId, FnPointer, FnSig, FnSubst, Interner, Rawness, Scalar,\n+    Substitution, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n };\n \n use super::{\n-    find_breakable, BindingMode, BreakableContext, Diverges, Expectation, InferenceContext,\n-    InferenceDiagnostic, TypeMismatch,\n+    coerce::auto_deref_adjust_steps, find_breakable, BindingMode, BreakableContext, Diverges,\n+    Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -77,51 +77,6 @@ impl<'a> InferenceContext<'a> {\n         }\n     }\n \n-    fn callable_sig_from_fn_trait(&mut self, ty: &Ty, num_args: usize) -> Option<(Vec<Ty>, Ty)> {\n-        let krate = self.resolver.krate()?;\n-        let fn_once_trait = FnTrait::FnOnce.get_id(self.db, krate)?;\n-        let output_assoc_type =\n-            self.db.trait_data(fn_once_trait).associated_type_by_name(&name![Output])?;\n-\n-        let mut arg_tys = vec![];\n-        let arg_ty = TyBuilder::tuple(num_args)\n-            .fill(repeat_with(|| {\n-                let arg = self.table.new_type_var();\n-                arg_tys.push(arg.clone());\n-                arg\n-            }))\n-            .build();\n-\n-        let projection = {\n-            let b = TyBuilder::assoc_type_projection(self.db, output_assoc_type);\n-            if b.remaining() != 2 {\n-                return None;\n-            }\n-            b.push(ty.clone()).push(arg_ty).build()\n-        };\n-\n-        let trait_env = self.trait_env.env.clone();\n-        let obligation = InEnvironment {\n-            goal: projection.trait_ref(self.db).cast(Interner),\n-            environment: trait_env,\n-        };\n-        let canonical = self.canonicalize(obligation.clone());\n-        if self.db.trait_solve(krate, canonical.value.cast(Interner)).is_some() {\n-            self.push_obligation(obligation.goal);\n-            let return_ty = self.table.normalize_projection_ty(projection);\n-            Some((arg_tys, return_ty))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub(crate) fn callable_sig(&mut self, ty: &Ty, num_args: usize) -> Option<(Vec<Ty>, Ty)> {\n-        match ty.callable_sig(self.db) {\n-            Some(sig) => Some((sig.params().to_vec(), sig.ret().clone())),\n-            None => self.callable_sig_from_fn_trait(ty, num_args),\n-        }\n-    }\n-\n     fn infer_expr_inner(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n         self.db.unwind_if_cancelled();\n \n@@ -319,22 +274,19 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Call { callee, args } => {\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());\n-                let canonicalized = self.canonicalize(callee_ty.clone());\n-                let mut derefs = Autoderef::new(\n-                    self.db,\n-                    self.resolver.krate(),\n-                    InEnvironment {\n-                        goal: canonicalized.value.clone(),\n-                        environment: self.table.trait_env.env.clone(),\n-                    },\n-                );\n-                let res = derefs.by_ref().find_map(|(callee_deref_ty, _)| {\n-                    let ty = &canonicalized.decanonicalize_ty(&mut self.table, callee_deref_ty);\n-                    self.callable_sig(ty, args.len())\n-                });\n+                let mut derefs = Autoderef::new(&mut self.table, callee_ty.clone());\n+                let mut res = None;\n+                // manual loop to be able to access `derefs.table`\n+                while let Some((callee_deref_ty, _)) = derefs.next() {\n+                    res = derefs.table.callable_sig(&callee_deref_ty, args.len());\n+                    if res.is_some() {\n+                        break;\n+                    }\n+                }\n                 let (param_tys, ret_ty): (Vec<Ty>, Ty) = match res {\n                     Some(res) => {\n-                        self.write_expr_adj(*callee, self.auto_deref_adjust_steps(&derefs));\n+                        let adjustments = auto_deref_adjust_steps(&derefs);\n+                        self.write_expr_adj(*callee, adjustments);\n                         res\n                     }\n                     None => (Vec::new(), self.err_ty()),\n@@ -489,88 +441,67 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Field { expr, name } => {\n                 let receiver_ty = self.infer_expr_inner(*expr, &Expectation::none());\n-                let canonicalized = self.canonicalize(receiver_ty);\n-\n-                let mut autoderef = Autoderef::new(\n-                    self.db,\n-                    self.resolver.krate(),\n-                    InEnvironment {\n-                        goal: canonicalized.value.clone(),\n-                        environment: self.trait_env.env.clone(),\n-                    },\n-                );\n+\n+                let mut autoderef = Autoderef::new(&mut self.table, receiver_ty);\n                 let ty = autoderef.by_ref().find_map(|(derefed_ty, _)| {\n-                    let module = self.resolver.module();\n-                    let db = self.db;\n-                    let is_visible = |field_id: &FieldId| {\n-                        module\n-                            .map(|mod_id| {\n-                                db.field_visibilities(field_id.parent)[field_id.local_id]\n-                                    .is_visible_from(db.upcast(), mod_id)\n-                            })\n-                            .unwrap_or(true)\n-                    };\n-                    match canonicalized\n-                        .decanonicalize_ty(&mut self.table, derefed_ty)\n-                        .kind(Interner)\n-                    {\n-                        TyKind::Tuple(_, substs) => name.as_tuple_index().and_then(|idx| {\n-                            substs\n-                                .as_slice(Interner)\n-                                .get(idx)\n-                                .map(|a| a.assert_ty_ref(Interner))\n-                                .cloned()\n-                        }),\n+                    let (field_id, parameters) = match derefed_ty.kind(Interner) {\n+                        TyKind::Tuple(_, substs) => {\n+                            return name.as_tuple_index().and_then(|idx| {\n+                                substs\n+                                    .as_slice(Interner)\n+                                    .get(idx)\n+                                    .map(|a| a.assert_ty_ref(Interner))\n+                                    .cloned()\n+                            });\n+                        }\n                         TyKind::Adt(AdtId(hir_def::AdtId::StructId(s)), parameters) => {\n                             let local_id = self.db.struct_data(*s).variant_data.field(name)?;\n                             let field = FieldId { parent: (*s).into(), local_id };\n-                            if is_visible(&field) {\n-                                self.write_field_resolution(tgt_expr, field);\n-                                Some(\n-                                    self.db.field_types((*s).into())[field.local_id]\n-                                        .clone()\n-                                        .substitute(Interner, &parameters),\n-                                )\n-                            } else {\n-                                // Write down the first field resolution even if it is not visible\n-                                // This aids IDE features for private fields like goto def and in\n-                                // case of autoderef finding an applicable field, this will be\n-                                // overwritten in a following cycle\n-                                self.write_field_resolution_if_empty(tgt_expr, field);\n-                                None\n-                            }\n+                            (field, parameters.clone())\n                         }\n                         TyKind::Adt(AdtId(hir_def::AdtId::UnionId(u)), parameters) => {\n                             let local_id = self.db.union_data(*u).variant_data.field(name)?;\n                             let field = FieldId { parent: (*u).into(), local_id };\n-                            if is_visible(&field) {\n-                                self.write_field_resolution(tgt_expr, field);\n-                                Some(\n-                                    self.db.field_types((*u).into())[field.local_id]\n-                                        .clone()\n-                                        .substitute(Interner, &parameters),\n-                                )\n-                            } else {\n-                                // Write down the first field resolution even if it is not visible\n-                                // This aids IDE features for private fields like goto def and in\n-                                // case of autoderef finding an applicable field, this will be\n-                                // overwritten in a following cycle\n-                                self.write_field_resolution_if_empty(tgt_expr, field);\n-                                None\n-                            }\n+                            (field, parameters.clone())\n                         }\n-                        _ => None,\n+                        _ => return None,\n+                    };\n+                    let module = self.resolver.module();\n+                    let is_visible = module\n+                        .map(|mod_id| {\n+                            self.db.field_visibilities(field_id.parent)[field_id.local_id]\n+                                .is_visible_from(self.db.upcast(), mod_id)\n+                        })\n+                        .unwrap_or(true);\n+                    if !is_visible {\n+                        // Write down the first field resolution even if it is not visible\n+                        // This aids IDE features for private fields like goto def and in\n+                        // case of autoderef finding an applicable field, this will be\n+                        // overwritten in a following cycle\n+                        if let Entry::Vacant(entry) = self.result.field_resolutions.entry(tgt_expr)\n+                        {\n+                            entry.insert(field_id);\n+                        }\n+                        return None;\n                     }\n+                    // can't have `write_field_resolution` here because `self.table` is borrowed :(\n+                    self.result.field_resolutions.insert(tgt_expr, field_id);\n+                    let ty = self.db.field_types(field_id.parent)[field_id.local_id]\n+                        .clone()\n+                        .substitute(Interner, &parameters);\n+                    Some(ty)\n                 });\n                 let ty = match ty {\n                     Some(ty) => {\n-                        self.write_expr_adj(*expr, self.auto_deref_adjust_steps(&autoderef));\n+                        let adjustments = auto_deref_adjust_steps(&autoderef);\n+                        self.write_expr_adj(*expr, adjustments);\n+                        let ty = self.insert_type_vars(ty);\n+                        let ty = self.normalize_associated_types_in(ty);\n                         ty\n                     }\n-                    None => self.err_ty(),\n+                    _ => self.err_ty(),\n                 };\n-                let ty = self.insert_type_vars(ty);\n-                self.normalize_associated_types_in(ty)\n+                ty\n             }\n             Expr::Await { expr } => {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n@@ -628,25 +559,9 @@ impl<'a> InferenceContext<'a> {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 let inner_ty = self.resolve_ty_shallow(&inner_ty);\n                 match op {\n-                    UnaryOp::Deref => match self.resolver.krate() {\n-                        Some(krate) => {\n-                            let canonicalized = self.canonicalize(inner_ty);\n-                            match autoderef::deref(\n-                                self.db,\n-                                krate,\n-                                InEnvironment {\n-                                    goal: &canonicalized.value,\n-                                    environment: self.trait_env.env.clone(),\n-                                },\n-                            ) {\n-                                Some(derefed_ty) => {\n-                                    canonicalized.decanonicalize_ty(&mut self.table, derefed_ty)\n-                                }\n-                                None => self.err_ty(),\n-                            }\n-                        }\n-                        None => self.err_ty(),\n-                    },\n+                    UnaryOp::Deref => {\n+                        autoderef::deref(&mut self.table, inner_ty).unwrap_or_else(|| self.err_ty())\n+                    }\n                     UnaryOp::Neg => {\n                         match inner_ty.kind(Interner) {\n                             // Fast path for builtins\n@@ -732,20 +647,19 @@ impl<'a> InferenceContext<'a> {\n                 let base_ty = self.infer_expr_inner(*base, &Expectation::none());\n                 let index_ty = self.infer_expr(*index, &Expectation::none());\n \n-                if let (Some(index_trait), Some(krate)) =\n-                    (self.resolve_ops_index(), self.resolver.krate())\n-                {\n-                    let canonicalized = self.canonicalize(base_ty);\n-                    let self_ty = method_resolution::resolve_indexing_op(\n+                if let Some(index_trait) = self.resolve_ops_index() {\n+                    let canonicalized = self.canonicalize(base_ty.clone());\n+                    let receiver_adjustments = method_resolution::resolve_indexing_op(\n                         self.db,\n-                        &canonicalized.value,\n                         self.trait_env.clone(),\n-                        krate,\n+                        canonicalized.value,\n                         index_trait,\n                     );\n-                    let self_ty = self_ty.map_or(self.err_ty(), |t| {\n-                        canonicalized.decanonicalize_ty(&mut self.table, t)\n-                    });\n+                    let (self_ty, adj) = receiver_adjustments\n+                        .map_or((self.err_ty(), Vec::new()), |adj| {\n+                            adj.apply(&mut self.table, base_ty)\n+                        });\n+                    self.write_expr_adj(*base, adj);\n                     self.resolve_associated_type_with_params(\n                         self_ty,\n                         self.resolve_ops_index_output(),\n@@ -992,22 +906,20 @@ impl<'a> InferenceContext<'a> {\n \n         let traits_in_scope = self.resolver.traits_in_scope(self.db.upcast());\n \n-        let resolved = self.resolver.krate().and_then(|krate| {\n-            method_resolution::lookup_method(\n-                &canonicalized_receiver.value,\n-                self.db,\n-                self.trait_env.clone(),\n-                krate,\n-                &traits_in_scope,\n-                self.resolver.module().into(),\n-                method_name,\n-            )\n-        });\n+        let resolved = method_resolution::lookup_method(\n+            &canonicalized_receiver.value,\n+            self.db,\n+            self.trait_env.clone(),\n+            &traits_in_scope,\n+            self.resolver.module().into(),\n+            method_name,\n+        );\n         let (receiver_ty, method_ty, substs) = match resolved {\n-            Some((ty, func)) => {\n-                let ty = canonicalized_receiver.decanonicalize_ty(&mut self.table, ty);\n+            Some((adjust, func)) => {\n+                let (ty, adjustments) = adjust.apply(&mut self.table, receiver_ty);\n                 let generics = generics(self.db.upcast(), func.into());\n-                let substs = self.substs_for_method_call(generics, generic_args, &ty);\n+                let substs = self.substs_for_method_call(generics, generic_args);\n+                self.write_expr_adj(receiver, adjustments);\n                 self.write_method_resolution(tgt_expr, func, substs.clone());\n                 (ty, self.db.value_ty(func.into()), substs)\n             }\n@@ -1120,20 +1032,15 @@ impl<'a> InferenceContext<'a> {\n         &mut self,\n         def_generics: Generics,\n         generic_args: Option<&GenericArgs>,\n-        receiver_ty: &Ty,\n     ) -> Substitution {\n         let (parent_params, self_params, type_params, impl_trait_params) =\n             def_generics.provenance_split();\n         assert_eq!(self_params, 0); // method shouldn't have another Self param\n         let total_len = parent_params + type_params + impl_trait_params;\n         let mut substs = Vec::with_capacity(total_len);\n-        // Parent arguments are unknown, except for the receiver type\n-        for (_id, param) in def_generics.iter_parent() {\n-            if param.provenance == hir_def::generics::TypeParamProvenance::TraitSelf {\n-                substs.push(receiver_ty.clone());\n-            } else {\n-                substs.push(self.table.new_type_var());\n-            }\n+        // Parent arguments are unknown\n+        for _ in def_generics.iter_parent() {\n+            substs.push(self.table.new_type_var());\n         }\n         // handle provided type arguments\n         if let Some(generic_args) = generic_args {"}, {"sha": "0d6c8f12d24f1c83a13e758cbbe6c71d208ada19", "filename": "crates/hir_ty/src/infer/path.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=ab896e38e124676c4d0532b74f4d0d714b33b2f9", "patch": "@@ -218,14 +218,12 @@ impl<'a> InferenceContext<'a> {\n         }\n \n         let canonical_ty = self.canonicalize(ty.clone());\n-        let krate = self.resolver.krate()?;\n         let traits_in_scope = self.resolver.traits_in_scope(self.db.upcast());\n \n         method_resolution::iterate_method_candidates(\n             &canonical_ty.value,\n             self.db,\n             self.table.trait_env.clone(),\n-            krate,\n             &traits_in_scope,\n             self.resolver.module().into(),\n             Some(name),"}, {"sha": "21b48b9d80256f8447dba1a3ef5f60e9c53342ba", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 77, "deletions": 21, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=ab896e38e124676c4d0532b74f4d0d714b33b2f9", "patch": "@@ -1,19 +1,21 @@\n //! Unification and canonicalization logic.\n \n-use std::{fmt, mem, sync::Arc};\n+use std::{fmt, iter, mem, sync::Arc};\n \n use chalk_ir::{\n     cast::Cast, fold::Fold, interner::HasInterner, zip::Zip, FloatTy, IntTy, NoSolution,\n     TyVariableKind, UniverseIndex,\n };\n use chalk_solve::infer::ParameterEnaVariableExt;\n use ena::unify::UnifyKey;\n+use hir_expand::name;\n \n use super::{InferOk, InferResult, InferenceContext, TypeError};\n use crate::{\n-    db::HirDatabase, fold_tys, static_lifetime, AliasEq, AliasTy, BoundVar, Canonical, Const,\n-    DebruijnIndex, GenericArg, Goal, Guidance, InEnvironment, InferenceVar, Interner, Lifetime,\n-    ProjectionTy, Scalar, Solution, Substitution, TraitEnvironment, Ty, TyKind, VariableKind,\n+    db::HirDatabase, fold_tys, static_lifetime, traits::FnTrait, AliasEq, AliasTy, BoundVar,\n+    Canonical, Const, DebruijnIndex, GenericArg, Goal, Guidance, InEnvironment, InferenceVar,\n+    Interner, Lifetime, ProjectionTy, ProjectionTyExt, Scalar, Solution, Substitution,\n+    TraitEnvironment, Ty, TyBuilder, TyExt, TyKind, VariableKind,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -24,32 +26,20 @@ impl<'a> InferenceContext<'a> {\n     where\n         T::Result: HasInterner<Interner = Interner>,\n     {\n-        // try to resolve obligations before canonicalizing, since this might\n-        // result in new knowledge about variables\n-        self.resolve_obligations_as_possible();\n         self.table.canonicalize(t)\n     }\n }\n \n #[derive(Debug, Clone)]\n-pub(super) struct Canonicalized<T>\n+pub(crate) struct Canonicalized<T>\n where\n     T: HasInterner<Interner = Interner>,\n {\n-    pub(super) value: Canonical<T>,\n+    pub(crate) value: Canonical<T>,\n     free_vars: Vec<GenericArg>,\n }\n \n impl<T: HasInterner<Interner = Interner>> Canonicalized<T> {\n-    /// this method is wrong and shouldn't exist\n-    pub(super) fn decanonicalize_ty(&self, table: &mut InferenceTable, ty: Canonical<Ty>) -> Ty {\n-        let mut vars = self.free_vars.clone();\n-        while ty.binders.len(Interner) > vars.len() {\n-            vars.push(table.new_type_var().cast(Interner));\n-        }\n-        chalk_ir::Substitute::apply(&vars, ty.value, Interner)\n-    }\n-\n     pub(super) fn apply_solution(\n         &self,\n         ctx: &mut InferenceTable,\n@@ -203,13 +193,16 @@ impl<'a> InferenceTable<'a> {\n         .intern(Interner)\n     }\n \n-    pub(super) fn canonicalize<T: Fold<Interner> + HasInterner<Interner = Interner>>(\n+    pub(crate) fn canonicalize<T: Fold<Interner> + HasInterner<Interner = Interner>>(\n         &mut self,\n         t: T,\n     ) -> Canonicalized<T::Result>\n     where\n         T::Result: HasInterner<Interner = Interner>,\n     {\n+        // try to resolve obligations before canonicalizing, since this might\n+        // result in new knowledge about variables\n+        self.resolve_obligations_as_possible();\n         let result = self.var_unification_table.canonicalize(Interner, t);\n         let free_vars = result\n             .free_vars\n@@ -225,7 +218,7 @@ impl<'a> InferenceTable<'a> {\n     /// type annotation (e.g. from a let type annotation, field type or function\n     /// call). `make_ty` handles this already, but e.g. for field types we need\n     /// to do it as well.\n-    pub(super) fn normalize_associated_types_in(&mut self, ty: Ty) -> Ty {\n+    pub(crate) fn normalize_associated_types_in(&mut self, ty: Ty) -> Ty {\n         fold_tys(\n             ty,\n             |ty, _| match ty.kind(Interner) {\n@@ -238,7 +231,7 @@ impl<'a> InferenceTable<'a> {\n         )\n     }\n \n-    pub(super) fn normalize_projection_ty(&mut self, proj_ty: ProjectionTy) -> Ty {\n+    pub(crate) fn normalize_projection_ty(&mut self, proj_ty: ProjectionTy) -> Ty {\n         let var = self.new_type_var();\n         let alias_eq = AliasEq { alias: AliasTy::Projection(proj_ty), ty: var.clone() };\n         let obligation = alias_eq.cast(Interner);\n@@ -299,6 +292,13 @@ impl<'a> InferenceTable<'a> {\n         self.resolve_with_fallback_inner(&mut Vec::new(), t, &fallback)\n     }\n \n+    pub(crate) fn instantiate_canonical<T>(&mut self, canonical: Canonical<T>) -> T::Result\n+    where\n+        T: HasInterner<Interner = Interner> + Fold<Interner> + std::fmt::Debug,\n+    {\n+        self.var_unification_table.instantiate_canonical(Interner, canonical)\n+    }\n+\n     fn resolve_with_fallback_inner<T>(\n         &mut self,\n         var_stack: &mut Vec<InferenceVar>,\n@@ -351,6 +351,7 @@ impl<'a> InferenceTable<'a> {\n     /// If `ty` is a type variable with known type, returns that type;\n     /// otherwise, return ty.\n     pub(crate) fn resolve_ty_shallow(&mut self, ty: &Ty) -> Ty {\n+        self.resolve_obligations_as_possible();\n         self.var_unification_table.normalize_ty_shallow(Interner, ty).unwrap_or_else(|| ty.clone())\n     }\n \n@@ -363,6 +364,16 @@ impl<'a> InferenceTable<'a> {\n         self.var_unification_table.rollback_to(snapshot.var_table_snapshot);\n     }\n \n+    /// Checks an obligation without registering it. Useful mostly to check\n+    /// whether a trait *might* be implemented before deciding to 'lock in' the\n+    /// choice (during e.g. method resolution or deref).\n+    pub(crate) fn try_obligation(&mut self, goal: Goal) -> Option<Solution> {\n+        let in_env = InEnvironment::new(&self.trait_env.env, goal);\n+        let canonicalized = self.canonicalize(in_env);\n+        let solution = self.db.trait_solve(self.trait_env.krate, canonicalized.value);\n+        solution\n+    }\n+\n     pub(crate) fn register_obligation(&mut self, goal: Goal) {\n         let in_env = InEnvironment::new(&self.trait_env.env, goal);\n         self.register_obligation_in_env(in_env)\n@@ -522,6 +533,51 @@ impl<'a> InferenceTable<'a> {\n             }\n         }\n     }\n+\n+    pub(crate) fn callable_sig(&mut self, ty: &Ty, num_args: usize) -> Option<(Vec<Ty>, Ty)> {\n+        match ty.callable_sig(self.db) {\n+            Some(sig) => Some((sig.params().to_vec(), sig.ret().clone())),\n+            None => self.callable_sig_from_fn_trait(ty, num_args),\n+        }\n+    }\n+\n+    fn callable_sig_from_fn_trait(&mut self, ty: &Ty, num_args: usize) -> Option<(Vec<Ty>, Ty)> {\n+        let krate = self.trait_env.krate;\n+        let fn_once_trait = FnTrait::FnOnce.get_id(self.db, krate)?;\n+        let output_assoc_type =\n+            self.db.trait_data(fn_once_trait).associated_type_by_name(&name![Output])?;\n+\n+        let mut arg_tys = vec![];\n+        let arg_ty = TyBuilder::tuple(num_args)\n+            .fill(iter::repeat_with(|| {\n+                let arg = self.new_type_var();\n+                arg_tys.push(arg.clone());\n+                arg\n+            }))\n+            .build();\n+\n+        let projection = {\n+            let b = TyBuilder::assoc_type_projection(self.db, output_assoc_type);\n+            if b.remaining() != 2 {\n+                return None;\n+            }\n+            b.push(ty.clone()).push(arg_ty).build()\n+        };\n+\n+        let trait_env = self.trait_env.env.clone();\n+        let obligation = InEnvironment {\n+            goal: projection.trait_ref(self.db).cast(Interner),\n+            environment: trait_env,\n+        };\n+        let canonical = self.canonicalize(obligation.clone());\n+        if self.db.trait_solve(krate, canonical.value.cast(Interner)).is_some() {\n+            self.register_obligation(obligation.goal);\n+            let return_ty = self.normalize_projection_ty(projection);\n+            Some((arg_tys, return_ty))\n+        } else {\n+            None\n+        }\n+    }\n }\n \n impl<'a> fmt::Debug for InferenceTable<'a> {"}, {"sha": "44ece57a8e0e74142df94770fd828a1bfa6fd7bf", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 187, "deletions": 96, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=ab896e38e124676c4d0532b74f4d0d714b33b2f9", "patch": "@@ -17,10 +17,11 @@ use rustc_hash::{FxHashMap, FxHashSet};\n use stdx::never;\n \n use crate::{\n-    autoderef,\n+    autoderef::{self, AutoderefKind},\n     consteval::{self, ConstExt},\n     db::HirDatabase,\n     from_foreign_def_id,\n+    infer::{unify::InferenceTable, Adjust, Adjustment, AutoBorrow, OverloadedDeref, PointerCast},\n     primitive::{self, FloatTy, IntTy, UintTy},\n     static_lifetime,\n     utils::all_super_traits,\n@@ -429,28 +430,25 @@ pub fn def_crates(\n     Some(res)\n }\n \n-/// Look up the method with the given name, returning the actual autoderefed\n-/// receiver type (but without autoref applied yet).\n+/// Look up the method with the given name.\n pub(crate) fn lookup_method(\n     ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n-    krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n     visible_from_module: VisibleFromModule,\n     name: &Name,\n-) -> Option<(Canonical<Ty>, FunctionId)> {\n+) -> Option<(ReceiverAdjustments, FunctionId)> {\n     iterate_method_candidates(\n         ty,\n         db,\n         env,\n-        krate,\n         traits_in_scope,\n         visible_from_module,\n         Some(name),\n         LookupMode::MethodCall,\n-        |ty, f| match f {\n-            AssocItemId::FunctionId(f) => Some((ty.clone(), f)),\n+        |adjustments, f| match f {\n+            AssocItemId::FunctionId(f) => Some((adjustments, f)),\n             _ => None,\n         },\n     )\n@@ -496,33 +494,89 @@ impl From<Option<BlockId>> for VisibleFromModule {\n     }\n }\n \n+#[derive(Debug, Clone, Default)]\n+pub struct ReceiverAdjustments {\n+    autoref: Option<Mutability>,\n+    autoderefs: usize,\n+    unsize_array: bool,\n+}\n+\n+impl ReceiverAdjustments {\n+    pub(crate) fn apply(&self, table: &mut InferenceTable, ty: Ty) -> (Ty, Vec<Adjustment>) {\n+        let mut ty = ty;\n+        let mut adjust = Vec::new();\n+        for _ in 0..self.autoderefs {\n+            match autoderef::autoderef_step(table, ty.clone()) {\n+                None => {\n+                    never!(\"autoderef not possible for {:?}\", ty);\n+                    ty = TyKind::Error.intern(Interner);\n+                    break;\n+                }\n+                Some((kind, new_ty)) => {\n+                    ty = new_ty.clone();\n+                    adjust.push(Adjustment {\n+                        kind: Adjust::Deref(match kind {\n+                            // FIXME should we know the mutability here?\n+                            AutoderefKind::Overloaded => Some(OverloadedDeref(Mutability::Not)),\n+                            AutoderefKind::Builtin => None,\n+                        }),\n+                        target: new_ty,\n+                    });\n+                }\n+            }\n+        }\n+        if self.unsize_array {\n+            ty = match ty.kind(Interner) {\n+                TyKind::Array(inner, _) => TyKind::Slice(inner.clone()).intern(Interner),\n+                _ => {\n+                    never!(\"unsize_array with non-array {:?}\", ty);\n+                    ty\n+                }\n+            };\n+            // FIXME this is kind of wrong since the unsize needs to happen to a pointer/reference\n+            adjust.push(Adjustment {\n+                kind: Adjust::Pointer(PointerCast::Unsize),\n+                target: ty.clone(),\n+            });\n+        }\n+        if let Some(m) = self.autoref {\n+            ty = TyKind::Ref(m, static_lifetime(), ty).intern(Interner);\n+            adjust\n+                .push(Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(m)), target: ty.clone() });\n+        }\n+        (ty, adjust)\n+    }\n+\n+    fn with_autoref(&self, m: Mutability) -> ReceiverAdjustments {\n+        Self { autoref: Some(m), ..*self }\n+    }\n+}\n+\n // This would be nicer if it just returned an iterator, but that runs into\n // lifetime problems, because we need to borrow temp `CrateImplDefs`.\n // FIXME add a context type here?\n-pub fn iterate_method_candidates<T>(\n+pub(crate) fn iterate_method_candidates<T>(\n     ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n-    krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n     visible_from_module: VisibleFromModule,\n     name: Option<&Name>,\n     mode: LookupMode,\n-    mut callback: impl FnMut(&Canonical<Ty>, AssocItemId) -> Option<T>,\n+    mut callback: impl FnMut(ReceiverAdjustments, AssocItemId) -> Option<T>,\n ) -> Option<T> {\n     let mut slot = None;\n     iterate_method_candidates_dyn(\n         ty,\n         db,\n         env,\n-        krate,\n         traits_in_scope,\n         visible_from_module,\n         name,\n         mode,\n-        &mut |ty, item| {\n+        &mut |adj, item| {\n             assert!(slot.is_none());\n-            if let Some(it) = callback(ty, item) {\n+            if let Some(it) = callback(adj, item) {\n                 slot = Some(it);\n                 return ControlFlow::Break(());\n             }\n@@ -532,28 +586,45 @@ pub fn iterate_method_candidates<T>(\n     slot\n }\n \n+pub fn iterate_path_candidates(\n+    ty: &Canonical<Ty>,\n+    db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n+    traits_in_scope: &FxHashSet<TraitId>,\n+    visible_from_module: VisibleFromModule,\n+    name: Option<&Name>,\n+    callback: &mut dyn FnMut(AssocItemId) -> ControlFlow<()>,\n+) -> ControlFlow<()> {\n+    iterate_method_candidates_dyn(\n+        ty,\n+        db,\n+        env,\n+        traits_in_scope,\n+        visible_from_module,\n+        name,\n+        LookupMode::Path,\n+        // the adjustments are not relevant for path lookup\n+        &mut |_, id| callback(id),\n+    )\n+}\n+\n pub fn iterate_method_candidates_dyn(\n     ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n-    krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n     visible_from_module: VisibleFromModule,\n     name: Option<&Name>,\n     mode: LookupMode,\n-    callback: &mut dyn FnMut(&Canonical<Ty>, AssocItemId) -> ControlFlow<()>,\n+    callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n     match mode {\n         LookupMode::MethodCall => {\n-            // For method calls, rust first does any number of autoderef, and then one\n-            // autoref (i.e. when the method takes &self or &mut self). We just ignore\n-            // the autoref currently -- when we find a method matching the given name,\n-            // we assume it fits.\n-\n-            // Also note that when we've got a receiver like &S, even if the method we\n-            // find in the end takes &self, we still do the autoderef step (just as\n-            // rustc does an autoderef and then autoref again).\n-            let ty = InEnvironment { goal: ty.clone(), environment: env.env.clone() };\n+            // For method calls, rust first does any number of autoderef, and\n+            // then one autoref (i.e. when the method takes &self or &mut self).\n+            // Note that when we've got a receiver like &S, even if the method\n+            // we find in the end takes &self, we still do the autoderef step\n+            // (just as rustc does an autoderef and then autoref again).\n \n             // We have to be careful about the order we're looking at candidates\n             // in here. Consider the case where we're resolving `x.clone()`\n@@ -568,29 +639,31 @@ pub fn iterate_method_candidates_dyn(\n             // the methods by autoderef order of *receiver types*, not *self\n             // types*.\n \n-            let deref_chain = autoderef_method_receiver(db, krate, ty);\n-            let mut deref_chains = stdx::slice_tails(&deref_chain);\n+            let mut table = InferenceTable::new(db, env.clone());\n+            let ty = table.instantiate_canonical(ty.clone());\n+            let (deref_chain, adj) = autoderef_method_receiver(&mut table, ty);\n+            let deref_chains = stdx::slice_tails(&deref_chain);\n \n-            deref_chains.try_for_each(|deref_chain| {\n+            let result = deref_chains.zip(adj).try_for_each(|(deref_chain, adj)| {\n                 iterate_method_candidates_with_autoref(\n                     deref_chain,\n+                    adj,\n                     db,\n                     env.clone(),\n-                    krate,\n                     traits_in_scope,\n                     visible_from_module,\n                     name,\n                     callback,\n                 )\n-            })\n+            });\n+            result\n         }\n         LookupMode::Path => {\n             // No autoderef for path lookups\n             iterate_method_candidates_for_self_ty(\n                 ty,\n                 db,\n-                env,\n-                krate,\n+                env.clone(),\n                 traits_in_scope,\n                 visible_from_module,\n                 name,\n@@ -602,62 +675,63 @@ pub fn iterate_method_candidates_dyn(\n \n fn iterate_method_candidates_with_autoref(\n     deref_chain: &[Canonical<Ty>],\n+    first_adjustment: ReceiverAdjustments,\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n-    krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n     visible_from_module: VisibleFromModule,\n     name: Option<&Name>,\n-    mut callback: &mut dyn FnMut(&Canonical<Ty>, AssocItemId) -> ControlFlow<()>,\n+    mut callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n     let (receiver_ty, rest) = match deref_chain.split_first() {\n-        Some((rec, rest)) => (rec.clone(), rest),\n+        Some((rec, rest)) => (rec, rest),\n         None => {\n             never!(\"received empty deref-chain\");\n             return ControlFlow::Break(());\n         }\n     };\n     iterate_method_candidates_by_receiver(\n-        &receiver_ty,\n+        receiver_ty,\n+        first_adjustment.clone(),\n         &rest,\n         db,\n         env.clone(),\n-        krate,\n         traits_in_scope,\n         visible_from_module,\n         name,\n         &mut callback,\n     )?;\n \n     let refed = Canonical {\n-        binders: receiver_ty.binders.clone(),\n         value: TyKind::Ref(Mutability::Not, static_lifetime(), receiver_ty.value.clone())\n             .intern(Interner),\n+        binders: receiver_ty.binders.clone(),\n     };\n \n     iterate_method_candidates_by_receiver(\n         &refed,\n+        first_adjustment.with_autoref(Mutability::Not),\n         deref_chain,\n         db,\n         env.clone(),\n-        krate,\n         traits_in_scope,\n         visible_from_module,\n         name,\n         &mut callback,\n     )?;\n \n     let ref_muted = Canonical {\n-        binders: receiver_ty.binders,\n-        value: TyKind::Ref(Mutability::Mut, static_lifetime(), receiver_ty.value).intern(Interner),\n+        value: TyKind::Ref(Mutability::Mut, static_lifetime(), receiver_ty.value.clone())\n+            .intern(Interner),\n+        binders: receiver_ty.binders.clone(),\n     };\n \n     iterate_method_candidates_by_receiver(\n         &ref_muted,\n+        first_adjustment.with_autoref(Mutability::Mut),\n         deref_chain,\n         db,\n-        env,\n-        krate,\n+        env.clone(),\n         traits_in_scope,\n         visible_from_module,\n         name,\n@@ -667,14 +741,14 @@ fn iterate_method_candidates_with_autoref(\n \n fn iterate_method_candidates_by_receiver(\n     receiver_ty: &Canonical<Ty>,\n+    receiver_adjustments: ReceiverAdjustments,\n     rest_of_deref_chain: &[Canonical<Ty>],\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n-    krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n     visible_from_module: VisibleFromModule,\n     name: Option<&Name>,\n-    mut callback: &mut dyn FnMut(&Canonical<Ty>, AssocItemId) -> ControlFlow<()>,\n+    mut callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n     // We're looking for methods with *receiver* type receiver_ty. These could\n     // be found in any of the derefs of receiver_ty, so we have to go through\n@@ -686,7 +760,7 @@ fn iterate_method_candidates_by_receiver(\n             env.clone(),\n             name,\n             Some(receiver_ty),\n-            krate,\n+            Some(receiver_adjustments.clone()),\n             visible_from_module,\n             &mut callback,\n         )?\n@@ -697,10 +771,10 @@ fn iterate_method_candidates_by_receiver(\n             self_ty,\n             db,\n             env.clone(),\n-            krate,\n             traits_in_scope,\n             name,\n             Some(receiver_ty),\n+            Some(receiver_adjustments.clone()),\n             &mut callback,\n         )?\n     }\n@@ -712,36 +786,35 @@ fn iterate_method_candidates_for_self_ty(\n     self_ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n-    krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n     visible_from_module: VisibleFromModule,\n     name: Option<&Name>,\n-    mut callback: &mut dyn FnMut(&Canonical<Ty>, AssocItemId) -> ControlFlow<()>,\n+    mut callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n     iterate_inherent_methods(\n         self_ty,\n         db,\n         env.clone(),\n         name,\n         None,\n-        krate,\n+        None,\n         visible_from_module,\n         &mut callback,\n     )?;\n-    iterate_trait_method_candidates(self_ty, db, env, krate, traits_in_scope, name, None, callback)\n+    iterate_trait_method_candidates(self_ty, db, env, traits_in_scope, name, None, None, callback)\n }\n \n fn iterate_trait_method_candidates(\n     self_ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n-    krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n     name: Option<&Name>,\n     receiver_ty: Option<&Canonical<Ty>>,\n-    callback: &mut dyn FnMut(&Canonical<Ty>, AssocItemId) -> ControlFlow<()>,\n+    receiver_adjustments: Option<ReceiverAdjustments>,\n+    callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n-    let receiver_is_array = matches!(self_ty.value.kind(Interner), chalk_ir::TyKind::Array(..));\n+    let self_is_array = matches!(self_ty.value.kind(Interner), chalk_ir::TyKind::Array(..));\n     // if ty is `dyn Trait`, the trait doesn't need to be in scope\n     let inherent_trait =\n         self_ty.value.dyn_trait().into_iter().flat_map(|t| all_super_traits(db.upcast(), t));\n@@ -763,10 +836,10 @@ fn iterate_trait_method_candidates(\n         // 2021.\n         // This is to make `[a].into_iter()` not break code with the new `IntoIterator` impl for\n         // arrays.\n-        if data.skip_array_during_method_dispatch && receiver_is_array {\n+        if data.skip_array_during_method_dispatch && self_is_array {\n             // FIXME: this should really be using the edition of the method name's span, in case it\n             // comes from a macro\n-            if db.crate_graph()[krate].edition < Edition::Edition2021 {\n+            if db.crate_graph()[env.krate].edition < Edition::Edition2021 {\n                 continue;\n             }\n         }\n@@ -782,14 +855,13 @@ fn iterate_trait_method_candidates(\n                 continue;\n             }\n             if !known_implemented {\n-                let goal = generic_implements_goal(db, env.clone(), t, self_ty.clone());\n-                if db.trait_solve(krate, goal.cast(Interner)).is_none() {\n+                let goal = generic_implements_goal(db, env.clone(), t, self_ty);\n+                if db.trait_solve(env.krate, goal.cast(Interner)).is_none() {\n                     continue 'traits;\n                 }\n             }\n             known_implemented = true;\n-            // FIXME: we shouldn't be ignoring the binders here\n-            callback(self_ty, item)?\n+            callback(receiver_adjustments.clone().unwrap_or_default(), item)?;\n         }\n     }\n     ControlFlow::Continue(())\n@@ -824,11 +896,11 @@ fn iterate_inherent_methods(\n     env: Arc<TraitEnvironment>,\n     name: Option<&Name>,\n     receiver_ty: Option<&Canonical<Ty>>,\n-    krate: CrateId,\n+    receiver_adjustments: Option<ReceiverAdjustments>,\n     visible_from_module: VisibleFromModule,\n-    callback: &mut dyn FnMut(&Canonical<Ty>, AssocItemId) -> ControlFlow<()>,\n+    callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n-    let def_crates = match def_crates(db, &self_ty.value, krate) {\n+    let def_crates = match def_crates(db, &self_ty.value, env.krate) {\n         Some(k) => k,\n         None => return ControlFlow::Continue(()),\n     };\n@@ -848,6 +920,7 @@ fn iterate_inherent_methods(\n                 env.clone(),\n                 name,\n                 receiver_ty,\n+                receiver_adjustments.clone(),\n                 module,\n                 callback,\n             )?;\n@@ -856,7 +929,17 @@ fn iterate_inherent_methods(\n \n     for krate in def_crates {\n         let impls = db.inherent_impls_in_crate(krate);\n-        impls_for_self_ty(&impls, self_ty, db, env.clone(), name, receiver_ty, module, callback)?;\n+        impls_for_self_ty(\n+            &impls,\n+            self_ty,\n+            db,\n+            env.clone(),\n+            name,\n+            receiver_ty,\n+            receiver_adjustments.clone(),\n+            module,\n+            callback,\n+        )?;\n     }\n     return ControlFlow::Continue(());\n \n@@ -867,8 +950,9 @@ fn iterate_inherent_methods(\n         env: Arc<TraitEnvironment>,\n         name: Option<&Name>,\n         receiver_ty: Option<&Canonical<Ty>>,\n+        receiver_adjustments: Option<ReceiverAdjustments>,\n         visible_from_module: Option<ModuleId>,\n-        callback: &mut dyn FnMut(&Canonical<Ty>, AssocItemId) -> ControlFlow<()>,\n+        callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n     ) -> ControlFlow<()> {\n         let impls_for_self_ty = filter_inherent_impls_for_self_ty(impls, &self_ty.value);\n         for &impl_def in impls_for_self_ty {\n@@ -889,33 +973,32 @@ fn iterate_inherent_methods(\n                 // already happens in `is_valid_candidate` above; if not, we\n                 // check it here\n                 if receiver_ty.is_none()\n-                    && inherent_impl_substs(db, env.clone(), impl_def, self_ty).is_none()\n+                    && inherent_impl_substs(db, env.clone(), impl_def, &self_ty).is_none()\n                 {\n                     cov_mark::hit!(impl_self_type_match_without_receiver);\n                     continue;\n                 }\n-                let receiver_ty = receiver_ty.unwrap_or(self_ty);\n-                callback(receiver_ty, item)?;\n+                callback(receiver_adjustments.clone().unwrap_or_default(), item)?;\n             }\n         }\n         ControlFlow::Continue(())\n     }\n }\n \n-/// Returns the self type for the index trait call.\n+/// Returns the receiver type for the index trait call.\n pub fn resolve_indexing_op(\n     db: &dyn HirDatabase,\n-    ty: &Canonical<Ty>,\n     env: Arc<TraitEnvironment>,\n-    krate: CrateId,\n+    ty: Canonical<Ty>,\n     index_trait: TraitId,\n-) -> Option<Canonical<Ty>> {\n-    let ty = InEnvironment { goal: ty.clone(), environment: env.env.clone() };\n-    let deref_chain = autoderef_method_receiver(db, krate, ty);\n-    for ty in deref_chain {\n-        let goal = generic_implements_goal(db, env.clone(), index_trait, ty.clone());\n-        if db.trait_solve(krate, goal.cast(Interner)).is_some() {\n-            return Some(ty);\n+) -> Option<ReceiverAdjustments> {\n+    let mut table = InferenceTable::new(db, env.clone());\n+    let ty = table.instantiate_canonical(ty);\n+    let (deref_chain, adj) = autoderef_method_receiver(&mut table, ty);\n+    for (ty, adj) in deref_chain.into_iter().zip(adj) {\n+        let goal = generic_implements_goal(db, env.clone(), index_trait, &ty);\n+        if db.trait_solve(env.krate, goal.cast(Interner)).is_some() {\n+            return Some(adj);\n         }\n     }\n     None\n@@ -1067,11 +1150,10 @@ pub fn implements_trait(\n     ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n-    krate: CrateId,\n     trait_: TraitId,\n ) -> bool {\n-    let goal = generic_implements_goal(db, env, trait_, ty.clone());\n-    let solution = db.trait_solve(krate, goal.cast(Interner));\n+    let goal = generic_implements_goal(db, env.clone(), trait_, &ty);\n+    let solution = db.trait_solve(env.krate, goal.cast(Interner));\n \n     solution.is_some()\n }\n@@ -1080,11 +1162,10 @@ pub fn implements_trait_unique(\n     ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n-    krate: CrateId,\n     trait_: TraitId,\n ) -> bool {\n-    let goal = generic_implements_goal(db, env, trait_, ty.clone());\n-    let solution = db.trait_solve(krate, goal.cast(Interner));\n+    let goal = generic_implements_goal(db, env.clone(), trait_, &ty);\n+    let solution = db.trait_solve(env.krate, goal.cast(Interner));\n \n     matches!(solution, Some(crate::Solution::Unique(_)))\n }\n@@ -1095,11 +1176,11 @@ fn generic_implements_goal(\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n     trait_: TraitId,\n-    self_ty: Canonical<Ty>,\n+    self_ty: &Canonical<Ty>,\n ) -> Canonical<InEnvironment<super::DomainGoal>> {\n     let mut kinds = self_ty.binders.interned().to_vec();\n     let trait_ref = TyBuilder::trait_ref(db, trait_)\n-        .push(self_ty.value)\n+        .push(self_ty.value.clone())\n         .fill_with_bound_vars(DebruijnIndex::INNERMOST, kinds.len())\n         .build();\n     kinds.extend(\n@@ -1117,17 +1198,27 @@ fn generic_implements_goal(\n }\n \n fn autoderef_method_receiver(\n-    db: &dyn HirDatabase,\n-    krate: CrateId,\n-    ty: InEnvironment<Canonical<Ty>>,\n-) -> Vec<Canonical<Ty>> {\n-    let mut deref_chain: Vec<_> = autoderef::autoderef(db, Some(krate), ty).collect();\n+    table: &mut InferenceTable,\n+    ty: Ty,\n+) -> (Vec<Canonical<Ty>>, Vec<ReceiverAdjustments>) {\n+    let (mut deref_chain, mut adjustments): (Vec<_>, Vec<_>) = (Vec::new(), Vec::new());\n+    let mut autoderef = autoderef::Autoderef::new(table, ty);\n+    while let Some((ty, derefs)) = autoderef.next() {\n+        deref_chain.push(autoderef.table.canonicalize(ty).value);\n+        adjustments.push(ReceiverAdjustments {\n+            autoref: None,\n+            autoderefs: derefs,\n+            unsize_array: false,\n+        });\n+    }\n     // As a last step, we can do array unsizing (that's the only unsizing that rustc does for method receivers!)\n-    if let Some(TyKind::Array(parameters, _)) = deref_chain.last().map(|ty| ty.value.kind(Interner))\n-    {\n-        let kinds = deref_chain.last().unwrap().binders.clone();\n+    if let (Some((TyKind::Array(parameters, _), binders)), Some(adj)) = (\n+        deref_chain.last().map(|ty| (ty.value.kind(Interner), ty.binders.clone())),\n+        adjustments.last().cloned(),\n+    ) {\n         let unsized_ty = TyKind::Slice(parameters.clone()).intern(Interner);\n-        deref_chain.push(Canonical { value: unsized_ty, binders: kinds })\n+        deref_chain.push(Canonical { value: unsized_ty, binders });\n+        adjustments.push(ReceiverAdjustments { unsize_array: true, ..adj });\n     }\n-    deref_chain\n+    (deref_chain, adjustments)\n }"}, {"sha": "7385da56622dddac4b64bf6d3c2b585889955dc4", "filename": "crates/hir_ty/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests.rs?ref=ab896e38e124676c4d0532b74f4d0d714b33b2f9", "patch": "@@ -100,6 +100,7 @@ fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_sour\n                         .trim_start_matches(\"adjustments: \")\n                         .split(',')\n                         .map(|it| it.trim().to_string())\n+                        .filter(|it| !it.is_empty())\n                         .collect(),\n                 );\n             } else {"}, {"sha": "c0dddb608ea394e75c4c057aa01c9db2c00e280d", "filename": "crates/hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=ab896e38e124676c4d0532b74f4d0d714b33b2f9", "patch": "@@ -242,6 +242,45 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn coerce_autoderef_implication_1() {\n+    check_no_mismatches(\n+        r\"\n+//- minicore: deref\n+struct Foo<T>;\n+impl core::ops::Deref for Foo<u32> { type Target = (); }\n+\n+fn takes_ref_foo<T>(x: &Foo<T>) {}\n+fn test() {\n+    let foo = Foo;\n+      //^^^ type: Foo<{unknown}>\n+    takes_ref_foo(&foo);\n+\n+    let foo = Foo;\n+      //^^^ type: Foo<u32>\n+    let _: &() = &foo;\n+}\",\n+    );\n+}\n+\n+#[test]\n+fn coerce_autoderef_implication_2() {\n+    check(\n+        r\"\n+//- minicore: deref\n+struct Foo<T>;\n+impl core::ops::Deref for Foo<u32> { type Target = (); }\n+\n+fn takes_ref_foo<T>(x: &Foo<T>) {}\n+fn test() {\n+    let foo = Foo;\n+      //^^^ type: Foo<{unknown}>\n+    let _: &u32 = &Foo;\n+                //^^^^ expected &u32, got &Foo<{unknown}>\n+}\",\n+    );\n+}\n+\n #[test]\n fn closure_return_coerce() {\n     check_no_mismatches("}, {"sha": "c118ae24cfe300a3542327b357dbadc6f1bed147", "filename": "crates/hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=ab896e38e124676c4d0532b74f4d0d714b33b2f9", "patch": "@@ -1460,3 +1460,121 @@ fn main() {\n     \"#,\n     );\n }\n+\n+#[test]\n+fn deref_fun_1() {\n+    check_types(\n+        r#\"\n+//- minicore: deref\n+\n+struct A<T, U>(T, U);\n+struct B<T>(T);\n+struct C<T>(T);\n+\n+impl<T> core::ops::Deref for A<B<T>, u32> {\n+    type Target = B<T>;\n+    fn deref(&self) -> &B<T> { &self.0 }\n+}\n+impl core::ops::Deref for B<isize> {\n+    type Target = C<isize>;\n+    fn deref(&self) -> &C<isize> { loop {} }\n+}\n+\n+impl<T: Copy> C<T> {\n+    fn thing(&self) -> T { self.0 }\n+}\n+\n+fn make<T>() -> T { loop {} }\n+\n+fn test() {\n+    let a1 = A(make(), make());\n+    let _: usize = (*a1).0;\n+    a1;\n+  //^^ A<B<usize>, u32>\n+\n+    let a2 = A(make(), make());\n+    a2.thing();\n+  //^^^^^^^^^^ isize\n+    a2;\n+  //^^ A<B<isize>, u32>\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn deref_fun_2() {\n+    check_types(\n+        r#\"\n+//- minicore: deref\n+\n+struct A<T, U>(T, U);\n+struct B<T>(T);\n+struct C<T>(T);\n+\n+impl<T> core::ops::Deref for A<B<T>, u32> {\n+    type Target = B<T>;\n+    fn deref(&self) -> &B<T> { &self.0 }\n+}\n+impl core::ops::Deref for B<isize> {\n+    type Target = C<isize>;\n+    fn deref(&self) -> &C<isize> { loop {} }\n+}\n+\n+impl<T> core::ops::Deref for A<C<T>, i32> {\n+    type Target = C<T>;\n+    fn deref(&self) -> &C<T> { &self.0 }\n+}\n+\n+impl<T: Copy> C<T> {\n+    fn thing(&self) -> T { self.0 }\n+}\n+\n+fn make<T>() -> T { loop {} }\n+\n+fn test() {\n+    let a1 = A(make(), 1u32);\n+    a1.thing();\n+    a1;\n+  //^^ A<B<isize>, u32>\n+\n+    let a2 = A(make(), 1i32);\n+    let _: &str = a2.thing();\n+    a2;\n+  //^^ A<C<&str>, i32>\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn receiver_adjustment_autoref() {\n+    check(\n+        r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo(&self) {}\n+}\n+fn test() {\n+    Foo.foo();\n+  //^^^ adjustments: Borrow(Ref(Not))\n+    (&Foo).foo();\n+  // ^^^^ adjustments: ,\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn receiver_adjustment_unsize_array() {\n+    // FIXME not quite correct\n+    check(\n+        r#\"\n+//- minicore: slice\n+fn test() {\n+    let a = [1, 2, 3];\n+    a.len();\n+} //^ adjustments: Pointer(Unsize), Borrow(Ref(Not))\n+\"#,\n+    );\n+}"}, {"sha": "04d8b91e3598abba098f0c833616500ec4f5491b", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=ab896e38e124676c4d0532b74f4d0d714b33b2f9", "patch": "@@ -540,6 +540,52 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn infer_ops_index_field() {\n+    check_types(\n+        r#\"\n+//- minicore: index\n+struct Bar;\n+struct Foo {\n+    field: u32;\n+}\n+\n+impl core::ops::Index<u32> for Bar {\n+    type Output = Foo;\n+}\n+\n+fn test() {\n+    let a = Bar;\n+    let b = a[1u32].field;\n+    b;\n+} //^ u32\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn infer_ops_index_field_autoderef() {\n+    check_types(\n+        r#\"\n+//- minicore: index\n+struct Bar;\n+struct Foo {\n+    field: u32;\n+}\n+\n+impl core::ops::Index<u32> for Bar {\n+    type Output = Foo;\n+}\n+\n+fn test() {\n+    let a = Bar;\n+    let b = (&a[1u32]).field;\n+    b;\n+} //^ u32\n+\"#,\n+    );\n+}\n+\n #[test]\n fn infer_ops_index_int() {\n     check_types("}, {"sha": "b139edbee9459e8dae30ecf792f3b0e293a4118d", "filename": "crates/hir_ty/src/traits.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits.rs?ref=ab896e38e124676c4d0532b74f4d0d714b33b2f9", "patch": "@@ -40,8 +40,7 @@ fn create_chalk_solver() -> chalk_recursive::RecursiveSolver<Interner> {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TraitEnvironment {\n     pub krate: CrateId,\n-    // When we're using Chalk's Ty we can make this a BTreeMap since it's Ord,\n-    // but for now it's too annoying...\n+    // FIXME make this a BTreeMap\n     pub(crate) traits_from_clauses: Vec<(Ty, TraitId)>,\n     pub env: chalk_ir::Environment<Interner>,\n }"}, {"sha": "4a4ad984db14a844808f627653719e8b7d59dd0e", "filename": "crates/ide_assists/src/handlers/convert_iter_for_each_to_for.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs?ref=ab896e38e124676c4d0532b74f4d0d714b33b2f9", "patch": "@@ -154,11 +154,11 @@ fn is_ref_and_impls_iter_method(\n     let has_wanted_method = ty\n         .iterate_method_candidates(\n             sema.db,\n-            krate,\n+            &scope,\n             &traits_in_scope,\n             None,\n             Some(&wanted_method),\n-            |_, func| {\n+            |func| {\n                 if func.ret_type(sema.db).impls_trait(sema.db, iter_trait, &[]) {\n                     return Some(());\n                 }"}, {"sha": "ac17e3f057a56f12ac76bbaeb8aa4542de6fb3bc", "filename": "crates/ide_assists/src/handlers/destructure_tuple_binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs?ref=ab896e38e124676c4d0532b74f4d0d714b33b2f9", "patch": "@@ -371,7 +371,7 @@ fn handle_ref_field_usage(ctx: &AssistContext, field_expr: &FieldExpr) -> RefDat\n             fn is_auto_ref(ctx: &AssistContext, call_expr: &MethodCallExpr) -> bool {\n                 fn impl_(ctx: &AssistContext, call_expr: &MethodCallExpr) -> Option<bool> {\n                     let rec = call_expr.receiver()?;\n-                    let rec_ty = ctx.sema.type_of_expr(&rec)?.adjusted();\n+                    let rec_ty = ctx.sema.type_of_expr(&rec)?.original();\n                     // input must be actual value\n                     if rec_ty.is_reference() {\n                         return Some(false);"}, {"sha": "db0cfbe2ec0f1917389bc4b38a346860188b108a", "filename": "crates/ide_assists/src/handlers/generate_is_empty_from_len.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_is_empty_from_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_is_empty_from_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_is_empty_from_len.rs?ref=ab896e38e124676c4d0532b74f4d0d714b33b2f9", "patch": "@@ -90,10 +90,9 @@ fn get_impl_method(\n     let impl_def: hir::Impl = ctx.sema.to_def(impl_)?;\n \n     let scope = ctx.sema.scope(impl_.syntax());\n-    let krate = impl_def.module(db).krate();\n     let ty = impl_def.self_ty(db);\n     let traits_in_scope = scope.visible_traits();\n-    ty.iterate_method_candidates(db, krate, &traits_in_scope, None, Some(fn_name), |_, func| {\n+    ty.iterate_method_candidates(db, &scope, &traits_in_scope, None, Some(fn_name), |func| {\n         Some(func)\n     })\n }"}, {"sha": "981e25b55c7b39b2fd533b22abd78f477c2d0d06", "filename": "crates/ide_completion/src/completions/dot.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=ab896e38e124676c4d0532b74f4d0d714b33b2f9", "patch": "@@ -74,30 +74,28 @@ fn complete_methods(\n     receiver: &hir::Type,\n     mut f: impl FnMut(hir::Function),\n ) {\n-    if let Some(krate) = ctx.krate {\n-        let mut seen_methods = FxHashSet::default();\n-        let mut traits_in_scope = ctx.scope.visible_traits();\n-\n-        // Remove drop from the environment as calling `Drop::drop` is not allowed\n-        if let Some(drop_trait) = ctx.famous_defs().core_ops_Drop() {\n-            cov_mark::hit!(dot_remove_drop_trait);\n-            traits_in_scope.remove(&drop_trait.into());\n-        }\n-\n-        receiver.iterate_method_candidates(\n-            ctx.db,\n-            krate,\n-            &traits_in_scope,\n-            ctx.module,\n-            None,\n-            |_ty, func| {\n-                if func.self_param(ctx.db).is_some() && seen_methods.insert(func.name(ctx.db)) {\n-                    f(func);\n-                }\n-                None::<()>\n-            },\n-        );\n-    }\n+    let mut seen_methods = FxHashSet::default();\n+    let mut traits_in_scope = ctx.scope.visible_traits();\n+\n+    // Remove drop from the environment as calling `Drop::drop` is not allowed\n+    if let Some(drop_trait) = ctx.famous_defs().core_ops_Drop() {\n+        cov_mark::hit!(dot_remove_drop_trait);\n+        traits_in_scope.remove(&drop_trait.into());\n+    }\n+\n+    receiver.iterate_method_candidates(\n+        ctx.db,\n+        &ctx.scope,\n+        &traits_in_scope,\n+        ctx.module,\n+        None,\n+        |func| {\n+            if func.self_param(ctx.db).is_some() && seen_methods.insert(func.name(ctx.db)) {\n+                f(func);\n+            }\n+            None::<()>\n+        },\n+    );\n }\n \n #[cfg(test)]"}, {"sha": "c8a9cf21da125a2a914064e8133d44765a6958fa", "filename": "crates/ide_completion/src/completions/pattern.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=ab896e38e124676c4d0532b74f4d0d714b33b2f9", "patch": "@@ -134,39 +134,37 @@ fn pattern_path_completion(\n                         .for_each(|variant| acc.add_enum_variant(ctx, variant, None));\n                 }\n                 res @ (hir::PathResolution::TypeParam(_) | hir::PathResolution::SelfType(_)) => {\n-                    if let Some(krate) = ctx.krate {\n-                        let ty = match res {\n-                            hir::PathResolution::TypeParam(param) => param.ty(ctx.db),\n-                            hir::PathResolution::SelfType(impl_def) => impl_def.self_ty(ctx.db),\n-                            _ => return,\n-                        };\n+                    let ty = match res {\n+                        hir::PathResolution::TypeParam(param) => param.ty(ctx.db),\n+                        hir::PathResolution::SelfType(impl_def) => impl_def.self_ty(ctx.db),\n+                        _ => return,\n+                    };\n \n-                        if let Some(hir::Adt::Enum(e)) = ty.as_adt() {\n-                            e.variants(ctx.db)\n-                                .into_iter()\n-                                .for_each(|variant| acc.add_enum_variant(ctx, variant, None));\n-                        }\n+                    if let Some(hir::Adt::Enum(e)) = ty.as_adt() {\n+                        e.variants(ctx.db)\n+                            .into_iter()\n+                            .for_each(|variant| acc.add_enum_variant(ctx, variant, None));\n+                    }\n \n-                        let traits_in_scope = ctx.scope.visible_traits();\n-                        let mut seen = FxHashSet::default();\n-                        ty.iterate_path_candidates(\n-                            ctx.db,\n-                            krate,\n-                            &traits_in_scope,\n-                            ctx.module,\n-                            None,\n-                            |_ty, item| {\n-                                // Note associated consts cannot be referenced in patterns\n-                                if let AssocItem::TypeAlias(ta) = item {\n-                                    // We might iterate candidates of a trait multiple times here, so deduplicate them.\n-                                    if seen.insert(item) {\n-                                        acc.add_type_alias(ctx, ta);\n-                                    }\n+                    let traits_in_scope = ctx.scope.visible_traits();\n+                    let mut seen = FxHashSet::default();\n+                    ty.iterate_path_candidates(\n+                        ctx.db,\n+                        &ctx.scope,\n+                        &traits_in_scope,\n+                        ctx.module,\n+                        None,\n+                        |item| {\n+                            // Note associated consts cannot be referenced in patterns\n+                            if let AssocItem::TypeAlias(ta) = item {\n+                                // We might iterate candidates of a trait multiple times here, so deduplicate them.\n+                                if seen.insert(item) {\n+                                    acc.add_type_alias(ctx, ta);\n                                 }\n-                                None::<()>\n-                            },\n-                        );\n-                    }\n+                            }\n+                            None::<()>\n+                        },\n+                    );\n                 }\n                 _ => {}\n             }"}, {"sha": "d63aacbadbc910e527dd34260388418fed375671", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=ab896e38e124676c4d0532b74f4d0d714b33b2f9", "patch": "@@ -138,11 +138,11 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                 let traits_in_scope = ctx.scope.visible_traits();\n                 ty.iterate_path_candidates(\n                     ctx.db,\n-                    krate,\n+                    &ctx.scope,\n                     &traits_in_scope,\n                     ctx.module,\n                     None,\n-                    |_ty, item| {\n+                    |item| {\n                         add_assoc_item(acc, ctx, item);\n                         None::<()>\n                     },\n@@ -164,35 +164,33 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n             }\n         }\n         hir::PathResolution::TypeParam(_) | hir::PathResolution::SelfType(_) => {\n-            if let Some(krate) = ctx.krate {\n-                let ty = match resolution {\n-                    hir::PathResolution::TypeParam(param) => param.ty(ctx.db),\n-                    hir::PathResolution::SelfType(impl_def) => impl_def.self_ty(ctx.db),\n-                    _ => return,\n-                };\n-\n-                if let Some(hir::Adt::Enum(e)) = ty.as_adt() {\n-                    add_enum_variants(acc, ctx, e);\n-                }\n+            let ty = match resolution {\n+                hir::PathResolution::TypeParam(param) => param.ty(ctx.db),\n+                hir::PathResolution::SelfType(impl_def) => impl_def.self_ty(ctx.db),\n+                _ => return,\n+            };\n \n-                let traits_in_scope = ctx.scope.visible_traits();\n-                let mut seen = FxHashSet::default();\n-                ty.iterate_path_candidates(\n-                    ctx.db,\n-                    krate,\n-                    &traits_in_scope,\n-                    ctx.module,\n-                    None,\n-                    |_ty, item| {\n-                        // We might iterate candidates of a trait multiple times here, so deduplicate\n-                        // them.\n-                        if seen.insert(item) {\n-                            add_assoc_item(acc, ctx, item);\n-                        }\n-                        None::<()>\n-                    },\n-                );\n+            if let Some(hir::Adt::Enum(e)) = ty.as_adt() {\n+                add_enum_variants(acc, ctx, e);\n             }\n+\n+            let traits_in_scope = ctx.scope.visible_traits();\n+            let mut seen = FxHashSet::default();\n+            ty.iterate_path_candidates(\n+                ctx.db,\n+                &ctx.scope,\n+                &traits_in_scope,\n+                ctx.module,\n+                None,\n+                |item| {\n+                    // We might iterate candidates of a trait multiple times here, so deduplicate\n+                    // them.\n+                    if seen.insert(item) {\n+                        add_assoc_item(acc, ctx, item);\n+                    }\n+                    None::<()>\n+                },\n+            );\n         }\n         _ => {}\n     }"}, {"sha": "d91627e0a9212dec008f052ffddb593c34bbfa6c", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=ab896e38e124676c4d0532b74f4d0d714b33b2f9", "patch": "@@ -1,7 +1,7 @@\n //! Look up accessible paths for items.\n use hir::{\n     AsAssocItem, AssocItem, AssocItemContainer, Crate, ItemInNs, MacroDef, ModPath, Module,\n-    ModuleDef, PathResolution, PrefixKind, ScopeDef, Semantics, Type,\n+    ModuleDef, PathResolution, PrefixKind, ScopeDef, Semantics, SemanticsScope, Type,\n };\n use itertools::Itertools;\n use rustc_hash::FxHashSet;\n@@ -239,7 +239,6 @@ impl ImportAssets {\n         let _p = profile::span(\"import_assets::search_for\");\n \n         let scope_definitions = self.scope_definitions(sema);\n-        let current_crate = self.module_with_candidate.krate();\n         let mod_path = |item| {\n             get_mod_path(\n                 sema.db,\n@@ -249,15 +248,18 @@ impl ImportAssets {\n             )\n         };\n \n+        let krate = self.module_with_candidate.krate();\n+        let scope = sema.scope(&self.candidate_node);\n+\n         match &self.import_candidate {\n             ImportCandidate::Path(path_candidate) => {\n-                path_applicable_imports(sema, current_crate, path_candidate, mod_path)\n+                path_applicable_imports(sema, krate, path_candidate, mod_path)\n             }\n             ImportCandidate::TraitAssocItem(trait_candidate) => {\n-                trait_applicable_items(sema, current_crate, trait_candidate, true, mod_path)\n+                trait_applicable_items(sema, krate, &scope, trait_candidate, true, mod_path)\n             }\n             ImportCandidate::TraitMethod(trait_candidate) => {\n-                trait_applicable_items(sema, current_crate, trait_candidate, false, mod_path)\n+                trait_applicable_items(sema, krate, &scope, trait_candidate, false, mod_path)\n             }\n         }\n         .into_iter()\n@@ -447,6 +449,7 @@ fn module_with_segment_name(\n fn trait_applicable_items(\n     sema: &Semantics<RootDatabase>,\n     current_crate: Crate,\n+    scope: &SemanticsScope,\n     trait_candidate: &TraitImportCandidate,\n     trait_assoc_item: bool,\n     mod_path: impl Fn(ItemInNs) -> Option<ModPath>,\n@@ -484,11 +487,11 @@ fn trait_applicable_items(\n     if trait_assoc_item {\n         trait_candidate.receiver_ty.iterate_path_candidates(\n             db,\n-            current_crate,\n+            scope,\n             &trait_candidates,\n             None,\n             None,\n-            |_, assoc| {\n+            |assoc| {\n                 if required_assoc_items.contains(&assoc) {\n                     if let AssocItem::Function(f) = assoc {\n                         if f.self_param(db).is_some() {\n@@ -511,11 +514,11 @@ fn trait_applicable_items(\n     } else {\n         trait_candidate.receiver_ty.iterate_method_candidates(\n             db,\n-            current_crate,\n+            scope,\n             &trait_candidates,\n             None,\n             None,\n-            |_, function| {\n+            |function| {\n                 let assoc = function.as_assoc_item(db)?;\n                 if required_assoc_items.contains(&assoc) {\n                     let located_trait = assoc.containing_trait(db)?;"}, {"sha": "e15cb874efbe0995d0a767ac1e5b0a85745c1234", "filename": "crates/ide_ssr/src/resolving.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fide_ssr%2Fsrc%2Fresolving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab896e38e124676c4d0532b74f4d0d714b33b2f9/crates%2Fide_ssr%2Fsrc%2Fresolving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_ssr%2Fsrc%2Fresolving.rs?ref=ab896e38e124676c4d0532b74f4d0d714b33b2f9", "patch": "@@ -222,11 +222,11 @@ impl<'db> ResolutionScope<'db> {\n             let module = self.scope.module()?;\n             adt.ty(self.scope.db).iterate_path_candidates(\n                 self.scope.db,\n-                module.krate(),\n+                &self.scope,\n                 &self.scope.visible_traits(),\n                 Some(module),\n                 None,\n-                |_ty, assoc_item| {\n+                |assoc_item| {\n                     let item_name = assoc_item.name(self.scope.db)?;\n                     if item_name.to_smol_str().as_str() == name.text() {\n                         Some(hir::PathResolution::AssocItem(assoc_item))"}]}