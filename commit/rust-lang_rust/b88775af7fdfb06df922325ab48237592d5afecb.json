{"sha": "b88775af7fdfb06df922325ab48237592d5afecb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4ODc3NWFmN2ZkZmIwNmRmOTIyMzI1YWI0ODIzNzU5MmQ1YWZlY2I=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-07T13:53:24Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-08T08:20:15Z"}, "message": "migrate ra_editor to rowan 0.2", "tree": {"sha": "68ee9946a5d59d8d8f82a658aa3816dc658c1ff8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68ee9946a5d59d8d8f82a658aa3816dc658c1ff8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b88775af7fdfb06df922325ab48237592d5afecb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b88775af7fdfb06df922325ab48237592d5afecb", "html_url": "https://github.com/rust-lang/rust/commit/b88775af7fdfb06df922325ab48237592d5afecb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b88775af7fdfb06df922325ab48237592d5afecb/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b73c51ff9bdf96ea22af0b9c431f201dcc8ddcd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b73c51ff9bdf96ea22af0b9c431f201dcc8ddcd3", "html_url": "https://github.com/rust-lang/rust/commit/b73c51ff9bdf96ea22af0b9c431f201dcc8ddcd3"}], "stats": {"total": 179, "additions": 83, "deletions": 96}, "files": [{"sha": "a320caabfaadbda480707db570de82234e1e8733", "filename": "crates/ra_editor/src/assists.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b88775af7fdfb06df922325ab48237592d5afecb/crates%2Fra_editor%2Fsrc%2Fassists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88775af7fdfb06df922325ab48237592d5afecb/crates%2Fra_editor%2Fsrc%2Fassists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fassists.rs?ref=b88775af7fdfb06df922325ab48237592d5afecb", "patch": "@@ -12,7 +12,7 @@ mod split_import;\n \n use ra_text_edit::{TextEdit, TextEditBuilder};\n use ra_syntax::{\n-    Direction, SyntaxNodeRef, TextUnit, TextRange,SourceFileNode, AstNode,\n+    Direction, SyntaxNode, TextUnit, TextRange, SourceFile, AstNode,\n     algo::{find_leaf_at_offset, find_covering_node, LeafAtOffset},\n };\n \n@@ -28,7 +28,7 @@ pub use self::{\n };\n \n /// Return all the assists applicable at the given position.\n-pub fn assists(file: &SourceFileNode, range: TextRange) -> Vec<LocalEdit> {\n+pub fn assists(file: &SourceFile, range: TextRange) -> Vec<LocalEdit> {\n     let ctx = AssistCtx::new(file, range);\n     [\n         flip_comma,\n@@ -50,7 +50,7 @@ pub struct LocalEdit {\n     pub cursor_position: Option<TextUnit>,\n }\n \n-fn non_trivia_sibling(node: SyntaxNodeRef, direction: Direction) -> Option<SyntaxNodeRef> {\n+fn non_trivia_sibling(node: &SyntaxNode, direction: Direction) -> Option<&SyntaxNode> {\n     node.siblings(direction)\n         .skip(1)\n         .find(|node| !node.kind().is_trivia())\n@@ -88,7 +88,7 @@ fn non_trivia_sibling(node: SyntaxNodeRef, direction: Direction) -> Option<Synta\n /// easier to just compute the edit eagarly :-)\n #[derive(Debug, Clone)]\n pub struct AssistCtx<'a> {\n-    source_file: &'a SourceFileNode,\n+    source_file: &'a SourceFile,\n     range: TextRange,\n     should_compute_edit: bool,\n }\n@@ -106,7 +106,7 @@ struct AssistBuilder {\n }\n \n impl<'a> AssistCtx<'a> {\n-    pub fn new(source_file: &'a SourceFileNode, range: TextRange) -> AssistCtx {\n+    pub fn new(source_file: &'a SourceFile, range: TextRange) -> AssistCtx {\n         AssistCtx {\n             source_file,\n             range,\n@@ -145,13 +145,13 @@ impl<'a> AssistCtx<'a> {\n         }))\n     }\n \n-    pub(crate) fn leaf_at_offset(&self) -> LeafAtOffset<SyntaxNodeRef<'a>> {\n+    pub(crate) fn leaf_at_offset(&self) -> LeafAtOffset<&'a SyntaxNode> {\n         find_leaf_at_offset(self.source_file.syntax(), self.range.start())\n     }\n-    pub(crate) fn node_at_offset<N: AstNode<'a>>(&self) -> Option<N> {\n+    pub(crate) fn node_at_offset<N: AstNode>(&self) -> Option<&'a N> {\n         find_node_at_offset(self.source_file.syntax(), self.range.start())\n     }\n-    pub(crate) fn covering_node(&self) -> SyntaxNodeRef<'a> {\n+    pub(crate) fn covering_node(&self) -> &'a SyntaxNode {\n         find_covering_node(self.source_file.syntax(), self.range)\n     }\n }"}, {"sha": "6e964d011bdfe4445522b0567fcf9b8347dd2607", "filename": "crates/ra_editor/src/assists/add_derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b88775af7fdfb06df922325ab48237592d5afecb/crates%2Fra_editor%2Fsrc%2Fassists%2Fadd_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88775af7fdfb06df922325ab48237592d5afecb/crates%2Fra_editor%2Fsrc%2Fassists%2Fadd_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fassists%2Fadd_derive.rs?ref=b88775af7fdfb06df922325ab48237592d5afecb", "patch": "@@ -28,7 +28,7 @@ pub fn add_derive(ctx: AssistCtx) -> Option<Assist> {\n }\n \n // Insert `derive` after doc comments.\n-fn derive_insertion_offset(nominal: ast::NominalDef) -> Option<TextUnit> {\n+fn derive_insertion_offset(nominal: &ast::NominalDef) -> Option<TextUnit> {\n     let non_ws_child = nominal\n         .syntax()\n         .children()"}, {"sha": "89729e2c251aed548ecb12d4de773be8c5699430", "filename": "crates/ra_editor/src/assists/change_visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b88775af7fdfb06df922325ab48237592d5afecb/crates%2Fra_editor%2Fsrc%2Fassists%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88775af7fdfb06df922325ab48237592d5afecb/crates%2Fra_editor%2Fsrc%2Fassists%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fassists%2Fchange_visibility.rs?ref=b88775af7fdfb06df922325ab48237592d5afecb", "patch": "@@ -46,7 +46,7 @@ fn add_vis(ctx: AssistCtx) -> Option<Assist> {\n     })\n }\n \n-fn change_vis(ctx: AssistCtx, vis: ast::Visibility) -> Option<Assist> {\n+fn change_vis(ctx: AssistCtx, vis: &ast::Visibility) -> Option<Assist> {\n     if vis.syntax().text() != \"pub\" {\n         return None;\n     }"}, {"sha": "523ec7034f2da3bd4f56289990f379b58dfa742a", "filename": "crates/ra_editor/src/assists/introduce_variable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b88775af7fdfb06df922325ab48237592d5afecb/crates%2Fra_editor%2Fsrc%2Fassists%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88775af7fdfb06df922325ab48237592d5afecb/crates%2Fra_editor%2Fsrc%2Fassists%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fassists%2Fintroduce_variable.rs?ref=b88775af7fdfb06df922325ab48237592d5afecb", "patch": "@@ -1,7 +1,7 @@\n use ra_syntax::{\n     ast::{self, AstNode},\n     SyntaxKind::WHITESPACE,\n-    SyntaxNodeRef, TextUnit,\n+    SyntaxNode, TextUnit,\n };\n \n use crate::assists::{AssistCtx, Assist};\n@@ -39,7 +39,7 @@ pub fn introduce_variable<'a>(ctx: AssistCtx) -> Option<Assist> {\n \n /// Statement or last in the block expression, which will follow\n /// the freshly introduced var.\n-fn anchor_stmt(expr: ast::Expr) -> Option<SyntaxNodeRef> {\n+fn anchor_stmt(expr: &ast::Expr) -> Option<&SyntaxNode> {\n     expr.syntax().ancestors().find(|&node| {\n         if ast::Stmt::cast(node).is_some() {\n             return true;"}, {"sha": "2b695dfdfc486e151bf4a5a03845c0997b0f650f", "filename": "crates/ra_editor/src/diagnostics.rs", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b88775af7fdfb06df922325ab48237592d5afecb/crates%2Fra_editor%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88775af7fdfb06df922325ab48237592d5afecb/crates%2Fra_editor%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fdiagnostics.rs?ref=b88775af7fdfb06df922325ab48237592d5afecb", "patch": "@@ -1,25 +1,15 @@\n use itertools::Itertools;\n \n use ra_syntax::{\n+    Location, SourceFile, SyntaxKind, TextRange, SyntaxNode,\n     ast::{self, AstNode},\n-    Location,\n-    SourceFileNode,\n-    SyntaxKind,\n-    TextRange,\n-};\n-use ra_syntax::SyntaxNodeRef;\n-use ra_text_edit::{\n-    TextEdit,\n-    TextEditBuilder,\n-};\n \n-use crate::{\n-    Diagnostic,\n-    LocalEdit,\n-    Severity,\n };\n+use ra_text_edit::{TextEdit, TextEditBuilder};\n+\n+use crate::{Diagnostic, LocalEdit, Severity};\n \n-pub fn diagnostics(file: &SourceFileNode) -> Vec<Diagnostic> {\n+pub fn diagnostics(file: &SourceFile) -> Vec<Diagnostic> {\n     fn location_to_range(location: Location) -> TextRange {\n         match location {\n             Location::Offset(offset) => TextRange::offset_len(offset, 1.into()),\n@@ -48,7 +38,7 @@ pub fn diagnostics(file: &SourceFileNode) -> Vec<Diagnostic> {\n \n fn check_unnecessary_braces_in_use_statement(\n     acc: &mut Vec<Diagnostic>,\n-    node: SyntaxNodeRef,\n+    node: &SyntaxNode,\n ) -> Option<()> {\n     let use_tree_list = ast::UseTreeList::cast(node)?;\n     if let Some((single_use_tree,)) = use_tree_list.use_trees().collect_tuple() {\n@@ -79,7 +69,7 @@ fn check_unnecessary_braces_in_use_statement(\n }\n \n fn text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n-    single_use_tree: ast::UseTree,\n+    single_use_tree: &ast::UseTree,\n ) -> Option<TextEdit> {\n     let use_tree_list_node = single_use_tree.syntax().parent()?;\n     if single_use_tree\n@@ -102,7 +92,7 @@ fn text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n \n fn check_struct_shorthand_initialization(\n     acc: &mut Vec<Diagnostic>,\n-    node: SyntaxNodeRef,\n+    node: &SyntaxNode,\n ) -> Option<()> {\n     let struct_lit = ast::StructLit::cast(node)?;\n     let named_field_list = struct_lit.named_field_list()?;\n@@ -138,10 +128,10 @@ mod tests {\n \n     use super::*;\n \n-    type DiagnosticChecker = fn(&mut Vec<Diagnostic>, SyntaxNodeRef) -> Option<()>;\n+    type DiagnosticChecker = fn(&mut Vec<Diagnostic>, &SyntaxNode) -> Option<()>;\n \n     fn check_not_applicable(code: &str, func: DiagnosticChecker) {\n-        let file = SourceFileNode::parse(code);\n+        let file = SourceFile::parse(code);\n         let mut diagnostics = Vec::new();\n         for node in file.syntax().descendants() {\n             func(&mut diagnostics, node);\n@@ -150,7 +140,7 @@ mod tests {\n     }\n \n     fn check_apply(before: &str, after: &str, func: DiagnosticChecker) {\n-        let file = SourceFileNode::parse(before);\n+        let file = SourceFile::parse(before);\n         let mut diagnostics = Vec::new();\n         for node in file.syntax().descendants() {\n             func(&mut diagnostics, node);"}, {"sha": "08cae5a51616f7e62ae8b607721dd9ee2eb26de8", "filename": "crates/ra_editor/src/extend_selection.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b88775af7fdfb06df922325ab48237592d5afecb/crates%2Fra_editor%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88775af7fdfb06df922325ab48237592d5afecb/crates%2Fra_editor%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fextend_selection.rs?ref=b88775af7fdfb06df922325ab48237592d5afecb", "patch": "@@ -1,11 +1,10 @@\n use ra_syntax::{\n+    Direction, SyntaxNode, TextRange, TextUnit,\n     algo::{find_covering_node, find_leaf_at_offset, LeafAtOffset},\n-    Direction,\n     SyntaxKind::*,\n-    SyntaxNodeRef, TextRange, TextUnit,\n };\n \n-pub fn extend_selection(root: SyntaxNodeRef, range: TextRange) -> Option<TextRange> {\n+pub fn extend_selection(root: &SyntaxNode, range: TextRange) -> Option<TextRange> {\n     let string_kinds = [COMMENT, STRING, RAW_STRING, BYTE_STRING, RAW_BYTE_STRING];\n     if range.is_empty() {\n         let offset = range.start();\n@@ -40,7 +39,7 @@ pub fn extend_selection(root: SyntaxNodeRef, range: TextRange) -> Option<TextRan\n }\n \n fn extend_single_word_in_comment_or_string(\n-    leaf: SyntaxNodeRef,\n+    leaf: &SyntaxNode,\n     offset: TextUnit,\n ) -> Option<TextRange> {\n     let text: &str = leaf.leaf_text()?;\n@@ -66,7 +65,7 @@ fn extend_single_word_in_comment_or_string(\n     }\n }\n \n-fn extend_ws(root: SyntaxNodeRef, ws: SyntaxNodeRef, offset: TextUnit) -> TextRange {\n+fn extend_ws(root: &SyntaxNode, ws: &SyntaxNode, offset: TextUnit) -> TextRange {\n     let ws_text = ws.leaf_text().unwrap();\n     let suffix = TextRange::from_to(offset, ws.range().end()) - ws.range().start();\n     let prefix = TextRange::from_to(ws.range().start(), offset) - ws.range().start();\n@@ -89,9 +88,9 @@ fn extend_ws(root: SyntaxNodeRef, ws: SyntaxNodeRef, offset: TextUnit) -> TextRa\n     ws.range()\n }\n \n-fn pick_best<'a>(l: SyntaxNodeRef<'a>, r: SyntaxNodeRef<'a>) -> SyntaxNodeRef<'a> {\n+fn pick_best<'a>(l: &'a SyntaxNode, r: &'a SyntaxNode) -> &'a SyntaxNode {\n     return if priority(r) > priority(l) { r } else { l };\n-    fn priority(n: SyntaxNodeRef) -> usize {\n+    fn priority(n: &SyntaxNode) -> usize {\n         match n.kind() {\n             WHITESPACE => 0,\n             IDENT | SELF_KW | SUPER_KW | CRATE_KW | LIFETIME => 2,\n@@ -100,7 +99,7 @@ fn pick_best<'a>(l: SyntaxNodeRef<'a>, r: SyntaxNodeRef<'a>) -> SyntaxNodeRef<'a\n     }\n }\n \n-fn extend_comments(node: SyntaxNodeRef) -> Option<TextRange> {\n+fn extend_comments(node: &SyntaxNode) -> Option<TextRange> {\n     let prev = adj_comments(node, Direction::Prev);\n     let next = adj_comments(node, Direction::Next);\n     if prev != next {\n@@ -110,7 +109,7 @@ fn extend_comments(node: SyntaxNodeRef) -> Option<TextRange> {\n     }\n }\n \n-fn adj_comments(node: SyntaxNodeRef, dir: Direction) -> SyntaxNodeRef {\n+fn adj_comments(node: &SyntaxNode, dir: Direction) -> &SyntaxNode {\n     let mut res = node;\n     for node in node.siblings(dir) {\n         match node.kind() {\n@@ -124,13 +123,14 @@ fn adj_comments(node: SyntaxNodeRef, dir: Direction) -> SyntaxNodeRef {\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n-    use ra_syntax::SourceFileNode;\n+    use ra_syntax::{SourceFile, AstNode};\n     use test_utils::extract_offset;\n \n+    use super::*;\n+\n     fn do_check(before: &str, afters: &[&str]) {\n         let (cursor, before) = extract_offset(before);\n-        let file = SourceFileNode::parse(&before);\n+        let file = SourceFile::parse(&before);\n         let mut range = TextRange::offset_len(cursor, 0.into());\n         for &after in afters {\n             range = extend_selection(file.syntax(), range).unwrap();"}, {"sha": "6f310688939b07fdcbb5d3016ec174709eddfde8", "filename": "crates/ra_editor/src/folding_ranges.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b88775af7fdfb06df922325ab48237592d5afecb/crates%2Fra_editor%2Fsrc%2Ffolding_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88775af7fdfb06df922325ab48237592d5afecb/crates%2Fra_editor%2Fsrc%2Ffolding_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Ffolding_ranges.rs?ref=b88775af7fdfb06df922325ab48237592d5afecb", "patch": "@@ -1,9 +1,8 @@\n use rustc_hash::FxHashSet;\n \n use ra_syntax::{\n-    ast, AstNode, Direction, SourceFileNode,\n+    ast, AstNode, Direction, SourceFile, SyntaxNode, TextRange,\n     SyntaxKind::{self, *},\n-    SyntaxNodeRef, TextRange,\n };\n \n #[derive(Debug, PartialEq, Eq)]\n@@ -19,7 +18,7 @@ pub struct Fold {\n     pub kind: FoldKind,\n }\n \n-pub fn folding_ranges(file: &SourceFileNode) -> Vec<Fold> {\n+pub fn folding_ranges(file: &SourceFile) -> Vec<Fold> {\n     let mut res = vec![];\n     let mut visited_comments = FxHashSet::default();\n     let mut visited_imports = FxHashSet::default();\n@@ -69,7 +68,7 @@ fn fold_kind(kind: SyntaxKind) -> Option<FoldKind> {\n     }\n }\n \n-fn has_newline(node: SyntaxNodeRef) -> bool {\n+fn has_newline(node: &SyntaxNode) -> bool {\n     for descendant in node.descendants() {\n         if let Some(ws) = ast::Whitespace::cast(descendant) {\n             if ws.has_newlines() {\n@@ -86,8 +85,8 @@ fn has_newline(node: SyntaxNodeRef) -> bool {\n }\n \n fn contiguous_range_for_group<'a>(\n-    first: SyntaxNodeRef<'a>,\n-    visited: &mut FxHashSet<SyntaxNodeRef<'a>>,\n+    first: &'a SyntaxNode,\n+    visited: &mut FxHashSet<&'a SyntaxNode>,\n ) -> Option<TextRange> {\n     visited.insert(first);\n \n@@ -124,8 +123,8 @@ fn contiguous_range_for_group<'a>(\n }\n \n fn contiguous_range_for_comment<'a>(\n-    first: SyntaxNodeRef<'a>,\n-    visited: &mut FxHashSet<SyntaxNodeRef<'a>>,\n+    first: &'a SyntaxNode,\n+    visited: &mut FxHashSet<&'a SyntaxNode>,\n ) -> Option<TextRange> {\n     visited.insert(first);\n \n@@ -174,7 +173,7 @@ mod tests {\n \n     fn do_check(text: &str, fold_kinds: &[FoldKind]) {\n         let (ranges, text) = extract_ranges(text, \"fold\");\n-        let file = SourceFileNode::parse(&text);\n+        let file = SourceFile::parse(&text);\n         let folds = folding_ranges(&file);\n \n         assert_eq!("}, {"sha": "6731260a31af358e1227651ab3c8e2d458cd8844", "filename": "crates/ra_editor/src/lib.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b88775af7fdfb06df922325ab48237592d5afecb/crates%2Fra_editor%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88775af7fdfb06df922325ab48237592d5afecb/crates%2Fra_editor%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Flib.rs?ref=b88775af7fdfb06df922325ab48237592d5afecb", "patch": "@@ -21,11 +21,10 @@ pub use self::{\n };\n use ra_text_edit::TextEditBuilder;\n use ra_syntax::{\n-    algo::find_leaf_at_offset,\n-    ast::{self, AstNode},\n-    SourceFileNode,\n+    SourceFile, SyntaxNode, TextRange, TextUnit, Direction,\n     SyntaxKind::{self, *},\n-    SyntaxNodeRef, TextRange, TextUnit, Direction,\n+    ast::{self, AstNode},\n+    algo::find_leaf_at_offset,\n };\n use rustc_hash::FxHashSet;\n \n@@ -49,7 +48,7 @@ pub struct Diagnostic {\n     pub fix: Option<LocalEdit>,\n }\n \n-pub fn matching_brace(file: &SourceFileNode, offset: TextUnit) -> Option<TextUnit> {\n+pub fn matching_brace(file: &SourceFile, offset: TextUnit) -> Option<TextUnit> {\n     const BRACES: &[SyntaxKind] = &[\n         L_CURLY, R_CURLY, L_BRACK, R_BRACK, L_PAREN, R_PAREN, L_ANGLE, R_ANGLE,\n     ];\n@@ -67,7 +66,7 @@ pub fn matching_brace(file: &SourceFileNode, offset: TextUnit) -> Option<TextUni\n     Some(matching_node.range().start())\n }\n \n-pub fn highlight(root: SyntaxNodeRef) -> Vec<HighlightedRange> {\n+pub fn highlight(root: &SyntaxNode) -> Vec<HighlightedRange> {\n     // Visited nodes to handle highlighting priorities\n     let mut highlighted = FxHashSet::default();\n     let mut res = Vec::new();\n@@ -117,26 +116,25 @@ pub fn highlight(root: SyntaxNodeRef) -> Vec<HighlightedRange> {\n     res\n }\n \n-pub fn syntax_tree(file: &SourceFileNode) -> String {\n+pub fn syntax_tree(file: &SourceFile) -> String {\n     ::ra_syntax::utils::dump_tree(file.syntax())\n }\n \n-pub fn find_node_at_offset<'a, N: AstNode<'a>>(\n-    syntax: SyntaxNodeRef<'a>,\n-    offset: TextUnit,\n-) -> Option<N> {\n+pub fn find_node_at_offset<N: AstNode>(syntax: &SyntaxNode, offset: TextUnit) -> Option<&N> {\n     find_leaf_at_offset(syntax, offset).find_map(|leaf| leaf.ancestors().find_map(N::cast))\n }\n \n #[cfg(test)]\n mod tests {\n+    use ra_syntax::AstNode;\n+\n     use crate::test_utils::{add_cursor, assert_eq_dbg, assert_eq_text, extract_offset};\n \n     use super::*;\n \n     #[test]\n     fn test_highlighting() {\n-        let file = SourceFileNode::parse(\n+        let file = SourceFile::parse(\n             r#\"\n // comment\n fn main() {}\n@@ -159,7 +157,7 @@ fn main() {}\n     fn test_matching_brace() {\n         fn do_check(before: &str, after: &str) {\n             let (pos, before) = extract_offset(before);\n-            let file = SourceFileNode::parse(&before);\n+            let file = SourceFile::parse(&before);\n             let new_pos = match matching_brace(&file, pos) {\n                 None => pos,\n                 Some(pos) => pos,"}, {"sha": "8bd57555f513394c0cd73a44af893ff8e306e77b", "filename": "crates/ra_editor/src/structure.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b88775af7fdfb06df922325ab48237592d5afecb/crates%2Fra_editor%2Fsrc%2Fstructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88775af7fdfb06df922325ab48237592d5afecb/crates%2Fra_editor%2Fsrc%2Fstructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fstructure.rs?ref=b88775af7fdfb06df922325ab48237592d5afecb", "patch": "@@ -3,7 +3,7 @@ use crate::TextRange;\n use ra_syntax::{\n     algo::visit::{visitor, Visitor},\n     ast::{self, NameOwner},\n-    AstNode, SourceFileNode, SyntaxKind, SyntaxNodeRef, WalkEvent,\n+    AstNode, SourceFile, SyntaxKind, SyntaxNode, WalkEvent,\n };\n \n #[derive(Debug, Clone)]\n@@ -15,7 +15,7 @@ pub struct StructureNode {\n     pub kind: SyntaxKind,\n }\n \n-pub fn file_structure(file: &SourceFileNode) -> Vec<StructureNode> {\n+pub fn file_structure(file: &SourceFile) -> Vec<StructureNode> {\n     let mut res = Vec::new();\n     let mut stack = Vec::new();\n \n@@ -38,8 +38,8 @@ pub fn file_structure(file: &SourceFileNode) -> Vec<StructureNode> {\n     res\n }\n \n-fn structure_node(node: SyntaxNodeRef) -> Option<StructureNode> {\n-    fn decl<'a, N: NameOwner<'a>>(node: N) -> Option<StructureNode> {\n+fn structure_node(node: &SyntaxNode) -> Option<StructureNode> {\n+    fn decl<N: NameOwner>(node: &N) -> Option<StructureNode> {\n         let name = node.name()?;\n         Some(StructureNode {\n             parent: None,\n@@ -60,7 +60,7 @@ fn structure_node(node: SyntaxNodeRef) -> Option<StructureNode> {\n         .visit(decl::<ast::TypeDef>)\n         .visit(decl::<ast::ConstDef>)\n         .visit(decl::<ast::StaticDef>)\n-        .visit(|im: ast::ImplBlock| {\n+        .visit(|im: &ast::ImplBlock| {\n             let target_type = im.target_type()?;\n             let target_trait = im.target_trait();\n             let label = match target_trait {\n@@ -91,7 +91,7 @@ mod tests {\n \n     #[test]\n     fn test_file_structure() {\n-        let file = SourceFileNode::parse(\n+        let file = SourceFile::parse(\n             r#\"\n struct Foo {\n     x: i32"}, {"sha": "bf40c92c07abb2e4001c94a7c7b4ba62531162c1", "filename": "crates/ra_editor/src/test_utils.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b88775af7fdfb06df922325ab48237592d5afecb/crates%2Fra_editor%2Fsrc%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88775af7fdfb06df922325ab48237592d5afecb/crates%2Fra_editor%2Fsrc%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Ftest_utils.rs?ref=b88775af7fdfb06df922325ab48237592d5afecb", "patch": "@@ -1,15 +1,15 @@\n-use ra_syntax::{SourceFileNode, TextRange, TextUnit};\n+use ra_syntax::{SourceFile, TextRange, TextUnit};\n \n use crate::LocalEdit;\n pub use test_utils::*;\n \n-pub fn check_action<F: Fn(&SourceFileNode, TextUnit) -> Option<LocalEdit>>(\n+pub fn check_action<F: Fn(&SourceFile, TextUnit) -> Option<LocalEdit>>(\n     before: &str,\n     after: &str,\n     f: F,\n ) {\n     let (before_cursor_pos, before) = extract_offset(before);\n-    let file = SourceFileNode::parse(&before);\n+    let file = SourceFile::parse(&before);\n     let result = f(&file, before_cursor_pos).expect(\"code action is not applicable\");\n     let actual = result.edit.apply(&before);\n     let actual_cursor_pos = match result.cursor_position {\n@@ -20,13 +20,13 @@ pub fn check_action<F: Fn(&SourceFileNode, TextUnit) -> Option<LocalEdit>>(\n     assert_eq_text!(after, &actual);\n }\n \n-pub fn check_action_range<F: Fn(&SourceFileNode, TextRange) -> Option<LocalEdit>>(\n+pub fn check_action_range<F: Fn(&SourceFile, TextRange) -> Option<LocalEdit>>(\n     before: &str,\n     after: &str,\n     f: F,\n ) {\n     let (range, before) = extract_range(before);\n-    let file = SourceFileNode::parse(&before);\n+    let file = SourceFile::parse(&before);\n     let result = f(&file, range).expect(\"code action is not applicable\");\n     let actual = result.edit.apply(&before);\n     let actual_cursor_pos = match result.cursor_position {"}, {"sha": "5b260d2ac7475bddafe2e5cfff62d76a1f9a0d55", "filename": "crates/ra_editor/src/typing.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b88775af7fdfb06df922325ab48237592d5afecb/crates%2Fra_editor%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88775af7fdfb06df922325ab48237592d5afecb/crates%2Fra_editor%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Ftyping.rs?ref=b88775af7fdfb06df922325ab48237592d5afecb", "patch": "@@ -5,15 +5,15 @@ use ra_syntax::{\n     algo::{find_covering_node, find_leaf_at_offset, LeafAtOffset},\n     ast,\n     text_utils::intersect,\n-    AstNode, Direction, SourceFileNode, SyntaxKind,\n+    AstNode, Direction, SourceFile, SyntaxKind,\n     SyntaxKind::*,\n-    SyntaxNodeRef, TextRange, TextUnit,\n+    SyntaxNode, TextRange, TextUnit,\n };\n use ra_text_edit::text_utils::contains_offset_nonstrict;\n \n use crate::{find_node_at_offset, LocalEdit, TextEditBuilder};\n \n-pub fn join_lines(file: &SourceFileNode, range: TextRange) -> LocalEdit {\n+pub fn join_lines(file: &SourceFile, range: TextRange) -> LocalEdit {\n     let range = if range.is_empty() {\n         let syntax = file.syntax();\n         let text = syntax.text().slice(range.start()..);\n@@ -59,7 +59,7 @@ pub fn join_lines(file: &SourceFileNode, range: TextRange) -> LocalEdit {\n     }\n }\n \n-pub fn on_enter(file: &SourceFileNode, offset: TextUnit) -> Option<LocalEdit> {\n+pub fn on_enter(file: &SourceFile, offset: TextUnit) -> Option<LocalEdit> {\n     let comment = find_leaf_at_offset(file.syntax(), offset)\n         .left_biased()\n         .and_then(ast::Comment::cast)?;\n@@ -85,7 +85,7 @@ pub fn on_enter(file: &SourceFileNode, offset: TextUnit) -> Option<LocalEdit> {\n     })\n }\n \n-fn node_indent<'a>(file: &'a SourceFileNode, node: SyntaxNodeRef) -> Option<&'a str> {\n+fn node_indent<'a>(file: &'a SourceFile, node: &SyntaxNode) -> Option<&'a str> {\n     let ws = match find_leaf_at_offset(file.syntax(), node.range().start()) {\n         LeafAtOffset::Between(l, r) => {\n             assert!(r == node);\n@@ -105,8 +105,8 @@ fn node_indent<'a>(file: &'a SourceFileNode, node: SyntaxNodeRef) -> Option<&'a\n     Some(&text[pos..])\n }\n \n-pub fn on_eq_typed(file: &SourceFileNode, offset: TextUnit) -> Option<LocalEdit> {\n-    let let_stmt: ast::LetStmt = find_node_at_offset(file.syntax(), offset)?;\n+pub fn on_eq_typed(file: &SourceFile, offset: TextUnit) -> Option<LocalEdit> {\n+    let let_stmt: &ast::LetStmt = find_node_at_offset(file.syntax(), offset)?;\n     if let_stmt.has_semi() {\n         return None;\n     }\n@@ -136,7 +136,7 @@ pub fn on_eq_typed(file: &SourceFileNode, offset: TextUnit) -> Option<LocalEdit>\n     })\n }\n \n-pub fn on_dot_typed(file: &SourceFileNode, offset: TextUnit) -> Option<LocalEdit> {\n+pub fn on_dot_typed(file: &SourceFile, offset: TextUnit) -> Option<LocalEdit> {\n     let before_dot_offset = offset - TextUnit::of_char('.');\n \n     let whitespace = find_leaf_at_offset(file.syntax(), before_dot_offset).left_biased()?;\n@@ -151,7 +151,7 @@ pub fn on_dot_typed(file: &SourceFileNode, offset: TextUnit) -> Option<LocalEdit\n         .skip(1)\n         .next()?;\n \n-    ast::MethodCallExprNode::cast(method_call)?;\n+    ast::MethodCallExpr::cast(method_call)?;\n \n     // find how much the _method call is indented\n     let method_chain_indent = method_call\n@@ -188,7 +188,7 @@ fn last_line_indent_in_whitespace(ws: &str) -> &str {\n \n fn remove_newline(\n     edit: &mut TextEditBuilder,\n-    node: SyntaxNodeRef,\n+    node: &SyntaxNode,\n     node_text: &str,\n     offset: TextUnit,\n ) {\n@@ -266,7 +266,7 @@ fn is_trailing_comma(left: SyntaxKind, right: SyntaxKind) -> bool {\n     }\n }\n \n-fn join_single_expr_block(edit: &mut TextEditBuilder, node: SyntaxNodeRef) -> Option<()> {\n+fn join_single_expr_block(edit: &mut TextEditBuilder, node: &SyntaxNode) -> Option<()> {\n     let block = ast::Block::cast(node.parent()?)?;\n     let block_expr = ast::BlockExpr::cast(block.syntax().parent()?)?;\n     let expr = single_expr(block)?;\n@@ -277,7 +277,7 @@ fn join_single_expr_block(edit: &mut TextEditBuilder, node: SyntaxNodeRef) -> Op\n     Some(())\n }\n \n-fn single_expr(block: ast::Block) -> Option<ast::Expr> {\n+fn single_expr(block: &ast::Block) -> Option<&ast::Expr> {\n     let mut res = None;\n     for child in block.syntax().children() {\n         if let Some(expr) = ast::Expr::cast(child) {\n@@ -297,7 +297,7 @@ fn single_expr(block: ast::Block) -> Option<ast::Expr> {\n     res\n }\n \n-fn join_single_use_tree(edit: &mut TextEditBuilder, node: SyntaxNodeRef) -> Option<()> {\n+fn join_single_use_tree(edit: &mut TextEditBuilder, node: &SyntaxNode) -> Option<()> {\n     let use_tree_list = ast::UseTreeList::cast(node.parent()?)?;\n     let (tree,) = use_tree_list.use_trees().collect_tuple()?;\n     edit.replace(\n@@ -307,7 +307,7 @@ fn join_single_use_tree(edit: &mut TextEditBuilder, node: SyntaxNodeRef) -> Opti\n     Some(())\n }\n \n-fn compute_ws(left: SyntaxNodeRef, right: SyntaxNodeRef) -> &'static str {\n+fn compute_ws(left: &SyntaxNode, right: &SyntaxNode) -> &'static str {\n     match left.kind() {\n         L_PAREN | L_BRACK => return \"\",\n         L_CURLY => {\n@@ -547,7 +547,7 @@ fn foo() {\n \n     fn check_join_lines_sel(before: &str, after: &str) {\n         let (sel, before) = extract_range(before);\n-        let file = SourceFileNode::parse(&before);\n+        let file = SourceFile::parse(&before);\n         let result = join_lines(&file, sel);\n         let actual = result.edit.apply(&before);\n         assert_eq_text!(after, &actual);\n@@ -626,7 +626,7 @@ pub fn handle_find_matching_brace() {\n     fn test_on_eq_typed() {\n         fn do_check(before: &str, after: &str) {\n             let (offset, before) = extract_offset(before);\n-            let file = SourceFileNode::parse(&before);\n+            let file = SourceFile::parse(&before);\n             let result = on_eq_typed(&file, offset).unwrap();\n             let actual = result.edit.apply(&before);\n             assert_eq_text!(after, &actual);\n@@ -670,7 +670,7 @@ fn foo() {\n     fn test_on_dot_typed() {\n         fn do_check(before: &str, after: &str) {\n             let (offset, before) = extract_offset(before);\n-            let file = SourceFileNode::parse(&before);\n+            let file = SourceFile::parse(&before);\n             if let Some(result) = on_eq_typed(&file, offset) {\n                 let actual = result.edit.apply(&before);\n                 assert_eq_text!(after, &actual);\n@@ -779,7 +779,7 @@ fn foo() {\n     fn test_on_enter() {\n         fn apply_on_enter(before: &str) -> Option<String> {\n             let (offset, before) = extract_offset(before);\n-            let file = SourceFileNode::parse(&before);\n+            let file = SourceFile::parse(&before);\n             let result = on_enter(&file, offset)?;\n             let actual = result.edit.apply(&before);\n             let actual = add_cursor(&actual, result.cursor_position.unwrap());"}]}