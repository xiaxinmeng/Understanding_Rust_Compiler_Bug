{"sha": "a87786e3e993564b444763f99dae24cdcb44a791", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4Nzc4NmUzZTk5MzU2NGI0NDQ3NjNmOTlkYWUyNGNkY2I0NGE3OTE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-12T01:04:50Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-15T18:41:15Z"}, "message": "librustc: Remove identifiers named `box`, since it's about to become a keyword.", "tree": {"sha": "266903ba1a444bc9a1d2220055d32910e7aa194f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/266903ba1a444bc9a1d2220055d32910e7aa194f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a87786e3e993564b444763f99dae24cdcb44a791", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a87786e3e993564b444763f99dae24cdcb44a791", "html_url": "https://github.com/rust-lang/rust/commit/a87786e3e993564b444763f99dae24cdcb44a791", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a87786e3e993564b444763f99dae24cdcb44a791/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "html_url": "https://github.com/rust-lang/rust/commit/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0"}], "stats": {"total": 251, "additions": 134, "deletions": 117}, "files": [{"sha": "d829236a4dc5271a7bc17cc8377a52012188d653", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -303,7 +303,7 @@ pub fn opaque_box_body(bcx: @mut Block,\n     let _icx = push_ctxt(\"opaque_box_body\");\n     let ccx = bcx.ccx();\n     let ty = type_of(ccx, body_t);\n-    let ty = Type::box(ccx, &ty);\n+    let ty = Type::smart_ptr(ccx, &ty);\n     let boxptr = PointerCast(bcx, boxptr, ty.ptr_to());\n     GEPi(bcx, boxptr, [0u, abi::box_field_body])\n }\n@@ -385,20 +385,24 @@ pub fn malloc_raw(bcx: @mut Block, t: ty::t, heap: heap) -> Result {\n \n pub struct MallocResult {\n     bcx: @mut Block,\n-    box: ValueRef,\n+    smart_ptr: ValueRef,\n     body: ValueRef\n }\n \n-// malloc_general_dyn: usefully wraps malloc_raw_dyn; allocates a box,\n-// and pulls out the body\n+// malloc_general_dyn: usefully wraps malloc_raw_dyn; allocates a smart\n+// pointer, and pulls out the body\n pub fn malloc_general_dyn(bcx: @mut Block, t: ty::t, heap: heap, size: ValueRef)\n     -> MallocResult {\n     assert!(heap != heap_exchange);\n     let _icx = push_ctxt(\"malloc_general\");\n     let Result {bcx: bcx, val: llbox} = malloc_raw_dyn(bcx, t, heap, size);\n     let body = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n \n-    MallocResult { bcx: bcx, box: llbox, body: body }\n+    MallocResult {\n+        bcx: bcx,\n+        smart_ptr: llbox,\n+        body: body,\n+    }\n }\n \n pub fn malloc_general(bcx: @mut Block, t: ty::t, heap: heap) -> MallocResult {"}, {"sha": "acb308f6eee763bbf6a3262ec1aeecb3d87db79e", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -1683,7 +1683,7 @@ fn boxed_type_metadata(cx: &mut CrateContext,\n         None                    => ~\"BoxedType\"\n     };\n \n-    let box_llvm_type = Type::box(cx, &content_llvm_type);\n+    let box_llvm_type = Type::smart_ptr(cx, &content_llvm_type);\n     let member_llvm_types = box_llvm_type.field_types();\n     assert!(box_layout_is_correct(cx, member_llvm_types, content_llvm_type));\n "}, {"sha": "92c28586dfe62d6ae10fa3021e858078942c2144", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -1396,8 +1396,11 @@ fn trans_unary_datum(bcx: @mut Block,\n             revoke_clean(bcx, val);\n             return immediate_rvalue_bcx(bcx, val, box_ty);\n         } else {\n-            let base::MallocResult { bcx, box: bx, body } =\n-                base::malloc_general(bcx, contents_ty, heap);\n+            let base::MallocResult {\n+                bcx,\n+                smart_ptr: bx,\n+                body\n+            } = base::malloc_general(bcx, contents_ty, heap);\n             add_clean_free(bcx, bx, heap);\n             let bcx = trans_into(bcx, contents, SaveIn(body));\n             revoke_clean(bcx, bx);"}, {"sha": "688a40650653a03e3eba8792282e859af144f06e", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -98,7 +98,7 @@ pub fn alloc_raw(bcx: @mut Block, unit_ty: ty::t,\n         Store(bcx, alloc, GEPi(bcx, val, [0u, abi::vec_elt_alloc]));\n         return rslt(bcx, val);\n     } else {\n-        let base::MallocResult {bcx, box: bx, body} =\n+        let base::MallocResult {bcx, smart_ptr: bx, body} =\n             base::malloc_general_dyn(bcx, vecbodyty, heap, vecsize);\n         Store(bcx, fill, GEPi(bcx, body, [0u, abi::vec_elt_fill]));\n         Store(bcx, alloc, GEPi(bcx, body, [0u, abi::vec_elt_alloc]));"}, {"sha": "4986854dd15f3ea5aa7b255530a101343b142051", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -258,7 +258,7 @@ impl Type {\n         Type::struct_(Type::box_header_fields(ctx), false)\n     }\n \n-    pub fn box(ctx: &CrateContext, ty: &Type) -> Type {\n+    pub fn smart_ptr(ctx: &CrateContext, ty: &Type) -> Type {\n         Type::struct_(Type::box_header_fields(ctx) + &[*ty], false)\n     }\n \n@@ -267,11 +267,11 @@ impl Type {\n     }\n \n     pub fn opaque_box(ctx: &CrateContext) -> Type {\n-        Type::box(ctx, &Type::opaque())\n+        Type::smart_ptr(ctx, &Type::opaque())\n     }\n \n     pub fn unique(ctx: &CrateContext, ty: &Type) -> Type {\n-        Type::box(ctx, ty)\n+        Type::smart_ptr(ctx, ty)\n     }\n \n     pub fn opaque_cbox_ptr(cx: &CrateContext) -> Type {"}, {"sha": "17620a81e51a7a62b039074fc301397d610d6178", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -221,16 +221,18 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n         adt::incomplete_type_of(cx, repr, name)\n       }\n       ty::ty_estr(ty::vstore_box) => {\n-        Type::box(cx, &Type::vec(cx.sess.targ_cfg.arch, &Type::i8())).ptr_to()\n+        Type::smart_ptr(cx,\n+                        &Type::vec(cx.sess.targ_cfg.arch,\n+                                   &Type::i8())).ptr_to()\n       }\n       ty::ty_evec(ref mt, ty::vstore_box) => {\n           let e_ty = type_of(cx, mt.ty);\n           let v_ty = Type::vec(cx.sess.targ_cfg.arch, &e_ty);\n-          Type::box(cx, &v_ty).ptr_to()\n+          Type::smart_ptr(cx, &v_ty).ptr_to()\n       }\n       ty::ty_box(ref mt) => {\n           let ty = type_of(cx, mt.ty);\n-          Type::box(cx, &ty).ptr_to()\n+          Type::smart_ptr(cx, &ty).ptr_to()\n       }\n       ty::ty_opaque_box => Type::opaque_box(cx).ptr_to(),\n       ty::ty_uniq(ref mt) => {"}, {"sha": "7b1d29b664b6d233a0bacda601a76880981fe819", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -25,8 +25,8 @@ use vec::{ImmutableVector, OwnedVector};\n #[inline]\n pub fn capacity<T>(v: @[T]) -> uint {\n     unsafe {\n-        let box = v.repr();\n-        (*box).data.alloc / mem::size_of::<T>()\n+        let managed_box = v.repr();\n+        (*managed_box).data.alloc / mem::size_of::<T>()\n     }\n }\n "}, {"sha": "fde3ed3f0fe6c0164eacc0dda2c52691b2cc370b", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -120,11 +120,11 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_bump_box_refcount() {\n+    fn test_bump_managed_refcount() {\n         unsafe {\n-            let box = @~\"box box box\";       // refcount 1\n-            bump_box_refcount(box);         // refcount 2\n-            let ptr: *int = transmute(box); // refcount 2\n+            let managed = @~\"box box box\";      // refcount 1\n+            bump_managed_refcount(managed);     // refcount 2\n+            let ptr: *int = transmute(managed); // refcount 2\n             let _box1: @~str = ::cast::transmute_copy(&ptr);\n             let _box2: @~str = ::cast::transmute_copy(&ptr);\n             assert!(*_box1 == ~\"box box box\");"}, {"sha": "1a87de6305828d3608927d2ca02b023dc3880bba", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -157,19 +157,19 @@ impl<T: Eq> Eq for RefCell<T> {\n }\n \n /// Wraps a borrowed reference to a value in a `RefCell` box.\n-pub struct Ref<'box, T> {\n-    priv parent: &'box RefCell<T>\n+pub struct Ref<'b, T> {\n+    priv parent: &'b RefCell<T>\n }\n \n #[unsafe_destructor]\n-impl<'box, T> Drop for Ref<'box, T> {\n+impl<'b, T> Drop for Ref<'b, T> {\n     fn drop(&mut self) {\n         assert!(self.parent.borrow != WRITING && self.parent.borrow != UNUSED);\n         unsafe { self.parent.as_mut().borrow -= 1; }\n     }\n }\n \n-impl<'box, T> Ref<'box, T> {\n+impl<'b, T> Ref<'b, T> {\n     /// Retrieve an immutable reference to the stored value.\n     #[inline]\n     pub fn get<'a>(&'a self) -> &'a T {\n@@ -178,19 +178,19 @@ impl<'box, T> Ref<'box, T> {\n }\n \n /// Wraps a mutable borrowed reference to a value in a `RefCell` box.\n-pub struct RefMut<'box, T> {\n-    priv parent: &'box mut RefCell<T>\n+pub struct RefMut<'b, T> {\n+    priv parent: &'b mut RefCell<T>\n }\n \n #[unsafe_destructor]\n-impl<'box, T> Drop for RefMut<'box, T> {\n+impl<'b, T> Drop for RefMut<'b, T> {\n     fn drop(&mut self) {\n         assert!(self.parent.borrow == WRITING);\n         self.parent.borrow = UNUSED;\n     }\n }\n \n-impl<'box, T> RefMut<'box, T> {\n+impl<'b, T> RefMut<'b, T> {\n     /// Retrieve a mutable reference to the stored value.\n     #[inline]\n     pub fn get<'a>(&'a mut self) -> &'a mut T {"}, {"sha": "fbcf7dd4e9026a9ac5d50cec705d059103cfbe69", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -30,26 +30,26 @@ struct AnnihilateStats {\n }\n \n unsafe fn each_live_alloc(read_next_before: bool,\n-                          f: |box: *mut raw::Box<()>, uniq: bool| -> bool)\n+                          f: |alloc: *mut raw::Box<()>, uniq: bool| -> bool)\n                           -> bool {\n     //! Walks the internal list of allocations\n \n     use managed;\n     use rt::local_heap;\n \n-    let mut box = local_heap::live_allocs();\n-    while box != ptr::mut_null() {\n-        let next_before = (*box).next;\n-        let uniq = (*box).ref_count == managed::RC_MANAGED_UNIQUE;\n+    let mut alloc = local_heap::live_allocs();\n+    while alloc != ptr::mut_null() {\n+        let next_before = (*alloc).next;\n+        let uniq = (*alloc).ref_count == managed::RC_MANAGED_UNIQUE;\n \n-        if !f(box as *mut raw::Box<()>, uniq) {\n+        if !f(alloc as *mut raw::Box<()>, uniq) {\n             return false;\n         }\n \n         if read_next_before {\n-            box = next_before;\n+            alloc = next_before;\n         } else {\n-            box = (*box).next;\n+            alloc = (*alloc).next;\n         }\n     }\n     return true;\n@@ -82,12 +82,12 @@ pub unsafe fn annihilate() {\n     //\n     // In this pass, nothing gets freed, so it does not matter whether\n     // we read the next field before or after the callback.\n-    each_live_alloc(true, |box, uniq| {\n+    each_live_alloc(true, |alloc, uniq| {\n         stats.n_total_boxes += 1;\n         if uniq {\n             stats.n_unique_boxes += 1;\n         } else {\n-            (*box).ref_count = managed::RC_IMMORTAL;\n+            (*alloc).ref_count = managed::RC_IMMORTAL;\n         }\n         true\n     });\n@@ -97,10 +97,10 @@ pub unsafe fn annihilate() {\n     // In this pass, unique-managed boxes may get freed, but not\n     // managed boxes, so we must read the `next` field *after* the\n     // callback, as the original value may have been freed.\n-    each_live_alloc(false, |box, uniq| {\n+    each_live_alloc(false, |alloc, uniq| {\n         if !uniq {\n-            let tydesc = (*box).type_desc;\n-            let data = &(*box).data as *();\n+            let tydesc = (*alloc).type_desc;\n+            let data = &(*alloc).data as *();\n             ((*tydesc).drop_glue)(data as *i8);\n         }\n         true\n@@ -112,12 +112,12 @@ pub unsafe fn annihilate() {\n     // unique-managed boxes, though I think that none of those are\n     // left), so we must read the `next` field before, since it will\n     // not be valid after.\n-    each_live_alloc(true, |box, uniq| {\n+    each_live_alloc(true, |alloc, uniq| {\n         if !uniq {\n             stats.n_bytes_freed +=\n-                (*((*box).type_desc)).size\n+                (*((*alloc).type_desc)).size\n                 + mem::size_of::<raw::Box<()>>();\n-            local_free(box as *i8);\n+            local_free(alloc as *i8);\n         }\n         true\n     });"}, {"sha": "87fe5ac6f220bd383b7ccef624c9515314de4cdf", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -157,13 +157,13 @@ pub fn pop<T: 'static>(key: Key<T>) -> Option<T> {\n \n                 // Move `data` into transmute to get out the memory that it\n                 // owns, we must free it manually later.\n-                let (_vtable, box): (uint, ~T) = unsafe {\n+                let (_vtable, alloc): (uint, ~T) = unsafe {\n                     cast::transmute(data)\n                 };\n \n-                // Now that we own `box`, we can just move out of it as we would\n-                // with any other data.\n-                return Some(*box);\n+                // Now that we own `alloc`, we can just move out of it as we\n+                // would with any other data.\n+                return Some(*alloc);\n             }\n             _ => {}\n         }\n@@ -254,8 +254,8 @@ fn get_with<T:'static,\n                     // compiler coercions to achieve a '&' pointer.\n                     unsafe {\n                         match *cast::transmute::<&TLSValue, &(uint, ~T)>(data){\n-                            (_vtable, ref box) => {\n-                                let value: &T = *box;\n+                            (_vtable, ref alloc) => {\n+                                let value: &T = *alloc;\n                                 ret = f(Some(value));\n                             }\n                         }"}, {"sha": "423981d9e918130be2d44b0cf17cad07ab9f59f7", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -28,7 +28,7 @@ static ALL_BITS: uint = FROZEN_BIT | MUT_BIT;\n \n #[deriving(Eq)]\n pub struct BorrowRecord {\n-    priv box: *mut raw::Box<()>,\n+    priv alloc: *mut raw::Box<()>,\n     file: *c_char,\n     priv line: size_t\n }\n@@ -55,8 +55,9 @@ pub fn clear_task_borrow_list() {\n }\n \n #[cold]\n-unsafe fn fail_borrowed(box: *mut raw::Box<()>, file: *c_char, line: size_t) -> ! {\n-    debug_borrow(\"fail_borrowed: \", box, 0, 0, file, line);\n+unsafe fn fail_borrowed(alloc: *mut raw::Box<()>, file: *c_char, line: size_t)\n+                        -> ! {\n+    debug_borrow(\"fail_borrowed: \", alloc, 0, 0, file, line);\n \n     match try_take_task_borrow_list() {\n         None => { // not recording borrows\n@@ -67,7 +68,7 @@ unsafe fn fail_borrowed(box: *mut raw::Box<()>, file: *c_char, line: size_t) ->\n             let mut msg = ~\"borrowed\";\n             let mut sep = \" at \";\n             for entry in borrow_list.rev_iter() {\n-                if entry.box == box {\n+                if entry.alloc == alloc {\n                     msg.push_str(sep);\n                     let filename = str::raw::from_c_str(entry.file);\n                     msg.push_str(filename);\n@@ -153,7 +154,11 @@ pub unsafe fn record_borrow(a: *u8, old_ref_count: uint,\n         debug_borrow(\"record_borrow:\", a, old_ref_count, 0, file, line);\n         swap_task_borrow_list(|borrow_list| {\n             let mut borrow_list = borrow_list;\n-            borrow_list.push(BorrowRecord {box: a, file: file, line: line});\n+            borrow_list.push(BorrowRecord {\n+                alloc: a,\n+                file: file,\n+                line: line,\n+            });\n             borrow_list\n         })\n     }\n@@ -172,7 +177,7 @@ pub unsafe fn unrecord_borrow(a: *u8,\n             let mut borrow_list = borrow_list;\n             assert!(!borrow_list.is_empty());\n             let br = borrow_list.pop();\n-            if br.box != a || br.file != file || br.line != line {\n+            if br.alloc != a || br.file != file || br.line != line {\n                 let err = format!(\"wrong borrow found, br={:?}\", br);\n                 err.with_c_str(|msg_p| {\n                     task::begin_unwind_raw(msg_p, file, line)"}, {"sha": "770fc9ffa12e2972dcd997f0acd027d1c6c6a6c5", "filename": "src/libstd/rt/deque.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibstd%2Frt%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibstd%2Frt%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fdeque.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -599,9 +599,9 @@ mod tests {\n \n         let (threads, hits) = vec::unzip(range(0, NTHREADS).map(|_| {\n             let s = s.clone();\n-            let box = ~AtomicUint::new(0);\n+            let unique_box = ~AtomicUint::new(0);\n             let thread_box = unsafe {\n-                *cast::transmute::<&~AtomicUint, **mut AtomicUint>(&box)\n+                *cast::transmute::<&~AtomicUint,**mut AtomicUint>(&unique_box)\n             };\n             (do Thread::start {\n                 unsafe {\n@@ -617,7 +617,7 @@ mod tests {\n                         }\n                     }\n                 }\n-            }, box)\n+            }, unique_box)\n         }));\n \n         let mut rng = rand::task_rng();"}, {"sha": "385bb0b276c4919802de5ca7c09853fdc8229e21", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -78,10 +78,10 @@ pub unsafe fn closure_exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n     let total_size = get_box_size(size, (*td).align);\n     let p = malloc_raw(total_size as uint);\n \n-    let box = p as *mut raw::Box<()>;\n-    (*box).type_desc = td;\n+    let alloc = p as *mut raw::Box<()>;\n+    (*alloc).type_desc = td;\n \n-    box as *c_char\n+    alloc as *c_char\n }\n \n // NB: Calls to free CANNOT be allowed to fail, as throwing an exception from"}, {"sha": "f2edc6e7ede605b882a07962576acee102e585aa", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -59,22 +59,22 @@ impl LocalHeap {\n \n     pub fn alloc(&mut self, td: *TyDesc, size: uint) -> *mut Box {\n         let total_size = global_heap::get_box_size(size, unsafe { (*td).align });\n-        let box = self.memory_region.malloc(total_size);\n+        let alloc = self.memory_region.malloc(total_size);\n         {\n             // Make sure that we can't use `mybox` outside of this scope\n-            let mybox: &mut Box = unsafe { cast::transmute(box) };\n+            let mybox: &mut Box = unsafe { cast::transmute(alloc) };\n             // Clear out this box, and move it to the front of the live\n             // allocations list\n             mybox.type_desc = td;\n             mybox.ref_count = 1;\n             mybox.prev = ptr::mut_null();\n             mybox.next = self.live_allocs;\n             if !self.live_allocs.is_null() {\n-                unsafe { (*self.live_allocs).prev = box; }\n+                unsafe { (*self.live_allocs).prev = alloc; }\n             }\n-            self.live_allocs = box;\n+            self.live_allocs = alloc;\n         }\n-        return box;\n+        return alloc;\n     }\n \n     pub fn realloc(&mut self, ptr: *mut Box, size: uint) -> *mut Box {\n@@ -97,10 +97,10 @@ impl LocalHeap {\n         return new_box;\n     }\n \n-    pub fn free(&mut self, box: *mut Box) {\n+    pub fn free(&mut self, alloc: *mut Box) {\n         {\n             // Make sure that we can't use `mybox` outside of this scope\n-            let mybox: &mut Box = unsafe { cast::transmute(box) };\n+            let mybox: &mut Box = unsafe { cast::transmute(alloc) };\n             assert!(!mybox.type_desc.is_null());\n \n             // Unlink it from the linked list\n@@ -110,7 +110,7 @@ impl LocalHeap {\n             if !mybox.next.is_null() {\n                 unsafe { (*mybox.next).prev = mybox.prev; }\n             }\n-            if self.live_allocs == box {\n+            if self.live_allocs == alloc {\n                 self.live_allocs = mybox.next;\n             }\n \n@@ -126,7 +126,7 @@ impl LocalHeap {\n             mybox.type_desc = ptr::null();\n         }\n \n-        self.memory_region.free(box);\n+        self.memory_region.free(alloc);\n     }\n }\n \n@@ -175,7 +175,7 @@ impl AllocHeader {\n     #[cfg(not(rtdebug))]\n     fn update_size(&mut self, _size: u32) {}\n \n-    fn box(&mut self) -> *mut Box {\n+    fn as_box(&mut self) -> *mut Box {\n         let myaddr: uint = unsafe { cast::transmute(self) };\n         (myaddr + AllocHeader::size()) as *mut Box\n     }\n@@ -187,8 +187,8 @@ impl AllocHeader {\n         return (header_size + ptr_size - 1) / ptr_size * ptr_size;\n     }\n \n-    fn from(box: *mut Box) -> *mut AllocHeader {\n-        (box as uint - AllocHeader::size()) as *mut AllocHeader\n+    fn from(a_box: *mut Box) -> *mut AllocHeader {\n+        (a_box as uint - AllocHeader::size()) as *mut AllocHeader\n     }\n }\n \n@@ -204,12 +204,12 @@ impl MemoryRegion {\n         self.claim(alloc);\n         self.live_allocations += 1;\n \n-        return alloc.box();\n+        return alloc.as_box();\n     }\n \n-    fn realloc(&mut self, box: *mut Box, size: uint) -> *mut Box {\n-        rtassert!(!box.is_null());\n-        let orig_alloc = AllocHeader::from(box);\n+    fn realloc(&mut self, alloc: *mut Box, size: uint) -> *mut Box {\n+        rtassert!(!alloc.is_null());\n+        let orig_alloc = AllocHeader::from(alloc);\n         unsafe { (*orig_alloc).assert_sane(); }\n \n         let total_size = size + AllocHeader::size();\n@@ -222,12 +222,12 @@ impl MemoryRegion {\n         alloc.assert_sane();\n         alloc.update_size(size as u32);\n         self.update(alloc, orig_alloc as *AllocHeader);\n-        return alloc.box();\n+        return alloc.as_box();\n     }\n \n-    fn free(&mut self, box: *mut Box) {\n-        rtassert!(!box.is_null());\n-        let alloc = AllocHeader::from(box);\n+    fn free(&mut self, alloc: *mut Box) {\n+        rtassert!(!alloc.is_null());\n+        let alloc = AllocHeader::from(alloc);\n         unsafe {\n             (*alloc).assert_sane();\n             self.release(cast::transmute(alloc));"}, {"sha": "be9adc91e031111199e92fc141d272197217dbf3", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -2280,10 +2280,10 @@ pub mod raw {\n      */\n     #[inline]\n     pub unsafe fn init_elem<T>(v: &mut [T], i: uint, val: T) {\n-        let mut box = Some(val);\n+        let mut alloc = Some(val);\n         v.as_mut_buf(|p, _len| {\n             intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i as int)),\n-                                      box.take_unwrap());\n+                                      alloc.take_unwrap());\n         })\n     }\n "}, {"sha": "5138115746e1f7db77aa4bf6006ebf0974212357", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -555,16 +555,18 @@ impl Printer {\n }\n \n // Convenience functions to talk to the printer.\n-pub fn box(p: @mut Printer, indent: uint, b: breaks) {\n+//\n+// \"raw box\"\n+pub fn rbox(p: @mut Printer, indent: uint, b: breaks) {\n     p.pretty_print(BEGIN(begin_t {\n         offset: indent as int,\n         breaks: b\n     }));\n }\n \n-pub fn ibox(p: @mut Printer, indent: uint) { box(p, indent, inconsistent); }\n+pub fn ibox(p: @mut Printer, indent: uint) { rbox(p, indent, inconsistent); }\n \n-pub fn cbox(p: @mut Printer, indent: uint) { box(p, indent, consistent); }\n+pub fn cbox(p: @mut Printer, indent: uint) { rbox(p, indent, consistent); }\n \n pub fn break_offset(p: @mut Printer, n: uint, off: int) {\n     p.pretty_print(BREAK(break_t {"}, {"sha": "568501a73bba8892c0507dfc7e613891c90617a1", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -242,9 +242,10 @@ pub fn cbox(s: @ps, u: uint) {\n     pp::cbox(s.s, u);\n }\n \n-pub fn box(s: @ps, u: uint, b: pp::breaks) {\n+// \"raw box\"\n+pub fn rbox(s: @ps, u: uint, b: pp::breaks) {\n     s.boxes.push(b);\n-    pp::box(s.s, u, b);\n+    pp::rbox(s.s, u, b);\n }\n \n pub fn nbsp(s: @ps) { word(s.s, \" \"); }\n@@ -332,7 +333,7 @@ pub fn synth_comment(s: @ps, text: ~str) {\n }\n \n pub fn commasep<T>(s: @ps, b: breaks, elts: &[T], op: |@ps, &T|) {\n-    box(s, 0u, b);\n+    rbox(s, 0u, b);\n     let mut first = true;\n     for elt in elts.iter() {\n         if first { first = false; } else { word_space(s, \",\"); }\n@@ -348,7 +349,7 @@ pub fn commasep_cmnt<T>(\n                      elts: &[T],\n                      op: |@ps, &T|,\n                      get_span: |&T| -> codemap::Span) {\n-    box(s, 0u, b);\n+    rbox(s, 0u, b);\n     let len = elts.len();\n     let mut i = 0u;\n     for elt in elts.iter() {\n@@ -1771,7 +1772,7 @@ pub fn print_fn_args(s: @ps, decl: &ast::fn_decl,\n                  opt_explicit_self: Option<ast::explicit_self_>) {\n     // It is unfortunate to duplicate the commasep logic, but we want the\n     // self type and the args all in the same box.\n-    box(s, 0u, inconsistent);\n+    rbox(s, 0u, inconsistent);\n     let mut first = true;\n     for explicit_self in opt_explicit_self.iter() {\n         first = !print_explicit_self(s, *explicit_self);\n@@ -2071,7 +2072,7 @@ pub fn print_ty_fn(s: @ps,\n \n     // It is unfortunate to duplicate the commasep logic, but we want the\n     // self type and the args all in the same box.\n-    box(s, 0u, inconsistent);\n+    rbox(s, 0u, inconsistent);\n     let mut first = true;\n     for explicit_self in opt_explicit_self.iter() {\n         first = !print_explicit_self(s, *explicit_self);"}, {"sha": "f0dd20f44958994185fc9824f14cc58bce9b827a", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -46,7 +46,7 @@ type nillist = List<()>;\n // Filled with things that have to be unwound\n \n struct State {\n-    box: @nillist,\n+    managed: @nillist,\n     unique: ~nillist,\n     tuple: (@nillist, ~nillist),\n     vec: ~[@nillist],\n@@ -78,7 +78,7 @@ fn recurse_or_fail(depth: int, st: Option<State>) {\n         let st = match st {\n           None => {\n             State {\n-                box: @Nil,\n+                managed: @Nil,\n                 unique: ~Nil,\n                 tuple: (@Nil, ~Nil),\n                 vec: ~[@Nil],\n@@ -87,7 +87,7 @@ fn recurse_or_fail(depth: int, st: Option<State>) {\n           }\n           Some(st) => {\n             State {\n-                box: @Cons((), st.box),\n+                managed: @Cons((), st.managed),\n                 unique: ~Cons((), @*st.unique),\n                 tuple: (@Cons((), st.tuple.first()),\n                         ~Cons((), @*st.tuple.second())),"}, {"sha": "3719be3612bc07908a6b09f366ba552d7252dc21", "filename": "src/test/compile-fail/regions-infer-borrow-scope-within-loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -12,10 +12,10 @@\n \n fn borrow<'r, T>(x: &'r T) -> &'r T {x}\n \n-fn foo(cond: || -> bool, box: || -> @int) {\n+fn foo(cond: || -> bool, make_box: || -> @int) {\n     let mut y: &int;\n     loop {\n-        let x = box();\n+        let x = make_box();\n \n         // Here we complain because the resulting region\n         // of this borrow is the fn body as a whole."}, {"sha": "0c2693a898b7638cb4bddb00801a84b4cd0f7848", "filename": "src/test/compile-fail/removed-syntax-uniq-mut-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-expr.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn f() {\n-    let box = ~mut 42;\n+    let a_box = ~mut 42;\n     //~^  ERROR found `mut` in ident position\n     //~^^ ERROR expected `;` but found `42`\n }"}, {"sha": "420ee843766bb3ed3aa831b9831e9cd2a9da9af1", "filename": "src/test/run-pass/borrowck-scope-of-deref-issue-4666.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Ftest%2Frun-pass%2Fborrowck-scope-of-deref-issue-4666.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Ftest%2Frun-pass%2Fborrowck-scope-of-deref-issue-4666.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-scope-of-deref-issue-4666.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -29,19 +29,19 @@ fn fun1() {\n     // in the past, borrow checker behaved differently when\n     // init and decl of `v` were distinct\n     let v;\n-    let mut box = Box {x: 0};\n-    box.set(22);\n-    v = *box.get();\n-    box.set(v+1);\n-    assert_eq!(23, *box.get());\n+    let mut a_box = Box {x: 0};\n+    a_box.set(22);\n+    v = *a_box.get();\n+    a_box.set(v+1);\n+    assert_eq!(23, *a_box.get());\n }\n \n fn fun2() {\n-    let mut box = Box {x: 0};\n-    box.set(22);\n-    let v = *box.get();\n-    box.set(v+1);\n-    assert_eq!(23, *box.get());\n+    let mut a_box = Box {x: 0};\n+    a_box.set(22);\n+    let v = *a_box.get();\n+    a_box.set(v+1);\n+    assert_eq!(23, *a_box.get());\n }\n \n pub fn main() {"}, {"sha": "beaa51671c139ea70bcd2b938b7a4b7257ab6c0a", "filename": "src/test/run-pass/boxed-class-type-substitution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Ftest%2Frun-pass%2Fboxed-class-type-substitution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Ftest%2Frun-pass%2Fboxed-class-type-substitution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fboxed-class-type-substitution.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -30,7 +30,7 @@ fn Box() -> Box {\n }\n \n struct LayoutData {\n-    box: Option<@Box>\n+    a_box: Option<@Box>\n }\n \n pub fn main() { }"}, {"sha": "29a972ae30e966198a2955b916535b3068fa8b02", "filename": "src/test/run-pass/cycle-collection.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Ftest%2Frun-pass%2Fcycle-collection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Ftest%2Frun-pass%2Fcycle-collection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcycle-collection.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -16,8 +16,8 @@ enum taggy {\n }\n \n fn f() {\n-    let box = @mut nil;\n-    *box = cons(box);\n+    let a_box = @mut nil;\n+    *a_box = cons(a_box);\n }\n \n pub fn main() {"}, {"sha": "a5f5d56fe06cddd7c3e29ef3e3cc502e8d294eca", "filename": "src/test/run-pass/generic-box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Ftest%2Frun-pass%2Fgeneric-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Ftest%2Frun-pass%2Fgeneric-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-box.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -10,11 +10,11 @@\n \n #[feature(managed_boxes)];\n \n-fn box<T:'static>(x: Box<T>) -> @Box<T> { return @x; }\n+fn box_it<T:'static>(x: Box<T>) -> @Box<T> { return @x; }\n \n struct Box<T> {x: T, y: T, z: T}\n \n pub fn main() {\n-    let x: @Box<int> = box::<int>(Box{x: 1, y: 2, z: 3});\n+    let x: @Box<int> = box_it::<int>(Box{x: 1, y: 2, z: 3});\n     assert_eq!(x.y, 2);\n }"}, {"sha": "3b817b314cf1453927baa77c9912a21f268fe7d4", "filename": "src/test/run-pass/generic-unique.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a87786e3e993564b444763f99dae24cdcb44a791/src%2Ftest%2Frun-pass%2Fgeneric-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87786e3e993564b444763f99dae24cdcb44a791/src%2Ftest%2Frun-pass%2Fgeneric-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-unique.rs?ref=a87786e3e993564b444763f99dae24cdcb44a791", "patch": "@@ -10,9 +10,9 @@\n \n struct Triple<T> { x: T, y: T, z: T }\n \n-fn box<T>(x: Triple<T>) -> ~Triple<T> { return ~x; }\n+fn box_it<T>(x: Triple<T>) -> ~Triple<T> { return ~x; }\n \n pub fn main() {\n-    let x: ~Triple<int> = box::<int>(Triple{x: 1, y: 2, z: 3});\n+    let x: ~Triple<int> = box_it::<int>(Triple{x: 1, y: 2, z: 3});\n     assert_eq!(x.y, 2);\n }"}]}