{"sha": "ad1bfd2f3ef01193937ded389439d3a9452c0323", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkMWJmZDJmM2VmMDExOTM5MzdkZWQzODk0MzlkM2E5NDUyYzAzMjM=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2020-08-14T21:46:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-14T21:46:52Z"}, "message": "Rollup merge of #75501 - poliorcetics:intra-links-std-ffi, r=jyn514\n\nMove to intra doc links in std::ffi\n\nHelps with #75080.\n\n@rustbot modify labels: T-doc, A-intra-doc-links, T-rustdoc", "tree": {"sha": "d49d28050379e9eeb1246f9cd9b8a178e9d302a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d49d28050379e9eeb1246f9cd9b8a178e9d302a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad1bfd2f3ef01193937ded389439d3a9452c0323", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfNwZNCRBK7hj4Ov3rIwAAdHIIAIPeI1RaTxzQUkUAkB6YkUjY\nrOV7Q7yxFtfN1skthEVoyKPDmMdDpZcYtRhdwSpJ1SN+qbhyvGANO+9P6TnzEFtK\nNC7C7i2yF7jduiexOmfsdB3+dRHL6wLwwAwyWJ9V8DcJT59PezYFPWm9q+PoeeKl\nhuu7i4/jWQgCyQ1FZ5lmjnnhMQV+bMEIokz9GYn3dE6Unm3fvncxWD8Alf4as8UY\nPROGUC/dbpVbeJtjEnD2lfSD75G4nSWhL7DihvLFRgzRiroe3IyXT7lEHrfV0gOe\nEzubvNB7fKr9kIbKi3V8nR1ARWAEYgbQJi4xzBQOz+fH2slMbe4fa2qGKpzXPzo=\n=WFIq\n-----END PGP SIGNATURE-----\n", "payload": "tree d49d28050379e9eeb1246f9cd9b8a178e9d302a8\nparent 1cf79eca7905e1cd9766e6bca651d1d1ce4ba4f4\nparent ee4f893e27a6270cd84dcc4a27884d76722cc0fd\nauthor Tyler Mandry <tmandry@gmail.com> 1597441612 -0700\ncommitter GitHub <noreply@github.com> 1597441612 -0700\n\nRollup merge of #75501 - poliorcetics:intra-links-std-ffi, r=jyn514\n\nMove to intra doc links in std::ffi\n\nHelps with #75080.\n\n@rustbot modify labels: T-doc, A-intra-doc-links, T-rustdoc\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad1bfd2f3ef01193937ded389439d3a9452c0323", "html_url": "https://github.com/rust-lang/rust/commit/ad1bfd2f3ef01193937ded389439d3a9452c0323", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad1bfd2f3ef01193937ded389439d3a9452c0323/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cf79eca7905e1cd9766e6bca651d1d1ce4ba4f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cf79eca7905e1cd9766e6bca651d1d1ce4ba4f4", "html_url": "https://github.com/rust-lang/rust/commit/1cf79eca7905e1cd9766e6bca651d1d1ce4ba4f4"}, {"sha": "ee4f893e27a6270cd84dcc4a27884d76722cc0fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee4f893e27a6270cd84dcc4a27884d76722cc0fd", "html_url": "https://github.com/rust-lang/rust/commit/ee4f893e27a6270cd84dcc4a27884d76722cc0fd"}], "stats": {"total": 314, "additions": 81, "deletions": 233}, "files": [{"sha": "11b3f22503e83c6c6c8a474efb6519e94884ebd5", "filename": "library/std/src/ffi/c_str.rs", "status": "modified", "additions": 51, "deletions": 142, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/ad1bfd2f3ef01193937ded389439d3a9452c0323/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1bfd2f3ef01193937ded389439d3a9452c0323/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs?ref=ad1bfd2f3ef01193937ded389439d3a9452c0323", "patch": "@@ -36,23 +36,23 @@ use crate::sys;\n /// example, you can build a `CString` straight out of a [`String`] or\n /// a [`&str`], since both implement that trait).\n ///\n-/// The [`new`] method will actually check that the provided `&[u8]`\n+/// The [`CString::new`] method will actually check that the provided `&[u8]`\n /// does not have 0 bytes in the middle, and return an error if it\n /// finds one.\n ///\n /// # Extracting a raw pointer to the whole C string\n ///\n-/// `CString` implements a [`as_ptr`] method through the [`Deref`]\n+/// `CString` implements a [`as_ptr`][`CStr::as_ptr`] method through the [`Deref`]\n /// trait. This method will give you a `*const c_char` which you can\n /// feed directly to extern functions that expect a nul-terminated\n-/// string, like C's `strdup()`. Notice that [`as_ptr`] returns a\n+/// string, like C's `strdup()`. Notice that [`as_ptr`][`CStr::as_ptr`] returns a\n /// read-only pointer; if the C code writes to it, that causes\n /// undefined behavior.\n ///\n /// # Extracting a slice of the whole C string\n ///\n /// Alternatively, you can obtain a `&[`[`u8`]`]` slice from a\n-/// `CString` with the [`as_bytes`] method. Slices produced in this\n+/// `CString` with the [`CString::as_bytes`] method. Slices produced in this\n /// way do *not* contain the trailing nul terminator. This is useful\n /// when you will be calling an extern function that takes a `*const\n /// u8` argument which is not necessarily nul-terminated, plus another\n@@ -61,28 +61,19 @@ use crate::sys;\n /// [`len`][slice.len] method.\n ///\n /// If you need a `&[`[`u8`]`]` slice *with* the nul terminator, you\n-/// can use [`as_bytes_with_nul`] instead.\n+/// can use [`CString::as_bytes_with_nul`] instead.\n ///\n /// Once you have the kind of slice you need (with or without a nul\n /// terminator), you can call the slice's own\n /// [`as_ptr`][slice.as_ptr] method to get a read-only raw pointer to pass to\n /// extern functions. See the documentation for that function for a\n /// discussion on ensuring the lifetime of the raw pointer.\n ///\n-/// [`Into`]: ../convert/trait.Into.html\n-/// [`Vec`]: ../vec/struct.Vec.html\n-/// [`String`]: ../string/struct.String.html\n-/// [`&str`]: ../primitive.str.html\n-/// [`u8`]: ../primitive.u8.html\n-/// [`new`]: #method.new\n-/// [`as_bytes`]: #method.as_bytes\n-/// [`as_bytes_with_nul`]: #method.as_bytes_with_nul\n-/// [`as_ptr`]: #method.as_ptr\n+/// [`&str`]: str\n /// [slice.as_ptr]: ../primitive.slice.html#method.as_ptr\n /// [slice.len]: ../primitive.slice.html#method.len\n-/// [`Deref`]: ../ops/trait.Deref.html\n-/// [`CStr`]: struct.CStr.html\n-/// [`&CStr`]: struct.CStr.html\n+/// [`Deref`]: ops::Deref\n+/// [`&CStr`]: CStr\n ///\n /// # Examples\n ///\n@@ -114,7 +105,6 @@ use crate::sys;\n /// documentation of `CString` before use, as improper ownership management\n /// of `CString` instances can lead to invalid memory accesses, memory leaks,\n /// and other memory errors.\n-\n #[derive(PartialEq, PartialOrd, Eq, Ord, Hash, Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct CString {\n@@ -138,8 +128,8 @@ pub struct CString {\n ///\n /// Note that this structure is **not** `repr(C)` and is not recommended to be\n /// placed in the signatures of FFI functions. Instead, safe wrappers of FFI\n-/// functions may leverage the unsafe [`from_ptr`] constructor to provide a safe\n-/// interface to other consumers.\n+/// functions may leverage the unsafe [`CStr::from_ptr`] constructor to provide\n+/// a safe interface to other consumers.\n ///\n /// # Examples\n ///\n@@ -190,11 +180,7 @@ pub struct CString {\n /// println!(\"string: {}\", my_string_safe());\n /// ```\n ///\n-/// [`u8`]: ../primitive.u8.html\n-/// [`&str`]: ../primitive.str.html\n-/// [`String`]: ../string/struct.String.html\n-/// [`CString`]: struct.CString.html\n-/// [`from_ptr`]: #method.from_ptr\n+/// [`&str`]: str\n #[derive(Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n // FIXME:\n@@ -219,9 +205,6 @@ pub struct CStr {\n /// This error is created by the [`new`][`CString::new`] method on\n /// [`CString`]. See its documentation for more.\n ///\n-/// [`CString`]: struct.CString.html\n-/// [`CString::new`]: struct.CString.html#method.new\n-///\n /// # Examples\n ///\n /// ```\n@@ -238,12 +221,9 @@ pub struct NulError(usize, Vec<u8>);\n /// The slice used to create a [`CStr`] must have one and only one nul byte,\n /// positioned at the end.\n ///\n-/// This error is created by the [`from_bytes_with_nul`] method on [`CStr`].\n+/// This error is created by the [`CStr::from_bytes_with_nul`] method.\n /// See its documentation for more.\n ///\n-/// [`CStr`]: struct.CStr.html\n-/// [`from_bytes_with_nul`]: struct.CStr.html#method.from_bytes_with_nul\n-///\n /// # Examples\n ///\n /// ```\n@@ -262,12 +242,9 @@ pub struct FromBytesWithNulError {\n /// The vector used to create a [`CString`] must have one and only one nul byte,\n /// positioned at the end.\n ///\n-/// This error is created by the [`from_vec_with_nul`] method on [`CString`].\n+/// This error is created by the [`CString::from_vec_with_nul`] method.\n /// See its documentation for more.\n ///\n-/// [`CString`]: struct.CString.html\n-/// [`from_vec_with_nul`]: struct.CString.html#method.from_vec_with_nul\n-///\n /// # Examples\n ///\n /// ```\n@@ -317,8 +294,6 @@ impl FromVecWithNulError {\n     ///\n     /// assert_eq!(&bytes[..], value.unwrap_err().as_bytes());\n     /// ```\n-    ///\n-    /// [`CString`]: struct.CString.html\n     pub fn as_bytes(&self) -> &[u8] {\n         &self.bytes[..]\n     }\n@@ -344,26 +319,19 @@ impl FromVecWithNulError {\n     ///\n     /// assert_eq!(bytes, value.unwrap_err().into_bytes());\n     /// ```\n-    ///\n-    /// [`CString`]: struct.CString.html\n     pub fn into_bytes(self) -> Vec<u8> {\n         self.bytes\n     }\n }\n \n /// An error indicating invalid UTF-8 when converting a [`CString`] into a [`String`].\n ///\n-/// `CString` is just a wrapper over a buffer of bytes with a nul\n-/// terminator; [`into_string`][`CString::into_string`] performs UTF-8\n-/// validation on those bytes and may return this error.\n+/// `CString` is just a wrapper over a buffer of bytes with a nul terminator;\n+/// [`CString::into_string`] performs UTF-8 validation on those bytes and may\n+/// return this error.\n ///\n-/// This `struct` is created by the\n-/// [`into_string`][`CString::into_string`] method on [`CString`]. See\n+/// This `struct` is created by [`CString::into_string()`]. See\n /// its documentation for more.\n-///\n-/// [`String`]: ../string/struct.String.html\n-/// [`CString`]: struct.CString.html\n-/// [`CString::into_string`]: struct.CString.html#method.into_string\n #[derive(Clone, PartialEq, Eq, Debug)]\n #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n pub struct IntoStringError {\n@@ -399,8 +367,6 @@ impl CString {\n     /// This function will return an error if the supplied bytes contain an\n     /// internal 0 byte. The [`NulError`] returned will contain the bytes as well as\n     /// the position of the nul byte.\n-    ///\n-    /// [`NulError`]: struct.NulError.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new<T: Into<Vec<u8>>>(t: T) -> Result<CString, NulError> {\n         trait SpecIntoVec {\n@@ -440,11 +406,9 @@ impl CString {\n     /// Creates a C-compatible string by consuming a byte vector,\n     /// without checking for interior 0 bytes.\n     ///\n-    /// This method is equivalent to [`new`] except that no runtime assertion\n-    /// is made that `v` contains no 0 bytes, and it requires an actual\n-    /// byte vector, not anything that can be converted to one with Into.\n-    ///\n-    /// [`new`]: #method.new\n+    /// This method is equivalent to [`CString::new`] except that no runtime\n+    /// assertion is made that `v` contains no 0 bytes, and it requires an\n+    /// actual byte vector, not anything that can be converted to one with Into.\n     ///\n     /// # Examples\n     ///\n@@ -463,21 +427,22 @@ impl CString {\n         CString { inner: v.into_boxed_slice() }\n     }\n \n-    /// Retakes ownership of a `CString` that was transferred to C via [`into_raw`].\n+    /// Retakes ownership of a `CString` that was transferred to C via\n+    /// [`CString::into_raw`].\n     ///\n     /// Additionally, the length of the string will be recalculated from the pointer.\n     ///\n     /// # Safety\n     ///\n     /// This should only ever be called with a pointer that was earlier\n-    /// obtained by calling [`into_raw`] on a `CString`. Other usage (e.g., trying to take\n+    /// obtained by calling [`CString::into_raw`]. Other usage (e.g., trying to take\n     /// ownership of a string that was allocated by foreign code) is likely to lead\n     /// to undefined behavior or allocator corruption.\n     ///\n     /// It should be noted that the length isn't just \"recomputed,\" but that\n     /// the recomputed length must match the original length from the\n-    /// [`into_raw`] call. This means the [`into_raw`]/`from_raw` methods\n-    /// should not be used when passing the string to C functions that can\n+    /// [`CString::into_raw`] call. This means the [`CString::into_raw`]/`from_raw`\n+    /// methods should not be used when passing the string to C functions that can\n     /// modify the string's length.\n     ///\n     /// > **Note:** If you need to borrow a string that was allocated by\n@@ -486,9 +451,6 @@ impl CString {\n     /// > make your own provisions for freeing it appropriately, likely\n     /// > with the foreign code's API to do that.\n     ///\n-    /// [`into_raw`]: #method.into_raw\n-    /// [`CStr`]: struct.CStr.html\n-    ///\n     /// # Examples\n     ///\n     /// Creates a `CString`, pass ownership to an `extern` function (via raw pointer), then retake\n@@ -526,18 +488,16 @@ impl CString {\n     /// Consumes the `CString` and transfers ownership of the string to a C caller.\n     ///\n     /// The pointer which this function returns must be returned to Rust and reconstituted using\n-    /// [`from_raw`] to be properly deallocated. Specifically, one\n+    /// [`CString::from_raw`] to be properly deallocated. Specifically, one\n     /// should *not* use the standard C `free()` function to deallocate\n     /// this string.\n     ///\n-    /// Failure to call [`from_raw`] will lead to a memory leak.\n+    /// Failure to call [`CString::from_raw`] will lead to a memory leak.\n     ///\n     /// The C side must **not** modify the length of the string (by writing a\n     /// `NULL` somewhere inside the string or removing the final one) before\n-    /// it makes it back into Rust using [`from_raw`]. See the safety section\n-    /// in [`from_raw`].\n-    ///\n-    /// [`from_raw`]: #method.from_raw\n+    /// it makes it back into Rust using [`CString::from_raw`]. See the safety section\n+    /// in [`CString::from_raw`].\n     ///\n     /// # Examples\n     ///\n@@ -568,8 +528,6 @@ impl CString {\n     ///\n     /// On failure, ownership of the original `CString` is returned.\n     ///\n-    /// [`String`]: ../string/struct.String.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -616,10 +574,8 @@ impl CString {\n         vec\n     }\n \n-    /// Equivalent to the [`into_bytes`] function except that the returned vector\n-    /// includes the trailing nul terminator.\n-    ///\n-    /// [`into_bytes`]: #method.into_bytes\n+    /// Equivalent to [`CString::into_bytes()`] except that the\n+    /// returned vector includes the trailing nul terminator.\n     ///\n     /// # Examples\n     ///\n@@ -640,9 +596,7 @@ impl CString {\n     /// The returned slice does **not** contain the trailing nul\n     /// terminator, and it is guaranteed to not have any interior nul\n     /// bytes. If you need the nul terminator, use\n-    /// [`as_bytes_with_nul`] instead.\n-    ///\n-    /// [`as_bytes_with_nul`]: #method.as_bytes_with_nul\n+    /// [`CString::as_bytes_with_nul`] instead.\n     ///\n     /// # Examples\n     ///\n@@ -659,10 +613,8 @@ impl CString {\n         &self.inner[..self.inner.len() - 1]\n     }\n \n-    /// Equivalent to the [`as_bytes`] function except that the returned slice\n-    /// includes the trailing nul terminator.\n-    ///\n-    /// [`as_bytes`]: #method.as_bytes\n+    /// Equivalent to [`CString::as_bytes()`] except that the\n+    /// returned slice includes the trailing nul terminator.\n     ///\n     /// # Examples\n     ///\n@@ -681,8 +633,6 @@ impl CString {\n \n     /// Extracts a [`CStr`] slice containing the entire string.\n     ///\n-    /// [`CStr`]: struct.CStr.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -701,8 +651,6 @@ impl CString {\n \n     /// Converts this `CString` into a boxed [`CStr`].\n     ///\n-    /// [`CStr`]: struct.CStr.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -719,8 +667,6 @@ impl CString {\n     }\n \n     /// Bypass \"move out of struct which implements [`Drop`] trait\" restriction.\n-    ///\n-    /// [`Drop`]: ../ops/trait.Drop.html\n     fn into_inner(self) -> Box<[u8]> {\n         // Rationale: `mem::forget(self)` invalidates the previous call to `ptr::read(&self.inner)`\n         // so we use `ManuallyDrop` to ensure `self` is not dropped.\n@@ -730,12 +676,12 @@ impl CString {\n         unsafe { ptr::read(&this.inner) }\n     }\n \n-    /// Converts a `Vec` of `u8` to a `CString` without checking the invariants\n-    /// on the given `Vec`.\n+    /// Converts a [`Vec`]`<u8>` to a [`CString`] without checking the\n+    /// invariants on the given [`Vec`].\n     ///\n     /// # Safety\n     ///\n-    /// The given `Vec` **must** have one nul byte as its last element.\n+    /// The given [`Vec`] **must** have one nul byte as its last element.\n     /// This means it cannot be empty nor have any other nul byte anywhere else.\n     ///\n     /// # Example\n@@ -753,10 +699,10 @@ impl CString {\n         Self { inner: v.into_boxed_slice() }\n     }\n \n-    /// Attempts to converts a `Vec` of `u8` to a `CString`.\n+    /// Attempts to converts a [`Vec`]`<u8>` to a [`CString`].\n     ///\n     /// Runtime checks are present to ensure there is only one nul byte in the\n-    /// `Vec`, its last element.\n+    /// [`Vec`], its last element.\n     ///\n     /// # Errors\n     ///\n@@ -765,8 +711,8 @@ impl CString {\n     ///\n     /// # Examples\n     ///\n-    /// A successful conversion will produce the same result as [`new`] when\n-    /// called without the ending nul byte.\n+    /// A successful conversion will produce the same result as [`CString::new`]\n+    /// when called without the ending nul byte.\n     ///\n     /// ```\n     /// #![feature(cstring_from_vec_with_nul)]\n@@ -778,7 +724,7 @@ impl CString {\n     /// );\n     /// ```\n     ///\n-    /// A incorrectly formatted vector will produce an error.\n+    /// A incorrectly formatted [`Vec`] will produce an error.\n     ///\n     /// ```\n     /// #![feature(cstring_from_vec_with_nul)]\n@@ -788,8 +734,6 @@ impl CString {\n     /// // No nul byte\n     /// let _: FromVecWithNulError = CString::from_vec_with_nul(b\"abc\".to_vec()).unwrap_err();\n     /// ```\n-    ///\n-    /// [`new`]: #method.new\n     #[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n     pub fn from_vec_with_nul(v: Vec<u8>) -> Result<Self, FromVecWithNulError> {\n         let nul_pos = memchr::memchr(0, &v);\n@@ -846,9 +790,6 @@ impl From<CString> for Vec<u8> {\n     /// Converts a [`CString`] into a [`Vec`]`<u8>`.\n     ///\n     /// The conversion consumes the [`CString`], and removes the terminating NUL byte.\n-    ///\n-    /// [`Vec`]: ../vec/struct.Vec.html\n-    /// [`CString`]: ../ffi/struct.CString.html\n     #[inline]\n     fn from(s: CString) -> Vec<u8> {\n         s.into_bytes()\n@@ -921,9 +862,6 @@ impl From<Cow<'_, CStr>> for Box<CStr> {\n #[stable(feature = \"c_string_from_box\", since = \"1.18.0\")]\n impl From<Box<CStr>> for CString {\n     /// Converts a [`Box`]`<CStr>` into a [`CString`] without copying or allocating.\n-    ///\n-    /// [`Box`]: ../boxed/struct.Box.html\n-    /// [`CString`]: ../ffi/struct.CString.html\n     #[inline]\n     fn from(s: Box<CStr>) -> CString {\n         s.into_c_string()\n@@ -934,10 +872,6 @@ impl From<Box<CStr>> for CString {\n impl From<Vec<NonZeroU8>> for CString {\n     /// Converts a [`Vec`]`<`[`NonZeroU8`]`>` into a [`CString`] without\n     /// copying nor checking for inner null bytes.\n-    ///\n-    /// [`CString`]: ../ffi/struct.CString.html\n-    /// [`NonZeroU8`]: ../num/struct.NonZeroU8.html\n-    /// [`Vec`]: ../vec/struct.Vec.html\n     #[inline]\n     fn from(v: Vec<NonZeroU8>) -> CString {\n         unsafe {\n@@ -967,9 +901,6 @@ impl Clone for Box<CStr> {\n #[stable(feature = \"box_from_c_string\", since = \"1.20.0\")]\n impl From<CString> for Box<CStr> {\n     /// Converts a [`CString`] into a [`Box`]`<CStr>` without copying or allocating.\n-    ///\n-    /// [`CString`]: ../ffi/struct.CString.html\n-    /// [`Box`]: ../boxed/struct.Box.html\n     #[inline]\n     fn from(s: CString) -> Box<CStr> {\n         s.into_boxed_c_str()\n@@ -1003,9 +934,6 @@ impl<'a> From<&'a CString> for Cow<'a, CStr> {\n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<CString> for Arc<CStr> {\n     /// Converts a [`CString`] into a [`Arc`]`<CStr>` without copying or allocating.\n-    ///\n-    /// [`CString`]: ../ffi/struct.CString.html\n-    /// [`Arc`]: ../sync/struct.Arc.html\n     #[inline]\n     fn from(s: CString) -> Arc<CStr> {\n         let arc: Arc<[u8]> = Arc::from(s.into_inner());\n@@ -1025,9 +953,6 @@ impl From<&CStr> for Arc<CStr> {\n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<CString> for Rc<CStr> {\n     /// Converts a [`CString`] into a [`Rc`]`<CStr>` without copying or allocating.\n-    ///\n-    /// [`CString`]: ../ffi/struct.CString.html\n-    /// [`Rc`]: ../rc/struct.Rc.html\n     #[inline]\n     fn from(s: CString) -> Rc<CStr> {\n         let rc: Rc<[u8]> = Rc::from(s.into_inner());\n@@ -1056,8 +981,6 @@ impl NulError {\n     /// Returns the position of the nul byte in the slice that caused\n     /// [`CString::new`] to fail.\n     ///\n-    /// [`CString::new`]: struct.CString.html#method.new\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1109,9 +1032,6 @@ impl fmt::Display for NulError {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl From<NulError> for io::Error {\n     /// Converts a [`NulError`] into a [`io::Error`].\n-    ///\n-    /// [`NulError`]: ../ffi/struct.NulError.html\n-    /// [`io::Error`]: ../io/struct.Error.html\n     fn from(_: NulError) -> io::Error {\n         io::Error::new(io::ErrorKind::InvalidInput, \"data provided contains a nul byte\")\n     }\n@@ -1162,8 +1082,6 @@ impl fmt::Display for FromVecWithNulError {\n impl IntoStringError {\n     /// Consumes this error, returning original [`CString`] which generated the\n     /// error.\n-    ///\n-    /// [`CString`]: struct.CString.html\n     #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n     pub fn into_cstring(self) -> CString {\n         self.inner\n@@ -1355,7 +1273,8 @@ impl CStr {\n     ///\n     /// This happens because the pointer returned by `as_ptr` does not carry any\n     /// lifetime information and the [`CString`] is deallocated immediately after\n-    /// the `CString::new(\"Hello\").expect(\"CString::new failed\").as_ptr()` expression is evaluated.\n+    /// the `CString::new(\"Hello\").expect(\"CString::new failed\").as_ptr()`\n+    /// expression is evaluated.\n     /// To fix the problem, bind the `CString` to a local variable:\n     ///\n     /// ```no_run\n@@ -1370,10 +1289,8 @@ impl CStr {\n     /// }\n     /// ```\n     ///\n-    /// This way, the lifetime of the `CString` in `hello` encompasses\n+    /// This way, the lifetime of the [`CString`] in `hello` encompasses\n     /// the lifetime of `ptr` and the `unsafe` block.\n-    ///\n-    /// [`CString`]: struct.CString.html\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"const_str_as_ptr\", since = \"1.32.0\")]\n@@ -1407,15 +1324,13 @@ impl CStr {\n \n     /// Converts this C string to a byte slice containing the trailing 0 byte.\n     ///\n-    /// This function is the equivalent of [`to_bytes`] except that it will retain\n-    /// the trailing nul terminator instead of chopping it off.\n+    /// This function is the equivalent of [`CStr::to_bytes`] except that it\n+    /// will retain the trailing nul terminator instead of chopping it off.\n     ///\n     /// > **Note**: This method is currently implemented as a 0-cost cast, but\n     /// > it is planned to alter its definition in the future to perform the\n     /// > length calculation whenever this method is called.\n     ///\n-    /// [`to_bytes`]: #method.to_bytes\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1436,7 +1351,7 @@ impl CStr {\n     /// function will return the corresponding [`&str`] slice. Otherwise,\n     /// it will return an error with details of where UTF-8 validation failed.\n     ///\n-    /// [`&str`]: ../primitive.str.html\n+    /// [`&str`]: str\n     ///\n     /// # Examples\n     ///\n@@ -1464,12 +1379,9 @@ impl CStr {\n     /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD] and return a\n     /// [`Cow`]`::`[`Owned`]`(`[`String`]`)` with the result.\n     ///\n-    /// [`Cow`]: ../borrow/enum.Cow.html\n-    /// [`Borrowed`]: ../borrow/enum.Cow.html#variant.Borrowed\n-    /// [`Owned`]: ../borrow/enum.Cow.html#variant.Owned\n-    /// [`str`]: ../primitive.str.html\n-    /// [`String`]: ../string/struct.String.html\n-    /// [U+FFFD]: ../char/constant.REPLACEMENT_CHARACTER.html\n+    /// [`Borrowed`]: Cow::Borrowed\n+    /// [`Owned`]: Cow::Owned\n+    /// [U+FFFD]: crate::char::REPLACEMENT_CHARACTER\n     ///\n     /// # Examples\n     ///\n@@ -1504,9 +1416,6 @@ impl CStr {\n \n     /// Converts a [`Box`]`<CStr>` into a [`CString`] without copying or allocating.\n     ///\n-    /// [`Box`]: ../boxed/struct.Box.html\n-    /// [`CString`]: struct.CString.html\n-    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "0184495eecf09ffdf59ca11148b34f41f974acd1", "filename": "library/std/src/ffi/mod.rs", "status": "modified", "additions": 15, "deletions": 27, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ad1bfd2f3ef01193937ded389439d3a9452c0323/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1bfd2f3ef01193937ded389439d3a9452c0323/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs?ref=ad1bfd2f3ef01193937ded389439d3a9452c0323", "patch": "@@ -88,7 +88,7 @@\n //! [`env::var_os()`] is used to query environment variables; it\n //! returns an [`Option`]`<`[`OsString`]`>`. If the environment variable\n //! exists you will get a [`Some`]`(os_string)`, which you can *then* try to\n-//! convert to a Rust string. This yields a [`Result<>`], so that\n+//! convert to a Rust string. This yields a [`Result`], so that\n //! your code can detect errors in case the environment variable did\n //! not in fact contain valid Unicode data.\n //!\n@@ -124,34 +124,22 @@\n //! method is an [`OsString`] which can be round-tripped to a Windows\n //! string losslessly.\n //!\n-//! [`String`]: ../string/struct.String.html\n-//! [`str`]: ../primitive.str.html\n-//! [`char`]: ../primitive.char.html\n-//! [`u8`]: ../primitive.u8.html\n-//! [`u16`]: ../primitive.u16.html\n //! [Unicode scalar value]: http://www.unicode.org/glossary/#unicode_scalar_value\n //! [Unicode code point]: http://www.unicode.org/glossary/#code_point\n-//! [`CString`]: struct.CString.html\n-//! [`CStr`]: struct.CStr.html\n-//! [`OsString`]: struct.OsString.html\n-//! [`OsStr`]: struct.OsStr.html\n-//! [`env::set_var()`]: ../env/fn.set_var.html\n-//! [`env::var_os()`]: ../env/fn.var_os.html\n-//! [`Result<>`]: ../result/enum.Result.html\n-//! [unix.OsStringExt]: ../os/unix/ffi/trait.OsStringExt.html\n-//! [`from_vec`]: ../os/unix/ffi/trait.OsStringExt.html#tymethod.from_vec\n-//! [`into_vec`]: ../os/unix/ffi/trait.OsStringExt.html#tymethod.into_vec\n-//! [unix.OsStrExt]: ../os/unix/ffi/trait.OsStrExt.html\n-//! [`from_bytes`]: ../os/unix/ffi/trait.OsStrExt.html#tymethod.from_bytes\n-//! [`as_bytes`]: ../os/unix/ffi/trait.OsStrExt.html#tymethod.as_bytes\n-//! [`OsStrExt`]: ../os/unix/ffi/trait.OsStrExt.html\n-//! [windows.OsStrExt]: ../os/windows/ffi/trait.OsStrExt.html\n-//! [`encode_wide`]: ../os/windows/ffi/trait.OsStrExt.html#tymethod.encode_wide\n-//! [`collect`]: ../iter/trait.Iterator.html#method.collect\n-//! [windows.OsStringExt]: ../os/windows/ffi/trait.OsStringExt.html\n-//! [`from_wide`]: ../os/windows/ffi/trait.OsStringExt.html#tymethod.from_wide\n-//! [`Option`]: ../option/enum.Option.html\n-//! [`Some`]: ../option/enum.Option.html#variant.Some\n+//! [`env::set_var()`]: crate::env::set_var\n+//! [`env::var_os()`]: crate::env::var_os\n+//! [unix.OsStringExt]: crate::os::unix::ffi::OsStringExt\n+//! [`from_vec`]: crate::os::unix::ffi::OsStringExt::from_vec\n+//! [`into_vec`]: crate::os::unix::ffi::OsStringExt::into_vec\n+//! [unix.OsStrExt]: crate::os::unix::ffi::OsStrExt\n+//! [`from_bytes`]: crate::os::unix::ffi::OsStrExt::from_bytes\n+//! [`as_bytes`]: crate::os::unix::ffi::OsStrExt::as_bytes\n+//! [`OsStrExt`]: crate::os::unix::ffi::OsStrExt\n+//! [windows.OsStrExt]: crate::os::windows::ffi::OsStrExt\n+//! [`encode_wide`]: crate::os::windows::ffi::OsStrExt::encode_wide\n+//! [`collect`]: crate::iter::Iterator::collect\n+//! [windows.OsStringExt]: crate::os::windows::ffi::OsStringExt\n+//! [`from_wide`]: crate::os::windows::ffi::OsStringExt::from_wide\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "262d39d98ee2ecc66790141c9cb2b11fe3b96162", "filename": "library/std/src/ffi/os_str.rs", "status": "modified", "additions": 15, "deletions": 64, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/ad1bfd2f3ef01193937ded389439d3a9452c0323/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1bfd2f3ef01193937ded389439d3a9452c0323/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs?ref=ad1bfd2f3ef01193937ded389439d3a9452c0323", "patch": "@@ -47,14 +47,14 @@ use crate::sys_common::{AsInner, FromInner, IntoInner};\n /// create an `OsString` from a normal Rust string.\n ///\n /// **From slices:** Just like you can start with an empty Rust\n-/// [`String`] and then [`push_str`][String.push_str] `&str`\n+/// [`String`] and then [`String::push_str`] `&str`\n /// sub-string slices into it, you can create an empty `OsString` with\n-/// the [`new`] method and then push string slices into it with the\n-/// [`push`] method.\n+/// the [`OsString::new`] method and then push string slices into it with the\n+/// [`OsString::push`] method.\n ///\n /// # Extracting a borrowed reference to the whole OS string\n ///\n-/// You can use the [`as_os_str`] method to get an `&`[`OsStr`] from\n+/// You can use the [`OsString::as_os_str`] method to get an `&`[`OsStr`] from\n /// an `OsString`; this is effectively a borrowed reference to the\n /// whole string.\n ///\n@@ -63,18 +63,9 @@ use crate::sys_common::{AsInner, FromInner, IntoInner};\n /// See the [module's toplevel documentation about conversions][conversions] for a discussion on\n /// the traits which `OsString` implements for [conversions] from/to native representations.\n ///\n-/// [`OsStr`]: struct.OsStr.html\n-/// [`&OsStr`]: struct.OsStr.html\n-/// [`CStr`]: struct.CStr.html\n-/// [`From`]: ../convert/trait.From.html\n-/// [`String`]: ../string/struct.String.html\n-/// [`&str`]: ../primitive.str.html\n-/// [`u8`]: ../primitive.u8.html\n-/// [`u16`]: ../primitive.u16.html\n-/// [String.push_str]: ../string/struct.String.html#method.push_str\n-/// [`new`]: #method.new\n-/// [`push`]: #method.push\n-/// [`as_os_str`]: #method.as_os_str\n+/// [`&OsStr`]: OsStr\n+/// [`&str`]: str\n+/// [`CStr`]: crate::ffi::CStr\n /// [conversions]: index.html#conversions\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -93,9 +84,7 @@ pub struct OsString {\n /// See the [module's toplevel documentation about conversions][conversions] for a discussion on\n /// the traits which `OsStr` implements for [conversions] from/to native representations.\n ///\n-/// [`OsString`]: struct.OsString.html\n-/// [`&str`]: ../primitive.str.html\n-/// [`String`]: ../string/struct.String.html\n+/// [`&str`]: str\n /// [conversions]: index.html#conversions\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n // FIXME:\n@@ -125,8 +114,6 @@ impl OsString {\n \n     /// Converts to an [`OsStr`] slice.\n     ///\n-    /// [`OsStr`]: struct.OsStr.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -145,8 +132,6 @@ impl OsString {\n     ///\n     /// On failure, ownership of the original `OsString` is returned.\n     ///\n-    /// [`String`]: ../../std/string/struct.String.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -163,7 +148,7 @@ impl OsString {\n \n     /// Extends the string with the given [`&OsStr`] slice.\n     ///\n-    /// [`&OsStr`]: struct.OsStr.html\n+    /// [`&OsStr`]: OsStr\n     ///\n     /// # Examples\n     ///\n@@ -333,8 +318,6 @@ impl OsString {\n \n     /// Converts this `OsString` into a boxed [`OsStr`].\n     ///\n-    /// [`OsStr`]: struct.OsStr.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -356,8 +339,6 @@ impl From<String> for OsString {\n     /// Converts a [`String`] into a [`OsString`].\n     ///\n     /// The conversion copies the data, and includes an allocation on the heap.\n-    ///\n-    /// [`OsString`]: ../../std/ffi/struct.OsString.html\n     fn from(s: String) -> OsString {\n         OsString { inner: Buf::from_string(s) }\n     }\n@@ -544,7 +525,7 @@ impl OsStr {\n     ///\n     /// This conversion may entail doing a check for UTF-8 validity.\n     ///\n-    /// [`&str`]: ../../std/primitive.str.html\n+    /// [`&str`]: str\n     ///\n     /// # Examples\n     ///\n@@ -564,9 +545,7 @@ impl OsStr {\n     /// Any non-Unicode sequences are replaced with\n     /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n     ///\n-    /// [`Cow`]: ../../std/borrow/enum.Cow.html\n-    /// [`str`]: ../../std/primitive.str.html\n-    /// [U+FFFD]: ../../std/char/constant.REPLACEMENT_CHARACTER.html\n+    /// [U+FFFD]: crate::char::REPLACEMENT_CHARACTER\n     ///\n     /// # Examples\n     ///\n@@ -613,8 +592,6 @@ impl OsStr {\n \n     /// Copies the slice into an owned [`OsString`].\n     ///\n-    /// [`OsString`]: struct.OsString.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -662,9 +639,6 @@ impl OsStr {\n     /// This number is simply useful for passing to other methods, like\n     /// [`OsString::with_capacity`] to avoid reallocations.\n     ///\n-    /// [`OsString`]: struct.OsString.html\n-    /// [`OsString::with_capacity`]: struct.OsString.html#method.with_capacity\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -682,9 +656,6 @@ impl OsStr {\n     }\n \n     /// Converts a [`Box`]`<OsStr>` into an [`OsString`] without copying or allocating.\n-    ///\n-    /// [`Box`]: ../boxed/struct.Box.html\n-    /// [`OsString`]: struct.OsString.html\n     #[stable(feature = \"into_boxed_os_str\", since = \"1.20.0\")]\n     pub fn into_os_string(self: Box<OsStr>) -> OsString {\n         let boxed = unsafe { Box::from_raw(Box::into_raw(self) as *mut Slice) };\n@@ -706,9 +677,7 @@ impl OsStr {\n     /// but non-ASCII letters are unchanged.\n     ///\n     /// To return a new lowercased value without modifying the existing one, use\n-    /// [`to_ascii_lowercase`].\n-    ///\n-    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n+    /// [`OsStr::to_ascii_lowercase`].\n     ///\n     /// # Examples\n     ///\n@@ -733,9 +702,7 @@ impl OsStr {\n     /// but non-ASCII letters are unchanged.\n     ///\n     /// To return a new uppercased value without modifying the existing one, use\n-    /// [`to_ascii_uppercase`].\n-    ///\n-    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n+    /// [`OsStr::to_ascii_uppercase`].\n     ///\n     /// # Examples\n     ///\n@@ -760,9 +727,7 @@ impl OsStr {\n     /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n     /// but non-ASCII letters are unchanged.\n     ///\n-    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n-    ///\n-    /// [`make_ascii_lowercase`]: #method.make_ascii_lowercase\n+    /// To lowercase the value in-place, use [`OsStr::make_ascii_lowercase`].\n     ///\n     /// # Examples\n     ///\n@@ -784,9 +749,7 @@ impl OsStr {\n     /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n     /// but non-ASCII letters are unchanged.\n     ///\n-    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n-    ///\n-    /// [`make_ascii_uppercase`]: #method.make_ascii_uppercase\n+    /// To uppercase the value in-place, use [`OsStr::make_ascii_uppercase`].\n     ///\n     /// # Examples\n     ///\n@@ -865,9 +828,6 @@ impl From<Cow<'_, OsStr>> for Box<OsStr> {\n impl From<Box<OsStr>> for OsString {\n     /// Converts a [`Box`]`<`[`OsStr`]`>` into a `OsString` without copying or\n     /// allocating.\n-    ///\n-    /// [`Box`]: ../boxed/struct.Box.html\n-    /// [`OsStr`]: ../ffi/struct.OsStr.html\n     fn from(boxed: Box<OsStr>) -> OsString {\n         boxed.into_os_string()\n     }\n@@ -876,9 +836,6 @@ impl From<Box<OsStr>> for OsString {\n #[stable(feature = \"box_from_os_string\", since = \"1.20.0\")]\n impl From<OsString> for Box<OsStr> {\n     /// Converts a [`OsString`] into a [`Box`]`<OsStr>` without copying or allocating.\n-    ///\n-    /// [`Box`]: ../boxed/struct.Box.html\n-    /// [`OsString`]: ../ffi/struct.OsString.html\n     fn from(s: OsString) -> Box<OsStr> {\n         s.into_boxed_os_str()\n     }\n@@ -895,9 +852,6 @@ impl Clone for Box<OsStr> {\n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<OsString> for Arc<OsStr> {\n     /// Converts a [`OsString`] into a [`Arc`]`<OsStr>` without copying or allocating.\n-    ///\n-    /// [`Arc`]: ../sync/struct.Arc.html\n-    /// [`OsString`]: ../ffi/struct.OsString.html\n     #[inline]\n     fn from(s: OsString) -> Arc<OsStr> {\n         let arc = s.inner.into_arc();\n@@ -917,9 +871,6 @@ impl From<&OsStr> for Arc<OsStr> {\n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<OsString> for Rc<OsStr> {\n     /// Converts a [`OsString`] into a [`Rc`]`<OsStr>` without copying or allocating.\n-    ///\n-    /// [`Rc`]: ../rc/struct.Rc.html\n-    /// [`OsString`]: ../ffi/struct.OsString.html\n     #[inline]\n     fn from(s: OsString) -> Rc<OsStr> {\n         let rc = s.inner.into_rc();"}]}