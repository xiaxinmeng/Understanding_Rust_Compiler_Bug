{"sha": "b31038764dbc060b8fcccdee89e5e43072428458", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzMTAzODc2NGRiYzA2MGI4ZmNjY2RlZTg5ZTVlNDMwNzI0Mjg0NTg=", "commit": {"author": {"name": "Martin Wernst\u00e5l", "email": "m4rw3r@gmail.com", "date": "2015-08-16T15:05:18Z"}, "committer": {"name": "Martin Wernst\u00e5l", "email": "m4rw3r@gmail.com", "date": "2015-08-16T20:15:26Z"}, "message": "rustdoc: Pass the Context down to short_stability()", "tree": {"sha": "4d8887b7508129dc59ea97f90528343134574f07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d8887b7508129dc59ea97f90528343134574f07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b31038764dbc060b8fcccdee89e5e43072428458", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b31038764dbc060b8fcccdee89e5e43072428458", "html_url": "https://github.com/rust-lang/rust/commit/b31038764dbc060b8fcccdee89e5e43072428458", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b31038764dbc060b8fcccdee89e5e43072428458/comments", "author": {"login": "m4rw3r", "id": 108100, "node_id": "MDQ6VXNlcjEwODEwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/108100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m4rw3r", "html_url": "https://github.com/m4rw3r", "followers_url": "https://api.github.com/users/m4rw3r/followers", "following_url": "https://api.github.com/users/m4rw3r/following{/other_user}", "gists_url": "https://api.github.com/users/m4rw3r/gists{/gist_id}", "starred_url": "https://api.github.com/users/m4rw3r/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m4rw3r/subscriptions", "organizations_url": "https://api.github.com/users/m4rw3r/orgs", "repos_url": "https://api.github.com/users/m4rw3r/repos", "events_url": "https://api.github.com/users/m4rw3r/events{/privacy}", "received_events_url": "https://api.github.com/users/m4rw3r/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m4rw3r", "id": 108100, "node_id": "MDQ6VXNlcjEwODEwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/108100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m4rw3r", "html_url": "https://github.com/m4rw3r", "followers_url": "https://api.github.com/users/m4rw3r/followers", "following_url": "https://api.github.com/users/m4rw3r/following{/other_user}", "gists_url": "https://api.github.com/users/m4rw3r/gists{/gist_id}", "starred_url": "https://api.github.com/users/m4rw3r/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m4rw3r/subscriptions", "organizations_url": "https://api.github.com/users/m4rw3r/orgs", "repos_url": "https://api.github.com/users/m4rw3r/repos", "events_url": "https://api.github.com/users/m4rw3r/events{/privacy}", "received_events_url": "https://api.github.com/users/m4rw3r/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "440c0f07c3112d14dd3b359af873155a28865592", "url": "https://api.github.com/repos/rust-lang/rust/commits/440c0f07c3112d14dd3b359af873155a28865592", "html_url": "https://github.com/rust-lang/rust/commit/440c0f07c3112d14dd3b359af873155a28865592"}], "stats": {"total": 114, "additions": 58, "deletions": 56}, "files": [{"sha": "dceb052e7960a5b316c6cbb49ce48c8bff550652", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 58, "deletions": 56, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/b31038764dbc060b8fcccdee89e5e43072428458/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31038764dbc060b8fcccdee89e5e43072428458/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=b31038764dbc060b8fcccdee89e5e43072428458", "patch": "@@ -1494,16 +1494,16 @@ impl<'a> fmt::Display for Item<'a> {\n                 item_module(fmt, self.cx, self.item, &m.items)\n             }\n             clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) =>\n-                item_function(fmt, self.item, f),\n+                item_function(fmt, self.cx, self.item, f),\n             clean::TraitItem(ref t) => item_trait(fmt, self.cx, self.item, t),\n-            clean::StructItem(ref s) => item_struct(fmt, self.item, s),\n-            clean::EnumItem(ref e) => item_enum(fmt, self.item, e),\n-            clean::TypedefItem(ref t, _) => item_typedef(fmt, self.item, t),\n-            clean::MacroItem(ref m) => item_macro(fmt, self.item, m),\n-            clean::PrimitiveItem(ref p) => item_primitive(fmt, self.item, p),\n+            clean::StructItem(ref s) => item_struct(fmt, self.cx, self.item, s),\n+            clean::EnumItem(ref e) => item_enum(fmt, self.cx, self.item, e),\n+            clean::TypedefItem(ref t, _) => item_typedef(fmt, self.cx, self.item, t),\n+            clean::MacroItem(ref m) => item_macro(fmt, self.cx, self.item, m),\n+            clean::PrimitiveItem(ref p) => item_primitive(fmt, self.cx, self.item, p),\n             clean::StaticItem(ref i) | clean::ForeignStaticItem(ref i) =>\n-                item_static(fmt, self.item, i),\n-            clean::ConstantItem(ref c) => item_constant(fmt, self.item, c),\n+                item_static(fmt, self.cx, self.item, i),\n+            clean::ConstantItem(ref c) => item_constant(fmt, self.cx, self.item, c),\n             _ => Ok(())\n         }\n     }\n@@ -1546,8 +1546,8 @@ fn plain_summary_line(s: Option<&str>) -> String {\n     markdown::plain_summary_line(&line[..])\n }\n \n-fn document(w: &mut fmt::Formatter, item: &clean::Item) -> fmt::Result {\n-    if let Some(s) = short_stability(item, true) {\n+fn document(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item) -> fmt::Result {\n+    if let Some(s) = short_stability(item, cx, true) {\n         try!(write!(w, \"<div class='stability'>{}</div>\", s));\n     }\n     if let Some(s) = item.doc_value() {\n@@ -1558,7 +1558,7 @@ fn document(w: &mut fmt::Formatter, item: &clean::Item) -> fmt::Result {\n \n fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                item: &clean::Item, items: &[clean::Item]) -> fmt::Result {\n-    try!(document(w, item));\n+    try!(document(w, cx, item));\n \n     let mut indices = (0..items.len()).filter(|i| {\n         !cx.ignore_private_item(&items[*i])\n@@ -1666,7 +1666,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n \n             _ => {\n                 if myitem.name.is_none() { continue }\n-                let stab_docs = if let Some(s) = short_stability(myitem, false) {\n+                let stab_docs = if let Some(s) = short_stability(myitem, cx, false) {\n                     format!(\"[{}]\", s)\n                 } else {\n                     String::new()\n@@ -1694,7 +1694,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n     write!(w, \"</table>\")\n }\n \n-fn short_stability(item: &clean::Item, show_reason: bool) -> Option<String> {\n+fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Option<String> {\n     item.stability.as_ref().and_then(|stab| {\n         let reason = if show_reason && !stab.reason.is_empty() {\n             format!(\": {}\", stab.reason)\n@@ -1729,18 +1729,18 @@ impl<'a> fmt::Display for Initializer<'a> {\n     }\n }\n \n-fn item_constant(w: &mut fmt::Formatter, it: &clean::Item,\n+fn item_constant(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                  c: &clean::Constant) -> fmt::Result {\n     try!(write!(w, \"<pre class='rust const'>{vis}const \\\n                     {name}: {typ}{init}</pre>\",\n            vis = VisSpace(it.visibility),\n            name = it.name.as_ref().unwrap(),\n            typ = c.type_,\n            init = Initializer(&c.expr)));\n-    document(w, it)\n+    document(w, cx, it)\n }\n \n-fn item_static(w: &mut fmt::Formatter, it: &clean::Item,\n+fn item_static(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                s: &clean::Static) -> fmt::Result {\n     try!(write!(w, \"<pre class='rust static'>{vis}static {mutability}\\\n                     {name}: {typ}{init}</pre>\",\n@@ -1749,10 +1749,10 @@ fn item_static(w: &mut fmt::Formatter, it: &clean::Item,\n            name = it.name.as_ref().unwrap(),\n            typ = s.type_,\n            init = Initializer(&s.expr)));\n-    document(w, it)\n+    document(w, cx, it)\n }\n \n-fn item_function(w: &mut fmt::Formatter, it: &clean::Item,\n+fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                  f: &clean::Function) -> fmt::Result {\n     try!(write!(w, \"<pre class='rust fn'>{vis}{unsafety}{abi}{constness}fn \\\n                     {name}{generics}{decl}{where_clause}</pre>\",\n@@ -1764,7 +1764,7 @@ fn item_function(w: &mut fmt::Formatter, it: &clean::Item,\n            generics = f.generics,\n            where_clause = WhereClause(&f.generics),\n            decl = f.decl));\n-    document(w, it)\n+    document(w, cx, it)\n }\n \n fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n@@ -1841,17 +1841,17 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     try!(write!(w, \"</pre>\"));\n \n     // Trait documentation\n-    try!(document(w, it));\n+    try!(document(w, cx, it));\n \n-    fn trait_item(w: &mut fmt::Formatter, m: &clean::Item)\n+    fn trait_item(w: &mut fmt::Formatter, cx: &Context, m: &clean::Item)\n                   -> fmt::Result {\n         try!(write!(w, \"<h3 id='{ty}.{name}' class='method stab {stab}'><code>\",\n                     ty = shortty(m),\n                     name = *m.name.as_ref().unwrap(),\n                     stab = m.stability_class()));\n         try!(render_assoc_item(w, m, AssocItemLink::Anchor));\n         try!(write!(w, \"</code></h3>\"));\n-        try!(document(w, m));\n+        try!(document(w, cx, m));\n         Ok(())\n     }\n \n@@ -1861,7 +1861,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             <div class='methods'>\n         \"));\n         for t in &types {\n-            try!(trait_item(w, *t));\n+            try!(trait_item(w, cx, *t));\n         }\n         try!(write!(w, \"</div>\"));\n     }\n@@ -1872,7 +1872,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             <div class='methods'>\n         \"));\n         for t in &consts {\n-            try!(trait_item(w, *t));\n+            try!(trait_item(w, cx, *t));\n         }\n         try!(write!(w, \"</div>\"));\n     }\n@@ -1884,7 +1884,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             <div class='methods'>\n         \"));\n         for m in &required {\n-            try!(trait_item(w, *m));\n+            try!(trait_item(w, cx, *m));\n         }\n         try!(write!(w, \"</div>\"));\n     }\n@@ -1894,13 +1894,13 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             <div class='methods'>\n         \"));\n         for m in &provided {\n-            try!(trait_item(w, *m));\n+            try!(trait_item(w, cx, *m));\n         }\n         try!(write!(w, \"</div>\"));\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    try!(render_assoc_items(w, it.def_id, AssocItemRender::All));\n+    try!(render_assoc_items(w, cx, it.def_id, AssocItemRender::All));\n \n     let cache = cache();\n     try!(write!(w, \"\n@@ -2012,7 +2012,7 @@ fn render_assoc_item(w: &mut fmt::Formatter, meth: &clean::Item,\n     }\n }\n \n-fn item_struct(w: &mut fmt::Formatter, it: &clean::Item,\n+fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                s: &clean::Struct) -> fmt::Result {\n     try!(write!(w, \"<pre class='rust struct'>\"));\n     try!(render_attributes(w, it));\n@@ -2025,7 +2025,7 @@ fn item_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                        true));\n     try!(write!(w, \"</pre>\"));\n \n-    try!(document(w, it));\n+    try!(document(w, cx, it));\n     let mut fields = s.fields.iter().filter(|f| {\n         match f.inner {\n             clean::StructFieldItem(clean::HiddenStructField) => false,\n@@ -2042,16 +2042,16 @@ fn item_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                                     <code>{name}</code></td><td>\",\n                             stab = field.stability_class(),\n                             name = field.name.as_ref().unwrap()));\n-                try!(document(w, field));\n+                try!(document(w, cx, field));\n                 try!(write!(w, \"</td></tr>\"));\n             }\n             try!(write!(w, \"</table>\"));\n         }\n     }\n-    render_assoc_items(w, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it.def_id, AssocItemRender::All)\n }\n \n-fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n+fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n              e: &clean::Enum) -> fmt::Result {\n     try!(write!(w, \"<pre class='rust enum'>\"));\n     try!(render_attributes(w, it));\n@@ -2104,13 +2104,13 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n     }\n     try!(write!(w, \"</pre>\"));\n \n-    try!(document(w, it));\n+    try!(document(w, cx, it));\n     if !e.variants.is_empty() {\n         try!(write!(w, \"<h2 class='variants'>Variants</h2>\\n<table>\"));\n         for variant in &e.variants {\n             try!(write!(w, \"<tr><td id='variant.{name}'><code>{name}</code></td><td>\",\n                           name = variant.name.as_ref().unwrap()));\n-            try!(document(w, variant));\n+            try!(document(w, cx, variant));\n             match variant.inner {\n                 clean::VariantItem(ref var) => {\n                     match var.kind {\n@@ -2132,7 +2132,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n                                                   <code>{f}</code></td><td>\",\n                                               v = variant.name.as_ref().unwrap(),\n                                               f = field.name.as_ref().unwrap()));\n-                                try!(document(w, field));\n+                                try!(document(w, cx, field));\n                                 try!(write!(w, \"</td></tr>\"));\n                             }\n                             try!(write!(w, \"</table>\"));\n@@ -2147,7 +2147,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n         try!(write!(w, \"</table>\"));\n \n     }\n-    try!(render_assoc_items(w, it.def_id, AssocItemRender::All));\n+    try!(render_assoc_items(w, cx, it.def_id, AssocItemRender::All));\n     Ok(())\n }\n \n@@ -2242,6 +2242,7 @@ enum AssocItemRender<'a> {\n }\n \n fn render_assoc_items(w: &mut fmt::Formatter,\n+                      cx: &Context,\n                       it: ast::DefId,\n                       what: AssocItemRender) -> fmt::Result {\n     let c = cache();\n@@ -2265,7 +2266,7 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n             }\n         };\n         for i in &non_trait {\n-            try!(render_impl(w, i, AssocItemLink::Anchor, render_header));\n+            try!(render_impl(w, cx, i, AssocItemLink::Anchor, render_header));\n         }\n     }\n     if let AssocItemRender::DerefFor { .. } = what {\n@@ -2281,7 +2282,7 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n             }\n         });\n         if let Some(impl_) = deref_impl {\n-            try!(render_deref_methods(w, impl_));\n+            try!(render_deref_methods(w, cx, impl_));\n         }\n         try!(write!(w, \"<h2 id='implementations'>Trait \\\n                           Implementations</h2>\"));\n@@ -2290,22 +2291,22 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n         });\n         for i in &manual {\n             let did = i.trait_did().unwrap();\n-            try!(render_impl(w, i, AssocItemLink::GotoSource(did), true));\n+            try!(render_impl(w, cx, i, AssocItemLink::GotoSource(did), true));\n         }\n         if !derived.is_empty() {\n             try!(write!(w, \"<h3 id='derived_implementations'>\\\n                 Derived Implementations \\\n             </h3>\"));\n             for i in &derived {\n                 let did = i.trait_did().unwrap();\n-                try!(render_impl(w, i, AssocItemLink::GotoSource(did), true));\n+                try!(render_impl(w, cx, i, AssocItemLink::GotoSource(did), true));\n             }\n         }\n     }\n     Ok(())\n }\n \n-fn render_deref_methods(w: &mut fmt::Formatter, impl_: &Impl) -> fmt::Result {\n+fn render_deref_methods(w: &mut fmt::Formatter, cx: &Context, impl_: &Impl) -> fmt::Result {\n     let deref_type = impl_.impl_.trait_.as_ref().unwrap();\n     let target = impl_.impl_.items.iter().filter_map(|item| {\n         match item.inner {\n@@ -2315,12 +2316,12 @@ fn render_deref_methods(w: &mut fmt::Formatter, impl_: &Impl) -> fmt::Result {\n     }).next().expect(\"Expected associated type binding\");\n     let what = AssocItemRender::DerefFor { trait_: deref_type, type_: target };\n     match *target {\n-        clean::ResolvedPath { did, .. } => render_assoc_items(w, did, what),\n+        clean::ResolvedPath { did, .. } => render_assoc_items(w, cx, did, what),\n         _ => {\n             if let Some(prim) = target.primitive_type() {\n                 if let Some(c) = cache().primitive_locations.get(&prim) {\n                     let did = ast::DefId { krate: *c, node: prim.to_node_id() };\n-                    try!(render_assoc_items(w, did, what));\n+                    try!(render_assoc_items(w, cx, did, what));\n                 }\n             }\n             Ok(())\n@@ -2331,7 +2332,7 @@ fn render_deref_methods(w: &mut fmt::Formatter, impl_: &Impl) -> fmt::Result {\n // Render_header is false when we are rendering a `Deref` impl and true\n // otherwise. If render_header is false, we will avoid rendering static\n // methods, since they are not accessible for the type implementing `Deref`\n-fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: AssocItemLink,\n+fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLink,\n                render_header: bool) -> fmt::Result {\n     if render_header {\n         try!(write!(w, \"<h3 class='impl'><code>{}</code></h3>\", i.impl_));\n@@ -2340,7 +2341,7 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: AssocItemLink,\n         }\n     }\n \n-    fn doctraititem(w: &mut fmt::Formatter, item: &clean::Item,\n+    fn doctraititem(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item,\n                     link: AssocItemLink, render_static: bool) -> fmt::Result {\n         match item.inner {\n             clean::MethodItem(..) | clean::TyMethodItem(..) => {\n@@ -2390,7 +2391,7 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: AssocItemLink,\n             if is_static_method(item) && !render_static {\n                 Ok(())\n             } else {\n-                document(w, item)\n+                document(w, cx, item)\n             }\n         } else {\n             Ok(())\n@@ -2407,10 +2408,11 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: AssocItemLink,\n \n     try!(write!(w, \"<div class='impl-items'>\"));\n     for trait_item in &i.impl_.items {\n-        try!(doctraititem(w, trait_item, link, render_header));\n+        try!(doctraititem(w, cx, trait_item, link, render_header));\n     }\n \n     fn render_default_items(w: &mut fmt::Formatter,\n+                            cx: &Context,\n                             did: ast::DefId,\n                             t: &clean::Trait,\n                               i: &clean::Impl,\n@@ -2422,7 +2424,7 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: AssocItemLink,\n                 None => {}\n             }\n \n-            try!(doctraititem(w, trait_item, AssocItemLink::GotoSource(did), render_static));\n+            try!(doctraititem(w, cx, trait_item, AssocItemLink::GotoSource(did), render_static));\n         }\n         Ok(())\n     }\n@@ -2433,23 +2435,23 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: AssocItemLink,\n     // for them work.\n     if let Some(clean::ResolvedPath { did, .. }) = i.impl_.trait_ {\n         if let Some(t) = cache().traits.get(&did) {\n-            try!(render_default_items(w, did, t, &i.impl_, render_header));\n+            try!(render_default_items(w, cx, did, t, &i.impl_, render_header));\n \n         }\n     }\n     try!(write!(w, \"</div>\"));\n     Ok(())\n }\n \n-fn item_typedef(w: &mut fmt::Formatter, it: &clean::Item,\n+fn item_typedef(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 t: &clean::Typedef) -> fmt::Result {\n     try!(write!(w, \"<pre class='rust typedef'>type {}{}{where_clause} = {type_};</pre>\",\n                   it.name.as_ref().unwrap(),\n                   t.generics,\n                   where_clause = WhereClause(&t.generics),\n                   type_ = t.type_));\n \n-    document(w, it)\n+    document(w, cx, it)\n }\n \n impl<'a> fmt::Display for Sidebar<'a> {\n@@ -2520,19 +2522,19 @@ impl<'a> fmt::Display for Source<'a> {\n     }\n }\n \n-fn item_macro(w: &mut fmt::Formatter, it: &clean::Item,\n+fn item_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n               t: &clean::Macro) -> fmt::Result {\n     try!(w.write_str(&highlight::highlight(&t.source,\n                                           Some(\"macro\"),\n                                           None)));\n-    document(w, it)\n+    document(w, cx, it)\n }\n \n-fn item_primitive(w: &mut fmt::Formatter,\n+fn item_primitive(w: &mut fmt::Formatter, cx: &Context,\n                   it: &clean::Item,\n                   _p: &clean::PrimitiveType) -> fmt::Result {\n-    try!(document(w, it));\n-    render_assoc_items(w, it.def_id, AssocItemRender::All)\n+    try!(document(w, cx, it));\n+    render_assoc_items(w, cx, it.def_id, AssocItemRender::All)\n }\n \n fn get_basic_keywords() -> &'static str {"}]}