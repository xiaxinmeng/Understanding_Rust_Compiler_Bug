{"sha": "c00a4648a4cab9659a5712af457d07d42178c5e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwMGE0NjQ4YTRjYWI5NjU5YTU3MTJhZjQ1N2QwN2Q0MjE3OGM1ZTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-16T00:47:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-16T00:47:50Z"}, "message": "Auto merge of #78833 - CDirkx:parse_prefix, r=dtolnay\n\nRefactor and fix `parse_prefix` on Windows\n\nThis PR is an extension of #78692 as well as a general refactor of `parse_prefix`:\n\n**Fixes**:\nThere are two errors in the current implementation of `parse_prefix`:\n\nFirstly, in the current implementation only `\\` is recognized as a separator character in device namespace prefixes. This behavior is only correct for verbatim paths; `\"\\\\.\\C:/foo\"` should be parsed as `\"C:\"` instead of `\"C:/foo\"`.\n\nSecondly, the current implementation only handles single separator characters. In non-verbatim paths a series of separator characters should be recognized as a single boundary, e.g. the UNC path `\"\\\\localhost\\\\\\\\\\\\C$\\foo\"` should be parsed as `\"\\\\localhost\\\\\\\\\\\\C$\"` and then `UNC(server: \"localhost\", share: \"C$\")`, but currently it is not parsed at all, because it starts being parsed as `\\\\localhost\\` and then has an invalid empty share location.\n\nPaths like `\"\\\\.\\C:/foo\"` and `\"\\\\localhost\\\\\\\\\\\\C$\\foo\"` are valid on Windows, they are equivalent to just `\"C:\\foo\"`.\n\n**Refactoring**:\nAll uses of `&[u8]` within `parse_prefix` are extracted to helper functions and`&OsStr` is used instead. This reduces the number of places unsafe is used:\n- `get_first_two_components` is adapted to the more general `parse_next_component` and used in more places\n- code for parsing drive prefixes is extracted to `parse_drive`", "tree": {"sha": "4ac7816081dd4f68a06f47db52e8e26f53d34853", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ac7816081dd4f68a06f47db52e8e26f53d34853"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c00a4648a4cab9659a5712af457d07d42178c5e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c00a4648a4cab9659a5712af457d07d42178c5e0", "html_url": "https://github.com/rust-lang/rust/commit/c00a4648a4cab9659a5712af457d07d42178c5e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c00a4648a4cab9659a5712af457d07d42178c5e0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4031f7b0a8047653f2f989f2d8579bf5650e71ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/4031f7b0a8047653f2f989f2d8579bf5650e71ca", "html_url": "https://github.com/rust-lang/rust/commit/4031f7b0a8047653f2f989f2d8579bf5650e71ca"}, {"sha": "94d73d4403ef98b3b38b8e3035c2eac87fb900f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/94d73d4403ef98b3b38b8e3035c2eac87fb900f9", "html_url": "https://github.com/rust-lang/rust/commit/94d73d4403ef98b3b38b8e3035c2eac87fb900f9"}], "stats": {"total": 225, "additions": 141, "deletions": 84}, "files": [{"sha": "5d93016cadb37ec9efe4c6050d155a0447fac645", "filename": "library/std/src/ffi/os_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c00a4648a4cab9659a5712af457d07d42178c5e0/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c00a4648a4cab9659a5712af457d07d42178c5e0/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs?ref=c00a4648a4cab9659a5712af457d07d42178c5e0", "patch": "@@ -667,10 +667,10 @@ impl OsStr {\n \n     /// Gets the underlying byte representation.\n     ///\n-    /// Note: it is *crucial* that this API is private, to avoid\n+    /// Note: it is *crucial* that this API is not externally public, to avoid\n     /// revealing the internal, platform-specific encodings.\n     #[inline]\n-    fn bytes(&self) -> &[u8] {\n+    pub(crate) fn bytes(&self) -> &[u8] {\n         unsafe { &*(&self.inner as *const _ as *const [u8]) }\n     }\n "}, {"sha": "896d6c2a64c60e34c7459e7bb437b9b749f80471", "filename": "library/std/src/path/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c00a4648a4cab9659a5712af457d07d42178c5e0/library%2Fstd%2Fsrc%2Fpath%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c00a4648a4cab9659a5712af457d07d42178c5e0/library%2Fstd%2Fsrc%2Fpath%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath%2Ftests.rs?ref=c00a4648a4cab9659a5712af457d07d42178c5e0", "patch": "@@ -873,12 +873,12 @@ pub fn test_decompositions_windows() {\n     );\n \n     t!(\"\\\\\\\\.\\\\foo/bar\",\n-    iter: [\"\\\\\\\\.\\\\foo/bar\", \"\\\\\"],\n+    iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\", \"bar\"],\n     has_root: true,\n     is_absolute: true,\n-    parent: None,\n-    file_name: None,\n-    file_stem: None,\n+    parent: Some(\"\\\\\\\\.\\\\foo/\"),\n+    file_name: Some(\"bar\"),\n+    file_stem: Some(\"bar\"),\n     extension: None\n     );\n "}, {"sha": "c10c0df4a3a9908e8aaddf7e4dda86be2aa68724", "filename": "library/std/src/sys/windows/path.rs", "status": "modified", "additions": 104, "deletions": 70, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/c00a4648a4cab9659a5712af457d07d42178c5e0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c00a4648a4cab9659a5712af457d07d42178c5e0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs?ref=c00a4648a4cab9659a5712af457d07d42178c5e0", "patch": "@@ -8,15 +8,12 @@ mod tests;\n pub const MAIN_SEP_STR: &str = \"\\\\\";\n pub const MAIN_SEP: char = '\\\\';\n \n-// The unsafety here stems from converting between `&OsStr` and `&[u8]`\n-// and back. This is safe to do because (1) we only look at ASCII\n-// contents of the encoding and (2) new &OsStr values are produced\n-// only from ASCII-bounded slices of existing &OsStr values.\n-fn os_str_as_u8_slice(s: &OsStr) -> &[u8] {\n-    unsafe { mem::transmute(s) }\n-}\n-unsafe fn u8_slice_as_os_str(s: &[u8]) -> &OsStr {\n-    mem::transmute(s)\n+// Safety: `bytes` must be a valid wtf8 encoded slice\n+#[inline]\n+unsafe fn bytes_as_os_str(bytes: &[u8]) -> &OsStr {\n+    // &OsStr is layout compatible with &Slice, which is compatible with &Wtf8,\n+    // which is compatible with &[u8].\n+    mem::transmute(bytes)\n }\n \n #[inline]\n@@ -29,79 +26,116 @@ pub fn is_verbatim_sep(b: u8) -> bool {\n     b == b'\\\\'\n }\n \n-// In most DOS systems, it is not possible to have more than 26 drive letters.\n-// See <https://en.wikipedia.org/wiki/Drive_letter_assignment#Common_assignments>.\n-pub fn is_valid_drive_letter(disk: u8) -> bool {\n-    disk.is_ascii_alphabetic()\n-}\n-\n pub fn parse_prefix(path: &OsStr) -> Option<Prefix<'_>> {\n     use Prefix::{DeviceNS, Disk, Verbatim, VerbatimDisk, VerbatimUNC, UNC};\n \n-    let path = os_str_as_u8_slice(path);\n-\n-    // \\\\\n-    if let Some(path) = path.strip_prefix(br\"\\\\\") {\n-        // \\\\?\\\n-        if let Some(path) = path.strip_prefix(br\"?\\\") {\n-            // \\\\?\\UNC\\server\\share\n-            if let Some(path) = path.strip_prefix(br\"UNC\\\") {\n-                let (server, share) = match get_first_two_components(path, is_verbatim_sep) {\n-                    Some((server, share)) => unsafe {\n-                        (u8_slice_as_os_str(server), u8_slice_as_os_str(share))\n-                    },\n-                    None => (unsafe { u8_slice_as_os_str(path) }, OsStr::new(\"\")),\n-                };\n-                return Some(VerbatimUNC(server, share));\n+    if let Some(path) = strip_prefix(path, r\"\\\\\") {\n+        // \\\\\n+        if let Some(path) = strip_prefix(path, r\"?\\\") {\n+            // \\\\?\\\n+            if let Some(path) = strip_prefix(path, r\"UNC\\\") {\n+                // \\\\?\\UNC\\server\\share\n+\n+                let (server, path) = parse_next_component(path, true);\n+                let (share, _) = parse_next_component(path, true);\n+\n+                Some(VerbatimUNC(server, share))\n             } else {\n-                // \\\\?\\path\n-                match path {\n-                    // \\\\?\\C:\\path\n-                    [c, b':', b'\\\\', ..] if is_valid_drive_letter(*c) => {\n-                        return Some(VerbatimDisk(c.to_ascii_uppercase()));\n-                    }\n-                    // \\\\?\\cat_pics\n-                    _ => {\n-                        let idx = path.iter().position(|&b| b == b'\\\\').unwrap_or(path.len());\n-                        let slice = &path[..idx];\n-                        return Some(Verbatim(unsafe { u8_slice_as_os_str(slice) }));\n-                    }\n+                let (prefix, _) = parse_next_component(path, true);\n+\n+                // in verbatim paths only recognize an exact drive prefix\n+                if let Some(drive) = parse_drive_exact(prefix) {\n+                    // \\\\?\\C:\n+                    Some(VerbatimDisk(drive))\n+                } else {\n+                    // \\\\?\\prefix\n+                    Some(Verbatim(prefix))\n                 }\n             }\n-        } else if let Some(path) = path.strip_prefix(b\".\\\\\") {\n+        } else if let Some(path) = strip_prefix(path, r\".\\\") {\n             // \\\\.\\COM42\n-            let idx = path.iter().position(|&b| b == b'\\\\').unwrap_or(path.len());\n-            let slice = &path[..idx];\n-            return Some(DeviceNS(unsafe { u8_slice_as_os_str(slice) }));\n-        }\n-        match get_first_two_components(path, is_sep_byte) {\n-            Some((server, share)) if !server.is_empty() && !share.is_empty() => {\n+            let (prefix, _) = parse_next_component(path, false);\n+            Some(DeviceNS(prefix))\n+        } else {\n+            let (server, path) = parse_next_component(path, false);\n+            let (share, _) = parse_next_component(path, false);\n+\n+            if !server.is_empty() && !share.is_empty() {\n                 // \\\\server\\share\n-                return Some(unsafe { UNC(u8_slice_as_os_str(server), u8_slice_as_os_str(share)) });\n+                Some(UNC(server, share))\n+            } else {\n+                // no valid prefix beginning with \"\\\\\" recognized\n+                None\n             }\n-            _ => {}\n         }\n-    } else if let [c, b':', ..] = path {\n+    } else if let Some(drive) = parse_drive(path) {\n         // C:\n-        if is_valid_drive_letter(*c) {\n-            return Some(Disk(c.to_ascii_uppercase()));\n-        }\n+        Some(Disk(drive))\n+    } else {\n+        // no prefix\n+        None\n     }\n-    None\n }\n \n-/// Returns the first two path components with predicate `f`.\n-///\n-/// The two components returned will be use by caller\n-/// to construct `VerbatimUNC` or `UNC` Windows path prefix.\n-///\n-/// Returns [`None`] if there are no separators in path.\n-fn get_first_two_components(path: &[u8], f: fn(u8) -> bool) -> Option<(&[u8], &[u8])> {\n-    let idx = path.iter().position(|&x| f(x))?;\n-    // Panic safe\n-    // The max `idx+1` is `path.len()` and `path[path.len()..]` is a valid index.\n-    let (first, path) = (&path[..idx], &path[idx + 1..]);\n-    let idx = path.iter().position(|&x| f(x)).unwrap_or(path.len());\n-    let second = &path[..idx];\n-    Some((first, second))\n+// Parses a drive prefix, e.g. \"C:\" and \"C:\\whatever\"\n+fn parse_drive(prefix: &OsStr) -> Option<u8> {\n+    // In most DOS systems, it is not possible to have more than 26 drive letters.\n+    // See <https://en.wikipedia.org/wiki/Drive_letter_assignment#Common_assignments>.\n+    fn is_valid_drive_letter(drive: &u8) -> bool {\n+        drive.is_ascii_alphabetic()\n+    }\n+\n+    match prefix.bytes() {\n+        [drive, b':', ..] if is_valid_drive_letter(drive) => Some(drive.to_ascii_uppercase()),\n+        _ => None,\n+    }\n+}\n+\n+// Parses a drive prefix exactly, e.g. \"C:\"\n+fn parse_drive_exact(prefix: &OsStr) -> Option<u8> {\n+    // only parse two bytes: the drive letter and the drive separator\n+    if prefix.len() == 2 { parse_drive(prefix) } else { None }\n+}\n+\n+fn strip_prefix<'a>(path: &'a OsStr, prefix: &str) -> Option<&'a OsStr> {\n+    // `path` and `prefix` are valid wtf8 and utf8 encoded slices respectively, `path[prefix.len()]`\n+    // is thus a code point boundary and `path[prefix.len()..]` is a valid wtf8 encoded slice.\n+    match path.bytes().strip_prefix(prefix.as_bytes()) {\n+        Some(path) => unsafe { Some(bytes_as_os_str(path)) },\n+        None => None,\n+    }\n+}\n+\n+// Parse the next path component.\n+//\n+// Returns the next component and the rest of the path excluding the component and separator.\n+// Does not recognize `/` as a separator character if `verbatim` is true.\n+fn parse_next_component(path: &OsStr, verbatim: bool) -> (&OsStr, &OsStr) {\n+    let separator = if verbatim { is_verbatim_sep } else { is_sep_byte };\n+\n+    match path.bytes().iter().position(|&x| separator(x)) {\n+        Some(separator_start) => {\n+            let mut separator_end = separator_start + 1;\n+\n+            // a series of multiple separator characters is treated as a single separator,\n+            // except in verbatim paths\n+            while !verbatim && separator_end < path.len() && separator(path.bytes()[separator_end])\n+            {\n+                separator_end += 1;\n+            }\n+\n+            let component = &path.bytes()[..separator_start];\n+\n+            // Panic safe\n+            // The max `separator_end` is `bytes.len()` and `bytes[bytes.len()..]` is a valid index.\n+            let path = &path.bytes()[separator_end..];\n+\n+            // Safety: `path` is a valid wtf8 encoded slice and each of the separators ('/', '\\')\n+            // is encoded in a single byte, therefore `bytes[separator_start]` and\n+            // `bytes[separator_end]` must be code point boundaries and thus\n+            // `bytes[..separator_start]` and `bytes[separator_end..]` are valid wtf8 slices.\n+            unsafe { (bytes_as_os_str(component), bytes_as_os_str(path)) }\n+        }\n+        None => (path, OsStr::new(\"\")),\n+    }\n }"}, {"sha": "9675da6ff883bd0bbeeec68bf900a44ca9ba8cd4", "filename": "library/std/src/sys/windows/path/tests.rs", "status": "modified", "additions": 31, "deletions": 8, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c00a4648a4cab9659a5712af457d07d42178c5e0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c00a4648a4cab9659a5712af457d07d42178c5e0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath%2Ftests.rs?ref=c00a4648a4cab9659a5712af457d07d42178c5e0", "patch": "@@ -1,21 +1,44 @@\n use super::*;\n \n #[test]\n-fn test_get_first_two_components() {\n+fn test_parse_next_component() {\n     assert_eq!(\n-        get_first_two_components(br\"server\\share\", is_verbatim_sep),\n-        Some((&b\"server\"[..], &b\"share\"[..])),\n+        parse_next_component(OsStr::new(r\"server\\share\"), true),\n+        (OsStr::new(r\"server\"), OsStr::new(r\"share\"))\n     );\n \n     assert_eq!(\n-        get_first_two_components(br\"server\\\", is_verbatim_sep),\n-        Some((&b\"server\"[..], &b\"\"[..]))\n+        parse_next_component(OsStr::new(r\"server/share\"), true),\n+        (OsStr::new(r\"server/share\"), OsStr::new(r\"\"))\n     );\n \n     assert_eq!(\n-        get_first_two_components(br\"\\server\\\", is_verbatim_sep),\n-        Some((&b\"\"[..], &b\"server\"[..]))\n+        parse_next_component(OsStr::new(r\"server/share\"), false),\n+        (OsStr::new(r\"server\"), OsStr::new(r\"share\"))\n     );\n \n-    assert_eq!(get_first_two_components(br\"there are no separators here\", is_verbatim_sep), None,);\n+    assert_eq!(\n+        parse_next_component(OsStr::new(r\"server\\\"), false),\n+        (OsStr::new(r\"server\"), OsStr::new(r\"\"))\n+    );\n+\n+    assert_eq!(\n+        parse_next_component(OsStr::new(r\"\\server\\\"), false),\n+        (OsStr::new(r\"\"), OsStr::new(r\"server\\\"))\n+    );\n+\n+    assert_eq!(\n+        parse_next_component(OsStr::new(r\"servershare\"), false),\n+        (OsStr::new(r\"servershare\"), OsStr::new(\"\"))\n+    );\n+\n+    assert_eq!(\n+        parse_next_component(OsStr::new(r\"server/\\//\\/\\\\\\\\/////\\/share\"), false),\n+        (OsStr::new(r\"server\"), OsStr::new(r\"share\"))\n+    );\n+\n+    assert_eq!(\n+        parse_next_component(OsStr::new(r\"server\\\\\\\\\\\\\\\\\\\\\\\\\\\\share\"), true),\n+        (OsStr::new(r\"server\"), OsStr::new(r\"\\\\\\\\\\\\\\\\\\\\\\\\\\share\"))\n+    );\n }"}]}