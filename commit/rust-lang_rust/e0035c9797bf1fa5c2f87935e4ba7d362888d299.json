{"sha": "e0035c9797bf1fa5c2f87935e4ba7d362888d299", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwMDM1Yzk3OTdiZjFmYTVjMmY4NzkzNWU0YmE3ZDM2Mjg4OGQyOTk=", "commit": {"author": {"name": "Vincent Prouillet", "email": "vincent@wearewizards.io", "date": "2016-08-05T15:27:40Z"}, "committer": {"name": "Vincent Prouillet", "email": "vincent@wearewizards.io", "date": "2016-08-05T19:10:27Z"}, "message": "Update error message for E0323, E0324 and E0325", "tree": {"sha": "ec3450b749fd5dc5c9deae5aa94b1d433751cb5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec3450b749fd5dc5c9deae5aa94b1d433751cb5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0035c9797bf1fa5c2f87935e4ba7d362888d299", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0035c9797bf1fa5c2f87935e4ba7d362888d299", "html_url": "https://github.com/rust-lang/rust/commit/e0035c9797bf1fa5c2f87935e4ba7d362888d299", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0035c9797bf1fa5c2f87935e4ba7d362888d299/comments", "author": null, "committer": null, "parents": [{"sha": "271d048523b6c1b0e773d9e5cc76bbb997cc180c", "url": "https://api.github.com/repos/rust-lang/rust/commits/271d048523b6c1b0e773d9e5cc76bbb997cc180c", "html_url": "https://github.com/rust-lang/rust/commit/271d048523b6c1b0e773d9e5cc76bbb997cc180c"}], "stats": {"total": 38, "additions": 30, "deletions": 8}, "files": [{"sha": "f384ae2b88e1d0dd394f808fc760e674ccfce2d3", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e0035c9797bf1fa5c2f87935e4ba7d362888d299/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0035c9797bf1fa5c2f87935e4ba7d362888d299/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e0035c9797bf1fa5c2f87935e4ba7d362888d299", "patch": "@@ -993,7 +993,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n     for impl_item in impl_items {\n-        let ty_impl_item = ccx.tcx.impl_or_trait_item(ccx.tcx.map.local_def_id(impl_item.id));\n+        let ty_impl_item = tcx.impl_or_trait_item(tcx.map.local_def_id(impl_item.id));\n         let ty_trait_item = trait_items.iter()\n             .find(|ac| ac.name() == ty_impl_item.name());\n \n@@ -1014,11 +1014,18 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                            trait_const,\n                                            &impl_trait_ref);\n                     } else {\n-                        span_err!(tcx.sess, impl_item.span, E0323,\n+                         let mut err = struct_span_err!(tcx.sess, impl_item.span, E0323,\n                                   \"item `{}` is an associated const, \\\n                                   which doesn't match its trait `{:?}`\",\n                                   impl_const.name,\n-                                  impl_trait_ref)\n+                                  impl_trait_ref);\n+                         err.span_label(impl_item.span, &format!(\"does not match trait\"));\n+                         // We can only get the spans from local trait definition\n+                         // Same for E0324 and E0325\n+                         if let Some(trait_span) = tcx.map.span_if_local(ty_trait_item.def_id()) {\n+                            err.span_label(trait_span, &format!(\"original trait requirement\"));\n+                         }\n+                         err.emit()\n                     }\n                 }\n                 hir::ImplItemKind::Method(ref sig, ref body) => {\n@@ -1037,11 +1044,16 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                             &trait_method,\n                                             &impl_trait_ref);\n                     } else {\n-                        span_err!(tcx.sess, impl_item.span, E0324,\n+                        let mut err = struct_span_err!(tcx.sess, impl_item.span, E0324,\n                                   \"item `{}` is an associated method, \\\n                                   which doesn't match its trait `{:?}`\",\n                                   impl_method.name,\n-                                  impl_trait_ref)\n+                                  impl_trait_ref);\n+                         err.span_label(impl_item.span, &format!(\"does not match trait\"));\n+                         if let Some(trait_span) = tcx.map.span_if_local(ty_trait_item.def_id()) {\n+                            err.span_label(trait_span, &format!(\"original trait requirement\"));\n+                         }\n+                         err.emit()\n                     }\n                 }\n                 hir::ImplItemKind::Type(_) => {\n@@ -1055,11 +1067,16 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             overridden_associated_type = Some(impl_item);\n                         }\n                     } else {\n-                        span_err!(tcx.sess, impl_item.span, E0325,\n+                        let mut err = struct_span_err!(tcx.sess, impl_item.span, E0325,\n                                   \"item `{}` is an associated type, \\\n                                   which doesn't match its trait `{:?}`\",\n                                   impl_type.name,\n-                                  impl_trait_ref)\n+                                  impl_trait_ref);\n+                         err.span_label(impl_item.span, &format!(\"does not match trait\"));\n+                         if let Some(trait_span) = tcx.map.span_if_local(ty_trait_item.def_id()) {\n+                            err.span_label(trait_span, &format!(\"original trait requirement\"));\n+                         }\n+                         err.emit()\n                     }\n                 }\n             }"}, {"sha": "6452e50d0893ea9b3bc44ea22f1857eeb435b0c0", "filename": "src/test/compile-fail/impl-wrong-item-for-trait.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e0035c9797bf1fa5c2f87935e4ba7d362888d299/src%2Ftest%2Fcompile-fail%2Fimpl-wrong-item-for-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0035c9797bf1fa5c2f87935e4ba7d362888d299/src%2Ftest%2Fcompile-fail%2Fimpl-wrong-item-for-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-wrong-item-for-trait.rs?ref=e0035c9797bf1fa5c2f87935e4ba7d362888d299", "patch": "@@ -12,7 +12,9 @@\n \n trait Foo {\n     fn bar(&self);\n-    const MY_CONST: u32;\n+    //~^ NOTE original trait requirement\n+    //~| NOTE original trait requirement\n+    const MY_CONST: u32; //~ NOTE original trait requirement\n }\n \n pub struct FooConstForMethod;\n@@ -21,6 +23,7 @@ impl Foo for FooConstForMethod {\n     //~^ ERROR E0046\n     const bar: u64 = 1;\n     //~^ ERROR E0323\n+    //~| NOTE does not match trait\n     const MY_CONST: u32 = 1;\n }\n \n@@ -31,6 +34,7 @@ impl Foo for FooMethodForConst {\n     fn bar(&self) {}\n     fn MY_CONST() {}\n     //~^ ERROR E0324\n+    //~| NOTE does not match trait\n }\n \n pub struct FooTypeForMethod;\n@@ -39,6 +43,7 @@ impl Foo for FooTypeForMethod {\n     //~^ ERROR E0046\n     type bar = u64;\n     //~^ ERROR E0325\n+    //~| NOTE does not match trait\n     const MY_CONST: u32 = 1;\n }\n "}]}