{"sha": "26714219f1c5f8c748f95198d0824551ea2e0eeb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2NzE0MjE5ZjFjNWY4Yzc0OGY5NTE5OGQwODI0NTUxZWEyZTBlZWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-29T21:46:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-29T21:46:15Z"}, "message": "Auto merge of #58846 - bjorn3:misc_cg_ssa_refactor, r=eddyb\n\nMisc refactorings to rustc_codegen_ssa\n\nUnlike #56636 this doesn't split `BuilderMethods` into a lot of traits. That makes this PR twice as small and the split turned out to not be very useful anyway.\n\nr? @eddyb", "tree": {"sha": "5cc73d0687b6f0cfc81bdc88e9f880075dc13adf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cc73d0687b6f0cfc81bdc88e9f880075dc13adf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26714219f1c5f8c748f95198d0824551ea2e0eeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26714219f1c5f8c748f95198d0824551ea2e0eeb", "html_url": "https://github.com/rust-lang/rust/commit/26714219f1c5f8c748f95198d0824551ea2e0eeb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26714219f1c5f8c748f95198d0824551ea2e0eeb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e782d790f1b63d82af39248bebe027f92d891bcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/e782d790f1b63d82af39248bebe027f92d891bcc", "html_url": "https://github.com/rust-lang/rust/commit/e782d790f1b63d82af39248bebe027f92d891bcc"}, {"sha": "35705dee7eb10783280e0be92aedfc187e019dd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/35705dee7eb10783280e0be92aedfc187e019dd2", "html_url": "https://github.com/rust-lang/rust/commit/35705dee7eb10783280e0be92aedfc187e019dd2"}], "stats": {"total": 1452, "additions": 693, "deletions": 759}, "files": [{"sha": "3a0d9e1334cf6b6783af1f44501809bacecbbb02", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -859,4 +859,8 @@ impl AbiBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     ) {\n         ty.apply_attrs_callsite(self, callsite)\n     }\n+\n+    fn get_param(&self, index: usize) -> Self::Value {\n+        llvm::get_param(self.llfn(), index as c_uint)\n+    }\n }"}, {"sha": "100a896ea0c7d703a6312dbc6636cdad98707fcb", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -10,7 +10,7 @@ use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::mir::operand::OperandValue;\n \n-use std::ffi::CString;\n+use std::ffi::{CStr, CString};\n use libc::{c_uint, c_char};\n \n \n@@ -73,7 +73,8 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n \n         let asm = CString::new(ia.asm.as_str().as_bytes()).unwrap();\n         let constraint_cstr = CString::new(all_constraints).unwrap();\n-        let r = self.inline_asm_call(\n+        let r = inline_asm_call(\n+            self,\n             &asm,\n             &constraint_cstr,\n             &inputs,\n@@ -119,3 +120,46 @@ impl AsmMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n }\n+\n+fn inline_asm_call(\n+    bx: &mut Builder<'a, 'll, 'tcx>,\n+    asm: &CStr,\n+    cons: &CStr,\n+    inputs: &[&'ll Value],\n+    output: &'ll llvm::Type,\n+    volatile: bool,\n+    alignstack: bool,\n+    dia: ::syntax::ast::AsmDialect,\n+) -> Option<&'ll Value> {\n+    let volatile = if volatile { llvm::True }\n+                    else        { llvm::False };\n+    let alignstack = if alignstack { llvm::True }\n+                        else          { llvm::False };\n+\n+    let argtys = inputs.iter().map(|v| {\n+        debug!(\"Asm Input Type: {:?}\", *v);\n+        bx.cx.val_ty(*v)\n+    }).collect::<Vec<_>>();\n+\n+    debug!(\"Asm Output Type: {:?}\", output);\n+    let fty = bx.cx.type_func(&argtys[..], output);\n+    unsafe {\n+        // Ask LLVM to verify that the constraints are well-formed.\n+        let constraints_ok = llvm::LLVMRustInlineAsmVerify(fty, cons.as_ptr());\n+        debug!(\"Constraint verification result: {:?}\", constraints_ok);\n+        if constraints_ok {\n+            let v = llvm::LLVMRustInlineAsm(\n+                fty,\n+                asm.as_ptr(),\n+                cons.as_ptr(),\n+                volatile,\n+                alignstack,\n+                llvm::AsmDialect::from_generic(dia),\n+            );\n+            Some(bx.call(v, inputs, None))\n+        } else {\n+            // LLVM has detected an issue with our constraints, bail out\n+            None\n+        }\n+    }\n+}"}, {"sha": "123fda1e215ff9ca5890919fb34f08288d79a767", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 312, "deletions": 287, "changes": 599, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -1,10 +1,11 @@\n-use crate::llvm::{AtomicRmwBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n+use crate::llvm::{AtomicRmwBinOp, AtomicOrdering, SynchronizationScope};\n use crate::llvm::{self, False, BasicBlock};\n use crate::common::Funclet;\n use crate::context::CodegenCx;\n use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n+use syntax::symbol::LocalInternedString;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind, RealPredicate};\n use rustc_codegen_ssa::MemFlags;\n use libc::{c_uint, c_char};\n@@ -18,9 +19,9 @@ use rustc_codegen_ssa::base::to_immediate;\n use rustc_codegen_ssa::mir::operand::{OperandValue, OperandRef};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use std::borrow::Cow;\n-use std::ffi::CStr;\n use std::ops::{Deref, Range};\n use std::ptr;\n+use std::iter::TrustedLen;\n \n // All Builders must have an llfn associated with them\n #[must_use]\n@@ -120,50 +121,18 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         Builder::new_block(self.cx, self.llfn(), name)\n     }\n \n-    fn llfn(&self) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMGetBasicBlockParent(self.llbb())\n-        }\n-    }\n-\n     fn llbb(&self) -> &'ll BasicBlock {\n         unsafe {\n             llvm::LLVMGetInsertBlock(self.llbuilder)\n         }\n     }\n \n-    fn count_insn(&self, category: &str) {\n-        if self.sess().codegen_stats() {\n-            self.stats.borrow_mut().n_llvm_insns += 1;\n-        }\n-        if self.sess().count_llvm_insns() {\n-            *self.stats\n-                      .borrow_mut()\n-                      .llvm_insns\n-                      .entry(category.to_string())\n-                      .or_insert(0) += 1;\n-        }\n-    }\n-\n-    fn set_value_name(&mut self, value: &'ll Value, name: &str) {\n-        let cname = SmallCStr::new(name);\n-        unsafe {\n-            llvm::LLVMSetValueName(value, cname.as_ptr());\n-        }\n-    }\n-\n     fn position_at_end(&mut self, llbb: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMPositionBuilderAtEnd(self.llbuilder, llbb);\n         }\n     }\n \n-    fn position_at_start(&mut self, llbb: &'ll BasicBlock) {\n-        unsafe {\n-            llvm::LLVMRustPositionBuilderAtStart(self.llbuilder, llbb);\n-        }\n-    }\n-\n     fn ret_void(&mut self) {\n         self.count_insn(\"retvoid\");\n         unsafe {\n@@ -201,10 +170,16 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         &mut self,\n         v: &'ll Value,\n         else_llbb: &'ll BasicBlock,\n-        num_cases: usize,\n-    ) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMBuildSwitch(self.llbuilder, v, else_llbb, num_cases as c_uint)\n+        cases: impl ExactSizeIterator<Item = (u128, &'ll BasicBlock)> + TrustedLen,\n+    ) {\n+        let switch = unsafe {\n+            llvm::LLVMBuildSwitch(self.llbuilder, v, else_llbb, cases.len() as c_uint)\n+        };\n+        for (on_val, dest) in cases {\n+            let on_val = self.const_uint_big(self.val_ty(v), on_val);\n+            unsafe {\n+                llvm::LLVMAddCase(switch, on_val, dest)\n+            }\n         }\n     }\n \n@@ -616,7 +591,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         assert_eq!(place.llextra.is_some(), place.layout.is_unsized());\n \n         if place.layout.is_zst() {\n-            return OperandRef::new_zst(self.cx(), place.layout);\n+            return OperandRef::new_zst(self, place.layout);\n         }\n \n         fn scalar_load_metadata<'a, 'll, 'tcx>(\n@@ -683,7 +658,37 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         OperandRef { val, layout: place.layout }\n     }\n \n+    fn write_operand_repeatedly(\n+        mut self,\n+        cg_elem: OperandRef<'tcx, &'ll Value>,\n+        count: u64,\n+        dest: PlaceRef<'tcx, &'ll Value>,\n+    ) -> Self {\n+        let zero = self.const_usize(0);\n+        let count = self.const_usize(count);\n+        let start = dest.project_index(&mut self, zero).llval;\n+        let end = dest.project_index(&mut self, count).llval;\n+\n+        let mut header_bx = self.build_sibling_block(\"repeat_loop_header\");\n+        let mut body_bx = self.build_sibling_block(\"repeat_loop_body\");\n+        let next_bx = self.build_sibling_block(\"repeat_loop_next\");\n+\n+        self.br(header_bx.llbb());\n+        let current = header_bx.phi(self.val_ty(start), &[start], &[self.llbb()]);\n+\n+        let keep_going = header_bx.icmp(IntPredicate::IntNE, current, end);\n+        header_bx.cond_br(keep_going, body_bx.llbb(), next_bx.llbb());\n+\n+        let align = dest.align.restrict_for_offset(dest.layout.field(self.cx(), 0).size);\n+        cg_elem.val.store(&mut body_bx,\n+            PlaceRef::new_sized(current, cg_elem.layout, align));\n \n+        let next = body_bx.inbounds_gep(current, &[self.const_usize(1)]);\n+        body_bx.br(header_bx.llbb());\n+        header_bx.add_incoming_to_phi(current, next, body_bx.llbb());\n+\n+        next_bx\n+    }\n \n     fn range_metadata(&mut self, load: &'ll Value, range: Range<u128>) {\n         if self.sess().target.target.arch == \"amdgpu\" {\n@@ -786,6 +791,14 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n+    fn struct_gep(&mut self, ptr: &'ll Value, idx: u64) -> &'ll Value {\n+        self.count_insn(\"structgep\");\n+        assert_eq!(idx as c_uint as u64, idx);\n+        unsafe {\n+            llvm::LLVMBuildStructGEP(self.llbuilder, ptr, idx as c_uint, noname())\n+        }\n+    }\n+\n     /* Casts */\n     fn trunc(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"trunc\");\n@@ -896,64 +909,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     /* Miscellaneous instructions */\n-    fn empty_phi(&mut self, ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"emptyphi\");\n-        unsafe {\n-            llvm::LLVMBuildPhi(self.llbuilder, ty, noname())\n-        }\n-    }\n-\n-    fn phi(&mut self, ty: &'ll Type, vals: &[&'ll Value], bbs: &[&'ll BasicBlock]) -> &'ll Value {\n-        assert_eq!(vals.len(), bbs.len());\n-        let phi = self.empty_phi(ty);\n-        self.count_insn(\"addincoming\");\n-        unsafe {\n-            llvm::LLVMAddIncoming(phi, vals.as_ptr(),\n-                                  bbs.as_ptr(),\n-                                  vals.len() as c_uint);\n-            phi\n-        }\n-    }\n-\n-    fn inline_asm_call(&mut self, asm: &CStr, cons: &CStr,\n-                       inputs: &[&'ll Value], output: &'ll Type,\n-                       volatile: bool, alignstack: bool,\n-                       dia: syntax::ast::AsmDialect) -> Option<&'ll Value> {\n-        self.count_insn(\"inlineasm\");\n-\n-        let volatile = if volatile { llvm::True }\n-                       else        { llvm::False };\n-        let alignstack = if alignstack { llvm::True }\n-                         else          { llvm::False };\n-\n-        let argtys = inputs.iter().map(|v| {\n-            debug!(\"Asm Input Type: {:?}\", *v);\n-            self.cx.val_ty(*v)\n-        }).collect::<Vec<_>>();\n-\n-        debug!(\"Asm Output Type: {:?}\", output);\n-        let fty = self.type_func(&argtys[..], output);\n-        unsafe {\n-            // Ask LLVM to verify that the constraints are well-formed.\n-            let constraints_ok = llvm::LLVMRustInlineAsmVerify(fty, cons.as_ptr());\n-            debug!(\"Constraint verification result: {:?}\", constraints_ok);\n-            if constraints_ok {\n-                let v = llvm::LLVMRustInlineAsm(\n-                    fty,\n-                    asm.as_ptr(),\n-                    cons.as_ptr(),\n-                    volatile,\n-                    alignstack,\n-                    AsmDialect::from_generic(dia),\n-                );\n-                Some(self.call(v, inputs, None))\n-            } else {\n-                // LLVM has detected an issue with our constraints, bail out\n-                None\n-            }\n-        }\n-    }\n-\n     fn memcpy(&mut self, dst: &'ll Value, dst_align: Align,\n                   src: &'ll Value, src_align: Align,\n                   size: &'ll Value, flags: MemFlags) {\n@@ -1011,15 +966,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         self.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None);\n     }\n \n-    fn minnum(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"minnum\");\n-        unsafe { llvm::LLVMRustBuildMinNum(self.llbuilder, lhs, rhs) }\n-    }\n-    fn maxnum(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"maxnum\");\n-        unsafe { llvm::LLVMRustBuildMaxNum(self.llbuilder, lhs, rhs) }\n-    }\n-\n     fn select(\n         &mut self, cond: &'ll Value,\n         then_val: &'ll Value,\n@@ -1046,24 +992,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn insert_element(\n-        &mut self, vec: &'ll Value,\n-        elt: &'ll Value,\n-        idx: &'ll Value,\n-    ) -> &'ll Value {\n-        self.count_insn(\"insertelement\");\n-        unsafe {\n-            llvm::LLVMBuildInsertElement(self.llbuilder, vec, elt, idx, noname())\n-        }\n-    }\n-\n-    fn shuffle_vector(&mut self, v1: &'ll Value, v2: &'ll Value, mask: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"shufflevector\");\n-        unsafe {\n-            llvm::LLVMBuildShuffleVector(self.llbuilder, v1, v2, mask, noname())\n-        }\n-    }\n-\n     fn vector_splat(&mut self, num_elts: usize, elt: &'ll Value) -> &'ll Value {\n         unsafe {\n             let elt_ty = self.cx.val_ty(elt);\n@@ -1074,81 +1002,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn vector_reduce_fadd_fast(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fadd_fast\");\n-        unsafe {\n-            // FIXME: add a non-fast math version once\n-            // https://bugs.llvm.org/show_bug.cgi?id=36732\n-            // is fixed.\n-            let instr = llvm::LLVMRustBuildVectorReduceFAdd(self.llbuilder, acc, src);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n-            instr\n-        }\n-    }\n-    fn vector_reduce_fmul_fast(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fmul_fast\");\n-        unsafe {\n-            // FIXME: add a non-fast math version once\n-            // https://bugs.llvm.org/show_bug.cgi?id=36732\n-            // is fixed.\n-            let instr = llvm::LLVMRustBuildVectorReduceFMul(self.llbuilder, acc, src);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n-            instr\n-        }\n-    }\n-    fn vector_reduce_add(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.add\");\n-        unsafe { llvm::LLVMRustBuildVectorReduceAdd(self.llbuilder, src) }\n-    }\n-    fn vector_reduce_mul(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.mul\");\n-        unsafe { llvm::LLVMRustBuildVectorReduceMul(self.llbuilder, src) }\n-    }\n-    fn vector_reduce_and(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.and\");\n-        unsafe { llvm::LLVMRustBuildVectorReduceAnd(self.llbuilder, src) }\n-    }\n-    fn vector_reduce_or(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.or\");\n-        unsafe { llvm::LLVMRustBuildVectorReduceOr(self.llbuilder, src) }\n-    }\n-    fn vector_reduce_xor(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.xor\");\n-        unsafe { llvm::LLVMRustBuildVectorReduceXor(self.llbuilder, src) }\n-    }\n-    fn vector_reduce_fmin(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fmin\");\n-        unsafe { llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ false) }\n-    }\n-    fn vector_reduce_fmax(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fmax\");\n-        unsafe { llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ false) }\n-    }\n-    fn vector_reduce_fmin_fast(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fmin_fast\");\n-        unsafe {\n-            let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ true);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n-            instr\n-        }\n-    }\n-    fn vector_reduce_fmax_fast(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fmax_fast\");\n-        unsafe {\n-            let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ true);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n-            instr\n-        }\n-    }\n-    fn vector_reduce_min(&mut self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.min\");\n-        unsafe { llvm::LLVMRustBuildVectorReduceMin(self.llbuilder, src, is_signed) }\n-    }\n-    fn vector_reduce_max(&mut self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.max\");\n-        unsafe { llvm::LLVMRustBuildVectorReduceMax(self.llbuilder, src, is_signed) }\n-    }\n-\n     fn extract_value(&mut self, agg_val: &'ll Value, idx: u64) -> &'ll Value {\n         self.count_insn(\"extractvalue\");\n         assert_eq!(idx as c_uint as u64, idx);\n@@ -1176,12 +1029,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn add_clause(&mut self, landing_pad: &'ll Value, clause: &'ll Value) {\n-        unsafe {\n-            llvm::LLVMAddClause(landing_pad, clause);\n-        }\n-    }\n-\n     fn set_cleanup(&mut self, landing_pad: &'ll Value) {\n         self.count_insn(\"setcleanup\");\n         unsafe {\n@@ -1235,14 +1082,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         Funclet::new(ret.expect(\"LLVM does not have support for catchpad\"))\n     }\n \n-    fn catch_ret(&mut self, funclet: &Funclet<'ll>, unwind: &'ll BasicBlock) -> &'ll Value {\n-        self.count_insn(\"catchret\");\n-        let ret = unsafe {\n-            llvm::LLVMRustBuildCatchRet(self.llbuilder, funclet.cleanuppad(), unwind)\n-        };\n-        ret.expect(\"LLVM does not have support for catchret\")\n-    }\n-\n     fn catch_switch(\n         &mut self,\n         parent: Option<&'ll Value>,\n@@ -1326,26 +1165,254 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn add_case(&mut self, s: &'ll Value, on_val: &'ll Value, dest: &'ll BasicBlock) {\n+    fn set_invariant_load(&mut self, load: &'ll Value) {\n         unsafe {\n-            llvm::LLVMAddCase(s, on_val, dest)\n+            llvm::LLVMSetMetadata(load, llvm::MD_invariant_load as c_uint,\n+                                  llvm::LLVMMDNodeInContext(self.cx.llcx, ptr::null(), 0));\n         }\n     }\n \n-    fn add_incoming_to_phi(&mut self, phi: &'ll Value, val: &'ll Value, bb: &'ll BasicBlock) {\n-        self.count_insn(\"addincoming\");\n+    fn lifetime_start(&mut self, ptr: &'ll Value, size: Size) {\n+        self.call_lifetime_intrinsic(\"llvm.lifetime.start\", ptr, size);\n+    }\n+\n+    fn lifetime_end(&mut self, ptr: &'ll Value, size: Size) {\n+        self.call_lifetime_intrinsic(\"llvm.lifetime.end\", ptr, size);\n+    }\n+\n+    fn call(\n+        &mut self,\n+        llfn: &'ll Value,\n+        args: &[&'ll Value],\n+        funclet: Option<&Funclet<'ll>>,\n+    ) -> &'ll Value {\n+        self.count_insn(\"call\");\n+\n+        debug!(\"Call {:?} with args ({:?})\",\n+               llfn,\n+               args);\n+\n+        let args = self.check_call(\"call\", llfn, args);\n+        let bundle = funclet.map(|funclet| funclet.bundle());\n+        let bundle = bundle.as_ref().map(|b| &*b.raw);\n+\n         unsafe {\n-            llvm::LLVMAddIncoming(phi, &val, &bb, 1 as c_uint);\n+            llvm::LLVMRustBuildCall(\n+                self.llbuilder,\n+                llfn,\n+                args.as_ptr() as *const &llvm::Value,\n+                args.len() as c_uint,\n+                bundle, noname()\n+            )\n         }\n     }\n \n-    fn set_invariant_load(&mut self, load: &'ll Value) {\n+    fn zext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+        self.count_insn(\"zext\");\n         unsafe {\n-            llvm::LLVMSetMetadata(load, llvm::MD_invariant_load as c_uint,\n-                                  llvm::LLVMMDNodeInContext(self.cx.llcx, ptr::null(), 0));\n+            llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n+\n+    fn cx(&self) -> &CodegenCx<'ll, 'tcx> {\n+        self.cx\n+    }\n+\n+    unsafe fn delete_basic_block(&mut self, bb: &'ll BasicBlock) {\n+        llvm::LLVMDeleteBasicBlock(bb);\n+    }\n+\n+    fn do_not_inline(&mut self, llret: &'ll Value) {\n+        llvm::Attribute::NoInline.apply_callsite(llvm::AttributePlace::Function, llret);\n+    }\n+}\n+\n+impl StaticBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n+fn get_static(&mut self, def_id: DefId) -> &'ll Value {\n+        // Forward to the `get_static` method of `CodegenCx`\n+        self.cx().get_static(def_id)\n+    }\n+\n+    fn static_panic_msg(\n+        &mut self,\n+        msg: Option<LocalInternedString>,\n+        filename: LocalInternedString,\n+        line: Self::Value,\n+        col: Self::Value,\n+        kind: &str,\n+    ) -> Self::Value {\n+        let align = self.tcx.data_layout.aggregate_align.abi\n+            .max(self.tcx.data_layout.i32_align.abi)\n+            .max(self.tcx.data_layout.pointer_align.abi);\n+\n+        let filename = self.const_str_slice(filename);\n+\n+        let with_msg_components;\n+        let without_msg_components;\n+\n+        let components = if let Some(msg) = msg {\n+            let msg = self.const_str_slice(msg);\n+            with_msg_components = [msg, filename, line, col];\n+            &with_msg_components as &[_]\n+        } else {\n+            without_msg_components = [filename, line, col];\n+            &without_msg_components as &[_]\n+        };\n+\n+        let struct_ = self.const_struct(&components, false);\n+        self.static_addr_of(struct_, align, Some(kind))\n+    }\n+}\n+\n+impl Builder<'a, 'll, 'tcx> {\n+    pub fn llfn(&self) -> &'ll Value {\n+        unsafe {\n+            llvm::LLVMGetBasicBlockParent(self.llbb())\n+        }\n+    }\n+\n+    fn count_insn(&self, category: &str) {\n+        if self.sess().codegen_stats() {\n+            self.stats.borrow_mut().n_llvm_insns += 1;\n+        }\n+        if self.sess().count_llvm_insns() {\n+            *self.stats\n+                      .borrow_mut()\n+                      .llvm_insns\n+                      .entry(category.to_string())\n+                      .or_insert(0) += 1;\n+        }\n+    }\n+\n+    fn position_at_start(&mut self, llbb: &'ll BasicBlock) {\n+        unsafe {\n+            llvm::LLVMRustPositionBuilderAtStart(self.llbuilder, llbb);\n+        }\n+    }\n+\n+    pub fn minnum(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"minnum\");\n+        unsafe { llvm::LLVMRustBuildMinNum(self.llbuilder, lhs, rhs) }\n+    }\n+\n+    pub fn maxnum(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"maxnum\");\n+        unsafe { llvm::LLVMRustBuildMaxNum(self.llbuilder, lhs, rhs) }\n+    }\n+\n+    pub fn insert_element(\n+        &mut self, vec: &'ll Value,\n+        elt: &'ll Value,\n+        idx: &'ll Value,\n+    ) -> &'ll Value {\n+        self.count_insn(\"insertelement\");\n+        unsafe {\n+            llvm::LLVMBuildInsertElement(self.llbuilder, vec, elt, idx, noname())\n+        }\n+    }\n+\n+    pub fn shuffle_vector(\n+        &mut self,\n+        v1: &'ll Value,\n+        v2: &'ll Value,\n+        mask: &'ll Value,\n+    ) -> &'ll Value {\n+        self.count_insn(\"shufflevector\");\n+        unsafe {\n+            llvm::LLVMBuildShuffleVector(self.llbuilder, v1, v2, mask, noname())\n+        }\n+    }\n+\n+    pub fn vector_reduce_fadd_fast(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.fadd_fast\");\n+        unsafe {\n+            // FIXME: add a non-fast math version once\n+            // https://bugs.llvm.org/show_bug.cgi?id=36732\n+            // is fixed.\n+            let instr = llvm::LLVMRustBuildVectorReduceFAdd(self.llbuilder, acc, src);\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_fmul_fast(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.fmul_fast\");\n+        unsafe {\n+            // FIXME: add a non-fast math version once\n+            // https://bugs.llvm.org/show_bug.cgi?id=36732\n+            // is fixed.\n+            let instr = llvm::LLVMRustBuildVectorReduceFMul(self.llbuilder, acc, src);\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_add(&mut self, src: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.add\");\n+        unsafe { llvm::LLVMRustBuildVectorReduceAdd(self.llbuilder, src) }\n+    }\n+    pub fn vector_reduce_mul(&mut self, src: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.mul\");\n+        unsafe { llvm::LLVMRustBuildVectorReduceMul(self.llbuilder, src) }\n+    }\n+    pub fn vector_reduce_and(&mut self, src: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.and\");\n+        unsafe { llvm::LLVMRustBuildVectorReduceAnd(self.llbuilder, src) }\n+    }\n+    pub fn vector_reduce_or(&mut self, src: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.or\");\n+        unsafe { llvm::LLVMRustBuildVectorReduceOr(self.llbuilder, src) }\n+    }\n+    pub fn vector_reduce_xor(&mut self, src: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.xor\");\n+        unsafe { llvm::LLVMRustBuildVectorReduceXor(self.llbuilder, src) }\n+    }\n+    pub fn vector_reduce_fmin(&mut self, src: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.fmin\");\n+        unsafe { llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ false) }\n+    }\n+    pub fn vector_reduce_fmax(&mut self, src: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.fmax\");\n+        unsafe { llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ false) }\n+    }\n+    pub fn vector_reduce_fmin_fast(&mut self, src: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.fmin_fast\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ true);\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_fmax_fast(&mut self, src: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.fmax_fast\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ true);\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_min(&mut self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.min\");\n+        unsafe { llvm::LLVMRustBuildVectorReduceMin(self.llbuilder, src, is_signed) }\n+    }\n+    pub fn vector_reduce_max(&mut self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.max\");\n+        unsafe { llvm::LLVMRustBuildVectorReduceMax(self.llbuilder, src, is_signed) }\n+    }\n+\n+    pub fn add_clause(&mut self, landing_pad: &'ll Value, clause: &'ll Value) {\n+        unsafe {\n+            llvm::LLVMAddClause(landing_pad, clause);\n+        }\n+    }\n+\n+    pub fn catch_ret(&mut self, funclet: &Funclet<'ll>, unwind: &'ll BasicBlock) -> &'ll Value {\n+        self.count_insn(\"catchret\");\n+        let ret = unsafe {\n+            llvm::LLVMRustBuildCatchRet(self.llbuilder, funclet.cleanuppad(), unwind)\n+        };\n+        ret.expect(\"LLVM does not have support for catchret\")\n+    }\n+\n     fn check_store<'b>(&mut self,\n                        val: &'ll Value,\n                        ptr: &'ll Value) -> &'ll Value {\n@@ -1407,76 +1474,13 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         Cow::Owned(casted_args)\n     }\n \n-    fn lifetime_start(&mut self, ptr: &'ll Value, size: Size) {\n-        self.call_lifetime_intrinsic(\"llvm.lifetime.start\", ptr, size);\n-    }\n-\n-    fn lifetime_end(&mut self, ptr: &'ll Value, size: Size) {\n-        self.call_lifetime_intrinsic(\"llvm.lifetime.end\", ptr, size);\n-    }\n-\n-    fn call(\n-        &mut self,\n-        llfn: &'ll Value,\n-        args: &[&'ll Value],\n-        funclet: Option<&Funclet<'ll>>,\n-    ) -> &'ll Value {\n-        self.count_insn(\"call\");\n-\n-        debug!(\"Call {:?} with args ({:?})\",\n-               llfn,\n-               args);\n-\n-        let args = self.check_call(\"call\", llfn, args);\n-        let bundle = funclet.map(|funclet| funclet.bundle());\n-        let bundle = bundle.as_ref().map(|b| &*b.raw);\n-\n-        unsafe {\n-            llvm::LLVMRustBuildCall(\n-                self.llbuilder,\n-                llfn,\n-                args.as_ptr() as *const &llvm::Value,\n-                args.len() as c_uint,\n-                bundle, noname()\n-            )\n-        }\n-    }\n-\n-    fn zext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"zext\");\n-        unsafe {\n-            llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty, noname())\n-        }\n-    }\n-\n-    fn struct_gep(&mut self, ptr: &'ll Value, idx: u64) -> &'ll Value {\n-        self.count_insn(\"structgep\");\n-        assert_eq!(idx as c_uint as u64, idx);\n+    pub fn va_arg(&mut self, list: &'ll Value, ty: &'ll Type) -> &'ll Value {\n+        self.count_insn(\"vaarg\");\n         unsafe {\n-            llvm::LLVMBuildStructGEP(self.llbuilder, ptr, idx as c_uint, noname())\n+            llvm::LLVMBuildVAArg(self.llbuilder, list, ty, noname())\n         }\n     }\n \n-    fn cx(&self) -> &CodegenCx<'ll, 'tcx> {\n-        self.cx\n-    }\n-\n-    unsafe fn delete_basic_block(&mut self, bb: &'ll BasicBlock) {\n-        llvm::LLVMDeleteBasicBlock(bb);\n-    }\n-\n-    fn do_not_inline(&mut self, llret: &'ll Value) {\n-        llvm::Attribute::NoInline.apply_callsite(llvm::AttributePlace::Function, llret);\n-    }\n-}\n-\n-impl StaticBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n-    fn get_static(&self, def_id: DefId) -> &'ll Value {\n-        self.cx().get_static(def_id)\n-    }\n-}\n-\n-impl Builder<'a, 'll, 'tcx> {\n     fn call_lifetime_intrinsic(&mut self, intrinsic: &str, ptr: &'ll Value, size: Size) {\n         if self.cx.sess().opts.optimize == config::OptLevel::No {\n             return;\n@@ -1492,4 +1496,25 @@ impl Builder<'a, 'll, 'tcx> {\n         let ptr = self.pointercast(ptr, self.cx.type_i8p());\n         self.call(lifetime_intrinsic, &[self.cx.const_u64(size), ptr], None);\n     }\n+\n+    fn phi(&mut self, ty: &'ll Type, vals: &[&'ll Value], bbs: &[&'ll BasicBlock]) -> &'ll Value {\n+        self.count_insn(\"addincoming\");\n+        assert_eq!(vals.len(), bbs.len());\n+        let phi = unsafe {\n+            llvm::LLVMBuildPhi(self.llbuilder, ty, noname())\n+        };\n+        unsafe {\n+            llvm::LLVMAddIncoming(phi, vals.as_ptr(),\n+                                  bbs.as_ptr(),\n+                                  vals.len() as c_uint);\n+            phi\n+        }\n+    }\n+\n+    fn add_incoming_to_phi(&mut self, phi: &'ll Value, val: &'ll Value, bb: &'ll BasicBlock) {\n+        self.count_insn(\"addincoming\");\n+        unsafe {\n+            llvm::LLVMAddIncoming(phi, &val, &bb, 1 as c_uint);\n+        }\n+    }\n }"}, {"sha": "9554e54e4142ae207105b317ba324574e97819b6", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 94, "deletions": 92, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -93,6 +93,100 @@ impl BackendTypes for CodegenCx<'ll, 'tcx> {\n     type DIScope = &'ll llvm::debuginfo::DIScope;\n }\n \n+impl CodegenCx<'ll, 'tcx> {\n+    pub fn const_fat_ptr(\n+        &self,\n+        ptr: &'ll Value,\n+        meta: &'ll Value\n+    ) -> &'ll Value {\n+        assert_eq!(abi::FAT_PTR_ADDR, 0);\n+        assert_eq!(abi::FAT_PTR_EXTRA, 1);\n+        self.const_struct(&[ptr, meta], false)\n+    }\n+\n+    pub fn const_array(&self, ty: &'ll Type, elts: &[&'ll Value]) -> &'ll Value {\n+        unsafe {\n+            return llvm::LLVMConstArray(ty, elts.as_ptr(), elts.len() as c_uint);\n+        }\n+    }\n+\n+    pub fn const_vector(&self, elts: &[&'ll Value]) -> &'ll Value {\n+        unsafe {\n+            return llvm::LLVMConstVector(elts.as_ptr(), elts.len() as c_uint);\n+        }\n+    }\n+\n+    pub fn const_bytes(&self, bytes: &[u8]) -> &'ll Value {\n+        bytes_in_context(self.llcx, bytes)\n+    }\n+\n+    fn const_cstr(\n+        &self,\n+        s: LocalInternedString,\n+        null_terminated: bool,\n+    ) -> &'ll Value {\n+        unsafe {\n+            if let Some(&llval) = self.const_cstr_cache.borrow().get(&s) {\n+                return llval;\n+            }\n+\n+            let sc = llvm::LLVMConstStringInContext(self.llcx,\n+                                                    s.as_ptr() as *const c_char,\n+                                                    s.len() as c_uint,\n+                                                    !null_terminated as Bool);\n+            let sym = self.generate_local_symbol_name(\"str\");\n+            let g = self.define_global(&sym[..], self.val_ty(sc)).unwrap_or_else(||{\n+                bug!(\"symbol `{}` is already defined\", sym);\n+            });\n+            llvm::LLVMSetInitializer(g, sc);\n+            llvm::LLVMSetGlobalConstant(g, True);\n+            llvm::LLVMRustSetLinkage(g, llvm::Linkage::InternalLinkage);\n+\n+            self.const_cstr_cache.borrow_mut().insert(s, g);\n+            g\n+        }\n+    }\n+\n+    pub fn const_str_slice(&self, s: LocalInternedString) -> &'ll Value {\n+        let len = s.len();\n+        let cs = consts::ptrcast(self.const_cstr(s, false),\n+            self.type_ptr_to(self.layout_of(self.tcx.mk_str()).llvm_type(self)));\n+        self.const_fat_ptr(cs, self.const_usize(len as u64))\n+    }\n+\n+    pub fn const_get_elt(&self, v: &'ll Value, idx: u64) -> &'ll Value {\n+        unsafe {\n+            assert_eq!(idx as c_uint as u64, idx);\n+            let us = &[idx as c_uint];\n+            let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n+\n+            debug!(\"const_get_elt(v={:?}, idx={}, r={:?})\",\n+                   v, idx, r);\n+\n+            r\n+        }\n+    }\n+\n+    pub fn const_get_real(&self, v: &'ll Value) -> Option<(f64, bool)> {\n+        unsafe {\n+            if self.is_const_real(v) {\n+                let mut loses_info: llvm::Bool = ::std::mem::uninitialized();\n+                let r = llvm::LLVMConstRealGetDouble(v, &mut loses_info);\n+                let loses_info = if loses_info == 1 { true } else { false };\n+                Some((r, loses_info))\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+\n+    fn is_const_real(&self, v: &'ll Value) -> bool {\n+        unsafe {\n+            llvm::LLVMIsAConstantFP(v).is_some()\n+        }\n+    }\n+}\n+\n impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn const_null(&self, t: &'ll Type) -> &'ll Value {\n         unsafe {\n@@ -155,50 +249,6 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         self.const_uint(self.type_i8(), i as u64)\n     }\n \n-    fn const_cstr(\n-        &self,\n-        s: LocalInternedString,\n-        null_terminated: bool,\n-    ) -> &'ll Value {\n-        unsafe {\n-            if let Some(&llval) = self.const_cstr_cache.borrow().get(&s) {\n-                return llval;\n-            }\n-\n-            let sc = llvm::LLVMConstStringInContext(self.llcx,\n-                                                    s.as_ptr() as *const c_char,\n-                                                    s.len() as c_uint,\n-                                                    !null_terminated as Bool);\n-            let sym = self.generate_local_symbol_name(\"str\");\n-            let g = self.define_global(&sym[..], self.val_ty(sc)).unwrap_or_else(||{\n-                bug!(\"symbol `{}` is already defined\", sym);\n-            });\n-            llvm::LLVMSetInitializer(g, sc);\n-            llvm::LLVMSetGlobalConstant(g, True);\n-            llvm::LLVMRustSetLinkage(g, llvm::Linkage::InternalLinkage);\n-\n-            self.const_cstr_cache.borrow_mut().insert(s, g);\n-            g\n-        }\n-    }\n-\n-    fn const_str_slice(&self, s: LocalInternedString) -> &'ll Value {\n-        let len = s.len();\n-        let cs = consts::ptrcast(self.const_cstr(s, false),\n-            self.type_ptr_to(self.layout_of(self.tcx.mk_str()).llvm_type(self)));\n-        self.const_fat_ptr(cs, self.const_usize(len as u64))\n-    }\n-\n-    fn const_fat_ptr(\n-        &self,\n-        ptr: &'ll Value,\n-        meta: &'ll Value\n-    ) -> &'ll Value {\n-        assert_eq!(abi::FAT_PTR_ADDR, 0);\n-        assert_eq!(abi::FAT_PTR_EXTRA, 1);\n-        self.const_struct(&[ptr, meta], false)\n-    }\n-\n     fn const_struct(\n         &self,\n         elts: &[&'ll Value],\n@@ -207,48 +257,6 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         struct_in_context(self.llcx, elts, packed)\n     }\n \n-    fn const_array(&self, ty: &'ll Type, elts: &[&'ll Value]) -> &'ll Value {\n-        unsafe {\n-            return llvm::LLVMConstArray(ty, elts.as_ptr(), elts.len() as c_uint);\n-        }\n-    }\n-\n-    fn const_vector(&self, elts: &[&'ll Value]) -> &'ll Value {\n-        unsafe {\n-            return llvm::LLVMConstVector(elts.as_ptr(), elts.len() as c_uint);\n-        }\n-    }\n-\n-    fn const_bytes(&self, bytes: &[u8]) -> &'ll Value {\n-        bytes_in_context(self.llcx, bytes)\n-    }\n-\n-    fn const_get_elt(&self, v: &'ll Value, idx: u64) -> &'ll Value {\n-        unsafe {\n-            assert_eq!(idx as c_uint as u64, idx);\n-            let us = &[idx as c_uint];\n-            let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n-\n-            debug!(\"const_get_elt(v={:?}, idx={}, r={:?})\",\n-                   v, idx, r);\n-\n-            r\n-        }\n-    }\n-\n-    fn const_get_real(&self, v: &'ll Value) -> Option<(f64, bool)> {\n-        unsafe {\n-            if self.is_const_real(v) {\n-                let mut loses_info: llvm::Bool = ::std::mem::uninitialized();\n-                let r = llvm::LLVMConstRealGetDouble(v, &mut loses_info);\n-                let loses_info = if loses_info == 1 { true } else { false };\n-                Some((r, loses_info))\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-\n     fn const_to_uint(&self, v: &'ll Value) -> u64 {\n         unsafe {\n             llvm::LLVMConstIntGetZExtValue(v)\n@@ -261,12 +269,6 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    fn is_const_real(&self, v: &'ll Value) -> bool {\n-        unsafe {\n-            llvm::LLVMIsAConstantFP(v).is_some()\n-        }\n-    }\n-\n     fn const_to_opt_u128(&self, v: &'ll Value, sign_ext: bool) -> Option<u128> {\n         unsafe {\n             if self.is_const_integral(v) {"}, {"sha": "fc79e868fb4bf635f1bec3a11328e2774d1a238b", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -10,7 +10,6 @@ use crate::monomorphize::partitioning::CodegenUnit;\n use crate::type_::Type;\n use crate::type_of::PointeeInfo;\n use rustc_codegen_ssa::traits::*;\n-use libc::c_uint;\n \n use rustc_data_structures::base_n;\n use rustc_data_structures::small_c_str::SmallCStr;\n@@ -326,10 +325,6 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         get_fn(self, instance)\n     }\n \n-    fn get_param(&self, llfn: &'ll Value, index: c_uint) -> &'ll Value {\n-        llvm::get_param(llfn, index)\n-    }\n-\n     fn eh_personality(&self) -> &'ll Value {\n         // The exception handling personality function.\n         //"}, {"sha": "6abbcd9feba7ac2cd28095d34d495d64e7b28ca6", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -32,7 +32,7 @@ use rustc_codegen_ssa::debuginfo::{FunctionDebugContext, MirDebugScope, Variable\n     VariableKind, FunctionDebugContextData};\n \n use libc::c_uint;\n-use std::cell::{Cell, RefCell};\n+use std::cell::RefCell;\n use std::ffi::CString;\n \n use syntax_pos::{self, Span, Pos};\n@@ -158,7 +158,7 @@ impl DebugInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         variable_kind: VariableKind,\n         span: Span,\n     ) {\n-        assert!(!dbg_context.get_ref(span).source_locations_enabled.get());\n+        assert!(!dbg_context.get_ref(span).source_locations_enabled);\n         let cx = self.cx();\n \n         let file = span_start(cx, span).file;\n@@ -216,7 +216,7 @@ impl DebugInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn set_source_location(\n         &mut self,\n-        debug_context: &FunctionDebugContext<&'ll DISubprogram>,\n+        debug_context: &mut FunctionDebugContext<&'ll DISubprogram>,\n         scope: Option<&'ll DIScope>,\n         span: Span,\n     ) {\n@@ -225,6 +225,13 @@ impl DebugInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     fn insert_reference_to_gdb_debug_scripts_section_global(&mut self) {\n         gdb::insert_reference_to_gdb_debug_scripts_section_global(self)\n     }\n+\n+    fn set_value_name(&mut self, value: &'ll Value, name: &str) {\n+        let cname = SmallCStr::new(name);\n+        unsafe {\n+            llvm::LLVMSetValueName(value, cname.as_ptr());\n+        }\n+    }\n }\n \n impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n@@ -327,7 +334,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         // Initialize fn debug context (including scope map and namespace map)\n         let fn_debug_context = FunctionDebugContextData {\n             fn_metadata,\n-            source_locations_enabled: Cell::new(false),\n+            source_locations_enabled: false,\n             defining_crate: def_id.krate,\n         };\n \n@@ -519,7 +526,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn create_mir_scopes(\n         &self,\n         mir: &mir::Mir<'_>,\n-        debug_context: &FunctionDebugContext<&'ll DISubprogram>,\n+        debug_context: &mut FunctionDebugContext<&'ll DISubprogram>,\n     ) -> IndexVec<mir::SourceScope, MirDebugScope<&'ll DIScope>> {\n         create_scope_map::create_mir_scopes(self, mir, debug_context)\n     }"}, {"sha": "dec93a65dbaf49aa42526d0e4e2630d024178ff0", "filename": "src/librustc_codegen_llvm/debuginfo/source_loc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -30,7 +30,7 @@ pub fn set_source_location<D>(\n         FunctionDebugContext::RegularContext(ref data) => data\n     };\n \n-    let dbg_loc = if function_debug_context.source_locations_enabled.get() {\n+    let dbg_loc = if function_debug_context.source_locations_enabled {\n         debug!(\"set_source_location: {}\", bx.sess().source_map().span_to_string(span));\n         let loc = span_start(bx.cx(), span);\n         InternalDebugLocation::new(scope.unwrap(), loc.line, loc.col.to_usize())"}, {"sha": "0aae6b46e3def279749084bc64dcc1b24180fa75", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -20,6 +20,7 @@\n #![feature(concat_idents)]\n #![feature(link_args)]\n #![feature(static_nobundle)]\n+#![feature(trusted_len)]\n #![deny(rust_2018_idioms)]\n #![allow(explicit_outlives_requirements)]\n "}, {"sha": "a5ed64a66a39da1ebdf3fce19c258a8559516b04", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 101, "deletions": 60, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -11,15 +11,14 @@ use rustc_codegen_ssa::traits::*;\n use crate::common;\n use crate::type_of::LayoutLlvmExt;\n use crate::abi::{LlvmType, FnTypeExt};\n-use rustc::util::nodemap::FxHashMap;\n+use syntax::ast;\n use rustc::ty::Ty;\n-use rustc::ty::layout::TyLayout;\n+use rustc::ty::layout::{self, Align, Size, TyLayout};\n use rustc_target::abi::call::{CastTarget, FnType, Reg};\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_codegen_ssa::common::TypeKind;\n \n use std::fmt;\n-use std::cell::RefCell;\n use std::ptr;\n \n use libc::c_uint;\n@@ -52,21 +51,116 @@ impl CodegenCx<'ll, 'tcx> {\n                                     els.len() as c_uint, packed as Bool)\n         }\n     }\n-}\n \n-impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n-    fn type_void(&self) -> &'ll Type {\n+    crate fn type_void(&self) -> &'ll Type {\n         unsafe {\n             llvm::LLVMVoidTypeInContext(self.llcx)\n         }\n     }\n \n-    fn type_metadata(&self) -> &'ll Type {\n+    crate fn type_metadata(&self) -> &'ll Type {\n         unsafe {\n             llvm::LLVMRustMetadataTypeInContext(self.llcx)\n         }\n     }\n \n+    ///x Creates an integer type with the given number of bits, e.g., i24\n+    crate fn type_ix(&self, num_bits: u64) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMIntTypeInContext(self.llcx, num_bits as c_uint)\n+        }\n+    }\n+\n+    crate fn type_x86_mmx(&self) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMX86MMXTypeInContext(self.llcx)\n+        }\n+    }\n+\n+    crate fn type_vector(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMVectorType(ty, len as c_uint)\n+        }\n+    }\n+\n+    crate fn func_params_types(&self, ty: &'ll Type) -> Vec<&'ll Type> {\n+        unsafe {\n+            let n_args = llvm::LLVMCountParamTypes(ty) as usize;\n+            let mut args = Vec::with_capacity(n_args);\n+            llvm::LLVMGetParamTypes(ty, args.as_mut_ptr());\n+            args.set_len(n_args);\n+            args\n+        }\n+    }\n+\n+    crate fn type_bool(&self) -> &'ll Type {\n+        self.type_i8()\n+    }\n+\n+    crate fn type_int_from_ty(&self, t: ast::IntTy) -> &'ll Type {\n+        match t {\n+            ast::IntTy::Isize => self.type_isize(),\n+            ast::IntTy::I8 => self.type_i8(),\n+            ast::IntTy::I16 => self.type_i16(),\n+            ast::IntTy::I32 => self.type_i32(),\n+            ast::IntTy::I64 => self.type_i64(),\n+            ast::IntTy::I128 => self.type_i128(),\n+        }\n+    }\n+\n+    crate fn type_uint_from_ty(&self, t: ast::UintTy) -> &'ll Type {\n+        match t {\n+            ast::UintTy::Usize => self.type_isize(),\n+            ast::UintTy::U8 => self.type_i8(),\n+            ast::UintTy::U16 => self.type_i16(),\n+            ast::UintTy::U32 => self.type_i32(),\n+            ast::UintTy::U64 => self.type_i64(),\n+            ast::UintTy::U128 => self.type_i128(),\n+        }\n+    }\n+\n+    crate fn type_float_from_ty(&self, t: ast::FloatTy) -> &'ll Type {\n+        match t {\n+            ast::FloatTy::F32 => self.type_f32(),\n+            ast::FloatTy::F64 => self.type_f64(),\n+        }\n+    }\n+\n+    crate fn type_pointee_for_align(&self, align: Align) -> &'ll Type {\n+        // FIXME(eddyb) We could find a better approximation if ity.align < align.\n+        let ity = layout::Integer::approximate_align(self, align);\n+        self.type_from_integer(ity)\n+    }\n+\n+    /// Return a LLVM type that has at most the required alignment,\n+    /// and exactly the required size, as a best-effort padding array.\n+    crate fn type_padding_filler(&self, size: Size, align: Align) -> &'ll Type {\n+        let unit = layout::Integer::approximate_align(self, align);\n+        let size = size.bytes();\n+        let unit_size = unit.size().bytes();\n+        assert_eq!(size % unit_size, 0);\n+        self.type_array(self.type_from_integer(unit), size / unit_size)\n+    }\n+\n+    crate fn type_variadic_func(\n+        &self,\n+        args: &[&'ll Type],\n+        ret: &'ll Type\n+    ) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMFunctionType(ret, args.as_ptr(),\n+                                   args.len() as c_uint, True)\n+        }\n+    }\n+\n+    crate fn type_array(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMRustArrayType(ty, len)\n+        }\n+    }\n+}\n+\n+impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn type_i1(&self) -> &'ll Type {\n         unsafe {\n             llvm::LLVMInt1TypeInContext(self.llcx)\n@@ -104,12 +198,6 @@ impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    fn type_ix(&self, num_bits: u64) -> &'ll Type {\n-        unsafe {\n-            llvm::LLVMIntTypeInContext(self.llcx, num_bits as c_uint)\n-        }\n-    }\n-\n     fn type_isize(&self) -> &'ll Type {\n         self.isize_ty\n     }\n@@ -126,12 +214,6 @@ impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    fn type_x86_mmx(&self) -> &'ll Type {\n-        unsafe {\n-            llvm::LLVMX86MMXTypeInContext(self.llcx)\n-        }\n-    }\n-\n     fn type_func(\n         &self,\n         args: &[&'ll Type],\n@@ -143,17 +225,6 @@ impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    fn type_variadic_func(\n-        &self,\n-        args: &[&'ll Type],\n-        ret: &'ll Type\n-    ) -> &'ll Type {\n-        unsafe {\n-            llvm::LLVMFunctionType(ret, args.as_ptr(),\n-                                   args.len() as c_uint, True)\n-        }\n-    }\n-\n     fn type_struct(\n         &self,\n         els: &[&'ll Type],\n@@ -166,19 +237,6 @@ impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-\n-    fn type_array(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n-        unsafe {\n-            llvm::LLVMRustArrayType(ty, len)\n-        }\n-    }\n-\n-    fn type_vector(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n-        unsafe {\n-            llvm::LLVMVectorType(ty, len as c_uint)\n-        }\n-    }\n-\n     fn type_kind(&self, ty: &'ll Type) -> TypeKind {\n         unsafe {\n             llvm::LLVMRustGetTypeKind(ty).to_generic()\n@@ -203,16 +261,6 @@ impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    fn func_params_types(&self, ty: &'ll Type) -> Vec<&'ll Type> {\n-        unsafe {\n-            let n_args = llvm::LLVMCountParamTypes(ty) as usize;\n-            let mut args = Vec::with_capacity(n_args);\n-            llvm::LLVMGetParamTypes(ty, args.as_mut_ptr());\n-            args.set_len(n_args);\n-            args\n-        }\n-    }\n-\n     fn float_width(&self, ty: &'ll Type) -> usize {\n         match self.type_kind(ty) {\n             TypeKind::Float => 32,\n@@ -232,10 +280,6 @@ impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn val_ty(&self, v: &'ll Value) -> &'ll Type {\n         common::val_ty(v)\n     }\n-\n-    fn scalar_lltypes(&self) -> &RefCell<FxHashMap<Ty<'tcx>, Self::Type>> {\n-        &self.scalar_lltypes\n-    }\n }\n \n impl Type {\n@@ -294,9 +338,6 @@ impl LayoutTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn cast_backend_type(&self, ty: &CastTarget) -> &'ll Type {\n         ty.llvm_type(self)\n     }\n-    fn fn_backend_type(&self, ty: &FnType<'tcx, Ty<'tcx>>) -> &'ll Type {\n-        ty.llvm_type(self)\n-    }\n     fn fn_ptr_backend_type(&self, ty: &FnType<'tcx, Ty<'tcx>>) -> &'ll Type {\n         ty.ptr_to_llvm_type(self)\n     }"}, {"sha": "27e3e306699053ee4bc74818cc72a50576ee105e", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -501,8 +501,8 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n         bx.insert_reference_to_gdb_debug_scripts_section_global();\n \n         // Params from native main() used as args for rust start function\n-        let param_argc = cx.get_param(llfn, 0);\n-        let param_argv = cx.get_param(llfn, 1);\n+        let param_argc = bx.get_param(0);\n+        let param_argv = bx.get_param(1);\n         let arg_argc = bx.intcast(param_argc, cx.type_isize(), true);\n         let arg_argv = param_argv;\n "}, {"sha": "0e1885fe29ba6f8efbfe06b6c299d99c028ea6d8", "filename": "src/librustc_codegen_ssa/common.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcommon.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -1,7 +1,7 @@\n #![allow(non_camel_case_types, non_snake_case)]\n \n-use rustc::ty::{self, Ty, TyCtxt};\n-use syntax_pos::{DUMMY_SP, Span};\n+use rustc::ty::{Ty, TyCtxt};\n+use syntax_pos::Span;\n \n use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items::LangItem;\n@@ -11,18 +11,6 @@ use crate::traits::*;\n use rustc::hir;\n use crate::traits::BuilderMethods;\n \n-pub fn type_needs_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.needs_drop(tcx, ty::ParamEnv::reveal_all())\n-}\n-\n-pub fn type_is_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.is_sized(tcx.at(DUMMY_SP), ty::ParamEnv::reveal_all())\n-}\n-\n-pub fn type_is_freeze<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.is_freeze(tcx, ty::ParamEnv::reveal_all(), DUMMY_SP)\n-}\n-\n pub enum IntPredicate {\n     IntEQ,\n     IntNE,"}, {"sha": "aa7cdbed99446904d21b52719c5b0555285ac5e3", "filename": "src/librustc_codegen_ssa/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -1,6 +1,5 @@\n use syntax_pos::{BytePos, Span};\n use rustc::hir::def_id::CrateNum;\n-use std::cell::Cell;\n \n pub enum FunctionDebugContext<D> {\n     RegularContext(FunctionDebugContextData<D>),\n@@ -36,18 +35,18 @@ impl<D> FunctionDebugContext<D> {\n /// they are disabled when beginning to codegen a new function. This functions\n /// switches source location emitting on and must therefore be called before the\n /// first real statement/expression of the function is codegened.\n-pub fn start_emitting_source_locations<D>(dbg_context: &FunctionDebugContext<D>) {\n+pub fn start_emitting_source_locations<D>(dbg_context: &mut FunctionDebugContext<D>) {\n     match *dbg_context {\n-        FunctionDebugContext::RegularContext(ref data) => {\n-            data.source_locations_enabled.set(true)\n+        FunctionDebugContext::RegularContext(ref mut data) => {\n+            data.source_locations_enabled = true;\n         },\n         _ => { /* safe to ignore */ }\n     }\n }\n \n pub struct FunctionDebugContextData<D> {\n     pub fn_metadata: D,\n-    pub source_locations_enabled: Cell<bool>,\n+    pub source_locations_enabled: bool,\n     pub defining_crate: CrateNum,\n }\n "}, {"sha": "1e898ced7a6006aa85fcd27ac7538e51cd1e7133", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -10,6 +10,7 @@\n #![feature(try_blocks)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n+#![feature(trusted_len)]\n #![allow(unused_attributes)]\n #![allow(dead_code)]\n #![deny(rust_2018_idioms)]"}, {"sha": "98da07a905e2541794fd8122b42fbb5b264fae72", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 27, "deletions": 44, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -214,17 +214,13 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n         } else {\n             let (otherwise, targets) = targets.split_last().unwrap();\n-            let switch = bx.switch(discr.immediate(),\n-                                   helper.llblock(self, *otherwise),\n-                                   values.len());\n-            let switch_llty = bx.immediate_backend_type(\n-                bx.layout_of(switch_ty)\n+            bx.switch(\n+                discr.immediate(),\n+                helper.llblock(self, *otherwise),\n+                values.iter().zip(targets).map(|(&value, target)| {\n+                    (value, helper.llblock(self, *target))\n+                })\n             );\n-            for (&value, target) in values.iter().zip(targets) {\n-                let llval = bx.const_uint_big(switch_llty, value);\n-                let llbb = helper.llblock(self, *target);\n-                bx.add_case(switch, llval, llbb)\n-            }\n         }\n     }\n \n@@ -399,43 +395,37 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // Get the location information.\n         let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n         let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n-        let filename = bx.const_str_slice(filename);\n         let line = bx.const_u32(loc.line as u32);\n         let col = bx.const_u32(loc.col.to_usize() as u32 + 1);\n-        let align = self.cx.tcx().data_layout.aggregate_align.abi\n-            .max(self.cx.tcx().data_layout.i32_align.abi)\n-            .max(self.cx.tcx().data_layout.pointer_align.abi);\n \n         // Put together the arguments to the panic entry point.\n         let (lang_item, args) = match *msg {\n             EvalErrorKind::BoundsCheck { ref len, ref index } => {\n                 let len = self.codegen_operand(&mut bx, len).immediate();\n                 let index = self.codegen_operand(&mut bx, index).immediate();\n \n-                let file_line_col = bx.const_struct(&[filename, line, col], false);\n-                let file_line_col = bx.static_addr_of(\n-                    file_line_col,\n-                    align,\n-                    Some(\"panic_bounds_check_loc\")\n+                let file_line_col = bx.static_panic_msg(\n+                    None,\n+                    filename,\n+                    line,\n+                    col,\n+                    \"panic_bounds_check_loc\",\n                 );\n                 (lang_items::PanicBoundsCheckFnLangItem,\n-                 vec![file_line_col, index, len])\n+                    vec![file_line_col, index, len])\n             }\n             _ => {\n                 let str = msg.description();\n                 let msg_str = Symbol::intern(str).as_str();\n-                let msg_str = bx.const_str_slice(msg_str);\n-                let msg_file_line_col = bx.const_struct(\n-                    &[msg_str, filename, line, col],\n-                    false\n-                );\n-                let msg_file_line_col = bx.static_addr_of(\n-                    msg_file_line_col,\n-                    align,\n-                    Some(\"panic_loc\")\n+                let msg_file_line_col = bx.static_panic_msg(\n+                    Some(msg_str),\n+                    filename,\n+                    line,\n+                    col,\n+                    \"panic_loc\",\n                 );\n                 (lang_items::PanicFnLangItem,\n-                 vec![msg_file_line_col])\n+                    vec![msg_file_line_col])\n             }\n         };\n \n@@ -539,27 +529,20 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             if layout.abi.is_uninhabited() {\n                 let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n                 let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n-                let filename = bx.const_str_slice(filename);\n                 let line = bx.const_u32(loc.line as u32);\n                 let col = bx.const_u32(loc.col.to_usize() as u32 + 1);\n-                let align = self.cx.tcx().data_layout.aggregate_align.abi\n-                    .max(self.cx.tcx().data_layout.i32_align.abi)\n-                    .max(self.cx.tcx().data_layout.pointer_align.abi);\n \n                 let str = format!(\n                     \"Attempted to instantiate uninhabited type {}\",\n                     ty\n                 );\n                 let msg_str = Symbol::intern(&str).as_str();\n-                let msg_str = bx.const_str_slice(msg_str);\n-                let msg_file_line_col = bx.const_struct(\n-                    &[msg_str, filename, line, col],\n-                    false,\n-                );\n-                let msg_file_line_col = bx.static_addr_of(\n-                    msg_file_line_col,\n-                    align,\n-                    Some(\"panic_loc\"),\n+                let msg_file_line_col = bx.static_panic_msg(\n+                    Some(msg_str),\n+                    filename,\n+                    line,\n+                    col,\n+                    \"panic_loc\",\n                 );\n \n                 // Obtain the panic entry point.\n@@ -657,7 +640,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             span_bug!(span, \"shuffle indices must be constant\");\n                         }\n                         mir::Operand::Constant(ref constant) => {\n-                            let c = self.eval_mir_constant(&bx, constant);\n+                            let c = self.eval_mir_constant(constant);\n                             let (llval, ty) = self.simd_shuffle_indices(\n                                 &bx,\n                                 constant.span,"}, {"sha": "3f8dc420cf40278692c33ac0cffd5680a87331d0", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -3,7 +3,7 @@ use rustc_mir::const_eval::const_field;\n use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout;\n+use rustc::ty::layout::{self, HasTyCtxt};\n use syntax::source_map::Span;\n use crate::traits::*;\n \n@@ -12,20 +12,19 @@ use super::FunctionCx;\n impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn eval_mir_constant(\n         &mut self,\n-        bx: &Bx,\n         constant: &mir::Constant<'tcx>,\n     ) -> Result<ty::Const<'tcx>, ErrorHandled> {\n         match constant.literal.val {\n             mir::interpret::ConstValue::Unevaluated(def_id, ref substs) => {\n                 let substs = self.monomorphize(substs);\n                 let instance = ty::Instance::resolve(\n-                    bx.tcx(), ty::ParamEnv::reveal_all(), def_id, substs,\n+                    self.cx.tcx(), ty::ParamEnv::reveal_all(), def_id, substs,\n                 ).unwrap();\n                 let cid = mir::interpret::GlobalId {\n                     instance,\n                     promoted: None,\n                 };\n-                bx.tcx().const_eval(ty::ParamEnv::reveal_all().and(cid))\n+                self.cx.tcx().const_eval(ty::ParamEnv::reveal_all().and(cid))\n             },\n             _ => Ok(*self.monomorphize(&constant.literal)),\n         }"}, {"sha": "91aa9bcc7808bfae7c4e03dfee8ec40a46db654f", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 23, "deletions": 34, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -1,8 +1,6 @@\n-use libc::c_uint;\n use rustc::ty::{self, Ty, TypeFoldable, UpvarSubsts};\n use rustc::ty::layout::{TyLayout, HasTyCtxt};\n use rustc::mir::{self, Mir};\n-use rustc::ty::subst::SubstsRef;\n use rustc::session::config::DebugInfo;\n use rustc_mir::monomorphize::Instance;\n use rustc_target::abi::call::{FnType, PassMode, IgnoreMode};\n@@ -84,9 +82,6 @@ pub struct FunctionCx<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> {\n     /// Debug information for MIR scopes.\n     scopes: IndexVec<mir::SourceScope, debuginfo::MirDebugScope<Bx::DIScope>>,\n \n-    /// If this function is being monomorphized, this contains the type substitutions used.\n-    param_substs: SubstsRef<'tcx>,\n-\n     /// If this function is a C-variadic function, this contains the `PlaceRef` of the\n     /// \"spoofed\" `VaList`.\n     va_list_ref: Option<PlaceRef<'tcx, Bx::Value>>,\n@@ -97,7 +92,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         where T: TypeFoldable<'tcx>\n     {\n         self.cx.tcx().subst_and_normalize_erasing_regions(\n-            self.param_substs,\n+            self.instance.substs,\n             ty::ParamEnv::reveal_all(),\n             value,\n         )\n@@ -109,7 +104,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         source_info: mir::SourceInfo\n     ) {\n         let (scope, span) = self.debug_loc(source_info);\n-        bx.set_source_location(&self.debug_context, scope, span);\n+        bx.set_source_location(&mut self.debug_context, scope, span);\n     }\n \n     pub fn debug_loc(&self, source_info: mir::SourceInfo) -> (Option<Bx::DIScope>, Span) {\n@@ -179,16 +174,16 @@ enum LocalRef<'tcx, V> {\n     Operand(Option<OperandRef<'tcx, V>>),\n }\n \n-impl<'tcx, V: CodegenObject> LocalRef<'tcx, V> {\n-    fn new_operand<Cx: CodegenMethods<'tcx, Value = V>>(\n-        cx: &Cx,\n+impl<'a, 'tcx: 'a, V: CodegenObject> LocalRef<'tcx, V> {\n+    fn new_operand<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        bx: &mut Bx,\n         layout: TyLayout<'tcx>,\n     ) -> LocalRef<'tcx, V> {\n         if layout.is_zst() {\n             // Zero-size temporaries aren't always initialized, which\n             // doesn't matter because they don't contain data, but\n             // we need something in the operand.\n-            LocalRef::Operand(Some(OperandRef::new_zst(cx, layout)))\n+            LocalRef::Operand(Some(OperandRef::new_zst(bx, layout)))\n         } else {\n             LocalRef::Operand(None)\n         }\n@@ -204,9 +199,11 @@ pub fn codegen_mir<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     instance: Instance<'tcx>,\n     sig: ty::FnSig<'tcx>,\n ) {\n+    assert!(!instance.substs.needs_infer());\n+\n     let fn_ty = cx.new_fn_type(sig, &[]);\n     debug!(\"fn_ty: {:?}\", fn_ty);\n-    let debug_context =\n+    let mut debug_context =\n         cx.create_function_debug_context(instance, sig, llfn, mir);\n     let mut bx = Bx::new_block(cx, llfn, \"start\");\n \n@@ -228,7 +225,7 @@ pub fn codegen_mir<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n         }).collect();\n \n     // Compute debuginfo scopes from MIR scopes.\n-    let scopes = cx.create_mir_scopes(mir, &debug_context);\n+    let scopes = cx.create_mir_scopes(mir, &mut debug_context);\n     let (landing_pads, funclets) = create_funclets(mir, &mut bx, &cleanup_kinds, &block_bxs);\n \n     let mut fx = FunctionCx {\n@@ -246,10 +243,6 @@ pub fn codegen_mir<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n         scopes,\n         locals: IndexVec::new(),\n         debug_context,\n-        param_substs: {\n-            assert!(!instance.substs.needs_infer());\n-            instance.substs\n-        },\n         va_list_ref: None,\n     };\n \n@@ -260,7 +253,7 @@ pub fn codegen_mir<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n         // FIXME(dlrobertson): This is ugly. Find a better way of getting the `PlaceRef` or\n         // `LocalRef` from `arg_local_refs`\n         let mut va_list_ref = None;\n-        let args = arg_local_refs(&mut bx, &fx, &fx.scopes, &memory_locals, &mut va_list_ref);\n+        let args = arg_local_refs(&mut bx, &fx, &memory_locals, &mut va_list_ref);\n         fx.va_list_ref = va_list_ref;\n \n         let mut allocate_local = |local| {\n@@ -276,7 +269,7 @@ pub fn codegen_mir<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n \n                 if !memory_locals.contains(local) && !dbg {\n                     debug!(\"alloc: {:?} ({}) -> operand\", local, name);\n-                    return LocalRef::new_operand(bx.cx(), layout);\n+                    return LocalRef::new_operand(&mut bx, layout);\n                 }\n \n                 debug!(\"alloc: {:?} ({}) -> place\", local, name);\n@@ -302,7 +295,7 @@ pub fn codegen_mir<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n                 // Temporary or return place\n                 if local == mir::RETURN_PLACE && fx.fn_ty.ret.is_indirect() {\n                     debug!(\"alloc: {:?} (return place) -> place\", local);\n-                    let llretptr = fx.cx.get_param(llfn, 0);\n+                    let llretptr = bx.get_param(0);\n                     LocalRef::Place(PlaceRef::new_sized(llretptr, layout, layout.align.abi))\n                 } else if memory_locals.contains(local) {\n                     debug!(\"alloc: {:?} -> place\", local);\n@@ -321,7 +314,7 @@ pub fn codegen_mir<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n                     // alloca in advance. Instead we wait until we see the\n                     // definition and update the operand there.\n                     debug!(\"alloc: {:?} -> operand\", local);\n-                    LocalRef::new_operand(bx.cx(), layout)\n+                    LocalRef::new_operand(&mut bx, layout)\n                 }\n             }\n         };\n@@ -341,7 +334,7 @@ pub fn codegen_mir<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     // Up until here, IR instructions for this function have explicitly not been annotated with\n     // source code location, so we don't step into call setup code. From here on, source location\n     // emitting should be enabled.\n-    debuginfo::start_emitting_source_locations(&fx.debug_context);\n+    debuginfo::start_emitting_source_locations(&mut fx.debug_context);\n \n     let rpo = traversal::reverse_postorder(&mir);\n     let mut visited = BitSet::new_empty(mir.basic_blocks().len());\n@@ -437,10 +430,6 @@ fn create_funclets<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     fx: &FunctionCx<'a, 'tcx, Bx>,\n-    scopes: &IndexVec<\n-        mir::SourceScope,\n-        debuginfo::MirDebugScope<Bx::DIScope>\n-    >,\n     memory_locals: &BitSet<mir::Local>,\n     va_list_ref: &mut Option<PlaceRef<'tcx, Bx::Value>>,\n ) -> Vec<LocalRef<'tcx, Bx::Value>> {\n@@ -450,7 +439,7 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     let mut llarg_idx = fx.fn_ty.ret.is_indirect() as usize;\n \n     // Get the argument scope, if it exists and if we need it.\n-    let arg_scope = scopes[mir::OUTERMOST_SOURCE_SCOPE];\n+    let arg_scope = fx.scopes[mir::OUTERMOST_SOURCE_SCOPE];\n     let arg_scope = if bx.sess().opts.debuginfo == DebugInfo::Full {\n         arg_scope.scope_metadata\n     } else {\n@@ -530,22 +519,22 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n             let local = |op| LocalRef::Operand(Some(op));\n             match arg.mode {\n                 PassMode::Ignore(IgnoreMode::Zst) => {\n-                    return local(OperandRef::new_zst(bx.cx(), arg.layout));\n+                    return local(OperandRef::new_zst(bx, arg.layout));\n                 }\n                 PassMode::Ignore(IgnoreMode::CVarArgs) => {}\n                 PassMode::Direct(_) => {\n-                    let llarg = bx.get_param(bx.llfn(), llarg_idx as c_uint);\n+                    let llarg = bx.get_param(llarg_idx);\n                     bx.set_value_name(llarg, &name);\n                     llarg_idx += 1;\n                     return local(\n                         OperandRef::from_immediate_or_packed_pair(bx, llarg, arg.layout));\n                 }\n                 PassMode::Pair(..) => {\n-                    let a = bx.get_param(bx.llfn(), llarg_idx as c_uint);\n+                    let a = bx.get_param(llarg_idx);\n                     bx.set_value_name(a, &(name.clone() + \".0\"));\n                     llarg_idx += 1;\n \n-                    let b = bx.get_param(bx.llfn(), llarg_idx as c_uint);\n+                    let b = bx.get_param(llarg_idx);\n                     bx.set_value_name(b, &(name + \".1\"));\n                     llarg_idx += 1;\n \n@@ -562,16 +551,16 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n             // Don't copy an indirect argument to an alloca, the caller\n             // already put it in a temporary alloca and gave it up.\n             // FIXME: lifetimes\n-            let llarg = bx.get_param(bx.llfn(), llarg_idx as c_uint);\n+            let llarg = bx.get_param(llarg_idx);\n             bx.set_value_name(llarg, &name);\n             llarg_idx += 1;\n             PlaceRef::new_sized(llarg, arg.layout, arg.layout.align.abi)\n         } else if arg.is_unsized_indirect() {\n             // As the storage for the indirect argument lives during\n             // the whole function call, we just copy the fat pointer.\n-            let llarg = bx.get_param(bx.llfn(), llarg_idx as c_uint);\n+            let llarg = bx.get_param(llarg_idx);\n             llarg_idx += 1;\n-            let llextra = bx.get_param(bx.llfn(), llarg_idx as c_uint);\n+            let llextra = bx.get_param(llarg_idx);\n             llarg_idx += 1;\n             let indirect_operand = OperandValue::Pair(llarg, llextra);\n "}, {"sha": "c2b1021f816a60a055cca81e72a74cd57317cd4f", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -54,13 +54,13 @@ impl<V: CodegenObject> fmt::Debug for OperandRef<'tcx, V> {\n }\n \n impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n-    pub fn new_zst<Cx: CodegenMethods<'tcx, Value = V>>(\n-        cx: &Cx,\n+    pub fn new_zst<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        bx: &mut Bx,\n         layout: TyLayout<'tcx>\n     ) -> OperandRef<'tcx, V> {\n         assert!(layout.is_zst());\n         OperandRef {\n-            val: OperandValue::Immediate(cx.const_undef(cx.immediate_backend_type(layout))),\n+            val: OperandValue::Immediate(bx.const_undef(bx.immediate_backend_type(layout))),\n             layout\n         }\n     }\n@@ -69,10 +69,10 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n         bx: &mut Bx,\n         val: ty::Const<'tcx>\n     ) -> Result<Self, ErrorHandled> {\n-        let layout = bx.cx().layout_of(val.ty);\n+        let layout = bx.layout_of(val.ty);\n \n         if layout.is_zst() {\n-            return Ok(OperandRef::new_zst(bx.cx(), layout));\n+            return Ok(OperandRef::new_zst(bx, layout));\n         }\n \n         let val = match val.val {\n@@ -84,10 +84,10 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n                     layout::Abi::Scalar(ref x) => x,\n                     _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout)\n                 };\n-                let llval = bx.cx().scalar_to_backend(\n+                let llval = bx.scalar_to_backend(\n                     x,\n                     scalar,\n-                    bx.cx().immediate_backend_type(layout),\n+                    bx.immediate_backend_type(layout),\n                 );\n                 OperandValue::Immediate(llval)\n             },\n@@ -96,16 +96,16 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n                     layout::Abi::ScalarPair(ref a, _) => a,\n                     _ => bug!(\"from_const: invalid ScalarPair layout: {:#?}\", layout)\n                 };\n-                let a_llval = bx.cx().scalar_to_backend(\n+                let a_llval = bx.scalar_to_backend(\n                     a,\n                     a_scalar,\n-                    bx.cx().scalar_pair_element_backend_type(layout, 0, true),\n+                    bx.scalar_pair_element_backend_type(layout, 0, true),\n                 );\n-                let b_llval = bx.cx().const_usize(b);\n+                let b_llval = bx.const_usize(b);\n                 OperandValue::Pair(a_llval, b_llval)\n             },\n             ConstValue::ByRef(ptr, alloc) => {\n-                return Ok(bx.load_operand(bx.cx().from_const_alloc(layout, alloc, ptr.offset)));\n+                return Ok(bx.load_operand(bx.from_const_alloc(layout, alloc, ptr.offset)));\n             },\n         };\n \n@@ -124,7 +124,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n         }\n     }\n \n-    pub fn deref<Cx: CodegenMethods<'tcx, Value = V>>(\n+    pub fn deref<Cx: LayoutTypeMethods<'tcx>>(\n         self,\n         cx: &Cx\n     ) -> PlaceRef<'tcx, V> {\n@@ -199,7 +199,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n         let mut val = match (self.val, &self.layout.abi) {\n             // If the field is ZST, it has no data.\n             _ if field.is_zst() => {\n-                return OperandRef::new_zst(bx.cx(), field);\n+                return OperandRef::new_zst(bx, field);\n             }\n \n             // Newtype of a scalar, scalar pair or vector.\n@@ -409,7 +409,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         // checks in `codegen_consume` and `extract_field`.\n                         let elem = o.layout.field(bx.cx(), 0);\n                         if elem.is_zst() {\n-                            return Some(OperandRef::new_zst(bx.cx(), elem));\n+                            return Some(OperandRef::new_zst(bx, elem));\n                         }\n                     }\n                     _ => {}\n@@ -432,7 +432,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // ZSTs don't require any actual memory access.\n         if layout.is_zst() {\n-            return OperandRef::new_zst(bx.cx(), layout);\n+            return OperandRef::new_zst(bx, layout);\n         }\n \n         if let Some(o) = self.maybe_codegen_consume_direct(bx, place) {\n@@ -460,7 +460,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n             mir::Operand::Constant(ref constant) => {\n                 let ty = self.monomorphize(&constant.ty);\n-                self.eval_mir_constant(bx, constant)\n+                self.eval_mir_constant(constant)\n                     .and_then(|c| OperandRef::from_const(bx, c))\n                     .unwrap_or_else(|err| {\n                         match err {"}, {"sha": "bf2afbbabab96c23ac7b6ec8d38ac5d8326c7bcc", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -80,7 +80,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n         Self::alloca(bx, ptr_layout, name)\n     }\n \n-    pub fn len<Cx: CodegenMethods<'tcx, Value = V>>(\n+    pub fn len<Cx: ConstMethods<'tcx, Value = V>>(\n         &self,\n         cx: &Cx\n     ) -> V {\n@@ -447,7 +447,8 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 // NB: The layout of a static may be unsized as is the case when working\n                 // with a static that is an extern_type.\n                 let layout = cx.layout_of(self.monomorphize(&ty));\n-                PlaceRef::new_thin_place(bx, bx.get_static(def_id), layout, layout.align.abi)\n+                let static_ = bx.get_static(def_id);\n+                PlaceRef::new_thin_place(bx, static_, layout, layout.align.abi)\n             },\n             mir::Place::Projection(box mir::Projection {\n                 ref base,"}, {"sha": "7a31c5b3950e0ab9a0c562f043da37c5756ea430", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 9, "deletions": 27, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -87,11 +87,11 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 if dest.layout.is_zst() {\n                     return bx;\n                 }\n-                let zero = bx.cx().const_usize(0);\n-                let start = dest.project_index(&mut bx, zero).llval;\n \n                 if let OperandValue::Immediate(v) = cg_elem.val {\n-                    let size = bx.cx().const_usize(dest.layout.size.bytes());\n+                    let zero = bx.const_usize(0);\n+                    let start = dest.project_index(&mut bx, zero).llval;\n+                    let size = bx.const_usize(dest.layout.size.bytes());\n \n                     // Use llvm.memset.p0i8.* to initialize all zero arrays\n                     if bx.cx().is_const_integral(v) && bx.cx().const_to_uint(v) == 0 {\n@@ -108,28 +108,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     }\n                 }\n \n-                let count = bx.cx().const_usize(count);\n-                let end = dest.project_index(&mut bx, count).llval;\n-\n-                let mut header_bx = bx.build_sibling_block(\"repeat_loop_header\");\n-                let mut body_bx = bx.build_sibling_block(\"repeat_loop_body\");\n-                let next_bx = bx.build_sibling_block(\"repeat_loop_next\");\n-\n-                bx.br(header_bx.llbb());\n-                let current = header_bx.phi(bx.cx().val_ty(start), &[start], &[bx.llbb()]);\n-\n-                let keep_going = header_bx.icmp(IntPredicate::IntNE, current, end);\n-                header_bx.cond_br(keep_going, body_bx.llbb(), next_bx.llbb());\n-\n-                let align = dest.align.restrict_for_offset(dest.layout.field(bx.cx(), 0).size);\n-                cg_elem.val.store(&mut body_bx,\n-                    PlaceRef::new_sized(current, cg_elem.layout, align));\n-\n-                let next = body_bx.inbounds_gep(current, &[bx.cx().const_usize(1)]);\n-                body_bx.br(header_bx.llbb());\n-                header_bx.add_incoming_to_phi(current, next, body_bx.llbb());\n-\n-                next_bx\n+                bx.write_operand_repeatedly(cg_elem, count, dest)\n             }\n \n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n@@ -523,8 +502,11 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 // According to `rvalue_creates_operand`, only ZST\n                 // aggregate rvalues are allowed to be operands.\n                 let ty = rvalue.ty(self.mir, self.cx.tcx());\n-                (bx, OperandRef::new_zst(self.cx,\n-                    self.cx.layout_of(self.monomorphize(&ty))))\n+                let operand = OperandRef::new_zst(\n+                    &mut bx,\n+                    self.cx.layout_of(self.monomorphize(&ty)),\n+                );\n+                (bx, operand)\n             }\n         }\n     }"}, {"sha": "a8fd4e1d2c7c756853466f47edb41708ece38c67", "filename": "src/librustc_codegen_ssa/traits/abi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Ftraits%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Ftraits%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fabi.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -10,4 +10,5 @@ pub trait AbiMethods<'tcx> {\n \n pub trait AbiBuilderMethods<'tcx>: BackendTypes {\n     fn apply_attrs_callsite(&mut self, ty: &FnType<'tcx, Ty<'tcx>>, callsite: Self::Value);\n+    fn get_param(&self, index: usize) -> Self::Value;\n }"}, {"sha": "48142fc9fa9f4e328d681a4d310e68c1efa9704d", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 12, "deletions": 72, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -11,11 +11,8 @@ use crate::mir::place::PlaceRef;\n use crate::MemFlags;\n use rustc::ty::Ty;\n use rustc::ty::layout::{Align, Size};\n-use std::ffi::CStr;\n-\n-use std::borrow::Cow;\n use std::ops::Range;\n-use syntax::ast::AsmDialect;\n+use std::iter::TrustedLen;\n \n #[derive(Copy, Clone)]\n pub enum OverflowOp {\n@@ -37,13 +34,9 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n     fn with_cx(cx: &'a Self::CodegenCx) -> Self;\n     fn build_sibling_block<'b>(&self, name: &'b str) -> Self;\n     fn cx(&self) -> &Self::CodegenCx;\n-    fn llfn(&self) -> Self::Value;\n     fn llbb(&self) -> Self::BasicBlock;\n-    fn count_insn(&self, category: &str);\n \n-    fn set_value_name(&mut self, value: Self::Value, name: &str);\n     fn position_at_end(&mut self, llbb: Self::BasicBlock);\n-    fn position_at_start(&mut self, llbb: Self::BasicBlock);\n     fn ret_void(&mut self);\n     fn ret(&mut self, v: Self::Value);\n     fn br(&mut self, dest: Self::BasicBlock);\n@@ -57,8 +50,8 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n         &mut self,\n         v: Self::Value,\n         else_llbb: Self::BasicBlock,\n-        num_cases: usize,\n-    ) -> Self::Value;\n+        cases: impl ExactSizeIterator<Item = (u128, Self::BasicBlock)> + TrustedLen,\n+    );\n     fn invoke(\n         &mut self,\n         llfn: Self::Value,\n@@ -68,6 +61,7 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n         funclet: Option<&Self::Funclet>,\n     ) -> Self::Value;\n     fn unreachable(&mut self);\n+\n     fn add(&mut self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n     fn fadd(&mut self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n     fn fadd_fast(&mut self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n@@ -121,6 +115,14 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n     fn load_operand(&mut self, place: PlaceRef<'tcx, Self::Value>)\n         -> OperandRef<'tcx, Self::Value>;\n \n+        /// Called for Rvalue::Repeat when the elem is neither a ZST nor optimizable using memset.\n+    fn write_operand_repeatedly(\n+        self,\n+        elem: OperandRef<'tcx, Self::Value>,\n+        count: u64,\n+        dest: PlaceRef<'tcx, Self::Value>,\n+    ) -> Self;\n+\n     fn range_metadata(&mut self, load: Self::Value, range: Range<u128>);\n     fn nonnull_metadata(&mut self, load: Self::Value);\n \n@@ -161,24 +163,6 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n     fn icmp(&mut self, op: IntPredicate, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n     fn fcmp(&mut self, op: RealPredicate, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n \n-    fn empty_phi(&mut self, ty: Self::Type) -> Self::Value;\n-    fn phi(\n-        &mut self,\n-        ty: Self::Type,\n-        vals: &[Self::Value],\n-        bbs: &[Self::BasicBlock],\n-    ) -> Self::Value;\n-    fn inline_asm_call(\n-        &mut self,\n-        asm: &CStr,\n-        cons: &CStr,\n-        inputs: &[Self::Value],\n-        output: Self::Type,\n-        volatile: bool,\n-        alignstack: bool,\n-        dia: AsmDialect,\n-    ) -> Option<Self::Value>;\n-\n     fn memcpy(\n         &mut self,\n         dst: Self::Value,\n@@ -206,8 +190,6 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n         flags: MemFlags,\n     );\n \n-    fn minnum(&mut self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n-    fn maxnum(&mut self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n     fn select(\n         &mut self,\n         cond: Self::Value,\n@@ -217,32 +199,7 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n \n     fn va_arg(&mut self, list: Self::Value, ty: Self::Type) -> Self::Value;\n     fn extract_element(&mut self, vec: Self::Value, idx: Self::Value) -> Self::Value;\n-    fn insert_element(\n-        &mut self,\n-        vec: Self::Value,\n-        elt: Self::Value,\n-        idx: Self::Value,\n-    ) -> Self::Value;\n-    fn shuffle_vector(\n-        &mut self,\n-        v1: Self::Value,\n-        v2: Self::Value,\n-        mask: Self::Value,\n-    ) -> Self::Value;\n     fn vector_splat(&mut self, num_elts: usize, elt: Self::Value) -> Self::Value;\n-    fn vector_reduce_fadd_fast(&mut self, acc: Self::Value, src: Self::Value) -> Self::Value;\n-    fn vector_reduce_fmul_fast(&mut self, acc: Self::Value, src: Self::Value) -> Self::Value;\n-    fn vector_reduce_add(&mut self, src: Self::Value) -> Self::Value;\n-    fn vector_reduce_mul(&mut self, src: Self::Value) -> Self::Value;\n-    fn vector_reduce_and(&mut self, src: Self::Value) -> Self::Value;\n-    fn vector_reduce_or(&mut self, src: Self::Value) -> Self::Value;\n-    fn vector_reduce_xor(&mut self, src: Self::Value) -> Self::Value;\n-    fn vector_reduce_fmin(&mut self, src: Self::Value) -> Self::Value;\n-    fn vector_reduce_fmax(&mut self, src: Self::Value) -> Self::Value;\n-    fn vector_reduce_fmin_fast(&mut self, src: Self::Value) -> Self::Value;\n-    fn vector_reduce_fmax_fast(&mut self, src: Self::Value) -> Self::Value;\n-    fn vector_reduce_min(&mut self, src: Self::Value, is_signed: bool) -> Self::Value;\n-    fn vector_reduce_max(&mut self, src: Self::Value, is_signed: bool) -> Self::Value;\n     fn extract_value(&mut self, agg_val: Self::Value, idx: u64) -> Self::Value;\n     fn insert_value(&mut self, agg_val: Self::Value, elt: Self::Value, idx: u64) -> Self::Value;\n \n@@ -252,7 +209,6 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n         pers_fn: Self::Value,\n         num_clauses: usize,\n     ) -> Self::Value;\n-    fn add_clause(&mut self, landing_pad: Self::Value, clause: Self::Value);\n     fn set_cleanup(&mut self, landing_pad: Self::Value);\n     fn resume(&mut self, exn: Self::Value) -> Self::Value;\n     fn cleanup_pad(&mut self, parent: Option<Self::Value>, args: &[Self::Value]) -> Self::Funclet;\n@@ -262,7 +218,6 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n         unwind: Option<Self::BasicBlock>,\n     ) -> Self::Value;\n     fn catch_pad(&mut self, parent: Self::Value, args: &[Self::Value]) -> Self::Funclet;\n-    fn catch_ret(&mut self, funclet: &Self::Funclet, unwind: Self::BasicBlock) -> Self::Value;\n     fn catch_switch(\n         &mut self,\n         parent: Option<Self::Value>,\n@@ -289,23 +244,8 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n         order: AtomicOrdering,\n     ) -> Self::Value;\n     fn atomic_fence(&mut self, order: AtomicOrdering, scope: SynchronizationScope);\n-    fn add_case(&mut self, s: Self::Value, on_val: Self::Value, dest: Self::BasicBlock);\n-    fn add_incoming_to_phi(&mut self, phi: Self::Value, val: Self::Value, bb: Self::BasicBlock);\n     fn set_invariant_load(&mut self, load: Self::Value);\n \n-    /// Returns the ptr value that should be used for storing `val`.\n-    fn check_store(&mut self, val: Self::Value, ptr: Self::Value) -> Self::Value;\n-\n-    /// Returns the args that should be used for a call to `llfn`.\n-    fn check_call<'b>(\n-        &mut self,\n-        typ: &str,\n-        llfn: Self::Value,\n-        args: &'b [Self::Value],\n-    ) -> Cow<'b, [Self::Value]>\n-    where\n-        [Self::Value]: ToOwned;\n-\n     /// Called for `StorageLive`\n     fn lifetime_start(&mut self, ptr: Self::Value, size: Size);\n "}, {"sha": "32412f303c155efc0f4a745fa29da80fe168ebf2", "filename": "src/librustc_codegen_ssa/traits/consts.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -3,7 +3,6 @@ use crate::mir::place::PlaceRef;\n use rustc::mir::interpret::Allocation;\n use rustc::mir::interpret::Scalar;\n use rustc::ty::layout;\n-use syntax::symbol::LocalInternedString;\n \n pub trait ConstMethods<'tcx>: BackendTypes {\n     // Constant constructors\n@@ -19,24 +18,12 @@ pub trait ConstMethods<'tcx>: BackendTypes {\n     fn const_usize(&self, i: u64) -> Self::Value;\n     fn const_u8(&self, i: u8) -> Self::Value;\n \n-    // This is a 'c-like' raw string, which differs from\n-    // our boxed-and-length-annotated strings.\n-    fn const_cstr(&self, s: LocalInternedString, null_terminated: bool) -> Self::Value;\n-\n-    fn const_str_slice(&self, s: LocalInternedString) -> Self::Value;\n-    fn const_fat_ptr(&self, ptr: Self::Value, meta: Self::Value) -> Self::Value;\n     fn const_struct(&self, elts: &[Self::Value], packed: bool) -> Self::Value;\n-    fn const_array(&self, ty: Self::Type, elts: &[Self::Value]) -> Self::Value;\n-    fn const_vector(&self, elts: &[Self::Value]) -> Self::Value;\n-    fn const_bytes(&self, bytes: &[u8]) -> Self::Value;\n \n-    fn const_get_elt(&self, v: Self::Value, idx: u64) -> Self::Value;\n-    fn const_get_real(&self, v: Self::Value) -> Option<(f64, bool)>;\n     fn const_to_uint(&self, v: Self::Value) -> u64;\n     fn const_to_opt_u128(&self, v: Self::Value, sign_ext: bool) -> Option<u128>;\n \n     fn is_const_integral(&self, v: Self::Value) -> bool;\n-    fn is_const_real(&self, v: Self::Value) -> bool;\n \n     fn scalar_to_backend(\n         &self,"}, {"sha": "a0b53fde09c4d975826cb6d9def717a6001a307c", "filename": "src/librustc_codegen_ssa/traits/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -28,7 +28,7 @@ pub trait DebugInfoMethods<'tcx>: BackendTypes {\n     fn create_mir_scopes(\n         &self,\n         mir: &mir::Mir<'_>,\n-        debug_context: &FunctionDebugContext<Self::DIScope>,\n+        debug_context: &mut FunctionDebugContext<Self::DIScope>,\n     ) -> IndexVec<mir::SourceScope, MirDebugScope<Self::DIScope>>;\n     fn extend_scope_to_file(\n         &self,\n@@ -53,9 +53,10 @@ pub trait DebugInfoBuilderMethods<'tcx>: BackendTypes {\n     );\n     fn set_source_location(\n         &mut self,\n-        debug_context: &FunctionDebugContext<Self::DIScope>,\n+        debug_context: &mut FunctionDebugContext<Self::DIScope>,\n         scope: Option<Self::DIScope>,\n         span: Span,\n     );\n     fn insert_reference_to_gdb_debug_scripts_section_global(&mut self);\n+    fn set_value_name(&mut self, value: Self::Value, name: &str);\n }"}, {"sha": "2797dd89f5b1599c3958122f7e8899ab07d18e12", "filename": "src/librustc_codegen_ssa/traits/misc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -1,5 +1,4 @@\n use super::BackendTypes;\n-use libc::c_uint;\n use rustc::mir::mono::Stats;\n use rustc::session::Session;\n use rustc::ty::{self, Instance, Ty};\n@@ -15,7 +14,6 @@ pub trait MiscMethods<'tcx>: BackendTypes {\n     fn check_overflow(&self) -> bool;\n     fn instances(&self) -> &RefCell<FxHashMap<Instance<'tcx>, Self::Value>>;\n     fn get_fn(&self, instance: Instance<'tcx>) -> Self::Value;\n-    fn get_param(&self, llfn: Self::Value, index: c_uint) -> Self::Value;\n     fn eh_personality(&self) -> Self::Value;\n     fn eh_unwind_resume(&self) -> Self::Value;\n     fn sess(&self) -> &Session;"}, {"sha": "d8992c159337dc3d3490b58258328555c7bdc3f5", "filename": "src/librustc_codegen_ssa/traits/statics.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -1,4 +1,5 @@\n use super::BackendTypes;\n+use syntax_pos::symbol::LocalInternedString;\n use rustc::hir::def_id::DefId;\n use rustc::ty::layout::Align;\n \n@@ -8,5 +9,13 @@ pub trait StaticMethods: BackendTypes {\n }\n \n pub trait StaticBuilderMethods<'tcx>: BackendTypes {\n-    fn get_static(&self, def_id: DefId) -> Self::Value;\n+    fn get_static(&mut self, def_id: DefId) -> Self::Value;\n+    fn static_panic_msg(\n+        &mut self,\n+        msg: Option<LocalInternedString>,\n+        filename: LocalInternedString,\n+        line: Self::Value,\n+        col: Self::Value,\n+        kind: &str,\n+    ) -> Self::Value;\n }"}, {"sha": "7fb2cb9d39362d1adae49b0683223496dfd2bbbd", "filename": "src/librustc_codegen_ssa/traits/type_.rs", "status": "modified", "additions": 6, "deletions": 69, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26714219f1c5f8c748f95198d0824551ea2e0eeb/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs?ref=26714219f1c5f8c748f95198d0824551ea2e0eeb", "patch": "@@ -1,62 +1,45 @@\n use super::misc::MiscMethods;\n use super::Backend;\n use super::HasCodegen;\n-use crate::common::{self, TypeKind};\n+use crate::common::TypeKind;\n use crate::mir::place::PlaceRef;\n-use rustc::ty::layout::{self, Align, Size, TyLayout};\n use rustc::ty::{self, Ty};\n-use rustc::util::nodemap::FxHashMap;\n+use rustc::ty::layout::{self, TyLayout};\n use rustc_target::abi::call::{ArgType, CastTarget, FnType, Reg};\n-use std::cell::RefCell;\n-use syntax::ast;\n+use syntax_pos::DUMMY_SP;\n \n // This depends on `Backend` and not `BackendTypes`, because consumers will probably want to use\n // `LayoutOf` or `HasTyCtxt`. This way, they don't have to add a constraint on it themselves.\n pub trait BaseTypeMethods<'tcx>: Backend<'tcx> {\n-    fn type_void(&self) -> Self::Type;\n-    fn type_metadata(&self) -> Self::Type;\n     fn type_i1(&self) -> Self::Type;\n     fn type_i8(&self) -> Self::Type;\n     fn type_i16(&self) -> Self::Type;\n     fn type_i32(&self) -> Self::Type;\n     fn type_i64(&self) -> Self::Type;\n     fn type_i128(&self) -> Self::Type;\n-\n-    // Creates an integer type with the given number of bits, e.g., i24\n-    fn type_ix(&self, num_bits: u64) -> Self::Type;\n     fn type_isize(&self) -> Self::Type;\n \n     fn type_f32(&self) -> Self::Type;\n     fn type_f64(&self) -> Self::Type;\n-    fn type_x86_mmx(&self) -> Self::Type;\n \n     fn type_func(&self, args: &[Self::Type], ret: Self::Type) -> Self::Type;\n-    fn type_variadic_func(&self, args: &[Self::Type], ret: Self::Type) -> Self::Type;\n     fn type_struct(&self, els: &[Self::Type], packed: bool) -> Self::Type;\n-    fn type_array(&self, ty: Self::Type, len: u64) -> Self::Type;\n-    fn type_vector(&self, ty: Self::Type, len: u64) -> Self::Type;\n     fn type_kind(&self, ty: Self::Type) -> TypeKind;\n     fn type_ptr_to(&self, ty: Self::Type) -> Self::Type;\n     fn element_type(&self, ty: Self::Type) -> Self::Type;\n \n     /// Returns the number of elements in `self` if it is a LLVM vector type.\n     fn vector_length(&self, ty: Self::Type) -> usize;\n \n-    fn func_params_types(&self, ty: Self::Type) -> Vec<Self::Type>;\n     fn float_width(&self, ty: Self::Type) -> usize;\n \n     /// Retrieves the bit width of the integer type `self`.\n     fn int_width(&self, ty: Self::Type) -> u64;\n \n     fn val_ty(&self, v: Self::Value) -> Self::Type;\n-    fn scalar_lltypes(&self) -> &RefCell<FxHashMap<Ty<'tcx>, Self::Type>>;\n }\n \n pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n-    fn type_bool(&self) -> Self::Type {\n-        self.type_i8()\n-    }\n-\n     fn type_i8p(&self) -> Self::Type {\n         self.type_ptr_to(self.type_i8())\n     }\n@@ -70,35 +53,6 @@ pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n         }\n     }\n \n-    fn type_int_from_ty(&self, t: ast::IntTy) -> Self::Type {\n-        match t {\n-            ast::IntTy::Isize => self.type_isize(),\n-            ast::IntTy::I8 => self.type_i8(),\n-            ast::IntTy::I16 => self.type_i16(),\n-            ast::IntTy::I32 => self.type_i32(),\n-            ast::IntTy::I64 => self.type_i64(),\n-            ast::IntTy::I128 => self.type_i128(),\n-        }\n-    }\n-\n-    fn type_uint_from_ty(&self, t: ast::UintTy) -> Self::Type {\n-        match t {\n-            ast::UintTy::Usize => self.type_isize(),\n-            ast::UintTy::U8 => self.type_i8(),\n-            ast::UintTy::U16 => self.type_i16(),\n-            ast::UintTy::U32 => self.type_i32(),\n-            ast::UintTy::U64 => self.type_i64(),\n-            ast::UintTy::U128 => self.type_i128(),\n-        }\n-    }\n-\n-    fn type_float_from_ty(&self, t: ast::FloatTy) -> Self::Type {\n-        match t {\n-            ast::FloatTy::F32 => self.type_f32(),\n-            ast::FloatTy::F64 => self.type_f64(),\n-        }\n-    }\n-\n     fn type_from_integer(&self, i: layout::Integer) -> Self::Type {\n         use rustc::ty::layout::Integer::*;\n         match i {\n@@ -110,32 +64,16 @@ pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n         }\n     }\n \n-    fn type_pointee_for_align(&self, align: Align) -> Self::Type {\n-        // FIXME(eddyb) We could find a better approximation if ity.align < align.\n-        let ity = layout::Integer::approximate_align(self, align);\n-        self.type_from_integer(ity)\n-    }\n-\n-    /// Return a LLVM type that has at most the required alignment,\n-    /// and exactly the required size, as a best-effort padding array.\n-    fn type_padding_filler(&self, size: Size, align: Align) -> Self::Type {\n-        let unit = layout::Integer::approximate_align(self, align);\n-        let size = size.bytes();\n-        let unit_size = unit.size().bytes();\n-        assert_eq!(size % unit_size, 0);\n-        self.type_array(self.type_from_integer(unit), size / unit_size)\n-    }\n-\n     fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n-        common::type_needs_drop(self.tcx(), ty)\n+        ty.needs_drop(self.tcx(), ty::ParamEnv::reveal_all())\n     }\n \n     fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n-        common::type_is_sized(self.tcx(), ty)\n+        ty.is_sized(self.tcx().at(DUMMY_SP), ty::ParamEnv::reveal_all())\n     }\n \n     fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n-        common::type_is_freeze(self.tcx(), ty)\n+        ty.is_freeze(self.tcx(), ty::ParamEnv::reveal_all(), DUMMY_SP)\n     }\n \n     fn type_has_metadata(&self, ty: Ty<'tcx>) -> bool {\n@@ -158,7 +96,6 @@ impl<T> DerivedTypeMethods<'tcx> for T where Self: BaseTypeMethods<'tcx> + MiscM\n pub trait LayoutTypeMethods<'tcx>: Backend<'tcx> {\n     fn backend_type(&self, layout: TyLayout<'tcx>) -> Self::Type;\n     fn cast_backend_type(&self, ty: &CastTarget) -> Self::Type;\n-    fn fn_backend_type(&self, ty: &FnType<'tcx, Ty<'tcx>>) -> Self::Type;\n     fn fn_ptr_backend_type(&self, ty: &FnType<'tcx, Ty<'tcx>>) -> Self::Type;\n     fn reg_backend_type(&self, ty: &Reg) -> Self::Type;\n     fn immediate_backend_type(&self, layout: TyLayout<'tcx>) -> Self::Type;"}]}