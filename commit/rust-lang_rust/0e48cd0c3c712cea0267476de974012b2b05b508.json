{"sha": "0e48cd0c3c712cea0267476de974012b2b05b508", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlNDhjZDBjM2M3MTJjZWEwMjY3NDc2ZGU5NzQwMTJiMmIwNWI1MDg=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-12-28T09:41:08Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-12-28T13:06:10Z"}, "message": "Draft the module exclusion in modules", "tree": {"sha": "e8b0e719409110f077e72a34242e9853e5fc5031", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8b0e719409110f077e72a34242e9853e5fc5031"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e48cd0c3c712cea0267476de974012b2b05b508", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e48cd0c3c712cea0267476de974012b2b05b508", "html_url": "https://github.com/rust-lang/rust/commit/0e48cd0c3c712cea0267476de974012b2b05b508", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e48cd0c3c712cea0267476de974012b2b05b508/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77ad203a719be074e81485af7a4fb02fac6cbf61", "url": "https://api.github.com/repos/rust-lang/rust/commits/77ad203a719be074e81485af7a4fb02fac6cbf61", "html_url": "https://github.com/rust-lang/rust/commit/77ad203a719be074e81485af7a4fb02fac6cbf61"}], "stats": {"total": 108, "additions": 71, "deletions": 37}, "files": [{"sha": "3d72a08b4433daafa947824f2090176c1836de54", "filename": "crates/completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e48cd0c3c712cea0267476de974012b2b05b508/crates%2Fcompletion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e48cd0c3c712cea0267476de974012b2b05b508/crates%2Fcompletion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=0e48cd0c3c712cea0267476de974012b2b05b508", "patch": "@@ -135,7 +135,7 @@ fn fuzzy_completion(acc: &mut Completions, ctx: &CompletionContext) -> Option<()\n         ctx.krate?,\n         Some(100),\n         &potential_import_name,\n-        true,\n+        false,\n     )\n     .filter_map(|import_candidate| {\n         Some(match import_candidate {"}, {"sha": "64d0ec471743250257f3d31b5e0bae6abc0b4e70", "filename": "crates/hir_def/src/import_map.rs", "status": "modified", "additions": 62, "deletions": 34, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/0e48cd0c3c712cea0267476de974012b2b05b508/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e48cd0c3c712cea0267476de974012b2b05b508/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fimport_map.rs?ref=0e48cd0c3c712cea0267476de974012b2b05b508", "patch": "@@ -156,8 +156,7 @@ impl ImportMap {\n             let start = last_batch_start;\n             last_batch_start = idx + 1;\n \n-            let key = fst_path(&importables[start].1.path);\n-\n+            let key = fst_string(&importables[start].1.path);\n             builder.insert(key, start as u64).unwrap();\n         }\n \n@@ -213,15 +212,15 @@ impl fmt::Debug for ImportMap {\n     }\n }\n \n-fn fst_path(path: &ImportPath) -> String {\n-    let mut s = path.to_string();\n+fn fst_string<T: ToString>(t: &T) -> String {\n+    let mut s = t.to_string();\n     s.make_ascii_lowercase();\n     s\n }\n \n fn cmp((_, lhs): &(&ItemInNs, &ImportInfo), (_, rhs): &(&ItemInNs, &ImportInfo)) -> Ordering {\n-    let lhs_str = fst_path(&lhs.path);\n-    let rhs_str = fst_path(&rhs.path);\n+    let lhs_str = fst_string(&lhs.path);\n+    let rhs_str = fst_string(&rhs.path);\n     lhs_str.cmp(&rhs_str)\n }\n \n@@ -242,7 +241,10 @@ pub enum ImportKind {\n pub struct Query {\n     query: String,\n     lowercased: String,\n-    anchor_end: bool,\n+    // TODO kb use enums instead?\n+    name_only: bool,\n+    name_end: bool,\n+    strict_include: bool,\n     case_sensitive: bool,\n     limit: usize,\n     exclude_import_kinds: FxHashSet<ImportKind>,\n@@ -253,17 +255,27 @@ impl Query {\n         Self {\n             lowercased: query.to_lowercase(),\n             query: query.to_string(),\n-            anchor_end: false,\n+            name_only: false,\n+            name_end: false,\n+            strict_include: false,\n             case_sensitive: false,\n             limit: usize::max_value(),\n             exclude_import_kinds: FxHashSet::default(),\n         }\n     }\n \n-    /// Only returns items whose paths end with the (case-insensitive) query string as their last\n-    /// segment.\n-    pub fn anchor_end(self) -> Self {\n-        Self { anchor_end: true, ..self }\n+    pub fn name_end(self) -> Self {\n+        Self { name_end: true, ..self }\n+    }\n+\n+    /// todo kb\n+    pub fn name_only(self) -> Self {\n+        Self { name_only: true, ..self }\n+    }\n+\n+    /// todo kb\n+    pub fn strict_include(self) -> Self {\n+        Self { strict_include: true, ..self }\n     }\n \n     /// Limits the returned number of items to `limit`.\n@@ -283,6 +295,35 @@ impl Query {\n     }\n }\n \n+// TODO kb: ugly with a special `return true` case and the `enforce_lowercase` one.\n+fn contains_query(query: &Query, input_path: &ImportPath, enforce_lowercase: bool) -> bool {\n+    let mut input = if query.name_only {\n+        input_path.segments.last().unwrap().to_string()\n+    } else {\n+        input_path.to_string()\n+    };\n+    if enforce_lowercase || !query.case_sensitive {\n+        input.make_ascii_lowercase();\n+    }\n+\n+    let query_string =\n+        if !enforce_lowercase && query.case_sensitive { &query.query } else { &query.lowercased };\n+\n+    if query.strict_include {\n+        if query.name_end {\n+            &input == query_string\n+        } else {\n+            input.contains(query_string)\n+        }\n+    } else if query.name_end {\n+        input.ends_with(query_string)\n+    } else {\n+        let input_chars = input.chars().collect::<FxHashSet<_>>();\n+        // TODO kb actually check for the order and the quantity\n+        query_string.chars().all(|query_char| input_chars.contains(&query_char))\n+    }\n+}\n+\n /// Searches dependencies of `krate` for an importable path matching `query`.\n ///\n /// This returns a list of items that could be imported from dependencies of `krate`.\n@@ -312,39 +353,26 @@ pub fn search_dependencies<'a>(\n             let importables = &import_map.importables[indexed_value.value as usize..];\n \n             // Path shared by the importable items in this group.\n-            let path = &import_map.map[&importables[0]].path;\n-\n-            if query.anchor_end {\n-                // Last segment must match query.\n-                let last = path.segments.last().unwrap().to_string();\n-                if last.to_lowercase() != query.lowercased {\n-                    continue;\n-                }\n+            let common_importables_path = &import_map.map[&importables[0]].path;\n+            if !contains_query(&query, common_importables_path, true) {\n+                continue;\n             }\n \n+            let common_importables_path_fst = fst_string(common_importables_path);\n             // Add the items from this `ModPath` group. Those are all subsequent items in\n             // `importables` whose paths match `path`.\n             let iter = importables\n                 .iter()\n                 .copied()\n                 .take_while(|item| {\n-                    let item_path = &import_map.map[item].path;\n-                    fst_path(item_path) == fst_path(path)\n+                    common_importables_path_fst == fst_string(&import_map.map[item].path)\n                 })\n                 .filter(|&item| match item_import_kind(item) {\n                     Some(import_kind) => !query.exclude_import_kinds.contains(&import_kind),\n                     None => true,\n-                });\n-\n-            if query.case_sensitive {\n-                // FIXME: This does not do a subsequence match.\n-                res.extend(iter.filter(|item| {\n-                    let item_path = &import_map.map[item].path;\n-                    item_path.to_string().contains(&query.query)\n-                }));\n-            } else {\n-                res.extend(iter);\n-            }\n+                })\n+                .filter(|item| contains_query(&query, &import_map.map[item].path, false));\n+            res.extend(iter);\n \n             if res.len() >= query.limit {\n                 res.truncate(query.limit);\n@@ -728,7 +756,7 @@ mod tests {\n         check_search(\n             ra_fixture,\n             \"main\",\n-            Query::new(\"fmt\").anchor_end(),\n+            Query::new(\"fmt\").name_only().strict_include(),\n             expect![[r#\"\n                 dep::fmt (t)\n                 dep::Fmt (t)"}, {"sha": "0de949b9a8b1fed28497ebc0c67d0963e280c4b6", "filename": "crates/ide_db/src/imports_locator.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0e48cd0c3c712cea0267476de974012b2b05b508/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e48cd0c3c712cea0267476de974012b2b05b508/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fimports_locator.rs?ref=0e48cd0c3c712cea0267476de974012b2b05b508", "patch": "@@ -27,7 +27,12 @@ pub fn find_exact_imports<'a>(\n             local_query.limit(40);\n             local_query\n         },\n-        import_map::Query::new(name_to_import).anchor_end().case_sensitive().limit(40),\n+        import_map::Query::new(name_to_import)\n+            .limit(40)\n+            .name_only()\n+            .name_end()\n+            .strict_include()\n+            .case_sensitive(),\n     )\n }\n \n@@ -36,11 +41,12 @@ pub fn find_similar_imports<'a>(\n     krate: Crate,\n     limit: Option<usize>,\n     name_to_import: &str,\n+    // TODO kb change it to search across the whole path or not?\n     ignore_modules: bool,\n ) -> impl Iterator<Item = Either<ModuleDef, MacroDef>> {\n     let _p = profile::span(\"find_similar_imports\");\n \n-    let mut external_query = import_map::Query::new(name_to_import);\n+    let mut external_query = import_map::Query::new(name_to_import).name_only();\n     if ignore_modules {\n         external_query = external_query.exclude_import_kind(import_map::ImportKind::Module);\n     }"}]}