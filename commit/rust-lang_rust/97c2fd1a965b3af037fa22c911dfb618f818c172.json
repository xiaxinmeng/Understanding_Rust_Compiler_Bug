{"sha": "97c2fd1a965b3af037fa22c911dfb618f818c172", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3YzJmZDFhOTY1YjNhZjAzN2ZhMjJjOTExZGZiNjE4ZjgxOGMxNzI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-19T21:39:46Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-20T22:20:50Z"}, "message": "core::rt: Move some TLS functions from local_sched to local_ptr", "tree": {"sha": "86797ebd7d868d133f8a785c5f6ba48cc2deecac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86797ebd7d868d133f8a785c5f6ba48cc2deecac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97c2fd1a965b3af037fa22c911dfb618f818c172", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97c2fd1a965b3af037fa22c911dfb618f818c172", "html_url": "https://github.com/rust-lang/rust/commit/97c2fd1a965b3af037fa22c911dfb618f818c172", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97c2fd1a965b3af037fa22c911dfb618f818c172/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86ba4573498ef251933fcc784d513c7586dfaae1", "url": "https://api.github.com/repos/rust-lang/rust/commits/86ba4573498ef251933fcc784d513c7586dfaae1", "html_url": "https://github.com/rust-lang/rust/commit/86ba4573498ef251933fcc784d513c7586dfaae1"}], "stats": {"total": 141, "additions": 82, "deletions": 59}, "files": [{"sha": "3d706fbbdae19f21b3b3cc1fa416bb06d0a5d4fb", "filename": "src/libcore/rt/local_ptr.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/97c2fd1a965b3af037fa22c911dfb618f818c172/src%2Flibcore%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c2fd1a965b3af037fa22c911dfb618f818c172/src%2Flibcore%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_ptr.rs?ref=97c2fd1a965b3af037fa22c911dfb618f818c172", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Access to a single thread-local pointer\n+\n+use libc::c_void;\n+use cast;\n+use option::{Option, Some, None};\n+use tls = rt::thread_local_storage;\n+\n+/// Initialize the TLS key. Other ops will fail if this isn't executed first.\n+pub fn init_tls_key() {\n+    unsafe {\n+        rust_initialize_rt_tls_key();\n+        extern {\n+            fn rust_initialize_rt_tls_key();\n+        }\n+    }\n+}\n+\n+pub fn tls_key() -> tls::Key {\n+    match maybe_tls_key() {\n+        Some(key) => key,\n+        None => abort!(\"runtime tls key not initialized\")\n+    }\n+}\n+\n+pub fn maybe_tls_key() -> Option<tls::Key> {\n+    unsafe {\n+        let key: *mut c_void = rust_get_rt_tls_key();\n+        let key: &mut tls::Key = cast::transmute(key);\n+        let key = *key;\n+        // Check that the key has been initialized.\n+\n+        // NB: This is a little racy because, while the key is\n+        // initalized under a mutex and it's assumed to be initalized\n+        // in the Scheduler ctor by any thread that needs to use it,\n+        // we are not accessing the key under a mutex.  Threads that\n+        // are not using the new Scheduler but still *want to check*\n+        // whether they are running under a new Scheduler may see a 0\n+        // value here that is in the process of being initialized in\n+        // another thread. I think this is fine since the only action\n+        // they could take if it was initialized would be to check the\n+        // thread-local value and see that it's not set.\n+        if key != -1 {\n+            return Some(key);\n+        } else {\n+            return None;\n+        }\n+    }\n+}\n+\n+extern {\n+    #[fast_ffi]\n+    fn rust_get_rt_tls_key() -> *mut c_void;\n+}"}, {"sha": "6b3bc373d2210d9b4055f84807fc6901c3410d66", "filename": "src/libcore/rt/local_sched.rs", "status": "modified", "additions": 6, "deletions": 52, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/97c2fd1a965b3af037fa22c911dfb618f818c172/src%2Flibcore%2Frt%2Flocal_sched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c2fd1a965b3af037fa22c911dfb618f818c172/src%2Flibcore%2Frt%2Flocal_sched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_sched.rs?ref=97c2fd1a965b3af037fa22c911dfb618f818c172", "patch": "@@ -18,25 +18,16 @@ use cell::Cell;\n \n use rt::sched::Scheduler;\n use rt::rtio::{EventLoop, IoFactoryObject};\n-use tls = rt::thread_local_storage;\n use unstable::finally::Finally;\n+use rt::local_ptr;\n+use tls = rt::thread_local_storage;\n \n #[cfg(test)] use rt::uv::uvio::UvEventLoop;\n \n-/// Initialize the TLS key. Other ops will fail if this isn't executed first.\n-pub fn init_tls_key() {\n-    unsafe {\n-        rust_initialize_rt_tls_key();\n-        extern {\n-            fn rust_initialize_rt_tls_key();\n-        }\n-    }\n-}\n-\n /// Give the Scheduler to thread-local storage\n pub fn put(sched: ~Scheduler) {\n     unsafe {\n-        let key = tls_key();\n+        let key = local_ptr::tls_key();\n         let void_sched: *mut c_void = cast::transmute(sched);\n         tls::set(key, void_sched);\n     }\n@@ -45,7 +36,7 @@ pub fn put(sched: ~Scheduler) {\n /// Take ownership of the Scheduler from thread-local storage\n pub fn take() -> ~Scheduler {\n     unsafe {\n-        let key = tls_key();\n+        let key = local_ptr::tls_key();\n         let void_sched: *mut c_void = tls::get(key);\n         rtassert!(void_sched.is_not_null());\n         let sched: ~Scheduler = cast::transmute(void_sched);\n@@ -57,7 +48,7 @@ pub fn take() -> ~Scheduler {\n /// Check whether there is a thread-local Scheduler attached to the running thread\n pub fn exists() -> bool {\n     unsafe {\n-        match maybe_tls_key() {\n+        match local_ptr::maybe_tls_key() {\n             Some(key) => tls::get(key).is_not_null(),\n             None => false\n         }\n@@ -89,7 +80,7 @@ pub fn borrow(f: &fn(&mut Scheduler)) {\n /// Because this leaves the Scheduler in thread-local storage it is possible\n /// For the Scheduler pointer to be aliased\n pub unsafe fn unsafe_borrow() -> *mut Scheduler {\n-    let key = tls_key();\n+    let key = local_ptr::tls_key();\n     let mut void_sched: *mut c_void = tls::get(key);\n     rtassert!(void_sched.is_not_null());\n     {\n@@ -106,43 +97,6 @@ pub unsafe fn unsafe_borrow_io() -> *mut IoFactoryObject {\n     return io;\n }\n \n-fn tls_key() -> tls::Key {\n-    match maybe_tls_key() {\n-        Some(key) => key,\n-        None => abort!(\"runtime tls key not initialized\")\n-    }\n-}\n-\n-fn maybe_tls_key() -> Option<tls::Key> {\n-    unsafe {\n-        let key: *mut c_void = rust_get_rt_tls_key();\n-        let key: &mut tls::Key = cast::transmute(key);\n-        let key = *key;\n-        // Check that the key has been initialized.\n-\n-        // NB: This is a little racy because, while the key is\n-        // initalized under a mutex and it's assumed to be initalized\n-        // in the Scheduler ctor by any thread that needs to use it,\n-        // we are not accessing the key under a mutex.  Threads that\n-        // are not using the new Scheduler but still *want to check*\n-        // whether they are running under a new Scheduler may see a 0\n-        // value here that is in the process of being initialized in\n-        // another thread. I think this is fine since the only action\n-        // they could take if it was initialized would be to check the\n-        // thread-local value and see that it's not set.\n-        if key != -1 {\n-            return Some(key);\n-        } else {\n-            return None;\n-        }\n-    }\n-}\n-\n-extern {\n-    #[fast_ffi]\n-    fn rust_get_rt_tls_key() -> *mut c_void;\n-}\n-\n #[test]\n fn thread_local_scheduler_smoke_test() {\n     let scheduler = ~UvEventLoop::new_scheduler();"}, {"sha": "bda44b4c67f8612caef86bf8071d06bf56808fa5", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/97c2fd1a965b3af037fa22c911dfb618f818c172/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c2fd1a965b3af037fa22c911dfb618f818c172/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=97c2fd1a965b3af037fa22c911dfb618f818c172", "patch": "@@ -85,10 +85,6 @@ pub mod uv;\n /// or task-local storage.\n pub mod local;\n \n-// FIXME #5248: The import in `sched` doesn't resolve unless this is pub!\n-/// Bindings to pthread/windows thread-local storage.\n-pub mod thread_local_storage;\n-\n /// A parallel work-stealing deque.\n mod work_queue;\n \n@@ -126,6 +122,15 @@ pub mod tube;\n /// Simple reimplementation of core::comm\n pub mod comm;\n \n+// FIXME #5248 shouldn't be pub\n+/// The runtime needs to be able to put a pointer into thread-local storage.\n+pub mod local_ptr;\n+\n+// FIXME #5248: The import in `sched` doesn't resolve unless this is pub!\n+/// Bindings to pthread/windows thread-local storage.\n+pub mod thread_local_storage;\n+\n+\n /// Set up a default runtime configuration, given compiler-supplied arguments.\n ///\n /// This is invoked by the `start` _language item_ (unstable::lang) to"}, {"sha": "8352993278cec76561c8f7405a8c592ed6779da9", "filename": "src/libcore/rt/sched.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/97c2fd1a965b3af037fa22c911dfb618f818c172/src%2Flibcore%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c2fd1a965b3af037fa22c911dfb618f818c172/src%2Flibcore%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched.rs?ref=97c2fd1a965b3af037fa22c911dfb618f818c172", "patch": "@@ -11,13 +11,14 @@\n use option::*;\n use sys;\n use cast::transmute;\n+use cell::Cell;\n \n use super::work_queue::WorkQueue;\n use super::stack::{StackPool, StackSegment};\n use super::rtio::{EventLoop, EventLoopObject};\n use super::context::Context;\n use super::task::Task;\n-use cell::Cell;\n+use rt::local_ptr;\n \n // A more convenient name for external callers, e.g. `local_sched::take()`\n pub mod local_sched;\n@@ -64,8 +65,8 @@ pub impl Scheduler {\n \n     fn new(event_loop: ~EventLoopObject) -> Scheduler {\n \n-        // Lazily initialize the scheduler TLS key\n-        local_sched::init_tls_key();\n+        // Lazily initialize the runtime TLS key\n+        local_ptr::init_tls_key();\n \n         Scheduler {\n             event_loop: event_loop,"}]}