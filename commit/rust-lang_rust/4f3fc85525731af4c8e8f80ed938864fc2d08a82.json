{"sha": "4f3fc85525731af4c8e8f80ed938864fc2d08a82", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmM2ZjODU1MjU3MzFhZjRjOGU4ZjgwZWQ5Mzg4NjRmYzJkMDhhODI=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2017-02-08T08:41:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-02-08T08:41:10Z"}, "message": "Merge pull request #121 from oli-obk/master\n\nfix `static mut` dealloc or freeze", "tree": {"sha": "8903dc89a378aad3aadc317f8004ffd213d721cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8903dc89a378aad3aadc317f8004ffd213d721cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f3fc85525731af4c8e8f80ed938864fc2d08a82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f3fc85525731af4c8e8f80ed938864fc2d08a82", "html_url": "https://github.com/rust-lang/rust/commit/4f3fc85525731af4c8e8f80ed938864fc2d08a82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f3fc85525731af4c8e8f80ed938864fc2d08a82/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63cd99440907840a8264883a9d2d84690f463a51", "url": "https://api.github.com/repos/rust-lang/rust/commits/63cd99440907840a8264883a9d2d84690f463a51", "html_url": "https://github.com/rust-lang/rust/commit/63cd99440907840a8264883a9d2d84690f463a51"}, {"sha": "fbfd2d4bca94ba2d19b89724d8450cbff52a0484", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbfd2d4bca94ba2d19b89724d8450cbff52a0484", "html_url": "https://github.com/rust-lang/rust/commit/fbfd2d4bca94ba2d19b89724d8450cbff52a0484"}], "stats": {"total": 179, "additions": 126, "deletions": 53}, "files": [{"sha": "f806110190c4d8350da4081847bdbadcf6f65948", "filename": "src/error.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f3fc85525731af4c8e8f80ed938864fc2d08a82/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3fc85525731af4c8e8f80ed938864fc2d08a82/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=4f3fc85525731af4c8e8f80ed938864fc2d08a82", "patch": "@@ -49,8 +49,8 @@ pub enum EvalError<'tcx> {\n     AssumptionNotHeld,\n     InlineAsm,\n     TypeNotPrimitive(Ty<'tcx>),\n-    ReallocatedFrozenMemory,\n-    DeallocatedFrozenMemory,\n+    ReallocatedStaticMemory,\n+    DeallocatedStaticMemory,\n     Layout(layout::LayoutError<'tcx>),\n     Unreachable,\n     ExpectedConcreteFunction(Function<'tcx>),\n@@ -118,10 +118,10 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"cannot evaluate inline assembly\",\n             EvalError::TypeNotPrimitive(_) =>\n                 \"expected primitive type, got nonprimitive\",\n-            EvalError::ReallocatedFrozenMemory =>\n-                \"tried to reallocate frozen memory\",\n-            EvalError::DeallocatedFrozenMemory =>\n-                \"tried to deallocate frozen memory\",\n+            EvalError::ReallocatedStaticMemory =>\n+                \"tried to reallocate static memory\",\n+            EvalError::DeallocatedStaticMemory =>\n+                \"tried to deallocate static memory\",\n             EvalError::Layout(_) =>\n                 \"rustc layout computation failed\",\n             EvalError::UnterminatedCString(_) =>"}, {"sha": "1996bbf9dcb7e5dca9c273de16a50d47dad7a03f", "filename": "src/eval_context.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4f3fc85525731af4c8e8f80ed938864fc2d08a82/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3fc85525731af4c8e8f80ed938864fc2d08a82/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=4f3fc85525731af4c8e8f80ed938864fc2d08a82", "patch": "@@ -100,9 +100,11 @@ pub struct Frame<'tcx> {\n #[derive(Clone, Debug, Eq, PartialEq, Hash)]\n pub enum StackPopCleanup {\n     /// The stackframe existed to compute the initial value of a static/constant, make sure it\n-    /// isn't modifyable afterwards. The allocation of the result is frozen iff it's an\n-    /// actual allocation. `PrimVal`s are unmodifyable anyway.\n-    Freeze,\n+    /// isn't modifyable afterwards in case of constants.\n+    /// In case of `static mut`, mark the memory to ensure it's never marked as immutable through\n+    /// references or deallocated\n+    /// The bool decides whether the value is mutable (true) or not (false)\n+    MarkStatic(bool),\n     /// A regular stackframe added due to a function call will need to get forwarded to the next\n     /// block\n     Goto(mir::BasicBlock),\n@@ -170,7 +172,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // FIXME: cache these allocs\n         let ptr = self.memory.allocate(s.len() as u64, 1)?;\n         self.memory.write_bytes(ptr, s.as_bytes())?;\n-        self.memory.freeze(ptr.alloc_id)?;\n+        self.memory.mark_static(ptr.alloc_id, false)?;\n         Ok(Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::from_u128(s.len() as u128)))\n     }\n \n@@ -194,7 +196,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             ByteStr(ref bs) => {\n                 let ptr = self.memory.allocate(bs.len() as u64, 1)?;\n                 self.memory.write_bytes(ptr, bs)?;\n-                self.memory.freeze(ptr.alloc_id)?;\n+                self.memory.mark_static(ptr.alloc_id, false)?;\n                 PrimVal::Ptr(ptr)\n             }\n \n@@ -310,27 +312,27 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         ::log_settings::settings().indentation -= 1;\n         let frame = self.stack.pop().expect(\"tried to pop a stack frame, but there were none\");\n         match frame.return_to_block {\n-            StackPopCleanup::Freeze => if let Lvalue::Global(id) = frame.return_lvalue {\n+            StackPopCleanup::MarkStatic(mutable) => if let Lvalue::Global(id) = frame.return_lvalue {\n                 let global_value = self.globals.get_mut(&id)\n-                    .expect(\"global should have been cached (freeze)\");\n+                    .expect(\"global should have been cached (static)\");\n                 match global_value.value {\n-                    Value::ByRef(ptr) => self.memory.freeze(ptr.alloc_id)?,\n+                    Value::ByRef(ptr) => self.memory.mark_static(ptr.alloc_id, mutable)?,\n                     Value::ByVal(val) => if let PrimVal::Ptr(ptr) = val {\n-                        self.memory.freeze(ptr.alloc_id)?;\n+                        self.memory.mark_static(ptr.alloc_id, mutable)?;\n                     },\n                     Value::ByValPair(val1, val2) => {\n                         if let PrimVal::Ptr(ptr) = val1 {\n-                            self.memory.freeze(ptr.alloc_id)?;\n+                            self.memory.mark_static(ptr.alloc_id, mutable)?;\n                         }\n                         if let PrimVal::Ptr(ptr) = val2 {\n-                            self.memory.freeze(ptr.alloc_id)?;\n+                            self.memory.mark_static(ptr.alloc_id, mutable)?;\n                         }\n                     },\n                 }\n                 assert!(global_value.mutable);\n-                global_value.mutable = false;\n+                global_value.mutable = mutable;\n             } else {\n-                bug!(\"StackPopCleanup::Freeze on: {:?}\", frame.return_lvalue);\n+                bug!(\"StackPopCleanup::MarkStatic on: {:?}\", frame.return_lvalue);\n             },\n             StackPopCleanup::Goto(target) => self.goto_block(target),\n             StackPopCleanup::None => {},\n@@ -341,11 +343,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 trace!(\"deallocating local\");\n                 self.memory.dump_alloc(ptr.alloc_id);\n                 match self.memory.deallocate(ptr) {\n-                    // Any frozen memory means that it belongs to a constant or something referenced\n-                    // by a constant. We could alternatively check whether the alloc_id is frozen\n-                    // before calling deallocate, but this is much simpler and is probably the\n-                    // rare case.\n-                    Ok(()) | Err(EvalError::DeallocatedFrozenMemory) => {},\n+                    // We could alternatively check whether the alloc_id is static before calling\n+                    // deallocate, but this is much simpler and is probably the rare case.\n+                    Ok(()) | Err(EvalError::DeallocatedStaticMemory) => {},\n                     other => return other,\n                 }\n             }\n@@ -868,9 +868,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     _ => {\n                         let ptr = self.alloc_ptr_with_substs(global_val.ty, cid.substs)?;\n                         self.write_value_to_ptr(global_val.value, ptr, global_val.ty)?;\n-                        if !global_val.mutable {\n-                            self.memory.freeze(ptr.alloc_id)?;\n-                        }\n+                        self.memory.mark_static(ptr.alloc_id, global_val.mutable)?;\n                         let lval = self.globals.get_mut(&cid).expect(\"already checked\");\n                         *lval = Global {\n                             value: Value::ByRef(ptr),"}, {"sha": "8f0c3a5622c96639e7aca0165a007ec5f1e04d9d", "filename": "src/memory.rs", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4f3fc85525731af4c8e8f80ed938864fc2d08a82/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3fc85525731af4c8e8f80ed938864fc2d08a82/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=4f3fc85525731af4c8e8f80ed938864fc2d08a82", "patch": "@@ -38,9 +38,19 @@ pub struct Allocation {\n     /// The alignment of the allocation to detect unaligned reads.\n     pub align: u64,\n     /// Whether the allocation may be modified.\n-    /// Use the `freeze` method of `Memory` to ensure that an error occurs, if the memory of this\n-    /// allocation is modified in the future.\n-    pub immutable: bool,\n+    /// Use the `mark_static` method of `Memory` to ensure that an error occurs, if the memory of this\n+    /// allocation is modified or deallocated in the future.\n+    pub static_kind: StaticKind,\n+}\n+\n+#[derive(Debug, PartialEq, Copy, Clone)]\n+pub enum StaticKind {\n+    /// may be deallocated without breaking miri's invariants\n+    NotStatic,\n+    /// may be modified, but never deallocated\n+    Mutable,\n+    /// may neither be modified nor deallocated\n+    Immutable,\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -272,7 +282,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             relocations: BTreeMap::new(),\n             undef_mask: UndefMask::new(size),\n             align,\n-            immutable: false,\n+            static_kind: StaticKind::NotStatic,\n         };\n         let id = self.next_id;\n         self.next_id.0 += 1;\n@@ -290,8 +300,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         if ptr.points_to_zst() {\n             return self.allocate(new_size, align);\n         }\n-        if self.get(ptr.alloc_id).map(|alloc| alloc.immutable).ok() == Some(true) {\n-            return Err(EvalError::ReallocatedFrozenMemory);\n+        if self.get(ptr.alloc_id).ok().map_or(false, |alloc| alloc.static_kind != StaticKind::NotStatic) {\n+            return Err(EvalError::ReallocatedStaticMemory);\n         }\n \n         let size = self.get(ptr.alloc_id)?.bytes.len() as u64;\n@@ -325,8 +335,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             // TODO(solson): Report error about non-__rust_allocate'd pointer.\n             return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n         }\n-        if self.get(ptr.alloc_id).map(|alloc| alloc.immutable).ok() == Some(true) {\n-            return Err(EvalError::DeallocatedFrozenMemory);\n+        if self.get(ptr.alloc_id).ok().map_or(false, |alloc| alloc.static_kind != StaticKind::NotStatic) {\n+            return Err(EvalError::DeallocatedStaticMemory);\n         }\n \n         if let Some(alloc) = self.alloc_map.remove(&ptr.alloc_id) {\n@@ -430,8 +440,11 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     pub fn get_mut(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation> {\n         match self.alloc_map.get_mut(&id) {\n-            Some(ref alloc) if alloc.immutable => Err(EvalError::ModifiedConstantMemory),\n-            Some(alloc) => Ok(alloc),\n+            Some(alloc) => match alloc.static_kind {\n+                StaticKind::Mutable |\n+                StaticKind::NotStatic => Ok(alloc),\n+                StaticKind::Immutable => Err(EvalError::ModifiedConstantMemory),\n+            },\n             None => match self.functions.get(&id) {\n                 Some(_) => Err(EvalError::DerefFunctionPointer),\n                 None if id == NEVER_ALLOC_ID || id == ZST_ALLOC_ID => Err(EvalError::InvalidMemoryAccess),\n@@ -514,7 +527,11 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                 }\n             }\n \n-            let immutable = if alloc.immutable { \" (immutable)\" } else { \"\" };\n+            let immutable = match alloc.static_kind {\n+                StaticKind::Mutable => \" (static mut)\",\n+                StaticKind::Immutable => \" (immutable)\",\n+                StaticKind::NotStatic => \"\",\n+            };\n             trace!(\"{}({} bytes){}\", msg, alloc.bytes.len(), immutable);\n \n             if !relocations.is_empty() {\n@@ -607,23 +624,28 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n /// Reading and writing\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n-    pub fn freeze(&mut self, alloc_id: AllocId) -> EvalResult<'tcx> {\n-        // do not use `self.get_mut(alloc_id)` here, because we might have already frozen a\n+    /// mark an allocation as static, either mutable or not\n+    pub fn mark_static(&mut self, alloc_id: AllocId, mutable: bool) -> EvalResult<'tcx> {\n+        // do not use `self.get_mut(alloc_id)` here, because we might have already marked a\n         // sub-element or have circular pointers (e.g. `Rc`-cycles)\n         let relocations = match self.alloc_map.get_mut(&alloc_id) {\n-            Some(ref mut alloc) if !alloc.immutable => {\n-                alloc.immutable = true;\n+            Some(&mut Allocation { ref mut relocations, static_kind: ref mut kind @ StaticKind::NotStatic, .. }) => {\n+                *kind = if mutable {\n+                    StaticKind::Mutable\n+                } else {\n+                    StaticKind::Immutable\n+                };\n                 // take out the relocations vector to free the borrow on self, so we can call\n-                // freeze recursively\n-                mem::replace(&mut alloc.relocations, Default::default())\n+                // mark recursively\n+                mem::replace(relocations, Default::default())\n             },\n             None if alloc_id == NEVER_ALLOC_ID || alloc_id == ZST_ALLOC_ID => return Ok(()),\n             None if !self.functions.contains_key(&alloc_id) => return Err(EvalError::DanglingPointerDeref),\n             _ => return Ok(()),\n         };\n         // recurse into inner allocations\n         for &alloc in relocations.values() {\n-            self.freeze(alloc)?;\n+            self.mark_static(alloc, mutable)?;\n         }\n         // put back the relocations\n         self.alloc_map.get_mut(&alloc_id).expect(\"checked above\").relocations = relocations;"}, {"sha": "fd90b33c82b7eb4a15e734afcbc754187f711f01", "filename": "src/step.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f3fc85525731af4c8e8f80ed938864fc2d08a82/src%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3fc85525731af4c8e8f80ed938864fc2d08a82/src%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstep.rs?ref=4f3fc85525731af4c8e8f80ed938864fc2d08a82", "patch": "@@ -156,11 +156,7 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n         self.try(|this| {\n             let mir = this.ecx.load_mir(def_id)?;\n             this.ecx.globals.insert(cid, Global::uninitialized(mir.return_ty));\n-            let cleanup = if immutable && !mir.return_ty.type_contents(this.ecx.tcx).interior_unsafe() {\n-                StackPopCleanup::Freeze\n-            } else {\n-                StackPopCleanup::None\n-            };\n+            let cleanup = StackPopCleanup::MarkStatic(!immutable || mir.return_ty.type_contents(this.ecx.tcx).interior_unsafe());\n             let name = ty::tls::with(|tcx| tcx.item_path_str(def_id));\n             trace!(\"pushing stack frame for global: {}\", name);\n             this.ecx.push_stack_frame(def_id, span, mir, substs, Lvalue::Global(cid), cleanup, Vec::new())\n@@ -213,7 +209,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                                               mir,\n                                               this.substs,\n                                               Lvalue::Global(cid),\n-                                              StackPopCleanup::Freeze,\n+                                              StackPopCleanup::MarkStatic(false),\n                                               Vec::new())\n                 });\n             }"}, {"sha": "0b43b3494438f6a42a9b6037e8305e7384d01e94", "filename": "src/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f3fc85525731af4c8e8f80ed938864fc2d08a82/src%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3fc85525731af4c8e8f80ed938864fc2d08a82/src%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvtable.rs?ref=4f3fc85525731af4c8e8f80ed938864fc2d08a82", "patch": "@@ -112,7 +112,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n         }\n \n-        self.memory.freeze(vtable.alloc_id)?;\n+        self.memory.mark_static(vtable.alloc_id, false)?;\n \n         Ok(vtable)\n     }"}, {"sha": "cb2e7217d5797331be2918c8d39b66a9b1c3fc05", "filename": "tests/compile-fail/modifying_constants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f3fc85525731af4c8e8f80ed938864fc2d08a82/tests%2Fcompile-fail%2Fmodifying_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3fc85525731af4c8e8f80ed938864fc2d08a82/tests%2Fcompile-fail%2Fmodifying_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmodifying_constants.rs?ref=4f3fc85525731af4c8e8f80ed938864fc2d08a82", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-    let x = &1; // the `&1` is promoted to a constant, but it used to be that only the pointer is frozen, not the pointee\n+    let x = &1; // the `&1` is promoted to a constant, but it used to be that only the pointer is marked static, not the pointee\n     let y = unsafe { &mut *(x as *const i32 as *mut i32) };\n     *y = 42; //~ ERROR tried to modify constant memory\n     assert_eq!(*x, 42);"}, {"sha": "0338a766e26278ddc53ca9f6e5d1ed6d07b936e5", "filename": "tests/run-pass/const-vec-of-fns.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4f3fc85525731af4c8e8f80ed938864fc2d08a82/tests%2Frun-pass%2Fconst-vec-of-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3fc85525731af4c8e8f80ed938864fc2d08a82/tests%2Frun-pass%2Fconst-vec-of-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconst-vec-of-fns.rs?ref=4f3fc85525731af4c8e8f80ed938864fc2d08a82", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// pretty-expanded FIXME #23616\n+\n+/*!\n+ * Try to double-check that static fns have the right size (with or\n+ * without dummy env ptr, as appropriate) by iterating a size-2 array.\n+ * If the static size differs from the runtime size, the second element\n+ * should be read as a null or otherwise wrong pointer and crash.\n+ */\n+\n+fn f() { }\n+static mut CLOSURES: &'static mut [fn()] = &mut [f as fn(), f as fn()];\n+\n+pub fn main() {\n+    unsafe {\n+        for closure in &mut *CLOSURES {\n+            (*closure)()\n+        }\n+    }\n+}"}, {"sha": "5b27324964b4770ec8e8a94428f009b80503f21c", "filename": "tests/run-pass/recursive_static.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4f3fc85525731af4c8e8f80ed938864fc2d08a82/tests%2Frun-pass%2Frecursive_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3fc85525731af4c8e8f80ed938864fc2d08a82/tests%2Frun-pass%2Frecursive_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Frecursive_static.rs?ref=4f3fc85525731af4c8e8f80ed938864fc2d08a82", "patch": "@@ -0,0 +1,11 @@\n+#![feature(static_recursion)]\n+\n+struct S(&'static S);\n+static S1: S = S(&S2);\n+static S2: S = S(&S1);\n+\n+fn main() {\n+    let p: *const S = S2.0;\n+    let q: *const S = &S1;\n+    assert_eq!(p, q);\n+}"}, {"sha": "be5830698b2117c7c47420668428b236331ea754", "filename": "tests/run-pass/static_mut.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4f3fc85525731af4c8e8f80ed938864fc2d08a82/tests%2Frun-pass%2Fstatic_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3fc85525731af4c8e8f80ed938864fc2d08a82/tests%2Frun-pass%2Fstatic_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstatic_mut.rs?ref=4f3fc85525731af4c8e8f80ed938864fc2d08a82", "patch": "@@ -0,0 +1,17 @@\n+#![allow(dead_code)]\n+\n+static mut FOO: i32 = 42;\n+static BAR: Foo = Foo(unsafe { &FOO as *const _} );\n+\n+struct Foo(*const i32);\n+\n+unsafe impl Sync for Foo {}\n+\n+fn main() {\n+    unsafe {\n+        assert_eq!(*BAR.0, 42);\n+        FOO = 5;\n+        assert_eq!(FOO, 5);\n+        assert_eq!(*BAR.0, 5);\n+    }\n+}"}]}