{"sha": "869fa27d131d3376c3a7b6e1d3a1fb0d1ce20c9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2OWZhMjdkMTMxZDMzNzZjM2E3YjZlMWQzYTFmYjBkMWNlMjBjOWM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-06-19T21:54:17Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-06-23T17:09:21Z"}, "message": "hygiene: Rename `MarkKind` to `Transparency`\n\nMove `is_builtin` for `Mark` to a separate flag", "tree": {"sha": "ff04427cb4b54d1fa1785647bb410b445430a419", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff04427cb4b54d1fa1785647bb410b445430a419"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/869fa27d131d3376c3a7b6e1d3a1fb0d1ce20c9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/869fa27d131d3376c3a7b6e1d3a1fb0d1ce20c9c", "html_url": "https://github.com/rust-lang/rust/commit/869fa27d131d3376c3a7b6e1d3a1fb0d1ce20c9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/869fa27d131d3376c3a7b6e1d3a1fb0d1ce20c9c/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b15785b67133b5017f141d1fda1dd3dcf331b4b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b15785b67133b5017f141d1fda1dd3dcf331b4b4", "html_url": "https://github.com/rust-lang/rust/commit/b15785b67133b5017f141d1fda1dd3dcf331b4b4"}], "stats": {"total": 84, "additions": 58, "deletions": 26}, "files": [{"sha": "2052918747b39301f1f14364c7d244b77a7eb00c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/869fa27d131d3376c3a7b6e1d3a1fb0d1ce20c9c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869fa27d131d3376c3a7b6e1d3a1fb0d1ce20c9c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=869fa27d131d3376c3a7b6e1d3a1fb0d1ce20c9c", "patch": "@@ -45,7 +45,7 @@ use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n \n use syntax::codemap::CodeMap;\n-use syntax::ext::hygiene::{Mark, MarkKind, SyntaxContext};\n+use syntax::ext::hygiene::{Mark, Transparency, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n@@ -1988,7 +1988,7 @@ impl<'a> Resolver<'a> {\n             // When resolving `$crate` from a `macro_rules!` invoked in a `macro`,\n             // we don't want to pretend that the `macro_rules!` definition is in the `macro`\n             // as described in `SyntaxContext::apply_mark`, so we ignore prepended modern marks.\n-            ctxt.marks().into_iter().find(|&mark| mark.kind() != MarkKind::Modern)\n+            ctxt.marks().into_iter().find(|&mark| mark.transparency() != Transparency::Opaque)\n         } else {\n             ctxt = ctxt.modern();\n             ctxt.adjust(Mark::root())"}, {"sha": "65dec8ad16c7d60e62b993a47d7b1f7e4effd831", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/869fa27d131d3376c3a7b6e1d3a1fb0d1ce20c9c/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869fa27d131d3376c3a7b6e1d3a1fb0d1ce20c9c/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=869fa27d131d3376c3a7b6e1d3a1fb0d1ce20c9c", "patch": "@@ -24,7 +24,7 @@ use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Annotatable, Determinacy, MultiModifier, MultiDecorator};\n use syntax::ext::base::{MacroKind, SyntaxExtension, Resolver as SyntaxResolver};\n use syntax::ext::expand::{Expansion, ExpansionKind, Invocation, InvocationKind, find_attr_invoc};\n-use syntax::ext::hygiene::{self, Mark, MarkKind};\n+use syntax::ext::hygiene::{self, Mark, Transparency};\n use syntax::ext::placeholders::placeholder;\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{self, emit_feature_err, GateIssue};\n@@ -331,9 +331,9 @@ impl<'a> base::Resolver for Resolver<'a> {\n         self.unused_macros.remove(&def_id);\n         let ext = self.get_macro(def);\n         if ext.is_modern() {\n-            invoc.expansion_data.mark.set_kind(MarkKind::Modern);\n+            invoc.expansion_data.mark.set_transparency(Transparency::Opaque);\n         } else if def_id.krate == BUILTIN_MACROS_CRATE {\n-            invoc.expansion_data.mark.set_kind(MarkKind::Builtin);\n+            invoc.expansion_data.mark.set_is_builtin(true);\n         }\n         Ok(Some(ext))\n     }"}, {"sha": "70c4324a056a0ff62028a7bddf1dcc234b81a1d6", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/869fa27d131d3376c3a7b6e1d3a1fb0d1ce20c9c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869fa27d131d3376c3a7b6e1d3a1fb0d1ce20c9c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=869fa27d131d3376c3a7b6e1d3a1fb0d1ce20c9c", "patch": "@@ -18,7 +18,7 @@ use util::parser::{self, AssocOp, Fixity};\n use attr;\n use codemap::{self, CodeMap};\n use syntax_pos::{self, BytePos};\n-use syntax_pos::hygiene::{Mark, MarkKind, SyntaxContext};\n+use syntax_pos::hygiene::{Mark, SyntaxContext};\n use parse::token::{self, BinOpToken, Token};\n use parse::lexer::comments;\n use parse::{self, ParseSess};\n@@ -842,7 +842,7 @@ pub trait PrintState<'a> {\n     fn print_dollar_crate(&mut self, mut ctxt: SyntaxContext) -> io::Result<()> {\n         if let Some(mark) = ctxt.adjust(Mark::root()) {\n             // Make a best effort to print something that complies\n-            if mark.kind() == MarkKind::Builtin {\n+            if mark.is_builtin() {\n                 if let Some(name) = std_inject::injected_crate_name() {\n                     self.writer().word(\"::\")?;\n                     self.writer().word(name)?;"}, {"sha": "cd2b8b2bff8b8f54ec495249796c012162391ea6", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 51, "deletions": 19, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/869fa27d131d3376c3a7b6e1d3a1fb0d1ce20c9c/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869fa27d131d3376c3a7b6e1d3a1fb0d1ce20c9c/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=869fa27d131d3376c3a7b6e1d3a1fb0d1ce20c9c", "patch": "@@ -43,21 +43,41 @@ pub struct Mark(u32);\n #[derive(Debug)]\n struct MarkData {\n     parent: Mark,\n-    kind: MarkKind,\n+    transparency: Transparency,\n+    is_builtin: bool,\n     expn_info: Option<ExpnInfo>,\n }\n \n+/// A property of a macro expansion that determines how identifiers\n+/// produced by that expansion are resolved.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum MarkKind {\n-    Modern,\n-    Builtin,\n-    Legacy,\n+pub enum Transparency {\n+    /// Identifier produced by a transparent expansion is always resolved at call-site.\n+    /// Call-site spans in procedural macros, hygiene opt-out in `macro` should use this.\n+    /// (Not used yet.)\n+    Transparent,\n+    /// Identifier produced by a semi-transparent expansion may be resolved\n+    /// either at call-site or at definition-site.\n+    /// If it's a local variable, label or `$crate` then it's resolved at def-site.\n+    /// Otherwise it's resolved at call-site.\n+    /// `macro_rules` macros behave like this, built-in macros currently behave like this too,\n+    /// but that's an implementation detail.\n+    SemiTransparent,\n+    /// Identifier produced by an opaque expansion is always resolved at definition-site.\n+    /// Def-site spans in procedural macros, identifiers from `macro` by default use this.\n+    Opaque,\n }\n \n impl Mark {\n     pub fn fresh(parent: Mark) -> Self {\n         HygieneData::with(|data| {\n-            data.marks.push(MarkData { parent: parent, kind: MarkKind::Legacy, expn_info: None });\n+            data.marks.push(MarkData {\n+                parent,\n+                // By default expansions behave like `macro_rules`.\n+                transparency: Transparency::SemiTransparent,\n+                is_builtin: false,\n+                expn_info: None,\n+            });\n             Mark(data.marks.len() as u32 - 1)\n         })\n     }\n@@ -97,23 +117,31 @@ impl Mark {\n \n     pub fn modern(mut self) -> Mark {\n         HygieneData::with(|data| {\n-            loop {\n-                if self == Mark::root() || data.marks[self.0 as usize].kind == MarkKind::Modern {\n-                    return self;\n-                }\n+            while data.marks[self.0 as usize].transparency != Transparency::Opaque {\n                 self = data.marks[self.0 as usize].parent;\n             }\n+            self\n         })\n     }\n \n     #[inline]\n-    pub fn kind(self) -> MarkKind {\n-        HygieneData::with(|data| data.marks[self.0 as usize].kind)\n+    pub fn transparency(self) -> Transparency {\n+        HygieneData::with(|data| data.marks[self.0 as usize].transparency)\n+    }\n+\n+    #[inline]\n+    pub fn set_transparency(self, transparency: Transparency) {\n+        HygieneData::with(|data| data.marks[self.0 as usize].transparency = transparency)\n+    }\n+\n+    #[inline]\n+    pub fn is_builtin(self) -> bool {\n+        HygieneData::with(|data| data.marks[self.0 as usize].is_builtin)\n     }\n \n     #[inline]\n-    pub fn set_kind(self, kind: MarkKind) {\n-        HygieneData::with(|data| data.marks[self.0 as usize].kind = kind)\n+    pub fn set_is_builtin(self, is_builtin: bool) {\n+        HygieneData::with(|data| data.marks[self.0 as usize].is_builtin = is_builtin)\n     }\n \n     pub fn is_descendant_of(mut self, ancestor: Mark) -> bool {\n@@ -169,7 +197,10 @@ impl HygieneData {\n         HygieneData {\n             marks: vec![MarkData {\n                 parent: Mark::root(),\n-                kind: MarkKind::Builtin,\n+                // If the root is opaque, then loops searching for an opaque mark\n+                // will automatically stop after reaching it.\n+                transparency: Transparency::Opaque,\n+                is_builtin: true,\n                 expn_info: None,\n             }],\n             syntax_contexts: vec![SyntaxContextData {\n@@ -215,8 +246,9 @@ impl SyntaxContext {\n         HygieneData::with(|data| {\n             data.marks.push(MarkData {\n                 parent: Mark::root(),\n-                kind: MarkKind::Legacy,\n-                expn_info: Some(expansion_info)\n+                transparency: Transparency::SemiTransparent,\n+                is_builtin: false,\n+                expn_info: Some(expansion_info),\n             });\n \n             let mark = Mark(data.marks.len() as u32 - 1);\n@@ -232,7 +264,7 @@ impl SyntaxContext {\n \n     /// Extend a syntax context with a given mark\n     pub fn apply_mark(self, mark: Mark) -> SyntaxContext {\n-        if mark.kind() == MarkKind::Modern {\n+        if mark.transparency() == Transparency::Opaque {\n             return self.apply_mark_internal(mark);\n         }\n \n@@ -262,7 +294,7 @@ impl SyntaxContext {\n         HygieneData::with(|data| {\n             let syntax_contexts = &mut data.syntax_contexts;\n             let mut modern = syntax_contexts[self.0 as usize].modern;\n-            if data.marks[mark.0 as usize].kind == MarkKind::Modern {\n+            if data.marks[mark.0 as usize].transparency == Transparency::Opaque {\n                 modern = *data.markings.entry((modern, mark)).or_insert_with(|| {\n                     let len = syntax_contexts.len() as u32;\n                     syntax_contexts.push(SyntaxContextData {"}]}