{"sha": "9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliY2ZkYjdiOWM1YzM3YTM4YjFiNWM3MWE1ZWZhMTRmMDM3ZDBjNzQ=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2016-02-23T20:47:09Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2016-03-14T22:05:13Z"}, "message": "Move projection_mode to InferContext rather than SelectionContext to reduce chance of bugs", "tree": {"sha": "edd74c74038d1927b26d46ed4e0d238ef1b7648c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/edd74c74038d1927b26d46ed4e0d238ef1b7648c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "html_url": "https://github.com/rust-lang/rust/commit/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "386f8eefc0a0775b228740cc5f682b6d10050e04", "url": "https://api.github.com/repos/rust-lang/rust/commits/386f8eefc0a0775b228740cc5f682b6d10050e04", "html_url": "https://github.com/rust-lang/rust/commit/386f8eefc0a0775b228740cc5f682b6d10050e04"}], "stats": {"total": 409, "additions": 225, "deletions": 184}, "files": [{"sha": "89b57e0d90a007031169310e143c2d72d4c0bc6b", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -25,6 +25,7 @@ use middle::expr_use_visitor as euv;\n use middle::infer;\n use middle::mem_categorization::{cmt};\n use middle::pat_util::*;\n+use middle::traits::ProjectionMode;\n use middle::ty::*;\n use middle::ty;\n use std::cmp::Ordering;\n@@ -1101,7 +1102,8 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                         //FIXME: (@jroesch) this code should be floated up as well\n                         let infcx = infer::new_infer_ctxt(cx.tcx,\n                                                           &cx.tcx.tables,\n-                                                          Some(cx.param_env.clone()));\n+                                                          Some(cx.param_env.clone()),\n+                                                          ProjectionMode::AnyFinal);\n                         if infcx.type_moves_by_default(pat_ty, pat.span) {\n                             check_move(p, sub.as_ref().map(|p| &**p));\n                         }\n@@ -1133,7 +1135,8 @@ fn check_for_mutation_in_guard<'a, 'tcx>(cx: &'a MatchCheckCtxt<'a, 'tcx>,\n \n     let infcx = infer::new_infer_ctxt(cx.tcx,\n                                       &cx.tcx.tables,\n-                                      Some(checker.cx.param_env.clone()));\n+                                      Some(checker.cx.param_env.clone()),\n+                                      ProjectionMode::AnyFinal);\n \n     let mut visitor = ExprUseVisitor::new(&mut checker, &infcx);\n     visitor.walk_expr(guard);"}, {"sha": "8a1a0080eb0c27adf0d8c293fca452342cdd2a2e", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -24,6 +24,7 @@ use middle::def_id::DefId;\n use middle::pat_util::def_to_path;\n use middle::ty::{self, Ty, TyCtxt};\n use middle::ty::util::IntTypeExt;\n+use middle::traits::ProjectionMode;\n use middle::astconv_util::ast_ty_to_prim_ty;\n use util::nodemap::NodeMap;\n \n@@ -1049,7 +1050,7 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n            trait_ref);\n \n     tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, ProjectionMode::AnyFinal);\n \n     let mut selcx = traits::SelectionContext::new(&infcx);\n     let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n@@ -1067,6 +1068,11 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n         }\n     };\n \n+    // NOTE: this code does not currently account for specialization, but when\n+    // it does so, it should hook into the ProjectionMode to determine when the\n+    // constant should resolve; this will also require plumbing through to this\n+    // function whether we are in \"trans mode\" to pick the right ProjectionMode\n+    // when constructing the inference context above.\n     match selection {\n         traits::VtableImpl(ref impl_data) => {\n             match tcx.associated_consts(impl_data.impl_def_id)"}, {"sha": "4ff1de422117b2852576828f49634cd790dfc7f5", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -27,7 +27,7 @@ use middle::region::CodeExtent;\n use middle::subst;\n use middle::subst::Substs;\n use middle::subst::Subst;\n-use middle::traits;\n+use middle::traits::{self, ProjectionMode};\n use middle::ty::adjustment;\n use middle::ty::{TyVid, IntVid, FloatVid};\n use middle::ty::{self, Ty, TyCtxt};\n@@ -99,6 +99,11 @@ pub struct InferCtxt<'a, 'tcx: 'a> {\n     // directly.\n     normalize: bool,\n \n+    // Sadly, the behavior of projection varies a bit depending on the\n+    // stage of compilation. The specifics are given in the\n+    // documentation for `ProjectionMode`.\n+    projection_mode: ProjectionMode,\n+\n     err_count_on_creation: usize,\n }\n \n@@ -354,7 +359,8 @@ pub fn fixup_err_to_string(f: FixupError) -> String {\n \n pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a TyCtxt<'tcx>,\n                                 tables: &'a RefCell<ty::Tables<'tcx>>,\n-                                param_env: Option<ty::ParameterEnvironment<'a, 'tcx>>)\n+                                param_env: Option<ty::ParameterEnvironment<'a, 'tcx>>,\n+                                projection_mode: ProjectionMode)\n                                 -> InferCtxt<'a, 'tcx> {\n     InferCtxt {\n         tcx: tcx,\n@@ -366,14 +372,16 @@ pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a TyCtxt<'tcx>,\n         parameter_environment: param_env.unwrap_or(tcx.empty_parameter_environment()),\n         reported_trait_errors: RefCell::new(FnvHashSet()),\n         normalize: false,\n+        projection_mode: projection_mode,\n         err_count_on_creation: tcx.sess.err_count()\n     }\n }\n \n pub fn normalizing_infer_ctxt<'a, 'tcx>(tcx: &'a TyCtxt<'tcx>,\n-                                        tables: &'a RefCell<ty::Tables<'tcx>>)\n+                                        tables: &'a RefCell<ty::Tables<'tcx>>,\n+                                        projection_mode: ProjectionMode)\n                                         -> InferCtxt<'a, 'tcx> {\n-    let mut infcx = new_infer_ctxt(tcx, tables, None);\n+    let mut infcx = new_infer_ctxt(tcx, tables, None, projection_mode);\n     infcx.normalize = true;\n     infcx\n }\n@@ -514,6 +522,7 @@ pub struct CombinedSnapshot {\n     region_vars_snapshot: RegionSnapshot,\n }\n \n+// NOTE: Callable from trans only!\n pub fn normalize_associated_type<'tcx,T>(tcx: &TyCtxt<'tcx>, value: &T) -> T\n     where T : TypeFoldable<'tcx>\n {\n@@ -525,7 +534,7 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &TyCtxt<'tcx>, value: &T) -> T\n         return value;\n     }\n \n-    let infcx = new_infer_ctxt(tcx, &tcx.tables, None);\n+    let infcx = new_infer_ctxt(tcx, &tcx.tables, None, ProjectionMode::Any);\n     let mut selcx = traits::SelectionContext::new(&infcx);\n     let cause = traits::ObligationCause::dummy();\n     let traits::Normalized { value: result, obligations } =\n@@ -593,6 +602,10 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    pub fn projection_mode(&self) -> ProjectionMode {\n+        self.projection_mode\n+    }\n+\n     pub fn freshen<T:TypeFoldable<'tcx>>(&self, t: T) -> T {\n         t.fold_with(&mut self.freshener())\n     }"}, {"sha": "33a1e3816e348ce204d563190bab20ffcf494c90", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -10,7 +10,6 @@\n \n //! See `README.md` for high-level documentation\n \n-use super::build_selcx;\n use super::{SelectionContext, Obligation, ObligationCause};\n use super::util;\n \n@@ -37,7 +36,7 @@ pub fn overlapping_impls<'cx, 'tcx>(infcx: &InferCtxt<'cx, 'tcx>,\n            impl1_def_id,\n            impl2_def_id);\n \n-    let selcx = &mut build_selcx(infcx).project_topmost().intercrate().build();\n+    let selcx = &mut SelectionContext::intercrate(infcx);\n     overlap(selcx, impl1_def_id, impl2_def_id)\n }\n "}, {"sha": "76dbd2793f9f662787eef4786aa0329381957b97", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -36,17 +36,15 @@ pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n pub use self::coherence::OrphanCheckErr;\n pub use self::fulfill::{FulfillmentContext, GlobalFulfilledPredicates, RegionObligation};\n-pub use self::project::MismatchedProjectionTypes;\n-pub use self::project::normalize;\n-pub use self::project::Normalized;\n+pub use self::project::{MismatchedProjectionTypes, ProjectionMode};\n+pub use self::project::{normalize, Normalized};\n pub use self::object_safety::is_object_safe;\n pub use self::object_safety::astconv_object_safety_violations;\n pub use self::object_safety::object_safety_violations;\n pub use self::object_safety::ObjectSafetyViolation;\n pub use self::object_safety::MethodViolationCode;\n pub use self::object_safety::is_vtable_safe_method;\n-pub use self::select::{EvaluationCache, SelectionContextBuilder, build_selcx};\n-pub use self::select::{ProjectionMode, SelectionContext, SelectionCache};\n+pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n pub use self::select::{MethodMatchedData}; // intentionally don't export variants\n pub use self::specialize::{Overlap, specialization_graph, specializes, translate_substs};\n@@ -435,7 +433,7 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n \n     let elaborated_env = unnormalized_env.with_caller_bounds(predicates);\n \n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(elaborated_env));\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(elaborated_env), ProjectionMode::AnyFinal);\n     let predicates = match fully_normalize(&infcx,\n                                            cause,\n                                            &infcx.parameter_environment.caller_bounds) {"}, {"sha": "58d36b45ecb0a2ccfd86643f29b89bb3c192428f", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -35,6 +35,94 @@ use util::common::FN_OUTPUT_NAME;\n \n use std::rc::Rc;\n \n+/// Depending on the stage of compilation, we want projection to be\n+/// more or less conservative.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub enum ProjectionMode {\n+    /// At coherence-checking time, we're still constructing the\n+    /// specialization graph, and thus we only project project\n+    /// non-`default` associated types that are defined directly in\n+    /// the applicable impl. (This behavior should be improved over\n+    /// time, to allow for successful projections modulo cycles\n+    /// between different impls).\n+    // TODO: Add tracking issue to do better here.\n+    ///\n+    /// Here's an example that will fail due to the restriction:\n+    ///\n+    /// ```\n+    /// trait Assoc {\n+    ///     type Output;\n+    /// }\n+    ///\n+    /// impl<T> Assoc for T {\n+    ///     type Output = bool;\n+    /// }\n+    ///\n+    /// impl Assoc for u8 {} // <- inherits the non-default type from above\n+    ///\n+    /// trait Foo {}\n+    /// impl Foo for u32 {}\n+    /// impl Foo for <u8 as Assoc>::Output {}  // <- this projection will fail\n+    /// ```\n+    ///\n+    /// The projection would succeed if `Output` had been defined\n+    /// directly in the impl for `u8`.\n+    // TODO: Add test\n+    Topmost,\n+\n+    /// At type-checking time, we refuse to project any associated\n+    /// type that is marked `default`. Non-`default` (\"final\") types\n+    /// are always projected. This is necessary in general for\n+    /// soundness of specialization. However, we *could* allow\n+    /// projections in fully-monomorphic cases. We choose not to,\n+    /// because we prefer for `default type` to force the type\n+    /// definition to be treated abstractly by any consumers of the\n+    /// impl. Concretely, that means that the following example will\n+    /// fail to compile:\n+    ///\n+    /// ```\n+    /// trait Assoc {\n+    ///     type Output;\n+    /// }\n+    ///\n+    /// impl<T> Assoc for T {\n+    ///     default type Output = bool;\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let <() as Assoc>::Output = true;\n+    /// }\n+    // TODO: Add test\n+    AnyFinal,\n+\n+    /// At trans time, all projections will succeed.\n+    Any,\n+}\n+\n+impl ProjectionMode {\n+    pub fn topmost(&self) -> bool {\n+        match *self {\n+            ProjectionMode::Topmost => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn any_final(&self) -> bool {\n+        match *self {\n+            ProjectionMode::AnyFinal => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn any(&self) -> bool {\n+        match *self {\n+            ProjectionMode::Any => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+\n pub type PolyProjectionObligation<'tcx> =\n     Obligation<'tcx, ty::PolyProjectionPredicate<'tcx>>;\n "}, {"sha": "3ef163f225c4aa956c5a7abeab396c79448b7a59", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 10, "deletions": 126, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -25,6 +25,7 @@ use super::report_overflow_error;\n use super::{ObligationCauseCode, BuiltinDerivedObligation, ImplDerivedObligation};\n use super::{SelectionError, Unimplemented, OutputTypeParameterMismatch};\n use super::{ObjectCastObligation, Obligation};\n+use super::ProjectionMode;\n use super::TraitNotObjectSafe;\n use super::Selection;\n use super::SelectionResult;\n@@ -77,98 +78,6 @@ pub struct SelectionContext<'cx, 'tcx:'cx> {\n     /// there is no type that the user could *actually name* that\n     /// would satisfy it. This avoids crippling inference, basically.\n     intercrate: bool,\n-\n-    /// Sadly, the behavior of projection varies a bit depending on the\n-    /// stage of compilation. The specifics are given in the\n-    /// documentation for `ProjectionMode`.\n-    projection_mode: ProjectionMode,\n-}\n-\n-/// Depending on the stage of compilation, we want projection to be\n-/// more or less conservative.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-pub enum ProjectionMode {\n-    /// At coherence-checking time, we're still constructing the\n-    /// specialization graph, and thus we only project project\n-    /// non-`default` associated types that are defined directly in\n-    /// the applicable impl. (This behavior should be improved over\n-    /// time, to allow for successful projections modulo cycles\n-    /// between different impls).\n-    // TODO: Add tracking issue to do better here.\n-    ///\n-    /// Here's an example that will fail due to the restriction:\n-    ///\n-    /// ```\n-    /// trait Assoc {\n-    ///     type Output;\n-    /// }\n-    ///\n-    /// impl<T> Assoc for T {\n-    ///     type Output = bool;\n-    /// }\n-    ///\n-    /// impl Assoc for u8 {} // <- inherits the non-default type from above\n-    ///\n-    /// trait Foo {}\n-    /// impl Foo for u32 {}\n-    /// impl Foo for <u8 as Assoc>::Output {}  // <- this projection will fail\n-    /// ```\n-    ///\n-    /// The projection would succeed if `Output` had been defined\n-    /// directly in the impl for `u8`.\n-    // TODO: Add test\n-    Topmost,\n-\n-    /// At type-checking time, we refuse to project any associated\n-    /// type that is marked `default`. Non-`default` (\"final\") types\n-    /// are always projected. This is necessary in general for\n-    /// soundness of specialization. However, we *could* allow\n-    /// projections in fully-monomorphic cases. We choose not to,\n-    /// because we prefer for `default type` to force the type\n-    /// definition to be treated abstractly by any consumers of the\n-    /// impl. Concretely, that means that the following example will\n-    /// fail to compile:\n-    ///\n-    /// ```\n-    /// trait Assoc {\n-    ///     type Output;\n-    /// }\n-    ///\n-    /// impl<T> Assoc for T {\n-    ///     default type Output = bool;\n-    /// }\n-    ///\n-    /// fn main() {\n-    ///     let <() as Assoc>::Output = true;\n-    /// }\n-    // TODO: Add test\n-    AnyFinal,\n-\n-    /// At trans time, all projections will succeed.\n-    Any,\n-}\n-\n-impl ProjectionMode {\n-    pub fn topmost(&self) -> bool {\n-        match *self {\n-            ProjectionMode::Topmost => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn any_final(&self) -> bool {\n-        match *self {\n-            ProjectionMode::AnyFinal => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn any(&self) -> bool {\n-        match *self {\n-            ProjectionMode::Any => true,\n-            _ => false,\n-        }\n-    }\n }\n \n // A stack that walks back up the stack frame.\n@@ -348,45 +257,20 @@ pub struct EvaluationCache<'tcx> {\n     hashmap: RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, EvaluationResult>>\n }\n \n-pub struct SelectionContextBuilder<'cx, 'tcx: 'cx>(SelectionContext<'cx, 'tcx>);\n-\n-impl<'cx, 'tcx> SelectionContextBuilder<'cx, 'tcx> {\n-    pub fn intercrate(mut self) -> Self {\n-        self.0.intercrate = true;\n-        self\n-    }\n-\n-    pub fn project_any(mut self) -> Self {\n-        self.0.projection_mode = ProjectionMode::Any;\n-        self\n-    }\n-\n-    pub fn project_any_final(mut self) -> Self {\n-        self.0.projection_mode = ProjectionMode::AnyFinal;\n-        self\n-    }\n-\n-    pub fn project_topmost(mut self) -> Self {\n-        self.0.projection_mode = ProjectionMode::Topmost;\n-        self\n-    }\n-\n-    pub fn build(self) -> SelectionContext<'cx, 'tcx> {\n-        self.0\n-    }\n-}\n-\n-pub fn build_selcx<'cx, 'tcx>(infcx: &'cx InferCtxt<'cx, 'tcx>) -> SelectionContextBuilder<'cx, 'tcx> {\n-    SelectionContextBuilder(SelectionContext::new(infcx))\n-}\n-\n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>) -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx: infcx,\n             freshener: infcx.freshener(),\n             intercrate: false,\n-            projection_mode: ProjectionMode::AnyFinal,\n+        }\n+    }\n+\n+    pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'tcx>) -> SelectionContext<'cx, 'tcx> {\n+        SelectionContext {\n+            infcx: infcx,\n+            freshener: infcx.freshener(),\n+            intercrate: true,\n         }\n     }\n \n@@ -407,7 +291,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     pub fn projection_mode(&self) -> ProjectionMode {\n-        self.projection_mode\n+        self.infcx.projection_mode()\n     }\n \n     ///////////////////////////////////////////////////////////////////////////"}, {"sha": "9cdcc870404d747032a52719a196cfb4f7531e81", "filename": "src/librustc/middle/traits/specialize/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fmod.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -17,15 +17,15 @@\n // See traits/README.md for a bit more detail on how specialization\n // fits together with the rest of the trait machinery.\n \n-use super::{build_selcx, SelectionContext, FulfillmentContext};\n+use super::{SelectionContext, FulfillmentContext};\n use super::util::{fresh_type_vars_for_impl, impl_trait_ref_and_oblig};\n \n use middle::cstore::CrateStore;\n use middle::def_id::DefId;\n use middle::infer::{self, InferCtxt, TypeOrigin};\n use middle::region;\n use middle::subst::{Subst, Substs};\n-use middle::traits;\n+use middle::traits::{self, ProjectionMode};\n use middle::ty;\n use syntax::codemap::DUMMY_SP;\n \n@@ -159,7 +159,7 @@ pub fn specializes(tcx: &ty::ctxt, impl1_def_id: DefId, impl2_def_id: DefId) ->\n         return false\n     }\n \n-    let mut infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n+    let mut infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables, ProjectionMode::Topmost);\n \n     // Skiolemize impl1: we want to prove that \"for all types matched by impl1,\n     // those types are also matched by impl2\".\n@@ -199,7 +199,7 @@ fn fulfill_implication<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                  -> Result<Substs<'tcx>, ()>\n {\n     infcx.probe(|_| {\n-        let selcx = &mut build_selcx(&infcx).project_topmost().build();\n+        let selcx = &mut SelectionContext::new(&infcx);\n         let target_substs = fresh_type_vars_for_impl(&infcx, DUMMY_SP, target_impl);\n         let (target_trait_ref, obligations) = impl_trait_ref_and_oblig(selcx,\n                                                                        target_impl,"}, {"sha": "def50766f4e13f207c741f2d6493b89f671376dd", "filename": "src/librustc/middle/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -16,7 +16,7 @@ use super::{Overlap, specializes};\n use middle::cstore::CrateStore;\n use middle::def_id::DefId;\n use middle::infer;\n-use middle::traits;\n+use middle::traits::{self, ProjectionMode};\n use middle::ty::{self, ImplOrTraitItem, TraitDef, TypeFoldable};\n use syntax::ast::Name;\n use util::nodemap::DefIdMap;\n@@ -93,7 +93,7 @@ impl Graph {\n             for slot in possible_siblings.iter_mut() {\n                 let possible_sibling = *slot;\n \n-                let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+                let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, ProjectionMode::Topmost);\n                 let overlap = traits::overlapping_impls(&infcx, possible_sibling, impl_def_id);\n \n                 if let Some(trait_ref) = overlap {"}, {"sha": "5af40a3675ff7c199b7498ed3ca489e9a4b4b699", "filename": "src/librustc/middle/ty/util.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -17,7 +17,7 @@ use middle::def_id::DefId;\n use middle::subst;\n use middle::infer;\n use middle::pat_util;\n-use middle::traits;\n+use middle::traits::{self, ProjectionMode};\n use middle::ty::{self, Ty, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n use middle::ty::{Disr, ParameterEnvironment};\n use middle::ty::TypeVariants::*;\n@@ -130,7 +130,10 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n         let tcx = self.tcx;\n \n         // FIXME: (@jroesch) float this code up\n-        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(self.clone()));\n+        let infcx = infer::new_infer_ctxt(tcx,\n+                                          &tcx.tables,\n+                                          Some(self.clone()),\n+                                          ProjectionMode::AnyFinal);\n \n         let adt = match self_type.sty {\n             ty::TyStruct(struct_def, substs) => {\n@@ -542,7 +545,10 @@ impl<'tcx> ty::TyS<'tcx> {\n                        -> bool\n     {\n         let tcx = param_env.tcx;\n-        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env.clone()));\n+        let infcx = infer::new_infer_ctxt(tcx,\n+                                          &tcx.tables,\n+                                          Some(param_env.clone()),\n+                                          ProjectionMode::AnyFinal);\n \n         let is_impld = traits::type_known_to_meet_builtin_bound(&infcx,\n                                                                 self, bound, span);"}, {"sha": "9186765e6d02c0c49f9cf0f84dd7cc45a551e865", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -27,6 +27,7 @@ use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::region;\n use rustc::middle::ty::{self, TyCtxt};\n+use rustc::middle::traits::ProjectionMode;\n use syntax::ast;\n use syntax::codemap::Span;\n use rustc_front::hir;\n@@ -202,7 +203,10 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     debug!(\"check_loans(body id={})\", body.id);\n \n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n-    let infcx = infer::new_infer_ctxt(bccx.tcx, &bccx.tcx.tables, Some(param_env));\n+    let infcx = infer::new_infer_ctxt(bccx.tcx,\n+                                      &bccx.tcx.tables,\n+                                      Some(param_env),\n+                                      ProjectionMode::AnyFinal);\n \n     let mut clcx = CheckLoanCtxt {\n         bccx: bccx,"}, {"sha": "2d255c054548f42e8c0a6e06710d5b4ea8f8433a", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -24,6 +24,7 @@ use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::region;\n use rustc::middle::ty::{self, TyCtxt};\n+use rustc::middle::traits::ProjectionMode;\n \n use syntax::ast;\n use syntax::codemap::Span;\n@@ -55,7 +56,10 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     };\n \n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n-    let infcx = infer::new_infer_ctxt(bccx.tcx, &bccx.tcx.tables, Some(param_env));\n+    let infcx = infer::new_infer_ctxt(bccx.tcx,\n+                                      &bccx.tcx.tables,\n+                                      Some(param_env),\n+                                      ProjectionMode::AnyFinal);\n     {\n         let mut euv = euv::ExprUseVisitor::new(&mut glcx, &infcx);\n         euv.walk_fn(decl, body);\n@@ -525,7 +529,10 @@ struct StaticInitializerCtxt<'a, 'tcx: 'a> {\n impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &Expr) {\n         if let hir::ExprAddrOf(mutbl, ref base) = ex.node {\n-            let infcx = infer::new_infer_ctxt(self.bccx.tcx, &self.bccx.tcx.tables, None);\n+            let infcx = infer::new_infer_ctxt(self.bccx.tcx,\n+                                              &self.bccx.tcx.tables,\n+                                              None,\n+                                              ProjectionMode::AnyFinal);\n             let mc = mc::MemCategorizationContext::new(&infcx);\n             let base_cmt = mc.cat_expr(&base).unwrap();\n             let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);"}, {"sha": "88027931022e755824cee9766c6c91b3e63509f1", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -35,6 +35,7 @@ use middle::def_id::DefId;\n use middle::subst::Substs;\n use middle::ty::{self, Ty, TyCtxt};\n use middle::ty::adjustment;\n+use middle::traits::ProjectionMode;\n use rustc::front::map as hir_map;\n use util::nodemap::{NodeSet};\n use lint::{Level, LateContext, LintContext, LintArray, Lint};\n@@ -868,7 +869,10 @@ impl LateLintPass for UnconditionalRecursion {\n                     let node_id = tcx.map.as_local_node_id(method.def_id).unwrap();\n \n                     let param_env = ty::ParameterEnvironment::for_item(tcx, node_id);\n-                    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env));\n+                    let infcx = infer::new_infer_ctxt(tcx,\n+                                                      &tcx.tables,\n+                                                      Some(param_env),\n+                                                      ProjectionMode::AnyFinal);\n                     let mut selcx = traits::SelectionContext::new(&infcx);\n                     match selcx.select(&obligation) {\n                         // The method comes from a `T: Trait` bound."}, {"sha": "4aa8b82ec544eb2b12544dedca8f7c1ed65bbc16", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -27,7 +27,7 @@ use hair::cx::Cx;\n use rustc::mir::mir_map::MirMap;\n use rustc::middle::infer;\n use rustc::middle::region::CodeExtentData;\n-use rustc::middle::ty::{self, Ty, TyCtxt};\n+use rustc::middle::traits::ProjectionMode;\n use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::NodeMap;\n use rustc_front::hir;\n@@ -137,7 +137,11 @@ impl<'a, 'm, 'tcx> Visitor<'tcx> for InnerDump<'a,'m,'tcx> {\n         };\n \n         let param_env = ty::ParameterEnvironment::for_item(self.tcx, id);\n-        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, Some(param_env));\n+        let infcx = infer::new_infer_ctxt(self.tcx,\n+                                          &self.tcx.tables,\n+                                          Some(param_env),\n+                                          ProjectionMode::AnyFinal);\n+\n         match build_mir(Cx::new(&infcx), implicit_arg_tys, id, span, decl, body) {\n             Ok(mir) => assert!(self.map.map.insert(id, mir).is_none()),\n             Err(ErrorReported) => {}"}, {"sha": "6be7f6c200247a01abd0fefdb2bd35d62a5cefe5", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -35,8 +35,8 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::infer;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n-use rustc::middle::traits;\n use rustc::middle::ty::{self, Ty, TyCtxt};\n+use rustc::middle::traits::{self, ProjectionMode};\n use rustc::util::nodemap::NodeMap;\n use rustc::middle::const_qualif::ConstQualif;\n use rustc::lint::builtin::CONST_ERR;\n@@ -92,7 +92,10 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n             None => self.tcx.empty_parameter_environment()\n         };\n \n-        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, Some(param_env));\n+        let infcx = infer::new_infer_ctxt(self.tcx,\n+                                          &self.tcx.tables,\n+                                          Some(param_env),\n+                                          ProjectionMode::AnyFinal);\n \n         f(&mut euv::ExprUseVisitor::new(self, &infcx))\n     }\n@@ -247,7 +250,10 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n \n     fn check_static_type(&self, e: &hir::Expr) {\n         let ty = self.tcx.node_id_to_type(e.id);\n-        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None);\n+        let infcx = infer::new_infer_ctxt(self.tcx,\n+                                          &self.tcx.tables,\n+                                          None,\n+                                          ProjectionMode::AnyFinal);\n         let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n         fulfillment_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);"}, {"sha": "88048b514e1f50784c5f0f5b9840ac93a52fa729", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -16,6 +16,7 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::infer;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::ty::{self, TyCtxt, ParameterEnvironment};\n+use rustc::middle::traits::ProjectionMode;\n \n use rustc_front::hir;\n use rustc_front::intravisit;\n@@ -43,7 +44,8 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n             let param_env = ParameterEnvironment::for_item(self.tcx, fn_id);\n             let infcx = infer::new_infer_ctxt(self.tcx,\n                                               &self.tcx.tables,\n-                                              Some(param_env.clone()));\n+                                              Some(param_env.clone()),\n+                                              ProjectionMode::AnyFinal);\n             let mut delegate = RvalueContextDelegate { tcx: self.tcx, param_env: &param_env };\n             let mut euv = euv::ExprUseVisitor::new(&mut delegate, &infcx);\n             euv.walk_fn(fd, b);"}, {"sha": "f5fbec0b1879e65653e4e9e4660e73f7d4781aca", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -217,6 +217,7 @@ use trans::tvec;\n use trans::type_of;\n use trans::Disr;\n use middle::ty::{self, Ty, TyCtxt};\n+use middle::traits::ProjectionMode;\n use session::config::NoDebugInfo;\n use util::common::indenter;\n use util::nodemap::FnvHashMap;\n@@ -1475,7 +1476,9 @@ fn is_discr_reassigned(bcx: Block, discr: &hir::Expr, body: &hir::Expr) -> bool\n         reassigned: false\n     };\n     {\n-        let infcx = infer::normalizing_infer_ctxt(bcx.tcx(), &bcx.tcx().tables);\n+        let infcx = infer::normalizing_infer_ctxt(bcx.tcx(),\n+                                                  &bcx.tcx().tables,\n+                                                  ProjectionMode::Any);\n         let mut visitor = euv::ExprUseVisitor::new(&mut rc, &infcx);\n         visitor.walk_expr(body);\n     }"}, {"sha": "d93d32f8e0d068b327fc411d397372d3cb800403", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -13,6 +13,7 @@ use libc::{c_uint, c_ulonglong};\n use llvm::{self, ValueRef, AttrHelper};\n use middle::ty;\n use middle::infer;\n+use middle::traits::ProjectionMode;\n use session::config::NoDebugInfo;\n use syntax::abi::Abi;\n pub use syntax::attr::InlineAttr;\n@@ -133,7 +134,9 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n     let (fn_sig, abi, env_ty) = match fn_type.sty {\n         ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f) => (&f.sig, f.abi, None),\n         ty::TyClosure(closure_did, ref substs) => {\n-            let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n+            let infcx = infer::normalizing_infer_ctxt(ccx.tcx(),\n+                                                      &ccx.tcx().tables,\n+                                                      ProjectionMode::Any);\n             function_type = infcx.closure_type(closure_did, substs);\n             let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);\n             (&function_type.sig, Abi::RustCall, Some(self_type))"}, {"sha": "11c03fe7a7dc7b87eeb4637191671925009f96fd", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -13,6 +13,7 @@ use back::link::{self, mangle_internal_name_by_path_and_seq};\n use llvm::{ValueRef, get_params};\n use middle::def_id::DefId;\n use middle::infer;\n+use middle::traits::ProjectionMode;\n use trans::adt;\n use trans::attributes;\n use trans::base::*;\n@@ -206,7 +207,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     // this function (`trans_closure`) is invoked at the point\n     // of the closure expression.\n \n-    let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n+    let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables, ProjectionMode::Any);\n     let function_type = infcx.closure_type(closure_def_id, closure_substs);\n \n     let freevars: Vec<ty::Freevar> =\n@@ -329,7 +330,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n            ccx.tn().val_to_string(llreffn));\n \n     let tcx = ccx.tcx();\n-    let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n+    let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables, ProjectionMode::Any);\n \n     // Find a version of the closure type. Substitute static for the\n     // region since it doesn't really matter."}, {"sha": "0aa69dec253a1b7eb6713059788ab7b587abddae", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -37,8 +37,8 @@ use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n-use middle::traits;\n use middle::ty::{self, Ty, TyCtxt};\n+use middle::traits::{self, SelectionContext, ProjectionMode};\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n use rustc_front::hir;\n use rustc::mir::repr::Mir;\n@@ -1137,8 +1137,8 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n-    let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n-    let mut selcx = traits::build_selcx(&infcx).project_any().build();\n+    let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables, ProjectionMode::Any);\n+    let mut selcx = SelectionContext::new(&infcx);\n \n     let obligation =\n         traits::Obligation::new(traits::ObligationCause::misc(span, ast::DUMMY_NODE_ID),\n@@ -1198,8 +1198,8 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            predicates);\n \n     let tcx = ccx.tcx();\n-    let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n-    let mut selcx = traits::build_selcx(&infcx).project_any().build();\n+    let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables, ProjectionMode::Any);\n+    let mut selcx = SelectionContext::new(&infcx);\n     let mut fulfill_cx = traits::FulfillmentContext::new();\n     let cause = traits::ObligationCause::dummy();\n     let traits::Normalized { value: predicates, obligations } ="}, {"sha": "0c512200ff3d560ad19708b950e7978896340568", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -22,6 +22,7 @@\n use llvm::{self, ValueRef};\n use middle::ty;\n use middle::infer;\n+use middle::traits::ProjectionMode;\n use syntax::abi::Abi;\n use trans::attributes;\n use trans::base;\n@@ -111,7 +112,9 @@ pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n             (&f.sig, f.abi, None)\n         }\n         ty::TyClosure(closure_did, ref substs) => {\n-            let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n+            let infcx = infer::normalizing_infer_ctxt(ccx.tcx(),\n+                                                      &ccx.tcx().tables,\n+                                                      ProjectionMode::Any);\n             function_type = infcx.closure_type(closure_did, substs);\n             let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);\n             let llenvironment_type = type_of::type_of_explicit_arg(ccx, self_type);"}, {"sha": "0f5c1cf87f1e19083d9339179d148edcc8c63200", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -17,7 +17,7 @@ use middle::def_id::DefId;\n use middle::infer;\n use middle::subst::{Subst, Substs};\n use middle::subst;\n-use middle::traits;\n+use middle::traits::{self, ProjectionMode};\n use trans::base::*;\n use trans::build::*;\n use trans::callee::{Callee, Virtual, ArgVals,\n@@ -488,7 +488,7 @@ pub fn get_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n     let trait_def = tcx.lookup_trait_def(trait_def_id);\n-    let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n+    let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables, ProjectionMode::Any);\n \n     match trait_def.ancestors(impl_def_id).fn_defs(tcx, name).next() {\n         Some(node_item) => {"}, {"sha": "899f79b3dff94f1dd1729ee231d2f9001b27484a", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -10,8 +10,8 @@\n \n use middle::free_region::FreeRegionMap;\n use middle::infer::{self, TypeOrigin};\n-use middle::traits;\n use middle::ty::{self, TyCtxt};\n+use middle::traits::{self, ProjectionMode};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace};\n \n use syntax::ast;\n@@ -42,7 +42,7 @@ pub fn compare_impl_method<'tcx>(tcx: &TyCtxt<'tcx>,\n     debug!(\"compare_impl_method: impl_trait_ref (liberated) = {:?}\",\n            impl_trait_ref);\n \n-    let mut infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+    let mut infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, ProjectionMode::AnyFinal);\n     let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n     let trait_to_impl_substs = &impl_trait_ref.substs;\n@@ -416,7 +416,7 @@ pub fn compare_const_impl<'tcx>(tcx: &TyCtxt<'tcx>,\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\",\n            impl_trait_ref);\n \n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, ProjectionMode::AnyFinal);\n     let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n     // The below is for the most part highly similar to the procedure"}, {"sha": "4ed1bab46b2d9664be25848b6434d736ff6fe5f6", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -15,8 +15,8 @@ use middle::free_region::FreeRegionMap;\n use middle::infer;\n use middle::region;\n use middle::subst::{self, Subst};\n-use middle::traits;\n use middle::ty::{self, Ty, TyCtxt};\n+use middle::traits::{self, ProjectionMode};\n use util::nodemap::FnvHashSet;\n \n use syntax::ast;\n@@ -82,7 +82,10 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n     // check that the impl type can be made to match the trait type.\n \n     let impl_param_env = ty::ParameterEnvironment::for_item(tcx, self_type_node_id);\n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(impl_param_env));\n+    let infcx = infer::new_infer_ctxt(tcx,\n+                                      &tcx.tables,\n+                                      Some(impl_param_env),\n+                                      ProjectionMode::AnyFinal);\n     let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n     let named_type = tcx.lookup_item_type(self_type_did).ty;"}, {"sha": "cdff78d01e3e22e8c638b564fc16d0c5692fc11e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -92,7 +92,7 @@ use middle::infer;\n use middle::infer::{TypeOrigin, TypeTrace, type_variable};\n use middle::pat_util::{self, pat_id_map};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace};\n-use middle::traits::{self, report_fulfillment_errors};\n+use middle::traits::{self, report_fulfillment_errors, ProjectionMode};\n use middle::ty::{GenericPredicates, TypeScheme};\n use middle::ty::{ParamTy, ParameterEnvironment};\n use middle::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n@@ -307,7 +307,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n            -> Inherited<'a, 'tcx> {\n \n         Inherited {\n-            infcx: infer::new_infer_ctxt(tcx, tables, Some(param_env)),\n+            infcx: infer::new_infer_ctxt(tcx, tables, Some(param_env), ProjectionMode::AnyFinal),\n             fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n             locals: RefCell::new(NodeMap()),\n             tables: tables,"}, {"sha": "278d4d8b5b44a41fa378e5e0602babfd408d7821", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -18,8 +18,8 @@\n use middle::def_id::DefId;\n use middle::lang_items::UnsizeTraitLangItem;\n use middle::subst::{self, Subst};\n-use middle::traits;\n use middle::ty::{self, TyCtxt, TypeFoldable};\n+use middle::traits::{self, ProjectionMode};\n use middle::ty::{ImplOrTraitItemId, ConstTraitItemId};\n use middle::ty::{MethodTraitItemId, TypeTraitItemId, ParameterEnvironment};\n use middle::ty::{Ty, TyBool, TyChar, TyEnum, TyError};\n@@ -384,7 +384,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (free)\",\n                    source, target);\n \n-            let infcx = new_infer_ctxt(tcx, &tcx.tables, Some(param_env));\n+            let infcx = new_infer_ctxt(tcx, &tcx.tables, Some(param_env), ProjectionMode::Topmost);\n \n             let origin = TypeOrigin::Misc(span);\n             let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>, mt_b: ty::TypeAndMut<'tcx>,\n@@ -529,7 +529,10 @@ pub fn report_duplicate_item<'tcx>(tcx: &TyCtxt<'tcx>, sp: Span, name: ast::Name\n \n pub fn check_coherence(crate_context: &CrateCtxt) {\n     let _task = crate_context.tcx.dep_graph.in_task(DepNode::Coherence);\n-    let infcx = new_infer_ctxt(crate_context.tcx, &crate_context.tcx.tables, None);\n+    let infcx = new_infer_ctxt(crate_context.tcx,\n+                               &crate_context.tcx.tables,\n+                               None,\n+                               ProjectionMode::Topmost);\n     CoherenceChecker {\n         crate_context: crate_context,\n         inference_context: infcx,"}, {"sha": "936be8091940679db53387c4537e2612cfc93b20", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "patch": "@@ -106,6 +106,7 @@ use middle::def::Def;\n use middle::infer::{self, TypeOrigin};\n use middle::subst::Substs;\n use middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use middle::traits::ProjectionMode;\n use session::{config, CompileResult};\n use util::common::time;\n use rustc_front::hir;\n@@ -196,7 +197,7 @@ fn require_same_types<'a, 'tcx, M>(tcx: &TyCtxt<'tcx>,\n {\n     let result = match maybe_infcx {\n         None => {\n-            let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+            let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, ProjectionMode::AnyFinal);\n             infer::mk_eqty(&infcx, t1_is_expected, TypeOrigin::Misc(span), t1, t2)\n         }\n         Some(infcx) => {"}]}