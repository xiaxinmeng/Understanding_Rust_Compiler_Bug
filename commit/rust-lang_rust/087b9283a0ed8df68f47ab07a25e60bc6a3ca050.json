{"sha": "087b9283a0ed8df68f47ab07a25e60bc6a3ca050", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4N2I5MjgzYTBlZDhkZjY4ZjQ3YWIwN2EyNWU2MGJjNmEzY2EwNTA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-08-29T20:20:58Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-09-22T04:05:05Z"}, "message": "collections: Stabilize Vec\n\nThe following methods, types, and names have become stable:\n\n* Vec\n* Vec::as_mut_slice\n* Vec::as_slice\n* Vec::capacity\n* Vec::clear\n* Vec::default\n* Vec::grow\n* Vec::insert\n* Vec::len\n* Vec::new\n* Vec::pop\n* Vec::push\n* Vec::remove\n* Vec::set_len\n* Vec::shrink_to_fit\n* Vec::truncate\n* Vec::with_capacity\n\nThe following have become unstable:\n\n* Vec::dedup        // naming\n* Vec::from_fn      // naming and unboxed closures\n* Vec::get_mut      // will be removed for IndexMut\n* Vec::grow_fn      // unboxed closures and naming\n* Vec::retain       // unboxed closures\n* Vec::swap_remove  // uncertain naming\n* Vec::from_elem    // uncertain semantics\n* vec::unzip        // should be generic for all collections\n\nThe following have been deprecated\n\n* Vec::append - call .extend()\n* Vec::append_one - call .push()\n* Vec::from_slice - call .to_vec()\n* Vec::grow_set - call .grow() and then .push()\n* Vec::into_vec - move the vector instead\n* Vec::move_iter - renamed to iter_move()\n* Vec::to_vec - call .clone()\n\nThe following methods remain experimental pending conventions\n\n* vec::raw\n* vec::raw::from_buf\n* Vec:from_raw_parts\n* Vec::push_all\n\nThis is a breaking change in terms of the signature of the `Vec::grow` function.\nThe argument used to be taken by reference, but it is now taken by value. Code\nmust update by removing a leading `&` sigil or by calling `.clone()` to create a\nvalue.\n\n[breaking-change]", "tree": {"sha": "cebc272db3379fe238aa633a658ed4d5f3d411c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cebc272db3379fe238aa633a658ed4d5f3d411c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/087b9283a0ed8df68f47ab07a25e60bc6a3ca050", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/087b9283a0ed8df68f47ab07a25e60bc6a3ca050", "html_url": "https://github.com/rust-lang/rust/commit/087b9283a0ed8df68f47ab07a25e60bc6a3ca050", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/087b9283a0ed8df68f47ab07a25e60bc6a3ca050/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81d1feb9804f66034df4f218cc8fb0209c7450a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/81d1feb9804f66034df4f218cc8fb0209c7450a7", "html_url": "https://github.com/rust-lang/rust/commit/81d1feb9804f66034df4f218cc8fb0209c7450a7"}], "stats": {"total": 61, "additions": 56, "deletions": 5}, "files": [{"sha": "dc43dd5e53d6c2690092f656c375032f423d9834", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 56, "deletions": 5, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/087b9283a0ed8df68f47ab07a25e60bc6a3ca050/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/087b9283a0ed8df68f47ab07a25e60bc6a3ca050/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=087b9283a0ed8df68f47ab07a25e60bc6a3ca050", "patch": "@@ -99,6 +99,7 @@ use slice::{Items, MutItems};\n /// to use `Vec::with_capacity` whenever possible to specify how big the vector\n /// is expected to get.\n #[unsafe_no_drop_flag]\n+#[stable]\n pub struct Vec<T> {\n     len: uint,\n     cap: uint,\n@@ -116,6 +117,7 @@ impl<T> Vec<T> {\n     /// let mut vec: Vec<int> = Vec::new();\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn new() -> Vec<T> {\n         // We want ptr to never be NULL so instead we set it to some arbitrary\n         // non-null value which is fine since we never call deallocate on the ptr\n@@ -152,6 +154,7 @@ impl<T> Vec<T> {\n     /// vec.push(11);\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn with_capacity(capacity: uint) -> Vec<T> {\n         if mem::size_of::<T>() == 0 {\n             Vec { len: 0, cap: uint::MAX, ptr: EMPTY as *mut T }\n@@ -177,6 +180,8 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec, vec![0, 2, 4]);\n     /// ```\n     #[inline]\n+    #[unstable = \"the naming is uncertain as well as this migrating to unboxed \\\n+                  closures in the future\"]\n     pub fn from_fn(length: uint, op: |uint| -> T) -> Vec<T> {\n         unsafe {\n             let mut xs = Vec::with_capacity(length);\n@@ -229,6 +234,7 @@ impl<T> Vec<T> {\n     ///     }\n     /// }\n     /// ```\n+    #[experimental]\n     pub unsafe fn from_raw_parts(length: uint, capacity: uint,\n                                  ptr: *mut T) -> Vec<T> {\n         Vec { len: length, cap: capacity, ptr: ptr }\n@@ -249,6 +255,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(odd, vec![1, 3]);\n     /// ```\n     #[inline]\n+    #[experimental]\n     pub fn partition(self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) {\n         let mut lefts  = Vec::new();\n         let mut rights = Vec::new();\n@@ -277,6 +284,7 @@ impl<T: Clone> Vec<T> {\n     /// assert_eq!(vec, vec![1, 2, 3, 4]);\n     /// ```\n     #[inline]\n+    #[deprecated = \"this function has been deprecated in favor of extend()\"]\n     pub fn append(mut self, second: &[T]) -> Vec<T> {\n         self.push_all(second);\n         self\n@@ -291,6 +299,7 @@ impl<T: Clone> Vec<T> {\n     /// let vec = Vec::from_slice(slice);\n     /// ```\n     #[inline]\n+    #[deprecated = \"this function has been deprecated in favor of to_vec()\"]\n     pub fn from_slice(values: &[T]) -> Vec<T> {\n         let mut vector = Vec::new();\n         vector.push_all(values);\n@@ -307,6 +316,7 @@ impl<T: Clone> Vec<T> {\n     /// println!(\"{}\", vec); // prints [hi, hi, hi]\n     /// ```\n     #[inline]\n+    #[unstable = \"this functionality may become more generic over all collections\"]\n     pub fn from_elem(length: uint, value: T) -> Vec<T> {\n         unsafe {\n             let mut xs = Vec::with_capacity(length);\n@@ -333,6 +343,7 @@ impl<T: Clone> Vec<T> {\n     /// assert_eq!(vec, vec![1, 2, 3, 4]);\n     /// ```\n     #[inline]\n+    #[experimental]\n     pub fn push_all(&mut self, other: &[T]) {\n         self.reserve_additional(other.len());\n \n@@ -359,15 +370,16 @@ impl<T: Clone> Vec<T> {\n     ///\n     /// ```\n     /// let mut vec = vec![\"hello\"];\n-    /// vec.grow(2, &(\"world\"));\n+    /// vec.grow(2, \"world\");\n     /// assert_eq!(vec, vec![\"hello\", \"world\", \"world\"]);\n     /// ```\n-    pub fn grow(&mut self, n: uint, value: &T) {\n+    #[stable]\n+    pub fn grow(&mut self, n: uint, value: T) {\n         self.reserve_additional(n);\n         let mut i: uint = 0u;\n \n         while i < n {\n-            self.push((*value).clone());\n+            self.push(value.clone());\n             i += 1u;\n         }\n     }\n@@ -382,15 +394,17 @@ impl<T: Clone> Vec<T> {\n     /// # Example\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// let mut vec = vec![\"a\", \"b\", \"c\"];\n     /// vec.grow_set(1, &(\"fill\"), \"d\");\n     /// vec.grow_set(4, &(\"fill\"), \"e\");\n     /// assert_eq!(vec, vec![\"a\", \"d\", \"c\", \"fill\", \"e\"]);\n     /// ```\n+    #[deprecated = \"call .grow() and .push() manually instead\"]\n     pub fn grow_set(&mut self, index: uint, initval: &T, value: T) {\n         let l = self.len();\n         if index >= l {\n-            self.grow(index - l + 1u, initval);\n+            self.grow(index - l + 1u, initval.clone());\n         }\n         *self.get_mut(index) = value;\n     }\n@@ -409,6 +423,7 @@ impl<T: Clone> Vec<T> {\n     /// assert_eq!(even, vec![2i, 4]);\n     /// assert_eq!(odd, vec![1i, 3]);\n     /// ```\n+    #[experimental]\n     pub fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) {\n         let mut lefts = Vec::new();\n         let mut rights = Vec::new();\n@@ -449,6 +464,7 @@ impl<T:Clone> Clone for Vec<T> {\n     }\n }\n \n+#[experimental = \"waiting on Index stability\"]\n impl<T> Index<uint,T> for Vec<T> {\n     #[inline]\n     #[allow(deprecated)] // allow use of get\n@@ -506,6 +522,8 @@ impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n         self.as_mut_slice().slice_mut_(start, end)\n     }\n }\n+\n+#[experimental = \"waiting on FromIterator stability\"]\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n     fn from_iter<I:Iterator<T>>(mut iterator: I) -> Vec<T> {\n@@ -518,6 +536,7 @@ impl<T> FromIterator<T> for Vec<T> {\n     }\n }\n \n+#[experimental = \"waiting on Extendable stability\"]\n impl<T> Extendable<T> for Vec<T> {\n     #[inline]\n     fn extend<I: Iterator<T>>(&mut self, mut iterator: I) {\n@@ -529,43 +548,52 @@ impl<T> Extendable<T> for Vec<T> {\n     }\n }\n \n+#[unstable = \"waiting on PartialEq stability\"]\n impl<T: PartialEq> PartialEq for Vec<T> {\n     #[inline]\n     fn eq(&self, other: &Vec<T>) -> bool {\n         self.as_slice() == other.as_slice()\n     }\n }\n \n+#[unstable = \"waiting on PartialOrd stability\"]\n impl<T: PartialOrd> PartialOrd for Vec<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n         self.as_slice().partial_cmp(&other.as_slice())\n     }\n }\n \n+#[unstable = \"waiting on Eq stability\"]\n impl<T: Eq> Eq for Vec<T> {}\n \n+#[experimental]\n impl<T: PartialEq, V: Slice<T>> Equiv<V> for Vec<T> {\n     #[inline]\n     fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n }\n \n+#[unstable = \"waiting on Ord stability\"]\n impl<T: Ord> Ord for Vec<T> {\n     #[inline]\n     fn cmp(&self, other: &Vec<T>) -> Ordering {\n         self.as_slice().cmp(&other.as_slice())\n     }\n }\n \n+#[experimental = \"waiting on Collection stability\"]\n impl<T> Collection for Vec<T> {\n     #[inline]\n+    #[stable]\n     fn len(&self) -> uint {\n         self.len\n     }\n }\n \n impl<T: Clone> CloneableVector<T> for Vec<T> {\n+    #[deprecated = \"call .clone() instead\"]\n     fn to_vec(&self) -> Vec<T> { self.clone() }\n+    #[deprecated = \"move the vector instead\"]\n     fn into_vec(self) -> Vec<T> { self }\n }\n \n@@ -600,6 +628,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec.capacity(), 10);\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn capacity(&self) -> uint {\n         self.cap\n     }\n@@ -683,6 +712,7 @@ impl<T> Vec<T> {\n     /// let mut vec = vec![1i, 2, 3];\n     /// vec.shrink_to_fit();\n     /// ```\n+    #[stable]\n     pub fn shrink_to_fit(&mut self) {\n         if mem::size_of::<T>() == 0 { return }\n \n@@ -717,6 +747,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec, vec![1, 2, 3]);\n     /// ```\n     #[inline]\n+    #[deprecated = \"call .push() instead\"]\n     pub fn append_one(mut self, x: T) -> Vec<T> {\n         self.push(x);\n         self\n@@ -734,6 +765,7 @@ impl<T> Vec<T> {\n     /// vec.truncate(2);\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n+    #[stable]\n     pub fn truncate(&mut self, len: uint) {\n         unsafe {\n             // drop any extra elements\n@@ -757,6 +789,7 @@ impl<T> Vec<T> {\n     /// foo(vec.as_mut_slice());\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n         unsafe {\n             mem::transmute(RawSlice {\n@@ -796,7 +829,6 @@ impl<T> Vec<T> {\n         }\n     }\n \n-\n     /// Sets the length of a vector.\n     ///\n     /// This will explicitly set the size of the vector, without actually\n@@ -812,6 +844,7 @@ impl<T> Vec<T> {\n     /// }\n     /// ```\n     #[inline]\n+    #[stable]\n     pub unsafe fn set_len(&mut self, len: uint) {\n         self.len = len;\n     }\n@@ -850,6 +883,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec, vec![1i, 4, 3]);\n     /// ```\n     #[inline]\n+    #[unstable = \"this is likely to be moved to actual indexing\"]\n     pub fn get_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n         &mut self.as_mut_slice()[index]\n     }\n@@ -1020,6 +1054,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(v.swap_remove(2), None);\n     /// ```\n     #[inline]\n+    #[unstable = \"the naming of this function may be altered\"]\n     pub fn swap_remove(&mut self, index: uint) -> Option<T> {\n         let length = self.len();\n         if length > 0 && index < length - 1 {\n@@ -1088,6 +1123,7 @@ impl<T> Vec<T> {\n     /// vec.insert(4, 5);\n     /// assert_eq!(vec, vec![1, 4, 2, 3, 5]);\n     /// ```\n+    #[stable]\n     pub fn insert(&mut self, index: uint, element: T) {\n         let len = self.len();\n         assert!(index <= len);\n@@ -1124,6 +1160,7 @@ impl<T> Vec<T> {\n     /// // v is unchanged:\n     /// assert_eq!(v, vec![1, 3]);\n     /// ```\n+    #[stable]\n     pub fn remove(&mut self, index: uint) -> Option<T> {\n         let len = self.len();\n         if index < len {\n@@ -1410,6 +1447,7 @@ impl<T> Vec<T> {\n     /// vec.retain(|x| x%2 == 0);\n     /// assert_eq!(vec, vec![2, 4]);\n     /// ```\n+    #[unstable = \"the closure argument may become an unboxed closure\"]\n     pub fn retain(&mut self, f: |&T| -> bool) {\n         let len = self.len();\n         let mut del = 0u;\n@@ -1441,6 +1479,7 @@ impl<T> Vec<T> {\n     /// vec.grow_fn(3, |i| i);\n     /// assert_eq!(vec, vec![0, 1, 0, 1, 2]);\n     /// ```\n+    #[unstable = \"this function may be renamed or change to unboxed closures\"]\n     pub fn grow_fn(&mut self, n: uint, f: |uint| -> T) {\n         self.reserve_additional(n);\n         for i in range(0u, n) {\n@@ -1467,8 +1506,10 @@ impl<T:Ord> Vec<T> {\n     }\n }\n \n+#[experimental = \"waiting on Mutable stability\"]\n impl<T> Mutable for Vec<T> {\n     #[inline]\n+    #[stable]\n     fn clear(&mut self) {\n         self.truncate(0)\n     }\n@@ -1499,6 +1540,7 @@ impl<T: PartialEq> Vec<T> {\n     /// vec.dedup();\n     /// assert_eq!(vec, vec![1i, 2, 3, 2]);\n     /// ```\n+    #[unstable = \"this function may be renamed\"]\n     pub fn dedup(&mut self) {\n         unsafe {\n             // Although we have a mutable reference to `self`, we cannot make\n@@ -1596,6 +1638,7 @@ impl<T> Slice<T> for Vec<T> {\n     /// foo(vec.as_slice());\n     /// ```\n     #[inline]\n+    #[stable]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         unsafe { mem::transmute(RawSlice { data: self.as_ptr(), len: self.len }) }\n     }\n@@ -1627,18 +1670,21 @@ impl<T> Drop for Vec<T> {\n     }\n }\n \n+#[stable]\n impl<T> Default for Vec<T> {\n     fn default() -> Vec<T> {\n         Vec::new()\n     }\n }\n \n+#[experimental = \"waiting on Show stability\"]\n impl<T:fmt::Show> fmt::Show for Vec<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.as_slice().fmt(f)\n     }\n }\n \n+#[experimental = \"waiting on MutableSeq stability\"]\n impl<T> MutableSeq<T> for Vec<T> {\n     /// Appends an element to the back of a collection.\n     ///\n@@ -1654,6 +1700,7 @@ impl<T> MutableSeq<T> for Vec<T> {\n     /// assert_eq!(vec, vec!(1, 2, 3));\n     /// ```\n     #[inline]\n+    #[stable]\n     fn push(&mut self, value: T) {\n         if mem::size_of::<T>() == 0 {\n             // zero-size types consume no memory, so we can't rely on the address space running out\n@@ -1680,6 +1727,7 @@ impl<T> MutableSeq<T> for Vec<T> {\n     }\n \n     #[inline]\n+    #[stable]\n     fn pop(&mut self) -> Option<T> {\n         if self.len == 0 {\n             None\n@@ -1765,6 +1813,7 @@ impl<T> Drop for MoveItems<T> {\n /// vector contains the first element of the i-th tuple of the input iterator,\n /// and the i-th element of the second vector contains the second element\n /// of the i-th tuple of the input iterator.\n+#[unstable = \"this functionality may become more generic over time\"]\n pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (Vec<T>, Vec<U>) {\n     let (lo, _) = iter.size_hint();\n     let mut ts = Vec::with_capacity(lo);\n@@ -1777,6 +1826,7 @@ pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (Vec<T>, Vec<U>) {\n }\n \n /// Unsafe vector operations.\n+#[unstable]\n pub mod raw {\n     use super::Vec;\n     use core::ptr;\n@@ -1786,6 +1836,7 @@ pub mod raw {\n     /// The elements of the buffer are copied into the vector without cloning,\n     /// as if `ptr::read()` were called on them.\n     #[inline]\n+    #[unstable]\n     pub unsafe fn from_buf<T>(ptr: *const T, elts: uint) -> Vec<T> {\n         let mut dst = Vec::with_capacity(elts);\n         dst.set_len(elts);"}]}