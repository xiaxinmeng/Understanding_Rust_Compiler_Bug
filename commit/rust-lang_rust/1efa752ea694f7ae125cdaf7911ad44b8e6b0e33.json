{"sha": "1efa752ea694f7ae125cdaf7911ad44b8e6b0e33", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlZmE3NTJlYTY5NGY3YWUxMjVjZGFmNzkxMWFkNDRiOGU2YjBlMzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-15T16:45:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-15T16:45:57Z"}, "message": "Auto merge of #32251 - durka:derive-2810, r=alexcrichton\n\nderive: clean up hygiene\n\nderive: clean up hygiene\n\nFixes #2810.\n\nSpawned from #32139.\n\nr? @alexcrichton", "tree": {"sha": "494c42f8b2bc2e3da0831627b8e40eb613c94e69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/494c42f8b2bc2e3da0831627b8e40eb613c94e69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1efa752ea694f7ae125cdaf7911ad44b8e6b0e33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1efa752ea694f7ae125cdaf7911ad44b8e6b0e33", "html_url": "https://github.com/rust-lang/rust/commit/1efa752ea694f7ae125cdaf7911ad44b8e6b0e33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1efa752ea694f7ae125cdaf7911ad44b8e6b0e33/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9121e87a662568d42cc481f87d81ed4df38cc0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9121e87a662568d42cc481f87d81ed4df38cc0d", "html_url": "https://github.com/rust-lang/rust/commit/f9121e87a662568d42cc481f87d81ed4df38cc0d"}, {"sha": "8355389e3e9d299d90ea78197c0e5b6c2162a957", "url": "https://api.github.com/repos/rust-lang/rust/commits/8355389e3e9d299d90ea78197c0e5b6c2162a957", "html_url": "https://github.com/rust-lang/rust/commit/8355389e3e9d299d90ea78197c0e5b6c2162a957"}], "stats": {"total": 254, "additions": 140, "deletions": 114}, "files": [{"sha": "a7e156c5f68205e9aba949295bd636e2be20b66f", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1efa752ea694f7ae125cdaf7911ad44b8e6b0e33/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efa752ea694f7ae125cdaf7911ad44b8e6b0e33/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=1efa752ea694f7ae125cdaf7911ad44b8e6b0e33", "patch": "@@ -11,7 +11,7 @@\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{MetaItem, Expr, BinOpKind, self};\n+use syntax::ast::{MetaItem, Expr, self};\n use syntax::codemap::Span;\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n@@ -64,7 +64,7 @@ pub fn ordering_collapsed(cx: &mut ExtCtxt,\n \n pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n               substr: &Substructure) -> P<Expr> {\n-    let test_id = cx.ident_of(\"__test\");\n+    let test_id = cx.ident_of(\"cmp\");\n     let equals_path = cx.path_global(span,\n                                      cx.std_path(&[\"cmp\", \"Ordering\", \"Equal\"]));\n \n@@ -73,36 +73,31 @@ pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n     /*\n     Builds:\n \n-    let __test = ::std::cmp::Ord::cmp(&self_field1, &other_field1);\n-    if other == ::std::cmp::Ordering::Equal {\n-        let __test = ::std::cmp::Ord::cmp(&self_field2, &other_field2);\n-        if __test == ::std::cmp::Ordering::Equal {\n-            ...\n-        } else {\n-            __test\n-        }\n-    } else {\n-        __test\n+    match ::std::cmp::Ord::cmp(&self_field1, &other_field1) {\n+        ::std::cmp::Ordering::Equal =>\n+            match ::std::cmp::Ord::cmp(&self_field2, &other_field2) {\n+                ::std::cmp::Ordering::Equal => {\n+                    ...\n+                }\n+                cmp => cmp\n+            },\n+        cmp => cmp\n     }\n-\n-    FIXME #6449: These `if`s could/should be `match`es.\n     */\n     cs_fold(\n         // foldr nests the if-elses correctly, leaving the first field\n         // as the outermost one, and the last as the innermost.\n         false,\n         |cx, span, old, self_f, other_fs| {\n-            // let __test = new;\n-            // if __test == ::std::cmp::Ordering::Equal {\n-            //    old\n-            // } else {\n-            //    __test\n+            // match new {\n+            //     ::std::cmp::Ordering::Equal => old,\n+            //     cmp => cmp\n             // }\n \n             let new = {\n                 let other_f = match (other_fs.len(), other_fs.get(0)) {\n                     (1, Some(o_f)) => o_f,\n-                    _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n+                    _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\"),\n                 };\n \n                 let args = vec![\n@@ -113,20 +108,21 @@ pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n                 cx.expr_call_global(span, cmp_path.clone(), args)\n             };\n \n-            let assign = cx.stmt_let(span, false, test_id, new);\n+            let eq_arm = cx.arm(span,\n+                                vec![cx.pat_enum(span,\n+                                                 equals_path.clone(),\n+                                                 vec![])],\n+                                old);\n+            let neq_arm = cx.arm(span,\n+                                 vec![cx.pat_ident(span, test_id)],\n+                                 cx.expr_ident(span, test_id));\n \n-            let cond = cx.expr_binary(span, BinOpKind::Eq,\n-                                      cx.expr_ident(span, test_id),\n-                                      cx.expr_path(equals_path.clone()));\n-            let if_ = cx.expr_if(span,\n-                                 cond,\n-                                 old, Some(cx.expr_ident(span, test_id)));\n-            cx.expr_block(cx.block(span, vec!(assign), Some(if_)))\n+            cx.expr_match(span, new, vec![eq_arm, neq_arm])\n         },\n         cx.expr_path(equals_path.clone()),\n         Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n             if self_args.len() != 2 {\n-                cx.span_bug(span, \"not exactly 2 arguments in `derives(Ord)`\")\n+                cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\")\n             } else {\n                 ordering_collapsed(cx, span, tag_tuple)\n             }"}, {"sha": "b3864a6c2e79e3e609a1b9ad5b553ee9cc0d810d", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/1efa752ea694f7ae125cdaf7911ad44b8e6b0e33/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efa752ea694f7ae125cdaf7911ad44b8e6b0e33/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=1efa752ea694f7ae125cdaf7911ad44b8e6b0e33", "patch": "@@ -107,41 +107,36 @@ pub fn some_ordering_collapsed(cx: &mut ExtCtxt,\n \n pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n               substr: &Substructure) -> P<Expr> {\n-    let test_id = cx.ident_of(\"__test\");\n+    let test_id = cx.ident_of(\"cmp\");\n     let ordering = cx.path_global(span,\n                                   cx.std_path(&[\"cmp\", \"Ordering\", \"Equal\"]));\n-    let ordering = cx.expr_path(ordering);\n-    let equals_expr = cx.expr_some(span, ordering);\n+    let ordering_expr = cx.expr_path(ordering.clone());\n+    let equals_expr = cx.expr_some(span, ordering_expr);\n \n     let partial_cmp_path = cx.std_path(&[\"cmp\", \"PartialOrd\", \"partial_cmp\"]);\n \n     /*\n     Builds:\n \n-    let __test = ::std::cmp::PartialOrd::partial_cmp(&self_field1, &other_field1);\n-    if __test == ::std::option::Option::Some(::std::cmp::Ordering::Equal) {\n-        let __test = ::std::cmp::PartialOrd::partial_cmp(&self_field2, &other_field2);\n-        if __test == ::std::option::Option::Some(::std::cmp::Ordering::Equal) {\n-            ...\n-        } else {\n-            __test\n-        }\n-    } else {\n-        __test\n+    match ::std::cmp::PartialOrd::partial_cmp(&self_field1, &other_field1) {\n+        ::std::option::Option::Some(::std::cmp::Ordering::Equal) =>\n+            match ::std::cmp::PartialOrd::partial_cmp(&self_field2, &other_field2) {\n+                ::std::option::Option::Some(::std::cmp::Ordering::Equal) => {\n+                    ...\n+                }\n+                cmp => cmp\n+            },\n+        cmp => cmp\n     }\n-\n-    FIXME #6449: These `if`s could/should be `match`es.\n     */\n     cs_fold(\n         // foldr nests the if-elses correctly, leaving the first field\n         // as the outermost one, and the last as the innermost.\n         false,\n         |cx, span, old, self_f, other_fs| {\n-            // let __test = new;\n-            // if __test == Some(::std::cmp::Ordering::Equal) {\n-            //    old\n-            // } else {\n-            //    __test\n+            // match new {\n+            //     Some(::std::cmp::Ordering::Equal) => old,\n+            //     cmp => cmp\n             // }\n \n             let new = {\n@@ -158,15 +153,17 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n                 cx.expr_call_global(span, partial_cmp_path.clone(), args)\n             };\n \n-            let assign = cx.stmt_let(span, false, test_id, new);\n-\n-            let cond = cx.expr_binary(span, BinOpKind::Eq,\n-                                      cx.expr_ident(span, test_id),\n-                                      equals_expr.clone());\n-            let if_ = cx.expr_if(span,\n-                                 cond,\n-                                 old, Some(cx.expr_ident(span, test_id)));\n-            cx.expr_block(cx.block(span, vec!(assign), Some(if_)))\n+            let eq_arm = cx.arm(span,\n+                                vec![cx.pat_some(span,\n+                                                 cx.pat_enum(span,\n+                                                             ordering.clone(),\n+                                                             vec![]))],\n+                                old);\n+            let neq_arm = cx.arm(span,\n+                                 vec![cx.pat_ident(span, test_id)],\n+                                 cx.expr_ident(span, test_id));\n+\n+            cx.expr_match(span, new, vec![eq_arm, neq_arm])\n         },\n         equals_expr.clone(),\n         Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {"}, {"sha": "49f14c937e953771e442fd3f315733dfcadee607", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1efa752ea694f7ae125cdaf7911ad44b8e6b0e33/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efa752ea694f7ae125cdaf7911ad44b8e6b0e33/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=1efa752ea694f7ae125cdaf7911ad44b8e6b0e33", "patch": "@@ -10,6 +10,7 @@\n \n //! The compiler code necessary for `#[derive(Decodable)]`. See encodable.rs for more.\n \n+use deriving;\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n@@ -54,6 +55,8 @@ fn expand_deriving_decodable_imp(cx: &mut ExtCtxt,\n         return\n     }\n \n+    let typaram = &*deriving::hygienic_type_parameter(item, \"__D\");\n+\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n@@ -66,18 +69,17 @@ fn expand_deriving_decodable_imp(cx: &mut ExtCtxt,\n                 name: \"decode\",\n                 generics: LifetimeBounds {\n                     lifetimes: Vec::new(),\n-                    bounds: vec!((\"__D\", vec!(Path::new_(\n-                                    vec!(krate, \"Decoder\"), None,\n-                                    vec!(), true))))\n+                    bounds: vec![(typaram,\n+                                  vec![Path::new_(vec!(krate, \"Decoder\"), None, vec!(), true)])]\n                 },\n                 explicit_self: None,\n-                args: vec!(Ptr(Box::new(Literal(Path::new_local(\"__D\"))),\n+                args: vec!(Ptr(Box::new(Literal(Path::new_local(typaram))),\n                             Borrowed(None, Mutability::Mutable))),\n                 ret_ty: Literal(Path::new_(\n                     pathvec_std!(cx, core::result::Result),\n                     None,\n                     vec!(Box::new(Self_), Box::new(Literal(Path::new_(\n-                        vec![\"__D\", \"Error\"], None, vec![], false\n+                        vec![typaram, \"Error\"], None, vec![], false\n                     )))),\n                     true\n                 )),"}, {"sha": "a05bd7869b2a9ccd1065c375c6fb4f28af1b748c", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1efa752ea694f7ae125cdaf7911ad44b8e6b0e33/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efa752ea694f7ae125cdaf7911ad44b8e6b0e33/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=1efa752ea694f7ae125cdaf7911ad44b8e6b0e33", "patch": "@@ -88,6 +88,7 @@\n //! }\n //! ```\n \n+use deriving;\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n@@ -130,6 +131,8 @@ fn expand_deriving_encodable_imp(cx: &mut ExtCtxt,\n         return;\n     }\n \n+    let typaram = &*deriving::hygienic_type_parameter(item, \"__S\");\n+\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n@@ -142,18 +145,17 @@ fn expand_deriving_encodable_imp(cx: &mut ExtCtxt,\n                 name: \"encode\",\n                 generics: LifetimeBounds {\n                     lifetimes: Vec::new(),\n-                    bounds: vec!((\"__S\", vec!(Path::new_(\n-                                    vec!(krate, \"Encoder\"), None,\n-                                    vec!(), true))))\n+                    bounds: vec![(typaram,\n+                                  vec![Path::new_(vec![krate, \"Encoder\"], None, vec!(), true)])]\n                 },\n                 explicit_self: borrowed_explicit_self(),\n-                args: vec!(Ptr(Box::new(Literal(Path::new_local(\"__S\"))),\n+                args: vec!(Ptr(Box::new(Literal(Path::new_local(typaram))),\n                             Borrowed(None, Mutability::Mutable))),\n                 ret_ty: Literal(Path::new_(\n                     pathvec_std!(cx, core::result::Result),\n                     None,\n                     vec!(Box::new(Tuple(Vec::new())), Box::new(Literal(Path::new_(\n-                        vec![\"__S\", \"Error\"], None, vec![], false\n+                        vec![typaram, \"Error\"], None, vec![], false\n                     )))),\n                     true\n                 )),"}, {"sha": "58c84e68795980f14a2dba7e514ac97e2b59c187", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/1efa752ea694f7ae125cdaf7911ad44b8e6b0e33/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efa752ea694f7ae125cdaf7911ad44b8e6b0e33/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=1efa752ea694f7ae125cdaf7911ad44b8e6b0e33", "patch": "@@ -156,14 +156,14 @@\n //!\n //! ```{.text}\n //! EnumNonMatchingCollapsed(\n-//!     vec![<ident of self>, <ident of __arg_1>],\n+//!     vec![<ident of self>, <ident of arg_1>],\n //!     &[<ast::Variant for C0>, <ast::Variant for C1>],\n-//!     &[<ident for self index value>, <ident of __arg_1 index value>])\n+//!     &[<ident for self index value>, <ident of arg_1 index value>])\n //! ```\n //!\n //! It is the same for when the arguments are flipped to `C1 {x}` and\n //! `C0(a)`; the only difference is what the values of the identifiers\n-//! <ident for self index value> and <ident of __arg_1 index value> will\n+//! <ident for self index value> and <ident of arg_1 index value> will\n //! be in the generated code.\n //!\n //! `EnumNonMatchingCollapsed` deliberately provides far less information\n@@ -843,7 +843,7 @@ impl<'a> MethodDef<'a> {\n \n         for (i, ty) in self.args.iter().enumerate() {\n             let ast_ty = ty.to_ty(cx, trait_.span, type_ident, generics);\n-            let ident = cx.ident_of(&format!(\"__arg_{}\", i));\n+            let ident = cx.ident_of(&format!(\"arg_{}\", i));\n             arg_tys.push((ident, ast_ty));\n \n             let arg_expr = cx.expr_ident(trait_.span, ident);\n@@ -929,12 +929,12 @@ impl<'a> MethodDef<'a> {\n     ///\n     /// // equivalent to:\n     /// impl PartialEq for A {\n-    ///     fn eq(&self, __arg_1: &A) -> bool {\n+    ///     fn eq(&self, arg_1: &A) -> bool {\n     ///         match *self {\n-    ///             A {x: ref __self_0_0, y: ref __self_0_1} => {\n-    ///                 match *__arg_1 {\n-    ///                     A {x: ref __self_1_0, y: ref __self_1_1} => {\n-    ///                         __self_0_0.eq(__self_1_0) && __self_0_1.eq(__self_1_1)\n+    ///             A {x: ref self_0_0, y: ref self_0_1} => {\n+    ///                 match *arg_1 {\n+    ///                     A {x: ref self_1_0, y: ref self_1_1} => {\n+    ///                         self_0_0.eq(self_1_0) && self_0_1.eq(self_1_1)\n     ///                     }\n     ///                 }\n     ///             }\n@@ -960,7 +960,7 @@ impl<'a> MethodDef<'a> {\n                 trait_.create_struct_pattern(cx,\n                                              struct_path,\n                                              struct_def,\n-                                             &format!(\"__self_{}\",\n+                                             &format!(\"self_{}\",\n                                                      i),\n                                              ast::Mutability::Immutable);\n             patterns.push(pat);\n@@ -1038,25 +1038,25 @@ impl<'a> MethodDef<'a> {\n     /// // is equivalent to\n     ///\n     /// impl PartialEq for A {\n-    ///     fn eq(&self, __arg_1: &A) -> ::bool {\n-    ///         match (&*self, &*__arg_1) {\n+    ///     fn eq(&self, arg_1: &A) -> ::bool {\n+    ///         match (&*self, &*arg_1) {\n     ///             (&A1, &A1) => true,\n-    ///             (&A2(ref __self_0),\n-    ///              &A2(ref __arg_1_0)) => (*__self_0).eq(&(*__arg_1_0)),\n+    ///             (&A2(ref self_0),\n+    ///              &A2(ref arg_1_0)) => (*self_0).eq(&(*arg_1_0)),\n     ///             _ => {\n-    ///                 let __self_vi = match *self { A1(..) => 0, A2(..) => 1 };\n-    ///                 let __arg_1_vi = match *__arg_1 { A1(..) => 0, A2(..) => 1 };\n+    ///                 let self_vi = match *self { A1(..) => 0, A2(..) => 1 };\n+    ///                 let arg_1_vi = match *arg_1 { A1(..) => 0, A2(..) => 1 };\n     ///                 false\n     ///             }\n     ///         }\n     ///     }\n     /// }\n     /// ```\n     ///\n-    /// (Of course `__self_vi` and `__arg_1_vi` are unused for\n+    /// (Of course `self_vi` and `arg_1_vi` are unused for\n     /// `PartialEq`, and those subcomputations will hopefully be removed\n-    /// as their results are unused.  The point of `__self_vi` and\n-    /// `__arg_1_vi` is for `PartialOrd`; see #15503.)\n+    /// as their results are unused.  The point of `self_vi` and\n+    /// `arg_1_vi` is for `PartialOrd`; see #15503.)\n     fn expand_enum_method_body<'b>(&self,\n                                cx: &mut ExtCtxt,\n                                trait_: &TraitDef<'b>,\n@@ -1087,14 +1087,14 @@ impl<'a> MethodDef<'a> {\n     /// for each of the self-args, carried in precomputed variables.\n \n     /// ```{.text}\n-    /// let __self0_vi = unsafe {\n+    /// let self0_vi = unsafe {\n     ///     std::intrinsics::discriminant_value(&self) } as i32;\n-    /// let __self1_vi = unsafe {\n-    ///     std::intrinsics::discriminant_value(&__arg1) } as i32;\n-    /// let __self2_vi = unsafe {\n-    ///     std::intrinsics::discriminant_value(&__arg2) } as i32;\n+    /// let self1_vi = unsafe {\n+    ///     std::intrinsics::discriminant_value(&arg1) } as i32;\n+    /// let self2_vi = unsafe {\n+    ///     std::intrinsics::discriminant_value(&arg2) } as i32;\n     ///\n-    /// if __self0_vi == __self1_vi && __self0_vi == __self2_vi && ... {\n+    /// if self0_vi == self1_vi && self0_vi == self2_vi && ... {\n     ///     match (...) {\n     ///         (Variant1, Variant1, ...) => Body1\n     ///         (Variant2, Variant2, ...) => Body2,\n@@ -1122,9 +1122,9 @@ impl<'a> MethodDef<'a> {\n         let self_arg_names = self_args.iter().enumerate()\n             .map(|(arg_count, _self_arg)| {\n                 if arg_count == 0 {\n-                    \"__self\".to_string()\n+                    \"self\".to_string()\n                 } else {\n-                    format!(\"__arg_{}\", arg_count)\n+                    format!(\"arg_{}\", arg_count)\n                 }\n             })\n             .collect::<Vec<String>>();\n@@ -1261,17 +1261,17 @@ impl<'a> MethodDef<'a> {\n             // with three Self args, builds three statements:\n             //\n             // ```\n-            // let __self0_vi = unsafe {\n+            // let self0_vi = unsafe {\n             //     std::intrinsics::discriminant_value(&self) } as i32;\n-            // let __self1_vi = unsafe {\n-            //     std::intrinsics::discriminant_value(&__arg1) } as i32;\n-            // let __self2_vi = unsafe {\n-            //     std::intrinsics::discriminant_value(&__arg2) } as i32;\n+            // let self1_vi = unsafe {\n+            //     std::intrinsics::discriminant_value(&arg1) } as i32;\n+            // let self2_vi = unsafe {\n+            //     std::intrinsics::discriminant_value(&arg2) } as i32;\n             // ```\n             let mut index_let_stmts: Vec<ast::Stmt> = Vec::new();\n \n             //We also build an expression which checks whether all discriminants are equal\n-            // discriminant_test = __self0_vi == __self1_vi && __self0_vi == __self2_vi && ...\n+            // discriminant_test = self0_vi == self1_vi && self0_vi == self2_vi && ...\n             let mut discriminant_test = cx.expr_bool(sp, true);\n \n             let target_type_name =\n@@ -1321,7 +1321,7 @@ impl<'a> MethodDef<'a> {\n             // down to desired l-values, but we cannot actually deref\n             // them when they are fed as r-values into a tuple\n             // expression; here add a layer of borrowing, turning\n-            // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n+            // `(*self, *arg_0, ...)` into `(&*self, &*arg_0, ...)`.\n             let borrowed_self_args = self_args.move_map(|self_arg| cx.expr_addr_of(sp, self_arg));\n             let match_arg = cx.expr(sp, ast::ExprKind::Tup(borrowed_self_args));\n \n@@ -1335,7 +1335,7 @@ impl<'a> MethodDef<'a> {\n             //      }\n             //  }\n             //  else {\n-            //      <delegated expression referring to __self0_vi, et al.>\n+            //      <delegated expression referring to self0_vi, et al.>\n             //  }\n             let all_match = cx.expr_match(sp, match_arg, match_arms);\n             let arm_expr = cx.expr_if(sp, discriminant_test, all_match, Some(arm_expr));\n@@ -1359,8 +1359,8 @@ impl<'a> MethodDef<'a> {\n             // error-prone, since the catch-all as defined above would\n             // generate code like this:\n             //\n-            //     _ => { let __self0 = match *self { };\n-            //            let __self1 = match *__arg_0 { };\n+            //     _ => { let self0 = match *self { };\n+            //            let self1 = match *arg_0 { };\n             //            <catch-all-expr> }\n             //\n             // Which is yields bindings for variables which type\n@@ -1399,7 +1399,7 @@ impl<'a> MethodDef<'a> {\n             // down to desired l-values, but we cannot actually deref\n             // them when they are fed as r-values into a tuple\n             // expression; here add a layer of borrowing, turning\n-            // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n+            // `(*self, *arg_0, ...)` into `(&*self, &*arg_0, ...)`.\n             let borrowed_self_args = self_args.move_map(|self_arg| cx.expr_addr_of(sp, self_arg));\n             let match_arg = cx.expr(sp, ast::ExprKind::Tup(borrowed_self_args));\n             cx.expr_match(sp, match_arg, match_arms)\n@@ -1613,8 +1613,8 @@ pub fn cs_fold<F>(use_foldl: bool,\n /// process the collected results. i.e.\n ///\n /// ```ignore\n-/// f(cx, span, vec![self_1.method(__arg_1_1, __arg_2_1),\n-///                  self_2.method(__arg_1_2, __arg_2_2)])\n+/// f(cx, span, vec![self_1.method(arg_1_1, arg_2_1),\n+///                  self_2.method(arg_1_2, arg_2_2)])\n /// ```\n #[inline]\n pub fn cs_same_method<F>(f: F,"}, {"sha": "ba38ebc860713e744c8a71a58d5058dbfd9454e8", "filename": "src/libsyntax_ext/deriving/hash.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1efa752ea694f7ae125cdaf7911ad44b8e6b0e33/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efa752ea694f7ae125cdaf7911ad44b8e6b0e33/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs?ref=1efa752ea694f7ae125cdaf7911ad44b8e6b0e33", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use deriving;\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n@@ -26,7 +27,10 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n \n     let path = Path::new_(pathvec_std!(cx, core::hash::Hash), None,\n                           vec!(), true);\n-    let arg = Path::new_local(\"__H\");\n+\n+    let typaram = &*deriving::hygienic_type_parameter(item, \"__H\");\n+\n+    let arg = Path::new_local(typaram);\n     let hash_trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n@@ -39,7 +43,7 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n                 name: \"hash\",\n                 generics: LifetimeBounds {\n                     lifetimes: Vec::new(),\n-                    bounds: vec![(\"__H\",\n+                    bounds: vec![(typaram,\n                                   vec![path_std!(cx, core::hash::Hasher)])],\n                 },\n                 explicit_self: borrowed_explicit_self(),"}, {"sha": "75de5c56ea139e32d1e4dd31dbd525a7823642ec", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1efa752ea694f7ae125cdaf7911ad44b8e6b0e33/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efa752ea694f7ae125cdaf7911ad44b8e6b0e33/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=1efa752ea694f7ae125cdaf7911ad44b8e6b0e33", "patch": "@@ -9,11 +9,8 @@\n // except according to those terms.\n \n //! The compiler code necessary to implement the `#[derive]` extensions.\n-//!\n-//! FIXME (#2810): hygiene. Search for \"__\" strings (in other files too). We also assume \"extra\" is\n-//! the standard library, and \"std\" is the core library.\n \n-use syntax::ast::{MetaItem, MetaItemKind};\n+use syntax::ast::{MetaItem, MetaItemKind, self};\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::base::{ExtCtxt, SyntaxEnv, Annotatable};\n use syntax::ext::base::{MultiDecorator, MultiItemDecorator, MultiModifier};\n@@ -197,3 +194,27 @@ fn warn_if_deprecated(ecx: &mut ExtCtxt, sp: Span, name: &str) {\n                                    name, replacement));\n     }\n }\n+\n+/// Construct a name for the inner type parameter that can't collide with any type parameters of\n+/// the item. This is achieved by starting with a base and then concatenating the names of all\n+/// other type parameters.\n+// FIXME(aburka): use real hygiene when that becomes possible\n+fn hygienic_type_parameter(item: &Annotatable, base: &str) -> String {\n+    let mut typaram = String::from(base);\n+    if let Annotatable::Item(ref item) = *item {\n+        match item.node {\n+            ast::ItemKind::Struct(_, ast::Generics { ref ty_params, .. }) |\n+                ast::ItemKind::Enum(_, ast::Generics { ref ty_params, .. }) => {\n+\n+                for ty in ty_params.iter() {\n+                    typaram.push_str(&ty.ident.name.as_str());\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+    }\n+\n+    typaram\n+}\n+"}, {"sha": "a98cfa2393f1ef01bd5daaab5ef35c66f36ccbaa", "filename": "src/test/run-pass/deriving-hash.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1efa752ea694f7ae125cdaf7911ad44b8e6b0e33/src%2Ftest%2Frun-pass%2Fderiving-hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efa752ea694f7ae125cdaf7911ad44b8e6b0e33/src%2Ftest%2Frun-pass%2Fderiving-hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-hash.rs?ref=1efa752ea694f7ae125cdaf7911ad44b8e6b0e33", "patch": "@@ -20,6 +20,10 @@ struct Person {\n     phone: usize,\n }\n \n+// test for hygiene name collisions\n+#[derive(Hash)] struct __H__H;\n+#[derive(Hash)] enum Collision<__H> { __H { __H__H: __H } }\n+\n fn hash<T: Hash>(t: &T) -> u64 {\n     let mut s = SipHasher::new_with_keys(0, 0);\n     t.hash(&mut s);"}]}