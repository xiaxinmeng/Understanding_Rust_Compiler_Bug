{"sha": "c9599d79a3b741b7c42353dc45eab6f1c461891f", "node_id": "C_kwDOAAsO6NoAKGM5NTk5ZDc5YTNiNzQxYjdjNDIzNTNkYzQ1ZWFiNmYxYzQ2MTg5MWY", "commit": {"author": {"name": "Samuel E. Moelius III", "email": "sam@moeli.us", "date": "2021-09-30T11:45:03Z"}, "committer": {"name": "Samuel E. Moelius III", "email": "sam@moeli.us", "date": "2021-10-15T16:44:38Z"}, "message": "Add `format_in_format_args` and `to_string_in_format_args` lints\n\nFixes #7667 and #7729", "tree": {"sha": "6a6f4ff8f34612b6e1e539e236bfa3f62f5b1bfb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a6f4ff8f34612b6e1e539e236bfa3f62f5b1bfb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9599d79a3b741b7c42353dc45eab6f1c461891f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9599d79a3b741b7c42353dc45eab6f1c461891f", "html_url": "https://github.com/rust-lang/rust/commit/c9599d79a3b741b7c42353dc45eab6f1c461891f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9599d79a3b741b7c42353dc45eab6f1c461891f/comments", "author": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "committer": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4996e17b1450fb837ee72db739266187c486c03d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4996e17b1450fb837ee72db739266187c486c03d", "html_url": "https://github.com/rust-lang/rust/commit/4996e17b1450fb837ee72db739266187c486c03d"}], "stats": {"total": 957, "additions": 908, "deletions": 49}, "files": [{"sha": "f6a883311c91ba32930dc27edc0ee0760397b420", "filename": "CHANGELOG.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9599d79a3b741b7c42353dc45eab6f1c461891f/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/c9599d79a3b741b7c42353dc45eab6f1c461891f/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=c9599d79a3b741b7c42353dc45eab6f1c461891f", "patch": "@@ -2736,6 +2736,7 @@ Released 2018-09-13\n [`for_loops_over_fallibles`]: https://rust-lang.github.io/rust-clippy/master/index.html#for_loops_over_fallibles\n [`forget_copy`]: https://rust-lang.github.io/rust-clippy/master/index.html#forget_copy\n [`forget_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#forget_ref\n+[`format_in_format_args`]: https://rust-lang.github.io/rust-clippy/master/index.html#format_in_format_args\n [`from_iter_instead_of_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#from_iter_instead_of_collect\n [`from_over_into`]: https://rust-lang.github.io/rust-clippy/master/index.html#from_over_into\n [`from_str_radix_10`]: https://rust-lang.github.io/rust-clippy/master/index.html#from_str_radix_10\n@@ -3015,6 +3016,7 @@ Released 2018-09-13\n [`temporary_assignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#temporary_assignment\n [`to_digit_is_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_digit_is_some\n [`to_string_in_display`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_string_in_display\n+[`to_string_in_format_args`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_string_in_format_args\n [`todo`]: https://rust-lang.github.io/rust-clippy/master/index.html#todo\n [`too_many_arguments`]: https://rust-lang.github.io/rust-clippy/master/index.html#too_many_arguments\n [`too_many_lines`]: https://rust-lang.github.io/rust-clippy/master/index.html#too_many_lines"}, {"sha": "472db6f5731dbd34dabd1f4e722b64bca62237a2", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 3, "deletions": 48, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c9599d79a3b741b7c42353dc45eab6f1c461891f/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9599d79a3b741b7c42353dc45eab6f1c461891f/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=c9599d79a3b741b7c42353dc45eab6f1c461891f", "patch": "@@ -1,11 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher::FormatExpn;\n-use clippy_utils::last_path_segment;\n use clippy_utils::source::{snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{BorrowKind, Expr, ExprKind, QPath};\n+use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -69,8 +68,8 @@ impl<'tcx> LateLintPass<'tcx> for UselessFormat {\n                     ty::Str => true,\n                     _ => false,\n                 };\n-                if format_args.args.iter().all(is_display_arg);\n-                if format_args.fmt_expr.map_or(true, check_unformatted);\n+                if let Some(args) = format_args.args();\n+                if args.iter().all(|arg| arg.is_display() && !arg.has_string_formatting());\n                 then {\n                     let is_new_string = match value.kind {\n                         ExprKind::Binary(..) => true,\n@@ -106,47 +105,3 @@ fn span_useless_format(cx: &LateContext<'_>, span: Span, mut sugg: String, mut a\n         applicability,\n     );\n }\n-\n-fn is_display_arg(expr: &Expr<'_>) -> bool {\n-    if_chain! {\n-        if let ExprKind::Call(_, [_, fmt]) = expr.kind;\n-        if let ExprKind::Path(QPath::Resolved(_, path)) = fmt.kind;\n-        if let [.., t, _] = path.segments;\n-        if t.ident.name == sym::Display;\n-        then { true } else { false }\n-    }\n-}\n-\n-/// Checks if the expression matches\n-/// ```rust,ignore\n-/// &[_ {\n-///    format: _ {\n-///         width: _::Implied,\n-///         precision: _::Implied,\n-///         ...\n-///    },\n-///    ...,\n-/// }]\n-/// ```\n-fn check_unformatted(expr: &Expr<'_>) -> bool {\n-    if_chain! {\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, expr) = expr.kind;\n-        if let ExprKind::Array([expr]) = expr.kind;\n-        // struct `core::fmt::rt::v1::Argument`\n-        if let ExprKind::Struct(_, fields, _) = expr.kind;\n-        if let Some(format_field) = fields.iter().find(|f| f.ident.name == sym::format);\n-        // struct `core::fmt::rt::v1::FormatSpec`\n-        if let ExprKind::Struct(_, fields, _) = format_field.expr.kind;\n-        if let Some(precision_field) = fields.iter().find(|f| f.ident.name == sym::precision);\n-        if let ExprKind::Path(ref precision_path) = precision_field.expr.kind;\n-        if last_path_segment(precision_path).ident.name == sym::Implied;\n-        if let Some(width_field) = fields.iter().find(|f| f.ident.name == sym::width);\n-        if let ExprKind::Path(ref width_qpath) = width_field.expr.kind;\n-        if last_path_segment(width_qpath).ident.name == sym::Implied;\n-        then {\n-            return true;\n-        }\n-    }\n-\n-    false\n-}"}, {"sha": "8b27442aa94656453060d0f80f558ae972b7a69e", "filename": "clippy_lints/src/format_args.rs", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/c9599d79a3b741b7c42353dc45eab6f1c461891f/clippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9599d79a3b741b7c42353dc45eab6f1c461891f/clippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_args.rs?ref=c9599d79a3b741b7c42353dc45eab6f1c461891f", "patch": "@@ -0,0 +1,223 @@\n+use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n+use clippy_utils::higher::{FormatArgsArg, FormatArgsExpn, FormatExpn};\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::ty::implements_trait;\n+use clippy_utils::{is_diag_trait_item, match_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n+use rustc_middle::ty::Ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{sym, BytePos, ExpnData, ExpnKind, Span, Symbol};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Detects `format!` within the arguments of another macro that does\n+    /// formatting such as `format!` itself, `write!` or `println!`. Suggests\n+    /// inlining the `format!` call.\n+    ///\n+    /// ### Why is this bad?\n+    /// The recommended code is both shorter and avoids a temporary allocation.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # use std::panic::Location;\n+    /// println!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # use std::panic::Location;\n+    /// println!(\"error: something failed at {}\", Location::caller());\n+    /// ```\n+    pub FORMAT_IN_FORMAT_ARGS,\n+    perf,\n+    \"`format!` used in a macro that does formatting\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for [`ToString::to_string`](https://doc.rust-lang.org/std/string/trait.ToString.html#tymethod.to_string)\n+    /// applied to a type that implements [`Display`](https://doc.rust-lang.org/std/fmt/trait.Display.html)\n+    /// in a macro that does formatting.\n+    ///\n+    /// ### Why is this bad?\n+    /// Since the type implements `Display`, the use of `to_string` is\n+    /// unnecessary.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # use std::panic::Location;\n+    /// println!(\"error: something failed at {}\", Location::caller().to_string());\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # use std::panic::Location;\n+    /// println!(\"error: something failed at {}\", Location::caller());\n+    /// ```\n+    pub TO_STRING_IN_FORMAT_ARGS,\n+    perf,\n+    \"`to_string` applied to a type that implements `Display` in format args\"\n+}\n+\n+declare_lint_pass!(FormatArgs => [FORMAT_IN_FORMAT_ARGS, TO_STRING_IN_FORMAT_ARGS]);\n+\n+const FORMAT_MACRO_PATHS: &[&[&str]] = &[\n+    &paths::FORMAT_ARGS_MACRO,\n+    &paths::ASSERT_EQ_MACRO,\n+    &paths::ASSERT_MACRO,\n+    &paths::ASSERT_NE_MACRO,\n+    &paths::EPRINT_MACRO,\n+    &paths::EPRINTLN_MACRO,\n+    &paths::PRINT_MACRO,\n+    &paths::PRINTLN_MACRO,\n+    &paths::WRITE_MACRO,\n+    &paths::WRITELN_MACRO,\n+];\n+\n+const FORMAT_MACRO_DIAG_ITEMS: &[Symbol] = &[sym::format_macro, sym::std_panic_macro];\n+\n+impl<'tcx> LateLintPass<'tcx> for FormatArgs {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n+        if_chain! {\n+            if let Some(format_args) = FormatArgsExpn::parse(expr);\n+            let expr_expn_data = expr.span.ctxt().outer_expn_data();\n+            let outermost_expn_data = outermost_expn_data(expr_expn_data);\n+            if let Some(macro_def_id) = outermost_expn_data.macro_def_id;\n+            if FORMAT_MACRO_PATHS\n+                .iter()\n+                .any(|path| match_def_path(cx, macro_def_id, path))\n+                || FORMAT_MACRO_DIAG_ITEMS\n+                    .iter()\n+                    .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, macro_def_id));\n+            if let ExpnKind::Macro(_, name) = outermost_expn_data.kind;\n+            if let Some(args) = format_args.args();\n+            then {\n+                for (i, arg) in args.iter().enumerate() {\n+                    if !arg.is_display() {\n+                        continue;\n+                    }\n+                    if arg.has_string_formatting() {\n+                        continue;\n+                    }\n+                    if is_aliased(&args, i) {\n+                        continue;\n+                    }\n+                    check_format_in_format_args(cx, outermost_expn_data.call_site, name, arg);\n+                    check_to_string_in_format_args(cx, name, arg);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn outermost_expn_data(expn_data: ExpnData) -> ExpnData {\n+    if expn_data.call_site.from_expansion() {\n+        outermost_expn_data(expn_data.call_site.ctxt().outer_expn_data())\n+    } else {\n+        expn_data\n+    }\n+}\n+\n+fn check_format_in_format_args(cx: &LateContext<'_>, call_site: Span, name: Symbol, arg: &FormatArgsArg<'_>) {\n+    if_chain! {\n+        if FormatExpn::parse(arg.value).is_some();\n+        if !arg.value.span.ctxt().outer_expn_data().call_site.from_expansion();\n+        then {\n+            span_lint_and_then(\n+                cx,\n+                FORMAT_IN_FORMAT_ARGS,\n+                trim_semicolon(cx, call_site),\n+                &format!(\"`format!` in `{}!` args\", name),\n+                |diag| {\n+                    diag.help(&format!(\n+                        \"combine the `format!(..)` arguments with the outer `{}!(..)` call\",\n+                        name\n+                    ));\n+                    diag.help(\"or consider changing `format!` to `format_args!`\");\n+                },\n+            );\n+        }\n+    }\n+}\n+\n+fn check_to_string_in_format_args<'tcx>(cx: &LateContext<'tcx>, name: Symbol, arg: &FormatArgsArg<'tcx>) {\n+    let value = arg.value;\n+    if_chain! {\n+        if !value.span.from_expansion();\n+        if let ExprKind::MethodCall(_, _, [receiver], _) = value.kind;\n+        if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(value.hir_id);\n+        if is_diag_trait_item(cx, method_def_id, sym::ToString);\n+        let receiver_ty = cx.typeck_results().expr_ty(receiver);\n+        if let Some(display_trait_id) = cx.tcx.get_diagnostic_item(sym::Display);\n+        if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n+        then {\n+            let (n_needed_derefs, target) = count_needed_derefs(\n+                receiver_ty,\n+                cx.typeck_results().expr_adjustments(receiver).iter(),\n+            );\n+            if implements_trait(cx, target, display_trait_id, &[]) {\n+                if n_needed_derefs == 0 {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        TO_STRING_IN_FORMAT_ARGS,\n+                        value.span.with_lo(receiver.span.hi()),\n+                        &format!(\"`to_string` applied to a type that implements `Display` in `{}!` args\", name),\n+                        \"remove this\",\n+                        String::new(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        TO_STRING_IN_FORMAT_ARGS,\n+                        value.span,\n+                        &format!(\"`to_string` applied to a type that implements `Display` in `{}!` args\", name),\n+                        \"use this\",\n+                        format!(\"{:*>width$}{}\", \"\", receiver_snippet, width = n_needed_derefs),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// Returns true if `args[i]` \"refers to\" or \"is referred to by\" another argument.\n+fn is_aliased(args: &[FormatArgsArg<'_>], i: usize) -> bool {\n+    let value = args[i].value;\n+    args.iter()\n+        .enumerate()\n+        .any(|(j, arg)| i != j && std::ptr::eq(value, arg.value))\n+}\n+\n+fn trim_semicolon(cx: &LateContext<'_>, span: Span) -> Span {\n+    snippet_opt(cx, span).map_or(span, |snippet| {\n+        let snippet = snippet.trim_end_matches(';');\n+        span.with_hi(span.lo() + BytePos(u32::try_from(snippet.len()).unwrap()))\n+    })\n+}\n+\n+fn count_needed_derefs<'tcx, I>(mut ty: Ty<'tcx>, mut iter: I) -> (usize, Ty<'tcx>)\n+where\n+    I: Iterator<Item = &'tcx Adjustment<'tcx>>,\n+{\n+    let mut n_total = 0;\n+    let mut n_needed = 0;\n+    loop {\n+        if let Some(Adjustment {\n+            kind: Adjust::Deref(overloaded_deref),\n+            target,\n+        }) = iter.next()\n+        {\n+            n_total += 1;\n+            if overloaded_deref.is_some() {\n+                n_needed = n_total;\n+            }\n+            ty = target;\n+        } else {\n+            return (n_needed, ty);\n+        }\n+    }\n+}"}, {"sha": "4c2dfbd1d8443655468fcd83703511e57b32e874", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9599d79a3b741b7c42353dc45eab6f1c461891f/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9599d79a3b741b7c42353dc45eab6f1c461891f/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=c9599d79a3b741b7c42353dc45eab6f1c461891f", "patch": "@@ -60,6 +60,8 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(float_equality_without_abs::FLOAT_EQUALITY_WITHOUT_ABS),\n     LintId::of(float_literal::EXCESSIVE_PRECISION),\n     LintId::of(format::USELESS_FORMAT),\n+    LintId::of(format_args::FORMAT_IN_FORMAT_ARGS),\n+    LintId::of(format_args::TO_STRING_IN_FORMAT_ARGS),\n     LintId::of(formatting::POSSIBLE_MISSING_COMMA),\n     LintId::of(formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING),\n     LintId::of(formatting::SUSPICIOUS_ELSE_FORMATTING),"}, {"sha": "f334f723f6b870101e6c8e64f5d2c2f0adb40d00", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9599d79a3b741b7c42353dc45eab6f1c461891f/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9599d79a3b741b7c42353dc45eab6f1c461891f/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=c9599d79a3b741b7c42353dc45eab6f1c461891f", "patch": "@@ -139,6 +139,8 @@ store.register_lints(&[\n     floating_point_arithmetic::IMPRECISE_FLOPS,\n     floating_point_arithmetic::SUBOPTIMAL_FLOPS,\n     format::USELESS_FORMAT,\n+    format_args::FORMAT_IN_FORMAT_ARGS,\n+    format_args::TO_STRING_IN_FORMAT_ARGS,\n     formatting::POSSIBLE_MISSING_COMMA,\n     formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING,\n     formatting::SUSPICIOUS_ELSE_FORMATTING,"}, {"sha": "a0d5cf9418e0b32f7244fbd48759acb925e9997f", "filename": "clippy_lints/src/lib.register_perf.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9599d79a3b741b7c42353dc45eab6f1c461891f/clippy_lints%2Fsrc%2Flib.register_perf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9599d79a3b741b7c42353dc45eab6f1c461891f/clippy_lints%2Fsrc%2Flib.register_perf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_perf.rs?ref=c9599d79a3b741b7c42353dc45eab6f1c461891f", "patch": "@@ -5,6 +5,8 @@\n store.register_group(true, \"clippy::perf\", Some(\"clippy_perf\"), vec![\n     LintId::of(entry::MAP_ENTRY),\n     LintId::of(escape::BOXED_LOCAL),\n+    LintId::of(format_args::FORMAT_IN_FORMAT_ARGS),\n+    LintId::of(format_args::TO_STRING_IN_FORMAT_ARGS),\n     LintId::of(large_const_arrays::LARGE_CONST_ARRAYS),\n     LintId::of(large_enum_variant::LARGE_ENUM_VARIANT),\n     LintId::of(loops::MANUAL_MEMCPY),"}, {"sha": "9794d74e19871ca8266688e3f5570c7b82169123", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9599d79a3b741b7c42353dc45eab6f1c461891f/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9599d79a3b741b7c42353dc45eab6f1c461891f/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=c9599d79a3b741b7c42353dc45eab6f1c461891f", "patch": "@@ -218,6 +218,7 @@ mod float_equality_without_abs;\n mod float_literal;\n mod floating_point_arithmetic;\n mod format;\n+mod format_args;\n mod formatting;\n mod from_over_into;\n mod from_str_radix_10;\n@@ -775,6 +776,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(non_send_fields_in_send_ty::NonSendFieldInSendTy::new(enable_raw_pointer_heuristic_for_send)));\n     store.register_late_pass(move || Box::new(undocumented_unsafe_blocks::UndocumentedUnsafeBlocks::default()));\n     store.register_late_pass(|| Box::new(match_str_case_mismatch::MatchStrCaseMismatch));\n+    store.register_late_pass(move || Box::new(format_args::FormatArgs));\n }\n \n #[rustfmt::skip]"}, {"sha": "fb4d53e2845d10ca7ca398b89112c93f1bc9a697", "filename": "clippy_utils/src/higher.rs", "status": "modified", "additions": 101, "deletions": 1, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/c9599d79a3b741b7c42353dc45eab6f1c461891f/clippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9599d79a3b741b7c42353dc45eab6f1c461891f/clippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhigher.rs?ref=c9599d79a3b741b7c42353dc45eab6f1c461891f", "patch": "@@ -3,7 +3,7 @@\n #![deny(clippy::missing_docs_in_private_items)]\n \n use crate::ty::is_type_diagnostic_item;\n-use crate::{is_expn_of, match_def_path, paths};\n+use crate::{is_expn_of, last_path_segment, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::{self, LitKind};\n use rustc_hir as hir;\n@@ -572,6 +572,106 @@ impl FormatArgsExpn<'tcx> {\n             }\n         }\n     }\n+\n+    /// Returns a vector of `FormatArgsArg`.\n+    pub fn args(&self) -> Option<Vec<FormatArgsArg<'tcx>>> {\n+        if let Some(expr) = self.fmt_expr {\n+            if_chain! {\n+                if let ExprKind::AddrOf(BorrowKind::Ref, _, expr) = expr.kind;\n+                if let ExprKind::Array(exprs) = expr.kind;\n+                then {\n+                    exprs.iter().map(|fmt| {\n+                        if_chain! {\n+                            // struct `core::fmt::rt::v1::Argument`\n+                            if let ExprKind::Struct(_, fields, _) = fmt.kind;\n+                            if let Some(position_field) = fields.iter().find(|f| f.ident.name == sym::position);\n+                            if let ExprKind::Lit(lit) = &position_field.expr.kind;\n+                            if let LitKind::Int(position, _) = lit.node;\n+                            then {\n+                                let i = usize::try_from(position).unwrap();\n+                                Some(FormatArgsArg { value: self.value_args[i], arg: &self.args[i], fmt: Some(fmt) })\n+                            } else {\n+                                None\n+                            }\n+                        }\n+                    }).collect()\n+                } else {\n+                    None\n+                }\n+            }\n+        } else {\n+            Some(\n+                self.value_args\n+                    .iter()\n+                    .zip(self.args.iter())\n+                    .map(|(value, arg)| FormatArgsArg { value, arg, fmt: None })\n+                    .collect(),\n+            )\n+        }\n+    }\n+}\n+\n+/// Type representing a `FormatArgsExpn`'s format arguments\n+pub struct FormatArgsArg<'tcx> {\n+    /// An element of `value_args` according to `position`\n+    pub value: &'tcx Expr<'tcx>,\n+    /// An element of `args` according to `position`\n+    pub arg: &'tcx Expr<'tcx>,\n+    /// An element of `fmt_expn`\n+    pub fmt: Option<&'tcx Expr<'tcx>>,\n+}\n+\n+impl<'tcx> FormatArgsArg<'tcx> {\n+    /// Returns true if any formatting parameters are used that would have an effect on strings,\n+    /// like `{:+2}` instead of just `{}`.\n+    pub fn has_string_formatting(&self) -> bool {\n+        self.fmt.map_or(false, |fmt| {\n+            // `!` because these conditions check that `self` is unformatted.\n+            !if_chain! {\n+                // struct `core::fmt::rt::v1::Argument`\n+                if let ExprKind::Struct(_, fields, _) = fmt.kind;\n+                if let Some(format_field) = fields.iter().find(|f| f.ident.name == sym::format);\n+                // struct `core::fmt::rt::v1::FormatSpec`\n+                if let ExprKind::Struct(_, subfields, _) = format_field.expr.kind;\n+                let mut precision_found = false;\n+                let mut width_found = false;\n+                if subfields.iter().all(|field| {\n+                    match field.ident.name {\n+                        sym::precision => {\n+                            precision_found = true;\n+                            if let ExprKind::Path(ref precision_path) = field.expr.kind {\n+                                last_path_segment(precision_path).ident.name == sym::Implied\n+                            } else {\n+                                false\n+                            }\n+                        }\n+                        sym::width => {\n+                            width_found = true;\n+                            if let ExprKind::Path(ref width_qpath) = field.expr.kind {\n+                                last_path_segment(width_qpath).ident.name == sym::Implied\n+                            } else {\n+                                false\n+                            }\n+                        }\n+                        _ => true,\n+                    }\n+                });\n+                if precision_found && width_found;\n+                then { true } else { false }\n+            }\n+        })\n+    }\n+\n+    /// Returns true if the argument is formatted using `Display::fmt`.\n+    pub fn is_display(&self) -> bool {\n+        if_chain! {\n+            if let ExprKind::Call(_, [_, format_field]) = self.arg.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, path)) = format_field.kind;\n+            if let [.., t, _] = path.segments;\n+            if t.ident.name == sym::Display;\n+            then { true } else { false }\n+        }\n+    }\n }\n \n /// Checks if a `let` statement is from a `for` loop desugaring."}, {"sha": "7c61288f661045f0013a478ca51dffc62776068d", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c9599d79a3b741b7c42353dc45eab6f1c461891f/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9599d79a3b741b7c42353dc45eab6f1c461891f/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=c9599d79a3b741b7c42353dc45eab6f1c461891f", "patch": "@@ -17,6 +17,12 @@ pub const APPLICABILITY_VALUES: [[&str; 3]; 4] = [\n #[cfg(feature = \"metadata-collector-lint\")]\n pub const DIAGNOSTIC_BUILDER: [&str; 3] = [\"rustc_errors\", \"diagnostic_builder\", \"DiagnosticBuilder\"];\n pub const ARC_PTR_EQ: [&str; 4] = [\"alloc\", \"sync\", \"Arc\", \"ptr_eq\"];\n+#[allow(clippy::invalid_paths)] // `check_path` does not seem to work for macros\n+pub const ASSERT_EQ_MACRO: [&str; 3] = [\"core\", \"macros\", \"assert_eq\"];\n+#[allow(clippy::invalid_paths)] // `check_path` does not seem to work for macros\n+pub const ASSERT_MACRO: [&str; 4] = [\"core\", \"macros\", \"builtin\", \"assert\"];\n+#[allow(clippy::invalid_paths)] // `check_path` does not seem to work for macros\n+pub const ASSERT_NE_MACRO: [&str; 3] = [\"core\", \"macros\", \"assert_ne\"];\n pub const ASMUT_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsMut\"];\n pub const ASREF_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsRef\"];\n pub(super) const BEGIN_PANIC: [&str; 3] = [\"std\", \"panicking\", \"begin_panic\"];\n@@ -42,11 +48,17 @@ pub const DROP: [&str; 3] = [\"core\", \"mem\", \"drop\"];\n pub const DURATION: [&str; 3] = [\"core\", \"time\", \"Duration\"];\n #[cfg(feature = \"internal-lints\")]\n pub const EARLY_CONTEXT: [&str; 2] = [\"rustc_lint\", \"EarlyContext\"];\n+#[allow(clippy::invalid_paths)] // `check_path` does not seem to work for macros\n+pub const EPRINT_MACRO: [&str; 3] = [\"std\", \"macros\", \"eprint\"];\n+#[allow(clippy::invalid_paths)] // `check_path` does not seem to work for macros\n+pub const EPRINTLN_MACRO: [&str; 3] = [\"std\", \"macros\", \"eprintln\"];\n pub const EXIT: [&str; 3] = [\"std\", \"process\", \"exit\"];\n pub const F32_EPSILON: [&str; 4] = [\"core\", \"f32\", \"<impl f32>\", \"EPSILON\"];\n pub const F64_EPSILON: [&str; 4] = [\"core\", \"f64\", \"<impl f64>\", \"EPSILON\"];\n pub const FILE: [&str; 3] = [\"std\", \"fs\", \"File\"];\n pub const FILE_TYPE: [&str; 3] = [\"std\", \"fs\", \"FileType\"];\n+#[allow(clippy::invalid_paths)] // `check_path` does not seem to work for macros\n+pub const FORMAT_ARGS_MACRO: [&str; 4] = [\"core\", \"macros\", \"builtin\", \"format_args\"];\n pub const FROM_FROM: [&str; 4] = [\"core\", \"convert\", \"From\", \"from\"];\n pub const FROM_ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"collect\", \"FromIterator\"];\n pub const FROM_ITERATOR_METHOD: [&str; 6] = [\"core\", \"iter\", \"traits\", \"collect\", \"FromIterator\", \"from_iter\"];\n@@ -109,6 +121,10 @@ pub const PERMISSIONS_FROM_MODE: [&str; 6] = [\"std\", \"os\", \"unix\", \"fs\", \"Permis\n pub const POLL: [&str; 4] = [\"core\", \"task\", \"poll\", \"Poll\"];\n pub const POLL_PENDING: [&str; 5] = [\"core\", \"task\", \"poll\", \"Poll\", \"Pending\"];\n pub const POLL_READY: [&str; 5] = [\"core\", \"task\", \"poll\", \"Poll\", \"Ready\"];\n+#[allow(clippy::invalid_paths)] // `check_path` does not seem to work for macros\n+pub const PRINT_MACRO: [&str; 3] = [\"std\", \"macros\", \"print\"];\n+#[allow(clippy::invalid_paths)] // `check_path` does not seem to work for macros\n+pub const PRINTLN_MACRO: [&str; 3] = [\"std\", \"macros\", \"println\"];\n pub const PTR_COPY: [&str; 3] = [\"core\", \"intrinsics\", \"copy\"];\n pub const PTR_COPY_NONOVERLAPPING: [&str; 3] = [\"core\", \"intrinsics\", \"copy_nonoverlapping\"];\n pub const PTR_EQ: [&str; 3] = [\"core\", \"ptr\", \"eq\"];\n@@ -185,3 +201,7 @@ pub const VEC_NEW: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"new\"];\n pub const VEC_RESIZE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"resize\"];\n pub const WEAK_ARC: [&str; 3] = [\"alloc\", \"sync\", \"Weak\"];\n pub const WEAK_RC: [&str; 3] = [\"alloc\", \"rc\", \"Weak\"];\n+#[allow(clippy::invalid_paths)] // `check_path` does not seem to work for macros\n+pub const WRITE_MACRO: [&str; 3] = [\"core\", \"macros\", \"write\"];\n+#[allow(clippy::invalid_paths)] // `check_path` does not seem to work for macros\n+pub const WRITELN_MACRO: [&str; 3] = [\"core\", \"macros\", \"writeln\"];"}, {"sha": "8376566c4d62d57fcfa1c51198500c4ac517e904", "filename": "tests/ui/format_args.fixed", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/c9599d79a3b741b7c42353dc45eab6f1c461891f/tests%2Fui%2Fformat_args.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c9599d79a3b741b7c42353dc45eab6f1c461891f/tests%2Fui%2Fformat_args.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat_args.fixed?ref=c9599d79a3b741b7c42353dc45eab6f1c461891f", "patch": "@@ -0,0 +1,105 @@\n+// run-rustfix\n+\n+#![allow(unreachable_code)]\n+#![allow(unused_macros)]\n+#![allow(unused_variables)]\n+#![allow(clippy::assertions_on_constants)]\n+#![allow(clippy::eq_op)]\n+#![warn(clippy::to_string_in_format_args)]\n+\n+use std::io::{stdout, Write};\n+use std::ops::Deref;\n+use std::panic::Location;\n+\n+struct Somewhere;\n+\n+impl ToString for Somewhere {\n+    fn to_string(&self) -> String {\n+        String::from(\"somewhere\")\n+    }\n+}\n+\n+struct X(u32);\n+\n+impl Deref for X {\n+    type Target = u32;\n+\n+    fn deref(&self) -> &u32 {\n+        &self.0\n+    }\n+}\n+\n+struct Y<'a>(&'a X);\n+\n+impl<'a> Deref for Y<'a> {\n+    type Target = &'a X;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+struct Z(u32);\n+\n+impl Deref for Z {\n+    type Target = u32;\n+\n+    fn deref(&self) -> &u32 {\n+        &self.0\n+    }\n+}\n+\n+impl std::fmt::Display for Z {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"Z\")\n+    }\n+}\n+\n+macro_rules! my_macro {\n+    () => {\n+        // here be dragons, do not enter (or lint)\n+        println!(\"error: something failed at {}\", Location::caller().to_string());\n+    };\n+}\n+\n+macro_rules! my_other_macro {\n+    () => {\n+        Location::caller().to_string()\n+    };\n+}\n+\n+fn main() {\n+    let x = &X(1);\n+    let x_ref = &x;\n+\n+    let _ = format!(\"error: something failed at {}\", Location::caller());\n+    let _ = write!(\n+        stdout(),\n+        \"error: something failed at {}\",\n+        Location::caller()\n+    );\n+    let _ = writeln!(\n+        stdout(),\n+        \"error: something failed at {}\",\n+        Location::caller()\n+    );\n+    print!(\"error: something failed at {}\", Location::caller());\n+    println!(\"error: something failed at {}\", Location::caller());\n+    eprint!(\"error: something failed at {}\", Location::caller());\n+    eprintln!(\"error: something failed at {}\", Location::caller());\n+    let _ = format_args!(\"error: something failed at {}\", Location::caller());\n+    assert!(true, \"error: something failed at {}\", Location::caller());\n+    assert_eq!(0, 0, \"error: something failed at {}\", Location::caller());\n+    assert_ne!(0, 0, \"error: something failed at {}\", Location::caller());\n+    panic!(\"error: something failed at {}\", Location::caller());\n+    println!(\"{}\", *X(1));\n+    println!(\"{}\", ***Y(&X(1)));\n+    println!(\"{}\", Z(1));\n+    println!(\"{}\", **x);\n+    println!(\"{}\", ***x_ref);\n+\n+    println!(\"error: something failed at {}\", Somewhere.to_string());\n+    println!(\"{} and again {0}\", x.to_string());\n+    my_macro!();\n+    println!(\"error: something failed at {}\", my_other_macro!());\n+}"}, {"sha": "164cc07066dc3b892022b616b34f4130083c12ce", "filename": "tests/ui/format_args.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/c9599d79a3b741b7c42353dc45eab6f1c461891f/tests%2Fui%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9599d79a3b741b7c42353dc45eab6f1c461891f/tests%2Fui%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat_args.rs?ref=c9599d79a3b741b7c42353dc45eab6f1c461891f", "patch": "@@ -0,0 +1,105 @@\n+// run-rustfix\n+\n+#![allow(unreachable_code)]\n+#![allow(unused_macros)]\n+#![allow(unused_variables)]\n+#![allow(clippy::assertions_on_constants)]\n+#![allow(clippy::eq_op)]\n+#![warn(clippy::to_string_in_format_args)]\n+\n+use std::io::{stdout, Write};\n+use std::ops::Deref;\n+use std::panic::Location;\n+\n+struct Somewhere;\n+\n+impl ToString for Somewhere {\n+    fn to_string(&self) -> String {\n+        String::from(\"somewhere\")\n+    }\n+}\n+\n+struct X(u32);\n+\n+impl Deref for X {\n+    type Target = u32;\n+\n+    fn deref(&self) -> &u32 {\n+        &self.0\n+    }\n+}\n+\n+struct Y<'a>(&'a X);\n+\n+impl<'a> Deref for Y<'a> {\n+    type Target = &'a X;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+struct Z(u32);\n+\n+impl Deref for Z {\n+    type Target = u32;\n+\n+    fn deref(&self) -> &u32 {\n+        &self.0\n+    }\n+}\n+\n+impl std::fmt::Display for Z {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"Z\")\n+    }\n+}\n+\n+macro_rules! my_macro {\n+    () => {\n+        // here be dragons, do not enter (or lint)\n+        println!(\"error: something failed at {}\", Location::caller().to_string());\n+    };\n+}\n+\n+macro_rules! my_other_macro {\n+    () => {\n+        Location::caller().to_string()\n+    };\n+}\n+\n+fn main() {\n+    let x = &X(1);\n+    let x_ref = &x;\n+\n+    let _ = format!(\"error: something failed at {}\", Location::caller().to_string());\n+    let _ = write!(\n+        stdout(),\n+        \"error: something failed at {}\",\n+        Location::caller().to_string()\n+    );\n+    let _ = writeln!(\n+        stdout(),\n+        \"error: something failed at {}\",\n+        Location::caller().to_string()\n+    );\n+    print!(\"error: something failed at {}\", Location::caller().to_string());\n+    println!(\"error: something failed at {}\", Location::caller().to_string());\n+    eprint!(\"error: something failed at {}\", Location::caller().to_string());\n+    eprintln!(\"error: something failed at {}\", Location::caller().to_string());\n+    let _ = format_args!(\"error: something failed at {}\", Location::caller().to_string());\n+    assert!(true, \"error: something failed at {}\", Location::caller().to_string());\n+    assert_eq!(0, 0, \"error: something failed at {}\", Location::caller().to_string());\n+    assert_ne!(0, 0, \"error: something failed at {}\", Location::caller().to_string());\n+    panic!(\"error: something failed at {}\", Location::caller().to_string());\n+    println!(\"{}\", X(1).to_string());\n+    println!(\"{}\", Y(&X(1)).to_string());\n+    println!(\"{}\", Z(1).to_string());\n+    println!(\"{}\", x.to_string());\n+    println!(\"{}\", x_ref.to_string());\n+\n+    println!(\"error: something failed at {}\", Somewhere.to_string());\n+    println!(\"{} and again {0}\", x.to_string());\n+    my_macro!();\n+    println!(\"error: something failed at {}\", my_other_macro!());\n+}"}, {"sha": "9cfc97edeafb8215fabae9014bc1b543840a650c", "filename": "tests/ui/format_args.stderr", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/c9599d79a3b741b7c42353dc45eab6f1c461891f/tests%2Fui%2Fformat_args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9599d79a3b741b7c42353dc45eab6f1c461891f/tests%2Fui%2Fformat_args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat_args.stderr?ref=c9599d79a3b741b7c42353dc45eab6f1c461891f", "patch": "@@ -0,0 +1,106 @@\n+error: `to_string` applied to a type that implements `Display` in `format!` args\n+  --> $DIR/format_args.rs:75:72\n+   |\n+LL |     let _ = format!(\"error: something failed at {}\", Location::caller().to_string());\n+   |                                                                        ^^^^^^^^^^^^ help: remove this\n+   |\n+   = note: `-D clippy::to-string-in-format-args` implied by `-D warnings`\n+\n+error: `to_string` applied to a type that implements `Display` in `write!` args\n+  --> $DIR/format_args.rs:79:27\n+   |\n+LL |         Location::caller().to_string()\n+   |                           ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `writeln!` args\n+  --> $DIR/format_args.rs:84:27\n+   |\n+LL |         Location::caller().to_string()\n+   |                           ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `print!` args\n+  --> $DIR/format_args.rs:86:63\n+   |\n+LL |     print!(\"error: something failed at {}\", Location::caller().to_string());\n+   |                                                               ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `println!` args\n+  --> $DIR/format_args.rs:87:65\n+   |\n+LL |     println!(\"error: something failed at {}\", Location::caller().to_string());\n+   |                                                                 ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `eprint!` args\n+  --> $DIR/format_args.rs:88:64\n+   |\n+LL |     eprint!(\"error: something failed at {}\", Location::caller().to_string());\n+   |                                                                ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `eprintln!` args\n+  --> $DIR/format_args.rs:89:66\n+   |\n+LL |     eprintln!(\"error: something failed at {}\", Location::caller().to_string());\n+   |                                                                  ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `format_args!` args\n+  --> $DIR/format_args.rs:90:77\n+   |\n+LL |     let _ = format_args!(\"error: something failed at {}\", Location::caller().to_string());\n+   |                                                                             ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `assert!` args\n+  --> $DIR/format_args.rs:91:70\n+   |\n+LL |     assert!(true, \"error: something failed at {}\", Location::caller().to_string());\n+   |                                                                      ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `assert_eq!` args\n+  --> $DIR/format_args.rs:92:73\n+   |\n+LL |     assert_eq!(0, 0, \"error: something failed at {}\", Location::caller().to_string());\n+   |                                                                         ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `assert_ne!` args\n+  --> $DIR/format_args.rs:93:73\n+   |\n+LL |     assert_ne!(0, 0, \"error: something failed at {}\", Location::caller().to_string());\n+   |                                                                         ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `panic!` args\n+  --> $DIR/format_args.rs:94:63\n+   |\n+LL |     panic!(\"error: something failed at {}\", Location::caller().to_string());\n+   |                                                               ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `println!` args\n+  --> $DIR/format_args.rs:95:20\n+   |\n+LL |     println!(\"{}\", X(1).to_string());\n+   |                    ^^^^^^^^^^^^^^^^ help: use this: `*X(1)`\n+\n+error: `to_string` applied to a type that implements `Display` in `println!` args\n+  --> $DIR/format_args.rs:96:20\n+   |\n+LL |     println!(\"{}\", Y(&X(1)).to_string());\n+   |                    ^^^^^^^^^^^^^^^^^^^^ help: use this: `***Y(&X(1))`\n+\n+error: `to_string` applied to a type that implements `Display` in `println!` args\n+  --> $DIR/format_args.rs:97:24\n+   |\n+LL |     println!(\"{}\", Z(1).to_string());\n+   |                        ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `println!` args\n+  --> $DIR/format_args.rs:98:20\n+   |\n+LL |     println!(\"{}\", x.to_string());\n+   |                    ^^^^^^^^^^^^^ help: use this: `**x`\n+\n+error: `to_string` applied to a type that implements `Display` in `println!` args\n+  --> $DIR/format_args.rs:99:20\n+   |\n+LL |     println!(\"{}\", x_ref.to_string());\n+   |                    ^^^^^^^^^^^^^^^^^ help: use this: `***x_ref`\n+\n+error: aborting due to 17 previous errors\n+"}, {"sha": "a8c06c2bde6645e418bd8d3f76599e24be4d9c2e", "filename": "tests/ui/format_args_unfixable.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c9599d79a3b741b7c42353dc45eab6f1c461891f/tests%2Fui%2Fformat_args_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9599d79a3b741b7c42353dc45eab6f1c461891f/tests%2Fui%2Fformat_args_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat_args_unfixable.rs?ref=c9599d79a3b741b7c42353dc45eab6f1c461891f", "patch": "@@ -0,0 +1,60 @@\n+#![allow(clippy::assertions_on_constants)]\n+#![allow(clippy::eq_op)]\n+#![warn(clippy::format_in_format_args)]\n+#![warn(clippy::to_string_in_format_args)]\n+\n+use std::io::{stdout, Error, ErrorKind, Write};\n+use std::ops::Deref;\n+use std::panic::Location;\n+\n+macro_rules! my_macro {\n+    () => {\n+        // here be dragons, do not enter (or lint)\n+        println!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    };\n+}\n+\n+macro_rules! my_other_macro {\n+    () => {\n+        format!(\"something failed at {}\", Location::caller())\n+    };\n+}\n+\n+fn main() {\n+    let error = Error::new(ErrorKind::Other, \"bad thing\");\n+    let x = 'x';\n+\n+    println!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    println!(\"{}: {}\", error, format!(\"something failed at {}\", Location::caller()));\n+    println!(\"{:?}: {}\", error, format!(\"something failed at {}\", Location::caller()));\n+    println!(\"{{}}: {}\", format!(\"something failed at {}\", Location::caller()));\n+    println!(r#\"error: \"{}\"\"#, format!(\"something failed at {}\", Location::caller()));\n+    println!(\"error: {}\", format!(r#\"something failed at \"{}\"\"#, Location::caller()));\n+    println!(\"error: {}\", format!(\"something failed at {} {0}\", Location::caller()));\n+    let _ = format!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    let _ = write!(\n+        stdout(),\n+        \"error: {}\",\n+        format!(\"something failed at {}\", Location::caller())\n+    );\n+    let _ = writeln!(\n+        stdout(),\n+        \"error: {}\",\n+        format!(\"something failed at {}\", Location::caller())\n+    );\n+    print!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    eprint!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    eprintln!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    let _ = format_args!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    assert!(true, \"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    assert_eq!(0, 0, \"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    assert_ne!(0, 0, \"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    panic!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+\n+    println!(\"error: {}\", format_args!(\"something failed at {}\", Location::caller()));\n+    println!(\"error: {:>70}\", format!(\"something failed at {}\", Location::caller()));\n+    println!(\"error: {} {0}\", format!(\"something failed at {}\", Location::caller()));\n+    println!(\"{} and again {0}\", format!(\"hi {}\", x));\n+    my_macro!();\n+    println!(\"error: {}\", my_other_macro!());\n+}"}, {"sha": "4476218ad58e91a3d0a4e0b5c7a23b5d1c0e43b4", "filename": "tests/ui/format_args_unfixable.stderr", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/c9599d79a3b741b7c42353dc45eab6f1c461891f/tests%2Fui%2Fformat_args_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9599d79a3b741b7c42353dc45eab6f1c461891f/tests%2Fui%2Fformat_args_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat_args_unfixable.stderr?ref=c9599d79a3b741b7c42353dc45eab6f1c461891f", "patch": "@@ -0,0 +1,175 @@\n+error: `format!` in `println!` args\n+  --> $DIR/format_args_unfixable.rs:27:5\n+   |\n+LL |     println!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::format-in-format-args` implied by `-D warnings`\n+   = help: combine the `format!(..)` arguments with the outer `println!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `println!` args\n+  --> $DIR/format_args_unfixable.rs:28:5\n+   |\n+LL |     println!(\"{}: {}\", error, format!(\"something failed at {}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `println!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `println!` args\n+  --> $DIR/format_args_unfixable.rs:29:5\n+   |\n+LL |     println!(\"{:?}: {}\", error, format!(\"something failed at {}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `println!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `println!` args\n+  --> $DIR/format_args_unfixable.rs:30:5\n+   |\n+LL |     println!(\"{{}}: {}\", format!(\"something failed at {}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `println!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `println!` args\n+  --> $DIR/format_args_unfixable.rs:31:5\n+   |\n+LL |     println!(r#\"error: \"{}\"\"#, format!(\"something failed at {}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `println!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `println!` args\n+  --> $DIR/format_args_unfixable.rs:32:5\n+   |\n+LL |     println!(\"error: {}\", format!(r#\"something failed at \"{}\"\"#, Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `println!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `println!` args\n+  --> $DIR/format_args_unfixable.rs:33:5\n+   |\n+LL |     println!(\"error: {}\", format!(\"something failed at {} {0}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `println!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `format!` args\n+  --> $DIR/format_args_unfixable.rs:34:13\n+   |\n+LL |     let _ = format!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `format!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `write!` args\n+  --> $DIR/format_args_unfixable.rs:35:13\n+   |\n+LL |       let _ = write!(\n+   |  _____________^\n+LL | |         stdout(),\n+LL | |         \"error: {}\",\n+LL | |         format!(\"something failed at {}\", Location::caller())\n+LL | |     );\n+   | |_____^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `write!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `writeln!` args\n+  --> $DIR/format_args_unfixable.rs:40:13\n+   |\n+LL |       let _ = writeln!(\n+   |  _____________^\n+LL | |         stdout(),\n+LL | |         \"error: {}\",\n+LL | |         format!(\"something failed at {}\", Location::caller())\n+LL | |     );\n+   | |_____^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `writeln!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `print!` args\n+  --> $DIR/format_args_unfixable.rs:45:5\n+   |\n+LL |     print!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `print!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `eprint!` args\n+  --> $DIR/format_args_unfixable.rs:46:5\n+   |\n+LL |     eprint!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `eprint!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `eprintln!` args\n+  --> $DIR/format_args_unfixable.rs:47:5\n+   |\n+LL |     eprintln!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `eprintln!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `format_args!` args\n+  --> $DIR/format_args_unfixable.rs:48:13\n+   |\n+LL |     let _ = format_args!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `format_args!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `assert!` args\n+  --> $DIR/format_args_unfixable.rs:49:5\n+   |\n+LL |     assert!(true, \"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `assert!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `assert_eq!` args\n+  --> $DIR/format_args_unfixable.rs:50:5\n+   |\n+LL |     assert_eq!(0, 0, \"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `assert_eq!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `assert_ne!` args\n+  --> $DIR/format_args_unfixable.rs:51:5\n+   |\n+LL |     assert_ne!(0, 0, \"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `assert_ne!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `panic!` args\n+  --> $DIR/format_args_unfixable.rs:52:5\n+   |\n+LL |     panic!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `panic!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: aborting due to 18 previous errors\n+"}]}