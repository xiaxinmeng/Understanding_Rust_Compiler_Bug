{"sha": "a248648862cabc05a5fefe320bd9fcaa9a0a8c7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNDg2NDg4NjJjYWJjMDVhNWZlZmUzMjBiZDlmY2FhOWEwYThjN2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-24T16:18:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-24T16:18:19Z"}, "message": "Auto merge of #7267 - camsteffen:sphash-improvements, r=Manishearth\n\nSome SpanlessHash improvements\n\nchangelog: none\n\n* Use `mem::discriminant().hash()` instead of `stable_hash` for simple enums and then use `FxHasher` instead of `StableHasher`. We don't use any StableHash features.\n* Use `UnHashMap` for maps keyed by spanless hash values.", "tree": {"sha": "e26d1a54bf6bea5a5d9ce0f16754bb177f123f6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e26d1a54bf6bea5a5d9ce0f16754bb177f123f6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a248648862cabc05a5fefe320bd9fcaa9a0a8c7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a248648862cabc05a5fefe320bd9fcaa9a0a8c7b", "html_url": "https://github.com/rust-lang/rust/commit/a248648862cabc05a5fefe320bd9fcaa9a0a8c7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a248648862cabc05a5fefe320bd9fcaa9a0a8c7b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c25f4b4434fd269a5a903dea6cc14035551b7274", "url": "https://api.github.com/repos/rust-lang/rust/commits/c25f4b4434fd269a5a903dea6cc14035551b7274", "html_url": "https://github.com/rust-lang/rust/commit/c25f4b4434fd269a5a903dea6cc14035551b7274"}, {"sha": "7f340578cc33e22dfe09927b696a91d0180fe11d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f340578cc33e22dfe09927b696a91d0180fe11d", "html_url": "https://github.com/rust-lang/rust/commit/7f340578cc33e22dfe09927b696a91d0180fe11d"}], "stats": {"total": 123, "additions": 44, "deletions": 79}, "files": [{"sha": "74a94db1800060c0bb3136895e004e709b6b64a1", "filename": "clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a248648862cabc05a5fefe320bd9fcaa9a0a8c7b/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a248648862cabc05a5fefe320bd9fcaa9a0a8c7b/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=a248648862cabc05a5fefe320bd9fcaa9a0a8c7b", "patch": "@@ -3,6 +3,7 @@ use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::{in_macro, SpanlessHash};\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::unhash::UnhashMap;\n use rustc_errors::Applicability;\n use rustc_hir::{def::Res, GenericBound, Generics, ParamName, Path, QPath, TyKind, WherePredicate};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -100,7 +101,7 @@ impl TraitBounds {\n             hasher.hash_ty(ty);\n             hasher.finish()\n         };\n-        let mut map = FxHashMap::default();\n+        let mut map: UnhashMap<u64, Vec<&GenericBound<'_>>> = UnhashMap::default();\n         let mut applicability = Applicability::MaybeIncorrect;\n         for bound in gen.where_clause.predicates {\n             if_chain! {"}, {"sha": "969193d82948698607a978576fbc0707f0196df6", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 35, "deletions": 73, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/a248648862cabc05a5fefe320bd9fcaa9a0a8c7b/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a248648862cabc05a5fefe320bd9fcaa9a0a8c7b/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=a248648862cabc05a5fefe320bd9fcaa9a0a8c7b", "patch": "@@ -2,20 +2,19 @@ use crate::consts::{constant_context, constant_simple};\n use crate::differing_macro_contexts;\n use crate::source::snippet_opt;\n use rustc_ast::ast::InlineAsmTemplatePiece;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::fx::FxHasher;\n use rustc_hir::def::Res;\n use rustc_hir::HirIdMap;\n use rustc_hir::{\n-    BinOpKind, Block, BlockCheckMode, BodyId, BorrowKind, CaptureBy, Expr, ExprField, ExprKind, FnRetTy, GenericArg,\n-    GenericArgs, Guard, HirId, InlineAsmOperand, Lifetime, LifetimeName, ParamName, Pat, PatField, PatKind, Path,\n-    PathSegment, QPath, Stmt, StmtKind, Ty, TyKind, TypeBinding,\n+    BinOpKind, Block, BodyId, Expr, ExprField, ExprKind, FnRetTy, GenericArg, GenericArgs, Guard, HirId,\n+    InlineAsmOperand, Lifetime, LifetimeName, ParamName, Pat, PatField, PatKind, Path, PathSegment, QPath, Stmt,\n+    StmtKind, Ty, TyKind, TypeBinding,\n };\n use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::LateContext;\n-use rustc_middle::ich::StableHashingContextProvider;\n use rustc_middle::ty::TypeckResults;\n use rustc_span::Symbol;\n-use std::hash::Hash;\n+use std::hash::{Hash, Hasher};\n \n /// Type used to check whether two ast are the same. This is different from the\n /// operator\n@@ -169,6 +168,12 @@ impl HirEqInterExpr<'_, '_, '_> {\n         }\n     }\n \n+    pub fn eq_body(&mut self, left: BodyId, right: BodyId) -> bool {\n+        let cx = self.inner.cx;\n+        let eval_const = |body| constant_context(cx, cx.tcx.typeck_body(body)).expr(&cx.tcx.hir().body(body).value);\n+        eval_const(left) == eval_const(right)\n+    }\n+\n     #[allow(clippy::similar_names)]\n     pub fn eq_expr(&mut self, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n         if !self.inner.allow_side_effects && differing_macro_contexts(left.span, right.span) {\n@@ -244,12 +249,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n                 self.inner.allow_side_effects && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprKind::Repeat(le, ref ll_id), &ExprKind::Repeat(re, ref rl_id)) => {\n-                let mut celcx = constant_context(self.inner.cx, self.inner.cx.tcx.typeck_body(ll_id.body));\n-                let ll = celcx.expr(&self.inner.cx.tcx.hir().body(ll_id.body).value);\n-                let mut celcx = constant_context(self.inner.cx, self.inner.cx.tcx.typeck_body(rl_id.body));\n-                let rl = celcx.expr(&self.inner.cx.tcx.hir().body(rl_id.body).value);\n-\n-                self.eq_expr(le, re) && ll == rl\n+                self.eq_expr(le, re) && self.eq_body(ll_id.body, rl_id.body)\n             },\n             (&ExprKind::Ret(ref l), &ExprKind::Ret(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n             (&ExprKind::Path(ref l), &ExprKind::Path(ref r)) => self.eq_qpath(l, r),\n@@ -285,6 +285,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n \n     fn eq_generic_arg(&mut self, left: &GenericArg<'_>, right: &GenericArg<'_>) -> bool {\n         match (left, right) {\n+            (GenericArg::Const(l), GenericArg::Const(r)) => self.eq_body(l.value.body, r.value.body),\n             (GenericArg::Lifetime(l_lt), GenericArg::Lifetime(r_lt)) => Self::eq_lifetime(l_lt, r_lt),\n             (GenericArg::Type(l_ty), GenericArg::Type(r_ty)) => self.eq_ty(l_ty, r_ty),\n             _ => false,\n@@ -385,10 +386,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n         match (&left.kind, &right.kind) {\n             (&TyKind::Slice(l_vec), &TyKind::Slice(r_vec)) => self.eq_ty(l_vec, r_vec),\n             (&TyKind::Array(lt, ref ll_id), &TyKind::Array(rt, ref rl_id)) => {\n-                let cx = self.inner.cx;\n-                let eval_const =\n-                    |body| constant_context(cx, cx.tcx.typeck_body(body)).expr(&cx.tcx.hir().body(body).value);\n-                self.eq_ty(lt, rt) && eval_const(ll_id.body) == eval_const(rl_id.body)\n+                self.eq_ty(lt, rt) && self.eq_body(ll_id.body, rl_id.body)\n             },\n             (&TyKind::Ptr(ref l_mut), &TyKind::Ptr(ref r_mut)) => {\n                 l_mut.mutbl == r_mut.mutbl && self.eq_ty(&*l_mut.ty, &*r_mut.ty)\n@@ -512,15 +510,15 @@ pub struct SpanlessHash<'a, 'tcx> {\n     /// Context used to evaluate constant expressions.\n     cx: &'a LateContext<'tcx>,\n     maybe_typeck_results: Option<&'tcx TypeckResults<'tcx>>,\n-    s: StableHasher,\n+    s: FxHasher,\n }\n \n impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n     pub fn new(cx: &'a LateContext<'tcx>) -> Self {\n         Self {\n             cx,\n             maybe_typeck_results: cx.maybe_typeck_results(),\n-            s: StableHasher::new(),\n+            s: FxHasher::default(),\n         }\n     }\n \n@@ -537,13 +535,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n             self.hash_expr(e);\n         }\n \n-        match b.rules {\n-            BlockCheckMode::DefaultBlock => 0,\n-            BlockCheckMode::UnsafeBlock(_) => 1,\n-            BlockCheckMode::PushUnsafeBlock(_) => 2,\n-            BlockCheckMode::PopUnsafeBlock(_) => 3,\n-        }\n-        .hash(&mut self.s);\n+        std::mem::discriminant(&b.rules).hash(&mut self.s);\n     }\n \n     #[allow(clippy::many_single_char_names, clippy::too_many_lines)]\n@@ -554,21 +546,16 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n \n         // const hashing may result in the same hash as some unrelated node, so add a sort of\n         // discriminant depending on which path we're choosing next\n-        simple_const.is_some().hash(&mut self.s);\n-\n-        if let Some(e) = simple_const {\n-            return e.hash(&mut self.s);\n+        simple_const.hash(&mut self.s);\n+        if simple_const.is_some() {\n+            return;\n         }\n \n         std::mem::discriminant(&e.kind).hash(&mut self.s);\n \n         match e.kind {\n             ExprKind::AddrOf(kind, m, e) => {\n-                match kind {\n-                    BorrowKind::Ref => 0,\n-                    BorrowKind::Raw => 1,\n-                }\n-                .hash(&mut self.s);\n+                std::mem::discriminant(&kind).hash(&mut self.s);\n                 m.hash(&mut self.s);\n                 self.hash_expr(e);\n             },\n@@ -582,17 +569,15 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 self.hash_expr(r);\n             },\n             ExprKind::AssignOp(ref o, l, r) => {\n-                o.node\n-                    .hash_stable(&mut self.cx.tcx.get_stable_hashing_context(), &mut self.s);\n+                std::mem::discriminant(&o.node).hash(&mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n             },\n             ExprKind::Block(b, _) => {\n                 self.hash_block(b);\n             },\n             ExprKind::Binary(op, l, r) => {\n-                op.node\n-                    .hash_stable(&mut self.cx.tcx.get_stable_hashing_context(), &mut self.s);\n+                std::mem::discriminant(&op.node).hash(&mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n             },\n@@ -616,11 +601,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 self.hash_ty(ty);\n             },\n             ExprKind::Closure(cap, _, eid, _, _) => {\n-                match cap {\n-                    CaptureBy::Value => 0,\n-                    CaptureBy::Ref => 1,\n-                }\n-                .hash(&mut self.s);\n+                std::mem::discriminant(&cap).hash(&mut self.s);\n                 // closures inherit TypeckResults\n                 self.hash_expr(&self.cx.tcx.hir().body(eid).value);\n             },\n@@ -694,8 +675,6 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 }\n             },\n             ExprKind::If(cond, then, ref else_opt) => {\n-                let c: fn(_, _, _) -> _ = ExprKind::If;\n-                c.hash(&mut self.s);\n                 self.hash_expr(cond);\n                 self.hash_expr(then);\n                 if let Some(e) = *else_opt {\n@@ -753,7 +732,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 self.hash_exprs(v);\n             },\n             ExprKind::Unary(lop, le) => {\n-                lop.hash_stable(&mut self.cx.tcx.get_stable_hashing_context(), &mut self.s);\n+                std::mem::discriminant(&lop).hash(&mut self.s);\n                 self.hash_expr(le);\n             },\n         }\n@@ -766,7 +745,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n     }\n \n     pub fn hash_name(&mut self, n: Symbol) {\n-        n.as_str().hash(&mut self.s);\n+        n.hash(&mut self.s);\n     }\n \n     pub fn hash_qpath(&mut self, p: &QPath<'_>) {\n@@ -778,7 +757,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 self.hash_name(path.ident.name);\n             },\n             QPath::LangItem(lang_item, ..) => {\n-                lang_item.hash_stable(&mut self.cx.tcx.get_stable_hashing_context(), &mut self.s);\n+                std::mem::discriminant(&lang_item).hash(&mut self.s);\n             },\n         }\n         // self.maybe_typeck_results.unwrap().qpath_res(p, id).hash(&mut self.s);\n@@ -788,7 +767,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n         std::mem::discriminant(&pat.kind).hash(&mut self.s);\n         match pat.kind {\n             PatKind::Binding(ann, _, _, pat) => {\n-                ann.hash_stable(&mut self.cx.tcx.get_stable_hashing_context(), &mut self.s);\n+                std::mem::discriminant(&ann).hash(&mut self.s);\n                 if let Some(pat) = pat {\n                     self.hash_pat(pat);\n                 }\n@@ -808,11 +787,11 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 if let Some(e) = e {\n                     self.hash_expr(e);\n                 }\n-                i.hash_stable(&mut self.cx.tcx.get_stable_hashing_context(), &mut self.s);\n+                std::mem::discriminant(&i).hash(&mut self.s);\n             },\n-            PatKind::Ref(pat, m) => {\n+            PatKind::Ref(pat, mu) => {\n                 self.hash_pat(pat);\n-                m.hash(&mut self.s);\n+                std::mem::discriminant(&mu).hash(&mut self.s);\n             },\n             PatKind::Slice(l, m, r) => {\n                 for pat in l {\n@@ -857,6 +836,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n             _ => {\n                 for seg in path.segments {\n                     self.hash_name(seg.ident.name);\n+                    self.hash_generic_args(seg.args().args);\n                 }\n             },\n         }\n@@ -928,10 +908,9 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 for arg in bfn.decl.inputs {\n                     self.hash_ty(arg);\n                 }\n+                std::mem::discriminant(&bfn.decl.output).hash(&mut self.s);\n                 match bfn.decl.output {\n-                    FnRetTy::DefaultReturn(_) => {\n-                        ().hash(&mut self.s);\n-                    },\n+                    FnRetTy::DefaultReturn(_) => {},\n                     FnRetTy::Return(ty) => {\n                         self.hash_ty(ty);\n                     },\n@@ -943,24 +922,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                     self.hash_ty(ty);\n                 }\n             },\n-            TyKind::Path(ref qpath) => match qpath {\n-                QPath::Resolved(ref maybe_ty, path) => {\n-                    if let Some(ty) = maybe_ty {\n-                        self.hash_ty(ty);\n-                    }\n-                    for segment in path.segments {\n-                        segment.ident.name.hash(&mut self.s);\n-                        self.hash_generic_args(segment.args().args);\n-                    }\n-                },\n-                QPath::TypeRelative(ty, segment) => {\n-                    self.hash_ty(ty);\n-                    segment.ident.name.hash(&mut self.s);\n-                },\n-                QPath::LangItem(lang_item, ..) => {\n-                    lang_item.hash(&mut self.s);\n-                },\n-            },\n+            TyKind::Path(ref qpath) => self.hash_qpath(qpath),\n             TyKind::OpaqueDef(_, arg_list) => {\n                 self.hash_generic_args(arg_list);\n             },"}, {"sha": "39fd324408a7f6c88e2acedc785bf822eba0e8bd", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a248648862cabc05a5fefe320bd9fcaa9a0a8c7b/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a248648862cabc05a5fefe320bd9fcaa9a0a8c7b/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=a248648862cabc05a5fefe320bd9fcaa9a0a8c7b", "patch": "@@ -63,7 +63,7 @@ use std::hash::BuildHasherDefault;\n \n use if_chain::if_chain;\n use rustc_ast::ast::{self, Attribute, BorrowKind, LitKind};\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::unhash::UnhashMap;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n@@ -1572,14 +1572,16 @@ where\n     Hash: Fn(&T) -> u64,\n     Eq: Fn(&T, &T) -> bool,\n {\n-    if exprs.len() == 2 && eq(&exprs[0], &exprs[1]) {\n-        return vec![(&exprs[0], &exprs[1])];\n+    match exprs {\n+        [a, b] if eq(a, b) => return vec![(a, b)],\n+        _ if exprs.len() <= 2 => return vec![],\n+        _ => {},\n     }\n \n     let mut match_expr_list: Vec<(&T, &T)> = Vec::new();\n \n-    let mut map: FxHashMap<_, Vec<&_>> =\n-        FxHashMap::with_capacity_and_hasher(exprs.len(), BuildHasherDefault::default());\n+    let mut map: UnhashMap<u64, Vec<&_>> =\n+        UnhashMap::with_capacity_and_hasher(exprs.len(), BuildHasherDefault::default());\n \n     for expr in exprs {\n         match map.entry(hash(expr)) {"}]}