{"sha": "f5c50e3350baaea9594196a5b7f07ec1db8445bf", "node_id": "C_kwDOAAsO6NoAKGY1YzUwZTMzNTBiYWFlYTk1OTQxOTZhNWI3ZjA3ZWMxZGI4NDQ1YmY", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2023-05-05T03:46:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-05T03:46:27Z"}, "message": "Rollup merge of #111132 - lcnr:nll-generalize, r=b-naber\n\ncleanup nll generalizer\n\nfollowup to #108861", "tree": {"sha": "d3b2ec0441305b284ee667ff0bbdb520eb9c4822", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3b2ec0441305b284ee667ff0bbdb520eb9c4822"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5c50e3350baaea9594196a5b7f07ec1db8445bf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkVHwTCRBK7hj4Ov3rIwAAqQMIACM7epuVbCkxeHXePThoY3Z0\ncAkKFkRiwifyD0ro/+36s9DFpEcfwfUm+1vX5nOyRWr1u+tSQD6AqECFEtzhq8pW\npk5mZ8G14OQ6p5wZgP4N0YdxKVUF6gvsSpYjXp5FBFiSpG0ze4K+tI8hM3UX8dER\n1nNorcvFwd1aixVp8nbBgUOn4jGL/tbaoc1qVXSSvFxwVZ8Htl86xtScEUbYR6Je\n5AqnWqf76BYzhiJajiLW1l0+gn2hCrj0+huwn7QEOWoXIwdxzmVTBJKQUiX1bMfp\n2rJlPwj1VS8AZv3b9DOimA91BpzT23jCQPFm/NyRsYIK7Yh1WTFwtCO12YgbwzM=\n=auTW\n-----END PGP SIGNATURE-----\n", "payload": "tree d3b2ec0441305b284ee667ff0bbdb520eb9c4822\nparent b2ee088c73158be66b643ace58857a842d38add8\nparent 0c5fe37786425edf53db60f20fe68f86dcb0b481\nauthor Yuki Okushi <jtitor@2k36.org> 1683258387 +0900\ncommitter GitHub <noreply@github.com> 1683258387 +0900\n\nRollup merge of #111132 - lcnr:nll-generalize, r=b-naber\n\ncleanup nll generalizer\n\nfollowup to #108861\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5c50e3350baaea9594196a5b7f07ec1db8445bf", "html_url": "https://github.com/rust-lang/rust/commit/f5c50e3350baaea9594196a5b7f07ec1db8445bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5c50e3350baaea9594196a5b7f07ec1db8445bf/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2ee088c73158be66b643ace58857a842d38add8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2ee088c73158be66b643ace58857a842d38add8", "html_url": "https://github.com/rust-lang/rust/commit/b2ee088c73158be66b643ace58857a842d38add8"}, {"sha": "0c5fe37786425edf53db60f20fe68f86dcb0b481", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c5fe37786425edf53db60f20fe68f86dcb0b481", "html_url": "https://github.com/rust-lang/rust/commit/0c5fe37786425edf53db60f20fe68f86dcb0b481"}], "stats": {"total": 133, "additions": 20, "deletions": 113}, "files": [{"sha": "315303b25fe4e0e0bf18e1c6a71335d6e4e6ab4f", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5c50e3350baaea9594196a5b7f07ec1db8445bf/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5c50e3350baaea9594196a5b7f07ec1db8445bf/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=f5c50e3350baaea9594196a5b7f07ec1db8445bf", "patch": "@@ -498,11 +498,11 @@ impl<'cx, 'tcx> BorrowckInferCtxt<'cx, 'tcx> {\n         let next_region = self.infcx.next_region_var(origin);\n         let vid = next_region.as_var();\n \n-        if cfg!(debug_assertions) && !self.inside_canonicalization_ctxt() {\n+        if cfg!(debug_assertions) {\n             debug!(\"inserting vid {:?} with origin {:?} into var_to_origin\", vid, origin);\n             let ctxt = get_ctxt_fn();\n             let mut var_to_origin = self.reg_var_to_origin.borrow_mut();\n-            var_to_origin.insert(vid, ctxt);\n+            assert_eq!(var_to_origin.insert(vid, ctxt), None);\n         }\n \n         next_region\n@@ -520,11 +520,11 @@ impl<'cx, 'tcx> BorrowckInferCtxt<'cx, 'tcx> {\n         let next_region = self.infcx.next_nll_region_var(origin);\n         let vid = next_region.as_var();\n \n-        if cfg!(debug_assertions) && !self.inside_canonicalization_ctxt() {\n+        if cfg!(debug_assertions) {\n             debug!(\"inserting vid {:?} with origin {:?} into var_to_origin\", vid, origin);\n             let ctxt = get_ctxt_fn();\n             let mut var_to_origin = self.reg_var_to_origin.borrow_mut();\n-            var_to_origin.insert(vid, ctxt);\n+            assert_eq!(var_to_origin.insert(vid, ctxt), None);\n         }\n \n         next_region"}, {"sha": "7158c62b548afb00250172969d09bea8e5dcbbfe", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f5c50e3350baaea9594196a5b7f07ec1db8445bf/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5c50e3350baaea9594196a5b7f07ec1db8445bf/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=f5c50e3350baaea9594196a5b7f07ec1db8445bf", "patch": "@@ -131,9 +131,13 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n             ty::BoundRegionKind::BrEnv => BoundRegionInfo::Name(sym::env),\n         };\n \n-        if cfg!(debug_assertions) && !self.type_checker.infcx.inside_canonicalization_ctxt() {\n+        if cfg!(debug_assertions) {\n             let mut var_to_origin = self.type_checker.infcx.reg_var_to_origin.borrow_mut();\n-            var_to_origin.insert(reg.as_var(), RegionCtxt::Placeholder(reg_info));\n+            let new = RegionCtxt::Placeholder(reg_info);\n+            let prev = var_to_origin.insert(reg.as_var(), new);\n+            if let Some(prev) = prev {\n+                assert_eq!(new, prev);\n+            }\n         }\n \n         reg\n@@ -146,9 +150,10 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n             universe,\n         );\n \n-        if cfg!(debug_assertions) && !self.type_checker.infcx.inside_canonicalization_ctxt() {\n+        if cfg!(debug_assertions) {\n             let mut var_to_origin = self.type_checker.infcx.reg_var_to_origin.borrow_mut();\n-            var_to_origin.insert(reg.as_var(), RegionCtxt::Existential(None));\n+            let prev = var_to_origin.insert(reg.as_var(), RegionCtxt::Existential(None));\n+            assert_eq!(prev, None);\n         }\n \n         reg"}, {"sha": "0c8854e962abb85a8f55bb743156b8959dd11ba3", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5c50e3350baaea9594196a5b7f07ec1db8445bf/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5c50e3350baaea9594196a5b7f07ec1db8445bf/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=f5c50e3350baaea9594196a5b7f07ec1db8445bf", "patch": "@@ -30,8 +30,6 @@ use super::*;\n use rustc_middle::ty::relate::{Relate, TypeRelation};\n use rustc_middle::ty::{Const, ImplSubject};\n \n-use std::cell::Cell;\n-\n /// Whether we should define opaque types or just treat them opaquely.\n ///\n /// Currently only used to prevent predicate matching from matching anything\n@@ -84,7 +82,6 @@ impl<'tcx> InferCtxt<'tcx> {\n             in_snapshot: self.in_snapshot.clone(),\n             universe: self.universe.clone(),\n             intercrate: self.intercrate,\n-            inside_canonicalization_ctxt: Cell::new(self.inside_canonicalization_ctxt()),\n         }\n     }\n }"}, {"sha": "427d05c8b4da7d14e300b7a10418ac88544d8192", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5c50e3350baaea9594196a5b7f07ec1db8445bf/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5c50e3350baaea9594196a5b7f07ec1db8445bf/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=f5c50e3350baaea9594196a5b7f07ec1db8445bf", "patch": "@@ -561,8 +561,6 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n     where\n         V: TypeFoldable<TyCtxt<'tcx>>,\n     {\n-        let _inside_canonical_ctxt_guard = infcx.set_canonicalization_ctxt();\n-\n         let needs_canonical_flags = if canonicalize_region_mode.any() {\n             TypeFlags::HAS_INFER |\n             TypeFlags::HAS_FREE_REGIONS | // `HAS_RE_PLACEHOLDER` implies `HAS_FREE_REGIONS`"}, {"sha": "a89b9931599023f88ce753ec16dc9f52faaa962e", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f5c50e3350baaea9594196a5b7f07ec1db8445bf/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5c50e3350baaea9594196a5b7f07ec1db8445bf/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=f5c50e3350baaea9594196a5b7f07ec1db8445bf", "patch": "@@ -39,7 +39,6 @@ use rustc_span::Span;\n \n use std::cell::{Cell, RefCell};\n use std::fmt;\n-use std::ops::Drop;\n \n use self::combine::CombineFields;\n use self::error_reporting::TypeErrCtxt;\n@@ -342,11 +341,6 @@ pub struct InferCtxt<'tcx> {\n     /// there is no type that the user could *actually name* that\n     /// would satisfy it. This avoids crippling inference, basically.\n     pub intercrate: bool,\n-\n-    /// Flag that is set when we enter canonicalization. Used for debugging to ensure\n-    /// that we only collect region information for `BorrowckInferCtxt::reg_var_to_origin`\n-    /// inside non-canonicalization contexts.\n-    inside_canonicalization_ctxt: Cell<bool>,\n }\n \n /// See the `error_reporting` module for more details.\n@@ -638,7 +632,6 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             skip_leak_check: Cell::new(false),\n             universe: Cell::new(ty::UniverseIndex::ROOT),\n             intercrate,\n-            inside_canonicalization_ctxt: Cell::new(false),\n         }\n     }\n }\n@@ -1636,31 +1629,6 @@ impl<'tcx> InferCtxt<'tcx> {\n             }\n         }\n     }\n-\n-    pub fn inside_canonicalization_ctxt(&self) -> bool {\n-        self.inside_canonicalization_ctxt.get()\n-    }\n-\n-    pub fn set_canonicalization_ctxt(&self) -> CanonicalizationCtxtGuard<'_, 'tcx> {\n-        let prev_ctxt = self.inside_canonicalization_ctxt();\n-        self.inside_canonicalization_ctxt.set(true);\n-        CanonicalizationCtxtGuard { prev_ctxt, infcx: self }\n-    }\n-\n-    fn set_canonicalization_ctxt_to(&self, ctxt: bool) {\n-        self.inside_canonicalization_ctxt.set(ctxt);\n-    }\n-}\n-\n-pub struct CanonicalizationCtxtGuard<'cx, 'tcx> {\n-    prev_ctxt: bool,\n-    infcx: &'cx InferCtxt<'tcx>,\n-}\n-\n-impl<'cx, 'tcx> Drop for CanonicalizationCtxtGuard<'cx, 'tcx> {\n-    fn drop(&mut self) {\n-        self.infcx.set_canonicalization_ctxt_to(self.prev_ctxt)\n-    }\n }\n \n impl<'tcx> TypeErrCtxt<'_, 'tcx> {"}, {"sha": "88a0a81e276d27e4de74e32a48f864af3afdeddc", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 7, "deletions": 68, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f5c50e3350baaea9594196a5b7f07ec1db8445bf/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5c50e3350baaea9594196a5b7f07ec1db8445bf/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=f5c50e3350baaea9594196a5b7f07ec1db8445bf", "patch": "@@ -30,11 +30,10 @@ use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::FnMutDelegate;\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n-use rustc_middle::ty::visit::{TypeSuperVisitable, TypeVisitable, TypeVisitableExt, TypeVisitor};\n+use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::{self, InferConst, Ty, TyCtxt};\n use rustc_span::{Span, Symbol};\n use std::fmt::Debug;\n-use std::ops::ControlFlow;\n \n use super::combine::ObligationEmittingRelation;\n \n@@ -115,11 +114,6 @@ pub trait TypeRelatingDelegate<'tcx> {\n     fn forbid_inference_vars() -> bool;\n }\n \n-#[derive(Clone, Debug, Default)]\n-struct BoundRegionScope<'tcx> {\n-    map: FxHashMap<ty::BoundRegion, ty::Region<'tcx>>,\n-}\n-\n #[derive(Copy, Clone)]\n struct UniversallyQuantified(bool);\n \n@@ -230,10 +224,13 @@ where\n     ) -> RelateResult<'tcx, T> {\n         let universe = self.infcx.probe_ty_var(for_vid).unwrap_err();\n \n+        if value.has_escaping_bound_vars() {\n+            bug!(\"trying to instantiate {for_vid:?} with escaping bound vars: {value:?}\");\n+        }\n+\n         let mut generalizer = TypeGeneralizer {\n             infcx: self.infcx,\n             delegate: &mut self.delegate,\n-            first_free_index: ty::INNERMOST,\n             ambient_variance: self.ambient_variance,\n             for_vid_sub_root: self.infcx.inner.borrow_mut().type_variables().sub_root_var(for_vid),\n             universe,\n@@ -488,13 +485,7 @@ where\n         }\n \n         if a == b {\n-            // Subtle: if a or b has a bound variable that we are lazily\n-            // substituting, then even if a == b, it could be that the values we\n-            // will substitute for those bound variables are *not* the same, and\n-            // hence returning `Ok(a)` is incorrect.\n-            if !a.has_escaping_bound_vars() && !b.has_escaping_bound_vars() {\n-                return Ok(a);\n-            }\n+            return Ok(a);\n         }\n \n         match (a.kind(), b.kind()) {\n@@ -726,47 +717,6 @@ where\n     }\n }\n \n-/// When we encounter a binder like `for<..> fn(..)`, we actually have\n-/// to walk the `fn` value to find all the values bound by the `for`\n-/// (these are not explicitly present in the ty representation right\n-/// now). This visitor handles that: it descends the type, tracking\n-/// binder depth, and finds late-bound regions targeting the\n-/// `for<..`>. For each of those, it creates an entry in\n-/// `bound_region_scope`.\n-struct ScopeInstantiator<'me, 'tcx> {\n-    next_region: &'me mut dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n-    // The debruijn index of the scope we are instantiating.\n-    target_index: ty::DebruijnIndex,\n-    bound_region_scope: &'me mut BoundRegionScope<'tcx>,\n-}\n-\n-impl<'me, 'tcx> TypeVisitor<TyCtxt<'tcx>> for ScopeInstantiator<'me, 'tcx> {\n-    fn visit_binder<T: TypeVisitable<TyCtxt<'tcx>>>(\n-        &mut self,\n-        t: &ty::Binder<'tcx, T>,\n-    ) -> ControlFlow<Self::BreakTy> {\n-        self.target_index.shift_in(1);\n-        t.super_visit_with(self);\n-        self.target_index.shift_out(1);\n-\n-        ControlFlow::Continue(())\n-    }\n-\n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        let ScopeInstantiator { bound_region_scope, next_region, .. } = self;\n-\n-        match *r {\n-            ty::ReLateBound(debruijn, br) if debruijn == self.target_index => {\n-                bound_region_scope.map.entry(br).or_insert_with(|| next_region(br));\n-            }\n-\n-            _ => {}\n-        }\n-\n-        ControlFlow::Continue(())\n-    }\n-}\n-\n /// The \"type generalizer\" is used when handling inference variables.\n ///\n /// The basic strategy for handling a constraint like `?A <: B` is to\n@@ -780,11 +730,6 @@ impl<'me, 'tcx> TypeVisitor<TyCtxt<'tcx>> for ScopeInstantiator<'me, 'tcx> {\n /// value of `A`. Finally, we relate `&'0 u32 <: &'x u32`, which\n /// establishes `'0: 'x` as a constraint.\n ///\n-/// As a side-effect of this generalization procedure, we also replace\n-/// all the bound regions that we have traversed with concrete values,\n-/// so that the resulting generalized type is independent from the\n-/// scopes.\n-///\n /// [blog post]: https://is.gd/0hKvIr\n struct TypeGeneralizer<'me, 'tcx, D>\n where\n@@ -798,8 +743,6 @@ where\n     /// some other type. What will be the variance at this point?\n     ambient_variance: ty::Variance,\n \n-    first_free_index: ty::DebruijnIndex,\n-\n     /// The vid of the type variable that is in the process of being\n     /// instantiated. If we find this within the value we are folding,\n     /// that means we would have created a cyclic value.\n@@ -939,7 +882,7 @@ where\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n         debug!(\"TypeGeneralizer::regions(a={:?})\", a);\n \n-        if let ty::ReLateBound(debruijn, _) = *a && debruijn < self.first_free_index {\n+        if let ty::ReLateBound(..) = *a {\n             return Ok(a);\n         }\n \n@@ -958,7 +901,6 @@ where\n         // FIXME(#54105) -- if the ambient variance is bivariant,\n         // though, we may however need to check well-formedness or\n         // risk a problem like #41677 again.\n-\n         let replacement_region_vid = self.delegate.generalize_existential(self.universe);\n \n         Ok(replacement_region_vid)\n@@ -1002,10 +944,7 @@ where\n         T: Relate<'tcx>,\n     {\n         debug!(\"TypeGeneralizer::binders(a={:?})\", a);\n-\n-        self.first_free_index.shift_in(1);\n         let result = self.relate(a.skip_binder(), a.skip_binder())?;\n-        self.first_free_index.shift_out(1);\n         Ok(a.rebind(result))\n     }\n }"}]}