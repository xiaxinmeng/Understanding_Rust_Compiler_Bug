{"sha": "78d8416caf65cfb50de61bb9423e9efa026bd45a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4ZDg0MTZjYWY2NWNmYjUwZGU2MWJiOTQyM2U5ZWZhMDI2YmQ0NWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-17T16:54:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-17T16:54:07Z"}, "message": "Auto merge of #42649 - estebank:if-cond, r=nikomatsakis\n\nReport error for assignment in `if` condition\n\nFor code like `if x = 3 {}`, output:\n\n```\nerror[E0308]: mismatched types\n  --> $DIR/issue-17283.rs:25:8\n   |\n25 |     if x = x {\n   |        ^^^^^\n   |        |\n   |        help: did you mean to compare equality? `x == x`\n   |        expected bool, found ()\n   |\n   = note: expected type `bool`\n              found type `()`\n```\n\nFix #40926.", "tree": {"sha": "82670dd65a81e38fc5b5a9da7f4ef010fb4b77f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82670dd65a81e38fc5b5a9da7f4ef010fb4b77f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78d8416caf65cfb50de61bb9423e9efa026bd45a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78d8416caf65cfb50de61bb9423e9efa026bd45a", "html_url": "https://github.com/rust-lang/rust/commit/78d8416caf65cfb50de61bb9423e9efa026bd45a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78d8416caf65cfb50de61bb9423e9efa026bd45a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfb8c80e118a6844e3a7130a884e92dde4ef4694", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfb8c80e118a6844e3a7130a884e92dde4ef4694", "html_url": "https://github.com/rust-lang/rust/commit/dfb8c80e118a6844e3a7130a884e92dde4ef4694"}, {"sha": "da78b4d88e1ba4598428a92a6c8d5f9c399fede0", "url": "https://api.github.com/repos/rust-lang/rust/commits/da78b4d88e1ba4598428a92a6c8d5f9c399fede0", "html_url": "https://github.com/rust-lang/rust/commit/da78b4d88e1ba4598428a92a6c8d5f9c399fede0"}], "stats": {"total": 182, "additions": 145, "deletions": 37}, "files": [{"sha": "bdd8169b84fe7ffcdf58726dee2875c8356fb1c2", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78d8416caf65cfb50de61bb9423e9efa026bd45a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78d8416caf65cfb50de61bb9423e9efa026bd45a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=78d8416caf65cfb50de61bb9423e9efa026bd45a", "patch": "@@ -413,7 +413,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // discriminant. This is sort of a workaround, see note (*) in\n             // `check_pat` for some details.\n             discrim_ty = self.next_ty_var(TypeVariableOrigin::TypeInference(discrim.span));\n-            self.check_expr_has_type(discrim, discrim_ty);\n+            self.check_expr_has_type_or_error(discrim, discrim_ty);\n         };\n \n         // If the discriminant diverges, the match is pointless (e.g.,\n@@ -480,7 +480,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         for (i, (arm, pats_diverge)) in arms.iter().zip(all_arm_pats_diverge).enumerate() {\n             if let Some(ref e) = arm.guard {\n                 self.diverges.set(pats_diverge);\n-                self.check_expr_has_type(e, tcx.types.bool);\n+                self.check_expr_has_type_or_error(e, tcx.types.bool);\n             }\n \n             self.diverges.set(pats_diverge);"}, {"sha": "1b6f96cf65137f3fcda3d25d2822d2a4c7986a6f", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78d8416caf65cfb50de61bb9423e9efa026bd45a/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78d8416caf65cfb50de61bb9423e9efa026bd45a/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=78d8416caf65cfb50de61bb9423e9efa026bd45a", "patch": "@@ -26,13 +26,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // Requires that the two types unify, and prints an error message if\n     // they don't.\n     pub fn demand_suptype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n+        self.demand_suptype_diag(sp, expected, actual).map(|mut e| e.emit());\n+    }\n+\n+    pub fn demand_suptype_diag(&self,\n+                               sp: Span,\n+                               expected: Ty<'tcx>,\n+                               actual: Ty<'tcx>) -> Option<DiagnosticBuilder<'tcx>> {\n         let cause = &self.misc(sp);\n         match self.at(cause, self.param_env).sup(expected, actual) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n+                None\n             },\n             Err(e) => {\n-                self.report_mismatched_types(&cause, expected, actual, e).emit();\n+                Some(self.report_mismatched_types(&cause, expected, actual, e))\n             }\n         }\n     }"}, {"sha": "f7e23d289873a75221fc9676e3386db020f8a9c2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 62, "deletions": 25, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/78d8416caf65cfb50de61bb9423e9efa026bd45a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78d8416caf65cfb50de61bb9423e9efa026bd45a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=78d8416caf65cfb50de61bb9423e9efa026bd45a", "patch": "@@ -232,6 +232,9 @@ pub enum Expectation<'tcx> {\n     /// We know nothing about what type this expression should have.\n     NoExpectation,\n \n+    /// This expression is an `if` condition, it must resolve to `bool`.\n+    ExpectIfCondition,\n+\n     /// This expression should have the type given (or some subtype)\n     ExpectHasType(Ty<'tcx>),\n \n@@ -310,9 +313,8 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     // no constraints yet present), just returns `None`.\n     fn resolve(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Expectation<'tcx> {\n         match self {\n-            NoExpectation => {\n-                NoExpectation\n-            }\n+            NoExpectation => NoExpectation,\n+            ExpectIfCondition => ExpectIfCondition,\n             ExpectCastableToType(t) => {\n                 ExpectCastableToType(fcx.resolve_type_vars_if_possible(&t))\n             }\n@@ -328,6 +330,7 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     fn to_option(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Option<Ty<'tcx>> {\n         match self.resolve(fcx) {\n             NoExpectation => None,\n+            ExpectIfCondition => Some(fcx.tcx.types.bool),\n             ExpectCastableToType(ty) |\n             ExpectHasType(ty) |\n             ExpectRvalueLikeUnsized(ty) => Some(ty),\n@@ -341,7 +344,8 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     fn only_has_type(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Option<Ty<'tcx>> {\n         match self.resolve(fcx) {\n             ExpectHasType(ty) => Some(ty),\n-            _ => None\n+            ExpectIfCondition => Some(fcx.tcx.types.bool),\n+            NoExpectation | ExpectCastableToType(_) | ExpectRvalueLikeUnsized(_) => None,\n         }\n     }\n \n@@ -2644,10 +2648,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.demand_eqtype(expr.span, expected, ty);\n     }\n \n-    pub fn check_expr_has_type(&self,\n-                               expr: &'gcx hir::Expr,\n-                               expected: Ty<'tcx>) -> Ty<'tcx> {\n-        let mut ty = self.check_expr_with_hint(expr, expected);\n+    pub fn check_expr_has_type_or_error(&self,\n+                                        expr: &'gcx hir::Expr,\n+                                        expected: Ty<'tcx>) -> Ty<'tcx> {\n+        self.check_expr_meets_expectation_or_error(expr, ExpectHasType(expected))\n+    }\n+\n+    fn check_expr_meets_expectation_or_error(&self,\n+                                             expr: &'gcx hir::Expr,\n+                                             expected: Expectation<'tcx>) -> Ty<'tcx> {\n+        let expected_ty = expected.to_option(&self).unwrap_or(self.tcx.types.bool);\n+        let mut ty = self.check_expr_with_expectation(expr, expected);\n \n         // While we don't allow *arbitrary* coercions here, we *do* allow\n         // coercions from ! to `expected`.\n@@ -2663,7 +2674,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ty = adj_ty;\n         }\n \n-        self.demand_suptype(expr.span, expected, ty);\n+        if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n+            // Add help to type error if this is an `if` condition with an assignment\n+            match (expected, &expr.node) {\n+                (ExpectIfCondition, &hir::ExprAssign(ref lhs, ref rhs)) => {\n+                    let msg = \"did you mean to compare equality?\";\n+                    if let (Ok(left), Ok(right)) = (\n+                        self.tcx.sess.codemap().span_to_snippet(lhs.span),\n+                        self.tcx.sess.codemap().span_to_snippet(rhs.span))\n+                    {\n+                        err.span_suggestion(expr.span, msg, format!(\"{} == {}\", left, right));\n+                    } else {\n+                        err.help(msg);\n+                    }\n+                }\n+                _ => (),\n+            }\n+            err.emit();\n+        }\n         ty\n     }\n \n@@ -2838,7 +2866,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        opt_else_expr: Option<&'gcx hir::Expr>,\n                        sp: Span,\n                        expected: Expectation<'tcx>) -> Ty<'tcx> {\n-        let cond_ty = self.check_expr_has_type(cond_expr, self.tcx.types.bool);\n+        let cond_ty = self.check_expr_meets_expectation_or_error(cond_expr, ExpectIfCondition);\n         let cond_diverges = self.diverges.get();\n         self.diverges.set(Diverges::Maybe);\n \n@@ -3325,7 +3353,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.check_expr_struct_fields(struct_ty, expected, expr.id, path_span, variant, fields,\n                                       base_expr.is_none());\n         if let &Some(ref base_expr) = base_expr {\n-            self.check_expr_has_type(base_expr, struct_ty);\n+            self.check_expr_has_type_or_error(base_expr, struct_ty);\n             match struct_ty.sty {\n                 ty::TyAdt(adt, substs) if adt.is_struct() => {\n                     let fru_field_types = adt.struct_variant().fields.iter().map(|f| {\n@@ -3638,19 +3666,28 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::ExprAssign(ref lhs, ref rhs) => {\n             let lhs_ty = self.check_expr_with_lvalue_pref(&lhs, PreferMutLvalue);\n \n-            let tcx = self.tcx;\n-            if !tcx.expr_is_lval(&lhs) {\n-                struct_span_err!(\n-                    tcx.sess, expr.span, E0070,\n-                    \"invalid left-hand side expression\")\n-                .span_label(\n-                    expr.span,\n-                    \"left-hand of expression not valid\")\n-                .emit();\n-            }\n-\n             let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n \n+            match expected {\n+                ExpectIfCondition => {\n+                    self.tcx.sess.delay_span_bug(lhs.span, \"invalid lhs expression in if;\\\n+                                                            expected error elsehwere\");\n+                }\n+                _ => {\n+                    // Only check this if not in an `if` condition, as the\n+                    // mistyped comparison help is more appropriate.\n+                    if !self.tcx.expr_is_lval(&lhs) {\n+                        struct_span_err!(\n+                            self.tcx.sess, expr.span, E0070,\n+                            \"invalid left-hand side expression\")\n+                        .span_label(\n+                            expr.span,\n+                            \"left-hand of expression not valid\")\n+                        .emit();\n+                    }\n+                }\n+            }\n+\n             self.require_type_is_sized(lhs_ty, lhs.span, traits::AssignmentLhsSized);\n \n             if lhs_ty.references_error() || rhs_ty.references_error() {\n@@ -3671,7 +3708,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               };\n \n               self.with_breakable_ctxt(expr.id, ctxt, || {\n-                  self.check_expr_has_type(&cond, tcx.types.bool);\n+                  self.check_expr_has_type_or_error(&cond, tcx.types.bool);\n                   let cond_diverging = self.diverges.get();\n                   self.check_block_no_value(&body);\n \n@@ -3809,7 +3846,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 None => {\n                     let t: Ty = self.next_ty_var(TypeVariableOrigin::MiscVariable(element.span));\n-                    let element_ty = self.check_expr_has_type(&element, t);\n+                    let element_ty = self.check_expr_has_type_or_error(&element, t);\n                     (element_ty, t)\n                 }\n             };\n@@ -4060,7 +4097,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             hir::StmtExpr(ref expr, _) => {\n                 // Check with expected type of ()\n-                self.check_expr_has_type(&expr, self.tcx.mk_nil());\n+                self.check_expr_has_type_or_error(&expr, self.tcx.mk_nil());\n             }\n             hir::StmtSemi(ref expr, _) => {\n                 self.check_expr(&expr);"}, {"sha": "98dc55c666303fa65c03f565e7ff1214985a7931", "filename": "src/test/ui/type-check/assignment-in-if.rs", "status": "renamed", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/78d8416caf65cfb50de61bb9423e9efa026bd45a/src%2Ftest%2Fui%2Ftype-check%2Fassignment-in-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78d8416caf65cfb50de61bb9423e9efa026bd45a/src%2Ftest%2Fui%2Ftype-check%2Fassignment-in-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Fassignment-in-if.rs?ref=78d8416caf65cfb50de61bb9423e9efa026bd45a", "patch": "@@ -24,25 +24,29 @@ fn main() {\n     // `x { ... }` should not be interpreted as a struct literal here\n     if x = x {\n         //~^ ERROR mismatched types\n-        //~| expected type `bool`\n-        //~| found type `()`\n-        //~| expected bool, found ()\n+        //~| HELP did you mean to compare equality?\n         println!(\"{}\", x);\n     }\n     // Explicit parentheses on the left should match behavior of above\n     if (x = x) {\n         //~^ ERROR mismatched types\n-        //~| expected type `bool`\n-        //~| found type `()`\n-        //~| expected bool, found ()\n+        //~| HELP did you mean to compare equality?\n         println!(\"{}\", x);\n     }\n     // The struct literal interpretation is fine with explicit parentheses on the right\n     if y = (Foo { foo: x }) {\n         //~^ ERROR mismatched types\n-        //~| expected type `bool`\n-        //~| found type `()`\n-        //~| expected bool, found ()\n+        //~| HELP did you mean to compare equality?\n+        println!(\"{}\", x);\n+    }\n+    // \"invalid left-hand side expression\" error is suppresed\n+    if 3 = x {\n+        //~^ ERROR mismatched types\n+        //~| HELP did you mean to compare equality?\n+        println!(\"{}\", x);\n+    }\n+    if (if true { x = 4 } else { x = 5 }) {\n+        //~^ ERROR mismatched types\n         println!(\"{}\", x);\n     }\n }", "previous_filename": "src/test/compile-fail/issue-17283.rs"}, {"sha": "294399992732233a541ce4899456667b22e00fc1", "filename": "src/test/ui/type-check/assignment-in-if.stderr", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/78d8416caf65cfb50de61bb9423e9efa026bd45a/src%2Ftest%2Fui%2Ftype-check%2Fassignment-in-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78d8416caf65cfb50de61bb9423e9efa026bd45a/src%2Ftest%2Fui%2Ftype-check%2Fassignment-in-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Fassignment-in-if.stderr?ref=78d8416caf65cfb50de61bb9423e9efa026bd45a", "patch": "@@ -0,0 +1,59 @@\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-in-if.rs:25:8\n+   |\n+25 |     if x = x {\n+   |        ^^^^^\n+   |        |\n+   |        help: did you mean to compare equality? `x == x`\n+   |        expected bool, found ()\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-in-if.rs:31:8\n+   |\n+31 |     if (x = x) {\n+   |        ^^^^^^^\n+   |        |\n+   |        help: did you mean to compare equality? `x == x`\n+   |        expected bool, found ()\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-in-if.rs:37:8\n+   |\n+37 |     if y = (Foo { foo: x }) {\n+   |        ^^^^^^^^^^^^^^^^^^^^\n+   |        |\n+   |        help: did you mean to compare equality? `y == (Foo { foo: x })`\n+   |        expected bool, found ()\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-in-if.rs:43:8\n+   |\n+43 |     if 3 = x {\n+   |        ^^^^^\n+   |        |\n+   |        help: did you mean to compare equality? `3 == x`\n+   |        expected bool, found ()\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-in-if.rs:48:8\n+   |\n+48 |     if (if true { x = 4 } else { x = 5 }) {\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected bool, found ()\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error: aborting due to previous error(s)\n+"}]}