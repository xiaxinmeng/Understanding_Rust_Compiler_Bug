{"sha": "fc74e359819002fad402f68728f6e5ba2d4cb704", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjNzRlMzU5ODE5MDAyZmFkNDAyZjY4NzI4ZjZlNWJhMmQ0Y2I3MDQ=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-07-07T20:07:06Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-07-08T15:16:09Z"}, "message": "Remove fallback to parent modules from lexical resolution", "tree": {"sha": "32c1c6b774ff39648ef7508739ef83975358996e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32c1c6b774ff39648ef7508739ef83975358996e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc74e359819002fad402f68728f6e5ba2d4cb704", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc74e359819002fad402f68728f6e5ba2d4cb704", "html_url": "https://github.com/rust-lang/rust/commit/fc74e359819002fad402f68728f6e5ba2d4cb704", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc74e359819002fad402f68728f6e5ba2d4cb704/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba", "url": "https://api.github.com/repos/rust-lang/rust/commits/94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba", "html_url": "https://github.com/rust-lang/rust/commit/94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba"}], "stats": {"total": 419, "additions": 317, "deletions": 102}, "files": [{"sha": "7a26a239aeffadb777733841e1411434752f789a", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=fc74e359819002fad402f68728f6e5ba2d4cb704", "patch": "@@ -129,6 +129,16 @@ pub enum Namespace {\n     MacroNS,\n }\n \n+impl Namespace {\n+    pub fn descr(self) -> &'static str {\n+        match self {\n+            TypeNS => \"type\",\n+            ValueNS => \"value\",\n+            MacroNS => \"macro\",\n+        }\n+    }\n+}\n+\n /// Just a helper \u2012 separate structure for each namespace.\n #[derive(Copy, Clone, Default, Debug)]\n pub struct PerNS<T> {"}, {"sha": "49a4a1b78a1a8714edf8d7808b6870e2fe04f19b", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 7, "deletions": 29, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=fc74e359819002fad402f68728f6e5ba2d4cb704", "patch": "@@ -153,6 +153,7 @@ impl Decodable for DefPathTable {\n /// The definition table containing node definitions.\n /// It holds the DefPathTable for local DefIds/DefPaths and it also stores a\n /// mapping from NodeIds to local DefIds.\n+#[derive(Clone)]\n pub struct Definitions {\n     table: DefPathTable,\n     node_to_def_index: NodeMap<DefIndex>,\n@@ -161,34 +162,12 @@ pub struct Definitions {\n     /// If `Mark` is an ID of some macro expansion,\n     /// then `DefId` is the normal module (`mod`) in which the expanded macro was defined.\n     parent_modules_of_macro_defs: FxHashMap<Mark, DefId>,\n-    /// Item with a given `DefIndex` was defined during opaque macro expansion with ID `Mark`.\n-    /// It can actually be defined during transparent macro expansions inside that opaque expansion,\n-    /// but transparent expansions are ignored here.\n-    opaque_expansions_that_defined: FxHashMap<DefIndex, Mark>,\n+    /// Item with a given `DefIndex` was defined during macro expansion with ID `Mark`.\n+    expansions_that_defined: FxHashMap<DefIndex, Mark>,\n     next_disambiguator: FxHashMap<(DefIndex, DefPathData), u32>,\n     def_index_to_span: FxHashMap<DefIndex, Span>,\n }\n \n-// Unfortunately we have to provide a manual impl of Clone because of the\n-// fixed-sized array field.\n-impl Clone for Definitions {\n-    fn clone(&self) -> Self {\n-        Definitions {\n-            table: self.table.clone(),\n-            node_to_def_index: self.node_to_def_index.clone(),\n-            def_index_to_node: [\n-                self.def_index_to_node[0].clone(),\n-                self.def_index_to_node[1].clone(),\n-            ],\n-            node_to_hir_id: self.node_to_hir_id.clone(),\n-            parent_modules_of_macro_defs: self.parent_modules_of_macro_defs.clone(),\n-            opaque_expansions_that_defined: self.opaque_expansions_that_defined.clone(),\n-            next_disambiguator: self.next_disambiguator.clone(),\n-            def_index_to_span: self.def_index_to_span.clone(),\n-        }\n-    }\n-}\n-\n /// A unique identifier that we can use to lookup a definition\n /// precisely. It combines the index of the definition's parent (if\n /// any) with a `DisambiguatedDefPathData`.\n@@ -409,7 +388,7 @@ impl Definitions {\n             def_index_to_node: [vec![], vec![]],\n             node_to_hir_id: IndexVec::new(),\n             parent_modules_of_macro_defs: FxHashMap(),\n-            opaque_expansions_that_defined: FxHashMap(),\n+            expansions_that_defined: FxHashMap(),\n             next_disambiguator: FxHashMap(),\n             def_index_to_span: FxHashMap(),\n         }\n@@ -584,9 +563,8 @@ impl Definitions {\n             self.node_to_def_index.insert(node_id, index);\n         }\n \n-        let expansion = expansion.modern();\n         if expansion != Mark::root() {\n-            self.opaque_expansions_that_defined.insert(index, expansion);\n+            self.expansions_that_defined.insert(index, expansion);\n         }\n \n         // The span is added if it isn't dummy\n@@ -606,8 +584,8 @@ impl Definitions {\n         self.node_to_hir_id = mapping;\n     }\n \n-    pub fn opaque_expansion_that_defined(&self, index: DefIndex) -> Mark {\n-        self.opaque_expansions_that_defined.get(&index).cloned().unwrap_or(Mark::root())\n+    pub fn expansion_that_defined(&self, index: DefIndex) -> Mark {\n+        self.expansions_that_defined.get(&index).cloned().unwrap_or(Mark::root())\n     }\n \n     pub fn parent_module_of_macro_def(&self, mark: Mark) -> DefId {"}, {"sha": "efc2d9311c1dcbe67ee58d39cc4d14e7e2da43a7", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=fc74e359819002fad402f68728f6e5ba2d4cb704", "patch": "@@ -316,6 +316,12 @@ declare_lint! {\n     \"checks the object safety of where clauses\"\n }\n \n+declare_lint! {\n+    pub PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n+    Warn,\n+    \"detects proc macro derives using inaccessible names from parent modules\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -372,6 +378,7 @@ impl LintPass for HardwiredLints {\n             DUPLICATE_MACRO_EXPORTS,\n             INTRA_DOC_LINK_RESOLUTION_FAILURE,\n             WHERE_CLAUSES_OBJECT_SAFETY,\n+            PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n         )\n     }\n }\n@@ -384,6 +391,7 @@ pub enum BuiltinLintDiagnostics {\n     BareTraitObject(Span, /* is_global */ bool),\n     AbsPathWithModule(Span),\n     DuplicatedMacroExports(ast::Ident, Span, Span),\n+    ProcMacroDeriveResolutionFallback(Span),\n }\n \n impl BuiltinLintDiagnostics {\n@@ -420,6 +428,10 @@ impl BuiltinLintDiagnostics {\n                 db.span_label(later_span, format!(\"`{}` already exported\", ident));\n                 db.span_note(earlier_span, \"previous macro export is now shadowed\");\n             }\n+            BuiltinLintDiagnostics::ProcMacroDeriveResolutionFallback(span) => {\n+                db.span_label(span, \"names from parent modules are not \\\n+                                     accessible without an explicit import\");\n+            }\n         }\n     }\n }"}, {"sha": "4a76cc683f6800ecf8715ee725d12006bae4ddbf", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=fc74e359819002fad402f68728f6e5ba2d4cb704", "patch": "@@ -2724,7 +2724,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn adjust_ident(self, mut ident: Ident, scope: DefId, block: NodeId) -> (Ident, DefId) {\n         ident = ident.modern();\n         let target_expansion = match scope.krate {\n-            LOCAL_CRATE => self.hir.definitions().opaque_expansion_that_defined(scope.index),\n+            LOCAL_CRATE => self.hir.definitions().expansion_that_defined(scope.index),\n             _ => Mark::root(),\n         };\n         let scope = match ident.span.adjust(target_expansion) {"}, {"sha": "27e51ad8961dfbc8b43949673841725767ce8cb6", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=fc74e359819002fad402f68728f6e5ba2d4cb704", "patch": "@@ -293,6 +293,11 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             reference: \"issue #50589 <https://github.com/rust-lang/rust/issues/50589>\",\n             edition: None,\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(PROC_MACRO_DERIVE_RESOLUTION_FALLBACK),\n+            reference: \"issue #50504 <https://github.com/rust-lang/rust/issues/50504>\",\n+            edition: None,\n+        },\n         ]);\n \n     // Register renamed and removed lints"}, {"sha": "ad63a43fead5cf37d147c8f064283ea50f5b4f7e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 57, "deletions": 26, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=fc74e359819002fad402f68728f6e5ba2d4cb704", "patch": "@@ -55,7 +55,7 @@ use syntax::util::lev_distance::find_best_match_for_name;\n \n use syntax::visit::{self, FnKind, Visitor};\n use syntax::attr;\n-use syntax::ast::{Arm, IsAsync, BindingMode, Block, Crate, Expr, ExprKind};\n+use syntax::ast::{CRATE_NODE_ID, Arm, IsAsync, BindingMode, Block, Crate, Expr, ExprKind};\n use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, GenericParamKind, Generics};\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Label, Local, Mutability, Pat, PatKind, Path};\n@@ -1891,7 +1891,12 @@ impl<'a> Resolver<'a> {\n \n         ident.span = ident.span.modern();\n         loop {\n-            module = unwrap_or!(self.hygienic_lexical_parent(module, &mut ident.span), break);\n+            let (opt_module, poisoned) = if record_used {\n+                self.hygienic_lexical_parent_with_compatibility_fallback(module, &mut ident.span)\n+            } else {\n+                (self.hygienic_lexical_parent(module, &mut ident.span), false)\n+            };\n+            module = unwrap_or!(opt_module, break);\n             let orig_current_module = self.current_module;\n             self.current_module = module; // Lexical resolutions can never be a privacy error.\n             let result = self.resolve_ident_in_module_unadjusted(\n@@ -1900,7 +1905,19 @@ impl<'a> Resolver<'a> {\n             self.current_module = orig_current_module;\n \n             match result {\n-                Ok(binding) => return Some(LexicalScopeBinding::Item(binding)),\n+                Ok(binding) => {\n+                    if poisoned {\n+                        self.session.buffer_lint_with_diagnostic(\n+                            lint::builtin::PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n+                            CRATE_NODE_ID, ident.span,\n+                            &format!(\"cannot find {} `{}` in this scope\", ns.descr(), ident),\n+                            lint::builtin::BuiltinLintDiagnostics::\n+                                ProcMacroDeriveResolutionFallback(ident.span),\n+                        );\n+                    }\n+                    return Some(LexicalScopeBinding::Item(binding))\n+                }\n+                _ if poisoned => break,\n                 Err(Undetermined) => return None,\n                 Err(Determined) => {}\n             }\n@@ -1935,7 +1952,7 @@ impl<'a> Resolver<'a> {\n         None\n     }\n \n-    fn hygienic_lexical_parent(&mut self, mut module: Module<'a>, span: &mut Span)\n+    fn hygienic_lexical_parent(&mut self, module: Module<'a>, span: &mut Span)\n                                -> Option<Module<'a>> {\n         if !module.expansion.is_descendant_of(span.ctxt().outer()) {\n             return Some(self.macro_def_scope(span.remove_mark()));\n@@ -1945,22 +1962,41 @@ impl<'a> Resolver<'a> {\n             return Some(module.parent.unwrap());\n         }\n \n-        let mut module_expansion = module.expansion.modern(); // for backward compatibility\n-        while let Some(parent) = module.parent {\n-            let parent_expansion = parent.expansion.modern();\n-            if module_expansion.is_descendant_of(parent_expansion) &&\n-               parent_expansion != module_expansion {\n-                return if parent_expansion.is_descendant_of(span.ctxt().outer()) {\n-                    Some(parent)\n-                } else {\n-                    None\n-                };\n+        None\n+    }\n+\n+    fn hygienic_lexical_parent_with_compatibility_fallback(\n+        &mut self, module: Module<'a>, span: &mut Span) -> (Option<Module<'a>>, /* poisoned */ bool\n+    ) {\n+        if let module @ Some(..) = self.hygienic_lexical_parent(module, span) {\n+            return (module, false);\n+        }\n+\n+        // We need to support the next case under a deprecation warning\n+        // ```\n+        // struct MyStruct;\n+        // ---- begin: this comes from a proc macro derive\n+        // mod implementation_details {\n+        //     // Note that `MyStruct` is not in scope here.\n+        //     impl SomeTrait for MyStruct { ... }\n+        // }\n+        // ---- end\n+        // ```\n+        // So we have to fall back to the module's parent during lexical resolution in this case.\n+        if let Some(parent) = module.parent {\n+            // Inner module is inside the macro, parent module is outside of the macro.\n+            if module.expansion != parent.expansion &&\n+            module.expansion.is_descendant_of(parent.expansion) {\n+                // The macro is a proc macro derive\n+                if module.expansion.looks_like_proc_macro_derive() {\n+                    if parent.expansion.is_descendant_of(span.ctxt().outer()) {\n+                        return (module.parent, true);\n+                    }\n+                }\n             }\n-            module = parent;\n-            module_expansion = parent_expansion;\n         }\n \n-        None\n+        (None, false)\n     }\n \n     fn resolve_ident_in_module(&mut self,\n@@ -4037,8 +4073,9 @@ impl<'a> Resolver<'a> {\n         let mut search_module = self.current_module;\n         loop {\n             self.get_traits_in_module_containing_item(ident, ns, search_module, &mut found_traits);\n-            search_module =\n-                unwrap_or!(self.hygienic_lexical_parent(search_module, &mut ident.span), break);\n+            search_module = unwrap_or!(\n+                self.hygienic_lexical_parent(search_module, &mut ident.span), break\n+            );\n         }\n \n         if let Some(prelude) = self.prelude {\n@@ -4395,12 +4432,6 @@ impl<'a> Resolver<'a> {\n             (TypeNS, _) => \"type\",\n         };\n \n-        let namespace = match ns {\n-            ValueNS => \"value\",\n-            MacroNS => \"macro\",\n-            TypeNS => \"type\",\n-        };\n-\n         let msg = format!(\"the name `{}` is defined multiple times\", name);\n \n         let mut err = match (old_binding.is_extern_crate(), new_binding.is_extern_crate()) {\n@@ -4418,7 +4449,7 @@ impl<'a> Resolver<'a> {\n \n         err.note(&format!(\"`{}` must be defined only once in the {} namespace of this {}\",\n                           name,\n-                          namespace,\n+                          ns.descr(),\n                           container));\n \n         err.span_label(span, format!(\"`{}` re{} here\", name, new_participle));"}, {"sha": "c7076478332f4c01b1fb7c3ca22ef089576a0c99", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=fc74e359819002fad402f68728f6e5ba2d4cb704", "patch": "@@ -72,26 +72,16 @@ pub enum Transparency {\n }\n \n impl Mark {\n-    fn fresh_with_data(mark_data: MarkData, data: &mut HygieneData) -> Self {\n-        data.marks.push(mark_data);\n-        Mark(data.marks.len() as u32 - 1)\n-    }\n-\n     pub fn fresh(parent: Mark) -> Self {\n         HygieneData::with(|data| {\n-            Mark::fresh_with_data(MarkData {\n+            data.marks.push(MarkData {\n                 parent,\n                 // By default expansions behave like `macro_rules`.\n                 default_transparency: Transparency::SemiTransparent,\n                 is_builtin: false,\n                 expn_info: None,\n-            }, data)\n-        })\n-    }\n-\n-    pub fn fresh_cloned(clone_from: Mark) -> Self {\n-        HygieneData::with(|data| {\n-            Mark::fresh_with_data(data.marks[clone_from.0 as usize].clone(), data)\n+            });\n+            Mark(data.marks.len() as u32 - 1)\n         })\n     }\n \n@@ -128,17 +118,6 @@ impl Mark {\n         })\n     }\n \n-    // FIXME: This operation doesn't really make sense when single macro expansion\n-    // can produce tokens with different transparencies. Figure out how to avoid it.\n-    pub fn modern(mut self) -> Mark {\n-        HygieneData::with(|data| {\n-            while data.marks[self.0 as usize].default_transparency != Transparency::Opaque {\n-                self = data.marks[self.0 as usize].parent;\n-            }\n-            self\n-        })\n-    }\n-\n     #[inline]\n     pub fn set_default_transparency(self, transparency: Transparency) {\n         assert_ne!(self, Mark::root());\n@@ -194,6 +173,24 @@ impl Mark {\n             b\n         })\n     }\n+\n+    // Used for enabling some compatibility fallback in resolve.\n+    #[inline]\n+    pub fn looks_like_proc_macro_derive(self) -> bool {\n+        HygieneData::with(|data| {\n+            let mark_data = &data.marks[self.0 as usize];\n+            if mark_data.default_transparency == Transparency::Opaque {\n+                if let Some(expn_info) = &mark_data.expn_info {\n+                    if let ExpnFormat::MacroAttribute(name) = expn_info.format {\n+                        if name.as_str().starts_with(\"derive(\") {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+            false\n+        })\n+    }\n }\n \n #[derive(Debug)]\n@@ -285,6 +282,7 @@ impl SyntaxContext {\n         })\n     }\n \n+    /// Extend a syntax context with a given mark and default transparency for that mark.\n     pub fn apply_mark(self, mark: Mark) -> SyntaxContext {\n         assert_ne!(mark, Mark::root());\n         self.apply_mark_with_transparency("}, {"sha": "6a8d545db49b966241cf62aaa97b36f350907391", "filename": "src/test/ui-fulldeps/proc-macro/auxiliary/generate-mod.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fgenerate-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fgenerate-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fgenerate-mod.rs?ref=fc74e359819002fad402f68728f6e5ba2d4cb704", "patch": "@@ -20,9 +20,35 @@ use proc_macro::*;\n #[proc_macro]\n pub fn check(_: TokenStream) -> TokenStream {\n     \"\n+    type Alias = FromOutside; // OK\n     struct Outer;\n     mod inner {\n+        type Alias = FromOutside; // `FromOutside` shouldn't be available from here\n         type Inner = Outer; // `Outer` shouldn't be available from here\n     }\n     \".parse().unwrap()\n }\n+\n+#[proc_macro_attribute]\n+pub fn check_attr(_: TokenStream, _: TokenStream) -> TokenStream {\n+    \"\n+    type AliasAttr = FromOutside; // OK\n+    struct OuterAttr;\n+    mod inner_attr {\n+        type Alias = FromOutside; // `FromOutside` shouldn't be available from here\n+        type Inner = OuterAttr; // `OuterAttr` shouldn't be available from here\n+    }\n+    \".parse().unwrap()\n+}\n+\n+#[proc_macro_derive(CheckDerive)]\n+pub fn check_derive(_: TokenStream) -> TokenStream {\n+    \"\n+    type AliasDerive = FromOutside; // OK\n+    struct OuterDerive;\n+    mod inner_derive {\n+        type Alias = FromOutside; // `FromOutside` shouldn't be available from here\n+        type Inner = OuterDerive; // `OuterDerive` shouldn't be available from here\n+    }\n+    \".parse().unwrap()\n+}"}, {"sha": "ff64421047fb8b4b7799f3bdae6379af4934600d", "filename": "src/test/ui-fulldeps/proc-macro/generate-mod.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.rs?ref=fc74e359819002fad402f68728f6e5ba2d4cb704", "patch": "@@ -12,10 +12,23 @@\n \n // aux-build:generate-mod.rs\n \n-#![feature(proc_macro, proc_macro_gen)]\n+#![feature(proc_macro, proc_macro_gen, proc_macro_path_invoc)]\n \n extern crate generate_mod;\n \n-generate_mod::check!(); //~ ERROR cannot find type `Outer` in this scope\n+struct FromOutside;\n+\n+generate_mod::check!(); //~ ERROR cannot find type `FromOutside` in this scope\n+                        //~| ERROR cannot find type `Outer` in this scope\n+\n+#[generate_mod::check_attr] //~ ERROR cannot find type `FromOutside` in this scope\n+                            //~| ERROR cannot find type `OuterAttr` in this scope\n+struct S;\n+\n+#[derive(generate_mod::CheckDerive)] //~ WARN cannot find type `FromOutside` in this scope\n+                                     //~| WARN cannot find type `OuterDerive` in this scope\n+                                     //~| WARN this was previously accepted\n+                                     //~| WARN this was previously accepted\n+struct Z;\n \n fn main() {}"}, {"sha": "c024aeffbb08675a33f0c1ad24e213f2e47a285b", "filename": "src/test/ui-fulldeps/proc-macro/generate-mod.stderr", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.stderr?ref=fc74e359819002fad402f68728f6e5ba2d4cb704", "patch": "@@ -1,9 +1,46 @@\n+error[E0412]: cannot find type `FromOutside` in this scope\n+  --> $DIR/generate-mod.rs:21:1\n+   |\n+LL | generate_mod::check!(); //~ ERROR cannot find type `FromOutside` in this scope\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n+\n error[E0412]: cannot find type `Outer` in this scope\n-  --> $DIR/generate-mod.rs:19:1\n+  --> $DIR/generate-mod.rs:21:1\n    |\n-LL | generate_mod::check!(); //~ ERROR cannot find type `Outer` in this scope\n+LL | generate_mod::check!(); //~ ERROR cannot find type `FromOutside` in this scope\n    | ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n \n-error: aborting due to previous error\n+error[E0412]: cannot find type `FromOutside` in this scope\n+  --> $DIR/generate-mod.rs:24:1\n+   |\n+LL | #[generate_mod::check_attr] //~ ERROR cannot find type `FromOutside` in this scope\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `OuterAttr` in this scope\n+  --> $DIR/generate-mod.rs:24:1\n+   |\n+LL | #[generate_mod::check_attr] //~ ERROR cannot find type `FromOutside` in this scope\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n+\n+warning: cannot find type `FromOutside` in this scope\n+  --> $DIR/generate-mod.rs:28:10\n+   |\n+LL | #[derive(generate_mod::CheckDerive)] //~ WARN cannot find type `FromOutside` in this scope\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n+   |\n+   = note: #[warn(proc_macro_derive_resolution_fallback)] on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #50504 <https://github.com/rust-lang/rust/issues/50504>\n+\n+warning: cannot find type `OuterDerive` in this scope\n+  --> $DIR/generate-mod.rs:28:10\n+   |\n+LL | #[derive(generate_mod::CheckDerive)] //~ WARN cannot find type `FromOutside` in this scope\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #50504 <https://github.com/rust-lang/rust/issues/50504>\n+\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0412`."}, {"sha": "958133e7ec5891b30a4ef2d93dba768df61c1947", "filename": "src/test/ui/hygiene/arguments.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Ftest%2Fui%2Fhygiene%2Farguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Ftest%2Fui%2Fhygiene%2Farguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Farguments.rs?ref=fc74e359819002fad402f68728f6e5ba2d4cb704", "patch": "@@ -23,5 +23,5 @@ macro m($t:ty, $e:expr) {\n \n fn main() {\n     struct S;\n-    m!(S, S);\n+    m!(S, S); //~ ERROR cannot find type `S` in this scope\n }", "previous_filename": "src/test/run-pass/hygiene/arguments.rs"}, {"sha": "1b0c23eff297e95cdceb12391892f124f9ea3c79", "filename": "src/test/ui/hygiene/arguments.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Ftest%2Fui%2Fhygiene%2Farguments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Ftest%2Fui%2Fhygiene%2Farguments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Farguments.stderr?ref=fc74e359819002fad402f68728f6e5ba2d4cb704", "patch": "@@ -0,0 +1,9 @@\n+error[E0412]: cannot find type `S` in this scope\n+  --> $DIR/arguments.rs:26:8\n+   |\n+LL |     m!(S, S); //~ ERROR cannot find type `S` in this scope\n+   |        ^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0412`."}, {"sha": "2b2108558a0f385908c02d0b9b75a3f1afd8badd", "filename": "src/test/ui/hygiene/generate-mod.rs", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.rs?ref=fc74e359819002fad402f68728f6e5ba2d4cb704", "patch": "@@ -12,13 +12,46 @@\n \n #![feature(decl_macro, rustc_attrs)]\n \n+macro genmod($FromOutside: ident, $Outer: ident) {\n+    type A = $FromOutside;\n+    struct $Outer;\n+    mod inner {\n+        type A = $FromOutside; // `FromOutside` shouldn't be available from here\n+        type Inner = $Outer; // `Outer` shouldn't be available from here\n+    }\n+}\n+\n #[rustc_transparent_macro]\n-macro genmod() {\n-    mod m {\n-        type A = S; //~ ERROR cannot find type `S` in this scope\n+macro genmod_transparent() {\n+    type A = FromOutside;\n+    struct Outer;\n+    mod inner {\n+        type A = FromOutside; //~ ERROR cannot find type `FromOutside` in this scope\n+        type Inner = Outer; //~ ERROR cannot find type `Outer` in this scope\n     }\n }\n \n-struct S;\n+macro_rules! genmod_legacy { () => {\n+    type A = FromOutside;\n+    struct Outer;\n+    mod inner {\n+        type A = FromOutside; //~ ERROR cannot find type `FromOutside` in this scope\n+        type Inner = Outer; //~ ERROR cannot find type `Outer` in this scope\n+    }\n+}}\n \n-genmod!();\n+fn check() {\n+    struct FromOutside;\n+    genmod!(FromOutside, Outer); //~ ERROR cannot find type `FromOutside` in this scope\n+                                 //~| ERROR cannot find type `Outer` in this scope\n+}\n+\n+fn check_transparent() {\n+    struct FromOutside;\n+    genmod_transparent!();\n+}\n+\n+fn check_legacy() {\n+    struct FromOutside;\n+    genmod_legacy!();\n+}"}, {"sha": "0c5905c5acb4fdc9ba2f93595feabfc269f30b66", "filename": "src/test/ui/hygiene/generate-mod.stderr", "status": "modified", "additions": 46, "deletions": 7, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.stderr?ref=fc74e359819002fad402f68728f6e5ba2d4cb704", "patch": "@@ -1,17 +1,56 @@\n-error[E0412]: cannot find type `S` in this scope\n-  --> $DIR/generate-mod.rs:18:18\n+error[E0412]: cannot find type `FromOutside` in this scope\n+  --> $DIR/generate-mod.rs:45:13\n    |\n-LL |         type A = S; //~ ERROR cannot find type `S` in this scope\n-   |                  ^ did you mean `A`?\n+LL |     genmod!(FromOutside, Outer); //~ ERROR cannot find type `FromOutside` in this scope\n+   |             ^^^^^^^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `Outer` in this scope\n+  --> $DIR/generate-mod.rs:45:26\n+   |\n+LL |     genmod!(FromOutside, Outer); //~ ERROR cannot find type `FromOutside` in this scope\n+   |                          ^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `FromOutside` in this scope\n+  --> $DIR/generate-mod.rs:29:18\n+   |\n+LL |         type A = FromOutside; //~ ERROR cannot find type `FromOutside` in this scope\n+   |                  ^^^^^^^^^^^ not found in this scope\n+...\n+LL |     genmod_transparent!();\n+   |     ---------------------- in this macro invocation\n+\n+error[E0412]: cannot find type `Outer` in this scope\n+  --> $DIR/generate-mod.rs:30:22\n+   |\n+LL |         type Inner = Outer; //~ ERROR cannot find type `Outer` in this scope\n+   |                      ^^^^^ not found in this scope\n+...\n+LL |     genmod_transparent!();\n+   |     ---------------------- in this macro invocation\n+\n+error[E0412]: cannot find type `FromOutside` in this scope\n+  --> $DIR/generate-mod.rs:38:18\n+   |\n+LL |         type A = FromOutside; //~ ERROR cannot find type `FromOutside` in this scope\n+   |                  ^^^^^^^^^^^ not found in this scope\n+...\n+LL |     genmod_legacy!();\n+   |     ----------------- in this macro invocation\n+\n+error[E0412]: cannot find type `Outer` in this scope\n+  --> $DIR/generate-mod.rs:39:22\n+   |\n+LL |         type Inner = Outer; //~ ERROR cannot find type `Outer` in this scope\n+   |                      ^^^^^ not found in this scope\n ...\n-LL | genmod!();\n-   | ---------- in this macro invocation\n+LL |     genmod_legacy!();\n+   |     ----------------- in this macro invocation\n \n error[E0601]: `main` function not found in crate `generate_mod`\n    |\n    = note: consider adding a `main` function to `$DIR/generate-mod.rs`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 7 previous errors\n \n Some errors occurred: E0412, E0601.\n For more information about an error, try `rustc --explain E0412`."}, {"sha": "9785ce6c0048eae04227e9dc0a34130237f751b9", "filename": "src/test/ui/hygiene/globs.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Ftest%2Fui%2Fhygiene%2Fglobs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Ftest%2Fui%2Fhygiene%2Fglobs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fglobs.rs?ref=fc74e359819002fad402f68728f6e5ba2d4cb704", "patch": "@@ -57,12 +57,26 @@ macro n($i:ident) {\n                 }\n             }\n         }\n+        macro n_with_super($j:ident) {\n+            mod test {\n+                use super::*;\n+                fn g() {\n+                    let _: u32 = $i();\n+                    let _: () = f();\n+                    super::$j();\n+                }\n+            }\n+        }\n \n-        n!(f);\n+        n!(f); //~ ERROR cannot find function `f` in this scope\n+        n_with_super!(f);\n         mod test2 {\n             super::n! {\n                 f //~ ERROR cannot find function `f` in this scope\n             }\n+            super::n_with_super! {\n+                f\n+            }\n         }\n     }\n }"}, {"sha": "7df2e31f9a752f79edac498a4564590ebd7f61a5", "filename": "src/test/ui/hygiene/globs.stderr", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Ftest%2Fui%2Fhygiene%2Fglobs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fc74e359819002fad402f68728f6e5ba2d4cb704/src%2Ftest%2Fui%2Fhygiene%2Fglobs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fglobs.stderr?ref=fc74e359819002fad402f68728f6e5ba2d4cb704", "patch": "@@ -30,20 +30,30 @@ LL | use bar::g;\n    |\n LL | use foo::test2::test::g;\n    |\n-LL | use foo::test::g;\n+LL | use foo::test2::test::g;\n    |\n LL | use foo::test::g;\n    |\n+and 2 other candidates\n+\n+error[E0425]: cannot find function `f` in this scope\n+  --> $DIR/globs.rs:71:12\n+   |\n+LL | n!(f);\n+   | ------ in this macro invocation\n+...\n+LL |         n!(f); //~ ERROR cannot find function `f` in this scope\n+   |            ^ not found in this scope\n \n error[E0425]: cannot find function `f` in this scope\n-  --> $DIR/globs.rs:64:17\n+  --> $DIR/globs.rs:75:17\n    |\n LL | n!(f);\n    | ------ in this macro invocation\n ...\n LL |                 f //~ ERROR cannot find function `f` in this scope\n    |                 ^ not found in this scope\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0425`."}]}