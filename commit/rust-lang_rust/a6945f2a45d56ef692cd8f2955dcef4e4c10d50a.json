{"sha": "a6945f2a45d56ef692cd8f2955dcef4e4c10d50a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2OTQ1ZjJhNDVkNTZlZjY5MmNkOGYyOTU1ZGNlZjRlNGMxMGQ1MGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-17T07:30:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-17T07:30:38Z"}, "message": "auto merge of #4993 : thestinger/rust/deque, r=graydon\n\nCloses #3748 and #2343.", "tree": {"sha": "5bcd877190d28af911f00d1263774272f7a4de75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5bcd877190d28af911f00d1263774272f7a4de75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6945f2a45d56ef692cd8f2955dcef4e4c10d50a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6945f2a45d56ef692cd8f2955dcef4e4c10d50a", "html_url": "https://github.com/rust-lang/rust/commit/a6945f2a45d56ef692cd8f2955dcef4e4c10d50a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6945f2a45d56ef692cd8f2955dcef4e4c10d50a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ea05a4d3e5a8ca5a5ca9585f88d3fadda83b60c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ea05a4d3e5a8ca5a5ca9585f88d3fadda83b60c", "html_url": "https://github.com/rust-lang/rust/commit/9ea05a4d3e5a8ca5a5ca9585f88d3fadda83b60c"}, {"sha": "8b38e07f24c5aeb817a2c83d8207016308550fa6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b38e07f24c5aeb817a2c83d8207016308550fa6", "html_url": "https://github.com/rust-lang/rust/commit/8b38e07f24c5aeb817a2c83d8207016308550fa6"}], "stats": {"total": 312, "additions": 145, "deletions": 167}, "files": [{"sha": "2c90100a6f6543063402196616901ad56362ac44", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 138, "deletions": 158, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/a6945f2a45d56ef692cd8f2955dcef4e4c10d50a/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6945f2a45d56ef692cd8f2955dcef4e4c10d50a/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=a6945f2a45d56ef692cd8f2955dcef4e4c10d50a", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,178 +8,158 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A deque. Untested as of yet. Likely buggy\n-#[forbid(non_camel_case_types)];\n-\n+use core::container::{Container, Mutable};\n use core::cmp::Eq;\n-use core::dvec::DVec;\n-use core::dvec;\n use core::prelude::*;\n use core::uint;\n use core::vec;\n \n-pub trait Deque<T> {\n-    fn size() -> uint;\n-    fn add_front(v: T);\n-    fn add_back(v: T);\n-    fn pop_front() -> T;\n-    fn pop_back() -> T;\n-    fn peek_front() -> T;\n-    fn peek_back() -> T;\n-    fn get(int) -> T;\n+const initial_capacity: uint = 32u; // 2^5\n+\n+pub struct Deque<T> {\n+    priv nelts: uint,\n+    priv lo: uint,\n+    priv hi: uint,\n+    priv elts: ~[Option<T>]\n }\n \n-// FIXME (#2343) eventually, a proper datatype plus an exported impl would\n-// be preferrable.\n-pub fn create<T: Copy>() -> Deque<T> {\n-    type Cell<T> = Option<T>;\n+impl<T> Container for Deque<T> {\n+    pure fn len(&self) -> uint { self.nelts }\n+    pure fn is_empty(&self) -> bool { self.len() == 0 }\n+}\n \n-    let initial_capacity: uint = 32u; // 2^5\n-     /**\n-      * Grow is only called on full elts, so nelts is also len(elts), unlike\n-      * elsewhere.\n-      */\n-    fn grow<T: Copy>(nelts: uint, lo: uint, elts: ~[Cell<T>])\n-      -> ~[Cell<T>] {\n-        let mut elts = elts;\n-        assert (nelts == vec::len(elts));\n-        let mut rv = ~[];\n+impl<T> Mutable for Deque<T> {\n+    fn clear(&mut self) {\n+        for vec::each_mut(self.elts) |x| { *x = None }\n+        self.nelts = 0;\n+        self.lo = 0;\n+        self.hi = 0;\n+    }\n+}\n \n-        let mut i = 0u;\n-        let nalloc = uint::next_power_of_two(nelts + 1u);\n-        while i < nalloc {\n-            if i < nelts {\n-                rv.push(elts[(lo + i) % nelts]);\n-            } else { rv.push(None); }\n-            i += 1u;\n-        }\n+impl<T> Deque<T> {\n+    static pure fn new() -> Deque<T> {\n+        Deque{nelts: 0, lo: 0, hi: 0,\n+              elts: vec::from_fn(initial_capacity, |_| None)}\n+    }\n+\n+    fn peek_front(&self) -> &self/T { get(self.elts, self.lo) }\n+    fn peek_back(&self) -> &self/T { get(self.elts, self.hi - 1u) }\n \n-        rv\n+    fn get(&self, i: int) -> &self/T {\n+        let idx = (self.lo + (i as uint)) % self.elts.len();\n+        get(self.elts, idx)\n     }\n-    fn get<T: Copy>(elts: &DVec<Cell<T>>, i: uint) -> T {\n-        match (*elts).get_elt(i) { Some(t) => t, _ => fail!() }\n+\n+    fn pop_front(&mut self) -> T {\n+        let mut result = self.elts[self.lo].swap_unwrap();\n+        self.lo = (self.lo + 1u) % self.elts.len();\n+        self.nelts -= 1u;\n+        result\n     }\n \n-    struct Repr<T> {\n-        mut nelts: uint,\n-        mut lo: uint,\n-        mut hi: uint,\n-        elts: DVec<Cell<T>>,\n+    fn pop_back(&mut self) -> T {\n+        if self.hi == 0u {\n+            self.hi = self.elts.len() - 1u;\n+        } else { self.hi -= 1u; }\n+        let mut result = self.elts[self.hi].swap_unwrap();\n+        self.elts[self.hi] = None;\n+        self.nelts -= 1u;\n+        result\n     }\n \n-    impl<T: Copy> Deque<T> for Repr<T> {\n-        fn size() -> uint { return self.nelts; }\n-        fn add_front(t: T) {\n-            let oldlo: uint = self.lo;\n-            if self.lo == 0u {\n-                self.lo = self.elts.len() - 1u;\n-            } else { self.lo -= 1u; }\n-            if self.lo == self.hi {\n-                self.elts.swap(|v| grow(self.nelts, oldlo, v));\n-                self.lo = self.elts.len() - 1u;\n-                self.hi = self.nelts;\n-            }\n-            self.elts.set_elt(self.lo, Some(t));\n-            self.nelts += 1u;\n-        }\n-        fn add_back(t: T) {\n-            if self.lo == self.hi && self.nelts != 0u {\n-                self.elts.swap(|v| grow(self.nelts, self.lo, v));\n-                self.lo = 0u;\n-                self.hi = self.nelts;\n-            }\n-            self.elts.set_elt(self.hi, Some(t));\n-            self.hi = (self.hi + 1u) % self.elts.len();\n-            self.nelts += 1u;\n-        }\n-        /**\n-         * We actually release (turn to none()) the T we're popping so\n-         * that we don't keep anyone's refcount up unexpectedly.\n-         */\n-        fn pop_front() -> T {\n-            let t: T = get(&self.elts, self.lo);\n-            self.elts.set_elt(self.lo, None);\n-            self.lo = (self.lo + 1u) % self.elts.len();\n-            self.nelts -= 1u;\n-            return t;\n-        }\n-        fn pop_back() -> T {\n-            if self.hi == 0u {\n-                self.hi = self.elts.len() - 1u;\n-            } else { self.hi -= 1u; }\n-            let t: T = get(&self.elts, self.hi);\n-            self.elts.set_elt(self.hi, None);\n-            self.nelts -= 1u;\n-            return t;\n+    fn add_front(&mut self, t: T) {\n+        let oldlo = self.lo;\n+        if self.lo == 0u {\n+            self.lo = self.elts.len() - 1u;\n+        } else { self.lo -= 1u; }\n+        if self.lo == self.hi {\n+            self.elts = grow(self.nelts, oldlo, self.elts);\n+            self.lo = self.elts.len() - 1u;\n+            self.hi = self.nelts;\n         }\n-        fn peek_front() -> T { return get(&self.elts, self.lo); }\n-        fn peek_back() -> T { return get(&self.elts, self.hi - 1u); }\n-        fn get(i: int) -> T {\n-            let idx = (self.lo + (i as uint)) % self.elts.len();\n-            return get(&self.elts, idx);\n+        self.elts[self.lo] = Some(t);\n+        self.nelts += 1u;\n+    }\n+\n+    fn add_back(&mut self, t: T) {\n+        if self.lo == self.hi && self.nelts != 0u {\n+            self.elts = grow(self.nelts, self.lo, self.elts);\n+            self.lo = 0u;\n+            self.hi = self.nelts;\n         }\n+        self.elts[self.hi] = Some(t);\n+        self.hi = (self.hi + 1u) % self.elts.len();\n+        self.nelts += 1u;\n+    }\n+}\n+\n+/// Grow is only called on full elts, so nelts is also len(elts), unlike\n+/// elsewhere.\n+fn grow<T>(nelts: uint, lo: uint, elts: &mut [Option<T>]) -> ~[Option<T>] {\n+    assert nelts == elts.len();\n+    let mut rv = ~[];\n+\n+    do vec::grow_fn(&mut rv, nelts + 1) |i| {\n+        let mut element = None;\n+        element <-> elts[(lo + i) % nelts];\n+        element\n     }\n \n-    let repr: Repr<T> = Repr {\n-        nelts: 0u,\n-        lo: 0u,\n-        hi: 0u,\n-        elts: dvec::from_vec(vec::from_elem(initial_capacity, None)),\n-    };\n+    rv\n+}\n \n-    repr as Deque::<T>\n+fn get<T>(elts: &r/[Option<T>], i: uint) -> &r/T {\n+    match elts[i] { Some(ref t) => t, _ => fail!() }\n }\n \n #[cfg(test)]\n mod tests {\n-    use core::prelude::*;\n-\n-    use deque::*;\n-    use deque;\n+    use super::*;\n \n     #[test]\n     fn test_simple() {\n-        let d: deque::Deque<int> = deque::create::<int>();\n-        assert (d.size() == 0u);\n+        let mut d = Deque::new();\n+        assert d.len() == 0u;\n         d.add_front(17);\n         d.add_front(42);\n         d.add_back(137);\n-        assert (d.size() == 3u);\n+        assert d.len() == 3u;\n         d.add_back(137);\n-        assert (d.size() == 4u);\n+        assert d.len() == 4u;\n         log(debug, d.peek_front());\n-        assert (d.peek_front() == 42);\n+        assert *d.peek_front() == 42;\n         log(debug, d.peek_back());\n-        assert (d.peek_back() == 137);\n+        assert *d.peek_back() == 137;\n         let mut i: int = d.pop_front();\n         log(debug, i);\n-        assert (i == 42);\n+        assert i == 42;\n         i = d.pop_back();\n         log(debug, i);\n-        assert (i == 137);\n+        assert i == 137;\n         i = d.pop_back();\n         log(debug, i);\n-        assert (i == 137);\n+        assert i == 137;\n         i = d.pop_back();\n         log(debug, i);\n-        assert (i == 17);\n-        assert (d.size() == 0u);\n+        assert i == 17;\n+        assert d.len() == 0u;\n         d.add_back(3);\n-        assert (d.size() == 1u);\n+        assert d.len() == 1u;\n         d.add_front(2);\n-        assert (d.size() == 2u);\n+        assert d.len() == 2u;\n         d.add_back(4);\n-        assert (d.size() == 3u);\n+        assert d.len() == 3u;\n         d.add_front(1);\n-        assert (d.size() == 4u);\n+        assert d.len() == 4u;\n         log(debug, d.get(0));\n         log(debug, d.get(1));\n         log(debug, d.get(2));\n         log(debug, d.get(3));\n-        assert (d.get(0) == 1);\n-        assert (d.get(1) == 2);\n-        assert (d.get(2) == 3);\n-        assert (d.get(3) == 4);\n+        assert *d.get(0) == 1;\n+        assert *d.get(1) == 2;\n+        assert *d.get(2) == 3;\n+        assert *d.get(3) == 4;\n     }\n \n     #[test]\n@@ -189,63 +169,63 @@ mod tests {\n         let c: @int = @64;\n         let d: @int = @175;\n \n-        let deq: deque::Deque<@int> = deque::create::<@int>();\n-        assert (deq.size() == 0u);\n+        let mut deq = Deque::new();\n+        assert deq.len() == 0;\n         deq.add_front(a);\n         deq.add_front(b);\n         deq.add_back(c);\n-        assert (deq.size() == 3u);\n+        assert deq.len() == 3;\n         deq.add_back(d);\n-        assert (deq.size() == 4u);\n-        assert (deq.peek_front() == b);\n-        assert (deq.peek_back() == d);\n-        assert (deq.pop_front() == b);\n-        assert (deq.pop_back() == d);\n-        assert (deq.pop_back() == c);\n-        assert (deq.pop_back() == a);\n-        assert (deq.size() == 0u);\n+        assert deq.len() == 4;\n+        assert *deq.peek_front() == b;\n+        assert *deq.peek_back() == d;\n+        assert deq.pop_front() == b;\n+        assert deq.pop_back() == d;\n+        assert deq.pop_back() == c;\n+        assert deq.pop_back() == a;\n+        assert deq.len() == 0;\n         deq.add_back(c);\n-        assert (deq.size() == 1u);\n+        assert deq.len() == 1;\n         deq.add_front(b);\n-        assert (deq.size() == 2u);\n+        assert deq.len() == 2;\n         deq.add_back(d);\n-        assert (deq.size() == 3u);\n+        assert deq.len() == 3;\n         deq.add_front(a);\n-        assert (deq.size() == 4u);\n-        assert (deq.get(0) == a);\n-        assert (deq.get(1) == b);\n-        assert (deq.get(2) == c);\n-        assert (deq.get(3) == d);\n+        assert deq.len() == 4;\n+        assert *deq.get(0) == a;\n+        assert *deq.get(1) == b;\n+        assert *deq.get(2) == c;\n+        assert *deq.get(3) == d;\n     }\n \n     fn test_parameterized<T: Copy Eq Durable>(a: T, b: T, c: T, d: T) {\n-        let deq: deque::Deque<T> = deque::create::<T>();\n-        assert (deq.size() == 0u);\n+        let mut deq = Deque::new();\n+        assert deq.len() == 0;\n         deq.add_front(a);\n         deq.add_front(b);\n         deq.add_back(c);\n-        assert (deq.size() == 3u);\n+        assert deq.len() == 3;\n         deq.add_back(d);\n-        assert (deq.size() == 4u);\n-        assert deq.peek_front() == b;\n-        assert deq.peek_back() == d;\n+        assert deq.len() == 4;\n+        assert *deq.peek_front() == b;\n+        assert *deq.peek_back() == d;\n         assert deq.pop_front() == b;\n         assert deq.pop_back() == d;\n         assert deq.pop_back() == c;\n         assert deq.pop_back() == a;\n-        assert (deq.size() == 0u);\n+        assert deq.len() == 0;\n         deq.add_back(c);\n-        assert (deq.size() == 1u);\n+        assert deq.len() == 1;\n         deq.add_front(b);\n-        assert (deq.size() == 2u);\n+        assert deq.len() == 2;\n         deq.add_back(d);\n-        assert (deq.size() == 3u);\n+        assert deq.len() == 3;\n         deq.add_front(a);\n-        assert (deq.size() == 4u);\n-        assert deq.get(0) == a;\n-        assert deq.get(1) == b;\n-        assert deq.get(2) == c;\n-        assert deq.get(3) == d;\n+        assert deq.len() == 4;\n+        assert *deq.get(0) == a;\n+        assert *deq.get(1) == b;\n+        assert *deq.get(2) == c;\n+        assert *deq.get(3) == d;\n     }\n \n     #[deriving_eq]"}, {"sha": "f1d5749e8402f84ce268180d744a9d1b5fc4a736", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a6945f2a45d56ef692cd8f2955dcef4e4c10d50a/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6945f2a45d56ef692cd8f2955dcef4e4c10d50a/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=a6945f2a45d56ef692cd8f2955dcef4e4c10d50a", "patch": "@@ -23,7 +23,6 @@ use std::time;\n use std::oldmap;\n use std::oldmap::Map;\n use std::oldmap::HashMap;\n-use std::deque;\n use std::deque::Deque;\n use std::par;\n use core::io::WriterUtil;\n@@ -124,18 +123,18 @@ fn bfs(graph: graph, key: node_id) -> bfs_result {\n     let mut marks : ~[node_id]\n         = vec::from_elem(vec::len(graph), -1i64);\n \n-    let Q = deque::create();\n+    let mut q = Deque::new();\n \n-    Q.add_back(key);\n+    q.add_back(key);\n     marks[key] = key;\n \n-    while Q.size() > 0 {\n-        let t = Q.pop_front();\n+    while !q.is_empty() {\n+        let t = q.pop_front();\n \n         do graph[t].each() |k| {\n             if marks[*k] == -1i64 {\n                 marks[*k] = t;\n-                Q.add_back(*k);\n+                q.add_back(*k);\n             }\n             true\n         };"}, {"sha": "a7afa1d6f349429ec9d7ea8c39f415894c73dec6", "filename": "src/test/run-pass/issue-2383.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a6945f2a45d56ef692cd8f2955dcef4e4c10d50a/src%2Ftest%2Frun-pass%2Fissue-2383.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6945f2a45d56ef692cd8f2955dcef4e4c10d50a/src%2Ftest%2Frun-pass%2Fissue-2383.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2383.rs?ref=a6945f2a45d56ef692cd8f2955dcef4e4c10d50a", "patch": "@@ -11,10 +11,9 @@\n // except according to those terms.\n \n extern mod std;\n-use std::deque;\n use std::deque::Deque;\n \n pub fn main() {\n-    let Q = deque::create();\n-    Q.add_back(10);\n+    let mut q = Deque::new();\n+    q.add_back(10);\n }"}]}