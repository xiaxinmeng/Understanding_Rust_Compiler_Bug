{"sha": "58c13e095e993d17563a8b5f1d30918d3614c097", "node_id": "C_kwDOAAsO6NoAKDU4YzEzZTA5NWU5OTNkMTc1NjNhOGI1ZjFkMzA5MThkMzYxNGMwOTc", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-11-08T05:53:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-08T05:53:52Z"}, "message": "Rollup merge of #103987 - compiler-errors:no-in_tail_expr, r=eholk\n\nRemove `in_tail_expr` from FnCtxt\n\nCleans up yet another unneeded member from `FnCtxt`. The `in_tail_expr` condition wasn't even correct -- it was set for true while typechecking the whole fn body.", "tree": {"sha": "0f465da8192e1c8a7b22620713b14908ae4f1df9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f465da8192e1c8a7b22620713b14908ae4f1df9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58c13e095e993d17563a8b5f1d30918d3614c097", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjae7wCRBK7hj4Ov3rIwAAXPEIAG1GtpQnRQQc95z4O9dzxy1x\n6hQNrbz7vFppoJ+QCYY8YGb7QkiKThjkdDFfCyeXdN3/f1dhs1uJlDgxND7ZXNmv\nieta2gQpOoMAvrDquwyk9LgA/7nunLsWaWHVRtyqzIYo79+g5vcrPmzD6jCDvmM2\nxJjc2rpxuBw3b3JYqj0ItjnubGjw+edjxaYZeAg0TJcHptE5b27PTWV4TDDt0isd\nlCGztCReH3m3PxNpp9p/l8rZYk/zyI0Nt3TzRTvTCEIedtp6MH46uuZI5g3wkADs\nPmVz6Xxwx+VSJtRMhFNizmDsMbPyEimM7PXeTt8wqHV+ylJW93U4yZ3NyXRB50w=\n=WWAZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 0f465da8192e1c8a7b22620713b14908ae4f1df9\nparent 799648a61f64d6254fcc9538a64ffe372ccda5f1\nparent a0cdc85b32765b6f227f6c7d9ae6e8cc661ab5d0\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1667886832 +0530\ncommitter GitHub <noreply@github.com> 1667886832 +0530\n\nRollup merge of #103987 - compiler-errors:no-in_tail_expr, r=eholk\n\nRemove `in_tail_expr` from FnCtxt\n\nCleans up yet another unneeded member from `FnCtxt`. The `in_tail_expr` condition wasn't even correct -- it was set for true while typechecking the whole fn body.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58c13e095e993d17563a8b5f1d30918d3614c097", "html_url": "https://github.com/rust-lang/rust/commit/58c13e095e993d17563a8b5f1d30918d3614c097", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58c13e095e993d17563a8b5f1d30918d3614c097/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "799648a61f64d6254fcc9538a64ffe372ccda5f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/799648a61f64d6254fcc9538a64ffe372ccda5f1", "html_url": "https://github.com/rust-lang/rust/commit/799648a61f64d6254fcc9538a64ffe372ccda5f1"}, {"sha": "a0cdc85b32765b6f227f6c7d9ae6e8cc661ab5d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0cdc85b32765b6f227f6c7d9ae6e8cc661ab5d0", "html_url": "https://github.com/rust-lang/rust/commit/a0cdc85b32765b6f227f6c7d9ae6e8cc661ab5d0"}], "stats": {"total": 130, "additions": 73, "deletions": 57}, "files": [{"sha": "6a4a6a5b0a546716721f3bf2d9ec77cbd0a6ed5a", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "modified", "additions": 73, "deletions": 50, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/58c13e095e993d17563a8b5f1d30918d3614c097/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58c13e095e993d17563a8b5f1d30918d3614c097/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=58c13e095e993d17563a8b5f1d30918d3614c097", "patch": "@@ -1,6 +1,6 @@\n use crate::coercion::{AsCoercionSite, CoerceMany};\n use crate::{Diverges, Expectation, FnCtxt, Needs};\n-use rustc_errors::{Applicability, MultiSpan};\n+use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir::{self as hir, ExprKind};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::traits::Obligation;\n@@ -137,55 +137,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Some(&arm.body),\n                 arm_ty,\n                 Some(&mut |err| {\n-                    let Some(ret) = self\n-                        .tcx\n-                        .hir()\n-                        .find_by_def_id(self.body_id.owner.def_id)\n-                        .and_then(|owner| owner.fn_decl())\n-                        .map(|decl| decl.output.span())\n-                    else { return; };\n-                    let Expectation::IsLast(stmt) = orig_expected else {\n-                        return\n-                    };\n-                    let can_coerce_to_return_ty = match self.ret_coercion.as_ref() {\n-                        Some(ret_coercion) if self.in_tail_expr => {\n-                            let ret_ty = ret_coercion.borrow().expected_ty();\n-                            let ret_ty = self.inh.infcx.shallow_resolve(ret_ty);\n-                            self.can_coerce(arm_ty, ret_ty)\n-                                && prior_arm.map_or(true, |(_, t, _)| self.can_coerce(t, ret_ty))\n-                                // The match arms need to unify for the case of `impl Trait`.\n-                                && !matches!(ret_ty.kind(), ty::Opaque(..))\n-                        }\n-                        _ => false,\n-                    };\n-                    if !can_coerce_to_return_ty {\n-                        return;\n-                    }\n-\n-                    let semi_span = expr.span.shrink_to_hi().with_hi(stmt.hi());\n-                    let mut ret_span: MultiSpan = semi_span.into();\n-                    ret_span.push_span_label(\n-                        expr.span,\n-                        \"this could be implicitly returned but it is a statement, not a \\\n-                            tail expression\",\n-                    );\n-                    ret_span\n-                        .push_span_label(ret, \"the `match` arms can conform to this return type\");\n-                    ret_span.push_span_label(\n-                        semi_span,\n-                        \"the `match` is a statement because of this semicolon, consider \\\n-                            removing it\",\n-                    );\n-                    err.span_note(\n-                        ret_span,\n-                        \"you might have meant to return the `match` expression\",\n-                    );\n-                    err.tool_only_span_suggestion(\n-                        semi_span,\n-                        \"remove this semicolon\",\n-                        \"\",\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                    self.suggest_removing_semicolon_for_coerce(\n+                        err,\n+                        expr,\n+                        orig_expected,\n+                        arm_ty,\n+                        prior_arm,\n+                    )\n                 }),\n                 false,\n             );\n@@ -219,6 +177,71 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         coercion.complete(self)\n     }\n \n+    fn suggest_removing_semicolon_for_coerce(\n+        &self,\n+        diag: &mut Diagnostic,\n+        expr: &hir::Expr<'tcx>,\n+        expectation: Expectation<'tcx>,\n+        arm_ty: Ty<'tcx>,\n+        prior_arm: Option<(Option<hir::HirId>, Ty<'tcx>, Span)>,\n+    ) {\n+        let hir = self.tcx.hir();\n+\n+        // First, check that we're actually in the tail of a function.\n+        let hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Block(block, _), .. }) =\n+            hir.get(self.body_id) else { return; };\n+        let Some(hir::Stmt { kind: hir::StmtKind::Semi(last_expr), .. })\n+            = block.innermost_block().stmts.last() else {  return; };\n+        if last_expr.hir_id != expr.hir_id {\n+            return;\n+        }\n+\n+        // Next, make sure that we have no type expectation.\n+        let Some(ret) = hir\n+            .find_by_def_id(self.body_id.owner.def_id)\n+            .and_then(|owner| owner.fn_decl())\n+            .map(|decl| decl.output.span()) else { return; };\n+        let Expectation::IsLast(stmt) = expectation else {\n+            return;\n+        };\n+\n+        let can_coerce_to_return_ty = match self.ret_coercion.as_ref() {\n+            Some(ret_coercion) => {\n+                let ret_ty = ret_coercion.borrow().expected_ty();\n+                let ret_ty = self.inh.infcx.shallow_resolve(ret_ty);\n+                self.can_coerce(arm_ty, ret_ty)\n+                    && prior_arm.map_or(true, |(_, ty, _)| self.can_coerce(ty, ret_ty))\n+                    // The match arms need to unify for the case of `impl Trait`.\n+                    && !matches!(ret_ty.kind(), ty::Opaque(..))\n+            }\n+            _ => false,\n+        };\n+        if !can_coerce_to_return_ty {\n+            return;\n+        }\n+\n+        let semi_span = expr.span.shrink_to_hi().with_hi(stmt.hi());\n+        let mut ret_span: MultiSpan = semi_span.into();\n+        ret_span.push_span_label(\n+            expr.span,\n+            \"this could be implicitly returned but it is a statement, not a \\\n+                            tail expression\",\n+        );\n+        ret_span.push_span_label(ret, \"the `match` arms can conform to this return type\");\n+        ret_span.push_span_label(\n+            semi_span,\n+            \"the `match` is a statement because of this semicolon, consider \\\n+                            removing it\",\n+        );\n+        diag.span_note(ret_span, \"you might have meant to return the `match` expression\");\n+        diag.tool_only_span_suggestion(\n+            semi_span,\n+            \"remove this semicolon\",\n+            \"\",\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+\n     /// When the previously checked expression (the scrutinee) diverges,\n     /// warn the user about the match arms being unreachable.\n     fn warn_arms_when_scrutinee_diverges(&self, arms: &'tcx [hir::Arm<'tcx>]) {"}, {"sha": "3c57e33f6f7fb164e10213569cf5a32cd538343c", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58c13e095e993d17563a8b5f1d30918d3614c097/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58c13e095e993d17563a8b5f1d30918d3614c097/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=58c13e095e993d17563a8b5f1d30918d3614c097", "patch": "@@ -100,7 +100,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n \n     inherited.typeck_results.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n \n-    fcx.in_tail_expr = true;\n     if let ty::Dynamic(..) = declared_ret_ty.kind() {\n         // FIXME: We need to verify that the return type is `Sized` after the return expression has\n         // been evaluated so that we have types available for all the nodes being returned, but that\n@@ -119,7 +118,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n         fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n         fcx.check_return_expr(&body.value, false);\n     }\n-    fcx.in_tail_expr = false;\n \n     // We insert the deferred_generator_interiors entry after visiting the body.\n     // This ensures that all nested generators appear before the entry of this generator."}, {"sha": "d5e4b6de581c3551a2af1020a282790f0807f431", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/58c13e095e993d17563a8b5f1d30918d3614c097/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58c13e095e993d17563a8b5f1d30918d3614c097/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=58c13e095e993d17563a8b5f1d30918d3614c097", "patch": "@@ -68,10 +68,6 @@ pub struct FnCtxt<'a, 'tcx> {\n     /// any).\n     pub(super) ret_coercion: Option<RefCell<DynamicCoerceMany<'tcx>>>,\n \n-    /// Used exclusively to reduce cost of advanced evaluation used for\n-    /// more helpful diagnostics.\n-    pub(super) in_tail_expr: bool,\n-\n     /// First span of a return site that we find. Used in error messages.\n     pub(super) ret_coercion_span: Cell<Option<Span>>,\n \n@@ -130,7 +126,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             param_env,\n             err_count_on_creation: inh.tcx.sess.err_count(),\n             ret_coercion: None,\n-            in_tail_expr: false,\n             ret_coercion_span: Cell::new(None),\n             resume_yield_tys: None,\n             ps: Cell::new(UnsafetyState::function(hir::Unsafety::Normal, hir::CRATE_HIR_ID)),"}]}