{"sha": "060e8cbaf1e3a57b97f96b13f702e04de4a5f1d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2MGU4Y2JhZjFlM2E1N2I5N2Y5NmIxM2Y3MDJlMDRkZTRhNWYxZDM=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-07T16:17:46Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-07T16:20:07Z"}, "message": "Get rid of raw pointers and UnsafeCell in cloudabi condvar.", "tree": {"sha": "6801c8eb25e8927db6d8735b37fe46ad4d655cc7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6801c8eb25e8927db6d8735b37fe46ad4d655cc7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/060e8cbaf1e3a57b97f96b13f702e04de4a5f1d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/060e8cbaf1e3a57b97f96b13f702e04de4a5f1d3", "html_url": "https://github.com/rust-lang/rust/commit/060e8cbaf1e3a57b97f96b13f702e04de4a5f1d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/060e8cbaf1e3a57b97f96b13f702e04de4a5f1d3/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41066beb4dd3a7618e1f7617d60704f5c4425bf7", "url": "https://api.github.com/repos/rust-lang/rust/commits/41066beb4dd3a7618e1f7617d60704f5c4425bf7", "html_url": "https://github.com/rust-lang/rust/commit/41066beb4dd3a7618e1f7617d60704f5c4425bf7"}], "stats": {"total": 41, "additions": 16, "deletions": 25}, "files": [{"sha": "4584b43809c467a391be90914941d8d0fb6a3a4a", "filename": "library/std/src/sys/cloudabi/condvar.rs", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/060e8cbaf1e3a57b97f96b13f702e04de4a5f1d3/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/060e8cbaf1e3a57b97f96b13f702e04de4a5f1d3/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fcondvar.rs?ref=060e8cbaf1e3a57b97f96b13f702e04de4a5f1d3", "patch": "@@ -1,4 +1,3 @@\n-use crate::cell::UnsafeCell;\n use crate::mem;\n use crate::sync::atomic::{AtomicU32, Ordering};\n use crate::sys::cloudabi::abi;\n@@ -12,37 +11,32 @@ extern \"C\" {\n }\n \n pub struct Condvar {\n-    condvar: UnsafeCell<AtomicU32>,\n+    condvar: AtomicU32,\n }\n \n pub type MovableCondvar = Condvar;\n \n unsafe impl Send for Condvar {}\n unsafe impl Sync for Condvar {}\n \n-const NEW: Condvar =\n-    Condvar { condvar: UnsafeCell::new(AtomicU32::new(abi::CONDVAR_HAS_NO_WAITERS.0)) };\n-\n impl Condvar {\n     pub const fn new() -> Condvar {\n-        NEW\n+        Condvar { condvar: AtomicU32::new(abi::CONDVAR_HAS_NO_WAITERS.0) }\n     }\n \n     pub unsafe fn init(&mut self) {}\n \n     pub unsafe fn notify_one(&self) {\n-        let condvar = self.condvar.get();\n-        if (*condvar).load(Ordering::Relaxed) != abi::CONDVAR_HAS_NO_WAITERS.0 {\n-            let ret = abi::condvar_signal(condvar as *mut abi::condvar, abi::scope::PRIVATE, 1);\n+        if self.condvar.load(Ordering::Relaxed) != abi::CONDVAR_HAS_NO_WAITERS.0 {\n+            let ret = abi::condvar_signal(&self.condvar as *const AtomicU32 as *mut abi::condvar, abi::scope::PRIVATE, 1);\n             assert_eq!(ret, abi::errno::SUCCESS, \"Failed to signal on condition variable\");\n         }\n     }\n \n     pub unsafe fn notify_all(&self) {\n-        let condvar = self.condvar.get();\n-        if (*condvar).load(Ordering::Relaxed) != abi::CONDVAR_HAS_NO_WAITERS.0 {\n+        if self.condvar.load(Ordering::Relaxed) != abi::CONDVAR_HAS_NO_WAITERS.0 {\n             let ret = abi::condvar_signal(\n-                condvar as *mut abi::condvar,\n+                &self.condvar as *const AtomicU32 as *mut abi::condvar,\n                 abi::scope::PRIVATE,\n                 abi::nthreads::MAX,\n             );\n@@ -53,20 +47,19 @@ impl Condvar {\n     pub unsafe fn wait(&self, mutex: &Mutex) {\n         let mutex = mutex::raw(mutex);\n         assert_eq!(\n-            (*mutex).load(Ordering::Relaxed) & !abi::LOCK_KERNEL_MANAGED.0,\n+            mutex.load(Ordering::Relaxed) & !abi::LOCK_KERNEL_MANAGED.0,\n             __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n             \"This lock is not write-locked by this thread\"\n         );\n \n         // Call into the kernel to wait on the condition variable.\n-        let condvar = self.condvar.get();\n         let subscription = abi::subscription {\n             type_: abi::eventtype::CONDVAR,\n             union: abi::subscription_union {\n                 condvar: abi::subscription_condvar {\n-                    condvar: condvar as *mut abi::condvar,\n+                    condvar: &self.condvar as *const AtomicU32 as *mut abi::condvar,\n                     condvar_scope: abi::scope::PRIVATE,\n-                    lock: mutex as *mut abi::lock,\n+                    lock: mutex as *const AtomicU32 as *mut abi::lock,\n                     lock_scope: abi::scope::PRIVATE,\n                 },\n             },\n@@ -86,23 +79,22 @@ impl Condvar {\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n         let mutex = mutex::raw(mutex);\n         assert_eq!(\n-            (*mutex).load(Ordering::Relaxed) & !abi::LOCK_KERNEL_MANAGED.0,\n+            mutex.load(Ordering::Relaxed) & !abi::LOCK_KERNEL_MANAGED.0,\n             __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n             \"This lock is not write-locked by this thread\"\n         );\n \n         // Call into the kernel to wait on the condition variable.\n-        let condvar = self.condvar.get();\n         let timeout =\n             checked_dur2intervals(&dur).expect(\"overflow converting duration to nanoseconds\");\n         let subscriptions = [\n             abi::subscription {\n                 type_: abi::eventtype::CONDVAR,\n                 union: abi::subscription_union {\n                     condvar: abi::subscription_condvar {\n-                        condvar: condvar as *mut abi::condvar,\n+                        condvar: &self.condvar as *const AtomicU32 as *mut abi::condvar,\n                         condvar_scope: abi::scope::PRIVATE,\n-                        lock: mutex as *mut abi::lock,\n+                        lock: mutex as *const AtomicU32 as *mut abi::lock,\n                         lock_scope: abi::scope::PRIVATE,\n                     },\n                 },\n@@ -144,9 +136,8 @@ impl Condvar {\n     }\n \n     pub unsafe fn destroy(&self) {\n-        let condvar = self.condvar.get();\n         assert_eq!(\n-            (*condvar).load(Ordering::Relaxed),\n+            self.condvar.load(Ordering::Relaxed),\n             abi::CONDVAR_HAS_NO_WAITERS.0,\n             \"Attempted to destroy a condition variable with blocked threads\"\n         );"}, {"sha": "1203d8de0c572617982342cfe526c94a22fc58fd", "filename": "library/std/src/sys/cloudabi/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/060e8cbaf1e3a57b97f96b13f702e04de4a5f1d3/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/060e8cbaf1e3a57b97f96b13f702e04de4a5f1d3/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fmutex.rs?ref=060e8cbaf1e3a57b97f96b13f702e04de4a5f1d3", "patch": "@@ -17,7 +17,7 @@ pub struct Mutex(RWLock);\n \n pub type MovableMutex = Mutex;\n \n-pub unsafe fn raw(m: &Mutex) -> *mut AtomicU32 {\n+pub unsafe fn raw(m: &Mutex) -> &AtomicU32 {\n     rwlock::raw(&m.0)\n }\n "}, {"sha": "508de8ba47c6e2632f48bbb7333bef08dbfcf5e4", "filename": "library/std/src/sys/cloudabi/rwlock.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/060e8cbaf1e3a57b97f96b13f702e04de4a5f1d3/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/060e8cbaf1e3a57b97f96b13f702e04de4a5f1d3/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Frwlock.rs?ref=060e8cbaf1e3a57b97f96b13f702e04de4a5f1d3", "patch": "@@ -15,8 +15,8 @@ pub struct RWLock {\n     lock: AtomicU32,\n }\n \n-pub unsafe fn raw(r: &RWLock) -> *mut AtomicU32 {\n-    &r.lock as *const AtomicU32 as *mut AtomicU32\n+pub unsafe fn raw(r: &RWLock) -> &AtomicU32 {\n+    &r.lock\n }\n \n unsafe impl Send for RWLock {}"}]}