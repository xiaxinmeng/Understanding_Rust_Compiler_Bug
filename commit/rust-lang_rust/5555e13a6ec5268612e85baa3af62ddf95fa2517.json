{"sha": "5555e13a6ec5268612e85baa3af62ddf95fa2517", "node_id": "C_kwDOAAsO6NoAKDU1NTVlMTNhNmVjNTI2ODYxMmU4NWJhYTNhZjYyZGRmOTVmYTI1MTc", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-08-29T11:19:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-29T11:19:39Z"}, "message": "Rollup merge of #99821 - cjgillot:ast-lifetimes-2, r=compiler-errors\n\nRemove separate indexing of early-bound regions\n\n~Based on https://github.com/rust-lang/rust/pull/99728.~\n\nThis PR copies some modifications from https://github.com/rust-lang/rust/pull/97839 around object lifetime defaults.\nThese modifications allow to stop counting generic parameters during lifetime resolution, and rely on the indexing given by `rustc_typeck::collect`.", "tree": {"sha": "bab81bfb0739a10b8d7acc1a56f4a37b45813342", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bab81bfb0739a10b8d7acc1a56f4a37b45813342"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5555e13a6ec5268612e85baa3af62ddf95fa2517", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjDKDLCRBK7hj4Ov3rIwAAoxcIACxMCyT1K76wkecguGo/lzpy\nzLCT3NdiDpriUPHdFJo6c5++KCzz7fXYj5IcwEQ7UJTYj/ZxABw5JgAXKaok8E3p\nra4cZjBuQmVt2IwmLurlBBWDTnqLHgL5a1699zUT2Ce6VlJrQePEqYbqlaCFIaJR\nxJoD6rQmr/DMxJFbuYkZHpCAqUmmEogFf9OkXWQ2wOZgjfYUXjPrBe5dLICHVTFg\nwbG6t5HAQpxYCoqLyx/7KbYTUw4benQ43ta0zrq41+0reH1UQbj/yyKOfJKjUSn7\n68ofH4MAC0g0PR4cW9n8/EsjGblVcHUUNVXq5Do+NHgsxWivRSOj9LPgcbAFnNM=\n=nQ9y\n-----END PGP SIGNATURE-----\n", "payload": "tree bab81bfb0739a10b8d7acc1a56f4a37b45813342\nparent 1999ed798e5a77087cde68d2fb955d768ecfb5a4\nparent da90ec17e01d8360650a096ec53db5470839b3ab\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1661771979 +0530\ncommitter GitHub <noreply@github.com> 1661771979 +0530\n\nRollup merge of #99821 - cjgillot:ast-lifetimes-2, r=compiler-errors\n\nRemove separate indexing of early-bound regions\n\n~Based on https://github.com/rust-lang/rust/pull/99728.~\n\nThis PR copies some modifications from https://github.com/rust-lang/rust/pull/97839 around object lifetime defaults.\nThese modifications allow to stop counting generic parameters during lifetime resolution, and rely on the indexing given by `rustc_typeck::collect`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5555e13a6ec5268612e85baa3af62ddf95fa2517", "html_url": "https://github.com/rust-lang/rust/commit/5555e13a6ec5268612e85baa3af62ddf95fa2517", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5555e13a6ec5268612e85baa3af62ddf95fa2517/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1999ed798e5a77087cde68d2fb955d768ecfb5a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1999ed798e5a77087cde68d2fb955d768ecfb5a4", "html_url": "https://github.com/rust-lang/rust/commit/1999ed798e5a77087cde68d2fb955d768ecfb5a4"}, {"sha": "da90ec17e01d8360650a096ec53db5470839b3ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/da90ec17e01d8360650a096ec53db5470839b3ab", "html_url": "https://github.com/rust-lang/rust/commit/da90ec17e01d8360650a096ec53db5470839b3ab"}], "stats": {"total": 612, "additions": 180, "deletions": 432}, "files": [{"sha": "ddad72fdab93d9dfabeba68820cef3edfac199a1", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=5555e13a6ec5268612e85baa3af62ddf95fa2517", "patch": "@@ -103,7 +103,7 @@ impl<'tcx> Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n                     // Find the index of the named region that was part of the\n                     // error. We will then search the function parameters for a bound\n                     // region at the right depth with the same index\n-                    (Some(rl::Region::EarlyBound(_, id)), ty::BrNamed(def_id, _)) => {\n+                    (Some(rl::Region::EarlyBound(id)), ty::BrNamed(def_id, _)) => {\n                         debug!(\"EarlyBound id={:?} def_id={:?}\", id, def_id);\n                         if id == def_id {\n                             self.found_type = Some(arg);\n@@ -133,7 +133,7 @@ impl<'tcx> Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n                         Some(\n                             rl::Region::Static\n                             | rl::Region::Free(_, _)\n-                            | rl::Region::EarlyBound(_, _)\n+                            | rl::Region::EarlyBound(_)\n                             | rl::Region::LateBound(_, _, _),\n                         )\n                         | None,\n@@ -188,7 +188,7 @@ impl<'tcx> Visitor<'tcx> for TyPathVisitor<'tcx> {\n     fn visit_lifetime(&mut self, lifetime: &hir::Lifetime) {\n         match (self.tcx.named_region(lifetime.hir_id), self.bound_region) {\n             // the lifetime of the TyPath!\n-            (Some(rl::Region::EarlyBound(_, id)), ty::BrNamed(def_id, _)) => {\n+            (Some(rl::Region::EarlyBound(id)), ty::BrNamed(def_id, _)) => {\n                 debug!(\"EarlyBound id={:?} def_id={:?}\", id, def_id);\n                 if id == def_id {\n                     self.found_it = true;\n@@ -209,7 +209,7 @@ impl<'tcx> Visitor<'tcx> for TyPathVisitor<'tcx> {\n             (\n                 Some(\n                     rl::Region::Static\n-                    | rl::Region::EarlyBound(_, _)\n+                    | rl::Region::EarlyBound(_)\n                     | rl::Region::LateBound(_, _, _)\n                     | rl::Region::Free(_, _),\n                 )"}, {"sha": "3d002380f09dd2c3fb38830d98c163174f4850e5", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=5555e13a6ec5268612e85baa3af62ddf95fa2517", "patch": "@@ -2026,13 +2026,13 @@ declare_lint_pass!(ExplicitOutlivesRequirements => [EXPLICIT_OUTLIVES_REQUIREMEN\n impl ExplicitOutlivesRequirements {\n     fn lifetimes_outliving_lifetime<'tcx>(\n         inferred_outlives: &'tcx [(ty::Predicate<'tcx>, Span)],\n-        index: u32,\n+        def_id: DefId,\n     ) -> Vec<ty::Region<'tcx>> {\n         inferred_outlives\n             .iter()\n             .filter_map(|(pred, _)| match pred.kind().skip_binder() {\n                 ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => match *a {\n-                    ty::ReEarlyBound(ebr) if ebr.index == index => Some(b),\n+                    ty::ReEarlyBound(ebr) if ebr.def_id == def_id => Some(b),\n                     _ => None,\n                 },\n                 _ => None,\n@@ -2069,8 +2069,12 @@ impl ExplicitOutlivesRequirements {\n             .filter_map(|(i, bound)| {\n                 if let hir::GenericBound::Outlives(lifetime) = bound {\n                     let is_inferred = match tcx.named_region(lifetime.hir_id) {\n-                        Some(Region::EarlyBound(index, ..)) => inferred_outlives.iter().any(|r| {\n-                            if let ty::ReEarlyBound(ebr) = **r { ebr.index == index } else { false }\n+                        Some(Region::EarlyBound(def_id)) => inferred_outlives.iter().any(|r| {\n+                            if let ty::ReEarlyBound(ebr) = **r {\n+                                ebr.def_id == def_id\n+                            } else {\n+                                false\n+                            }\n                         }),\n                         _ => false,\n                     };\n@@ -2164,11 +2168,14 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n             for (i, where_predicate) in hir_generics.predicates.iter().enumerate() {\n                 let (relevant_lifetimes, bounds, span, in_where_clause) = match where_predicate {\n                     hir::WherePredicate::RegionPredicate(predicate) => {\n-                        if let Some(Region::EarlyBound(index, ..)) =\n+                        if let Some(Region::EarlyBound(region_def_id)) =\n                             cx.tcx.named_region(predicate.lifetime.hir_id)\n                         {\n                             (\n-                                Self::lifetimes_outliving_lifetime(inferred_outlives, index),\n+                                Self::lifetimes_outliving_lifetime(\n+                                    inferred_outlives,\n+                                    region_def_id,\n+                                ),\n                                 &predicate.bounds,\n                                 predicate.span,\n                                 predicate.in_where_clause,"}, {"sha": "9d201a0c799928174f80efd1f93135013ed01733", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=5555e13a6ec5268612e85baa3af62ddf95fa2517", "patch": "@@ -199,6 +199,7 @@ provide! { tcx, def_id, other, cdata,\n     codegen_fn_attrs => { table }\n     impl_trait_ref => { table }\n     const_param_default => { table }\n+    object_lifetime_default => { table }\n     thir_abstract_const => { table }\n     optimized_mir => { table }\n     mir_for_ctfe => { table }"}, {"sha": "3482d9f04514e561b08c458639af28b7dde76292", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=5555e13a6ec5268612e85baa3af62ddf95fa2517", "patch": "@@ -1076,6 +1076,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     record_array!(self.tables.inferred_outlives_of[def_id] <- inferred_outlives);\n                 }\n             }\n+            if let DefKind::TyParam | DefKind::ConstParam = def_kind {\n+                if let Some(default) = self.tcx.object_lifetime_default(def_id) {\n+                    record!(self.tables.object_lifetime_default[def_id] <- default);\n+                }\n+            }\n             if let DefKind::Trait | DefKind::TraitAlias = def_kind {\n                 record!(self.tables.super_predicates_of[def_id] <- self.tcx.super_predicates_of(def_id));\n             }"}, {"sha": "aeffc85b507556648ed956d50937c91435949a48", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=5555e13a6ec5268612e85baa3af62ddf95fa2517", "patch": "@@ -16,6 +16,7 @@ use rustc_index::{bit_set::FiniteBitSet, vec::IndexVec};\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n+use rustc_middle::middle::resolve_lifetime::ObjectLifetimeDefault;\n use rustc_middle::mir;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::Providers;\n@@ -358,6 +359,7 @@ define_tables! {\n     codegen_fn_attrs: Table<DefIndex, LazyValue<CodegenFnAttrs>>,\n     impl_trait_ref: Table<DefIndex, LazyValue<ty::TraitRef<'static>>>,\n     const_param_default: Table<DefIndex, LazyValue<rustc_middle::ty::Const<'static>>>,\n+    object_lifetime_default: Table<DefIndex, LazyValue<ObjectLifetimeDefault>>,\n     optimized_mir: Table<DefIndex, LazyValue<mir::Body<'static>>>,\n     mir_for_ctfe: Table<DefIndex, LazyValue<mir::Body<'static>>>,\n     promoted_mir: Table<DefIndex, LazyValue<IndexVec<mir::Promoted, mir::Body<'static>>>>,"}, {"sha": "8f7877392483f27f0c6ad04321071c912a27ee13", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=5555e13a6ec5268612e85baa3af62ddf95fa2517", "patch": "@@ -486,7 +486,9 @@ impl<'hir> Map<'hir> {\n         let def_kind = self.tcx.def_kind(def_id);\n         match def_kind {\n             DefKind::Trait | DefKind::TraitAlias => def_id,\n-            DefKind::TyParam | DefKind::ConstParam => self.tcx.local_parent(def_id),\n+            DefKind::LifetimeParam | DefKind::TyParam | DefKind::ConstParam => {\n+                self.tcx.local_parent(def_id)\n+            }\n             _ => bug!(\"ty_param_owner: {:?} is a {:?} not a type parameter\", def_id, def_kind),\n         }\n     }\n@@ -495,7 +497,9 @@ impl<'hir> Map<'hir> {\n         let def_kind = self.tcx.def_kind(def_id);\n         match def_kind {\n             DefKind::Trait | DefKind::TraitAlias => kw::SelfUpper,\n-            DefKind::TyParam | DefKind::ConstParam => self.tcx.item_name(def_id.to_def_id()),\n+            DefKind::LifetimeParam | DefKind::TyParam | DefKind::ConstParam => {\n+                self.tcx.item_name(def_id.to_def_id())\n+            }\n             _ => bug!(\"ty_param_name: {:?} is a {:?} not a type parameter\", def_id, def_kind),\n         }\n     }"}, {"sha": "a171f5711dcffd3304c86dc958f8651aecbcebd6", "filename": "compiler/rustc_middle/src/middle/resolve_lifetime.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs?ref=5555e13a6ec5268612e85baa3af62ddf95fa2517", "patch": "@@ -10,7 +10,7 @@ use rustc_macros::HashStable;\n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, HashStable)]\n pub enum Region {\n     Static,\n-    EarlyBound(/* index */ u32, /* lifetime decl */ DefId),\n+    EarlyBound(/* lifetime decl */ DefId),\n     LateBound(ty::DebruijnIndex, /* late-bound index */ u32, /* lifetime decl */ DefId),\n     Free(DefId, /* lifetime decl */ DefId),\n }\n@@ -35,7 +35,13 @@ impl<T: PartialEq> Set1<T> {\n     }\n }\n \n-pub type ObjectLifetimeDefault = Set1<Region>;\n+#[derive(Copy, Clone, Debug, HashStable, Encodable, Decodable)]\n+pub enum ObjectLifetimeDefault {\n+    Empty,\n+    Static,\n+    Ambiguous,\n+    Param(DefId),\n+}\n \n /// Maps the id of each lifetime reference to the lifetime decl\n /// that it corresponds to."}, {"sha": "ddca9820da1aec8cacbd60356284744fa2c7fc03", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=5555e13a6ec5268612e85baa3af62ddf95fa2517", "patch": "@@ -1597,8 +1597,9 @@ rustc_queries! {\n     /// for each parameter if a trait object were to be passed for that parameter.\n     /// For example, for `struct Foo<'a, T, U>`, this would be `['static, 'static]`.\n     /// For `struct Foo<'a, T: 'a, U>`, this would instead be `['a, 'static]`.\n-    query object_lifetime_defaults(_: LocalDefId) -> Option<&'tcx [ObjectLifetimeDefault]> {\n-        desc { \"looking up lifetime defaults for a region on an item\" }\n+    query object_lifetime_default(key: DefId) -> Option<ObjectLifetimeDefault> {\n+        desc { \"looking up lifetime defaults for generic parameter `{:?}`\", key }\n+        separate_provide_extern\n     }\n     query late_bound_vars_map(_: LocalDefId)\n         -> Option<&'tcx FxHashMap<ItemLocalId, Vec<ty::BoundVariableKind>>> {"}, {"sha": "42b5d5a6efd7ec5435b6d141aef29c5858bf2f20", "filename": "compiler/rustc_middle/src/ty/generics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs?ref=5555e13a6ec5268612e85baa3af62ddf95fa2517", "patch": "@@ -1,4 +1,3 @@\n-use crate::middle::resolve_lifetime::ObjectLifetimeDefault;\n use crate::ty;\n use crate::ty::subst::{Subst, SubstsRef};\n use crate::ty::EarlyBinder;\n@@ -13,7 +12,7 @@ use super::{EarlyBoundRegion, InstantiatedPredicates, ParamConst, ParamTy, Predi\n #[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub enum GenericParamDefKind {\n     Lifetime,\n-    Type { has_default: bool, object_lifetime_default: ObjectLifetimeDefault, synthetic: bool },\n+    Type { has_default: bool, synthetic: bool },\n     Const { has_default: bool },\n }\n "}, {"sha": "19b8f27bc95caae910d164128766cbefb533a254", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=5555e13a6ec5268612e85baa3af62ddf95fa2517", "patch": "@@ -53,6 +53,7 @@ trivially_parameterized_over_tcx! {\n     crate::metadata::ModChild,\n     crate::middle::codegen_fn_attrs::CodegenFnAttrs,\n     crate::middle::exported_symbols::SymbolExportInfo,\n+    crate::middle::resolve_lifetime::ObjectLifetimeDefault,\n     crate::mir::ConstQualifs,\n     ty::Generics,\n     ty::ImplPolarity,"}, {"sha": "f376da29bd919e63b0250fcda94bfd9e58d53078", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=5555e13a6ec5268612e85baa3af62ddf95fa2517", "patch": "@@ -16,6 +16,7 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{self, FnSig, ForeignItem, HirId, Item, ItemKind, TraitItem, CRATE_HIR_ID};\n use rustc_hir::{MethodKind, Target};\n use rustc_middle::hir::nested_filter;\n+use rustc_middle::middle::resolve_lifetime::ObjectLifetimeDefault;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::lint::builtin::{\n@@ -172,6 +173,9 @@ impl CheckAttrVisitor<'_> {\n                 sym::no_implicit_prelude => {\n                     self.check_generic_attr(hir_id, attr, target, &[Target::Mod])\n                 }\n+                sym::rustc_object_lifetime_default => {\n+                    self.check_object_lifetime_default(hir_id, span)\n+                }\n                 _ => {}\n             }\n \n@@ -410,6 +414,30 @@ impl CheckAttrVisitor<'_> {\n         }\n     }\n \n+    /// Debugging aid for `object_lifetime_default` query.\n+    fn check_object_lifetime_default(&self, hir_id: HirId, span: Span) {\n+        let tcx = self.tcx;\n+        if let Some(generics) = tcx.hir().get_generics(tcx.hir().local_def_id(hir_id)) {\n+            let object_lifetime_default_reprs: String = generics\n+                .params\n+                .iter()\n+                .filter_map(|p| {\n+                    let param_id = tcx.hir().local_def_id(p.hir_id);\n+                    let default = tcx.object_lifetime_default(param_id)?;\n+                    Some(match default {\n+                        ObjectLifetimeDefault::Empty => \"BaseDefault\".to_owned(),\n+                        ObjectLifetimeDefault::Static => \"'static\".to_owned(),\n+                        ObjectLifetimeDefault::Param(def_id) => tcx.item_name(def_id).to_string(),\n+                        ObjectLifetimeDefault::Ambiguous => \"Ambiguous\".to_owned(),\n+                    })\n+                })\n+                .collect::<Vec<String>>()\n+                .join(\",\");\n+\n+            tcx.sess.span_err(span, &object_lifetime_default_reprs);\n+        }\n+    }\n+\n     /// Checks if a `#[track_caller]` is applied to a non-naked function. Returns `true` if valid.\n     fn check_track_caller(\n         &self,"}, {"sha": "6ea976a59006470517ddf93e68df4014d8605ffd", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 80, "deletions": 374, "changes": 454, "blob_url": "https://github.com/rust-lang/rust/blob/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=5555e13a6ec5268612e85baa3af62ddf95fa2517", "patch": "@@ -11,23 +11,21 @@ use rustc_data_structures::fx::{FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{DefIdMap, LocalDefId};\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{GenericArg, GenericParam, GenericParamKind, HirIdMap, LifetimeName, Node};\n use rustc_middle::bug;\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::resolve_lifetime::*;\n-use rustc_middle::ty::{self, GenericParamDefKind, TyCtxt};\n+use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n use rustc_span::def_id::DefId;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n-use std::borrow::Cow;\n use std::fmt;\n-use std::mem::take;\n \n trait RegionExt {\n-    fn early(hir_map: Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (LocalDefId, Region);\n+    fn early(hir_map: Map<'_>, param: &GenericParam<'_>) -> (LocalDefId, Region);\n \n     fn late(index: u32, hir_map: Map<'_>, param: &GenericParam<'_>) -> (LocalDefId, Region);\n \n@@ -36,19 +34,13 @@ trait RegionExt {\n     fn shifted(self, amount: u32) -> Region;\n \n     fn shifted_out_to_binder(self, binder: ty::DebruijnIndex) -> Region;\n-\n-    fn subst<'a, L>(self, params: L, map: &NamedRegionMap) -> Option<Region>\n-    where\n-        L: Iterator<Item = &'a hir::Lifetime>;\n }\n \n impl RegionExt for Region {\n-    fn early(hir_map: Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (LocalDefId, Region) {\n-        let i = *index;\n-        *index += 1;\n+    fn early(hir_map: Map<'_>, param: &GenericParam<'_>) -> (LocalDefId, Region) {\n         let def_id = hir_map.local_def_id(param.hir_id);\n-        debug!(\"Region::early: index={} def_id={:?}\", i, def_id);\n-        (def_id, Region::EarlyBound(i, def_id.to_def_id()))\n+        debug!(\"Region::early: def_id={:?}\", def_id);\n+        (def_id, Region::EarlyBound(def_id.to_def_id()))\n     }\n \n     fn late(idx: u32, hir_map: Map<'_>, param: &GenericParam<'_>) -> (LocalDefId, Region) {\n@@ -65,9 +57,7 @@ impl RegionExt for Region {\n         match *self {\n             Region::Static => None,\n \n-            Region::EarlyBound(_, id) | Region::LateBound(_, _, id) | Region::Free(_, id) => {\n-                Some(id)\n-            }\n+            Region::EarlyBound(id) | Region::LateBound(_, _, id) | Region::Free(_, id) => Some(id),\n         }\n     }\n \n@@ -88,17 +78,6 @@ impl RegionExt for Region {\n             _ => self,\n         }\n     }\n-\n-    fn subst<'a, L>(self, mut params: L, map: &NamedRegionMap) -> Option<Region>\n-    where\n-        L: Iterator<Item = &'a hir::Lifetime>,\n-    {\n-        if let Region::EarlyBound(index, _) = self {\n-            params.nth(index as usize).and_then(|lifetime| map.defs.get(&lifetime.hir_id).cloned())\n-        } else {\n-            Some(self)\n-        }\n-    }\n }\n \n /// Maps the id of each lifetime reference to the lifetime decl\n@@ -131,9 +110,6 @@ pub(crate) struct LifetimeContext<'a, 'tcx> {\n     /// be false if the `Item` we are resolving lifetimes for is not a trait or\n     /// we eventually need lifetimes resolve for trait items.\n     trait_definition_only: bool,\n-\n-    /// Cache for cross-crate per-definition object lifetime defaults.\n-    xcrate_object_lifetime_defaults: DefIdMap<Vec<ObjectLifetimeDefault>>,\n }\n \n #[derive(Debug)]\n@@ -147,25 +123,6 @@ enum Scope<'a> {\n         /// for diagnostics.\n         lifetimes: FxIndexMap<LocalDefId, Region>,\n \n-        /// if we extend this scope with another scope, what is the next index\n-        /// we should use for an early-bound region?\n-        next_early_index: u32,\n-\n-        /// Whether or not this binder would serve as the parent\n-        /// binder for opaque types introduced within. For example:\n-        ///\n-        /// ```text\n-        ///     fn foo<'a>() -> impl for<'b> Trait<Item = impl Trait2<'a>>\n-        /// ```\n-        ///\n-        /// Here, the opaque types we create for the `impl Trait`\n-        /// and `impl Trait2` references will both have the `foo` item\n-        /// as their parent. When we get to `impl Trait2`, we find\n-        /// that it is nested within the `for<>` binder -- this flag\n-        /// allows us to skip that when looking for the parent binder\n-        /// of the resulting opaque type.\n-        opaque_type_parent: bool,\n-\n         scope_type: BinderScopeType,\n \n         /// The late bound vars for a given item are stored by `HirId` to be\n@@ -245,19 +202,9 @@ struct TruncatedScopeDebug<'a>(&'a Scope<'a>);\n impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.0 {\n-            Scope::Binder {\n-                lifetimes,\n-                next_early_index,\n-                opaque_type_parent,\n-                scope_type,\n-                hir_id,\n-                where_bound_origin,\n-                s: _,\n-            } => f\n+            Scope::Binder { lifetimes, scope_type, hir_id, where_bound_origin, s: _ } => f\n                 .debug_struct(\"Binder\")\n                 .field(\"lifetimes\", lifetimes)\n-                .field(\"next_early_index\", next_early_index)\n-                .field(\"opaque_type_parent\", opaque_type_parent)\n                 .field(\"scope_type\", scope_type)\n                 .field(\"hir_id\", hir_id)\n                 .field(\"where_bound_origin\", where_bound_origin)\n@@ -294,10 +241,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n \n         named_region_map: |tcx, id| resolve_lifetimes_for(tcx, id).defs.get(&id),\n         is_late_bound_map,\n-        object_lifetime_defaults: |tcx, id| match tcx.hir().find_by_def_id(id) {\n-            Some(Node::Item(item)) => compute_object_lifetime_defaults(tcx, item),\n-            _ => None,\n-        },\n+        object_lifetime_default,\n         late_bound_vars_map: |tcx, id| resolve_lifetimes_for(tcx, id).late_bound_vars.get(&id),\n \n         ..*providers\n@@ -363,7 +307,6 @@ fn do_resolve(\n         map: &mut named_region_map,\n         scope: ROOT_SCOPE,\n         trait_definition_only,\n-        xcrate_object_lifetime_defaults: Default::default(),\n     };\n     visitor.visit_item(item);\n \n@@ -432,13 +375,6 @@ fn item_for(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> LocalDefId {\n     item\n }\n \n-/// In traits, there is an implicit `Self` type parameter which comes before the generics.\n-/// We have to account for this when computing the index of the other generic parameters.\n-/// This function returns whether there is such an implicit parameter defined on the given item.\n-fn sub_items_have_self_param(node: &hir::ItemKind<'_>) -> bool {\n-    matches!(*node, hir::ItemKind::Trait(..) | hir::ItemKind::TraitAlias(..))\n-}\n-\n fn late_region_as_bound_region<'tcx>(tcx: TyCtxt<'tcx>, region: &Region) -> ty::BoundVariableKind {\n     match region {\n         Region::LateBound(_, _, def_id) => {\n@@ -558,7 +494,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 }\n             }\n \n-            let next_early_index = self.next_early_index();\n             let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) =\n                 bound_generic_params\n                     .iter()\n@@ -576,8 +511,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 hir_id: e.hir_id,\n                 lifetimes,\n                 s: self.scope,\n-                next_early_index,\n-                opaque_type_parent: false,\n                 scope_type: BinderScopeType::Normal,\n                 where_bound_origin: None,\n             };\n@@ -603,7 +536,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         }\n         match item.kind {\n             hir::ItemKind::Fn(_, ref generics, _) => {\n-                self.visit_early_late(None, item.hir_id(), generics, |this| {\n+                self.visit_early_late(item.hir_id(), generics, |this| {\n                     intravisit::walk_item(this, item);\n                 });\n             }\n@@ -670,31 +603,20 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             | hir::ItemKind::TraitAlias(ref generics, ..)\n             | hir::ItemKind::Impl(hir::Impl { ref generics, .. }) => {\n                 // These kinds of items have only early-bound lifetime parameters.\n-                let mut index = if sub_items_have_self_param(&item.kind) {\n-                    1 // Self comes before lifetimes\n-                } else {\n-                    0\n-                };\n-                let mut non_lifetime_count = 0;\n                 let lifetimes = generics\n                     .params\n                     .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(self.tcx.hir(), &mut index, param))\n-                        }\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n-                            non_lifetime_count += 1;\n-                            None\n+                            Some(Region::early(self.tcx.hir(), param))\n                         }\n+                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n                     })\n                     .collect();\n                 self.map.late_bound_vars.insert(item.hir_id(), vec![]);\n                 let scope = Scope::Binder {\n                     hir_id: item.hir_id(),\n                     lifetimes,\n-                    next_early_index: index + non_lifetime_count,\n-                    opaque_type_parent: true,\n                     scope_type: BinderScopeType::Normal,\n                     s: ROOT_SCOPE,\n                     where_bound_origin: None,\n@@ -712,7 +634,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n         match item.kind {\n             hir::ForeignItemKind::Fn(_, _, ref generics) => {\n-                self.visit_early_late(None, item.hir_id(), generics, |this| {\n+                self.visit_early_late(item.hir_id(), generics, |this| {\n                     intravisit::walk_foreign_item(this, item);\n                 })\n             }\n@@ -729,7 +651,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n         match ty.kind {\n             hir::TyKind::BareFn(ref c) => {\n-                let next_early_index = self.next_early_index();\n                 let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) = c\n                     .generic_params\n                     .iter()\n@@ -746,8 +667,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     hir_id: ty.hir_id,\n                     lifetimes,\n                     s: self.scope,\n-                    next_early_index,\n-                    opaque_type_parent: false,\n                     scope_type: BinderScopeType::Normal,\n                     where_bound_origin: None,\n                 };\n@@ -886,32 +805,23 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n                 // We want to start our early-bound indices at the end of the parent scope,\n                 // not including any parent `impl Trait`s.\n-                let mut index = self.next_early_index_for_opaque_type();\n-                debug!(?index);\n-\n                 let mut lifetimes = FxIndexMap::default();\n-                let mut non_lifetime_count = 0;\n                 debug!(?generics.params);\n                 for param in generics.params {\n                     match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            let (def_id, reg) = Region::early(self.tcx.hir(), &mut index, &param);\n+                            let (def_id, reg) = Region::early(self.tcx.hir(), &param);\n                             lifetimes.insert(def_id, reg);\n                         }\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n-                            non_lifetime_count += 1;\n-                        }\n+                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {}\n                     }\n                 }\n-                let next_early_index = index + non_lifetime_count;\n                 self.map.late_bound_vars.insert(ty.hir_id, vec![]);\n \n                 let scope = Scope::Binder {\n                     hir_id: ty.hir_id,\n                     lifetimes,\n-                    next_early_index,\n                     s: self.scope,\n-                    opaque_type_parent: false,\n                     scope_type: BinderScopeType::Normal,\n                     where_bound_origin: None,\n                 };\n@@ -933,39 +843,27 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         use self::hir::TraitItemKind::*;\n         match trait_item.kind {\n             Fn(_, _) => {\n-                let tcx = self.tcx;\n-                self.visit_early_late(\n-                    Some(tcx.hir().get_parent_item(trait_item.hir_id())),\n-                    trait_item.hir_id(),\n-                    &trait_item.generics,\n-                    |this| intravisit::walk_trait_item(this, trait_item),\n-                );\n+                self.visit_early_late(trait_item.hir_id(), &trait_item.generics, |this| {\n+                    intravisit::walk_trait_item(this, trait_item)\n+                });\n             }\n             Type(bounds, ref ty) => {\n                 let generics = &trait_item.generics;\n-                let mut index = self.next_early_index();\n-                debug!(\"visit_ty: index = {}\", index);\n-                let mut non_lifetime_count = 0;\n                 let lifetimes = generics\n                     .params\n                     .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(self.tcx.hir(), &mut index, param))\n-                        }\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n-                            non_lifetime_count += 1;\n-                            None\n+                            Some(Region::early(self.tcx.hir(), param))\n                         }\n+                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n                     })\n                     .collect();\n                 self.map.late_bound_vars.insert(trait_item.hir_id(), vec![]);\n                 let scope = Scope::Binder {\n                     hir_id: trait_item.hir_id(),\n                     lifetimes,\n-                    next_early_index: index + non_lifetime_count,\n                     s: self.scope,\n-                    opaque_type_parent: true,\n                     scope_type: BinderScopeType::Normal,\n                     where_bound_origin: None,\n                 };\n@@ -993,40 +891,26 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         use self::hir::ImplItemKind::*;\n         match impl_item.kind {\n-            Fn(..) => {\n-                let tcx = self.tcx;\n-                self.visit_early_late(\n-                    Some(tcx.hir().get_parent_item(impl_item.hir_id())),\n-                    impl_item.hir_id(),\n-                    &impl_item.generics,\n-                    |this| intravisit::walk_impl_item(this, impl_item),\n-                );\n-            }\n+            Fn(..) => self.visit_early_late(impl_item.hir_id(), &impl_item.generics, |this| {\n+                intravisit::walk_impl_item(this, impl_item)\n+            }),\n             TyAlias(ref ty) => {\n                 let generics = &impl_item.generics;\n-                let mut index = self.next_early_index();\n-                let mut non_lifetime_count = 0;\n-                debug!(\"visit_ty: index = {}\", index);\n                 let lifetimes: FxIndexMap<LocalDefId, Region> = generics\n                     .params\n                     .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(self.tcx.hir(), &mut index, param))\n-                        }\n-                        GenericParamKind::Const { .. } | GenericParamKind::Type { .. } => {\n-                            non_lifetime_count += 1;\n-                            None\n+                            Some(Region::early(self.tcx.hir(), param))\n                         }\n+                        GenericParamKind::Const { .. } | GenericParamKind::Type { .. } => None,\n                     })\n                     .collect();\n                 self.map.late_bound_vars.insert(ty.hir_id, vec![]);\n                 let scope = Scope::Binder {\n                     hir_id: ty.hir_id,\n                     lifetimes,\n-                    next_early_index: index + non_lifetime_count,\n                     s: self.scope,\n-                    opaque_type_parent: true,\n                     scope_type: BinderScopeType::Normal,\n                     where_bound_origin: None,\n                 };\n@@ -1129,7 +1013,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                 })\n                                 .unzip();\n                         this.map.late_bound_vars.insert(bounded_ty.hir_id, binders.clone());\n-                        let next_early_index = this.next_early_index();\n                         // Even if there are no lifetimes defined here, we still wrap it in a binder\n                         // scope. If there happens to be a nested poly trait ref (an error), that\n                         // will be `Concatenating` anyways, so we don't have to worry about the depth\n@@ -1138,8 +1021,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                             hir_id: bounded_ty.hir_id,\n                             lifetimes,\n                             s: this.scope,\n-                            next_early_index,\n-                            opaque_type_parent: false,\n                             scope_type: BinderScopeType::Normal,\n                             where_bound_origin: Some(origin),\n                         };\n@@ -1210,8 +1091,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     hir_id: *hir_id,\n                     lifetimes: FxIndexMap::default(),\n                     s: self.scope,\n-                    next_early_index: self.next_early_index(),\n-                    opaque_type_parent: false,\n                     scope_type,\n                     where_bound_origin: None,\n                 };\n@@ -1230,7 +1109,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     ) {\n         debug!(\"visit_poly_trait_ref(trait_ref={:?})\", trait_ref);\n \n-        let next_early_index = self.next_early_index();\n         let (mut binders, scope_type) = self.poly_trait_ref_binder_info();\n \n         let initial_bound_vars = binders.len() as u32;\n@@ -1260,8 +1138,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             hir_id: trait_ref.trait_ref.hir_ref_id,\n             lifetimes,\n             s: self.scope,\n-            next_early_index,\n-            opaque_type_parent: false,\n             scope_type,\n             where_bound_origin: None,\n         };\n@@ -1272,139 +1148,56 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n }\n \n-fn compute_object_lifetime_defaults<'tcx>(\n+fn object_lifetime_default<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    item: &hir::Item<'_>,\n-) -> Option<&'tcx [ObjectLifetimeDefault]> {\n-    match item.kind {\n-        hir::ItemKind::Struct(_, ref generics)\n-        | hir::ItemKind::Union(_, ref generics)\n-        | hir::ItemKind::Enum(_, ref generics)\n-        | hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-            ref generics,\n-            origin: hir::OpaqueTyOrigin::TyAlias,\n-            ..\n-        })\n-        | hir::ItemKind::TyAlias(_, ref generics)\n-        | hir::ItemKind::Trait(_, _, ref generics, ..) => {\n-            let result = object_lifetime_defaults_for_item(tcx, generics);\n-\n-            // Debugging aid.\n-            let attrs = tcx.hir().attrs(item.hir_id());\n-            if tcx.sess.contains_name(attrs, sym::rustc_object_lifetime_default) {\n-                let object_lifetime_default_reprs: String = result\n-                    .iter()\n-                    .map(|set| match *set {\n-                        Set1::Empty => \"BaseDefault\".into(),\n-                        Set1::One(Region::Static) => \"'static\".into(),\n-                        Set1::One(Region::EarlyBound(mut i, _)) => generics\n-                            .params\n-                            .iter()\n-                            .find_map(|param| match param.kind {\n-                                GenericParamKind::Lifetime { .. } => {\n-                                    if i == 0 {\n-                                        return Some(param.name.ident().to_string().into());\n-                                    }\n-                                    i -= 1;\n-                                    None\n-                                }\n-                                _ => None,\n-                            })\n-                            .unwrap(),\n-                        Set1::One(_) => bug!(),\n-                        Set1::Many => \"Ambiguous\".into(),\n-                    })\n-                    .collect::<Vec<Cow<'static, str>>>()\n-                    .join(\",\");\n-                tcx.sess.span_err(item.span, &object_lifetime_default_reprs);\n-            }\n-\n-            Some(result)\n-        }\n-        _ => None,\n-    }\n-}\n-\n-/// Scan the bounds and where-clauses on parameters to extract bounds\n-/// of the form `T:'a` so as to determine the `ObjectLifetimeDefault`\n-/// for each type parameter.\n-fn object_lifetime_defaults_for_item<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    generics: &hir::Generics<'_>,\n-) -> &'tcx [ObjectLifetimeDefault] {\n-    fn add_bounds(set: &mut Set1<hir::LifetimeName>, bounds: &[hir::GenericBound<'_>]) {\n-        for bound in bounds {\n-            if let hir::GenericBound::Outlives(ref lifetime) = *bound {\n-                set.insert(lifetime.name.normalize_to_macros_2_0());\n-            }\n-        }\n-    }\n-\n-    let process_param = |param: &hir::GenericParam<'_>| match param.kind {\n+    param_def_id: DefId,\n+) -> Option<ObjectLifetimeDefault> {\n+    let param_def_id = param_def_id.expect_local();\n+    let parent_def_id = tcx.local_parent(param_def_id);\n+    let generics = tcx.hir().get_generics(parent_def_id)?;\n+    let param_hir_id = tcx.local_def_id_to_hir_id(param_def_id);\n+    let param = generics.params.iter().find(|p| p.hir_id == param_hir_id)?;\n+\n+    // Scan the bounds and where-clauses on parameters to extract bounds\n+    // of the form `T:'a` so as to determine the `ObjectLifetimeDefault`\n+    // for each type parameter.\n+    match param.kind {\n         GenericParamKind::Lifetime { .. } => None,\n         GenericParamKind::Type { .. } => {\n             let mut set = Set1::Empty;\n \n-            let param_def_id = tcx.hir().local_def_id(param.hir_id);\n-            for predicate in generics.predicates {\n-                // Look for `type: ...` where clauses.\n-                let hir::WherePredicate::BoundPredicate(ref data) = *predicate else { continue };\n-\n+            // Look for `type: ...` where clauses.\n+            for bound in generics.bounds_for_param(param_def_id) {\n                 // Ignore `for<'a> type: ...` as they can change what\n                 // lifetimes mean (although we could \"just\" handle it).\n-                if !data.bound_generic_params.is_empty() {\n+                if !bound.bound_generic_params.is_empty() {\n                     continue;\n                 }\n \n-                let res = match data.bounded_ty.kind {\n-                    hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => path.res,\n-                    _ => continue,\n-                };\n-\n-                if res == Res::Def(DefKind::TyParam, param_def_id.to_def_id()) {\n-                    add_bounds(&mut set, &data.bounds);\n+                for bound in bound.bounds {\n+                    if let hir::GenericBound::Outlives(ref lifetime) = *bound {\n+                        set.insert(lifetime.name.normalize_to_macros_2_0());\n+                    }\n                 }\n             }\n \n             Some(match set {\n-                Set1::Empty => Set1::Empty,\n-                Set1::One(name) => {\n-                    if name == hir::LifetimeName::Static {\n-                        Set1::One(Region::Static)\n-                    } else {\n-                        generics\n-                            .params\n-                            .iter()\n-                            .filter_map(|param| match param.kind {\n-                                GenericParamKind::Lifetime { .. } => {\n-                                    let param_def_id = tcx.hir().local_def_id(param.hir_id);\n-                                    Some((\n-                                        param_def_id,\n-                                        hir::LifetimeName::Param(param_def_id, param.name),\n-                                    ))\n-                                }\n-                                _ => None,\n-                            })\n-                            .enumerate()\n-                            .find(|&(_, (_, lt_name))| lt_name == name)\n-                            .map_or(Set1::Many, |(i, (def_id, _))| {\n-                                Set1::One(Region::EarlyBound(i as u32, def_id.to_def_id()))\n-                            })\n-                    }\n+                Set1::Empty => ObjectLifetimeDefault::Empty,\n+                Set1::One(hir::LifetimeName::Static) => ObjectLifetimeDefault::Static,\n+                Set1::One(hir::LifetimeName::Param(param_def_id, _)) => {\n+                    ObjectLifetimeDefault::Param(param_def_id.to_def_id())\n                 }\n-                Set1::Many => Set1::Many,\n+                _ => ObjectLifetimeDefault::Ambiguous,\n             })\n         }\n         GenericParamKind::Const { .. } => {\n             // Generic consts don't impose any constraints.\n             //\n             // We still store a dummy value here to allow generic parameters\n             // in an arbitrary order.\n-            Some(Set1::Empty)\n+            Some(ObjectLifetimeDefault::Empty)\n         }\n-    };\n-\n-    tcx.arena.alloc_from_iter(generics.params.iter().filter_map(process_param))\n+    }\n }\n \n impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n@@ -1413,20 +1206,17 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         F: for<'b> FnOnce(&mut LifetimeContext<'b, 'tcx>),\n     {\n         let LifetimeContext { tcx, map, .. } = self;\n-        let xcrate_object_lifetime_defaults = take(&mut self.xcrate_object_lifetime_defaults);\n         let mut this = LifetimeContext {\n             tcx: *tcx,\n             map,\n             scope: &wrap_scope,\n             trait_definition_only: self.trait_definition_only,\n-            xcrate_object_lifetime_defaults,\n         };\n         let span = tracing::debug_span!(\"scope\", scope = ?TruncatedScopeDebug(&this.scope));\n         {\n             let _enter = span.enter();\n             f(&mut this);\n         }\n-        self.xcrate_object_lifetime_defaults = this.xcrate_object_lifetime_defaults;\n     }\n \n     /// Visits self by adding a scope and handling recursive walk over the contents with `walk`.\n@@ -1449,30 +1239,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// ordering is not important there.\n     fn visit_early_late<F>(\n         &mut self,\n-        parent_id: Option<LocalDefId>,\n         hir_id: hir::HirId,\n         generics: &'tcx hir::Generics<'tcx>,\n         walk: F,\n     ) where\n         F: for<'b, 'c> FnOnce(&'b mut LifetimeContext<'c, 'tcx>),\n     {\n-        // Find the start of nested early scopes, e.g., in methods.\n-        let mut next_early_index = 0;\n-        if let Some(parent_id) = parent_id {\n-            let parent = self.tcx.hir().expect_item(parent_id);\n-            if sub_items_have_self_param(&parent.kind) {\n-                next_early_index += 1; // Self comes before lifetimes\n-            }\n-            match parent.kind {\n-                hir::ItemKind::Trait(_, _, ref generics, ..)\n-                | hir::ItemKind::Impl(hir::Impl { ref generics, .. }) => {\n-                    next_early_index += generics.params.len() as u32;\n-                }\n-                _ => {}\n-            }\n-        }\n-\n-        let mut non_lifetime_count = 0;\n         let mut named_late_bound_vars = 0;\n         let lifetimes: FxIndexMap<LocalDefId, Region> = generics\n             .params\n@@ -1484,16 +1256,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         named_late_bound_vars += 1;\n                         Some(Region::late(late_bound_idx, self.tcx.hir(), param))\n                     } else {\n-                        Some(Region::early(self.tcx.hir(), &mut next_early_index, param))\n+                        Some(Region::early(self.tcx.hir(), param))\n                     }\n                 }\n-                GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n-                    non_lifetime_count += 1;\n-                    None\n-                }\n+                GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n             })\n             .collect();\n-        let next_early_index = next_early_index + non_lifetime_count;\n \n         let binders: Vec<_> = generics\n             .params\n@@ -1512,51 +1280,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let scope = Scope::Binder {\n             hir_id,\n             lifetimes,\n-            next_early_index,\n             s: self.scope,\n-            opaque_type_parent: true,\n             scope_type: BinderScopeType::Normal,\n             where_bound_origin: None,\n         };\n         self.with(scope, walk);\n     }\n \n-    fn next_early_index_helper(&self, only_opaque_type_parent: bool) -> u32 {\n-        let mut scope = self.scope;\n-        loop {\n-            match *scope {\n-                Scope::Root => return 0,\n-\n-                Scope::Binder { next_early_index, opaque_type_parent, .. }\n-                    if (!only_opaque_type_parent || opaque_type_parent) =>\n-                {\n-                    return next_early_index;\n-                }\n-\n-                Scope::Binder { s, .. }\n-                | Scope::Body { s, .. }\n-                | Scope::Elision { s, .. }\n-                | Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::Supertrait { s, .. }\n-                | Scope::TraitRefBoundary { s, .. } => scope = s,\n-            }\n-        }\n-    }\n-\n-    /// Returns the next index one would use for an early-bound-region\n-    /// if extending the current scope.\n-    fn next_early_index(&self) -> u32 {\n-        self.next_early_index_helper(true)\n-    }\n-\n-    /// Returns the next index one would use for an `impl Trait` that\n-    /// is being converted into an opaque type alias `impl Trait`. This will be the\n-    /// next early index from the enclosing item, for the most\n-    /// part. See the `opaque_type_parent` field for more info.\n-    fn next_early_index_for_opaque_type(&self) -> u32 {\n-        self.next_early_index_helper(false)\n-    }\n-\n     #[tracing::instrument(level = \"debug\", skip(self))]\n     fn resolve_lifetime_ref(\n         &mut self,\n@@ -1679,17 +1409,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         );\n     }\n \n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     fn visit_segment_args(\n         &mut self,\n         res: Res,\n         depth: usize,\n         generic_args: &'tcx hir::GenericArgs<'tcx>,\n     ) {\n-        debug!(\n-            \"visit_segment_args(res={:?}, depth={:?}, generic_args={:?})\",\n-            res, depth, generic_args,\n-        );\n-\n         if generic_args.parenthesized {\n             self.visit_fn_like_elision(\n                 generic_args.inputs(),\n@@ -1707,13 +1433,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         // Figure out if this is a type/trait segment,\n         // which requires object lifetime defaults.\n-        let parent_def_id = |this: &mut Self, def_id: DefId| {\n-            let def_key = this.tcx.def_key(def_id);\n-            DefId { krate: def_id.krate, index: def_key.parent.expect(\"missing parent\") }\n-        };\n         let type_def_id = match res {\n-            Res::Def(DefKind::AssocTy, def_id) if depth == 1 => Some(parent_def_id(self, def_id)),\n-            Res::Def(DefKind::Variant, def_id) if depth == 0 => Some(parent_def_id(self, def_id)),\n+            Res::Def(DefKind::AssocTy, def_id) if depth == 1 => Some(self.tcx.parent(def_id)),\n+            Res::Def(DefKind::Variant, def_id) if depth == 0 => Some(self.tcx.parent(def_id)),\n             Res::Def(\n                 DefKind::Struct\n                 | DefKind::Union\n@@ -1725,7 +1447,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             _ => None,\n         };\n \n-        debug!(\"visit_segment_args: type_def_id={:?}\", type_def_id);\n+        debug!(?type_def_id);\n \n         // Compute a vector of defaults, one for each type parameter,\n         // per the rules given in RFCs 599 and 1156. Example:\n@@ -1763,55 +1485,39 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             };\n \n             let map = &self.map;\n-            let set_to_region = |set: &ObjectLifetimeDefault| match *set {\n-                Set1::Empty => {\n+            let generics = self.tcx.generics_of(def_id);\n+\n+            // `type_def_id` points to an item, so there is nothing to inherit generics from.\n+            debug_assert_eq!(generics.parent_count, 0);\n+\n+            let set_to_region = |set: ObjectLifetimeDefault| match set {\n+                ObjectLifetimeDefault::Empty => {\n                     if in_body {\n                         None\n                     } else {\n                         Some(Region::Static)\n                     }\n                 }\n-                Set1::One(r) => {\n-                    let lifetimes = generic_args.args.iter().filter_map(|arg| match arg {\n-                        GenericArg::Lifetime(lt) => Some(lt),\n+                ObjectLifetimeDefault::Static => Some(Region::Static),\n+                ObjectLifetimeDefault::Param(param_def_id) => {\n+                    // This index can be used with `generic_args` since `parent_count == 0`.\n+                    let index = generics.param_def_id_to_index[&param_def_id] as usize;\n+                    generic_args.args.get(index).and_then(|arg| match arg {\n+                        GenericArg::Lifetime(lt) => map.defs.get(&lt.hir_id).copied(),\n                         _ => None,\n-                    });\n-                    r.subst(lifetimes, map)\n+                    })\n                 }\n-                Set1::Many => None,\n+                ObjectLifetimeDefault::Ambiguous => None,\n             };\n-            if let Some(def_id) = def_id.as_local() {\n-                let id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-                self.tcx\n-                    .object_lifetime_defaults(id.owner)\n-                    .unwrap()\n-                    .iter()\n-                    .map(set_to_region)\n-                    .collect()\n-            } else {\n-                let tcx = self.tcx;\n-                self.xcrate_object_lifetime_defaults\n-                    .entry(def_id)\n-                    .or_insert_with(|| {\n-                        tcx.generics_of(def_id)\n-                            .params\n-                            .iter()\n-                            .filter_map(|param| match param.kind {\n-                                GenericParamDefKind::Type { object_lifetime_default, .. } => {\n-                                    Some(object_lifetime_default)\n-                                }\n-                                GenericParamDefKind::Const { .. } => Some(Set1::Empty),\n-                                GenericParamDefKind::Lifetime => None,\n-                            })\n-                            .collect()\n-                    })\n-                    .iter()\n-                    .map(set_to_region)\n-                    .collect()\n-            }\n+            generics\n+                .params\n+                .iter()\n+                .filter_map(|param| self.tcx.object_lifetime_default(param.def_id))\n+                .map(set_to_region)\n+                .collect()\n         });\n \n-        debug!(\"visit_segment_args: object_lifetime_defaults={:?}\", object_lifetime_defaults);\n+        debug!(?object_lifetime_defaults);\n \n         let mut i = 0;\n         for arg in generic_args.args {"}, {"sha": "5c96f1c4623a6c9010633d79951b1af3023c96c4", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=5555e13a6ec5268612e85baa3af62ddf95fa2517", "patch": "@@ -222,9 +222,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 tcx.mk_region(ty::ReLateBound(debruijn, br))\n             }\n \n-            Some(rl::Region::EarlyBound(index, id)) => {\n-                let name = lifetime_name(id.expect_local());\n-                tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion { def_id: id, index, name }))\n+            Some(rl::Region::EarlyBound(def_id)) => {\n+                let name = tcx.hir().ty_param_name(def_id.expect_local());\n+                let item_def_id = tcx.hir().ty_param_owner(def_id.expect_local());\n+                let generics = tcx.generics_of(item_def_id);\n+                let index = generics.param_def_id_to_index[&def_id];\n+                tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion { def_id, index, name }))\n             }\n \n             Some(rl::Region::Free(scope, id)) => {\n@@ -253,9 +256,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 })\n             }\n         };\n-\n         debug!(\"ast_region_to_region(lifetime={:?}) yields {:?}\", lifetime, r);\n-\n         r\n     }\n \n@@ -2853,10 +2854,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             );\n \n             if !infer_replacements.is_empty() {\n-                diag.multipart_suggestion(&format!(\n+                diag.multipart_suggestion(\n+                    &format!(\n                     \"try replacing `_` with the type{} in the corresponding trait method signature\",\n                     rustc_errors::pluralize!(infer_replacements.len()),\n-                ), infer_replacements, Applicability::MachineApplicable);\n+                ),\n+                    infer_replacements,\n+                    Applicability::MachineApplicable,\n+                );\n             }\n \n             diag.emit();"}, {"sha": "6236ad370df60e1bcd30a14c92b70a2fbd498dac", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5555e13a6ec5268612e85baa3af62ddf95fa2517/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=5555e13a6ec5268612e85baa3af62ddf95fa2517", "patch": "@@ -1617,7 +1617,6 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n                         pure_wrt_drop: false,\n                         kind: ty::GenericParamDefKind::Type {\n                             has_default: false,\n-                            object_lifetime_default: rl::Set1::Empty,\n                             synthetic: false,\n                         },\n                     });\n@@ -1661,8 +1660,6 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n         kind: ty::GenericParamDefKind::Lifetime,\n     }));\n \n-    let object_lifetime_defaults = tcx.object_lifetime_defaults(hir_id.owner);\n-\n     // Now create the real type and const parameters.\n     let type_start = own_start - has_self as u32 + params.len() as u32;\n     let mut i = 0;\n@@ -1687,13 +1684,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n                 }\n             }\n \n-            let kind = ty::GenericParamDefKind::Type {\n-                has_default: default.is_some(),\n-                object_lifetime_default: object_lifetime_defaults\n-                    .as_ref()\n-                    .map_or(rl::Set1::Empty, |o| o[i]),\n-                synthetic,\n-            };\n+            let kind = ty::GenericParamDefKind::Type { has_default: default.is_some(), synthetic };\n \n             let param_def = ty::GenericParamDef {\n                 index: type_start + i as u32,\n@@ -1745,11 +1736,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n             name: Symbol::intern(arg),\n             def_id,\n             pure_wrt_drop: false,\n-            kind: ty::GenericParamDefKind::Type {\n-                has_default: false,\n-                object_lifetime_default: rl::Set1::Empty,\n-                synthetic: false,\n-            },\n+            kind: ty::GenericParamDefKind::Type { has_default: false, synthetic: false },\n         }));\n     }\n \n@@ -1762,11 +1749,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n                 name: Symbol::intern(\"<const_ty>\"),\n                 def_id,\n                 pure_wrt_drop: false,\n-                kind: ty::GenericParamDefKind::Type {\n-                    has_default: false,\n-                    object_lifetime_default: rl::Set1::Empty,\n-                    synthetic: false,\n-                },\n+                kind: ty::GenericParamDefKind::Type { has_default: false, synthetic: false },\n             });\n         }\n     }"}, {"sha": "c425de081a6a6e4ac964362cbf7e2a1c9e3a177a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5555e13a6ec5268612e85baa3af62ddf95fa2517/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5555e13a6ec5268612e85baa3af62ddf95fa2517/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5555e13a6ec5268612e85baa3af62ddf95fa2517", "patch": "@@ -192,7 +192,7 @@ fn clean_poly_trait_ref_with_bindings<'tcx>(\n fn clean_lifetime<'tcx>(lifetime: hir::Lifetime, cx: &mut DocContext<'tcx>) -> Lifetime {\n     let def = cx.tcx.named_region(lifetime.hir_id);\n     if let Some(\n-        rl::Region::EarlyBound(_, node_id)\n+        rl::Region::EarlyBound(node_id)\n         | rl::Region::LateBound(_, _, node_id)\n         | rl::Region::Free(_, node_id),\n     ) = def"}, {"sha": "0f8898c389b7f4b33a819f03ff42622696884748", "filename": "src/test/incremental/hashes/enum_defs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5555e13a6ec5268612e85baa3af62ddf95fa2517/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5555e13a6ec5268612e85baa3af62ddf95fa2517/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs?ref=5555e13a6ec5268612e85baa3af62ddf95fa2517", "patch": "@@ -504,9 +504,9 @@ enum EnumAddLifetimeBoundToParameter<'a, T> {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,predicates_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes,predicates_of\")]\n #[rustc_clean(cfg=\"cfail6\")]\n enum EnumAddLifetimeBoundToParameter<'a, T: 'a> {\n     Variant1(T),\n@@ -559,9 +559,9 @@ enum EnumAddLifetimeBoundToParameterWhere<'a, T> {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,predicates_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes,predicates_of\")]\n #[rustc_clean(cfg=\"cfail6\")]\n enum EnumAddLifetimeBoundToParameterWhere<'a, T> where T: 'a {\n     Variant1(T),"}, {"sha": "c453eeceb77f53b1266e25a5eccef6a814f5a297", "filename": "src/test/incremental/hashes/trait_defs.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5555e13a6ec5268612e85baa3af62ddf95fa2517/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5555e13a6ec5268612e85baa3af62ddf95fa2517/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs?ref=5555e13a6ec5268612e85baa3af62ddf95fa2517", "patch": "@@ -1066,9 +1066,9 @@ trait TraitAddTraitBoundToTypeParameterOfTrait<T: ReferencedTrait0> { }\n trait TraitAddLifetimeBoundToTypeParameterOfTrait<'a, T> { }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"hir_owner,hir_owner_nodes,predicates_of\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of\", cfg=\"cfail5\")]\n+#[rustc_clean(except=\"hir_owner,hir_owner_nodes,predicates_of\", cfg=\"cfail5\")]\n #[rustc_clean(cfg=\"cfail6\")]\n trait TraitAddLifetimeBoundToTypeParameterOfTrait<'a, T: 'a> { }\n \n@@ -1144,9 +1144,9 @@ trait TraitAddSecondTraitBoundToTypeParameterOfTrait<T: ReferencedTrait0 + Refer\n trait TraitAddSecondLifetimeBoundToTypeParameterOfTrait<'a, 'b, T: 'a> { }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"hir_owner,hir_owner_nodes,predicates_of\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of\", cfg=\"cfail5\")]\n+#[rustc_clean(except=\"hir_owner,hir_owner_nodes,predicates_of\", cfg=\"cfail5\")]\n #[rustc_clean(cfg=\"cfail6\")]\n trait TraitAddSecondLifetimeBoundToTypeParameterOfTrait<'a, 'b, T: 'a + 'b> { }\n \n@@ -1201,9 +1201,9 @@ trait TraitAddTraitBoundToTypeParameterOfTraitWhere<T> where T: ReferencedTrait0\n trait TraitAddLifetimeBoundToTypeParameterOfTraitWhere<'a, T> { }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"hir_owner,hir_owner_nodes,predicates_of\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of\", cfg=\"cfail5\")]\n+#[rustc_clean(except=\"hir_owner,hir_owner_nodes,predicates_of\", cfg=\"cfail5\")]\n #[rustc_clean(cfg=\"cfail6\")]\n trait TraitAddLifetimeBoundToTypeParameterOfTraitWhere<'a, T> where T: 'a { }\n \n@@ -1254,9 +1254,9 @@ trait TraitAddSecondTraitBoundToTypeParameterOfTraitWhere<T>\n trait TraitAddSecondLifetimeBoundToTypeParameterOfTraitWhere<'a, 'b, T> where T: 'a { }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"hir_owner,hir_owner_nodes,predicates_of\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of\", cfg=\"cfail5\")]\n+#[rustc_clean(except=\"hir_owner,hir_owner_nodes,predicates_of\", cfg=\"cfail5\")]\n #[rustc_clean(cfg=\"cfail6\")]\n trait TraitAddSecondLifetimeBoundToTypeParameterOfTraitWhere<'a, 'b, T> where T: 'a + 'b { }\n "}]}