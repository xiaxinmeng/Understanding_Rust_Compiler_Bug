{"sha": "4b413bc393d8cde89ce0d687c3ef4ea50374af2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiNDEzYmMzOTNkOGNkZTg5Y2UwZDY4N2MzZWY0ZWE1MDM3NGFmMmM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-02-02T00:33:42Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-02-12T03:22:52Z"}, "message": "Move legacy custom derives collection into `resolver.find_attr_invoc()`.", "tree": {"sha": "458e236cbefa1d346792e21f35017368b64ff9aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/458e236cbefa1d346792e21f35017368b64ff9aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b413bc393d8cde89ce0d687c3ef4ea50374af2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b413bc393d8cde89ce0d687c3ef4ea50374af2c", "html_url": "https://github.com/rust-lang/rust/commit/4b413bc393d8cde89ce0d687c3ef4ea50374af2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b413bc393d8cde89ce0d687c3ef4ea50374af2c/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba7cf7cc5daefb9f28371b8be87dc262fb55937c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba7cf7cc5daefb9f28371b8be87dc262fb55937c", "html_url": "https://github.com/rust-lang/rust/commit/ba7cf7cc5daefb9f28371b8be87dc262fb55937c"}], "stats": {"total": 93, "additions": 56, "deletions": 37}, "files": [{"sha": "a1699784b9db26d6dbea8254d330719a3c689dd6", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 55, "deletions": 2, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4b413bc393d8cde89ce0d687c3ef4ea50374af2c/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b413bc393d8cde89ce0d687c3ef4ea50374af2c/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=4b413bc393d8cde89ce0d687c3ef4ea50374af2c", "patch": "@@ -27,10 +27,10 @@ use syntax::ext::base::{NormalTT, Resolver as SyntaxResolver, SyntaxExtension};\n use syntax::ext::expand::{Expansion, mark_tts};\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n-use syntax::feature_gate::{emit_feature_err, GateIssue, is_builtin_attr};\n+use syntax::feature_gate::{self, emit_feature_err, GateIssue, is_builtin_attr};\n use syntax::fold::{self, Folder};\n use syntax::ptr::P;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{Symbol, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::visit::Visitor;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -188,6 +188,49 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 return Some(attrs.remove(i));\n             }\n         }\n+\n+        // Check for legacy derives\n+        for i in 0..attrs.len() {\n+            if attrs[i].name() == \"derive\" {\n+                let mut traits = match attrs[i].meta_item_list() {\n+                    Some(traits) if !traits.is_empty() => traits.to_owned(),\n+                    _ => continue,\n+                };\n+\n+                for j in 0..traits.len() {\n+                    let legacy_name = Symbol::intern(&match traits[j].word() {\n+                        Some(..) => format!(\"derive_{}\", traits[j].name().unwrap()),\n+                        None => continue,\n+                    });\n+                    if !self.builtin_macros.contains_key(&legacy_name) {\n+                        continue\n+                    }\n+                    let span = traits.remove(j).span;\n+                    self.gate_legacy_custom_derive(legacy_name, span);\n+                    if traits.is_empty() {\n+                        attrs.remove(i);\n+                    } else {\n+                        attrs[i].value = ast::MetaItem {\n+                            name: attrs[i].name(),\n+                            span: span,\n+                            node: ast::MetaItemKind::List(traits),\n+                        };\n+                    }\n+                    return Some(ast::Attribute {\n+                        value: ast::MetaItem {\n+                            name: legacy_name,\n+                            span: span,\n+                            node: ast::MetaItemKind::Word,\n+                        },\n+                        id: attr::mk_attr_id(),\n+                        style: ast::AttrStyle::Outer,\n+                        is_sugared_doc: false,\n+                        span: span,\n+                    });\n+                }\n+            }\n+        }\n+\n         None\n     }\n \n@@ -540,4 +583,14 @@ impl<'a> Resolver<'a> {\n                              `use {}::{};`\", crate_name, name))\n             .emit();\n     }\n+\n+    fn gate_legacy_custom_derive(&mut self, name: Symbol, span: Span) {\n+        if !self.session.features.borrow().custom_derive {\n+            let sess = &self.session.parse_sess;\n+            let explain = feature_gate::EXPLAIN_CUSTOM_DERIVE;\n+            emit_feature_err(sess, \"custom_derive\", span, GateIssue::Language, explain);\n+        } else if !self.is_whitelisted_legacy_custom_derive(name) {\n+            self.session.span_warn(span, feature_gate::EXPLAIN_DEPR_CUSTOM_DERIVE);\n+        }\n+    }\n }"}, {"sha": "ba14a153ed29f2db8f5b5e3c0f3748dd6c2ce1b5", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4b413bc393d8cde89ce0d687c3ef4ea50374af2c/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b413bc393d8cde89ce0d687c3ef4ea50374af2c/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=4b413bc393d8cde89ce0d687c3ef4ea50374af2c", "patch": "@@ -13,7 +13,6 @@ use attr;\n use ast::{self, NestedMetaItem}; use ext::base::{ExtCtxt, SyntaxExtension};\n use codemap;\n use ext::build::AstBuilder;\n-use feature_gate;\n use symbol::Symbol;\n use syntax_pos::Span;\n \n@@ -64,20 +63,13 @@ pub fn verify_derive_attrs(cx: &mut ExtCtxt, attrs: &[ast::Attribute]) {\n \n #[derive(PartialEq, Debug, Clone, Copy)]\n pub enum DeriveType {\n-    Legacy,\n     ProcMacro,\n     Builtin\n }\n \n impl DeriveType {\n     // Classify a derive trait name by resolving the macro.\n     pub fn classify(cx: &mut ExtCtxt, tname: Name) -> DeriveType {\n-        let legacy_derive_name = Symbol::intern(&format!(\"derive_{}\", tname));\n-\n-        if let Ok(_) = cx.resolver.resolve_builtin_macro(legacy_derive_name) {\n-            return DeriveType::Legacy;\n-        }\n-\n         match cx.resolver.resolve_builtin_macro(tname) {\n             Ok(ext) => match *ext {\n                 SyntaxExtension::BuiltinDerive(..) => DeriveType::Builtin,\n@@ -185,33 +177,7 @@ pub fn add_derived_markers(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>) {\n pub fn find_derive_attr(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>)\n                         -> Option<ast::Attribute> {\n     verify_derive_attrs(cx, attrs);\n-    get_derive_attr(cx, attrs, DeriveType::Legacy).and_then(|a| {\n-        let titem = derive_attr_trait(cx, &a);\n-        titem.and_then(|titem| {\n-            let tword = titem.word().unwrap();\n-            let tname = tword.name();\n-            if !cx.ecfg.enable_custom_derive() {\n-                feature_gate::emit_feature_err(\n-                    &cx.parse_sess,\n-                    \"custom_derive\",\n-                    titem.span,\n-                    feature_gate::GateIssue::Language,\n-                    feature_gate::EXPLAIN_CUSTOM_DERIVE\n-                );\n-                None\n-            } else {\n-                let name = Symbol::intern(&format!(\"derive_{}\", tname));\n-                if !cx.resolver.is_whitelisted_legacy_custom_derive(name) {\n-                    cx.span_warn(titem.span,\n-                                 feature_gate::EXPLAIN_DEPR_CUSTOM_DERIVE);\n-                }\n-                let mitem = cx.meta_word(titem.span, name);\n-                Some(cx.attribute(mitem.span, mitem))\n-            }\n-        })\n-    }).or_else(|| {\n-        get_derive_attr(cx, attrs, DeriveType::ProcMacro)\n-    }).or_else(|| {\n+    get_derive_attr(cx, attrs, DeriveType::ProcMacro).or_else(|| {\n         add_derived_markers(cx, attrs);\n         get_derive_attr(cx, attrs, DeriveType::Builtin)\n     })"}]}