{"sha": "4fe88c05cd14fa182fd58cc68127f98aca77d1ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmZTg4YzA1Y2QxNGZhMTgyZmQ1OGNjNjgxMjdmOThhY2E3N2QxZmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-23T14:33:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-23T14:33:10Z"}, "message": "Auto merge of #51727 - varkor:expragain-to-exprcontinue, r=petrochenkov\n\nRename hir::ExprAgain to hir::ExprContinue\n\nThe current name is confusing and historical.\n\nI also used this PR to clean up the annoying indentation in `check/mod.rs`. If that's viewed as too tangential a change, I'll split it up, but it seemed reasonable to slip it in to reduce @bors's work. It's easy to compare for the two commits individually.\n\nr? @petrochenkov", "tree": {"sha": "ee8d7190f396bcc70bffcdf7c70670852c6f6faf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee8d7190f396bcc70bffcdf7c70670852c6f6faf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4fe88c05cd14fa182fd58cc68127f98aca77d1ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4fe88c05cd14fa182fd58cc68127f98aca77d1ff", "html_url": "https://github.com/rust-lang/rust/commit/4fe88c05cd14fa182fd58cc68127f98aca77d1ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a51e8071366474e80976eb7e487c0012b435dcef", "url": "https://api.github.com/repos/rust-lang/rust/commits/a51e8071366474e80976eb7e487c0012b435dcef", "html_url": "https://github.com/rust-lang/rust/commit/a51e8071366474e80976eb7e487c0012b435dcef"}, {"sha": "621047b2b0820f9f9962ae278b0093da398fff20", "url": "https://api.github.com/repos/rust-lang/rust/commits/621047b2b0820f9f9962ae278b0093da398fff20", "html_url": "https://github.com/rust-lang/rust/commit/621047b2b0820f9f9962ae278b0093da398fff20"}], "stats": {"total": 1080, "additions": 540, "deletions": 540}, "files": [{"sha": "f52d201abecb90a6bee88466146fefe33650519e", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=4fe88c05cd14fa182fd58cc68127f98aca77d1ff", "patch": "@@ -335,7 +335,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_unreachable_node()\n             }\n \n-            hir::ExprAgain(destination) => {\n+            hir::ExprContinue(destination) => {\n                 let (target_scope, cont_dest) =\n                     self.find_scope_edge(expr, destination, ScopeCfKind::Continue);\n                 let a = self.add_ast_node(expr.hir_id.local_id, &[pred]);"}, {"sha": "2a351d99841ff1a5acd4faab6a9e3fd21a4b3ca5", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=4fe88c05cd14fa182fd58cc68127f98aca77d1ff", "patch": "@@ -1068,7 +1068,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             }\n             walk_list!(visitor, visit_expr, opt_expr);\n         }\n-        ExprAgain(ref destination) => {\n+        ExprContinue(ref destination) => {\n             if let Some(ref label) = destination.label {\n                 visitor.visit_label(label);\n                 match destination.target_id {"}, {"sha": "02e9415fd8e3c401780c948b4ceaa7ae173a62b0", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=4fe88c05cd14fa182fd58cc68127f98aca77d1ff", "patch": "@@ -3731,7 +3731,7 @@ impl<'a> LoweringContext<'a> {\n                 )\n             }\n             ExprKind::Continue(opt_label) => {\n-                hir::ExprAgain(if self.is_in_loop_condition && opt_label.is_none() {\n+                hir::ExprContinue(if self.is_in_loop_condition && opt_label.is_none() {\n                     hir::Destination {\n                         label: None,\n                         target_id: Err(hir::LoopIdError::UnlabeledCfInWhileCondition).into(),"}, {"sha": "5f6921c7a87cc860d430b12f20f6fb10fae0474b", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=4fe88c05cd14fa182fd58cc68127f98aca77d1ff", "patch": "@@ -1279,7 +1279,7 @@ impl Expr {\n             ExprPath(..) => ExprPrecedence::Path,\n             ExprAddrOf(..) => ExprPrecedence::AddrOf,\n             ExprBreak(..) => ExprPrecedence::Break,\n-            ExprAgain(..) => ExprPrecedence::Continue,\n+            ExprContinue(..) => ExprPrecedence::Continue,\n             ExprRet(..) => ExprPrecedence::Ret,\n             ExprInlineAsm(..) => ExprPrecedence::InlineAsm,\n             ExprStruct(..) => ExprPrecedence::Struct,\n@@ -1374,7 +1374,7 @@ pub enum Expr_ {\n     /// A `break`, with an optional label to break\n     ExprBreak(Destination, Option<P<Expr>>),\n     /// A `continue`, with an optional label\n-    ExprAgain(Destination),\n+    ExprContinue(Destination),\n     /// A `return`, with an optional value to be returned\n     ExprRet(Option<P<Expr>>),\n "}, {"sha": "6db4e987840bbb2b724e7008b8d07d354a15207c", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=4fe88c05cd14fa182fd58cc68127f98aca77d1ff", "patch": "@@ -1475,7 +1475,7 @@ impl<'a> State<'a> {\n                     self.s.space()?;\n                 }\n             }\n-            hir::ExprAgain(destination) => {\n+            hir::ExprContinue(destination) => {\n                 self.s.word(\"continue\")?;\n                 self.s.space()?;\n                 if let Some(label) = destination.label {"}, {"sha": "b71b69474a72051efee603b7bc5149a2bf6bf928", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=4fe88c05cd14fa182fd58cc68127f98aca77d1ff", "patch": "@@ -621,7 +621,7 @@ impl_stable_hash_for!(enum hir::Expr_ {\n     ExprPath(path),\n     ExprAddrOf(mutability, sub),\n     ExprBreak(destination, sub),\n-    ExprAgain(destination),\n+    ExprContinue(destination),\n     ExprRet(val),\n     ExprInlineAsm(asm, inputs, outputs),\n     ExprStruct(path, fields, base),"}, {"sha": "718445bd3563e2908dc97ad53042a7122f7e56c1", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=4fe88c05cd14fa182fd58cc68127f98aca77d1ff", "patch": "@@ -479,7 +479,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.consume_exprs(inputs);\n             }\n \n-            hir::ExprAgain(..) |\n+            hir::ExprContinue(..) |\n             hir::ExprLit(..) => {}\n \n             hir::ExprLoop(ref blk, _, _) => {"}, {"sha": "b98a4416d213f32ce2c7a65c90154eab153ac7d4", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=4fe88c05cd14fa182fd58cc68127f98aca77d1ff", "patch": "@@ -502,7 +502,7 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n       hir::ExprArray(..) | hir::ExprCall(..) | hir::ExprMethodCall(..) |\n       hir::ExprTup(..) | hir::ExprBinary(..) | hir::ExprAddrOf(..) |\n       hir::ExprCast(..) | hir::ExprUnary(..) | hir::ExprBreak(..) |\n-      hir::ExprAgain(_) | hir::ExprLit(_) | hir::ExprRet(..) |\n+      hir::ExprContinue(_) | hir::ExprLit(_) | hir::ExprRet(..) |\n       hir::ExprBlock(..) | hir::ExprAssign(..) | hir::ExprAssignOp(..) |\n       hir::ExprStruct(..) | hir::ExprRepeat(..) |\n       hir::ExprInlineAsm(..) | hir::ExprBox(..) | hir::ExprYield(..) |\n@@ -1047,7 +1047,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               }\n           }\n \n-          hir::ExprAgain(label) => {\n+          hir::ExprContinue(label) => {\n               // Find which label this expr continues to\n               let sc = match label.target_id {\n                     Ok(node_id) => node_id,\n@@ -1431,7 +1431,7 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n       hir::ExprIndex(..) | hir::ExprField(..) |\n       hir::ExprArray(..) | hir::ExprTup(..) | hir::ExprBinary(..) |\n       hir::ExprCast(..) | hir::ExprUnary(..) | hir::ExprRet(..) |\n-      hir::ExprBreak(..) | hir::ExprAgain(..) | hir::ExprLit(_) |\n+      hir::ExprBreak(..) | hir::ExprContinue(..) | hir::ExprLit(_) |\n       hir::ExprBlock(..) | hir::ExprAddrOf(..) |\n       hir::ExprStruct(..) | hir::ExprRepeat(..) |\n       hir::ExprClosure(..) | hir::ExprPath(_) | hir::ExprYield(..) |"}, {"sha": "e3b59d25ab91f04c324bdfec65e91e93355cc03c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=4fe88c05cd14fa182fd58cc68127f98aca77d1ff", "patch": "@@ -686,7 +686,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n           hir::ExprBinary(..) | hir::ExprWhile(..) |\n           hir::ExprBlock(..) | hir::ExprLoop(..) | hir::ExprMatch(..) |\n           hir::ExprLit(..) | hir::ExprBreak(..) |\n-          hir::ExprAgain(..) | hir::ExprStruct(..) | hir::ExprRepeat(..) |\n+          hir::ExprContinue(..) | hir::ExprStruct(..) | hir::ExprRepeat(..) |\n           hir::ExprInlineAsm(..) | hir::ExprBox(..) => {\n             Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n           }"}, {"sha": "9c6c35a340e2fd7d1f1dc8591385baad7dd20fbb", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=4fe88c05cd14fa182fd58cc68127f98aca77d1ff", "patch": "@@ -543,7 +543,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 Err(err) => bug!(\"invalid loop id for break: {}\", err)\n             }\n         }\n-        hir::ExprAgain(dest) => {\n+        hir::ExprContinue(dest) => {\n             match dest.target_id {\n                 Ok(loop_id) => ExprKind::Continue {\n                     label: region::Scope::Node(cx.tcx.hir.node_to_hir_id(loop_id).local_id),"}, {"sha": "c99f1e9da439f04ce9b3133814123ed977511745", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=4fe88c05cd14fa182fd58cc68127f98aca77d1ff", "patch": "@@ -148,7 +148,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n \n                 self.require_break_cx(\"break\", e.span);\n             }\n-            hir::ExprAgain(label) => {\n+            hir::ExprContinue(label) => {\n                 self.require_label_in_labeled_block(e.span, &label, \"continue\");\n \n                 match label.target_id {"}, {"sha": "e9d03daa7ea06b82dd3d5e5794f4f9883204edfc", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=4fe88c05cd14fa182fd58cc68127f98aca77d1ff", "patch": "@@ -469,7 +469,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n \n         // More control flow (also not very meaningful).\n         hir::ExprBreak(..) |\n-        hir::ExprAgain(_) |\n+        hir::ExprContinue(_) |\n         hir::ExprRet(_) |\n \n         // Generator expressions"}, {"sha": "e84586520b1e4421286ac96df63d7aa1c1c56591", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 525, "deletions": 525, "changes": 1050, "blob_url": "https://github.com/rust-lang/rust/blob/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe88c05cd14fa182fd58cc68127f98aca77d1ff/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4fe88c05cd14fa182fd58cc68127f98aca77d1ff", "patch": "@@ -2331,7 +2331,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::ExprRepeat(..) |\n             hir::ExprArray(..) |\n             hir::ExprBreak(..) |\n-            hir::ExprAgain(..) |\n+            hir::ExprContinue(..) |\n             hir::ExprRet(..) |\n             hir::ExprWhile(..) |\n             hir::ExprLoop(..) |\n@@ -3611,579 +3611,579 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx;\n         let id = expr.id;\n         match expr.node {\n-          hir::ExprBox(ref subexpr) => {\n-            let expected_inner = expected.to_option(self).map_or(NoExpectation, |ty| {\n-                match ty.sty {\n-                    ty::TyAdt(def, _) if def.is_box()\n-                        => Expectation::rvalue_hint(self, ty.boxed_ty()),\n-                    _ => NoExpectation\n-                }\n-            });\n-            let referent_ty = self.check_expr_with_expectation(subexpr, expected_inner);\n-            tcx.mk_box(referent_ty)\n-          }\n-\n-          hir::ExprLit(ref lit) => {\n-            self.check_lit(&lit, expected)\n-          }\n-          hir::ExprBinary(op, ref lhs, ref rhs) => {\n-            self.check_binop(expr, op, lhs, rhs)\n-          }\n-          hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-            self.check_binop_assign(expr, op, lhs, rhs)\n-          }\n-          hir::ExprUnary(unop, ref oprnd) => {\n-            let expected_inner = match unop {\n-                hir::UnNot | hir::UnNeg => {\n-                    expected\n-                }\n-                hir::UnDeref => {\n-                    NoExpectation\n-                }\n-            };\n-            let needs = match unop {\n-                hir::UnDeref => needs,\n-                _ => Needs::None\n-            };\n-            let mut oprnd_t = self.check_expr_with_expectation_and_needs(&oprnd,\n-                                                                               expected_inner,\n-                                                                               needs);\n+            hir::ExprBox(ref subexpr) => {\n+                let expected_inner = expected.to_option(self).map_or(NoExpectation, |ty| {\n+                    match ty.sty {\n+                        ty::TyAdt(def, _) if def.is_box()\n+                            => Expectation::rvalue_hint(self, ty.boxed_ty()),\n+                        _ => NoExpectation\n+                    }\n+                });\n+                let referent_ty = self.check_expr_with_expectation(subexpr, expected_inner);\n+                tcx.mk_box(referent_ty)\n+            }\n \n-            if !oprnd_t.references_error() {\n-                oprnd_t = self.structurally_resolved_type(expr.span, oprnd_t);\n-                match unop {\n+            hir::ExprLit(ref lit) => {\n+                self.check_lit(&lit, expected)\n+            }\n+            hir::ExprBinary(op, ref lhs, ref rhs) => {\n+                self.check_binop(expr, op, lhs, rhs)\n+            }\n+            hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n+                self.check_binop_assign(expr, op, lhs, rhs)\n+            }\n+            hir::ExprUnary(unop, ref oprnd) => {\n+                let expected_inner = match unop {\n+                    hir::UnNot | hir::UnNeg => {\n+                        expected\n+                    }\n                     hir::UnDeref => {\n-                        if let Some(mt) = oprnd_t.builtin_deref(true) {\n-                            oprnd_t = mt.ty;\n-                        } else if let Some(ok) = self.try_overloaded_deref(\n-                                expr.span, oprnd_t, needs) {\n-                            let method = self.register_infer_ok_obligations(ok);\n-                            if let ty::TyRef(region, _, mutbl) = method.sig.inputs()[0].sty {\n-                                let mutbl = match mutbl {\n-                                    hir::MutImmutable => AutoBorrowMutability::Immutable,\n-                                    hir::MutMutable => AutoBorrowMutability::Mutable {\n-                                        // (It shouldn't actually matter for unary ops whether\n-                                        // we enable two-phase borrows or not, since a unary\n-                                        // op has no additional operands.)\n-                                        allow_two_phase_borrow: AllowTwoPhase::No,\n-                                    }\n-                                };\n-                                self.apply_adjustments(oprnd, vec![Adjustment {\n-                                    kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n-                                    target: method.sig.inputs()[0]\n-                                }]);\n+                        NoExpectation\n+                    }\n+                };\n+                let needs = match unop {\n+                    hir::UnDeref => needs,\n+                    _ => Needs::None\n+                };\n+                let mut oprnd_t = self.check_expr_with_expectation_and_needs(&oprnd,\n+                                                                                    expected_inner,\n+                                                                                    needs);\n+\n+                if !oprnd_t.references_error() {\n+                    oprnd_t = self.structurally_resolved_type(expr.span, oprnd_t);\n+                    match unop {\n+                        hir::UnDeref => {\n+                            if let Some(mt) = oprnd_t.builtin_deref(true) {\n+                                oprnd_t = mt.ty;\n+                            } else if let Some(ok) = self.try_overloaded_deref(\n+                                    expr.span, oprnd_t, needs) {\n+                                let method = self.register_infer_ok_obligations(ok);\n+                                if let ty::TyRef(region, _, mutbl) = method.sig.inputs()[0].sty {\n+                                    let mutbl = match mutbl {\n+                                        hir::MutImmutable => AutoBorrowMutability::Immutable,\n+                                        hir::MutMutable => AutoBorrowMutability::Mutable {\n+                                            // (It shouldn't actually matter for unary ops whether\n+                                            // we enable two-phase borrows or not, since a unary\n+                                            // op has no additional operands.)\n+                                            allow_two_phase_borrow: AllowTwoPhase::No,\n+                                        }\n+                                    };\n+                                    self.apply_adjustments(oprnd, vec![Adjustment {\n+                                        kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n+                                        target: method.sig.inputs()[0]\n+                                    }]);\n+                                }\n+                                oprnd_t = self.make_overloaded_place_return_type(method).ty;\n+                                self.write_method_call(expr.hir_id, method);\n+                            } else {\n+                                type_error_struct!(tcx.sess, expr.span, oprnd_t, E0614,\n+                                                    \"type `{}` cannot be dereferenced\",\n+                                                    oprnd_t).emit();\n+                                oprnd_t = tcx.types.err;\n                             }\n-                            oprnd_t = self.make_overloaded_place_return_type(method).ty;\n-                            self.write_method_call(expr.hir_id, method);\n-                        } else {\n-                            type_error_struct!(tcx.sess, expr.span, oprnd_t, E0614,\n-                                               \"type `{}` cannot be dereferenced\",\n-                                               oprnd_t).emit();\n-                            oprnd_t = tcx.types.err;\n                         }\n-                    }\n-                    hir::UnNot => {\n-                        let result = self.check_user_unop(expr, oprnd_t, unop);\n-                        // If it's builtin, we can reuse the type, this helps inference.\n-                        if !(oprnd_t.is_integral() || oprnd_t.sty == ty::TyBool) {\n-                            oprnd_t = result;\n+                        hir::UnNot => {\n+                            let result = self.check_user_unop(expr, oprnd_t, unop);\n+                            // If it's builtin, we can reuse the type, this helps inference.\n+                            if !(oprnd_t.is_integral() || oprnd_t.sty == ty::TyBool) {\n+                                oprnd_t = result;\n+                            }\n+                        }\n+                        hir::UnNeg => {\n+                            let result = self.check_user_unop(expr, oprnd_t, unop);\n+                            // If it's builtin, we can reuse the type, this helps inference.\n+                            if !(oprnd_t.is_integral() || oprnd_t.is_fp()) {\n+                                oprnd_t = result;\n+                            }\n                         }\n                     }\n-                    hir::UnNeg => {\n-                        let result = self.check_user_unop(expr, oprnd_t, unop);\n-                        // If it's builtin, we can reuse the type, this helps inference.\n-                        if !(oprnd_t.is_integral() || oprnd_t.is_fp()) {\n-                            oprnd_t = result;\n+                }\n+                oprnd_t\n+            }\n+            hir::ExprAddrOf(mutbl, ref oprnd) => {\n+                let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n+                    match ty.sty {\n+                        ty::TyRef(_, ty, _) | ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n+                            if self.is_place_expr(&oprnd) {\n+                                // Places may legitimately have unsized types.\n+                                // For example, dereferences of a fat pointer and\n+                                // the last field of a struct can be unsized.\n+                                ExpectHasType(ty)\n+                            } else {\n+                                Expectation::rvalue_hint(self, ty)\n+                            }\n                         }\n+                        _ => NoExpectation\n                     }\n+                });\n+                let needs = Needs::maybe_mut_place(mutbl);\n+                let ty = self.check_expr_with_expectation_and_needs(&oprnd, hint, needs);\n+\n+                let tm = ty::TypeAndMut { ty: ty, mutbl: mutbl };\n+                if tm.ty.references_error() {\n+                    tcx.types.err\n+                } else {\n+                    // Note: at this point, we cannot say what the best lifetime\n+                    // is to use for resulting pointer.  We want to use the\n+                    // shortest lifetime possible so as to avoid spurious borrowck\n+                    // errors.  Moreover, the longest lifetime will depend on the\n+                    // precise details of the value whose address is being taken\n+                    // (and how long it is valid), which we don't know yet until type\n+                    // inference is complete.\n+                    //\n+                    // Therefore, here we simply generate a region variable.  The\n+                    // region inferencer will then select the ultimate value.\n+                    // Finally, borrowck is charged with guaranteeing that the\n+                    // value whose address was taken can actually be made to live\n+                    // as long as it needs to live.\n+                    let region = self.next_region_var(infer::AddrOfRegion(expr.span));\n+                    tcx.mk_ref(region, tm)\n                 }\n             }\n-            oprnd_t\n-          }\n-          hir::ExprAddrOf(mutbl, ref oprnd) => {\n-            let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n-                match ty.sty {\n-                    ty::TyRef(_, ty, _) | ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n-                        if self.is_place_expr(&oprnd) {\n-                            // Places may legitimately have unsized types.\n-                            // For example, dereferences of a fat pointer and\n-                            // the last field of a struct can be unsized.\n-                            ExpectHasType(ty)\n+            hir::ExprPath(ref qpath) => {\n+                let (def, opt_ty, segs) = self.resolve_ty_and_def_ufcs(qpath, expr.id, expr.span);\n+                let ty = if def != Def::Err {\n+                    self.instantiate_value_path(segs, opt_ty, def, expr.span, id)\n+                } else {\n+                    self.set_tainted_by_errors();\n+                    tcx.types.err\n+                };\n+\n+                // We always require that the type provided as the value for\n+                // a type parameter outlives the moment of instantiation.\n+                let substs = self.tables.borrow().node_substs(expr.hir_id);\n+                self.add_wf_bounds(substs, expr);\n+\n+                ty\n+            }\n+            hir::ExprInlineAsm(_, ref outputs, ref inputs) => {\n+                for output in outputs {\n+                    self.check_expr(output);\n+                }\n+                for input in inputs {\n+                    self.check_expr(input);\n+                }\n+                tcx.mk_nil()\n+            }\n+            hir::ExprBreak(destination, ref expr_opt) => {\n+                if let Ok(target_id) = destination.target_id {\n+                    let (e_ty, cause);\n+                    if let Some(ref e) = *expr_opt {\n+                        // If this is a break with a value, we need to type-check\n+                        // the expression. Get an expected type from the loop context.\n+                        let opt_coerce_to = {\n+                            let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+                            enclosing_breakables.find_breakable(target_id)\n+                                                .coerce\n+                                                .as_ref()\n+                                                .map(|coerce| coerce.expected_ty())\n+                        };\n+\n+                        // If the loop context is not a `loop { }`, then break with\n+                        // a value is illegal, and `opt_coerce_to` will be `None`.\n+                        // Just set expectation to error in that case.\n+                        let coerce_to = opt_coerce_to.unwrap_or(tcx.types.err);\n+\n+                        // Recurse without `enclosing_breakables` borrowed.\n+                        e_ty = self.check_expr_with_hint(e, coerce_to);\n+                        cause = self.misc(e.span);\n+                    } else {\n+                        // Otherwise, this is a break *without* a value. That's\n+                        // always legal, and is equivalent to `break ()`.\n+                        e_ty = tcx.mk_nil();\n+                        cause = self.misc(expr.span);\n+                    }\n+\n+                    // Now that we have type-checked `expr_opt`, borrow\n+                    // the `enclosing_loops` field and let's coerce the\n+                    // type of `expr_opt` into what is expected.\n+                    let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+                    let ctxt = enclosing_breakables.find_breakable(target_id);\n+                    if let Some(ref mut coerce) = ctxt.coerce {\n+                        if let Some(ref e) = *expr_opt {\n+                            coerce.coerce(self, &cause, e, e_ty);\n                         } else {\n-                            Expectation::rvalue_hint(self, ty)\n+                            assert!(e_ty.is_nil());\n+                            coerce.coerce_forced_unit(self, &cause, &mut |_| (), true);\n+                        }\n+                    } else {\n+                        // If `ctxt.coerce` is `None`, we can just ignore\n+                        // the type of the expresison.  This is because\n+                        // either this was a break *without* a value, in\n+                        // which case it is always a legal type (`()`), or\n+                        // else an error would have been flagged by the\n+                        // `loops` pass for using break with an expression\n+                        // where you are not supposed to.\n+                        assert!(expr_opt.is_none() || self.tcx.sess.err_count() > 0);\n+                    }\n+\n+                    ctxt.may_break = true;\n+\n+                    // the type of a `break` is always `!`, since it diverges\n+                    tcx.types.never\n+                } else {\n+                    // Otherwise, we failed to find the enclosing loop;\n+                    // this can only happen if the `break` was not\n+                    // inside a loop at all, which is caught by the\n+                    // loop-checking pass.\n+                    assert!(self.tcx.sess.err_count() > 0);\n+\n+                    // We still need to assign a type to the inner expression to\n+                    // prevent the ICE in #43162.\n+                    if let Some(ref e) = *expr_opt {\n+                        self.check_expr_with_hint(e, tcx.types.err);\n+\n+                        // ... except when we try to 'break rust;'.\n+                        // ICE this expression in particular (see #43162).\n+                        if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = e.node {\n+                            if path.segments.len() == 1 && path.segments[0].name == \"rust\" {\n+                                fatally_break_rust(self.tcx.sess);\n+                            }\n                         }\n                     }\n-                    _ => NoExpectation\n+                    // There was an error, make typecheck fail\n+                    tcx.types.err\n                 }\n-            });\n-            let needs = Needs::maybe_mut_place(mutbl);\n-            let ty = self.check_expr_with_expectation_and_needs(&oprnd, hint, needs);\n \n-            let tm = ty::TypeAndMut { ty: ty, mutbl: mutbl };\n-            if tm.ty.references_error() {\n-                tcx.types.err\n-            } else {\n-                // Note: at this point, we cannot say what the best lifetime\n-                // is to use for resulting pointer.  We want to use the\n-                // shortest lifetime possible so as to avoid spurious borrowck\n-                // errors.  Moreover, the longest lifetime will depend on the\n-                // precise details of the value whose address is being taken\n-                // (and how long it is valid), which we don't know yet until type\n-                // inference is complete.\n-                //\n-                // Therefore, here we simply generate a region variable.  The\n-                // region inferencer will then select the ultimate value.\n-                // Finally, borrowck is charged with guaranteeing that the\n-                // value whose address was taken can actually be made to live\n-                // as long as it needs to live.\n-                let region = self.next_region_var(infer::AddrOfRegion(expr.span));\n-                tcx.mk_ref(region, tm)\n             }\n-          }\n-          hir::ExprPath(ref qpath) => {\n-              let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(qpath,\n-                                                                         expr.id, expr.span);\n-              let ty = if def != Def::Err {\n-                  self.instantiate_value_path(segments, opt_ty, def, expr.span, id)\n-              } else {\n-                  self.set_tainted_by_errors();\n-                  tcx.types.err\n-              };\n-\n-              // We always require that the type provided as the value for\n-              // a type parameter outlives the moment of instantiation.\n-              let substs = self.tables.borrow().node_substs(expr.hir_id);\n-              self.add_wf_bounds(substs, expr);\n-\n-              ty\n-          }\n-          hir::ExprInlineAsm(_, ref outputs, ref inputs) => {\n-              for output in outputs {\n-                  self.check_expr(output);\n-              }\n-              for input in inputs {\n-                  self.check_expr(input);\n-              }\n-              tcx.mk_nil()\n-          }\n-          hir::ExprBreak(destination, ref expr_opt) => {\n-              if let Ok(target_id) = destination.target_id {\n-                  let (e_ty, cause);\n-                  if let Some(ref e) = *expr_opt {\n-                      // If this is a break with a value, we need to type-check\n-                      // the expression. Get an expected type from the loop context.\n-                      let opt_coerce_to = {\n-                          let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-                          enclosing_breakables.find_breakable(target_id)\n-                                              .coerce\n-                                              .as_ref()\n-                                              .map(|coerce| coerce.expected_ty())\n-                      };\n-\n-                      // If the loop context is not a `loop { }`, then break with\n-                      // a value is illegal, and `opt_coerce_to` will be `None`.\n-                      // Just set expectation to error in that case.\n-                      let coerce_to = opt_coerce_to.unwrap_or(tcx.types.err);\n-\n-                      // Recurse without `enclosing_breakables` borrowed.\n-                      e_ty = self.check_expr_with_hint(e, coerce_to);\n-                      cause = self.misc(e.span);\n-                  } else {\n-                      // Otherwise, this is a break *without* a value. That's\n-                      // always legal, and is equivalent to `break ()`.\n-                      e_ty = tcx.mk_nil();\n-                      cause = self.misc(expr.span);\n-                  }\n-\n-                  // Now that we have type-checked `expr_opt`, borrow\n-                  // the `enclosing_loops` field and let's coerce the\n-                  // type of `expr_opt` into what is expected.\n-                  let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-                  let ctxt = enclosing_breakables.find_breakable(target_id);\n-                  if let Some(ref mut coerce) = ctxt.coerce {\n-                      if let Some(ref e) = *expr_opt {\n-                          coerce.coerce(self, &cause, e, e_ty);\n-                      } else {\n-                          assert!(e_ty.is_nil());\n-                          coerce.coerce_forced_unit(self, &cause, &mut |_| (), true);\n-                      }\n-                  } else {\n-                      // If `ctxt.coerce` is `None`, we can just ignore\n-                      // the type of the expresison.  This is because\n-                      // either this was a break *without* a value, in\n-                      // which case it is always a legal type (`()`), or\n-                      // else an error would have been flagged by the\n-                      // `loops` pass for using break with an expression\n-                      // where you are not supposed to.\n-                      assert!(expr_opt.is_none() || self.tcx.sess.err_count() > 0);\n-                  }\n-\n-                  ctxt.may_break = true;\n-\n-                  // the type of a `break` is always `!`, since it diverges\n-                  tcx.types.never\n-              } else {\n-                  // Otherwise, we failed to find the enclosing loop;\n-                  // this can only happen if the `break` was not\n-                  // inside a loop at all, which is caught by the\n-                  // loop-checking pass.\n-                  assert!(self.tcx.sess.err_count() > 0);\n-\n-                  // We still need to assign a type to the inner expression to\n-                  // prevent the ICE in #43162.\n-                  if let Some(ref e) = *expr_opt {\n-                      self.check_expr_with_hint(e, tcx.types.err);\n-\n-                      // ... except when we try to 'break rust;'.\n-                      // ICE this expression in particular (see #43162).\n-                      if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = e.node {\n-                          if path.segments.len() == 1 && path.segments[0].name == \"rust\" {\n-                              fatally_break_rust(self.tcx.sess);\n-                          }\n-                      }\n-                  }\n-                  // There was an error, make typecheck fail\n-                  tcx.types.err\n-              }\n-\n-          }\n-          hir::ExprAgain(_) => { tcx.types.never }\n-          hir::ExprRet(ref expr_opt) => {\n-            if self.ret_coercion.is_none() {\n-                struct_span_err!(self.tcx.sess, expr.span, E0572,\n-                                 \"return statement outside of function body\").emit();\n-            } else if let Some(ref e) = *expr_opt {\n-                self.check_return_expr(e);\n-            } else {\n-                let mut coercion = self.ret_coercion.as_ref().unwrap().borrow_mut();\n-                let cause = self.cause(expr.span, ObligationCauseCode::ReturnNoExpression);\n-                coercion.coerce_forced_unit(self, &cause, &mut |_| (), true);\n+            hir::ExprContinue(_) => { tcx.types.never }\n+            hir::ExprRet(ref expr_opt) => {\n+                if self.ret_coercion.is_none() {\n+                    struct_span_err!(self.tcx.sess, expr.span, E0572,\n+                                        \"return statement outside of function body\").emit();\n+                } else if let Some(ref e) = *expr_opt {\n+                    self.check_return_expr(e);\n+                } else {\n+                    let mut coercion = self.ret_coercion.as_ref().unwrap().borrow_mut();\n+                    let cause = self.cause(expr.span, ObligationCauseCode::ReturnNoExpression);\n+                    coercion.coerce_forced_unit(self, &cause, &mut |_| (), true);\n+                }\n+                tcx.types.never\n             }\n-            tcx.types.never\n-          }\n-          hir::ExprAssign(ref lhs, ref rhs) => {\n-            let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n+            hir::ExprAssign(ref lhs, ref rhs) => {\n+                let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n \n-            let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n+                let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n \n-            match expected {\n-                ExpectIfCondition => {\n-                    self.tcx.sess.delay_span_bug(lhs.span, \"invalid lhs expression in if;\\\n-                                                            expected error elsehwere\");\n-                }\n-                _ => {\n-                    // Only check this if not in an `if` condition, as the\n-                    // mistyped comparison help is more appropriate.\n-                    if !self.is_place_expr(&lhs) {\n-                        struct_span_err!(self.tcx.sess, expr.span, E0070,\n-                                         \"invalid left-hand side expression\")\n-                            .span_label(expr.span, \"left-hand of expression not valid\")\n-                            .emit();\n+                match expected {\n+                    ExpectIfCondition => {\n+                        self.tcx.sess.delay_span_bug(lhs.span, \"invalid lhs expression in if;\\\n+                                                                expected error elsehwere\");\n+                    }\n+                    _ => {\n+                        // Only check this if not in an `if` condition, as the\n+                        // mistyped comparison help is more appropriate.\n+                        if !self.is_place_expr(&lhs) {\n+                            struct_span_err!(self.tcx.sess, expr.span, E0070,\n+                                                \"invalid left-hand side expression\")\n+                                .span_label(expr.span, \"left-hand of expression not valid\")\n+                                .emit();\n+                        }\n                     }\n                 }\n+\n+                self.require_type_is_sized(lhs_ty, lhs.span, traits::AssignmentLhsSized);\n+\n+                if lhs_ty.references_error() || rhs_ty.references_error() {\n+                    tcx.types.err\n+                } else {\n+                    tcx.mk_nil()\n+                }\n+            }\n+            hir::ExprIf(ref cond, ref then_expr, ref opt_else_expr) => {\n+                self.check_then_else(&cond, then_expr, opt_else_expr.as_ref().map(|e| &**e),\n+                                    expr.span, expected)\n             }\n+            hir::ExprWhile(ref cond, ref body, _) => {\n+                let ctxt = BreakableCtxt {\n+                    // cannot use break with a value from a while loop\n+                    coerce: None,\n+                    may_break: false,  // Will get updated if/when we find a `break`.\n+                };\n \n-            self.require_type_is_sized(lhs_ty, lhs.span, traits::AssignmentLhsSized);\n+                let (ctxt, ()) = self.with_breakable_ctxt(expr.id, ctxt, || {\n+                    self.check_expr_has_type_or_error(&cond, tcx.types.bool);\n+                    let cond_diverging = self.diverges.get();\n+                    self.check_block_no_value(&body);\n \n-            if lhs_ty.references_error() || rhs_ty.references_error() {\n-                tcx.types.err\n-            } else {\n-                tcx.mk_nil()\n+                    // We may never reach the body so it diverging means nothing.\n+                    self.diverges.set(cond_diverging);\n+                });\n+\n+                if ctxt.may_break {\n+                    // No way to know whether it's diverging because\n+                    // of a `break` or an outer `break` or `return`.\n+                    self.diverges.set(Diverges::Maybe);\n+                }\n+\n+                self.tcx.mk_nil()\n             }\n-          }\n-          hir::ExprIf(ref cond, ref then_expr, ref opt_else_expr) => {\n-              self.check_then_else(&cond, then_expr, opt_else_expr.as_ref().map(|e| &**e),\n-                                   expr.span, expected)\n-          }\n-          hir::ExprWhile(ref cond, ref body, _) => {\n-              let ctxt = BreakableCtxt {\n-                  // cannot use break with a value from a while loop\n-                  coerce: None,\n-                  may_break: false,  // Will get updated if/when we find a `break`.\n-              };\n-\n-              let (ctxt, ()) = self.with_breakable_ctxt(expr.id, ctxt, || {\n-                  self.check_expr_has_type_or_error(&cond, tcx.types.bool);\n-                  let cond_diverging = self.diverges.get();\n-                  self.check_block_no_value(&body);\n-\n-                  // We may never reach the body so it diverging means nothing.\n-                  self.diverges.set(cond_diverging);\n-              });\n-\n-              if ctxt.may_break {\n-                  // No way to know whether it's diverging because\n-                  // of a `break` or an outer `break` or `return`.\n-                  self.diverges.set(Diverges::Maybe);\n-              }\n-\n-              self.tcx.mk_nil()\n-          }\n-          hir::ExprLoop(ref body, _, source) => {\n-              let coerce = match source {\n-                  // you can only use break with a value from a normal `loop { }`\n-                  hir::LoopSource::Loop => {\n-                      let coerce_to = expected.coercion_target_type(self, body.span);\n-                      Some(CoerceMany::new(coerce_to))\n-                  }\n-\n-                  hir::LoopSource::WhileLet |\n-                  hir::LoopSource::ForLoop => {\n-                      None\n-                  }\n-              };\n-\n-              let ctxt = BreakableCtxt {\n-                  coerce,\n-                  may_break: false, // Will get updated if/when we find a `break`.\n-              };\n-\n-              let (ctxt, ()) = self.with_breakable_ctxt(expr.id, ctxt, || {\n-                  self.check_block_no_value(&body);\n-              });\n-\n-              if ctxt.may_break {\n-                  // No way to know whether it's diverging because\n-                  // of a `break` or an outer `break` or `return`.\n-                  self.diverges.set(Diverges::Maybe);\n-              }\n-\n-              // If we permit break with a value, then result type is\n-              // the LUB of the breaks (possibly ! if none); else, it\n-              // is nil. This makes sense because infinite loops\n-              // (which would have type !) are only possible iff we\n-              // permit break with a value [1].\n-              assert!(ctxt.coerce.is_some() || ctxt.may_break); // [1]\n-              ctxt.coerce.map(|c| c.complete(self)).unwrap_or(self.tcx.mk_nil())\n-          }\n-          hir::ExprMatch(ref discrim, ref arms, match_src) => {\n-            self.check_match(expr, &discrim, arms, expected, match_src)\n-          }\n-          hir::ExprClosure(capture, ref decl, body_id, _, gen) => {\n-              self.check_expr_closure(expr, capture, &decl, body_id, gen, expected)\n-          }\n-          hir::ExprBlock(ref body, _) => {\n-            self.check_block_with_expected(&body, expected)\n-          }\n-          hir::ExprCall(ref callee, ref args) => {\n-              self.check_call(expr, &callee, args, expected)\n-          }\n-          hir::ExprMethodCall(ref segment, span, ref args) => {\n-              self.check_method_call(expr, segment, span, args, expected, needs)\n-          }\n-          hir::ExprCast(ref e, ref t) => {\n-            // Find the type of `e`. Supply hints based on the type we are casting to,\n-            // if appropriate.\n-            let t_cast = self.to_ty(t);\n-            let t_cast = self.resolve_type_vars_if_possible(&t_cast);\n-            let t_expr = self.check_expr_with_expectation(e, ExpectCastableToType(t_cast));\n-            let t_cast = self.resolve_type_vars_if_possible(&t_cast);\n-\n-            // Eagerly check for some obvious errors.\n-            if t_expr.references_error() || t_cast.references_error() {\n-                tcx.types.err\n-            } else {\n-                // Defer other checks until we're done type checking.\n-                let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n-                match cast::CastCheck::new(self, e, t_expr, t_cast, t.span, expr.span) {\n-                    Ok(cast_check) => {\n-                        deferred_cast_checks.push(cast_check);\n-                        t_cast\n+            hir::ExprLoop(ref body, _, source) => {\n+                let coerce = match source {\n+                    // you can only use break with a value from a normal `loop { }`\n+                    hir::LoopSource::Loop => {\n+                        let coerce_to = expected.coercion_target_type(self, body.span);\n+                        Some(CoerceMany::new(coerce_to))\n                     }\n-                    Err(ErrorReported) => {\n-                        tcx.types.err\n+\n+                    hir::LoopSource::WhileLet |\n+                    hir::LoopSource::ForLoop => {\n+                        None\n                     }\n+                };\n+\n+                let ctxt = BreakableCtxt {\n+                    coerce,\n+                    may_break: false, // Will get updated if/when we find a `break`.\n+                };\n+\n+                let (ctxt, ()) = self.with_breakable_ctxt(expr.id, ctxt, || {\n+                    self.check_block_no_value(&body);\n+                });\n+\n+                if ctxt.may_break {\n+                    // No way to know whether it's diverging because\n+                    // of a `break` or an outer `break` or `return`.\n+                    self.diverges.set(Diverges::Maybe);\n                 }\n-            }\n-          }\n-          hir::ExprType(ref e, ref t) => {\n-            let typ = self.to_ty(&t);\n-            self.check_expr_eq_type(&e, typ);\n-            typ\n-          }\n-          hir::ExprArray(ref args) => {\n-              let uty = expected.to_option(self).and_then(|uty| {\n-                  match uty.sty {\n-                      ty::TyArray(ty, _) | ty::TySlice(ty) => Some(ty),\n-                      _ => None\n-                  }\n-              });\n-\n-              let element_ty = if !args.is_empty() {\n-                  let coerce_to = uty.unwrap_or_else(\n-                      || self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span)));\n-                  let mut coerce = CoerceMany::with_coercion_sites(coerce_to, args);\n-                  assert_eq!(self.diverges.get(), Diverges::Maybe);\n-                  for e in args {\n-                      let e_ty = self.check_expr_with_hint(e, coerce_to);\n-                      let cause = self.misc(e.span);\n-                      coerce.coerce(self, &cause, e, e_ty);\n-                  }\n-                  coerce.complete(self)\n-              } else {\n-                  self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span))\n-              };\n-              tcx.mk_array(element_ty, args.len() as u64)\n-          }\n-          hir::ExprRepeat(ref element, ref count) => {\n-            let count_def_id = tcx.hir.local_def_id(count.id);\n-            let param_env = ty::ParamEnv::empty();\n-            let substs = Substs::identity_for_item(tcx.global_tcx(), count_def_id);\n-            let instance = ty::Instance::resolve(\n-                tcx.global_tcx(),\n-                param_env,\n-                count_def_id,\n-                substs,\n-            ).unwrap();\n-            let global_id = GlobalId {\n-                instance,\n-                promoted: None\n-            };\n-            let count = tcx.const_eval(param_env.and(global_id));\n \n-            if let Err(ref err) = count {\n-                err.report_as_error(\n-                    tcx.at(tcx.def_span(count_def_id)),\n-                    \"could not evaluate repeat length\",\n-                );\n+                // If we permit break with a value, then result type is\n+                // the LUB of the breaks (possibly ! if none); else, it\n+                // is nil. This makes sense because infinite loops\n+                // (which would have type !) are only possible iff we\n+                // permit break with a value [1].\n+                assert!(ctxt.coerce.is_some() || ctxt.may_break); // [1]\n+                ctxt.coerce.map(|c| c.complete(self)).unwrap_or(self.tcx.mk_nil())\n             }\n-\n-            let uty = match expected {\n-                ExpectHasType(uty) => {\n+            hir::ExprMatch(ref discrim, ref arms, match_src) => {\n+                self.check_match(expr, &discrim, arms, expected, match_src)\n+            }\n+            hir::ExprClosure(capture, ref decl, body_id, _, gen) => {\n+                self.check_expr_closure(expr, capture, &decl, body_id, gen, expected)\n+            }\n+            hir::ExprBlock(ref body, _) => {\n+                self.check_block_with_expected(&body, expected)\n+            }\n+            hir::ExprCall(ref callee, ref args) => {\n+                self.check_call(expr, &callee, args, expected)\n+            }\n+            hir::ExprMethodCall(ref segment, span, ref args) => {\n+                self.check_method_call(expr, segment, span, args, expected, needs)\n+            }\n+            hir::ExprCast(ref e, ref t) => {\n+                // Find the type of `e`. Supply hints based on the type we are casting to,\n+                // if appropriate.\n+                let t_cast = self.to_ty(t);\n+                let t_cast = self.resolve_type_vars_if_possible(&t_cast);\n+                let t_expr = self.check_expr_with_expectation(e, ExpectCastableToType(t_cast));\n+                let t_cast = self.resolve_type_vars_if_possible(&t_cast);\n+\n+                // Eagerly check for some obvious errors.\n+                if t_expr.references_error() || t_cast.references_error() {\n+                    tcx.types.err\n+                } else {\n+                    // Defer other checks until we're done type checking.\n+                    let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n+                    match cast::CastCheck::new(self, e, t_expr, t_cast, t.span, expr.span) {\n+                        Ok(cast_check) => {\n+                            deferred_cast_checks.push(cast_check);\n+                            t_cast\n+                        }\n+                        Err(ErrorReported) => {\n+                            tcx.types.err\n+                        }\n+                    }\n+                }\n+            }\n+            hir::ExprType(ref e, ref t) => {\n+                let ty = self.to_ty(&t);\n+                self.check_expr_eq_type(&e, ty);\n+                ty\n+            }\n+            hir::ExprArray(ref args) => {\n+                let uty = expected.to_option(self).and_then(|uty| {\n                     match uty.sty {\n                         ty::TyArray(ty, _) | ty::TySlice(ty) => Some(ty),\n                         _ => None\n                     }\n-                }\n-                _ => None\n-            };\n+                });\n \n-            let (element_ty, t) = match uty {\n-                Some(uty) => {\n-                    self.check_expr_coercable_to_type(&element, uty);\n-                    (uty, uty)\n-                }\n-                None => {\n-                    let t: Ty = self.next_ty_var(TypeVariableOrigin::MiscVariable(element.span));\n-                    let element_ty = self.check_expr_has_type_or_error(&element, t);\n-                    (element_ty, t)\n-                }\n-            };\n+                let element_ty = if !args.is_empty() {\n+                    let coerce_to = uty.unwrap_or_else(\n+                        || self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span)));\n+                    let mut coerce = CoerceMany::with_coercion_sites(coerce_to, args);\n+                    assert_eq!(self.diverges.get(), Diverges::Maybe);\n+                    for e in args {\n+                        let e_ty = self.check_expr_with_hint(e, coerce_to);\n+                        let cause = self.misc(e.span);\n+                        coerce.coerce(self, &cause, e, e_ty);\n+                    }\n+                    coerce.complete(self)\n+                } else {\n+                    self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span))\n+                };\n+                tcx.mk_array(element_ty, args.len() as u64)\n+            }\n+            hir::ExprRepeat(ref element, ref count) => {\n+                let count_def_id = tcx.hir.local_def_id(count.id);\n+                let param_env = ty::ParamEnv::empty();\n+                let substs = Substs::identity_for_item(tcx.global_tcx(), count_def_id);\n+                let instance = ty::Instance::resolve(\n+                    tcx.global_tcx(),\n+                    param_env,\n+                    count_def_id,\n+                    substs,\n+                ).unwrap();\n+                let global_id = GlobalId {\n+                    instance,\n+                    promoted: None\n+                };\n+                let count = tcx.const_eval(param_env.and(global_id));\n \n-            if let Ok(count) = count {\n-                let zero_or_one = count.assert_usize(tcx).map_or(false, |count| count <= 1);\n-                if !zero_or_one {\n-                    // For [foo, ..n] where n > 1, `foo` must have\n-                    // Copy type:\n-                    let lang_item = self.tcx.require_lang_item(lang_items::CopyTraitLangItem);\n-                    self.require_type_meets(t, expr.span, traits::RepeatVec, lang_item);\n+                if let Err(ref err) = count {\n+                    err.report_as_error(\n+                        tcx.at(tcx.def_span(count_def_id)),\n+                        \"could not evaluate repeat length\",\n+                    );\n                 }\n-            }\n \n-            if element_ty.references_error() {\n-                tcx.types.err\n-            } else if let Ok(count) = count {\n-                tcx.mk_ty(ty::TyArray(t, count))\n-            } else {\n-                tcx.types.err\n-            }\n-          }\n-          hir::ExprTup(ref elts) => {\n-            let flds = expected.only_has_type(self).and_then(|ty| {\n-                let ty = self.resolve_type_vars_with_obligations(ty);\n-                match ty.sty {\n-                    ty::TyTuple(ref flds) => Some(&flds[..]),\n+                let uty = match expected {\n+                    ExpectHasType(uty) => {\n+                        match uty.sty {\n+                            ty::TyArray(ty, _) | ty::TySlice(ty) => Some(ty),\n+                            _ => None\n+                        }\n+                    }\n                     _ => None\n-                }\n-            });\n+                };\n \n-            let elt_ts_iter = elts.iter().enumerate().map(|(i, e)| {\n-                let t = match flds {\n-                    Some(ref fs) if i < fs.len() => {\n-                        let ety = fs[i];\n-                        self.check_expr_coercable_to_type(&e, ety);\n-                        ety\n+                let (element_ty, t) = match uty {\n+                    Some(uty) => {\n+                        self.check_expr_coercable_to_type(&element, uty);\n+                        (uty, uty)\n                     }\n-                    _ => {\n-                        self.check_expr_with_expectation(&e, NoExpectation)\n+                    None => {\n+                        let ty = self.next_ty_var(TypeVariableOrigin::MiscVariable(element.span));\n+                        let element_ty = self.check_expr_has_type_or_error(&element, ty);\n+                        (element_ty, ty)\n                     }\n                 };\n-                t\n-            });\n-            let tuple = tcx.mk_tup(elt_ts_iter);\n-            if tuple.references_error() {\n-                tcx.types.err\n-            } else {\n-                self.require_type_is_sized(tuple, expr.span, traits::TupleInitializerSized);\n-                tuple\n+\n+                if let Ok(count) = count {\n+                    let zero_or_one = count.assert_usize(tcx).map_or(false, |count| count <= 1);\n+                    if !zero_or_one {\n+                        // For [foo, ..n] where n > 1, `foo` must have\n+                        // Copy type:\n+                        let lang_item = self.tcx.require_lang_item(lang_items::CopyTraitLangItem);\n+                        self.require_type_meets(t, expr.span, traits::RepeatVec, lang_item);\n+                    }\n+                }\n+\n+                if element_ty.references_error() {\n+                    tcx.types.err\n+                } else if let Ok(count) = count {\n+                    tcx.mk_ty(ty::TyArray(t, count))\n+                } else {\n+                    tcx.types.err\n+                }\n             }\n-          }\n-          hir::ExprStruct(ref qpath, ref fields, ref base_expr) => {\n-            self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n-          }\n-          hir::ExprField(ref base, field) => {\n-            self.check_field(expr, needs, &base, field)\n-          }\n-          hir::ExprIndex(ref base, ref idx) => {\n-              let base_t = self.check_expr_with_needs(&base, needs);\n-              let idx_t = self.check_expr(&idx);\n-\n-              if base_t.references_error() {\n-                  base_t\n-              } else if idx_t.references_error() {\n-                  idx_t\n-              } else {\n-                  let base_t = self.structurally_resolved_type(base.span, base_t);\n-                  match self.lookup_indexing(expr, base, base_t, idx_t, needs) {\n-                      Some((index_ty, element_ty)) => {\n-                          // two-phase not needed because index_ty is never mutable\n-                          self.demand_coerce(idx, idx_t, index_ty, AllowTwoPhase::No);\n-                          element_ty\n-                      }\n-                      None => {\n-                          let mut err = type_error_struct!(tcx.sess, expr.span, base_t, E0608,\n-                                                           \"cannot index into a value of type `{}`\",\n-                                                           base_t);\n-                          // Try to give some advice about indexing tuples.\n-                          if let ty::TyTuple(..) = base_t.sty {\n-                              let mut needs_note = true;\n-                              // If the index is an integer, we can show the actual\n-                              // fixed expression:\n-                              if let hir::ExprLit(ref lit) = idx.node {\n-                                  if let ast::LitKind::Int(i,\n+            hir::ExprTup(ref elts) => {\n+                let flds = expected.only_has_type(self).and_then(|ty| {\n+                    let ty = self.resolve_type_vars_with_obligations(ty);\n+                    match ty.sty {\n+                        ty::TyTuple(ref flds) => Some(&flds[..]),\n+                        _ => None\n+                    }\n+                });\n+\n+                let elt_ts_iter = elts.iter().enumerate().map(|(i, e)| {\n+                    let t = match flds {\n+                        Some(ref fs) if i < fs.len() => {\n+                            let ety = fs[i];\n+                            self.check_expr_coercable_to_type(&e, ety);\n+                            ety\n+                        }\n+                        _ => {\n+                            self.check_expr_with_expectation(&e, NoExpectation)\n+                        }\n+                    };\n+                    t\n+                });\n+                let tuple = tcx.mk_tup(elt_ts_iter);\n+                if tuple.references_error() {\n+                    tcx.types.err\n+                } else {\n+                    self.require_type_is_sized(tuple, expr.span, traits::TupleInitializerSized);\n+                    tuple\n+                }\n+            }\n+            hir::ExprStruct(ref qpath, ref fields, ref base_expr) => {\n+                self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n+            }\n+            hir::ExprField(ref base, field) => {\n+                self.check_field(expr, needs, &base, field)\n+            }\n+            hir::ExprIndex(ref base, ref idx) => {\n+                let base_t = self.check_expr_with_needs(&base, needs);\n+                let idx_t = self.check_expr(&idx);\n+\n+                if base_t.references_error() {\n+                    base_t\n+                } else if idx_t.references_error() {\n+                    idx_t\n+                } else {\n+                    let base_t = self.structurally_resolved_type(base.span, base_t);\n+                    match self.lookup_indexing(expr, base, base_t, idx_t, needs) {\n+                        Some((index_ty, element_ty)) => {\n+                            // two-phase not needed because index_ty is never mutable\n+                            self.demand_coerce(idx, idx_t, index_ty, AllowTwoPhase::No);\n+                            element_ty\n+                        }\n+                        None => {\n+                            let mut err =\n+                                type_error_struct!(tcx.sess, expr.span, base_t, E0608,\n+                                                   \"cannot index into a value of type `{}`\",\n+                                                   base_t);\n+                            // Try to give some advice about indexing tuples.\n+                            if let ty::TyTuple(..) = base_t.sty {\n+                                let mut needs_note = true;\n+                                // If the index is an integer, we can show the actual\n+                                // fixed expression:\n+                                if let hir::ExprLit(ref lit) = idx.node {\n+                                    if let ast::LitKind::Int(i,\n                                             ast::LitIntType::Unsuffixed) = lit.node {\n-                                      let snip = tcx.sess.codemap().span_to_snippet(base.span);\n-                                      if let Ok(snip) = snip {\n-                                          err.span_suggestion(expr.span,\n-                                                              \"to access tuple elements, use\",\n-                                                              format!(\"{}.{}\", snip, i));\n-                                          needs_note = false;\n-                                      }\n-                                  }\n-                              }\n-                              if needs_note {\n-                                  err.help(\"to access tuple elements, use tuple indexing \\\n+                                        let snip = tcx.sess.codemap().span_to_snippet(base.span);\n+                                        if let Ok(snip) = snip {\n+                                            err.span_suggestion(expr.span,\n+                                                                \"to access tuple elements, use\",\n+                                                                format!(\"{}.{}\", snip, i));\n+                                            needs_note = false;\n+                                        }\n+                                    }\n+                                }\n+                                if needs_note {\n+                                    err.help(\"to access tuple elements, use tuple indexing \\\n                                             syntax (e.g. `tuple.0`)\");\n-                              }\n-                          }\n-                          err.emit();\n-                          self.tcx.types.err\n-                      }\n-                  }\n-              }\n-           }\n-          hir::ExprYield(ref value) => {\n-            match self.yield_ty {\n-                Some(ty) => {\n-                    self.check_expr_coercable_to_type(&value, ty);\n+                                }\n+                            }\n+                            err.emit();\n+                            self.tcx.types.err\n+                        }\n+                    }\n                 }\n-                None => {\n-                    struct_span_err!(self.tcx.sess, expr.span, E0627,\n-                                 \"yield statement outside of generator literal\").emit();\n+            }\n+            hir::ExprYield(ref value) => {\n+                match self.yield_ty {\n+                    Some(ty) => {\n+                        self.check_expr_coercable_to_type(&value, ty);\n+                    }\n+                    None => {\n+                        struct_span_err!(self.tcx.sess, expr.span, E0627,\n+                                        \"yield statement outside of generator literal\").emit();\n+                    }\n                 }\n+                tcx.mk_nil()\n             }\n-            tcx.mk_nil()\n-          }\n         }\n     }\n "}]}