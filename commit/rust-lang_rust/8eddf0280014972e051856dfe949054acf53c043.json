{"sha": "8eddf0280014972e051856dfe949054acf53c043", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlZGRmMDI4MDAxNDk3MmUwNTE4NTZkZmU5NDkwNTRhY2Y1M2MwNDM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-26T02:18:04Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-26T02:18:43Z"}, "message": "Rollup merge of #34339 - jseyfried:thin_vec, r=petrochenkov,Manishearth\n\nGeneralize and abstract `ThinAttributes` to `ThinVec<Attribute>`.", "tree": {"sha": "8d4523f2bd6a218c75b5a602fa30d5cd85d8184c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d4523f2bd6a218c75b5a602fa30d5cd85d8184c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8eddf0280014972e051856dfe949054acf53c043", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8eddf0280014972e051856dfe949054acf53c043", "html_url": "https://github.com/rust-lang/rust/commit/8eddf0280014972e051856dfe949054acf53c043", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8eddf0280014972e051856dfe949054acf53c043/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8748cd92d06328af657934f6728183c10f92eefe", "url": "https://api.github.com/repos/rust-lang/rust/commits/8748cd92d06328af657934f6728183c10f92eefe", "html_url": "https://github.com/rust-lang/rust/commit/8748cd92d06328af657934f6728183c10f92eefe"}, {"sha": "5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "html_url": "https://github.com/rust-lang/rust/commit/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1"}], "stats": {"total": 591, "additions": 274, "deletions": 317}, "files": [{"sha": "78fd2bbbe0d2590e033ea4d87da820c69aad227f", "filename": "src/librustc/hir/fold.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -14,7 +14,6 @@\n use hir::*;\n use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, Attribute, Attribute_, MetaItem};\n use syntax::ast::MetaItemKind;\n-use syntax::attr::ThinAttributesExt;\n use hir;\n use syntax_pos::Span;\n use syntax::codemap::{respan, Spanned};\n@@ -293,8 +292,11 @@ pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<\n     })\n }\n \n-pub fn fold_attrs<T: Folder>(attrs: HirVec<Attribute>, fld: &mut T) -> HirVec<Attribute> {\n-    attrs.move_flat_map(|x| fld.fold_attribute(x))\n+pub fn fold_attrs<T, F>(attrs: T, fld: &mut F) -> T\n+    where T: Into<Vec<Attribute>> + From<Vec<Attribute>>,\n+          F: Folder,\n+{\n+    attrs.into().move_flat_map(|x| fld.fold_attribute(x)).into()\n }\n \n pub fn noop_fold_arm<T: Folder>(Arm { attrs, pats, guard, body }: Arm, fld: &mut T) -> Arm {\n@@ -462,7 +464,7 @@ pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n             pat: fld.fold_pat(pat),\n             init: init.map(|e| fld.fold_expr(e)),\n             span: fld.new_span(span),\n-            attrs: attrs.map_thin_attrs(|attrs| fold_attrs(attrs.into(), fld).into()),\n+            attrs: fold_attrs(attrs, fld),\n         }\n     })\n }\n@@ -1079,7 +1081,7 @@ pub fn noop_fold_expr<T: Folder>(Expr { id, node, span, attrs }: Expr, folder: &\n             }\n         },\n         span: folder.new_span(span),\n-        attrs: attrs.map_thin_attrs(|attrs| fold_attrs(attrs.into(), folder).into()),\n+        attrs: fold_attrs(attrs, folder),\n     }\n }\n "}, {"sha": "2d5c4ebf8d898bbc3bf0bff24f945a712f48045c", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -27,7 +27,6 @@\n \n use syntax::abi::Abi;\n use syntax::ast::{NodeId, CRATE_NODE_ID, Name, Attribute};\n-use syntax::attr::ThinAttributesExt;\n use syntax::codemap::Spanned;\n use syntax_pos::Span;\n use hir::*;\n@@ -757,7 +756,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             walk_list!(visitor, visit_arm, arms);\n         }\n         ExprClosure(_, ref function_declaration, ref body, _fn_decl_span) => {\n-            visitor.visit_fn(FnKind::Closure(expression.attrs.as_attr_slice()),\n+            visitor.visit_fn(FnKind::Closure(&expression.attrs),\n                              function_declaration,\n                              body,\n                              expression.span,"}, {"sha": "a32631ac53ddd2fb827e827266527013110ef860", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 72, "deletions": 84, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -50,7 +50,6 @@ use session::Session;\n use std::collections::BTreeMap;\n use std::iter;\n use syntax::ast::*;\n-use syntax::attr::{ThinAttributes, ThinAttributesExt};\n use syntax::ptr::P;\n use syntax::codemap::{respan, Spanned};\n use syntax::parse::token;\n@@ -951,16 +950,16 @@ impl<'a> LoweringContext<'a> {\n \n                     let make_call = |this: &mut LoweringContext, p, args| {\n                         let path = this.core_path(e.span, p);\n-                        let path = this.expr_path(path, None);\n-                        this.expr_call(e.span, path, args, None)\n+                        let path = this.expr_path(path, ThinVec::new());\n+                        this.expr_call(e.span, path, args)\n                     };\n \n                     let mk_stmt_let = |this: &mut LoweringContext, bind, expr| {\n-                        this.stmt_let(e.span, false, bind, expr, None)\n+                        this.stmt_let(e.span, false, bind, expr)\n                     };\n \n                     let mk_stmt_let_mut = |this: &mut LoweringContext, bind, expr| {\n-                        this.stmt_let(e.span, true, bind, expr, None)\n+                        this.stmt_let(e.span, true, bind, expr)\n                     };\n \n                     // let placer = <placer_expr> ;\n@@ -969,21 +968,21 @@ impl<'a> LoweringContext<'a> {\n                                                                  placer_expr,\n                                                                  e.span,\n                                                                  hir::PopUnstableBlock,\n-                                                                 None);\n+                                                                 ThinVec::new());\n                         mk_stmt_let(self, placer_ident, placer_expr)\n                     };\n \n                     // let mut place = Placer::make_place(placer);\n                     let (s2, place_binding) = {\n-                        let placer = self.expr_ident(e.span, placer_ident, None, placer_binding);\n+                        let placer = self.expr_ident(e.span, placer_ident, placer_binding);\n                         let call = make_call(self, &make_place, hir_vec![placer]);\n                         mk_stmt_let_mut(self, place_ident, call)\n                     };\n \n                     // let p_ptr = Place::pointer(&mut place);\n                     let (s3, p_ptr_binding) = {\n-                        let agent = self.expr_ident(e.span, place_ident, None, place_binding);\n-                        let args = hir_vec![self.expr_mut_addr_of(e.span, agent, None)];\n+                        let agent = self.expr_ident(e.span, place_ident, place_binding);\n+                        let args = hir_vec![self.expr_mut_addr_of(e.span, agent)];\n                         let call = make_call(self, &place_pointer, args);\n                         mk_stmt_let(self, p_ptr_ident, call)\n                     };\n@@ -994,31 +993,33 @@ impl<'a> LoweringContext<'a> {\n                                                                 value_expr,\n                                                                 e.span,\n                                                                 hir::PopUnstableBlock,\n-                                                                None);\n+                                                                ThinVec::new());\n                         self.signal_block_expr(hir_vec![],\n                                                value_expr,\n                                                e.span,\n-                                               hir::PopUnsafeBlock(hir::CompilerGenerated), None)\n+                                               hir::PopUnsafeBlock(hir::CompilerGenerated),\n+                                               ThinVec::new())\n                     };\n \n                     // push_unsafe!({\n                     //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n                     //     InPlace::finalize(place)\n                     // })\n                     let expr = {\n-                        let ptr = self.expr_ident(e.span, p_ptr_ident, None, p_ptr_binding);\n+                        let ptr = self.expr_ident(e.span, p_ptr_ident, p_ptr_binding);\n                         let call_move_val_init =\n                             hir::StmtSemi(\n                                 make_call(self, &move_val_init, hir_vec![ptr, pop_unsafe_expr]),\n                                 self.next_id());\n                         let call_move_val_init = respan(e.span, call_move_val_init);\n \n-                        let place = self.expr_ident(e.span, place_ident, None, place_binding);\n+                        let place = self.expr_ident(e.span, place_ident, place_binding);\n                         let call = make_call(self, &inplace_finalize, hir_vec![place]);\n                         self.signal_block_expr(hir_vec![call_move_val_init],\n                                                call,\n                                                e.span,\n-                                               hir::PushUnsafeBlock(hir::CompilerGenerated), None)\n+                                               hir::PushUnsafeBlock(hir::CompilerGenerated),\n+                                               ThinVec::new())\n                     };\n \n                     return self.signal_block_expr(hir_vec![s1, s2, s3],\n@@ -1090,7 +1091,7 @@ impl<'a> LoweringContext<'a> {\n                                     rules: hir::DefaultBlock,\n                                     span: span,\n                                 });\n-                                self.expr_block(blk, None)\n+                                self.expr_block(blk, ThinVec::new())\n                             }\n                             _ => self.lower_expr(els),\n                         }\n@@ -1157,7 +1158,7 @@ impl<'a> LoweringContext<'a> {\n                                                                           expr,\n                                                                           e.span,\n                                                                           hir::PopUnstableBlock,\n-                                                                          None);\n+                                                                          ThinVec::new());\n                                 this.field(token::intern(s), signal_block, ast_expr.span)\n                             }).collect();\n                             let attrs = ast_expr.attrs.clone();\n@@ -1169,7 +1170,7 @@ impl<'a> LoweringContext<'a> {\n                                                hir_expr,\n                                                ast_expr.span,\n                                                hir::PushUnstableBlock,\n-                                               None)\n+                                               ThinVec::new())\n                     }\n \n                     use syntax::ast::RangeLimits::*;\n@@ -1256,9 +1257,9 @@ impl<'a> LoweringContext<'a> {\n                             ex.span = e.span;\n                         }\n                         // merge attributes into the inner expression.\n-                        ex.attrs.update(|attrs| {\n-                            attrs.prepend(e.attrs.clone())\n-                        });\n+                        let mut attrs = e.attrs.clone();\n+                        attrs.extend::<Vec<_>>(ex.attrs.into());\n+                        ex.attrs = attrs;\n                         ex\n                     });\n                 }\n@@ -1277,7 +1278,7 @@ impl<'a> LoweringContext<'a> {\n                     // `<pat> => <body>`\n                     let pat_arm = {\n                         let body = self.lower_block(body);\n-                        let body_expr = self.expr_block(body, None);\n+                        let body_expr = self.expr_block(body, ThinVec::new());\n                         let pat = self.lower_pat(pat);\n                         self.arm(hir_vec![pat], body_expr)\n                     };\n@@ -1297,7 +1298,7 @@ impl<'a> LoweringContext<'a> {\n                                                 attrs: hir_vec![],\n                                                 pats: hir_vec![pat_under],\n                                                 guard: Some(cond),\n-                                                body: self.expr_block(then, None),\n+                                                body: self.expr_block(then, ThinVec::new()),\n                                             });\n                                             else_opt.map(|else_opt| (else_opt, true))\n                                         }\n@@ -1328,7 +1329,7 @@ impl<'a> LoweringContext<'a> {\n                     let else_arm = {\n                         let pat_under = self.pat_wild(e.span);\n                         let else_expr =\n-                            else_opt.unwrap_or_else(|| self.expr_tuple(e.span, hir_vec![], None));\n+                            else_opt.unwrap_or_else(|| self.expr_tuple(e.span, hir_vec![]));\n                         self.arm(hir_vec![pat_under], else_expr)\n                     };\n \n@@ -1363,15 +1364,15 @@ impl<'a> LoweringContext<'a> {\n                     // `<pat> => <body>`\n                     let pat_arm = {\n                         let body = self.lower_block(body);\n-                        let body_expr = self.expr_block(body, None);\n+                        let body_expr = self.expr_block(body, ThinVec::new());\n                         let pat = self.lower_pat(pat);\n                         self.arm(hir_vec![pat], body_expr)\n                     };\n \n                     // `_ => break`\n                     let break_arm = {\n                         let pat_under = self.pat_wild(e.span);\n-                        let break_expr = self.expr_break(e.span, None);\n+                        let break_expr = self.expr_break(e.span, ThinVec::new());\n                         self.arm(hir_vec![pat_under], break_expr)\n                     };\n \n@@ -1382,7 +1383,7 @@ impl<'a> LoweringContext<'a> {\n                                                hir::ExprMatch(sub_expr,\n                                                               arms,\n                                                               hir::MatchSource::WhileLetDesugar),\n-                                               None);\n+                                               ThinVec::new());\n \n                     // `[opt_ident]: loop { ... }`\n                     let loop_block = self.block_expr(match_expr);\n@@ -1424,7 +1425,7 @@ impl<'a> LoweringContext<'a> {\n                             id: self.next_id(),\n                             node: hir::ExprBlock(body_block),\n                             span: body_span,\n-                            attrs: None,\n+                            attrs: ThinVec::new(),\n                         });\n                         let pat = self.lower_pat(pat);\n                         let some_pat = self.pat_some(e.span, pat);\n@@ -1434,7 +1435,7 @@ impl<'a> LoweringContext<'a> {\n \n                     // `::std::option::Option::None => break`\n                     let break_arm = {\n-                        let break_expr = self.expr_break(e.span, None);\n+                        let break_expr = self.expr_break(e.span, ThinVec::new());\n                         let pat = self.pat_none(e.span);\n                         self.arm(hir_vec![pat], break_expr)\n                     };\n@@ -1450,25 +1451,26 @@ impl<'a> LoweringContext<'a> {\n \n                             self.path_global(e.span, strs)\n                         };\n-                        let iter = self.expr_ident(e.span, iter, None, iter_pat.id);\n-                        let ref_mut_iter = self.expr_mut_addr_of(e.span, iter, None);\n-                        let next_path = self.expr_path(next_path, None);\n-                        let next_expr = self.expr_call(e.span,\n-                                                       next_path,\n-                                                       hir_vec![ref_mut_iter],\n-                                                       None);\n+                        let iter = self.expr_ident(e.span, iter, iter_pat.id);\n+                        let ref_mut_iter = self.expr_mut_addr_of(e.span, iter);\n+                        let next_path = self.expr_path(next_path, ThinVec::new());\n+                        let next_expr = self.expr_call(e.span, next_path, hir_vec![ref_mut_iter]);\n                         let arms = hir_vec![pat_arm, break_arm];\n \n                         self.expr(e.span,\n                                   hir::ExprMatch(next_expr, arms, hir::MatchSource::ForLoopDesugar),\n-                                  None)\n+                                  ThinVec::new())\n                     };\n \n                     // `[opt_ident]: loop { ... }`\n                     let loop_block = self.block_expr(match_expr);\n                     let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident));\n-                    let loop_expr =\n-                        P(hir::Expr { id: e.id, node: loop_expr, span: e.span, attrs: None });\n+                    let loop_expr = P(hir::Expr {\n+                        id: e.id,\n+                        node: loop_expr,\n+                        span: e.span,\n+                        attrs: ThinVec::new(),\n+                    });\n \n                     // `mut iter => { ... }`\n                     let iter_arm = self.arm(hir_vec![iter_pat], loop_expr);\n@@ -1481,23 +1483,22 @@ impl<'a> LoweringContext<'a> {\n                             self.path_global(e.span, strs)\n                         };\n \n-                        let into_iter = self.expr_path(into_iter_path, None);\n-                        self.expr_call(e.span, into_iter, hir_vec![head], None)\n+                        let into_iter = self.expr_path(into_iter_path, ThinVec::new());\n+                        self.expr_call(e.span, into_iter, hir_vec![head])\n                     };\n \n                     let match_expr = self.expr_match(e.span,\n                                                      into_iter_expr,\n                                                      hir_vec![iter_arm],\n-                                                     hir::MatchSource::ForLoopDesugar,\n-                                                     None);\n+                                                     hir::MatchSource::ForLoopDesugar);\n \n                     // `{ let _result = ...; _result }`\n                     // underscore prevents an unused_variables lint if the head diverges\n                     let result_ident = self.str_to_ident(\"_result\");\n                     let (let_stmt, let_stmt_binding) =\n-                        self.stmt_let(e.span, false, result_ident, match_expr, None);\n+                        self.stmt_let(e.span, false, result_ident, match_expr);\n \n-                    let result = self.expr_ident(e.span, result_ident, None, let_stmt_binding);\n+                    let result = self.expr_ident(e.span, result_ident, let_stmt_binding);\n                     let block = self.block_all(e.span, hir_vec![let_stmt], Some(result));\n                     // add the attributes to the outer returned expr node\n                     return self.expr_block(block, e.attrs.clone());\n@@ -1524,7 +1525,7 @@ impl<'a> LoweringContext<'a> {\n                     let ok_arm = {\n                         let val_ident = self.str_to_ident(\"val\");\n                         let val_pat = self.pat_ident(e.span, val_ident);\n-                        let val_expr = self.expr_ident(e.span, val_ident, None, val_pat.id);\n+                        let val_expr = self.expr_ident(e.span, val_ident, val_pat.id);\n                         let ok_pat = self.pat_ok(e.span, val_pat);\n \n                         self.arm(hir_vec![ok_pat], val_expr)\n@@ -1537,26 +1538,26 @@ impl<'a> LoweringContext<'a> {\n                         let from_expr = {\n                             let path = self.std_path(&[\"convert\", \"From\", \"from\"]);\n                             let path = self.path_global(e.span, path);\n-                            let from = self.expr_path(path, None);\n-                            let err_expr = self.expr_ident(e.span, err_ident, None, err_local.id);\n+                            let from = self.expr_path(path, ThinVec::new());\n+                            let err_expr = self.expr_ident(e.span, err_ident, err_local.id);\n \n-                            self.expr_call(e.span, from, hir_vec![err_expr], None)\n+                            self.expr_call(e.span, from, hir_vec![err_expr])\n                         };\n                         let err_expr = {\n                             let path = self.std_path(&[\"result\", \"Result\", \"Err\"]);\n                             let path = self.path_global(e.span, path);\n-                            let err_ctor = self.expr_path(path, None);\n-                            self.expr_call(e.span, err_ctor, hir_vec![from_expr], None)\n+                            let err_ctor = self.expr_path(path, ThinVec::new());\n+                            self.expr_call(e.span, err_ctor, hir_vec![from_expr])\n                         };\n                         let err_pat = self.pat_err(e.span, err_local);\n                         let ret_expr = self.expr(e.span,\n-                                                 hir::Expr_::ExprRet(Some(err_expr)), None);\n-\n+                                                 hir::Expr_::ExprRet(Some(err_expr)),\n+                                                 ThinVec::new());\n                         self.arm(hir_vec![err_pat], ret_expr)\n                     };\n \n                     return self.expr_match(e.span, sub_expr, hir_vec![err_arm, ok_arm],\n-                                           hir::MatchSource::TryDesugar, None);\n+                                           hir::MatchSource::TryDesugar);\n                 }\n \n                 ExprKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n@@ -1679,23 +1680,18 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn expr_break(&mut self, span: Span, attrs: ThinAttributes) -> P<hir::Expr> {\n+    fn expr_break(&mut self, span: Span, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n         self.expr(span, hir::ExprBreak(None), attrs)\n     }\n \n-    fn expr_call(&mut self,\n-                 span: Span,\n-                 e: P<hir::Expr>,\n-                 args: hir::HirVec<P<hir::Expr>>,\n-                 attrs: ThinAttributes)\n+    fn expr_call(&mut self, span: Span, e: P<hir::Expr>, args: hir::HirVec<P<hir::Expr>>)\n                  -> P<hir::Expr> {\n-        self.expr(span, hir::ExprCall(e, args), attrs)\n+        self.expr(span, hir::ExprCall(e, args), ThinVec::new())\n     }\n \n-    fn expr_ident(&mut self, span: Span, id: Name, attrs: ThinAttributes, binding: NodeId)\n-                  -> P<hir::Expr> {\n+    fn expr_ident(&mut self, span: Span, id: Name, binding: NodeId) -> P<hir::Expr> {\n         let expr_path = hir::ExprPath(None, self.path_ident(span, id));\n-        let expr = self.expr(span, expr_path, attrs);\n+        let expr = self.expr(span, expr_path, ThinVec::new());\n \n         let def = self.resolver.definitions().map(|defs| {\n             Def::Local(defs.local_def_id(binding), binding)\n@@ -1705,12 +1701,11 @@ impl<'a> LoweringContext<'a> {\n         expr\n     }\n \n-    fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr>, attrs: ThinAttributes)\n-                        -> P<hir::Expr> {\n-        self.expr(span, hir::ExprAddrOf(hir::MutMutable, e), attrs)\n+    fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr>) -> P<hir::Expr> {\n+        self.expr(span, hir::ExprAddrOf(hir::MutMutable, e), ThinVec::new())\n     }\n \n-    fn expr_path(&mut self, path: hir::Path, attrs: ThinAttributes) -> P<hir::Expr> {\n+    fn expr_path(&mut self, path: hir::Path, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n         let def = self.resolver.resolve_generated_global_path(&path, true);\n         let expr = self.expr(path.span, hir::ExprPath(None, path), attrs);\n         self.resolver.record_resolution(expr.id, def);\n@@ -1721,34 +1716,32 @@ impl<'a> LoweringContext<'a> {\n                   span: Span,\n                   arg: P<hir::Expr>,\n                   arms: hir::HirVec<hir::Arm>,\n-                  source: hir::MatchSource,\n-                  attrs: ThinAttributes)\n+                  source: hir::MatchSource)\n                   -> P<hir::Expr> {\n-        self.expr(span, hir::ExprMatch(arg, arms, source), attrs)\n+        self.expr(span, hir::ExprMatch(arg, arms, source), ThinVec::new())\n     }\n \n-    fn expr_block(&mut self, b: P<hir::Block>, attrs: ThinAttributes) -> P<hir::Expr> {\n+    fn expr_block(&mut self, b: P<hir::Block>, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n         self.expr(b.span, hir::ExprBlock(b), attrs)\n     }\n \n-    fn expr_tuple(&mut self, sp: Span, exprs: hir::HirVec<P<hir::Expr>>, attrs: ThinAttributes)\n-                  -> P<hir::Expr> {\n-        self.expr(sp, hir::ExprTup(exprs), attrs)\n+    fn expr_tuple(&mut self, sp: Span, exprs: hir::HirVec<P<hir::Expr>>) -> P<hir::Expr> {\n+        self.expr(sp, hir::ExprTup(exprs), ThinVec::new())\n     }\n \n     fn expr_struct(&mut self,\n                    sp: Span,\n                    path: hir::Path,\n                    fields: hir::HirVec<hir::Field>,\n                    e: Option<P<hir::Expr>>,\n-                   attrs: ThinAttributes) -> P<hir::Expr> {\n+                   attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n         let def = self.resolver.resolve_generated_global_path(&path, false);\n         let expr = self.expr(sp, hir::ExprStruct(path, fields, e), attrs);\n         self.resolver.record_resolution(expr.id, def);\n         expr\n     }\n \n-    fn expr(&mut self, span: Span, node: hir::Expr_, attrs: ThinAttributes) -> P<hir::Expr> {\n+    fn expr(&mut self, span: Span, node: hir::Expr_, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n         P(hir::Expr {\n             id: self.next_id(),\n             node: node,\n@@ -1757,12 +1750,7 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn stmt_let(&mut self,\n-                sp: Span,\n-                mutbl: bool,\n-                ident: Name,\n-                ex: P<hir::Expr>,\n-                attrs: ThinAttributes)\n+    fn stmt_let(&mut self, sp: Span, mutbl: bool, ident: Name, ex: P<hir::Expr>)\n                 -> (hir::Stmt, NodeId) {\n         let pat = if mutbl {\n             self.pat_ident_binding_mode(sp, ident, hir::BindByValue(hir::MutMutable))\n@@ -1776,7 +1764,7 @@ impl<'a> LoweringContext<'a> {\n             init: Some(ex),\n             id: self.next_id(),\n             span: sp,\n-            attrs: attrs,\n+            attrs: ThinVec::new(),\n         });\n         let decl = respan(sp, hir::DeclLocal(local));\n         (respan(sp, hir::StmtDecl(P(decl), self.next_id())), pat_id)\n@@ -1936,7 +1924,7 @@ impl<'a> LoweringContext<'a> {\n                          expr: P<hir::Expr>,\n                          span: Span,\n                          rule: hir::BlockCheckMode,\n-                         attrs: ThinAttributes)\n+                         attrs: ThinVec<Attribute>)\n                          -> P<hir::Expr> {\n         let id = self.next_id();\n         let block = P(hir::Block {"}, {"sha": "50e8c6e7ab842e59adbec3e7336a1ec2a62492d7", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -27,7 +27,6 @@ use hir::map::{self, Node};\n use syntax::abi;\n use hir::{Block, FnDecl};\n use syntax::ast::{Attribute, Name, NodeId};\n-use syntax::attr::ThinAttributesExt;\n use hir as ast;\n use syntax_pos::Span;\n use hir::intravisit::FnKind;\n@@ -257,11 +256,7 @@ impl<'a> FnLikeNode<'a> {\n             }\n             map::NodeExpr(e) => match e.node {\n                 ast::ExprClosure(_, ref decl, ref block, _fn_decl_span) =>\n-                    closure(ClosureParts::new(&decl,\n-                                              &block,\n-                                              e.id,\n-                                              e.span,\n-                                              e.attrs.as_attr_slice())),\n+                    closure(ClosureParts::new(&decl, &block, e.id, e.span, &e.attrs)),\n                 _ => bug!(\"expr FnLikeNode that is not fn-like\"),\n             },\n             _ => bug!(\"other FnLikeNode that is not fn-like\"),"}, {"sha": "f9fb8ac66b7ef01292e3744ca870a9e58e375f7a", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -23,7 +23,6 @@ use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n \n use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID, };\n-use syntax::attr::ThinAttributesExt;\n use syntax::codemap::Spanned;\n use syntax::visit;\n use syntax_pos::Span;\n@@ -578,7 +577,7 @@ impl<'ast> Map<'ast> {\n             Some(NodeTraitItem(ref ti)) => Some(&ti.attrs[..]),\n             Some(NodeImplItem(ref ii)) => Some(&ii.attrs[..]),\n             Some(NodeVariant(ref v)) => Some(&v.node.attrs[..]),\n-            Some(NodeExpr(ref e)) => Some(e.attrs.as_attr_slice()),\n+            Some(NodeExpr(ref e)) => Some(&*e.attrs),\n             Some(NodeStmt(ref s)) => Some(s.node.attrs()),\n             // unit/tuple structs take the attributes straight from\n             // the struct definition."}, {"sha": "a139dd152f006f5bcc51d26c0d26a1cb33ea7a21", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -41,10 +41,10 @@ use syntax::codemap::{self, respan, Spanned};\n use syntax::abi::Abi;\n use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n-use syntax::attr::{ThinAttributes, ThinAttributesExt};\n use syntax::parse::token::{keywords, InternedString};\n use syntax::ptr::P;\n use syntax::tokenstream::TokenTree;\n+use syntax::util::ThinVec;\n \n use std::collections::BTreeMap;\n use std::fmt;\n@@ -734,7 +734,7 @@ impl Stmt_ {\n         match *self {\n             StmtDecl(ref d, _) => d.node.attrs(),\n             StmtExpr(ref e, _) |\n-            StmtSemi(ref e, _) => e.attrs.as_attr_slice(),\n+            StmtSemi(ref e, _) => &e.attrs,\n         }\n     }\n \n@@ -758,7 +758,7 @@ pub struct Local {\n     pub init: Option<P<Expr>>,\n     pub id: NodeId,\n     pub span: Span,\n-    pub attrs: ThinAttributes,\n+    pub attrs: ThinVec<Attribute>,\n }\n \n pub type Decl = Spanned<Decl_>;\n@@ -774,7 +774,7 @@ pub enum Decl_ {\n impl Decl_ {\n     pub fn attrs(&self) -> &[Attribute] {\n         match *self {\n-            DeclLocal(ref l) => l.attrs.as_attr_slice(),\n+            DeclLocal(ref l) => &l.attrs,\n             DeclItem(_) => &[]\n         }\n     }\n@@ -819,7 +819,7 @@ pub struct Expr {\n     pub id: NodeId,\n     pub node: Expr_,\n     pub span: Span,\n-    pub attrs: ThinAttributes,\n+    pub attrs: ThinVec<Attribute>,\n }\n \n impl fmt::Debug for Expr {"}, {"sha": "3e101e1934f294ce80a5d6d76220523321dfe50f", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -42,7 +42,6 @@ use std::mem;\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::parse::token::InternedString;\n use syntax::ast;\n-use syntax::attr::ThinAttributesExt;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n use hir;\n@@ -767,7 +766,7 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, e: &hir::Expr) {\n-        self.with_lint_attrs(e.attrs.as_attr_slice(), |cx| {\n+        self.with_lint_attrs(&e.attrs, |cx| {\n             run_lints!(cx, check_expr, late_passes, e);\n             hir_visit::walk_expr(cx, e);\n         })\n@@ -832,7 +831,7 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_local(&mut self, l: &hir::Local) {\n-        self.with_lint_attrs(l.attrs.as_attr_slice(), |cx| {\n+        self.with_lint_attrs(&l.attrs, |cx| {\n             run_lints!(cx, check_local, late_passes, l);\n             hir_visit::walk_local(cx, l);\n         })\n@@ -928,7 +927,7 @@ impl<'a> ast_visit::Visitor for EarlyContext<'a> {\n     }\n \n     fn visit_expr(&mut self, e: &ast::Expr) {\n-        self.with_lint_attrs(e.attrs.as_attr_slice(), |cx| {\n+        self.with_lint_attrs(&e.attrs, |cx| {\n             run_lints!(cx, check_expr, early_passes, e);\n             ast_visit::walk_expr(cx, e);\n         })\n@@ -988,7 +987,7 @@ impl<'a> ast_visit::Visitor for EarlyContext<'a> {\n     }\n \n     fn visit_local(&mut self, l: &ast::Local) {\n-        self.with_lint_attrs(l.attrs.as_attr_slice(), |cx| {\n+        self.with_lint_attrs(&l.attrs, |cx| {\n             run_lints!(cx, check_local, early_passes, l);\n             ast_visit::walk_local(cx, l);\n         })"}, {"sha": "c878edcd4b2a80c45865add1582093f72441adf8", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -452,7 +452,7 @@ fn const_val_to_expr(value: &ConstVal) -> P<hir::Expr> {\n         id: 0,\n         node: hir::ExprLit(P(Spanned { node: node, span: DUMMY_SP })),\n         span: DUMMY_SP,\n-        attrs: None,\n+        attrs: ast::ThinVec::new(),\n     })\n }\n "}, {"sha": "80eea76e107565ea6790efb4bb72dcc078d2f62f", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -672,7 +672,7 @@ impl fold::Folder for ReplaceBodyWithLoop {\n                 node: ast::ExprKind::Loop(empty_block, None),\n                 id: ast::DUMMY_NODE_ID,\n                 span: syntax_pos::DUMMY_SP,\n-                attrs: None,\n+                attrs: ast::ThinVec::new(),\n             });\n \n             expr_to_block(b.rules, Some(loop_expr))"}, {"sha": "dcdc1e60a99cd0bd8012716220dacebf563f1e5f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -14,8 +14,8 @@ pub use self::TyParamBound::*;\n pub use self::UnsafeSource::*;\n pub use self::ViewPath_::*;\n pub use self::PathParameters::*;\n+pub use util::ThinVec;\n \n-use attr::ThinAttributes;\n use syntax_pos::{mk_sp, Span, DUMMY_SP, ExpnId};\n use codemap::{respan, Spanned};\n use abi::Abi;\n@@ -835,10 +835,9 @@ pub enum StmtKind {\n     /// Expr without trailing semi-colon (must have unit type).\n     Expr(P<Expr>),\n \n-    /// Expr with trailing semi-colon (may have any type).\n     Semi(P<Expr>),\n \n-    Mac(P<(Mac, MacStmtStyle, ThinAttributes)>),\n+    Mac(P<(Mac, MacStmtStyle, ThinVec<Attribute>)>),\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -865,7 +864,7 @@ pub struct Local {\n     pub init: Option<P<Expr>>,\n     pub id: NodeId,\n     pub span: Span,\n-    pub attrs: ThinAttributes,\n+    pub attrs: ThinVec<Attribute>,\n }\n \n /// An arm of a 'match'.\n@@ -913,7 +912,7 @@ pub struct Expr {\n     pub id: NodeId,\n     pub node: ExprKind,\n     pub span: Span,\n-    pub attrs: ThinAttributes\n+    pub attrs: ThinVec<Attribute>\n }\n \n impl fmt::Debug for Expr {"}, {"sha": "da2967e306f6500c69aaaa5f4d221d6c26ec8e44", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 4, "deletions": 77, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -25,6 +25,7 @@ use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use parse::token::InternedString;\n use parse::{ParseSess, token};\n use ptr::P;\n+use util::ThinVec;\n \n use std::cell::{RefCell, Cell};\n use std::collections::HashSet;\n@@ -802,80 +803,6 @@ impl IntType {\n     }\n }\n \n-/// A list of attributes, behind a optional box as\n-/// a space optimization.\n-pub type ThinAttributes = Option<Box<Vec<Attribute>>>;\n-\n-pub trait ThinAttributesExt {\n-    fn map_thin_attrs<F>(self, f: F) -> Self\n-        where F: FnOnce(Vec<Attribute>) -> Vec<Attribute>;\n-    fn prepend(mut self, attrs: Self) -> Self;\n-    fn append(mut self, attrs: Self) -> Self;\n-    fn update<F>(&mut self, f: F)\n-        where Self: Sized,\n-              F: FnOnce(Self) -> Self;\n-    fn as_attr_slice(&self) -> &[Attribute];\n-    fn into_attr_vec(self) -> Vec<Attribute>;\n-}\n-\n-impl ThinAttributesExt for ThinAttributes {\n-    fn map_thin_attrs<F>(self, f: F) -> Self\n-        where F: FnOnce(Vec<Attribute>) -> Vec<Attribute>\n-    {\n-        f(self.map(|b| *b).unwrap_or(Vec::new())).into_thin_attrs()\n-    }\n-\n-    fn prepend(self, attrs: ThinAttributes) -> Self {\n-        attrs.map_thin_attrs(|mut attrs| {\n-            attrs.extend(self.into_attr_vec());\n-            attrs\n-        })\n-    }\n-\n-    fn append(self, attrs: ThinAttributes) -> Self {\n-        self.map_thin_attrs(|mut self_| {\n-            self_.extend(attrs.into_attr_vec());\n-            self_\n-        })\n-    }\n-\n-    fn update<F>(&mut self, f: F)\n-        where Self: Sized,\n-              F: FnOnce(ThinAttributes) -> ThinAttributes\n-    {\n-        let self_ = f(self.take());\n-        *self = self_;\n-    }\n-\n-    fn as_attr_slice(&self) -> &[Attribute] {\n-        match *self {\n-            Some(ref b) => b,\n-            None => &[],\n-        }\n-    }\n-\n-    fn into_attr_vec(self) -> Vec<Attribute> {\n-        match self {\n-            Some(b) => *b,\n-            None => Vec::new(),\n-        }\n-    }\n-}\n-\n-pub trait AttributesExt {\n-    fn into_thin_attrs(self) -> ThinAttributes;\n-}\n-\n-impl AttributesExt for Vec<Attribute> {\n-    fn into_thin_attrs(self) -> ThinAttributes {\n-        if self.len() == 0 {\n-            None\n-        } else {\n-            Some(Box::new(self))\n-        }\n-    }\n-}\n-\n pub trait HasAttrs: Sized {\n     fn attrs(&self) -> &[ast::Attribute];\n     fn map_attrs<F: FnOnce(Vec<ast::Attribute>) -> Vec<ast::Attribute>>(self, f: F) -> Self;\n@@ -890,12 +817,12 @@ impl HasAttrs for Vec<Attribute> {\n     }\n }\n \n-impl HasAttrs for ThinAttributes {\n+impl HasAttrs for ThinVec<Attribute> {\n     fn attrs(&self) -> &[Attribute] {\n-        self.as_attr_slice()\n+        &self\n     }\n     fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n-        self.map_thin_attrs(f)\n+        f(self.into()).into()\n     }\n }\n "}, {"sha": "757b039fcac8a658b535631d79c1a2c5a5bf9d50", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -380,7 +380,7 @@ impl DummyResult {\n             id: ast::DUMMY_NODE_ID,\n             node: ast::ExprKind::Lit(P(codemap::respan(sp, ast::LitKind::Bool(false)))),\n             span: sp,\n-            attrs: None,\n+            attrs: ast::ThinVec::new(),\n         })\n     }\n "}, {"sha": "f4ae23ed8be788bb07146420f315adaaeda53b61", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -530,7 +530,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             init: Some(ex),\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n-            attrs: None,\n+            attrs: ast::ThinVec::new(),\n         });\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n@@ -558,7 +558,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             init: Some(ex),\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n-            attrs: None,\n+            attrs: ast::ThinVec::new(),\n         });\n         P(ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n@@ -601,7 +601,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n             span: span,\n-            attrs: None,\n+            attrs: ast::ThinVec::new(),\n         })\n     }\n "}, {"sha": "32635f5cdd20db2f84249028563f15d5da540676", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -15,7 +15,7 @@ use ast;\n use attr::HasAttrs;\n use ext::mtwt;\n use attr;\n-use attr::{AttrMetaMethods, ThinAttributesExt};\n+use attr::AttrMetaMethods;\n use codemap::{Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use syntax_pos::{self, Span, ExpnId};\n use config::StripUnconfigured;\n@@ -107,7 +107,7 @@ pub fn expand_expr(mut expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr>\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n         ast::ExprKind::Mac(mac) => {\n-            return expand_mac_invoc(mac, None, expr.attrs.into_attr_vec(), expr.span, fld);\n+            return expand_mac_invoc(mac, None, expr.attrs.into(), expr.span, fld);\n         }\n \n         ast::ExprKind::While(cond, body, opt_ident) => {\n@@ -444,7 +444,7 @@ fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n     };\n \n     let mut fully_expanded: SmallVector<ast::Stmt> =\n-        expand_mac_invoc(mac, None, attrs.into_attr_vec(), stmt.span, fld);\n+        expand_mac_invoc(mac, None, attrs.into(), stmt.span, fld);\n \n     // If this is a macro invocation with a semicolon, then apply that\n     // semicolon to the final statement produced by expansion.\n@@ -1006,7 +1006,7 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n     fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n         expr.and_then(|expr| match expr.node {\n             ast::ExprKind::Mac(mac) =>\n-                expand_mac_invoc(mac, None, expr.attrs.into_attr_vec(), expr.span, self),\n+                expand_mac_invoc(mac, None, expr.attrs.into(), expr.span, self),\n             _ => Some(expand_expr(expr, self)),\n         })\n     }"}, {"sha": "3dc7c92f0160953152bc38bc9fee86d29675da4e", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -251,7 +251,7 @@ pub mod rt {\n                 id: ast::DUMMY_NODE_ID,\n                 node: ast::ExprKind::Lit(P(self.clone())),\n                 span: DUMMY_SP,\n-                attrs: None,\n+                attrs: ast::ThinVec::new(),\n             }).to_tokens(cx)\n         }\n     }\n@@ -282,7 +282,7 @@ pub mod rt {\n                         id: ast::DUMMY_NODE_ID,\n                         node: ast::ExprKind::Lit(P(dummy_spanned(lit))),\n                         span: DUMMY_SP,\n-                        attrs: None,\n+                        attrs: ast::ThinVec::new(),\n                     });\n                     if *self >= 0 {\n                         return lit.to_tokens(cx);\n@@ -291,7 +291,7 @@ pub mod rt {\n                         id: ast::DUMMY_NODE_ID,\n                         node: ast::ExprKind::Unary(ast::UnOp::Neg, lit),\n                         span: DUMMY_SP,\n-                        attrs: None,\n+                        attrs: ast::ThinVec::new(),\n                     }).to_tokens(cx)\n                 }\n             }"}, {"sha": "b2b286c9b1409d008111ae30a097b99da0dc8446", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -20,7 +20,6 @@\n \n use ast::*;\n use ast;\n-use attr::{ThinAttributes, ThinAttributesExt};\n use syntax_pos::Span;\n use codemap::{Spanned, respan};\n use parse::token::{self, keywords};\n@@ -332,8 +331,8 @@ pub fn fold_attrs<T: Folder>(attrs: Vec<Attribute>, fld: &mut T) -> Vec<Attribut\n     attrs.move_flat_map(|x| fld.fold_attribute(x))\n }\n \n-pub fn fold_thin_attrs<T: Folder>(attrs: ThinAttributes, fld: &mut T) -> ThinAttributes {\n-    attrs.map_thin_attrs(|v| fold_attrs(v, fld))\n+pub fn fold_thin_attrs<T: Folder>(attrs: ThinVec<Attribute>, fld: &mut T) -> ThinVec<Attribute> {\n+    fold_attrs(attrs.into(), fld).into()\n }\n \n pub fn noop_fold_arm<T: Folder>(Arm {attrs, pats, guard, body}: Arm, fld: &mut T) -> Arm {\n@@ -481,7 +480,7 @@ pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n         pat: fld.fold_pat(pat),\n         init: init.map(|e| fld.fold_expr(e)),\n         span: fld.new_span(span),\n-        attrs: attrs.map_thin_attrs(|v| fold_attrs(v, fld)),\n+        attrs: fold_attrs(attrs.into(), fld).into(),\n     })\n }\n \n@@ -1276,7 +1275,7 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n             ExprKind::Try(ex) => ExprKind::Try(folder.fold_expr(ex)),\n         },\n         span: folder.new_span(span),\n-        attrs: attrs.map_thin_attrs(|v| fold_attrs(v, folder)),\n+        attrs: fold_attrs(attrs.into(), folder).into(),\n     }\n }\n \n@@ -1329,9 +1328,7 @@ pub fn noop_fold_stmt<T: Folder>(Stmt {node, span, id}: Stmt, folder: &mut T)\n         StmtKind::Mac(mac) => SmallVector::one(Stmt {\n             id: id,\n             node: StmtKind::Mac(mac.map(|(mac, semi, attrs)| {\n-                let mac = folder.fold_mac(mac);\n-                let attrs = attrs.map_thin_attrs(|attrs| fold_attrs(attrs, folder));\n-                (mac, semi, attrs)\n+                (folder.fold_mac(mac), semi, fold_attrs(attrs.into(), folder).into())\n             })),\n             span: span,\n         })"}, {"sha": "652cf68db07592b7f3d66fb9ebf660d67c02127f", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -75,6 +75,9 @@ pub mod util {\n     pub mod parser_testing;\n     pub mod small_vector;\n     pub mod move_map;\n+\n+    mod thin_vec;\n+    pub use self::thin_vec::ThinVec;\n }\n \n pub mod diagnostics {"}, {"sha": "0c5a672dfbc9ee460768139d1a4c6f245f0f57ac", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -675,6 +675,7 @@ mod tests {\n     use tokenstream::{self, TokenTree};\n     use util::parser_testing::{string_to_tts, string_to_parser};\n     use util::parser_testing::{string_to_expr, string_to_item, string_to_stmt};\n+    use util::ThinVec;\n \n     // produce a syntax_pos::span\n     fn sp(a: u32, b: u32) -> Span {\n@@ -696,7 +697,7 @@ mod tests {\n                         ),\n                     }),\n                     span: sp(0, 1),\n-                    attrs: None,\n+                    attrs: ThinVec::new(),\n                    }))\n     }\n \n@@ -719,7 +720,7 @@ mod tests {\n                             )\n                         }),\n                     span: sp(0, 6),\n-                    attrs: None,\n+                    attrs: ThinVec::new(),\n                    }))\n     }\n \n@@ -835,10 +836,10 @@ mod tests {\n                             ),\n                         }),\n                         span:sp(7,8),\n-                        attrs: None,\n+                        attrs: ThinVec::new(),\n                     }))),\n                     span:sp(0,8),\n-                    attrs: None,\n+                    attrs: ThinVec::new(),\n                    }))\n     }\n \n@@ -858,7 +859,7 @@ mod tests {\n                                ),\n                             }),\n                            span: sp(0,1),\n-                           attrs: None})),\n+                           attrs: ThinVec::new()})),\n                        id: ast::DUMMY_NODE_ID,\n                        span: sp(0,1)}))\n \n@@ -953,7 +954,7 @@ mod tests {\n                                                         ),\n                                                       }),\n                                                 span: sp(17,18),\n-                                                attrs: None,})),\n+                                                attrs: ThinVec::new()})),\n                                             id: ast::DUMMY_NODE_ID,\n                                             span: sp(17,19)}),\n                                         expr: None,"}, {"sha": "83401011ed44e3b952e4aa4790ebc47b8ae5c927", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 75, "deletions": 82, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -37,7 +37,6 @@ use ast::{TraitItem, TraitRef};\n use ast::{Ty, TyKind, TypeBinding, TyParam, TyParamBounds};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n-use attr::{ThinAttributes, ThinAttributesExt, AttributesExt};\n use ast::{BinOpKind, UnOp};\n use ast;\n use codemap::{self, CodeMap, Spanned, spanned};\n@@ -57,6 +56,7 @@ use print::pprust;\n use ptr::P;\n use parse::PResult;\n use tokenstream::{self, Delimited, SequenceRepetition, TokenTree};\n+use util::ThinVec;\n \n use std::collections::HashSet;\n use std::mem;\n@@ -122,7 +122,7 @@ macro_rules! maybe_whole_expr {\n                         _ => unreachable!()\n                     };\n                     let span = $p.span;\n-                    Some($p.mk_expr(span.lo, span.hi, ExprKind::Path(None, pt), None))\n+                    Some($p.mk_expr(span.lo, span.hi, ExprKind::Path(None, pt), ThinVec::new()))\n                 }\n                 token::Interpolated(token::NtBlock(_)) => {\n                     // FIXME: The following avoids an issue with lexical borrowck scopes,\n@@ -132,7 +132,7 @@ macro_rules! maybe_whole_expr {\n                         _ => unreachable!()\n                     };\n                     let span = $p.span;\n-                    Some($p.mk_expr(span.lo, span.hi, ExprKind::Block(b), None))\n+                    Some($p.mk_expr(span.lo, span.hi, ExprKind::Block(b), ThinVec::new()))\n                 }\n                 _ => None\n             };\n@@ -318,12 +318,12 @@ pub struct ModulePathError {\n \n pub enum LhsExpr {\n     NotYetParsed,\n-    AttributesParsed(ThinAttributes),\n+    AttributesParsed(ThinVec<Attribute>),\n     AlreadyParsed(P<Expr>),\n }\n \n-impl From<Option<ThinAttributes>> for LhsExpr {\n-    fn from(o: Option<ThinAttributes>) -> Self {\n+impl From<Option<ThinVec<Attribute>>> for LhsExpr {\n+    fn from(o: Option<ThinVec<Attribute>>) -> Self {\n         if let Some(attrs) = o {\n             LhsExpr::AttributesParsed(attrs)\n         } else {\n@@ -1703,12 +1703,12 @@ impl<'a> Parser<'a> {\n         let lo = self.span.lo;\n         let literal = P(self.parse_lit()?);\n         let hi = self.last_span.hi;\n-        let expr = self.mk_expr(lo, hi, ExprKind::Lit(literal), None);\n+        let expr = self.mk_expr(lo, hi, ExprKind::Lit(literal), ThinVec::new());\n \n         if minus_present {\n             let minus_hi = self.last_span.hi;\n             let unary = self.mk_unary(UnOp::Neg, expr);\n-            Ok(self.mk_expr(minus_lo, minus_hi, unary, None))\n+            Ok(self.mk_expr(minus_lo, minus_hi, unary, ThinVec::new()))\n         } else {\n             Ok(expr)\n         }\n@@ -2066,13 +2066,13 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    pub fn mk_expr(&mut self, lo: BytePos, hi: BytePos,\n-                   node: ExprKind, attrs: ThinAttributes) -> P<Expr> {\n+    pub fn mk_expr(&mut self, lo: BytePos, hi: BytePos, node: ExprKind, attrs: ThinVec<Attribute>)\n+                   -> P<Expr> {\n         P(Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n             span: mk_sp(lo, hi),\n-            attrs: attrs,\n+            attrs: attrs.into(),\n         })\n     }\n \n@@ -2129,7 +2129,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn mk_mac_expr(&mut self, lo: BytePos, hi: BytePos,\n-                       m: Mac_, attrs: ThinAttributes) -> P<Expr> {\n+                       m: Mac_, attrs: ThinVec<Attribute>) -> P<Expr> {\n         P(Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: ExprKind::Mac(codemap::Spanned {node: m, span: mk_sp(lo, hi)}),\n@@ -2138,7 +2138,7 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    pub fn mk_lit_u32(&mut self, i: u32, attrs: ThinAttributes) -> P<Expr> {\n+    pub fn mk_lit_u32(&mut self, i: u32, attrs: ThinVec<Attribute>) -> P<Expr> {\n         let span = &self.span;\n         let lv_lit = P(codemap::Spanned {\n             node: LitKind::Int(i as u64, ast::LitIntType::Unsigned(UintTy::U32)),\n@@ -2179,7 +2179,7 @@ impl<'a> Parser<'a> {\n         //\n         // Therefore, prevent sub-parser from parsing\n         // attributes by giving them a empty \"already parsed\" list.\n-        let mut attrs = None;\n+        let mut attrs = ThinVec::new();\n \n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n@@ -2191,9 +2191,7 @@ impl<'a> Parser<'a> {\n             token::OpenDelim(token::Paren) => {\n                 self.bump();\n \n-                let attrs = self.parse_inner_attributes()?\n-                    .into_thin_attrs()\n-                    .prepend(attrs);\n+                attrs.extend(self.parse_inner_attributes()?);\n \n                 // (e) is parenthesized e\n                 // (e,) is a tuple with only one field, e\n@@ -2231,9 +2229,7 @@ impl<'a> Parser<'a> {\n             token::OpenDelim(token::Bracket) => {\n                 self.bump();\n \n-                let inner_attrs = self.parse_inner_attributes()?\n-                    .into_thin_attrs();\n-                attrs.update(|attrs| attrs.append(inner_attrs));\n+                attrs.extend(self.parse_inner_attributes()?);\n \n                 if self.check(&token::CloseDelim(token::Bracket)) {\n                     // Empty vector.\n@@ -2390,9 +2386,7 @@ impl<'a> Parser<'a> {\n                             let mut fields = Vec::new();\n                             let mut base = None;\n \n-                            let attrs = attrs.append(\n-                                self.parse_inner_attributes()?\n-                                    .into_thin_attrs());\n+                            attrs.extend(self.parse_inner_attributes()?);\n \n                             while self.token != token::CloseDelim(token::Brace) {\n                                 if self.eat(&token::DotDot) {\n@@ -2459,33 +2453,32 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_or_use_outer_attributes(&mut self,\n-                                     already_parsed_attrs: Option<ThinAttributes>)\n-                                     -> PResult<'a, ThinAttributes> {\n+                                     already_parsed_attrs: Option<ThinVec<Attribute>>)\n+                                     -> PResult<'a, ThinVec<Attribute>> {\n         if let Some(attrs) = already_parsed_attrs {\n             Ok(attrs)\n         } else {\n-            self.parse_outer_attributes().map(|a| a.into_thin_attrs())\n+            self.parse_outer_attributes().map(|a| a.into())\n         }\n     }\n \n     /// Parse a block or unsafe block\n     pub fn parse_block_expr(&mut self, lo: BytePos, blk_mode: BlockCheckMode,\n-                            attrs: ThinAttributes)\n+                            outer_attrs: ThinVec<Attribute>)\n                             -> PResult<'a, P<Expr>> {\n \n-        let outer_attrs = attrs;\n         self.expect(&token::OpenDelim(token::Brace))?;\n \n-        let inner_attrs = self.parse_inner_attributes()?.into_thin_attrs();\n-        let attrs = outer_attrs.append(inner_attrs);\n+        let mut attrs = outer_attrs;\n+        attrs.extend(self.parse_inner_attributes()?);\n \n         let blk = self.parse_block_tail(lo, blk_mode)?;\n         return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprKind::Block(blk), attrs));\n     }\n \n     /// parse a.b or a(13) or a[4] or just a\n     pub fn parse_dot_or_call_expr(&mut self,\n-                                  already_parsed_attrs: Option<ThinAttributes>)\n+                                  already_parsed_attrs: Option<ThinVec<Attribute>>)\n                                   -> PResult<'a, P<Expr>> {\n         let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n \n@@ -2497,20 +2490,21 @@ impl<'a> Parser<'a> {\n     pub fn parse_dot_or_call_expr_with(&mut self,\n                                        e0: P<Expr>,\n                                        lo: BytePos,\n-                                       attrs: ThinAttributes)\n+                                       mut attrs: ThinVec<Attribute>)\n                                        -> PResult<'a, P<Expr>> {\n         // Stitch the list of outer attributes onto the return value.\n         // A little bit ugly, but the best way given the current code\n         // structure\n         self.parse_dot_or_call_expr_with_(e0, lo)\n         .map(|expr|\n             expr.map(|mut expr| {\n-                expr.attrs.update(|a| a.prepend(attrs));\n+                attrs.extend::<Vec<_>>(expr.attrs.into());\n+                expr.attrs = attrs;\n                 match expr.node {\n                     ExprKind::If(..) | ExprKind::IfLet(..) => {\n-                        if !expr.attrs.as_attr_slice().is_empty() {\n+                        if !expr.attrs.is_empty() {\n                             // Just point to the first attribute in there...\n-                            let span = expr.attrs.as_attr_slice()[0].span;\n+                            let span = expr.attrs[0].span;\n \n                             self.span_err(span,\n                                 \"attributes are not yet allowed on `if` \\\n@@ -2558,7 +2552,7 @@ impl<'a> Parser<'a> {\n                 es.insert(0, self_value);\n                 let id = spanned(ident_span.lo, ident_span.hi, ident);\n                 let nd = self.mk_method_call(id, tys, es);\n-                self.mk_expr(lo, hi, nd, None)\n+                self.mk_expr(lo, hi, nd, ThinVec::new())\n             }\n             // Field access.\n             _ => {\n@@ -2571,7 +2565,7 @@ impl<'a> Parser<'a> {\n \n                 let id = spanned(ident_span.lo, ident_span.hi, ident);\n                 let field = self.mk_field(self_value, id);\n-                self.mk_expr(lo, ident_span.hi, field, None)\n+                self.mk_expr(lo, ident_span.hi, field, ThinVec::new())\n             }\n         })\n     }\n@@ -2583,7 +2577,7 @@ impl<'a> Parser<'a> {\n             // expr?\n             while self.eat(&token::Question) {\n                 let hi = self.last_span.hi;\n-                e = self.mk_expr(lo, hi, ExprKind::Try(e), None);\n+                e = self.mk_expr(lo, hi, ExprKind::Try(e), ThinVec::new());\n             }\n \n             // expr.f\n@@ -2611,7 +2605,7 @@ impl<'a> Parser<'a> {\n                         Some(n) => {\n                             let id = spanned(dot, hi, n);\n                             let field = self.mk_tup_field(e, id);\n-                            e = self.mk_expr(lo, hi, field, None);\n+                            e = self.mk_expr(lo, hi, field, ThinVec::new());\n                         }\n                         None => {\n                             let last_span = self.last_span;\n@@ -2663,7 +2657,7 @@ impl<'a> Parser<'a> {\n                 hi = self.last_span.hi;\n \n                 let nd = self.mk_call(e, es);\n-                e = self.mk_expr(lo, hi, nd, None);\n+                e = self.mk_expr(lo, hi, nd, ThinVec::new());\n               }\n \n               // expr[...]\n@@ -2674,7 +2668,7 @@ impl<'a> Parser<'a> {\n                 hi = self.span.hi;\n                 self.commit_expr_expecting(&ix, token::CloseDelim(token::Bracket))?;\n                 let index = self.mk_index(e, ix);\n-                e = self.mk_expr(lo, hi, index, None)\n+                e = self.mk_expr(lo, hi, index, ThinVec::new())\n               }\n               _ => return Ok(e)\n             }\n@@ -2905,7 +2899,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a prefix-unary-operator expr\n     pub fn parse_prefix_expr(&mut self,\n-                             already_parsed_attrs: Option<ThinAttributes>)\n+                             already_parsed_attrs: Option<ThinVec<Attribute>>)\n                              -> PResult<'a, P<Expr>> {\n         let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n         let lo = self.span.lo;\n@@ -2950,8 +2944,7 @@ impl<'a> Parser<'a> {\n                 let blk = self.parse_block()?;\n                 let span = blk.span;\n                 hi = span.hi;\n-                let blk_expr = self.mk_expr(span.lo, span.hi, ExprKind::Block(blk),\n-                                            None);\n+                let blk_expr = self.mk_expr(span.lo, hi, ExprKind::Block(blk), ThinVec::new());\n                 ExprKind::InPlace(place, blk_expr)\n             }\n             token::Ident(..) if self.token.is_keyword(keywords::Box) => {\n@@ -2971,7 +2964,7 @@ impl<'a> Parser<'a> {\n     /// This parses an expression accounting for associativity and precedence of the operators in\n     /// the expression.\n     pub fn parse_assoc_expr(&mut self,\n-                            already_parsed_attrs: Option<ThinAttributes>)\n+                            already_parsed_attrs: Option<ThinVec<Attribute>>)\n                             -> PResult<'a, P<Expr>> {\n         self.parse_assoc_expr_with(0, already_parsed_attrs.into())\n     }\n@@ -3024,13 +3017,13 @@ impl<'a> Parser<'a> {\n             // Special cases:\n             if op == AssocOp::As {\n                 let rhs = self.parse_ty()?;\n-                lhs = self.mk_expr(lhs_span.lo, rhs.span.hi,\n-                                   ExprKind::Cast(lhs, rhs), None);\n+                let (lo, hi) = (lhs_span.lo, rhs.span.hi);\n+                lhs = self.mk_expr(lo, hi, ExprKind::Cast(lhs, rhs), ThinVec::new());\n                 continue\n             } else if op == AssocOp::Colon {\n                 let rhs = self.parse_ty()?;\n-                lhs = self.mk_expr(lhs_span.lo, rhs.span.hi,\n-                                   ExprKind::Type(lhs, rhs), None);\n+                let (lo, hi) = (lhs_span.lo, rhs.span.hi);\n+                lhs = self.mk_expr(lo, hi, ExprKind::Type(lhs, rhs), ThinVec::new());\n                 continue\n             } else if op == AssocOp::DotDot || op == AssocOp::DotDotDot {\n                 // If we didn\u2019t have to handle `x..`/`x...`, it would be pretty easy to\n@@ -3056,7 +3049,7 @@ impl<'a> Parser<'a> {\n                 };\n \n                 let r = try!(self.mk_range(Some(lhs), rhs, limits));\n-                lhs = self.mk_expr(lhs_span.lo, rhs_span.hi, r, None);\n+                lhs = self.mk_expr(lhs_span.lo, rhs_span.hi, r, ThinVec::new());\n                 break\n             }\n \n@@ -3083,21 +3076,21 @@ impl<'a> Parser<'a> {\n                 }),\n             }?;\n \n+            let (lo, hi) = (lhs_span.lo, rhs.span.hi);\n             lhs = match op {\n                 AssocOp::Add | AssocOp::Subtract | AssocOp::Multiply | AssocOp::Divide |\n                 AssocOp::Modulus | AssocOp::LAnd | AssocOp::LOr | AssocOp::BitXor |\n                 AssocOp::BitAnd | AssocOp::BitOr | AssocOp::ShiftLeft | AssocOp::ShiftRight |\n                 AssocOp::Equal | AssocOp::Less | AssocOp::LessEqual | AssocOp::NotEqual |\n                 AssocOp::Greater | AssocOp::GreaterEqual => {\n                     let ast_op = op.to_ast_binop().unwrap();\n-                    let (lhs_span, rhs_span) = (lhs_span, rhs.span);\n                     let binary = self.mk_binary(codemap::respan(cur_op_span, ast_op), lhs, rhs);\n-                    self.mk_expr(lhs_span.lo, rhs_span.hi, binary, None)\n+                    self.mk_expr(lo, hi, binary, ThinVec::new())\n                 }\n                 AssocOp::Assign =>\n-                    self.mk_expr(lhs_span.lo, rhs.span.hi, ExprKind::Assign(lhs, rhs), None),\n+                    self.mk_expr(lo, hi, ExprKind::Assign(lhs, rhs), ThinVec::new()),\n                 AssocOp::Inplace =>\n-                    self.mk_expr(lhs_span.lo, rhs.span.hi, ExprKind::InPlace(lhs, rhs), None),\n+                    self.mk_expr(lo, hi, ExprKind::InPlace(lhs, rhs), ThinVec::new()),\n                 AssocOp::AssignOp(k) => {\n                     let aop = match k {\n                         token::Plus =>    BinOpKind::Add,\n@@ -3111,9 +3104,8 @@ impl<'a> Parser<'a> {\n                         token::Shl =>     BinOpKind::Shl,\n                         token::Shr =>     BinOpKind::Shr,\n                     };\n-                    let (lhs_span, rhs_span) = (lhs_span, rhs.span);\n                     let aopexpr = self.mk_assign_op(codemap::respan(cur_op_span, aop), lhs, rhs);\n-                    self.mk_expr(lhs_span.lo, rhs_span.hi, aopexpr, None)\n+                    self.mk_expr(lo, hi, aopexpr, ThinVec::new())\n                 }\n                 AssocOp::As | AssocOp::Colon | AssocOp::DotDot | AssocOp::DotDotDot => {\n                     self.bug(\"As, Colon, DotDot or DotDotDot branch reached\")\n@@ -3148,7 +3140,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse prefix-forms of range notation: `..expr`, `..`, `...expr`\n     fn parse_prefix_range_expr(&mut self,\n-                               already_parsed_attrs: Option<ThinAttributes>)\n+                               already_parsed_attrs: Option<ThinVec<Attribute>>)\n                                -> PResult<'a, P<Expr>> {\n         debug_assert!(self.token == token::DotDot || self.token == token::DotDotDot);\n         let tok = self.token.clone();\n@@ -3193,7 +3185,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an 'if' or 'if let' expression ('if' token already eaten)\n-    pub fn parse_if_expr(&mut self, attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n+    pub fn parse_if_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         if self.check_keyword(keywords::Let) {\n             return self.parse_if_let_expr(attrs);\n         }\n@@ -3211,7 +3203,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an 'if let' expression ('if' token already eaten)\n-    pub fn parse_if_let_expr(&mut self, attrs: ThinAttributes)\n+    pub fn parse_if_let_expr(&mut self, attrs: ThinVec<Attribute>)\n                              -> PResult<'a, P<Expr>> {\n         let lo = self.last_span.lo;\n         self.expect_keyword(keywords::Let)?;\n@@ -3232,7 +3224,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_lambda_expr(&mut self,\n                              lo: BytePos,\n                              capture_clause: CaptureBy,\n-                             attrs: ThinAttributes)\n+                             attrs: ThinVec<Attribute>)\n                              -> PResult<'a, P<Expr>>\n     {\n         let decl = self.parse_fn_block_decl()?;\n@@ -3267,24 +3259,24 @@ impl<'a> Parser<'a> {\n     // `else` token already eaten\n     pub fn parse_else_expr(&mut self) -> PResult<'a, P<Expr>> {\n         if self.eat_keyword(keywords::If) {\n-            return self.parse_if_expr(None);\n+            return self.parse_if_expr(ThinVec::new());\n         } else {\n             let blk = self.parse_block()?;\n-            return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprKind::Block(blk), None));\n+            return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprKind::Block(blk), ThinVec::new()));\n         }\n     }\n \n     /// Parse a 'for' .. 'in' expression ('for' token already eaten)\n     pub fn parse_for_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n                           span_lo: BytePos,\n-                          attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n+                          mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n \n         let pat = self.parse_pat()?;\n         self.expect_keyword(keywords::In)?;\n         let expr = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let (iattrs, loop_block) = self.parse_inner_attrs_and_block()?;\n-        let attrs = attrs.append(iattrs.into_thin_attrs());\n+        attrs.extend(iattrs);\n \n         let hi = self.last_span.hi;\n \n@@ -3296,13 +3288,13 @@ impl<'a> Parser<'a> {\n     /// Parse a 'while' or 'while let' expression ('while' token already eaten)\n     pub fn parse_while_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n                             span_lo: BytePos,\n-                            attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n+                            mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         if self.token.is_keyword(keywords::Let) {\n             return self.parse_while_let_expr(opt_ident, span_lo, attrs);\n         }\n         let cond = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n-        let attrs = attrs.append(iattrs.into_thin_attrs());\n+        attrs.extend(iattrs);\n         let hi = body.span.hi;\n         return Ok(self.mk_expr(span_lo, hi, ExprKind::While(cond, body, opt_ident),\n                                attrs));\n@@ -3311,29 +3303,29 @@ impl<'a> Parser<'a> {\n     /// Parse a 'while let' expression ('while' token already eaten)\n     pub fn parse_while_let_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n                                 span_lo: BytePos,\n-                                attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n+                                mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         self.expect_keyword(keywords::Let)?;\n         let pat = self.parse_pat()?;\n         self.expect(&token::Eq)?;\n         let expr = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n-        let attrs = attrs.append(iattrs.into_thin_attrs());\n+        attrs.extend(iattrs);\n         let hi = body.span.hi;\n         return Ok(self.mk_expr(span_lo, hi, ExprKind::WhileLet(pat, expr, body, opt_ident), attrs));\n     }\n \n     // parse `loop {...}`, `loop` token already eaten\n     pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n                            span_lo: BytePos,\n-                           attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n+                           mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n-        let attrs = attrs.append(iattrs.into_thin_attrs());\n+        attrs.extend(iattrs);\n         let hi = body.span.hi;\n         Ok(self.mk_expr(span_lo, hi, ExprKind::Loop(body, opt_ident), attrs))\n     }\n \n     // `match` token already eaten\n-    fn parse_match_expr(&mut self, attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n+    fn parse_match_expr(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         let match_span = self.last_span;\n         let lo = self.last_span.lo;\n         let discriminant = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL,\n@@ -3345,8 +3337,8 @@ impl<'a> Parser<'a> {\n             }\n             return Err(e)\n         }\n-        let attrs = attrs.append(\n-            self.parse_inner_attributes()?.into_thin_attrs());\n+        attrs.extend(self.parse_inner_attributes()?);\n+\n         let mut arms: Vec<Arm> = Vec::new();\n         while self.token != token::CloseDelim(token::Brace) {\n             match self.parse_arm() {\n@@ -3419,7 +3411,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse an expression, subject to the given restrictions\n     pub fn parse_expr_res(&mut self, r: Restrictions,\n-                          already_parsed_attrs: Option<ThinAttributes>)\n+                          already_parsed_attrs: Option<ThinVec<Attribute>>)\n                           -> PResult<'a, P<Expr>> {\n         self.with_res(r, |this| this.parse_assoc_expr(already_parsed_attrs))\n     }\n@@ -3617,7 +3609,7 @@ impl<'a> Parser<'a> {\n                 (None, self.parse_path(PathStyle::Expr)?)\n             };\n             let hi = self.last_span.hi;\n-            Ok(self.mk_expr(lo, hi, ExprKind::Path(qself, path), None))\n+            Ok(self.mk_expr(lo, hi, ExprKind::Path(qself, path), ThinVec::new()))\n         } else {\n             self.parse_pat_literal_maybe_minus()\n         }\n@@ -3712,7 +3704,8 @@ impl<'a> Parser<'a> {\n                       token::DotDotDot => {\n                         // Parse range\n                         let hi = self.last_span.hi;\n-                        let begin = self.mk_expr(lo, hi, ExprKind::Path(qself, path), None);\n+                        let begin =\n+                              self.mk_expr(lo, hi, ExprKind::Path(qself, path), ThinVec::new());\n                         self.bump();\n                         let end = self.parse_pat_range_end()?;\n                         pat = PatKind::Range(begin, end);\n@@ -3807,7 +3800,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a local variable declaration\n-    fn parse_local(&mut self, attrs: ThinAttributes) -> PResult<'a, P<Local>> {\n+    fn parse_local(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Local>> {\n         let lo = self.span.lo;\n         let pat = self.parse_pat()?;\n \n@@ -3941,7 +3934,7 @@ impl<'a> Parser<'a> {\n         Ok(Some(if self.eat_keyword(keywords::Let) {\n             Stmt {\n                 id: ast::DUMMY_NODE_ID,\n-                node: StmtKind::Local(self.parse_local(attrs.into_thin_attrs())?),\n+                node: StmtKind::Local(self.parse_local(attrs.into())?),\n                 span: mk_sp(lo, self.last_span.hi),\n             }\n         } else if self.token.is_ident()\n@@ -3997,7 +3990,7 @@ impl<'a> Parser<'a> {\n                 let mac = spanned(lo, hi, Mac_ { path: pth, tts: tts });\n                 Stmt {\n                     id: ast::DUMMY_NODE_ID,\n-                    node: StmtKind::Mac(P((mac, style, attrs.into_thin_attrs()))),\n+                    node: StmtKind::Mac(P((mac, style, attrs.into()))),\n                     span: mk_sp(lo, hi),\n                 }\n             } else {\n@@ -4057,7 +4050,7 @@ impl<'a> Parser<'a> {\n \n                     // Remainder are line-expr stmts.\n                     let e = self.parse_expr_res(\n-                        Restrictions::RESTRICTION_STMT_EXPR, Some(attrs.into_thin_attrs()))?;\n+                        Restrictions::RESTRICTION_STMT_EXPR, Some(attrs.into()))?;\n                     Stmt {\n                         id: ast::DUMMY_NODE_ID,\n                         span: mk_sp(lo, e.span.hi),\n@@ -4150,7 +4143,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn handle_macro_in_block(&mut self,\n-                             (mac, style, attrs): (ast::Mac, MacStmtStyle, ThinAttributes),\n+                             (mac, style, attrs): (ast::Mac, MacStmtStyle, ThinVec<Attribute>),\n                              span: Span,\n                              stmts: &mut Vec<Stmt>,\n                              last_block_expr: &mut Option<P<Expr>>)\n@@ -4168,7 +4161,7 @@ impl<'a> Parser<'a> {\n                     self.bump();\n                 }\n                 _ => {\n-                    let e = self.mk_mac_expr(span.lo, span.hi, mac.node, None);\n+                    let e = self.mk_mac_expr(span.lo, span.hi, mac.node, ThinVec::new());\n                     let lo = e.span.lo;\n                     let e = self.parse_dot_or_call_expr_with(e, lo, attrs)?;\n                     let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;"}, {"sha": "d399f53800469c083c9d3f64c5c5aaa07b5bb3db", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -14,7 +14,6 @@ use abi::{self, Abi};\n use ast::{self, BlockCheckMode, PatKind};\n use ast::{SelfKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::Attribute;\n-use attr::ThinAttributesExt;\n use util::parser::AssocOp;\n use attr;\n use attr::{AttrMetaMethods, AttributeMethods};\n@@ -1607,7 +1606,7 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(st.span.lo));\n         match st.node {\n             ast::StmtKind::Local(ref loc) => {\n-                try!(self.print_outer_attributes(loc.attrs.as_attr_slice()));\n+                try!(self.print_outer_attributes(&loc.attrs));\n                 try!(self.space_if_not_bol());\n                 try!(self.ibox(INDENT_UNIT));\n                 try!(self.word_nbsp(\"let\"));\n@@ -1635,7 +1634,7 @@ impl<'a> State<'a> {\n             ast::StmtKind::Mac(ref mac) => {\n                 let (ref mac, style, ref attrs) = **mac;\n                 try!(self.space_if_not_bol());\n-                try!(self.print_outer_attributes(attrs.as_attr_slice()));\n+                try!(self.print_outer_attributes(&attrs));\n                 let delim = match style {\n                     ast::MacStmtStyle::Braces => token::Brace,\n                     _ => token::Paren\n@@ -1975,7 +1974,7 @@ impl<'a> State<'a> {\n                                   is_inline: bool) -> io::Result<()> {\n         try!(self.maybe_print_comment(expr.span.lo));\n \n-        let attrs = expr.attrs.as_attr_slice();\n+        let attrs = &expr.attrs;\n         if is_inline {\n             try!(self.print_outer_attributes_inline(attrs));\n         } else {\n@@ -2119,9 +2118,7 @@ impl<'a> State<'a> {\n                     let i_expr = body.expr.as_ref().unwrap();\n                     match i_expr.node {\n                         ast::ExprKind::Block(ref blk) => {\n-                            try!(self.print_block_unclosed_with_attrs(\n-                                &blk,\n-                                i_expr.attrs.as_attr_slice()));\n+                            try!(self.print_block_unclosed_with_attrs(&blk, &i_expr.attrs));\n                         }\n                         _ => {\n                             // this is a bare expression"}, {"sha": "078103f834a08b58b2acfd147616a4dae71829dc", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -608,10 +608,10 @@ fn mk_test_descs(cx: &TestCtxt) -> P<ast::Expr> {\n                     mk_test_desc_and_fn_rec(cx, test)\n                 }).collect()),\n                 span: DUMMY_SP,\n-                attrs: None,\n+                attrs: ast::ThinVec::new(),\n             })),\n         span: DUMMY_SP,\n-        attrs: None,\n+        attrs: ast::ThinVec::new(),\n     })\n }\n "}, {"sha": "546686b46b8db4c92f2474b4f64ee354938cbe5a", "filename": "src/libsyntax/util/thin_vec.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Futil%2Fthin_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Futil%2Fthin_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fthin_vec.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// A vector type optimized for cases where this size is usually 0 (c.f. `SmallVector`).\n+/// The `Option<Box<..>>` wrapping allows us to represent a zero sized vector with `None`,\n+/// which uses only a single (null) pointer.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct ThinVec<T>(Option<Box<Vec<T>>>);\n+\n+impl<T> ThinVec<T> {\n+    pub fn new() -> Self {\n+        ThinVec(None)\n+    }\n+}\n+\n+impl<T> From<Vec<T>> for ThinVec<T> {\n+    fn from(vec: Vec<T>) -> Self {\n+        if vec.is_empty() {\n+            ThinVec(None)\n+        } else {\n+            ThinVec(Some(Box::new(vec)))\n+        }\n+    }\n+}\n+\n+impl<T> Into<Vec<T>> for ThinVec<T> {\n+    fn into(self) -> Vec<T> {\n+        match self {\n+            ThinVec(None) => Vec::new(),\n+            ThinVec(Some(vec)) => *vec,\n+        }\n+    }\n+}\n+\n+impl<T> ::std::ops::Deref for ThinVec<T> {\n+    type Target = [T];\n+    fn deref(&self) -> &[T] {\n+        match *self {\n+            ThinVec(None) => &[],\n+            ThinVec(Some(ref vec)) => vec,\n+        }\n+    }\n+}\n+\n+impl<T> Extend<T> for ThinVec<T> {\n+    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n+        match *self {\n+            ThinVec(Some(ref mut vec)) => vec.extend(iter),\n+            ThinVec(None) => *self = iter.into_iter().collect::<Vec<_>>().into(),\n+        }\n+    }\n+}"}, {"sha": "571965ef8728623abcfe70558dcfabeeee06a2bb", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -25,7 +25,6 @@\n \n use abi::Abi;\n use ast::*;\n-use attr::ThinAttributesExt;\n use syntax_pos::Span;\n use codemap::Spanned;\n \n@@ -184,7 +183,7 @@ pub fn walk_mod<V: Visitor>(visitor: &mut V, module: &Mod) {\n }\n \n pub fn walk_local<V: Visitor>(visitor: &mut V, local: &Local) {\n-    for attr in local.attrs.as_attr_slice() {\n+    for attr in local.attrs.iter() {\n         visitor.visit_attribute(attr);\n     }\n     visitor.visit_pat(&local.pat);\n@@ -604,7 +603,7 @@ pub fn walk_stmt<V: Visitor>(visitor: &mut V, statement: &Stmt) {\n         StmtKind::Mac(ref mac) => {\n             let (ref mac, _, ref attrs) = **mac;\n             visitor.visit_mac(mac);\n-            for attr in attrs.as_attr_slice() {\n+            for attr in attrs.iter() {\n                 visitor.visit_attribute(attr);\n             }\n         }\n@@ -616,7 +615,7 @@ pub fn walk_mac<V: Visitor>(_: &mut V, _: &Mac) {\n }\n \n pub fn walk_expr<V: Visitor>(visitor: &mut V, expression: &Expr) {\n-    for attr in expression.attrs.as_attr_slice() {\n+    for attr in expression.attrs.iter() {\n         visitor.visit_attribute(attr);\n     }\n     match expression.node {"}, {"sha": "56a8c28ffedc2fe6547bca57842d320da96d388a", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -261,6 +261,6 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::Token\n             expn_id: expn_id,\n         }),\n         span: sp,\n-        attrs: None,\n+        attrs: ast::ThinVec::new(),\n     }))\n }"}, {"sha": "870413a7f61b0526823f23356f5726e7170a3b52", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -71,7 +71,7 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[TokenTree])\n                 id: ast::DUMMY_NODE_ID,\n                 node: ast::ExprKind::Path(None, self.path()),\n                 span: self.span,\n-                attrs: None,\n+                attrs: ast::ThinVec::new(),\n             }))\n         }\n "}, {"sha": "dabe234eb9c19db5090af166018e8b23a8a82266", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -149,7 +149,7 @@ fn stmt_let_undescore(cx: &mut ExtCtxt,\n         init: Some(expr),\n         id: ast::DUMMY_NODE_ID,\n         span: sp,\n-        attrs: None,\n+        attrs: ast::ThinVec::new(),\n     });\n     ast::Stmt {\n         id: ast::DUMMY_NODE_ID,"}, {"sha": "64747002a65b03542eab3abc54bd4f4950be6a02", "filename": "src/test/run-pass-fulldeps/ast_stmt_expr_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8eddf0280014972e051856dfe949054acf53c043/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eddf0280014972e051856dfe949054acf53c043/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs?ref=8eddf0280014972e051856dfe949054acf53c043", "patch": "@@ -86,7 +86,7 @@ fn check_expr_attrs(es: &str, expected: &[&str]) {\n     let actual = &e.attrs;\n     str_compare(es,\n                 &expected.iter().map(|r| attr(r, &ps).unwrap()).collect::<Vec<_>>(),\n-                actual.as_attr_slice(),\n+                &actual,\n                 pprust::attribute_to_string);\n }\n "}]}