{"sha": "6f3061b18e960847b2db5b2b8216bad7349ef60e", "node_id": "C_kwDOAAsO6NoAKDZmMzA2MWIxOGU5NjA4NDdiMmRiNWIyYjgyMTZiYWQ3MzQ5ZWY2MGU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-21T21:25:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-21T21:25:52Z"}, "message": "Auto merge of #1945 - saethlin:better-sb-tracking, r=RalfJung\n\nProvide slightly better notes when tracking a pointer tag\n\nI slapped this in as a sort of advanced println-based debugging when trying to figure out a track-raw-pointers finding in `smallvec`. Perhaps this looks like a good idea to you all?\n\nEDIT: User scenario\n\nRun `MIRIFLAGS=-Ztag-raw-pointers cargo miri test`, get a diagnostic that looks like\n```\nerror: Undefined Behavior: trying to reborrow for SharedReadOnly at alloc99465+0x9, but parent tag <265507> does not have an appropriate item in the borrow stack\n```\nSo now run `MIRIFLAGS=-Ztag-raw-pointers -Zmiri-track-pointer-tag=265507 cargo miri test`\nOld:\n```\nnote: tracking was triggered\n   --> src/lib.rs:822:36\n    |\n822 |                 vec: NonNull::from(self),\n    |                                    ^^^^ popped tracked tag for item [SharedReadOnly for <265507>]\n```\nNew:\n```\nnote: tracking was triggered\n   --> src/lib.rs:822:36\n    |\n822 |                 vec: NonNull::from(self),\n    |                                    ^^^^ popped tracked tag for item [SharedReadOnly for <265507>] due to Write access for <265356>\n```\nSo that if a user is now beginning to question their sanity because they don't really understand SB yet, they can then track the tag which caused the parent tag to be removed from the stack to be sure what's going on here:\n```\n   --> src/lib.rs:792:5\n    |\n792 | /     pub fn drain<R>(&mut self, range: R) -> Drain<'_, A>\n793 | |     where\n794 | |         R: RangeBounds<usize>,\n795 | |     {\n...   |\n824 | |         }\n825 | |     }\n    | |_____^ created tag 265356\n```\n\nThe existing diagnostic can tell you where the tag you'd need was invalidated, but it cannot tell you what and why that tag was invalidated.", "tree": {"sha": "8f193440a4d4722ee19e96c87b3832e4cb603184", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f193440a4d4722ee19e96c87b3832e4cb603184"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f3061b18e960847b2db5b2b8216bad7349ef60e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f3061b18e960847b2db5b2b8216bad7349ef60e", "html_url": "https://github.com/rust-lang/rust/commit/6f3061b18e960847b2db5b2b8216bad7349ef60e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f3061b18e960847b2db5b2b8216bad7349ef60e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e969615937e9fdb7d293206e19f425b6184450de", "url": "https://api.github.com/repos/rust-lang/rust/commits/e969615937e9fdb7d293206e19f425b6184450de", "html_url": "https://github.com/rust-lang/rust/commit/e969615937e9fdb7d293206e19f425b6184450de"}, {"sha": "cd6921923c107781abd815f3e5ed6f9540a3ab73", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd6921923c107781abd815f3e5ed6f9540a3ab73", "html_url": "https://github.com/rust-lang/rust/commit/cd6921923c107781abd815f3e5ed6f9540a3ab73"}], "stats": {"total": 39, "additions": 31, "deletions": 8}, "files": [{"sha": "a28418e74905694250740d040abd555ff9219160", "filename": "src/diagnostics.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6f3061b18e960847b2db5b2b8216bad7349ef60e/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f3061b18e960847b2db5b2b8216bad7349ef60e/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=6f3061b18e960847b2db5b2b8216bad7349ef60e", "patch": "@@ -7,6 +7,7 @@ use log::trace;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::{source_map::DUMMY_SP, Span, SpanData, Symbol};\n \n+use crate::stacked_borrows::{AccessKind, SbTag};\n use crate::*;\n \n /// Details of premature program termination.\n@@ -58,7 +59,9 @@ impl MachineStopType for TerminationInfo {}\n /// Miri specific diagnostics\n pub enum NonHaltingDiagnostic {\n     CreatedPointerTag(NonZeroU64),\n-    PoppedPointerTag(Item),\n+    /// This `Item` was popped from the borrow stack, either due to a grant of\n+    /// `AccessKind` to `SbTag` or a deallocation when the second argument is `None`.\n+    PoppedPointerTag(Item, Option<(SbTag, AccessKind)>),\n     CreatedCallId(CallId),\n     CreatedAlloc(AllocId),\n     FreedAlloc(AllocId),\n@@ -321,7 +324,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 use NonHaltingDiagnostic::*;\n                 let msg = match e {\n                     CreatedPointerTag(tag) => format!(\"created tag {:?}\", tag),\n-                    PoppedPointerTag(item) => format!(\"popped tracked tag for item {:?}\", item),\n+                    PoppedPointerTag(item, tag) =>\n+                        match tag {\n+                            None =>\n+                                format!(\n+                                    \"popped tracked tag for item {:?} due to deallocation\",\n+                                    item\n+                                ),\n+                            Some((tag, access)) => {\n+                                format!(\n+                                    \"popped tracked tag for item {:?} due to {:?} access for {:?}\",\n+                                    item, access, tag\n+                                )\n+                            }\n+                        },\n                     CreatedCallId(id) => format!(\"function call with id {}\", id),\n                     CreatedAlloc(AllocId(id)) => format!(\"created allocation with id {}\", id),\n                     FreedAlloc(AllocId(id)) => format!(\"freed allocation with id {}\", id),"}, {"sha": "2919ce919aa47299139a00dd7a071168db726241", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6f3061b18e960847b2db5b2b8216bad7349ef60e/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f3061b18e960847b2db5b2b8216bad7349ef60e/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=6f3061b18e960847b2db5b2b8216bad7349ef60e", "patch": "@@ -111,7 +111,7 @@ pub struct GlobalState {\n pub type MemoryExtra = RefCell<GlobalState>;\n \n /// Indicates which kind of access is being performed.\n-#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]\n pub enum AccessKind {\n     Read,\n     Write,\n@@ -296,19 +296,26 @@ impl<'tcx> Stack {\n     }\n \n     /// Check if the given item is protected.\n+    ///\n+    /// The `provoking_access` argument is only used to produce diagnostics.\n+    /// It is `Some` when we are granting the contained access for said tag, and it is\n+    /// `None` during a deallocation.\n     fn check_protector(\n         item: &Item,\n-        tag: Option<SbTag>,\n+        provoking_access: Option<(SbTag, AccessKind)>,\n         global: &GlobalState,\n     ) -> InterpResult<'tcx> {\n         if let SbTag::Tagged(id) = item.tag {\n             if Some(id) == global.tracked_pointer_tag {\n-                register_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(item.clone()));\n+                register_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(\n+                    item.clone(),\n+                    provoking_access,\n+                ));\n             }\n         }\n         if let Some(call) = item.protector {\n             if global.is_active(call) {\n-                if let Some(tag) = tag {\n+                if let Some((tag, _)) = provoking_access {\n                     Err(err_sb_ub(format!(\n                         \"not granting access to tag {:?} because incompatible item is protected: {:?}\",\n                         tag, item\n@@ -348,7 +355,7 @@ impl<'tcx> Stack {\n             let first_incompatible_idx = self.find_first_write_incompatible(granting_idx);\n             for item in self.borrows.drain(first_incompatible_idx..).rev() {\n                 trace!(\"access: popping item {:?}\", item);\n-                Stack::check_protector(&item, Some(tag), global)?;\n+                Stack::check_protector(&item, Some((tag, access)), global)?;\n             }\n         } else {\n             // On a read, *disable* all `Unique` above the granting item.  This ensures U2 for read accesses.\n@@ -363,7 +370,7 @@ impl<'tcx> Stack {\n                 let item = &mut self.borrows[idx];\n                 if item.perm == Permission::Unique {\n                     trace!(\"access: disabling item {:?}\", item);\n-                    Stack::check_protector(item, Some(tag), global)?;\n+                    Stack::check_protector(item, Some((tag, access)), global)?;\n                     item.perm = Permission::Disabled;\n                 }\n             }"}]}