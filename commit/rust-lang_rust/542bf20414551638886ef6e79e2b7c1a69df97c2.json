{"sha": "542bf20414551638886ef6e79e2b7c1a69df97c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0MmJmMjA0MTQ1NTE2Mzg4ODZlZjZlNzllMmI3YzFhNjlkZjk3YzI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-02-02T02:37:45Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-02-02T05:22:49Z"}, "message": "core: Remove oldcomm", "tree": {"sha": "d89416f4bbc396dbb0b4e987e3cc7523dd20ee0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d89416f4bbc396dbb0b4e987e3cc7523dd20ee0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/542bf20414551638886ef6e79e2b7c1a69df97c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/542bf20414551638886ef6e79e2b7c1a69df97c2", "html_url": "https://github.com/rust-lang/rust/commit/542bf20414551638886ef6e79e2b7c1a69df97c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/542bf20414551638886ef6e79e2b7c1a69df97c2/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5633783f473e63578091aefbd6ac4e81797596a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5633783f473e63578091aefbd6ac4e81797596a8", "html_url": "https://github.com/rust-lang/rust/commit/5633783f473e63578091aefbd6ac4e81797596a8"}], "stats": {"total": 550, "additions": 0, "deletions": 550}, "files": [{"sha": "34804af70cae0e2553c0fb66b472bb8a73495ac2", "filename": "src/libcore/core.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/542bf20414551638886ef6e79e2b7c1a69df97c2/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/542bf20414551638886ef6e79e2b7c1a69df97c2/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=542bf20414551638886ef6e79e2b7c1a69df97c2", "patch": "@@ -144,7 +144,6 @@ pub mod hashmap;\n \n /* Tasks and communication */\n \n-pub mod oldcomm;\n #[path = \"task/mod.rs\"]\n pub mod task;\n pub mod pipes;"}, {"sha": "cb9593260d6638e8fa78a4972ef77703ea1233ee", "filename": "src/libcore/oldcomm.rs", "status": "removed", "additions": 0, "deletions": 547, "changes": 547, "blob_url": "https://github.com/rust-lang/rust/blob/5633783f473e63578091aefbd6ac4e81797596a8/src%2Flibcore%2Foldcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633783f473e63578091aefbd6ac4e81797596a8/src%2Flibcore%2Foldcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foldcomm.rs?ref=5633783f473e63578091aefbd6ac4e81797596a8", "patch": "@@ -1,547 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Deprecated communication between tasks\n-\n-Communication between tasks is facilitated by ports (in the receiving\n-task), and channels (in the sending task). Any number of channels may\n-feed into a single port.  Ports and channels may only transmit values\n-of unique types; that is, values that are statically guaranteed to be\n-accessed by a single 'owner' at a time.  Unique types include scalars,\n-vectors, strings, and records, tags, tuples and unique boxes (`~T`)\n-thereof. Most notably, shared boxes (`@T`) may not be transmitted\n-across channels.\n-\n-# Example\n-\n-~~~\n-let po = oldcomm::Port();\n-let ch = oldcomm::Chan(&po);\n-\n-do task::spawn {\n-    oldcomm::send(ch, ~\"Hello, World\");\n-}\n-\n-io::println(oldcomm::recv(po));\n-~~~\n-\n-# Note\n-\n-Use of this module is deprecated in favor of `core::pipes`. In the\n-`core::comm` will likely be rewritten with pipes, at which point it\n-will once again be the preferred module for intertask communication.\n-\n-*/\n-\n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n-use cast;\n-use either;\n-use either::Either;\n-use iter;\n-use libc;\n-use libc::size_t;\n-use prelude::*;\n-use ptr;\n-use result;\n-use sys;\n-use task;\n-use vec;\n-\n-// After snapshot, change p2::addr_of => addr_of\n-\n-/**\n- * A communication endpoint that can receive messages\n- *\n- * Each port has a unique per-task identity and may not be replicated or\n- * transmitted. If a port value is copied, both copies refer to the same\n- * port.  Ports may be associated with multiple `chan`s.\n- */\n-pub enum Port<T> {\n-    Port_(@PortPtr<T>)\n-}\n-\n-// It's critical that this only have one variant, so it has a record\n-// layout, and will work in the rust_task structure in task.rs.\n-/**\n- * A communication endpoint that can send messages\n- *\n- * Each channel is bound to a port when the channel is constructed, so\n- * the destination port for a channel must exist before the channel\n- * itself.  Channels are weak: a channel does not keep the port it is\n- * bound to alive. If a channel attempts to send data to a dead port that\n- * data will be silently dropped.  Channels may be duplicated and\n- * themselves transmitted over other channels.\n- */\n-pub enum Chan<T> {\n-    Chan_(port_id)\n-}\n-\n-/// Constructs a port\n-pub fn Port<T: Owned>() -> Port<T> {\n-    unsafe {\n-        Port_(@PortPtr(rustrt::new_port(sys::nonzero_size_of::<T>()\n-                                        as size_t)))\n-    }\n-}\n-\n-impl<T: Owned> Port<T> {\n-\n-    fn chan() -> Chan<T> { Chan(&self) }\n-    fn send(v: T) { self.chan().send(move v) }\n-    fn recv() -> T { recv(self) }\n-    fn peek() -> bool { peek(self) }\n-\n-}\n-\n-impl<T: Owned> Chan<T> {\n-\n-    fn chan() -> Chan<T> { self }\n-    fn send(v: T) { send(self, move v) }\n-    fn recv() -> T { recv_chan(self) }\n-    fn peek() -> bool { peek_chan(self) }\n-\n-}\n-\n-/// Open a new receiving channel for the duration of a function\n-pub fn listen<T: Owned, U>(f: fn(Chan<T>) -> U) -> U {\n-    let po = Port();\n-    f(po.chan())\n-}\n-\n-struct PortPtr<T> {\n-  po: *rust_port,\n-  drop {\n-    unsafe {\n-      do task::unkillable {\n-        // Once the port is detached it's guaranteed not to receive further\n-        // messages\n-        let yield = 0;\n-        let yieldp = ptr::addr_of(&yield);\n-        rustrt::rust_port_begin_detach(self.po, yieldp);\n-        if yield != 0 {\n-            // Need to wait for the port to be detached\n-            task::yield();\n-        }\n-        rustrt::rust_port_end_detach(self.po);\n-\n-        // Drain the port so that all the still-enqueued items get dropped\n-        while rustrt::rust_port_size(self.po) > 0 as size_t {\n-            recv_::<T>(self.po);\n-        }\n-        rustrt::del_port(self.po);\n-      }\n-    }\n-  }\n-}\n-\n-fn PortPtr<T: Owned>(po: *rust_port) -> PortPtr<T> {\n-    PortPtr {\n-        po: po\n-    }\n-}\n-\n-/**\n- * Internal function for converting from a channel to a port\n- *\n- * # Failure\n- *\n- * Fails if the port is detached or dead. Fails if the port\n- * is owned by a different task.\n- */\n-fn as_raw_port<T: Owned, U>(ch: Chan<T>, f: fn(*rust_port) -> U) -> U {\n-\n-    struct PortRef {\n-        p: *rust_port,\n-        drop {\n-            unsafe {\n-                if !ptr::is_null(self.p) {\n-                    rustrt::rust_port_drop(self.p);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn PortRef(p: *rust_port) -> PortRef {\n-        PortRef {\n-            p: p\n-        }\n-    }\n-\n-    unsafe {\n-        let p = PortRef(rustrt::rust_port_take(*ch));\n-\n-        if ptr::is_null(p.p) {\n-            die!(~\"unable to locate port for channel\")\n-        } else if rustrt::get_task_id() != rustrt::rust_port_task(p.p) {\n-            die!(~\"unable to access unowned port\")\n-        }\n-\n-        f(p.p)\n-    }\n-}\n-\n-/**\n- * Constructs a channel. The channel is bound to the port used to\n- * construct it.\n- */\n-pub fn Chan<T: Owned>(p: &Port<T>) -> Chan<T> {\n-    unsafe {\n-        Chan_(rustrt::get_port_id((**p).po))\n-    }\n-}\n-\n-/**\n- * Sends data over a channel. The sent data is moved into the channel,\n- * whereupon the caller loses access to it.\n- */\n-pub fn send<T: Owned>(ch: Chan<T>, data: T) {\n-    unsafe {\n-        let Chan_(p) = ch;\n-        let data_ptr = ptr::addr_of(&data) as *();\n-        let res = rustrt::rust_port_id_send(p, data_ptr);\n-        if res != 0 {\n-            // Data sent successfully\n-            cast::forget(move data);\n-        }\n-        task::yield();\n-    }\n-}\n-\n-/**\n- * Receive from a port.  If no data is available on the port then the\n- * task will block until data becomes available.\n- */\n-pub fn recv<T: Owned>(p: Port<T>) -> T { recv_((**p).po) }\n-\n-/// Returns true if there are messages available\n-pub fn peek<T: Owned>(p: Port<T>) -> bool { peek_((**p).po) }\n-\n-#[doc(hidden)]\n-pub fn recv_chan<T: Owned>(ch: Chan<T>) -> T {\n-    as_raw_port(ch, |x|recv_(x))\n-}\n-\n-fn peek_chan<T: Owned>(ch: Chan<T>) -> bool {\n-    as_raw_port(ch, |x|peek_(x))\n-}\n-\n-/// Receive on a raw port pointer\n-fn recv_<T>(p: *rust_port) -> T {\n-    unsafe {\n-        let yield = 0;\n-        let yieldp = ptr::addr_of(&yield);\n-        let mut res;\n-        res = rusti::init::<T>();\n-        rustrt::port_recv(ptr::addr_of(&res) as *uint, p, yieldp);\n-\n-        if yield != 0 {\n-            // Data isn't available yet, so res has not been initialized.\n-            task::yield();\n-        } else {\n-            // In the absence of compiler-generated preemption points\n-            // this is a good place to yield\n-            task::yield();\n-        }\n-        move res\n-    }\n-}\n-\n-fn peek_(p: *rust_port) -> bool {\n-    unsafe {\n-        // Yield here before we check to see if someone sent us a message\n-        // FIXME #524, if the compiler generates yields, we don't need this\n-        task::yield();\n-        rustrt::rust_port_size(p) != 0 as libc::size_t\n-    }\n-}\n-\n-/// Receive on one of two ports\n-pub fn select2<A: Owned, B: Owned>(p_a: Port<A>, p_b: Port<B>)\n-    -> Either<A, B> {\n-    unsafe {\n-        let ports = ~[(**p_a).po, (**p_b).po];\n-        let yield = 0, yieldp = ptr::addr_of(&yield);\n-\n-        let mut resport: *rust_port;\n-        resport = rusti::init::<*rust_port>();\n-        do vec::as_imm_buf(ports) |ports, n_ports| {\n-            rustrt::rust_port_select(ptr::addr_of(&resport), ports,\n-                                     n_ports as size_t, yieldp);\n-        }\n-\n-        if yield != 0 {\n-            // Wait for data\n-            task::yield();\n-        } else {\n-            // As in recv, this is a good place to yield anyway until\n-            // the compiler generates yield calls\n-            task::yield();\n-        }\n-\n-        // Now we know the port we're supposed to receive from\n-        assert resport != ptr::null();\n-\n-        if resport == (**p_a).po {\n-            either::Left(recv(p_a))\n-        } else if resport == (**p_b).po {\n-            either::Right(recv(p_b))\n-        } else {\n-            die!(~\"unexpected result from rust_port_select\");\n-        }\n-    }\n-}\n-\n-\n-/* Implementation details */\n-\n-#[allow(non_camel_case_types)] // runtime type\n-enum rust_port {}\n-\n-#[allow(non_camel_case_types)] // runtime type\n-type port_id = int;\n-\n-#[abi = \"cdecl\"]\n-extern mod rustrt {\n-    unsafe fn rust_port_id_send(target_port: port_id, data: *())\n-                             -> libc::uintptr_t;\n-\n-    unsafe fn new_port(unit_sz: libc::size_t) -> *rust_port;\n-    unsafe fn del_port(po: *rust_port);\n-    unsafe fn rust_port_begin_detach(po: *rust_port,\n-                              yield: *libc::uintptr_t);\n-    unsafe fn rust_port_end_detach(po: *rust_port);\n-    unsafe fn get_port_id(po: *rust_port) -> port_id;\n-    unsafe fn rust_port_size(po: *rust_port) -> libc::size_t;\n-    unsafe fn port_recv(dptr: *uint, po: *rust_port,\n-                 yield: *libc::uintptr_t);\n-    unsafe fn rust_port_select(dptr: **rust_port, ports: **rust_port,\n-                        n_ports: libc::size_t,\n-                        yield: *libc::uintptr_t);\n-    unsafe fn rust_port_take(port_id: port_id) -> *rust_port;\n-    unsafe fn rust_port_drop(p: *rust_port);\n-    unsafe fn rust_port_task(p: *rust_port) -> libc::uintptr_t;\n-    unsafe fn get_task_id() -> libc::uintptr_t;\n-}\n-\n-#[abi = \"rust-intrinsic\"]\n-extern mod rusti {\n-    fn init<T>() -> T;\n-}\n-\n-\n-/* Tests */\n-\n-\n-#[test]\n-fn create_port_and_chan() { let p = Port::<int>(); Chan(&p); }\n-\n-#[test]\n-fn send_int() {\n-    let p = Port::<int>();\n-    let c = Chan(&p);\n-    send(c, 22);\n-}\n-\n-#[test]\n-fn send_recv_fn() {\n-    let p = Port::<int>();\n-    let c = Chan::<int>(&p);\n-    send(c, 42);\n-    assert (recv(p) == 42);\n-}\n-\n-#[test]\n-fn send_recv_fn_infer() {\n-    let p = Port();\n-    let c = Chan(&p);\n-    send(c, 42);\n-    assert (recv(p) == 42);\n-}\n-\n-#[test]\n-fn chan_chan_infer() {\n-    let p = Port(), p2 = Port::<int>();\n-    let c = Chan(&p);\n-    send(c, Chan(&p2));\n-    recv(p);\n-}\n-\n-#[test]\n-fn chan_chan() {\n-    let p = Port::<Chan<int>>(), p2 = Port::<int>();\n-    let c = Chan(&p);\n-    send(c, Chan(&p2));\n-    recv(p);\n-}\n-\n-#[test]\n-fn test_peek() {\n-    let po = Port();\n-    let ch = Chan(&po);\n-    assert !peek(po);\n-    send(ch, ());\n-    assert peek(po);\n-    recv(po);\n-    assert !peek(po);\n-}\n-\n-#[test]\n-fn test_select2_available() {\n-    let po_a = Port();\n-    let po_b = Port();\n-    let ch_a = Chan(&po_a);\n-    let ch_b = Chan(&po_b);\n-\n-    send(ch_a, ~\"a\");\n-\n-    assert select2(po_a, po_b) == either::Left(~\"a\");\n-\n-    send(ch_b, ~\"b\");\n-\n-    assert select2(po_a, po_b) == either::Right(~\"b\");\n-}\n-\n-#[test]\n-fn test_select2_rendezvous() {\n-    let po_a = Port();\n-    let po_b = Port();\n-    let ch_a = Chan(&po_a);\n-    let ch_b = Chan(&po_b);\n-\n-    for iter::repeat(10) {\n-        do task::spawn {\n-            for iter::repeat(10) { task::yield() }\n-            send(ch_a, ~\"a\");\n-        };\n-\n-        assert select2(po_a, po_b) == either::Left(~\"a\");\n-\n-        do task::spawn {\n-            for iter::repeat(10) { task::yield() }\n-            send(ch_b, ~\"b\");\n-        };\n-\n-        assert select2(po_a, po_b) == either::Right(~\"b\");\n-    }\n-}\n-\n-#[test]\n-fn test_select2_stress() {\n-    let po_a = Port();\n-    let po_b = Port();\n-    let ch_a = Chan(&po_a);\n-    let ch_b = Chan(&po_b);\n-\n-    let msgs = 100;\n-    let times = 4u;\n-\n-    for iter::repeat(times) {\n-        do task::spawn {\n-            for iter::repeat(msgs) {\n-                send(ch_a, ~\"a\")\n-            }\n-        };\n-        do task::spawn {\n-            for iter::repeat(msgs) {\n-                send(ch_b, ~\"b\")\n-            }\n-        };\n-    }\n-\n-    let mut as_ = 0;\n-    let mut bs = 0;\n-    for iter::repeat(msgs * times * 2u) {\n-        match select2(po_a, po_b) {\n-          either::Left(~\"a\") => as_ += 1,\n-          either::Right(~\"b\") => bs += 1,\n-          _ => die!(~\"test_select_2_stress failed\")\n-        }\n-    }\n-\n-    assert as_ == 400;\n-    assert bs == 400;\n-}\n-\n-#[test]\n-fn test_recv_chan() {\n-    let po = Port();\n-    let ch = Chan(&po);\n-    send(ch, ~\"flower\");\n-    assert recv_chan(ch) == ~\"flower\";\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(windows))]\n-fn test_recv_chan_dead() {\n-    let ch = Chan(&Port());\n-    send(ch, ~\"flower\");\n-    recv_chan(ch);\n-}\n-\n-#[test]\n-#[ignore(cfg(windows))]\n-fn test_recv_chan_wrong_task() {\n-    let po = Port();\n-    let ch = Chan(&po);\n-    send(ch, ~\"flower\");\n-    assert result::is_err(&task::try(||\n-        recv_chan(ch)\n-    ))\n-}\n-\n-#[test]\n-fn test_port_send() {\n-    let po = Port();\n-    po.send(());\n-    po.recv();\n-}\n-\n-#[test]\n-fn test_chan_peek() {\n-    let po = Port();\n-    let ch = po.chan();\n-    ch.send(());\n-    assert ch.peek();\n-}\n-\n-#[test]\n-fn test_listen() {\n-    do listen |parent| {\n-        do task::spawn {\n-            parent.send(~\"oatmeal-salad\");\n-        }\n-        assert parent.recv() == ~\"oatmeal-salad\";\n-    }\n-}\n-\n-#[test]\n-#[ignore(cfg(windows))]\n-fn test_port_detach_fail() {\n-    for iter::repeat(100) {\n-        do task::spawn_unlinked {\n-            let po = Port();\n-            let ch = po.chan();\n-\n-            do task::spawn {\n-                die!();\n-            }\n-\n-            do task::spawn {\n-                ch.send(());\n-            }\n-        }\n-    }\n-}"}, {"sha": "6bd319a15d261134d960bd65885e7f579d00b88a", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/542bf20414551638886ef6e79e2b7c1a69df97c2/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542bf20414551638886ef6e79e2b7c1a69df97c2/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=542bf20414551638886ef6e79e2b7c1a69df97c2", "patch": "@@ -69,7 +69,6 @@ pub use io;\n pub use iter;\n pub use libc;\n pub use num;\n-pub use oldcomm;\n pub use ops;\n pub use option;\n pub use os;"}, {"sha": "c88587067c1eb068e3a3f0a8087609dbb4837871", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/542bf20414551638886ef6e79e2b7c1a69df97c2/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542bf20414551638886ef6e79e2b7c1a69df97c2/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=542bf20414551638886ef6e79e2b7c1a69df97c2", "patch": "@@ -75,7 +75,6 @@\n \n use cast;\n use container::Map;\n-use oldcomm;\n use option;\n use pipes::{Chan, GenericChan, GenericPort, Port, stream};\n use pipes;"}]}