{"sha": "6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhOGQxMzFlNWRmNjBiYTQ4YzIzODJmOWEzMDI3YjJjNzVjMTRlMTg=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-10-27T01:52:10Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-02T01:50:32Z"}, "message": "rustc: make all read access to tcx.tables go through a method.", "tree": {"sha": "ee8fdd3b7589db7da2e8d783d4baa1af9f1874ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee8fdd3b7589db7da2e8d783d4baa1af9f1874ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "html_url": "https://github.com/rust-lang/rust/commit/6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea4b94dab0d526135dd658d3a314cc5462d439b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea4b94dab0d526135dd658d3a314cc5462d439b0", "html_url": "https://github.com/rust-lang/rust/commit/ea4b94dab0d526135dd658d3a314cc5462d439b0"}], "stats": {"total": 449, "additions": 219, "deletions": 230}, "files": [{"sha": "8c7805b5450e3575044b7f5e41e676c68b170078", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -311,11 +311,11 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             hir::ExprIndex(ref l, ref r) |\n-            hir::ExprBinary(_, ref l, ref r) if self.tcx.is_method_call(expr.id) => {\n+            hir::ExprBinary(_, ref l, ref r) if self.tcx.tables().is_method_call(expr.id) => {\n                 self.call(expr, pred, &l, Some(&**r).into_iter())\n             }\n \n-            hir::ExprUnary(_, ref e) if self.tcx.is_method_call(expr.id) => {\n+            hir::ExprUnary(_, ref e) if self.tcx.tables().is_method_call(expr.id) => {\n                 self.call(expr, pred, &e, None::<hir::Expr>.iter())\n             }\n \n@@ -372,7 +372,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             func_or_rcvr: &hir::Expr,\n             args: I) -> CFGIndex {\n         let method_call = ty::MethodCall::expr(call_expr.id);\n-        let fn_ty = match self.tcx.tables.borrow().method_map.get(&method_call) {\n+        let fn_ty = match self.tcx.tables().method_map.get(&method_call) {\n             Some(method) => method.ty,\n             None => self.tcx.expr_ty_adjusted(func_or_rcvr)\n         };"}, {"sha": "daa32fc760faa6aa515a94594c2f06f630bb8b0a", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         match def {\n             Def::AssociatedTy(..) | Def::Method(_) | Def::AssociatedConst(_)\n             if self.tcx.trait_of_item(def.def_id()).is_some() => {\n-                if let Some(substs) = self.tcx.tables.borrow().item_substs.get(&id) {\n+                if let Some(substs) = self.tcx.tables().item_substs.get(&id) {\n                     if let ty::TyAdt(tyid, _) = substs.substs.type_at(0).sty {\n                         self.check_def_id(tyid.did);\n                     }\n@@ -123,7 +123,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn lookup_and_handle_method(&mut self, id: ast::NodeId) {\n         let method_call = ty::MethodCall::expr(id);\n-        let method = self.tcx.tables.borrow().method_map[&method_call];\n+        let method = self.tcx.tables().method_map[&method_call];\n         self.check_def_id(method.def_id);\n     }\n \n@@ -148,7 +148,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_field_pattern_match(&mut self, lhs: &hir::Pat,\n                                   pats: &[codemap::Spanned<hir::FieldPat>]) {\n-        let variant = match self.tcx.node_id_to_type(lhs.id).sty {\n+        let variant = match self.tcx.tables().node_id_to_type(lhs.id).sty {\n             ty::TyAdt(adt, _) => {\n                 adt.variant_of_def(self.tcx.expect_def(lhs.id))\n             }\n@@ -433,7 +433,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     }\n \n     fn should_warn_about_field(&mut self, field: &hir::StructField) -> bool {\n-        let field_type = self.tcx.node_id_to_type(field.id);\n+        let field_type = self.tcx.tables().node_id_to_type(field.id);\n         let is_marker_field = match field_type.ty_to_def_id() {\n             Some(def_id) => self.tcx.lang_items.items().iter().any(|item| *item == Some(def_id)),\n             _ => false"}, {"sha": "8964405fb7f778ac6e4d49ead9fb187f6ce02631", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -159,7 +159,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n                 let method_call = MethodCall::expr(expr.id);\n-                let base_type = self.tcx.tables.borrow().method_map[&method_call].ty;\n+                let base_type = self.tcx.tables().method_map[&method_call].ty;\n                 debug!(\"effect: method call case, base type is {:?}\",\n                         base_type);\n                 if type_is_unsafe_function(base_type) {\n@@ -214,7 +214,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n \n     fn visit_pat(&mut self, pat: &hir::Pat) {\n         if let PatKind::Struct(_, ref fields, _) = pat.node {\n-            if let ty::TyAdt(adt, ..) = self.tcx.pat_ty(pat).sty {\n+            if let ty::TyAdt(adt, ..) = self.tcx.tables().pat_ty(pat).sty {\n                 if adt.is_union() {\n                     for field in fields {\n                         self.require_unsafe(field.span, \"matching on union field\");"}, {"sha": "57503398cfe577acd6aa87f5e37af21cb734e5c9", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -163,7 +163,7 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for ExprVisitor<'a, 'gcx, 'tcx> {\n         if let hir::ExprPath(..) = expr.node {\n             match self.infcx.tcx.expect_def(expr.id) {\n                 Def::Fn(did) if self.def_id_is_transmute(did) => {\n-                    let typ = self.infcx.tcx.node_id_to_type(expr.id);\n+                    let typ = self.infcx.tcx.tables().node_id_to_type(expr.id);\n                     match typ.sty {\n                         ty::TyFnDef(.., ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n                             let from = bare_fn_ty.sig.0.inputs[0];"}, {"sha": "e544ddc402b5fdf42e1eb89bffdd9c1e673beab3", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -1081,7 +1081,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprAssignOp(_, ref l, ref r) => {\n             // an overloaded assign op is like a method call\n-            if self.ir.tcx.is_method_call(expr.id) {\n+            if self.ir.tcx.tables().is_method_call(expr.id) {\n                 let succ = self.propagate_through_expr(&l, succ);\n                 self.propagate_through_expr(&r, succ)\n             } else {\n@@ -1113,7 +1113,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprCall(ref f, ref args) => {\n             // FIXME(canndrew): This is_never should really be an is_uninhabited\n-            let diverges = !self.ir.tcx.is_method_call(expr.id) &&\n+            let diverges = !self.ir.tcx.tables().is_method_call(expr.id) &&\n                 self.ir.tcx.expr_ty_adjusted(&f).fn_ret().0.is_never();\n             let succ = if diverges {\n                 self.s.exit_ln\n@@ -1126,7 +1126,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprMethodCall(.., ref args) => {\n             let method_call = ty::MethodCall::expr(expr.id);\n-            let method_ty = self.ir.tcx.tables.borrow().method_map[&method_call].ty;\n+            let method_ty = self.ir.tcx.tables().method_map[&method_call].ty;\n             // FIXME(canndrew): This is_never should really be an is_uninhabited\n             let succ = if method_ty.fn_ret().0.is_never() {\n                 self.s.exit_ln\n@@ -1409,7 +1409,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       }\n \n       hir::ExprAssignOp(_, ref l, _) => {\n-        if !this.ir.tcx.is_method_call(expr.id) {\n+        if !this.ir.tcx.tables().is_method_call(expr.id) {\n             this.check_lvalue(&l);\n         }\n \n@@ -1459,7 +1459,7 @@ fn check_fn(_v: &Liveness,\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn fn_ret(&self, id: NodeId) -> ty::Binder<Ty<'tcx>> {\n-        let fn_ty = self.ir.tcx.node_id_to_type(id);\n+        let fn_ty = self.ir.tcx.tables().node_id_to_type(id);\n         match fn_ty.sty {\n             ty::TyClosure(closure_def_id, substs) =>\n                 self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n@@ -1502,7 +1502,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     None if !body.stmts.is_empty() =>\n                         match body.stmts.last().unwrap().node {\n                             hir::StmtSemi(ref e, _) => {\n-                                self.ir.tcx.expr_ty(&e) == fn_ret\n+                                self.ir.tcx.tables().expr_ty(&e) == fn_ret\n                             },\n                             _ => false\n                         },"}, {"sha": "1a50d7aa0adc7f34107bf6f5d05ee20541c4f624", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -116,7 +116,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n             }\n             hir::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                let def_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n+                let def_id = self.tcx.tables().method_map[&method_call].def_id;\n \n                 // Mark the trait item (and, possibly, its default impl) as reachable\n                 // Or mark inherent impl item as reachable"}, {"sha": "a03cf708e8c19d10071747b1cc68baeb20b4ee1d", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -555,7 +555,7 @@ pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n         hir::ExprMethodCall(i, ..) => {\n             span = i.span;\n             let method_call = ty::MethodCall::expr(e.id);\n-            tcx.tables.borrow().method_map[&method_call].def_id\n+            tcx.tables().method_map[&method_call].def_id\n         }\n         hir::ExprField(ref base_e, ref field) => {\n             span = field.span;\n@@ -580,7 +580,7 @@ pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n             }\n         }\n         hir::ExprStruct(_, ref expr_fields, _) => {\n-            match tcx.expr_ty(e).sty {\n+            match tcx.tables().expr_ty(e).sty {\n                 ty::TyAdt(adt, ..) => match adt.adt_kind() {\n                     AdtKind::Struct | AdtKind::Union => {\n                         // check the stability of each field that appears\n@@ -637,7 +637,7 @@ pub fn check_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &hir::Pat,\n     debug!(\"check_pat(pat = {:?})\", pat);\n     if is_internal(tcx, pat.span) { return; }\n \n-    let v = match tcx.pat_ty_opt(pat).map(|ty| &ty.sty) {\n+    let v = match tcx.tables().pat_ty_opt(pat).map(|ty| &ty.sty) {\n         Some(&ty::TyAdt(adt, _)) if !adt.is_enum() => adt.struct_variant(),\n         _ => return,\n     };"}, {"sha": "9a707a49b093f42000bd20f926a6e6759fba9bf4", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 60, "deletions": 9, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -41,7 +41,7 @@ use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n use arena::TypedArena;\n use std::borrow::Borrow;\n-use std::cell::{Cell, RefCell, Ref};\n+use std::cell::{Cell, RefCell};\n use std::hash::{Hash, Hasher};\n use std::mem;\n use std::ops::Deref;\n@@ -255,6 +255,65 @@ impl<'a, 'gcx, 'tcx> Tables<'tcx> {\n             fru_field_types: NodeMap()\n         }\n     }\n+\n+    pub fn node_id_to_type(&self, id: NodeId) -> Ty<'tcx> {\n+        match self.node_id_to_type_opt(id) {\n+            Some(ty) => ty,\n+            None => {\n+                bug!(\"node_id_to_type: no type for node `{}`\",\n+                     tls::with(|tcx| tcx.map.node_to_string(id)))\n+            }\n+        }\n+    }\n+\n+    pub fn node_id_to_type_opt(&self, id: NodeId) -> Option<Ty<'tcx>> {\n+        self.node_types.get(&id).cloned()\n+    }\n+\n+    pub fn node_id_item_substs(&self, id: NodeId) -> Option<&'tcx Substs<'tcx>> {\n+        self.item_substs.get(&id).map(|ts| ts.substs)\n+    }\n+\n+    // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n+    // doesn't provide type parameter substitutions.\n+    pub fn pat_ty(&self, pat: &hir::Pat) -> Ty<'tcx> {\n+        self.node_id_to_type(pat.id)\n+    }\n+\n+    pub fn pat_ty_opt(&self, pat: &hir::Pat) -> Option<Ty<'tcx>> {\n+        self.node_id_to_type_opt(pat.id)\n+    }\n+\n+    // Returns the type of an expression as a monotype.\n+    //\n+    // NB (1): This is the PRE-ADJUSTMENT TYPE for the expression.  That is, in\n+    // some cases, we insert `AutoAdjustment` annotations such as auto-deref or\n+    // auto-ref.  The type returned by this function does not consider such\n+    // adjustments.  See `expr_ty_adjusted()` instead.\n+    //\n+    // NB (2): This type doesn't provide type parameter substitutions; e.g. if you\n+    // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&isize) -> isize\"\n+    // instead of \"fn(ty) -> T with T = isize\".\n+    pub fn expr_ty(&self, expr: &hir::Expr) -> Ty<'tcx> {\n+        self.node_id_to_type(expr.id)\n+    }\n+\n+    pub fn expr_ty_opt(&self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n+        self.node_id_to_type_opt(expr.id)\n+    }\n+\n+\n+    pub fn is_method_call(&self, expr_id: NodeId) -> bool {\n+        self.method_map.contains_key(&ty::MethodCall::expr(expr_id))\n+    }\n+\n+    pub fn is_overloaded_autoderef(&self, expr_id: NodeId, autoderefs: u32) -> bool {\n+        self.method_map.contains_key(&ty::MethodCall::autoderef(expr_id, autoderefs))\n+    }\n+\n+    pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture<'tcx>> {\n+        Some(self.upvar_capture_map.get(&upvar_id).unwrap().clone())\n+    }\n }\n \n impl<'tcx> CommonTypes<'tcx> {\n@@ -599,14 +658,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.ty_param_defs.borrow().get(&node_id).unwrap().clone()\n     }\n \n-    pub fn node_types(self) -> Ref<'a, NodeMap<Ty<'tcx>>> {\n-        fn projection<'a, 'tcx>(tables: &'a Tables<'tcx>) -> &'a NodeMap<Ty<'tcx>> {\n-            &tables.node_types\n-        }\n-\n-        Ref::map(self.tables.borrow(), projection)\n-    }\n-\n     pub fn node_type_insert(self, id: NodeId, ty: Ty<'gcx>) {\n         self.tables.borrow_mut().node_types.insert(id, ty);\n     }"}, {"sha": "a378e22e5efd4a01fa9869cf1f682c1346a50cb1", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 65, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -2120,52 +2120,8 @@ impl BorrowKind {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn node_id_to_type(self, id: NodeId) -> Ty<'gcx> {\n-        match self.node_id_to_type_opt(id) {\n-           Some(ty) => ty,\n-           None => bug!(\"node_id_to_type: no type for node `{}`\",\n-                        self.map.node_to_string(id))\n-        }\n-    }\n-\n-    pub fn node_id_to_type_opt(self, id: NodeId) -> Option<Ty<'gcx>> {\n-        self.tables.borrow().node_types.get(&id).cloned()\n-    }\n-\n-    pub fn node_id_item_substs(self, id: NodeId) -> ItemSubsts<'gcx> {\n-        match self.tables.borrow().item_substs.get(&id) {\n-            None => ItemSubsts {\n-                substs: self.global_tcx().intern_substs(&[])\n-            },\n-            Some(ts) => ts.clone(),\n-        }\n-    }\n-\n-    // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n-    // doesn't provide type parameter substitutions.\n-    pub fn pat_ty(self, pat: &hir::Pat) -> Ty<'gcx> {\n-        self.node_id_to_type(pat.id)\n-    }\n-    pub fn pat_ty_opt(self, pat: &hir::Pat) -> Option<Ty<'gcx>> {\n-        self.node_id_to_type_opt(pat.id)\n-    }\n-\n-    // Returns the type of an expression as a monotype.\n-    //\n-    // NB (1): This is the PRE-ADJUSTMENT TYPE for the expression.  That is, in\n-    // some cases, we insert `AutoAdjustment` annotations such as auto-deref or\n-    // auto-ref.  The type returned by this function does not consider such\n-    // adjustments.  See `expr_ty_adjusted()` instead.\n-    //\n-    // NB (2): This type doesn't provide type parameter substitutions; e.g. if you\n-    // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&isize) -> isize\"\n-    // instead of \"fn(ty) -> T with T = isize\".\n-    pub fn expr_ty(self, expr: &hir::Expr) -> Ty<'gcx> {\n-        self.node_id_to_type(expr.id)\n-    }\n-\n-    pub fn expr_ty_opt(self, expr: &hir::Expr) -> Option<Ty<'gcx>> {\n-        self.node_id_to_type_opt(expr.id)\n+    pub fn tables(self) -> Ref<'a, Tables<'gcx>> {\n+        self.tables.borrow()\n     }\n \n     /// Returns the type of `expr`, considering any `AutoAdjustment`\n@@ -2178,21 +2134,21 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// unless it was to fix it properly, which seemed a distraction from the\n     /// thread at hand! -nmatsakis\n     pub fn expr_ty_adjusted(self, expr: &hir::Expr) -> Ty<'gcx> {\n-        self.expr_ty(expr)\n+        self.tables().expr_ty(expr)\n             .adjust(self.global_tcx(), expr.span, expr.id,\n-                    self.tables.borrow().adjustments.get(&expr.id),\n+                    self.tables().adjustments.get(&expr.id),\n                     |method_call| {\n-            self.tables.borrow().method_map.get(&method_call).map(|method| method.ty)\n+            self.tables().method_map.get(&method_call).map(|method| method.ty)\n         })\n     }\n \n     pub fn expr_ty_adjusted_opt(self, expr: &hir::Expr) -> Option<Ty<'gcx>> {\n-        self.expr_ty_opt(expr).map(|t| t.adjust(self.global_tcx(),\n+        self.tables().expr_ty_opt(expr).map(|t| t.adjust(self.global_tcx(),\n                                                 expr.span,\n                                                 expr.id,\n-                                                self.tables.borrow().adjustments.get(&expr.id),\n+                                                self.tables().adjustments.get(&expr.id),\n                                                 |method_call| {\n-            self.tables.borrow().method_map.get(&method_call).map(|method| method.ty)\n+            self.tables().method_map.get(&method_call).map(|method| method.ty)\n         }))\n     }\n \n@@ -2908,19 +2864,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_region(ty::ReScope(self.region_maps.node_extent(id)))\n     }\n \n-    pub fn is_method_call(self, expr_id: NodeId) -> bool {\n-        self.tables.borrow().method_map.contains_key(&MethodCall::expr(expr_id))\n-    }\n-\n-    pub fn is_overloaded_autoderef(self, expr_id: NodeId, autoderefs: u32) -> bool {\n-        self.tables.borrow().method_map.contains_key(&MethodCall::autoderef(expr_id,\n-                                                                            autoderefs))\n-    }\n-\n-    pub fn upvar_capture(self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture<'tcx>> {\n-        Some(self.tables.borrow().upvar_capture_map.get(&upvar_id).unwrap().clone())\n-    }\n-\n     pub fn visit_all_items_in_krate<V,F>(self,\n                                          dep_node_fn: F,\n                                          visitor: &mut V)"}, {"sha": "51574868f9bfb5b72a2f8483f4356bef9539311b", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -37,7 +37,7 @@ pub fn gather_decl<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                              decl_id: ast::NodeId,\n                              _decl_span: Span,\n                              var_id: ast::NodeId) {\n-    let ty = bccx.tcx.node_id_to_type(var_id);\n+    let ty = bccx.tcx.tables().node_id_to_type(var_id);\n     let loan_path = Rc::new(LoanPath::new(LpVar(var_id), ty));\n     move_data.add_move(bccx.tcx, loan_path, decl_id, Declared);\n }"}, {"sha": "615aca90db8bfd86497836f4c94938f8243407f9", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -201,7 +201,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n \n             // Finally, check if the whole match expression is exhaustive.\n             // Check for empty enum, because is_useful only works on inhabited types.\n-            let pat_ty = self.tcx.node_id_to_type(scrut.id);\n+            let pat_ty = self.tcx.tables().node_id_to_type(scrut.id);\n             if inlined_arms.is_empty() {\n                 if !pat_ty.is_uninhabited(self.tcx) {\n                     // We know the type is inhabited, so this must be wrong\n@@ -262,7 +262,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n     pat.walk(|p| {\n         if let PatKind::Binding(hir::BindByValue(hir::MutImmutable), name, None) = p.node {\n-            let pat_ty = cx.tcx.pat_ty(p);\n+            let pat_ty = cx.tcx.tables().pat_ty(p);\n             if let ty::TyAdt(edef, _) = pat_ty.sty {\n                 if edef.is_enum() {\n                     if let Def::Local(..) = cx.tcx.expect_def(p.id) {\n@@ -486,7 +486,7 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n     for pat in pats {\n         pat.walk(|p| {\n             if let PatKind::Binding(hir::BindByValue(..), _, ref sub) = p.node {\n-                let pat_ty = cx.tcx.node_id_to_type(p.id);\n+                let pat_ty = cx.tcx.tables().node_id_to_type(p.id);\n                 if pat_ty.moves_by_default(cx.tcx, cx.param_env, pat.span) {\n                     check_move(p, sub.as_ref().map(|p| &**p));\n                 }"}, {"sha": "1f66d7140682681173c01f4b90c2c9192f5e59ed", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -246,7 +246,7 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    pat_id: ast::NodeId,\n                                    span: Span)\n                                    -> Result<P<hir::Pat>, DefId> {\n-    let pat_ty = tcx.expr_ty(expr);\n+    let pat_ty = tcx.tables().expr_ty(expr);\n     debug!(\"expr={:?} pat_ty={:?} pat_id={}\", expr, pat_ty, pat_id);\n     match pat_ty.sty {\n         ty::TyFloat(_) => {\n@@ -329,7 +329,8 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 Def::StructCtor(_, CtorKind::Const) |\n                 Def::VariantCtor(_, CtorKind::Const) => PatKind::Path(None, path.clone()),\n                 Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n-                    let substs = Some(tcx.node_id_item_substs(expr.id).substs);\n+                    let substs = Some(tcx.tables().node_id_item_substs(expr.id)\n+                        .unwrap_or_else(|| tcx.intern_substs(&[])));\n                     let (expr, _ty) = lookup_const_by_id(tcx, def_id, substs).unwrap();\n                     return const_expr_to_pat(tcx, expr, pat_id, span);\n                 },\n@@ -606,7 +607,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let ety = match ty_hint {\n         ExprTypeChecked => {\n             // After type-checking, expr_ty is guaranteed to succeed.\n-            Some(tcx.expr_ty(e))\n+            Some(tcx.tables().expr_ty(e))\n         }\n         UncheckedExprHint(ty) => {\n             // Use the type hint; it's not guaranteed to be right, but it's\n@@ -617,7 +618,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // This expression might not be type-checked, and we have no hint.\n             // Try to query the context for a type anyway; we might get lucky\n             // (for example, if the expression was imported from another crate).\n-            tcx.expr_ty_opt(e)\n+            tcx.tables().expr_ty_opt(e)\n         }\n     };\n     let result = match e.node {\n@@ -759,7 +760,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let base_hint = if let ExprTypeChecked = ty_hint {\n             ExprTypeChecked\n         } else {\n-            match tcx.expr_ty_opt(&base) {\n+            match tcx.tables().expr_ty_opt(&base) {\n                 Some(t) => UncheckedExprHint(t),\n                 None => ty_hint\n             }\n@@ -798,7 +799,8 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n               Def::Const(def_id) |\n               Def::AssociatedConst(def_id) => {\n                   let substs = if let ExprTypeChecked = ty_hint {\n-                      Some(tcx.node_id_item_substs(e.id).substs)\n+                      Some(tcx.tables().node_id_item_substs(e.id)\n+                        .unwrap_or_else(|| tcx.intern_substs(&[])))\n                   } else {\n                       None\n                   };"}, {"sha": "10b2a7625cacfefa1140ec965188e48d1cb7d516", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -128,7 +128,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn lower_pattern(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n-        let mut ty = self.tcx.node_id_to_type(pat.id);\n+        let mut ty = self.tcx.tables().node_id_to_type(pat.id);\n \n         let kind = match pat.node {\n             PatKind::Wild => PatternKind::Wild,\n@@ -167,8 +167,9 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 match self.tcx.expect_def(pat.id) {\n                     Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                         let tcx = self.tcx.global_tcx();\n-                        let substs = Some(self.tcx.node_id_item_substs(pat.id).substs);\n-                        match eval::lookup_const_by_id(tcx, def_id, substs) {\n+                        let substs = tcx.tables().node_id_item_substs(pat.id)\n+                            .unwrap_or_else(|| tcx.intern_substs(&[]));\n+                        match eval::lookup_const_by_id(tcx, def_id, Some(substs)) {\n                             Some((const_expr, _const_ty)) => {\n                                 match eval::const_expr_to_pat(\n                                     tcx, const_expr, pat.id, pat.span)\n@@ -197,7 +198,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             PatKind::Slice(ref prefix, ref slice, ref suffix) => {\n-                let ty = self.tcx.node_id_to_type(pat.id);\n+                let ty = self.tcx.tables().node_id_to_type(pat.id);\n                 match ty.sty {\n                     ty::TyRef(_, mt) =>\n                         PatternKind::Deref {\n@@ -222,7 +223,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             PatKind::Tuple(ref subpatterns, ddpos) => {\n-                match self.tcx.node_id_to_type(pat.id).sty {\n+                match self.tcx.tables().node_id_to_type(pat.id).sty {\n                     ty::TyTuple(ref tys) => {\n                         let subpatterns =\n                             subpatterns.iter()\n@@ -243,7 +244,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             PatKind::Binding(bm, ref ident, ref sub) => {\n                 let def_id = self.tcx.expect_def(pat.id).def_id();\n                 let id = self.tcx.map.as_local_node_id(def_id).unwrap();\n-                let var_ty = self.tcx.node_id_to_type(pat.id);\n+                let var_ty = self.tcx.tables().node_id_to_type(pat.id);\n                 let region = match var_ty.sty {\n                     ty::TyRef(r, _) => Some(r),\n                     _ => None,\n@@ -280,7 +281,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             PatKind::TupleStruct(_, ref subpatterns, ddpos) => {\n-                let pat_ty = self.tcx.node_id_to_type(pat.id);\n+                let pat_ty = self.tcx.tables().node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => span_bug!(pat.span, \"tuple struct pattern not applied to an ADT\"),\n@@ -299,7 +300,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             PatKind::Struct(_, ref fields, _) => {\n-                let pat_ty = self.tcx.node_id_to_type(pat.id);\n+                let pat_ty = self.tcx.tables().node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => {"}, {"sha": "8dee9b6ddd44d86830c3bfa98e19b223a13b34cd", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -501,7 +501,7 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n                 pp::space(&mut s.s)?;\n                 pp::word(&mut s.s, \"as\")?;\n                 pp::space(&mut s.s)?;\n-                pp::word(&mut s.s, &self.tcx.expr_ty(expr).to_string())?;\n+                pp::word(&mut s.s, &self.tcx.tables().expr_ty(expr).to_string())?;\n                 s.pclose()\n             }\n             _ => Ok(()),"}, {"sha": "6afcd18df0ad305e8587e3e9b511f954cee7daf8", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -118,7 +118,9 @@ impl LateLintPass for BoxPointers {\n             hir::ItemTy(..) |\n             hir::ItemEnum(..) |\n             hir::ItemStruct(..) |\n-            hir::ItemUnion(..) => self.check_heap_type(cx, it.span, cx.tcx.node_id_to_type(it.id)),\n+            hir::ItemUnion(..) => {\n+                self.check_heap_type(cx, it.span, cx.tcx.tables().node_id_to_type(it.id))\n+            }\n             _ => (),\n         }\n \n@@ -129,15 +131,15 @@ impl LateLintPass for BoxPointers {\n                 for struct_field in struct_def.fields() {\n                     self.check_heap_type(cx,\n                                          struct_field.span,\n-                                         cx.tcx.node_id_to_type(struct_field.id));\n+                                         cx.tcx.tables().node_id_to_type(struct_field.id));\n                 }\n             }\n             _ => (),\n         }\n     }\n \n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n-        let ty = cx.tcx.node_id_to_type(e.id);\n+        let ty = cx.tcx.tables().node_id_to_type(e.id);\n         self.check_heap_type(cx, e.span, ty);\n     }\n }\n@@ -585,7 +587,7 @@ impl LateLintPass for MissingDebugImplementations {\n             let mut impls = NodeSet();\n             debug_def.for_each_impl(cx.tcx, |d| {\n                 if let Some(n) = cx.tcx.map.as_local_node_id(d) {\n-                    if let Some(ty_def) = cx.tcx.node_id_to_type(n).ty_to_def_id() {\n+                    if let Some(ty_def) = cx.tcx.tables().node_id_to_type(n).ty_to_def_id() {\n                         if let Some(node_id) = cx.tcx.map.as_local_node_id(ty_def) {\n                             impls.insert(node_id);\n                         }\n@@ -940,23 +942,20 @@ impl LateLintPass for UnconditionalRecursion {\n                                                 id: ast::NodeId)\n                                                 -> bool {\n             // Check for method calls and overloaded operators.\n-            let opt_m = tcx.tables.borrow().method_map.get(&ty::MethodCall::expr(id)).cloned();\n+            let opt_m = tcx.tables().method_map.get(&ty::MethodCall::expr(id)).cloned();\n             if let Some(m) = opt_m {\n                 if method_call_refers_to_method(tcx, method, m.def_id, m.substs, id) {\n                     return true;\n                 }\n             }\n \n             // Check for overloaded autoderef method calls.\n-            let opt_adj = tcx.tables.borrow().adjustments.get(&id).cloned();\n+            let opt_adj = tcx.tables().adjustments.get(&id).cloned();\n             if let Some(adjustment::AdjustDerefRef(adj)) = opt_adj {\n                 for i in 0..adj.autoderefs {\n                     let method_call = ty::MethodCall::autoderef(id, i as u32);\n-                    if let Some(m) = tcx.tables\n-                        .borrow()\n-                        .method_map\n-                        .get(&method_call)\n-                        .cloned() {\n+                    if let Some(m) = tcx.tables().method_map.get(&method_call)\n+                                                            .cloned() {\n                         if method_call_refers_to_method(tcx, method, m.def_id, m.substs, id) {\n                             return true;\n                         }\n@@ -971,12 +970,10 @@ impl LateLintPass for UnconditionalRecursion {\n                     // it doesn't necessarily have a definition.\n                     match tcx.expect_def_or_none(callee.id) {\n                         Some(Def::Method(def_id)) => {\n-                            let item_substs = tcx.node_id_item_substs(callee.id);\n-                            method_call_refers_to_method(tcx,\n-                                                         method,\n-                                                         def_id,\n-                                                         &item_substs.substs,\n-                                                         id)\n+                            let substs = tcx.tables().node_id_item_substs(callee.id)\n+                                .unwrap_or_else(|| tcx.intern_substs(&[]));\n+                            method_call_refers_to_method(\n+                                tcx, method, def_id, substs, id)\n                         }\n                         _ => false,\n                     }\n@@ -1213,7 +1210,7 @@ impl LateLintPass for MutableTransmutes {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }\n-                let typ = cx.tcx.node_id_to_type(expr.id);\n+                let typ = cx.tcx.tables().node_id_to_type(expr.id);\n                 match typ.sty {\n                     ty::TyFnDef(.., ref bare_fn) if bare_fn.abi == RustIntrinsic => {\n                         let from = bare_fn.sig.0.inputs[0];\n@@ -1284,7 +1281,7 @@ impl LateLintPass for UnionsWithDropFields {\n         if let hir::ItemUnion(ref vdata, _) = item.node {\n             let param_env = &ty::ParameterEnvironment::for_item(ctx.tcx, item.id);\n             for field in vdata.fields() {\n-                let field_ty = ctx.tcx.node_id_to_type(field.id);\n+                let field_ty = ctx.tcx.tables().node_id_to_type(field.id);\n                 if ctx.tcx.type_needs_drop_given_env(field_ty, param_env) {\n                     ctx.span_lint(UNIONS_WITH_DROP_FIELDS,\n                                   field.span,"}, {"sha": "b04759955a956b8d3a43153d9b98b4b89a7da7a5", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -113,14 +113,14 @@ impl LateLintPass for TypeLimits {\n                             forbid_unsigned_negation(cx, e.span);\n                         }\n                         ast::LitKind::Int(_, ast::LitIntType::Unsuffixed) => {\n-                            if let ty::TyUint(_) = cx.tcx.node_id_to_type(e.id).sty {\n+                            if let ty::TyUint(_) = cx.tcx.tables().node_id_to_type(e.id).sty {\n                                 forbid_unsigned_negation(cx, e.span);\n                             }\n                         }\n                         _ => (),\n                     }\n                 } else {\n-                    let t = cx.tcx.node_id_to_type(expr.id);\n+                    let t = cx.tcx.tables().node_id_to_type(expr.id);\n                     if let ty::TyUint(_) = t.sty {\n                         forbid_unsigned_negation(cx, e.span);\n                     }\n@@ -138,7 +138,7 @@ impl LateLintPass for TypeLimits {\n                 }\n \n                 if binop.node.is_shift() {\n-                    let opt_ty_bits = match cx.tcx.node_id_to_type(l.id).sty {\n+                    let opt_ty_bits = match cx.tcx.tables().node_id_to_type(l.id).sty {\n                         ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n                         ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n                         _ => None,\n@@ -171,7 +171,7 @@ impl LateLintPass for TypeLimits {\n                 }\n             }\n             hir::ExprLit(ref lit) => {\n-                match cx.tcx.node_id_to_type(e.id).sty {\n+                match cx.tcx.tables().node_id_to_type(e.id).sty {\n                     ty::TyInt(t) => {\n                         match lit.node {\n                             ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n@@ -324,7 +324,7 @@ impl LateLintPass for TypeLimits {\n             // Normalize the binop so that the literal is always on the RHS in\n             // the comparison\n             let norm_binop = if swap { rev_binop(binop) } else { binop };\n-            match tcx.node_id_to_type(expr.id).sty {\n+            match tcx.tables().node_id_to_type(expr.id).sty {\n                 ty::TyInt(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i64 = match lit.node {\n@@ -740,7 +740,7 @@ impl LateLintPass for VariantSizeDifferences {\n         if let hir::ItemEnum(ref enum_definition, ref gens) = it.node {\n             if gens.ty_params.is_empty() {\n                 // sizes only make sense for non-generic types\n-                let t = cx.tcx.node_id_to_type(it.id);\n+                let t = cx.tcx.tables().node_id_to_type(it.id);\n                 let layout = cx.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n                     let ty = cx.tcx.erase_regions(&t);\n                     ty.layout(&infcx)"}, {"sha": "2df09aa25c8becb19f4845aefe5ca818499fb72f", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -140,7 +140,7 @@ impl LateLintPass for UnusedResults {\n             return;\n         }\n \n-        let t = cx.tcx.expr_ty(&expr);\n+        let t = cx.tcx.tables().expr_ty(&expr);\n         let warned = match t.sty {\n             ty::TyTuple(ref tys) if tys.is_empty() => return,\n             ty::TyNever => return,\n@@ -441,7 +441,7 @@ impl LateLintPass for UnusedAllocation {\n             _ => return,\n         }\n \n-        if let Some(adjustment) = cx.tcx.tables.borrow().adjustments.get(&e.id) {\n+        if let Some(adjustment) = cx.tcx.tables().adjustments.get(&e.id) {\n             if let adjustment::AdjustDerefRef(adjustment::AutoDerefRef { ref autoref, .. }) =\n                 *adjustment {\n                 match autoref {"}, {"sha": "63ec6a7069bb2955af5dcb2cb6b973aed3077fb5", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -94,9 +94,9 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for SideTableEncodingIdVisitor<'a, 'b, 'tcx>\n         };\n \n         encode(tcx.expect_def_or_none(id).map(TableEntry::Def));\n-        encode(tcx.node_types().get(&id).cloned().map(TableEntry::NodeType));\n-        encode(tcx.tables.borrow().item_substs.get(&id).cloned().map(TableEntry::ItemSubsts));\n-        encode(tcx.tables.borrow().adjustments.get(&id).cloned().map(TableEntry::Adjustment));\n+        encode(tcx.tables().node_types.get(&id).cloned().map(TableEntry::NodeType));\n+        encode(tcx.tables().item_substs.get(&id).cloned().map(TableEntry::ItemSubsts));\n+        encode(tcx.tables().adjustments.get(&id).cloned().map(TableEntry::Adjustment));\n         encode(tcx.const_qualif_map.borrow().get(&id).cloned().map(TableEntry::ConstQualif));\n     }\n }"}, {"sha": "fdb117ef81b13e731b638ad70e795466cdcdb0f6", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -1016,7 +1016,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let data = ClosureData {\n             kind: tcx.closure_kind(def_id),\n-            ty: self.lazy(&tcx.tables.borrow().closure_tys[&def_id]),\n+            ty: self.lazy(&tcx.tables().closure_tys[&def_id]),\n         };\n \n         Entry {"}, {"sha": "58526a3444e248139638d5b024e8a21e0084389a", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -191,7 +191,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     assert_eq!(block, builder.return_block());\n \n     let mut spread_arg = None;\n-    match tcx.node_id_to_type(fn_id).sty {\n+    match tcx.tables().node_id_to_type(fn_id).sty {\n         ty::TyFnDef(_, _, f) if f.abi == Abi::RustCall => {\n             // RustCall pseudo-ABI untuples the last argument.\n             spread_arg = Some(Local::new(arguments.len()));\n@@ -203,7 +203,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let upvar_decls: Vec<_> = tcx.with_freevars(fn_id, |freevars| {\n         freevars.iter().map(|fv| {\n             let var_id = tcx.map.as_local_node_id(fv.def.def_id()).unwrap();\n-            let by_ref = tcx.upvar_capture(ty::UpvarId {\n+            let by_ref = tcx.tables().upvar_capture(ty::UpvarId {\n                 var_id: var_id,\n                 closure_expr_id: fn_id\n             }).map_or(false, |capture| match capture {"}, {"sha": "cb69de2cb3cace0923c907f0218e471cc3010649", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -77,7 +77,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n pub fn to_expr_ref<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    block: &'tcx hir::Block)\n                                    -> ExprRef<'tcx> {\n-    let block_ty = cx.tcx.node_id_to_type(block.id);\n+    let block_ty = cx.tcx.tables().node_id_to_type(block.id);\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(block.id);\n     let expr = Expr {\n         ty: block_ty,"}, {"sha": "ddf487e9d7659197015937afa0d671b58e5ece8f", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 42, "deletions": 44, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -37,10 +37,10 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n         let mut expr = make_mirror_unadjusted(cx, self);\n \n         debug!(\"make_mirror: unadjusted-expr={:?} applying adjustments={:?}\",\n-               expr, cx.tcx.tables.borrow().adjustments.get(&self.id));\n+               expr, cx.tcx.tables().adjustments.get(&self.id));\n \n         // Now apply adjustments, if any.\n-        match cx.tcx.tables.borrow().adjustments.get(&self.id) {\n+        match cx.tcx.tables().adjustments.get(&self.id) {\n             None => {}\n             Some(&ty::adjustment::AdjustReifyFnPointer) => {\n                 let adjusted_ty = cx.tcx.expr_ty_adjusted(self);\n@@ -86,11 +86,11 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                             self.id,\n                             self.span,\n                             i,\n-                            |mc| cx.tcx.tables.borrow().method_map.get(&mc).map(|m| m.ty));\n+                            |mc| cx.tcx.tables().method_map.get(&mc).map(|m| m.ty));\n                     debug!(\"make_mirror: autoderef #{}, adjusted_ty={:?}\", i, adjusted_ty);\n                     let method_key = ty::MethodCall::autoderef(self.id, i);\n                     let meth_ty =\n-                        cx.tcx.tables.borrow().method_map.get(&method_key).map(|m| m.ty);\n+                        cx.tcx.tables().method_map.get(&method_key).map(|m| m.ty);\n                     let kind = if let Some(meth_ty) = meth_ty {\n                         debug!(\"make_mirror: overloaded autoderef (meth_ty={:?})\", meth_ty);\n \n@@ -212,7 +212,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                           expr: &'tcx hir::Expr)\n                                           -> Expr<'tcx> {\n-    let expr_ty = cx.tcx.expr_ty(expr);\n+    let expr_ty = cx.tcx.tables().expr_ty(expr);\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n \n     let kind = match expr.node {\n@@ -231,7 +231,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprCall(ref fun, ref args) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 // The callee is something implementing Fn, FnMut, or FnOnce.\n                 // Find the actual method implementation being called and\n                 // build the appropriate UFCS call expression with the\n@@ -282,7 +282,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     })\n                 } else { None };\n                 if let Some((adt_def, index)) = adt_data {\n-                    let substs = cx.tcx.node_id_item_substs(fun.id).substs;\n+                    let substs = cx.tcx.tables().node_id_item_substs(fun.id)\n+                        .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n                     let field_refs = args.iter().enumerate().map(|(idx, e)| FieldExprRef {\n                         name: Field::new(idx),\n                         expr: e.to_ref()\n@@ -296,7 +297,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     }\n                 } else {\n                     ExprKind::Call {\n-                        ty: cx.tcx.node_id_to_type(fun.id),\n+                        ty: cx.tcx.tables().node_id_to_type(fun.id),\n                         fun: fun.to_ref(),\n                         args: args.to_ref(),\n                     }\n@@ -328,7 +329,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 let pass_args = if op.node.is_by_value() {\n                     PassArgs::ByValue\n                 } else {\n@@ -350,7 +351,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         },\n \n         hir::ExprBinary(op, ref lhs, ref rhs) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 let pass_args = if op.node.is_by_value() {\n                     PassArgs::ByValue\n                 } else {\n@@ -406,7 +407,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprIndex(ref lhs, ref index) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 overloaded_lvalue(cx, expr, ty::MethodCall::expr(expr.id),\n                                   PassArgs::ByValue, lhs.to_ref(), vec![index])\n             } else {\n@@ -418,7 +419,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnDeref, ref arg) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 overloaded_lvalue(cx, expr, ty::MethodCall::expr(expr.id),\n                                   PassArgs::ByValue, arg.to_ref(), vec![])\n             } else {\n@@ -427,7 +428,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnNot, ref arg) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n                                     PassArgs::ByValue, arg.to_ref(), vec![])\n             } else {\n@@ -439,7 +440,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n                                     PassArgs::ByValue, arg.to_ref(), vec![])\n             } else {\n@@ -470,10 +471,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                             base: base.as_ref().map(|base| {\n                                 FruInfo {\n                                     base: base.to_ref(),\n-                                    field_types: cx.tcx.tables\n-                                        .borrow()\n-                                        .fru_field_types[&expr.id]\n-                                        .clone()\n+                                    field_types:\n+                                        cx.tcx.tables().fru_field_types[&expr.id].clone()\n                                 }\n                             })\n                         }\n@@ -512,7 +511,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprClosure(..) => {\n-            let closure_ty = cx.tcx.expr_ty(expr);\n+            let closure_ty = cx.tcx.tables().expr_ty(expr);\n             let (def_id, substs) = match closure_ty.sty {\n                 ty::TyClosure(def_id, substs) => (def_id, substs),\n                 _ => {\n@@ -551,7 +550,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprRepeat(ref v, ref c) => ExprKind::Repeat {\n             value: v.to_ref(),\n             count: TypedConstVal {\n-                ty: cx.tcx.expr_ty(c),\n+                ty: cx.tcx.tables().expr_ty(c),\n                 span: c.span,\n                 value: match const_eval::eval_const_expr(cx.tcx.global_tcx(), c) {\n                     ConstVal::Integral(ConstInt::Usize(u)) => u,\n@@ -631,8 +630,7 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                  expr: &hir::Expr,\n                                  method_call: ty::MethodCall)\n                                  -> Expr<'tcx> {\n-    let tables = cx.tcx.tables.borrow();\n-    let callee = &tables.method_map[&method_call];\n+    let callee = cx.tcx.tables().method_map[&method_call];\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n     Expr {\n         temp_lifetime: temp_lifetime,\n@@ -666,8 +664,8 @@ fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      expr: &'tcx hir::Expr)\n                                      -> ExprKind<'tcx> {\n-    let substs = cx.tcx.node_id_item_substs(expr.id).substs;\n-    // Otherwise there may be def_map borrow conflicts\n+    let substs = cx.tcx.tables().node_id_item_substs(expr.id)\n+        .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n     let def = cx.tcx.expect_def(expr.id);\n     let def_id = match def {\n         // A regular function, constructor function or a constant.\n@@ -677,18 +675,20 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Def::Const(def_id) | Def::AssociatedConst(def_id) => def_id,\n \n         Def::StructCtor(def_id, CtorKind::Const) |\n-        Def::VariantCtor(def_id, CtorKind::Const) => match cx.tcx.node_id_to_type(expr.id).sty {\n-            // A unit struct/variant which is used as a value.\n-            // We return a completely different ExprKind here to account for this special case.\n-            ty::TyAdt(adt_def, substs) => return ExprKind::Adt {\n-                adt_def: adt_def,\n-                variant_index: adt_def.variant_index_with_id(def_id),\n-                substs: substs,\n-                fields: vec![],\n-                base: None,\n-            },\n-            ref sty => bug!(\"unexpected sty: {:?}\", sty)\n-        },\n+        Def::VariantCtor(def_id, CtorKind::Const) => {\n+            match cx.tcx.tables().node_id_to_type(expr.id).sty {\n+                // A unit struct/variant which is used as a value.\n+                // We return a completely different ExprKind here to account for this special case.\n+                ty::TyAdt(adt_def, substs) => return ExprKind::Adt {\n+                    adt_def: adt_def,\n+                    variant_index: adt_def.variant_index_with_id(def_id),\n+                    substs: substs,\n+                    fields: vec![],\n+                    base: None,\n+                },\n+                ref sty => bug!(\"unexpected sty: {:?}\", sty)\n+            }\n+        }\n \n         Def::Static(node_id, _) => return ExprKind::StaticRef {\n             id: node_id,\n@@ -720,7 +720,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Def::Upvar(def_id, index, closure_expr_id) => {\n             let id_var = cx.tcx.map.as_local_node_id(def_id).unwrap();\n             debug!(\"convert_var(upvar({:?}, {:?}, {:?}))\", id_var, index, closure_expr_id);\n-            let var_ty = cx.tcx.node_id_to_type(id_var);\n+            let var_ty = cx.tcx.tables().node_id_to_type(id_var);\n \n             let body_id = match cx.tcx.map.find(closure_expr_id) {\n                 Some(map::NodeExpr(expr)) => {\n@@ -737,7 +737,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             };\n \n             // FIXME free regions in closures are not right\n-            let closure_ty = cx.tcx.node_id_to_type(closure_expr_id);\n+            let closure_ty = cx.tcx.tables().node_id_to_type(closure_expr_id);\n \n             // FIXME we're just hard-coding the idea that the\n             // signature will be &self or &mut self and hence will\n@@ -809,7 +809,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 var_id: id_var,\n                 closure_expr_id: closure_expr_id,\n             };\n-            let upvar_capture = match cx.tcx.upvar_capture(upvar_id) {\n+            let upvar_capture = match cx.tcx.tables().upvar_capture(upvar_id) {\n                 Some(c) => c,\n                 None => {\n                     span_bug!(\n@@ -931,9 +931,7 @@ fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     // line up (this is because `*x` and `x[y]` represent lvalues):\n \n     // to find the type &T of the content returned by the method;\n-    let tables = cx.tcx.tables.borrow();\n-    let callee = &tables.method_map[&method_call];\n-    let ref_ty = callee.ty.fn_ret();\n+    let ref_ty = cx.tcx.tables().method_map[&method_call].ty.fn_ret();\n     let ref_ty = cx.tcx.no_late_bound_regions(&ref_ty).unwrap();\n     // callees always have all late-bound regions fully instantiated,\n \n@@ -962,9 +960,9 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         var_id: id_var,\n         closure_expr_id: closure_expr.id,\n     };\n-    let upvar_capture = cx.tcx.upvar_capture(upvar_id).unwrap();\n+    let upvar_capture = cx.tcx.tables().upvar_capture(upvar_id).unwrap();\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(closure_expr.id);\n-    let var_ty = cx.tcx.node_id_to_type(id_var);\n+    let var_ty = cx.tcx.tables().node_id_to_type(id_var);\n     let captured_var = Expr {\n         temp_lifetime: temp_lifetime,\n         ty: var_ty,"}, {"sha": "0ffc59fe6bf45da6140208019e0e8419845ba63b", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -214,7 +214,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n                 id: ast::NodeId) {\n         // fetch the fully liberated fn signature (that is, all bound\n         // types/lifetimes replaced)\n-        let fn_sig = match self.tcx.tables.borrow().liberated_fn_sigs.get(&id) {\n+        let fn_sig = match self.tcx.tables().liberated_fn_sigs.get(&id) {\n             Some(f) => f.clone(),\n             None => {\n                 span_bug!(span, \"no liberated fn sig for {:?}\", id);\n@@ -248,7 +248,7 @@ fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              closure_expr_id: ast::NodeId,\n                              body_id: ast::NodeId)\n                              -> Ty<'tcx> {\n-    let closure_ty = tcx.node_id_to_type(closure_expr_id);\n+    let closure_ty = tcx.tables().node_id_to_type(closure_expr_id);\n \n     // We're just hard-coding the idea that the signature will be\n     // &self or &mut self and hence will have a bound region with"}, {"sha": "20e9e76ab843ddc4c45bc86eb74d2910eeddf10c", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -319,7 +319,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         let mut outer = self.qualif;\n         self.qualif = ConstQualif::empty();\n \n-        let node_ty = self.tcx.node_id_to_type(ex.id);\n+        let node_ty = self.tcx.tables().node_id_to_type(ex.id);\n         check_expr(self, ex, node_ty);\n         check_adjustments(self, ex);\n \n@@ -449,14 +449,14 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n     match e.node {\n         hir::ExprUnary(..) |\n         hir::ExprBinary(..) |\n-        hir::ExprIndex(..) if v.tcx.tables.borrow().method_map.contains_key(&method_call) => {\n+        hir::ExprIndex(..) if v.tcx.tables().method_map.contains_key(&method_call) => {\n             v.add_qualif(ConstQualif::NOT_CONST);\n         }\n         hir::ExprBox(_) => {\n             v.add_qualif(ConstQualif::NOT_CONST);\n         }\n         hir::ExprUnary(op, ref inner) => {\n-            match v.tcx.node_id_to_type(inner.id).sty {\n+            match v.tcx.tables().node_id_to_type(inner.id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op == hir::UnDeref);\n \n@@ -466,7 +466,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprBinary(op, ref lhs, _) => {\n-            match v.tcx.node_id_to_type(lhs.id).sty {\n+            match v.tcx.tables().node_id_to_type(lhs.id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op.node == hir::BiEq || op.node == hir::BiNe ||\n                             op.node == hir::BiLe || op.node == hir::BiLt ||\n@@ -503,7 +503,8 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n                     }\n                 }\n                 Def::Const(did) | Def::AssociatedConst(did) => {\n-                    let substs = Some(v.tcx.node_id_item_substs(e.id).substs);\n+                    let substs = Some(v.tcx.tables().node_id_item_substs(e.id)\n+                        .unwrap_or_else(|| v.tcx.intern_substs(&[])));\n                     if let Some((expr, _)) = lookup_const_by_id(v.tcx, did, substs) {\n                         let inner = v.global_expr(Mode::Const, expr);\n                         v.add_qualif(inner);\n@@ -555,7 +556,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprMethodCall(..) => {\n-            let method = v.tcx.tables.borrow().method_map[&method_call];\n+            let method = v.tcx.tables().method_map[&method_call];\n             let is_const = match v.tcx.impl_or_trait_item(method.def_id).container() {\n                 ty::ImplContainer(_) => v.handle_const_fn_call(e, method.def_id, node_ty),\n                 ty::TraitContainer(_) => false\n@@ -565,7 +566,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprStruct(..) => {\n-            if let ty::TyAdt(adt, ..) = v.tcx.expr_ty(e).sty {\n+            if let ty::TyAdt(adt, ..) = v.tcx.tables().expr_ty(e).sty {\n                 // unsafe_cell_type doesn't necessarily exist with no_core\n                 if Some(adt.did) == v.tcx.lang_items.unsafe_cell_type() {\n                     v.add_qualif(ConstQualif::MUTABLE_MEM);\n@@ -624,7 +625,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n \n /// Check the adjustments of an expression\n fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr) {\n-    match v.tcx.tables.borrow().adjustments.get(&e.id) {\n+    match v.tcx.tables().adjustments.get(&e.id) {\n         None |\n         Some(&ty::adjustment::AdjustNeverToAny(..)) |\n         Some(&ty::adjustment::AdjustReifyFnPointer) |\n@@ -633,7 +634,7 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n \n         Some(&ty::adjustment::AdjustDerefRef(ty::adjustment::AutoDerefRef { autoderefs, .. })) => {\n             if (0..autoderefs as u32)\n-                .any(|autoderef| v.tcx.is_overloaded_autoderef(e.id, autoderef)) {\n+                .any(|autoderef| v.tcx.tables().is_overloaded_autoderef(e.id, autoderef)) {\n                 v.add_qualif(ConstQualif::NOT_CONST);\n             }\n         }"}, {"sha": "8fdfecd4a586519f3fac992ea2e9445adf324206", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -430,11 +430,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                let method = self.tcx.tables.borrow().method_map[&method_call];\n+                let method = self.tcx.tables().method_map[&method_call];\n                 self.check_method(expr.span, method.def_id);\n             }\n             hir::ExprStruct(_, ref expr_fields, _) => {\n-                let adt = self.tcx.expr_ty(expr).ty_adt_def().unwrap();\n+                let adt = self.tcx.tables().expr_ty(expr).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(self.tcx.expect_def(expr.id));\n                 // RFC 736: ensure all unmentioned fields are visible.\n                 // Rather than computing the set of unmentioned fields\n@@ -495,14 +495,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n \n         match pattern.node {\n             PatKind::Struct(_, ref fields, _) => {\n-                let adt = self.tcx.pat_ty(pattern).ty_adt_def().unwrap();\n+                let adt = self.tcx.tables().pat_ty(pattern).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(self.tcx.expect_def(pattern.id));\n                 for field in fields {\n                     self.check_field(field.span, adt, variant.field_named(field.node.name));\n                 }\n             }\n             PatKind::TupleStruct(_, ref fields, ddpos) => {\n-                match self.tcx.pat_ty(pattern).sty {\n+                match self.tcx.tables().pat_ty(pattern).sty {\n                     // enum fields have no privacy at this time\n                     ty::TyAdt(def, _) if !def.is_enum() => {\n                         let expected_len = def.struct_variant().fields.len();"}, {"sha": "3a092613a054afdd27fee80a557741b9d05ec45e", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -356,7 +356,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             collector.visit_pat(&arg.pat);\n             let span_utils = self.span.clone();\n             for &(id, ref p, ..) in &collector.collected_paths {\n-                let typ = self.tcx.node_types().get(&id).unwrap().to_string();\n+                let typ = self.tcx.tables().node_types.get(&id).unwrap().to_string();\n                 // get the span only for the name of the variable (I hope the path is only ever a\n                 // variable name, but who knows?)\n                 let sub_span = span_utils.span_for_last_ident(p.span);\n@@ -988,7 +988,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         match p.node {\n             PatKind::Struct(ref path, ref fields, _) => {\n                 visit::walk_path(self, path);\n-                let adt = self.tcx.node_id_to_type(p.id).ty_adt_def().unwrap();\n+                let adt = self.tcx.tables().node_id_to_type(p.id).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(self.tcx.expect_def(p.id));\n \n                 for &Spanned { node: ref field, span } in fields {\n@@ -1023,8 +1023,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 ast::Mutability::Immutable => value.to_string(),\n                 _ => String::new(),\n             };\n-            let types = self.tcx.node_types();\n-            let typ = match types.get(&id) {\n+            let typ = match self.tcx.tables().node_types.get(&id) {\n                 Some(typ) => {\n                     let typ = typ.to_string();\n                     if !value.is_empty() {\n@@ -1355,7 +1354,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n             }\n             ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n                 let hir_expr = self.save_ctxt.tcx.map.expect_expr(ex.id);\n-                let adt = self.tcx.expr_ty(&hir_expr).ty_adt_def().unwrap();\n+                let adt = self.tcx.tables().expr_ty(&hir_expr).ty_adt_def().unwrap();\n                 let def = self.tcx.expect_def(hir_expr.id);\n                 self.process_struct_lit(ex, path, fields, adt.variant_of_def(def), base)\n             }\n@@ -1468,7 +1467,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                     } else {\n                         \"<mutable>\".to_string()\n                     };\n-                    let typ = self.tcx.node_types()\n+                    let typ = self.tcx.tables().node_types\n                                   .get(&id).map(|t| t.to_string()).unwrap_or(String::new());\n                     value.push_str(\": \");\n                     value.push_str(&typ);"}, {"sha": "c111824a30cb563b63b73f0fa9ea92054caf93ce", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -286,7 +286,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                           scope: NodeId) -> Option<VariableData> {\n         if let Some(ident) = field.ident {\n             let qualname = format!(\"::{}::{}\", self.tcx.node_path_str(scope), ident);\n-            let typ = self.tcx.node_types().get(&field.id).unwrap().to_string();\n+            let typ = self.tcx.tables().node_types.get(&field.id).unwrap().to_string();\n             let sub_span = self.span_utils.sub_span_before_token(field.span, token::Colon);\n             filter!(self.span_utils, sub_span, field.span, None);\n             Some(VariableData {\n@@ -472,7 +472,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n             ast::ExprKind::MethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                let method_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n+                let method_id = self.tcx.tables().method_map[&method_call].def_id;\n                 let (def_id, decl_id) = match self.tcx.impl_or_trait_item(method_id).container() {\n                     ty::ImplContainer(_) => (Some(method_id), None),\n                     ty::TraitContainer(_) => (None, Some(method_id)),"}, {"sha": "ffb13a833a582543e615fe7dba8e971f289e3590", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> Callee<'tcx> {\n     pub fn method_call<'blk>(bcx: Block<'blk, 'tcx>,\n                              method_call: ty::MethodCall)\n                              -> Callee<'tcx> {\n-        let method = bcx.tcx().tables.borrow().method_map[&method_call];\n+        let method = bcx.tcx().tables().method_map[&method_call];\n         Callee::method(bcx, method)\n     }\n "}, {"sha": "a439d415ede151f16e2f7e1418498e89b4f5a69f", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -1082,10 +1082,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n             hir::ItemStruct(_, ref generics) |\n             hir::ItemUnion(_, ref generics) => {\n                 if !generics.is_parameterized() {\n-                    let ty = {\n-                        let tables = self.scx.tcx().tables.borrow();\n-                        tables.node_types[&item.id]\n-                    };\n+                    let ty = self.scx.tcx().tables().node_types[&item.id];\n \n                     if self.mode == TransItemCollectionMode::Eager {\n                         debug!(\"RootCollector: ADT drop-glue for {}\","}, {"sha": "4bb34850e0870c0cce998ceb9a57acb54ac81dbf", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -1765,7 +1765,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     };\n \n     let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n-    let variable_type = tcx.erase_regions(&tcx.node_id_to_type(node_id));\n+    let variable_type = tcx.erase_regions(&tcx.tables().node_id_to_type(node_id));\n     let type_metadata = type_metadata(cx, variable_type, span);\n     let var_name = tcx.item_name(node_def_id).to_string();\n     let linkage_name = mangled_name_of_item(cx, node_def_id, \"\");"}, {"sha": "2db58ef066296cdfaea3b707f116e1da4c05a023", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -1551,7 +1551,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n                 tcx.prohibit_type_params(base_segments);\n                 let impl_id = tcx.map.as_local_node_id(def_id).unwrap();\n-                let ty = tcx.node_id_to_type(impl_id);\n+                let ty = tcx.tables().node_id_to_type(impl_id);\n                 if let Some(free_substs) = self.get_free_substs() {\n                     ty.subst(tcx, free_substs)\n                 } else {"}, {"sha": "3fec347b75b933b0681988335454066fc89dd1dc", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -773,7 +773,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n         check_union(ccx, it.id, it.span);\n       }\n       hir::ItemTy(_, ref generics) => {\n-        let pty_ty = ccx.tcx.node_id_to_type(it.id);\n+        let pty_ty = ccx.tcx.tables().node_id_to_type(it.id);\n         check_bounds_are_used(ccx, generics, pty_ty);\n       }\n       hir::ItemForeignMod(ref m) => {\n@@ -1188,7 +1188,7 @@ fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  sp: Span,\n                                  item_id: ast::NodeId)\n                                  -> bool {\n-    let rty = tcx.node_id_to_type(item_id);\n+    let rty = tcx.tables().node_id_to_type(item_id);\n \n     // Check that it is possible to represent this type. This call identifies\n     // (1) types that contain themselves and (2) types that contain a different\n@@ -1207,7 +1207,7 @@ fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, id: ast::NodeId) {\n-    let t = tcx.node_id_to_type(id);\n+    let t = tcx.tables().node_id_to_type(id);\n     match t.sty {\n         ty::TyAdt(def, substs) if def.is_struct() => {\n             let fields = &def.struct_variant().fields;"}, {"sha": "be1f2e35679d71e7ab191c5130a8fff33b87678a", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -416,7 +416,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                     }\n                 }\n                 None => {\n-                    let self_ty = fcx.tcx.node_id_to_type(item.id);\n+                    let self_ty = fcx.tcx.tables().node_id_to_type(item.id);\n                     let self_ty = fcx.instantiate_type_scheme(item.span, free_substs, &self_ty);\n                     fcx.register_wf_obligation(self_ty, ast_self_ty.span, this.code.clone());\n                 }\n@@ -519,7 +519,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                                      item: &hir::Item,\n                                      ast_generics: &hir::Generics)\n     {\n-        let ty = self.tcx().node_id_to_type(item.id);\n+        let ty = self.tcx().tables().node_id_to_type(item.id);\n         if self.tcx().has_error_field(ty) {\n             return;\n         }\n@@ -649,7 +649,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let fields =\n             struct_def.fields().iter()\n             .map(|field| {\n-                let field_ty = self.tcx.node_id_to_type(field.id);\n+                let field_ty = self.tcx.tables().node_id_to_type(field.id);\n                 let field_ty = self.instantiate_type_scheme(field.span,\n                                                             &self.parameter_environment\n                                                                  .free_substs,"}, {"sha": "688bcbdcd121c60de24b64cde5b14f24db711843", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -229,7 +229,7 @@ impl<'cx, 'gcx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'gcx, 'tcx> {\n         debug!(\"Type for pattern binding {} (id {}) resolved to {:?}\",\n                pat_to_string(p),\n                p.id,\n-               self.tcx().node_id_to_type(p.id));\n+               self.tcx().tables().node_id_to_type(p.id));\n \n         intravisit::walk_pat(self, p);\n     }"}, {"sha": "5a48b5f0e1fd12bd1d1b376f9563847ea8f9c32b", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8d131e5df60ba48c2382f9a3027b2c75c14e18/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "patch": "@@ -211,7 +211,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                     main_id: ast::NodeId,\n                     main_span: Span) {\n     let tcx = ccx.tcx;\n-    let main_t = tcx.node_id_to_type(main_id);\n+    let main_t = tcx.tables().node_id_to_type(main_id);\n     match main_t.sty {\n         ty::TyFnDef(..) => {\n             match tcx.map.find(main_id) {\n@@ -263,7 +263,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                      start_id: ast::NodeId,\n                      start_span: Span) {\n     let tcx = ccx.tcx;\n-    let start_t = tcx.node_id_to_type(start_id);\n+    let start_t = tcx.tables().node_id_to_type(start_id);\n     match start_t.sty {\n         ty::TyFnDef(..) => {\n             match tcx.map.find(start_id) {"}]}