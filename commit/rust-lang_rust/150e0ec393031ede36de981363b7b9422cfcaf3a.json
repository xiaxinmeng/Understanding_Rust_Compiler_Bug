{"sha": "150e0ec393031ede36de981363b7b9422cfcaf3a", "node_id": "C_kwDOAAsO6NoAKDE1MGUwZWMzOTMwMzFlZGUzNmRlOTgxMzYzYjdiOTQyMmNmY2FmM2E", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2022-11-10T15:47:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-10T15:47:38Z"}, "message": "Rollup merge of #104060 - ink-feather-org:const_hash, r=fee1-dead\n\nMake `Hash`, `Hasher` and `BuildHasher` `#[const_trait]` and make `Sip` const `Hasher`\n\nThis PR enables using Hashes in const context.\n\nr? ``@fee1-dead``", "tree": {"sha": "71e2d6ed9476cec96b1d22b8686e4a512385efc6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71e2d6ed9476cec96b1d22b8686e4a512385efc6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/150e0ec393031ede36de981363b7b9422cfcaf3a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjbR0aCRBK7hj4Ov3rIwAAKg0IAG9cBN6QCc84yvcP1WfB4w2v\nzF2sIEwsEaFfMgL8hgOn0lG5bdjAbL97i7FY5fwqRR1coPp2SQYBTFikFMjMftRu\nky/XwU+VxbcXqX7ANCuezFl2rhgIX/O67wlXu21wBD9HO4z/vGHzATMKupUXjpZv\ncl0Ddcd6LCsc6KNuafUyabv2tMIoAn+qkvVU4VdgXiHF991LY4u34LXqc7UHUJXX\n01K/+RazgTfnhrQ61F4i74q6uG0m59T+ab7KFeVe5Il4d3DP2x4Szm2b6DGkJGbI\nAHx6oXohH+NMsqhGCeBiG74Bmf//fY3JXkY6GEbwwPMz5YGBddY5/TFa7NJ77TU=\n=D3Os\n-----END PGP SIGNATURE-----\n", "payload": "tree 71e2d6ed9476cec96b1d22b8686e4a512385efc6\nparent 529f7149d2c3fbf5e8b24325331bf3ae6f393616\nparent 56e59bcb27943a1a520f2d59f41af1f1cd8b1c01\nauthor Manish Goregaokar <manishsmail@gmail.com> 1668095258 -0500\ncommitter GitHub <noreply@github.com> 1668095258 -0500\n\nRollup merge of #104060 - ink-feather-org:const_hash, r=fee1-dead\n\nMake `Hash`, `Hasher` and `BuildHasher` `#[const_trait]` and make `Sip` const `Hasher`\n\nThis PR enables using Hashes in const context.\n\nr? ``@fee1-dead``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/150e0ec393031ede36de981363b7b9422cfcaf3a", "html_url": "https://github.com/rust-lang/rust/commit/150e0ec393031ede36de981363b7b9422cfcaf3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/150e0ec393031ede36de981363b7b9422cfcaf3a/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "529f7149d2c3fbf5e8b24325331bf3ae6f393616", "url": "https://api.github.com/repos/rust-lang/rust/commits/529f7149d2c3fbf5e8b24325331bf3ae6f393616", "html_url": "https://github.com/rust-lang/rust/commit/529f7149d2c3fbf5e8b24325331bf3ae6f393616"}, {"sha": "56e59bcb27943a1a520f2d59f41af1f1cd8b1c01", "url": "https://api.github.com/repos/rust-lang/rust/commits/56e59bcb27943a1a520f2d59f41af1f1cd8b1c01", "html_url": "https://github.com/rust-lang/rust/commit/56e59bcb27943a1a520f2d59f41af1f1cd8b1c01"}], "stats": {"total": 184, "additions": 129, "deletions": 55}, "files": [{"sha": "c755afa39eb608de9ffffd576b0b4d5fa443b0f5", "filename": "library/core/src/hash/mod.rs", "status": "modified", "additions": 56, "deletions": 27, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/150e0ec393031ede36de981363b7b9422cfcaf3a/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150e0ec393031ede36de981363b7b9422cfcaf3a/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs?ref=150e0ec393031ede36de981363b7b9422cfcaf3a", "patch": "@@ -86,7 +86,8 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::fmt;\n-use crate::marker;\n+use crate::intrinsics::const_eval_select;\n+use crate::marker::{self, Destruct};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(deprecated)]\n@@ -183,6 +184,7 @@ mod sip;\n /// [impl]: ../../std/primitive.str.html#impl-Hash-for-str\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_diagnostic_item = \"Hash\"]\n+#[const_trait]\n pub trait Hash {\n     /// Feeds this value into the given [`Hasher`].\n     ///\n@@ -234,13 +236,25 @@ pub trait Hash {\n     /// [`hash`]: Hash::hash\n     /// [`hash_slice`]: Hash::hash_slice\n     #[stable(feature = \"hash_slice\", since = \"1.3.0\")]\n-    fn hash_slice<H: Hasher>(data: &[Self], state: &mut H)\n+    fn hash_slice<H: ~const Hasher>(data: &[Self], state: &mut H)\n     where\n         Self: Sized,\n     {\n-        for piece in data {\n-            piece.hash(state);\n+        //FIXME(const_trait_impl): revert to only a for loop\n+        fn rt<T: Hash, H: Hasher>(data: &[T], state: &mut H) {\n+            for piece in data {\n+                piece.hash(state)\n+            }\n+        }\n+        const fn ct<T: ~const Hash, H: ~const Hasher>(data: &[T], state: &mut H) {\n+            let mut i = 0;\n+            while i < data.len() {\n+                data[i].hash(state);\n+                i += 1;\n+            }\n         }\n+        // SAFETY: same behavior, CT just uses while instead of for\n+        unsafe { const_eval_select((data, state), ct, rt) };\n     }\n }\n \n@@ -313,6 +327,7 @@ pub use macros::Hash;\n /// [`write_u8`]: Hasher::write_u8\n /// [`write_u32`]: Hasher::write_u32\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[const_trait]\n pub trait Hasher {\n     /// Returns the hash value for the values written so far.\n     ///\n@@ -558,7 +573,8 @@ pub trait Hasher {\n }\n \n #[stable(feature = \"indirect_hasher_impl\", since = \"1.22.0\")]\n-impl<H: Hasher + ?Sized> Hasher for &mut H {\n+#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+impl<H: ~const Hasher + ?Sized> const Hasher for &mut H {\n     fn finish(&self) -> u64 {\n         (**self).finish()\n     }\n@@ -638,6 +654,7 @@ impl<H: Hasher + ?Sized> Hasher for &mut H {\n /// [`build_hasher`]: BuildHasher::build_hasher\n /// [`HashMap`]: ../../std/collections/struct.HashMap.html\n #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n+#[const_trait]\n pub trait BuildHasher {\n     /// Type of the hasher that will be created.\n     #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n@@ -698,9 +715,10 @@ pub trait BuildHasher {\n     /// );\n     /// ```\n     #[unstable(feature = \"build_hasher_simple_hash_one\", issue = \"86161\")]\n-    fn hash_one<T: Hash>(&self, x: T) -> u64\n+    fn hash_one<T: ~const Hash + ~const Destruct>(&self, x: T) -> u64\n     where\n         Self: Sized,\n+        Self::Hasher: ~const Hasher + ~const Destruct,\n     {\n         let mut hasher = self.build_hasher();\n         x.hash(&mut hasher);\n@@ -764,7 +782,8 @@ impl<H> fmt::Debug for BuildHasherDefault<H> {\n }\n \n #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n-impl<H: Default + Hasher> BuildHasher for BuildHasherDefault<H> {\n+#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+impl<H: ~const Default + Hasher> const BuildHasher for BuildHasherDefault<H> {\n     type Hasher = H;\n \n     fn build_hasher(&self) -> H {\n@@ -806,14 +825,15 @@ mod impls {\n     macro_rules! impl_write {\n         ($(($ty:ident, $meth:ident),)*) => {$(\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl Hash for $ty {\n+            #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+            impl const Hash for $ty {\n                 #[inline]\n-                fn hash<H: Hasher>(&self, state: &mut H) {\n+                fn hash<H: ~const Hasher>(&self, state: &mut H) {\n                     state.$meth(*self)\n                 }\n \n                 #[inline]\n-                fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {\n+                fn hash_slice<H: ~const Hasher>(data: &[$ty], state: &mut H) {\n                     let newlen = data.len() * mem::size_of::<$ty>();\n                     let ptr = data.as_ptr() as *const u8;\n                     // SAFETY: `ptr` is valid and aligned, as this macro is only used\n@@ -842,54 +862,60 @@ mod impls {\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl Hash for bool {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    impl const Hash for bool {\n         #[inline]\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n+        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n             state.write_u8(*self as u8)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl Hash for char {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    impl const Hash for char {\n         #[inline]\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n+        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n             state.write_u32(*self as u32)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl Hash for str {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    impl const Hash for str {\n         #[inline]\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n+        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n             state.write_str(self);\n         }\n     }\n \n     #[stable(feature = \"never_hash\", since = \"1.29.0\")]\n-    impl Hash for ! {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    impl const Hash for ! {\n         #[inline]\n-        fn hash<H: Hasher>(&self, _: &mut H) {\n+        fn hash<H: ~const Hasher>(&self, _: &mut H) {\n             *self\n         }\n     }\n \n     macro_rules! impl_hash_tuple {\n         () => (\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl Hash for () {\n+            #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+            impl const Hash for () {\n                 #[inline]\n-                fn hash<H: Hasher>(&self, _state: &mut H) {}\n+                fn hash<H: ~const Hasher>(&self, _state: &mut H) {}\n             }\n         );\n \n         ( $($name:ident)+) => (\n             maybe_tuple_doc! {\n                 $($name)+ @\n                 #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-                impl<$($name: Hash),+> Hash for ($($name,)+) where last_type!($($name,)+): ?Sized {\n+                #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+                impl<$($name: ~const Hash),+> const Hash for ($($name,)+) where last_type!($($name,)+): ?Sized {\n                     #[allow(non_snake_case)]\n                     #[inline]\n-                    fn hash<S: Hasher>(&self, state: &mut S) {\n+                    fn hash<S: ~const Hasher>(&self, state: &mut S) {\n                         let ($(ref $name,)+) = *self;\n                         $($name.hash(state);)+\n                     }\n@@ -932,24 +958,27 @@ mod impls {\n     impl_hash_tuple! { T B C D E F G H I J K L }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: Hash> Hash for [T] {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    impl<T: ~const Hash> const Hash for [T] {\n         #[inline]\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n+        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n             state.write_length_prefix(self.len());\n             Hash::hash_slice(self, state)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: ?Sized + Hash> Hash for &T {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    impl<T: ?Sized + ~const Hash> const Hash for &T {\n         #[inline]\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n+        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n             (**self).hash(state);\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: ?Sized + Hash> Hash for &mut T {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    impl<T: ?Sized + ~const Hash> const Hash for &mut T {\n         #[inline]\n         fn hash<H: Hasher>(&self, state: &mut H) {\n             (**self).hash(state);"}, {"sha": "7f8287bf56f645d40d4a3f4658641539d55bb765", "filename": "library/core/src/hash/sip.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/150e0ec393031ede36de981363b7b9422cfcaf3a/library%2Fcore%2Fsrc%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150e0ec393031ede36de981363b7b9422cfcaf3a/library%2Fcore%2Fsrc%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fsip.rs?ref=150e0ec393031ede36de981363b7b9422cfcaf3a", "patch": "@@ -118,7 +118,7 @@ macro_rules! load_int_le {\n /// Safety: this performs unchecked indexing of `buf` at `start..start+len`, so\n /// that must be in-bounds.\n #[inline]\n-unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n+const unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n     debug_assert!(len < 8);\n     let mut i = 0; // current byte index (from LSB) in the output u64\n     let mut out = 0;\n@@ -138,7 +138,8 @@ unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n         out |= (unsafe { *buf.get_unchecked(start + i) } as u64) << (i * 8);\n         i += 1;\n     }\n-    debug_assert_eq!(i, len);\n+    //FIXME(fee1-dead): use debug_assert_eq\n+    debug_assert!(i == len);\n     out\n }\n \n@@ -150,8 +151,9 @@ impl SipHasher {\n         since = \"1.13.0\",\n         note = \"use `std::collections::hash_map::DefaultHasher` instead\"\n     )]\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n     #[must_use]\n-    pub fn new() -> SipHasher {\n+    pub const fn new() -> SipHasher {\n         SipHasher::new_with_keys(0, 0)\n     }\n \n@@ -162,8 +164,9 @@ impl SipHasher {\n         since = \"1.13.0\",\n         note = \"use `std::collections::hash_map::DefaultHasher` instead\"\n     )]\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n     #[must_use]\n-    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n+    pub const fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n         SipHasher(SipHasher24 { hasher: Hasher::new_with_keys(key0, key1) })\n     }\n }\n@@ -176,7 +179,8 @@ impl SipHasher13 {\n         since = \"1.13.0\",\n         note = \"use `std::collections::hash_map::DefaultHasher` instead\"\n     )]\n-    pub fn new() -> SipHasher13 {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    pub const fn new() -> SipHasher13 {\n         SipHasher13::new_with_keys(0, 0)\n     }\n \n@@ -187,14 +191,15 @@ impl SipHasher13 {\n         since = \"1.13.0\",\n         note = \"use `std::collections::hash_map::DefaultHasher` instead\"\n     )]\n-    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher13 {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    pub const fn new_with_keys(key0: u64, key1: u64) -> SipHasher13 {\n         SipHasher13 { hasher: Hasher::new_with_keys(key0, key1) }\n     }\n }\n \n impl<S: Sip> Hasher<S> {\n     #[inline]\n-    fn new_with_keys(key0: u64, key1: u64) -> Hasher<S> {\n+    const fn new_with_keys(key0: u64, key1: u64) -> Hasher<S> {\n         let mut state = Hasher {\n             k0: key0,\n             k1: key1,\n@@ -209,7 +214,7 @@ impl<S: Sip> Hasher<S> {\n     }\n \n     #[inline]\n-    fn reset(&mut self) {\n+    const fn reset(&mut self) {\n         self.length = 0;\n         self.state.v0 = self.k0 ^ 0x736f6d6570736575;\n         self.state.v1 = self.k1 ^ 0x646f72616e646f6d;\n@@ -220,7 +225,8 @@ impl<S: Sip> Hasher<S> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl super::Hasher for SipHasher {\n+#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+impl const super::Hasher for SipHasher {\n     #[inline]\n     fn write(&mut self, msg: &[u8]) {\n         self.0.hasher.write(msg)\n@@ -238,7 +244,8 @@ impl super::Hasher for SipHasher {\n }\n \n #[unstable(feature = \"hashmap_internals\", issue = \"none\")]\n-impl super::Hasher for SipHasher13 {\n+#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+impl const super::Hasher for SipHasher13 {\n     #[inline]\n     fn write(&mut self, msg: &[u8]) {\n         self.hasher.write(msg)\n@@ -255,7 +262,7 @@ impl super::Hasher for SipHasher13 {\n     }\n }\n \n-impl<S: Sip> super::Hasher for Hasher<S> {\n+impl<S: ~const Sip> const super::Hasher for Hasher<S> {\n     // Note: no integer hashing methods (`write_u*`, `write_i*`) are defined\n     // for this type. We could add them, copy the `short_write` implementation\n     // in librustc_data_structures/sip128.rs, and add `write_u*`/`write_i*`\n@@ -335,7 +342,7 @@ impl<S: Sip> super::Hasher for Hasher<S> {\n     }\n }\n \n-impl<S: Sip> Clone for Hasher<S> {\n+impl<S: Sip> const Clone for Hasher<S> {\n     #[inline]\n     fn clone(&self) -> Hasher<S> {\n         Hasher {\n@@ -359,6 +366,7 @@ impl<S: Sip> Default for Hasher<S> {\n }\n \n #[doc(hidden)]\n+#[const_trait]\n trait Sip {\n     fn c_rounds(_: &mut State);\n     fn d_rounds(_: &mut State);\n@@ -367,7 +375,7 @@ trait Sip {\n #[derive(Debug, Clone, Default)]\n struct Sip13Rounds;\n \n-impl Sip for Sip13Rounds {\n+impl const Sip for Sip13Rounds {\n     #[inline]\n     fn c_rounds(state: &mut State) {\n         compress!(state);\n@@ -384,7 +392,7 @@ impl Sip for Sip13Rounds {\n #[derive(Debug, Clone, Default)]\n struct Sip24Rounds;\n \n-impl Sip for Sip24Rounds {\n+impl const Sip for Sip24Rounds {\n     #[inline]\n     fn c_rounds(state: &mut State) {\n         compress!(state);"}, {"sha": "5dc7427bee003c5cca37685b594f13babb3cc5de", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/150e0ec393031ede36de981363b7b9422cfcaf3a/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150e0ec393031ede36de981363b7b9422cfcaf3a/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=150e0ec393031ede36de981363b7b9422cfcaf3a", "patch": "@@ -112,6 +112,7 @@\n #![feature(const_float_bits_conv)]\n #![feature(const_float_classify)]\n #![feature(const_fmt_arguments_new)]\n+#![feature(const_hash)]\n #![feature(const_heap)]\n #![feature(const_convert)]\n #![feature(const_index_range_slice_index)]"}, {"sha": "267245f05dcd2203eb7c8d6a77d086c2c81f0720", "filename": "library/core/tests/hash/mod.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/150e0ec393031ede36de981363b7b9422cfcaf3a/library%2Fcore%2Ftests%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150e0ec393031ede36de981363b7b9422cfcaf3a/library%2Fcore%2Ftests%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fhash%2Fmod.rs?ref=150e0ec393031ede36de981363b7b9422cfcaf3a", "patch": "@@ -9,16 +9,19 @@ struct MyHasher {\n     hash: u64,\n }\n \n-impl Default for MyHasher {\n+impl const Default for MyHasher {\n     fn default() -> MyHasher {\n         MyHasher { hash: 0 }\n     }\n }\n \n-impl Hasher for MyHasher {\n+impl const Hasher for MyHasher {\n     fn write(&mut self, buf: &[u8]) {\n-        for byte in buf {\n-            self.hash += *byte as u64;\n+        // FIXME(const_trait_impl): change to for loop\n+        let mut i = 0;\n+        while i < buf.len() {\n+            self.hash += buf[i] as u64;\n+            i += 1;\n         }\n     }\n     fn write_str(&mut self, s: &str) {\n@@ -32,12 +35,25 @@ impl Hasher for MyHasher {\n \n #[test]\n fn test_writer_hasher() {\n-    fn hash<T: Hash>(t: &T) -> u64 {\n+    const fn hash<T: ~const Hash>(t: &T) -> u64 {\n         let mut s = MyHasher { hash: 0 };\n         t.hash(&mut s);\n         s.finish()\n     }\n \n+    const {\n+        // FIXME(fee1-dead): assert_eq\n+        assert!(hash(&()) == 0);\n+        assert!(hash(&5_u8) == 5);\n+        assert!(hash(&5_u16) == 5);\n+        assert!(hash(&5_u32) == 5);\n+\n+        assert!(hash(&'a') == 97);\n+\n+        let s: &str = \"a\";\n+        assert!(hash(&s) == 97 + 0xFF);\n+    };\n+\n     assert_eq!(hash(&()), 0);\n \n     assert_eq!(hash(&5_u8), 5);\n@@ -97,7 +113,7 @@ struct CustomHasher {\n     output: u64,\n }\n \n-impl Hasher for CustomHasher {\n+impl const Hasher for CustomHasher {\n     fn finish(&self) -> u64 {\n         self.output\n     }\n@@ -109,27 +125,29 @@ impl Hasher for CustomHasher {\n     }\n }\n \n-impl Default for CustomHasher {\n+impl const Default for CustomHasher {\n     fn default() -> CustomHasher {\n         CustomHasher { output: 0 }\n     }\n }\n \n-impl Hash for Custom {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n+impl const Hash for Custom {\n+    fn hash<H: ~const Hasher>(&self, state: &mut H) {\n         state.write_u64(self.hash);\n     }\n }\n \n #[test]\n fn test_custom_state() {\n-    fn hash<T: Hash>(t: &T) -> u64 {\n+    const fn hash<T: ~const Hash>(t: &T) -> u64 {\n         let mut c = CustomHasher { output: 0 };\n         t.hash(&mut c);\n         c.finish()\n     }\n \n     assert_eq!(hash(&Custom { hash: 5 }), 5);\n+\n+    const { assert!(hash(&Custom { hash: 6 }) == 6) };\n }\n \n // FIXME: Instantiated functions with i128 in the signature is not supported in Emscripten."}, {"sha": "3abf6efcfa9ba842d312f4bc4deb1a29a5b61d9b", "filename": "library/core/tests/hash/sip.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/150e0ec393031ede36de981363b7b9422cfcaf3a/library%2Fcore%2Ftests%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150e0ec393031ede36de981363b7b9422cfcaf3a/library%2Fcore%2Ftests%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fhash%2Fsip.rs?ref=150e0ec393031ede36de981363b7b9422cfcaf3a", "patch": "@@ -8,7 +8,6 @@ use core::{mem, slice};\n struct Bytes<'a>(&'a [u8]);\n \n impl<'a> Hash for Bytes<'a> {\n-    #[allow(unused_must_use)]\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         let Bytes(v) = *self;\n         state.write(v);\n@@ -24,6 +23,20 @@ fn hash<T: Hash>(x: &T) -> u64 {\n     hash_with(SipHasher::new(), x)\n }\n \n+#[test]\n+const fn test_const_sip() {\n+    let val1 = 0x45;\n+    let val2 = 0xfeed;\n+\n+    const fn const_hash<T: ~const Hash>(x: &T) -> u64 {\n+        let mut st = SipHasher::new();\n+        x.hash(&mut st);\n+        st.finish()\n+    }\n+\n+    assert!(const_hash(&(val1)) != const_hash(&(val2)));\n+}\n+\n #[test]\n #[allow(unused_must_use)]\n fn test_siphash_1_3() {"}, {"sha": "61d31b3448734349b7c5b06ba5bf68de895d18b3", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/150e0ec393031ede36de981363b7b9422cfcaf3a/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150e0ec393031ede36de981363b7b9422cfcaf3a/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=150e0ec393031ede36de981363b7b9422cfcaf3a", "patch": "@@ -11,6 +11,7 @@\n #![feature(const_caller_location)]\n #![feature(const_cell_into_inner)]\n #![feature(const_convert)]\n+#![feature(const_hash)]\n #![feature(const_heap)]\n #![feature(const_maybe_uninit_as_mut_ptr)]\n #![feature(const_maybe_uninit_assume_init_read)]"}, {"sha": "df490358827e7ae9c8fd777450dc776a19f66b10", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/150e0ec393031ede36de981363b7b9422cfcaf3a/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150e0ec393031ede36de981363b7b9422cfcaf3a/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=150e0ec393031ede36de981363b7b9422cfcaf3a", "patch": "@@ -3161,14 +3161,16 @@ impl DefaultHasher {\n     #[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n     #[inline]\n     #[allow(deprecated)]\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n     #[must_use]\n-    pub fn new() -> DefaultHasher {\n+    pub const fn new() -> DefaultHasher {\n         DefaultHasher(SipHasher13::new_with_keys(0, 0))\n     }\n }\n \n #[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n-impl Default for DefaultHasher {\n+#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+impl const Default for DefaultHasher {\n     /// Creates a new `DefaultHasher` using [`new`].\n     /// See its documentation for more.\n     ///\n@@ -3180,7 +3182,8 @@ impl Default for DefaultHasher {\n }\n \n #[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n-impl Hasher for DefaultHasher {\n+#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+impl const Hasher for DefaultHasher {\n     // The underlying `SipHasher13` doesn't override the other\n     // `write_*` methods, so it's ok not to forward them here.\n "}, {"sha": "9334c833bb6509c82e3fb2a4b3cfb55125740f33", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/150e0ec393031ede36de981363b7b9422cfcaf3a/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150e0ec393031ede36de981363b7b9422cfcaf3a/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=150e0ec393031ede36de981363b7b9422cfcaf3a", "patch": "@@ -352,6 +352,7 @@\n //\n // Only for const-ness:\n #![feature(const_collections_with_hasher)]\n+#![feature(const_hash)]\n #![feature(const_io_structs)]\n #![feature(const_ip)]\n #![feature(const_ipv4)]"}]}