{"sha": "3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhNWQyY2RiZjNhZmY5MWI1N2JjNmI3MGRkNDI5YWU1ZTc3MWQwNTQ=", "commit": {"author": {"name": "Tyler Bindon", "email": "martica@martica.org", "date": "2013-01-25T19:29:51Z"}, "committer": {"name": "Tyler Bindon", "email": "martica@martica.org", "date": "2013-01-26T02:42:23Z"}, "message": "Fix Option camel case in comments", "tree": {"sha": "dfbf800eac335b9f63b91d90f0132c56b18980e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfbf800eac335b9f63b91d90f0132c56b18980e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054", "html_url": "https://github.com/rust-lang/rust/commit/3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054/comments", "author": {"login": "martica", "id": 84769, "node_id": "MDQ6VXNlcjg0NzY5", "avatar_url": "https://avatars.githubusercontent.com/u/84769?v=4", "gravatar_id": "", "url": "https://api.github.com/users/martica", "html_url": "https://github.com/martica", "followers_url": "https://api.github.com/users/martica/followers", "following_url": "https://api.github.com/users/martica/following{/other_user}", "gists_url": "https://api.github.com/users/martica/gists{/gist_id}", "starred_url": "https://api.github.com/users/martica/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/martica/subscriptions", "organizations_url": "https://api.github.com/users/martica/orgs", "repos_url": "https://api.github.com/users/martica/repos", "events_url": "https://api.github.com/users/martica/events{/privacy}", "received_events_url": "https://api.github.com/users/martica/received_events", "type": "User", "site_admin": false}, "committer": {"login": "martica", "id": 84769, "node_id": "MDQ6VXNlcjg0NzY5", "avatar_url": "https://avatars.githubusercontent.com/u/84769?v=4", "gravatar_id": "", "url": "https://api.github.com/users/martica", "html_url": "https://github.com/martica", "followers_url": "https://api.github.com/users/martica/followers", "following_url": "https://api.github.com/users/martica/following{/other_user}", "gists_url": "https://api.github.com/users/martica/gists{/gist_id}", "starred_url": "https://api.github.com/users/martica/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/martica/subscriptions", "organizations_url": "https://api.github.com/users/martica/orgs", "repos_url": "https://api.github.com/users/martica/repos", "events_url": "https://api.github.com/users/martica/events{/privacy}", "received_events_url": "https://api.github.com/users/martica/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ff7489dc62bdcc0dbd507c52cba90d47cfdd129", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ff7489dc62bdcc0dbd507c52cba90d47cfdd129", "html_url": "https://github.com/rust-lang/rust/commit/7ff7489dc62bdcc0dbd507c52cba90d47cfdd129"}], "stats": {"total": 38, "additions": 19, "deletions": 19}, "files": [{"sha": "05a2572fdefe3d6eb514fc40af55d94dc807af97", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054", "patch": "@@ -149,7 +149,7 @@ pub pure fn chain_ref<T, U>(opt: &Option<T>,\n #[inline(always)]\n pub pure fn or<T>(opta: Option<T>, optb: Option<T>) -> Option<T> {\n     /*!\n-     * Returns the leftmost some() value, or none if both are none.\n+     * Returns the leftmost Some() value, or None if both are None.\n      */\n     match move opta {\n         Some(move opta) => Some(move opta),"}, {"sha": "35c1c96befae5264f67b49d0d87c3709e6eb3d30", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054", "patch": "@@ -114,10 +114,10 @@ variables from reassigned if there may be pointers to their interior)\n Finally, in some cases, both dangers can arise.  For example, something\n like the following:\n \n-    let mut x = ~some(5);\n+    let mut x = ~Some(5);\n     match x {\n-      ~some(ref y) => { ... }\n-      ~none => { ... }\n+      ~Some(ref y) => { ... }\n+      ~None => { ... }\n     }\n \n In this case, if `x` to be reassigned or `*x` were to be mutated, then"}, {"sha": "5916588a9a2bb772108faa63132fb37cb2429a6c", "filename": "src/librustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054", "patch": "@@ -226,8 +226,8 @@ priv impl &preserve_ctxt {\n             //\n             // As an example, consider this scenario:\n             //\n-            //    let mut x = @some(3);\n-            //    match *x { Some(y) {...} none {...} }\n+            //    let mut x = @Some(3);\n+            //    match *x { Some(y) {...} None {...} }\n             //\n             // Technically, the value `x` need only be rooted\n             // in the `some` arm.  However, we evaluate `x` in trans\n@@ -236,8 +236,8 @@ priv impl &preserve_ctxt {\n             //\n             // As a second example, consider *this* scenario:\n             //\n-            //    let x = @mut @some(3);\n-            //    match x { @@some(y) {...} @@none {...} }\n+            //    let x = @mut @Some(3);\n+            //    match x { @@Some(y) {...} @@None {...} }\n             //\n             // Here again, `x` need only be rooted in the `some` arm.\n             // In this case, the value which needs to be rooted is"}, {"sha": "6a62e622526d7bc5de24efbcc287203e2bb00c2e", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054", "patch": "@@ -100,8 +100,8 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n     // Replace any typedef'd types with their equivalent non-typedef\n     // type. This ensures that all LLVM nominal types that contain\n     // Rust types are defined as the same LLVM types.  If we don't do\n-    // this then, e.g. `option<{myfield: bool}>` would be a different\n-    // type than `option<myrec>`.\n+    // this then, e.g. `Option<{myfield: bool}>` would be a different\n+    // type than `Option<myrec>`.\n     let t_norm = ty::normalize_ty(cx.tcx, t);\n \n     if t != t_norm {"}, {"sha": "3e9a9756a81c6e0f0771946cc7a9b6fe16e1387c", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054", "patch": "@@ -468,7 +468,7 @@ fn read_future(sock: &TcpSocket, timeout_msecs: uint)\n  *     }\n  *     // this callback is ran when a new connection arrives\n  *     {|new_conn, kill_ch|\n- *     let cont_po = core::comm::port::<option<tcp_err_data>>();\n+ *     let cont_po = core::comm::port::<Option<tcp_err_data>>();\n  *     let cont_ch = core::comm::chan(cont_po);\n  *     task::spawn {||\n  *         let accept_result = net::tcp::accept(new_conn);\n@@ -484,9 +484,9 @@ fn read_future(sock: &TcpSocket, timeout_msecs: uint)\n  *     };\n  *     match core::comm::recv(cont_po) {\n  *       // shut down listen()\n- *       some(err_data) { core::comm::send(kill_chan, some(err_data)) }\n+ *       Some(err_data) { core::comm::send(kill_chan, Some(err_data)) }\n  *       // wait for next connection\n- *       none {}\n+ *       None {}\n  *     }\n  * };\n  * ~~~~~~~~~~~\n@@ -593,7 +593,7 @@ pub fn accept(new_conn: TcpNewConnection)\n  * callback's arguments are:\n  *     * `new_conn` - an opaque type that can be passed to\n  *     `net::tcp::accept` in order to be converted to a `tcp_socket`.\n- *     * `kill_ch` - channel of type `core::comm::chan<option<tcp_err_data>>`.\n+ *     * `kill_ch` - channel of type `core::comm::chan<Option<tcp_err_data>>`.\n  *     this channel can be used to send a message to cause `listen` to begin\n  *     closing the underlying libuv data structures.\n  *"}, {"sha": "ded0f316a150e9905db8eba8e1066210fc67c623", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054", "patch": "@@ -893,7 +893,7 @@ pub mod node {\n      * # Return value\n      *\n      * * `option::None` if no transformation happened\n-     * * `option::some(x)` otherwise, in which case `x` has the same contents\n+     * * `option::Some(x)` otherwise, in which case `x` has the same contents\n      *    as `node` bot lower height and/or fragmentation.\n      */\n     pub fn bal(node: @Node) -> Option<@Node> {"}, {"sha": "ce6231afa673daecf9c3df26c924d3c038f297f4", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=3a5d2cdbf3aff91b57bc6b70dd429ae5e771d054", "patch": "@@ -100,11 +100,11 @@ pub fn sleep(iotask: IoTask, msecs: uint) {\n }\n \n /**\n- * Receive on a port for (up to) a specified time, then return an `option<T>`\n+ * Receive on a port for (up to) a specified time, then return an `Option<T>`\n  *\n  * This call will block to receive on the provided port for up to the\n  * specified timeout. Depending on whether the provided port receives in that\n- * time period, `recv_timeout` will return an `option<T>` representing the\n+ * time period, `recv_timeout` will return an `Option<T>` representing the\n  * result.\n  *\n  * # Arguments\n@@ -115,9 +115,9 @@ pub fn sleep(iotask: IoTask, msecs: uint) {\n  *\n  * # Returns\n  *\n- * An `option<T>` representing the outcome of the call. If the call `recv`'d\n+ * An `Option<T>` representing the outcome of the call. If the call `recv`'d\n  * on the provided port in the allotted timeout period, then the result will\n- * be a `some(T)`. If not, then `none` will be returned.\n+ * be a `Some(T)`. If not, then `None` will be returned.\n  */\n pub fn recv_timeout<T: Copy Owned>(iotask: IoTask,\n                                    msecs: uint,"}]}