{"sha": "b25c063caa5e4ab8202527e3cfcfe04196e0836f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNWMwNjNjYWE1ZTRhYjgyMDI1MjdlM2NmY2ZlMDQxOTZlMDgzNmY=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-10T06:19:54Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-17T08:07:47Z"}, "message": "Refactor out `PerNS`.", "tree": {"sha": "a53190273a9185958212468c22c69d54264a8501", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a53190273a9185958212468c22c69d54264a8501"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b25c063caa5e4ab8202527e3cfcfe04196e0836f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b25c063caa5e4ab8202527e3cfcfe04196e0836f", "html_url": "https://github.com/rust-lang/rust/commit/b25c063caa5e4ab8202527e3cfcfe04196e0836f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b25c063caa5e4ab8202527e3cfcfe04196e0836f/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bbf7a43d3c9f35d7066c5382fa2db898c1e467a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bbf7a43d3c9f35d7066c5382fa2db898c1e467a", "html_url": "https://github.com/rust-lang/rust/commit/1bbf7a43d3c9f35d7066c5382fa2db898c1e467a"}], "stats": {"total": 364, "additions": 186, "deletions": 178}, "files": [{"sha": "5917a1a0d1759c50f558244ebe9652403f89c693", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b25c063caa5e4ab8202527e3cfcfe04196e0836f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25c063caa5e4ab8202527e3cfcfe04196e0836f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b25c063caa5e4ab8202527e3cfcfe04196e0836f", "patch": "@@ -15,7 +15,7 @@\n \n use macros::{InvocationData, LegacyScope};\n use resolve_imports::ImportDirective;\n-use resolve_imports::ImportDirectiveSubclass::{self, GlobImport};\n+use resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n use {Resolver, Module, ModuleS, ModuleKind, NameBinding, NameBindingKind, ToNameBinding};\n use Namespace::{self, TypeNS, ValueNS, MacroNS};\n use ResolveResult::Success;\n@@ -37,6 +37,7 @@ use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind};\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::ext::base::SyntaxExtension;\n+use syntax::ext::base::Determinacy::Undetermined;\n use syntax::ext::expand::mark_tts;\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n@@ -157,7 +158,11 @@ impl<'b> Resolver<'b> {\n                                 .emit();\n                         }\n \n-                        let subclass = ImportDirectiveSubclass::single(binding.name, source.name);\n+                        let subclass = SingleImport {\n+                            target: binding.name,\n+                            source: source.name,\n+                            result: self.per_ns(|_, _| Cell::new(Err(Undetermined))),\n+                        };\n                         self.add_import_directive(\n                             module_path, subclass, view_path.span, item.id, vis, expansion,\n                         );\n@@ -206,7 +211,11 @@ impl<'b> Resolver<'b> {\n                                     (module_path.to_vec(), name, rename)\n                                 }\n                             };\n-                            let subclass = ImportDirectiveSubclass::single(rename, name);\n+                            let subclass = SingleImport {\n+                                target: rename,\n+                                source: name,\n+                                result: self.per_ns(|_, _| Cell::new(Err(Undetermined))),\n+                            };\n                             let id = source_item.node.id;\n                             self.add_import_directive(\n                                 module_path, subclass, source_item.span, id, vis, expansion,"}, {"sha": "492c5e695bbbb5a39740dfa64f69fe4ccb351ebf", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b25c063caa5e4ab8202527e3cfcfe04196e0836f/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25c063caa5e4ab8202527e3cfcfe04196e0836f/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=b25c063caa5e4ab8202527e3cfcfe04196e0836f", "patch": "@@ -22,7 +22,6 @@\n use std::ops::{Deref, DerefMut};\n \n use Resolver;\n-use Namespace::{TypeNS, ValueNS};\n \n use rustc::lint;\n use rustc::util::nodemap::NodeMap;\n@@ -56,8 +55,9 @@ impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n     // We have information about whether `use` (import) directives are actually\n     // used now. If an import is not used at all, we signal a lint error.\n     fn check_import(&mut self, item_id: ast::NodeId, id: ast::NodeId, span: Span) {\n-        if !self.used_imports.contains(&(id, TypeNS)) &&\n-           !self.used_imports.contains(&(id, ValueNS)) {\n+        let mut used = false;\n+        self.per_ns(|this, ns| used |= this.used_imports.contains(&(id, ns)));\n+        if !used {\n             if self.maybe_unused_trait_imports.contains(&id) {\n                 // Check later.\n                 return;"}, {"sha": "af729770242535fea42ccd0c74e1ebf53ae11ce7", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 83, "deletions": 61, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/b25c063caa5e4ab8202527e3cfcfe04196e0836f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25c063caa5e4ab8202527e3cfcfe04196e0836f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b25c063caa5e4ab8202527e3cfcfe04196e0836f", "patch": "@@ -536,6 +536,33 @@ pub enum Namespace {\n     MacroNS,\n }\n \n+#[derive(Clone, Default, Debug)]\n+pub struct PerNS<T> {\n+    value_ns: T,\n+    type_ns: T,\n+}\n+\n+impl<T> ::std::ops::Index<Namespace> for PerNS<T> {\n+    type Output = T;\n+    fn index(&self, ns: Namespace) -> &T {\n+        match ns {\n+            ValueNS => &self.value_ns,\n+            TypeNS => &self.type_ns,\n+            MacroNS => unreachable!(),\n+        }\n+    }\n+}\n+\n+impl<T> ::std::ops::IndexMut<Namespace> for PerNS<T> {\n+    fn index_mut(&mut self, ns: Namespace) -> &mut T {\n+        match ns {\n+            ValueNS => &mut self.value_ns,\n+            TypeNS => &mut self.type_ns,\n+            MacroNS => unreachable!(),\n+        }\n+    }\n+}\n+\n impl<'a> Visitor for Resolver<'a> {\n     fn visit_item(&mut self, item: &Item) {\n         self.resolve_item(item);\n@@ -612,7 +639,7 @@ impl<'a> Visitor for Resolver<'a> {\n         };\n \n         // Create a value rib for the function.\n-        self.value_ribs.push(Rib::new(rib_kind));\n+        self.ribs[ValueNS].push(Rib::new(rib_kind));\n \n         // Create a label rib for the function.\n         self.label_ribs.push(Rib::new(rib_kind));\n@@ -642,7 +669,7 @@ impl<'a> Visitor for Resolver<'a> {\n         debug!(\"(resolving function) leaving function\");\n \n         self.label_ribs.pop();\n-        self.value_ribs.pop();\n+        self.ribs[ValueNS].pop();\n     }\n }\n \n@@ -1049,12 +1076,9 @@ pub struct Resolver<'a> {\n     // The module that represents the current item scope.\n     current_module: Module<'a>,\n \n-    // The current set of local scopes, for values.\n+    // The current set of local scopes for types and values.\n     // FIXME #4948: Reuse ribs to avoid allocation.\n-    value_ribs: Vec<Rib<'a>>,\n-\n-    // The current set of local scopes, for types.\n-    type_ribs: Vec<Rib<'a>>,\n+    ribs: PerNS<Vec<Rib<'a>>>,\n \n     // The current set of local scopes, for labels.\n     label_ribs: Vec<Rib<'a>>,\n@@ -1273,8 +1297,10 @@ impl<'a> Resolver<'a> {\n             indeterminate_imports: Vec::new(),\n \n             current_module: graph_root,\n-            value_ribs: vec![Rib::new(ModuleRibKind(graph_root))],\n-            type_ribs: vec![Rib::new(ModuleRibKind(graph_root))],\n+            ribs: PerNS {\n+                value_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n+                type_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n+            },\n             label_ribs: Vec::new(),\n \n             current_trait_ref: None,\n@@ -1335,6 +1361,13 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    fn per_ns<T, F: FnMut(&mut Self, Namespace) -> T>(&mut self, mut f: F) -> PerNS<T> {\n+        PerNS {\n+            type_ns: f(self, TypeNS),\n+            value_ns: f(self, ValueNS),\n+        }\n+    }\n+\n     /// Entry point to crate resolution.\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n         ImportResolver { resolver: self }.finalize_imports();\n@@ -1354,14 +1387,6 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n-    fn get_ribs<'b>(&'b mut self, ns: Namespace) -> &'b mut Vec<Rib<'a>> {\n-        match ns {\n-            ValueNS => &mut self.value_ribs,\n-            TypeNS => &mut self.type_ribs,\n-            MacroNS => panic!(\"The macro namespace has no ribs\"),\n-        }\n-    }\n-\n     fn record_use(&mut self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>, span: Span)\n                   -> bool /* true if an error was reported */ {\n         // track extern crates for unused_extern_crate lint\n@@ -1577,16 +1602,16 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Walk backwards up the ribs in scope.\n-        for i in (0 .. self.get_ribs(ns).len()).rev() {\n-            if let Some(def) = self.get_ribs(ns)[i].bindings.get(&ident).cloned() {\n+        for i in (0 .. self.ribs[ns].len()).rev() {\n+            if let Some(def) = self.ribs[ns][i].bindings.get(&ident).cloned() {\n                 // The ident resolves to a type parameter or local variable.\n                 return Some(LexicalScopeBinding::LocalDef(LocalDef {\n                     ribs: Some((ns, i)),\n                     def: def,\n                 }));\n             }\n \n-            if let ModuleRibKind(module) = self.get_ribs(ns)[i].kind {\n+            if let ModuleRibKind(module) = self.ribs[ns][i].kind {\n                 let name = ident.name;\n                 let item = self.resolve_name_in_module(module, name, ns, true, record_used);\n                 if let Success(binding) = item {\n@@ -1604,7 +1629,7 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n \n-            if let MacroDefinition(mac) = self.get_ribs(ns)[i].kind {\n+            if let MacroDefinition(mac) = self.ribs[ns][i].kind {\n                 // If an invocation of this macro created `ident`, give up on `ident`\n                 // and switch to `ident`'s source from the macro definition.\n                 let (source_ctxt, source_macro) = ident.ctxt.source();\n@@ -1689,14 +1714,14 @@ impl<'a> Resolver<'a> {\n         if let Some(module) = module {\n             // Move down in the graph.\n             let orig_module = replace(&mut self.current_module, module);\n-            self.value_ribs.push(Rib::new(ModuleRibKind(module)));\n-            self.type_ribs.push(Rib::new(ModuleRibKind(module)));\n+            self.ribs[ValueNS].push(Rib::new(ModuleRibKind(module)));\n+            self.ribs[TypeNS].push(Rib::new(ModuleRibKind(module)));\n \n             f(self);\n \n             self.current_module = orig_module;\n-            self.value_ribs.pop();\n-            self.type_ribs.pop();\n+            self.ribs[ValueNS].pop();\n+            self.ribs[TypeNS].pop();\n         } else {\n             f(self);\n         }\n@@ -1871,7 +1896,7 @@ impl<'a> Resolver<'a> {\n                     function_type_rib.bindings.insert(Ident::with_empty_ctxt(name), def);\n                     self.record_def(type_parameter.id, PathResolution::new(def));\n                 }\n-                self.type_ribs.push(function_type_rib);\n+                self.ribs[TypeNS].push(function_type_rib);\n             }\n \n             NoTypeParameters => {\n@@ -1882,7 +1907,7 @@ impl<'a> Resolver<'a> {\n         f(self);\n \n         if let HasTypeParameters(..) = type_parameters {\n-            self.type_ribs.pop();\n+            self.ribs[TypeNS].pop();\n         }\n     }\n \n@@ -1897,11 +1922,11 @@ impl<'a> Resolver<'a> {\n     fn with_constant_rib<F>(&mut self, f: F)\n         where F: FnOnce(&mut Resolver)\n     {\n-        self.value_ribs.push(Rib::new(ConstantItemRibKind));\n-        self.type_ribs.push(Rib::new(ConstantItemRibKind));\n+        self.ribs[ValueNS].push(Rib::new(ConstantItemRibKind));\n+        self.ribs[TypeNS].push(Rib::new(ConstantItemRibKind));\n         f(self);\n-        self.type_ribs.pop();\n-        self.value_ribs.pop();\n+        self.ribs[TypeNS].pop();\n+        self.ribs[ValueNS].pop();\n     }\n \n     fn resolve_trait_reference(&mut self,\n@@ -2011,9 +2036,9 @@ impl<'a> Resolver<'a> {\n \n         // plain insert (no renaming, types are not currently hygienic....)\n         self_type_rib.bindings.insert(keywords::SelfType.ident(), self_def);\n-        self.type_ribs.push(self_type_rib);\n+        self.ribs[TypeNS].push(self_type_rib);\n         f(self);\n-        self.type_ribs.pop();\n+        self.ribs[TypeNS].pop();\n     }\n \n     fn resolve_implementation(&mut self,\n@@ -2167,7 +2192,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_arm(&mut self, arm: &Arm) {\n-        self.value_ribs.push(Rib::new(NormalRibKind));\n+        self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n \n         let mut bindings_list = FxHashMap();\n         for pattern in &arm.pats {\n@@ -2181,7 +2206,7 @@ impl<'a> Resolver<'a> {\n         walk_list!(self, visit_expr, &arm.guard);\n         self.visit_expr(&arm.body);\n \n-        self.value_ribs.pop();\n+        self.ribs[ValueNS].pop();\n     }\n \n     fn resolve_block(&mut self, block: &Block) {\n@@ -2193,19 +2218,19 @@ impl<'a> Resolver<'a> {\n         let mut num_macro_definition_ribs = 0;\n         if let Some(anonymous_module) = anonymous_module {\n             debug!(\"(resolving block) found anonymous module, moving down\");\n-            self.value_ribs.push(Rib::new(ModuleRibKind(anonymous_module)));\n-            self.type_ribs.push(Rib::new(ModuleRibKind(anonymous_module)));\n+            self.ribs[ValueNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n+            self.ribs[TypeNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n             self.current_module = anonymous_module;\n         } else {\n-            self.value_ribs.push(Rib::new(NormalRibKind));\n+            self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n         }\n \n         // Descend into the block.\n         for stmt in &block.stmts {\n             if let Some(marks) = self.macros_at_scope.remove(&stmt.id) {\n                 num_macro_definition_ribs += marks.len() as u32;\n                 for mark in marks {\n-                    self.value_ribs.push(Rib::new(MacroDefinition(mark)));\n+                    self.ribs[ValueNS].push(Rib::new(MacroDefinition(mark)));\n                     self.label_ribs.push(Rib::new(MacroDefinition(mark)));\n                 }\n             }\n@@ -2216,12 +2241,12 @@ impl<'a> Resolver<'a> {\n         // Move back up.\n         self.current_module = orig_module;\n         for _ in 0 .. num_macro_definition_ribs {\n-            self.value_ribs.pop();\n+            self.ribs[ValueNS].pop();\n             self.label_ribs.pop();\n         }\n-        self.value_ribs.pop();\n+        self.ribs[ValueNS].pop();\n         if let Some(_) = anonymous_module {\n-            self.type_ribs.pop();\n+            self.ribs[TypeNS].pop();\n         }\n         debug!(\"(resolving block) leaving block\");\n     }\n@@ -2340,7 +2365,7 @@ impl<'a> Resolver<'a> {\n             Some(..) if pat_src == PatternSource::Match => {\n                 // `Variant1(a) | Variant2(a)`, ok\n                 // Reuse definition from the first `a`.\n-                def = self.value_ribs.last_mut().unwrap().bindings[&ident.node];\n+                def = self.ribs[ValueNS].last_mut().unwrap().bindings[&ident.node];\n             }\n             Some(..) => {\n                 span_bug!(ident.span, \"two bindings with the same name from \\\n@@ -2350,7 +2375,7 @@ impl<'a> Resolver<'a> {\n                 // A completely fresh binding, add to the lists if it's valid.\n                 if ident.node.name != keywords::Invalid.name() {\n                     bindings.insert(ident.node, outer_pat_id);\n-                    self.value_ribs.last_mut().unwrap().bindings.insert(ident.node, def);\n+                    self.ribs[ValueNS].last_mut().unwrap().bindings.insert(ident.node, def);\n                 }\n             }\n         }\n@@ -2634,9 +2659,8 @@ impl<'a> Resolver<'a> {\n     // Resolve a local definition, potentially adjusting for closures.\n     fn adjust_local_def(&mut self, local_def: LocalDef, span: Span) -> Option<Def> {\n         let ribs = match local_def.ribs {\n-            Some((TypeNS, i)) => &self.type_ribs[i + 1..],\n-            Some((ValueNS, i)) => &self.value_ribs[i + 1..],\n-            _ => &[] as &[_],\n+            Some((ns, i)) => &self.ribs[ns][i + 1..],\n+            None => &[] as &[_],\n         };\n         let mut def = local_def.def;\n         match def {\n@@ -2798,22 +2822,20 @@ impl<'a> Resolver<'a> {\n         where F: FnOnce(&mut Resolver<'a>) -> T,\n     {\n         self.with_empty_ribs(|this| {\n-            this.value_ribs.push(Rib::new(ModuleRibKind(module)));\n-            this.type_ribs.push(Rib::new(ModuleRibKind(module)));\n+            this.ribs[ValueNS].push(Rib::new(ModuleRibKind(module)));\n+            this.ribs[TypeNS].push(Rib::new(ModuleRibKind(module)));\n             f(this)\n         })\n     }\n \n     fn with_empty_ribs<T, F>(&mut self, f: F) -> T\n         where F: FnOnce(&mut Resolver<'a>) -> T,\n     {\n-        let value_ribs = replace(&mut self.value_ribs, Vec::new());\n-        let type_ribs = replace(&mut self.type_ribs, Vec::new());\n+        let ribs = replace(&mut self.ribs, PerNS::<Vec<Rib>>::default());\n         let label_ribs = replace(&mut self.label_ribs, Vec::new());\n \n         let result = f(self);\n-        self.value_ribs = value_ribs;\n-        self.type_ribs = type_ribs;\n+        self.ribs = ribs;\n         self.label_ribs = label_ribs;\n         result\n     }\n@@ -2865,7 +2887,7 @@ impl<'a> Resolver<'a> {\n             return SuggestionType::Macro(format!(\"{}!\", macro_name));\n         }\n \n-        let names = self.value_ribs\n+        let names = self.ribs[ValueNS]\n                     .iter()\n                     .rev()\n                     .flat_map(|rib| rib.bindings.keys().map(|ident| &ident.name));\n@@ -2968,7 +2990,7 @@ impl<'a> Resolver<'a> {\n                         } else {\n                             let mut method_scope = false;\n                             let mut is_static = false;\n-                            self.value_ribs.iter().rev().all(|rib| {\n+                            self.ribs[ValueNS].iter().rev().all(|rib| {\n                                 method_scope = match rib.kind {\n                                     MethodRibKind(is_static_) => {\n                                         is_static = is_static_;\n@@ -3079,10 +3101,10 @@ impl<'a> Resolver<'a> {\n             ExprKind::IfLet(ref pattern, ref subexpression, ref if_block, ref optional_else) => {\n                 self.visit_expr(subexpression);\n \n-                self.value_ribs.push(Rib::new(NormalRibKind));\n+                self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n                 self.resolve_pattern(pattern, PatternSource::IfLet, &mut FxHashMap());\n                 self.visit_block(if_block);\n-                self.value_ribs.pop();\n+                self.ribs[ValueNS].pop();\n \n                 optional_else.as_ref().map(|expr| self.visit_expr(expr));\n             }\n@@ -3096,22 +3118,22 @@ impl<'a> Resolver<'a> {\n \n             ExprKind::WhileLet(ref pattern, ref subexpression, ref block, label) => {\n                 self.visit_expr(subexpression);\n-                self.value_ribs.push(Rib::new(NormalRibKind));\n+                self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n                 self.resolve_pattern(pattern, PatternSource::WhileLet, &mut FxHashMap());\n \n                 self.resolve_labeled_block(label, expr.id, block);\n \n-                self.value_ribs.pop();\n+                self.ribs[ValueNS].pop();\n             }\n \n             ExprKind::ForLoop(ref pattern, ref subexpression, ref block, label) => {\n                 self.visit_expr(subexpression);\n-                self.value_ribs.push(Rib::new(NormalRibKind));\n+                self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n                 self.resolve_pattern(pattern, PatternSource::For, &mut FxHashMap());\n \n                 self.resolve_labeled_block(label, expr.id, block);\n \n-                self.value_ribs.pop();\n+                self.ribs[ValueNS].pop();\n             }\n \n             ExprKind::Field(ref subexpression, _) => {"}, {"sha": "f04f3bf45ee933c8611f909739b1b829f7653728", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 86, "deletions": 109, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/b25c063caa5e4ab8202527e3cfcfe04196e0836f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25c063caa5e4ab8202527e3cfcfe04196e0836f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=b25c063caa5e4ab8202527e3cfcfe04196e0836f", "patch": "@@ -10,8 +10,8 @@\n \n use self::ImportDirectiveSubclass::*;\n \n-use Module;\n-use Namespace::{self, TypeNS, ValueNS};\n+use {Module, PerNS};\n+use Namespace::{self, TypeNS};\n use {NameBinding, NameBindingKind, PrivacyError, ToNameBinding};\n use ResolveResult;\n use ResolveResult::*;\n@@ -39,8 +39,7 @@ pub enum ImportDirectiveSubclass<'a> {\n     SingleImport {\n         target: Name,\n         source: Name,\n-        value_result: Cell<Result<&'a NameBinding<'a>, Determinacy>>,\n-        type_result: Cell<Result<&'a NameBinding<'a>, Determinacy>>,\n+        result: PerNS<Cell<Result<&'a NameBinding<'a>, Determinacy>>>,\n     },\n     GlobImport {\n         is_prelude: bool,\n@@ -50,17 +49,6 @@ pub enum ImportDirectiveSubclass<'a> {\n     ExternCrate,\n }\n \n-impl<'a> ImportDirectiveSubclass<'a> {\n-    pub fn single(target: Name, source: Name) -> Self {\n-        SingleImport {\n-            target: target,\n-            source: source,\n-            type_result: Cell::new(Err(Undetermined)),\n-            value_result: Cell::new(Err(Undetermined)),\n-        }\n-    }\n-}\n-\n /// One import directive.\n #[derive(Debug,Clone)]\n pub struct ImportDirective<'a> {\n@@ -276,10 +264,10 @@ impl<'a> Resolver<'a> {\n         self.indeterminate_imports.push(directive);\n         match directive.subclass {\n             SingleImport { target, .. } => {\n-                for &ns in &[ValueNS, TypeNS] {\n-                    let mut resolution = self.resolution(current_module, target, ns).borrow_mut();\n+                self.per_ns(|this, ns| {\n+                    let mut resolution = this.resolution(current_module, target, ns).borrow_mut();\n                     resolution.single_imports.add_directive(directive);\n-                }\n+                });\n             }\n             // We don't add prelude imports to the globs since they only affect lexical scopes,\n             // which are not relevant to import resolution.\n@@ -397,6 +385,18 @@ impl<'a> Resolver<'a> {\n \n         t\n     }\n+\n+    // Define a \"dummy\" resolution containing a Def::Err as a placeholder for a\n+    // failed resolution\n+    fn import_dummy_binding(&mut self, directive: &'a ImportDirective<'a>) {\n+        if let SingleImport { target, .. } = directive.subclass {\n+            let dummy_binding = self.dummy_binding;\n+            let dummy_binding = self.import(dummy_binding, directive);\n+            self.per_ns(|this, ns| {\n+                let _ = this.try_define(directive.parent, target, ns, dummy_binding.clone());\n+            });\n+        }\n+    }\n }\n \n pub struct ImportResolver<'a, 'b: 'a> {\n@@ -481,17 +481,6 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         }\n     }\n \n-    // Define a \"dummy\" resolution containing a Def::Err as a placeholder for a\n-    // failed resolution\n-    fn import_dummy_binding(&mut self, directive: &'b ImportDirective<'b>) {\n-        if let SingleImport { target, .. } = directive.subclass {\n-            let dummy_binding = self.dummy_binding;\n-            let dummy_binding = self.import(dummy_binding, directive);\n-            let _ = self.try_define(directive.parent, target, ValueNS, dummy_binding.clone());\n-            let _ = self.try_define(directive.parent, target, TypeNS, dummy_binding);\n-        }\n-    }\n-\n     /// Attempts to resolve the given import. The return value indicates\n     /// failure if we're certain the name does not exist, indeterminate if we\n     /// don't know whether the name exists at the moment due to other\n@@ -523,9 +512,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         };\n \n         directive.imported_module.set(Some(module));\n-        let (source, target, value_result, type_result) = match directive.subclass {\n-            SingleImport { source, target, ref value_result, ref type_result } =>\n-                (source, target, value_result, type_result),\n+        let (source, target, result) = match directive.subclass {\n+            SingleImport { source, target, ref result } => (source, target, result),\n             GlobImport { .. } => {\n                 self.resolve_glob_import(directive);\n                 return Success(());\n@@ -534,46 +522,45 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         };\n \n         let mut indeterminate = false;\n-        for &(ns, result) in &[(ValueNS, value_result), (TypeNS, type_result)] {\n-            if let Err(Undetermined) = result.get() {\n-                result.set({\n-                    match self.resolve_name_in_module(module, source, ns, false, None) {\n+        self.per_ns(|this, ns| {\n+            if let Err(Undetermined) = result[ns].get() {\n+                result[ns].set({\n+                    match this.resolve_name_in_module(module, source, ns, false, None) {\n                         Success(binding) => Ok(binding),\n                         Indeterminate => Err(Undetermined),\n                         Failed(_) => Err(Determined),\n                     }\n                 });\n             } else {\n-                continue\n+                return\n             };\n \n-            match result.get() {\n+            match result[ns].get() {\n                 Err(Undetermined) => indeterminate = true,\n                 Err(Determined) => {\n-                    self.update_resolution(directive.parent, target, ns, |_, resolution| {\n+                    this.update_resolution(directive.parent, target, ns, |_, resolution| {\n                         resolution.single_imports.directive_failed()\n                     });\n                 }\n                 Ok(binding) if !binding.is_importable() => {\n                     let msg = format!(\"`{}` is not directly importable\", target);\n-                    struct_span_err!(self.session, directive.span, E0253, \"{}\", &msg)\n+                    struct_span_err!(this.session, directive.span, E0253, \"{}\", &msg)\n                         .span_label(directive.span, &format!(\"cannot be imported directly\"))\n                         .emit();\n                     // Do not import this illegal binding. Import a dummy binding and pretend\n                     // everything is fine\n-                    self.import_dummy_binding(directive);\n-                    return Success(());\n+                    this.import_dummy_binding(directive);\n                 }\n                 Ok(binding) => {\n-                    let imported_binding = self.import(binding, directive);\n-                    let conflict = self.try_define(directive.parent, target, ns, imported_binding);\n+                    let imported_binding = this.import(binding, directive);\n+                    let conflict = this.try_define(directive.parent, target, ns, imported_binding);\n                     if let Err(old_binding) = conflict {\n-                        let binding = &self.import(binding, directive);\n-                        self.report_conflict(directive.parent, target, ns, binding, old_binding);\n+                        let binding = &this.import(binding, directive);\n+                        this.report_conflict(directive.parent, target, ns, binding, old_binding);\n                     }\n                 }\n             }\n-        }\n+        });\n \n         if indeterminate { Indeterminate } else { Success(()) }\n     }\n@@ -601,9 +588,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             },\n         };\n \n-        let (name, value_result, type_result) = match directive.subclass {\n-            SingleImport { source, ref value_result, ref type_result, .. } =>\n-                (source, value_result.get(), type_result.get()),\n+        let (name, result) = match directive.subclass {\n+            SingleImport { source, ref result, .. } => (source, result),\n             GlobImport { .. } if module.def_id() == directive.parent.def_id() => {\n                 // Importing a module into itself is not allowed.\n                 let msg = \"Cannot glob-import a module into itself.\".into();\n@@ -621,21 +607,27 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             _ => unreachable!(),\n         };\n \n-        for &(ns, result) in &[(ValueNS, value_result), (TypeNS, type_result)] {\n-            if let Ok(binding) = result {\n-                if self.record_use(name, ns, binding, directive.span) {\n-                    self.resolution(module, name, ns).borrow_mut().binding =\n-                        Some(self.dummy_binding);\n+        let mut all_ns_err = true;\n+        self.per_ns(|this, ns| {\n+            if let Ok(binding) = result[ns].get() {\n+                all_ns_err = false;\n+                if this.record_use(name, ns, binding, directive.span) {\n+                    this.resolution(module, name, ns).borrow_mut().binding =\n+                        Some(this.dummy_binding);\n                 }\n             }\n-        }\n+        });\n \n-        if value_result.is_err() && type_result.is_err() {\n-            let (value_result, type_result);\n-            value_result = self.resolve_name_in_module(module, name, ValueNS, false, Some(span));\n-            type_result = self.resolve_name_in_module(module, name, TypeNS, false, Some(span));\n+        if all_ns_err {\n+            let mut all_ns_failed = true;\n+            self.per_ns(|this, ns| {\n+                match this.resolve_name_in_module(module, name, ns, false, Some(span)) {\n+                    Success(_) => all_ns_failed = false,\n+                    _ => {}\n+                }\n+            });\n \n-            return if let (Failed(_), Failed(_)) = (value_result, type_result) {\n+            return if all_ns_failed {\n                 let resolutions = module.resolutions.borrow();\n                 let names = resolutions.iter().filter_map(|(&(ref n, _), resolution)| {\n                     if *n == name { return None; } // Never suggest the same name\n@@ -663,64 +655,49 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             }\n         }\n \n-        let session = self.session;\n-        let reexport_error = || {\n-            let msg = format!(\"`{}` is private, and cannot be reexported\", name);\n-            let note_msg =\n-                format!(\"consider marking `{}` as `pub` in the imported module\", name);\n-            struct_span_err!(session, directive.span, E0364, \"{}\", &msg)\n-                .span_note(directive.span, &note_msg)\n-                .emit();\n-        };\n-\n-        let extern_crate_lint = || {\n-            let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n-                               (error E0364), consider declaring with `pub`\",\n-                               name);\n-            session.add_lint(PRIVATE_IN_PUBLIC, directive.id, directive.span, msg);\n-        };\n-\n-        match (value_result, type_result) {\n-            // All namespaces must be re-exported with extra visibility for an error to occur.\n-            (Ok(value_binding), Ok(type_binding)) => {\n+        let mut reexport_error = None;\n+        let mut any_successful_reexport = false;\n+        self.per_ns(|this, ns| {\n+            if let Ok(binding) = result[ns].get() {\n                 let vis = directive.vis.get();\n-                if !value_binding.pseudo_vis().is_at_least(vis, self) &&\n-                   !type_binding.pseudo_vis().is_at_least(vis, self) {\n-                    reexport_error();\n-                } else if type_binding.is_extern_crate() &&\n-                          !type_binding.vis.is_at_least(vis, self) {\n-                    extern_crate_lint();\n-                }\n-            }\n-\n-            (Ok(binding), _) if !binding.pseudo_vis().is_at_least(directive.vis.get(), self) => {\n-                reexport_error();\n-            }\n-\n-            (_, Ok(binding)) if !binding.pseudo_vis().is_at_least(directive.vis.get(), self) => {\n-                if binding.is_extern_crate() {\n-                    extern_crate_lint();\n+                if !binding.pseudo_vis().is_at_least(vis, this) {\n+                    reexport_error = Some((ns, binding));\n                 } else {\n-                    struct_span_err!(self.session, directive.span, E0365,\n-                                     \"`{}` is private, and cannot be reexported\", name)\n-                        .span_label(directive.span, &format!(\"reexport of private `{}`\", name))\n-                        .note(&format!(\"consider declaring type or module `{}` with `pub`\", name))\n-                        .emit();\n+                    any_successful_reexport = true;\n                 }\n             }\n+        });\n \n-            _ => {}\n+        // All namespaces must be re-exported with extra visibility for an error to occur.\n+        if !any_successful_reexport {\n+            let (ns, binding) = reexport_error.unwrap();\n+            if ns == TypeNS && binding.is_extern_crate() {\n+                let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n+                                   (error E0364), consider declaring with `pub`\",\n+                                   name);\n+                self.session.add_lint(PRIVATE_IN_PUBLIC, directive.id, directive.span, msg);\n+            } else if ns == TypeNS {\n+                struct_span_err!(self.session, directive.span, E0365,\n+                                 \"`{}` is private, and cannot be reexported\", name)\n+                    .span_label(directive.span, &format!(\"reexport of private `{}`\", name))\n+                    .note(&format!(\"consider declaring type or module `{}` with `pub`\", name))\n+                    .emit();\n+            } else {\n+                let msg = format!(\"`{}` is private, and cannot be reexported\", name);\n+                let note_msg =\n+                    format!(\"consider marking `{}` as `pub` in the imported module\", name);\n+                struct_span_err!(self.session, directive.span, E0364, \"{}\", &msg)\n+                    .span_note(directive.span, &note_msg)\n+                    .emit();\n+            }\n         }\n \n         // Record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n-        let def = match type_result.ok().map(NameBinding::def) {\n-            Some(def) => def,\n-            None => value_result.ok().map(NameBinding::def).unwrap(),\n-        };\n-        let path_resolution = PathResolution::new(def);\n-        self.def_map.insert(directive.id, path_resolution);\n+        self.per_ns(|this, ns| if let Some(binding) = result[ns].get().ok() {\n+            this.def_map.entry(directive.id).or_insert(PathResolution::new(binding.def()));\n+        });\n \n         debug!(\"(resolving single import) successfully resolved import\");\n         return Success(());"}, {"sha": "2d53aee39e95da6e829e75fb4873d7d2aef542ca", "filename": "src/test/compile-fail/blind-item-block-item-shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b25c063caa5e4ab8202527e3cfcfe04196e0836f/src%2Ftest%2Fcompile-fail%2Fblind-item-block-item-shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25c063caa5e4ab8202527e3cfcfe04196e0836f/src%2Ftest%2Fcompile-fail%2Fblind-item-block-item-shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblind-item-block-item-shadow.rs?ref=b25c063caa5e4ab8202527e3cfcfe04196e0836f", "patch": "@@ -14,6 +14,6 @@ fn main() {\n     {\n         struct Bar;\n         use foo::Bar;\n-        //~^ ERROR a value named `Bar` has already been defined in this block\n+        //~^ ERROR a type named `Bar` has already been defined in this block\n     }\n }"}, {"sha": "760612c05ce49443ffe7b76c6a815360023efec7", "filename": "src/test/compile-fail/double-type-import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b25c063caa5e4ab8202527e3cfcfe04196e0836f/src%2Ftest%2Fcompile-fail%2Fdouble-type-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25c063caa5e4ab8202527e3cfcfe04196e0836f/src%2Ftest%2Fcompile-fail%2Fdouble-type-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdouble-type-import.rs?ref=b25c063caa5e4ab8202527e3cfcfe04196e0836f", "patch": "@@ -11,7 +11,7 @@\n mod foo {\n     pub use self::bar::X;\n     use self::bar::X;\n-    //~^ ERROR a value named `X` has already been imported in this module\n+    //~^ ERROR a type named `X` has already been imported in this module\n \n     mod bar {\n         pub struct X;"}]}