{"sha": "a2572fe77efe58a7c202824deeb0b78fca89cf7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNTcyZmU3N2VmZTU4YTdjMjAyODI0ZGVlYjBiNzhmY2E4OWNmN2U=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-14T00:01:52Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-14T00:08:35Z"}, "message": "rustc: Eliminate metadata's dependency on trans", "tree": {"sha": "1b591568facb5d29d5655d29010df5582d2eac32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b591568facb5d29d5655d29010df5582d2eac32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2572fe77efe58a7c202824deeb0b78fca89cf7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2572fe77efe58a7c202824deeb0b78fca89cf7e", "html_url": "https://github.com/rust-lang/rust/commit/a2572fe77efe58a7c202824deeb0b78fca89cf7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2572fe77efe58a7c202824deeb0b78fca89cf7e/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecf290d448e1b46e073bd8727c04156a06948bf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecf290d448e1b46e073bd8727c04156a06948bf5", "html_url": "https://github.com/rust-lang/rust/commit/ecf290d448e1b46e073bd8727c04156a06948bf5"}], "stats": {"total": 191, "additions": 123, "deletions": 68}, "files": [{"sha": "c5e5cecbaf18861ceb874aa1fd2965a6fa88dc1e", "filename": "src/rustc/metadata.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a2572fe77efe58a7c202824deeb0b78fca89cf7e/src%2Frustc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2572fe77efe58a7c202824deeb0b78fca89cf7e/src%2Frustc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata.rs?ref=a2572fe77efe58a7c202824deeb0b78fca89cf7e", "patch": "@@ -1,3 +1,16 @@\n+export maps;\n+\n+// Auxiliary maps of things to be encoded\n+type maps = {\n+    mutbl_map: middle::borrowck::mutbl_map,\n+    copy_map: middle::alias::copy_map,\n+    last_uses: middle::last_use::last_uses,\n+    impl_map: middle::resolve::impl_map,\n+    method_map: middle::typeck::method_map,\n+    vtable_map: middle::typeck::vtable_map,\n+    spill_map: middle::last_use::spill_map\n+};\n+\n // Define the rustc API's that the metadata module has access to\n // Over time we will reduce these dependencies and, once metadata has\n // no dependencies on rustc it can move into its own crate.\n@@ -7,8 +20,6 @@ mod middle {\n     export ast_map;\n     import ty = middle_::ty;\n     export ty;\n-    import trans = middle_::trans;\n-    export trans;\n     import typeck = middle_::typeck;\n     export typeck;\n     import last_use = middle_::last_use;\n@@ -17,12 +28,18 @@ mod middle {\n     export freevars;\n     import resolve = middle_::resolve;\n     export resolve;\n+    import borrowck = middle_::borrowck;\n+    export borrowck;\n+    import alias = middle_::alias;\n+    export alias;\n }\n \n mod front {\n }\n \n mod back {\n+    import link = back_::link;\n+    export link;\n }\n \n mod driver {"}, {"sha": "ba64a6614ed958e088587ff059ce1759fd23989d", "filename": "src/rustc/metadata/astencode.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a2572fe77efe58a7c202824deeb0b78fca89cf7e/src%2Frustc%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2572fe77efe58a7c202824deeb0b78fca89cf7e/src%2Frustc%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode.rs?ref=a2572fe77efe58a7c202824deeb0b78fca89cf7e", "patch": "@@ -17,7 +17,6 @@ import std::serialization::serializer_helpers;\n import std::serialization::deserializer_helpers;\n import std::prettyprint::serializer;\n import std::smallintmap::map;\n-import middle::trans::common::maps;\n import middle::{ty, typeck, last_use, ast_map};\n import middle::typeck::{method_origin,\n                         serialize_method_origin,\n@@ -657,7 +656,7 @@ impl helpers for ebml::ebml_deserializer {\n impl helpers for @e::encode_ctxt {\n     fn ty_str_ctxt() -> @tyencode::ctxt {\n         @{ds: e::def_to_str,\n-          tcx: self.ccx.tcx,\n+          tcx: self.tcx,\n           reachable: encoder::reachable(self, _),\n           abbrevs: tyencode::ac_use_abbrevs(self.type_abbrevs)}\n     }\n@@ -721,8 +720,7 @@ fn encode_side_tables_for_ii(ecx: @e::encode_ctxt,\n fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n                              ebml_w: ebml::writer,\n                              id: ast::node_id) {\n-    let ccx = ecx.ccx;\n-    let tcx = ccx.tcx;\n+    let tcx = ecx.tcx;\n \n     #debug[\"Encoding side tables for id %d\", id];\n \n@@ -796,25 +794,25 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n     //    }\n     //}\n \n-    option::iter(ccx.maps.mutbl_map.find(id)) {|_m|\n+    option::iter(ecx.maps.mutbl_map.find(id)) {|_m|\n         ebml_w.tag(c::tag_table_mutbl) {||\n             ebml_w.id(id);\n         }\n     }\n \n-    option::iter(ccx.maps.copy_map.find(id)) {|_m|\n+    option::iter(ecx.maps.copy_map.find(id)) {|_m|\n         ebml_w.tag(c::tag_table_copy) {||\n             ebml_w.id(id);\n         }\n     }\n \n-    option::iter(ccx.maps.spill_map.find(id)) {|_m|\n+    option::iter(ecx.maps.spill_map.find(id)) {|_m|\n         ebml_w.tag(c::tag_table_spill) {||\n             ebml_w.id(id);\n         }\n     }\n \n-    option::iter(ccx.maps.last_uses.find(id)) {|m|\n+    option::iter(ecx.maps.last_uses.find(id)) {|m|\n         ebml_w.tag(c::tag_table_last_use) {||\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val) {||\n@@ -826,7 +824,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n     // impl_map is not used except when emitting metadata,\n     // don't need to keep it.\n \n-    option::iter(ccx.maps.method_map.find(id)) {|mo|\n+    option::iter(ecx.maps.method_map.find(id)) {|mo|\n         ebml_w.tag(c::tag_table_method_map) {||\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val) {||\n@@ -835,7 +833,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    option::iter(ccx.maps.vtable_map.find(id)) {|dr|\n+    option::iter(ecx.maps.vtable_map.find(id)) {|dr|\n         ebml_w.tag(c::tag_table_vtable_map) {||\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val) {||"}, {"sha": "42331973baae4f3b4a4fe65e7ffc8637c7cecca1", "filename": "src/rustc/metadata/common.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2572fe77efe58a7c202824deeb0b78fca89cf7e/src%2Frustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2572fe77efe58a7c202824deeb0b78fca89cf7e/src%2Frustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcommon.rs?ref=a2572fe77efe58a7c202824deeb0b78fca89cf7e", "patch": "@@ -131,4 +131,3 @@ fn hash_path(&&s: str) -> uint {\n     for str::each(s) {|ch| h = (h << 5u) + h ^ (ch as uint); }\n     ret h;\n }\n-"}, {"sha": "e691f09221f6a6c49881be8f23fa46fa391fbe14", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2572fe77efe58a7c202824deeb0b78fca89cf7e/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2572fe77efe58a7c202824deeb0b78fca89cf7e/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=a2572fe77efe58a7c202824deeb0b78fca89cf7e", "patch": "@@ -7,7 +7,6 @@ import middle::{ty, ast_map};\n import option::{some, none};\n import driver::session;\n import driver::session::expect;\n-import middle::trans::common::maps;\n import common::*;\n import std::map::hashmap;\n "}, {"sha": "f634c3b6639f9f81e03958cba03541144ea7be55", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2572fe77efe58a7c202824deeb0b78fca89cf7e/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2572fe77efe58a7c202824deeb0b78fca89cf7e/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=a2572fe77efe58a7c202824deeb0b78fca89cf7e", "patch": "@@ -13,7 +13,6 @@ import tydecode::{parse_ty_data, parse_def_id, parse_bounds_data,\n         parse_ident};\n import syntax::print::pprust;\n import cmd=cstore::crate_metadata;\n-import middle::trans::common::maps;\n import util::ppaux::ty_to_str;\n import ebml::deserializer;\n "}, {"sha": "7c2618290848efdd84963194689d5257d44c74bb", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 69, "deletions": 37, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/a2572fe77efe58a7c202824deeb0b78fca89cf7e/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2572fe77efe58a7c202824deeb0b78fca89cf7e/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=a2572fe77efe58a7c202824deeb0b78fca89cf7e", "patch": "@@ -11,15 +11,17 @@ import syntax::print::pprust;\n import syntax::{ast_util, visit};\n import syntax::ast_util::local_def;\n import common::*;\n-import middle::trans::common::crate_ctxt;\n import middle::ty;\n import middle::ty::node_id_to_type;\n import middle::ast_map;\n import syntax::attr;\n-import driver::session::session;\n import std::serialization::serializer;\n import std::ebml::serializer;\n+import middle::resolve;\n+import syntax::ast;\n+import driver::session::session;\n \n+export encode_parms;\n export encode_metadata;\n export encoded_ty;\n export reachable;\n@@ -32,11 +34,31 @@ export encode_def_id;\n \n type abbrev_map = map::hashmap<ty::t, tyencode::ty_abbrev>;\n \n-type encode_ctxt = {ccx: @crate_ctxt,\n-                    type_abbrevs: abbrev_map};\n+type encode_parms = {\n+    tcx: ty::ctxt,\n+    reachable: hashmap<ast::node_id, ()>,\n+    exp_map: resolve::exp_map,\n+    item_symbols: hashmap<ast::node_id, str>,\n+    discrim_symbols: hashmap<ast::node_id, str>,\n+    link_meta: back::link::link_meta,\n+    cstore: cstore::cstore,\n+    maps: maps\n+};\n+\n+type encode_ctxt = {\n+    tcx: ty::ctxt,\n+    reachable: hashmap<ast::node_id, ()>,\n+    exp_map: resolve::exp_map,\n+    item_symbols: hashmap<ast::node_id, str>,\n+    discrim_symbols: hashmap<ast::node_id, str>,\n+    link_meta: back::link::link_meta,\n+    cstore: cstore::cstore,\n+    maps: maps,\n+    type_abbrevs: abbrev_map\n+};\n \n fn reachable(ecx: @encode_ctxt, id: node_id) -> bool {\n-    ecx.ccx.reachable.contains_key(id)\n+    ecx.reachable.contains_key(id)\n }\n \n // Path table encoding\n@@ -201,7 +223,7 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n \n fn encode_iface_ref(ebml_w: ebml::writer, ecx: @encode_ctxt, t: @iface_ref) {\n     ebml_w.start_tag(tag_impl_iface);\n-    encode_type(ecx, ebml_w, node_id_to_type(ecx.ccx.tcx, t.id));\n+    encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, t.id));\n     ebml_w.end_tag();\n }\n \n@@ -218,8 +240,8 @@ fn encode_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt, crate: @crate)\n \n fn encode_reexport_paths(ebml_w: ebml::writer,\n                          ecx: @encode_ctxt, &index: [entry<str>]) {\n-    let tcx = ecx.ccx.tcx;\n-    for ecx.ccx.exp_map.each {|exp_id, defs|\n+    let tcx = ecx.tcx;\n+    for ecx.exp_map.each {|exp_id, defs|\n         for defs.each {|def|\n             if !def.reexp { cont; }\n             let path = alt check tcx.items.get(exp_id) {\n@@ -247,12 +269,12 @@ fn def_to_str(did: def_id) -> str { ret #fmt[\"%d:%d\", did.crate, did.node]; }\n fn encode_type_param_bounds(ebml_w: ebml::writer, ecx: @encode_ctxt,\n                             params: [ty_param]) {\n     let ty_str_ctxt = @{ds: def_to_str,\n-                        tcx: ecx.ccx.tcx,\n+                        tcx: ecx.tcx,\n                         reachable: reachable(ecx, _),\n                         abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     for params.each {|param|\n         ebml_w.start_tag(tag_items_data_item_ty_param_bounds);\n-        let bs = ecx.ccx.tcx.ty_param_bounds.get(param.id);\n+        let bs = ecx.tcx.ty_param_bounds.get(param.id);\n         tyencode::enc_bounds(ebml_w.writer, ty_str_ctxt, bs);\n         ebml_w.end_tag();\n     }\n@@ -267,7 +289,7 @@ fn encode_variant_id(ebml_w: ebml::writer, vid: def_id) {\n fn write_type(ecx: @encode_ctxt, ebml_w: ebml::writer, typ: ty::t) {\n     let ty_str_ctxt =\n         @{ds: def_to_str,\n-          tcx: ecx.ccx.tcx,\n+          tcx: ecx.tcx,\n           reachable: reachable(ecx, _),\n           abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n@@ -281,9 +303,9 @@ fn encode_type(ecx: @encode_ctxt, ebml_w: ebml::writer, typ: ty::t) {\n \n fn encode_symbol(ecx: @encode_ctxt, ebml_w: ebml::writer, id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n-    let sym = alt ecx.ccx.item_symbols.find(id) {\n+    let sym = alt ecx.item_symbols.find(id) {\n       some(x) { x }\n-      none { ecx.ccx.tcx.sess.bug(#fmt(\"encode_symbol: \\\n+      none { ecx.tcx.sess.bug(#fmt(\"encode_symbol: \\\n                     id not found %d\", id)); }\n     };\n     ebml_w.writer.write(str::bytes(sym));\n@@ -292,7 +314,7 @@ fn encode_symbol(ecx: @encode_ctxt, ebml_w: ebml::writer, id: node_id) {\n \n fn encode_discriminant(ecx: @encode_ctxt, ebml_w: ebml::writer, id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n-    ebml_w.writer.write(str::bytes(ecx.ccx.discrim_symbols.get(id)));\n+    ebml_w.writer.write(str::bytes(ecx.discrim_symbols.get(id)));\n     ebml_w.end_tag();\n }\n \n@@ -314,7 +336,7 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                             ty_params: [ty_param]) {\n     let mut disr_val = 0;\n     let mut i = 0;\n-    let vi = ty::enum_variants(ecx.ccx.tcx, {crate: local_crate, node: id});\n+    let vi = ty::enum_variants(ecx.tcx, {crate: local_crate, node: id});\n     for variants.each {|variant|\n         *index += [{val: variant.node.id, pos: ebml_w.writer.tell()}];\n         ebml_w.start_tag(tag_items_data_item);\n@@ -323,7 +345,7 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         encode_name(ebml_w, variant.node.name);\n         encode_parent_item(ebml_w, local_def(id));\n         encode_type(ecx, ebml_w,\n-                    node_id_to_type(ecx.ccx.tcx, variant.node.id));\n+                    node_id_to_type(ecx.tcx, variant.node.id));\n         if vec::len(variant.node.args) > 0u && ty_params.len() == 0u {\n             encode_symbol(ecx, ebml_w, variant.node.id);\n         }\n@@ -365,22 +387,22 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n     encode_def_id(ebml_w, local_def(id));\n     encode_family(ebml_w, 'm');\n     encode_name(ebml_w, name);\n-    alt ecx.ccx.maps.impl_map.get(id) {\n+    alt ecx.maps.impl_map.get(id) {\n       list::cons(impls, @list::nil) {\n         for vec::each(*impls) {|i|\n             if ast_util::is_exported(i.ident, md) {\n                 ebml_w.start_tag(tag_mod_impl);\n             /* If did stands for an iface\n                ref, we need to map it to its parent class */\n-                alt ecx.ccx.tcx.items.get(i.did.node) {\n+                alt ecx.tcx.items.get(i.did.node) {\n                   ast_map::node_item(it@@{node: cl@item_class(*),_},_) {\n                     ebml_w.wr_str(def_to_str(local_def(it.id)));\n-                    some(ty::lookup_item_type(ecx.ccx.tcx, i.did).ty)\n+                    some(ty::lookup_item_type(ecx.tcx, i.did).ty)\n                   }\n                   ast_map::node_item(@{node: item_impl(_,_,\n                                            some(ifce),_,_),_},_) {\n                     ebml_w.wr_str(def_to_str(i.did));\n-                    some(ty::node_id_to_type(ecx.ccx.tcx, ifce.id))\n+                    some(ty::node_id_to_type(ecx.tcx, ifce.id))\n                   }\n                   _ {\n                       ebml_w.wr_str(def_to_str(i.did)); none\n@@ -391,7 +413,7 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n             } // for\n       } // list::cons alt\n       _ {\n-          ecx.ccx.tcx.sess.bug(#fmt(\"encode_info_for_mod: empty impl_map \\\n+          ecx.tcx.sess.bug(#fmt(\"encode_info_for_mod: empty impl_map \\\n             entry for %?\", path));\n       }\n     }\n@@ -413,7 +435,7 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                          global_index: @mut[entry<int>])\n  -> [entry<int>] {\n     let index = @mut [];\n-    let tcx = ecx.ccx.tcx;\n+    let tcx = ecx.tcx;\n     for items.each {|ci|\n      /* We encode both private and public fields -- need to include\n         private fields to get the offsets right */\n@@ -460,9 +482,9 @@ fn encode_info_for_fn(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         encode_def_id(ebml_w, local_def(id));\n         encode_family(ebml_w, purity_fn_family(decl.purity));\n         encode_type_param_bounds(ebml_w, ecx, tps);\n-        let its_ty = node_id_to_type(ecx.ccx.tcx, id);\n+        let its_ty = node_id_to_type(ecx.tcx, id);\n         #debug(\"fn name = %s ty = %s\", ident,\n-               util::ppaux::ty_to_str(ecx.ccx.tcx, its_ty));\n+               util::ppaux::ty_to_str(ecx.tcx, its_ty));\n         encode_type(ecx, ebml_w, its_ty);\n         encode_path(ebml_w, path, ast_map::path_name(ident));\n         alt item {\n@@ -485,7 +507,7 @@ fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: ebml::writer,\n     encode_def_id(ebml_w, local_def(m.id));\n     encode_family(ebml_w, purity_fn_family(m.decl.purity));\n     encode_type_param_bounds(ebml_w, ecx, all_tps);\n-    encode_type(ecx, ebml_w, node_id_to_type(ecx.ccx.tcx, m.id));\n+    encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, m.id));\n     encode_name(ebml_w, m.ident);\n     encode_path(ebml_w, impl_path, ast_map::path_name(m.ident));\n     if all_tps.len() > 0u || should_inline {\n@@ -519,7 +541,7 @@ fn should_inline(attrs: [attribute]) -> bool {\n fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                         index: @mut [entry<int>], path: ast_map::path) {\n \n-    let tcx = ecx.ccx.tcx;\n+    let tcx = ecx.tcx;\n     let must_write =\n         alt item.node { item_enum(_, _, _) { true } _ { false } };\n     if !must_write && !reachable(ecx, item.id) { ret; }\n@@ -750,7 +772,7 @@ fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         encode_def_id(ebml_w, local_def(nitem.id));\n         encode_family(ebml_w, purity_fn_family(fn_decl.purity));\n         encode_type_param_bounds(ebml_w, ecx, tps);\n-        encode_type(ecx, ebml_w, node_id_to_type(ecx.ccx.tcx, nitem.id));\n+        encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n         if abi == native_abi_rust_intrinsic {\n             astencode::encode_inlined_item(ecx, ebml_w, path,\n                                            ii_native(nitem));\n@@ -774,7 +796,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         visit_expr: {|_e, _cx, _v|},\n         visit_item: {|i, cx, v|\n             visit::visit_item(i, cx, v);\n-            alt check ecx.ccx.tcx.items.get(i.id) {\n+            alt check ecx.tcx.items.get(i.id) {\n               ast_map::node_item(_, pt) {\n                 encode_info_for_item(ecx, ebml_w, i, index, *pt);\n                 /* encode ctor, then encode items */\n@@ -798,7 +820,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         },\n         visit_native_item: {|ni, cx, v|\n             visit::visit_native_item(ni, cx, v);\n-            alt check ecx.ccx.tcx.items.get(ni.id) {\n+            alt check ecx.tcx.items.get(ni.id) {\n               ast_map::node_native_item(_, abi, pt) {\n                 encode_info_for_native_item(ecx, ebml_w, ni, index, *pt, abi);\n               }\n@@ -915,13 +937,13 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> [attribute] {\n     fn synthesize_link_attr(ecx: @encode_ctxt, items: [@meta_item]) ->\n        attribute {\n \n-        assert (ecx.ccx.link_meta.name != \"\");\n-        assert (ecx.ccx.link_meta.vers != \"\");\n+        assert (ecx.link_meta.name != \"\");\n+        assert (ecx.link_meta.vers != \"\");\n \n         let name_item =\n-            attr::mk_name_value_item_str(\"name\", ecx.ccx.link_meta.name);\n+            attr::mk_name_value_item_str(\"name\", ecx.link_meta.name);\n         let vers_item =\n-            attr::mk_name_value_item_str(\"vers\", ecx.ccx.link_meta.vers);\n+            attr::mk_name_value_item_str(\"vers\", ecx.link_meta.vers);\n \n         let other_items =\n             {\n@@ -1018,19 +1040,29 @@ fn encode_hash(ebml_w: ebml::writer, hash: str) {\n     ebml_w.end_tag();\n }\n \n-fn encode_metadata(cx: @crate_ctxt, crate: @crate) -> [u8] {\n-    let ecx = @{ccx: cx, type_abbrevs: ty::new_ty_hash()};\n+fn encode_metadata(parms: encode_parms, crate: @crate) -> [u8] {\n+    let ecx: @encode_ctxt = @{\n+        tcx: parms.tcx,\n+        reachable: parms.reachable,\n+        exp_map: parms.exp_map,\n+        item_symbols: parms.item_symbols,\n+        discrim_symbols: parms.discrim_symbols,\n+        link_meta: parms.link_meta,\n+        cstore: parms.cstore,\n+        maps: parms.maps,\n+        type_abbrevs: ty::new_ty_hash()\n+     };\n \n     let buf = io::mem_buffer();\n     let buf_w = io::mem_buffer_writer(buf);\n     let ebml_w = ebml::writer(buf_w);\n \n-    encode_hash(ebml_w, cx.link_meta.extras_hash);\n+    encode_hash(ebml_w, ecx.link_meta.extras_hash);\n \n     let crate_attrs = synthesize_crate_attrs(ecx, crate);\n     encode_attributes(ebml_w, crate_attrs);\n \n-    encode_crate_deps(ebml_w, cx.sess.cstore);\n+    encode_crate_deps(ebml_w, ecx.cstore);\n \n     // Encode and index the paths.\n     ebml_w.start_tag(tag_paths);"}, {"sha": "6bad2249cac319feb7a6e63928aa3ad703155169", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a2572fe77efe58a7c202824deeb0b78fca89cf7e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2572fe77efe58a7c202824deeb0b78fca89cf7e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=a2572fe77efe58a7c202824deeb0b78fca89cf7e", "patch": "@@ -38,7 +38,7 @@ import link::{mangle_internal_name_by_type_only,\n               mangle_internal_name_by_path,\n               mangle_internal_name_by_path_and_seq,\n               mangle_exported_name};\n-import metadata::{csearch, cstore};\n+import metadata::{csearch, cstore, encoder};\n import util::ppaux::{ty_to_str, ty_to_short_str};\n \n import common::*;\n@@ -4932,9 +4932,26 @@ fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n          C_array(ccx.int_type, subcrates)]));\n }\n \n+fn crate_ctxt_to_encode_parms(cx: @crate_ctxt)\n+    -> encoder::encode_parms {\n+\n+    {\n+        tcx: cx.tcx,\n+        reachable: cx.reachable,\n+        exp_map: cx.exp_map,\n+        item_symbols: cx.item_symbols,\n+        discrim_symbols: cx.discrim_symbols,\n+        link_meta: cx.link_meta,\n+        cstore: cx.sess.cstore,\n+        maps: cx.maps,\n+    }\n+\n+}\n+\n fn write_metadata(cx: @crate_ctxt, crate: @ast::crate) {\n     if !cx.sess.building_library { ret; }\n-    let llmeta = C_bytes(metadata::encoder::encode_metadata(cx, crate));\n+    let encode_parms = crate_ctxt_to_encode_parms(cx);\n+    let llmeta = C_bytes(encoder::encode_metadata(encode_parms, crate));\n     let llconst = C_struct([llmeta]);\n     let mut llglobal = str::as_c_str(\"rust_metadata\", {|buf|\n         llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst), buf)\n@@ -4961,7 +4978,8 @@ fn write_abi_version(ccx: @crate_ctxt) {\n }\n \n fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n-               output: str, emap: resolve::exp_map, maps: maps)\n+               output: str, emap: resolve::exp_map,\n+               maps: metadata::maps)\n     -> (ModuleRef, link::link_meta) {\n     let sha = std::sha1::sha1();\n     let link_meta = link::build_link_meta(sess, *crate, output, sha);"}, {"sha": "72e982ba445069ca49e38ece08d850593f65c417", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a2572fe77efe58a7c202824deeb0b78fca89cf7e/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2572fe77efe58a7c202824deeb0b78fca89cf7e/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=a2572fe77efe58a7c202824deeb0b78fca89cf7e", "patch": "@@ -17,7 +17,7 @@ import lib::llvm::{llvm, target_data, type_names, associate_type,\n                    name_has_type};\n import lib::llvm::{ModuleRef, ValueRef, TypeRef, BasicBlockRef, BuilderRef};\n import lib::llvm::{True, False, Bool};\n-import metadata::csearch;\n+import metadata::{csearch, encoder};\n import ast_map::path;\n \n type namegen = fn@(str) -> str;\n@@ -62,17 +62,6 @@ type stats =\n \n resource BuilderRef_res(B: BuilderRef) { llvm::LLVMDisposeBuilder(B); }\n \n-// Misc. auxiliary maps used in the crate_ctxt\n-type maps = {\n-    mutbl_map: middle::borrowck::mutbl_map,\n-    copy_map: middle::alias::copy_map,\n-    last_uses: middle::last_use::last_uses,\n-    impl_map: middle::resolve::impl_map,\n-    method_map: middle::typeck::method_map,\n-    vtable_map: middle::typeck::vtable_map,\n-    spill_map: last_use::spill_map\n-};\n-\n // Crate context.  Every crate we compile has one of these.\n type crate_ctxt = {\n      sess: session::session,\n@@ -110,7 +99,7 @@ type crate_ctxt = {\n      type_short_names: hashmap<ty::t, str>,\n      all_llvm_symbols: set<str>,\n      tcx: ty::ctxt,\n-     maps: maps,\n+     maps: metadata::maps,\n      stats: stats,\n      upcalls: @upcall::upcalls,\n      tydesc_type: TypeRef,"}, {"sha": "6771688137e601fd81241e67984848d3457c273d", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2572fe77efe58a7c202824deeb0b78fca89cf7e/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a2572fe77efe58a7c202824deeb0b78fca89cf7e/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=a2572fe77efe58a7c202824deeb0b78fca89cf7e", "patch": "@@ -28,6 +28,7 @@ import util_ = util;\n import lib_ = lib;\n import driver_ = driver;\n import middle_ = middle;\n+import back_ = back;\n \n mod middle {\n     mod trans {"}, {"sha": "bdccf3b171d0df37c9e45d4519b96891b8d5792d", "filename": "src/rustc/syntax.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2572fe77efe58a7c202824deeb0b78fca89cf7e/src%2Frustc%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2572fe77efe58a7c202824deeb0b78fca89cf7e/src%2Frustc%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax.rs?ref=a2572fe77efe58a7c202824deeb0b78fca89cf7e", "patch": "@@ -28,3 +28,6 @@ export attr;\n \n import rustsyntax::ext;\n export ext;\n+\n+import rustsyntax::diagnostic;\n+export diagnostic;\n\\ No newline at end of file"}]}