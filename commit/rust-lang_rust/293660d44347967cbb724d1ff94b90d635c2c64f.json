{"sha": "293660d44347967cbb724d1ff94b90d635c2c64f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5MzY2MGQ0NDM0Nzk2N2NiYjcyNGQxZmY5NGI5MGQ2MzVjMmM2NGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-20T20:32:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-20T20:32:00Z"}, "message": "auto merge of #8519 : msullivan/rust/objects, r=catamorphism\n\nr?", "tree": {"sha": "fec2b59fd77e8b1d1d791976673a186e031ae7d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fec2b59fd77e8b1d1d791976673a186e031ae7d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/293660d44347967cbb724d1ff94b90d635c2c64f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/293660d44347967cbb724d1ff94b90d635c2c64f", "html_url": "https://github.com/rust-lang/rust/commit/293660d44347967cbb724d1ff94b90d635c2c64f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/293660d44347967cbb724d1ff94b90d635c2c64f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8c3fe45c6138cd1f4d143fdb0e843ee2d4759b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8c3fe45c6138cd1f4d143fdb0e843ee2d4759b2", "html_url": "https://github.com/rust-lang/rust/commit/a8c3fe45c6138cd1f4d143fdb0e843ee2d4759b2"}, {"sha": "6a6d3b600fbd5c0076281d737fa4673e254ce313", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a6d3b600fbd5c0076281d737fa4673e254ce313", "html_url": "https://github.com/rust-lang/rust/commit/6a6d3b600fbd5c0076281d737fa4673e254ce313"}], "stats": {"total": 397, "additions": 226, "deletions": 171}, "files": [{"sha": "a22daac90b5517e7c30fb48ef77850a7f6cb54a3", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/293660d44347967cbb724d1ff94b90d635c2c64f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293660d44347967cbb724d1ff94b90d635c2c64f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=293660d44347967cbb724d1ff94b90d635c2c64f", "patch": "@@ -586,8 +586,13 @@ impl tr for method_origin {\n                 }\n             )\n           }\n-          typeck::method_trait(did, m) => {\n-              typeck::method_trait(did.tr(xcx), m)\n+          typeck::method_object(ref mo) => {\n+            typeck::method_object(\n+                typeck::method_object {\n+                    trait_id: mo.trait_id.tr(xcx),\n+                    .. *mo\n+                }\n+            )\n           }\n         }\n     }"}, {"sha": "222bef641d2247f8f71d021de716c8a1b7ccbc76", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/293660d44347967cbb724d1ff94b90d635c2c64f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293660d44347967cbb724d1ff94b90d635c2c64f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=293660d44347967cbb724d1ff94b90d635c2c64f", "patch": "@@ -16,7 +16,7 @@ use metadata::csearch;\n use middle::ty::{ty_struct, ty_enum};\n use middle::ty;\n use middle::typeck::{method_map, method_origin, method_param};\n-use middle::typeck::{method_static, method_trait};\n+use middle::typeck::{method_static, method_object};\n \n use std::util::ignore;\n use syntax::ast::{decl_item, def, def_fn, def_id, def_static_method};\n@@ -280,10 +280,14 @@ impl PrivacyVisitor {\n             }\n             method_param(method_param {\n                 trait_id: trait_id,\n-                 method_num: method_num,\n+                method_num: method_num,\n                  _\n             }) |\n-            method_trait(trait_id, method_num) => {\n+            method_object(method_object {\n+                trait_id: trait_id,\n+                method_num: method_num,\n+                 _\n+            }) => {\n                 if trait_id.crate == LOCAL_CRATE {\n                     match self.tcx.items.find(&trait_id.node) {\n                         Some(&node_item(item, _)) => {"}, {"sha": "d8c7b916a02326cb863db7eede876904296712be", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/293660d44347967cbb724d1ff94b90d635c2c64f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293660d44347967cbb724d1ff94b90d635c2c64f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=293660d44347967cbb724d1ff94b90d635c2c64f", "patch": "@@ -1015,6 +1015,8 @@ pub fn node_vtables(bcx: @mut Block, id: ast::NodeId)\n     raw_vtables.map_move(|vts| resolve_vtables_in_fn_ctxt(bcx.fcx, *vts))\n }\n \n+// Apply the typaram substitutions in the FunctionContext to some\n+// vtables. This should eliminate any vtable_params.\n pub fn resolve_vtables_in_fn_ctxt(fcx: &FunctionContext, vts: typeck::vtable_res)\n     -> typeck::vtable_res {\n     resolve_vtables_under_param_substs(fcx.ccx.tcx,\n@@ -1047,15 +1049,6 @@ pub fn resolve_param_vtables_under_param_substs(\n \n \n \n-// Apply the typaram substitutions in the FunctionContext to a vtable. This should\n-// eliminate any vtable_params.\n-pub fn resolve_vtable_in_fn_ctxt(fcx: &FunctionContext, vt: &typeck::vtable_origin)\n-    -> typeck::vtable_origin {\n-    resolve_vtable_under_param_substs(fcx.ccx.tcx,\n-                                      fcx.param_substs,\n-                                      vt)\n-}\n-\n pub fn resolve_vtable_under_param_substs(tcx: ty::ctxt,\n                                          param_substs: Option<@param_substs>,\n                                          vt: &typeck::vtable_origin)\n@@ -1081,8 +1074,8 @@ pub fn resolve_vtable_under_param_substs(tcx: ty::ctxt,\n                 }\n                 _ => {\n                     tcx.sess.bug(fmt!(\n-                        \"resolve_vtable_in_fn_ctxt: asked to lookup but \\\n-                         no vtables in the fn_ctxt!\"))\n+                        \"resolve_vtable_under_param_substs: asked to lookup \\\n+                         but no vtables in the fn_ctxt!\"))\n                 }\n             }\n         }"}, {"sha": "1318ef2c8958db24cc07975df24b20df018846fe", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/293660d44347967cbb724d1ff94b90d635c2c64f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293660d44347967cbb724d1ff94b90d635c2c64f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=293660d44347967cbb724d1ff94b90d635c2c64f", "patch": "@@ -67,7 +67,7 @@ pub struct CrateContext {\n      // Cache computed type parameter uses (see type_use.rs)\n      type_use_cache: HashMap<ast::def_id, @~[type_use::type_uses]>,\n      // Cache generated vtables\n-     vtables: HashMap<mono_id, ValueRef>,\n+     vtables: HashMap<(ty::t, mono_id), ValueRef>,\n      // Cache of constant strings,\n      const_cstr_cache: HashMap<@str, ValueRef>,\n "}, {"sha": "f4451d9c53f4e7695d5153af312955dace1159a8", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 42, "deletions": 33, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/293660d44347967cbb724d1ff94b90d635c2c64f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293660d44347967cbb724d1ff94b90d635c2c64f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=293660d44347967cbb724d1ff94b90d635c2c64f", "patch": "@@ -186,10 +186,10 @@ pub fn trans_method_callee(bcx: @mut Block,\n             }\n         }\n \n-        typeck::method_trait(_, off) => {\n+        typeck::method_object(ref mt) => {\n             trans_trait_callee(bcx,\n                                callee_id,\n-                               off,\n+                               mt.real_index,\n                                this)\n         }\n     }\n@@ -398,7 +398,6 @@ pub fn combine_impl_and_methods_tps(bcx: @mut Block,\n     return (ty_substs, vtables);\n }\n \n-\n pub fn trans_trait_callee(bcx: @mut Block,\n                           callee_id: ast::NodeId,\n                           n_method: uint,\n@@ -506,20 +505,35 @@ pub fn vtable_id(ccx: @mut CrateContext,\n /// This is used only for objects.\n pub fn get_vtable(bcx: @mut Block,\n                   self_ty: ty::t,\n-                  origin: typeck::vtable_origin)\n+                  origins: typeck::vtable_param_res)\n                   -> ValueRef {\n-    let hash_id = vtable_id(bcx.ccx(), &origin);\n-    match bcx.ccx().vtables.find(&hash_id) {\n-        Some(&val) => val,\n-        None => {\n-            match origin {\n-                typeck::vtable_static(id, substs, sub_vtables) => {\n-                    make_impl_vtable(bcx, id, self_ty, substs, sub_vtables)\n-                }\n-                _ => fail!(\"get_vtable: expected a static origin\"),\n+    let ccx = bcx.ccx();\n+    let _icx = push_ctxt(\"impl::get_vtable\");\n+\n+    // Check the cache.\n+    let hash_id = (self_ty, vtable_id(ccx, &origins[0]));\n+    match ccx.vtables.find(&hash_id) {\n+        Some(&val) => { return val }\n+        None => { }\n+    }\n+\n+    // Not in the cache. Actually build it.\n+    let methods = do origins.flat_map |origin| {\n+        match *origin {\n+            typeck::vtable_static(id, ref substs, sub_vtables) => {\n+                emit_vtable_methods(bcx, id, *substs, sub_vtables)\n             }\n+            _ => ccx.sess.bug(\"get_vtable: expected a static origin\"),\n         }\n-    }\n+    };\n+\n+    // Generate a type descriptor for the vtable.\n+    let tydesc = get_tydesc(ccx, self_ty);\n+    glue::lazily_emit_all_tydesc_glue(ccx, tydesc);\n+\n+    let vtable = make_vtable(ccx, tydesc, methods);\n+    ccx.vtables.insert(hash_id, vtable);\n+    return vtable;\n }\n \n /// Helper function to declare and initialize the vtable.\n@@ -547,15 +561,12 @@ pub fn make_vtable(ccx: &mut CrateContext,\n     }\n }\n \n-/// Generates a dynamic vtable for objects.\n-pub fn make_impl_vtable(bcx: @mut Block,\n-                        impl_id: ast::def_id,\n-                        self_ty: ty::t,\n-                        substs: &[ty::t],\n-                        vtables: typeck::vtable_res)\n-                        -> ValueRef {\n+fn emit_vtable_methods(bcx: @mut Block,\n+                       impl_id: ast::def_id,\n+                       substs: &[ty::t],\n+                       vtables: typeck::vtable_res)\n+                       -> ~[ValueRef] {\n     let ccx = bcx.ccx();\n-    let _icx = push_ctxt(\"impl::make_impl_vtable\");\n     let tcx = ccx.tcx;\n \n     let trt_id = match ty::impl_trait_ref(tcx, impl_id) {\n@@ -565,7 +576,7 @@ pub fn make_impl_vtable(bcx: @mut Block,\n     };\n \n     let trait_method_def_ids = ty::trait_method_def_ids(tcx, trt_id);\n-    let methods = do trait_method_def_ids.map |method_def_id| {\n+    do trait_method_def_ids.map |method_def_id| {\n         let im = ty::method(tcx, *method_def_id);\n         let fty = ty::subst_tps(tcx,\n                                 substs,\n@@ -583,13 +594,7 @@ pub fn make_impl_vtable(bcx: @mut Block,\n             trans_fn_ref_with_vtables(bcx, m_id, 0,\n                                       substs, Some(vtables)).llfn\n         }\n-    };\n-\n-    // Generate a type descriptor for the vtable.\n-    let tydesc = get_tydesc(ccx, self_ty);\n-    glue::lazily_emit_all_tydesc_glue(ccx, tydesc);\n-\n-    make_vtable(ccx, tydesc, methods)\n+    }\n }\n \n pub fn trans_trait_cast(bcx: @mut Block,\n@@ -621,9 +626,13 @@ pub fn trans_trait_cast(bcx: @mut Block,\n     bcx = expr::trans_into(bcx, val, SaveIn(llboxdest));\n \n     // Store the vtable into the pair or triple.\n-    let orig = ccx.maps.vtable_map.get(&id)[0][0].clone();\n-    let orig = resolve_vtable_in_fn_ctxt(bcx.fcx, &orig);\n-    let vtable = get_vtable(bcx, v_ty, orig);\n+    // This is structured a bit funny because of dynamic borrow failures.\n+    let origins = {\n+        let res = ccx.maps.vtable_map.get(&id);\n+        let res = resolve_vtables_in_fn_ctxt(bcx.fcx, *res);\n+        res[0]\n+    };\n+    let vtable = get_vtable(bcx, v_ty, origins);\n     Store(bcx, vtable, PointerCast(bcx,\n                                    GEPi(bcx, lldest, [0u, abi::trt_field_vtable]),\n                                    val_ty(vtable).ptr_to()));"}, {"sha": "67bd87824975b92a377a661e5f629e10bcd7ff55", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/293660d44347967cbb724d1ff94b90d635c2c64f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293660d44347967cbb724d1ff94b90d635c2c64f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=293660d44347967cbb724d1ff94b90d635c2c64f", "patch": "@@ -59,6 +59,7 @@ pub struct field {\n     mt: mt\n }\n \n+#[deriving(Clone)]\n pub struct Method {\n     ident: ast::ident,\n     generics: ty::Generics,\n@@ -3136,12 +3137,14 @@ pub fn method_call_type_param_defs(tcx: ctxt,\n           typeck::method_param(typeck::method_param {\n               trait_id: trt_id,\n               method_num: n_mth, _}) |\n-          typeck::method_trait(trt_id, n_mth) => {\n+          typeck::method_object(typeck::method_object {\n+              trait_id: trt_id,\n+              method_num: n_mth, _}) => {\n             // ...trait methods bounds, in contrast, include only the\n             // method bounds, so we must preprend the tps from the\n             // trait itself.  This ought to be harmonized.\n             let trait_type_param_defs =\n-                ty::lookup_trait_def(tcx, trt_id).generics.type_param_defs;\n+                lookup_trait_def(tcx, trt_id).generics.type_param_defs;\n             @vec::append(\n                 (*trait_type_param_defs).clone(),\n                 *ty::trait_method(tcx,"}, {"sha": "c8d3bdaab2892867ddd750cdda2969471c0bbc7b", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 111, "deletions": 91, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/293660d44347967cbb724d1ff94b90d635c2c64f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293660d44347967cbb724d1ff94b90d635c2c64f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=293660d44347967cbb724d1ff94b90d635c2c64f", "patch": "@@ -90,7 +90,7 @@ use middle::typeck::check::vtable;\n use middle::typeck::check;\n use middle::typeck::infer;\n use middle::typeck::{method_map_entry, method_origin, method_param};\n-use middle::typeck::{method_static, method_trait};\n+use middle::typeck::{method_static, method_object};\n use middle::typeck::{param_numbered, param_self, param_index};\n use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n use util::common::indenter;\n@@ -298,7 +298,7 @@ impl<'self> LookupContext<'self> {\n         loop {\n             match get(self_ty).sty {\n                 ty_trait(did, ref substs, _, _, _) => {\n-                    self.push_inherent_candidates_from_trait(did, substs);\n+                    self.push_inherent_candidates_from_object(did, substs);\n                     self.push_inherent_impl_candidates_for_type(did);\n                 }\n                 ty_enum(did, _) | ty_struct(did, _) => {\n@@ -363,53 +363,85 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    fn push_inherent_candidates_from_trait(&self,\n-                                               did: def_id,\n-                                               substs: &ty::substs) {\n-        debug!(\"push_inherent_candidates_from_trait(did=%s, substs=%s)\",\n-               self.did_to_str(did),\n-               substs_to_str(self.tcx(), substs));\n-        let _indenter = indenter();\n-\n+    // Determine the index of a method in the list of all methods belonging\n+    // to a trait and its supertraits.\n+    fn get_method_index(&self,\n+                        trait_ref: @TraitRef,\n+                        subtrait_id: ast::def_id,\n+                        n_method: uint) -> uint {\n         let tcx = self.tcx();\n-        let ms = ty::trait_methods(tcx, did);\n-        let index = match ms.iter().position(|m| m.ident == self.m_name) {\n-            Some(i) => i,\n-            None => { return; } // no method with the right name\n-        };\n-        let method = ms[index];\n \n-        match method.explicit_self {\n-            ast::sty_static => {\n-                return; // not a method we can call with dot notation\n+        // We need to figure the \"real index\" of the method in a\n+        // listing of all the methods of an object. We do this by\n+        // iterating down the supertraits of the object's trait until\n+        // we find the trait the method came from, counting up the\n+        // methods from them.\n+        let mut method_count = 0;\n+        do ty::each_bound_trait_and_supertraits(tcx, &[trait_ref])\n+            |bound_ref| {\n+            if bound_ref.def_id == subtrait_id { false }\n+                else {\n+                method_count += ty::trait_methods(tcx, bound_ref.def_id).len();\n+                true\n             }\n-            _ => {}\n-        }\n+        };\n+\n+        return method_count + n_method;\n+    }\n+\n+\n+    fn push_inherent_candidates_from_object(&self,\n+                                            did: def_id,\n+                                            substs: &ty::substs) {\n+        debug!(\"push_inherent_candidates_from_object(did=%s, substs=%s)\",\n+               self.did_to_str(did),\n+               substs_to_str(self.tcx(), substs));\n+        let _indenter = indenter();\n \n         // It is illegal to invoke a method on a trait instance that\n         // refers to the `self` type. An error will be reported by\n         // `enforce_object_limitations()` if the method refers\n         // to the `Self` type. Substituting ty_err here allows\n         // compiler to soldier on.\n         //\n-        // NOTE: `confirm_candidate()` also relies upon this substitution\n+        // `confirm_candidate()` also relies upon this substitution\n         // for Self. (fix)\n         let rcvr_substs = substs {\n             self_ty: Some(ty::mk_err()),\n             ..(*substs).clone()\n         };\n-\n-        self.inherent_candidates.push(Candidate {\n-            rcvr_match_condition: RcvrMatchesIfObject(did),\n-            rcvr_substs: rcvr_substs,\n-            method_ty: method,\n-            origin: method_trait(did, index)\n-        });\n+        let trait_ref = @TraitRef { def_id: did, substs: rcvr_substs.clone() };\n+\n+        do self.push_inherent_candidates_from_bounds_inner(&[trait_ref])\n+            |trait_ref, m, method_num, _bound_num| {\n+            let vtable_index =\n+                self.get_method_index(trait_ref, trait_ref.def_id, method_num);\n+            // We need to fix up the transformed self type.\n+            let transformed_self_ty =\n+                self.construct_transformed_self_ty_for_object(\n+                    did, &rcvr_substs, m);\n+            let m = @Method {\n+                transformed_self_ty: Some(transformed_self_ty),\n+                .. (*m).clone()\n+            };\n+\n+            Candidate {\n+                rcvr_match_condition: RcvrMatchesIfObject(did),\n+                rcvr_substs: trait_ref.substs.clone(),\n+                method_ty: m,\n+                origin: method_object(method_object {\n+                        trait_id: trait_ref.def_id,\n+                        object_trait_id: did,\n+                        method_num: method_num,\n+                        real_index: vtable_index\n+                    })\n+            }\n+        };\n     }\n \n     fn push_inherent_candidates_from_param(&self,\n-                                               rcvr_ty: ty::t,\n-                                               param_ty: param_ty) {\n+                                           rcvr_ty: ty::t,\n+                                           param_ty: param_ty) {\n         debug!(\"push_inherent_candidates_from_param(param_ty=%?)\",\n                param_ty);\n         let _indenter = indenter();\n@@ -441,9 +473,34 @@ impl<'self> LookupContext<'self> {\n     }\n \n     fn push_inherent_candidates_from_bounds(&self,\n-                                                self_ty: ty::t,\n-                                                bounds: &[@TraitRef],\n-                                                param: param_index) {\n+                                            self_ty: ty::t,\n+                                            bounds: &[@TraitRef],\n+                                            param: param_index) {\n+        do self.push_inherent_candidates_from_bounds_inner(bounds)\n+            |trait_ref, m, method_num, bound_num| {\n+            Candidate {\n+                rcvr_match_condition: RcvrMatchesIfSubtype(self_ty),\n+                rcvr_substs: trait_ref.substs.clone(),\n+                method_ty: m,\n+                origin: method_param(\n+                                     method_param {\n+                        trait_id: trait_ref.def_id,\n+                        method_num: method_num,\n+                        param_num: param,\n+                        bound_num: bound_num,\n+                    })\n+            }\n+        }\n+    }\n+\n+    // Do a search through a list of bounds, using a callback to actually\n+    // create the candidates.\n+    fn push_inherent_candidates_from_bounds_inner(\n+        &self,\n+        bounds: &[@TraitRef],\n+        mk_cand: &fn(trait_ref: @TraitRef, m: @ty::Method, method_num: uint,\n+                     bound_num: uint) -> Candidate) {\n+\n         let tcx = self.tcx();\n         let mut next_bound_idx = 0; // count only trait bounds\n \n@@ -459,18 +516,8 @@ impl<'self> LookupContext<'self> {\n                 Some(pos) => {\n                     let method = trait_methods[pos];\n \n-                    let cand = Candidate {\n-                        rcvr_match_condition: RcvrMatchesIfSubtype(self_ty),\n-                        rcvr_substs: bound_trait_ref.substs.clone(),\n-                        method_ty: method,\n-                        origin: method_param(\n-                                             method_param {\n-                                trait_id: bound_trait_ref.def_id,\n-                                method_num: pos,\n-                                param_num: param,\n-                                bound_num: this_bound_idx,\n-                            })\n-                    };\n+                    let cand = mk_cand(bound_trait_ref, method,\n+                                       pos, this_bound_idx);\n \n                     debug!(\"pushing inherent candidate for param: %?\", cand);\n                     self.inherent_candidates.push(cand);\n@@ -879,7 +926,7 @@ impl<'self> LookupContext<'self> {\n     fn confirm_candidate(&self, rcvr_ty: ty::t, candidate: &Candidate)\n                              -> method_map_entry {\n         let tcx = self.tcx();\n-        let fty = self.fn_ty_from_origin(&candidate.origin);\n+        let fty = ty::mk_bare_fn(tcx, candidate.method_ty.fty.clone());\n \n         debug!(\"confirm_candidate(expr=%s, candidate=%s, fty=%s)\",\n                self.expr.repr(tcx),\n@@ -891,17 +938,9 @@ impl<'self> LookupContext<'self> {\n \n         // static methods should never have gotten this far:\n         assert!(candidate.method_ty.explicit_self != sty_static);\n-\n-        let transformed_self_ty = match candidate.origin {\n-            method_trait(trait_def_id, _) => {\n-                self.construct_transformed_self_ty_for_object(\n-                    trait_def_id, candidate)\n-            }\n-            _ => {\n-                let t = candidate.method_ty.transformed_self_ty.unwrap();\n-                ty::subst(tcx, &candidate.rcvr_substs, t)\n-            }\n-        };\n+        let transformed_self_ty =\n+            ty::subst(tcx, &candidate.rcvr_substs,\n+                      candidate.method_ty.transformed_self_ty.unwrap());\n \n         // Determine the values for the type parameters of the method.\n         // If they were not explicitly supplied, just construct fresh\n@@ -992,9 +1031,11 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    fn construct_transformed_self_ty_for_object(&self,\n-                                                trait_def_id: ast::def_id,\n-                                                candidate: &Candidate) -> ty::t\n+    fn construct_transformed_self_ty_for_object(\n+        &self,\n+        trait_def_id: ast::def_id,\n+        rcvr_substs: &ty::substs,\n+        method_ty: &ty::Method) -> ty::t\n     {\n         /*!\n          * This is a bit tricky. We have a match against a trait method\n@@ -1010,17 +1051,17 @@ impl<'self> LookupContext<'self> {\n          * result to be `&'a Foo`. Assuming that `m_method` is being\n          * called, we want the result to be `@mut Foo`. Of course,\n          * this transformation has already been done as part of\n-         * `candidate.method_ty.transformed_self_ty`, but there the\n+         * `method_ty.transformed_self_ty`, but there the\n          * type is expressed in terms of `Self` (i.e., `&'a Self`, `@mut Self`).\n          * Because objects are not standalone types, we can't just substitute\n          * `s/Self/Foo/`, so we must instead perform this kind of hokey\n          * match below.\n          */\n \n-        let substs = ty::substs {regions: candidate.rcvr_substs.regions.clone(),\n+        let substs = ty::substs {regions: rcvr_substs.regions.clone(),\n                                  self_ty: None,\n-                                 tps: candidate.rcvr_substs.tps.clone()};\n-        match candidate.method_ty.explicit_self {\n+                                 tps: rcvr_substs.tps.clone()};\n+        match method_ty.explicit_self {\n             ast::sty_static => {\n                 self.bug(~\"static method for object type receiver\");\n             }\n@@ -1029,7 +1070,7 @@ impl<'self> LookupContext<'self> {\n             }\n             ast::sty_region(*) | ast::sty_box(*) | ast::sty_uniq(*) => {\n                 let transformed_self_ty =\n-                    candidate.method_ty.transformed_self_ty.clone().unwrap();\n+                    method_ty.transformed_self_ty.clone().unwrap();\n                 match ty::get(transformed_self_ty).sty {\n                     ty::ty_rptr(r, mt) => { // must be sty_region\n                         ty::mk_trait(self.tcx(), trait_def_id,\n@@ -1072,7 +1113,7 @@ impl<'self> LookupContext<'self> {\n             method_static(*) | method_param(*) => {\n                 return; // not a call to a trait instance\n             }\n-            method_trait(*) => {}\n+            method_object(*) => {}\n         }\n \n         match candidate.method_ty.explicit_self {\n@@ -1117,7 +1158,7 @@ impl<'self> LookupContext<'self> {\n             // XXX: does this properly enforce this on everything now\n             // that self has been merged in? -sully\n             method_param(method_param { trait_id: trait_id, _ }) |\n-            method_trait(trait_id, _) => {\n+            method_object(method_object { trait_id: trait_id, _ }) => {\n                 bad = self.tcx().destructor_for_type.contains_key(&trait_id);\n             }\n         }\n@@ -1235,27 +1276,6 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    fn fn_ty_from_origin(&self, origin: &method_origin) -> ty::t {\n-        return match *origin {\n-            method_static(did) => {\n-                ty::lookup_item_type(self.tcx(), did).ty\n-            }\n-            method_param(ref mp) => {\n-                type_of_trait_method(self.tcx(), mp.trait_id, mp.method_num)\n-            }\n-            method_trait(did, idx) => {\n-                type_of_trait_method(self.tcx(), did, idx)\n-            }\n-        };\n-\n-        fn type_of_trait_method(tcx: ty::ctxt,\n-                                trait_did: def_id,\n-                                method_num: uint) -> ty::t {\n-            let trait_methods = ty::trait_methods(tcx, trait_did);\n-            ty::mk_bare_fn(tcx, trait_methods[method_num].fty.clone())\n-        }\n-    }\n-\n     fn report_candidate(&self, idx: uint, origin: &method_origin) {\n         match *origin {\n             method_static(impl_did) => {\n@@ -1264,8 +1284,8 @@ impl<'self> LookupContext<'self> {\n             method_param(ref mp) => {\n                 self.report_param_candidate(idx, (*mp).trait_id)\n             }\n-            method_trait(trait_did, _) => {\n-                self.report_trait_candidate(idx, trait_did)\n+            method_object(ref mo) => {\n+                self.report_trait_candidate(idx, mo.trait_id)\n             }\n         }\n     }"}, {"sha": "cd69a642b72c6e3295b84ae9d7cbacf60e602b98", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/293660d44347967cbb724d1ff94b90d635c2c64f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293660d44347967cbb724d1ff94b90d635c2c64f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=293660d44347967cbb724d1ff94b90d635c2c64f", "patch": "@@ -647,30 +647,21 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                                   self_ty: Some(mt.ty)\n                               }\n                           };\n-                          let vtable_opt =\n-                              lookup_vtable(&vcx,\n-                                            location_info,\n-                                            mt.ty,\n-                                            target_trait_ref,\n-                                            is_early);\n-                          match vtable_opt {\n-                              Some(vtable) => {\n-                                  // Map this expression to that\n-                                  // vtable (that is: \"ex has vtable\n-                                  // <vtable>\")\n-                                  if !is_early {\n-                                      insert_vtables(fcx, ex.id,\n-                                                     @~[@~[vtable]]);\n-                                  }\n-                              }\n-                              None => {\n-                                  fcx.tcx().sess.span_err(\n-                                      ex.span,\n-                                      fmt!(\"failed to find an implementation \\\n-                                            of trait %s for %s\",\n-                                           fcx.infcx().ty_to_str(target_ty),\n-                                           fcx.infcx().ty_to_str(mt.ty)));\n-                              }\n+\n+                          let param_bounds = ty::ParamBounds {\n+                              builtin_bounds: ty::EmptyBuiltinBounds(),\n+                              trait_bounds: ~[target_trait_ref]\n+                          };\n+                          let vtables =\n+                                lookup_vtables_for_param(&vcx,\n+                                                         location_info,\n+                                                         None,\n+                                                         &param_bounds,\n+                                                         mt.ty,\n+                                                         is_early);\n+\n+                          if !is_early {\n+                              insert_vtables(fcx, ex.id, @~[vtables]);\n                           }\n \n                           // Now, if this is &trait, we need to link the"}, {"sha": "a8a3701e4a5adbbd9249527e6f171ce9c6da05f2", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/293660d44347967cbb724d1ff94b90d635c2c64f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293660d44347967cbb724d1ff94b90d635c2c64f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=293660d44347967cbb724d1ff94b90d635c2c64f", "patch": "@@ -88,7 +88,7 @@ pub enum method_origin {\n     method_param(method_param),\n \n     // method invoked on a trait instance\n-    method_trait(ast::def_id, uint),\n+    method_object(method_object),\n \n }\n \n@@ -110,6 +110,26 @@ pub struct method_param {\n     bound_num: uint,\n }\n \n+// details for a method invoked with a receiver whose type is an object\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct method_object {\n+    // the (super)trait containing the method to be invoked\n+    trait_id: ast::def_id,\n+\n+    // the actual base trait id of the object\n+    object_trait_id: ast::def_id,\n+\n+    // index of the method to be invoked amongst the trait's methods\n+    method_num: uint,\n+\n+    // index into the actual runtime vtable.\n+    // the vtable is formed by concatenating together the method lists of\n+    // the base object trait and all supertraits;  this is the index into\n+    // that vtable\n+    real_index: uint,\n+}\n+\n+\n #[deriving(Clone)]\n pub struct method_map_entry {\n     // the type of the self parameter, which is not reflected in the fn type"}, {"sha": "0fdcac26ac878fd57af887706f1d85febcdfdf6d", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/293660d44347967cbb724d1ff94b90d635c2c64f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293660d44347967cbb724d1ff94b90d635c2c64f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=293660d44347967cbb724d1ff94b90d635c2c64f", "patch": "@@ -747,8 +747,8 @@ impl Repr for typeck::method_origin {\n             &typeck::method_param(ref p) => {\n                 p.repr(tcx)\n             }\n-            &typeck::method_trait(def_id, n) => {\n-                fmt!(\"method_trait(%s, %?)\", def_id.repr(tcx), n)\n+            &typeck::method_object(ref p) => {\n+                p.repr(tcx)\n             }\n         }\n     }\n@@ -764,6 +764,16 @@ impl Repr for typeck::method_param {\n     }\n }\n \n+impl Repr for typeck::method_object {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        fmt!(\"method_object(%s,%?,%?)\",\n+             self.trait_id.repr(tcx),\n+             self.method_num,\n+             self.real_index)\n+    }\n+}\n+\n+\n impl Repr for ty::RegionVid {\n     fn repr(&self, _tcx: ctxt) -> ~str {\n         fmt!(\"%?\", *self)"}, {"sha": "e716549d1e69fca017c0b83fd2efe823ce51911b", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/293660d44347967cbb724d1ff94b90d635c2c64f/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293660d44347967cbb724d1ff94b90d635c2c64f/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=293660d44347967cbb724d1ff94b90d635c2c64f", "patch": "@@ -38,7 +38,7 @@ impl Logger for StdErrLogger {\n         };\n \n         // Truncate the string\n-        let buf_bytes = 256;\n+        let buf_bytes = 2048;\n         if s.len() > buf_bytes {\n             let s = s.slice(0, buf_bytes) + \"[...]\";\n             print(s);"}]}