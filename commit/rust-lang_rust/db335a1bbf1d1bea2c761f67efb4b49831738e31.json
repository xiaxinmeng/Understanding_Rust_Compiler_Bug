{"sha": "db335a1bbf1d1bea2c761f67efb4b49831738e31", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiMzM1YTFiYmYxZDFiZWEyYzc2MWY2N2VmYjRiNDk4MzE3MzhlMzE=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-01-05T08:34:03Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-01-16T18:44:12Z"}, "message": "Add flyimport completion for trait assoc items", "tree": {"sha": "910963c004c460d2f0c322a0e643947aaf7132b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/910963c004c460d2f0c322a0e643947aaf7132b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db335a1bbf1d1bea2c761f67efb4b49831738e31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db335a1bbf1d1bea2c761f67efb4b49831738e31", "html_url": "https://github.com/rust-lang/rust/commit/db335a1bbf1d1bea2c761f67efb4b49831738e31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db335a1bbf1d1bea2c761f67efb4b49831738e31/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "html_url": "https://github.com/rust-lang/rust/commit/9a349f280ff1c6d0b57df80aa3d6720474e4b00a"}], "stats": {"total": 910, "additions": 662, "deletions": 248}, "files": [{"sha": "e93901cb3101f2b8f294e564fcb301913e5a176e", "filename": "crates/assists/src/handlers/auto_import.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=db335a1bbf1d1bea2c761f67efb4b49831738e31", "patch": "@@ -3,7 +3,7 @@ use ide_db::helpers::{\n     insert_use::{insert_use, ImportScope},\n     mod_path_to_ast,\n };\n-use syntax::ast;\n+use syntax::{ast, AstNode, SyntaxNode};\n \n use crate::{AssistContext, AssistId, AssistKind, Assists, GroupLabel};\n \n@@ -82,25 +82,16 @@ use crate::{AssistContext, AssistId, AssistKind, Assists, GroupLabel};\n // # pub mod std { pub mod collections { pub struct HashMap { } } }\n // ```\n pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let import_assets =\n-        if let Some(path_under_caret) = ctx.find_node_at_offset_with_descend::<ast::Path>() {\n-            ImportAssets::for_regular_path(path_under_caret, &ctx.sema)\n-        } else if let Some(method_under_caret) =\n-            ctx.find_node_at_offset_with_descend::<ast::MethodCallExpr>()\n-        {\n-            ImportAssets::for_method_call(method_under_caret, &ctx.sema)\n-        } else {\n-            None\n-        }?;\n-    let proposed_imports = import_assets.search_for_imports(&ctx.sema, &ctx.config.insert_use);\n+    let (import_assets, syntax_under_caret) = find_importable_node(ctx)?;\n+    let proposed_imports =\n+        import_assets.search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind);\n     if proposed_imports.is_empty() {\n         return None;\n     }\n \n-    let range = ctx.sema.original_range(import_assets.syntax_under_caret()).range;\n+    let range = ctx.sema.original_range(&syntax_under_caret).range;\n     let group = import_group_message(import_assets.import_candidate());\n-    let scope =\n-        ImportScope::find_insert_use_container(import_assets.syntax_under_caret(), &ctx.sema)?;\n+    let scope = ImportScope::find_insert_use_container(&syntax_under_caret, &ctx.sema)?;\n     for (import, _) in proposed_imports {\n         acc.add_group(\n             &group,\n@@ -117,14 +108,28 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     Some(())\n }\n \n+pub(super) fn find_importable_node(ctx: &AssistContext) -> Option<(ImportAssets, SyntaxNode)> {\n+    if let Some(path_under_caret) = ctx.find_node_at_offset_with_descend::<ast::Path>() {\n+        ImportAssets::for_exact_path(&path_under_caret, &ctx.sema)\n+            .zip(Some(path_under_caret.syntax().clone()))\n+    } else if let Some(method_under_caret) =\n+        ctx.find_node_at_offset_with_descend::<ast::MethodCallExpr>()\n+    {\n+        ImportAssets::for_method_call(&method_under_caret, &ctx.sema)\n+            .zip(Some(method_under_caret.syntax().clone()))\n+    } else {\n+        None\n+    }\n+}\n+\n fn import_group_message(import_candidate: &ImportCandidate) -> GroupLabel {\n     let name = match import_candidate {\n-        ImportCandidate::Path(candidate) => format!(\"Import {}\", &candidate.name),\n+        ImportCandidate::Path(candidate) => format!(\"Import {}\", candidate.name.text()),\n         ImportCandidate::TraitAssocItem(candidate) => {\n-            format!(\"Import a trait for item {}\", &candidate.name)\n+            format!(\"Import a trait for item {}\", candidate.name.text())\n         }\n         ImportCandidate::TraitMethod(candidate) => {\n-            format!(\"Import a trait for method {}\", &candidate.name)\n+            format!(\"Import a trait for method {}\", candidate.name.text())\n         }\n     };\n     GroupLabel(name)"}, {"sha": "af8a11d03556cfed271a1d66d548d2c4a11fbbf3", "filename": "crates/assists/src/handlers/qualify_path.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fassists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fassists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=db335a1bbf1d1bea2c761f67efb4b49831738e31", "patch": "@@ -1,10 +1,7 @@\n use std::iter;\n \n use hir::AsName;\n-use ide_db::helpers::{\n-    import_assets::{ImportAssets, ImportCandidate},\n-    mod_path_to_ast,\n-};\n+use ide_db::helpers::{import_assets::ImportCandidate, mod_path_to_ast};\n use ide_db::RootDatabase;\n use syntax::{\n     ast,\n@@ -18,6 +15,8 @@ use crate::{\n     AssistId, AssistKind, GroupLabel,\n };\n \n+use super::auto_import::find_importable_node;\n+\n // Assist: qualify_path\n //\n // If the name is unresolved, provides all possible qualified paths for it.\n@@ -36,47 +35,38 @@ use crate::{\n // # pub mod std { pub mod collections { pub struct HashMap { } } }\n // ```\n pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let import_assets =\n-        if let Some(path_under_caret) = ctx.find_node_at_offset_with_descend::<ast::Path>() {\n-            ImportAssets::for_regular_path(path_under_caret, &ctx.sema)\n-        } else if let Some(method_under_caret) =\n-            ctx.find_node_at_offset_with_descend::<ast::MethodCallExpr>()\n-        {\n-            ImportAssets::for_method_call(method_under_caret, &ctx.sema)\n-        } else {\n-            None\n-        }?;\n+    let (import_assets, syntax_under_caret) = find_importable_node(ctx)?;\n     let proposed_imports = import_assets.search_for_relative_paths(&ctx.sema);\n     if proposed_imports.is_empty() {\n         return None;\n     }\n \n     let candidate = import_assets.import_candidate();\n-    let range = ctx.sema.original_range(import_assets.syntax_under_caret()).range;\n+    let range = ctx.sema.original_range(&syntax_under_caret).range;\n \n     let qualify_candidate = match candidate {\n         ImportCandidate::Path(candidate) => {\n             if candidate.qualifier.is_some() {\n                 mark::hit!(qualify_path_qualifier_start);\n-                let path = ast::Path::cast(import_assets.syntax_under_caret().clone())?;\n+                let path = ast::Path::cast(syntax_under_caret)?;\n                 let (prev_segment, segment) = (path.qualifier()?.segment()?, path.segment()?);\n                 QualifyCandidate::QualifierStart(segment, prev_segment.generic_arg_list())\n             } else {\n                 mark::hit!(qualify_path_unqualified_name);\n-                let path = ast::Path::cast(import_assets.syntax_under_caret().clone())?;\n+                let path = ast::Path::cast(syntax_under_caret)?;\n                 let generics = path.segment()?.generic_arg_list();\n                 QualifyCandidate::UnqualifiedName(generics)\n             }\n         }\n         ImportCandidate::TraitAssocItem(_) => {\n             mark::hit!(qualify_path_trait_assoc_item);\n-            let path = ast::Path::cast(import_assets.syntax_under_caret().clone())?;\n+            let path = ast::Path::cast(syntax_under_caret)?;\n             let (qualifier, segment) = (path.qualifier()?, path.segment()?);\n             QualifyCandidate::TraitAssocItem(qualifier, segment)\n         }\n         ImportCandidate::TraitMethod(_) => {\n             mark::hit!(qualify_path_trait_method);\n-            let mcall_expr = ast::MethodCallExpr::cast(import_assets.syntax_under_caret().clone())?;\n+            let mcall_expr = ast::MethodCallExpr::cast(syntax_under_caret)?;\n             QualifyCandidate::TraitMethod(ctx.sema.db, mcall_expr)\n         }\n     };\n@@ -140,7 +130,7 @@ impl QualifyCandidate<'_> {\n         let generics =\n             mcall_expr.generic_arg_list().as_ref().map_or_else(String::new, ToString::to_string);\n         let arg_list = mcall_expr.arg_list().map(|arg_list| arg_list.args());\n-        let trait_ = item_as_trait(item)?;\n+        let trait_ = item_as_trait(db, item)?;\n         let method = find_trait_method(db, trait_, &trait_method_name)?;\n         if let Some(self_access) = method.self_param(db).map(|sp| sp.access(db)) {\n             let receiver = match self_access {\n@@ -179,19 +169,22 @@ fn find_trait_method(\n     }\n }\n \n-fn item_as_trait(item: hir::ItemInNs) -> Option<hir::Trait> {\n-    if let hir::ModuleDef::Trait(trait_) = hir::ModuleDef::from(item.as_module_def_id()?) {\n+fn item_as_trait(db: &RootDatabase, item: hir::ItemInNs) -> Option<hir::Trait> {\n+    let item_module_def = hir::ModuleDef::from(item.as_module_def_id()?);\n+\n+    if let hir::ModuleDef::Trait(trait_) = item_module_def {\n         Some(trait_)\n     } else {\n-        None\n+        item_module_def.as_assoc_item(db)?.containing_trait(db)\n     }\n }\n \n fn group_label(candidate: &ImportCandidate) -> GroupLabel {\n     let name = match candidate {\n         ImportCandidate::Path(it) => &it.name,\n         ImportCandidate::TraitAssocItem(it) | ImportCandidate::TraitMethod(it) => &it.name,\n-    };\n+    }\n+    .text();\n     GroupLabel(format!(\"Qualify {}\", name))\n }\n "}, {"sha": "9101e405c96f732dad7c10b50d1b0f7182757fa3", "filename": "crates/completion/src/completions/flyimport.rs", "status": "modified", "additions": 268, "deletions": 32, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=db335a1bbf1d1bea2c761f67efb4b49831738e31", "patch": "@@ -45,9 +45,8 @@\n //! Note that having this flag set to `true` does not guarantee that the feature is enabled: your client needs to have the corredponding\n //! capability enabled.\n \n-use either::Either;\n use hir::{ModPath, ScopeDef};\n-use ide_db::{helpers::insert_use::ImportScope, imports_locator};\n+use ide_db::helpers::{import_assets::ImportAssets, insert_use::ImportScope};\n use syntax::AstNode;\n use test_utils::mark;\n \n@@ -60,7 +59,7 @@ use crate::{\n use super::Completions;\n \n pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n-    if !ctx.config.enable_autoimport_completions {\n+    if !ctx.config.enable_imports_on_the_fly {\n         return None;\n     }\n     if ctx.attribute_under_caret.is_some() || ctx.mod_declaration_under_caret.is_some() {\n@@ -72,46 +71,56 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n     }\n     let _p = profile::span(\"import_on_the_fly\").detail(|| potential_import_name.to_string());\n \n-    let current_module = ctx.scope.module()?;\n-    let anchor = ctx.name_ref_syntax.as_ref()?;\n-    let import_scope = ImportScope::find_insert_use_container(anchor.syntax(), &ctx.sema)?;\n-\n+    let import_scope =\n+        ImportScope::find_insert_use_container(ctx.name_ref_syntax.as_ref()?.syntax(), &ctx.sema)?;\n     let user_input_lowercased = potential_import_name.to_lowercase();\n-    let mut all_mod_paths = imports_locator::find_similar_imports(\n-        &ctx.sema,\n-        ctx.krate?,\n-        Some(40),\n-        potential_import_name,\n-        true,\n-        true,\n-    )\n-    .filter_map(|import_candidate| {\n-        Some(match import_candidate {\n-            Either::Left(module_def) => {\n-                (current_module.find_use_path(ctx.db, module_def)?, ScopeDef::ModuleDef(module_def))\n-            }\n-            Either::Right(macro_def) => {\n-                (current_module.find_use_path(ctx.db, macro_def)?, ScopeDef::MacroDef(macro_def))\n-            }\n+    let mut all_mod_paths = import_assets(ctx, potential_import_name)?\n+        .search_for_relative_paths(&ctx.sema)\n+        .into_iter()\n+        .map(|(mod_path, item_in_ns)| {\n+            let scope_item = match item_in_ns {\n+                hir::ItemInNs::Types(id) => ScopeDef::ModuleDef(id.into()),\n+                hir::ItemInNs::Values(id) => ScopeDef::ModuleDef(id.into()),\n+                hir::ItemInNs::Macros(id) => ScopeDef::MacroDef(id.into()),\n+            };\n+            (mod_path, scope_item)\n         })\n-    })\n-    .filter(|(mod_path, _)| mod_path.len() > 1)\n-    .collect::<Vec<_>>();\n-\n+        .collect::<Vec<_>>();\n     all_mod_paths.sort_by_cached_key(|(mod_path, _)| {\n         compute_fuzzy_completion_order_key(mod_path, &user_input_lowercased)\n     });\n \n     acc.add_all(all_mod_paths.into_iter().filter_map(|(import_path, definition)| {\n-        render_resolution_with_import(\n-            RenderContext::new(ctx),\n-            ImportEdit { import_path, import_scope: import_scope.clone() },\n-            &definition,\n-        )\n+        let import_for_trait_assoc_item = match definition {\n+            ScopeDef::ModuleDef(module_def) => module_def\n+                .as_assoc_item(ctx.db)\n+                .and_then(|assoc| assoc.containing_trait(ctx.db))\n+                .is_some(),\n+            _ => false,\n+        };\n+        let import_edit = ImportEdit {\n+            import_path,\n+            import_scope: import_scope.clone(),\n+            import_for_trait_assoc_item,\n+        };\n+        render_resolution_with_import(RenderContext::new(ctx), import_edit, &definition)\n     }));\n     Some(())\n }\n \n+fn import_assets(ctx: &CompletionContext, fuzzy_name: String) -> Option<ImportAssets> {\n+    let current_module = ctx.scope.module()?;\n+    if let Some(dot_receiver) = &ctx.dot_receiver {\n+        ImportAssets::for_fuzzy_method_call(\n+            current_module,\n+            ctx.sema.type_of_expr(dot_receiver)?,\n+            fuzzy_name,\n+        )\n+    } else {\n+        ImportAssets::for_fuzzy_path(current_module, ctx.path_qual.clone(), fuzzy_name, &ctx.sema)\n+    }\n+}\n+\n fn compute_fuzzy_completion_order_key(\n     proposed_mod_path: &ModPath,\n     user_input_lowercased: &str,\n@@ -258,6 +267,176 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn trait_function_fuzzy_completion() {\n+        let fixture = r#\"\n+        //- /lib.rs crate:dep\n+        pub mod test_mod {\n+            pub trait TestTrait {\n+                const SPECIAL_CONST: u8;\n+                type HumbleType;\n+                fn weird_function();\n+                fn random_method(&self);\n+            }\n+            pub struct TestStruct {}\n+            impl TestTrait for TestStruct {\n+                const SPECIAL_CONST: u8 = 42;\n+                type HumbleType = ();\n+                fn weird_function() {}\n+                fn random_method(&self) {}\n+            }\n+        }\n+\n+        //- /main.rs crate:main deps:dep\n+        fn main() {\n+            dep::test_mod::TestStruct::wei$0\n+        }\n+        \"#;\n+\n+        check(\n+            fixture,\n+            expect![[r#\"\n+            fn weird_function() (dep::test_mod::TestTrait) fn weird_function()\n+        \"#]],\n+        );\n+\n+        check_edit(\n+            \"weird_function\",\n+            fixture,\n+            r#\"\n+use dep::test_mod::TestTrait;\n+\n+fn main() {\n+    dep::test_mod::TestStruct::weird_function()$0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn trait_const_fuzzy_completion() {\n+        let fixture = r#\"\n+        //- /lib.rs crate:dep\n+        pub mod test_mod {\n+            pub trait TestTrait {\n+                const SPECIAL_CONST: u8;\n+                type HumbleType;\n+                fn weird_function();\n+                fn random_method(&self);\n+            }\n+            pub struct TestStruct {}\n+            impl TestTrait for TestStruct {\n+                const SPECIAL_CONST: u8 = 42;\n+                type HumbleType = ();\n+                fn weird_function() {}\n+                fn random_method(&self) {}\n+            }\n+        }\n+\n+        //- /main.rs crate:main deps:dep\n+        fn main() {\n+            dep::test_mod::TestStruct::spe$0\n+        }\n+        \"#;\n+\n+        check(\n+            fixture,\n+            expect![[r#\"\n+            ct SPECIAL_CONST (dep::test_mod::TestTrait)\n+        \"#]],\n+        );\n+\n+        check_edit(\n+            \"SPECIAL_CONST\",\n+            fixture,\n+            r#\"\n+use dep::test_mod::TestTrait;\n+\n+fn main() {\n+    dep::test_mod::TestStruct::SPECIAL_CONST\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn trait_method_fuzzy_completion() {\n+        let fixture = r#\"\n+        //- /lib.rs crate:dep\n+        pub mod test_mod {\n+            pub trait TestTrait {\n+                const SPECIAL_CONST: u8;\n+                type HumbleType;\n+                fn weird_function();\n+                fn random_method(&self);\n+            }\n+            pub struct TestStruct {}\n+            impl TestTrait for TestStruct {\n+                const SPECIAL_CONST: u8 = 42;\n+                type HumbleType = ();\n+                fn weird_function() {}\n+                fn random_method(&self) {}\n+            }\n+        }\n+\n+        //- /main.rs crate:main deps:dep\n+        fn main() {\n+            let test_struct = dep::test_mod::TestStruct {};\n+            test_struct.ran$0\n+        }\n+        \"#;\n+\n+        check(\n+            fixture,\n+            expect![[r#\"\n+            me random_method() (dep::test_mod::TestTrait) fn random_method(&self)\n+        \"#]],\n+        );\n+\n+        check_edit(\n+            \"random_method\",\n+            fixture,\n+            r#\"\n+use dep::test_mod::TestTrait;\n+\n+fn main() {\n+    let test_struct = dep::test_mod::TestStruct {};\n+    test_struct.random_method()$0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_trait_type_fuzzy_completion() {\n+        check(\n+            r#\"\n+//- /lib.rs crate:dep\n+pub mod test_mod {\n+    pub trait TestTrait {\n+        const SPECIAL_CONST: u8;\n+        type HumbleType;\n+        fn weird_function();\n+        fn random_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        const SPECIAL_CONST: u8 = 42;\n+        type HumbleType = ();\n+        fn weird_function() {}\n+        fn random_method(&self) {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    dep::test_mod::TestStruct::hum$0\n+}\n+\"#,\n+            expect![[r#\"\"#]],\n+        );\n+    }\n+\n     #[test]\n     fn does_not_propose_names_in_scope() {\n         check(\n@@ -288,4 +467,61 @@ fn main() {\n             expect![[r#\"\"#]],\n         );\n     }\n+\n+    #[test]\n+    fn does_not_propose_traits_in_scope() {\n+        check(\n+            r#\"\n+//- /lib.rs crate:dep\n+pub mod test_mod {\n+    pub trait TestTrait {\n+        const SPECIAL_CONST: u8;\n+        type HumbleType;\n+        fn weird_function();\n+        fn random_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        const SPECIAL_CONST: u8 = 42;\n+        type HumbleType = ();\n+        fn weird_function() {}\n+        fn random_method(&self) {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:dep\n+use dep::test_mod::{TestStruct, TestTrait};\n+fn main() {\n+    dep::test_mod::TestStruct::hum$0\n+}\n+\"#,\n+            expect![[r#\"\"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn blanket_trait_impl_import() {\n+        check(\n+            r#\"\n+//- /lib.rs crate:dep\n+pub mod test_mod {\n+    pub struct TestStruct {}\n+    pub trait TestTrait {\n+        fn another_function();\n+    }\n+    impl<T> TestTrait for T {\n+        fn another_function() {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    dep::test_mod::TestStruct::ano$0\n+}\n+\"#,\n+            expect![[r#\"\n+                fn another_function() (dep::test_mod::TestTrait) fn another_function()\n+            \"#]],\n+        );\n+    }\n }"}, {"sha": "d70ed6c1cde518b06424e335715e3e80111508a9", "filename": "crates/completion/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fcompletion%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fcompletion%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fconfig.rs?ref=db335a1bbf1d1bea2c761f67efb4b49831738e31", "patch": "@@ -9,7 +9,7 @@ use ide_db::helpers::{insert_use::InsertUseConfig, SnippetCap};\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct CompletionConfig {\n     pub enable_postfix_completions: bool,\n-    pub enable_autoimport_completions: bool,\n+    pub enable_imports_on_the_fly: bool,\n     pub add_call_parenthesis: bool,\n     pub add_call_argument_snippets: bool,\n     pub snippet_cap: Option<SnippetCap>,"}, {"sha": "378bd2c70b54babc93ff2848642c8c195bdfc423", "filename": "crates/completion/src/item.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fcompletion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fcompletion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fitem.rs?ref=db335a1bbf1d1bea2c761f67efb4b49831738e31", "patch": "@@ -270,6 +270,7 @@ impl CompletionItem {\n pub struct ImportEdit {\n     pub import_path: ModPath,\n     pub import_scope: ImportScope,\n+    pub import_for_trait_assoc_item: bool,\n }\n \n impl ImportEdit {\n@@ -321,17 +322,19 @@ impl Builder {\n         let mut insert_text = self.insert_text;\n \n         if let Some(import_to_add) = self.import_to_add.as_ref() {\n-            let mut import_path_without_last_segment = import_to_add.import_path.to_owned();\n-            let _ = import_path_without_last_segment.segments.pop();\n-\n-            if !import_path_without_last_segment.segments.is_empty() {\n-                if lookup.is_none() {\n-                    lookup = Some(label.clone());\n-                }\n-                if insert_text.is_none() {\n-                    insert_text = Some(label.clone());\n+            if import_to_add.import_for_trait_assoc_item {\n+                lookup = lookup.or_else(|| Some(label.clone()));\n+                insert_text = insert_text.or_else(|| Some(label.clone()));\n+                label = format!(\"{} ({})\", label, import_to_add.import_path);\n+            } else {\n+                let mut import_path_without_last_segment = import_to_add.import_path.to_owned();\n+                let _ = import_path_without_last_segment.segments.pop();\n+\n+                if !import_path_without_last_segment.segments.is_empty() {\n+                    lookup = lookup.or_else(|| Some(label.clone()));\n+                    insert_text = insert_text.or_else(|| Some(label.clone()));\n+                    label = format!(\"{}::{}\", import_path_without_last_segment, label);\n                 }\n-                label = format!(\"{}::{}\", import_path_without_last_segment, label);\n             }\n         }\n "}, {"sha": "56ec13e8cd8c9168957b30d3c38faaa980ec9f6c", "filename": "crates/completion/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fcompletion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fcompletion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Flib.rs?ref=db335a1bbf1d1bea2c761f67efb4b49831738e31", "patch": "@@ -139,6 +139,7 @@ pub fn resolve_completion_edits(\n     position: FilePosition,\n     full_import_path: &str,\n     imported_name: String,\n+    import_for_trait_assoc_item: bool,\n ) -> Option<Vec<TextEdit>> {\n     let ctx = CompletionContext::new(db, position, config)?;\n     let anchor = ctx.name_ref_syntax.as_ref()?;\n@@ -154,7 +155,7 @@ pub fn resolve_completion_edits(\n         })\n         .find(|mod_path| mod_path.to_string() == full_import_path)?;\n \n-    ImportEdit { import_path, import_scope }\n+    ImportEdit { import_path, import_scope, import_for_trait_assoc_item }\n         .to_text_edit(config.insert_use.merge)\n         .map(|edit| vec![edit])\n }"}, {"sha": "4b3c9702a4440e5e232b194cd7583c9e04bcdc1e", "filename": "crates/completion/src/render.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fcompletion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fcompletion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender.rs?ref=db335a1bbf1d1bea2c761f67efb4b49831738e31", "patch": "@@ -10,7 +10,7 @@ pub(crate) mod type_alias;\n \n mod builder_ext;\n \n-use hir::{Documentation, HasAttrs, HirDisplay, Mutability, ScopeDef, Type};\n+use hir::{Documentation, HasAttrs, HirDisplay, ModuleDef, Mutability, ScopeDef, Type};\n use ide_db::{helpers::SnippetCap, RootDatabase};\n use syntax::TextRange;\n use test_utils::mark;\n@@ -51,16 +51,16 @@ pub(crate) fn render_resolution_with_import<'a>(\n     import_edit: ImportEdit,\n     resolution: &ScopeDef,\n ) -> Option<CompletionItem> {\n-    Render::new(ctx)\n-        .render_resolution(\n-            import_edit.import_path.segments.last()?.to_string(),\n-            Some(import_edit),\n-            resolution,\n-        )\n-        .map(|mut item| {\n-            item.completion_kind = CompletionKind::Magic;\n-            item\n-        })\n+    let local_name = match resolution {\n+        ScopeDef::ModuleDef(ModuleDef::Function(f)) => f.name(ctx.completion.db).to_string(),\n+        ScopeDef::ModuleDef(ModuleDef::Const(c)) => c.name(ctx.completion.db)?.to_string(),\n+        ScopeDef::ModuleDef(ModuleDef::TypeAlias(t)) => t.name(ctx.completion.db).to_string(),\n+        _ => import_edit.import_path.segments.last()?.to_string(),\n+    };\n+    Render::new(ctx).render_resolution(local_name, Some(import_edit), resolution).map(|mut item| {\n+        item.completion_kind = CompletionKind::Magic;\n+        item\n+    })\n }\n \n /// Interface for data and methods required for items rendering."}, {"sha": "3faf861b9af024844ffb4ffceeb218f371ec57a4", "filename": "crates/completion/src/test_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fcompletion%2Fsrc%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fcompletion%2Fsrc%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Ftest_utils.rs?ref=db335a1bbf1d1bea2c761f67efb4b49831738e31", "patch": "@@ -18,7 +18,7 @@ use crate::{item::CompletionKind, CompletionConfig, CompletionItem};\n \n pub(crate) const TEST_CONFIG: CompletionConfig = CompletionConfig {\n     enable_postfix_completions: true,\n-    enable_autoimport_completions: true,\n+    enable_imports_on_the_fly: true,\n     add_call_parenthesis: true,\n     add_call_argument_snippets: true,\n     snippet_cap: SnippetCap::new(true),"}, {"sha": "2950f08b8f0077e21034fa3b0eb204ef5b8a74f2", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=db335a1bbf1d1bea2c761f67efb4b49831738e31", "patch": "@@ -272,6 +272,15 @@ impl ModuleDef {\n \n         hir_ty::diagnostics::validate_module_item(db, module.id.krate, id, sink)\n     }\n+\n+    pub fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem> {\n+        match self {\n+            ModuleDef::Function(f) => f.as_assoc_item(db),\n+            ModuleDef::Const(c) => c.as_assoc_item(db),\n+            ModuleDef::TypeAlias(t) => t.as_assoc_item(db),\n+            _ => None,\n+        }\n+    }\n }\n \n impl Module {\n@@ -1091,6 +1100,13 @@ impl AssocItem {\n             AssocContainerId::ContainerId(_) => panic!(\"invalid AssocItem\"),\n         }\n     }\n+\n+    pub fn containing_trait(self, db: &dyn HirDatabase) -> Option<Trait> {\n+        match self.container(db) {\n+            AssocItemContainer::Trait(t) => Some(t),\n+            _ => None,\n+        }\n+    }\n }\n \n impl HasVisibility for AssocItem {"}, {"sha": "fac0de90cd67ad604738a8334abee64f39a5b569", "filename": "crates/hir_def/src/import_map.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fimport_map.rs?ref=db335a1bbf1d1bea2c761f67efb4b49831738e31", "patch": "@@ -263,6 +263,7 @@ pub enum ImportKind {\n     Trait,\n     TypeAlias,\n     BuiltinType,\n+    AssociatedItem,\n }\n \n /// A way to match import map contents against the search query.\n@@ -282,6 +283,7 @@ pub struct Query {\n     query: String,\n     lowercased: String,\n     name_only: bool,\n+    assoc_items_only: bool,\n     search_mode: SearchMode,\n     case_sensitive: bool,\n     limit: usize,\n@@ -295,6 +297,7 @@ impl Query {\n             query,\n             lowercased,\n             name_only: false,\n+            assoc_items_only: false,\n             search_mode: SearchMode::Contains,\n             case_sensitive: false,\n             limit: usize::max_value(),\n@@ -309,6 +312,11 @@ impl Query {\n         Self { name_only: true, ..self }\n     }\n \n+    /// Matches only the entries that are associated items, ignoring the rest.\n+    pub fn assoc_items_only(self) -> Self {\n+        Self { assoc_items_only: true, ..self }\n+    }\n+\n     /// Specifies the way to search for the entries using the query.\n     pub fn search_mode(self, search_mode: SearchMode) -> Self {\n         Self { search_mode, ..self }\n@@ -331,6 +339,14 @@ impl Query {\n     }\n \n     fn import_matches(&self, import: &ImportInfo, enforce_lowercase: bool) -> bool {\n+        if import.is_trait_assoc_item {\n+            if self.exclude_import_kinds.contains(&ImportKind::AssociatedItem) {\n+                return false;\n+            }\n+        } else if self.assoc_items_only {\n+            return false;\n+        }\n+\n         let mut input = if import.is_trait_assoc_item || self.name_only {\n             import.path.segments.last().unwrap().to_string()\n         } else {\n@@ -813,6 +829,56 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn assoc_items_filtering() {\n+        let ra_fixture = r#\"\n+        //- /main.rs crate:main deps:dep\n+        //- /dep.rs crate:dep\n+        pub mod fmt {\n+            pub trait Display {\n+                type FmtTypeAlias;\n+                const FMT_CONST: bool;\n+\n+                fn format_function();\n+                fn format_method(&self);\n+            }\n+        }\n+    \"#;\n+\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"fmt\".to_string()).search_mode(SearchMode::Fuzzy).assoc_items_only(),\n+            expect![[r#\"\n+            dep::fmt::Display::FMT_CONST (a)\n+            dep::fmt::Display::format_function (a)\n+            dep::fmt::Display::format_method (a)\n+        \"#]],\n+        );\n+\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"fmt\".to_string())\n+                .search_mode(SearchMode::Fuzzy)\n+                .exclude_import_kind(ImportKind::AssociatedItem),\n+            expect![[r#\"\n+            dep::fmt (t)\n+            dep::fmt::Display (t)\n+        \"#]],\n+        );\n+\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"fmt\".to_string())\n+                .search_mode(SearchMode::Fuzzy)\n+                .assoc_items_only()\n+                .exclude_import_kind(ImportKind::AssociatedItem),\n+            expect![[r#\"\"#]],\n+        );\n+    }\n+\n     #[test]\n     fn search_mode() {\n         let ra_fixture = r#\""}, {"sha": "1f08d7810388c80517c3ecf52b33305422140f01", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=db335a1bbf1d1bea2c761f67efb4b49831738e31", "patch": "@@ -438,10 +438,10 @@ fn get_symbol_fragment(db: &dyn HirDatabase, field_or_assoc: &FieldOrAssocItem)\n         FieldOrAssocItem::Field(field) => format!(\"#structfield.{}\", field.name(db)),\n         FieldOrAssocItem::AssocItem(assoc) => match assoc {\n             AssocItem::Function(function) => {\n-                let is_trait_method = matches!(\n-                    function.as_assoc_item(db).map(|assoc| assoc.container(db)),\n-                    Some(AssocItemContainer::Trait(..))\n-                );\n+                let is_trait_method = function\n+                    .as_assoc_item(db)\n+                    .and_then(|assoc| assoc.containing_trait(db))\n+                    .is_some();\n                 // This distinction may get more complicated when specialization is available.\n                 // Rustdoc makes this decision based on whether a method 'has defaultness'.\n                 // Currently this is only the case for provided trait methods."}, {"sha": "07f52613f52d2bd0c058d331315a32b8e88444d0", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=db335a1bbf1d1bea2c761f67efb4b49831738e31", "patch": "@@ -481,6 +481,7 @@ impl Analysis {\n         position: FilePosition,\n         full_import_path: &str,\n         imported_name: String,\n+        import_for_trait_assoc_item: bool,\n     ) -> Cancelable<Vec<TextEdit>> {\n         Ok(self\n             .with_db(|db| {\n@@ -490,6 +491,7 @@ impl Analysis {\n                     position,\n                     full_import_path,\n                     imported_name,\n+                    import_for_trait_assoc_item,\n                 )\n             })?\n             .unwrap_or_default())"}, {"sha": "e284220c1e51903fd7fb4c2282c7271c58f1942a", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 186, "deletions": 100, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=db335a1bbf1d1bea2c761f67efb4b49831738e31", "patch": "@@ -1,12 +1,13 @@\n //! Look up accessible paths for items.\n use either::Either;\n-use hir::{AsAssocItem, AssocItemContainer, ModuleDef, Semantics};\n+use hir::{AsAssocItem, AssocItem, Module, ModuleDef, PrefixKind, Semantics};\n use rustc_hash::FxHashSet;\n-use syntax::{ast, AstNode, SyntaxNode};\n+use syntax::{ast, AstNode};\n \n-use crate::{imports_locator, RootDatabase};\n-\n-use super::insert_use::InsertUseConfig;\n+use crate::{\n+    imports_locator::{self, AssocItemSearch},\n+    RootDatabase,\n+};\n \n #[derive(Debug)]\n pub enum ImportCandidate {\n@@ -24,86 +25,141 @@ pub enum ImportCandidate {\n \n #[derive(Debug)]\n pub struct TraitImportCandidate {\n-    pub ty: hir::Type,\n-    pub name: ast::NameRef,\n+    pub receiver_ty: hir::Type,\n+    pub name: NameToImport,\n }\n \n #[derive(Debug)]\n pub struct PathImportCandidate {\n     pub qualifier: Option<ast::Path>,\n-    pub name: ast::NameRef,\n+    pub name: NameToImport,\n+}\n+\n+#[derive(Debug)]\n+pub enum NameToImport {\n+    Exact(String),\n+    Fuzzy(String),\n+}\n+\n+impl NameToImport {\n+    pub fn text(&self) -> &str {\n+        match self {\n+            NameToImport::Exact(text) => text.as_str(),\n+            NameToImport::Fuzzy(text) => text.as_str(),\n+        }\n+    }\n }\n \n #[derive(Debug)]\n pub struct ImportAssets {\n     import_candidate: ImportCandidate,\n-    module_with_name_to_import: hir::Module,\n-    syntax_under_caret: SyntaxNode,\n+    module_with_candidate: hir::Module,\n }\n \n impl ImportAssets {\n     pub fn for_method_call(\n-        method_call: ast::MethodCallExpr,\n+        method_call: &ast::MethodCallExpr,\n         sema: &Semantics<RootDatabase>,\n     ) -> Option<Self> {\n-        let syntax_under_caret = method_call.syntax().to_owned();\n-        let module_with_name_to_import = sema.scope(&syntax_under_caret).module()?;\n         Some(Self {\n-            import_candidate: ImportCandidate::for_method_call(sema, &method_call)?,\n-            module_with_name_to_import,\n-            syntax_under_caret,\n+            import_candidate: ImportCandidate::for_method_call(sema, method_call)?,\n+            module_with_candidate: sema.scope(method_call.syntax()).module()?,\n         })\n     }\n \n-    pub fn for_regular_path(\n-        path_under_caret: ast::Path,\n+    pub fn for_exact_path(\n+        fully_qualified_path: &ast::Path,\n         sema: &Semantics<RootDatabase>,\n     ) -> Option<Self> {\n-        let syntax_under_caret = path_under_caret.syntax().to_owned();\n+        let syntax_under_caret = fully_qualified_path.syntax();\n         if syntax_under_caret.ancestors().find_map(ast::Use::cast).is_some() {\n             return None;\n         }\n-\n-        let module_with_name_to_import = sema.scope(&syntax_under_caret).module()?;\n         Some(Self {\n-            import_candidate: ImportCandidate::for_regular_path(sema, &path_under_caret)?,\n-            module_with_name_to_import,\n-            syntax_under_caret,\n+            import_candidate: ImportCandidate::for_regular_path(sema, fully_qualified_path)?,\n+            module_with_candidate: sema.scope(syntax_under_caret).module()?,\n+        })\n+    }\n+\n+    pub fn for_fuzzy_path(\n+        module_with_path: Module,\n+        qualifier: Option<ast::Path>,\n+        fuzzy_name: String,\n+        sema: &Semantics<RootDatabase>,\n+    ) -> Option<Self> {\n+        Some(match qualifier {\n+            Some(qualifier) => {\n+                let qualifier_resolution = sema.resolve_path(&qualifier)?;\n+                match qualifier_resolution {\n+                    hir::PathResolution::Def(hir::ModuleDef::Adt(assoc_item_path)) => Self {\n+                        import_candidate: ImportCandidate::TraitAssocItem(TraitImportCandidate {\n+                            receiver_ty: assoc_item_path.ty(sema.db),\n+                            name: NameToImport::Fuzzy(fuzzy_name),\n+                        }),\n+                        module_with_candidate: module_with_path,\n+                    },\n+                    _ => Self {\n+                        import_candidate: ImportCandidate::Path(PathImportCandidate {\n+                            qualifier: Some(qualifier),\n+                            name: NameToImport::Fuzzy(fuzzy_name),\n+                        }),\n+                        module_with_candidate: module_with_path,\n+                    },\n+                }\n+            }\n+            None => Self {\n+                import_candidate: ImportCandidate::Path(PathImportCandidate {\n+                    qualifier: None,\n+                    name: NameToImport::Fuzzy(fuzzy_name),\n+                }),\n+                module_with_candidate: module_with_path,\n+            },\n         })\n     }\n \n-    pub fn syntax_under_caret(&self) -> &SyntaxNode {\n-        &self.syntax_under_caret\n+    pub fn for_fuzzy_method_call(\n+        module_with_method_call: Module,\n+        receiver_ty: hir::Type,\n+        fuzzy_method_name: String,\n+    ) -> Option<Self> {\n+        Some(Self {\n+            import_candidate: ImportCandidate::TraitMethod(TraitImportCandidate {\n+                receiver_ty,\n+                name: NameToImport::Fuzzy(fuzzy_method_name),\n+            }),\n+            module_with_candidate: module_with_method_call,\n+        })\n     }\n+}\n \n+impl ImportAssets {\n     pub fn import_candidate(&self) -> &ImportCandidate {\n         &self.import_candidate\n     }\n \n-    fn get_search_query(&self) -> &str {\n+    fn name_to_import(&self) -> &NameToImport {\n         match &self.import_candidate {\n-            ImportCandidate::Path(candidate) => candidate.name.text(),\n+            ImportCandidate::Path(candidate) => &candidate.name,\n             ImportCandidate::TraitAssocItem(candidate)\n-            | ImportCandidate::TraitMethod(candidate) => candidate.name.text(),\n+            | ImportCandidate::TraitMethod(candidate) => &candidate.name,\n         }\n     }\n \n     pub fn search_for_imports(\n         &self,\n         sema: &Semantics<RootDatabase>,\n-        config: &InsertUseConfig,\n+        prefix_kind: PrefixKind,\n     ) -> Vec<(hir::ModPath, hir::ItemInNs)> {\n-        let _p = profile::span(\"import_assists::search_for_imports\");\n-        self.search_for(sema, Some(config.prefix_kind))\n+        let _p = profile::span(\"import_assets::search_for_imports\");\n+        self.search_for(sema, Some(prefix_kind))\n     }\n \n     /// This may return non-absolute paths if a part of the returned path is already imported into scope.\n-    #[allow(dead_code)]\n     pub fn search_for_relative_paths(\n         &self,\n         sema: &Semantics<RootDatabase>,\n     ) -> Vec<(hir::ModPath, hir::ItemInNs)> {\n-        let _p = profile::span(\"import_assists::search_for_relative_paths\");\n+        let _p = profile::span(\"import_assets::search_for_relative_paths\");\n         self.search_for(sema, None)\n     }\n \n@@ -114,60 +170,56 @@ impl ImportAssets {\n     ) -> Vec<(hir::ModPath, hir::ItemInNs)> {\n         let db = sema.db;\n         let mut trait_candidates = FxHashSet::default();\n-        let current_crate = self.module_with_name_to_import.krate();\n+        let current_crate = self.module_with_candidate.krate();\n \n         let filter = |candidate: Either<hir::ModuleDef, hir::MacroDef>| {\n             trait_candidates.clear();\n             match &self.import_candidate {\n                 ImportCandidate::TraitAssocItem(trait_candidate) => {\n-                    let located_assoc_item = match candidate {\n-                        Either::Left(ModuleDef::Function(located_function)) => {\n-                            located_function.as_assoc_item(db)\n-                        }\n-                        Either::Left(ModuleDef::Const(located_const)) => {\n-                            located_const.as_assoc_item(db)\n-                        }\n+                    let canidate_assoc_item = match candidate {\n+                        Either::Left(module_def) => module_def.as_assoc_item(db),\n                         _ => None,\n-                    }\n-                    .map(|assoc| assoc.container(db))\n-                    .and_then(Self::assoc_to_trait)?;\n-\n-                    trait_candidates.insert(located_assoc_item.into());\n+                    }?;\n+                    trait_candidates.insert(canidate_assoc_item.containing_trait(db)?.into());\n \n                     trait_candidate\n-                        .ty\n+                        .receiver_ty\n                         .iterate_path_candidates(\n                             db,\n                             current_crate,\n                             &trait_candidates,\n                             None,\n-                            |_, assoc| Self::assoc_to_trait(assoc.container(db)),\n+                            |_, assoc| {\n+                                if canidate_assoc_item == assoc {\n+                                    Some(assoc_to_module_def(assoc))\n+                                } else {\n+                                    None\n+                                }\n+                            },\n                         )\n-                        .map(ModuleDef::from)\n                         .map(Either::Left)\n                 }\n                 ImportCandidate::TraitMethod(trait_candidate) => {\n-                    let located_assoc_item =\n-                        if let Either::Left(ModuleDef::Function(located_function)) = candidate {\n-                            located_function\n-                                .as_assoc_item(db)\n-                                .map(|assoc| assoc.container(db))\n-                                .and_then(Self::assoc_to_trait)\n-                        } else {\n-                            None\n-                        }?;\n-\n-                    trait_candidates.insert(located_assoc_item.into());\n+                    let canidate_assoc_item = match candidate {\n+                        Either::Left(module_def) => module_def.as_assoc_item(db),\n+                        _ => None,\n+                    }?;\n+                    trait_candidates.insert(canidate_assoc_item.containing_trait(db)?.into());\n \n                     trait_candidate\n-                        .ty\n+                        .receiver_ty\n                         .iterate_method_candidates(\n                             db,\n                             current_crate,\n                             &trait_candidates,\n                             None,\n                             |_, function| {\n-                                Self::assoc_to_trait(function.as_assoc_item(db)?.container(db))\n+                                let assoc = function.as_assoc_item(db)?;\n+                                if canidate_assoc_item == assoc {\n+                                    Some(assoc_to_module_def(assoc))\n+                                } else {\n+                                    None\n+                                }\n                             },\n                         )\n                         .map(ModuleDef::from)\n@@ -177,34 +229,69 @@ impl ImportAssets {\n             }\n         };\n \n-        let mut res = imports_locator::find_exact_imports(\n-            sema,\n-            current_crate,\n-            self.get_search_query().to_string(),\n-        )\n-        .filter_map(filter)\n-        .filter_map(|candidate| {\n-            let item: hir::ItemInNs = candidate.either(Into::into, Into::into);\n-            if let Some(prefix_kind) = prefixed {\n-                self.module_with_name_to_import.find_use_path_prefixed(db, item, prefix_kind)\n-            } else {\n-                self.module_with_name_to_import.find_use_path(db, item)\n+        let unfiltered_imports = match self.name_to_import() {\n+            NameToImport::Exact(exact_name) => {\n+                imports_locator::find_exact_imports(sema, current_crate, exact_name.clone())\n             }\n-            .map(|path| (path, item))\n-        })\n-        .filter(|(use_path, _)| use_path.len() > 1)\n-        .take(20)\n-        .collect::<Vec<_>>();\n-        res.sort_by_key(|(path, _)| path.clone());\n+            // FIXME: ideally, we should avoid using `fst` for seacrhing trait imports for assoc items:\n+            // instead, we need to look up all trait impls for a certain struct and search through them only\n+            // see https://github.com/rust-analyzer/rust-analyzer/pull/7293#issuecomment-761585032\n+            // and https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0/topic/Blanket.20trait.20impls.20lookup\n+            // for the details\n+            NameToImport::Fuzzy(fuzzy_name) => imports_locator::find_similar_imports(\n+                sema,\n+                current_crate,\n+                fuzzy_name.clone(),\n+                match self.import_candidate {\n+                    ImportCandidate::TraitAssocItem(_) | ImportCandidate::TraitMethod(_) => {\n+                        AssocItemSearch::AssocItemsOnly\n+                    }\n+                    _ => AssocItemSearch::Exclude,\n+                },\n+            ),\n+        };\n+\n+        let mut res = unfiltered_imports\n+            .filter_map(filter)\n+            .filter_map(|candidate| {\n+                let item: hir::ItemInNs = candidate.clone().either(Into::into, Into::into);\n+\n+                let item_to_search = match self.import_candidate {\n+                    ImportCandidate::TraitAssocItem(_) | ImportCandidate::TraitMethod(_) => {\n+                        let canidate_trait = match candidate {\n+                            Either::Left(module_def) => {\n+                                module_def.as_assoc_item(db)?.containing_trait(db)\n+                            }\n+                            _ => None,\n+                        }?;\n+                        ModuleDef::from(canidate_trait).into()\n+                    }\n+                    _ => item,\n+                };\n+\n+                if let Some(prefix_kind) = prefixed {\n+                    self.module_with_candidate.find_use_path_prefixed(\n+                        db,\n+                        item_to_search,\n+                        prefix_kind,\n+                    )\n+                } else {\n+                    self.module_with_candidate.find_use_path(db, item_to_search)\n+                }\n+                .map(|path| (path, item))\n+            })\n+            .filter(|(use_path, _)| use_path.len() > 1)\n+            .collect::<Vec<_>>();\n+        res.sort_by_cached_key(|(path, _)| path.clone());\n         res\n     }\n+}\n \n-    fn assoc_to_trait(assoc: AssocItemContainer) -> Option<hir::Trait> {\n-        if let AssocItemContainer::Trait(extracted_trait) = assoc {\n-            Some(extracted_trait)\n-        } else {\n-            None\n-        }\n+fn assoc_to_module_def(assoc: AssocItem) -> ModuleDef {\n+    match assoc {\n+        AssocItem::Function(f) => f.into(),\n+        AssocItem::Const(c) => c.into(),\n+        AssocItem::TypeAlias(t) => t.into(),\n     }\n }\n \n@@ -216,22 +303,19 @@ impl ImportCandidate {\n         match sema.resolve_method_call(method_call) {\n             Some(_) => None,\n             None => Some(Self::TraitMethod(TraitImportCandidate {\n-                ty: sema.type_of_expr(&method_call.receiver()?)?,\n-                name: method_call.name_ref()?,\n+                receiver_ty: sema.type_of_expr(&method_call.receiver()?)?,\n+                name: NameToImport::Exact(method_call.name_ref()?.to_string()),\n             })),\n         }\n     }\n \n-    fn for_regular_path(\n-        sema: &Semantics<RootDatabase>,\n-        path_under_caret: &ast::Path,\n-    ) -> Option<Self> {\n-        if sema.resolve_path(path_under_caret).is_some() {\n+    fn for_regular_path(sema: &Semantics<RootDatabase>, path: &ast::Path) -> Option<Self> {\n+        if sema.resolve_path(path).is_some() {\n             return None;\n         }\n \n-        let segment = path_under_caret.segment()?;\n-        let candidate = if let Some(qualifier) = path_under_caret.qualifier() {\n+        let segment = path.segment()?;\n+        let candidate = if let Some(qualifier) = path.qualifier() {\n             let qualifier_start = qualifier.syntax().descendants().find_map(ast::NameRef::cast)?;\n             let qualifier_start_path =\n                 qualifier_start.syntax().ancestors().find_map(ast::Path::cast)?;\n@@ -244,22 +328,24 @@ impl ImportCandidate {\n                 match qualifier_resolution {\n                     hir::PathResolution::Def(hir::ModuleDef::Adt(assoc_item_path)) => {\n                         ImportCandidate::TraitAssocItem(TraitImportCandidate {\n-                            ty: assoc_item_path.ty(sema.db),\n-                            name: segment.name_ref()?,\n+                            receiver_ty: assoc_item_path.ty(sema.db),\n+                            name: NameToImport::Exact(segment.name_ref()?.to_string()),\n                         })\n                     }\n                     _ => return None,\n                 }\n             } else {\n                 ImportCandidate::Path(PathImportCandidate {\n                     qualifier: Some(qualifier),\n-                    name: qualifier_start,\n+                    name: NameToImport::Exact(qualifier_start.to_string()),\n                 })\n             }\n         } else {\n             ImportCandidate::Path(PathImportCandidate {\n                 qualifier: None,\n-                name: segment.syntax().descendants().find_map(ast::NameRef::cast)?,\n+                name: NameToImport::Exact(\n+                    segment.syntax().descendants().find_map(ast::NameRef::cast)?.to_string(),\n+                ),\n             })\n         };\n         Some(candidate)"}, {"sha": "d69e6596081be099dfd90650d17bb5e387fae5aa", "filename": "crates/ide_db/src/imports_locator.rs", "status": "modified", "additions": 44, "deletions": 30, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fimports_locator.rs?ref=db335a1bbf1d1bea2c761f67efb4b49831738e31", "patch": "@@ -1,7 +1,10 @@\n //! This module contains an import search functionality that is provided to the assists module.\n //! Later, this should be moved away to a separate crate that is accessible from the assists module.\n \n-use hir::{import_map, AsAssocItem, Crate, MacroDef, ModuleDef, Semantics};\n+use hir::{\n+    import_map::{self, ImportKind},\n+    AsAssocItem, Crate, MacroDef, ModuleDef, Semantics,\n+};\n use syntax::{ast, AstNode, SyntaxKind::NAME};\n \n use crate::{\n@@ -18,9 +21,9 @@ pub fn find_exact_imports<'a>(\n     sema: &Semantics<'a, RootDatabase>,\n     krate: Crate,\n     name_to_import: String,\n-) -> impl Iterator<Item = Either<ModuleDef, MacroDef>> {\n+) -> Box<dyn Iterator<Item = Either<ModuleDef, MacroDef>>> {\n     let _p = profile::span(\"find_exact_imports\");\n-    find_imports(\n+    Box::new(find_imports(\n         sema,\n         krate,\n         {\n@@ -34,47 +37,58 @@ pub fn find_exact_imports<'a>(\n             .name_only()\n             .search_mode(import_map::SearchMode::Equals)\n             .case_sensitive(),\n-    )\n+    ))\n+}\n+\n+pub enum AssocItemSearch {\n+    Include,\n+    Exclude,\n+    AssocItemsOnly,\n }\n \n pub fn find_similar_imports<'a>(\n     sema: &Semantics<'a, RootDatabase>,\n     krate: Crate,\n-    limit: Option<usize>,\n     fuzzy_search_string: String,\n-    ignore_assoc_items: bool,\n-    name_only: bool,\n-) -> impl Iterator<Item = Either<ModuleDef, MacroDef>> + 'a {\n+    assoc_item_search: AssocItemSearch,\n+) -> Box<dyn Iterator<Item = Either<ModuleDef, MacroDef>> + 'a> {\n     let _p = profile::span(\"find_similar_imports\");\n \n     let mut external_query = import_map::Query::new(fuzzy_search_string.clone())\n-        .search_mode(import_map::SearchMode::Fuzzy);\n-    if name_only {\n-        external_query = external_query.name_only();\n+        .search_mode(import_map::SearchMode::Fuzzy)\n+        .name_only()\n+        .limit(QUERY_SEARCH_LIMIT);\n+\n+    match assoc_item_search {\n+        AssocItemSearch::Include => {}\n+        AssocItemSearch::Exclude => {\n+            external_query = external_query.exclude_import_kind(ImportKind::AssociatedItem);\n+        }\n+        AssocItemSearch::AssocItemsOnly => {\n+            external_query = external_query.assoc_items_only();\n+        }\n     }\n \n     let mut local_query = symbol_index::Query::new(fuzzy_search_string);\n-\n-    if let Some(limit) = limit {\n-        local_query.limit(limit);\n-        external_query = external_query.limit(limit);\n-    }\n+    local_query.limit(QUERY_SEARCH_LIMIT);\n \n     let db = sema.db;\n-    find_imports(sema, krate, local_query, external_query).filter(move |import_candidate| {\n-        if ignore_assoc_items {\n-            match import_candidate {\n-                Either::Left(ModuleDef::Function(function)) => function.as_assoc_item(db).is_none(),\n-                Either::Left(ModuleDef::Const(const_)) => const_.as_assoc_item(db).is_none(),\n-                Either::Left(ModuleDef::TypeAlias(type_alias)) => {\n-                    type_alias.as_assoc_item(db).is_none()\n-                }\n-                _ => true,\n-            }\n-        } else {\n-            true\n-        }\n-    })\n+    Box::new(find_imports(sema, krate, local_query, external_query).filter(\n+        move |import_candidate| match assoc_item_search {\n+            AssocItemSearch::Include => true,\n+            AssocItemSearch::Exclude => !is_assoc_item(import_candidate, db),\n+            AssocItemSearch::AssocItemsOnly => is_assoc_item(import_candidate, db),\n+        },\n+    ))\n+}\n+\n+fn is_assoc_item(import_candidate: &Either<ModuleDef, MacroDef>, db: &RootDatabase) -> bool {\n+    match import_candidate {\n+        Either::Left(ModuleDef::Function(function)) => function.as_assoc_item(db).is_some(),\n+        Either::Left(ModuleDef::Const(const_)) => const_.as_assoc_item(db).is_some(),\n+        Either::Left(ModuleDef::TypeAlias(type_alias)) => type_alias.as_assoc_item(db).is_some(),\n+        _ => false,\n+    }\n }\n \n fn find_imports<'a>("}, {"sha": "a01b49822922a91ade53c08072366b6e3308e1b2", "filename": "crates/rust-analyzer/src/cli/analysis_bench.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs?ref=db335a1bbf1d1bea2c761f67efb4b49831738e31", "patch": "@@ -93,7 +93,7 @@ impl BenchCmd {\n                 if is_completion {\n                     let options = CompletionConfig {\n                         enable_postfix_completions: true,\n-                        enable_autoimport_completions: true,\n+                        enable_imports_on_the_fly: true,\n                         add_call_parenthesis: true,\n                         add_call_argument_snippets: true,\n                         snippet_cap: SnippetCap::new(true),"}, {"sha": "3ddb9e19afcd83302dceb2dca03d7d9c3601e088", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=db335a1bbf1d1bea2c761f67efb4b49831738e31", "patch": "@@ -559,7 +559,7 @@ impl Config {\n     pub fn completion(&self) -> CompletionConfig {\n         CompletionConfig {\n             enable_postfix_completions: self.data.completion_postfix_enable,\n-            enable_autoimport_completions: self.data.completion_autoimport_enable\n+            enable_imports_on_the_fly: self.data.completion_autoimport_enable\n                 && completion_item_edit_resolve(&self.caps),\n             add_call_parenthesis: self.data.completion_addCallParenthesis,\n             add_call_argument_snippets: self.data.completion_addCallArgumentSnippets,\n@@ -581,18 +581,7 @@ impl Config {\n         AssistConfig {\n             snippet_cap: SnippetCap::new(self.experimental(\"snippetTextEdit\")),\n             allowed: None,\n-            insert_use: InsertUseConfig {\n-                merge: match self.data.assist_importMergeBehavior {\n-                    MergeBehaviorDef::None => None,\n-                    MergeBehaviorDef::Full => Some(MergeBehavior::Full),\n-                    MergeBehaviorDef::Last => Some(MergeBehavior::Last),\n-                },\n-                prefix_kind: match self.data.assist_importPrefix {\n-                    ImportPrefixDef::Plain => PrefixKind::Plain,\n-                    ImportPrefixDef::ByCrate => PrefixKind::ByCrate,\n-                    ImportPrefixDef::BySelf => PrefixKind::BySelf,\n-                },\n-            },\n+            insert_use: self.insert_use_config(),\n         }\n     }\n     pub fn call_info_full(&self) -> bool {"}, {"sha": "a19e9e7dc1b9b2a442756990e18ff25babdf8a35", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=db335a1bbf1d1bea2c761f67efb4b49831738e31", "patch": "@@ -653,7 +653,7 @@ pub(crate) fn handle_completion(\n             let mut new_completion_items =\n                 to_proto::completion_item(&line_index, line_endings, item.clone());\n \n-            if completion_config.enable_autoimport_completions {\n+            if completion_config.enable_imports_on_the_fly {\n                 for new_item in &mut new_completion_items {\n                     fill_resolve_data(&mut new_item.data, &item, &text_document_position);\n                 }\n@@ -703,6 +703,7 @@ pub(crate) fn handle_completion_resolve(\n             FilePosition { file_id, offset },\n             &resolve_data.full_import_path,\n             resolve_data.imported_name,\n+            resolve_data.import_for_trait_assoc_item,\n         )?\n         .into_iter()\n         .flat_map(|edit| {\n@@ -1694,6 +1695,7 @@ struct CompletionResolveData {\n     position: lsp_types::TextDocumentPositionParams,\n     full_import_path: String,\n     imported_name: String,\n+    import_for_trait_assoc_item: bool,\n }\n \n fn fill_resolve_data(\n@@ -1710,6 +1712,7 @@ fn fill_resolve_data(\n             position: position.to_owned(),\n             full_import_path,\n             imported_name,\n+            import_for_trait_assoc_item: import_edit.import_for_trait_assoc_item,\n         })\n         .unwrap(),\n     );"}, {"sha": "0e35500027ccd9baa06a0f4154fc5a8dae225912", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db335a1bbf1d1bea2c761f67efb4b49831738e31/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=db335a1bbf1d1bea2c761f67efb4b49831738e31", "patch": "@@ -884,7 +884,7 @@ mod tests {\n             .completions(\n                 &ide::CompletionConfig {\n                     enable_postfix_completions: true,\n-                    enable_autoimport_completions: true,\n+                    enable_imports_on_the_fly: true,\n                     add_call_parenthesis: true,\n                     add_call_argument_snippets: true,\n                     snippet_cap: SnippetCap::new(true),"}]}