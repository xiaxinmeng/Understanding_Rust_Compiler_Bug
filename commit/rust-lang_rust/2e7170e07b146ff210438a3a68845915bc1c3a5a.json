{"sha": "2e7170e07b146ff210438a3a68845915bc1c3a5a", "node_id": "C_kwDOAAsO6NoAKDJlNzE3MGUwN2IxNDZmZjIxMDQzOGEzYTY4ODQ1OTE1YmMxYzNhNWE", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-01-02T16:49:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-02T16:49:40Z"}, "message": "Merge #11166\n\n11166: minor: Simplify r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "caa5cbf55e9dbcec12c29920aa6dfe1c2a81e7dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/caa5cbf55e9dbcec12c29920aa6dfe1c2a81e7dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e7170e07b146ff210438a3a68845915bc1c3a5a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh0dekCRBK7hj4Ov3rIwAA4/kIACtiPEkwTrT1uISVdQArcgIA\nbuOrmlbsLQdb0HhrYvvIEKcsPcDI4pFJaZ+JgyfhcDRUptBMB/xP0oxNTAeJAv9a\nlYFZikJB/Zh6x36cOc5D3ygB7blTxAwKDUOS7RwzArd8F8Vt68RzZ/OLbwX0h2XO\n/FzWfTltN1eagoU948QigM7lxvBQzOGaysMyNsCZ87WnIPxnD45NbQ7Z/Q1/I606\nHWXegYfEy02Twq0HNZOjXOsaZvMuY6xDZp7bvVKD4WzGvmiBmH3LWzF29RJ2eXLe\nLS7jkHS0fUhT0s8ewoecD6P3LSTQb+q6wLaQ5qni0X1eEvcyoXOjIbqQpAqQNHM=\n=dsDd\n-----END PGP SIGNATURE-----\n", "payload": "tree caa5cbf55e9dbcec12c29920aa6dfe1c2a81e7dc\nparent 367cd5ce9b7392b0898d4ac625e7266a3df5292a\nparent f31863b189aa438ba8d1d508b38a8dcdcae2fa9e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1641142180 +0000\ncommitter GitHub <noreply@github.com> 1641142180 +0000\n\nMerge #11166\n\n11166: minor: Simplify r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e7170e07b146ff210438a3a68845915bc1c3a5a", "html_url": "https://github.com/rust-lang/rust/commit/2e7170e07b146ff210438a3a68845915bc1c3a5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e7170e07b146ff210438a3a68845915bc1c3a5a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "367cd5ce9b7392b0898d4ac625e7266a3df5292a", "url": "https://api.github.com/repos/rust-lang/rust/commits/367cd5ce9b7392b0898d4ac625e7266a3df5292a", "html_url": "https://github.com/rust-lang/rust/commit/367cd5ce9b7392b0898d4ac625e7266a3df5292a"}, {"sha": "f31863b189aa438ba8d1d508b38a8dcdcae2fa9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f31863b189aa438ba8d1d508b38a8dcdcae2fa9e", "html_url": "https://github.com/rust-lang/rust/commit/f31863b189aa438ba8d1d508b38a8dcdcae2fa9e"}], "stats": {"total": 148, "additions": 65, "deletions": 83}, "files": [{"sha": "2de10ddbdf9bfb32fc5c52b8f8f616ce5dc63418", "filename": "crates/hir_def/src/macro_expansion_tests/mbe/meta_syntax.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e7170e07b146ff210438a3a68845915bc1c3a5a/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmeta_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7170e07b146ff210438a3a68845915bc1c3a5a/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmeta_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmeta_syntax.rs?ref=2e7170e07b146ff210438a3a68845915bc1c3a5a", "patch": "@@ -69,11 +69,11 @@ macro_rules! e3 { ($(i:ident)_) => () }\n /* error: invalid macro definition: invalid repeat */\n \n macro_rules! f1 { ($i) => ($i) }\n-/* error: invalid macro definition: bad fragment specifier 1 */\n+/* error: invalid macro definition: missing fragment specifier */\n macro_rules! f2 { ($i:) => ($i) }\n-/* error: invalid macro definition: bad fragment specifier 1 */\n+/* error: invalid macro definition: missing fragment specifier */\n macro_rules! f3 { ($i:_) => () }\n-/* error: invalid macro definition: bad fragment specifier 1 */\n+/* error: invalid macro definition: missing fragment specifier */\n \"#]],\n     )\n }"}, {"sha": "910724411d46e33db11fbb11236d540301d4aa82", "filename": "crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2e7170e07b146ff210438a3a68845915bc1c3a5a/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7170e07b146ff210438a3a68845915bc1c3a5a/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=2e7170e07b146ff210438a3a68845915bc1c3a5a", "patch": "@@ -571,18 +571,18 @@ fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n \n         if !error_items.is_empty() {\n             error_recover_item = error_items.pop().map(|it| it.bindings);\n-        } else if !eof_items.is_empty() {\n-            error_recover_item = Some(eof_items[0].bindings.clone());\n+        } else if let [state, ..] = &*eof_items {\n+            error_recover_item = Some(state.bindings.clone());\n         }\n \n         // We need to do some post processing after the `match_loop_inner`.\n         // If we reached the EOF, check that there is EXACTLY ONE possible matcher. Otherwise,\n         // either the parse is ambiguous (which should never happen) or there is a syntax error.\n         if src.peek_n(0).is_none() && stack.is_empty() {\n-            if eof_items.len() == 1 {\n+            if let [state] = &*eof_items {\n                 // remove all errors, because it is the correct answer !\n                 res = Match::default();\n-                res.bindings = bindings_builder.build(&eof_items[0].bindings);\n+                res.bindings = bindings_builder.build(&state.bindings);\n             } else {\n                 // Error recovery\n                 if let Some(item) = error_recover_item {\n@@ -598,10 +598,10 @@ fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n         //\n         // Another possibility is that we need to call out to parse some rust nonterminal\n         // (black-box) parser. However, if there is not EXACTLY ONE of these, something is wrong.\n-        if (bb_items.is_empty() && next_items.is_empty())\n-            || (!bb_items.is_empty() && !next_items.is_empty())\n-            || bb_items.len() > 1\n-        {\n+        let has_leftover_tokens = (bb_items.is_empty() && next_items.is_empty())\n+            || !(bb_items.is_empty() || next_items.is_empty())\n+            || bb_items.len() > 1;\n+        if has_leftover_tokens {\n             res.unmatched_tts += src.len();\n             while let Some(it) = stack.pop() {\n                 src = it;\n@@ -624,7 +624,11 @@ fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n                     stack.push(src.clone());\n                     src = TtIter::new(subtree);\n                 }\n-                None if !stack.is_empty() => src = stack.pop().unwrap(),\n+                None => {\n+                    if let Some(iter) = stack.pop() {\n+                        src = iter;\n+                    }\n+                }\n                 _ => (),\n             }\n         }\n@@ -662,29 +666,23 @@ fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n fn match_leaf(lhs: &tt::Leaf, src: &mut TtIter) -> Result<(), ExpandError> {\n     let rhs = match src.expect_leaf() {\n         Ok(l) => l,\n-        Err(()) => {\n-            return Err(err!(\"expected leaf: `{}`\", lhs));\n-        }\n+        Err(()) => return Err(err!(\"expected leaf: `{}`\", lhs)),\n     };\n     match (lhs, rhs) {\n         (\n             tt::Leaf::Punct(tt::Punct { char: lhs, .. }),\n             tt::Leaf::Punct(tt::Punct { char: rhs, .. }),\n-        ) if lhs == rhs => (),\n+        ) if lhs == rhs => Ok(()),\n         (\n             tt::Leaf::Ident(tt::Ident { text: lhs, .. }),\n             tt::Leaf::Ident(tt::Ident { text: rhs, .. }),\n-        ) if lhs == rhs => (),\n+        ) if lhs == rhs => Ok(()),\n         (\n             tt::Leaf::Literal(tt::Literal { text: lhs, .. }),\n             tt::Leaf::Literal(tt::Literal { text: rhs, .. }),\n-        ) if lhs == rhs => (),\n-        _ => {\n-            return Err(ExpandError::UnexpectedToken);\n-        }\n+        ) if lhs == rhs => Ok(()),\n+        _ => Err(ExpandError::UnexpectedToken),\n     }\n-\n-    Ok(())\n }\n \n fn match_meta_var(kind: &str, input: &mut TtIter) -> ExpandResult<Option<Fragment>> {"}, {"sha": "b5ae5b91bb6e9b9cabd494e3c85edbeb3e4a8d9a", "filename": "crates/mbe/src/expander/transcriber.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2e7170e07b146ff210438a3a68845915bc1c3a5a/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7170e07b146ff210438a3a68845915bc1c3a5a/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs?ref=2e7170e07b146ff210438a3a68845915bc1c3a5a", "patch": "@@ -4,11 +4,10 @@\n use syntax::SmolStr;\n use tt::{Delimiter, Subtree};\n \n-use super::ExpandResult;\n use crate::{\n     expander::{Binding, Bindings, Fragment},\n     parser::{Op, RepeatKind, Separator},\n-    ExpandError, MetaTemplate,\n+    ExpandError, ExpandResult, MetaTemplate,\n };\n \n impl Bindings {\n@@ -17,36 +16,36 @@ impl Bindings {\n     }\n \n     fn get(&self, name: &str, nesting: &mut [NestingState]) -> Result<&Fragment, ExpandError> {\n-        let mut b: &Binding = self.inner.get(name).ok_or_else(|| {\n-            ExpandError::BindingError(format!(\"could not find binding `{}`\", name))\n-        })?;\n+        macro_rules! binding_err {\n+            ($($arg:tt)*) => { ExpandError::BindingError(format!($($arg)*)) };\n+        }\n+\n+        let mut b: &Binding = self\n+            .inner\n+            .get(name)\n+            .ok_or_else(|| binding_err!(\"could not find binding `{}`\", name))?;\n         for nesting_state in nesting.iter_mut() {\n             nesting_state.hit = true;\n             b = match b {\n                 Binding::Fragment(_) => break,\n                 Binding::Nested(bs) => bs.get(nesting_state.idx).ok_or_else(|| {\n                     nesting_state.at_end = true;\n-                    ExpandError::BindingError(format!(\"could not find nested binding `{}`\", name))\n+                    binding_err!(\"could not find nested binding `{}`\", name)\n                 })?,\n                 Binding::Empty => {\n                     nesting_state.at_end = true;\n-                    return Err(ExpandError::BindingError(format!(\n-                        \"could not find empty binding `{}`\",\n-                        name\n-                    )));\n+                    return Err(binding_err!(\"could not find empty binding `{}`\", name));\n                 }\n             };\n         }\n         match b {\n             Binding::Fragment(it) => Ok(it),\n-            Binding::Nested(_) => Err(ExpandError::BindingError(format!(\n-                \"expected simple binding, found nested binding `{}`\",\n-                name\n-            ))),\n-            Binding::Empty => Err(ExpandError::BindingError(format!(\n-                \"expected simple binding, found empty binding `{}`\",\n-                name\n-            ))),\n+            Binding::Nested(_) => {\n+                Err(binding_err!(\"expected simple binding, found nested binding `{}`\", name))\n+            }\n+            Binding::Empty => {\n+                Err(binding_err!(\"expected simple binding, found empty binding `{}`\", name))\n+            }\n         }\n     }\n }\n@@ -109,7 +108,7 @@ fn expand_subtree(\n         }\n     }\n     // drain the elements added in this instance of expand_subtree\n-    let tts = arena.drain(start_elements..arena.len()).collect();\n+    let tts = arena.drain(start_elements..).collect();\n     ExpandResult { value: tt::Subtree { delimiter, token_trees: tts }, err }\n }\n \n@@ -193,23 +192,22 @@ fn expand_repeat(\n         push_subtree(&mut buf, t);\n \n         if let Some(sep) = separator {\n-            match sep {\n+            has_seps = match sep {\n                 Separator::Ident(ident) => {\n-                    has_seps = 1;\n                     buf.push(tt::Leaf::from(ident.clone()).into());\n+                    1\n                 }\n                 Separator::Literal(lit) => {\n-                    has_seps = 1;\n                     buf.push(tt::Leaf::from(lit.clone()).into());\n+                    1\n                 }\n-\n                 Separator::Puncts(puncts) => {\n-                    has_seps = puncts.len();\n-                    for punct in puncts {\n-                        buf.push(tt::Leaf::from(*punct).into());\n+                    for &punct in puncts {\n+                        buf.push(tt::Leaf::from(punct).into());\n                     }\n+                    puncts.len()\n                 }\n-            }\n+            };\n         }\n \n         if RepeatKind::ZeroOrOne == kind {"}, {"sha": "ef29380557d355aa52b048f64661b6c934897220", "filename": "crates/mbe/src/parser.rs", "status": "modified", "additions": 19, "deletions": 33, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2e7170e07b146ff210438a3a68845915bc1c3a5a/crates%2Fmbe%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7170e07b146ff210438a3a68845915bc1c3a5a/crates%2Fmbe%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fparser.rs?ref=2e7170e07b146ff210438a3a68845915bc1c3a5a", "patch": "@@ -41,7 +41,7 @@ impl MetaTemplate {\n         let mut res = Vec::new();\n         while let Some(first) = src.next() {\n             let op = next_op(first, &mut src, mode)?;\n-            res.push(op)\n+            res.push(op);\n         }\n \n         Ok(MetaTemplate(res))\n@@ -110,12 +110,6 @@ macro_rules! err {\n     };\n }\n \n-macro_rules! bail {\n-    ($($tt:tt)*) => {\n-        return Err(err!($($tt)*))\n-    };\n-}\n-\n fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Result<Op, ParseError> {\n     let res = match first {\n         tt::TokenTree::Leaf(leaf @ tt::Leaf::Punct(tt::Punct { char: '$', .. })) => {\n@@ -131,26 +125,24 @@ fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Resul\n                     Op::Repeat { tokens, separator, kind }\n                 }\n                 tt::TokenTree::Leaf(leaf) => match leaf {\n-                    tt::Leaf::Punct(_) => return Err(ParseError::Expected(\"ident\".to_string())),\n                     tt::Leaf::Ident(ident) if ident.text == \"crate\" => {\n                         // We simply produce identifier `$crate` here. And it will be resolved when lowering ast to Path.\n                         Op::Leaf(tt::Leaf::from(tt::Ident { text: \"$crate\".into(), id: ident.id }))\n                     }\n                     tt::Leaf::Ident(ident) => {\n-                        let name = ident.text.clone();\n                         let kind = eat_fragment_kind(src, mode)?;\n+                        let name = ident.text.clone();\n                         let id = ident.id;\n                         Op::Var { name, kind, id }\n                     }\n-                    tt::Leaf::Literal(lit) => {\n-                        if is_boolean_literal(lit) {\n-                            let name = lit.text.clone();\n-                            let kind = eat_fragment_kind(src, mode)?;\n-                            let id = lit.id;\n-                            Op::Var { name, kind, id }\n-                        } else {\n-                            bail!(\"bad var 2\");\n-                        }\n+                    tt::Leaf::Literal(lit) if is_boolean_literal(lit) => {\n+                        let kind = eat_fragment_kind(src, mode)?;\n+                        let name = lit.text.clone();\n+                        let id = lit.id;\n+                        Op::Var { name, kind, id }\n+                    }\n+                    tt::Leaf::Punct(_) | tt::Leaf::Literal(_) => {\n+                        return Err(ParseError::Expected(\"ident\".to_string()))\n                     }\n                 },\n             }\n@@ -166,8 +158,8 @@ fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Resul\n \n fn eat_fragment_kind(src: &mut TtIter<'_>, mode: Mode) -> Result<Option<SmolStr>, ParseError> {\n     if let Mode::Pattern = mode {\n-        src.expect_char(':').map_err(|()| err!(\"bad fragment specifier 1\"))?;\n-        let ident = src.expect_ident().map_err(|()| err!(\"bad fragment specifier 1\"))?;\n+        src.expect_char(':').map_err(|()| err!(\"missing fragment specifier\"))?;\n+        let ident = src.expect_ident().map_err(|()| err!(\"missing fragment specifier\"))?;\n         return Ok(Some(ident.text.clone()));\n     };\n     Ok(None)\n@@ -199,21 +191,15 @@ fn parse_repeat(src: &mut TtIter) -> Result<(Option<Separator>, RepeatKind), Par\n                     '*' => RepeatKind::ZeroOrMore,\n                     '+' => RepeatKind::OneOrMore,\n                     '?' => RepeatKind::ZeroOrOne,\n-                    _ => {\n-                        match &mut separator {\n-                            Separator::Puncts(puncts) => {\n-                                if puncts.len() == 3 {\n-                                    return Err(ParseError::InvalidRepeat);\n-                                }\n-                                puncts.push(*punct)\n-                            }\n-                            _ => return Err(ParseError::InvalidRepeat),\n+                    _ => match &mut separator {\n+                        Separator::Puncts(puncts) if puncts.len() != 3 => {\n+                            puncts.push(*punct);\n+                            continue;\n                         }\n-                        continue;\n-                    }\n+                        _ => return Err(ParseError::InvalidRepeat),\n+                    },\n                 };\n-                let separator = if has_sep { Some(separator) } else { None };\n-                return Ok((separator, repeat_kind));\n+                return Ok((has_sep.then(|| separator), repeat_kind));\n             }\n         }\n     }"}]}