{"sha": "7e210a8129c844e0b3aca4a28153effd0817ef41", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlMjEwYTgxMjljODQ0ZTBiM2FjYTRhMjgxNTNlZmZkMDgxN2VmNDE=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-31T19:07:45Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-01T14:54:22Z"}, "message": "std: Replace `for` with `do { .. }` expr in std::gc\n\nChange all users of old-style for with internal iterators to using\n`do`-loops.\n\nThe code in stackwalk.rs does not actually implement the\nlooping protocol (no break on return false).\n\nThe code in gc.rs does not use loop breaks, nor does any code using it.\n\nWe remove the capacity to break from the loops in std::gc and implement\nthe walks using `do { .. }` expressions.\n\nNo behavior change.", "tree": {"sha": "a48837c9ed59251169c728c541d78632ea44b2f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a48837c9ed59251169c728c541d78632ea44b2f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e210a8129c844e0b3aca4a28153effd0817ef41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e210a8129c844e0b3aca4a28153effd0817ef41", "html_url": "https://github.com/rust-lang/rust/commit/7e210a8129c844e0b3aca4a28153effd0817ef41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e210a8129c844e0b3aca4a28153effd0817ef41/comments", "author": null, "committer": null, "parents": [{"sha": "e5a64f2adddd1ed2ec8e92ec94658b24ece4dbfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5a64f2adddd1ed2ec8e92ec94658b24ece4dbfc", "html_url": "https://github.com/rust-lang/rust/commit/e5a64f2adddd1ed2ec8e92ec94658b24ece4dbfc"}], "stats": {"total": 114, "additions": 52, "deletions": 62}, "files": [{"sha": "9a8db6990b65dedbef92bbe4214c56d1440df9fe", "filename": "src/libstd/gc.rs", "status": "modified", "additions": 49, "deletions": 58, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/7e210a8129c844e0b3aca4a28153effd0817ef41/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e210a8129c844e0b3aca4a28153effd0817ef41/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=7e210a8129c844e0b3aca4a28153effd0817ef41", "patch": "@@ -121,11 +121,11 @@ unsafe fn is_safe_point(pc: *Word) -> Option<SafePoint> {\n     return None;\n }\n \n-type Visitor<'self> = &'self fn(root: **Word, tydesc: *TyDesc) -> bool;\n+type Visitor<'self> = &'self fn(root: **Word, tydesc: *TyDesc);\n \n // Walks the list of roots for the given safe point, and calls visitor\n // on each root.\n-unsafe fn _walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) -> bool {\n+unsafe fn _walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n     let fp_bytes = fp as *u8;\n     let sp_meta = sp.sp_meta as *u32;\n \n@@ -151,7 +151,7 @@ unsafe fn _walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) -> bool {\n             } else {\n                 ptr::null()\n             };\n-            if !visitor(root, tydesc) { return false; }\n+            visitor(root, tydesc);\n         }\n         sri += 1;\n     }\n@@ -164,10 +164,9 @@ unsafe fn _walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) -> bool {\n         }\n         rri += 1;\n     }\n-    return true;\n }\n \n-unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) -> bool {\n+unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n     _walk_safe_point(fp, sp, visitor)\n }\n \n@@ -223,15 +222,15 @@ static need_cleanup:    Memory = exchange_heap | stack;\n \n // Walks stack, searching for roots of the requested type, and passes\n // each root to the visitor.\n-unsafe fn _walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) -> bool {\n+unsafe fn _walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {\n     let mut segment = rustrt::rust_get_stack_segment();\n     let mut last_ret: *Word = ptr::null();\n     // To avoid collecting memory used by the GC itself, skip stack\n     // frames until past the root GC stack frame. The root GC stack\n     // frame is marked by a sentinel, which is a box pointer stored on\n     // the stack.\n     let mut reached_sentinel = ptr::is_null(sentinel);\n-    for walk_stack |frame| {\n+    do walk_stack |frame| {\n         let pc = last_ret;\n         let Segment {segment: next_segment, boundary: boundary} =\n             find_segment_for_frame(frame.fp, segment);\n@@ -248,53 +247,46 @@ unsafe fn _walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) -> boo\n         let ret_offset = if boundary { 4 } else { 1 };\n         last_ret = *ptr::offset(frame.fp, ret_offset as int) as *Word;\n \n-        if ptr::is_null(pc) {\n-            loop;\n-        }\n-\n-        let mut delay_reached_sentinel = reached_sentinel;\n-        let sp = is_safe_point(pc);\n-        match sp {\n-          Some(sp_info) => {\n-            for walk_safe_point(frame.fp, sp_info) |root, tydesc| {\n-                // Skip roots until we see the sentinel.\n-                if !reached_sentinel {\n-                    if root == sentinel {\n-                        delay_reached_sentinel = true;\n-                    }\n-                    loop;\n-                }\n-\n-                // Skip null pointers, which can occur when a\n-                // unique pointer has already been freed.\n-                if ptr::is_null(*root) {\n-                    loop;\n-                }\n-\n-                if ptr::is_null(tydesc) {\n-                    // Root is a generic box.\n-                    let refcount = **root;\n-                    if mem | task_local_heap != 0 && refcount != -1 {\n-                        if !visitor(root, tydesc) { return false; }\n-                    } else if mem | exchange_heap != 0 && refcount == -1 {\n-                        if !visitor(root, tydesc) { return false; }\n-                    }\n-                } else {\n-                    // Root is a non-immediate.\n-                    if mem | stack != 0 {\n-                        if !visitor(root, tydesc) { return false; }\n+        if !ptr::is_null(pc) {\n+\n+            let mut delay_reached_sentinel = reached_sentinel;\n+            let sp = is_safe_point(pc);\n+            match sp {\n+                Some(sp_info) => {\n+                    do walk_safe_point(frame.fp, sp_info) |root, tydesc| {\n+                        // Skip roots until we see the sentinel.\n+                        if !reached_sentinel && root == sentinel {\n+                            delay_reached_sentinel = true;\n+                        }\n+\n+                        // Skip null pointers, which can occur when a\n+                        // unique pointer has already been freed.\n+                        if reached_sentinel && !ptr::is_null(*root) {\n+                            if ptr::is_null(tydesc) {\n+                                // Root is a generic box.\n+                                let refcount = **root;\n+                                if mem | task_local_heap != 0 && refcount != -1 {\n+                                    visitor(root, tydesc);\n+                                } else if mem | exchange_heap != 0 && refcount == -1 {\n+                                    visitor(root, tydesc);\n+                                }\n+                            } else {\n+                                // Root is a non-immediate.\n+                                if mem | stack != 0 {\n+                                    visitor(root, tydesc);\n+                                }\n+                            }\n+                        }\n                     }\n                 }\n+                None => ()\n             }\n-          }\n-          None => ()\n+            reached_sentinel = delay_reached_sentinel;\n         }\n-        reached_sentinel = delay_reached_sentinel;\n     }\n-    return true;\n }\n \n-unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) -> bool {\n+unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {\n     _walk_gc_roots(mem, sentinel, visitor)\n }\n pub fn gc() {\n@@ -304,7 +296,7 @@ pub fn gc() {\n             return;\n         }\n \n-        for walk_gc_roots(task_local_heap, ptr::null()) |_root, _tydesc| {\n+        do walk_gc_roots(task_local_heap, ptr::null()) |_root, _tydesc| {\n             // FIXME(#2997): Walk roots and mark them.\n             io::stdout().write([46]); // .\n         }\n@@ -349,18 +341,17 @@ pub fn cleanup_stack_for_failure() {\n         };\n \n         let mut roots = HashSet::new();\n-        for walk_gc_roots(need_cleanup, sentinel) |root, tydesc| {\n+        do walk_gc_roots(need_cleanup, sentinel) |root, tydesc| {\n             // Track roots to avoid double frees.\n-            if roots.contains(&*root) {\n-                loop;\n-            }\n-            roots.insert(*root);\n+            if !roots.contains(&*root) {\n+                roots.insert(*root);\n \n-            if ptr::is_null(tydesc) {\n-                // FIXME #4420: Destroy this box\n-                // FIXME #4330: Destroy this box\n-            } else {\n-                ((*tydesc).drop_glue)(*root as *i8);\n+                if ptr::is_null(tydesc) {\n+                    // FIXME #4420: Destroy this box\n+                    // FIXME #4330: Destroy this box\n+                } else {\n+                    ((*tydesc).drop_glue)(*root as *i8);\n+                }\n             }\n         }\n     }"}, {"sha": "cc516fb559ea8babc701a824cdee94641073ef8f", "filename": "src/libstd/stackwalk.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e210a8129c844e0b3aca4a28153effd0817ef41/src%2Flibstd%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e210a8129c844e0b3aca4a28153effd0817ef41/src%2Flibstd%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstackwalk.rs?ref=7e210a8129c844e0b3aca4a28153effd0817ef41", "patch": "@@ -25,7 +25,7 @@ pub fn Frame(fp: *Word) -> Frame {\n     }\n }\n \n-pub fn walk_stack(visit: &fn(Frame) -> bool) -> bool {\n+pub fn walk_stack(visit: &fn(Frame)) {\n \n     debug!(\"beginning stack walk\");\n \n@@ -51,12 +51,11 @@ pub fn walk_stack(visit: &fn(Frame) -> bool) -> bool {\n             }\n         }\n     }\n-    return true;\n }\n \n #[test]\n fn test_simple() {\n-    for walk_stack |_frame| {\n+    do walk_stack |_frame| {\n     }\n }\n \n@@ -65,7 +64,7 @@ fn test_simple_deep() {\n     fn run(i: int) {\n         if i == 0 { return }\n \n-        for walk_stack |_frame| {\n+        do walk_stack |_frame| {\n             // Would be nice to test something here...\n         }\n         run(i - 1);"}]}