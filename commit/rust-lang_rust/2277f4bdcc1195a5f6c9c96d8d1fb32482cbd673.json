{"sha": "2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyNzdmNGJkY2MxMTk1YTVmNmM5Yzk2ZDhkMWZiMzI0ODJjYmQ2NzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-06T22:51:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-06T22:51:51Z"}, "message": "Auto merge of #41121 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 8 pull requests\n\n- Successful merges: #40878, #40976, #41089, #41090, #41108, #41111, #41112, #41114\n- Failed merges:", "tree": {"sha": "2d5866aa48e565017fcb785b816982340075c303", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d5866aa48e565017fcb785b816982340075c303"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "html_url": "https://github.com/rust-lang/rust/commit/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50c186419bb38e8ea2f1e6f9c31b754e3a1a3e65", "url": "https://api.github.com/repos/rust-lang/rust/commits/50c186419bb38e8ea2f1e6f9c31b754e3a1a3e65", "html_url": "https://github.com/rust-lang/rust/commit/50c186419bb38e8ea2f1e6f9c31b754e3a1a3e65"}, {"sha": "8af853b310f189dba7847a58340c65ad5b012ac1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8af853b310f189dba7847a58340c65ad5b012ac1", "html_url": "https://github.com/rust-lang/rust/commit/8af853b310f189dba7847a58340c65ad5b012ac1"}], "stats": {"total": 5233, "additions": 3488, "deletions": 1745}, "files": [{"sha": "3533f0df5d1ce82d13e9aa992c7ee62798b5aa0c", "filename": ".gitmodules", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -25,4 +25,4 @@\n \turl = https://github.com/rust-lang-nursery/reference.git\n [submodule \"book\"]\n \tpath = src/doc/book\n-\turl = https://github.com/rust-lang/book\n+\turl = https://github.com/rust-lang/book.git"}, {"sha": "ad285a57a84a3f56891012099ae498dab2503b9b", "filename": "src/ci/docker/dist-i586-gnu-i686-musl/build-musl.sh", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Fci%2Fdocker%2Fdist-i586-gnu-i686-musl%2Fbuild-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Fci%2Fdocker%2Fdist-i586-gnu-i686-musl%2Fbuild-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i586-gnu-i686-musl%2Fbuild-musl.sh?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -15,11 +15,14 @@ set -ex\n export CFLAGS=\"-fPIC -Wa,-mrelax-relocations=no\"\n export CXXFLAGS=\"-Wa,-mrelax-relocations=no\"\n \n-MUSL=musl-1.1.14\n+MUSL=musl-1.1.16\n curl https://www.musl-libc.org/releases/$MUSL.tar.gz | tar xzf -\n cd $MUSL\n-CFLAGS=\"$CFLAGS -m32\" ./configure --prefix=/musl-i686 --disable-shared --target=i686\n-make -j10\n+CC=gcc \\\n+  CFLAGS=\"$CFLAGS -m32\" \\\n+  ./configure --prefix=/musl-i686 --disable-shared \\\n+    --target=i686\n+make AR=ar RANLIB=ranlib -j10\n make install\n cd ..\n "}, {"sha": "776da0093974c0c68c9b59ca84f9fd55eec26059", "filename": "src/ci/docker/dist-x86_64-musl/build-musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2Fbuild-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2Fbuild-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2Fbuild-musl.sh?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -15,7 +15,7 @@ set -ex\n export CFLAGS=\"-fPIC -Wa,-mrelax-relocations=no\"\n export CXXFLAGS=\"-Wa,-mrelax-relocations=no\"\n \n-MUSL=musl-1.1.14\n+MUSL=musl-1.1.16\n curl https://www.musl-libc.org/releases/$MUSL.tar.gz | tar xzf -\n cd $MUSL\n ./configure --prefix=/musl-x86_64 --disable-shared"}, {"sha": "35ecf411db4e0b2a998b03a18be4fcd7404ec701", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -1346,7 +1346,7 @@ impl<T: PartialEq> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    ///# #![feature(vec_remove_item)]\n+    /// # #![feature(vec_remove_item)]\n     /// let mut vec = vec![1, 2, 3, 1];\n     ///\n     /// vec.remove_item(&1);"}, {"sha": "2e1058bfc3413bd4efa59a5815c3fc1fae711541", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -153,8 +153,9 @@ unsafe impl<T> Sync for AtomicPtr<T> {}\n /// Rust's memory orderings are [the same as\n /// LLVM's](http://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations).\n ///\n-/// For more information see the [nomicon][1].\n-/// [1]: ../../../nomicon/atomics.html\n+/// For more information see the [nomicon].\n+///\n+/// [nomicon]: ../../../nomicon/atomics.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy, Clone, Debug)]\n pub enum Ordering {"}, {"sha": "dca9ebb3397a62b547b831f931ae172231df6f5b", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -394,6 +394,10 @@ impl Definitions {\n         }\n     }\n \n+    pub fn node_to_hir_id(&self, node_id: ast::NodeId) -> hir::HirId {\n+        self.node_to_hir_id[node_id]\n+    }\n+\n     /// Add a definition with a parent definition.\n     pub fn create_def_with_parent(&mut self,\n                                   parent: Option<DefIndex>,"}, {"sha": "73d81212cd77eaf5ffd15c5d4e7d241582521048", "filename": "src/librustc/ich/hcx.rs", "status": "added", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -0,0 +1,300 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir;\n+use hir::def_id::DefId;\n+use ich::{self, CachingCodemapView, DefPathHashes};\n+use session::config::DebugInfoLevel::NoDebugInfo;\n+use ty;\n+\n+use std::hash as std_hash;\n+\n+use syntax::ast;\n+use syntax::attr;\n+use syntax::ext::hygiene::SyntaxContext;\n+use syntax::symbol::Symbol;\n+use syntax_pos::Span;\n+\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n+use rustc_data_structures::accumulate_vec::AccumulateVec;\n+\n+/// This is the context state available during incr. comp. hashing. It contains\n+/// enough information to transform DefIds and HirIds into stable DefPaths (i.e.\n+/// a reference to the TyCtxt) and it holds a few caches for speeding up various\n+/// things (e.g. each DefId/DefPath is only hashed once).\n+pub struct StableHashingContext<'a, 'tcx: 'a> {\n+    tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+    def_path_hashes: DefPathHashes<'a, 'tcx>,\n+    codemap: CachingCodemapView<'tcx>,\n+    hash_spans: bool,\n+    hash_bodies: bool,\n+    overflow_checks_enabled: bool,\n+    node_id_hashing_mode: NodeIdHashingMode,\n+    // A sorted array of symbol keys for fast lookup.\n+    ignored_attr_names: Vec<Symbol>,\n+}\n+\n+#[derive(PartialEq, Eq, Clone, Copy)]\n+pub enum NodeIdHashingMode {\n+    Ignore,\n+    HashDefPath,\n+    HashTraitsInScope,\n+}\n+\n+impl<'a, 'tcx: 'a> StableHashingContext<'a, 'tcx> {\n+\n+    pub fn new(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+        let hash_spans_initial = tcx.sess.opts.debuginfo != NoDebugInfo;\n+        let check_overflow_initial = tcx.sess.overflow_checks();\n+\n+        let mut ignored_attr_names: Vec<_> = ich::IGNORED_ATTRIBUTES\n+            .iter()\n+            .map(|&s| Symbol::intern(s))\n+            .collect();\n+\n+        ignored_attr_names.sort();\n+\n+        StableHashingContext {\n+            tcx: tcx,\n+            def_path_hashes: DefPathHashes::new(tcx),\n+            codemap: CachingCodemapView::new(tcx),\n+            hash_spans: hash_spans_initial,\n+            hash_bodies: true,\n+            overflow_checks_enabled: check_overflow_initial,\n+            node_id_hashing_mode: NodeIdHashingMode::HashDefPath,\n+            ignored_attr_names: ignored_attr_names,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn while_hashing_hir_bodies<F: FnOnce(&mut Self)>(&mut self,\n+                                                          hash_bodies: bool,\n+                                                          f: F) {\n+        let prev_hash_bodies = self.hash_bodies;\n+        self.hash_bodies = hash_bodies;\n+        f(self);\n+        self.hash_bodies = prev_hash_bodies;\n+    }\n+\n+    #[inline]\n+    pub fn while_hashing_spans<F: FnOnce(&mut Self)>(&mut self,\n+                                                     hash_spans: bool,\n+                                                     f: F) {\n+        let prev_hash_spans = self.hash_spans;\n+        self.hash_spans = hash_spans;\n+        f(self);\n+        self.hash_spans = prev_hash_spans;\n+    }\n+\n+    #[inline]\n+    pub fn with_node_id_hashing_mode<F: FnOnce(&mut Self)>(&mut self,\n+                                                           mode: NodeIdHashingMode,\n+                                                           f: F) {\n+        let prev = self.node_id_hashing_mode;\n+        self.node_id_hashing_mode = mode;\n+        f(self);\n+        self.node_id_hashing_mode = prev;\n+    }\n+\n+    #[inline]\n+    pub fn tcx(&self) -> ty::TyCtxt<'a, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    #[inline]\n+    pub fn def_path_hash(&mut self, def_id: DefId) -> u64 {\n+        self.def_path_hashes.hash(def_id)\n+    }\n+\n+    #[inline]\n+    pub fn hash_spans(&self) -> bool {\n+        self.hash_spans\n+    }\n+\n+    #[inline]\n+    pub fn hash_bodies(&self) -> bool {\n+        self.hash_bodies\n+    }\n+\n+    #[inline]\n+    pub fn codemap(&mut self) -> &mut CachingCodemapView<'tcx> {\n+        &mut self.codemap\n+    }\n+\n+    #[inline]\n+    pub fn is_ignored_attr(&self, name: Symbol) -> bool {\n+        self.ignored_attr_names.binary_search(&name).is_ok()\n+    }\n+\n+    pub fn hash_hir_item_like<F: FnOnce(&mut Self)>(&mut self,\n+                                                    item_attrs: &[ast::Attribute],\n+                                                    f: F) {\n+        let prev_overflow_checks = self.overflow_checks_enabled;\n+        if attr::contains_name(item_attrs, \"rustc_inherit_overflow_checks\") {\n+            self.overflow_checks_enabled = true;\n+        }\n+        let prev_hash_node_ids = self.node_id_hashing_mode;\n+        self.node_id_hashing_mode = NodeIdHashingMode::Ignore;\n+\n+        f(self);\n+\n+        self.node_id_hashing_mode = prev_hash_node_ids;\n+        self.overflow_checks_enabled = prev_overflow_checks;\n+    }\n+\n+    #[inline]\n+    pub fn binop_can_panic_at_runtime(&self, binop: hir::BinOp_) -> bool\n+    {\n+        match binop {\n+            hir::BiAdd |\n+            hir::BiSub |\n+            hir::BiMul => self.overflow_checks_enabled,\n+\n+            hir::BiDiv |\n+            hir::BiRem => true,\n+\n+            hir::BiAnd |\n+            hir::BiOr |\n+            hir::BiBitXor |\n+            hir::BiBitAnd |\n+            hir::BiBitOr |\n+            hir::BiShl |\n+            hir::BiShr |\n+            hir::BiEq |\n+            hir::BiLt |\n+            hir::BiLe |\n+            hir::BiNe |\n+            hir::BiGe |\n+            hir::BiGt => false\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn unop_can_panic_at_runtime(&self, unop: hir::UnOp) -> bool\n+    {\n+        match unop {\n+            hir::UnDeref |\n+            hir::UnNot => false,\n+            hir::UnNeg => self.overflow_checks_enabled,\n+        }\n+    }\n+}\n+\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::NodeId {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        match hcx.node_id_hashing_mode {\n+            NodeIdHashingMode::Ignore => {\n+                // Most NodeIds in the HIR can be ignored, but if there is a\n+                // corresponding entry in the `trait_map` we need to hash that.\n+                // Make sure we don't ignore too much by checking that there is\n+                // no entry in a debug_assert!().\n+                debug_assert!(hcx.tcx.trait_map.get(self).is_none());\n+            }\n+            NodeIdHashingMode::HashDefPath => {\n+                hcx.tcx.hir.definitions().node_to_hir_id(*self).hash_stable(hcx, hasher);\n+            }\n+            NodeIdHashingMode::HashTraitsInScope => {\n+                if let Some(traits) = hcx.tcx.trait_map.get(self) {\n+                    // The ordering of the candidates is not fixed. So we hash\n+                    // the def-ids and then sort them and hash the collection.\n+                    let mut candidates: AccumulateVec<[_; 8]> =\n+                        traits.iter()\n+                              .map(|&hir::TraitCandidate { def_id, import_id: _ }| {\n+                                  hcx.def_path_hash(def_id)\n+                              })\n+                              .collect();\n+                    if traits.len() > 1 {\n+                        candidates.sort();\n+                    }\n+                    candidates.hash_stable(hcx, hasher);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for Span {\n+\n+    // Hash a span in a stable way. We can't directly hash the span's BytePos\n+    // fields (that would be similar to hashing pointers, since those are just\n+    // offsets into the CodeMap). Instead, we hash the (file name, line, column)\n+    // triple, which stays the same even if the containing FileMap has moved\n+    // within the CodeMap.\n+    // Also note that we are hashing byte offsets for the column, not unicode\n+    // codepoint offsets. For the purpose of the hash that's sufficient.\n+    // Also, hashing filenames is expensive so we avoid doing it twice when the\n+    // span starts and ends in the same file, which is almost always the case.\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use syntax_pos::Pos;\n+\n+        if !hcx.hash_spans {\n+            return\n+        }\n+\n+        // If this is not an empty or invalid span, we want to hash the last\n+        // position that belongs to it, as opposed to hashing the first\n+        // position past it.\n+        let span_hi = if self.hi > self.lo {\n+            // We might end up in the middle of a multibyte character here,\n+            // but that's OK, since we are not trying to decode anything at\n+            // this position.\n+            self.hi - ::syntax_pos::BytePos(1)\n+        } else {\n+            self.hi\n+        };\n+\n+        {\n+            let loc1 = hcx.codemap().byte_pos_to_line_and_col(self.lo);\n+            let loc1 = loc1.as_ref()\n+                           .map(|&(ref fm, line, col)| (&fm.name[..], line, col.to_usize()))\n+                           .unwrap_or((\"???\", 0, 0));\n+\n+            let loc2 = hcx.codemap().byte_pos_to_line_and_col(span_hi);\n+            let loc2 = loc2.as_ref()\n+                           .map(|&(ref fm, line, col)| (&fm.name[..], line, col.to_usize()))\n+                           .unwrap_or((\"???\", 0, 0));\n+\n+            if loc1.0 == loc2.0 {\n+                std_hash::Hash::hash(&0u8, hasher);\n+\n+                std_hash::Hash::hash(loc1.0, hasher);\n+                std_hash::Hash::hash(&loc1.1, hasher);\n+                std_hash::Hash::hash(&loc1.2, hasher);\n+\n+                // Do not hash the file name twice\n+                std_hash::Hash::hash(&loc2.1, hasher);\n+                std_hash::Hash::hash(&loc2.2, hasher);\n+            } else {\n+                std_hash::Hash::hash(&1u8, hasher);\n+\n+                std_hash::Hash::hash(loc1.0, hasher);\n+                std_hash::Hash::hash(&loc1.1, hasher);\n+                std_hash::Hash::hash(&loc1.2, hasher);\n+\n+                std_hash::Hash::hash(loc2.0, hasher);\n+                std_hash::Hash::hash(&loc2.1, hasher);\n+                std_hash::Hash::hash(&loc2.2, hasher);\n+            }\n+        }\n+\n+        if self.ctxt == SyntaxContext::empty() {\n+            0u8.hash_stable(hcx, hasher);\n+        } else {\n+            1u8.hash_stable(hcx, hasher);\n+            self.source_callsite().hash_stable(hcx, hasher);\n+        }\n+    }\n+}"}, {"sha": "6d11f2a87a413485ceb97bbaf6cdb2ebc4b8caf4", "filename": "src/librustc/ich/impls_const_math.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fich%2Fimpls_const_math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fich%2Fimpls_const_math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_const_math.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains `HashStable` implementations for various data types\n+//! from `rustc_const_math` in no particular order.\n+\n+impl_stable_hash_for!(enum ::rustc_const_math::ConstFloat {\n+    F32(val),\n+    F64(val)\n+});\n+\n+impl_stable_hash_for!(enum ::rustc_const_math::ConstInt {\n+    I8(val),\n+    I16(val),\n+    I32(val),\n+    I64(val),\n+    I128(val),\n+    Isize(val),\n+    U8(val),\n+    U16(val),\n+    U32(val),\n+    U64(val),\n+    U128(val),\n+    Usize(val)\n+});\n+\n+impl_stable_hash_for!(enum ::rustc_const_math::ConstIsize {\n+    Is16(i16),\n+    Is32(i32),\n+    Is64(i64)\n+});\n+\n+impl_stable_hash_for!(enum ::rustc_const_math::ConstUsize {\n+    Us16(i16),\n+    Us32(i32),\n+    Us64(i64)\n+});\n+\n+impl_stable_hash_for!(enum ::rustc_const_math::ConstMathErr {\n+    NotInRange,\n+    CmpBetweenUnequalTypes,\n+    UnequalTypes(op),\n+    Overflow(op),\n+    ShiftNegative,\n+    DivisionByZero,\n+    RemainderByZero,\n+    UnsignedNegation,\n+    ULitOutOfRange(int_ty),\n+    LitOutOfRange(int_ty)\n+});\n+\n+impl_stable_hash_for!(enum ::rustc_const_math::Op {\n+    Add,\n+    Sub,\n+    Mul,\n+    Div,\n+    Rem,\n+    Shr,\n+    Shl,\n+    Neg,\n+    BitAnd,\n+    BitOr,\n+    BitXor\n+});"}, {"sha": "fb18f50027e29602d2a9ea630f6619e3767a1da8", "filename": "src/librustc/ich/impls_hir.rs", "status": "added", "additions": 1104, "deletions": 0, "changes": 1104, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -0,0 +1,1104 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains `HashStable` implementations for various HIR data\n+//! types in no particular order.\n+\n+use hir;\n+use hir::def_id::DefId;\n+use ich::{StableHashingContext, NodeIdHashingMode};\n+use std::mem;\n+\n+use syntax::ast;\n+\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for DefId {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        hcx.def_path_hash(*self).hash_stable(hcx, hasher);\n+    }\n+}\n+\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::HirId {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::HirId {\n+            owner,\n+            local_id,\n+        } = *self;\n+\n+        hcx.def_path_hash(DefId::local(owner)).hash_stable(hcx, hasher);\n+        local_id.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(tuple_struct hir::ItemLocalId { index });\n+\n+// The following implementations of HashStable for ItemId, TraitItemId, and\n+// ImplItemId deserve special attention. Normally we do not hash NodeIds within\n+// the HIR, since they just signify a HIR nodes own path. But ItemId et al\n+// are used when another item in the HIR is *referenced* and we certainly\n+// want to pick up on a reference changing its target, so we hash the NodeIds\n+// in \"DefPath Mode\".\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::ItemId {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::ItemId {\n+            id\n+        } = *self;\n+\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            id.hash_stable(hcx, hasher);\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::TraitItemId {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::TraitItemId {\n+            node_id\n+        } = * self;\n+\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            node_id.hash_stable(hcx, hasher);\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::ImplItemId {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::ImplItemId {\n+            node_id\n+        } = * self;\n+\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            node_id.hash_stable(hcx, hasher);\n+        })\n+    }\n+}\n+\n+impl_stable_hash_for!(struct hir::Lifetime {\n+    id,\n+    span,\n+    name\n+});\n+\n+impl_stable_hash_for!(struct hir::LifetimeDef {\n+    lifetime,\n+    bounds,\n+    pure_wrt_drop\n+});\n+\n+impl_stable_hash_for!(struct hir::Path {\n+    span,\n+    def,\n+    segments\n+});\n+\n+impl_stable_hash_for!(struct hir::PathSegment {\n+    name,\n+    parameters\n+});\n+\n+impl_stable_hash_for!(enum hir::PathParameters {\n+    AngleBracketedParameters(data),\n+    ParenthesizedParameters(data)\n+});\n+\n+impl_stable_hash_for!(struct hir::AngleBracketedParameterData {\n+    lifetimes,\n+    types,\n+    infer_types,\n+    bindings\n+});\n+\n+impl_stable_hash_for!(struct hir::ParenthesizedParameterData {\n+    span,\n+    inputs,\n+    output\n+});\n+\n+impl_stable_hash_for!(enum hir::TyParamBound {\n+    TraitTyParamBound(poly_trait_ref, trait_bound_modifier),\n+    RegionTyParamBound(lifetime)\n+});\n+\n+impl_stable_hash_for!(enum hir::TraitBoundModifier {\n+    None,\n+    Maybe\n+});\n+\n+impl_stable_hash_for!(struct hir::TyParam {\n+    name,\n+    id,\n+    bounds,\n+    default,\n+    span,\n+    pure_wrt_drop\n+});\n+\n+impl_stable_hash_for!(struct hir::Generics {\n+    lifetimes,\n+    ty_params,\n+    where_clause,\n+    span\n+});\n+\n+impl_stable_hash_for!(struct hir::WhereClause {\n+    id,\n+    predicates\n+});\n+\n+impl_stable_hash_for!(enum hir::WherePredicate {\n+    BoundPredicate(pred),\n+    RegionPredicate(pred),\n+    EqPredicate(pred)\n+});\n+\n+impl_stable_hash_for!(struct hir::WhereBoundPredicate {\n+    span,\n+    bound_lifetimes,\n+    bounded_ty,\n+    bounds\n+});\n+\n+impl_stable_hash_for!(struct hir::WhereRegionPredicate {\n+    span,\n+    lifetime,\n+    bounds\n+});\n+\n+impl_stable_hash_for!(struct hir::WhereEqPredicate {\n+    id,\n+    span,\n+    lhs_ty,\n+    rhs_ty\n+});\n+\n+impl_stable_hash_for!(struct hir::MutTy {\n+    ty,\n+    mutbl\n+});\n+\n+impl_stable_hash_for!(struct hir::MethodSig {\n+    unsafety,\n+    constness,\n+    abi,\n+    decl,\n+    generics\n+});\n+\n+impl_stable_hash_for!(struct hir::TypeBinding {\n+    id,\n+    name,\n+    ty,\n+    span\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Ty {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let node_id_hashing_mode = match self.node {\n+            hir::TySlice(..)       |\n+            hir::TyArray(..)       |\n+            hir::TyPtr(..)         |\n+            hir::TyRptr(..)        |\n+            hir::TyBareFn(..)      |\n+            hir::TyNever           |\n+            hir::TyTup(..)         |\n+            hir::TyTraitObject(..) |\n+            hir::TyImplTrait(..)   |\n+            hir::TyTypeof(..)      |\n+            hir::TyInfer           => {\n+                NodeIdHashingMode::Ignore\n+            }\n+            hir::TyPath(..) => {\n+                NodeIdHashingMode::HashTraitsInScope\n+            }\n+        };\n+\n+        hcx.while_hashing_hir_bodies(true, |hcx| {\n+            let hir::Ty {\n+                id,\n+                ref node,\n+                ref span,\n+            } = *self;\n+\n+            hcx.with_node_id_hashing_mode(node_id_hashing_mode, |hcx| {\n+                id.hash_stable(hcx, hasher);\n+            });\n+            node.hash_stable(hcx, hasher);\n+            span.hash_stable(hcx, hasher);\n+        })\n+    }\n+}\n+\n+impl_stable_hash_for!(enum hir::PrimTy {\n+    TyInt(int_ty),\n+    TyUint(uint_ty),\n+    TyFloat(float_ty),\n+    TyStr,\n+    TyBool,\n+    TyChar\n+});\n+\n+impl_stable_hash_for!(struct hir::BareFnTy {\n+    unsafety,\n+    abi,\n+    lifetimes,\n+    decl\n+});\n+\n+impl_stable_hash_for!(enum hir::Ty_ {\n+    TySlice(t),\n+    TyArray(t, body_id),\n+    TyPtr(t),\n+    TyRptr(lifetime, t),\n+    TyBareFn(t),\n+    TyNever,\n+    TyTup(ts),\n+    TyPath(qpath),\n+    TyTraitObject(trait_refs, lifetime),\n+    TyImplTrait(bounds),\n+    TyTypeof(body_id),\n+    TyInfer\n+});\n+\n+impl_stable_hash_for!(struct hir::FnDecl {\n+    inputs,\n+    output,\n+    variadic,\n+    has_implicit_self\n+});\n+\n+impl_stable_hash_for!(enum hir::FunctionRetTy {\n+    DefaultReturn(span),\n+    Return(t)\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::TraitRef {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::TraitRef {\n+            ref path,\n+            ref_id,\n+        } = *self;\n+\n+        path.hash_stable(hcx, hasher);\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashTraitsInScope, |hcx| {\n+            ref_id.hash_stable(hcx, hasher);\n+        });\n+    }\n+}\n+\n+\n+impl_stable_hash_for!(struct hir::PolyTraitRef {\n+    bound_lifetimes,\n+    trait_ref,\n+    span\n+});\n+\n+impl_stable_hash_for!(enum hir::QPath {\n+    Resolved(t, path),\n+    TypeRelative(t, path_segment)\n+});\n+\n+impl_stable_hash_for!(struct hir::MacroDef {\n+    name,\n+    attrs,\n+    id,\n+    span,\n+    body\n+});\n+\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Block {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::Block {\n+            ref stmts,\n+            ref expr,\n+            id,\n+            rules,\n+            span,\n+            targeted_by_break,\n+        } = *self;\n+\n+        let non_item_stmts = || stmts.iter().filter(|stmt| {\n+            match stmt.node {\n+                hir::StmtDecl(ref decl, _) => {\n+                    match decl.node {\n+                        // If this is a declaration of a nested item, we don't\n+                        // want to leave any trace of it in the hash value, not\n+                        // even that it exists. Otherwise changing the position\n+                        // of nested items would invalidate the containing item\n+                        // even though that does not constitute a semantic\n+                        // change.\n+                        hir::DeclItem(_) => false,\n+                        hir::DeclLocal(_) => true\n+                    }\n+                }\n+                hir::StmtExpr(..) |\n+                hir::StmtSemi(..) => true\n+            }\n+        });\n+\n+        let count = non_item_stmts().count();\n+\n+        count.hash_stable(hcx, hasher);\n+\n+        for stmt in non_item_stmts() {\n+            stmt.hash_stable(hcx, hasher);\n+        }\n+\n+        expr.hash_stable(hcx, hasher);\n+        id.hash_stable(hcx, hasher);\n+        rules.hash_stable(hcx, hasher);\n+        span.hash_stable(hcx, hasher);\n+        targeted_by_break.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Pat {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let node_id_hashing_mode = match self.node {\n+            hir::PatKind::Wild        |\n+            hir::PatKind::Binding(..) |\n+            hir::PatKind::Tuple(..)   |\n+            hir::PatKind::Box(..)     |\n+            hir::PatKind::Ref(..)     |\n+            hir::PatKind::Lit(..)     |\n+            hir::PatKind::Range(..)   |\n+            hir::PatKind::Slice(..)   => {\n+                NodeIdHashingMode::Ignore\n+            }\n+            hir::PatKind::Path(..)        |\n+            hir::PatKind::Struct(..)      |\n+            hir::PatKind::TupleStruct(..) => {\n+                NodeIdHashingMode::HashTraitsInScope\n+            }\n+        };\n+\n+        let hir::Pat {\n+            id,\n+            ref node,\n+            ref span\n+        } = *self;\n+\n+        hcx.with_node_id_hashing_mode(node_id_hashing_mode, |hcx| {\n+            id.hash_stable(hcx, hasher);\n+        });\n+        node.hash_stable(hcx, hasher);\n+        span.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for_spanned!(hir::FieldPat);\n+impl_stable_hash_for!(struct hir::FieldPat {\n+    name,\n+    pat,\n+    is_shorthand\n+});\n+\n+impl_stable_hash_for!(enum hir::BindingMode {\n+    BindByRef(mutability),\n+    BindByValue(mutability)\n+});\n+\n+impl_stable_hash_for!(enum hir::RangeEnd {\n+    Included,\n+    Excluded\n+});\n+\n+impl_stable_hash_for!(enum hir::PatKind {\n+    Wild,\n+    Binding(binding_mode, var, name, sub),\n+    Struct(path, field_pats, dotdot),\n+    TupleStruct(path, field_pats, dotdot),\n+    Path(path),\n+    Tuple(field_pats, dotdot),\n+    Box(sub),\n+    Ref(sub, mutability),\n+    Lit(expr),\n+    Range(start, end, end_kind),\n+    Slice(one, two, three)\n+});\n+\n+impl_stable_hash_for!(enum hir::BinOp_ {\n+    BiAdd,\n+    BiSub,\n+    BiMul,\n+    BiDiv,\n+    BiRem,\n+    BiAnd,\n+    BiOr,\n+    BiBitXor,\n+    BiBitAnd,\n+    BiBitOr,\n+    BiShl,\n+    BiShr,\n+    BiEq,\n+    BiLt,\n+    BiLe,\n+    BiNe,\n+    BiGe,\n+    BiGt\n+});\n+\n+impl_stable_hash_for_spanned!(hir::BinOp_);\n+\n+impl_stable_hash_for!(enum hir::UnOp {\n+    UnDeref,\n+    UnNot,\n+    UnNeg\n+});\n+\n+impl_stable_hash_for_spanned!(hir::Stmt_);\n+\n+impl_stable_hash_for!(struct hir::Local {\n+    pat,\n+    ty,\n+    init,\n+    id,\n+    span,\n+    attrs\n+});\n+\n+impl_stable_hash_for_spanned!(hir::Decl_);\n+impl_stable_hash_for!(enum hir::Decl_ {\n+    DeclLocal(local),\n+    DeclItem(item_id)\n+});\n+\n+impl_stable_hash_for!(struct hir::Arm {\n+    attrs,\n+    pats,\n+    guard,\n+    body\n+});\n+\n+impl_stable_hash_for!(struct hir::Field {\n+    name,\n+    expr,\n+    span,\n+    is_shorthand\n+});\n+\n+impl_stable_hash_for_spanned!(ast::Name);\n+\n+\n+impl_stable_hash_for!(enum hir::BlockCheckMode {\n+    DefaultBlock,\n+    UnsafeBlock(src),\n+    PushUnsafeBlock(src),\n+    PopUnsafeBlock(src)\n+});\n+\n+impl_stable_hash_for!(enum hir::UnsafeSource {\n+    CompilerGenerated,\n+    UserProvided\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Expr {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        hcx.while_hashing_hir_bodies(true, |hcx| {\n+            let hir::Expr {\n+                id,\n+                ref span,\n+                ref node,\n+                ref attrs\n+            } = *self;\n+\n+            let (spans_always_on, node_id_hashing_mode) = match *node {\n+                hir::ExprBox(..)        |\n+                hir::ExprArray(..)      |\n+                hir::ExprCall(..)       |\n+                hir::ExprLit(..)        |\n+                hir::ExprCast(..)       |\n+                hir::ExprType(..)       |\n+                hir::ExprIf(..)         |\n+                hir::ExprWhile(..)      |\n+                hir::ExprLoop(..)       |\n+                hir::ExprMatch(..)      |\n+                hir::ExprClosure(..)    |\n+                hir::ExprBlock(..)      |\n+                hir::ExprAssign(..)     |\n+                hir::ExprTupField(..)   |\n+                hir::ExprAddrOf(..)     |\n+                hir::ExprBreak(..)      |\n+                hir::ExprAgain(..)      |\n+                hir::ExprRet(..)        |\n+                hir::ExprInlineAsm(..)  |\n+                hir::ExprRepeat(..)     |\n+                hir::ExprTup(..)        => {\n+                    // For these we only hash the span when debuginfo is on.\n+                    (false, NodeIdHashingMode::Ignore)\n+                }\n+                // For the following, spans might be significant because of\n+                // panic messages indicating the source location.\n+                hir::ExprBinary(op, ..) => {\n+                    (hcx.binop_can_panic_at_runtime(op.node), NodeIdHashingMode::Ignore)\n+                }\n+                hir::ExprUnary(op, _) => {\n+                    (hcx.unop_can_panic_at_runtime(op), NodeIdHashingMode::Ignore)\n+                }\n+                hir::ExprAssignOp(op, ..) => {\n+                    (hcx.binop_can_panic_at_runtime(op.node), NodeIdHashingMode::Ignore)\n+                }\n+                hir::ExprIndex(..) => {\n+                    (true, NodeIdHashingMode::Ignore)\n+                }\n+                // For these we don't care about the span, but want to hash the\n+                // trait in scope\n+                hir::ExprMethodCall(..) |\n+                hir::ExprPath(..)       |\n+                hir::ExprStruct(..)     |\n+                hir::ExprField(..)      => {\n+                    (false, NodeIdHashingMode::HashTraitsInScope)\n+                }\n+            };\n+\n+            hcx.with_node_id_hashing_mode(node_id_hashing_mode, |hcx| {\n+                id.hash_stable(hcx, hasher);\n+            });\n+\n+            if spans_always_on {\n+                hcx.while_hashing_spans(true, |hcx| {\n+                    span.hash_stable(hcx, hasher);\n+                    node.hash_stable(hcx, hasher);\n+                    attrs.hash_stable(hcx, hasher);\n+                });\n+            } else {\n+                span.hash_stable(hcx, hasher);\n+                node.hash_stable(hcx, hasher);\n+                attrs.hash_stable(hcx, hasher);\n+            }\n+        })\n+    }\n+}\n+\n+impl_stable_hash_for!(enum hir::Expr_ {\n+    ExprBox(sub),\n+    ExprArray(subs),\n+    ExprCall(callee, args),\n+    ExprMethodCall(name, ts, args),\n+    ExprTup(fields),\n+    ExprBinary(op, lhs, rhs),\n+    ExprUnary(op, operand),\n+    ExprLit(value),\n+    ExprCast(expr, t),\n+    ExprType(expr, t),\n+    ExprIf(cond, then, els),\n+    ExprWhile(cond, body, label),\n+    ExprLoop(body, label, loop_src),\n+    ExprMatch(matchee, arms, match_src),\n+    ExprClosure(capture_clause, decl, body_id, span),\n+    ExprBlock(blk),\n+    ExprAssign(lhs, rhs),\n+    ExprAssignOp(op, lhs, rhs),\n+    ExprField(owner, field_name),\n+    ExprTupField(owner, idx),\n+    ExprIndex(lhs, rhs),\n+    ExprPath(path),\n+    ExprAddrOf(mutability, sub),\n+    ExprBreak(destination, sub),\n+    ExprAgain(destination),\n+    ExprRet(val),\n+    ExprInlineAsm(asm, inputs, outputs),\n+    ExprStruct(path, fields, base),\n+    ExprRepeat(val, times)\n+});\n+\n+impl_stable_hash_for!(enum hir::LoopSource {\n+    Loop,\n+    WhileLet,\n+    ForLoop\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::MatchSource {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use hir::MatchSource;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            MatchSource::Normal |\n+            MatchSource::WhileLetDesugar |\n+            MatchSource::ForLoopDesugar |\n+            MatchSource::TryDesugar => {\n+                // No fields to hash.\n+            }\n+            MatchSource::IfLetDesugar { contains_else_clause } => {\n+                contains_else_clause.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum hir::CaptureClause {\n+    CaptureByValue,\n+    CaptureByRef\n+});\n+\n+impl_stable_hash_for_spanned!(usize);\n+\n+impl_stable_hash_for!(struct hir::Destination {\n+    ident,\n+    target_id\n+});\n+\n+impl_stable_hash_for_spanned!(ast::Ident);\n+\n+impl_stable_hash_for!(enum hir::LoopIdResult {\n+    Ok(node_id),\n+    Err(loop_id_error)\n+});\n+\n+impl_stable_hash_for!(enum hir::LoopIdError {\n+    OutsideLoopScope,\n+    UnlabeledCfInWhileCondition,\n+    UnresolvedLabel\n+});\n+\n+impl_stable_hash_for!(enum hir::ScopeTarget {\n+    Block(node_id),\n+    Loop(loop_id_result)\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::Ident {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ast::Ident {\n+            ref name,\n+            ctxt: _ // Ignore this\n+        } = *self;\n+\n+        name.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::TraitItem {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::TraitItem {\n+            id,\n+            name,\n+            ref attrs,\n+            ref node,\n+            span\n+        } = *self;\n+\n+        hcx.hash_hir_item_like(attrs, |hcx| {\n+            id.hash_stable(hcx, hasher);\n+            name.hash_stable(hcx, hasher);\n+            attrs.hash_stable(hcx, hasher);\n+            node.hash_stable(hcx, hasher);\n+            span.hash_stable(hcx, hasher);\n+        });\n+    }\n+}\n+\n+impl_stable_hash_for!(enum hir::TraitMethod {\n+    Required(name),\n+    Provided(body)\n+});\n+\n+impl_stable_hash_for!(enum hir::TraitItemKind {\n+    Const(t, body),\n+    Method(sig, method),\n+    Type(bounds, rhs)\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::ImplItem {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::ImplItem {\n+            id,\n+            name,\n+            ref vis,\n+            defaultness,\n+            ref attrs,\n+            ref node,\n+            span\n+        } = *self;\n+\n+        hcx.hash_hir_item_like(attrs, |hcx| {\n+            id.hash_stable(hcx, hasher);\n+            name.hash_stable(hcx, hasher);\n+            vis.hash_stable(hcx, hasher);\n+            defaultness.hash_stable(hcx, hasher);\n+            attrs.hash_stable(hcx, hasher);\n+            node.hash_stable(hcx, hasher);\n+            span.hash_stable(hcx, hasher);\n+        });\n+    }\n+}\n+\n+impl_stable_hash_for!(enum hir::ImplItemKind {\n+    Const(t, body),\n+    Method(sig, body),\n+    Type(t)\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Visibility {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            hir::Visibility::Public |\n+            hir::Visibility::Crate |\n+            hir::Visibility::Inherited => {\n+                // No fields to hash.\n+            }\n+            hir::Visibility::Restricted { ref path, id } => {\n+                hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashTraitsInScope, |hcx| {\n+                    id.hash_stable(hcx, hasher);\n+                });\n+                path.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Defaultness {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            hir::Defaultness::Final => {\n+                // No fields to hash.\n+            }\n+            hir::Defaultness::Default { has_value } => {\n+                has_value.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum hir::ImplPolarity {\n+    Positive,\n+    Negative\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Mod {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::Mod {\n+            inner,\n+            // We are not hashing the IDs of the items contained in the module.\n+            // This is harmless and matches the current behavior but it's not\n+            // actually correct. See issue #40876.\n+            item_ids: _,\n+        } = *self;\n+\n+        inner.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(struct hir::ForeignMod {\n+    abi,\n+    items\n+});\n+\n+impl_stable_hash_for!(struct hir::EnumDef {\n+    variants\n+});\n+\n+impl_stable_hash_for!(struct hir::Variant_ {\n+    name,\n+    attrs,\n+    data,\n+    disr_expr\n+});\n+\n+impl_stable_hash_for_spanned!(hir::Variant_);\n+\n+impl_stable_hash_for!(enum hir::UseKind {\n+    Single,\n+    Glob,\n+    ListStem\n+});\n+\n+impl_stable_hash_for!(struct hir::StructField {\n+    span,\n+    name,\n+    vis,\n+    id,\n+    ty,\n+    attrs\n+});\n+\n+impl_stable_hash_for!(enum hir::VariantData {\n+    Struct(fields, id),\n+    Tuple(fields, id),\n+    Unit(id)\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Item {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let node_id_hashing_mode = match self.node {\n+            hir::ItemExternCrate(..) |\n+            hir::ItemStatic(..)      |\n+            hir::ItemConst(..)       |\n+            hir::ItemFn(..)          |\n+            hir::ItemMod(..)         |\n+            hir::ItemForeignMod(..)  |\n+            hir::ItemTy(..)          |\n+            hir::ItemEnum(..)        |\n+            hir::ItemStruct(..)      |\n+            hir::ItemUnion(..)       |\n+            hir::ItemTrait(..)       |\n+            hir::ItemDefaultImpl(..) |\n+            hir::ItemImpl(..)        => {\n+                NodeIdHashingMode::Ignore\n+            }\n+            hir::ItemUse(..) => {\n+                NodeIdHashingMode::HashTraitsInScope\n+            }\n+        };\n+\n+        let hir::Item {\n+            name,\n+            ref attrs,\n+            id,\n+            ref node,\n+            ref vis,\n+            span\n+        } = *self;\n+\n+        hcx.hash_hir_item_like(attrs, |hcx| {\n+            hcx.with_node_id_hashing_mode(node_id_hashing_mode, |hcx| {\n+                id.hash_stable(hcx, hasher);\n+            });\n+            name.hash_stable(hcx, hasher);\n+            attrs.hash_stable(hcx, hasher);\n+            node.hash_stable(hcx, hasher);\n+            vis.hash_stable(hcx, hasher);\n+            span.hash_stable(hcx, hasher);\n+        });\n+    }\n+}\n+\n+impl_stable_hash_for!(enum hir::Item_ {\n+    ItemExternCrate(name),\n+    ItemUse(path, use_kind),\n+    ItemStatic(ty, mutability, body_id),\n+    ItemConst(ty, body_id),\n+    ItemFn(fn_decl, unsafety, constness, abi, generics, body_id),\n+    ItemMod(module),\n+    ItemForeignMod(foreign_mod),\n+    ItemTy(ty, generics),\n+    ItemEnum(enum_def, generics),\n+    ItemStruct(variant_data, generics),\n+    ItemUnion(variant_data, generics),\n+    ItemTrait(unsafety, generics, bounds, item_refs),\n+    ItemDefaultImpl(unsafety, trait_ref),\n+    ItemImpl(unsafety, impl_polarity, generics, trait_ref, ty, impl_item_refs)\n+});\n+\n+impl_stable_hash_for!(struct hir::TraitItemRef {\n+    id,\n+    name,\n+    kind,\n+    span,\n+    defaultness\n+});\n+\n+impl_stable_hash_for!(struct hir::ImplItemRef {\n+    id,\n+    name,\n+    kind,\n+    span,\n+    vis,\n+    defaultness\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::AssociatedItemKind {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            hir::AssociatedItemKind::Const |\n+            hir::AssociatedItemKind::Type => {\n+                // No fields to hash.\n+            }\n+            hir::AssociatedItemKind::Method { has_self } => {\n+                has_self.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct hir::ForeignItem {\n+    name,\n+    attrs,\n+    node,\n+    id,\n+    span,\n+    vis\n+});\n+\n+impl_stable_hash_for!(enum hir::ForeignItem_ {\n+    ForeignItemFn(fn_decl, arg_names, generics),\n+    ForeignItemStatic(ty, is_mutbl)\n+});\n+\n+impl_stable_hash_for!(enum hir::Stmt_ {\n+    StmtDecl(decl, id),\n+    StmtExpr(expr, id),\n+    StmtSemi(expr, id)\n+});\n+\n+impl_stable_hash_for!(struct hir::Arg {\n+    pat,\n+    id\n+});\n+\n+impl_stable_hash_for!(struct hir::Body {\n+    arguments,\n+    value\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::BodyId {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        if hcx.hash_bodies() {\n+            hcx.tcx().hir.body(*self).hash_stable(hcx, hasher);\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct hir::InlineAsmOutput {\n+    constraint,\n+    is_rw,\n+    is_indirect\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::InlineAsm {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::InlineAsm {\n+            asm,\n+            asm_str_style,\n+            ref outputs,\n+            ref inputs,\n+            ref clobbers,\n+            volatile,\n+            alignstack,\n+            dialect,\n+            ctxt: _, // This is used for error reporting\n+        } = *self;\n+\n+        asm.hash_stable(hcx, hasher);\n+        asm_str_style.hash_stable(hcx, hasher);\n+        outputs.hash_stable(hcx, hasher);\n+        inputs.hash_stable(hcx, hasher);\n+        clobbers.hash_stable(hcx, hasher);\n+        volatile.hash_stable(hcx, hasher);\n+        alignstack.hash_stable(hcx, hasher);\n+        dialect.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(enum hir::def::CtorKind {\n+    Fn,\n+    Const,\n+    Fictive\n+});\n+\n+impl_stable_hash_for!(enum hir::def::Def {\n+    Mod(def_id),\n+    Struct(def_id),\n+    Union(def_id),\n+    Enum(def_id),\n+    Variant(def_id),\n+    Trait(def_id),\n+    TyAlias(def_id),\n+    AssociatedTy(def_id),\n+    PrimTy(prim_ty),\n+    TyParam(def_id),\n+    SelfTy(trait_def_id, impl_def_id),\n+    Fn(def_id),\n+    Const(def_id),\n+    Static(def_id, is_mutbl),\n+    StructCtor(def_id, ctor_kind),\n+    VariantCtor(def_id, ctor_kind),\n+    Method(def_id),\n+    AssociatedConst(def_id),\n+    Local(def_id),\n+    Upvar(def_id, index, expr_id),\n+    Label(node_id),\n+    Macro(def_id, macro_kind),\n+    Err\n+});\n+\n+impl_stable_hash_for!(enum hir::Mutability {\n+    MutMutable,\n+    MutImmutable\n+});\n+\n+\n+impl_stable_hash_for!(enum hir::Unsafety {\n+    Unsafe,\n+    Normal\n+});\n+\n+\n+impl_stable_hash_for!(enum hir::Constness {\n+    Const,\n+    NotConst\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::def_id::DefIndex {\n+\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        DefId::local(*self).hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(struct hir::def::Export {\n+    name,\n+    def,\n+    span\n+});"}, {"sha": "401f7e1921ab49a3561cedb8ac808a87ef53395a", "filename": "src/librustc/ich/impls_mir.rs", "status": "added", "additions": 407, "deletions": 0, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -0,0 +1,407 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains `HashStable` implementations for various MIR data\n+//! types in no particular order.\n+\n+use ich::StableHashingContext;\n+use mir;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n+use std::mem;\n+\n+\n+impl_stable_hash_for!(struct mir::SourceInfo { span, scope });\n+impl_stable_hash_for!(enum mir::Mutability { Mut, Not });\n+impl_stable_hash_for!(enum mir::BorrowKind { Shared, Unique, Mut });\n+impl_stable_hash_for!(enum mir::LocalKind { Var, Temp, Arg, ReturnPointer });\n+impl_stable_hash_for!(struct mir::LocalDecl<'tcx> { mutability, ty, name, source_info });\n+impl_stable_hash_for!(struct mir::UpvarDecl { debug_name, by_ref });\n+impl_stable_hash_for!(struct mir::BasicBlockData<'tcx> { statements, terminator, is_cleanup });\n+impl_stable_hash_for!(struct mir::Terminator<'tcx> { source_info, kind });\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Local {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use rustc_data_structures::indexed_vec::Idx;\n+        self.index().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::BasicBlock {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use rustc_data_structures::indexed_vec::Idx;\n+        self.index().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Field {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use rustc_data_structures::indexed_vec::Idx;\n+        self.index().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::VisibilityScope {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use rustc_data_structures::indexed_vec::Idx;\n+        self.index().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Promoted {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use rustc_data_structures::indexed_vec::Idx;\n+        self.index().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::TerminatorKind<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            mir::TerminatorKind::Goto { ref target } => {\n+                target.hash_stable(hcx, hasher);\n+            }\n+            mir::TerminatorKind::SwitchInt { ref discr,\n+                                             switch_ty,\n+                                             ref values,\n+                                             ref targets } => {\n+                discr.hash_stable(hcx, hasher);\n+                switch_ty.hash_stable(hcx, hasher);\n+                values.hash_stable(hcx, hasher);\n+                targets.hash_stable(hcx, hasher);\n+            }\n+            mir::TerminatorKind::Resume |\n+            mir::TerminatorKind::Return |\n+            mir::TerminatorKind::Unreachable => {}\n+            mir::TerminatorKind::Drop { ref location, target, unwind } => {\n+                location.hash_stable(hcx, hasher);\n+                target.hash_stable(hcx, hasher);\n+                unwind.hash_stable(hcx, hasher);\n+            }\n+            mir::TerminatorKind::DropAndReplace { ref location,\n+                                                  ref value,\n+                                                  target,\n+                                                  unwind, } => {\n+                location.hash_stable(hcx, hasher);\n+                value.hash_stable(hcx, hasher);\n+                target.hash_stable(hcx, hasher);\n+                unwind.hash_stable(hcx, hasher);\n+            }\n+            mir::TerminatorKind::Call { ref func,\n+                                        ref args,\n+                                        ref destination,\n+                                        cleanup } => {\n+                func.hash_stable(hcx, hasher);\n+                args.hash_stable(hcx, hasher);\n+                destination.hash_stable(hcx, hasher);\n+                cleanup.hash_stable(hcx, hasher);\n+            }\n+            mir::TerminatorKind::Assert { ref cond,\n+                                          expected,\n+                                          ref msg,\n+                                          target,\n+                                          cleanup } => {\n+                cond.hash_stable(hcx, hasher);\n+                expected.hash_stable(hcx, hasher);\n+                msg.hash_stable(hcx, hasher);\n+                target.hash_stable(hcx, hasher);\n+                cleanup.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::AssertMessage<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            mir::AssertMessage::BoundsCheck { ref len, ref index } => {\n+                len.hash_stable(hcx, hasher);\n+                index.hash_stable(hcx, hasher);\n+            }\n+            mir::AssertMessage::Math(ref const_math_err) => {\n+                const_math_err.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct mir::Statement<'tcx> { source_info, kind });\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::StatementKind<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n+                lvalue.hash_stable(hcx, hasher);\n+                rvalue.hash_stable(hcx, hasher);\n+            }\n+            mir::StatementKind::SetDiscriminant { ref lvalue, variant_index } => {\n+                lvalue.hash_stable(hcx, hasher);\n+                variant_index.hash_stable(hcx, hasher);\n+            }\n+            mir::StatementKind::StorageLive(ref lvalue) |\n+            mir::StatementKind::StorageDead(ref lvalue) => {\n+                lvalue.hash_stable(hcx, hasher);\n+            }\n+            mir::StatementKind::Nop => {}\n+            mir::StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n+                asm.hash_stable(hcx, hasher);\n+                outputs.hash_stable(hcx, hasher);\n+                inputs.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Lvalue<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            mir::Lvalue::Local(ref local) => {\n+                local.hash_stable(hcx, hasher);\n+            }\n+            mir::Lvalue::Static(ref statik) => {\n+                statik.hash_stable(hcx, hasher);\n+            }\n+            mir::Lvalue::Projection(ref lvalue_projection) => {\n+                lvalue_projection.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx, B, V> HashStable<StableHashingContext<'a, 'tcx>> for mir::Projection<'tcx, B, V>\n+    where B: HashStable<StableHashingContext<'a, 'tcx>>,\n+          V: HashStable<StableHashingContext<'a, 'tcx>>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let mir::Projection {\n+            ref base,\n+            ref elem,\n+        } = *self;\n+\n+        base.hash_stable(hcx, hasher);\n+        elem.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx, V> HashStable<StableHashingContext<'a, 'tcx>> for mir::ProjectionElem<'tcx, V>\n+    where V: HashStable<StableHashingContext<'a, 'tcx>>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            mir::ProjectionElem::Deref => {}\n+            mir::ProjectionElem::Field(field, ty) => {\n+                field.hash_stable(hcx, hasher);\n+                ty.hash_stable(hcx, hasher);\n+            }\n+            mir::ProjectionElem::Index(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            mir::ProjectionElem::ConstantIndex { offset, min_length, from_end } => {\n+                offset.hash_stable(hcx, hasher);\n+                min_length.hash_stable(hcx, hasher);\n+                from_end.hash_stable(hcx, hasher);\n+            }\n+            mir::ProjectionElem::Subslice { from, to } => {\n+                from.hash_stable(hcx, hasher);\n+                to.hash_stable(hcx, hasher);\n+            }\n+            mir::ProjectionElem::Downcast(adt_def, variant) => {\n+                adt_def.hash_stable(hcx, hasher);\n+                variant.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct mir::VisibilityScopeData { span, parent_scope });\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Operand<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            mir::Operand::Consume(ref lvalue) => {\n+                lvalue.hash_stable(hcx, hasher);\n+            }\n+            mir::Operand::Constant(ref constant) => {\n+                constant.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Rvalue<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            mir::Rvalue::Use(ref operand) => {\n+                operand.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::Repeat(ref operand, ref val) => {\n+                operand.hash_stable(hcx, hasher);\n+                val.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::Ref(region, borrow_kind, ref lvalue) => {\n+                region.hash_stable(hcx, hasher);\n+                borrow_kind.hash_stable(hcx, hasher);\n+                lvalue.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::Len(ref lvalue) => {\n+                lvalue.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::Cast(cast_kind, ref operand, ty) => {\n+                cast_kind.hash_stable(hcx, hasher);\n+                operand.hash_stable(hcx, hasher);\n+                ty.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::BinaryOp(op, ref operand1, ref operand2) |\n+            mir::Rvalue::CheckedBinaryOp(op, ref operand1, ref operand2) => {\n+                op.hash_stable(hcx, hasher);\n+                operand1.hash_stable(hcx, hasher);\n+                operand2.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::UnaryOp(op, ref operand) => {\n+                op.hash_stable(hcx, hasher);\n+                operand.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::Discriminant(ref lvalue) => {\n+                lvalue.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::Box(ty) => {\n+                ty.hash_stable(hcx, hasher);\n+            }\n+            mir::Rvalue::Aggregate(ref kind, ref operands) => {\n+                kind.hash_stable(hcx, hasher);\n+                operands.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum mir::CastKind {\n+    Misc,\n+    ReifyFnPointer,\n+    ClosureFnPointer,\n+    UnsafeFnPointer,\n+    Unsize\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::AggregateKind<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            mir::AggregateKind::Tuple => {}\n+            mir::AggregateKind::Array(t) => {\n+                t.hash_stable(hcx, hasher);\n+            }\n+            mir::AggregateKind::Adt(adt_def, idx, substs, active_field) => {\n+                adt_def.hash_stable(hcx, hasher);\n+                idx.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+                active_field.hash_stable(hcx, hasher);\n+            }\n+            mir::AggregateKind::Closure(def_id, ref substs) => {\n+                def_id.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum mir::BinOp {\n+    Add,\n+    Sub,\n+    Mul,\n+    Div,\n+    Rem,\n+    BitXor,\n+    BitAnd,\n+    BitOr,\n+    Shl,\n+    Shr,\n+    Eq,\n+    Lt,\n+    Le,\n+    Ne,\n+    Ge,\n+    Gt\n+});\n+\n+impl_stable_hash_for!(enum mir::UnOp {\n+    Not,\n+    Neg\n+});\n+\n+\n+impl_stable_hash_for!(struct mir::Constant<'tcx> { span, ty, literal });\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Literal<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            mir::Literal::Item { def_id, substs } => {\n+                def_id.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+            }\n+            mir::Literal::Value { ref value } => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            mir::Literal::Promoted { index } => {\n+                index.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct mir::Location { block, statement_index });"}, {"sha": "26734500001f6d772327d64f712d074ab21d7c02", "filename": "src/librustc/ich/impls_syntax.rs", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -0,0 +1,301 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains `HashStable` implementations for various data types\n+//! from libsyntax in no particular order.\n+\n+use ich::StableHashingContext;\n+\n+use std::hash as std_hash;\n+use std::mem;\n+\n+use syntax::ast;\n+use syntax::parse::token;\n+use syntax::tokenstream;\n+use syntax_pos::Span;\n+\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n+use rustc_data_structures::accumulate_vec::AccumulateVec;\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::syntax::symbol::InternedString {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let s: &str = &**self;\n+        s.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::Name {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.as_str().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(enum ::syntax::ast::AsmDialect {\n+    Att,\n+    Intel\n+});\n+\n+impl_stable_hash_for!(enum ::syntax::ext::base::MacroKind {\n+    Bang,\n+    Attr,\n+    Derive\n+});\n+\n+\n+impl_stable_hash_for!(enum ::syntax::abi::Abi {\n+    Cdecl,\n+    Stdcall,\n+    Fastcall,\n+    Vectorcall,\n+    Aapcs,\n+    Win64,\n+    SysV64,\n+    PtxKernel,\n+    Msp430Interrupt,\n+    X86Interrupt,\n+    Rust,\n+    C,\n+    System,\n+    RustIntrinsic,\n+    RustCall,\n+    PlatformIntrinsic,\n+    Unadjusted\n+});\n+\n+impl_stable_hash_for!(struct ::syntax::attr::Deprecation { since, note });\n+impl_stable_hash_for!(struct ::syntax::attr::Stability { level, feature, rustc_depr });\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::syntax::attr::StabilityLevel {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ::syntax::attr::StabilityLevel::Unstable { ref reason, ref issue } => {\n+                reason.hash_stable(hcx, hasher);\n+                issue.hash_stable(hcx, hasher);\n+            }\n+            ::syntax::attr::StabilityLevel::Stable { ref since } => {\n+                since.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ::syntax::attr::RustcDeprecation { since, reason });\n+\n+\n+impl_stable_hash_for!(enum ::syntax::attr::IntType {\n+    SignedInt(int_ty),\n+    UnsignedInt(uint_ty)\n+});\n+\n+impl_stable_hash_for!(enum ::syntax::ast::LitIntType {\n+    Signed(int_ty),\n+    Unsigned(int_ty),\n+    Unsuffixed\n+});\n+\n+impl_stable_hash_for_spanned!(::syntax::ast::LitKind);\n+impl_stable_hash_for!(enum ::syntax::ast::LitKind {\n+    Str(value, style),\n+    ByteStr(value),\n+    Byte(value),\n+    Char(value),\n+    Int(value, lit_int_type),\n+    Float(value, float_ty),\n+    FloatUnsuffixed(value),\n+    Bool(value)\n+});\n+\n+impl_stable_hash_for!(enum ::syntax::ast::IntTy { Is, I8, I16, I32, I64, I128 });\n+impl_stable_hash_for!(enum ::syntax::ast::UintTy { Us, U8, U16, U32, U64, U128 });\n+impl_stable_hash_for!(enum ::syntax::ast::FloatTy { F32, F64 });\n+impl_stable_hash_for!(enum ::syntax::ast::Unsafety { Unsafe, Normal });\n+impl_stable_hash_for!(enum ::syntax::ast::Constness { Const, NotConst });\n+impl_stable_hash_for!(enum ::syntax::ast::Defaultness { Default, Final });\n+impl_stable_hash_for!(struct ::syntax::ast::Lifetime { id, span, name });\n+impl_stable_hash_for!(enum ::syntax::ast::StrStyle { Cooked, Raw(pounds) });\n+impl_stable_hash_for!(enum ::syntax::ast::AttrStyle { Outer, Inner });\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for [ast::Attribute] {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        // Some attributes are always ignored during hashing.\n+        let filtered: AccumulateVec<[&ast::Attribute; 8]> = self\n+            .iter()\n+            .filter(|attr| {\n+                !attr.is_sugared_doc &&\n+                attr.name().map(|name| !hcx.is_ignored_attr(name)).unwrap_or(true)\n+            })\n+            .collect();\n+\n+        filtered.len().hash_stable(hcx, hasher);\n+        for attr in filtered {\n+            attr.hash_stable(hcx, hasher);\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::Attribute {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        // Make sure that these have been filtered out.\n+        debug_assert!(self.name().map(|name| !hcx.is_ignored_attr(name)).unwrap_or(true));\n+        debug_assert!(!self.is_sugared_doc);\n+\n+        let ast::Attribute {\n+            id: _,\n+            style,\n+            ref path,\n+            ref tokens,\n+            is_sugared_doc: _,\n+            span,\n+        } = *self;\n+\n+        style.hash_stable(hcx, hasher);\n+        path.segments.len().hash_stable(hcx, hasher);\n+        for segment in &path.segments {\n+            segment.identifier.name.hash_stable(hcx, hasher);\n+        }\n+        for tt in tokens.trees() {\n+            tt.hash_stable(hcx, hasher);\n+        }\n+        span.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for tokenstream::TokenTree {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            tokenstream::TokenTree::Token(span, ref token) => {\n+                span.hash_stable(hcx, hasher);\n+                hash_token(token, hcx, hasher, span);\n+            }\n+            tokenstream::TokenTree::Delimited(span, ref delimited) => {\n+                span.hash_stable(hcx, hasher);\n+                std_hash::Hash::hash(&delimited.delim, hasher);\n+                for sub_tt in delimited.stream().trees() {\n+                    sub_tt.hash_stable(hcx, hasher);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for tokenstream::TokenStream {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        for sub_tt in self.trees() {\n+            sub_tt.hash_stable(hcx, hasher);\n+        }\n+    }\n+}\n+\n+fn hash_token<'a, 'tcx, W: StableHasherResult>(token: &token::Token,\n+                                               hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                               hasher: &mut StableHasher<W>,\n+                                               error_reporting_span: Span) {\n+    mem::discriminant(token).hash_stable(hcx, hasher);\n+    match *token {\n+        token::Token::Eq |\n+        token::Token::Lt |\n+        token::Token::Le |\n+        token::Token::EqEq |\n+        token::Token::Ne |\n+        token::Token::Ge |\n+        token::Token::Gt |\n+        token::Token::AndAnd |\n+        token::Token::OrOr |\n+        token::Token::Not |\n+        token::Token::Tilde |\n+        token::Token::At |\n+        token::Token::Dot |\n+        token::Token::DotDot |\n+        token::Token::DotDotDot |\n+        token::Token::Comma |\n+        token::Token::Semi |\n+        token::Token::Colon |\n+        token::Token::ModSep |\n+        token::Token::RArrow |\n+        token::Token::LArrow |\n+        token::Token::FatArrow |\n+        token::Token::Pound |\n+        token::Token::Dollar |\n+        token::Token::Question |\n+        token::Token::Underscore |\n+        token::Token::Whitespace |\n+        token::Token::Comment |\n+        token::Token::Eof => {}\n+\n+        token::Token::BinOp(bin_op_token) |\n+        token::Token::BinOpEq(bin_op_token) => {\n+            std_hash::Hash::hash(&bin_op_token, hasher);\n+        }\n+\n+        token::Token::OpenDelim(delim_token) |\n+        token::Token::CloseDelim(delim_token) => {\n+            std_hash::Hash::hash(&delim_token, hasher);\n+        }\n+        token::Token::Literal(ref lit, ref opt_name) => {\n+            mem::discriminant(lit).hash_stable(hcx, hasher);\n+            match *lit {\n+                token::Lit::Byte(val) |\n+                token::Lit::Char(val) |\n+                token::Lit::Integer(val) |\n+                token::Lit::Float(val) |\n+                token::Lit::Str_(val) |\n+                token::Lit::ByteStr(val) => val.hash_stable(hcx, hasher),\n+                token::Lit::StrRaw(val, n) |\n+                token::Lit::ByteStrRaw(val, n) => {\n+                    val.hash_stable(hcx, hasher);\n+                    n.hash_stable(hcx, hasher);\n+                }\n+            };\n+            opt_name.hash_stable(hcx, hasher);\n+        }\n+\n+        token::Token::Ident(ident) |\n+        token::Token::Lifetime(ident) |\n+        token::Token::SubstNt(ident) => ident.name.hash_stable(hcx, hasher),\n+\n+        token::Token::Interpolated(ref non_terminal) => {\n+            // FIXME(mw): This could be implemented properly. It's just a\n+            //            lot of work, since we would need to hash the AST\n+            //            in a stable way, in addition to the HIR.\n+            //            Since this is hardly used anywhere, just emit a\n+            //            warning for now.\n+            if hcx.tcx().sess.opts.debugging_opts.incremental.is_some() {\n+                let msg = format!(\"Quasi-quoting might make incremental \\\n+                                   compilation very inefficient: {:?}\",\n+                                  non_terminal);\n+                hcx.tcx().sess.span_warn(error_reporting_span, &msg[..]);\n+            }\n+\n+            std_hash::Hash::hash(non_terminal, hasher);\n+        }\n+\n+        token::Token::DocComment(val) |\n+        token::Token::Shebang(val) => val.hash_stable(hcx, hasher),\n+    }\n+}"}, {"sha": "7b6f3af2a11ec88582d572128185e17c029b4a43", "filename": "src/librustc/ich/impls_ty.rs", "status": "added", "additions": 415, "deletions": 0, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -0,0 +1,415 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains `HashStable` implementations for various data types\n+//! from rustc::ty in no particular order.\n+\n+use ich::StableHashingContext;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n+use std::hash as std_hash;\n+use std::mem;\n+use ty;\n+\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Ty<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let type_hash = hcx.tcx().type_id_hash(*self);\n+        type_hash.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::ItemSubsts<'tcx> { substs });\n+\n+impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>> for ty::Slice<T>\n+    where T: HashStable<StableHashingContext<'a, 'tcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        (&**self).hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::subst::Kind<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.as_type().hash_stable(hcx, hasher);\n+        self.as_region().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Region {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ty::ReErased |\n+            ty::ReStatic |\n+            ty::ReEmpty => {\n+                // No variant fields to hash for these ...\n+            }\n+            ty::ReLateBound(db, ty::BrAnon(i)) => {\n+                db.depth.hash_stable(hcx, hasher);\n+                i.hash_stable(hcx, hasher);\n+            }\n+            ty::ReEarlyBound(ty::EarlyBoundRegion { index, name }) => {\n+                index.hash_stable(hcx, hasher);\n+                name.hash_stable(hcx, hasher);\n+            }\n+            ty::ReLateBound(..) |\n+            ty::ReFree(..) |\n+            ty::ReScope(..) |\n+            ty::ReVar(..) |\n+            ty::ReSkolemized(..) => {\n+                bug!(\"TypeIdHasher: unexpected region {:?}\", *self)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::adjustment::AutoBorrow<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ty::adjustment::AutoBorrow::Ref(ref region, mutability) => {\n+                region.hash_stable(hcx, hasher);\n+                mutability.hash_stable(hcx, hasher);\n+            }\n+            ty::adjustment::AutoBorrow::RawPtr(mutability) => {\n+                mutability.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::adjustment::Adjust<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ty::adjustment::Adjust::NeverToAny |\n+            ty::adjustment::Adjust::ReifyFnPointer |\n+            ty::adjustment::Adjust::UnsafeFnPointer |\n+            ty::adjustment::Adjust::ClosureFnPointer |\n+            ty::adjustment::Adjust::MutToConstPointer => {}\n+            ty::adjustment::Adjust::DerefRef { autoderefs, ref autoref, unsize } => {\n+                autoderefs.hash_stable(hcx, hasher);\n+                autoref.hash_stable(hcx, hasher);\n+                unsize.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::adjustment::Adjustment<'tcx> { kind, target });\n+impl_stable_hash_for!(struct ty::MethodCall { expr_id, autoderef });\n+impl_stable_hash_for!(struct ty::MethodCallee<'tcx> { def_id, ty, substs });\n+impl_stable_hash_for!(struct ty::UpvarId { var_id, closure_expr_id });\n+impl_stable_hash_for!(struct ty::UpvarBorrow<'tcx> { kind, region });\n+\n+impl_stable_hash_for!(enum ty::BorrowKind {\n+    ImmBorrow,\n+    UniqueImmBorrow,\n+    MutBorrow\n+});\n+\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::UpvarCapture<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ty::UpvarCapture::ByValue => {}\n+            ty::UpvarCapture::ByRef(ref up_var_borrow) => {\n+                up_var_borrow.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::FnSig<'tcx> {\n+    inputs_and_output,\n+    variadic,\n+    unsafety,\n+    abi\n+});\n+\n+impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>> for ty::Binder<T>\n+    where T: HashStable<StableHashingContext<'a, 'tcx>> + ty::fold::TypeFoldable<'tcx>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        hcx.tcx().anonymize_late_bound_regions(self).0.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(enum ty::ClosureKind { Fn, FnMut, FnOnce });\n+\n+impl_stable_hash_for!(enum ty::Visibility {\n+    Public,\n+    Restricted(def_id),\n+    Invisible\n+});\n+\n+impl_stable_hash_for!(struct ty::TraitRef<'tcx> { def_id, substs });\n+impl_stable_hash_for!(struct ty::TraitPredicate<'tcx> { trait_ref });\n+impl_stable_hash_for!(tuple_struct ty::EquatePredicate<'tcx> { t1, t2 });\n+\n+impl<'a, 'tcx, A, B> HashStable<StableHashingContext<'a, 'tcx>> for ty::OutlivesPredicate<A, B>\n+    where A: HashStable<StableHashingContext<'a, 'tcx>>,\n+          B: HashStable<StableHashingContext<'a, 'tcx>>,\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ty::OutlivesPredicate(ref a, ref b) = *self;\n+        a.hash_stable(hcx, hasher);\n+        b.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::ProjectionPredicate<'tcx> { projection_ty, ty });\n+impl_stable_hash_for!(struct ty::ProjectionTy<'tcx> { trait_ref, item_name });\n+\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Predicate<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ty::Predicate::Trait(ref pred) => {\n+                pred.hash_stable(hcx, hasher);\n+            }\n+            ty::Predicate::Equate(ref pred) => {\n+                pred.hash_stable(hcx, hasher);\n+            }\n+            ty::Predicate::RegionOutlives(ref pred) => {\n+                pred.hash_stable(hcx, hasher);\n+            }\n+            ty::Predicate::TypeOutlives(ref pred) => {\n+                pred.hash_stable(hcx, hasher);\n+            }\n+            ty::Predicate::Projection(ref pred) => {\n+                pred.hash_stable(hcx, hasher);\n+            }\n+            ty::Predicate::WellFormed(ty) => {\n+                ty.hash_stable(hcx, hasher);\n+            }\n+            ty::Predicate::ObjectSafe(def_id) => {\n+                def_id.hash_stable(hcx, hasher);\n+            }\n+            ty::Predicate::ClosureKind(def_id, closure_kind) => {\n+                def_id.hash_stable(hcx, hasher);\n+                closure_kind.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::AdtFlags {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          _: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        std_hash::Hash::hash(self, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::VariantDef {\n+    did,\n+    name,\n+    discr,\n+    fields,\n+    ctor_kind\n+});\n+\n+impl_stable_hash_for!(enum ty::VariantDiscr {\n+    Explicit(def_id),\n+    Relative(distance)\n+});\n+\n+impl_stable_hash_for!(struct ty::FieldDef {\n+    did,\n+    name,\n+    vis\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>>\n+for ::middle::const_val::ConstVal<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use middle::const_val::ConstVal;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            ConstVal::Float(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Integral(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Str(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::ByteStr(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Bool(value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Function(def_id, substs) => {\n+                def_id.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Struct(ref _name_value_map) => {\n+                // BTreeMap<ast::Name, ConstVal<'tcx>>),\n+                panic!(\"Ordering still unstable\")\n+            }\n+            ConstVal::Tuple(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Array(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Repeat(ref value, times) => {\n+                value.hash_stable(hcx, hasher);\n+                times.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Char(value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::ClosureSubsts<'tcx> { substs });\n+\n+\n+impl_stable_hash_for!(struct ty::GenericPredicates<'tcx> {\n+    parent,\n+    predicates\n+});\n+\n+impl_stable_hash_for!(enum ty::Variance {\n+    Covariant,\n+    Invariant,\n+    Contravariant,\n+    Bivariant\n+});\n+\n+impl_stable_hash_for!(enum ty::adjustment::CustomCoerceUnsized {\n+    Struct(index)\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Generics {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ty::Generics {\n+            parent,\n+            parent_regions,\n+            parent_types,\n+            ref regions,\n+            ref types,\n+\n+            // Reverse map to each `TypeParameterDef`'s `index` field, from\n+            // `def_id.index` (`def_id.krate` is the same as the item's).\n+            type_param_to_index: _, // Don't hash this\n+            has_self,\n+        } = *self;\n+\n+        parent.hash_stable(hcx, hasher);\n+        parent_regions.hash_stable(hcx, hasher);\n+        parent_types.hash_stable(hcx, hasher);\n+        regions.hash_stable(hcx, hasher);\n+        types.hash_stable(hcx, hasher);\n+        has_self.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::RegionParameterDef {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ty::RegionParameterDef {\n+            name,\n+            def_id,\n+            index,\n+            issue_32330: _,\n+            pure_wrt_drop\n+        } = *self;\n+\n+        name.hash_stable(hcx, hasher);\n+        def_id.hash_stable(hcx, hasher);\n+        index.hash_stable(hcx, hasher);\n+        pure_wrt_drop.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::TypeParameterDef {\n+    name,\n+    def_id,\n+    index,\n+    has_default,\n+    object_lifetime_default,\n+    pure_wrt_drop\n+});\n+\n+\n+impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>>\n+for ::middle::resolve_lifetime::Set1<T>\n+    where T: HashStable<StableHashingContext<'a, 'tcx>>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use middle::resolve_lifetime::Set1;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            Set1::Empty |\n+            Set1::Many => {\n+                // Nothing to do.\n+            }\n+            Set1::One(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum ::middle::resolve_lifetime::Region {\n+    Static,\n+    EarlyBound(index, decl),\n+    LateBound(db_index, decl),\n+    LateBoundAnon(db_index, anon_index),\n+    Free(call_site_scope_data, decl)\n+});\n+\n+impl_stable_hash_for!(struct ::middle::region::CallSiteScopeData {\n+    fn_id,\n+    body_id\n+});\n+\n+impl_stable_hash_for!(struct ty::DebruijnIndex {\n+    depth\n+});"}, {"sha": "f0601a0efabf89e87390c67498c3e6c436d6a48d", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -8,20 +8,44 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! ICH - Incremental Compilation Hash\n+\n pub use self::fingerprint::Fingerprint;\n pub use self::def_path_hash::DefPathHashes;\n pub use self::caching_codemap_view::CachingCodemapView;\n+pub use self::hcx::{StableHashingContext, NodeIdHashingMode};\n \n mod fingerprint;\n mod def_path_hash;\n mod caching_codemap_view;\n+mod hcx;\n+\n+mod impls_const_math;\n+mod impls_hir;\n+mod impls_mir;\n+mod impls_ty;\n+mod impls_syntax;\n \n pub const ATTR_DIRTY: &'static str = \"rustc_dirty\";\n pub const ATTR_CLEAN: &'static str = \"rustc_clean\";\n pub const ATTR_DIRTY_METADATA: &'static str = \"rustc_metadata_dirty\";\n pub const ATTR_CLEAN_METADATA: &'static str = \"rustc_metadata_clean\";\n pub const ATTR_IF_THIS_CHANGED: &'static str = \"rustc_if_this_changed\";\n pub const ATTR_THEN_THIS_WOULD_NEED: &'static str = \"rustc_then_this_would_need\";\n+pub const ATTR_PARTITION_REUSED: &'static str = \"rustc_partition_reused\";\n+pub const ATTR_PARTITION_TRANSLATED: &'static str = \"rustc_partition_translated\";\n+\n+\n+pub const DEP_GRAPH_ASSERT_ATTRS: &'static [&'static str] = &[\n+    ATTR_IF_THIS_CHANGED,\n+    ATTR_THEN_THIS_WOULD_NEED,\n+    ATTR_DIRTY,\n+    ATTR_CLEAN,\n+    ATTR_DIRTY_METADATA,\n+    ATTR_CLEAN_METADATA,\n+    ATTR_PARTITION_REUSED,\n+    ATTR_PARTITION_TRANSLATED,\n+];\n \n pub const IGNORED_ATTRIBUTES: &'static [&'static str] = &[\n     \"cfg\",\n@@ -30,5 +54,7 @@ pub const IGNORED_ATTRIBUTES: &'static [&'static str] = &[\n     ATTR_DIRTY,\n     ATTR_CLEAN,\n     ATTR_DIRTY_METADATA,\n-    ATTR_CLEAN_METADATA\n+    ATTR_CLEAN_METADATA,\n+    ATTR_PARTITION_REUSED,\n+    ATTR_PARTITION_TRANSLATED,\n ];"}, {"sha": "3b002fd4dfc1a210e8445eb9e2cd8469beac0c68", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -41,6 +41,7 @@\n #![feature(specialization)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n+#![feature(discriminant_value)]\n \n extern crate arena;\n extern crate core;"}, {"sha": "c18e585f79553bd1791ca22614efb51701389829", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-tidy-linelength\n+\n macro_rules! enum_from_u32 {\n     ($(#[$attr:meta])* pub enum $name:ident {\n         $($variant:ident = $e:expr,)*\n@@ -59,3 +61,80 @@ macro_rules! span_bug {\n         $crate::session::span_bug_fmt(file!(), line!(), $span, format_args!($($message)*))\n     })\n }\n+\n+#[macro_export]\n+macro_rules! __impl_stable_hash_field {\n+    (DECL IGNORED) => (_);\n+    (DECL $name:ident) => (ref $name);\n+    (USE IGNORED $ctx:expr, $hasher:expr) => ({});\n+    (USE $name:ident, $ctx:expr, $hasher:expr) => ($name.hash_stable($ctx, $hasher));\n+}\n+\n+#[macro_export]\n+macro_rules! impl_stable_hash_for {\n+    (enum $enum_name:path { $( $variant:ident $( ( $($arg:ident),* ) )* ),* }) => {\n+        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'tcx>> for $enum_name {\n+            #[inline]\n+            fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'tcx>,\n+                                                  __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n+                use $enum_name::*;\n+                ::std::mem::discriminant(self).hash_stable(__ctx, __hasher);\n+\n+                match *self {\n+                    $(\n+                        $variant $( ( $( __impl_stable_hash_field!(DECL $arg) ),* ) )* => {\n+                            $($( __impl_stable_hash_field!(USE $arg, __ctx, __hasher) );*)*\n+                        }\n+                    )*\n+                }\n+            }\n+        }\n+    };\n+    (struct $struct_name:path { $($field:ident),* }) => {\n+        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'tcx>> for $struct_name {\n+            #[inline]\n+            fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'tcx>,\n+                                                  __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n+                let $struct_name {\n+                    $(ref $field),*\n+                } = *self;\n+\n+                $( $field.hash_stable(__ctx, __hasher));*\n+            }\n+        }\n+    };\n+    (tuple_struct $struct_name:path { $($field:ident),* }) => {\n+        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'tcx>> for $struct_name {\n+            #[inline]\n+            fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'tcx>,\n+                                                  __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n+                let $struct_name (\n+                    $(ref $field),*\n+                ) = *self;\n+\n+                $( $field.hash_stable(__ctx, __hasher));*\n+            }\n+        }\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! impl_stable_hash_for_spanned {\n+    ($T:path) => (\n+\n+        impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::syntax::codemap::Spanned<$T>\n+        {\n+            #[inline]\n+            fn hash_stable<W: StableHasherResult>(&self,\n+                                                  hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                                  hasher: &mut StableHasher<W>) {\n+                self.node.hash_stable(hcx, hasher);\n+                self.span.hash_stable(hcx, hasher);\n+            }\n+        }\n+    );\n+}\n+"}, {"sha": "7d3c17a048917adf85f0477eae8ce3e0bf29d801", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -202,11 +202,14 @@ pub enum ImmutabilityBlame<'tcx> {\n }\n \n impl<'tcx> cmt_<'tcx> {\n-    fn resolve_field(&self, field_name: FieldName) -> (&'tcx ty::AdtDef, &'tcx ty::FieldDef)\n+    fn resolve_field(&self, field_name: FieldName) -> Option<(&'tcx ty::AdtDef, &'tcx ty::FieldDef)>\n     {\n-        let adt_def = self.ty.ty_adt_def().unwrap_or_else(|| {\n-            bug!(\"interior cmt {:?} is not an ADT\", self)\n-        });\n+        let adt_def = match self.ty.sty {\n+            ty::TyAdt(def, _) => def,\n+            ty::TyTuple(..) => return None,\n+            // closures get `Categorization::Upvar` rather than `Categorization::Interior`\n+            _ =>  bug!(\"interior cmt {:?} is not an ADT\", self)\n+        };\n         let variant_def = match self.cat {\n             Categorization::Downcast(_, variant_did) => {\n                 adt_def.variant_with_id(variant_did)\n@@ -220,7 +223,7 @@ impl<'tcx> cmt_<'tcx> {\n             NamedField(name) => variant_def.field_named(name),\n             PositionalField(idx) => &variant_def.fields[idx]\n         };\n-        (adt_def, field_def)\n+        Some((adt_def, field_def))\n     }\n \n     pub fn immutability_blame(&self) -> Option<ImmutabilityBlame<'tcx>> {\n@@ -232,8 +235,9 @@ impl<'tcx> cmt_<'tcx> {\n                     Categorization::Local(node_id) =>\n                         Some(ImmutabilityBlame::LocalDeref(node_id)),\n                     Categorization::Interior(ref base_cmt, InteriorField(field_name)) => {\n-                        let (adt_def, field_def) = base_cmt.resolve_field(field_name);\n-                        Some(ImmutabilityBlame::AdtFieldDeref(adt_def, field_def))\n+                        base_cmt.resolve_field(field_name).map(|(adt_def, field_def)| {\n+                            ImmutabilityBlame::AdtFieldDeref(adt_def, field_def)\n+                        })\n                     }\n                     Categorization::Upvar(Upvar { id, .. }) => {\n                         if let NoteClosureEnv(..) = self.note {"}, {"sha": "799686ceca4a0ec97021d7ed5343d0d24c417b7f", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -10,7 +10,9 @@\n \n use std::cell::{Ref, RefCell};\n use rustc_data_structures::indexed_vec::IndexVec;\n-\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n+use ich::StableHashingContext;\n use mir::{Mir, BasicBlock};\n \n use rustc_serialize as serialize;\n@@ -33,6 +35,13 @@ impl serialize::Decodable for Cache {\n     }\n }\n \n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for Cache {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          _: &mut StableHashingContext<'a, 'tcx>,\n+                                          _: &mut StableHasher<W>) {\n+        // do nothing\n+    }\n+}\n \n impl Cache {\n     pub fn new() -> Self {"}, {"sha": "aea4684e526ce3a04c454a23bb93075c0b8ebf9d", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -243,6 +243,19 @@ impl<'tcx> Mir<'tcx> {\n     }\n }\n \n+impl_stable_hash_for!(struct Mir<'tcx> {\n+    basic_blocks,\n+    visibility_scopes,\n+    promoted,\n+    return_ty,\n+    local_decls,\n+    arg_count,\n+    upvar_decls,\n+    spread_arg,\n+    span,\n+    cache\n+});\n+\n impl<'tcx> Index<BasicBlock> for Mir<'tcx> {\n     type Output = BasicBlockData<'tcx>;\n \n@@ -830,6 +843,11 @@ pub struct Static<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n+impl_stable_hash_for!(struct Static<'tcx> {\n+    def_id,\n+    ty\n+});\n+\n /// The `Projection` data structure defines things of the form `B.x`\n /// or `*B` or `B[index]`. Note that it is parameterized because it is\n /// shared between `Constant` and `Lvalue`. See the aliases"}, {"sha": "3c529a69820427052525d8fc999fc79ba552b3df", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -19,6 +19,7 @@ use dep_graph::{self, DepNode};\n use hir::{map as hir_map, FreevarMap, TraitMap};\n use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use ich::StableHashingContext;\n use middle::const_val::ConstVal;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::privacy::AccessLevels;\n@@ -50,6 +51,8 @@ use syntax_pos::{DUMMY_SP, Span};\n use rustc_const_math::ConstInt;\n \n use rustc_data_structures::accumulate_vec::IntoIter as AccIntoIter;\n+use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n+                                           HashStable};\n \n use hir;\n use hir::itemlikevisit::ItemLikeVisitor;\n@@ -1379,6 +1382,25 @@ impl<'tcx> serialize::UseSpecializedEncodable for &'tcx AdtDef {\n \n impl<'tcx> serialize::UseSpecializedDecodable for &'tcx AdtDef {}\n \n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for AdtDef {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ty::AdtDef {\n+            did,\n+            ref variants,\n+            ref flags,\n+            ref repr,\n+        } = *self;\n+\n+        did.hash_stable(hcx, hasher);\n+        variants.hash_stable(hcx, hasher);\n+        flags.hash_stable(hcx, hasher);\n+        repr.hash_stable(hcx, hasher);\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum AdtKind { Struct, Union, Enum }\n \n@@ -1391,6 +1413,13 @@ pub struct ReprOptions {\n     pub int: Option<attr::IntType>,\n }\n \n+impl_stable_hash_for!(struct ReprOptions {\n+    c,\n+    packed,\n+    simd,\n+    int\n+});\n+\n impl ReprOptions {\n     pub fn new(tcx: TyCtxt, did: DefId) -> ReprOptions {\n         let mut ret = ReprOptions::default();"}, {"sha": "54f5cff16ed6cb584b888d46983820938f5e9d1e", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -490,6 +490,17 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n               _ => span_bug!(e.span, \"typeck error\"),\n              })\n           }\n+          (Char(a), Char(b)) => {\n+            Bool(match op.node {\n+              hir::BiEq => a == b,\n+              hir::BiNe => a != b,\n+              hir::BiLt => a < b,\n+              hir::BiLe => a <= b,\n+              hir::BiGe => a >= b,\n+              hir::BiGt => a > b,\n+              _ => span_bug!(e.span, \"typeck error\"),\n+             })\n+          }\n \n           _ => signal!(e, MiscBinaryOp),\n         }"}, {"sha": "c1735b4a4ec9a588156757293152deb775fa1129", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -37,6 +37,8 @@\n #![feature(unsize)]\n #![feature(i128_type)]\n #![feature(conservative_impl_trait)]\n+#![feature(discriminant_value)]\n+#![feature(specialization)]\n \n #![cfg_attr(unix, feature(libc))]\n #![cfg_attr(test, feature(test))]"}, {"sha": "dc412a0763ef70f196eed9134bfa930f21a40570", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 191, "deletions": 1, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::hash::Hasher;\n+use std::hash::{Hash, Hasher};\n use std::marker::PhantomData;\n use std::mem;\n use blake2b::Blake2bHasher;\n@@ -174,3 +174,193 @@ impl<W> Hasher for StableHasher<W> {\n         self.write_ileb128(i as i64);\n     }\n }\n+\n+\n+/// Something that implements `HashStable<CTX>` can be hashed in a way that is\n+/// stable across multiple compiliation sessions.\n+pub trait HashStable<CTX> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>);\n+}\n+\n+// Implement HashStable by just calling `Hash::hash()`. This works fine for\n+// self-contained values that don't depend on the hashing context `CTX`.\n+macro_rules! impl_stable_hash_via_hash {\n+    ($t:ty) => (\n+        impl<CTX> HashStable<CTX> for $t {\n+            #[inline]\n+            fn hash_stable<W: StableHasherResult>(&self,\n+                                                  _: &mut CTX,\n+                                                  hasher: &mut StableHasher<W>) {\n+                ::std::hash::Hash::hash(self, hasher);\n+            }\n+        }\n+    );\n+}\n+\n+impl_stable_hash_via_hash!(i8);\n+impl_stable_hash_via_hash!(i16);\n+impl_stable_hash_via_hash!(i32);\n+impl_stable_hash_via_hash!(i64);\n+impl_stable_hash_via_hash!(isize);\n+\n+impl_stable_hash_via_hash!(u8);\n+impl_stable_hash_via_hash!(u16);\n+impl_stable_hash_via_hash!(u32);\n+impl_stable_hash_via_hash!(u64);\n+impl_stable_hash_via_hash!(usize);\n+\n+impl_stable_hash_via_hash!(u128);\n+impl_stable_hash_via_hash!(i128);\n+\n+impl_stable_hash_via_hash!(char);\n+impl_stable_hash_via_hash!(());\n+\n+impl<CTX> HashStable<CTX> for f32 {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        let val: u32 = unsafe {\n+            ::std::mem::transmute(*self)\n+        };\n+        val.hash_stable(ctx, hasher);\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for f64 {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        let val: u64 = unsafe {\n+            ::std::mem::transmute(*self)\n+        };\n+        val.hash_stable(ctx, hasher);\n+    }\n+}\n+\n+impl<T1: HashStable<CTX>, T2: HashStable<CTX>, CTX> HashStable<CTX> for (T1, T2) {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.0.hash_stable(ctx, hasher);\n+        self.1.hash_stable(ctx, hasher);\n+    }\n+}\n+\n+impl<T: HashStable<CTX>, CTX> HashStable<CTX> for [T] {\n+    default fn hash_stable<W: StableHasherResult>(&self,\n+                                                  ctx: &mut CTX,\n+                                                  hasher: &mut StableHasher<W>) {\n+        self.len().hash_stable(ctx, hasher);\n+        for item in self {\n+            item.hash_stable(ctx, hasher);\n+        }\n+    }\n+}\n+\n+impl<T: HashStable<CTX>, CTX> HashStable<CTX> for Vec<T> {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        (&self[..]).hash_stable(ctx, hasher);\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for str {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          _: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.len().hash(hasher);\n+        self.as_bytes().hash(hasher);\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for bool {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        (if *self { 1u8 } else { 0u8 }).hash_stable(ctx, hasher);\n+    }\n+}\n+\n+\n+impl<T, CTX> HashStable<CTX> for Option<T>\n+    where T: HashStable<CTX>\n+{\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        if let Some(ref value) = *self {\n+            1u8.hash_stable(ctx, hasher);\n+            value.hash_stable(ctx, hasher);\n+        } else {\n+            0u8.hash_stable(ctx, hasher);\n+        }\n+    }\n+}\n+\n+impl<'a, T, CTX> HashStable<CTX> for &'a T\n+    where T: HashStable<CTX>\n+{\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        (**self).hash_stable(ctx, hasher);\n+    }\n+}\n+\n+impl<T, CTX> HashStable<CTX> for ::std::mem::Discriminant<T> {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          _: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        ::std::hash::Hash::hash(self, hasher);\n+    }\n+}\n+\n+impl<K, V, CTX> HashStable<CTX> for ::std::collections::BTreeMap<K, V>\n+    where K: Ord + HashStable<CTX>,\n+          V: HashStable<CTX>,\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.len().hash_stable(ctx, hasher);\n+        for (k, v) in self {\n+            k.hash_stable(ctx, hasher);\n+            v.hash_stable(ctx, hasher);\n+        }\n+    }\n+}\n+\n+impl<T, CTX> HashStable<CTX> for ::std::collections::BTreeSet<T>\n+    where T: Ord + HashStable<CTX>,\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.len().hash_stable(ctx, hasher);\n+        for v in self {\n+            v.hash_stable(ctx, hasher);\n+        }\n+    }\n+}\n+\n+impl<I: ::indexed_vec::Idx, T, CTX> HashStable<CTX> for ::indexed_vec::IndexVec<I, T>\n+    where T: HashStable<CTX>,\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.len().hash_stable(ctx, hasher);\n+        for v in &self.raw {\n+            v.hash_stable(ctx, hasher);\n+        }\n+    }\n+}"}, {"sha": "c80a5a1627797bfbae1448530bd649f99ca9b55d", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 93, "deletions": 104, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -27,24 +27,17 @@\n //! at the end of compilation would be different from those computed\n //! at the beginning.\n \n-use syntax::ast;\n use std::cell::RefCell;\n use std::hash::Hash;\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n-use rustc::hir::intravisit as visit;\n-use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n-use rustc::ich::{Fingerprint, DefPathHashes, CachingCodemapView};\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::ich::{Fingerprint, StableHashingContext};\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::stable_hasher::StableHasher;\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use rustc_data_structures::fx::FxHashMap;\n use rustc::util::common::record_time;\n-use rustc::session::config::DebugInfoLevel::NoDebugInfo;\n-\n-use self::svh_visitor::StrictVersionHashVisitor;\n-\n-mod svh_visitor;\n \n pub type IchHasher = StableHasher<Fingerprint>;\n \n@@ -94,107 +87,58 @@ impl<'a> ::std::ops::Index<&'a DepNode<DefId>> for IncrementalHashesMap {\n     }\n }\n \n-\n-pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                                    -> IncrementalHashesMap {\n-    let _ignore = tcx.dep_graph.in_ignore();\n-    let krate = tcx.hir.krate();\n-    let hash_spans = tcx.sess.opts.debuginfo != NoDebugInfo;\n-    let mut visitor = HashItemsVisitor {\n-        tcx: tcx,\n-        hashes: IncrementalHashesMap::new(),\n-        def_path_hashes: DefPathHashes::new(tcx),\n-        codemap: CachingCodemapView::new(tcx),\n-        hash_spans: hash_spans,\n-    };\n-    record_time(&tcx.sess.perf_stats.incr_comp_hashes_time, || {\n-        visitor.calculate_def_id(DefId::local(CRATE_DEF_INDEX), |v| {\n-            v.hash_crate_root_module(krate);\n-        });\n-        krate.visit_all_item_likes(&mut visitor.as_deep_visitor());\n-\n-        for macro_def in krate.exported_macros.iter() {\n-            visitor.calculate_node_id(macro_def.id,\n-                                      |v| v.visit_macro_def(macro_def));\n-        }\n-    });\n-\n-    tcx.sess.perf_stats.incr_comp_hashes_count.set(visitor.hashes.len() as u64);\n-\n-    record_time(&tcx.sess.perf_stats.svh_time, || visitor.compute_crate_hash());\n-    visitor.hashes\n-}\n-\n-struct HashItemsVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    def_path_hashes: DefPathHashes<'a, 'tcx>,\n-    codemap: CachingCodemapView<'tcx>,\n+struct ComputeItemHashesVisitor<'a, 'tcx: 'a> {\n+    hcx: StableHashingContext<'a, 'tcx>,\n     hashes: IncrementalHashesMap,\n-    hash_spans: bool,\n }\n \n-impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n-    fn calculate_node_id<W>(&mut self, id: ast::NodeId, walk_op: W)\n-        where W: for<'v> FnMut(&mut StrictVersionHashVisitor<'v, 'a, 'tcx>)\n-    {\n-        let def_id = self.tcx.hir.local_def_id(id);\n-        self.calculate_def_id(def_id, walk_op)\n-    }\n-\n-    fn calculate_def_id<W>(&mut self, def_id: DefId, mut walk_op: W)\n-        where W: for<'v> FnMut(&mut StrictVersionHashVisitor<'v, 'a, 'tcx>)\n+impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n+    fn compute_and_store_ich_for_item_like<T>(&mut self,\n+                                              dep_node: DepNode<DefId>,\n+                                              hash_bodies: bool,\n+                                              item_like: T)\n+        where T: HashStable<StableHashingContext<'a, 'tcx>>\n     {\n-        assert!(def_id.is_local());\n-        debug!(\"HashItemsVisitor::calculate(def_id={:?})\", def_id);\n-        self.calculate_def_hash(DepNode::Hir(def_id), false, &mut walk_op);\n-        self.calculate_def_hash(DepNode::HirBody(def_id), true, &mut walk_op);\n-    }\n+        let mut hasher = IchHasher::new();\n+        self.hcx.while_hashing_hir_bodies(hash_bodies, |hcx| {\n+            item_like.hash_stable(hcx, &mut hasher);\n+        });\n \n-    fn calculate_def_hash<W>(&mut self,\n-                             dep_node: DepNode<DefId>,\n-                             hash_bodies: bool,\n-                             walk_op: &mut W)\n-        where W: for<'v> FnMut(&mut StrictVersionHashVisitor<'v, 'a, 'tcx>)\n-    {\n-        let mut state = IchHasher::new();\n-        walk_op(&mut StrictVersionHashVisitor::new(&mut state,\n-                                                   self.tcx,\n-                                                   &mut self.def_path_hashes,\n-                                                   &mut self.codemap,\n-                                                   self.hash_spans,\n-                                                   hash_bodies));\n-        let bytes_hashed = state.bytes_hashed();\n-        let item_hash = state.finish();\n+        let bytes_hashed = hasher.bytes_hashed();\n+        let item_hash = hasher.finish();\n         debug!(\"calculate_def_hash: dep_node={:?} hash={:?}\", dep_node, item_hash);\n         self.hashes.insert(dep_node, item_hash);\n \n-        let bytes_hashed = self.tcx.sess.perf_stats.incr_comp_bytes_hashed.get() +\n+        let tcx = self.hcx.tcx();\n+        let bytes_hashed =\n+            tcx.sess.perf_stats.incr_comp_bytes_hashed.get() +\n             bytes_hashed;\n-        self.tcx.sess.perf_stats.incr_comp_bytes_hashed.set(bytes_hashed);\n+        tcx.sess.perf_stats.incr_comp_bytes_hashed.set(bytes_hashed);\n     }\n \n     fn compute_crate_hash(&mut self) {\n-        let krate = self.tcx.hir.krate();\n+        let tcx = self.hcx.tcx();\n+        let krate = tcx.hir.krate();\n \n         let mut crate_state = IchHasher::new();\n \n-        let crate_disambiguator = self.tcx.sess.local_crate_disambiguator();\n+        let crate_disambiguator = tcx.sess.local_crate_disambiguator();\n         \"crate_disambiguator\".hash(&mut crate_state);\n         crate_disambiguator.as_str().len().hash(&mut crate_state);\n         crate_disambiguator.as_str().hash(&mut crate_state);\n \n         // add each item (in some deterministic order) to the overall\n         // crate hash.\n         {\n-            let def_path_hashes = &mut self.def_path_hashes;\n+            let hcx = &mut self.hcx;\n             let mut item_hashes: Vec<_> =\n                 self.hashes.iter()\n                            .map(|(item_dep_node, &item_hash)| {\n                                // convert from a DepNode<DefId> tp a\n                                // DepNode<u64> where the u64 is the\n                                // hash of the def-id's def-path:\n                                let item_dep_node =\n-                                   item_dep_node.map_def(|&did| Some(def_path_hashes.hash(did)))\n+                                   item_dep_node.map_def(|&did| Some(hcx.def_path_hash(did)))\n                                                 .unwrap();\n                                (item_dep_node, item_hash)\n                            })\n@@ -203,40 +147,85 @@ impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n             item_hashes.hash(&mut crate_state);\n         }\n \n-        {\n-            let mut visitor = StrictVersionHashVisitor::new(&mut crate_state,\n-                                                            self.tcx,\n-                                                            &mut self.def_path_hashes,\n-                                                            &mut self.codemap,\n-                                                            self.hash_spans,\n-                                                            false);\n-            visitor.hash_attributes(&krate.attrs);\n-        }\n+        krate.attrs.hash_stable(&mut self.hcx, &mut crate_state);\n \n         let crate_hash = crate_state.finish();\n         self.hashes.insert(DepNode::Krate, crate_hash);\n         debug!(\"calculate_crate_hash: crate_hash={:?}\", crate_hash);\n     }\n-}\n \n-\n-impl<'a, 'tcx> Visitor<'tcx> for HashItemsVisitor<'a, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n+    fn hash_crate_root_module(&mut self, krate: &'tcx hir::Crate) {\n+        let hir::Crate {\n+            ref module,\n+            // Crate attributes are not copied over to the root `Mod`, so hash\n+            // them explicitly here.\n+            ref attrs,\n+            span,\n+\n+            // These fields are handled separately:\n+            exported_macros: _,\n+            items: _,\n+            trait_items: _,\n+            impl_items: _,\n+            bodies: _,\n+            trait_impls: _,\n+            trait_default_impl: _,\n+            body_ids: _,\n+        } = *krate;\n+\n+        let def_id = DefId::local(CRATE_DEF_INDEX);\n+        self.compute_and_store_ich_for_item_like(DepNode::Hir(def_id),\n+                                                 false,\n+                                                 (module, (span, attrs)));\n+        self.compute_and_store_ich_for_item_like(DepNode::HirBody(def_id),\n+                                                 true,\n+                                                 (module, (span, attrs)));\n     }\n+}\n \n+impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for ComputeItemHashesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        self.calculate_node_id(item.id, |v| v.visit_item(item));\n-        visit::walk_item(self, item);\n+        let def_id = self.hcx.tcx().hir.local_def_id(item.id);\n+        self.compute_and_store_ich_for_item_like(DepNode::Hir(def_id), false, item);\n+        self.compute_and_store_ich_for_item_like(DepNode::HirBody(def_id), true, item);\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        self.calculate_node_id(trait_item.id, |v| v.visit_trait_item(trait_item));\n-        visit::walk_trait_item(self, trait_item);\n+    fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n+        let def_id = self.hcx.tcx().hir.local_def_id(item.id);\n+        self.compute_and_store_ich_for_item_like(DepNode::Hir(def_id), false, item);\n+        self.compute_and_store_ich_for_item_like(DepNode::HirBody(def_id), true, item);\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n-        self.calculate_node_id(impl_item.id, |v| v.visit_impl_item(impl_item));\n-        visit::walk_impl_item(self, impl_item);\n+    fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n+        let def_id = self.hcx.tcx().hir.local_def_id(item.id);\n+        self.compute_and_store_ich_for_item_like(DepNode::Hir(def_id), false, item);\n+        self.compute_and_store_ich_for_item_like(DepNode::HirBody(def_id), true, item);\n     }\n }\n+\n+pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                                    -> IncrementalHashesMap {\n+    let _ignore = tcx.dep_graph.in_ignore();\n+    let krate = tcx.hir.krate();\n+\n+    let mut visitor = ComputeItemHashesVisitor {\n+        hcx: StableHashingContext::new(tcx),\n+        hashes: IncrementalHashesMap::new(),\n+    };\n+\n+    record_time(&tcx.sess.perf_stats.incr_comp_hashes_time, || {\n+        visitor.hash_crate_root_module(krate);\n+        krate.visit_all_item_likes(&mut visitor);\n+\n+        for macro_def in krate.exported_macros.iter() {\n+            let def_id = tcx.hir.local_def_id(macro_def.id);\n+            visitor.compute_and_store_ich_for_item_like(DepNode::Hir(def_id), false, macro_def);\n+            visitor.compute_and_store_ich_for_item_like(DepNode::HirBody(def_id), true, macro_def);\n+        }\n+    });\n+\n+    tcx.sess.perf_stats.incr_comp_hashes_count.set(visitor.hashes.len() as u64);\n+\n+    record_time(&tcx.sess.perf_stats.svh_time, || visitor.compute_crate_hash());\n+    visitor.hashes\n+}"}, {"sha": "5401b371888e939c58b6b3145b5f3faf67aa5315", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "removed", "additions": 0, "deletions": 1111, "changes": 1111, "blob_url": "https://github.com/rust-lang/rust/blob/50c186419bb38e8ea2f1e6f9c31b754e3a1a3e65/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c186419bb38e8ea2f1e6f9c31b754e3a1a3e65/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=50c186419bb38e8ea2f1e6f9c31b754e3a1a3e65", "patch": "@@ -1,1111 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use self::SawExprComponent::*;\n-use self::SawAbiComponent::*;\n-use self::SawItemComponent::*;\n-use self::SawPatComponent::*;\n-use self::SawTyComponent::*;\n-use self::SawTraitOrImplItemComponent::*;\n-use syntax::abi::Abi;\n-use syntax::ast::{self, Name, NodeId};\n-use syntax::attr;\n-use syntax::ext::hygiene::SyntaxContext;\n-use syntax::parse::token;\n-use syntax::symbol::InternedString;\n-use syntax_pos::{Span, BytePos};\n-use syntax::tokenstream;\n-use rustc::hir;\n-use rustc::hir::*;\n-use rustc::hir::def::Def;\n-use rustc::hir::def_id::DefId;\n-use rustc::hir::intravisit::{self as visit, Visitor};\n-use rustc::ich::{DefPathHashes, CachingCodemapView, IGNORED_ATTRIBUTES};\n-use rustc::ty::TyCtxt;\n-use std::hash::{Hash, Hasher};\n-\n-use super::IchHasher;\n-\n-pub struct StrictVersionHashVisitor<'a, 'hash: 'a, 'tcx: 'hash> {\n-    pub tcx: TyCtxt<'hash, 'tcx, 'tcx>,\n-    pub st: &'a mut IchHasher,\n-    // collect a deterministic hash of def-ids that we have seen\n-    def_path_hashes: &'a mut DefPathHashes<'hash, 'tcx>,\n-    hash_spans: bool,\n-    codemap: &'a mut CachingCodemapView<'tcx>,\n-    overflow_checks_enabled: bool,\n-    hash_bodies: bool,\n-}\n-\n-impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n-    pub fn new(st: &'a mut IchHasher,\n-               tcx: TyCtxt<'hash, 'tcx, 'tcx>,\n-               def_path_hashes: &'a mut DefPathHashes<'hash, 'tcx>,\n-               codemap: &'a mut CachingCodemapView<'tcx>,\n-               hash_spans: bool,\n-               hash_bodies: bool)\n-               -> Self {\n-        let check_overflow = tcx.sess.overflow_checks();\n-\n-        StrictVersionHashVisitor {\n-            st: st,\n-            tcx: tcx,\n-            def_path_hashes: def_path_hashes,\n-            hash_spans: hash_spans,\n-            codemap: codemap,\n-            overflow_checks_enabled: check_overflow,\n-            hash_bodies: hash_bodies,\n-        }\n-    }\n-\n-    fn compute_def_id_hash(&mut self, def_id: DefId) -> u64 {\n-        self.def_path_hashes.hash(def_id)\n-    }\n-\n-    // Hash a span in a stable way. We can't directly hash the span's BytePos\n-    // fields (that would be similar to hashing pointers, since those are just\n-    // offsets into the CodeMap). Instead, we hash the (file name, line, column)\n-    // triple, which stays the same even if the containing FileMap has moved\n-    // within the CodeMap.\n-    // Also note that we are hashing byte offsets for the column, not unicode\n-    // codepoint offsets. For the purpose of the hash that's sufficient.\n-    // Also, hashing filenames is expensive so we avoid doing it twice when the\n-    // span starts and ends in the same file, which is almost always the case.\n-    fn hash_span(&mut self, span: Span) {\n-        debug!(\"hash_span: st={:?}\", self.st);\n-\n-        // If this is not an empty or invalid span, we want to hash the last\n-        // position that belongs to it, as opposed to hashing the first\n-        // position past it.\n-        let span_hi = if span.hi > span.lo {\n-            // We might end up in the middle of a multibyte character here,\n-            // but that's OK, since we are not trying to decode anything at\n-            // this position.\n-            span.hi - BytePos(1)\n-        } else {\n-            span.hi\n-        };\n-\n-        let expn_kind = if span.ctxt == SyntaxContext::empty() {\n-            SawSpanExpnKind::NoExpansion\n-        } else {\n-            SawSpanExpnKind::SomeExpansion\n-        };\n-\n-        let loc1 = self.codemap.byte_pos_to_line_and_col(span.lo);\n-        let loc1 = loc1.as_ref()\n-                       .map(|&(ref fm, line, col)| (&fm.name[..], line, col))\n-                       .unwrap_or((\"???\", 0, BytePos(0)));\n-\n-        let loc2 = self.codemap.byte_pos_to_line_and_col(span_hi);\n-        let loc2 = loc2.as_ref()\n-                       .map(|&(ref fm, line, col)| (&fm.name[..], line, col))\n-                       .unwrap_or((\"???\", 0, BytePos(0)));\n-\n-        let saw = if loc1.0 == loc2.0 {\n-            SawSpan(loc1.0,\n-                    loc1.1, loc1.2,\n-                    loc2.1, loc2.2,\n-                    expn_kind)\n-        } else {\n-            SawSpanTwoFiles(loc1.0, loc1.1, loc1.2,\n-                            loc2.0, loc2.1, loc2.2,\n-                            expn_kind)\n-        };\n-        saw.hash(self.st);\n-\n-        if expn_kind == SawSpanExpnKind::SomeExpansion {\n-            self.hash_span(span.source_callsite());\n-        }\n-    }\n-\n-    fn hash_discriminant<T>(&mut self, v: &T) {\n-        unsafe {\n-            let disr = ::std::intrinsics::discriminant_value(v);\n-            debug!(\"hash_discriminant: disr={}, st={:?}\", disr, self.st);\n-            disr.hash(self.st);\n-        }\n-    }\n-}\n-\n-// To off-load the bulk of the hash-computation on #[derive(Hash)],\n-// we define a set of enums corresponding to the content that our\n-// crate visitor will encounter as it traverses the ast.\n-//\n-// The important invariant is that all of the Saw*Component enums\n-// do not carry any Spans, Names, or Idents.\n-//\n-// Not carrying any Names/Idents is the important fix for problem\n-// noted on PR #13948: using the ident.name as the basis for a\n-// hash leads to unstable SVH, because ident.name is just an index\n-// into intern table (i.e. essentially a random address), not\n-// computed from the name content.\n-//\n-// With the below enums, the SVH computation is not sensitive to\n-// artifacts of how rustc was invoked nor of how the source code\n-// was laid out.  (Or at least it is *less* sensitive.)\n-\n-// This enum represents the different potential bits of code the\n-// visitor could encounter that could affect the ABI for the crate,\n-// and assigns each a distinct tag to feed into the hash computation.\n-#[derive(Hash)]\n-enum SawAbiComponent<'a> {\n-\n-    // FIXME (#14132): should we include (some function of)\n-    // ident.ctxt as well?\n-    SawIdent(InternedString),\n-    SawStructDef(InternedString),\n-\n-    SawLifetime,\n-    SawLifetimeDef(usize),\n-\n-    SawMod,\n-    SawForeignItem(SawForeignItemComponent),\n-    SawItem(SawItemComponent),\n-    SawTy(SawTyComponent),\n-    SawFnDecl(bool),\n-    SawGenerics,\n-    SawTraitItem(SawTraitOrImplItemComponent),\n-    SawImplItem(SawTraitOrImplItemComponent),\n-    SawStructField,\n-    SawVariant(bool),\n-    SawQPath,\n-    SawPathSegment,\n-    SawPathParameters,\n-    SawBlock,\n-    SawPat(SawPatComponent),\n-    SawLocal,\n-    SawArm,\n-    SawExpr(SawExprComponent<'a>),\n-    SawStmt,\n-    SawVis,\n-    SawAssociatedItemKind(hir::AssociatedItemKind),\n-    SawDefaultness(hir::Defaultness),\n-    SawWherePredicate,\n-    SawTyParamBound,\n-    SawPolyTraitRef,\n-    SawAssocTypeBinding,\n-    SawAttribute(ast::AttrStyle),\n-    SawMacroDef,\n-    SawSpan(&'a str,\n-            usize, BytePos,\n-            usize, BytePos,\n-            SawSpanExpnKind),\n-    SawSpanTwoFiles(&'a str, usize, BytePos,\n-                    &'a str, usize, BytePos,\n-                    SawSpanExpnKind),\n-}\n-\n-/// SawExprComponent carries all of the information that we want\n-/// to include in the hash that *won't* be covered by the\n-/// subsequent recursive traversal of the expression's\n-/// substructure by the visitor.\n-///\n-/// We know every Expr_ variant is covered by a variant because\n-/// `fn saw_expr` maps each to some case below.  Ensuring that\n-/// each variant carries an appropriate payload has to be verified\n-/// by hand.\n-///\n-/// (However, getting that *exactly* right is not so important\n-/// because the SVH is just a developer convenience; there is no\n-/// guarantee of collision-freedom, hash collisions are just\n-/// (hopefully) unlikely.)\n-///\n-/// The xxxComponent enums and saw_xxx functions for Item, Pat,\n-/// Ty, TraitItem and ImplItem follow the same methodology.\n-#[derive(Hash)]\n-enum SawExprComponent<'a> {\n-\n-    SawExprLoop(Option<InternedString>),\n-    SawExprField(InternedString),\n-    SawExprTupField(usize),\n-    SawExprBreak(Option<InternedString>),\n-    SawExprAgain(Option<InternedString>),\n-\n-    SawExprBox,\n-    SawExprArray,\n-    SawExprCall,\n-    SawExprMethodCall,\n-    SawExprTup,\n-    SawExprBinary(hir::BinOp_),\n-    SawExprUnary(hir::UnOp),\n-    SawExprLit(ast::LitKind),\n-    SawExprLitStr(InternedString, ast::StrStyle),\n-    SawExprLitFloat(InternedString, Option<ast::FloatTy>),\n-    SawExprCast,\n-    SawExprType,\n-    SawExprIf,\n-    SawExprWhile,\n-    SawExprMatch,\n-    SawExprClosure(CaptureClause),\n-    SawExprBlock,\n-    SawExprAssign,\n-    SawExprAssignOp(hir::BinOp_),\n-    SawExprIndex,\n-    SawExprPath,\n-    SawExprAddrOf(hir::Mutability),\n-    SawExprRet,\n-    SawExprInlineAsm(StableInlineAsm<'a>),\n-    SawExprStruct,\n-    SawExprRepeat,\n-}\n-\n-// The boolean returned indicates whether the span of this expression is always\n-// significant, regardless of debuginfo.\n-fn saw_expr<'a>(node: &'a Expr_,\n-                overflow_checks_enabled: bool)\n-                -> (SawExprComponent<'a>, bool) {\n-    let binop_can_panic_at_runtime = |binop| {\n-        match binop {\n-            BiAdd |\n-            BiSub |\n-            BiMul => overflow_checks_enabled,\n-\n-            BiDiv |\n-            BiRem => true,\n-\n-            BiAnd |\n-            BiOr |\n-            BiBitXor |\n-            BiBitAnd |\n-            BiBitOr |\n-            BiShl |\n-            BiShr |\n-            BiEq |\n-            BiLt |\n-            BiLe |\n-            BiNe |\n-            BiGe |\n-            BiGt => false\n-        }\n-    };\n-\n-    let unop_can_panic_at_runtime = |unop| {\n-        match unop {\n-            UnDeref |\n-            UnNot => false,\n-            UnNeg => overflow_checks_enabled,\n-        }\n-    };\n-\n-    match *node {\n-        ExprBox(..)              => (SawExprBox, false),\n-        ExprArray(..)            => (SawExprArray, false),\n-        ExprCall(..)             => (SawExprCall, false),\n-        ExprMethodCall(..)       => (SawExprMethodCall, false),\n-        ExprTup(..)              => (SawExprTup, false),\n-        ExprBinary(op, ..)       => {\n-            (SawExprBinary(op.node), binop_can_panic_at_runtime(op.node))\n-        }\n-        ExprUnary(op, _)         => {\n-            (SawExprUnary(op), unop_can_panic_at_runtime(op))\n-        }\n-        ExprLit(ref lit)         => (saw_lit(lit), false),\n-        ExprCast(..)             => (SawExprCast, false),\n-        ExprType(..)             => (SawExprType, false),\n-        ExprIf(..)               => (SawExprIf, false),\n-        ExprWhile(..)            => (SawExprWhile, false),\n-        ExprLoop(_, id, _)       => (SawExprLoop(id.map(|id| id.node.as_str())), false),\n-        ExprMatch(..)            => (SawExprMatch, false),\n-        ExprClosure(cc, _, _, _) => (SawExprClosure(cc), false),\n-        ExprBlock(..)            => (SawExprBlock, false),\n-        ExprAssign(..)           => (SawExprAssign, false),\n-        ExprAssignOp(op, ..)     => {\n-            (SawExprAssignOp(op.node), binop_can_panic_at_runtime(op.node))\n-        }\n-        ExprField(_, name)       => (SawExprField(name.node.as_str()), false),\n-        ExprTupField(_, id)      => (SawExprTupField(id.node), false),\n-        ExprIndex(..)            => (SawExprIndex, true),\n-        ExprPath(_)              => (SawExprPath, false),\n-        ExprAddrOf(m, _)         => (SawExprAddrOf(m), false),\n-        ExprBreak(label, _)      => (SawExprBreak(label.ident.map(|i|\n-                                                    i.node.name.as_str())), false),\n-        ExprAgain(label)         => (SawExprAgain(label.ident.map(|i|\n-                                                    i.node.name.as_str())), false),\n-        ExprRet(..)              => (SawExprRet, false),\n-        ExprInlineAsm(ref a,..)  => (SawExprInlineAsm(StableInlineAsm(a)), false),\n-        ExprStruct(..)           => (SawExprStruct, false),\n-        ExprRepeat(..)           => (SawExprRepeat, false),\n-    }\n-}\n-\n-fn saw_lit(lit: &ast::Lit) -> SawExprComponent<'static> {\n-    match lit.node {\n-        ast::LitKind::Str(s, style) => SawExprLitStr(s.as_str(), style),\n-        ast::LitKind::Float(s, ty) => SawExprLitFloat(s.as_str(), Some(ty)),\n-        ast::LitKind::FloatUnsuffixed(s) => SawExprLitFloat(s.as_str(), None),\n-        ref node @ _ => SawExprLit(node.clone()),\n-    }\n-}\n-\n-#[derive(Hash)]\n-enum SawItemComponent {\n-    SawItemExternCrate,\n-    SawItemUse(UseKind),\n-    SawItemStatic(Mutability),\n-    SawItemConst,\n-    SawItemFn(Unsafety, Constness, Abi),\n-    SawItemMod,\n-    SawItemForeignMod(Abi),\n-    SawItemTy,\n-    SawItemEnum,\n-    SawItemStruct,\n-    SawItemUnion,\n-    SawItemTrait(Unsafety),\n-    SawItemDefaultImpl(Unsafety),\n-    SawItemImpl(Unsafety, ImplPolarity)\n-}\n-\n-fn saw_item(node: &Item_) -> SawItemComponent {\n-    match *node {\n-        ItemExternCrate(..) => SawItemExternCrate,\n-        ItemUse(_, kind) => SawItemUse(kind),\n-        ItemStatic(_, mutability, _) => SawItemStatic(mutability),\n-        ItemConst(..) =>SawItemConst,\n-        ItemFn(_, unsafety, constness, abi, _, _) => SawItemFn(unsafety, constness, abi),\n-        ItemMod(..) => SawItemMod,\n-        ItemForeignMod(ref fm) => SawItemForeignMod(fm.abi),\n-        ItemTy(..) => SawItemTy,\n-        ItemEnum(..) => SawItemEnum,\n-        ItemStruct(..) => SawItemStruct,\n-        ItemUnion(..) => SawItemUnion,\n-        ItemTrait(unsafety, ..) => SawItemTrait(unsafety),\n-        ItemDefaultImpl(unsafety, _) => SawItemDefaultImpl(unsafety),\n-        ItemImpl(unsafety, implpolarity, ..) => SawItemImpl(unsafety, implpolarity)\n-    }\n-}\n-\n-#[derive(Hash)]\n-enum SawForeignItemComponent {\n-    Static { mutable: bool },\n-    Fn,\n-}\n-\n-#[derive(Hash)]\n-enum SawPatComponent {\n-    SawPatWild,\n-    SawPatBinding(BindingMode),\n-    SawPatStruct,\n-    SawPatTupleStruct,\n-    SawPatPath,\n-    SawPatTuple,\n-    SawPatBox,\n-    SawPatRef(Mutability),\n-    SawPatLit,\n-    SawPatRange,\n-    SawPatSlice\n-}\n-\n-fn saw_pat(node: &PatKind) -> SawPatComponent {\n-    match *node {\n-        PatKind::Wild => SawPatWild,\n-        PatKind::Binding(bindingmode, ..) => SawPatBinding(bindingmode),\n-        PatKind::Struct(..) => SawPatStruct,\n-        PatKind::TupleStruct(..) => SawPatTupleStruct,\n-        PatKind::Path(_) => SawPatPath,\n-        PatKind::Tuple(..) => SawPatTuple,\n-        PatKind::Box(..) => SawPatBox,\n-        PatKind::Ref(_, mutability) => SawPatRef(mutability),\n-        PatKind::Lit(..) => SawPatLit,\n-        PatKind::Range(..) => SawPatRange,\n-        PatKind::Slice(..) => SawPatSlice\n-    }\n-}\n-\n-#[derive(Hash)]\n-enum SawTyComponent {\n-    SawTySlice,\n-    SawTyArray,\n-    SawTyPtr(Mutability),\n-    SawTyRptr(Mutability),\n-    SawTyBareFn(Unsafety, Abi),\n-    SawTyNever,\n-    SawTyTup,\n-    SawTyPath,\n-    SawTyObjectSum,\n-    SawTyImplTrait,\n-    SawTyTypeof,\n-    SawTyInfer\n-}\n-\n-fn saw_ty(node: &Ty_) -> SawTyComponent {\n-    match *node {\n-      TySlice(..) => SawTySlice,\n-      TyArray(..) => SawTyArray,\n-      TyPtr(ref mty) => SawTyPtr(mty.mutbl),\n-      TyRptr(_, ref mty) => SawTyRptr(mty.mutbl),\n-      TyBareFn(ref barefnty) => SawTyBareFn(barefnty.unsafety, barefnty.abi),\n-      TyNever => SawTyNever,\n-      TyTup(..) => SawTyTup,\n-      TyPath(_) => SawTyPath,\n-      TyTraitObject(..) => SawTyObjectSum,\n-      TyImplTrait(..) => SawTyImplTrait,\n-      TyTypeof(..) => SawTyTypeof,\n-      TyInfer => SawTyInfer\n-    }\n-}\n-\n-#[derive(Hash)]\n-enum SawTraitOrImplItemComponent {\n-    SawTraitOrImplItemConst,\n-    // The boolean signifies whether a body is present\n-    SawTraitOrImplItemMethod(Unsafety, Constness, Abi, bool),\n-    SawTraitOrImplItemType\n-}\n-\n-fn saw_trait_item(ti: &TraitItemKind) -> SawTraitOrImplItemComponent {\n-    match *ti {\n-        TraitItemKind::Const(..) => SawTraitOrImplItemConst,\n-        TraitItemKind::Method(ref sig, TraitMethod::Required(_)) =>\n-            SawTraitOrImplItemMethod(sig.unsafety, sig.constness, sig.abi, false),\n-        TraitItemKind::Method(ref sig, TraitMethod::Provided(_)) =>\n-            SawTraitOrImplItemMethod(sig.unsafety, sig.constness, sig.abi, true),\n-        TraitItemKind::Type(..) => SawTraitOrImplItemType\n-    }\n-}\n-\n-fn saw_impl_item(ii: &ImplItemKind) -> SawTraitOrImplItemComponent {\n-    match *ii {\n-        ImplItemKind::Const(..) => SawTraitOrImplItemConst,\n-        ImplItemKind::Method(ref sig, _) =>\n-            SawTraitOrImplItemMethod(sig.unsafety, sig.constness, sig.abi, true),\n-        ImplItemKind::Type(..) => SawTraitOrImplItemType\n-    }\n-}\n-\n-#[derive(Clone, Copy, Hash, Eq, PartialEq)]\n-enum SawSpanExpnKind {\n-    NoExpansion,\n-    SomeExpansion,\n-}\n-\n-/// A wrapper that provides a stable Hash implementation.\n-struct StableInlineAsm<'a>(&'a InlineAsm);\n-\n-impl<'a> Hash for StableInlineAsm<'a> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        let InlineAsm {\n-            asm,\n-            asm_str_style,\n-            ref outputs,\n-            ref inputs,\n-            ref clobbers,\n-            volatile,\n-            alignstack,\n-            dialect,\n-            ctxt: _, // This is used for error reporting\n-        } = *self.0;\n-\n-        asm.as_str().hash(state);\n-        asm_str_style.hash(state);\n-        outputs.len().hash(state);\n-        for output in outputs {\n-            let InlineAsmOutput { constraint, is_rw, is_indirect } = *output;\n-            constraint.as_str().hash(state);\n-            is_rw.hash(state);\n-            is_indirect.hash(state);\n-        }\n-        inputs.len().hash(state);\n-        for input in inputs {\n-            input.as_str().hash(state);\n-        }\n-        clobbers.len().hash(state);\n-        for clobber in clobbers {\n-            clobber.as_str().hash(state);\n-        }\n-        volatile.hash(state);\n-        alignstack.hash(state);\n-        dialect.hash(state);\n-    }\n-}\n-\n-macro_rules! hash_attrs {\n-    ($visitor:expr, $attrs:expr) => ({\n-        let attrs = $attrs;\n-        if attrs.len() > 0 {\n-            $visitor.hash_attributes(attrs);\n-        }\n-    })\n-}\n-\n-macro_rules! hash_span {\n-    ($visitor:expr, $span:expr) => ({\n-        hash_span!($visitor, $span, false)\n-    });\n-    ($visitor:expr, $span:expr, $force:expr) => ({\n-        if $force || $visitor.hash_spans {\n-            $visitor.hash_span($span);\n-        }\n-    });\n-}\n-\n-impl<'a, 'hash, 'tcx> Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> visit::NestedVisitorMap<'this, 'tcx> {\n-        if self.hash_bodies {\n-            visit::NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n-        } else {\n-            visit::NestedVisitorMap::None\n-        }\n-    }\n-\n-    fn visit_variant_data(&mut self,\n-                          s: &'tcx VariantData,\n-                          name: Name,\n-                          _: &'tcx Generics,\n-                          _: NodeId,\n-                          span: Span) {\n-        debug!(\"visit_variant_data: st={:?}\", self.st);\n-        SawStructDef(name.as_str()).hash(self.st);\n-        hash_span!(self, span);\n-        visit::walk_struct_def(self, s);\n-    }\n-\n-    fn visit_variant(&mut self,\n-                     v: &'tcx Variant,\n-                     g: &'tcx Generics,\n-                     item_id: NodeId) {\n-        debug!(\"visit_variant: st={:?}\", self.st);\n-        SawVariant(v.node.disr_expr.is_some()).hash(self.st);\n-        hash_attrs!(self, &v.node.attrs);\n-        visit::walk_variant(self, v, g, item_id)\n-    }\n-\n-    fn visit_name(&mut self, span: Span, name: Name) {\n-        debug!(\"visit_name: st={:?}\", self.st);\n-        SawIdent(name.as_str()).hash(self.st);\n-        hash_span!(self, span);\n-    }\n-\n-    fn visit_lifetime(&mut self, l: &'tcx Lifetime) {\n-        debug!(\"visit_lifetime: st={:?}\", self.st);\n-        SawLifetime.hash(self.st);\n-        visit::walk_lifetime(self, l);\n-    }\n-\n-    fn visit_lifetime_def(&mut self, l: &'tcx LifetimeDef) {\n-        debug!(\"visit_lifetime_def: st={:?}\", self.st);\n-        SawLifetimeDef(l.bounds.len()).hash(self.st);\n-        visit::walk_lifetime_def(self, l);\n-    }\n-\n-    fn visit_expr(&mut self, ex: &'tcx Expr) {\n-        debug!(\"visit_expr: st={:?}\", self.st);\n-        let (saw_expr, force_span) = saw_expr(&ex.node,\n-                                              self.overflow_checks_enabled);\n-        SawExpr(saw_expr).hash(self.st);\n-        // No need to explicitly hash the discriminant here, since we are\n-        // implicitly hashing the discriminant of SawExprComponent.\n-        hash_span!(self, ex.span, force_span);\n-        hash_attrs!(self, &ex.attrs);\n-\n-        // Always hash nested constant bodies (e.g. n in `[x; n]`).\n-        let hash_bodies = self.hash_bodies;\n-        self.hash_bodies = true;\n-        visit::walk_expr(self, ex);\n-        self.hash_bodies = hash_bodies;\n-    }\n-\n-    fn visit_stmt(&mut self, s: &'tcx Stmt) {\n-        debug!(\"visit_stmt: st={:?}\", self.st);\n-\n-        // We don't want to modify the hash for decls, because\n-        // they might be item decls (if they are local decls,\n-        // we'll hash that fact in visit_local); but we do want to\n-        // remember if this was a StmtExpr or StmtSemi (the later\n-        // had an explicit semi-colon; this affects the typing\n-        // rules).\n-        match s.node {\n-            StmtDecl(..) => (),\n-            StmtExpr(..) => {\n-                SawStmt.hash(self.st);\n-                self.hash_discriminant(&s.node);\n-                hash_span!(self, s.span);\n-            }\n-            StmtSemi(..) => {\n-                SawStmt.hash(self.st);\n-                self.hash_discriminant(&s.node);\n-                hash_span!(self, s.span);\n-            }\n-        }\n-\n-        visit::walk_stmt(self, s)\n-    }\n-\n-    fn visit_foreign_item(&mut self, i: &'tcx ForeignItem) {\n-        debug!(\"visit_foreign_item: st={:?}\", self.st);\n-\n-        match i.node {\n-            ForeignItemFn(..) => {\n-                SawForeignItem(SawForeignItemComponent::Fn)\n-            }\n-            ForeignItemStatic(_, mutable) => {\n-                SawForeignItem(SawForeignItemComponent::Static {\n-                    mutable: mutable\n-                })\n-            }\n-        }.hash(self.st);\n-\n-        hash_span!(self, i.span);\n-        hash_attrs!(self, &i.attrs);\n-        visit::walk_foreign_item(self, i)\n-    }\n-\n-    fn visit_item(&mut self, i: &'tcx Item) {\n-        debug!(\"visit_item: {:?} st={:?}\", i, self.st);\n-\n-        self.maybe_enable_overflow_checks(&i.attrs);\n-\n-        SawItem(saw_item(&i.node)).hash(self.st);\n-        hash_span!(self, i.span);\n-        hash_attrs!(self, &i.attrs);\n-        visit::walk_item(self, i)\n-    }\n-\n-    fn visit_mod(&mut self, m: &'tcx Mod, span: Span, n: NodeId) {\n-        debug!(\"visit_mod: st={:?}\", self.st);\n-        SawMod.hash(self.st);\n-        hash_span!(self, span);\n-        visit::walk_mod(self, m, n)\n-    }\n-\n-    fn visit_ty(&mut self, t: &'tcx Ty) {\n-        debug!(\"visit_ty: st={:?}\", self.st);\n-        SawTy(saw_ty(&t.node)).hash(self.st);\n-        hash_span!(self, t.span);\n-\n-        // Always hash nested constant bodies (e.g. N in `[T; N]`).\n-        let hash_bodies = self.hash_bodies;\n-        self.hash_bodies = true;\n-        visit::walk_ty(self, t);\n-        self.hash_bodies = hash_bodies;\n-    }\n-\n-    fn visit_generics(&mut self, g: &'tcx Generics) {\n-        debug!(\"visit_generics: st={:?}\", self.st);\n-        SawGenerics.hash(self.st);\n-        visit::walk_generics(self, g)\n-    }\n-\n-    fn visit_fn_decl(&mut self, fd: &'tcx FnDecl) {\n-        debug!(\"visit_fn_decl: st={:?}\", self.st);\n-        SawFnDecl(fd.variadic).hash(self.st);\n-        visit::walk_fn_decl(self, fd)\n-    }\n-\n-    fn visit_trait_item(&mut self, ti: &'tcx TraitItem) {\n-        debug!(\"visit_trait_item: st={:?}\", self.st);\n-\n-        self.maybe_enable_overflow_checks(&ti.attrs);\n-\n-        SawTraitItem(saw_trait_item(&ti.node)).hash(self.st);\n-        hash_span!(self, ti.span);\n-        hash_attrs!(self, &ti.attrs);\n-        visit::walk_trait_item(self, ti)\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'tcx ImplItem) {\n-        debug!(\"visit_impl_item: st={:?}\", self.st);\n-\n-        self.maybe_enable_overflow_checks(&ii.attrs);\n-\n-        SawImplItem(saw_impl_item(&ii.node)).hash(self.st);\n-        hash_span!(self, ii.span);\n-        hash_attrs!(self, &ii.attrs);\n-        visit::walk_impl_item(self, ii)\n-    }\n-\n-    fn visit_struct_field(&mut self, s: &'tcx StructField) {\n-        debug!(\"visit_struct_field: st={:?}\", self.st);\n-        SawStructField.hash(self.st);\n-        hash_span!(self, s.span);\n-        hash_attrs!(self, &s.attrs);\n-        visit::walk_struct_field(self, s)\n-    }\n-\n-    fn visit_qpath(&mut self, qpath: &'tcx QPath, id: NodeId, span: Span) {\n-        debug!(\"visit_qpath: st={:?}\", self.st);\n-        SawQPath.hash(self.st);\n-        self.hash_discriminant(qpath);\n-        visit::walk_qpath(self, qpath, id, span)\n-    }\n-\n-    fn visit_path(&mut self, path: &'tcx Path, _: ast::NodeId) {\n-        debug!(\"visit_path: st={:?}\", self.st);\n-        hash_span!(self, path.span);\n-        visit::walk_path(self, path)\n-    }\n-\n-    fn visit_def_mention(&mut self, def: Def) {\n-        self.hash_def(def);\n-    }\n-\n-    fn visit_block(&mut self, b: &'tcx Block) {\n-        debug!(\"visit_block: st={:?}\", self.st);\n-        SawBlock.hash(self.st);\n-        hash_span!(self, b.span);\n-        visit::walk_block(self, b)\n-    }\n-\n-    fn visit_pat(&mut self, p: &'tcx Pat) {\n-        debug!(\"visit_pat: st={:?}\", self.st);\n-        SawPat(saw_pat(&p.node)).hash(self.st);\n-        hash_span!(self, p.span);\n-        visit::walk_pat(self, p)\n-    }\n-\n-    fn visit_local(&mut self, l: &'tcx Local) {\n-        debug!(\"visit_local: st={:?}\", self.st);\n-        SawLocal.hash(self.st);\n-        hash_attrs!(self, &l.attrs);\n-        visit::walk_local(self, l)\n-        // No need to hash span, we are hashing all component spans\n-    }\n-\n-    fn visit_arm(&mut self, a: &'tcx Arm) {\n-        debug!(\"visit_arm: st={:?}\", self.st);\n-        SawArm.hash(self.st);\n-        hash_attrs!(self, &a.attrs);\n-        visit::walk_arm(self, a)\n-    }\n-\n-    fn visit_id(&mut self, id: NodeId) {\n-        debug!(\"visit_id: id={} st={:?}\", id, self.st);\n-        self.hash_resolve(id)\n-    }\n-\n-    fn visit_vis(&mut self, v: &'tcx Visibility) {\n-        debug!(\"visit_vis: st={:?}\", self.st);\n-        SawVis.hash(self.st);\n-        self.hash_discriminant(v);\n-        visit::walk_vis(self, v)\n-    }\n-\n-    fn visit_associated_item_kind(&mut self, kind: &'tcx AssociatedItemKind) {\n-        debug!(\"visit_associated_item_kind: st={:?}\", self.st);\n-        SawAssociatedItemKind(*kind).hash(self.st);\n-        visit::walk_associated_item_kind(self, kind);\n-    }\n-\n-    fn visit_defaultness(&mut self, defaultness: &'tcx Defaultness) {\n-        debug!(\"visit_associated_item_kind: st={:?}\", self.st);\n-        SawDefaultness(*defaultness).hash(self.st);\n-        visit::walk_defaultness(self, defaultness);\n-    }\n-\n-    fn visit_where_predicate(&mut self, predicate: &'tcx WherePredicate) {\n-        debug!(\"visit_where_predicate: st={:?}\", self.st);\n-        SawWherePredicate.hash(self.st);\n-        self.hash_discriminant(predicate);\n-        // Ignoring span. Any important nested components should be visited.\n-        visit::walk_where_predicate(self, predicate)\n-    }\n-\n-    fn visit_ty_param_bound(&mut self, bounds: &'tcx TyParamBound) {\n-        debug!(\"visit_ty_param_bound: st={:?}\", self.st);\n-        SawTyParamBound.hash(self.st);\n-        self.hash_discriminant(bounds);\n-        // The TraitBoundModifier in TraitTyParamBound will be hash in\n-        // visit_poly_trait_ref()\n-        visit::walk_ty_param_bound(self, bounds)\n-    }\n-\n-    fn visit_poly_trait_ref(&mut self, t: &'tcx PolyTraitRef, m: TraitBoundModifier) {\n-        debug!(\"visit_poly_trait_ref: st={:?}\", self.st);\n-        SawPolyTraitRef.hash(self.st);\n-        m.hash(self.st);\n-        visit::walk_poly_trait_ref(self, t, m)\n-    }\n-\n-    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'tcx PathSegment) {\n-        debug!(\"visit_path_segment: st={:?}\", self.st);\n-        SawPathSegment.hash(self.st);\n-        visit::walk_path_segment(self, path_span, path_segment)\n-    }\n-\n-    fn visit_path_parameters(&mut self, path_span: Span, path_parameters: &'tcx PathParameters) {\n-        debug!(\"visit_path_parameters: st={:?}\", self.st);\n-        SawPathParameters.hash(self.st);\n-        self.hash_discriminant(path_parameters);\n-        visit::walk_path_parameters(self, path_span, path_parameters)\n-    }\n-\n-    fn visit_assoc_type_binding(&mut self, type_binding: &'tcx TypeBinding) {\n-        debug!(\"visit_assoc_type_binding: st={:?}\", self.st);\n-        SawAssocTypeBinding.hash(self.st);\n-        hash_span!(self, type_binding.span);\n-        visit::walk_assoc_type_binding(self, type_binding)\n-    }\n-\n-    fn visit_attribute(&mut self, _: &ast::Attribute) {\n-        // We explicitly do not use this method, since doing that would\n-        // implicitly impose an order on the attributes being hashed, while we\n-        // explicitly don't want their order to matter\n-    }\n-\n-    fn visit_macro_def(&mut self, macro_def: &'tcx MacroDef) {\n-        debug!(\"visit_macro_def: st={:?}\", self.st);\n-        SawMacroDef.hash(self.st);\n-        hash_attrs!(self, &macro_def.attrs);\n-        for tt in macro_def.body.trees() {\n-            self.hash_token_tree(&tt);\n-        }\n-        visit::walk_macro_def(self, macro_def)\n-    }\n-}\n-\n-#[derive(Hash)]\n-pub enum DefHash {\n-    SawDefId,\n-    SawLabel,\n-    SawPrimTy,\n-    SawSelfTy,\n-    SawErr,\n-}\n-\n-impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n-    fn hash_resolve(&mut self, id: ast::NodeId) {\n-        // Because whether or not a given id has an entry is dependent\n-        // solely on expr variant etc, we don't need to hash whether\n-        // or not an entry was present (we are already hashing what\n-        // variant it is above when we visit the HIR).\n-\n-        if let Some(traits) = self.tcx.trait_map.get(&id) {\n-            debug!(\"hash_resolve: id={:?} traits={:?} st={:?}\", id, traits, self.st);\n-            traits.len().hash(self.st);\n-\n-            // The ordering of the candidates is not fixed. So we hash\n-            // the def-ids and then sort them and hash the collection.\n-            let mut candidates: Vec<_> =\n-                traits.iter()\n-                      .map(|&TraitCandidate { def_id, import_id: _ }| {\n-                          self.compute_def_id_hash(def_id)\n-                      })\n-                      .collect();\n-            candidates.sort();\n-            candidates.hash(self.st);\n-        }\n-    }\n-\n-    fn hash_def_id(&mut self, def_id: DefId) {\n-        self.compute_def_id_hash(def_id).hash(self.st);\n-    }\n-\n-    fn hash_def(&mut self, def: Def) {\n-        match def {\n-            // Crucial point: for all of these variants, the variant +\n-            // add'l data that is added is always the same if the\n-            // def-id is the same, so it suffices to hash the def-id\n-            Def::Fn(..) |\n-            Def::Mod(..) |\n-            Def::Static(..) |\n-            Def::Variant(..) |\n-            Def::VariantCtor(..) |\n-            Def::Enum(..) |\n-            Def::TyAlias(..) |\n-            Def::AssociatedTy(..) |\n-            Def::TyParam(..) |\n-            Def::Struct(..) |\n-            Def::StructCtor(..) |\n-            Def::Union(..) |\n-            Def::Trait(..) |\n-            Def::Method(..) |\n-            Def::Const(..) |\n-            Def::AssociatedConst(..) |\n-            Def::Local(..) |\n-            Def::Upvar(..) |\n-            Def::Macro(..) => {\n-                DefHash::SawDefId.hash(self.st);\n-                self.hash_def_id(def.def_id());\n-            }\n-\n-            Def::Label(..) => {\n-                DefHash::SawLabel.hash(self.st);\n-                // we don't encode the `id` because it always refers to something\n-                // within this item, so if it changed, there would have to be other\n-                // changes too\n-            }\n-            Def::PrimTy(ref prim_ty) => {\n-                DefHash::SawPrimTy.hash(self.st);\n-                prim_ty.hash(self.st);\n-            }\n-            Def::SelfTy(..) => {\n-                DefHash::SawSelfTy.hash(self.st);\n-                // the meaning of Self is always the same within a\n-                // given context, so we don't need to hash the other\n-                // fields\n-            }\n-            Def::Err => {\n-                DefHash::SawErr.hash(self.st);\n-            }\n-        }\n-    }\n-\n-    pub fn hash_attributes(&mut self, attributes: &[ast::Attribute]) {\n-        debug!(\"hash_attributes: st={:?}\", self.st);\n-        let indices = self.indices_sorted_by(attributes, |attr| attr.name());\n-\n-        for i in indices {\n-            let attr = &attributes[i];\n-            match attr.name() {\n-                Some(name) if IGNORED_ATTRIBUTES.contains(&&*name.as_str()) => continue,\n-                _ => {}\n-            };\n-            if !attr.is_sugared_doc {\n-                SawAttribute(attr.style).hash(self.st);\n-                for segment in &attr.path.segments {\n-                    SawIdent(segment.identifier.name.as_str()).hash(self.st);\n-                }\n-                for tt in attr.tokens.trees() {\n-                    self.hash_token_tree(&tt);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn indices_sorted_by<T, K, F>(&mut self, items: &[T], get_key: F) -> Vec<usize>\n-        where K: Ord,\n-              F: Fn(&T) -> K\n-    {\n-        let mut indices = Vec::with_capacity(items.len());\n-        indices.extend(0 .. items.len());\n-        indices.sort_by_key(|index| get_key(&items[*index]));\n-        indices\n-    }\n-\n-    fn maybe_enable_overflow_checks(&mut self, item_attrs: &[ast::Attribute]) {\n-        if attr::contains_name(item_attrs, \"rustc_inherit_overflow_checks\") {\n-            self.overflow_checks_enabled = true;\n-        }\n-    }\n-\n-    fn hash_token_tree(&mut self, tt: &tokenstream::TokenTree) {\n-        self.hash_discriminant(tt);\n-        match *tt {\n-            tokenstream::TokenTree::Token(span, ref token) => {\n-                hash_span!(self, span);\n-                self.hash_token(token, span);\n-            }\n-            tokenstream::TokenTree::Delimited(span, ref delimited) => {\n-                hash_span!(self, span);\n-                delimited.delim.hash(self.st);\n-                for sub_tt in delimited.stream().trees() {\n-                    self.hash_token_tree(&sub_tt);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn hash_token(&mut self,\n-                  token: &token::Token,\n-                  error_reporting_span: Span) {\n-        self.hash_discriminant(token);\n-        match *token {\n-            token::Token::Eq |\n-            token::Token::Lt |\n-            token::Token::Le |\n-            token::Token::EqEq |\n-            token::Token::Ne |\n-            token::Token::Ge |\n-            token::Token::Gt |\n-            token::Token::AndAnd |\n-            token::Token::OrOr |\n-            token::Token::Not |\n-            token::Token::Tilde |\n-            token::Token::At |\n-            token::Token::Dot |\n-            token::Token::DotDot |\n-            token::Token::DotDotDot |\n-            token::Token::Comma |\n-            token::Token::Semi |\n-            token::Token::Colon |\n-            token::Token::ModSep |\n-            token::Token::RArrow |\n-            token::Token::LArrow |\n-            token::Token::FatArrow |\n-            token::Token::Pound |\n-            token::Token::Dollar |\n-            token::Token::Question |\n-            token::Token::Underscore |\n-            token::Token::Whitespace |\n-            token::Token::Comment |\n-            token::Token::Eof => {}\n-\n-            token::Token::BinOp(bin_op_token) |\n-            token::Token::BinOpEq(bin_op_token) => bin_op_token.hash(self.st),\n-\n-            token::Token::OpenDelim(delim_token) |\n-            token::Token::CloseDelim(delim_token) => delim_token.hash(self.st),\n-\n-            token::Token::Literal(ref lit, ref opt_name) => {\n-                self.hash_discriminant(lit);\n-                match *lit {\n-                    token::Lit::Byte(val) |\n-                    token::Lit::Char(val) |\n-                    token::Lit::Integer(val) |\n-                    token::Lit::Float(val) |\n-                    token::Lit::Str_(val) |\n-                    token::Lit::ByteStr(val) => val.as_str().hash(self.st),\n-                    token::Lit::StrRaw(val, n) |\n-                    token::Lit::ByteStrRaw(val, n) => {\n-                        val.as_str().hash(self.st);\n-                        n.hash(self.st);\n-                    }\n-                };\n-                opt_name.map(ast::Name::as_str).hash(self.st);\n-            }\n-\n-            token::Token::Ident(ident) |\n-            token::Token::Lifetime(ident) |\n-            token::Token::SubstNt(ident) => ident.name.as_str().hash(self.st),\n-\n-            token::Token::Interpolated(ref non_terminal) => {\n-                // FIXME(mw): This could be implemented properly. It's just a\n-                //            lot of work, since we would need to hash the AST\n-                //            in a stable way, in addition to the HIR.\n-                //            Since this is hardly used anywhere, just emit a\n-                //            warning for now.\n-                if self.tcx.sess.opts.debugging_opts.incremental.is_some() {\n-                    let msg = format!(\"Quasi-quoting might make incremental \\\n-                                       compilation very inefficient: {:?}\",\n-                                      non_terminal);\n-                    self.tcx.sess.span_warn(error_reporting_span, &msg[..]);\n-                }\n-\n-                non_terminal.hash(self.st);\n-            }\n-\n-            token::Token::DocComment(val) |\n-            token::Token::Shebang(val) => val.as_str().hash(self.st),\n-        }\n-    }\n-\n-    pub fn hash_crate_root_module(&mut self, krate: &'tcx Crate) {\n-        let hir::Crate {\n-            ref module,\n-            ref attrs,\n-            span,\n-\n-            // These fields are handled separately:\n-            exported_macros: _,\n-            items: _,\n-            trait_items: _,\n-            impl_items: _,\n-            bodies: _,\n-            trait_impls: _,\n-            trait_default_impl: _,\n-            body_ids: _,\n-        } = *krate;\n-\n-        visit::Visitor::visit_mod(self, module, span, ast::CRATE_NODE_ID);\n-        // Crate attributes are not copied over to the root `Mod`, so hash them\n-        // explicitly here.\n-        hash_attrs!(self, attrs);\n-    }\n-}"}, {"sha": "d10df17f85837bc251a7055f04f512704eb5d792", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -22,7 +22,6 @@\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(rand)]\n-#![feature(core_intrinsics)]\n #![feature(conservative_impl_trait)]\n #![cfg_attr(stage0, feature(pub_restricted))]\n "}, {"sha": "63cfe591ce366b6fefdd6367de221f214f12610d", "filename": "src/librustc_trans/assert_module_sources.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc_trans%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustc_trans%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fassert_module_sources.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -32,8 +32,7 @@ use syntax::ast;\n \n use {ModuleSource, ModuleTranslation};\n \n-const PARTITION_REUSED: &'static str = \"rustc_partition_reused\";\n-const PARTITION_TRANSLATED: &'static str = \"rustc_partition_translated\";\n+use rustc::ich::{ATTR_PARTITION_REUSED, ATTR_PARTITION_TRANSLATED};\n \n const MODULE: &'static str = \"module\";\n const CFG: &'static str = \"cfg\";\n@@ -62,9 +61,9 @@ struct AssertModuleSource<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n     fn check_attr(&self, attr: &ast::Attribute) {\n-        let disposition = if attr.check_name(PARTITION_REUSED) {\n+        let disposition = if attr.check_name(ATTR_PARTITION_REUSED) {\n             Disposition::Reused\n-        } else if attr.check_name(PARTITION_TRANSLATED) {\n+        } else if attr.check_name(ATTR_PARTITION_TRANSLATED) {\n             Disposition::Translated\n         } else {\n             return;"}, {"sha": "1e687d63f58755d732d1e71878c4ca45262d90df", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 267, "deletions": 461, "changes": 728, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -16,18 +16,18 @@\n //! of `fmt::Display`. Example usage:\n //!\n //! ```rust,ignore\n-//! use rustdoc::html::markdown::{Markdown, MarkdownOutputStyle};\n+//! use rustdoc::html::markdown::Markdown;\n //!\n //! let s = \"My *markdown* _text_\";\n-//! let html = format!(\"{}\", Markdown(s, MarkdownOutputStyle::Fancy));\n+//! let html = format!(\"{}\", Markdown(s));\n //! // ... something using html\n //! ```\n \n #![allow(non_camel_case_types)]\n \n use std::ascii::AsciiExt;\n use std::cell::RefCell;\n-use std::collections::HashMap;\n+use std::collections::{HashMap, VecDeque};\n use std::default::Default;\n use std::fmt::{self, Write};\n use std::str;\n@@ -37,43 +37,23 @@ use syntax::codemap::Span;\n use html::render::derive_id;\n use html::toc::TocBuilder;\n use html::highlight;\n-use html::escape::Escape;\n use test;\n \n-use pulldown_cmark::{self, Event, Parser, Tag};\n-\n-#[derive(Copy, Clone)]\n-pub enum MarkdownOutputStyle {\n-    Compact,\n-    Fancy,\n-}\n-\n-impl MarkdownOutputStyle {\n-    pub fn is_compact(&self) -> bool {\n-        match *self {\n-            MarkdownOutputStyle::Compact => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_fancy(&self) -> bool {\n-        match *self {\n-            MarkdownOutputStyle::Fancy => true,\n-            _ => false,\n-        }\n-    }\n-}\n+use pulldown_cmark::{html, Event, Tag, Parser};\n+use pulldown_cmark::{Options, OPTION_ENABLE_FOOTNOTES, OPTION_ENABLE_TABLES};\n \n /// A unit struct which has the `fmt::Display` trait implemented. When\n /// formatted, this struct will emit the HTML corresponding to the rendered\n /// version of the contained markdown string.\n // The second parameter is whether we need a shorter version or not.\n-pub struct Markdown<'a>(pub &'a str, pub MarkdownOutputStyle);\n+pub struct Markdown<'a>(pub &'a str);\n /// A unit struct like `Markdown`, that renders the markdown with a\n /// table of contents.\n pub struct MarkdownWithToc<'a>(pub &'a str);\n /// A unit struct like `Markdown`, that renders the markdown escaping HTML tags.\n pub struct MarkdownHtml<'a>(pub &'a str);\n+/// A unit struct like `Markdown`, that renders only the first paragraph.\n+pub struct MarkdownSummaryLine<'a>(pub &'a str);\n \n /// Returns Some(code) if `s` is a line that should be stripped from\n /// documentation but used in example code. `code` is the portion of\n@@ -90,12 +70,21 @@ fn stripped_filtered_line<'a>(s: &'a str) -> Option<&'a str> {\n     }\n }\n \n-/// Returns a new string with all consecutive whitespace collapsed into\n-/// single spaces.\n+/// Convert chars from a title for an id.\n ///\n-/// Any leading or trailing whitespace will be trimmed.\n-fn collapse_whitespace(s: &str) -> String {\n-    s.split_whitespace().collect::<Vec<_>>().join(\" \")\n+/// \"Hello, world!\" -> \"hello-world\"\n+fn slugify(c: char) -> Option<char> {\n+    if c.is_alphanumeric() || c == '-' || c == '_' {\n+        if c.is_ascii() {\n+            Some(c.to_ascii_lowercase())\n+        } else {\n+            Some(c)\n+        }\n+    } else if c.is_whitespace() && c.is_ascii() {\n+        Some('-')\n+    } else {\n+        None\n+    }\n }\n \n // Information about the playground if a URL has been specified, containing an\n@@ -104,103 +93,50 @@ thread_local!(pub static PLAYGROUND: RefCell<Option<(Option<String>, String)>> =\n     RefCell::new(None)\n });\n \n-macro_rules! event_loop_break {\n-    ($parser:expr, $toc_builder:expr, $shorter:expr, $buf:expr, $escape:expr, $id:expr,\n-     $($end_event:pat)|*) => {{\n-        fn inner(id: &mut Option<&mut String>, s: &str) {\n-            if let Some(ref mut id) = *id {\n-                id.push_str(s);\n-            }\n-        }\n-        while let Some(event) = $parser.next() {\n-            match event {\n-                $($end_event)|* => break,\n-                Event::Text(ref s) => {\n-                    debug!(\"Text\");\n-                    inner($id, s);\n-                    if $escape {\n-                        $buf.push_str(&format!(\"{}\", Escape(s)));\n-                    } else {\n-                        $buf.push_str(s);\n-                    }\n-                }\n-                Event::SoftBreak => {\n-                    debug!(\"SoftBreak\");\n-                    if !$buf.is_empty() {\n-                        $buf.push(' ');\n-                    }\n-                }\n-                x => {\n-                    looper($parser, &mut $buf, Some(x), $toc_builder, $shorter, $id);\n-                }\n-            }\n-        }\n-    }}\n-}\n-\n-struct ParserWrapper<'a> {\n-    parser: Parser<'a>,\n-    // The key is the footnote reference. The value is the footnote definition and the id.\n-    footnotes: HashMap<String, (String, u16)>,\n+/// Adds syntax highlighting and playground Run buttons to rust code blocks.\n+struct CodeBlocks<'a, I: Iterator<Item = Event<'a>>> {\n+    inner: I,\n }\n \n-impl<'a> ParserWrapper<'a> {\n-    pub fn new(s: &'a str) -> ParserWrapper<'a> {\n-        ParserWrapper {\n-            parser: Parser::new_ext(s, pulldown_cmark::OPTION_ENABLE_TABLES |\n-                                       pulldown_cmark::OPTION_ENABLE_FOOTNOTES),\n-            footnotes: HashMap::new(),\n+impl<'a, I: Iterator<Item = Event<'a>>> CodeBlocks<'a, I> {\n+    fn new(iter: I) -> Self {\n+        CodeBlocks {\n+            inner: iter,\n         }\n     }\n+}\n \n-    pub fn next(&mut self) -> Option<Event<'a>> {\n-        self.parser.next()\n-    }\n+impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n+    type Item = Event<'a>;\n \n-    pub fn get_entry(&mut self, key: &str) -> &mut (String, u16) {\n-        let new_id = self.footnotes.keys().count() + 1;\n-        let key = key.to_owned();\n-        self.footnotes.entry(key).or_insert((String::new(), new_id as u16))\n-    }\n-}\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let event = self.inner.next();\n+        if let Some(Event::Start(Tag::CodeBlock(lang))) = event {\n+            if !LangString::parse(&lang).rust {\n+                return Some(Event::Start(Tag::CodeBlock(lang)));\n+            }\n+        } else {\n+            return event;\n+        }\n \n-pub fn render(w: &mut fmt::Formatter,\n-              s: &str,\n-              print_toc: bool,\n-              shorter: MarkdownOutputStyle) -> fmt::Result {\n-    fn code_block(parser: &mut ParserWrapper, buffer: &mut String, lang: &str) {\n-        debug!(\"CodeBlock\");\n         let mut origtext = String::new();\n-        while let Some(event) = parser.next() {\n+        for event in &mut self.inner {\n             match event {\n-                Event::End(Tag::CodeBlock(_)) => break,\n+                Event::End(Tag::CodeBlock(..)) => break,\n                 Event::Text(ref s) => {\n                     origtext.push_str(s);\n                 }\n                 _ => {}\n             }\n         }\n-        let origtext = origtext.trim_left();\n-        debug!(\"docblock: ==============\\n{:?}\\n=======\", origtext);\n-\n         let lines = origtext.lines().filter(|l| {\n             stripped_filtered_line(*l).is_none()\n         });\n         let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n-        let block_info = if lang.is_empty() {\n-            LangString::all_false()\n-        } else {\n-            LangString::parse(lang)\n-        };\n-        if !block_info.rust {\n-            buffer.push_str(&format!(\"<pre><code class=\\\"language-{}\\\">{}</code></pre>\",\n-                            lang, text));\n-            return\n-        }\n         PLAYGROUND.with(|play| {\n             // insert newline to clearly separate it from the\n             // previous block so we can shorten the html output\n-            buffer.push('\\n');\n+            let mut s = String::from(\"\\n\");\n             let playground_button = play.borrow().as_ref().and_then(|&(ref krate, ref url)| {\n                 if url.is_empty() {\n                     return None;\n@@ -210,7 +146,7 @@ pub fn render(w: &mut fmt::Formatter,\n                 }).collect::<Vec<&str>>().join(\"\\n\");\n                 let krate = krate.as_ref().map(|s| &**s);\n                 let test = test::maketest(&test, krate, false,\n-                                          &Default::default());\n+                                        &Default::default());\n                 let channel = if test.contains(\"#![feature(\") {\n                     \"&amp;version=nightly\"\n                 } else {\n@@ -239,376 +175,186 @@ pub fn render(w: &mut fmt::Formatter,\n                     url, test_escaped, channel\n                 ))\n             });\n-            buffer.push_str(&highlight::render_with_highlighting(\n-                            &text,\n-                            Some(\"rust-example-rendered\"),\n-                            None,\n-                            playground_button.as_ref().map(String::as_str)));\n-        });\n-    }\n-\n-    fn heading(parser: &mut ParserWrapper, buffer: &mut String,\n-               toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle, level: i32) {\n-        debug!(\"Heading\");\n-        let mut ret = String::new();\n-        let mut id = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, ret, true, &mut Some(&mut id),\n-                          Event::End(Tag::Header(_)));\n-        ret = ret.trim_right().to_owned();\n-\n-        let id = id.chars().filter_map(|c| {\n-            if c.is_alphanumeric() || c == '-' || c == '_' {\n-                if c.is_ascii() {\n-                    Some(c.to_ascii_lowercase())\n-                } else {\n-                    Some(c)\n-                }\n-            } else if c.is_whitespace() && c.is_ascii() {\n-                Some('-')\n-            } else {\n-                None\n-            }\n-        }).collect::<String>();\n-\n-        let id = derive_id(id);\n-\n-        let sec = toc_builder.as_mut().map_or(\"\".to_owned(), |builder| {\n-            format!(\"{} \", builder.push(level as u32, ret.clone(), id.clone()))\n-        });\n-\n-        // Render the HTML\n-        buffer.push_str(&format!(\"<h{lvl} id=\\\"{id}\\\" class=\\\"section-header\\\">\\\n-                                  <a href=\\\"#{id}\\\">{sec}{}</a></h{lvl}>\",\n-                                 ret, lvl = level, id = id, sec = sec));\n+            s.push_str(&highlight::render_with_highlighting(\n+                        &text,\n+                        Some(\"rust-example-rendered\"),\n+                        None,\n+                        playground_button.as_ref().map(String::as_str)));\n+            Some(Event::Html(s.into()))\n+        })\n     }\n+}\n \n-    fn inline_code(parser: &mut ParserWrapper, buffer: &mut String,\n-                   toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle,\n-                   id: &mut Option<&mut String>) {\n-        debug!(\"InlineCode\");\n-        let mut content = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, content, false, id, Event::End(Tag::Code));\n-        buffer.push_str(&format!(\"<code>{}</code>\",\n-                                 Escape(&collapse_whitespace(content.trim_right()))));\n-    }\n+/// Make headings links with anchor ids and build up TOC.\n+struct HeadingLinks<'a, 'b, I: Iterator<Item = Event<'a>>> {\n+    inner: I,\n+    toc: Option<&'b mut TocBuilder>,\n+    buf: VecDeque<Event<'a>>,\n+}\n \n-    fn link(parser: &mut ParserWrapper, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-            shorter: MarkdownOutputStyle, url: &str, title: &str,\n-            id: &mut Option<&mut String>) {\n-        debug!(\"Link\");\n-        let mut content = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, content, true, id,\n-                          Event::End(Tag::Link(_, _)));\n-        if title.is_empty() {\n-            buffer.push_str(&format!(\"<a href=\\\"{}\\\">{}</a>\", url, content));\n-        } else {\n-            buffer.push_str(&format!(\"<a href=\\\"{}\\\" title=\\\"{}\\\">{}</a>\",\n-                                     url, Escape(title), content));\n+impl<'a, 'b, I: Iterator<Item = Event<'a>>> HeadingLinks<'a, 'b, I> {\n+    fn new(iter: I, toc: Option<&'b mut TocBuilder>) -> Self {\n+        HeadingLinks {\n+            inner: iter,\n+            toc: toc,\n+            buf: VecDeque::new(),\n         }\n     }\n+}\n \n-    fn image(parser: &mut ParserWrapper, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-            shorter: MarkdownOutputStyle, url: &str, mut title: String,\n-            id: &mut Option<&mut String>) {\n-        debug!(\"Image\");\n-        event_loop_break!(parser, toc_builder, shorter, title, true, id,\n-                          Event::End(Tag::Image(_, _)));\n-        buffer.push_str(&format!(\"<img src=\\\"{}\\\" alt=\\\"{}\\\">\", url, title));\n-    }\n-\n-    fn paragraph(parser: &mut ParserWrapper, buffer: &mut String,\n-                 toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle,\n-                 id: &mut Option<&mut String>) {\n-        debug!(\"Paragraph\");\n-        let mut content = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, content, true, id,\n-                          Event::End(Tag::Paragraph));\n-        buffer.push_str(&format!(\"<p>{}</p>\", content.trim_right()));\n-    }\n-\n-    fn table_cell(parser: &mut ParserWrapper, buffer: &mut String,\n-                  toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle) {\n-        debug!(\"TableCell\");\n-        let mut content = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, content, true, &mut None,\n-                          Event::End(Tag::TableHead) |\n-                              Event::End(Tag::Table(_)) |\n-                              Event::End(Tag::TableRow) |\n-                              Event::End(Tag::TableCell));\n-        buffer.push_str(&format!(\"<td>{}</td>\", content.trim()));\n-    }\n+impl<'a, 'b, I: Iterator<Item = Event<'a>>> Iterator for HeadingLinks<'a, 'b, I> {\n+    type Item = Event<'a>;\n \n-    fn table_row(parser: &mut ParserWrapper, buffer: &mut String,\n-                 toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle) {\n-        debug!(\"TableRow\");\n-        let mut content = String::new();\n-        while let Some(event) = parser.next() {\n-            match event {\n-                Event::End(Tag::TableHead) |\n-                    Event::End(Tag::Table(_)) |\n-                    Event::End(Tag::TableRow) => break,\n-                Event::Start(Tag::TableCell) => {\n-                    table_cell(parser, &mut content, toc_builder, shorter);\n-                }\n-                x => {\n-                    looper(parser, &mut content, Some(x), toc_builder, shorter, &mut None);\n-                }\n-            }\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if let Some(e) = self.buf.pop_front() {\n+            return Some(e);\n         }\n-        buffer.push_str(&format!(\"<tr>{}</tr>\", content));\n-    }\n \n-    fn table_head(parser: &mut ParserWrapper, buffer: &mut String,\n-                  toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle) {\n-        debug!(\"TableHead\");\n-        let mut content = String::new();\n-        while let Some(event) = parser.next() {\n-            match event {\n-                Event::End(Tag::TableHead) | Event::End(Tag::Table(_)) => break,\n-                Event::Start(Tag::TableCell) => {\n-                    table_cell(parser, &mut content, toc_builder, shorter);\n-                }\n-                x => {\n-                    looper(parser, &mut content, Some(x), toc_builder, shorter, &mut None);\n+        let event = self.inner.next();\n+        if let Some(Event::Start(Tag::Header(level))) = event {\n+            let mut id = String::new();\n+            for event in &mut self.inner {\n+                match event {\n+                    Event::End(Tag::Header(..)) => break,\n+                    Event::Text(ref text) => id.extend(text.chars().filter_map(slugify)),\n+                    _ => {},\n                 }\n+                self.buf.push_back(event);\n             }\n-        }\n-        if !content.is_empty() {\n-            buffer.push_str(&format!(\"<thead><tr>{}</tr></thead>\", content.replace(\"td>\", \"th>\")));\n-        }\n-    }\n+            let id = derive_id(id);\n \n-    fn table(parser: &mut ParserWrapper, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-             shorter: MarkdownOutputStyle) {\n-        debug!(\"Table\");\n-        let mut content = String::new();\n-        let mut rows = String::new();\n-        while let Some(event) = parser.next() {\n-            match event {\n-                Event::End(Tag::Table(_)) => break,\n-                Event::Start(Tag::TableHead) => {\n-                    table_head(parser, &mut content, toc_builder, shorter);\n-                }\n-                Event::Start(Tag::TableRow) => {\n-                    table_row(parser, &mut rows, toc_builder, shorter);\n-                }\n-                _ => {}\n+            if let Some(ref mut builder) = self.toc {\n+                let mut html_header = String::new();\n+                html::push_html(&mut html_header, self.buf.iter().cloned());\n+                let sec = builder.push(level as u32, html_header, id.clone());\n+                self.buf.push_front(Event::InlineHtml(format!(\"{} \", sec).into()));\n             }\n-        }\n-        buffer.push_str(&format!(\"<table>{}{}</table>\",\n-                                 content,\n-                                 if shorter.is_compact() || rows.is_empty() {\n-                                     String::new()\n-                                 } else {\n-                                     format!(\"<tbody>{}</tbody>\", rows)\n-                                 }));\n-    }\n \n-    fn blockquote(parser: &mut ParserWrapper, buffer: &mut String,\n-                  toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle) {\n-        debug!(\"BlockQuote\");\n-        let mut content = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, content, true, &mut None,\n-                          Event::End(Tag::BlockQuote));\n-        buffer.push_str(&format!(\"<blockquote>{}</blockquote>\", content.trim_right()));\n-    }\n+            self.buf.push_back(Event::InlineHtml(format!(\"</a></h{}>\", level).into()));\n \n-    fn list_item(parser: &mut ParserWrapper, buffer: &mut String,\n-                 toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle) {\n-        debug!(\"ListItem\");\n-        let mut content = String::new();\n-        while let Some(event) = parser.next() {\n-            match event {\n-                Event::End(Tag::Item) => break,\n-                Event::Text(ref s) => {\n-                    content.push_str(&format!(\"{}\", Escape(s)));\n-                }\n-                x => {\n-                    looper(parser, &mut content, Some(x), toc_builder, shorter, &mut None);\n-                }\n-            }\n-            if shorter.is_compact() {\n-                break\n-            }\n+            let start_tags = format!(\"<h{level} id=\\\"{id}\\\" class=\\\"section-header\\\">\\\n+                                      <a href=\\\"#{id}\\\">\",\n+                                     id = id,\n+                                     level = level);\n+            return Some(Event::InlineHtml(start_tags.into()));\n         }\n-        buffer.push_str(&format!(\"<li>{}</li>\", content));\n+        event\n     }\n+}\n \n-    fn list(parser: &mut ParserWrapper, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-            shorter: MarkdownOutputStyle, is_sorted_list: bool) {\n-        debug!(\"List\");\n-        let mut content = String::new();\n-        while let Some(event) = parser.next() {\n-            match event {\n-                Event::End(Tag::List(_)) => break,\n-                Event::Start(Tag::Item) => {\n-                    list_item(parser, &mut content, toc_builder, shorter);\n-                }\n-                x => {\n-                    looper(parser, &mut content, Some(x), toc_builder, shorter, &mut None);\n-                }\n-            }\n-            if shorter.is_compact() {\n-                break\n-            }\n+/// Extracts just the first paragraph.\n+struct SummaryLine<'a, I: Iterator<Item = Event<'a>>> {\n+    inner: I,\n+    started: bool,\n+    depth: u32,\n+}\n+\n+impl<'a, I: Iterator<Item = Event<'a>>> SummaryLine<'a, I> {\n+    fn new(iter: I) -> Self {\n+        SummaryLine {\n+            inner: iter,\n+            started: false,\n+            depth: 0,\n         }\n-        buffer.push_str(&format!(\"<{0}>{1}</{0}>\",\n-                                 if is_sorted_list { \"ol\" } else { \"ul\" },\n-                                 content));\n     }\n+}\n \n-    fn emphasis(parser: &mut ParserWrapper, buffer: &mut String,\n-                toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle,\n-                id: &mut Option<&mut String>) {\n-        debug!(\"Emphasis\");\n-        let mut content = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, content, false, id,\n-                          Event::End(Tag::Emphasis));\n-        buffer.push_str(&format!(\"<em>{}</em>\", content));\n-    }\n+impl<'a, I: Iterator<Item = Event<'a>>> Iterator for SummaryLine<'a, I> {\n+    type Item = Event<'a>;\n \n-    fn strong(parser: &mut ParserWrapper, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-              shorter: MarkdownOutputStyle, id: &mut Option<&mut String>) {\n-        debug!(\"Strong\");\n-        let mut content = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, content, false, id,\n-                          Event::End(Tag::Strong));\n-        buffer.push_str(&format!(\"<strong>{}</strong>\", content));\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.started && self.depth == 0 {\n+            return None;\n+        }\n+        if !self.started {\n+            self.started = true;\n+        }\n+        let event = self.inner.next();\n+        match event {\n+            Some(Event::Start(..)) => self.depth += 1,\n+            Some(Event::End(..)) => self.depth -= 1,\n+            _ => {}\n+        }\n+        event\n     }\n+}\n \n-    fn footnote(parser: &mut ParserWrapper, buffer: &mut String,\n-                toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle,\n-                id: &mut Option<&mut String>) {\n-        debug!(\"FootnoteDefinition\");\n-        let mut content = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, content, true, id,\n-                          Event::End(Tag::FootnoteDefinition(_)));\n-        buffer.push_str(&content);\n-    }\n+/// Moves all footnote definitions to the end and add back links to the\n+/// references.\n+struct Footnotes<'a, I: Iterator<Item = Event<'a>>> {\n+    inner: I,\n+    footnotes: HashMap<String, (Vec<Event<'a>>, u16)>,\n+}\n \n-    fn rule(parser: &mut ParserWrapper, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-            shorter: MarkdownOutputStyle, id: &mut Option<&mut String>) {\n-        debug!(\"Rule\");\n-        let mut content = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, content, true, id,\n-                          Event::End(Tag::Rule));\n-        buffer.push_str(\"<hr>\");\n+impl<'a, I: Iterator<Item = Event<'a>>> Footnotes<'a, I> {\n+    fn new(iter: I) -> Self {\n+        Footnotes {\n+            inner: iter,\n+            footnotes: HashMap::new(),\n+        }\n+    }\n+    fn get_entry(&mut self, key: &str) -> &mut (Vec<Event<'a>>, u16) {\n+        let new_id = self.footnotes.keys().count() + 1;\n+        let key = key.to_owned();\n+        self.footnotes.entry(key).or_insert((Vec::new(), new_id as u16))\n     }\n+}\n \n-    fn looper<'a>(parser: &'a mut ParserWrapper, buffer: &mut String, next_event: Option<Event<'a>>,\n-                  toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle,\n-                  id: &mut Option<&mut String>) -> bool {\n-        if let Some(event) = next_event {\n-            match event {\n-                Event::Start(Tag::CodeBlock(lang)) => {\n-                    code_block(parser, buffer, &*lang);\n-                }\n-                Event::Start(Tag::Header(level)) => {\n-                    heading(parser, buffer, toc_builder, shorter, level);\n-                }\n-                Event::Start(Tag::Code) => {\n-                    inline_code(parser, buffer, toc_builder, shorter, id);\n-                }\n-                Event::Start(Tag::Paragraph) => {\n-                    paragraph(parser, buffer, toc_builder, shorter, id);\n-                }\n-                Event::Start(Tag::Link(ref url, ref t)) => {\n-                    link(parser, buffer, toc_builder, shorter, url, t.as_ref(), id);\n-                }\n-                Event::Start(Tag::Image(ref url, ref t)) => {\n-                    image(parser, buffer, toc_builder, shorter, url, t.as_ref().to_owned(), id);\n-                }\n-                Event::Start(Tag::Table(_)) => {\n-                    table(parser, buffer, toc_builder, shorter);\n-                }\n-                Event::Start(Tag::BlockQuote) => {\n-                    blockquote(parser, buffer, toc_builder, shorter);\n-                }\n-                Event::Start(Tag::List(x)) => {\n-                    list(parser, buffer, toc_builder, shorter, x.is_some());\n-                }\n-                Event::Start(Tag::Emphasis) => {\n-                    emphasis(parser, buffer, toc_builder, shorter, id);\n-                }\n-                Event::Start(Tag::Strong) => {\n-                    strong(parser, buffer, toc_builder, shorter, id);\n-                }\n-                Event::Start(Tag::Rule) => {\n-                    rule(parser, buffer, toc_builder, shorter, id);\n-                }\n-                Event::Start(Tag::FootnoteDefinition(ref def)) => {\n-                    debug!(\"FootnoteDefinition\");\n-                    let mut content = String::new();\n-                    let def = def.as_ref();\n-                    footnote(parser, &mut content, toc_builder, shorter, id);\n-                    let entry = parser.get_entry(def);\n-                    let cur_id = (*entry).1;\n-                    (*entry).0.push_str(&format!(\"<li id=\\\"ref{}\\\">{}&nbsp;<a href=\\\"#supref{0}\\\" \\\n-                                                  rev=\\\"footnote\\\">\u21a9</a></p></li>\",\n-                                                 cur_id,\n-                                                 if content.ends_with(\"</p>\") {\n-                                                     &content[..content.len() - 4]\n-                                                 } else {\n-                                                     &content\n-                                                 }));\n-                }\n-                Event::FootnoteReference(ref reference) => {\n-                    debug!(\"FootnoteReference\");\n-                    let entry = parser.get_entry(reference.as_ref());\n-                    buffer.push_str(&format!(\"<sup id=\\\"supref{0}\\\"><a href=\\\"#ref{0}\\\">{0}</a>\\\n-                                              </sup>\",\n-                                             (*entry).1));\n-                }\n-                Event::HardBreak => {\n-                    debug!(\"HardBreak\");\n-                    if shorter.is_fancy() {\n-                        buffer.push_str(\"<br>\");\n-                    } else if !buffer.is_empty() {\n-                        buffer.push(' ');\n+impl<'a, I: Iterator<Item = Event<'a>>> Iterator for Footnotes<'a, I> {\n+    type Item = Event<'a>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        loop {\n+            match self.inner.next() {\n+                Some(Event::FootnoteReference(ref reference)) => {\n+                    let entry = self.get_entry(&reference);\n+                    let reference = format!(\"<sup id=\\\"supref{0}\\\"><a href=\\\"#ref{0}\\\">{0}\\\n+                                             </a></sup>\",\n+                                            (*entry).1);\n+                    return Some(Event::Html(reference.into()));\n+                }\n+                Some(Event::Start(Tag::FootnoteDefinition(def))) => {\n+                    let mut content = Vec::new();\n+                    for event in &mut self.inner {\n+                        if let Event::End(Tag::FootnoteDefinition(..)) = event {\n+                            break;\n+                        }\n+                        content.push(event);\n+                    }\n+                    let entry = self.get_entry(&def);\n+                    (*entry).0 = content;\n+                }\n+                Some(e) => return Some(e),\n+                None => {\n+                    if !self.footnotes.is_empty() {\n+                        let mut v: Vec<_> = self.footnotes.drain().map(|(_, x)| x).collect();\n+                        v.sort_by(|a, b| a.1.cmp(&b.1));\n+                        let mut ret = String::from(\"<div class=\\\"footnotes\\\"><hr><ol>\");\n+                        for (mut content, id) in v {\n+                            write!(ret, \"<li id=\\\"ref{}\\\">\", id).unwrap();\n+                            let mut is_paragraph = false;\n+                            if let Some(&Event::End(Tag::Paragraph)) = content.last() {\n+                                content.pop();\n+                                is_paragraph = true;\n+                            }\n+                            html::push_html(&mut ret, content.into_iter());\n+                            write!(ret,\n+                                   \"&nbsp;<a href=\\\"#supref{}\\\" rev=\\\"footnote\\\">\u21a9</a>\",\n+                                   id).unwrap();\n+                            if is_paragraph {\n+                                ret.push_str(\"</p>\");\n+                            }\n+                            ret.push_str(\"</li>\");\n+                        }\n+                        ret.push_str(\"</ol></div>\");\n+                        return Some(Event::Html(ret.into()));\n+                    } else {\n+                        return None;\n                     }\n                 }\n-                Event::Html(h) | Event::InlineHtml(h) => {\n-                    debug!(\"Html/InlineHtml\");\n-                    buffer.push_str(&*h);\n-                }\n-                _ => {}\n             }\n-            shorter.is_fancy()\n-        } else {\n-            false\n         }\n     }\n-\n-    let mut toc_builder = if print_toc {\n-        Some(TocBuilder::new())\n-    } else {\n-        None\n-    };\n-    let mut buffer = String::new();\n-    let mut parser = ParserWrapper::new(s);\n-    loop {\n-        let next_event = parser.next();\n-        if !looper(&mut parser, &mut buffer, next_event, &mut toc_builder, shorter, &mut None) {\n-            break\n-        }\n-    }\n-    if !parser.footnotes.is_empty() {\n-        let mut v: Vec<_> = parser.footnotes.values().collect();\n-        v.sort_by(|a, b| a.1.cmp(&b.1));\n-        buffer.push_str(&format!(\"<div class=\\\"footnotes\\\"><hr><ol>{}</ol></div>\",\n-                                 v.iter()\n-                                  .map(|s| s.0.as_str())\n-                                  .collect::<Vec<_>>()\n-                                  .join(\"\")));\n-    }\n-    let mut ret = toc_builder.map_or(Ok(()), |builder| {\n-        write!(w, \"<nav id=\\\"TOC\\\">{}</nav>\", builder.into_toc())\n-    });\n-\n-    if ret.is_ok() {\n-        ret = w.write_str(&buffer);\n-    }\n-    ret\n }\n \n pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Span) {\n@@ -755,17 +501,45 @@ impl LangString {\n \n impl<'a> fmt::Display for Markdown<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let Markdown(md, shorter) = *self;\n+        let Markdown(md) = *self;\n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n-        render(fmt, md, false, shorter)\n+\n+        let mut opts = Options::empty();\n+        opts.insert(OPTION_ENABLE_TABLES);\n+        opts.insert(OPTION_ENABLE_FOOTNOTES);\n+\n+        let p = Parser::new_ext(md, opts);\n+\n+        let mut s = String::with_capacity(md.len() * 3 / 2);\n+\n+        html::push_html(&mut s,\n+                        Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, None))));\n+\n+        fmt.write_str(&s)\n     }\n }\n \n impl<'a> fmt::Display for MarkdownWithToc<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let MarkdownWithToc(md) = *self;\n-        render(fmt, md, true, MarkdownOutputStyle::Fancy)\n+\n+        let mut opts = Options::empty();\n+        opts.insert(OPTION_ENABLE_TABLES);\n+        opts.insert(OPTION_ENABLE_FOOTNOTES);\n+\n+        let p = Parser::new_ext(md, opts);\n+\n+        let mut s = String::with_capacity(md.len() * 3 / 2);\n+\n+        let mut toc = TocBuilder::new();\n+\n+        html::push_html(&mut s,\n+                        Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, Some(&mut toc)))));\n+\n+        write!(fmt, \"<nav id=\\\"TOC\\\">{}</nav>\", toc.into_toc())?;\n+\n+        fmt.write_str(&s)\n     }\n }\n \n@@ -774,7 +548,41 @@ impl<'a> fmt::Display for MarkdownHtml<'a> {\n         let MarkdownHtml(md) = *self;\n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n-        render(fmt, md, false, MarkdownOutputStyle::Fancy)\n+\n+        let mut opts = Options::empty();\n+        opts.insert(OPTION_ENABLE_TABLES);\n+        opts.insert(OPTION_ENABLE_FOOTNOTES);\n+\n+        let p = Parser::new_ext(md, opts);\n+\n+        // Treat inline HTML as plain text.\n+        let p = p.map(|event| match event {\n+            Event::Html(text) | Event::InlineHtml(text) => Event::Text(text),\n+            _ => event\n+        });\n+\n+        let mut s = String::with_capacity(md.len() * 3 / 2);\n+\n+        html::push_html(&mut s,\n+                        Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, None))));\n+\n+        fmt.write_str(&s)\n+    }\n+}\n+\n+impl<'a> fmt::Display for MarkdownSummaryLine<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let MarkdownSummaryLine(md) = *self;\n+        // This is actually common enough to special-case\n+        if md.is_empty() { return Ok(()) }\n+\n+        let p = Parser::new(md);\n+\n+        let mut s = String::new();\n+\n+        html::push_html(&mut s, SummaryLine::new(p));\n+\n+        fmt.write_str(&s)\n     }\n }\n \n@@ -796,14 +604,10 @@ pub fn plain_summary_line(md: &str) -> String {\n             let next_event = next_event.unwrap();\n             let (ret, is_in) = match next_event {\n                 Event::Start(Tag::Paragraph) => (None, 1),\n-                Event::Start(Tag::Link(_, ref t)) if !self.is_first => {\n-                    (Some(t.as_ref().to_owned()), 1)\n-                }\n                 Event::Start(Tag::Code) => (Some(\"`\".to_owned()), 1),\n                 Event::End(Tag::Code) => (Some(\"`\".to_owned()), -1),\n                 Event::Start(Tag::Header(_)) => (None, 1),\n                 Event::Text(ref s) if self.is_in > 0 => (Some(s.as_ref().to_owned()), 0),\n-                Event::End(Tag::Link(_, ref t)) => (Some(t.as_ref().to_owned()), -1),\n                 Event::End(Tag::Paragraph) | Event::End(Tag::Header(_)) => (None, -1),\n                 _ => (None, 0),\n             };\n@@ -834,7 +638,7 @@ pub fn plain_summary_line(md: &str) -> String {\n \n #[cfg(test)]\n mod tests {\n-    use super::{LangString, Markdown, MarkdownHtml, MarkdownOutputStyle};\n+    use super::{LangString, Markdown, MarkdownHtml};\n     use super::plain_summary_line;\n     use html::render::reset_ids;\n \n@@ -874,14 +678,14 @@ mod tests {\n     #[test]\n     fn issue_17736() {\n         let markdown = \"# title\";\n-        format!(\"{}\", Markdown(markdown, MarkdownOutputStyle::Fancy));\n+        format!(\"{}\", Markdown(markdown));\n         reset_ids(true);\n     }\n \n     #[test]\n     fn test_header() {\n         fn t(input: &str, expect: &str) {\n-            let output = format!(\"{}\", Markdown(input, MarkdownOutputStyle::Fancy));\n+            let output = format!(\"{}\", Markdown(input));\n             assert_eq!(output, expect, \"original: {}\", input);\n             reset_ids(true);\n         }\n@@ -903,7 +707,7 @@ mod tests {\n     #[test]\n     fn test_header_ids_multiple_blocks() {\n         fn t(input: &str, expect: &str) {\n-            let output = format!(\"{}\", Markdown(input, MarkdownOutputStyle::Fancy));\n+            let output = format!(\"{}\", Markdown(input));\n             assert_eq!(output, expect, \"original: {}\", input);\n         }\n \n@@ -934,6 +738,7 @@ mod tests {\n         }\n \n         t(\"hello [Rust](https://www.rust-lang.org) :)\", \"hello Rust :)\");\n+        t(\"hello [Rust](https://www.rust-lang.org \\\"Rust\\\") :)\", \"hello Rust :)\");\n         t(\"code `let x = i32;` ...\", \"code `let x = i32;` ...\");\n         t(\"type `Type<'static>` ...\", \"type `Type<'static>` ...\");\n         t(\"# top header\", \"top header\");\n@@ -947,7 +752,8 @@ mod tests {\n             assert_eq!(output, expect, \"original: {}\", input);\n         }\n \n-        t(\"`Struct<'a, T>`\", \"<p><code>Struct&lt;&#39;a, T&gt;</code></p>\");\n-        t(\"Struct<'a, T>\", \"<p>Struct&lt;&#39;a, T&gt;</p>\");\n+        t(\"`Struct<'a, T>`\", \"<p><code>Struct&lt;'a, T&gt;</code></p>\\n\");\n+        t(\"Struct<'a, T>\", \"<p>Struct&lt;'a, T&gt;</p>\\n\");\n+        t(\"Struct<br>\", \"<p>Struct&lt;br&gt;</p>\\n\");\n     }\n }"}, {"sha": "1e1202f04005cdd3ccdb0b3b15b484c39b868b1e", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -72,7 +72,7 @@ use html::format::{TyParamBounds, WhereClause, href, AbiSpace};\n use html::format::{VisSpace, Method, UnsafetySpace, MutableSpace};\n use html::format::fmt_impl_for_trait_page;\n use html::item_type::ItemType;\n-use html::markdown::{self, Markdown, MarkdownHtml, MarkdownOutputStyle};\n+use html::markdown::{self, Markdown, MarkdownHtml, MarkdownSummaryLine};\n use html::{highlight, layout};\n \n /// A pair of name and its optional document.\n@@ -1651,7 +1651,7 @@ fn document_short(w: &mut fmt::Formatter, item: &clean::Item, link: AssocItemLin\n             format!(\"{}\", &plain_summary_line(Some(s)))\n         };\n         write!(w, \"<div class='docblock'>{}</div>\",\n-               Markdown(&markdown, MarkdownOutputStyle::Fancy))?;\n+               Markdown(&markdown))?;\n     }\n     Ok(())\n }\n@@ -1684,8 +1684,7 @@ fn get_doc_value(item: &clean::Item) -> Option<&str> {\n fn document_full(w: &mut fmt::Formatter, item: &clean::Item) -> fmt::Result {\n     if let Some(s) = get_doc_value(item) {\n         write!(w, \"<div class='docblock'>{}</div>\",\n-               Markdown(&format!(\"{}{}\", md_render_assoc_item(item), s),\n-                                 MarkdownOutputStyle::Fancy))?;\n+               Markdown(&format!(\"{}{}\", md_render_assoc_item(item), s)))?;\n     }\n     Ok(())\n }\n@@ -1873,8 +1872,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                        </tr>\",\n                        name = *myitem.name.as_ref().unwrap(),\n                        stab_docs = stab_docs,\n-                       docs = shorter(Some(&Markdown(doc_value,\n-                                                     MarkdownOutputStyle::Compact).to_string())),\n+                       docs = MarkdownSummaryLine(doc_value),\n                        class = myitem.type_(),\n                        stab = myitem.stability_class().unwrap_or(\"\".to_string()),\n                        unsafety_flag = unsafety_flag,\n@@ -2904,7 +2902,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n         write!(w, \"</span>\")?;\n         write!(w, \"</h3>\\n\")?;\n         if let Some(ref dox) = i.impl_item.doc_value() {\n-            write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox, MarkdownOutputStyle::Fancy))?;\n+            write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox))?;\n         }\n     }\n "}, {"sha": "5fadda030a4b41c5bc7798375ae6848694a3dbba", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -25,7 +25,7 @@ use externalfiles::{ExternalHtml, LoadStringError, load_string};\n use html::render::reset_ids;\n use html::escape::Escape;\n use html::markdown;\n-use html::markdown::{Markdown, MarkdownWithToc, MarkdownOutputStyle, find_testable_code};\n+use html::markdown::{Markdown, MarkdownWithToc, find_testable_code};\n use test::{TestOptions, Collector};\n \n /// Separate any lines at the start of the file that begin with `# ` or `%`.\n@@ -96,7 +96,7 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n     let rendered = if include_toc {\n         format!(\"{}\", MarkdownWithToc(text))\n     } else {\n-        format!(\"{}\", Markdown(text, MarkdownOutputStyle::Fancy))\n+        format!(\"{}\", Markdown(text))\n     };\n \n     let err = write!("}, {"sha": "6b1267d89b6d5730246c2f7d0ce6d797ded38968", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -1176,6 +1176,7 @@ impl AsInner<fs_imp::DirEntry> for DirEntry {\n /// This function currently corresponds to the `unlink` function on Unix\n /// and the `DeleteFile` function on Windows.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1212,6 +1213,7 @@ pub fn remove_file<P: AsRef<Path>>(path: P) -> io::Result<()> {\n /// This function currently corresponds to the `stat` function on Unix\n /// and the `GetFileAttributesEx` function on Windows.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1245,6 +1247,7 @@ pub fn metadata<P: AsRef<Path>>(path: P) -> io::Result<Metadata> {\n /// This function currently corresponds to the `lstat` function on Unix\n /// and the `GetFileAttributesEx` function on Windows.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1287,6 +1290,7 @@ pub fn symlink_metadata<P: AsRef<Path>>(path: P) -> io::Result<Metadata> {\n /// on Windows, `from` can be anything, but `to` must *not* be a directory.\n ///\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1330,6 +1334,7 @@ pub fn rename<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<()>\n /// `O_CLOEXEC` is set for returned file descriptors.\n /// On Windows, this function currently corresponds to `CopyFileEx`.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1366,6 +1371,7 @@ pub fn copy<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<u64> {\n /// This function currently corresponds to the `link` function on Unix\n /// and the `CreateHardLink` function on Windows.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1424,6 +1430,7 @@ pub fn soft_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<(\n /// and the `CreateFile` function with `FILE_FLAG_OPEN_REPARSE_POINT` and\n /// `FILE_FLAG_BACKUP_SEMANTICS` flags on Windows.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1457,6 +1464,7 @@ pub fn read_link<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {\n /// This function currently corresponds to the `realpath` function on Unix\n /// and the `CreateFile` and `GetFinalPathNameByHandle` functions on Windows.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1489,6 +1497,7 @@ pub fn canonicalize<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {\n /// This function currently corresponds to the `mkdir` function on Unix\n /// and the `CreateDirectory` function on Windows.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1522,6 +1531,7 @@ pub fn create_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n /// This function currently corresponds to the `mkdir` function on Unix\n /// and the `CreateDirectory` function on Windows.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1562,6 +1572,7 @@ pub fn create_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n /// This function currently corresponds to the `rmdir` function on Unix\n /// and the `RemoveDirectory` function on Windows.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1599,6 +1610,7 @@ pub fn remove_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n /// and the `FindFirstFile`, `GetFileAttributesEx`, `DeleteFile`, and `RemoveDirectory` functions\n /// on Windows.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1633,6 +1645,7 @@ pub fn remove_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n /// This function currently corresponds to the `opendir` function on Unix\n /// and the `FindFirstFile` function on Windows.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors\n@@ -1679,6 +1692,7 @@ pub fn read_dir<P: AsRef<Path>>(path: P) -> io::Result<ReadDir> {\n /// This function currently corresponds to the `chmod` function on Unix\n /// and the `SetFileAttributes` function on Windows.\n /// Note that, this [may change in the future][changes].\n+///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n /// # Errors"}, {"sha": "3b82412716e54f7346dbfc24c2732f56070f246c", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -21,12 +21,12 @@ use memchr;\n /// The `BufReader` struct adds buffering to any reader.\n ///\n /// It can be excessively inefficient to work directly with a [`Read`] instance.\n-/// For example, every call to [`read`] on [`TcpStream`] results in a system call.\n-/// A `BufReader` performs large, infrequent reads on the underlying [`Read`]\n-/// and maintains an in-memory buffer of the results.\n+/// For example, every call to [`read`][`TcpStream::read`] on [`TcpStream`]\n+/// results in a system call. A `BufReader` performs large, infrequent reads on\n+/// the underlying [`Read`] and maintains an in-memory buffer of the results.\n ///\n /// [`Read`]: ../../std/io/trait.Read.html\n-/// [`read`]: ../../std/net/struct.TcpStream.html#method.read\n+/// [`TcpStream::read`]: ../../std/net/struct.TcpStream.html#method.read\n /// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n ///\n /// # Examples\n@@ -261,9 +261,10 @@ impl<R: Seek> Seek for BufReader<R> {\n /// Wraps a writer and buffers its output.\n ///\n /// It can be excessively inefficient to work directly with something that\n-/// implements [`Write`]. For example, every call to [`write`] on [`TcpStream`]\n-/// results in a system call. A `BufWriter` keeps an in-memory buffer of data\n-/// and writes it to an underlying writer in large, infrequent batches.\n+/// implements [`Write`]. For example, every call to\n+/// [`write`][`Tcpstream::write`] on [`TcpStream`] results in a system call. A\n+/// `BufWriter` keeps an in-memory buffer of data and writes it to an underlying\n+/// writer in large, infrequent batches.\n ///\n /// The buffer will be written out when the writer is dropped.\n ///\n@@ -303,7 +304,7 @@ impl<R: Seek> Seek for BufReader<R> {\n /// the `stream` is dropped.\n ///\n /// [`Write`]: ../../std/io/trait.Write.html\n-/// [`write`]: ../../std/net/struct.TcpStream.html#method.write\n+/// [`Tcpstream::write`]: ../../std/net/struct.TcpStream.html#method.write\n /// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BufWriter<W: Write> {"}, {"sha": "cd096c115ba5a2a181f9a2275076915240bbaf13", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -21,7 +21,8 @@\n //! of other types, and you can implement them for your types too. As such,\n //! you'll see a few different types of I/O throughout the documentation in\n //! this module: [`File`]s, [`TcpStream`]s, and sometimes even [`Vec<T>`]s. For\n-//! example, [`Read`] adds a [`read`] method, which we can use on `File`s:\n+//! example, [`Read`] adds a [`read`][`Read::read`] method, which we can use on\n+//! `File`s:\n //!\n //! ```\n //! use std::io;\n@@ -106,7 +107,7 @@\n //! ```\n //!\n //! [`BufWriter`] doesn't add any new ways of writing; it just buffers every call\n-//! to [`write`]:\n+//! to [`write`][`Write::write`]:\n //!\n //! ```\n //! use std::io;\n@@ -257,13 +258,13 @@\n //! [`Vec<T>`]: ../vec/struct.Vec.html\n //! [`BufReader`]: struct.BufReader.html\n //! [`BufWriter`]: struct.BufWriter.html\n-//! [`write`]: trait.Write.html#tymethod.write\n+//! [`Write::write`]: trait.Write.html#tymethod.write\n //! [`io::stdout`]: fn.stdout.html\n //! [`println!`]: ../macro.println.html\n //! [`Lines`]: struct.Lines.html\n //! [`io::Result`]: type.Result.html\n //! [`?` operator]: ../../book/syntax-index.html\n-//! [`read`]: trait.Read.html#tymethod.read\n+//! [`Read::read`]: trait.Read.html#tymethod.read\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "bc315d54100e42d1048a90baa96d64cda64d2722", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -58,7 +58,7 @@ pub struct TcpStream(net_imp::TcpStream);\n ///\n /// After creating a `TcpListener` by [`bind`]ing it to a socket address, it listens\n /// for incoming TCP connections. These can be accepted by calling [`accept`] or by\n-/// iterating over the [`Incoming`] iterator returned by [`incoming`].\n+/// iterating over the [`Incoming`] iterator returned by [`incoming`][`TcpListener::incoming`].\n ///\n /// The socket will be closed when the value is dropped.\n ///\n@@ -68,7 +68,7 @@ pub struct TcpStream(net_imp::TcpStream);\n /// [`bind`]: #method.bind\n /// [IETF RFC 793]: https://tools.ietf.org/html/rfc793\n /// [`Incoming`]: ../../std/net/struct.Incoming.html\n-/// [`incoming`]: #method.incoming\n+/// [`TcpListener::incoming`]: #method.incoming\n ///\n /// # Examples\n ///"}, {"sha": "86e661d7948f07dfb05a533f16e0077ae9c6ae13", "filename": "src/libstd/prelude/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibstd%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibstd%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fmod.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -56,14 +56,14 @@\n //!   traits indicate fundamental properties of types.\n //! * [`std::ops`]::{[`Drop`], [`Fn`], [`FnMut`], [`FnOnce`]}. Various\n //!   operations for both destructors and overloading `()`.\n-//! * [`std::mem`]::[`drop`], a convenience function for explicitly dropping a\n-//!   value.\n+//! * [`std::mem`]::[`drop`][`mem::drop`], a convenience function for explicitly\n+//!   dropping a value.\n //! * [`std::boxed`]::[`Box`], a way to allocate values on the heap.\n //! * [`std::borrow`]::[`ToOwned`], The conversion trait that defines\n //!   [`to_owned`], the generic method for creating an owned type from a\n //!   borrowed type.\n-//! * [`std::clone`]::[`Clone`], the ubiquitous trait that defines [`clone`],\n-//!   the method for producing a copy of a value.\n+//! * [`std::clone`]::[`Clone`], the ubiquitous trait that defines\n+//!   [`clone`][`Clone::clone`], the method for producing a copy of a value.\n //! * [`std::cmp`]::{[`PartialEq`], [`PartialOrd`], [`Eq`], [`Ord`] }. The\n //!   comparison traits, which implement the comparison operators and are often\n //!   seen in trait bounds.\n@@ -117,8 +117,8 @@\n //! [`ToOwned`]: ../borrow/trait.ToOwned.html\n //! [`ToString`]: ../string/trait.ToString.html\n //! [`Vec`]: ../vec/struct.Vec.html\n-//! [`clone`]: ../clone/trait.Clone.html#tymethod.clone\n-//! [`drop`]: ../mem/fn.drop.html\n+//! [`Clone::clone`]: ../clone/trait.Clone.html#tymethod.clone\n+//! [`mem::drop`]: ../mem/fn.drop.html\n //! [`std::borrow`]: ../borrow/index.html\n //! [`std::boxed`]: ../boxed/index.html\n //! [`std::clone`]: ../clone/index.html"}, {"sha": "8cfd8fcd8c680b166fa38c14a3facd402afbc484", "filename": "src/libstd/process.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -1070,6 +1070,27 @@ pub fn exit(code: i32) -> ! {\n ///     // execution never gets here\n /// }\n /// ```\n+///\n+/// The [`abort`] function terminates the process, so the destructor will not\n+/// get run on the example below:\n+///\n+/// ```no_run\n+/// use std::process;\n+///\n+/// struct HasDrop;\n+///\n+/// impl Drop for HasDrop {\n+///     fn drop(&mut self) {\n+///         println!(\"This will never be printed!\");\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let _x = HasDrop;\n+///     process::abort();\n+///     // the destructor implemented for HasDrop will never get run\n+/// }\n+/// ```\n #[stable(feature = \"process_abort\", since = \"1.17.0\")]\n pub fn abort() -> ! {\n     unsafe { ::sys::abort_internal() };"}, {"sha": "d6e2fed56be96b1d5b640dacc05aecc73fe2295f", "filename": "src/libstd/sys/windows/ext/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -144,7 +144,7 @@ pub trait OpenOptionsExt {\n     /// `CreateFile`).\n     ///\n     /// If a _new_ file is created because it does not yet exist and\n-    ///`.create(true)` or `.create_new(true)` are specified, the new file is\n+    /// `.create(true)` or `.create_new(true)` are specified, the new file is\n     /// given the attributes declared with `.attributes()`.\n     ///\n     /// If an _existing_ file is opened with `.create(true).truncate(true)`, its"}, {"sha": "759f055c4b1236e4640982e21d4be19fd15b7155", "filename": "src/libstd/sys/windows/ext/process.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -104,6 +104,7 @@ pub trait CommandExt {\n     /// Sets the [process creation flags][1] to be passed to `CreateProcess`.\n     ///\n     /// These will always be ORed with `CREATE_UNICODE_ENVIRONMENT`.\n+    ///\n     /// [1]: https://msdn.microsoft.com/en-us/library/windows/desktop/ms684863(v=vs.85).aspx\n     #[stable(feature = \"windows_process_extensions\", since = \"1.16.0\")]\n     fn creation_flags(&mut self, flags: u32) -> &mut process::Command;"}, {"sha": "7ab6b82ada3445f6ca739fcd4439cc6a538c58c0", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -90,7 +90,7 @@\n //! two ways:\n //!\n //! * By spawning a new thread, e.g. using the [`thread::spawn`][`spawn`]\n-//!   function, and calling [`thread`] on the [`JoinHandle`].\n+//!   function, and calling [`thread`][`JoinHandle::thread`] on the [`JoinHandle`].\n //! * By requesting the current thread, using the [`thread::current`] function.\n //!\n //! The [`thread::current`] function is available even for threads not spawned\n@@ -151,7 +151,7 @@\n //! [`Arc`]: ../../std/sync/struct.Arc.html\n //! [`spawn`]: ../../std/thread/fn.spawn.html\n //! [`JoinHandle`]: ../../std/thread/struct.JoinHandle.html\n-//! [`thread`]: ../../std/thread/struct.JoinHandle.html#method.thread\n+//! [`JoinHandle::thread`]: ../../std/thread/struct.JoinHandle.html#method.thread\n //! [`join`]: ../../std/thread/struct.JoinHandle.html#method.join\n //! [`Result`]: ../../std/result/enum.Result.html\n //! [`Ok`]: ../../std/result/enum.Result.html#variant.Ok"}, {"sha": "15111bbba0a92d6d04cdb03b0f0f5f09fcd09587", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -43,6 +43,8 @@ use std::{mem, ptr, slice, vec};\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n+use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n+                                           HashStable};\n /// An owned smart pointer.\n #[derive(Hash, PartialEq, Eq, PartialOrd, Ord)]\n pub struct P<T: ?Sized> {\n@@ -215,3 +217,13 @@ impl<T: Decodable> Decodable for P<[T]> {\n         }))\n     }\n }\n+\n+impl<CTX, T> HashStable<CTX> for P<T>\n+    where T: ?Sized + HashStable<CTX>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        (**self).hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "2d9fd7aa87553dc81ad73bb36f77fc3198ce781a", "filename": "src/libsyntax/util/rc_slice.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibsyntax%2Futil%2Frc_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Flibsyntax%2Futil%2Frc_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Frc_slice.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -12,6 +12,9 @@ use std::fmt;\n use std::ops::Deref;\n use std::rc::Rc;\n \n+use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n+                                           HashStable};\n+\n #[derive(Clone)]\n pub struct RcSlice<T> {\n     data: Rc<Box<[T]>>,\n@@ -41,3 +44,13 @@ impl<T: fmt::Debug> fmt::Debug for RcSlice<T> {\n         fmt::Debug::fmt(self.deref(), f)\n     }\n }\n+\n+impl<CTX, T> HashStable<CTX> for RcSlice<T>\n+    where T: HashStable<CTX>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        (**self).hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "f7f79356a0b9f22284b76925a49f0b2f82eca5ed", "filename": "src/test/run-pass/const-err.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Ftest%2Frun-pass%2Fconst-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Ftest%2Frun-pass%2Fconst-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-err.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -13,6 +13,10 @@\n #![deny(const_err)]\n \n const X: *const u8 = b\"\" as _;\n+const Y: bool = 'A' == 'B';\n+const Z: char = 'A';\n+const W: bool = Z <= 'B';\n+\n \n fn main() {\n     let _ = ((-1 as i8) << 8 - 1) as f32;"}, {"sha": "f048b64d104abc82ab7e60521c05884c86506ee6", "filename": "src/test/rustdoc/check-hard-break.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Ftest%2Frustdoc%2Fcheck-hard-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Ftest%2Frustdoc%2Fcheck-hard-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcheck-hard-break.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -13,7 +13,8 @@\n // ignore-tidy-end-whitespace\n \n // @has foo/fn.f.html\n-// @has - '<p>hard break:<br>after hard break</p>'\n+// @has - '<p>hard break:<br />'\n+// @has - 'after hard break</p>'\n /// hard break:  \n /// after hard break\n pub fn f() {}"}, {"sha": "46542677857fc797cc0461d335502f13d25a45ad", "filename": "src/test/rustdoc/check-rule-image-footnote.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Ftest%2Frustdoc%2Fcheck-rule-image-footnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Ftest%2Frustdoc%2Fcheck-rule-image-footnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcheck-rule-image-footnote.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -13,16 +13,21 @@\n // ignore-tidy-linelength\n \n // @has foo/fn.f.html\n-// @has - '<p>markdown test</p><p>this is a <a href=\"https://example.com\" title=\"this is a title\">link</a>.</p><p>hard break: after hard break</p><hr><p>a footnote<sup id=\"supref1\"><a href=\"#ref1\">1</a></sup>.</p><p>another footnote<sup id=\"supref2\"><a href=\"#ref2\">2</a></sup>.</p><p><img src=\"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\" alt=\"Rust\"></p><div class=\"footnotes\"><hr><ol><li id=\"ref1\"><p>Thing&nbsp;<a href=\"#supref1\" rev=\"footnote\">\u21a9</a></p></li><li id=\"ref2\"><p>Another Thing&nbsp;<a href=\"#supref2\" rev=\"footnote\">\u21a9</a></p></li></ol></div>'\n+// @has - '<p>markdown test</p>'\n+// @has - '<p>this is a <a href=\"https://example.com\" title=\"this is a title\">link</a>.</p>'\n+// @has - '<hr />'\n+// @has - '<p>a footnote<sup id=\"supref1\"><a href=\"#ref1\">1</a></sup>.</p>'\n+// @has - '<p>another footnote<sup id=\"supref2\"><a href=\"#ref2\">2</a></sup>.</p>'\n+// @has - '<p><img src=\"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\" alt=\"Rust\" /></p>'\n+// @has - '<div class=\"footnotes\"><hr><ol><li id=\"ref1\">'\n+// @has - '<p>Thing&nbsp;<a href=\"#supref1\" rev=\"footnote\">\u21a9</a></p></li><li id=\"ref2\">'\n+// @has - '<p>Another Thing&nbsp;<a href=\"#supref2\" rev=\"footnote\">\u21a9</a></p></li></ol></div>'\n /// markdown test\n ///\n /// this is a [link].\n ///\n /// [link]: https://example.com \"this is a title\"\n ///\n-/// hard break:\n-/// after hard break\n-///\n /// -----------\n ///\n /// a footnote[^footnote].\n@@ -36,5 +41,4 @@\n ///\n ///\n /// ![Rust](https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png)\n-#[deprecated(note = \"Struct<T>\")]\n pub fn f() {}"}, {"sha": "29f157e0425c90de1669310ee59b259960697464", "filename": "src/test/rustdoc/test-lists.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Ftest%2Frustdoc%2Ftest-lists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Ftest%2Frustdoc%2Ftest-lists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftest-lists.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -10,23 +10,27 @@\n \n #![crate_name = \"foo\"]\n \n-// ignore-tidy-linelength\n-\n // @has foo/fn.f.html\n-// @has - \"<pre class='rust fn'>pub fn f()</pre><div class='docblock'><ol><li>list<ol><li>fooooo</li><li>x</li></ol></li><li>foo</li></ol>\"\n+// @has - //ol/li \"list\"\n+// @has - //ol/li/ol/li \"fooooo\"\n+// @has - //ol/li/ol/li \"x\"\n+// @has - //ol/li \"foo\"\n /// 1. list\n ///     1. fooooo\n ///     2. x\n /// 2. foo\n pub fn f() {}\n \n // @has foo/fn.foo2.html\n-// @has - \"<pre class='rust fn'>pub fn foo2()</pre><div class='docblock'><ul><li>normal list<ul><li><p>sub list</p></li><li><p>new elem still same elem</p><p>and again same elem!</p></li></ul></li><li>new big elem</li></ul>\"\n+// @has - //ul/li \"normal list\"\n+// @has - //ul/li/ul/li \"sub list\"\n+// @has - //ul/li/ul/li \"new elem still same elem and again same elem!\"\n+// @has - //ul/li \"new big elem\"\n /// * normal list\n ///     * sub list\n ///     * new elem\n ///       still same elem\n ///\n ///       and again same elem!\n /// * new big elem\n-pub fn foo2() {}\n\\ No newline at end of file\n+pub fn foo2() {}"}, {"sha": "d7c8935560623118722a329e82234d7b59a97332", "filename": "src/test/ui/did_you_mean/issue-39544.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -51,3 +51,9 @@ pub fn with_arg(z: Z, w: &Z) {\n     let _ = &mut z.x;\n     let _ = &mut w.x;\n }\n+\n+pub fn with_tuple() {\n+    let mut y = 0;\n+    let x = (&y,);\n+    *x.0 = 1;\n+}"}, {"sha": "2e98bc65e9e9f0c268e3badf0b5e61bdc11f914a", "filename": "src/test/ui/did_you_mean/issue-39544.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.stderr?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -90,5 +90,11 @@ error: cannot borrow immutable field `w.x` as mutable\n 52 |     let _ = &mut w.x;\n    |                  ^^^ cannot mutably borrow immutable field\n \n-error: aborting due to 11 previous errors\n+error: cannot assign to immutable borrowed content `*x.0`\n+  --> $DIR/issue-39544.rs:58:5\n+   |\n+58 |     *x.0 = 1;\n+   |     ^^^^^^^^ cannot borrow as mutable\n+\n+error: aborting due to 12 previous errors\n "}, {"sha": "efadde992277fefe4b0c6544375487aa47ea6449", "filename": "src/tools/error_index_generator/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=2277f4bdcc1195a5f6c9c96d8d1fb32482cbd673", "patch": "@@ -24,7 +24,7 @@ use std::path::PathBuf;\n \n use syntax::diagnostics::metadata::{get_metadata_dir, ErrorMetadataMap, ErrorMetadata};\n \n-use rustdoc::html::markdown::{Markdown, MarkdownOutputStyle, PLAYGROUND};\n+use rustdoc::html::markdown::{Markdown, PLAYGROUND};\n use rustc_serialize::json;\n \n enum OutputFormat {\n@@ -100,7 +100,7 @@ impl Formatter for HTMLFormatter {\n \n         // Description rendered as markdown.\n         match info.description {\n-            Some(ref desc) => write!(output, \"{}\", Markdown(desc, MarkdownOutputStyle::Fancy))?,\n+            Some(ref desc) => write!(output, \"{}\", Markdown(desc))?,\n             None => write!(output, \"<p>No description.</p>\\n\")?,\n         }\n "}]}