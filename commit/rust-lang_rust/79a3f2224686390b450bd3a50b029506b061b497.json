{"sha": "79a3f2224686390b450bd3a50b029506b061b497", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5YTNmMjIyNDY4NjM5MGI0NTBiZDNhNTBiMDI5NTA2YjA2MWI0OTc=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-01-30T13:33:02Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-03T23:40:38Z"}, "message": "Refactor away resolve_item_by_name_in_lexical_scope", "tree": {"sha": "0dece9ed7142adcddd0c853b263a4dbc475832be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0dece9ed7142adcddd0c853b263a4dbc475832be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79a3f2224686390b450bd3a50b029506b061b497", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79a3f2224686390b450bd3a50b029506b061b497", "html_url": "https://github.com/rust-lang/rust/commit/79a3f2224686390b450bd3a50b029506b061b497", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79a3f2224686390b450bd3a50b029506b061b497/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "964b72b3e0347e0364a974d7f7e8ce34cdeac972", "url": "https://api.github.com/repos/rust-lang/rust/commits/964b72b3e0347e0364a974d7f7e8ce34cdeac972", "html_url": "https://github.com/rust-lang/rust/commit/964b72b3e0347e0364a974d7f7e8ce34cdeac972"}], "stats": {"total": 55, "additions": 10, "deletions": 45}, "files": [{"sha": "a12eb42ccd4829f8c8da575d18ba9a7cf163c4ae", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 10, "deletions": 45, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/79a3f2224686390b450bd3a50b029506b061b497/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79a3f2224686390b450bd3a50b029506b061b497/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=79a3f2224686390b450bd3a50b029506b061b497", "patch": "@@ -2774,9 +2774,17 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n+        // Check the items.\n+        let module = self.current_module;\n         let name = identifier.unhygienic_name;\n-        self.resolve_item_by_name_in_lexical_scope(name, namespace, record_used)\n-            .map(LocalDef::from_def)\n+        match self.resolve_item_in_lexical_scope(module, name, namespace, record_used) {\n+            Success((target, _)) => target.binding.def().map(LocalDef::from_def),\n+            Failed(Some((span, msg))) => {\n+                resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n+                None\n+            }\n+            _ => None,\n+        }\n     }\n \n     // Resolve a local definition, potentially adjusting for closures.\n@@ -3020,49 +3028,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         None\n     }\n \n-    fn resolve_item_by_name_in_lexical_scope(&mut self,\n-                                             name: Name,\n-                                             namespace: Namespace,\n-                                             record_used: bool)\n-                                             -> Option<Def> {\n-        // Check the items.\n-        let module = self.current_module;\n-        match self.resolve_item_in_lexical_scope(module, name, namespace, record_used) {\n-            Success((target, _)) => {\n-                match target.binding.def() {\n-                    None => {\n-                        // This can happen if we were looking for a type and\n-                        // found a module instead. Modules don't have defs.\n-                        debug!(\"(resolving item path by identifier in lexical scope) failed to \\\n-                                resolve {} after success...\",\n-                               name);\n-                        None\n-                    }\n-                    Some(def) => {\n-                        debug!(\"(resolving item path in lexical scope) resolved `{}` to item\",\n-                               name);\n-                        // This lookup is \"all public\" because it only searched\n-                        // for one identifier in the current module (couldn't\n-                        // have passed through reexports or anything like that.\n-                        Some(def)\n-                    }\n-                }\n-            }\n-            Indeterminate => None,\n-            Failed(err) => {\n-                debug!(\"(resolving item path by identifier in lexical scope) failed to \\\n-                        resolve `{}`\",\n-                       name);\n-\n-                if let Some((span, msg)) = err {\n-                    resolve_error(self, span, ResolutionError::FailedToResolve(&*msg))\n-                }\n-\n-                None\n-            }\n-        }\n-    }\n-\n     fn with_no_errors<T, F>(&mut self, f: F) -> T\n         where F: FnOnce(&mut Resolver) -> T\n     {"}]}