{"sha": "76b262f693381b404934dc893b98baf6dbc4aa8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2YjI2MmY2OTMzODFiNDA0OTM0ZGM4OTNiOThiYWY2ZGJjNGFhOGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-24T00:52:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-24T00:52:04Z"}, "message": "auto merge of #12509 : brson/rust/rollup, r=brson\n\nRollup of https://github.com/mozilla/rust/pull/12506, https://github.com/mozilla/rust/pull/12500, https://github.com/mozilla/rust/pull/12480, https://github.com/mozilla/rust/pull/12478, https://github.com/mozilla/rust/pull/12461.", "tree": {"sha": "52a86afaf532211aa5abbaea24aebe4c80e5fddf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52a86afaf532211aa5abbaea24aebe4c80e5fddf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76b262f693381b404934dc893b98baf6dbc4aa8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76b262f693381b404934dc893b98baf6dbc4aa8f", "html_url": "https://github.com/rust-lang/rust/commit/76b262f693381b404934dc893b98baf6dbc4aa8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76b262f693381b404934dc893b98baf6dbc4aa8f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "329fcd48e508ebe41e6d2425c0f54b2210af401d", "url": "https://api.github.com/repos/rust-lang/rust/commits/329fcd48e508ebe41e6d2425c0f54b2210af401d", "html_url": "https://github.com/rust-lang/rust/commit/329fcd48e508ebe41e6d2425c0f54b2210af401d"}, {"sha": "d08952cfa5ecef0d7a3841a666694231edc8093a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d08952cfa5ecef0d7a3841a666694231edc8093a", "html_url": "https://github.com/rust-lang/rust/commit/d08952cfa5ecef0d7a3841a666694231edc8093a"}], "stats": {"total": 175, "additions": 46, "deletions": 129}, "files": [{"sha": "debe4a27f56b86dbce1990f62d634916ac70d57c", "filename": "src/doc/complement-cheatsheet.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76b262f693381b404934dc893b98baf6dbc4aa8f/src%2Fdoc%2Fcomplement-cheatsheet.md", "raw_url": "https://github.com/rust-lang/rust/raw/76b262f693381b404934dc893b98baf6dbc4aa8f/src%2Fdoc%2Fcomplement-cheatsheet.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-cheatsheet.md?ref=76b262f693381b404934dc893b98baf6dbc4aa8f", "patch": "@@ -211,7 +211,7 @@ Description            C signature                                    Equivalent\n ---------------------- ---------------------------------------------- ------------------------------------------\n no parameters          `void foo(void);`                              `fn foo();`\n return value           `int foo(void);`                               `fn foo() -> c_int;`\n-function parameters    `void foo(int x, int y);`                      `fn foo(x: int, y: int);`\n+function parameters    `void foo(int x, int y);`                      `fn foo(x: c_int, y: c_int);`\n in-out pointers        `void foo(const int* in_ptr, int* out_ptr);`   `fn foo(in_ptr: *c_int, out_ptr: *mut c_int);`\n \n Note: The Rust signatures should be wrapped in an `extern \"ABI\" { ... }` block."}, {"sha": "2e6a0ef7e5bcbd1e89df6e13ba4311bdc2437d20", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76b262f693381b404934dc893b98baf6dbc4aa8f/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/76b262f693381b404934dc893b98baf6dbc4aa8f/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=76b262f693381b404934dc893b98baf6dbc4aa8f", "patch": "@@ -1026,7 +1026,7 @@ type was invalid because the size was infinite!\n \n An *owned box* (`~`) uses a dynamic memory allocation to provide the invariant\n of always being the size of a pointer, regardless of the contained type. This\n-can be leverage to create a valid `List` definition:\n+can be leveraged to create a valid `List` definition:\n \n ~~~\n enum List {"}, {"sha": "1ec89d1850f0e77e6af93a081322c16e9748b1d4", "filename": "src/libstd/char.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/76b262f693381b404934dc893b98baf6dbc4aa8f/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b262f693381b404934dc893b98baf6dbc4aa8f/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=76b262f693381b404934dc893b98baf6dbc4aa8f", "patch": "@@ -69,6 +69,7 @@ static TAG_FOUR_B: uint = 240u;\n pub static MAX: char = '\\U0010ffff';\n \n /// Convert from `u32` to a character.\n+#[inline]\n pub fn from_u32(i: u32) -> Option<char> {\n     // catch out-of-bounds and surrogates\n     if (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF) {"}, {"sha": "91a8d59932689b2dfcb6212e6f0be997b5ff17ef", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 41, "deletions": 126, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/76b262f693381b404934dc893b98baf6dbc4aa8f/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b262f693381b404934dc893b98baf6dbc4aa8f/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=76b262f693381b404934dc893b98baf6dbc4aa8f", "patch": "@@ -8,16 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*! Synchronous I/O\n+// FIXME: cover these topics:\n+//        path, reader, writer, stream, raii (close not needed),\n+//        stdio, print!, println!, file access, process spawning,\n+//        error handling\n \n-This module defines the Rust interface for synchronous I/O.\n-It models byte-oriented input and output with the Reader and Writer traits.\n-Types that implement both `Reader` and `Writer` are called 'streams',\n-and automatically implement the `Stream` trait.\n-Implementations are provided for common I/O streams like\n-file, TCP, UDP, Unix domain sockets.\n-Readers and Writers may be composed to add capabilities like string\n-parsing, encoding, and compression.\n+\n+/*! I/O, including files, networking, timers, and processes\n+\n+`std::io` provides Rust's basic I/O types,\n+for reading and writing to files, TCP, UDP,\n+and other types of sockets and pipes,\n+manipulating the file system, spawning processes and signal handling.\n \n # Examples\n \n@@ -77,9 +79,7 @@ Some examples of obvious things you might want to do\n     let lines: ~[~str] = file.lines().collect();\n     ```\n \n-* Make a simple HTTP request\n-  FIXME This needs more improvement: TcpStream constructor taking &str,\n-  `write_str` and `write_line` methods.\n+* Make a simple TCP client connection and request\n \n     ```rust,should_fail\n     # #[allow(unused_must_use)];\n@@ -92,72 +92,35 @@ Some examples of obvious things you might want to do\n     let response = socket.read_to_end();\n     ```\n \n-* Connect based on URL? Requires thinking about where the URL type lives\n-  and how to make protocol handlers extensible, e.g. the \"tcp\" protocol\n-  yields a `TcpStream`.\n-  FIXME this is not implemented now.\n+* Make a simple TCP server\n \n     ```rust\n-    // connect(\"tcp://localhost:8080\");\n+    # fn main() { }\n+    # fn foo() {\n+    # #[allow(unused_must_use, dead_code)];\n+    use std::io::net::tcp::TcpListener;\n+    use std::io::net::ip::{Ipv4Addr, SocketAddr};\n+    use std::io::{Acceptor, Listener};\n+\n+    let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 80 };\n+    let listener = TcpListener::bind(addr);\n+\n+    // bind the listener to the specified address\n+    let mut acceptor = listener.listen();\n+\n+    // accept connections and process them\n+    # fn handle_client<T>(_: T) {}\n+    for stream in acceptor.incoming() {\n+        spawn(proc() {\n+            handle_client(stream);\n+        });\n+    }\n+\n+    // close the socket server\n+    drop(acceptor);\n+    # }\n     ```\n \n-# Terms\n-\n-* Reader - An I/O source, reads bytes into a buffer\n-* Writer - An I/O sink, writes bytes from a buffer\n-* Stream - Typical I/O sources like files and sockets are both Readers and Writers,\n-  and are collectively referred to a `streams`.\n-  such as encoding or decoding\n-\n-# Blocking and synchrony\n-\n-When discussing I/O you often hear the terms 'synchronous' and\n-'asynchronous', along with 'blocking' and 'non-blocking' compared and\n-contrasted. A synchronous I/O interface performs each I/O operation to\n-completion before proceeding to the next. Synchronous interfaces are\n-usually used in imperative style as a sequence of commands. An\n-asynchronous interface allows multiple I/O requests to be issued\n-simultaneously, without waiting for each to complete before proceeding\n-to the next.\n-\n-Asynchronous interfaces are used to achieve 'non-blocking' I/O. In\n-traditional single-threaded systems, performing a synchronous I/O\n-operation means that the program stops all activity (it 'blocks')\n-until the I/O is complete. Blocking is bad for performance when\n-there are other computations that could be done.\n-\n-Asynchronous interfaces are most often associated with the callback\n-(continuation-passing) style popularised by node.js. Such systems rely\n-on all computations being run inside an event loop which maintains a\n-list of all pending I/O events; when one completes the registered\n-callback is run and the code that made the I/O request continues.\n-Such interfaces achieve non-blocking at the expense of being more\n-difficult to reason about.\n-\n-Rust's I/O interface is synchronous - easy to read - and non-blocking by default.\n-\n-Remember that Rust tasks are 'green threads', lightweight threads that\n-are multiplexed onto a single operating system thread. If that system\n-thread blocks then no other task may proceed. Rust tasks are\n-relatively cheap to create, so as long as other tasks are free to\n-execute then non-blocking code may be written by simply creating a new\n-task.\n-\n-When discussing blocking in regards to Rust's I/O model, we are\n-concerned with whether performing I/O blocks other Rust tasks from\n-proceeding. In other words, when a task calls `read`, it must then\n-wait (or 'sleep', or 'block') until the call to `read` is complete.\n-During this time, other tasks may or may not be executed, depending on\n-how `read` is implemented.\n-\n-\n-Rust's default I/O implementation is non-blocking; by cooperating\n-directly with the task scheduler it arranges to never block progress\n-of *other* tasks. Under the hood, Rust uses asynchronous I/O via a\n-per-scheduler (and hence per-thread) event loop. Synchronous I/O\n-requests are implemented by descheduling the running task and\n-performing an asynchronous request; the task is only resumed once the\n-asynchronous request completes.\n \n # Error Handling\n \n@@ -170,10 +133,11 @@ Rust's I/O employs a combination of techniques to reduce boilerplate\n while still providing feedback about errors. The basic strategy:\n \n * All I/O operations return `IoResult<T>` which is equivalent to\n-  `Result<T, IoError>`. The core `Result` type is defined in the `std::result`\n+  `Result<T, IoError>`. The `Result` type is defined in the `std::result`\n   module.\n * If the `Result` type goes unused, then the compiler will by default emit a\n-  warning about the unused result.\n+  warning about the unused result. This is because `Result` has the\n+  `#[must_use]` attribute.\n * Common traits are implemented for `IoResult`, e.g.\n   `impl<R: Reader> Reader for IoResult<R>`, so that error values do not have\n   to be 'unwrapped' before use.\n@@ -192,7 +156,7 @@ If you wanted to handle the error though you might write:\n use std::io::File;\n \n match File::create(&Path::new(\"diary.txt\")).write(bytes!(\"Met a girl.\\n\")) {\n-    Ok(()) => { /* succeeded */ }\n+    Ok(()) => (), // succeeded\n     Err(e) => println!(\"failed to write to my diary: {}\", e),\n }\n \n@@ -208,55 +172,6 @@ need to inspect or unwrap the `IoResult<File>` and we simply call `write_line`\n on it. If `new` returned an `Err(..)` then the followup call to `write_line`\n will also return an error.\n \n-# Issues with i/o scheduler affinity, work stealing, task pinning\n-\n-# Resource management\n-\n-* `close` vs. RAII\n-\n-# Paths, URLs and overloaded constructors\n-\n-\n-\n-# Scope\n-\n-In scope for core\n-\n-* Url?\n-\n-Some I/O things don't belong in core\n-\n-  - url\n-  - net - `fn connect`\n-    - http\n-  - flate\n-\n-Out of scope\n-\n-* Async I/O. We'll probably want it eventually\n-\n-\n-# FIXME Questions and issues\n-\n-* Should default constructors take `Path` or `&str`? `Path` makes simple cases verbose.\n-  Overloading would be nice.\n-* Add overloading for Path and &str and Url &str\n-* stdin/err/out\n-* print, println, etc.\n-* fsync\n-* relationship with filesystem querying, Directory, File types etc.\n-* Rename Reader/Writer to ByteReader/Writer, make Reader/Writer generic?\n-* Can Port and Chan be implementations of a generic Reader<T>/Writer<T>?\n-* Trait for things that are both readers and writers, Stream?\n-* How to handle newline conversion\n-* String conversion\n-* open vs. connect for generic stream opening\n-* Do we need `close` at all? dtors might be good enough\n-* How does I/O relate to the Iterator trait?\n-* std::base64 filters\n-* Using conditions is a big unknown since we don't have much experience with them\n-* Too many uses of OtherIoError\n-\n */\n \n #[allow(missing_doc)];"}, {"sha": "3c094cd631d76b882176bd0464e6cf7ed22465d2", "filename": "src/libstd/str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/76b262f693381b404934dc893b98baf6dbc4aa8f/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b262f693381b404934dc893b98baf6dbc4aa8f/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=76b262f693381b404934dc893b98baf6dbc4aa8f", "patch": "@@ -1061,6 +1061,7 @@ static UTF8_CHAR_WIDTH: [u8, ..256] = [\n ];\n \n /// Given a first byte, determine how many bytes are in this UTF-8 character\n+#[inline]\n pub fn utf8_char_width(b: u8) -> uint {\n     return UTF8_CHAR_WIDTH[b] as uint;\n }"}, {"sha": "c9bdd49f86c7fbbb291f1c1368ce9dfc46164a36", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76b262f693381b404934dc893b98baf6dbc4aa8f/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b262f693381b404934dc893b98baf6dbc4aa8f/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=76b262f693381b404934dc893b98baf6dbc4aa8f", "patch": "@@ -609,7 +609,7 @@ impl<T: Writer> ConsoleTestState<T> {\n         let ratchet_success = match *ratchet_metrics {\n             None => true,\n             Some(ref pth) => {\n-                try!(self.write_plain(format!(\"\\nusing metrics ratcher: {}\\n\",\n+                try!(self.write_plain(format!(\"\\nusing metrics ratchet: {}\\n\",\n                                         pth.display())));\n                 match ratchet_pct {\n                     None => (),"}]}