{"sha": "e045c79c2d8697ef7ab2e25c3165cb5896f163ba", "node_id": "C_kwDOAAsO6NoAKGUwNDVjNzljMmQ4Njk3ZWY3YWIyZTI1YzMxNjVjYjU4OTZmMTYzYmE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-13T07:11:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-13T07:11:18Z"}, "message": "Rollup merge of #91938 - yaahc:error-reporter, r=m-ou-se\n\nAdd `std::error::Report` type\n\nThis is a continuation of https://github.com/rust-lang/rust/pull/90174, split into a separate PR since I cannot push to ```````@seanchen1991``````` 's fork", "tree": {"sha": "5e0a1a7751c75d3fa252f6423c0fcb269405d075", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e0a1a7751c75d3fa252f6423c0fcb269405d075"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e045c79c2d8697ef7ab2e25c3165cb5896f163ba", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh39CWCRBK7hj4Ov3rIwAAlvkIAE8k+stsaPeDhjBqNb0GM3Nt\nCGCyk2hGcfk5m1JXdH+zXB4nh6peRm0ZBsxxyGuTSUy3iJJmWlCwYq9JIJTyUJLD\n11XPZil/CUoB47BaYmVS2oT4N9PcBVV/IUmycTDrNWtjrVTPtF/SKuDyyRwuaHn/\nHRJB/QyFpDGWKzbentZ7ShKTCyLHbnGO9qb9Twy8RJsQSu6B8SLvSBhBLUEYnk+O\nR0VWKPLXOPkVeoRThxCycdKDN9KXJGtDGDn/ySzjfNH25X27StvqIR1FhlO6cYLW\nLSdFaIZtGkOM/8xpBBsLUh4IMTJ3dfzgfB3xvQySAaq785jnHeFqXwiGJCd3M8Y=\n=1sYZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 5e0a1a7751c75d3fa252f6423c0fcb269405d075\nparent 3e7bc08b6c591b2f70eecde18e299ff127b65cff\nparent 72cb1bd06dfdcec7c707e46fff44b3351a6c5ea9\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1642057878 +0100\ncommitter GitHub <noreply@github.com> 1642057878 +0100\n\nRollup merge of #91938 - yaahc:error-reporter, r=m-ou-se\n\nAdd `std::error::Report` type\n\nThis is a continuation of https://github.com/rust-lang/rust/pull/90174, split into a separate PR since I cannot push to ```````@seanchen1991``````` 's fork\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e045c79c2d8697ef7ab2e25c3165cb5896f163ba", "html_url": "https://github.com/rust-lang/rust/commit/e045c79c2d8697ef7ab2e25c3165cb5896f163ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e045c79c2d8697ef7ab2e25c3165cb5896f163ba/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e7bc08b6c591b2f70eecde18e299ff127b65cff", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e7bc08b6c591b2f70eecde18e299ff127b65cff", "html_url": "https://github.com/rust-lang/rust/commit/3e7bc08b6c591b2f70eecde18e299ff127b65cff"}, {"sha": "72cb1bd06dfdcec7c707e46fff44b3351a6c5ea9", "url": "https://api.github.com/repos/rust-lang/rust/commits/72cb1bd06dfdcec7c707e46fff44b3351a6c5ea9", "html_url": "https://github.com/rust-lang/rust/commit/72cb1bd06dfdcec7c707e46fff44b3351a6c5ea9"}], "stats": {"total": 1052, "additions": 1048, "deletions": 4}, "files": [{"sha": "643108b88bf79da58131bacff61a3a67e616285b", "filename": "library/std/src/error.rs", "status": "modified", "additions": 643, "deletions": 4, "changes": 647, "blob_url": "https://github.com/rust-lang/rust/blob/e045c79c2d8697ef7ab2e25c3165cb5896f163ba/library%2Fstd%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e045c79c2d8697ef7ab2e25c3165cb5896f163ba/library%2Fstd%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror.rs?ref=e045c79c2d8697ef7ab2e25c3165cb5896f163ba", "patch": "@@ -25,7 +25,7 @@ use crate::backtrace::Backtrace;\n use crate::borrow::Cow;\n use crate::cell;\n use crate::char;\n-use crate::fmt::{self, Debug, Display};\n+use crate::fmt::{self, Debug, Display, Write};\n use crate::mem::transmute;\n use crate::num;\n use crate::str;\n@@ -63,7 +63,7 @@ pub trait Error: Debug + Display {\n     ///\n     /// #[derive(Debug)]\n     /// struct SuperError {\n-    ///     side: SuperErrorSideKick,\n+    ///     source: SuperErrorSideKick,\n     /// }\n     ///\n     /// impl fmt::Display for SuperError {\n@@ -74,7 +74,7 @@ pub trait Error: Debug + Display {\n     ///\n     /// impl Error for SuperError {\n     ///     fn source(&self) -> Option<&(dyn Error + 'static)> {\n-    ///         Some(&self.side)\n+    ///         Some(&self.source)\n     ///     }\n     /// }\n     ///\n@@ -90,7 +90,7 @@ pub trait Error: Debug + Display {\n     /// impl Error for SuperErrorSideKick {}\n     ///\n     /// fn get_super_error() -> Result<(), SuperError> {\n-    ///     Err(SuperError { side: SuperErrorSideKick })\n+    ///     Err(SuperError { source: SuperErrorSideKick })\n     /// }\n     ///\n     /// fn main() {\n@@ -810,3 +810,642 @@ impl dyn Error + Send + Sync {\n         })\n     }\n }\n+\n+/// An error reporter that print's an error and its sources.\n+///\n+/// Report also exposes configuration options for formatting the error chain, either entirely on a\n+/// single line, or in multi-line format with each cause in the error chain on a new line.\n+///\n+/// `Report` only requires that the wrapped error implements `Error`. It doesn't require that the\n+/// wrapped error be `Send`, `Sync`, or `'static`.\n+///\n+/// # Examples\n+///\n+/// ```rust\n+/// #![feature(error_reporter)]\n+/// use std::error::{Error, Report};\n+/// use std::fmt;\n+///\n+/// #[derive(Debug)]\n+/// struct SuperError {\n+///     source: SuperErrorSideKick,\n+/// }\n+///\n+/// impl fmt::Display for SuperError {\n+///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+///         write!(f, \"SuperError is here!\")\n+///     }\n+/// }\n+///\n+/// impl Error for SuperError {\n+///     fn source(&self) -> Option<&(dyn Error + 'static)> {\n+///         Some(&self.source)\n+///     }\n+/// }\n+///\n+/// #[derive(Debug)]\n+/// struct SuperErrorSideKick;\n+///\n+/// impl fmt::Display for SuperErrorSideKick {\n+///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+///         write!(f, \"SuperErrorSideKick is here!\")\n+///     }\n+/// }\n+///\n+/// impl Error for SuperErrorSideKick {}\n+///\n+/// fn get_super_error() -> Result<(), SuperError> {\n+///     Err(SuperError { source: SuperErrorSideKick })\n+/// }\n+///\n+/// fn main() {\n+///     match get_super_error() {\n+///         Err(e) => println!(\"Error: {}\", Report::new(e)),\n+///         _ => println!(\"No error\"),\n+///     }\n+/// }\n+/// ```\n+///\n+/// This example produces the following output:\n+///\n+/// ```console\n+/// Error: SuperError is here!: SuperErrorSideKick is here!\n+/// ```\n+///\n+/// ## Output consistency\n+///\n+/// Report prints the same output via `Display` and `Debug`, so it works well with\n+/// [`Result::unwrap`]/[`Result::expect`] which print their `Err` variant via `Debug`:\n+///\n+/// ```should_panic\n+/// #![feature(error_reporter)]\n+/// use std::error::Report;\n+/// # use std::error::Error;\n+/// # use std::fmt;\n+/// # #[derive(Debug)]\n+/// # struct SuperError {\n+/// #     source: SuperErrorSideKick,\n+/// # }\n+/// # impl fmt::Display for SuperError {\n+/// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+/// #         write!(f, \"SuperError is here!\")\n+/// #     }\n+/// # }\n+/// # impl Error for SuperError {\n+/// #     fn source(&self) -> Option<&(dyn Error + 'static)> {\n+/// #         Some(&self.source)\n+/// #     }\n+/// # }\n+/// # #[derive(Debug)]\n+/// # struct SuperErrorSideKick;\n+/// # impl fmt::Display for SuperErrorSideKick {\n+/// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+/// #         write!(f, \"SuperErrorSideKick is here!\")\n+/// #     }\n+/// # }\n+/// # impl Error for SuperErrorSideKick {}\n+/// # fn get_super_error() -> Result<(), SuperError> {\n+/// #     Err(SuperError { source: SuperErrorSideKick })\n+/// # }\n+///\n+/// get_super_error().map_err(Report::new).unwrap();\n+/// ```\n+///\n+/// This example produces the following output:\n+///\n+/// ```console\n+/// thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: SuperError is here!: SuperErrorSideKick is here!', src/error.rs:34:40\n+/// note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n+/// ```\n+///\n+/// ## Return from `main`\n+///\n+/// `Report` also implements `From` for all types that implement [`Error`], this when combined with\n+/// the `Debug` output means `Report` is an ideal starting place for formatting errors returned\n+/// from `main`.\n+///\n+/// ```should_panic\n+/// #![feature(error_reporter)]\n+/// use std::error::Report;\n+/// # use std::error::Error;\n+/// # use std::fmt;\n+/// # #[derive(Debug)]\n+/// # struct SuperError {\n+/// #     source: SuperErrorSideKick,\n+/// # }\n+/// # impl fmt::Display for SuperError {\n+/// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+/// #         write!(f, \"SuperError is here!\")\n+/// #     }\n+/// # }\n+/// # impl Error for SuperError {\n+/// #     fn source(&self) -> Option<&(dyn Error + 'static)> {\n+/// #         Some(&self.source)\n+/// #     }\n+/// # }\n+/// # #[derive(Debug)]\n+/// # struct SuperErrorSideKick;\n+/// # impl fmt::Display for SuperErrorSideKick {\n+/// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+/// #         write!(f, \"SuperErrorSideKick is here!\")\n+/// #     }\n+/// # }\n+/// # impl Error for SuperErrorSideKick {}\n+/// # fn get_super_error() -> Result<(), SuperError> {\n+/// #     Err(SuperError { source: SuperErrorSideKick })\n+/// # }\n+///\n+/// fn main() -> Result<(), Report> {\n+///     get_super_error()?;\n+///     Ok(())\n+/// }\n+/// ```\n+///\n+/// This example produces the following output:\n+///\n+/// ```console\n+/// Error: SuperError is here!: SuperErrorSideKick is here!\n+/// ```\n+///\n+/// **Note**: `Report`s constructed via `?` and `From` will be configured to use the single line\n+/// output format, if you want to make sure your `Report`s are pretty printed and include backtrace\n+/// you will need to manually convert and enable those flags.\n+///\n+/// ```should_panic\n+/// #![feature(error_reporter)]\n+/// use std::error::Report;\n+/// # use std::error::Error;\n+/// # use std::fmt;\n+/// # #[derive(Debug)]\n+/// # struct SuperError {\n+/// #     source: SuperErrorSideKick,\n+/// # }\n+/// # impl fmt::Display for SuperError {\n+/// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+/// #         write!(f, \"SuperError is here!\")\n+/// #     }\n+/// # }\n+/// # impl Error for SuperError {\n+/// #     fn source(&self) -> Option<&(dyn Error + 'static)> {\n+/// #         Some(&self.source)\n+/// #     }\n+/// # }\n+/// # #[derive(Debug)]\n+/// # struct SuperErrorSideKick;\n+/// # impl fmt::Display for SuperErrorSideKick {\n+/// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+/// #         write!(f, \"SuperErrorSideKick is here!\")\n+/// #     }\n+/// # }\n+/// # impl Error for SuperErrorSideKick {}\n+/// # fn get_super_error() -> Result<(), SuperError> {\n+/// #     Err(SuperError { source: SuperErrorSideKick })\n+/// # }\n+///\n+/// fn main() -> Result<(), Report> {\n+///     get_super_error()\n+///         .map_err(Report::from)\n+///         .map_err(|r| r.pretty(true).show_backtrace(true))?;\n+///     Ok(())\n+/// }\n+/// ```\n+///\n+/// This example produces the following output:\n+///\n+/// ```console\n+/// Error: SuperError is here!\n+///\n+/// Caused by:\n+///       SuperErrorSideKick is here!\n+/// ```\n+#[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+pub struct Report<E = Box<dyn Error>> {\n+    /// The error being reported.\n+    error: E,\n+    /// Whether a backtrace should be included as part of the report.\n+    show_backtrace: bool,\n+    /// Whether the report should be pretty-printed.\n+    pretty: bool,\n+}\n+\n+impl<E> Report<E>\n+where\n+    Report<E>: From<E>,\n+{\n+    /// Create a new `Report` from an input error.\n+    #[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+    pub fn new(error: E) -> Report<E> {\n+        Self::from(error)\n+    }\n+}\n+\n+impl<E> Report<E> {\n+    /// Enable pretty-printing the report across multiple lines.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(error_reporter)]\n+    /// use std::error::Report;\n+    /// # use std::error::Error;\n+    /// # use std::fmt;\n+    /// # #[derive(Debug)]\n+    /// # struct SuperError {\n+    /// #     source: SuperErrorSideKick,\n+    /// # }\n+    /// # impl fmt::Display for SuperError {\n+    /// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    /// #         write!(f, \"SuperError is here!\")\n+    /// #     }\n+    /// # }\n+    /// # impl Error for SuperError {\n+    /// #     fn source(&self) -> Option<&(dyn Error + 'static)> {\n+    /// #         Some(&self.source)\n+    /// #     }\n+    /// # }\n+    /// # #[derive(Debug)]\n+    /// # struct SuperErrorSideKick;\n+    /// # impl fmt::Display for SuperErrorSideKick {\n+    /// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    /// #         write!(f, \"SuperErrorSideKick is here!\")\n+    /// #     }\n+    /// # }\n+    /// # impl Error for SuperErrorSideKick {}\n+    ///\n+    /// let error = SuperError { source: SuperErrorSideKick };\n+    /// let report = Report::new(error).pretty(true);\n+    /// eprintln!(\"Error: {:?}\", report);\n+    /// ```\n+    ///\n+    /// This example produces the following output:\n+    ///\n+    /// ```console\n+    /// Error: SuperError is here!\n+    ///\n+    /// Caused by:\n+    ///       SuperErrorSideKick is here!\n+    /// ```\n+    ///\n+    /// When there are multiple source errors the causes will be numbered in order of iteration\n+    /// starting from the outermost error.\n+    ///\n+    /// ```rust\n+    /// #![feature(error_reporter)]\n+    /// use std::error::Report;\n+    /// # use std::error::Error;\n+    /// # use std::fmt;\n+    /// # #[derive(Debug)]\n+    /// # struct SuperError {\n+    /// #     source: SuperErrorSideKick,\n+    /// # }\n+    /// # impl fmt::Display for SuperError {\n+    /// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    /// #         write!(f, \"SuperError is here!\")\n+    /// #     }\n+    /// # }\n+    /// # impl Error for SuperError {\n+    /// #     fn source(&self) -> Option<&(dyn Error + 'static)> {\n+    /// #         Some(&self.source)\n+    /// #     }\n+    /// # }\n+    /// # #[derive(Debug)]\n+    /// # struct SuperErrorSideKick {\n+    /// #     source: SuperErrorSideKickSideKick,\n+    /// # }\n+    /// # impl fmt::Display for SuperErrorSideKick {\n+    /// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    /// #         write!(f, \"SuperErrorSideKick is here!\")\n+    /// #     }\n+    /// # }\n+    /// # impl Error for SuperErrorSideKick {\n+    /// #     fn source(&self) -> Option<&(dyn Error + 'static)> {\n+    /// #         Some(&self.source)\n+    /// #     }\n+    /// # }\n+    /// # #[derive(Debug)]\n+    /// # struct SuperErrorSideKickSideKick;\n+    /// # impl fmt::Display for SuperErrorSideKickSideKick {\n+    /// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    /// #         write!(f, \"SuperErrorSideKickSideKick is here!\")\n+    /// #     }\n+    /// # }\n+    /// # impl Error for SuperErrorSideKickSideKick { }\n+    ///\n+    /// let source = SuperErrorSideKickSideKick;\n+    /// let source = SuperErrorSideKick { source };\n+    /// let error = SuperError { source };\n+    /// let report = Report::new(error).pretty(true);\n+    /// eprintln!(\"Error: {:?}\", report);\n+    /// ```\n+    ///\n+    /// This example produces the following output:\n+    ///\n+    /// ```console\n+    /// Error: SuperError is here!\n+    ///\n+    /// Caused by:\n+    ///    0: SuperErrorSideKick is here!\n+    ///    1: SuperErrorSideKickSideKick is here!\n+    /// ```\n+    #[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+    pub fn pretty(mut self, pretty: bool) -> Self {\n+        self.pretty = pretty;\n+        self\n+    }\n+\n+    /// Display backtrace if available when using pretty output format.\n+    ///\n+    /// # Examples\n+    ///\n+    /// **Note**: Report will search for the first `Backtrace` it can find starting from the\n+    /// outermost error. In this example it will display the backtrace from the second error in the\n+    /// chain, `SuperErrorSideKick`.\n+    ///\n+    /// ```rust\n+    /// #![feature(error_reporter)]\n+    /// #![feature(backtrace)]\n+    /// # use std::error::Error;\n+    /// # use std::fmt;\n+    /// use std::error::Report;\n+    /// use std::backtrace::Backtrace;\n+    ///\n+    /// # #[derive(Debug)]\n+    /// # struct SuperError {\n+    /// #     source: SuperErrorSideKick,\n+    /// # }\n+    /// # impl fmt::Display for SuperError {\n+    /// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    /// #         write!(f, \"SuperError is here!\")\n+    /// #     }\n+    /// # }\n+    /// # impl Error for SuperError {\n+    /// #     fn source(&self) -> Option<&(dyn Error + 'static)> {\n+    /// #         Some(&self.source)\n+    /// #     }\n+    /// # }\n+    /// #[derive(Debug)]\n+    /// struct SuperErrorSideKick {\n+    ///     backtrace: Backtrace,\n+    /// }\n+    ///\n+    /// impl SuperErrorSideKick {\n+    ///     fn new() -> SuperErrorSideKick {\n+    ///         SuperErrorSideKick { backtrace: Backtrace::force_capture() }\n+    ///     }\n+    /// }\n+    ///\n+    /// impl Error for SuperErrorSideKick {\n+    ///     fn backtrace(&self) -> Option<&Backtrace> {\n+    ///         Some(&self.backtrace)\n+    ///     }\n+    /// }\n+    ///\n+    /// // The rest of the example is unchanged ...\n+    /// # impl fmt::Display for SuperErrorSideKick {\n+    /// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    /// #         write!(f, \"SuperErrorSideKick is here!\")\n+    /// #     }\n+    /// # }\n+    ///\n+    /// let source = SuperErrorSideKick::new();\n+    /// let error = SuperError { source };\n+    /// let report = Report::new(error).pretty(true).show_backtrace(true);\n+    /// eprintln!(\"Error: {:?}\", report);\n+    /// ```\n+    ///\n+    /// This example produces something similar to the following output:\n+    ///\n+    /// ```console\n+    /// Error: SuperError is here!\n+    ///\n+    /// Caused by:\n+    ///       SuperErrorSideKick is here!\n+    ///\n+    /// Stack backtrace:\n+    ///    0: rust_out::main::_doctest_main_src_error_rs_1158_0::SuperErrorSideKick::new\n+    ///    1: rust_out::main::_doctest_main_src_error_rs_1158_0\n+    ///    2: rust_out::main\n+    ///    3: core::ops::function::FnOnce::call_once\n+    ///    4: std::sys_common::backtrace::__rust_begin_short_backtrace\n+    ///    5: std::rt::lang_start::{{closure}}\n+    ///    6: std::panicking::try\n+    ///    7: std::rt::lang_start_internal\n+    ///    8: std::rt::lang_start\n+    ///    9: main\n+    ///   10: __libc_start_main\n+    ///   11: _start\n+    /// ```\n+    #[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+    pub fn show_backtrace(mut self, show_backtrace: bool) -> Self {\n+        self.show_backtrace = show_backtrace;\n+        self\n+    }\n+}\n+\n+impl<E> Report<E>\n+where\n+    E: Error,\n+{\n+    fn backtrace(&self) -> Option<&Backtrace> {\n+        // have to grab the backtrace on the first error directly since that error may not be\n+        // 'static\n+        let backtrace = self.error.backtrace();\n+        let backtrace = backtrace.or_else(|| {\n+            self.error\n+                .source()\n+                .map(|source| source.chain().find_map(|source| source.backtrace()))\n+                .flatten()\n+        });\n+        backtrace\n+    }\n+\n+    /// Format the report as a single line.\n+    #[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+    fn fmt_singleline(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.error)?;\n+\n+        let sources = self.error.source().into_iter().flat_map(<dyn Error>::chain);\n+\n+        for cause in sources {\n+            write!(f, \": {}\", cause)?;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Format the report as multiple lines, with each error cause on its own line.\n+    #[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+    fn fmt_multiline(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let error = &self.error;\n+\n+        write!(f, \"{}\", error)?;\n+\n+        if let Some(cause) = error.source() {\n+            write!(f, \"\\n\\nCaused by:\")?;\n+\n+            let multiple = cause.source().is_some();\n+\n+            for (ind, error) in cause.chain().enumerate() {\n+                writeln!(f)?;\n+                let mut indented = Indented { inner: f };\n+                if multiple {\n+                    write!(indented, \"{: >4}: {}\", ind, error)?;\n+                } else {\n+                    write!(indented, \"      {}\", error)?;\n+                }\n+            }\n+        }\n+\n+        if self.show_backtrace {\n+            let backtrace = self.backtrace();\n+\n+            if let Some(backtrace) = backtrace {\n+                let backtrace = backtrace.to_string();\n+\n+                f.write_str(\"\\n\\nStack backtrace:\\n\")?;\n+                f.write_str(backtrace.trim_end())?;\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+impl Report<Box<dyn Error>> {\n+    fn backtrace(&self) -> Option<&Backtrace> {\n+        // have to grab the backtrace on the first error directly since that error may not be\n+        // 'static\n+        let backtrace = self.error.backtrace();\n+        let backtrace = backtrace.or_else(|| {\n+            self.error\n+                .source()\n+                .map(|source| source.chain().find_map(|source| source.backtrace()))\n+                .flatten()\n+        });\n+        backtrace\n+    }\n+\n+    /// Format the report as a single line.\n+    #[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+    fn fmt_singleline(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.error)?;\n+\n+        let sources = self.error.source().into_iter().flat_map(<dyn Error>::chain);\n+\n+        for cause in sources {\n+            write!(f, \": {}\", cause)?;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Format the report as multiple lines, with each error cause on its own line.\n+    #[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+    fn fmt_multiline(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let error = &self.error;\n+\n+        write!(f, \"{}\", error)?;\n+\n+        if let Some(cause) = error.source() {\n+            write!(f, \"\\n\\nCaused by:\")?;\n+\n+            let multiple = cause.source().is_some();\n+\n+            for (ind, error) in cause.chain().enumerate() {\n+                writeln!(f)?;\n+                let mut indented = Indented { inner: f };\n+                if multiple {\n+                    write!(indented, \"{: >4}: {}\", ind, error)?;\n+                } else {\n+                    write!(indented, \"      {}\", error)?;\n+                }\n+            }\n+        }\n+\n+        if self.show_backtrace {\n+            let backtrace = self.backtrace();\n+\n+            if let Some(backtrace) = backtrace {\n+                let backtrace = backtrace.to_string();\n+\n+                f.write_str(\"\\n\\nStack backtrace:\\n\")?;\n+                f.write_str(backtrace.trim_end())?;\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+#[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+impl<E> From<E> for Report<E>\n+where\n+    E: Error,\n+{\n+    fn from(error: E) -> Self {\n+        Report { error, show_backtrace: false, pretty: false }\n+    }\n+}\n+\n+#[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+impl<'a, E> From<E> for Report<Box<dyn Error + 'a>>\n+where\n+    E: Error + 'a,\n+{\n+    fn from(error: E) -> Self {\n+        let error = box error;\n+        Report { error, show_backtrace: false, pretty: false }\n+    }\n+}\n+\n+#[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+impl<E> fmt::Display for Report<E>\n+where\n+    E: Error,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self.pretty { self.fmt_multiline(f) } else { self.fmt_singleline(f) }\n+    }\n+}\n+\n+#[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+impl fmt::Display for Report<Box<dyn Error>> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self.pretty { self.fmt_multiline(f) } else { self.fmt_singleline(f) }\n+    }\n+}\n+\n+// This type intentionally outputs the same format for `Display` and `Debug`for\n+// situations where you unwrap a `Report` or return it from main.\n+#[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+impl<E> fmt::Debug for Report<E>\n+where\n+    Report<E>: fmt::Display,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+/// Wrapper type for indenting the inner source.\n+struct Indented<'a, D> {\n+    inner: &'a mut D,\n+}\n+\n+impl<T> Write for Indented<'_, T>\n+where\n+    T: Write,\n+{\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        for (i, line) in s.split('\\n').enumerate() {\n+            if i > 0 {\n+                self.inner.write_char('\\n')?;\n+                self.inner.write_str(\"      \")?;\n+            }\n+\n+            self.inner.write_str(line)?;\n+        }\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "eae5f43ff3cfb060b424b6a59aa0d8e40e35b2ad", "filename": "library/std/src/error/tests.rs", "status": "modified", "additions": 405, "deletions": 0, "changes": 405, "blob_url": "https://github.com/rust-lang/rust/blob/e045c79c2d8697ef7ab2e25c3165cb5896f163ba/library%2Fstd%2Fsrc%2Ferror%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e045c79c2d8697ef7ab2e25c3165cb5896f163ba/library%2Fstd%2Fsrc%2Ferror%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror%2Ftests.rs?ref=e045c79c2d8697ef7ab2e25c3165cb5896f163ba", "patch": "@@ -35,3 +35,408 @@ fn downcasting() {\n         Err(e) => assert_eq!(*e.downcast::<A>().unwrap(), A),\n     }\n }\n+\n+use crate::backtrace::Backtrace;\n+use crate::error::Report;\n+\n+#[derive(Debug)]\n+struct SuperError {\n+    source: SuperErrorSideKick,\n+}\n+\n+impl fmt::Display for SuperError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"SuperError is here!\")\n+    }\n+}\n+\n+impl Error for SuperError {\n+    fn source(&self) -> Option<&(dyn Error + 'static)> {\n+        Some(&self.source)\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct SuperErrorSideKick;\n+\n+impl fmt::Display for SuperErrorSideKick {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"SuperErrorSideKick is here!\")\n+    }\n+}\n+\n+impl Error for SuperErrorSideKick {}\n+\n+#[test]\n+fn single_line_formatting() {\n+    let error = SuperError { source: SuperErrorSideKick };\n+    let report = Report::new(&error);\n+    let actual = report.to_string();\n+    let expected = String::from(\"SuperError is here!: SuperErrorSideKick is here!\");\n+\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn multi_line_formatting() {\n+    let error = SuperError { source: SuperErrorSideKick };\n+    let report = Report::new(&error).pretty(true);\n+    let actual = report.to_string();\n+    let expected = String::from(\n+        \"\\\n+SuperError is here!\n+\n+Caused by:\n+      SuperErrorSideKick is here!\",\n+    );\n+\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn error_with_no_sources_formats_single_line_correctly() {\n+    let report = Report::new(SuperErrorSideKick);\n+    let actual = report.to_string();\n+    let expected = String::from(\"SuperErrorSideKick is here!\");\n+\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn error_with_no_sources_formats_multi_line_correctly() {\n+    let report = Report::new(SuperErrorSideKick).pretty(true);\n+    let actual = report.to_string();\n+    let expected = String::from(\"SuperErrorSideKick is here!\");\n+\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn error_with_backtrace_outputs_correctly_with_one_source() {\n+    let trace = Backtrace::force_capture();\n+    let expected = format!(\n+        \"\\\n+The source of the error\n+\n+Caused by:\n+      Error with backtrace\n+\n+Stack backtrace:\n+{}\",\n+        trace\n+    );\n+    let error = GenericError::new(\"Error with backtrace\");\n+    let mut error = GenericError::new_with_source(\"The source of the error\", error);\n+    error.backtrace = Some(trace);\n+    let report = Report::new(error).pretty(true).show_backtrace(true);\n+\n+    println!(\"Error: {}\", report);\n+    assert_eq!(expected.trim_end(), report.to_string());\n+}\n+\n+#[test]\n+fn error_with_backtrace_outputs_correctly_with_two_sources() {\n+    let trace = Backtrace::force_capture();\n+    let expected = format!(\n+        \"\\\n+Error with two sources\n+\n+Caused by:\n+   0: The source of the error\n+   1: Error with backtrace\n+\n+Stack backtrace:\n+{}\",\n+        trace\n+    );\n+    let mut error = GenericError::new(\"Error with backtrace\");\n+    error.backtrace = Some(trace);\n+    let error = GenericError::new_with_source(\"The source of the error\", error);\n+    let error = GenericError::new_with_source(\"Error with two sources\", error);\n+    let report = Report::new(error).pretty(true).show_backtrace(true);\n+\n+    println!(\"Error: {}\", report);\n+    assert_eq!(expected.trim_end(), report.to_string());\n+}\n+\n+#[derive(Debug)]\n+struct GenericError<D> {\n+    message: D,\n+    backtrace: Option<Backtrace>,\n+    source: Option<Box<dyn Error + 'static>>,\n+}\n+\n+impl<D> GenericError<D> {\n+    fn new(message: D) -> GenericError<D> {\n+        Self { message, backtrace: None, source: None }\n+    }\n+\n+    fn new_with_source<E>(message: D, source: E) -> GenericError<D>\n+    where\n+        E: Error + 'static,\n+    {\n+        let source: Box<dyn Error + 'static> = Box::new(source);\n+        let source = Some(source);\n+        GenericError { message, backtrace: None, source }\n+    }\n+}\n+\n+impl<D> fmt::Display for GenericError<D>\n+where\n+    D: fmt::Display,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(&self.message, f)\n+    }\n+}\n+\n+impl<D> Error for GenericError<D>\n+where\n+    D: fmt::Debug + fmt::Display,\n+{\n+    fn source(&self) -> Option<&(dyn Error + 'static)> {\n+        self.source.as_deref()\n+    }\n+\n+    fn backtrace(&self) -> Option<&Backtrace> {\n+        self.backtrace.as_ref()\n+    }\n+}\n+\n+#[test]\n+fn error_formats_single_line_with_rude_display_impl() {\n+    #[derive(Debug)]\n+    struct MyMessage;\n+\n+    impl fmt::Display for MyMessage {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.write_str(\"line 1\\nline 2\")?;\n+            f.write_str(\"\\nline 3\\nline 4\\n\")?;\n+            f.write_str(\"line 5\\nline 6\")?;\n+            Ok(())\n+        }\n+    }\n+\n+    let error = GenericError::new(MyMessage);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let report = Report::new(error);\n+    let expected = \"\\\n+line 1\n+line 2\n+line 3\n+line 4\n+line 5\n+line 6: line 1\n+line 2\n+line 3\n+line 4\n+line 5\n+line 6: line 1\n+line 2\n+line 3\n+line 4\n+line 5\n+line 6: line 1\n+line 2\n+line 3\n+line 4\n+line 5\n+line 6\";\n+\n+    let actual = report.to_string();\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn error_formats_multi_line_with_rude_display_impl() {\n+    #[derive(Debug)]\n+    struct MyMessage;\n+\n+    impl fmt::Display for MyMessage {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.write_str(\"line 1\\nline 2\")?;\n+            f.write_str(\"\\nline 3\\nline 4\\n\")?;\n+            f.write_str(\"line 5\\nline 6\")?;\n+            Ok(())\n+        }\n+    }\n+\n+    let error = GenericError::new(MyMessage);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let report = Report::new(error).pretty(true);\n+    let expected = \"line 1\n+line 2\n+line 3\n+line 4\n+line 5\n+line 6\n+\n+Caused by:\n+   0: line 1\n+      line 2\n+      line 3\n+      line 4\n+      line 5\n+      line 6\n+   1: line 1\n+      line 2\n+      line 3\n+      line 4\n+      line 5\n+      line 6\n+   2: line 1\n+      line 2\n+      line 3\n+      line 4\n+      line 5\n+      line 6\";\n+\n+    let actual = report.to_string();\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn errors_that_start_with_newline_formats_correctly() {\n+    #[derive(Debug)]\n+    struct MyMessage;\n+\n+    impl fmt::Display for MyMessage {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.write_str(\"\\nThe message\\n\")\n+        }\n+    }\n+\n+    let error = GenericError::new(MyMessage);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let report = Report::new(error).pretty(true);\n+    let expected = \"\n+The message\n+\n+\n+Caused by:\n+   0: \\\n+\\n      The message\n+      \\\n+\\n   1: \\\n+\\n      The message\n+      \";\n+\n+    let actual = report.to_string();\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn errors_with_multiple_writes_on_same_line_dont_insert_erroneous_newlines() {\n+    #[derive(Debug)]\n+    struct MyMessage;\n+\n+    impl fmt::Display for MyMessage {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.write_str(\"The message\")?;\n+            f.write_str(\" goes on\")?;\n+            f.write_str(\" and on.\")\n+        }\n+    }\n+\n+    let error = GenericError::new(MyMessage);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let report = Report::new(error).pretty(true);\n+    let expected = \"\\\n+The message goes on and on.\n+\n+Caused by:\n+   0: The message goes on and on.\n+   1: The message goes on and on.\";\n+\n+    let actual = report.to_string();\n+    println!(\"{}\", actual);\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn errors_with_string_interpolation_formats_correctly() {\n+    #[derive(Debug)]\n+    struct MyMessage(usize);\n+\n+    impl fmt::Display for MyMessage {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            write!(f, \"Got an error code: ({}). \", self.0)?;\n+            write!(f, \"What would you like to do in response?\")\n+        }\n+    }\n+\n+    let error = GenericError::new(MyMessage(10));\n+    let error = GenericError::new_with_source(MyMessage(20), error);\n+    let report = Report::new(error).pretty(true);\n+    let expected = \"\\\n+Got an error code: (20). What would you like to do in response?\n+\n+Caused by:\n+      Got an error code: (10). What would you like to do in response?\";\n+    let actual = report.to_string();\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn empty_lines_mid_message() {\n+    #[derive(Debug)]\n+    struct MyMessage;\n+\n+    impl fmt::Display for MyMessage {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.write_str(\"line 1\\n\\nline 2\")\n+        }\n+    }\n+\n+    let error = GenericError::new(MyMessage);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let report = Report::new(error).pretty(true);\n+    let expected = \"\\\n+line 1\n+\n+line 2\n+\n+Caused by:\n+   0: line 1\n+      \\\n+\\n      line 2\n+   1: line 1\n+      \\\n+\\n      line 2\";\n+\n+    let actual = report.to_string();\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn only_one_source() {\n+    #[derive(Debug)]\n+    struct MyMessage;\n+\n+    impl fmt::Display for MyMessage {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.write_str(\"line 1\\nline 2\")\n+        }\n+    }\n+\n+    let error = GenericError::new(MyMessage);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let report = Report::new(error).pretty(true);\n+    let expected = \"\\\n+line 1\n+line 2\n+\n+Caused by:\n+      line 1\n+      line 2\";\n+\n+    let actual = report.to_string();\n+    assert_eq!(expected, actual);\n+}"}]}