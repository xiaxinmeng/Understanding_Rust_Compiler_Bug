{"sha": "cbf88730e755d099c854f84dd0f1990490bf0088", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiZjg4NzMwZTc1NWQwOTljODU0Zjg0ZGQwZjE5OTA0OTBiZjAwODg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-08T11:36:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-08T11:36:52Z"}, "message": "Auto merge of #38813 - eddyb:lazy-11, r=nikomatsakis\n\n[11/n] Separate ty::Tables into one per each body.\n\n_This is part of a series ([prev](https://github.com/rust-lang/rust/pull/38449) | [next]()) of patches designed to rework rustc into an out-of-order on-demand pipeline model for both better feature support (e.g. [MIR-based](https://github.com/solson/miri) early constant evaluation) and incremental execution of compiler passes (e.g. type-checking), with beneficial consequences to IDE support as well.\nIf any motivation is unclear, please ask for additional PR description clarifications or code comments._\n\n<hr>\n\nIn order to track the results of type-checking and inference for incremental recompilation, they must be stored separately for each function or constant value, instead of lumped together.\n\nThese side-`Tables` also have to be tracked by various passes, as they visit through bodies (all of which have `Tables`, even if closures share the ones from their parent functions). This is usually done by switching a `tables` field in an override of `visit_nested_body` before recursing through `visit_body`, to the relevant one and then restoring it - however, in many cases the nesting is unnecessary and creating the visitor for each body in the crate and then visiting that body, would be a much cleaner solution.\n\nTo simplify handling of inlined HIR & its side-tables, their `NodeId` remapping and entries HIR map were fully stripped out, which means that `NodeId`s from inlined HIR must not be used where a local `NodeId` is expected. It might be possible to make the nodes (`Expr`, `Block`, `Pat`, etc.) that only show up within a `Body` have IDs that are scoped to that `Body`, which would also allow `Tables` to use `Vec`s.\n\nThat last part also fixes #38790 which was accidentally introduced in a previous refactor.", "tree": {"sha": "d963b89f70bd039ba13fb0ef7f5393a30e315226", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d963b89f70bd039ba13fb0ef7f5393a30e315226"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbf88730e755d099c854f84dd0f1990490bf0088", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbf88730e755d099c854f84dd0f1990490bf0088", "html_url": "https://github.com/rust-lang/rust/commit/cbf88730e755d099c854f84dd0f1990490bf0088", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbf88730e755d099c854f84dd0f1990490bf0088/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ac9d337dcc544b4b1959997cdd36f1ba0c8d3e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ac9d337dcc544b4b1959997cdd36f1ba0c8d3e1", "html_url": "https://github.com/rust-lang/rust/commit/7ac9d337dcc544b4b1959997cdd36f1ba0c8d3e1"}, {"sha": "cde0a7e7e01f64caed45e97ff958821d9247959e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cde0a7e7e01f64caed45e97ff958821d9247959e", "html_url": "https://github.com/rust-lang/rust/commit/cde0a7e7e01f64caed45e97ff958821d9247959e"}], "stats": {"total": 2527, "additions": 1120, "deletions": 1407}, "files": [{"sha": "d153945dc091f51f10a5145c7c35a8afa7177bde", "filename": "src/Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -569,7 +569,6 @@ dependencies = [\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n- \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_driver 0.0.0\",\n  \"rustc_errors 0.0.0\","}, {"sha": "35afdd75cb8c4f47baf90f1a59af38cb8ecf41b9", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -18,6 +18,7 @@ use hir::{self, PatKind};\n \n struct CFGBuilder<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tables: &'a ty::Tables<'tcx>,\n     graph: CFGGraph,\n     fn_exit: CFGIndex,\n     loop_scopes: Vec<LoopScope>,\n@@ -42,10 +43,23 @@ pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let fn_exit = graph.add_node(CFGNodeData::Exit);\n     let body_exit;\n \n+    // Find the function this expression is from.\n+    let mut node_id = body.id;\n+    loop {\n+        let node = tcx.map.get(node_id);\n+        if hir::map::blocks::FnLikeNode::from_node(node).is_some() {\n+            break;\n+        }\n+        let parent = tcx.map.get_parent_node(node_id);\n+        assert!(node_id != parent);\n+        node_id = parent;\n+    }\n+\n     let mut cfg_builder = CFGBuilder {\n+        tcx: tcx,\n+        tables: tcx.item_tables(tcx.map.local_def_id(node_id)),\n         graph: graph,\n         fn_exit: fn_exit,\n-        tcx: tcx,\n         loop_scopes: Vec::new()\n     };\n     body_exit = cfg_builder.expr(body, entry);\n@@ -310,11 +324,11 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             hir::ExprIndex(ref l, ref r) |\n-            hir::ExprBinary(_, ref l, ref r) if self.tcx.tables().is_method_call(expr.id) => {\n+            hir::ExprBinary(_, ref l, ref r) if self.tables.is_method_call(expr.id) => {\n                 self.call(expr, pred, &l, Some(&**r).into_iter())\n             }\n \n-            hir::ExprUnary(_, ref e) if self.tcx.tables().is_method_call(expr.id) => {\n+            hir::ExprUnary(_, ref e) if self.tables.is_method_call(expr.id) => {\n                 self.call(expr, pred, &e, None::<hir::Expr>.iter())\n             }\n \n@@ -368,9 +382,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             func_or_rcvr: &hir::Expr,\n             args: I) -> CFGIndex {\n         let method_call = ty::MethodCall::expr(call_expr.id);\n-        let fn_ty = match self.tcx.tables().method_map.get(&method_call) {\n+        let fn_ty = match self.tables.method_map.get(&method_call) {\n             Some(method) => method.ty,\n-            None => self.tcx.tables().expr_ty_adjusted(func_or_rcvr)\n+            None => self.tables.expr_ty_adjusted(func_or_rcvr)\n         };\n \n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);"}, {"sha": "a68876b5ae9c0b6bdbe03bc862f5727317c75b14", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -113,6 +113,7 @@ pub enum DepNode<D: Clone + Debug> {\n     SizedConstraint(D),\n     AssociatedItemDefIds(D),\n     InherentImpls(D),\n+    Tables(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n     // nice to get more fine-grained here (e.g., to include a\n@@ -162,6 +163,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             ItemSignature,\n             AssociatedItemDefIds,\n             InherentImpls,\n+            Tables,\n             TraitImpls,\n             ReprHints,\n         }\n@@ -230,6 +232,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             SizedConstraint(ref d) => op(d).map(SizedConstraint),\n             AssociatedItemDefIds(ref d) => op(d).map(AssociatedItemDefIds),\n             InherentImpls(ref d) => op(d).map(InherentImpls),\n+            Tables(ref d) => op(d).map(Tables),\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),\n             ReprHints(ref d) => op(d).map(ReprHints),"}, {"sha": "91e88e2c73ff892947f387eff7f606cbbfc1a94f", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -45,15 +45,6 @@ pub struct FnLikeNode<'a> { node: map::Node<'a> }\n /// corresponds to some FnLikeNode.\n pub trait MaybeFnLike { fn is_fn_like(&self) -> bool; }\n \n-/// Components shared by fn-like things (fn items, methods, closures).\n-pub struct FnParts<'a> {\n-    pub decl: &'a FnDecl,\n-    pub body: ast::BodyId,\n-    pub kind: FnKind<'a>,\n-    pub span: Span,\n-    pub id:   NodeId,\n-}\n-\n impl MaybeFnLike for ast::Item {\n     fn is_fn_like(&self) -> bool {\n         match self.node { ast::ItemFn(..) => true, _ => false, }\n@@ -165,16 +156,6 @@ impl<'a> FnLikeNode<'a> {\n         }\n     }\n \n-    pub fn to_fn_parts(self) -> FnParts<'a> {\n-        FnParts {\n-            decl: self.decl(),\n-            body: self.body(),\n-            kind: self.kind(),\n-            span: self.span(),\n-            id:   self.id(),\n-        }\n-    }\n-\n     pub fn body(self) -> ast::BodyId {\n         self.handle(|i: ItemFnParts<'a>|  i.body,\n                     |_, _, _: &'a ast::MethodSig, _, body: ast::BodyId, _, _|  body,"}, {"sha": "bd0ff695d093a518ca58c395b59953f5cf477fc0", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 4, "deletions": 34, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -23,10 +23,6 @@ pub struct NodeCollector<'ast> {\n     pub(super) map: Vec<MapEntry<'ast>>,\n     /// The parent of this node\n     pub parent_node: NodeId,\n-    /// If true, completely ignore nested items. We set this when loading\n-    /// HIR from metadata, since in that case we only want the HIR for\n-    /// one specific item (and not the ones nested inside of it).\n-    pub ignore_nested_items: bool\n }\n \n impl<'ast> NodeCollector<'ast> {\n@@ -35,30 +31,12 @@ impl<'ast> NodeCollector<'ast> {\n             krate: krate,\n             map: vec![],\n             parent_node: CRATE_NODE_ID,\n-            ignore_nested_items: false\n         };\n         collector.insert_entry(CRATE_NODE_ID, RootCrate);\n \n         collector\n     }\n \n-    pub(super) fn extend(krate: &'ast Crate,\n-                         parent: &'ast InlinedItem,\n-                         parent_node: NodeId,\n-                         map: Vec<MapEntry<'ast>>)\n-                         -> NodeCollector<'ast> {\n-        let mut collector = NodeCollector {\n-            krate: krate,\n-            map: map,\n-            parent_node: parent_node,\n-            ignore_nested_items: true\n-        };\n-\n-        collector.insert_entry(parent_node, RootInlinedParent(parent));\n-\n-        collector\n-    }\n-\n     fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'ast>) {\n         debug!(\"ast_map: {:?} => {:?}\", id, entry);\n         let len = self.map.len();\n@@ -92,27 +70,19 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n \n     fn visit_nested_item(&mut self, item: ItemId) {\n         debug!(\"visit_nested_item: {:?}\", item);\n-        if !self.ignore_nested_items {\n-            self.visit_item(self.krate.item(item.id))\n-        }\n+        self.visit_item(self.krate.item(item.id));\n     }\n \n     fn visit_nested_trait_item(&mut self, item_id: TraitItemId) {\n-        if !self.ignore_nested_items {\n-            self.visit_trait_item(self.krate.trait_item(item_id))\n-        }\n+        self.visit_trait_item(self.krate.trait_item(item_id));\n     }\n \n     fn visit_nested_impl_item(&mut self, item_id: ImplItemId) {\n-        if !self.ignore_nested_items {\n-            self.visit_impl_item(self.krate.impl_item(item_id))\n-        }\n+        self.visit_impl_item(self.krate.impl_item(item_id));\n     }\n \n     fn visit_nested_body(&mut self, id: BodyId) {\n-        if !self.ignore_nested_items {\n-            self.visit_body(self.krate.body(id))\n-        }\n+        self.visit_body(self.krate.body(id));\n     }\n \n     fn visit_item(&mut self, i: &'ast Item) {"}, {"sha": "7c0621279fd6f607f26e0675ec4484c8886db298", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 79, "deletions": 163, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -25,28 +25,18 @@ use syntax::codemap::Spanned;\n use syntax_pos::Span;\n \n use hir::*;\n-use hir::intravisit::Visitor;\n use hir::print::Nested;\n+use util::nodemap::DefIdMap;\n \n use arena::TypedArena;\n use std::cell::RefCell;\n use std::io;\n-use std::mem;\n \n pub mod blocks;\n mod collector;\n mod def_collector;\n pub mod definitions;\n \n-/// The data we save and restore about an inlined item or method.  This is not\n-/// part of the AST that we parse from a file, but it becomes part of the tree\n-/// that we trans.\n-#[derive(Debug)]\n-struct InlinedItem {\n-    def_id: DefId,\n-    body: Body,\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub enum Node<'ast> {\n     NodeItem(&'ast Item),\n@@ -99,7 +89,6 @@ enum MapEntry<'ast> {\n \n     /// Roots for node trees.\n     RootCrate,\n-    RootInlinedParent(&'ast InlinedItem)\n }\n \n impl<'ast> Clone for MapEntry<'ast> {\n@@ -152,8 +141,7 @@ impl<'ast> MapEntry<'ast> {\n             EntryVisibility(id, _) => id,\n \n             NotPresent |\n-            RootCrate |\n-            RootInlinedParent(_) => return None,\n+            RootCrate => return None,\n         })\n     }\n \n@@ -225,15 +213,15 @@ impl<'ast> MapEntry<'ast> {\n pub struct Forest {\n     krate: Crate,\n     pub dep_graph: DepGraph,\n-    inlined_items: TypedArena<InlinedItem>\n+    inlined_bodies: TypedArena<Body>\n }\n \n impl Forest {\n     pub fn new(krate: Crate, dep_graph: &DepGraph) -> Forest {\n         Forest {\n             krate: krate,\n             dep_graph: dep_graph.clone(),\n-            inlined_items: TypedArena::new()\n+            inlined_bodies: TypedArena::new()\n         }\n     }\n \n@@ -263,20 +251,15 @@ pub struct Map<'ast> {\n     ///\n     /// Also, indexing is pretty quick when you've got a vector and\n     /// plain old integers.\n-    map: RefCell<Vec<MapEntry<'ast>>>,\n+    map: Vec<MapEntry<'ast>>,\n \n     definitions: Definitions,\n \n-    /// All NodeIds that are numerically greater or equal to this value come\n-    /// from inlined items.\n-    local_node_id_watermark: NodeId,\n+    /// Bodies inlined from other crates are cached here.\n+    inlined_bodies: RefCell<DefIdMap<&'ast Body>>,\n }\n \n impl<'ast> Map<'ast> {\n-    pub fn is_inlined_node_id(&self, id: NodeId) -> bool {\n-        id >= self.local_node_id_watermark\n-    }\n-\n     /// Registers a read in the dependency graph of the AST node with\n     /// the given `id`. This needs to be called each time a public\n     /// function returns the HIR for a node -- in other words, when it\n@@ -289,111 +272,71 @@ impl<'ast> Map<'ast> {\n     }\n \n     fn dep_node(&self, id0: NodeId) -> DepNode<DefId> {\n-        let map = self.map.borrow();\n         let mut id = id0;\n-        if !self.is_inlined_node_id(id) {\n-            let mut last_expr = None;\n-            loop {\n-                let entry = map[id.as_usize()];\n-                match entry {\n-                    EntryItem(..) |\n-                    EntryTraitItem(..) |\n-                    EntryImplItem(..) => {\n-                        if let Some(last_id) = last_expr {\n-                            // The body may have a separate dep node\n-                            if entry.is_body_owner(last_id) {\n-                                let def_id = self.local_def_id(id);\n-                                return DepNode::HirBody(def_id);\n-                            }\n+        let mut last_expr = None;\n+        loop {\n+            let entry = self.map[id.as_usize()];\n+            match entry {\n+                EntryItem(..) |\n+                EntryTraitItem(..) |\n+                EntryImplItem(..) => {\n+                    if let Some(last_id) = last_expr {\n+                        // The body may have a separate dep node\n+                        if entry.is_body_owner(last_id) {\n+                            let def_id = self.local_def_id(id);\n+                            return DepNode::HirBody(def_id);\n                         }\n-                        return DepNode::Hir(self.local_def_id(id));\n                     }\n+                    return DepNode::Hir(self.local_def_id(id));\n+                }\n \n-                    EntryVariant(p, v) => {\n-                        id = p;\n+                EntryVariant(p, v) => {\n+                    id = p;\n \n-                        if last_expr.is_some() {\n-                            if v.node.disr_expr.map(|e| e.node_id) == last_expr {\n-                                // The enum parent holds both Hir and HirBody nodes.\n-                                let def_id = self.local_def_id(id);\n-                                return DepNode::HirBody(def_id);\n-                            }\n+                    if last_expr.is_some() {\n+                        if v.node.disr_expr.map(|e| e.node_id) == last_expr {\n+                            // The enum parent holds both Hir and HirBody nodes.\n+                            let def_id = self.local_def_id(id);\n+                            return DepNode::HirBody(def_id);\n                         }\n                     }\n+                }\n \n-                    EntryForeignItem(p, _) |\n-                    EntryField(p, _) |\n-                    EntryStmt(p, _) |\n-                    EntryTy(p, _) |\n-                    EntryTraitRef(p, _) |\n-                    EntryLocal(p, _) |\n-                    EntryPat(p, _) |\n-                    EntryBlock(p, _) |\n-                    EntryStructCtor(p, _) |\n-                    EntryLifetime(p, _) |\n-                    EntryTyParam(p, _) |\n-                    EntryVisibility(p, _) =>\n-                        id = p,\n-\n-                    EntryExpr(p, _) => {\n-                        last_expr = Some(id);\n-                        id = p;\n-                    }\n-\n-                    RootCrate => {\n-                        return DepNode::Hir(DefId::local(CRATE_DEF_INDEX));\n-                    }\n-\n-                    RootInlinedParent(_) =>\n-                        bug!(\"node {} has inlined ancestor but is not inlined\", id0),\n-\n-                    NotPresent =>\n-                        // Some nodes, notably macro definitions, are not\n-                        // present in the map for whatever reason, but\n-                        // they *do* have def-ids. So if we encounter an\n-                        // empty hole, check for that case.\n-                        return self.opt_local_def_id(id)\n-                                   .map(|def_id| DepNode::Hir(def_id))\n-                                   .unwrap_or_else(|| {\n-                                       bug!(\"Walking parents from `{}` \\\n-                                             led to `NotPresent` at `{}`\",\n-                                            id0, id)\n-                                   }),\n+                EntryForeignItem(p, _) |\n+                EntryField(p, _) |\n+                EntryStmt(p, _) |\n+                EntryTy(p, _) |\n+                EntryTraitRef(p, _) |\n+                EntryLocal(p, _) |\n+                EntryPat(p, _) |\n+                EntryBlock(p, _) |\n+                EntryStructCtor(p, _) |\n+                EntryLifetime(p, _) |\n+                EntryTyParam(p, _) |\n+                EntryVisibility(p, _) =>\n+                    id = p,\n+\n+                EntryExpr(p, _) => {\n+                    last_expr = Some(id);\n+                    id = p;\n                 }\n-            }\n-        } else {\n-            // reading from an inlined def-id is really a read out of\n-            // the metadata from which we loaded the item.\n-            loop {\n-                match map[id.as_usize()] {\n-                    EntryItem(p, _) |\n-                    EntryForeignItem(p, _) |\n-                    EntryTraitItem(p, _) |\n-                    EntryImplItem(p, _) |\n-                    EntryVariant(p, _) |\n-                    EntryField(p, _) |\n-                    EntryExpr(p, _) |\n-                    EntryStmt(p, _) |\n-                    EntryTy(p, _) |\n-                    EntryTraitRef(p, _) |\n-                    EntryLocal(p, _) |\n-                    EntryPat(p, _) |\n-                    EntryBlock(p, _) |\n-                    EntryStructCtor(p, _) |\n-                    EntryLifetime(p, _) |\n-                    EntryTyParam(p, _) |\n-                    EntryVisibility(p, _) =>\n-                        id = p,\n-\n-                    RootInlinedParent(parent) =>\n-                        return DepNode::MetaData(parent.def_id),\n-\n-                    RootCrate =>\n-                        bug!(\"node {} has crate ancestor but is inlined\", id0),\n-\n-                    NotPresent =>\n-                        bug!(\"node {} is inlined but not present in map\", id0),\n+\n+                RootCrate => {\n+                    return DepNode::Hir(DefId::local(CRATE_DEF_INDEX));\n                 }\n+\n+                NotPresent =>\n+                    // Some nodes, notably macro definitions, are not\n+                    // present in the map for whatever reason, but\n+                    // they *do* have def-ids. So if we encounter an\n+                    // empty hole, check for that case.\n+                    return self.opt_local_def_id(id)\n+                               .map(|def_id| DepNode::Hir(def_id))\n+                               .unwrap_or_else(|| {\n+                                   bug!(\"Walking parents from `{}` \\\n+                                         led to `NotPresent` at `{}`\",\n+                                        id0, id)\n+                               }),\n             }\n         }\n     }\n@@ -442,11 +385,11 @@ impl<'ast> Map<'ast> {\n     }\n \n     fn entry_count(&self) -> usize {\n-        self.map.borrow().len()\n+        self.map.len()\n     }\n \n     fn find_entry(&self, id: NodeId) -> Option<MapEntry<'ast>> {\n-        self.map.borrow().get(id.as_usize()).cloned()\n+        self.map.get(id.as_usize()).cloned()\n     }\n \n     pub fn krate(&self) -> &'ast Crate {\n@@ -483,7 +426,7 @@ impl<'ast> Map<'ast> {\n     /// for embedded constant expressions (e.g. `N` in `[T; N]`).\n     pub fn body_owner(&self, BodyId { node_id }: BodyId) -> NodeId {\n         let parent = self.get_parent_node(node_id);\n-        if self.map.borrow()[parent.as_usize()].is_body_owner(node_id) {\n+        if self.map[parent.as_usize()].is_body_owner(node_id) {\n             parent\n         } else {\n             node_id\n@@ -644,11 +587,7 @@ impl<'ast> Map<'ast> {\n     }\n \n     pub fn get_parent_did(&self, id: NodeId) -> DefId {\n-        let parent = self.get_parent(id);\n-        match self.find_entry(parent) {\n-            Some(RootInlinedParent(ii)) => ii.def_id,\n-            _ => self.local_def_id(parent)\n-        }\n+        self.local_def_id(self.get_parent(id))\n     }\n \n     pub fn get_foreign_abi(&self, id: NodeId) -> Abi {\n@@ -660,8 +599,6 @@ impl<'ast> Map<'ast> {\n                     _ => None\n                 }\n             }\n-            /// Wrong but OK, because the only inlined foreign items are intrinsics.\n-            Some(RootInlinedParent(_)) => Some(Abi::RustIntrinsic),\n             _ => None\n         };\n         match abi {\n@@ -737,11 +674,17 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn expect_inlined_body(&self, id: NodeId) -> &'ast Body {\n-        match self.find_entry(id) {\n-            Some(RootInlinedParent(inlined_item)) => &inlined_item.body,\n-            _ => bug!(\"expected inlined item, found {}\", self.node_to_string(id)),\n-        }\n+    pub fn get_inlined_body(&self, def_id: DefId) -> Option<&'ast Body> {\n+        self.inlined_bodies.borrow().get(&def_id).map(|&body| {\n+            self.dep_graph.read(DepNode::MetaData(def_id));\n+            body\n+        })\n+    }\n+\n+    pub fn intern_inlined_body(&self, def_id: DefId, body: Body) -> &'ast Body {\n+        let body = self.forest.inlined_bodies.alloc(body);\n+        self.inlined_bodies.borrow_mut().insert(def_id, body);\n+        body\n     }\n \n     /// Returns the name associated with the given NodeId's AST.\n@@ -824,7 +767,6 @@ impl<'ast> Map<'ast> {\n             Some(EntryVisibility(_, v)) => bug!(\"unexpected Visibility {:?}\", v),\n \n             Some(RootCrate) => self.forest.krate.span,\n-            Some(RootInlinedParent(parent)) => parent.body.value.span,\n             Some(NotPresent) | None => {\n                 bug!(\"hir::map::Map::span: id not in map: {:?}\", id)\n             }\n@@ -973,41 +915,15 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest,\n               entries, vector_length, (entries as f64 / vector_length as f64) * 100.);\n     }\n \n-    let local_node_id_watermark = NodeId::new(map.len());\n-\n     Map {\n         forest: forest,\n         dep_graph: forest.dep_graph.clone(),\n-        map: RefCell::new(map),\n+        map: map,\n         definitions: definitions,\n-        local_node_id_watermark: local_node_id_watermark,\n+        inlined_bodies: RefCell::new(DefIdMap()),\n     }\n }\n \n-/// Used for bodies loaded from external crate that are being inlined into this\n-/// crate.\n-pub fn map_decoded_body<'ast>(map: &Map<'ast>,\n-                              def_id: DefId,\n-                              body: Body,\n-                              parent_id: NodeId)\n-                              -> &'ast Body {\n-    let _ignore = map.forest.dep_graph.in_ignore();\n-\n-    let ii = map.forest.inlined_items.alloc(InlinedItem {\n-        def_id: def_id,\n-        body: body\n-    });\n-\n-    let mut collector = NodeCollector::extend(map.krate(),\n-                                              ii,\n-                                              parent_id,\n-                                              mem::replace(&mut *map.map.borrow_mut(), vec![]));\n-    collector.visit_body(&ii.body);\n-    *map.map.borrow_mut() = collector.map;\n-\n-    &ii.body\n-}\n-\n /// Identical to the `PpAnn` implementation for `hir::Crate`,\n /// except it avoids creating a dependency on the whole crate.\n impl<'ast> print::PpAnn for Map<'ast> {"}, {"sha": "b44e1563ee7ed64839a37013561808666a029e2e", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 139, "deletions": 53, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -27,7 +27,6 @@ use middle::region::CodeExtent;\n use middle::lang_items;\n use mir::tcx::LvalueTy;\n use ty::subst::{Kind, Subst, Substs};\n-use ty::adjustment;\n use ty::{TyVid, IntVid, FloatVid};\n use ty::{self, Ty, TyCtxt};\n use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n@@ -37,10 +36,11 @@ use traits::{self, ObligationCause, PredicateObligations, Reveal};\n use rustc_data_structures::unify::{self, UnificationTable};\n use std::cell::{Cell, RefCell, Ref, RefMut};\n use std::fmt;\n+use std::ops::Deref;\n use syntax::ast;\n use errors::DiagnosticBuilder;\n use syntax_pos::{self, Span, DUMMY_SP};\n-use util::nodemap::{FxHashMap, FxHashSet, NodeMap};\n+use util::nodemap::{FxHashMap, FxHashSet};\n use arena::DroplessArena;\n \n use self::combine::CombineFields;\n@@ -76,28 +76,63 @@ pub type Bound<T> = Option<T>;\n pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n pub type FixupResult<T> = Result<T, FixupError>; // \"fixup result\"\n \n-/// A version of &ty::Tables which can be global or local.\n-/// Only the local version supports borrow_mut.\n+/// A version of &ty::Tables which can be `Missing` (not needed),\n+/// `InProgress` (during typeck) or `Interned` (result of typeck).\n+/// Only the `InProgress` version supports `borrow_mut`.\n #[derive(Copy, Clone)]\n pub enum InferTables<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    Global(&'a RefCell<ty::Tables<'gcx>>),\n-    Local(&'a RefCell<ty::Tables<'tcx>>)\n+    Interned(&'a ty::Tables<'gcx>),\n+    InProgress(&'a RefCell<ty::Tables<'tcx>>),\n+    Missing\n+}\n+\n+pub enum InferTablesRef<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    Interned(&'a ty::Tables<'gcx>),\n+    InProgress(Ref<'a, ty::Tables<'tcx>>)\n+}\n+\n+impl<'a, 'gcx, 'tcx> Deref for InferTablesRef<'a, 'gcx, 'tcx> {\n+    type Target = ty::Tables<'tcx>;\n+    fn deref(&self) -> &Self::Target {\n+        match *self {\n+            InferTablesRef::Interned(tables) => tables,\n+            InferTablesRef::InProgress(ref tables) => tables\n+        }\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> InferTables<'a, 'gcx, 'tcx> {\n-    pub fn borrow(self) -> Ref<'a, ty::Tables<'tcx>> {\n+    pub fn borrow(self) -> InferTablesRef<'a, 'gcx, 'tcx> {\n         match self {\n-            InferTables::Global(tables) => tables.borrow(),\n-            InferTables::Local(tables) => tables.borrow()\n+            InferTables::Interned(tables) => InferTablesRef::Interned(tables),\n+            InferTables::InProgress(tables) => InferTablesRef::InProgress(tables.borrow()),\n+            InferTables::Missing => {\n+                bug!(\"InferTables: infcx.tables.borrow() with no tables\")\n+            }\n+        }\n+    }\n+\n+    pub fn expect_interned(self) -> &'a ty::Tables<'gcx> {\n+        match self {\n+            InferTables::Interned(tables) => tables,\n+            InferTables::InProgress(_) => {\n+                bug!(\"InferTables: infcx.tables.expect_interned() during type-checking\");\n+            }\n+            InferTables::Missing => {\n+                bug!(\"InferTables: infcx.tables.expect_interned() with no tables\")\n+            }\n         }\n     }\n \n     pub fn borrow_mut(self) -> RefMut<'a, ty::Tables<'tcx>> {\n         match self {\n-            InferTables::Global(_) => {\n+            InferTables::Interned(_) => {\n                 bug!(\"InferTables: infcx.tables.borrow_mut() outside of type-checking\");\n             }\n-            InferTables::Local(tables) => tables.borrow_mut()\n+            InferTables::InProgress(tables) => tables.borrow_mut(),\n+            InferTables::Missing => {\n+                bug!(\"InferTables: infcx.tables.borrow_mut() with no tables\")\n+            }\n         }\n     }\n }\n@@ -370,27 +405,84 @@ impl fmt::Display for FixupError {\n     }\n }\n \n+pub trait InferEnv<'a, 'tcx> {\n+    fn to_parts(self, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                -> (Option<&'a ty::Tables<'tcx>>,\n+                    Option<ty::Tables<'tcx>>,\n+                    Option<ty::ParameterEnvironment<'tcx>>);\n+}\n+\n+impl<'a, 'tcx> InferEnv<'a, 'tcx> for () {\n+    fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n+                -> (Option<&'a ty::Tables<'tcx>>,\n+                    Option<ty::Tables<'tcx>>,\n+                    Option<ty::ParameterEnvironment<'tcx>>) {\n+        (None, None, None)\n+    }\n+}\n+\n+impl<'a, 'tcx> InferEnv<'a, 'tcx> for ty::ParameterEnvironment<'tcx> {\n+    fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n+                -> (Option<&'a ty::Tables<'tcx>>,\n+                    Option<ty::Tables<'tcx>>,\n+                    Option<ty::ParameterEnvironment<'tcx>>) {\n+        (None, None, Some(self))\n+    }\n+}\n+\n+impl<'a, 'tcx> InferEnv<'a, 'tcx> for (&'a ty::Tables<'tcx>, ty::ParameterEnvironment<'tcx>) {\n+    fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n+                -> (Option<&'a ty::Tables<'tcx>>,\n+                    Option<ty::Tables<'tcx>>,\n+                    Option<ty::ParameterEnvironment<'tcx>>) {\n+        (Some(self.0), None, Some(self.1))\n+    }\n+}\n+\n+impl<'a, 'tcx> InferEnv<'a, 'tcx> for (ty::Tables<'tcx>, ty::ParameterEnvironment<'tcx>) {\n+    fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n+                -> (Option<&'a ty::Tables<'tcx>>,\n+                    Option<ty::Tables<'tcx>>,\n+                    Option<ty::ParameterEnvironment<'tcx>>) {\n+        (None, Some(self.0), Some(self.1))\n+    }\n+}\n+\n+impl<'a, 'tcx> InferEnv<'a, 'tcx> for hir::BodyId {\n+    fn to_parts(self, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                -> (Option<&'a ty::Tables<'tcx>>,\n+                    Option<ty::Tables<'tcx>>,\n+                    Option<ty::ParameterEnvironment<'tcx>>) {\n+        let item_id = tcx.map.body_owner(self);\n+        (Some(tcx.item_tables(tcx.map.local_def_id(item_id))),\n+         None,\n+         Some(ty::ParameterEnvironment::for_item(tcx, item_id)))\n+    }\n+}\n+\n /// Helper type of a temporary returned by tcx.infer_ctxt(...).\n /// Necessary because we can't write the following bound:\n /// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(InferCtxt<'b, 'gcx, 'tcx>).\n pub struct InferCtxtBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     global_tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     arena: DroplessArena,\n-    tables: Option<RefCell<ty::Tables<'tcx>>>,\n+    fresh_tables: Option<RefCell<ty::Tables<'tcx>>>,\n+    tables: Option<&'a ty::Tables<'gcx>>,\n     param_env: Option<ty::ParameterEnvironment<'gcx>>,\n     projection_mode: Reveal,\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n-    pub fn infer_ctxt(self,\n-                      tables: Option<ty::Tables<'tcx>>,\n-                      param_env: Option<ty::ParameterEnvironment<'gcx>>,\n-                      projection_mode: Reveal)\n-                      -> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n+    pub fn infer_ctxt<E: InferEnv<'a, 'gcx>>(self,\n+                                             env: E,\n+                                             projection_mode: Reveal)\n+                                             -> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n+        let (tables, fresh_tables, param_env) = env.to_parts(self);\n         InferCtxtBuilder {\n             global_tcx: self,\n             arena: DroplessArena::new(),\n-            tables: tables.map(RefCell::new),\n+            fresh_tables: fresh_tables.map(RefCell::new),\n+            tables: tables,\n             param_env: param_env,\n             projection_mode: projection_mode,\n         }\n@@ -399,16 +491,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n     /// Fake InferCtxt with the global tcx. Used by pre-MIR borrowck\n     /// for MemCategorizationContext/ExprUseVisitor.\n     /// If any inference functionality is used, ICEs will occur.\n-    pub fn borrowck_fake_infer_ctxt(self, param_env: ty::ParameterEnvironment<'gcx>)\n+    pub fn borrowck_fake_infer_ctxt(self, body: hir::BodyId)\n                                     -> InferCtxt<'a, 'gcx, 'gcx> {\n+        let (tables, _, param_env) = body.to_parts(self);\n         InferCtxt {\n             tcx: self,\n-            tables: InferTables::Global(&self.tables),\n+            tables: InferTables::Interned(tables.unwrap()),\n             type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n             int_unification_table: RefCell::new(UnificationTable::new()),\n             float_unification_table: RefCell::new(UnificationTable::new()),\n             region_vars: RegionVarBindings::new(self),\n-            parameter_environment: param_env,\n+            parameter_environment: param_env.unwrap(),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             projection_cache: RefCell::new(traits::ProjectionCache::new()),\n@@ -428,15 +521,14 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n         let InferCtxtBuilder {\n             global_tcx,\n             ref arena,\n-            ref tables,\n+            ref fresh_tables,\n+            tables,\n             ref mut param_env,\n             projection_mode,\n         } = *self;\n-        let tables = if let Some(ref tables) = *tables {\n-            InferTables::Local(tables)\n-        } else {\n-            InferTables::Global(&global_tcx.tables)\n-        };\n+        let tables = tables.map(InferTables::Interned).unwrap_or_else(|| {\n+            fresh_tables.as_ref().map_or(InferTables::Missing, InferTables::InProgress)\n+        });\n         let param_env = param_env.take().unwrap_or_else(|| {\n             global_tcx.empty_parameter_environment()\n         });\n@@ -555,7 +647,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             return value;\n         }\n \n-        self.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n+        self.infer_ctxt((), Reveal::All).enter(|infcx| {\n             value.trans_normalize(&infcx)\n         })\n     }\n@@ -573,7 +665,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             return value;\n         }\n \n-        self.infer_ctxt(None, Some(env.clone()), Reveal::All).enter(|infcx| {\n+        self.infer_ctxt(env.clone(), Reveal::All).enter(|infcx| {\n             value.trans_normalize(&infcx)\n        })\n     }\n@@ -1490,8 +1582,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // Even if the type may have no inference variables, during\n             // type-checking closure types are in local tables only.\n             let local_closures = match self.tables {\n-                InferTables::Local(_) => ty.has_closure_types(),\n-                InferTables::Global(_) => false\n+                InferTables::InProgress(_) => ty.has_closure_types(),\n+                _ => false\n             };\n             if !local_closures {\n                 return ty.moves_by_default(self.tcx.global_tcx(), self.param_env(), span);\n@@ -1526,15 +1618,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             .map(|method| method.def_id)\n     }\n \n-    pub fn adjustments(&self) -> Ref<NodeMap<adjustment::Adjustment<'tcx>>> {\n-        fn project_adjustments<'a, 'tcx>(tables: &'a ty::Tables<'tcx>)\n-                                        -> &'a NodeMap<adjustment::Adjustment<'tcx>> {\n-            &tables.adjustments\n-        }\n-\n-        Ref::map(self.tables.borrow(), project_adjustments)\n-    }\n-\n     pub fn is_method_call(&self, id: ast::NodeId) -> bool {\n         self.tables.borrow().method_map.contains_key(&ty::MethodCall::expr(id))\n     }\n@@ -1555,30 +1638,33 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         def_id: DefId)\n                         -> Option<ty::ClosureKind>\n     {\n-        if def_id.is_local() {\n-            self.tables.borrow().closure_kinds.get(&def_id).cloned()\n-        } else {\n-            // During typeck, ALL closures are local. But afterwards,\n-            // during trans, we see closure ids from other traits.\n-            // That may require loading the closure data out of the\n-            // cstore.\n-            Some(self.tcx.closure_kind(def_id))\n+        if let InferTables::InProgress(tables) = self.tables {\n+            if let Some(id) = self.tcx.map.as_local_node_id(def_id) {\n+                return tables.borrow().closure_kinds.get(&id).cloned();\n+            }\n         }\n+\n+        // During typeck, ALL closures are local. But afterwards,\n+        // during trans, we see closure ids from other traits.\n+        // That may require loading the closure data out of the\n+        // cstore.\n+        Some(self.tcx.closure_kind(def_id))\n     }\n \n     pub fn closure_type(&self,\n                         def_id: DefId,\n                         substs: ty::ClosureSubsts<'tcx>)\n                         -> ty::ClosureTy<'tcx>\n     {\n-        if let InferTables::Local(tables) = self.tables {\n-            if let Some(ty) = tables.borrow().closure_tys.get(&def_id) {\n-                return ty.subst(self.tcx, substs.substs);\n+        if let InferTables::InProgress(tables) = self.tables {\n+            if let Some(id) = self.tcx.map.as_local_node_id(def_id) {\n+                if let Some(ty) = tables.borrow().closure_tys.get(&id) {\n+                    return ty.subst(self.tcx, substs.substs);\n+                }\n             }\n         }\n \n-        let closure_ty = self.tcx.closure_type(def_id, substs);\n-        closure_ty\n+        self.tcx.closure_type(def_id, substs)\n     }\n }\n "}, {"sha": "f7f9a17ee51eee36f8040bca0f477b43fd286217", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -27,7 +27,7 @@ use self::TargetLint::*;\n \n use dep_graph::DepNode;\n use middle::privacy::AccessLevels;\n-use ty::TyCtxt;\n+use ty::{self, TyCtxt};\n use session::{config, early_error, Session};\n use lint::{Level, LevelSource, Lint, LintId, LintPass, LintSource};\n use lint::{EarlyLintPassObject, LateLintPassObject};\n@@ -336,6 +336,9 @@ pub struct LateContext<'a, 'tcx: 'a> {\n     /// Type context we're checking in.\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n+    /// Side-tables for the body we are in.\n+    pub tables: &'a ty::Tables<'tcx>,\n+\n     /// The crate being checked.\n     pub krate: &'a hir::Crate,\n \n@@ -703,22 +706,6 @@ impl<'a> EarlyContext<'a> {\n }\n \n impl<'a, 'tcx> LateContext<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-           krate: &'a hir::Crate,\n-           access_levels: &'a AccessLevels) -> LateContext<'a, 'tcx> {\n-        // We want to own the lint store, so move it out of the session.\n-        let lint_store = mem::replace(&mut *tcx.sess.lint_store.borrow_mut(),\n-                                      LintStore::new());\n-\n-        LateContext {\n-            tcx: tcx,\n-            krate: krate,\n-            access_levels: access_levels,\n-            lints: lint_store,\n-            level_stack: vec![],\n-        }\n-    }\n-\n     fn visit_ids<'b, F: 'b>(&'b mut self, f: F)\n         where F: FnOnce(&mut IdVisitor<'b, 'a, 'tcx>)\n     {\n@@ -795,6 +782,14 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         hir_visit::NestedVisitorMap::All(&self.tcx.map)\n     }\n \n+    fn visit_nested_body(&mut self, body: hir::BodyId) {\n+        let old_tables = self.tables;\n+        self.tables = self.tcx.body_tables(body);\n+        let body = self.tcx.map.body(body);\n+        self.visit_body(body);\n+        self.tables = old_tables;\n+    }\n+\n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_item, late_passes, it);\n@@ -837,10 +832,15 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n \n     fn visit_fn(&mut self, fk: hir_visit::FnKind<'tcx>, decl: &'tcx hir::FnDecl,\n                 body_id: hir::BodyId, span: Span, id: ast::NodeId) {\n+        // Wrap in tables here, not just in visit_nested_body,\n+        // in order for `check_fn` to be able to use them.\n+        let old_tables = self.tables;\n+        self.tables = self.tcx.body_tables(body_id);\n         let body = self.tcx.map.body(body_id);\n         run_lints!(self, check_fn, late_passes, fk, decl, body, span, id);\n         hir_visit::walk_fn(self, fk, decl, body_id, span, id);\n         run_lints!(self, check_fn_post, late_passes, fk, decl, body, span, id);\n+        self.tables = old_tables;\n     }\n \n     fn visit_variant_data(&mut self,\n@@ -1238,7 +1238,17 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let _task = tcx.dep_graph.in_task(DepNode::LateLintCheck);\n \n     let krate = tcx.map.krate();\n-    let mut cx = LateContext::new(tcx, krate, access_levels);\n+\n+    // We want to own the lint store, so move it out of the session.\n+    let lint_store = mem::replace(&mut *tcx.sess.lint_store.borrow_mut(), LintStore::new());\n+    let mut cx = LateContext {\n+        tcx: tcx,\n+        tables: &ty::Tables::empty(),\n+        krate: krate,\n+        access_levels: access_levels,\n+        lints: lint_store,\n+        level_stack: vec![],\n+    };\n \n     // Visit the whole crate.\n     cx.with_lint_attrs(&krate.attrs, |cx| {"}, {"sha": "f583f601726edc25319e49c90510ed7f1627a0c7", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -15,23 +15,21 @@ use hir::def_id::DefId;\n use rustc_const_math::*;\n use self::ConstVal::*;\n \n+use std::collections::BTreeMap;\n+\n #[derive(Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n pub enum ConstVal {\n     Float(ConstFloat),\n     Integral(ConstInt),\n     Str(InternedString),\n     ByteStr(Rc<Vec<u8>>),\n     Bool(bool),\n-    Struct(ast::NodeId),\n-    Tuple(ast::NodeId),\n     Function(DefId),\n-    Array(ast::NodeId, u64),\n-    Repeat(ast::NodeId, u64),\n+    Struct(BTreeMap<ast::Name, ConstVal>),\n+    Tuple(Vec<ConstVal>),\n+    Array(Vec<ConstVal>),\n+    Repeat(Box<ConstVal>, u64),\n     Char(char),\n-    /// A value that only occurs in case `eval_const_expr` reported an error. You should never\n-    /// handle this case. Its sole purpose is to allow more errors to be reported instead of\n-    /// causing a fatal error.\n-    Dummy,\n }\n \n impl ConstVal {\n@@ -48,7 +46,6 @@ impl ConstVal {\n             Array(..) => \"array\",\n             Repeat(..) => \"repeat\",\n             Char(..) => \"char\",\n-            Dummy => \"dummy value\",\n         }\n     }\n }"}, {"sha": "5af62d0172f5cad4ca88f09713248097b8877eff", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -49,6 +49,7 @@ fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n     worklist: Vec<ast::NodeId>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tables: &'a ty::Tables<'tcx>,\n     live_symbols: Box<FxHashSet<ast::NodeId>>,\n     struct_has_extern_repr: bool,\n     ignore_non_const_paths: bool,\n@@ -57,19 +58,6 @@ struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-           worklist: Vec<ast::NodeId>) -> MarkSymbolVisitor<'a, 'tcx> {\n-        MarkSymbolVisitor {\n-            worklist: worklist,\n-            tcx: tcx,\n-            live_symbols: box FxHashSet(),\n-            struct_has_extern_repr: false,\n-            ignore_non_const_paths: false,\n-            inherited_pub_visibility: false,\n-            ignore_variant_stack: vec![],\n-        }\n-    }\n-\n     fn check_def_id(&mut self, def_id: DefId) {\n         if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n             if should_explore(self.tcx, node_id) {\n@@ -109,12 +97,12 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn lookup_and_handle_method(&mut self, id: ast::NodeId) {\n         let method_call = ty::MethodCall::expr(id);\n-        let method = self.tcx.tables().method_map[&method_call];\n+        let method = self.tables.method_map[&method_call];\n         self.check_def_id(method.def_id);\n     }\n \n     fn handle_field_access(&mut self, lhs: &hir::Expr, name: ast::Name) {\n-        match self.tcx.tables().expr_ty_adjusted(lhs).sty {\n+        match self.tables.expr_ty_adjusted(lhs).sty {\n             ty::TyAdt(def, _) => {\n                 self.insert_def_id(def.struct_variant().field_named(name).did);\n             }\n@@ -123,7 +111,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn handle_tup_field_access(&mut self, lhs: &hir::Expr, idx: usize) {\n-        match self.tcx.tables().expr_ty_adjusted(lhs).sty {\n+        match self.tables.expr_ty_adjusted(lhs).sty {\n             ty::TyAdt(def, _) => {\n                 self.insert_def_id(def.struct_variant().fields[idx].did);\n             }\n@@ -134,7 +122,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_field_pattern_match(&mut self, lhs: &hir::Pat, def: Def,\n                                   pats: &[codemap::Spanned<hir::FieldPat>]) {\n-        let variant = match self.tcx.tables().node_id_to_type(lhs.id).sty {\n+        let variant = match self.tables.node_id_to_type(lhs.id).sty {\n             ty::TyAdt(adt, _) => adt.variant_of_def(def),\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\")\n         };\n@@ -209,7 +197,15 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_nested_body(&mut self, body: hir::BodyId) {\n+        let old_tables = self.tables;\n+        self.tables = self.tcx.body_tables(body);\n+        let body = self.tcx.map.body(body);\n+        self.visit_body(body);\n+        self.tables = old_tables;\n     }\n \n     fn visit_variant_data(&mut self, def: &'tcx hir::VariantData, _: ast::Name,\n@@ -227,7 +223,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprPath(ref qpath @ hir::QPath::TypeRelative(..)) => {\n-                let def = self.tcx.tables().qpath_def(qpath, expr.id);\n+                let def = self.tables.qpath_def(qpath, expr.id);\n                 self.handle_definition(def);\n             }\n             hir::ExprMethodCall(..) => {\n@@ -267,7 +263,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n                 self.handle_field_pattern_match(pat, path.def, fields);\n             }\n             PatKind::Path(ref qpath @ hir::QPath::TypeRelative(..)) => {\n-                let def = self.tcx.tables().qpath_def(qpath, pat.id);\n+                let def = self.tables.qpath_def(qpath, pat.id);\n                 self.handle_definition(def);\n             }\n             _ => ()\n@@ -393,7 +389,16 @@ fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        krate: &hir::Crate)\n                        -> Box<FxHashSet<ast::NodeId>> {\n     let worklist = create_and_seed_worklist(tcx, access_levels, krate);\n-    let mut symbol_visitor = MarkSymbolVisitor::new(tcx, worklist);\n+    let mut symbol_visitor = MarkSymbolVisitor {\n+        worklist: worklist,\n+        tcx: tcx,\n+        tables: &ty::Tables::empty(),\n+        live_symbols: box FxHashSet(),\n+        struct_has_extern_repr: false,\n+        ignore_non_const_paths: false,\n+        inherited_pub_visibility: false,\n+        ignore_variant_stack: vec![],\n+    };\n     symbol_visitor.mark_live_symbols();\n     symbol_visitor.live_symbols\n }"}, {"sha": "c42e8fcb08ced9906e7a7f4ef1631859f15abe42", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -52,6 +52,7 @@ fn type_is_unsafe_function(ty: Ty) -> bool {\n \n struct EffectCheckVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tables: &'a ty::Tables<'tcx>,\n \n     /// Whether we're in an unsafe context.\n     unsafe_context: UnsafeContext,\n@@ -94,7 +95,15 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_nested_body(&mut self, body: hir::BodyId) {\n+        let old_tables = self.tables;\n+        self.tables = self.tcx.body_tables(body);\n+        let body = self.tcx.map.body(body);\n+        self.visit_body(body);\n+        self.tables = old_tables;\n     }\n \n     fn visit_fn(&mut self, fn_kind: FnKind<'tcx>, fn_decl: &'tcx hir::FnDecl,\n@@ -163,7 +172,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n                 let method_call = MethodCall::expr(expr.id);\n-                let base_type = self.tcx.tables().method_map[&method_call].ty;\n+                let base_type = self.tables.method_map[&method_call].ty;\n                 debug!(\"effect: method call case, base type is {:?}\",\n                         base_type);\n                 if type_is_unsafe_function(base_type) {\n@@ -172,15 +181,15 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ExprCall(ref base, _) => {\n-                let base_type = self.tcx.tables().expr_ty_adjusted(base);\n+                let base_type = self.tables.expr_ty_adjusted(base);\n                 debug!(\"effect: call case, base type is {:?}\",\n                         base_type);\n                 if type_is_unsafe_function(base_type) {\n                     self.require_unsafe(expr.span, \"call to unsafe function\")\n                 }\n             }\n             hir::ExprUnary(hir::UnDeref, ref base) => {\n-                let base_type = self.tcx.tables().expr_ty_adjusted(base);\n+                let base_type = self.tables.expr_ty_adjusted(base);\n                 debug!(\"effect: unary case, base type is {:?}\",\n                         base_type);\n                 if let ty::TyRawPtr(_) = base_type.sty {\n@@ -204,7 +213,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ExprField(ref base_expr, field) => {\n-                if let ty::TyAdt(adt, ..) = self.tcx.tables().expr_ty_adjusted(base_expr).sty {\n+                if let ty::TyAdt(adt, ..) = self.tables.expr_ty_adjusted(base_expr).sty {\n                     if adt.is_union() {\n                         self.require_unsafe(field.span, \"access to union field\");\n                     }\n@@ -218,7 +227,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n \n     fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n         if let PatKind::Struct(_, ref fields, _) = pat.node {\n-            if let ty::TyAdt(adt, ..) = self.tcx.tables().pat_ty(pat).sty {\n+            if let ty::TyAdt(adt, ..) = self.tables.pat_ty(pat).sty {\n                 if adt.is_union() {\n                     for field in fields {\n                         self.require_unsafe(field.span, \"matching on union field\");\n@@ -236,6 +245,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n     let mut visitor = EffectCheckVisitor {\n         tcx: tcx,\n+        tables: &ty::Tables::empty(),\n         unsafe_context: UnsafeContext::new(SafeContext),\n     };\n "}, {"sha": "0eacbba3fdd446ec4d100b4c3a7f80b5ec298cb2", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -708,7 +708,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     fn walk_adjustment(&mut self, expr: &hir::Expr) {\n         let infcx = self.mc.infcx;\n         //NOTE(@jroesch): mixed RefCell borrow causes crash\n-        let adj = infcx.adjustments().get(&expr.id).map(|x| x.clone());\n+        let adj = infcx.tables.borrow().adjustments.get(&expr.id).map(|x| x.clone());\n         if let Some(adjustment) = adj {\n             match adjustment.kind {\n                 adjustment::Adjust::NeverToAny |\n@@ -989,7 +989,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 PatKind::Struct(ref qpath, ..) => qpath,\n                 _ => return\n             };\n-            let def = tcx.tables().qpath_def(qpath, pat.id);\n+            let def = infcx.tables.borrow().qpath_def(qpath, pat.id);\n             match def {\n                 Def::Variant(variant_did) |\n                 Def::VariantCtor(variant_did, ..) => {"}, {"sha": "d42b866d47209c5663692c12570a6c78e95158e0", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 10, "deletions": 50, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -19,7 +19,7 @@ use ty::layout::{LayoutError, Pointer, SizeSkeleton};\n use syntax::abi::Abi::RustIntrinsic;\n use syntax::ast;\n use syntax_pos::Span;\n-use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n+use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir;\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n@@ -33,18 +33,6 @@ struct ItemVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>\n }\n \n-impl<'a, 'tcx> ItemVisitor<'a, 'tcx> {\n-    fn visit_const(&mut self, item_id: ast::NodeId, body: hir::BodyId) {\n-        let param_env = ty::ParameterEnvironment::for_item(self.tcx, item_id);\n-        self.tcx.infer_ctxt(None, Some(param_env), Reveal::All).enter(|infcx| {\n-            let mut visitor = ExprVisitor {\n-                infcx: &infcx\n-            };\n-            visitor.visit_nested_body(body);\n-        });\n-    }\n-}\n-\n struct ExprVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>\n }\n@@ -118,64 +106,36 @@ impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for ItemVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+        NestedVisitorMap::None\n     }\n \n-    // const, static and N in [T; N].\n-    fn visit_body(&mut self, body: &'tcx hir::Body) {\n-        self.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n+    fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n+        let body = self.tcx.map.body(body_id);\n+        self.tcx.infer_ctxt(body_id, Reveal::All).enter(|infcx| {\n             let mut visitor = ExprVisitor {\n                 infcx: &infcx\n             };\n             visitor.visit_body(body);\n         });\n-    }\n-\n-    fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n-        if let hir::TraitItemKind::Const(_, Some(body)) = item.node {\n-            self.visit_const(item.id, body);\n-        } else {\n-            intravisit::walk_trait_item(self, item);\n-        }\n-    }\n-\n-    fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n-        if let hir::ImplItemKind::Const(_, body) = item.node {\n-            self.visit_const(item.id, body);\n-        } else {\n-            intravisit::walk_impl_item(self, item);\n-        }\n-    }\n-\n-    fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n-                b: hir::BodyId, s: Span, id: ast::NodeId) {\n-        if let FnKind::Closure(..) = fk {\n-            span_bug!(s, \"intrinsicck: closure outside of function\")\n-        }\n-        let param_env = ty::ParameterEnvironment::for_item(self.tcx, id);\n-        self.tcx.infer_ctxt(None, Some(param_env), Reveal::All).enter(|infcx| {\n-            let mut visitor = ExprVisitor {\n-                infcx: &infcx\n-            };\n-            visitor.visit_fn(fk, fd, b, s, id);\n-        });\n+        self.visit_body(body);\n     }\n }\n \n impl<'a, 'gcx, 'tcx> Visitor<'gcx> for ExprVisitor<'a, 'gcx, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n-        NestedVisitorMap::OnlyBodies(&self.infcx.tcx.map)\n+        NestedVisitorMap::None\n     }\n \n     fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n         let def = if let hir::ExprPath(ref qpath) = expr.node {\n-            self.infcx.tcx.tables().qpath_def(qpath, expr.id)\n+            self.infcx.tables.borrow().qpath_def(qpath, expr.id)\n         } else {\n             Def::Err\n         };\n         match def {\n             Def::Fn(did) if self.def_id_is_transmute(did) => {\n-                let typ = self.infcx.tcx.tables().node_id_to_type(expr.id);\n+                let typ = self.infcx.tables.borrow().node_id_to_type(expr.id);\n+                let typ = self.infcx.tcx.lift_to_global(&typ).unwrap();\n                 match typ.sty {\n                     ty::TyFnDef(.., ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n                         let from = bare_fn_ty.sig.skip_binder().inputs()[0];"}, {"sha": "5307b4ec774524e85958893d782f62c8263f3159", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 42, "deletions": 43, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -351,22 +351,6 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for Liveness<'a, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_local(&mut self, l: &'tcx hir::Local) {\n-        check_local(self, l);\n-    }\n-    fn visit_expr(&mut self, ex: &'tcx Expr) {\n-        check_expr(self, ex);\n-    }\n-    fn visit_arm(&mut self, a: &'tcx hir::Arm) {\n-        check_arm(self, a);\n-    }\n-}\n-\n fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n                           fk: FnKind<'tcx>,\n                           decl: &'tcx hir::FnDecl,\n@@ -394,24 +378,13 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n     // and so forth:\n     intravisit::walk_fn(&mut fn_maps, fk, decl, body_id, sp, id);\n \n-    // Special nodes and variables:\n-    // - exit_ln represents the end of the fn, either by return or panic\n-    // - implicit_ret_var is a pseudo-variable that represents\n-    //   an implicit return\n-    let specials = Specials {\n-        exit_ln: fn_maps.add_live_node(ExitNode),\n-        fallthrough_ln: fn_maps.add_live_node(ExitNode),\n-        no_ret_var: fn_maps.add_variable(ImplicitRet),\n-        clean_exit_var: fn_maps.add_variable(CleanExit)\n-    };\n-\n     // compute liveness\n-    let mut lsets = Liveness::new(&mut fn_maps, specials);\n+    let mut lsets = Liveness::new(&mut fn_maps, body_id);\n     let entry_ln = lsets.compute(&body.value);\n \n     // check for various error conditions\n     lsets.visit_body(body);\n-    lsets.check_ret(id, sp, fk, entry_ln, body);\n+    lsets.check_ret(id, sp, entry_ln, body);\n     lsets.warn_about_unused_args(body, entry_ln);\n }\n \n@@ -539,6 +512,7 @@ const ACC_USE: u32 = 4;\n \n struct Liveness<'a, 'tcx: 'a> {\n     ir: &'a mut IrMaps<'a, 'tcx>,\n+    tables: &'a ty::Tables<'tcx>,\n     s: Specials,\n     successors: Vec<LiveNode>,\n     users: Vec<Users>,\n@@ -553,11 +527,26 @@ struct Liveness<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n-    fn new(ir: &'a mut IrMaps<'a, 'tcx>, specials: Specials) -> Liveness<'a, 'tcx> {\n+    fn new(ir: &'a mut IrMaps<'a, 'tcx>, body: hir::BodyId) -> Liveness<'a, 'tcx> {\n+        // Special nodes and variables:\n+        // - exit_ln represents the end of the fn, either by return or panic\n+        // - implicit_ret_var is a pseudo-variable that represents\n+        //   an implicit return\n+        let specials = Specials {\n+            exit_ln: ir.add_live_node(ExitNode),\n+            fallthrough_ln: ir.add_live_node(ExitNode),\n+            no_ret_var: ir.add_variable(ImplicitRet),\n+            clean_exit_var: ir.add_variable(CleanExit)\n+        };\n+\n+        let tables = ir.tcx.body_tables(body);\n+\n         let num_live_nodes = ir.num_live_nodes;\n         let num_vars = ir.num_vars;\n+\n         Liveness {\n             ir: ir,\n+            tables: tables,\n             s: specials,\n             successors: vec![invalid_node(); num_live_nodes],\n             users: vec![invalid_users(); num_live_nodes * num_vars],\n@@ -1065,7 +1054,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprAssignOp(_, ref l, ref r) => {\n             // an overloaded assign op is like a method call\n-            if self.ir.tcx.tables().is_method_call(expr.id) {\n+            if self.tables.is_method_call(expr.id) {\n                 let succ = self.propagate_through_expr(&l, succ);\n                 self.propagate_through_expr(&r, succ)\n             } else {\n@@ -1092,8 +1081,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprCall(ref f, ref args) => {\n             // FIXME(canndrew): This is_never should really be an is_uninhabited\n-            let diverges = !self.ir.tcx.tables().is_method_call(expr.id) &&\n-                self.ir.tcx.tables().expr_ty_adjusted(&f).fn_ret().0.is_never();\n+            let diverges = !self.tables.is_method_call(expr.id) &&\n+                self.tables.expr_ty_adjusted(&f).fn_ret().0.is_never();\n             let succ = if diverges {\n                 self.s.exit_ln\n             } else {\n@@ -1105,7 +1094,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprMethodCall(.., ref args) => {\n             let method_call = ty::MethodCall::expr(expr.id);\n-            let method_ty = self.ir.tcx.tables().method_map[&method_call].ty;\n+            let method_ty = self.tables.method_map[&method_call].ty;\n             // FIXME(canndrew): This is_never should really be an is_uninhabited\n             let succ = if method_ty.fn_ret().0.is_never() {\n                 self.s.exit_ln\n@@ -1355,6 +1344,22 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n // _______________________________________________________________________\n // Checking for error conditions\n \n+impl<'a, 'tcx> Visitor<'tcx> for Liveness<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_local(&mut self, l: &'tcx hir::Local) {\n+        check_local(self, l);\n+    }\n+    fn visit_expr(&mut self, ex: &'tcx Expr) {\n+        check_expr(self, ex);\n+    }\n+    fn visit_arm(&mut self, a: &'tcx hir::Arm) {\n+        check_arm(self, a);\n+    }\n+}\n+\n fn check_local<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, local: &'tcx hir::Local) {\n     match local.init {\n         Some(_) => {\n@@ -1389,7 +1394,7 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n       }\n \n       hir::ExprAssignOp(_, ref l, _) => {\n-        if !this.ir.tcx.tables().is_method_call(expr.id) {\n+        if !this.tables.is_method_call(expr.id) {\n             this.check_lvalue(&l);\n         }\n \n@@ -1432,15 +1437,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn check_ret(&self,\n                  id: NodeId,\n                  sp: Span,\n-                 fk: FnKind,\n                  entry_ln: LiveNode,\n                  body: &hir::Body)\n     {\n-        let fn_ty = if let FnKind::Closure(_) = fk {\n-            self.ir.tcx.tables().node_id_to_type(id)\n-        } else {\n-            self.ir.tcx.item_type(self.ir.tcx.map.local_def_id(id))\n-        };\n+        let fn_ty = self.ir.tcx.item_type(self.ir.tcx.map.local_def_id(id));\n         let fn_ret = match fn_ty.sty {\n             ty::TyClosure(closure_def_id, substs) =>\n                 self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n@@ -1457,8 +1457,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         if !fn_ret.is_never() && self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n             let param_env = ParameterEnvironment::for_item(self.ir.tcx, id);\n             let t_ret_subst = fn_ret.subst(self.ir.tcx, &param_env.free_substs);\n-            let is_nil = self.ir.tcx.infer_ctxt(None, Some(param_env),\n-                                                Reveal::All).enter(|infcx| {\n+            let is_nil = self.ir.tcx.infer_ctxt(param_env, Reveal::All).enter(|infcx| {\n                 let cause = traits::ObligationCause::dummy();\n                 traits::fully_normalize(&infcx, cause, &t_ret_subst).unwrap().is_nil()\n             });"}, {"sha": "92e69d7d729578092ed1b927f5ffd1a31ae42db3", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -384,7 +384,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn cat_expr(&self, expr: &hir::Expr) -> McResult<cmt<'tcx>> {\n-        match self.infcx.adjustments().get(&expr.id) {\n+        match self.infcx.tables.borrow().adjustments.get(&expr.id) {\n             None => {\n                 // No adjustments.\n                 self.cat_expr_unadjusted(expr)"}, {"sha": "6eaf3448d0284c28dbd8b018015da37a490cffcc", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -79,6 +79,7 @@ fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n struct ReachableContext<'a, 'tcx: 'a> {\n     // The type context.\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tables: &'a ty::Tables<'tcx>,\n     // The set of items which must be exported in the linkage sense.\n     reachable_symbols: NodeSet,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n@@ -90,17 +91,25 @@ struct ReachableContext<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_nested_body(&mut self, body: hir::BodyId) {\n+        let old_tables = self.tables;\n+        self.tables = self.tcx.body_tables(body);\n+        let body = self.tcx.map.body(body);\n+        self.visit_body(body);\n+        self.tables = old_tables;\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         let def = match expr.node {\n             hir::ExprPath(ref qpath) => {\n-                Some(self.tcx.tables().qpath_def(qpath, expr.id))\n+                Some(self.tables.qpath_def(qpath, expr.id))\n             }\n             hir::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                let def_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n+                let def_id = self.tables.method_map[&method_call].def_id;\n                 Some(Def::Method(def_id))\n             }\n             _ => None\n@@ -135,20 +144,6 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n-    // Creates a new reachability computation context.\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ReachableContext<'a, 'tcx> {\n-        let any_library = tcx.sess.crate_types.borrow().iter().any(|ty| {\n-            *ty == config::CrateTypeRlib || *ty == config::CrateTypeDylib ||\n-            *ty == config::CrateTypeProcMacro\n-        });\n-        ReachableContext {\n-            tcx: tcx,\n-            reachable_symbols: NodeSet(),\n-            worklist: Vec::new(),\n-            any_library: any_library,\n-        }\n-    }\n-\n     // Returns true if the given def ID represents a local item that is\n     // eligible for inlining and false otherwise.\n     fn def_id_represents_local_inlined_item(&self, def_id: DefId) -> bool {\n@@ -369,7 +364,17 @@ pub fn find_reachable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 -> NodeSet {\n     let _task = tcx.dep_graph.in_task(DepNode::Reachability);\n \n-    let mut reachable_context = ReachableContext::new(tcx);\n+    let any_library = tcx.sess.crate_types.borrow().iter().any(|ty| {\n+        *ty == config::CrateTypeRlib || *ty == config::CrateTypeDylib ||\n+        *ty == config::CrateTypeProcMacro\n+    });\n+    let mut reachable_context = ReachableContext {\n+        tcx: tcx,\n+        tables: &ty::Tables::empty(),\n+        reachable_symbols: NodeSet(),\n+        worklist: Vec::new(),\n+        any_library: any_library,\n+    };\n \n     // Step 1: Seed the worklist with all nodes which were found to be public as\n     //         a result of the privacy pass along with all local lang items and impl items."}, {"sha": "5bae0e347f7c40cc7369070d2bbd773735f55325", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -29,7 +29,7 @@ use std::fmt::{self, Debug, Formatter, Write};\n use std::{iter, u32};\n use std::ops::{Index, IndexMut};\n use std::vec::IntoIter;\n-use syntax::ast::{self, Name};\n+use syntax::ast::Name;\n use syntax_pos::Span;\n \n mod cache;\n@@ -1271,17 +1271,12 @@ fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ConstVal) -> fmt::Result {\n         }\n         Bool(b) => write!(fmt, \"{:?}\", b),\n         Function(def_id) => write!(fmt, \"{}\", item_path_str(def_id)),\n-        Struct(node_id) | Tuple(node_id) | Array(node_id, _) | Repeat(node_id, _) =>\n-            write!(fmt, \"{}\", node_to_string(node_id)),\n+        Struct(_) | Tuple(_) | Array(_) | Repeat(..) =>\n+            bug!(\"ConstVal `{:?}` should not be in MIR\", const_val),\n         Char(c) => write!(fmt, \"{:?}\", c),\n-        Dummy => bug!(),\n     }\n }\n \n-fn node_to_string(node_id: ast::NodeId) -> String {\n-    ty::tls::with(|tcx| tcx.map.node_to_user_string(node_id))\n-}\n-\n fn item_path_str(def_id: DefId) -> String {\n     ty::tls::with(|tcx| tcx.item_path_str(def_id))\n }"}, {"sha": "4893e240911273cf6e7954486f8186a826fb104d", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -474,7 +474,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let elaborated_env = unnormalized_env.with_caller_bounds(predicates);\n \n-    tcx.infer_ctxt(None, Some(elaborated_env), Reveal::NotSpecializable).enter(|infcx| {\n+    tcx.infer_ctxt(elaborated_env, Reveal::NotSpecializable).enter(|infcx| {\n         let predicates = match fully_normalize(&infcx, cause,\n                                                &infcx.parameter_environment.caller_bounds) {\n             Ok(predicates) => predicates,\n@@ -576,7 +576,7 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"normalize_and_test_predicates(predicates={:?})\",\n            predicates);\n \n-    tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n+    tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n         let mut selcx = SelectionContext::new(&infcx);\n         let mut fulfill_cx = FulfillmentContext::new();\n         let cause = ObligationCause::dummy();"}, {"sha": "0fe054b30ba3174a1c1bfa3cbe6b6fbc0d1bc51f", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -123,7 +123,7 @@ pub fn find_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let ancestors = trait_def.ancestors(impl_data.impl_def_id);\n     match ancestors.defs(tcx, name, ty::AssociatedKind::Method).next() {\n         Some(node_item) => {\n-            let substs = tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n+            let substs = tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n                 let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n                 let substs = translate_substs(&infcx, impl_data.impl_def_id,\n                                               substs, node_item.node);\n@@ -189,7 +189,7 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              .subst(tcx, &penv.free_substs);\n \n     // Create a infcx, taking the predicates of impl1 as assumptions:\n-    let result = tcx.infer_ctxt(None, Some(penv), Reveal::ExactMatch).enter(|infcx| {\n+    let result = tcx.infer_ctxt(penv, Reveal::ExactMatch).enter(|infcx| {\n         // Normalize the trait reference. The WF rules ought to ensure\n         // that this always succeeds.\n         let impl1_trait_ref ="}, {"sha": "368b1fb4bcbd38ca4d61e0356fa993a2a19b860c", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -108,7 +108,7 @@ impl<'a, 'gcx, 'tcx> Children {\n             let possible_sibling = *slot;\n \n             let tcx = tcx.global_tcx();\n-            let (le, ge) = tcx.infer_ctxt(None, None, Reveal::ExactMatch).enter(|infcx| {\n+            let (le, ge) = tcx.infer_ctxt((), Reveal::ExactMatch).enter(|infcx| {\n                 let overlap = traits::overlapping_impls(&infcx,\n                                                         possible_sibling,\n                                                         impl_def_id);"}, {"sha": "3df64ebd1581b66237b088c3d5d7d30f473e531f", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -65,6 +65,7 @@ pub struct GlobalArenas<'tcx> {\n     trait_def: TypedArena<ty::TraitDef>,\n     adt_def: TypedArena<ty::AdtDef>,\n     mir: TypedArena<RefCell<Mir<'tcx>>>,\n+    tables: TypedArena<ty::Tables<'tcx>>,\n }\n \n impl<'tcx> GlobalArenas<'tcx> {\n@@ -75,6 +76,7 @@ impl<'tcx> GlobalArenas<'tcx> {\n             trait_def: TypedArena::new(),\n             adt_def: TypedArena::new(),\n             mir: TypedArena::new(),\n+            tables: TypedArena::new(),\n         }\n     }\n }\n@@ -189,6 +191,7 @@ pub struct CommonTypes<'tcx> {\n     pub err: Ty<'tcx>,\n }\n \n+#[derive(RustcEncodable, RustcDecodable)]\n pub struct Tables<'tcx> {\n     /// Resolved definitions for `<T>::X` associated paths.\n     pub type_relative_path_defs: NodeMap<Def>,\n@@ -211,13 +214,11 @@ pub struct Tables<'tcx> {\n     /// Borrows\n     pub upvar_capture_map: ty::UpvarCaptureMap<'tcx>,\n \n-    /// Records the type of each closure. The def ID is the ID of the\n-    /// expression defining the closure.\n-    pub closure_tys: DefIdMap<ty::ClosureTy<'tcx>>,\n+    /// Records the type of each closure.\n+    pub closure_tys: NodeMap<ty::ClosureTy<'tcx>>,\n \n-    /// Records the type of each closure. The def ID is the ID of the\n-    /// expression defining the closure.\n-    pub closure_kinds: DefIdMap<ty::ClosureKind>,\n+    /// Records the type of each closure.\n+    pub closure_kinds: NodeMap<ty::ClosureKind>,\n \n     /// For each fn, records the \"liberated\" types of its arguments\n     /// and return type. Liberated means that all bound regions\n@@ -233,7 +234,7 @@ pub struct Tables<'tcx> {\n     pub fru_field_types: NodeMap<Vec<Ty<'tcx>>>\n }\n \n-impl<'a, 'gcx, 'tcx> Tables<'tcx> {\n+impl<'tcx> Tables<'tcx> {\n     pub fn empty() -> Tables<'tcx> {\n         Tables {\n             type_relative_path_defs: NodeMap(),\n@@ -242,8 +243,8 @@ impl<'a, 'gcx, 'tcx> Tables<'tcx> {\n             adjustments: NodeMap(),\n             method_map: FxHashMap(),\n             upvar_capture_map: FxHashMap(),\n-            closure_tys: DefIdMap(),\n-            closure_kinds: DefIdMap(),\n+            closure_tys: NodeMap(),\n+            closure_kinds: NodeMap(),\n             liberated_fn_sigs: NodeMap(),\n             fru_field_types: NodeMap()\n         }\n@@ -401,7 +402,7 @@ pub struct GlobalCtxt<'tcx> {\n     free_region_maps: RefCell<NodeMap<FreeRegionMap>>,\n     // FIXME: jroesch make this a refcell\n \n-    pub tables: RefCell<Tables<'tcx>>,\n+    pub tables: RefCell<DepTrackingMap<maps::Tables<'tcx>>>,\n \n     /// Maps from a trait item to the trait item \"descriptor\"\n     pub associated_items: RefCell<DepTrackingMap<maps::AssociatedItems<'tcx>>>,\n@@ -524,6 +525,14 @@ pub struct GlobalCtxt<'tcx> {\n     /// Caches CoerceUnsized kinds for impls on custom types.\n     pub custom_coerce_unsized_kinds: RefCell<DefIdMap<ty::adjustment::CustomCoerceUnsized>>,\n \n+    /// Records the type of each closure. The def ID is the ID of the\n+    /// expression defining the closure.\n+    pub closure_tys: RefCell<DepTrackingMap<maps::ClosureTypes<'tcx>>>,\n+\n+    /// Records the type of each closure. The def ID is the ID of the\n+    /// expression defining the closure.\n+    pub closure_kinds: RefCell<DepTrackingMap<maps::ClosureKinds<'tcx>>>,\n+\n     /// Maps a cast expression to its kind. This is keyed on the\n     /// *from* expression of the cast, not the cast itself.\n     pub cast_kinds: RefCell<NodeMap<ty::cast::CastKind>>,\n@@ -645,6 +654,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.global_arenas.mir.alloc(RefCell::new(mir))\n     }\n \n+    pub fn alloc_tables(self, tables: ty::Tables<'gcx>) -> &'gcx ty::Tables<'gcx> {\n+        self.global_arenas.tables.alloc(tables)\n+    }\n+\n     pub fn alloc_trait_def(self, def: ty::TraitDef) -> &'gcx ty::TraitDef {\n         self.global_arenas.trait_def.alloc(def)\n     }\n@@ -743,7 +756,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             variance_computed: Cell::new(false),\n             sess: s,\n             trait_map: resolutions.trait_map,\n-            tables: RefCell::new(Tables::empty()),\n+            tables: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             impl_trait_refs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             trait_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             adt_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n@@ -777,6 +790,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             repr_hint_cache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             rvalue_promotable_to_static: RefCell::new(NodeMap()),\n             custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n+            closure_tys: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            closure_kinds: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             cast_kinds: RefCell::new(NodeMap()),\n             fragment_infos: RefCell::new(DefIdMap()),\n             crate_name: Symbol::intern(crate_name),"}, {"sha": "59d22d270b15d49f946af7ec5b272586d8078ea4", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -46,3 +46,6 @@ dep_map_ty! { ItemVariances: ItemSignature(DefId) -> Rc<Vec<ty::Variance>> }\n dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Vec<DefId> }\n dep_map_ty! { ReprHints: ReprHints(DefId) -> Rc<Vec<attr::ReprAttr>> }\n dep_map_ty! { Mir: Mir(DefId) -> &'tcx RefCell<mir::Mir<'tcx>> }\n+dep_map_ty! { ClosureKinds: ItemSignature(DefId) -> ty::ClosureKind }\n+dep_map_ty! { ClosureTypes: ItemSignature(DefId) -> ty::ClosureTy<'tcx> }\n+dep_map_ty! { Tables: Tables(DefId) -> &'tcx ty::Tables<'tcx> }"}, {"sha": "a88b1e3ece9641b1ffdc80bf44ad9edb0b780246", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -321,7 +321,7 @@ pub struct MethodCallee<'tcx> {\n /// needed to add to the side tables. Thus to disambiguate\n /// we also keep track of whether there's an adjustment in\n /// our key.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct MethodCall {\n     pub expr_id: NodeId,\n     pub autoderef: u32\n@@ -501,7 +501,7 @@ impl<T> Slice<T> {\n /// Upvars do not get their own node-id. Instead, we use the pair of\n /// the original var id (that is, the root variable that is referenced\n /// by the upvar) and the id of the closure expression.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct UpvarId {\n     pub var_id: NodeId,\n     pub closure_expr_id: NodeId,\n@@ -1917,8 +1917,30 @@ impl BorrowKind {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn tables(self) -> Ref<'a, Tables<'gcx>> {\n-        self.tables.borrow()\n+    pub fn body_tables(self, body: hir::BodyId) -> &'gcx Tables<'gcx> {\n+        self.item_tables(self.map.body_owner_def_id(body))\n+    }\n+\n+    pub fn item_tables(self, def_id: DefId) -> &'gcx Tables<'gcx> {\n+        self.tables.memoize(def_id, || {\n+            if def_id.is_local() {\n+                // Closures' tables come from their outermost function,\n+                // as they are part of the same \"inference environment\".\n+                let outer_def_id = self.closure_base_def_id(def_id);\n+                if outer_def_id != def_id {\n+                    return self.item_tables(outer_def_id);\n+                }\n+\n+                bug!(\"No def'n found for {:?} in tcx.tables\", def_id);\n+            }\n+\n+            // Cross-crate side-tables only exist alongside serialized HIR.\n+            self.sess.cstore.maybe_get_item_body(self.global_tcx(), def_id).map(|_| {\n+                self.tables.borrow()[&def_id]\n+            }).unwrap_or_else(|| {\n+                bug!(\"tcx.item_tables({:?}): missing from metadata\", def_id)\n+            })\n+        })\n     }\n \n     pub fn expr_span(self, id: NodeId) -> Span {\n@@ -2454,12 +2476,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // If this is a local def-id, it should be inserted into the\n         // tables by typeck; else, it will be retreived from\n         // the external crate metadata.\n-        if let Some(&kind) = self.tables.borrow().closure_kinds.get(&def_id) {\n+        if let Some(&kind) = self.closure_kinds.borrow().get(&def_id) {\n             return kind;\n         }\n \n         let kind = self.sess.cstore.closure_kind(def_id);\n-        self.tables.borrow_mut().closure_kinds.insert(def_id, kind);\n+        self.closure_kinds.borrow_mut().insert(def_id, kind);\n         kind\n     }\n \n@@ -2471,12 +2493,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // If this is a local def-id, it should be inserted into the\n         // tables by typeck; else, it will be retreived from\n         // the external crate metadata.\n-        if let Some(ty) = self.tables.borrow().closure_tys.get(&def_id) {\n+        if let Some(ty) = self.closure_tys.borrow().get(&def_id) {\n             return ty.subst(self, substs.substs);\n         }\n \n         let ty = self.sess.cstore.closure_ty(self.global_tcx(), def_id);\n-        self.tables.borrow_mut().closure_tys.insert(def_id, ty.clone());\n+        self.closure_tys.borrow_mut().insert(def_id, ty.clone());\n         ty.subst(self, substs.substs)\n     }\n "}, {"sha": "65bec9ecdaf959ffa3b7bef709284ebffaa0bdb4", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -146,7 +146,7 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n                                        self_type: Ty<'tcx>, span: Span)\n                                        -> Result<(), CopyImplementationError> {\n         // FIXME: (@jroesch) float this code up\n-        tcx.infer_ctxt(None, Some(self.clone()), Reveal::NotSpecializable).enter(|infcx| {\n+        tcx.infer_ctxt(self.clone(), Reveal::NotSpecializable).enter(|infcx| {\n             let (adt, substs) = match self_type.sty {\n                 ty::TyAdt(adt, substs) => (adt, substs),\n                 _ => return Err(CopyImplementationError::NotAnAdt)\n@@ -536,7 +536,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             }\n         }\n         let result =\n-            tcx.infer_ctxt(None, Some(param_env.clone()), Reveal::ExactMatch)\n+            tcx.infer_ctxt(param_env.clone(), Reveal::ExactMatch)\n             .enter(|infcx| {\n                 traits::type_known_to_meet_bound(&infcx, self, def_id, span)\n             });"}, {"sha": "0605644d497db4c2927ca47433571ef7e4dd05ee", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -188,12 +188,10 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                      dfcx_loans: &LoanDataFlow<'b, 'tcx>,\n                                      move_data: &move_data::FlowedMoveData<'c, 'tcx>,\n                                      all_loans: &[Loan<'tcx>],\n-                                     fn_id: ast::NodeId,\n                                      body: &hir::Body) {\n     debug!(\"check_loans(body id={})\", body.value.id);\n \n-    let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n-    let infcx = bccx.tcx.borrowck_fake_infer_ctxt(param_env);\n+    let infcx = bccx.tcx.borrowck_fake_infer_ctxt(body.id());\n     let mut clcx = CheckLoanCtxt {\n         bccx: bccx,\n         dfcx_loans: dfcx_loans,"}, {"sha": "c33ced52e2bd6aee181faebf9e37f6acd99fa0a9", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -18,7 +18,7 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n \n use std::rc::Rc;\n use syntax::ast;\n@@ -34,12 +34,10 @@ struct GatherMoveInfo<'tcx> {\n \n pub fn gather_decl<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                              move_data: &MoveData<'tcx>,\n-                             decl_id: ast::NodeId,\n-                             _decl_span: Span,\n-                             var_id: ast::NodeId) {\n-    let ty = bccx.tcx.tables().node_id_to_type(var_id);\n-    let loan_path = Rc::new(LoanPath::new(LpVar(var_id), ty));\n-    move_data.add_move(bccx.tcx, loan_path, decl_id, Declared);\n+                             var_id: ast::NodeId,\n+                             var_ty: Ty<'tcx>) {\n+    let loan_path = Rc::new(LoanPath::new(LpVar(var_id), var_ty));\n+    move_data.add_move(bccx.tcx, loan_path, var_id, Declared);\n }\n \n pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,"}, {"sha": "7101d843b4ce3798558469d1f5883bcceeecda5f", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -18,14 +18,14 @@\n \n use borrowck::*;\n use borrowck::move_data::MoveData;\n+use rustc::infer::InferCtxt;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::region;\n use rustc::ty::{self, TyCtxt};\n \n use syntax::ast;\n-use syntax::ast::NodeId;\n use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::Expr;\n@@ -40,20 +40,20 @@ mod gather_moves;\n mod move_error;\n \n pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                    fn_id: NodeId,\n-                                    body: &hir::Body)\n+                                    body: hir::BodyId)\n                                     -> (Vec<Loan<'tcx>>,\n                                         move_data::MoveData<'tcx>) {\n+    let infcx = bccx.tcx.borrowck_fake_infer_ctxt(body);\n     let mut glcx = GatherLoanCtxt {\n         bccx: bccx,\n+        infcx: &infcx,\n         all_loans: Vec::new(),\n-        item_ub: bccx.tcx.region_maps.node_extent(body.value.id),\n+        item_ub: bccx.tcx.region_maps.node_extent(body.node_id),\n         move_data: MoveData::new(),\n         move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n \n-    let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n-    let infcx = bccx.tcx.borrowck_fake_infer_ctxt(param_env);\n+    let body = glcx.bccx.tcx.map.body(body);\n     euv::ExprUseVisitor::new(&mut glcx, &infcx).consume_body(body);\n \n     glcx.report_potential_errors();\n@@ -63,6 +63,7 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n \n struct GatherLoanCtxt<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n+    infcx: &'a InferCtxt<'a, 'tcx, 'tcx>,\n     move_data: move_data::MoveData<'tcx>,\n     move_error_collector: move_error::MoveErrorCollector<'tcx>,\n     all_loans: Vec<Loan<'tcx>>,\n@@ -158,8 +159,9 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                                         mode);\n     }\n \n-    fn decl_without_init(&mut self, id: ast::NodeId, span: Span) {\n-        gather_moves::gather_decl(self.bccx, &self.move_data, id, span, id);\n+    fn decl_without_init(&mut self, id: ast::NodeId, _span: Span) {\n+        let ty = self.infcx.tables.borrow().node_id_to_type(id);\n+        gather_moves::gather_decl(self.bccx, &self.move_data, id, ty);\n     }\n }\n \n@@ -516,19 +518,17 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n /// sure the loans being taken are sound.\n struct StaticInitializerCtxt<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n-    item_id: ast::NodeId\n+    body_id: hir::BodyId,\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for StaticInitializerCtxt<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.bccx.tcx.map)\n+        NestedVisitorMap::None\n     }\n \n     fn visit_expr(&mut self, ex: &'tcx Expr) {\n         if let hir::ExprAddrOf(mutbl, ref base) = ex.node {\n-            let param_env = ty::ParameterEnvironment::for_item(self.bccx.tcx,\n-                                                               self.item_id);\n-            let infcx = self.bccx.tcx.borrowck_fake_infer_ctxt(param_env);\n+            let infcx = self.bccx.tcx.borrowck_fake_infer_ctxt(self.body_id);\n             let mc = mc::MemCategorizationContext::new(&infcx);\n             let base_cmt = mc.cat_expr(&base).unwrap();\n             let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);\n@@ -545,16 +545,14 @@ impl<'a, 'tcx> Visitor<'tcx> for StaticInitializerCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn gather_loans_in_static_initializer<'a, 'tcx>(bccx: &mut BorrowckCtxt<'a, 'tcx>,\n-                                                    item_id: ast::NodeId,\n-                                                    body: hir::BodyId) {\n-\n+pub fn gather_loans_in_static_initializer(bccx: &mut BorrowckCtxt, body: hir::BodyId) {\n     debug!(\"gather_loans_in_static_initializer(expr={:?})\", body);\n \n     let mut sicx = StaticInitializerCtxt {\n         bccx: bccx,\n-        item_id: item_id\n+        body_id: body\n     };\n \n-    sicx.visit_nested_body(body);\n+    let body = sicx.bccx.tcx.map.body(body);\n+    sicx.visit_body(body);\n }"}, {"sha": "c0e038d183dad59e2d91e30401ab9cbe161a61b5", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -24,7 +24,7 @@ use self::InteriorKind::*;\n \n use rustc::dep_graph::DepNode;\n use rustc::hir::map as hir_map;\n-use rustc::hir::map::blocks::{FnParts, FnLikeNode};\n+use rustc::hir::map::blocks::FnLikeNode;\n use rustc::cfg;\n use rustc::middle::dataflow::DataFlowContext;\n use rustc::middle::dataflow::BitwiseOperator;\n@@ -89,14 +89,14 @@ impl<'a, 'tcx> Visitor<'tcx> for BorrowckCtxt<'a, 'tcx> {\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n         if let hir::TraitItemKind::Const(_, Some(expr)) = ti.node {\n-            gather_loans::gather_loans_in_static_initializer(self, ti.id, expr);\n+            gather_loans::gather_loans_in_static_initializer(self, expr);\n         }\n         intravisit::walk_trait_item(self, ti);\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n         if let hir::ImplItemKind::Const(_, expr) = ii.node {\n-            gather_loans::gather_loans_in_static_initializer(self, ii.id, expr);\n+            gather_loans::gather_loans_in_static_initializer(self, expr);\n         }\n         intravisit::walk_impl_item(self, ii);\n     }\n@@ -143,7 +143,7 @@ fn borrowck_item<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>, item: &'tcx hir::I\n     match item.node {\n         hir::ItemStatic(.., ex) |\n         hir::ItemConst(_, ex) => {\n-            gather_loans::gather_loans_in_static_initializer(this, item.id, ex);\n+            gather_loans::gather_loans_in_static_initializer(this, ex);\n         }\n         _ => { }\n     }\n@@ -179,7 +179,7 @@ fn borrowck_fn<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n     let AnalysisData { all_loans,\n                        loans: loan_dfcx,\n                        move_data: flowed_moves } =\n-        build_borrowck_dataflow_data(this, &cfg, body, id);\n+        build_borrowck_dataflow_data(this, &cfg, body_id);\n \n     move_data::fragments::instrument_move_fragments(&flowed_moves.move_data,\n                                                     this.tcx,\n@@ -189,31 +189,26 @@ fn borrowck_fn<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                                                  &flowed_moves.move_data,\n                                                  id);\n \n-    check_loans::check_loans(this,\n-                             &loan_dfcx,\n-                             &flowed_moves,\n-                             &all_loans[..],\n-                             id,\n-                             body);\n+    check_loans::check_loans(this, &loan_dfcx, &flowed_moves, &all_loans[..], body);\n \n     intravisit::walk_fn(this, fk, decl, body_id, sp, id);\n }\n \n fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                                           cfg: &cfg::CFG,\n-                                          body: &'tcx hir::Body,\n-                                          id: ast::NodeId)\n+                                          body_id: hir::BodyId)\n                                           -> AnalysisData<'a, 'tcx>\n {\n     // Check the body of fn items.\n     let tcx = this.tcx;\n+    let body = tcx.map.body(body_id);\n     let id_range = {\n         let mut visitor = intravisit::IdRangeComputingVisitor::new(&tcx.map);\n         visitor.visit_body(body);\n         visitor.result()\n     };\n     let (all_loans, move_data) =\n-        gather_loans::gather_loans_in_fn(this, id, body);\n+        gather_loans::gather_loans_in_fn(this, body_id);\n \n     let mut loan_dfcx =\n         DataFlowContext::new(this.tcx,\n@@ -246,7 +241,7 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n /// the `BorrowckCtxt` itself , e.g. the flowgraph visualizer.\n pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    fn_parts: FnParts<'tcx>,\n+    body: hir::BodyId,\n     cfg: &cfg::CFG)\n     -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'a, 'tcx>)\n {\n@@ -262,13 +257,7 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n         }\n     };\n \n-    let body = tcx.map.body(fn_parts.body);\n-\n-    let dataflow_data = build_borrowck_dataflow_data(&mut bccx,\n-                                                     cfg,\n-                                                     body,\n-                                                     fn_parts.id);\n-\n+    let dataflow_data = build_borrowck_dataflow_data(&mut bccx, cfg, body);\n     (bccx, dataflow_data)\n }\n "}, {"sha": "400af3c7023460fa4d5652a8b77b1218080f690b", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -51,6 +51,7 @@ impl<'a, 'tcx> Visitor<'tcx> for OuterVisitor<'a, 'tcx> {\n \n         MatchVisitor {\n             tcx: self.tcx,\n+            tables: self.tcx.body_tables(b),\n             param_env: &ty::ParameterEnvironment::for_item(self.tcx, id)\n         }.visit_body(self.tcx.map.body(b));\n     }\n@@ -68,6 +69,7 @@ fn create_e0004<'a>(sess: &'a Session, sp: Span, error_message: String) -> Diagn\n \n struct MatchVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tables: &'a ty::Tables<'tcx>,\n     param_env: &'a ty::ParameterEnvironment<'tcx>\n }\n \n@@ -156,7 +158,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n \n             let inlined_arms : Vec<(Vec<_>, _)> = arms.iter().map(|arm| (\n                 arm.pats.iter().map(|pat| {\n-                    let mut patcx = PatternContext::new(self.tcx);\n+                    let mut patcx = PatternContext::new(self.tcx, self.tables);\n                     let pattern = expand_pattern(cx, patcx.lower_pattern(&pat));\n                     if !patcx.errors.is_empty() {\n                         self.report_inlining_errors(patcx, pat.span);\n@@ -181,7 +183,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                 .flat_map(|arm| &arm.0)\n                 .map(|pat| vec![pat.0])\n                 .collect();\n-            let scrut_ty = cx.tcx.tables().node_id_to_type(scrut.id);\n+            let scrut_ty = self.tables.node_id_to_type(scrut.id);\n             check_exhaustive(cx, scrut_ty, scrut.span, &matrix, source);\n         })\n     }\n@@ -195,7 +197,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n \n         let module = self.tcx.map.local_def_id(self.tcx.map.get_module_parent(pat.id));\n         MatchCheckCtxt::create_and_enter(self.tcx, module, |ref mut cx| {\n-            let mut patcx = PatternContext::new(self.tcx);\n+            let mut patcx = PatternContext::new(self.tcx, self.tables);\n             let pattern = patcx.lower_pattern(pat);\n             let pattern_ty = pattern.ty;\n             let pats : Matrix = vec![vec![\n@@ -228,7 +230,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n     pat.walk(|p| {\n         if let PatKind::Binding(hir::BindByValue(hir::MutImmutable), _, name, None) = p.node {\n-            let pat_ty = cx.tcx.tables().pat_ty(p);\n+            let pat_ty = cx.tables.pat_ty(p);\n             if let ty::TyAdt(edef, _) = pat_ty.sty {\n                 if edef.is_enum() && edef.variants.iter().any(|variant| {\n                     variant.name == name.node && variant.ctor_kind == CtorKind::Const\n@@ -455,7 +457,7 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n     for pat in pats {\n         pat.walk(|p| {\n             if let PatKind::Binding(hir::BindByValue(..), _, _, ref sub) = p.node {\n-                let pat_ty = cx.tcx.tables().node_id_to_type(p.id);\n+                let pat_ty = cx.tables.node_id_to_type(p.id);\n                 if pat_ty.moves_by_default(cx.tcx, cx.param_env, pat.span) {\n                     check_move(p, sub.as_ref().map(|p| &**p));\n                 }\n@@ -470,13 +472,11 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n ///\n /// FIXME: this should be done by borrowck.\n fn check_for_mutation_in_guard(cx: &MatchVisitor, guard: &hir::Expr) {\n-    cx.tcx.infer_ctxt(None, Some(cx.param_env.clone()),\n-                      Reveal::NotSpecializable).enter(|infcx| {\n+    cx.tcx.infer_ctxt((cx.tables, cx.param_env.clone()), Reveal::NotSpecializable).enter(|infcx| {\n         let mut checker = MutationChecker {\n             cx: cx,\n         };\n-        let mut visitor = ExprUseVisitor::new(&mut checker, &infcx);\n-        visitor.walk_expr(guard);\n+        ExprUseVisitor::new(&mut checker, &infcx).walk_expr(guard);\n     });\n }\n "}, {"sha": "bc72c8fb9b6fe14eb2cb71b9041a71be6fdc4500", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 193, "deletions": 181, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -52,34 +52,24 @@ macro_rules! math {\n \n fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   variant_def: DefId)\n-                                  -> Option<&'tcx Expr> {\n-    let variant_expr = |variants: &'tcx [hir::Variant], id: ast::NodeId |\n-                        -> Option<&'tcx Expr> {\n-        for variant in variants {\n-            if variant.node.data.id() == id {\n-                return variant.node.disr_expr.map(|e| {\n-                    &tcx.map.body(e).value\n-                });\n-            }\n-        }\n-        None\n-    };\n-\n+                                  -> Option<(&'tcx Expr, Option<&'a ty::Tables<'tcx>>)> {\n     if let Some(variant_node_id) = tcx.map.as_local_node_id(variant_def) {\n         let enum_node_id = tcx.map.get_parent(variant_node_id);\n-        match tcx.map.find(enum_node_id) {\n-            None => None,\n-            Some(ast_map::NodeItem(it)) => match it.node {\n-                hir::ItemEnum(hir::EnumDef { ref variants }, _) => {\n-                    variant_expr(variants, variant_node_id)\n+        if let Some(ast_map::NodeItem(it)) = tcx.map.find(enum_node_id) {\n+            if let hir::ItemEnum(ref edef, _) = it.node {\n+                for variant in &edef.variants {\n+                    if variant.node.data.id() == variant_node_id {\n+                        return variant.node.disr_expr.map(|e| {\n+                            let def_id = tcx.map.body_owner_def_id(e);\n+                            (&tcx.map.body(e).value,\n+                             tcx.tables.borrow().get(&def_id).cloned())\n+                        });\n+                    }\n                 }\n-                _ => None\n-            },\n-            Some(_) => None\n+            }\n         }\n-    } else {\n-        None\n     }\n+    None\n }\n \n /// * `def_id` is the id of the constant.\n@@ -90,17 +80,22 @@ fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         def_id: DefId,\n                                         substs: Option<&'tcx Substs<'tcx>>)\n-                                        -> Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)> {\n+                                        -> Option<(&'tcx Expr,\n+                                                   Option<&'a ty::Tables<'tcx>>,\n+                                                   Option<ty::Ty<'tcx>>)> {\n     if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n         match tcx.map.find(node_id) {\n             None => None,\n-            Some(ast_map::NodeItem(it)) => match it.node {\n-                hir::ItemConst(ref ty, body) => {\n-                    Some((&tcx.map.body(body).value,\n-                          tcx.ast_ty_to_prim_ty(ty)))\n-                }\n-                _ => None\n-            },\n+            Some(ast_map::NodeItem(&hir::Item {\n+                node: hir::ItemConst(ref ty, body), ..\n+            })) |\n+            Some(ast_map::NodeImplItem(&hir::ImplItem {\n+                node: hir::ImplItemKind::Const(ref ty, body), ..\n+            })) => {\n+                Some((&tcx.map.body(body).value,\n+                      tcx.tables.borrow().get(&def_id).cloned(),\n+                      tcx.ast_ty_to_prim_ty(ty)))\n+            }\n             Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n                 hir::TraitItemKind::Const(ref ty, default) => {\n                     if let Some(substs) = substs {\n@@ -111,6 +106,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         let trait_id = tcx.map.local_def_id(trait_id);\n                         let default_value = default.map(|body| {\n                             (&tcx.map.body(body).value,\n+                             tcx.tables.borrow().get(&def_id).cloned(),\n                              tcx.ast_ty_to_prim_ty(ty))\n                         });\n                         resolve_trait_associated_const(tcx, def_id, default_value, trait_id, substs)\n@@ -126,18 +122,12 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 }\n                 _ => None\n             },\n-            Some(ast_map::NodeImplItem(ii)) => match ii.node {\n-                hir::ImplItemKind::Const(ref ty, body) => {\n-                    Some((&tcx.map.body(body).value,\n-                          tcx.ast_ty_to_prim_ty(ty)))\n-                }\n-                _ => None\n-            },\n             Some(_) => None\n         }\n     } else {\n-        let expr_ty = tcx.sess.cstore.maybe_get_item_body(tcx, def_id).map(|body| {\n-            (&body.value, Some(tcx.sess.cstore.item_type(tcx, def_id)))\n+        let expr_tables_ty = tcx.sess.cstore.maybe_get_item_body(tcx, def_id).map(|body| {\n+            (&body.value, Some(tcx.item_tables(def_id)),\n+             Some(tcx.sess.cstore.item_type(tcx, def_id)))\n         });\n         match tcx.sess.cstore.describe_def(def_id) {\n             Some(Def::AssociatedConst(_)) => {\n@@ -148,34 +138,38 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 // substitutions for the reference to it.\n                 if let Some(trait_id) = trait_id {\n                     if let Some(substs) = substs {\n-                        resolve_trait_associated_const(tcx, def_id, expr_ty, trait_id, substs)\n+                        resolve_trait_associated_const(tcx, def_id, expr_tables_ty,\n+                                                       trait_id, substs)\n                     } else {\n                         None\n                     }\n                 } else {\n-                    expr_ty\n+                    expr_tables_ty\n                 }\n             },\n-            Some(Def::Const(..)) => expr_ty,\n+            Some(Def::Const(..)) => expr_tables_ty,\n             _ => None\n         }\n     }\n }\n \n fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                                   -> Option<&'tcx hir::Body>\n+                                   -> Option<(&'tcx hir::Body, Option<&'a ty::Tables<'tcx>>)>\n {\n     if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n         FnLikeNode::from_node(tcx.map.get(node_id)).and_then(|fn_like| {\n             if fn_like.constness() == hir::Constness::Const {\n-                Some(tcx.map.body(fn_like.body()))\n+                Some((tcx.map.body(fn_like.body()),\n+                      tcx.tables.borrow().get(&def_id).cloned()))\n             } else {\n                 None\n             }\n         })\n     } else {\n         if tcx.sess.cstore.is_const_fn(def_id) {\n-            tcx.sess.cstore.maybe_get_item_body(tcx, def_id)\n+            tcx.sess.cstore.maybe_get_item_body(tcx, def_id).map(|body| {\n+                (body, Some(tcx.item_tables(def_id)))\n+            })\n         } else {\n             None\n         }\n@@ -230,30 +224,38 @@ pub fn note_const_eval_err<'a, 'tcx>(\n     }\n }\n \n-pub fn eval_const_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 e: &Expr) -> ConstVal {\n-    match eval_const_expr_checked(tcx, e) {\n-        Ok(r) => r,\n-        // non-const path still needs to be a fatal error, because enums are funky\n-        Err(s) => {\n-            report_const_eval_err(tcx, &s, e.span, \"expression\").emit();\n-            match s.kind {\n-                NonConstPath |\n-                UnimplementedConstVal(_) => tcx.sess.abort_if_errors(),\n-                _ => {}\n-            }\n-            Dummy\n-        },\n-    }\n+pub struct ConstContext<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tables: Option<&'a ty::Tables<'tcx>>,\n+    fn_args: Option<DefIdMap<ConstVal>>\n }\n \n-pub fn eval_const_expr_checked<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                         e: &Expr) -> EvalResult\n-{\n-    eval_const_expr_partial(tcx, e, ExprTypeChecked, None)\n-}\n+impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, body: hir::BodyId) -> Self {\n+        let def_id = tcx.map.body_owner_def_id(body);\n+        ConstContext {\n+            tcx: tcx,\n+            tables: tcx.tables.borrow().get(&def_id).cloned(),\n+            fn_args: None\n+        }\n+    }\n \n-pub type FnArgMap<'a> = Option<&'a DefIdMap<ConstVal>>;\n+    pub fn with_tables(tcx: TyCtxt<'a, 'tcx, 'tcx>, tables: &'a ty::Tables<'tcx>) -> Self {\n+        ConstContext {\n+            tcx: tcx,\n+            tables: Some(tables),\n+            fn_args: None\n+        }\n+    }\n+\n+    /// Evaluate a constant expression in a context where the expression isn't\n+    /// guaranteed to be evaluatable. `ty_hint` is usually ExprTypeChecked,\n+    /// but a few places need to evaluate constants during type-checking, like\n+    /// computing the length of an array. (See also the FIXME above EvalHint.)\n+    pub fn eval(&self, e: &Expr, ty_hint: EvalHint<'tcx>) -> EvalResult {\n+        eval_const_expr_partial(self, e, ty_hint)\n+    }\n+}\n \n #[derive(Clone, Debug)]\n pub struct ConstEvalErr {\n@@ -433,20 +435,16 @@ macro_rules! signal {\n     }\n }\n \n-/// Evaluate a constant expression in a context where the expression isn't\n-/// guaranteed to be evaluatable. `ty_hint` is usually ExprTypeChecked,\n-/// but a few places need to evaluate constants during type-checking, like\n-/// computing the length of an array. (See also the FIXME above EvalHint.)\n-pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                         e: &Expr,\n-                                         ty_hint: EvalHint<'tcx>,\n-                                         fn_args: FnArgMap) -> EvalResult {\n+fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n+                                     e: &Expr,\n+                                     ty_hint: EvalHint<'tcx>) -> EvalResult {\n+    let tcx = cx.tcx;\n     // Try to compute the type of the expression based on the EvalHint.\n     // (See also the definition of EvalHint, and the FIXME above EvalHint.)\n     let ety = match ty_hint {\n         ExprTypeChecked => {\n             // After type-checking, expr_ty is guaranteed to succeed.\n-            Some(tcx.tables().expr_ty(e))\n+            cx.tables.map(|tables| tables.expr_ty(e))\n         }\n         UncheckedExprHint(ty) => {\n             // Use the type hint; it's not guaranteed to be right, but it's\n@@ -457,7 +455,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // This expression might not be type-checked, and we have no hint.\n             // Try to query the context for a type anyway; we might get lucky\n             // (for example, if the expression was imported from another crate).\n-            tcx.tables().expr_ty_opt(e)\n+            cx.tables.and_then(|tables| tables.expr_ty_opt(e))\n         }\n     };\n     let result = match e.node {\n@@ -510,14 +508,14 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 _ => {},\n             }\n         }\n-        match eval_const_expr_partial(tcx, &inner, ty_hint, fn_args)? {\n+        match cx.eval(inner, ty_hint)? {\n           Float(f) => Float(-f),\n           Integral(i) => Integral(math!(e, -i)),\n           const_val => signal!(e, NegateOn(const_val)),\n         }\n       }\n       hir::ExprUnary(hir::UnNot, ref inner) => {\n-        match eval_const_expr_partial(tcx, &inner, ty_hint, fn_args)? {\n+        match cx.eval(inner, ty_hint)? {\n           Integral(i) => Integral(math!(e, !i)),\n           Bool(b) => Bool(!b),\n           const_val => signal!(e, NotOn(const_val)),\n@@ -533,8 +531,8 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // gives us a type through a type-suffix, cast or const def type\n         // we need to re-eval the other value of the BinOp if it was\n         // not inferred\n-        match (eval_const_expr_partial(tcx, &a, ty_hint, fn_args)?,\n-               eval_const_expr_partial(tcx, &b, b_ty, fn_args)?) {\n+        match (cx.eval(a, ty_hint)?,\n+               cx.eval(b, b_ty)?) {\n           (Float(a), Float(b)) => {\n             use std::cmp::Ordering::*;\n             match op.node {\n@@ -604,13 +602,13 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let base_hint = if let ExprTypeChecked = ty_hint {\n             ExprTypeChecked\n         } else {\n-            match tcx.tables().expr_ty_opt(&base) {\n+            match cx.tables.and_then(|tables| tables.expr_ty_opt(&base)) {\n                 Some(t) => UncheckedExprHint(t),\n                 None => ty_hint\n             }\n         };\n \n-        let val = match eval_const_expr_partial(tcx, &base, base_hint, fn_args) {\n+        let val = match cx.eval(base, base_hint) {\n             Ok(val) => val,\n             Err(ConstEvalErr { kind: ErroneousReferencedConstant(\n                 box ConstEvalErr { kind: TypeMismatch(_, val), .. }), .. }) |\n@@ -623,7 +621,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     // we had a type hint, so we can't have an unknown type\n                     None => bug!(),\n                 };\n-                eval_const_expr_partial(tcx, &base, hint, fn_args)?\n+                cx.eval(base, hint)?\n             },\n             Err(e) => return Err(e),\n         };\n@@ -633,22 +631,29 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n       }\n       hir::ExprPath(ref qpath) => {\n-          let def = tcx.tables().qpath_def(qpath, e.id);\n+          let def = cx.tables.map(|tables| tables.qpath_def(qpath, e.id)).unwrap_or_else(|| {\n+            // There are no tables so we can only handle already-resolved HIR.\n+            match *qpath {\n+                hir::QPath::Resolved(_, ref path) => path.def,\n+                hir::QPath::TypeRelative(..) => Def::Err\n+            }\n+          });\n           match def {\n               Def::Const(def_id) |\n               Def::AssociatedConst(def_id) => {\n                   let substs = if let ExprTypeChecked = ty_hint {\n-                      Some(tcx.tables().node_id_item_substs(e.id)\n+                      Some(cx.tables.and_then(|tables| tables.node_id_item_substs(e.id))\n                         .unwrap_or_else(|| tcx.intern_substs(&[])))\n                   } else {\n                       None\n                   };\n-                  if let Some((expr, ty)) = lookup_const_by_id(tcx, def_id, substs) {\n+                  if let Some((expr, tables, ty)) = lookup_const_by_id(tcx, def_id, substs) {\n                       let item_hint = match ty {\n                           Some(ty) => ty_hint.checked_or(ty),\n                           None => ty_hint,\n                       };\n-                      match eval_const_expr_partial(tcx, expr, item_hint, None) {\n+                      let cx = ConstContext { tcx: tcx, tables: tables, fn_args: None };\n+                      match cx.eval(expr, item_hint) {\n                           Ok(val) => val,\n                           Err(err) => {\n                               debug!(\"bad reference: {:?}, {:?}\", err.description(), err.span);\n@@ -660,8 +665,9 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                   }\n               },\n               Def::VariantCtor(variant_def, ..) => {\n-                  if let Some(const_expr) = lookup_variant_by_id(tcx, variant_def) {\n-                      match eval_const_expr_partial(tcx, const_expr, ty_hint, None) {\n+                  if let Some((expr, tables)) = lookup_variant_by_id(tcx, variant_def) {\n+                      let cx = ConstContext { tcx: tcx, tables: tables, fn_args: None };\n+                      match cx.eval(expr, ty_hint) {\n                           Ok(val) => val,\n                           Err(err) => {\n                               debug!(\"bad reference: {:?}, {:?}\", err.description(), err.span);\n@@ -673,11 +679,11 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                   }\n               }\n               Def::StructCtor(..) => {\n-                  ConstVal::Struct(e.id)\n+                  ConstVal::Struct(Default::default())\n               }\n               Def::Local(def_id) => {\n-                  debug!(\"Def::Local({:?}): {:?}\", def_id, fn_args);\n-                  if let Some(val) = fn_args.and_then(|args| args.get(&def_id)) {\n+                  debug!(\"Def::Local({:?}): {:?}\", def_id, cx.fn_args);\n+                  if let Some(val) = cx.fn_args.as_ref().and_then(|args| args.get(&def_id)) {\n                       val.clone()\n                   } else {\n                       signal!(e, NonConstPath);\n@@ -690,14 +696,14 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n       }\n       hir::ExprCall(ref callee, ref args) => {\n           let sub_ty_hint = ty_hint.erase_hint();\n-          let callee_val = eval_const_expr_partial(tcx, callee, sub_ty_hint, fn_args)?;\n+          let callee_val = cx.eval(callee, sub_ty_hint)?;\n           let did = match callee_val {\n               Function(did) => did,\n               Struct(_) => signal!(e, UnimplementedConstVal(\"tuple struct constructors\")),\n               callee => signal!(e, CallOn(callee)),\n           };\n-          let body = match lookup_const_fn_by_id(tcx, did) {\n-              Some(body) => body,\n+          let (body, tables) = match lookup_const_fn_by_id(tcx, did) {\n+              Some(x) => x,\n               None => signal!(e, NonConstPath),\n           };\n \n@@ -710,66 +716,69 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n           let mut call_args = DefIdMap();\n           for (arg, arg_expr) in arg_defs.into_iter().zip(args.iter()) {\n               let arg_hint = ty_hint.erase_hint();\n-              let arg_val = eval_const_expr_partial(\n-                  tcx,\n-                  arg_expr,\n-                  arg_hint,\n-                  fn_args\n-              )?;\n+              let arg_val = cx.eval(arg_expr, arg_hint)?;\n               debug!(\"const call arg: {:?}\", arg);\n               if let Some(def_id) = arg {\n                 assert!(call_args.insert(def_id, arg_val).is_none());\n               }\n           }\n           debug!(\"const call({:?})\", call_args);\n-          eval_const_expr_partial(tcx, &body.value, ty_hint, Some(&call_args))?\n+          let callee_cx = ConstContext {\n+            tcx: tcx,\n+            tables: tables,\n+            fn_args: Some(call_args)\n+          };\n+          callee_cx.eval(&body.value, ty_hint)?\n       },\n       hir::ExprLit(ref lit) => match lit_to_const(&lit.node, tcx, ety) {\n           Ok(val) => val,\n           Err(err) => signal!(e, err),\n       },\n       hir::ExprBlock(ref block) => {\n         match block.expr {\n-            Some(ref expr) => eval_const_expr_partial(tcx, &expr, ty_hint, fn_args)?,\n+            Some(ref expr) => cx.eval(expr, ty_hint)?,\n             None => signal!(e, UnimplementedConstVal(\"empty block\")),\n         }\n       }\n-      hir::ExprType(ref e, _) => eval_const_expr_partial(tcx, &e, ty_hint, fn_args)?,\n-      hir::ExprTup(_) => Tuple(e.id),\n-      hir::ExprStruct(..) => Struct(e.id),\n+      hir::ExprType(ref e, _) => cx.eval(e, ty_hint)?,\n+      hir::ExprTup(ref fields) => {\n+        let field_hint = ty_hint.erase_hint();\n+        Tuple(fields.iter().map(|e| cx.eval(e, field_hint)).collect::<Result<_, _>>()?)\n+      }\n+      hir::ExprStruct(_, ref fields, _) => {\n+        let field_hint = ty_hint.erase_hint();\n+        Struct(fields.iter().map(|f| {\n+            cx.eval(&f.expr, field_hint).map(|v| (f.name.node, v))\n+        }).collect::<Result<_, _>>()?)\n+      }\n       hir::ExprIndex(ref arr, ref idx) => {\n         if !tcx.sess.features.borrow().const_indexing {\n             signal!(e, IndexOpFeatureGated);\n         }\n         let arr_hint = ty_hint.erase_hint();\n-        let arr = eval_const_expr_partial(tcx, arr, arr_hint, fn_args)?;\n+        let arr = cx.eval(arr, arr_hint)?;\n         let idx_hint = ty_hint.checked_or(tcx.types.usize);\n-        let idx = match eval_const_expr_partial(tcx, idx, idx_hint, fn_args)? {\n+        let idx = match cx.eval(idx, idx_hint)? {\n             Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n             Integral(_) => bug!(),\n             _ => signal!(idx, IndexNotInt),\n         };\n         assert_eq!(idx as usize as u64, idx);\n         match arr {\n-            Array(_, n) if idx >= n => {\n-                signal!(e, IndexOutOfBounds { len: n, index: idx })\n+            Array(ref v) => {\n+                if let Some(elem) = v.get(idx as usize) {\n+                    elem.clone()\n+                } else {\n+                    let n = v.len() as u64;\n+                    assert_eq!(n as usize as u64, n);\n+                    signal!(e, IndexOutOfBounds { len: n, index: idx })\n+                }\n             }\n-            Array(v, n) => if let hir::ExprArray(ref v) = tcx.map.expect_expr(v).node {\n-                assert_eq!(n as usize as u64, n);\n-                eval_const_expr_partial(tcx, &v[idx as usize], ty_hint, fn_args)?\n-            } else {\n-                bug!()\n-            },\n \n-            Repeat(_, n) if idx >= n => {\n+            Repeat(.., n) if idx >= n => {\n                 signal!(e, IndexOutOfBounds { len: n, index: idx })\n             }\n-            Repeat(elem, _) => eval_const_expr_partial(\n-                tcx,\n-                &tcx.map.expect_expr(elem),\n-                ty_hint,\n-                fn_args,\n-            )?,\n+            Repeat(ref elem, _) => (**elem).clone(),\n \n             ByteStr(ref data) if idx >= data.len() as u64 => {\n                 signal!(e, IndexOutOfBounds { len: data.len() as u64, index: idx })\n@@ -781,52 +790,51 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             _ => signal!(e, IndexedNonVec),\n         }\n       }\n-      hir::ExprArray(ref v) => Array(e.id, v.len() as u64),\n-      hir::ExprRepeat(_, n) => {\n+      hir::ExprArray(ref v) => {\n+        let elem_hint = ty_hint.erase_hint();\n+        Array(v.iter().map(|e| cx.eval(e, elem_hint)).collect::<Result<_, _>>()?)\n+      }\n+      hir::ExprRepeat(ref elem, count) => {\n+          let elem_hint = ty_hint.erase_hint();\n           let len_hint = ty_hint.checked_or(tcx.types.usize);\n-          let n = &tcx.map.body(n).value;\n-          Repeat(\n-              e.id,\n-              match eval_const_expr_partial(tcx, n, len_hint, fn_args)? {\n-                  Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n-                  Integral(_) => signal!(e, RepeatCountNotNatural),\n-                  _ => signal!(e, RepeatCountNotInt),\n-              },\n-          )\n+          let n = if let Some(ty) = ety {\n+            // For cross-crate constants, we have the type already,\n+            // but not the body for `count`, so use the type.\n+            match ty.sty {\n+                ty::TyArray(_, n) => n as u64,\n+                _ => bug!()\n+            }\n+          } else {\n+            let n = &tcx.map.body(count).value;\n+            match ConstContext::new(tcx, count).eval(n, len_hint)? {\n+                Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n+                Integral(_) => signal!(e, RepeatCountNotNatural),\n+                _ => signal!(e, RepeatCountNotInt),\n+            }\n+          };\n+          Repeat(Box::new(cx.eval(elem, elem_hint)?), n)\n       },\n       hir::ExprTupField(ref base, index) => {\n         let base_hint = ty_hint.erase_hint();\n-        let c = eval_const_expr_partial(tcx, base, base_hint, fn_args)?;\n-        if let Tuple(tup_id) = c {\n-            if let hir::ExprTup(ref fields) = tcx.map.expect_expr(tup_id).node {\n-                if index.node < fields.len() {\n-                    eval_const_expr_partial(tcx, &fields[index.node], ty_hint, fn_args)?\n-                } else {\n-                    signal!(e, TupleIndexOutOfBounds);\n-                }\n+        let c = cx.eval(base, base_hint)?;\n+        if let Tuple(ref fields) = c {\n+            if let Some(elem) = fields.get(index.node) {\n+                elem.clone()\n             } else {\n-                bug!()\n+                signal!(e, TupleIndexOutOfBounds);\n             }\n         } else {\n             signal!(base, ExpectedConstTuple);\n         }\n       }\n       hir::ExprField(ref base, field_name) => {\n         let base_hint = ty_hint.erase_hint();\n-        // Get the base expression if it is a struct and it is constant\n-        let c = eval_const_expr_partial(tcx, base, base_hint, fn_args)?;\n-        if let Struct(struct_id) = c {\n-            if let hir::ExprStruct(_, ref fields, _) = tcx.map.expect_expr(struct_id).node {\n-                // Check that the given field exists and evaluate it\n-                // if the idents are compared run-pass/issue-19244 fails\n-                if let Some(f) = fields.iter().find(|f| f.name.node\n-                                                     == field_name.node) {\n-                    eval_const_expr_partial(tcx, &f.expr, ty_hint, fn_args)?\n-                } else {\n-                    signal!(e, MissingStructField);\n-                }\n+        let c = cx.eval(base, base_hint)?;\n+        if let Struct(ref fields) = c {\n+            if let Some(f) = fields.get(&field_name.node) {\n+                f.clone()\n             } else {\n-                bug!()\n+                signal!(e, MissingStructField);\n             }\n         } else {\n             signal!(base, ExpectedConstStruct);\n@@ -909,17 +917,17 @@ fn infer<'a, 'tcx>(i: ConstInt,\n fn resolve_trait_associated_const<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     trait_item_id: DefId,\n-    default_value: Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)>,\n+    default_value: Option<(&'tcx Expr, Option<&'a ty::Tables<'tcx>>, Option<ty::Ty<'tcx>>)>,\n     trait_id: DefId,\n     rcvr_substs: &'tcx Substs<'tcx>\n-) -> Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)>\n+) -> Option<(&'tcx Expr, Option<&'a ty::Tables<'tcx>>, Option<ty::Ty<'tcx>>)>\n {\n     let trait_ref = ty::Binder(ty::TraitRef::new(trait_id, rcvr_substs));\n     debug!(\"resolve_trait_associated_const: trait_ref={:?}\",\n            trait_ref);\n \n     tcx.populate_implementations_for_trait_if_necessary(trait_id);\n-    tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n+    tcx.infer_ctxt((), Reveal::NotSpecializable).enter(|infcx| {\n         let mut selcx = traits::SelectionContext::new(&infcx);\n         let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n                                                  trait_ref.to_poly_trait_predicate());\n@@ -1160,36 +1168,40 @@ pub fn compare_const_vals(tcx: TyCtxt, span: Span, a: &ConstVal, b: &ConstVal)\n     }\n }\n \n-pub fn compare_lit_exprs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   span: Span,\n-                                   a: &Expr,\n-                                   b: &Expr) -> Result<Ordering, ErrorReported> {\n-    let a = match eval_const_expr_partial(tcx, a, ExprTypeChecked, None) {\n-        Ok(a) => a,\n-        Err(e) => {\n-            report_const_eval_err(tcx, &e, a.span, \"expression\").emit();\n-            return Err(ErrorReported);\n-        }\n-    };\n-    let b = match eval_const_expr_partial(tcx, b, ExprTypeChecked, None) {\n-        Ok(b) => b,\n-        Err(e) => {\n-            report_const_eval_err(tcx, &e, b.span, \"expression\").emit();\n-            return Err(ErrorReported);\n-        }\n-    };\n-    compare_const_vals(tcx, span, &a, &b)\n+impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n+    pub fn compare_lit_exprs(&self,\n+                             span: Span,\n+                             a: &Expr,\n+                             b: &Expr) -> Result<Ordering, ErrorReported> {\n+        let tcx = self.tcx;\n+        let a = match self.eval(a, ExprTypeChecked) {\n+            Ok(a) => a,\n+            Err(e) => {\n+                report_const_eval_err(tcx, &e, a.span, \"expression\").emit();\n+                return Err(ErrorReported);\n+            }\n+        };\n+        let b = match self.eval(b, ExprTypeChecked) {\n+            Ok(b) => b,\n+            Err(e) => {\n+                report_const_eval_err(tcx, &e, b.span, \"expression\").emit();\n+                return Err(ErrorReported);\n+            }\n+        };\n+        compare_const_vals(tcx, span, &a, &b)\n+    }\n }\n \n \n /// Returns the value of the length-valued expression\n pub fn eval_length<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             count_expr: &hir::Expr,\n+                             count: hir::BodyId,\n                              reason: &str)\n                              -> Result<usize, ErrorReported>\n {\n     let hint = UncheckedExprHint(tcx.types.usize);\n-    match eval_const_expr_partial(tcx, count_expr, hint, None) {\n+    let count_expr = &tcx.map.body(count).value;\n+    match ConstContext::new(tcx, count).eval(count_expr, hint) {\n         Ok(Integral(Usize(count))) => {\n             let val = count.as_u64(tcx.sess.target.uint_type);\n             assert_eq!(val as usize as u64, val);"}, {"sha": "fbd15b6eb103531fbd6e746ddd7c31c9de95b869", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -119,8 +119,7 @@ fn print_const_val(value: &ConstVal, f: &mut fmt::Formatter) -> fmt::Result {\n         ConstVal::Tuple(_) |\n         ConstVal::Function(_) |\n         ConstVal::Array(..) |\n-        ConstVal::Repeat(..) |\n-        ConstVal::Dummy => bug!(\"{:?} not printable in a pattern\", value)\n+        ConstVal::Repeat(..) => bug!(\"{:?} not printable in a pattern\", value)\n     }\n }\n \n@@ -261,12 +260,15 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n \n pub struct PatternContext<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub tables: &'a ty::Tables<'gcx>,\n     pub errors: Vec<PatternError>,\n }\n \n impl<'a, 'gcx, 'tcx> Pattern<'tcx> {\n-    pub fn from_hir(tcx: TyCtxt<'a, 'gcx, 'tcx>, pat: &hir::Pat) -> Self {\n-        let mut pcx = PatternContext::new(tcx);\n+    pub fn from_hir(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                    tables: &'a ty::Tables<'gcx>,\n+                    pat: &hir::Pat) -> Self {\n+        let mut pcx = PatternContext::new(tcx, tables);\n         let result = pcx.lower_pattern(pat);\n         if !pcx.errors.is_empty() {\n             span_bug!(pat.span, \"encountered errors lowering pattern: {:?}\", pcx.errors)\n@@ -277,12 +279,12 @@ impl<'a, 'gcx, 'tcx> Pattern<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n-        PatternContext { tcx: tcx, errors: vec![] }\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, tables: &'a ty::Tables<'gcx>) -> Self {\n+        PatternContext { tcx: tcx, tables: tables, errors: vec![] }\n     }\n \n     pub fn lower_pattern(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n-        let mut ty = self.tcx.tables().node_id_to_type(pat.id);\n+        let mut ty = self.tables.node_id_to_type(pat.id);\n \n         let kind = match pat.node {\n             PatKind::Wild => PatternKind::Wild,\n@@ -309,7 +311,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             PatKind::Slice(ref prefix, ref slice, ref suffix) => {\n-                let ty = self.tcx.tables().node_id_to_type(pat.id);\n+                let ty = self.tables.node_id_to_type(pat.id);\n                 match ty.sty {\n                     ty::TyRef(_, mt) =>\n                         PatternKind::Deref {\n@@ -334,7 +336,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             PatKind::Tuple(ref subpatterns, ddpos) => {\n-                let ty = self.tcx.tables().node_id_to_type(pat.id);\n+                let ty = self.tables.node_id_to_type(pat.id);\n                 match ty.sty {\n                     ty::TyTuple(ref tys) => {\n                         let subpatterns =\n@@ -355,7 +357,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n \n             PatKind::Binding(bm, def_id, ref ident, ref sub) => {\n                 let id = self.tcx.map.as_local_node_id(def_id).unwrap();\n-                let var_ty = self.tcx.tables().node_id_to_type(pat.id);\n+                let var_ty = self.tables.node_id_to_type(pat.id);\n                 let region = match var_ty.sty {\n                     ty::TyRef(r, _) => Some(r),\n                     _ => None,\n@@ -392,7 +394,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             PatKind::TupleStruct(ref qpath, ref subpatterns, ddpos) => {\n-                let def = self.tcx.tables().qpath_def(qpath, pat.id);\n+                let def = self.tables.qpath_def(qpath, pat.id);\n                 let adt_def = match ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => span_bug!(pat.span, \"tuple struct pattern not applied to an ADT\"),\n@@ -411,7 +413,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             PatKind::Struct(ref qpath, ref fields, _) => {\n-                let def = self.tcx.tables().qpath_def(qpath, pat.id);\n+                let def = self.tables.qpath_def(qpath, pat.id);\n                 let adt_def = match ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => {\n@@ -569,16 +571,21 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                   pat_id: ast::NodeId,\n                   span: Span)\n                   -> Pattern<'tcx> {\n-        let ty = self.tcx.tables().node_id_to_type(id);\n-        let def = self.tcx.tables().qpath_def(qpath, id);\n+        let ty = self.tables.node_id_to_type(id);\n+        let def = self.tables.qpath_def(qpath, id);\n         let kind = match def {\n             Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                 let tcx = self.tcx.global_tcx();\n-                let substs = tcx.tables().node_id_item_substs(id)\n+                let substs = self.tables.node_id_item_substs(id)\n                     .unwrap_or_else(|| tcx.intern_substs(&[]));\n                 match eval::lookup_const_by_id(tcx, def_id, Some(substs)) {\n-                    Some((const_expr, _const_ty)) => {\n-                        return self.lower_const_expr(const_expr, pat_id, span);\n+                    Some((const_expr, const_tables, _const_ty)) => {\n+                        // Enter the inlined constant's tables temporarily.\n+                        let old_tables = self.tables;\n+                        self.tables = const_tables.expect(\"missing tables after typeck\");\n+                        let pat = self.lower_const_expr(const_expr, pat_id, span);\n+                        self.tables = old_tables;\n+                        return pat;\n                     }\n                     None => {\n                         self.errors.push(PatternError::StaticInPattern(span));\n@@ -597,7 +604,8 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn lower_lit(&mut self, expr: &hir::Expr) -> PatternKind<'tcx> {\n-        match eval::eval_const_expr_checked(self.tcx.global_tcx(), expr) {\n+        let const_cx = eval::ConstContext::with_tables(self.tcx.global_tcx(), self.tables);\n+        match const_cx.eval(expr, eval::EvalHint::ExprTypeChecked) {\n             Ok(value) => {\n                 PatternKind::Constant { value: value }\n             }\n@@ -613,7 +621,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                         pat_id: ast::NodeId,\n                         span: Span)\n                         -> Pattern<'tcx> {\n-        let pat_ty = self.tcx.tables().expr_ty(expr);\n+        let pat_ty = self.tables.expr_ty(expr);\n         debug!(\"expr={:?} pat_ty={:?} pat_id={}\", expr, pat_ty, pat_id);\n         match pat_ty.sty {\n             ty::TyFloat(_) => {\n@@ -659,8 +667,8 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                     hir::ExprPath(ref qpath) => qpath,\n                     _ => bug!()\n                 };\n-                let ty = self.tcx.tables().node_id_to_type(callee.id);\n-                let def = self.tcx.tables().qpath_def(qpath, callee.id);\n+                let ty = self.tables.node_id_to_type(callee.id);\n+                let def = self.tables.qpath_def(qpath, callee.id);\n                 match def {\n                     Def::Fn(..) | Def::Method(..) => self.lower_lit(expr),\n                     _ => {\n@@ -676,8 +684,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             hir::ExprStruct(ref qpath, ref fields, None) => {\n-                let def = self.tcx.tables().qpath_def(qpath, expr.id);\n-                let pat_ty = self.tcx.tables().node_id_to_type(expr.id);\n+                let def = self.tables.qpath_def(qpath, expr.id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => {"}, {"sha": "afacfb6e3f9fd6a1cd839121c988c6673d8a45cf", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -39,6 +39,7 @@ use syntax_pos;\n \n use graphviz as dot;\n \n+use std::cell::Cell;\n use std::fs::File;\n use std::io::{self, Write};\n use std::iter;\n@@ -236,7 +237,11 @@ impl PpSourceMode {\n                                                                  arenas,\n                                                                  id,\n                                                                  |tcx, _, _, _| {\n-                    let annotation = TypedAnnotation { tcx: tcx };\n+                    let empty_tables = ty::Tables::empty();\n+                    let annotation = TypedAnnotation {\n+                        tcx: tcx,\n+                        tables: Cell::new(&empty_tables)\n+                    };\n                     let _ignore = tcx.dep_graph.in_ignore();\n                     f(&annotation, payload, ast_map.forest.krate())\n                 }),\n@@ -488,6 +493,7 @@ impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n \n struct TypedAnnotation<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tables: Cell<&'a ty::Tables<'tcx>>,\n }\n \n impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n@@ -511,7 +517,13 @@ impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n     fn nested(&self, state: &mut pprust_hir::State, nested: pprust_hir::Nested)\n               -> io::Result<()> {\n-        pprust_hir::PpAnn::nested(&self.tcx.map, state, nested)\n+        let old_tables = self.tables.get();\n+        if let pprust_hir::Nested::Body(id) = nested {\n+            self.tables.set(self.tcx.body_tables(id));\n+        }\n+        pprust_hir::PpAnn::nested(&self.tcx.map, state, nested)?;\n+        self.tables.set(old_tables);\n+        Ok(())\n     }\n     fn pre(&self, s: &mut pprust_hir::State, node: pprust_hir::AnnNode) -> io::Result<()> {\n         match node {\n@@ -525,7 +537,7 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n                 pp::space(&mut s.s)?;\n                 pp::word(&mut s.s, \"as\")?;\n                 pp::space(&mut s.s)?;\n-                pp::word(&mut s.s, &self.tcx.tables().expr_ty(expr).to_string())?;\n+                pp::word(&mut s.s, &self.tables.get().expr_ty(expr).to_string())?;\n                 s.pclose()\n             }\n             _ => Ok(()),\n@@ -751,7 +763,7 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n         }\n         blocks::Code::FnLike(fn_like) => {\n             let (bccx, analysis_data) =\n-                borrowck::build_borrowck_dataflow_data_for_fn(tcx, fn_like.to_fn_parts(), &cfg);\n+                borrowck::build_borrowck_dataflow_data_for_fn(tcx, fn_like.body(), &cfg);\n \n             let lcfg = borrowck_dot::DataflowLabeller {\n                 inner: lcfg,"}, {"sha": "ede35d052ad51407488c7435a5614e4cbfa4a14b", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -149,7 +149,7 @@ fn test_env<F>(source_string: &str,\n                              index,\n                              \"test_crate\",\n                              |tcx| {\n-        tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n+        tcx.infer_ctxt((), Reveal::NotSpecializable).enter(|infcx| {\n \n             body(Env { infcx: &infcx });\n             let free_regions = FreeRegionMap::new();"}, {"sha": "8d86e7e2e8b9ea7d563465a20490a9e06989ada6", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -138,7 +138,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n-        let ty = cx.tcx.tables().node_id_to_type(e.id);\n+        let ty = cx.tables.node_id_to_type(e.id);\n         self.check_heap_type(cx, e.span, ty);\n     }\n }\n@@ -738,8 +738,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             // is this a recursive call?\n             let self_recursive = if node_id != ast::DUMMY_NODE_ID {\n                 match method {\n-                    Some(ref method) => expr_refers_to_this_method(cx.tcx, method, node_id),\n-                    None => expr_refers_to_this_fn(cx.tcx, id, node_id),\n+                    Some(ref method) => expr_refers_to_this_method(cx, method, node_id),\n+                    None => expr_refers_to_this_fn(cx, id, node_id),\n                 }\n             } else {\n                 false\n@@ -787,63 +787,62 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n         // Functions for identifying if the given Expr NodeId `id`\n         // represents a call to the function `fn_id`/method `method`.\n \n-        fn expr_refers_to_this_fn(tcx: TyCtxt, fn_id: ast::NodeId, id: ast::NodeId) -> bool {\n-            match tcx.map.get(id) {\n+        fn expr_refers_to_this_fn(cx: &LateContext, fn_id: ast::NodeId, id: ast::NodeId) -> bool {\n+            match cx.tcx.map.get(id) {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n                     let def = if let hir::ExprPath(ref qpath) = callee.node {\n-                        tcx.tables().qpath_def(qpath, callee.id)\n+                        cx.tables.qpath_def(qpath, callee.id)\n                     } else {\n                         return false;\n                     };\n-                    def.def_id() == tcx.map.local_def_id(fn_id)\n+                    def.def_id() == cx.tcx.map.local_def_id(fn_id)\n                 }\n                 _ => false,\n             }\n         }\n \n         // Check if the expression `id` performs a call to `method`.\n-        fn expr_refers_to_this_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                method: &ty::AssociatedItem,\n-                                                id: ast::NodeId)\n-                                                -> bool {\n+        fn expr_refers_to_this_method(cx: &LateContext,\n+                                      method: &ty::AssociatedItem,\n+                                      id: ast::NodeId)\n+                                      -> bool {\n             use rustc::ty::adjustment::*;\n \n             // Check for method calls and overloaded operators.\n-            let opt_m = tcx.tables().method_map.get(&ty::MethodCall::expr(id)).cloned();\n+            let opt_m = cx.tables.method_map.get(&ty::MethodCall::expr(id)).cloned();\n             if let Some(m) = opt_m {\n-                if method_call_refers_to_method(tcx, method, m.def_id, m.substs, id) {\n+                if method_call_refers_to_method(cx.tcx, method, m.def_id, m.substs, id) {\n                     return true;\n                 }\n             }\n \n             // Check for overloaded autoderef method calls.\n-            let opt_adj = tcx.tables().adjustments.get(&id).cloned();\n+            let opt_adj = cx.tables.adjustments.get(&id).cloned();\n             if let Some(Adjustment { kind: Adjust::DerefRef { autoderefs, .. }, .. }) = opt_adj {\n                 for i in 0..autoderefs {\n                     let method_call = ty::MethodCall::autoderef(id, i as u32);\n-                    if let Some(m) = tcx.tables().method_map.get(&method_call)\n-                                                            .cloned() {\n-                        if method_call_refers_to_method(tcx, method, m.def_id, m.substs, id) {\n+                    if let Some(m) = cx.tables.method_map.get(&method_call).cloned() {\n+                        if method_call_refers_to_method(cx.tcx, method, m.def_id, m.substs, id) {\n                             return true;\n                         }\n                     }\n                 }\n             }\n \n             // Check for calls to methods via explicit paths (e.g. `T::method()`).\n-            match tcx.map.get(id) {\n+            match cx.tcx.map.get(id) {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n                     let def = if let hir::ExprPath(ref qpath) = callee.node {\n-                        tcx.tables().qpath_def(qpath, callee.id)\n+                        cx.tables.qpath_def(qpath, callee.id)\n                     } else {\n                         return false;\n                     };\n                     match def {\n                         Def::Method(def_id) => {\n-                            let substs = tcx.tables().node_id_item_substs(callee.id)\n-                                .unwrap_or_else(|| tcx.intern_substs(&[]));\n+                            let substs = cx.tables.node_id_item_substs(callee.id)\n+                                .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n                             method_call_refers_to_method(\n-                                tcx, method, def_id, substs, id)\n+                                cx.tcx, method, def_id, substs, id)\n                         }\n                         _ => false,\n                     }\n@@ -882,8 +881,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n                     // checking, so it's always local\n                     let node_id = tcx.map.as_local_node_id(method.def_id).unwrap();\n \n-                    let param_env = Some(ty::ParameterEnvironment::for_item(tcx, node_id));\n-                    tcx.infer_ctxt(None, param_env, Reveal::NotSpecializable).enter(|infcx| {\n+                    let param_env = ty::ParameterEnvironment::for_item(tcx, node_id);\n+                    tcx.infer_ctxt(param_env, Reveal::NotSpecializable).enter(|infcx| {\n                         let mut selcx = traits::SelectionContext::new(&infcx);\n                         match selcx.select(&obligation) {\n                             // The method comes from a `T: Trait` bound.\n@@ -1073,15 +1072,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n              expr: &hir::Expr)\n              -> Option<(&'tcx ty::TypeVariants<'tcx>, &'tcx ty::TypeVariants<'tcx>)> {\n             let def = if let hir::ExprPath(ref qpath) = expr.node {\n-                cx.tcx.tables().qpath_def(qpath, expr.id)\n+                cx.tables.qpath_def(qpath, expr.id)\n             } else {\n                 return None;\n             };\n             if let Def::Fn(did) = def {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }\n-                let typ = cx.tcx.tables().node_id_to_type(expr.id);\n+                let typ = cx.tables.node_id_to_type(expr.id);\n                 match typ.sty {\n                     ty::TyFnDef(.., ref bare_fn) if bare_fn.abi == RustIntrinsic => {\n                         let from = bare_fn.sig.skip_binder().inputs()[0];"}, {"sha": "2a77e9a4a7c8b5b0c58c9d093b4de57e9b5bcf9d", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -16,7 +16,7 @@ use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n use rustc::ty::layout::{Layout, Primitive};\n use rustc::traits::Reveal;\n use middle::const_val::ConstVal;\n-use rustc_const_eval::eval_const_expr_partial;\n+use rustc_const_eval::ConstContext;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n use util::nodemap::FxHashSet;\n use lint::{LateContext, LintContext, LintArray};\n@@ -89,14 +89,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 }\n             }\n             hir::ExprBinary(binop, ref l, ref r) => {\n-                if is_comparison(binop) && !check_limits(cx.tcx, binop, &l, &r) {\n+                if is_comparison(binop) && !check_limits(cx, binop, &l, &r) {\n                     cx.span_lint(UNUSED_COMPARISONS,\n                                  e.span,\n                                  \"comparison is useless due to type limits\");\n                 }\n \n                 if binop.node.is_shift() {\n-                    let opt_ty_bits = match cx.tcx.tables().node_id_to_type(l.id).sty {\n+                    let opt_ty_bits = match cx.tables.node_id_to_type(l.id).sty {\n                         ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n                         ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n                         _ => None,\n@@ -110,7 +110,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                 false\n                             }\n                         } else {\n-                            match eval_const_expr_partial(cx.tcx, &r, ExprTypeChecked, None) {\n+                            let const_cx = ConstContext::with_tables(cx.tcx, cx.tables);\n+                            match const_cx.eval(&r, ExprTypeChecked) {\n                                 Ok(ConstVal::Integral(i)) => {\n                                     i.is_negative() ||\n                                     i.to_u64()\n@@ -129,7 +130,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 }\n             }\n             hir::ExprLit(ref lit) => {\n-                match cx.tcx.tables().node_id_to_type(e.id).sty {\n+                match cx.tables.node_id_to_type(e.id).sty {\n                     ty::TyInt(t) => {\n                         match lit.node {\n                             ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n@@ -274,11 +275,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             }\n         }\n \n-        fn check_limits<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  binop: hir::BinOp,\n-                                  l: &hir::Expr,\n-                                  r: &hir::Expr)\n-                                  -> bool {\n+        fn check_limits(cx: &LateContext,\n+                        binop: hir::BinOp,\n+                        l: &hir::Expr,\n+                        r: &hir::Expr)\n+                        -> bool {\n             let (lit, expr, swap) = match (&l.node, &r.node) {\n                 (&hir::ExprLit(_), _) => (l, r, true),\n                 (_, &hir::ExprLit(_)) => (r, l, false),\n@@ -287,7 +288,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             // Normalize the binop so that the literal is always on the RHS in\n             // the comparison\n             let norm_binop = if swap { rev_binop(binop) } else { binop };\n-            match tcx.tables().node_id_to_type(expr.id).sty {\n+            match cx.tables.node_id_to_type(expr.id).sty {\n                 ty::TyInt(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i128 = match lit.node {\n@@ -696,7 +697,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n             if gens.ty_params.is_empty() {\n                 // sizes only make sense for non-generic types\n                 let t = cx.tcx.item_type(cx.tcx.map.local_def_id(it.id));\n-                let layout = cx.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n+                let layout = cx.tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n                     let ty = cx.tcx.erase_regions(&t);\n                     ty.layout(&infcx).unwrap_or_else(|e| {\n                         bug!(\"failed to get layout for `{}`: {}\", t, e)"}, {"sha": "48d9f5e72c26dab57a38b58deeb2d5879522939e", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             return;\n         }\n \n-        let t = cx.tcx.tables().expr_ty(&expr);\n+        let t = cx.tables.expr_ty(&expr);\n         let warned = match t.sty {\n             ty::TyTuple(ref tys) if tys.is_empty() => return,\n             ty::TyNever => return,\n@@ -440,7 +440,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAllocation {\n             _ => return,\n         }\n \n-        if let Some(adjustment) = cx.tcx.tables().adjustments.get(&e.id) {\n+        if let Some(adjustment) = cx.tables.adjustments.get(&e.id) {\n             if let adjustment::Adjust::DerefRef { autoref, .. } = adjustment.kind {\n                 match autoref {\n                     Some(adjustment::AutoBorrow::Ref(_, hir::MutImmutable)) => {"}, {"sha": "3c14d38cc38211a6ad32612476a1d54ef28648c8", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 11, "deletions": 107, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -8,59 +8,31 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::hir::map as ast_map;\n+use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n \n-use rustc::hir::intravisit::{Visitor, IdRangeComputingVisitor, IdRange, NestedVisitorMap};\n-\n-use cstore::CrateMetadata;\n use encoder::EncodeContext;\n use schema::*;\n \n use rustc::hir;\n-use rustc::hir::def::Def;\n-use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, TyCtxt, Ty};\n-\n-use syntax::ast;\n+use rustc::ty;\n \n use rustc_serialize::Encodable;\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Ast<'tcx> {\n-    id_range: IdRange,\n-    body: Lazy<hir::Body>,\n-    side_tables: LazySeq<(ast::NodeId, TableEntry<'tcx>)>,\n+    pub body: Lazy<hir::Body>,\n+    pub tables: Lazy<ty::Tables<'tcx>>,\n     pub nested_bodies: LazySeq<hir::Body>,\n     pub rvalue_promotable_to_static: bool,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n-enum TableEntry<'tcx> {\n-    TypeRelativeDef(Def),\n-    NodeType(Ty<'tcx>),\n-    ItemSubsts(ty::ItemSubsts<'tcx>),\n-    Adjustment(ty::adjustment::Adjustment<'tcx>),\n-}\n-\n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-    pub fn encode_body(&mut self, body: hir::BodyId) -> Lazy<Ast<'tcx>> {\n-        let body = self.tcx.map.body(body);\n-\n-        let mut id_visitor = IdRangeComputingVisitor::new(&self.tcx.map);\n-        id_visitor.visit_body(body);\n+    pub fn encode_body(&mut self, body_id: hir::BodyId) -> Lazy<Ast<'tcx>> {\n+        let body = self.tcx.map.body(body_id);\n+        let lazy_body = self.lazy(body);\n \n-        let body_pos = self.position();\n-        body.encode(self).unwrap();\n-\n-        let tables_pos = self.position();\n-        let tables_count = {\n-            let mut visitor = SideTableEncodingIdVisitor {\n-                ecx: self,\n-                count: 0,\n-            };\n-            visitor.visit_body(body);\n-            visitor.count\n-        };\n+        let tables = self.tcx.body_tables(body_id);\n+        let lazy_tables = self.lazy(tables);\n \n         let nested_pos = self.position();\n         let nested_count = {\n@@ -76,44 +48,14 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             self.tcx.rvalue_promotable_to_static.borrow()[&body.value.id];\n \n         self.lazy(&Ast {\n-            id_range: id_visitor.result(),\n-            body: Lazy::with_position(body_pos),\n-            side_tables: LazySeq::with_position_and_length(tables_pos, tables_count),\n+            body: lazy_body,\n+            tables: lazy_tables,\n             nested_bodies: LazySeq::with_position_and_length(nested_pos, nested_count),\n             rvalue_promotable_to_static: rvalue_promotable_to_static\n         })\n     }\n }\n \n-struct SideTableEncodingIdVisitor<'a, 'b: 'a, 'tcx: 'b> {\n-    ecx: &'a mut EncodeContext<'b, 'tcx>,\n-    count: usize,\n-}\n-\n-impl<'a, 'b, 'tcx> Visitor<'tcx> for SideTableEncodingIdVisitor<'a, 'b, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.ecx.tcx.map)\n-    }\n-\n-    fn visit_id(&mut self, id: ast::NodeId) {\n-        debug!(\"Encoding side tables for id {}\", id);\n-\n-        let tcx = self.ecx.tcx;\n-        let mut encode = |entry: Option<TableEntry>| {\n-            if let Some(entry) = entry {\n-                (id, entry).encode(self.ecx).unwrap();\n-                self.count += 1;\n-            }\n-        };\n-\n-        encode(tcx.tables().type_relative_path_defs.get(&id).cloned()\n-                  .map(TableEntry::TypeRelativeDef));\n-        encode(tcx.tables().node_types.get(&id).cloned().map(TableEntry::NodeType));\n-        encode(tcx.tables().item_substs.get(&id).cloned().map(TableEntry::ItemSubsts));\n-        encode(tcx.tables().adjustments.get(&id).cloned().map(TableEntry::Adjustment));\n-    }\n-}\n-\n struct NestedBodyEncodingVisitor<'a, 'b: 'a, 'tcx: 'b> {\n     ecx: &'a mut EncodeContext<'b, 'tcx>,\n     count: usize,\n@@ -132,41 +74,3 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for NestedBodyEncodingVisitor<'a, 'b, 'tcx> {\n         self.visit_body(body);\n     }\n }\n-\n-/// Decodes an item's body from its AST in the cdata's metadata and adds it to the\n-/// ast-map.\n-pub fn decode_body<'a, 'tcx>(cdata: &CrateMetadata,\n-                             tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             def_id: DefId,\n-                             ast: Ast<'tcx>)\n-                             -> &'tcx hir::Body {\n-    debug!(\"> Decoding inlined fn: {}\", tcx.item_path_str(def_id));\n-\n-    let cnt = ast.id_range.max.as_usize() - ast.id_range.min.as_usize();\n-    let start = tcx.sess.reserve_node_ids(cnt);\n-    let id_ranges = [ast.id_range,\n-                     IdRange {\n-                         min: start,\n-                         max: ast::NodeId::new(start.as_usize() + cnt),\n-                     }];\n-\n-    for (id, entry) in ast.side_tables.decode((cdata, tcx, id_ranges)) {\n-        match entry {\n-            TableEntry::TypeRelativeDef(def) => {\n-                tcx.tables.borrow_mut().type_relative_path_defs.insert(id, def);\n-            }\n-            TableEntry::NodeType(ty) => {\n-                tcx.tables.borrow_mut().node_types.insert(id, ty);\n-            }\n-            TableEntry::ItemSubsts(item_substs) => {\n-                tcx.tables.borrow_mut().item_substs.insert(id, item_substs);\n-            }\n-            TableEntry::Adjustment(adj) => {\n-                tcx.tables.borrow_mut().adjustments.insert(id, adj);\n-            }\n-        }\n-    }\n-\n-    let body = ast.body.decode((cdata, tcx, id_ranges));\n-    ast_map::map_decoded_body(&tcx.map, def_id, body, tcx.sess.next_node_id())\n-}"}, {"sha": "efc19abb33e1b5fdb34928a940b18eff6897c471", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -97,7 +97,6 @@ pub struct CStore {\n     used_link_args: RefCell<Vec<String>>,\n     statically_included_foreign_items: RefCell<FxHashSet<DefIndex>>,\n     pub dllimport_foreign_items: RefCell<FxHashSet<DefIndex>>,\n-    pub inlined_item_cache: RefCell<DefIdMap<Option<ast::NodeId>>>,\n     pub visible_parent_map: RefCell<DefIdMap<DefId>>,\n }\n \n@@ -112,7 +111,6 @@ impl CStore {\n             statically_included_foreign_items: RefCell::new(FxHashSet()),\n             dllimport_foreign_items: RefCell::new(FxHashSet()),\n             visible_parent_map: RefCell::new(FxHashMap()),\n-            inlined_item_cache: RefCell::new(FxHashMap()),\n         }\n     }\n "}, {"sha": "3d025e984b0400f903e76fe76a10ff2947647da4", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -434,27 +434,14 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                                def_id: DefId)\n                                -> Option<&'tcx hir::Body>\n     {\n-        self.dep_graph.read(DepNode::MetaData(def_id));\n-\n-        if let Some(&cached) = self.inlined_item_cache.borrow().get(&def_id) {\n-            return cached.map(|root_id| {\n-                // Already inline\n-                debug!(\"maybe_get_item_body({}): already inline\", tcx.item_path_str(def_id));\n-                tcx.map.expect_inlined_body(root_id)\n-            });\n+        if let Some(cached) = tcx.map.get_inlined_body(def_id) {\n+            return Some(cached);\n         }\n \n+        self.dep_graph.read(DepNode::MetaData(def_id));\n         debug!(\"maybe_get_item_body({}): inlining item\", tcx.item_path_str(def_id));\n \n-        let inlined = self.get_crate_data(def_id.krate).maybe_get_item_body(tcx, def_id.index);\n-\n-        self.inlined_item_cache.borrow_mut().insert(def_id, inlined.map(|body| {\n-            let root_id = tcx.map.get_parent_node(body.value.id);\n-            assert_eq!(tcx.map.get_parent_node(root_id), root_id);\n-            root_id\n-        }));\n-\n-        inlined\n+        self.get_crate_data(def_id.krate).maybe_get_item_body(tcx, def_id.index)\n     }\n \n     fn item_body_nested_bodies(&self, def: DefId) -> BTreeMap<hir::BodyId, hir::Body> {"}, {"sha": "f3a673898b25c10c112c67b14001057f7b945a3c", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 9, "deletions": 54, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -10,13 +10,11 @@\n \n // Decoding metadata from a single crate's metadata\n \n-use astencode::decode_body;\n use cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary};\n use schema::*;\n \n use rustc::hir::map::{DefKey, DefPath, DefPathData};\n use rustc::hir;\n-use rustc::hir::intravisit::IdRange;\n \n use rustc::middle::cstore::LinkagePreference;\n use rustc::hir::def::{self, Def, CtorKind};\n@@ -40,7 +38,7 @@ use std::u32;\n \n use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n use syntax::attr;\n-use syntax::ast::{self, NodeId};\n+use syntax::ast;\n use syntax::codemap;\n use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP};\n use rustc_i128::{u128, i128};\n@@ -50,8 +48,6 @@ pub struct DecodeContext<'a, 'tcx: 'a> {\n     cdata: Option<&'a CrateMetadata>,\n     sess: Option<&'a Session>,\n     tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n-    from_id_range: IdRange,\n-    to_id_range: IdRange,\n \n     // Cache the last used filemap for translating spans as an optimization.\n     last_filemap_index: usize,\n@@ -67,18 +63,12 @@ pub trait Metadata<'a, 'tcx>: Copy {\n     fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> { None }\n \n     fn decoder(self, pos: usize) -> DecodeContext<'a, 'tcx> {\n-        let id_range = IdRange {\n-            min: NodeId::from_u32(u32::MIN),\n-            max: NodeId::from_u32(u32::MAX),\n-        };\n         let tcx = self.tcx();\n         DecodeContext {\n             opaque: opaque::Decoder::new(self.raw_bytes(), pos),\n             cdata: self.cdata(),\n             sess: self.sess().or(tcx.map(|tcx| tcx.sess)),\n             tcx: tcx,\n-            from_id_range: id_range,\n-            to_id_range: id_range,\n             last_filemap_index: 0,\n             lazy_state: LazyState::NoNode,\n         }\n@@ -128,26 +118,6 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'a, 'tcx, 'tcx>\n     }\n }\n \n-// HACK(eddyb) Only used by astencode to customize the from/to IdRange's.\n-impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'a, 'tcx, 'tcx>, [IdRange; 2]) {\n-    fn raw_bytes(self) -> &'a [u8] {\n-        self.0.raw_bytes()\n-    }\n-    fn cdata(self) -> Option<&'a CrateMetadata> {\n-        Some(self.0)\n-    }\n-    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> {\n-        Some(self.1)\n-    }\n-\n-    fn decoder(self, pos: usize) -> DecodeContext<'a, 'tcx> {\n-        let mut dcx = (self.0, self.1).decoder(pos);\n-        dcx.from_id_range = self.2[0];\n-        dcx.to_id_range = self.2[1];\n-        dcx\n-    }\n-}\n-\n impl<'a, 'tcx: 'a, T: Decodable> Lazy<T> {\n     pub fn decode<M: Metadata<'a, 'tcx>>(self, meta: M) -> T {\n         let mut dcx = meta.decoder(self.position);\n@@ -256,28 +226,6 @@ impl<'a, 'tcx, T> SpecializedDecoder<LazySeq<T>> for DecodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<NodeId> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<NodeId, Self::Error> {\n-        let id = u32::decode(self)?;\n-\n-        // from_id_range should be non-empty\n-        assert!(!self.from_id_range.empty());\n-        // Make sure that translating the NodeId will actually yield a\n-        // meaningful result\n-        if !self.from_id_range.contains(NodeId::from_u32(id)) {\n-            bug!(\"NodeId::decode: {} out of DecodeContext range ({:?} -> {:?})\",\n-                 id,\n-                 self.from_id_range,\n-                 self.to_id_range);\n-        }\n-\n-        // Use wrapping arithmetic because otherwise it introduces control flow.\n-        // Maybe we should just have the control flow? -- aatch\n-        Ok(NodeId::from_u32(id.wrapping_sub(self.from_id_range.min.as_u32())\n-            .wrapping_add(self.to_id_range.min.as_u32())))\n-    }\n-}\n-\n impl<'a, 'tcx> SpecializedDecoder<CrateNum> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<CrateNum, Self::Error> {\n         let cnum = CrateNum::from_u32(u32::decode(self)?);\n@@ -829,7 +777,14 @@ impl<'a, 'tcx> CrateMetadata {\n                                -> Option<&'tcx hir::Body> {\n         if self.is_proc_macro(id) { return None; }\n         self.entry(id).ast.map(|ast| {\n-            decode_body(self, tcx, self.local_def_id(id), ast.decode(self))\n+            let def_id = self.local_def_id(id);\n+            let ast = ast.decode(self);\n+\n+            let tables = ast.tables.decode((self, tcx));\n+            tcx.tables.borrow_mut().insert(def_id, tcx.alloc_tables(tables));\n+\n+            let body = ast.body.decode((self, tcx));\n+            tcx.map.intern_inlined_body(def_id, body)\n         })\n     }\n "}, {"sha": "7de768b7b9049447c6ed9995545d7a73ef918d79", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -1037,7 +1037,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let data = ClosureData {\n             kind: tcx.closure_kind(def_id),\n-            ty: self.lazy(&tcx.tables().closure_tys[&def_id]),\n+            ty: self.lazy(&tcx.closure_tys.borrow()[&def_id]),\n         };\n \n         Entry {"}, {"sha": "7347841a5f1ef396ecd473c467601891cb4cda88", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -169,7 +169,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let upvar_decls: Vec<_> = tcx.with_freevars(fn_id, |freevars| {\n         freevars.iter().map(|fv| {\n             let var_id = tcx.map.as_local_node_id(fv.def.def_id()).unwrap();\n-            let by_ref = tcx.tables().upvar_capture(ty::UpvarId {\n+            let by_ref = hir.tables().upvar_capture(ty::UpvarId {\n                 var_id: var_id,\n                 closure_expr_id: fn_id\n             }).map_or(false, |capture| match capture {\n@@ -195,13 +195,12 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n }\n \n pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n-                                       item_id: ast::NodeId,\n                                        body_id: hir::BodyId)\n                                        -> Mir<'tcx> {\n     let tcx = hir.tcx();\n     let ast_expr = &tcx.map.body(body_id).value;\n-    let ty = tcx.tables().expr_ty_adjusted(ast_expr);\n-    let span = tcx.map.span(item_id);\n+    let ty = hir.tables().expr_ty_adjusted(ast_expr);\n+    let span = tcx.map.span(tcx.map.body_owner(body_id));\n     let mut builder = Builder::new(hir, span, 0, ty);\n \n     let extent = tcx.region_maps.temporary_scope(ast_expr.id)\n@@ -306,7 +305,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let lvalue = Lvalue::Local(Local::new(index + 1));\n \n             if let Some(pattern) = pattern {\n-                let pattern = Pattern::from_hir(self.hir.tcx(), pattern);\n+                let pattern = Pattern::from_hir(self.hir.tcx(), self.hir.tables(), pattern);\n                 scope = self.declare_bindings(scope, ast_body.span, &pattern);\n                 unpack!(block = self.lvalue_into_pattern(block, pattern, &lvalue));\n             }"}, {"sha": "4b3d62fd6d6efe3042a68e32dd8ff71599b3c273", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -61,7 +61,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         let remainder_extent =\n                             cx.tcx.region_maps.lookup_code_extent(remainder_extent);\n \n-                        let pattern = Pattern::from_hir(cx.tcx, &local.pat);\n+                        let pattern = Pattern::from_hir(cx.tcx, cx.tables(), &local.pat);\n                         result.push(StmtRef::Mirror(Box::new(Stmt {\n                             span: stmt.span,\n                             kind: StmtKind::Let {\n@@ -82,7 +82,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n pub fn to_expr_ref<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    block: &'tcx hir::Block)\n                                    -> ExprRef<'tcx> {\n-    let block_ty = cx.tcx.tables().node_id_to_type(block.id);\n+    let block_ty = cx.tables().node_id_to_type(block.id);\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(block.id);\n     let expr = Expr {\n         ty: block_ty,"}, {"sha": "fe10fb57c35e888caec43b8fe9cd975db3d7bc0f", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -17,7 +17,7 @@ use hair::cx::to_ref::ToRef;\n use rustc::hir::map;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::middle::const_val::ConstVal;\n-use rustc_const_eval as const_eval;\n+use rustc_const_eval::{ConstContext, EvalHint, fatal_const_eval_err};\n use rustc::ty::{self, AdtKind, VariantDef, Ty};\n use rustc::ty::cast::CastKind as TyCastKind;\n use rustc::hir;\n@@ -33,7 +33,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n         debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n \n         let mut expr = make_mirror_unadjusted(cx, self);\n-        let adj = cx.tcx.tables().adjustments.get(&self.id).cloned();\n+        let adj = cx.tables().adjustments.get(&self.id).cloned();\n \n         debug!(\"make_mirror: unadjusted-expr={:?} applying adjustments={:?}\",\n                expr,\n@@ -80,13 +80,13 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     let i = i as u32;\n                     let adjusted_ty =\n                         expr.ty.adjust_for_autoderef(cx.tcx, self.id, self.span, i, |mc| {\n-                            cx.tcx.tables().method_map.get(&mc).map(|m| m.ty)\n+                            cx.tables().method_map.get(&mc).map(|m| m.ty)\n                         });\n                     debug!(\"make_mirror: autoderef #{}, adjusted_ty={:?}\",\n                            i,\n                            adjusted_ty);\n                     let method_key = ty::MethodCall::autoderef(self.id, i);\n-                    let meth_ty = cx.tcx.tables().method_map.get(&method_key).map(|m| m.ty);\n+                    let meth_ty = cx.tables().method_map.get(&method_key).map(|m| m.ty);\n                     let kind = if let Some(meth_ty) = meth_ty {\n                         debug!(\"make_mirror: overloaded autoderef (meth_ty={:?})\", meth_ty);\n \n@@ -217,7 +217,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                           expr: &'tcx hir::Expr)\n                                           -> Expr<'tcx> {\n-    let expr_ty = cx.tcx.tables().expr_ty(expr);\n+    let expr_ty = cx.tables().expr_ty(expr);\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n \n     let kind = match expr.node {\n@@ -236,7 +236,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprCall(ref fun, ref args) => {\n-            if cx.tcx.tables().is_method_call(expr.id) {\n+            if cx.tables().is_method_call(expr.id) {\n                 // The callee is something implementing Fn, FnMut, or FnOnce.\n                 // Find the actual method implementation being called and\n                 // build the appropriate UFCS call expression with the\n@@ -285,9 +285,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     None\n                 };\n                 if let Some((adt_def, index)) = adt_data {\n-                    let substs = cx.tcx\n-                        .tables()\n-                        .node_id_item_substs(fun.id)\n+                    let substs = cx.tables().node_id_item_substs(fun.id)\n                         .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n                     let field_refs = args.iter()\n                         .enumerate()\n@@ -307,7 +305,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     }\n                 } else {\n                     ExprKind::Call {\n-                        ty: cx.tcx.tables().node_id_to_type(fun.id),\n+                        ty: cx.tables().node_id_to_type(fun.id),\n                         fun: fun.to_ref(),\n                         args: args.to_ref(),\n                     }\n@@ -337,7 +335,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-            if cx.tcx.tables().is_method_call(expr.id) {\n+            if cx.tables().is_method_call(expr.id) {\n                 let pass_args = if op.node.is_by_value() {\n                     PassArgs::ByValue\n                 } else {\n@@ -361,7 +359,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprLit(..) => ExprKind::Literal { literal: cx.const_eval_literal(expr) },\n \n         hir::ExprBinary(op, ref lhs, ref rhs) => {\n-            if cx.tcx.tables().is_method_call(expr.id) {\n+            if cx.tables().is_method_call(expr.id) {\n                 let pass_args = if op.node.is_by_value() {\n                     PassArgs::ByValue\n                 } else {\n@@ -421,7 +419,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprIndex(ref lhs, ref index) => {\n-            if cx.tcx.tables().is_method_call(expr.id) {\n+            if cx.tables().is_method_call(expr.id) {\n                 overloaded_lvalue(cx,\n                                   expr,\n                                   ty::MethodCall::expr(expr.id),\n@@ -437,7 +435,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnDeref, ref arg) => {\n-            if cx.tcx.tables().is_method_call(expr.id) {\n+            if cx.tables().is_method_call(expr.id) {\n                 overloaded_lvalue(cx,\n                                   expr,\n                                   ty::MethodCall::expr(expr.id),\n@@ -450,7 +448,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnNot, ref arg) => {\n-            if cx.tcx.tables().is_method_call(expr.id) {\n+            if cx.tables().is_method_call(expr.id) {\n                 overloaded_operator(cx,\n                                     expr,\n                                     ty::MethodCall::expr(expr.id),\n@@ -466,7 +464,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n-            if cx.tcx.tables().is_method_call(expr.id) {\n+            if cx.tables().is_method_call(expr.id) {\n                 overloaded_operator(cx,\n                                     expr,\n                                     ty::MethodCall::expr(expr.id),\n@@ -500,8 +498,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                 base: base.as_ref().map(|base| {\n                                     FruInfo {\n                                         base: base.to_ref(),\n-                                        field_types: cx.tcx.tables().fru_field_types[&expr.id]\n-                                            .clone(),\n+                                        field_types: cx.tables().fru_field_types[&expr.id].clone(),\n                                     }\n                                 }),\n                             }\n@@ -541,7 +538,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprClosure(..) => {\n-            let closure_ty = cx.tcx.tables().expr_ty(expr);\n+            let closure_ty = cx.tables().expr_ty(expr);\n             let (def_id, substs) = match closure_ty.sty {\n                 ty::TyClosure(def_id, substs) => (def_id, substs),\n                 _ => {\n@@ -562,7 +559,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprPath(ref qpath) => {\n-            let def = cx.tcx.tables().qpath_def(qpath, expr.id);\n+            let def = cx.tables().qpath_def(qpath, expr.id);\n             convert_path_expr(cx, expr, def)\n         }\n \n@@ -575,17 +572,21 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         // Now comes the rote stuff:\n-        hir::ExprRepeat(ref v, c) => {\n-            let c = &cx.tcx.map.body(c).value;\n+        hir::ExprRepeat(ref v, count) => {\n+            let tcx = cx.tcx.global_tcx();\n+            let c = &cx.tcx.map.body(count).value;\n+            let count = match ConstContext::new(tcx, count).eval(c, EvalHint::ExprTypeChecked) {\n+                Ok(ConstVal::Integral(ConstInt::Usize(u))) => u,\n+                Ok(other) => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n+                Err(s) => fatal_const_eval_err(tcx, &s, c.span, \"expression\")\n+            };\n+\n             ExprKind::Repeat {\n                 value: v.to_ref(),\n                 count: TypedConstVal {\n-                    ty: cx.tcx.tables().expr_ty(c),\n+                    ty: cx.tcx.types.usize,\n                     span: c.span,\n-                    value: match const_eval::eval_const_expr(cx.tcx.global_tcx(), c) {\n-                        ConstVal::Integral(ConstInt::Usize(u)) => u,\n-                        other => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n-                    },\n+                    value: count\n                 }\n             }\n         }\n@@ -627,7 +628,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n         hir::ExprField(ref source, name) => {\n-            let index = match cx.tcx.tables().expr_ty_adjusted(source).sty {\n+            let index = match cx.tables().expr_ty_adjusted(source).sty {\n                 ty::TyAdt(adt_def, _) => adt_def.variants[0].index_of_field_named(name.node),\n                 ref ty => span_bug!(expr.span, \"field of non-ADT: {:?}\", ty),\n             };\n@@ -679,7 +680,7 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                  expr: &hir::Expr,\n                                  method_call: ty::MethodCall)\n                                  -> Expr<'tcx> {\n-    let callee = cx.tcx.tables().method_map[&method_call];\n+    let callee = cx.tables().method_map[&method_call];\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n     Expr {\n         temp_lifetime: temp_lifetime,\n@@ -703,7 +704,7 @@ fn to_borrow_kind(m: hir::Mutability) -> BorrowKind {\n \n fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n     Arm {\n-        patterns: arm.pats.iter().map(|p| Pattern::from_hir(cx.tcx, p)).collect(),\n+        patterns: arm.pats.iter().map(|p| Pattern::from_hir(cx.tcx, cx.tables(), p)).collect(),\n         guard: arm.guard.to_ref(),\n         body: arm.body.to_ref(),\n     }\n@@ -713,9 +714,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      expr: &'tcx hir::Expr,\n                                      def: Def)\n                                      -> ExprKind<'tcx> {\n-    let substs = cx.tcx\n-        .tables()\n-        .node_id_item_substs(expr.id)\n+    let substs = cx.tables().node_id_item_substs(expr.id)\n         .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n     let def_id = match def {\n         // A regular function, constructor function or a constant.\n@@ -728,7 +727,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         Def::StructCtor(def_id, CtorKind::Const) |\n         Def::VariantCtor(def_id, CtorKind::Const) => {\n-            match cx.tcx.tables().node_id_to_type(expr.id).sty {\n+            match cx.tables().node_id_to_type(expr.id).sty {\n                 // A unit struct/variant which is used as a value.\n                 // We return a completely different ExprKind here to account for this special case.\n                 ty::TyAdt(adt_def, substs) => {\n@@ -776,7 +775,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                    id_var,\n                    index,\n                    closure_expr_id);\n-            let var_ty = cx.tcx.tables().node_id_to_type(id_var);\n+            let var_ty = cx.tables().node_id_to_type(id_var);\n \n             let body_id = match cx.tcx.map.find(closure_expr_id) {\n                 Some(map::NodeExpr(expr)) => {\n@@ -793,7 +792,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             };\n \n             // FIXME free regions in closures are not right\n-            let closure_ty = cx.tcx.tables().node_id_to_type(closure_expr_id);\n+            let closure_ty = cx.tables().node_id_to_type(closure_expr_id);\n \n             // FIXME we're just hard-coding the idea that the\n             // signature will be &self or &mut self and hence will\n@@ -869,7 +868,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 var_id: id_var,\n                 closure_expr_id: closure_expr_id,\n             };\n-            let upvar_capture = match cx.tcx.tables().upvar_capture(upvar_id) {\n+            let upvar_capture = match cx.tables().upvar_capture(upvar_id) {\n                 Some(c) => c,\n                 None => {\n                     span_bug!(expr.span, \"no upvar_capture for {:?}\", upvar_id);\n@@ -948,7 +947,7 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n             argrefs.extend(args.iter()\n                 .map(|arg| {\n-                    let arg_ty = cx.tcx.tables().expr_ty_adjusted(arg);\n+                    let arg_ty = cx.tables().expr_ty_adjusted(arg);\n                     let adjusted_ty = cx.tcx.mk_ref(region,\n                                                     ty::TypeAndMut {\n                                                         ty: arg_ty,\n@@ -990,7 +989,7 @@ fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     // line up (this is because `*x` and `x[y]` represent lvalues):\n \n     // to find the type &T of the content returned by the method;\n-    let ref_ty = cx.tcx.tables().method_map[&method_call].ty.fn_ret();\n+    let ref_ty = cx.tables().method_map[&method_call].ty.fn_ret();\n     let ref_ty = cx.tcx.no_late_bound_regions(&ref_ty).unwrap();\n     // callees always have all late-bound regions fully instantiated,\n \n@@ -1019,9 +1018,9 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         var_id: id_var,\n         closure_expr_id: closure_expr.id,\n     };\n-    let upvar_capture = cx.tcx.tables().upvar_capture(upvar_id).unwrap();\n+    let upvar_capture = cx.tables().upvar_capture(upvar_id).unwrap();\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(closure_expr.id);\n-    let var_ty = cx.tcx.tables().node_id_to_type(id_var);\n+    let var_ty = cx.tables().node_id_to_type(id_var);\n     let captured_var = Expr {\n         temp_lifetime: temp_lifetime,\n         ty: var_ty,"}, {"sha": "4b553a71b83259df57478b4a33273efe42a83dfa", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -18,9 +18,8 @@ use hair::*;\n use rustc::mir::transform::MirSource;\n \n use rustc::middle::const_val::ConstVal;\n-use rustc_const_eval as const_eval;\n+use rustc_const_eval::{ConstContext, EvalHint, fatal_const_eval_err};\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::infer::InferCtxt;\n@@ -52,17 +51,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             MirSource::Promoted(..) => bug!(),\n         };\n \n-        let src_node_id = src.item_id();\n-\n-        // We are going to be accessing various tables\n-        // generated by TypeckItemBody; we also assume\n-        // that the body passes type check. These tables\n-        // are not individually tracked, so just register\n-        // a read here.\n-        let src_def_id = infcx.tcx.map.local_def_id(src_node_id);\n-        infcx.tcx.dep_graph.read(DepNode::TypeckItemBody(src_def_id));\n-\n-        let attrs = infcx.tcx.map.attrs(src_node_id);\n+        let attrs = infcx.tcx.map.attrs(src.item_id());\n \n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on\n@@ -128,7 +117,11 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn const_eval_literal(&mut self, e: &hir::Expr) -> Literal<'tcx> {\n-        Literal::Value { value: const_eval::eval_const_expr(self.tcx.global_tcx(), e) }\n+        let tcx = self.tcx.global_tcx();\n+        match ConstContext::with_tables(tcx, self.tables()).eval(e, EvalHint::ExprTypeChecked) {\n+            Ok(value) => Literal::Value { value: value },\n+            Err(s) => fatal_const_eval_err(tcx, &s, e.span, \"expression\")\n+        }\n     }\n \n     pub fn trait_method(&mut self,\n@@ -177,6 +170,10 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         self.tcx\n     }\n \n+    pub fn tables(&self) -> &'a ty::Tables<'gcx> {\n+        self.infcx.tables.expect_interned()\n+    }\n+\n     pub fn check_overflow(&self) -> bool {\n         self.check_overflow\n     }"}, {"sha": "453c3e43b6b86c6e7955fafb153ea11384c71399", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 48, "deletions": 153, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -18,19 +18,18 @@\n \n use build;\n use rustc::dep_graph::DepNode;\n-use rustc::hir::def_id::DefId;\n use rustc::mir::Mir;\n use rustc::mir::transform::MirSource;\n use rustc::mir::visit::MutVisitor;\n use pretty;\n use hair::cx::Cx;\n \n-use rustc::infer::InferCtxtBuilder;\n+use rustc::infer::InferCtxt;\n use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n use rustc::hir;\n-use rustc::hir::intravisit::{self, FnKind, Visitor, NestedVisitorMap};\n+use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -80,34 +79,50 @@ struct BuildMir<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>\n }\n \n-/// Helper type of a temporary returned by BuildMir::cx(...).\n-/// Necessary because we can't write the following bound:\n-/// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(Cx<'b, 'gcx, 'tcx>).\n-struct CxBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    src: MirSource,\n-    def_id: DefId,\n-    infcx: InferCtxtBuilder<'a, 'gcx, 'tcx>\n-}\n+fn build<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                         body_id: hir::BodyId)\n+                         -> (Mir<'tcx>, MirSource) {\n+    let tcx = infcx.tcx.global_tcx();\n \n-impl<'a, 'gcx, 'tcx> BuildMir<'a, 'gcx> {\n-    fn cx<'b>(&'b mut self, src: MirSource) -> CxBuilder<'b, 'gcx, 'tcx> {\n-        let param_env = ty::ParameterEnvironment::for_item(self.tcx, src.item_id());\n-        let def_id = self.tcx.map.local_def_id(src.item_id());\n-        CxBuilder {\n-            src: src,\n-            infcx: self.tcx.infer_ctxt(None, Some(param_env), Reveal::NotSpecializable),\n-            def_id: def_id\n-        }\n+    let item_id = tcx.map.body_owner(body_id);\n+    let src = MirSource::from_node(tcx, item_id);\n+    let cx = Cx::new(infcx, src);\n+    if let MirSource::Fn(id) = src {\n+        // fetch the fully liberated fn signature (that is, all bound\n+        // types/lifetimes replaced)\n+        let fn_sig = cx.tables().liberated_fn_sigs[&id].clone();\n+\n+        let ty = tcx.item_type(tcx.map.local_def_id(id));\n+        let (abi, implicit_argument) = if let ty::TyClosure(..) = ty.sty {\n+            (Abi::Rust, Some((closure_self_ty(tcx, id, body_id), None)))\n+        } else {\n+            (ty.fn_abi(), None)\n+        };\n+\n+        let body = tcx.map.body(body_id);\n+        let explicit_arguments =\n+            body.arguments\n+                .iter()\n+                .enumerate()\n+                .map(|(index, arg)| {\n+                    (fn_sig.inputs()[index], Some(&*arg.pat))\n+                });\n+\n+        let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n+        (build::construct_fn(cx, id, arguments, abi, fn_sig.output(), body), src)\n+    } else {\n+        (build::construct_const(cx, body_id), src)\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> CxBuilder<'a, 'gcx, 'tcx> {\n-    fn build<F>(&'tcx mut self, f: F)\n-        where F: for<'b> FnOnce(Cx<'b, 'gcx, 'tcx>) -> Mir<'tcx>\n-    {\n-        let (src, def_id) = (self.src, self.def_id);\n-        self.infcx.enter(|infcx| {\n-            let mut mir = f(Cx::new(&infcx, src));\n+impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n+        self.tcx.infer_ctxt(body_id, Reveal::NotSpecializable).enter(|infcx| {\n+            let (mut mir, src) = build(&infcx, body_id);\n \n             // Convert the Mir to global types.\n             let tcx = infcx.tcx.global_tcx();\n@@ -117,152 +132,32 @@ impl<'a, 'gcx, 'tcx> CxBuilder<'a, 'gcx, 'tcx> {\n             };\n             globalizer.visit_mir(&mut mir);\n             let mir = unsafe {\n-                mem::transmute::<Mir, Mir<'gcx>>(mir)\n+                mem::transmute::<Mir, Mir<'tcx>>(mir)\n             };\n \n             pretty::dump_mir(tcx, \"mir_map\", &0, src, &mir);\n \n             let mir = tcx.alloc_mir(mir);\n+            let def_id = tcx.map.local_def_id(src.item_id());\n             assert!(tcx.mir_map.borrow_mut().insert(def_id, mir).is_none());\n         });\n-    }\n-}\n-\n-impl<'a, 'gcx> BuildMir<'a, 'gcx> {\n-    fn build_const_integer(&mut self, body: hir::BodyId) {\n-        let body = self.tcx.map.body(body);\n-        // FIXME(eddyb) Closures should have separate\n-        // function definition IDs and expression IDs.\n-        // Type-checking should not let closures get\n-        // this far in an integer constant position.\n-        if let hir::ExprClosure(..) = body.value.node {\n-            return;\n-        }\n-        self.cx(MirSource::Const(body.value.id)).build(|cx| {\n-            build::construct_const(cx, body.value.id, body.id())\n-        });\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n-    }\n-\n-    // Const and static items.\n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        match item.node {\n-            hir::ItemConst(_, expr) => {\n-                self.cx(MirSource::Const(item.id)).build(|cx| {\n-                    build::construct_const(cx, item.id, expr)\n-                });\n-            }\n-            hir::ItemStatic(_, m, expr) => {\n-                self.cx(MirSource::Static(item.id, m)).build(|cx| {\n-                    build::construct_const(cx, item.id, expr)\n-                });\n-            }\n-            _ => {}\n-        }\n-        intravisit::walk_item(self, item);\n-    }\n-\n-    // Trait associated const defaults.\n-    fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n-        if let hir::TraitItemKind::Const(_, Some(expr)) = item.node {\n-            self.cx(MirSource::Const(item.id)).build(|cx| {\n-                build::construct_const(cx, item.id, expr)\n-            });\n-        }\n-        intravisit::walk_trait_item(self, item);\n-    }\n-\n-    // Impl associated const.\n-    fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n-        if let hir::ImplItemKind::Const(_, expr) = item.node {\n-            self.cx(MirSource::Const(item.id)).build(|cx| {\n-                build::construct_const(cx, item.id, expr)\n-            });\n-        }\n-        intravisit::walk_impl_item(self, item);\n-    }\n-\n-    // Repeat counts, i.e. [expr; constant].\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        if let hir::ExprRepeat(_, count) = expr.node {\n-            self.build_const_integer(count);\n-        }\n-        intravisit::walk_expr(self, expr);\n-    }\n-\n-    // Array lengths, i.e. [T; constant].\n-    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        if let hir::TyArray(_, length) = ty.node {\n-            self.build_const_integer(length);\n-        }\n-        intravisit::walk_ty(self, ty);\n-    }\n-\n-    // Enum variant discriminant values.\n-    fn visit_variant(&mut self, v: &'tcx hir::Variant,\n-                     g: &'tcx hir::Generics, item_id: ast::NodeId) {\n-        if let Some(expr) = v.node.disr_expr {\n-            self.build_const_integer(expr);\n-        }\n-        intravisit::walk_variant(self, v, g, item_id);\n-    }\n-\n-    fn visit_fn(&mut self,\n-                fk: FnKind<'tcx>,\n-                decl: &'tcx hir::FnDecl,\n-                body_id: hir::BodyId,\n-                span: Span,\n-                id: ast::NodeId) {\n-        // fetch the fully liberated fn signature (that is, all bound\n-        // types/lifetimes replaced)\n-        let fn_sig = match self.tcx.tables().liberated_fn_sigs.get(&id) {\n-            Some(f) => f.clone(),\n-            None => {\n-                span_bug!(span, \"no liberated fn sig for {:?}\", id);\n-            }\n-        };\n-\n-        let (abi, implicit_argument) = if let FnKind::Closure(..) = fk {\n-            (Abi::Rust, Some((closure_self_ty(self.tcx, id, body_id.node_id), None)))\n-        } else {\n-            let def_id = self.tcx.map.local_def_id(id);\n-            (self.tcx.item_type(def_id).fn_abi(), None)\n-        };\n \n         let body = self.tcx.map.body(body_id);\n-        let explicit_arguments =\n-            body.arguments\n-                .iter()\n-                .enumerate()\n-                .map(|(index, arg)| {\n-                    (fn_sig.inputs()[index], Some(&*arg.pat))\n-                });\n-\n-        let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n-        self.cx(MirSource::Fn(id)).build(|cx| {\n-            build::construct_fn(cx, id, arguments, abi, fn_sig.output(), body)\n-        });\n-\n-        intravisit::walk_fn(self, fk, decl, body_id, span, id);\n+        self.visit_body(body);\n     }\n }\n \n fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              closure_expr_id: ast::NodeId,\n-                             body_id: ast::NodeId)\n+                             body_id: hir::BodyId)\n                              -> Ty<'tcx> {\n-    let closure_ty = tcx.tables().node_id_to_type(closure_expr_id);\n+    let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_id);\n \n     // We're just hard-coding the idea that the signature will be\n     // &self or &mut self and hence will have a bound region with\n     // number 0, hokey.\n     let region = ty::Region::ReFree(ty::FreeRegion {\n-        scope: tcx.region_maps.item_extent(body_id),\n+        scope: tcx.region_maps.item_extent(body_id.node_id),\n         bound_region: ty::BoundRegion::BrAnon(0),\n     });\n     let region = tcx.mk_region(region);"}, {"sha": "fea27ee5c54837736cc049d957cb7b835ad10a4e", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -1038,7 +1038,7 @@ impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants {\n         // Statics must be Sync.\n         if mode == Mode::Static {\n             let ty = mir.return_ty;\n-            tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n+            tcx.infer_ctxt((), Reveal::NotSpecializable).enter(|infcx| {\n                 let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);\n                 let mut fulfillment_cx = traits::FulfillmentContext::new();\n                 fulfillment_cx.register_bound(&infcx, ty,"}, {"sha": "0fabbe6678ad8810c029db2a1434d810e494eca1", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -725,7 +725,7 @@ impl<'tcx> MirPass<'tcx> for TypeckMir {\n             return;\n         }\n         let param_env = ty::ParameterEnvironment::for_item(tcx, src.item_id());\n-        tcx.infer_ctxt(None, Some(param_env), Reveal::NotSpecializable).enter(|infcx| {\n+        tcx.infer_ctxt(param_env, Reveal::NotSpecializable).enter(|infcx| {\n             let mut checker = TypeChecker::new(&infcx, src.item_id());\n             {\n                 let mut verifier = TypeVerifier::new(&mut checker, mir);"}, {"sha": "8f12817511ad3bbccd6c9a90b992d67151825a1c", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 37, "deletions": 28, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -26,10 +26,9 @@\n \n use rustc::dep_graph::DepNode;\n use rustc::ty::cast::CastKind;\n-use rustc_const_eval::{ConstEvalErr, compare_lit_exprs};\n-use rustc_const_eval::{eval_const_expr_partial};\n+use rustc_const_eval::{ConstEvalErr, ConstContext};\n use rustc_const_eval::ErrKind::{IndexOpFeatureGated, UnimplementedConstVal, MiscCatchAll, Math};\n-use rustc_const_eval::ErrKind::{ErroneousReferencedConstant, MiscBinaryOp, NonConstPath};\n+use rustc_const_eval::ErrKind::{ErroneousReferencedConstant, MiscBinaryOp, NonConstPath, BadType};\n use rustc_const_eval::ErrKind::UnresolvedPath;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_math::{ConstMathErr, Op};\n@@ -61,15 +60,18 @@ struct CheckCrateVisitor<'a, 'tcx: 'a> {\n     promotable: bool,\n     mut_rvalue_borrows: NodeSet,\n     param_env: ty::ParameterEnvironment<'tcx>,\n+    tables: &'a ty::Tables<'tcx>,\n }\n \n impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n     fn check_const_eval(&self, expr: &'gcx hir::Expr) {\n-        if let Err(err) = eval_const_expr_partial(self.tcx, expr, ExprTypeChecked, None) {\n+        let const_cx = ConstContext::with_tables(self.tcx, self.tables);\n+        if let Err(err) = const_cx.eval(expr, ExprTypeChecked) {\n             match err.kind {\n                 UnimplementedConstVal(_) => {}\n                 IndexOpFeatureGated => {}\n                 ErroneousReferencedConstant(_) => {}\n+                BadType(_) => {}\n                 _ => {\n                     self.tcx.sess.add_lint(CONST_ERR,\n                                            expr.id,\n@@ -111,36 +113,42 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        match self.tcx.rvalue_promotable_to_static.borrow_mut().entry(body.node_id) {\n+    fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n+        match self.tcx.rvalue_promotable_to_static.borrow_mut().entry(body_id.node_id) {\n             Entry::Occupied(_) => return,\n             Entry::Vacant(entry) => {\n                 // Prevent infinite recursion on re-entry.\n                 entry.insert(false);\n             }\n         }\n \n-        let item_id = self.tcx.map.body_owner(body);\n+        let item_id = self.tcx.map.body_owner(body_id);\n \n         let outer_in_fn = self.in_fn;\n         self.in_fn = match MirSource::from_node(self.tcx, item_id) {\n             MirSource::Fn(_) => true,\n             _ => false\n         };\n \n-        let body = self.tcx.map.body(body);\n+        let outer_tables = self.tables;\n+        self.tables = self.tcx.item_tables(self.tcx.map.local_def_id(item_id));\n+\n+        let body = self.tcx.map.body(body_id);\n         if !self.in_fn {\n             self.check_const_eval(&body.value);\n         }\n \n-        let param_env = ty::ParameterEnvironment::for_item(self.tcx, item_id);\n-        let outer_param_env = mem::replace(&mut self.param_env, param_env);\n-        self.tcx.infer_ctxt(None, Some(self.param_env.clone()), Reveal::NotSpecializable)\n-            .enter(|infcx| euv::ExprUseVisitor::new(self, &infcx).consume_body(body));\n+        let outer_penv = self.tcx.infer_ctxt(body_id, Reveal::NotSpecializable).enter(|infcx| {\n+            let param_env = infcx.parameter_environment.clone();\n+            let outer_penv = mem::replace(&mut self.param_env, param_env);\n+            euv::ExprUseVisitor::new(self, &infcx).consume_body(body);\n+            outer_penv\n+        });\n \n         self.visit_body(body);\n \n-        self.param_env = outer_param_env;\n+        self.param_env = outer_penv;\n+        self.tables = outer_tables;\n         self.in_fn = outer_in_fn;\n     }\n \n@@ -150,10 +158,8 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n                 self.check_const_eval(lit);\n             }\n             PatKind::Range(ref start, ref end) => {\n-                self.check_const_eval(start);\n-                self.check_const_eval(end);\n-\n-                match compare_lit_exprs(self.tcx, p.span, start, end) {\n+                let const_cx = ConstContext::with_tables(self.tcx, self.tables);\n+                match const_cx.compare_lit_exprs(p.span, start, end) {\n                     Ok(Ordering::Less) |\n                     Ok(Ordering::Equal) => {}\n                     Ok(Ordering::Greater) => {\n@@ -193,7 +199,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         let outer = self.promotable;\n         self.promotable = true;\n \n-        let node_ty = self.tcx.tables().node_id_to_type(ex.id);\n+        let node_ty = self.tables.node_id_to_type(ex.id);\n         check_expr(self, ex, node_ty);\n         check_adjustments(self, ex);\n \n@@ -219,7 +225,8 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         }\n \n         if self.in_fn && self.promotable {\n-            match eval_const_expr_partial(self.tcx, ex, ExprTypeChecked, None) {\n+            let const_cx = ConstContext::with_tables(self.tcx, self.tables);\n+            match const_cx.eval(ex, ExprTypeChecked) {\n                 Ok(_) => {}\n                 Err(ConstEvalErr { kind: UnimplementedConstVal(_), .. }) |\n                 Err(ConstEvalErr { kind: MiscCatchAll, .. }) |\n@@ -230,6 +237,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n                 Err(ConstEvalErr { kind: Math(ConstMathErr::Overflow(Op::Shr)), .. }) |\n                 Err(ConstEvalErr { kind: Math(ConstMathErr::Overflow(Op::Shl)), .. }) |\n                 Err(ConstEvalErr { kind: IndexOpFeatureGated, .. }) => {}\n+                Err(ConstEvalErr { kind: BadType(_), .. }) => {}\n                 Err(msg) => {\n                     self.tcx.sess.add_lint(CONST_ERR,\n                                            ex.id,\n@@ -262,14 +270,14 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n     match e.node {\n         hir::ExprUnary(..) |\n         hir::ExprBinary(..) |\n-        hir::ExprIndex(..) if v.tcx.tables().method_map.contains_key(&method_call) => {\n+        hir::ExprIndex(..) if v.tables.method_map.contains_key(&method_call) => {\n             v.promotable = false;\n         }\n         hir::ExprBox(_) => {\n             v.promotable = false;\n         }\n         hir::ExprUnary(op, ref inner) => {\n-            match v.tcx.tables().node_id_to_type(inner.id).sty {\n+            match v.tables.node_id_to_type(inner.id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op == hir::UnDeref);\n \n@@ -279,7 +287,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprBinary(op, ref lhs, _) => {\n-            match v.tcx.tables().node_id_to_type(lhs.id).sty {\n+            match v.tables.node_id_to_type(lhs.id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op.node == hir::BiEq || op.node == hir::BiNe ||\n                             op.node == hir::BiLe || op.node == hir::BiLt ||\n@@ -301,7 +309,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprPath(ref qpath) => {\n-            let def = v.tcx.tables().qpath_def(qpath, e.id);\n+            let def = v.tables.qpath_def(qpath, e.id);\n             match def {\n                 Def::VariantCtor(..) | Def::StructCtor(..) |\n                 Def::Fn(..) | Def::Method(..) => {}\n@@ -337,7 +345,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n             // The callee is an arbitrary expression, it doesn't necessarily have a definition.\n             let def = if let hir::ExprPath(ref qpath) = callee.node {\n-                v.tcx.tables().qpath_def(qpath, callee.id)\n+                v.tables.qpath_def(qpath, callee.id)\n             } else {\n                 Def::Err\n             };\n@@ -359,14 +367,14 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprMethodCall(..) => {\n-            let method = v.tcx.tables().method_map[&method_call];\n+            let method = v.tables.method_map[&method_call];\n             match v.tcx.associated_item(method.def_id).container {\n                 ty::ImplContainer(_) => v.handle_const_fn_call(method.def_id, node_ty),\n                 ty::TraitContainer(_) => v.promotable = false\n             }\n         }\n         hir::ExprStruct(..) => {\n-            if let ty::TyAdt(adt, ..) = v.tcx.tables().expr_ty(e).sty {\n+            if let ty::TyAdt(adt, ..) = v.tables.expr_ty(e).sty {\n                 // unsafe_cell_type doesn't necessarily exist with no_core\n                 if Some(adt.did) == v.tcx.lang_items.unsafe_cell_type() {\n                     v.promotable = false;\n@@ -420,7 +428,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr) {\n     use rustc::ty::adjustment::*;\n \n-    match v.tcx.tables().adjustments.get(&e.id).map(|adj| adj.kind) {\n+    match v.tables.adjustments.get(&e.id).map(|adj| adj.kind) {\n         None |\n         Some(Adjust::NeverToAny) |\n         Some(Adjust::ReifyFnPointer) |\n@@ -429,7 +437,7 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n \n         Some(Adjust::DerefRef { autoderefs, .. }) => {\n             if (0..autoderefs as u32)\n-                .any(|autoderef| v.tcx.tables().is_overloaded_autoderef(e.id, autoderef)) {\n+                .any(|autoderef| v.tables.is_overloaded_autoderef(e.id, autoderef)) {\n                 v.promotable = false;\n             }\n         }\n@@ -440,6 +448,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.visit_all_item_likes_in_krate(DepNode::CheckConst,\n                                       &mut CheckCrateVisitor {\n                                           tcx: tcx,\n+                                          tables: &ty::Tables::empty(),\n                                           in_fn: false,\n                                           promotable: false,\n                                           mut_rvalue_borrows: NodeSet(),"}, {"sha": "78b591a48cca5f23e02f50e4f1b06ebb4566b096", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -14,11 +14,11 @@\n use rustc::dep_graph::DepNode;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n-use rustc::ty::{self, TyCtxt, ParameterEnvironment};\n+use rustc::ty::{self, TyCtxt};\n use rustc::traits::Reveal;\n \n use rustc::hir;\n-use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n use syntax::ast;\n use syntax_pos::Span;\n \n@@ -33,28 +33,19 @@ struct RvalueContext<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> Visitor<'tcx> for RvalueContext<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+        NestedVisitorMap::None\n     }\n \n-    fn visit_fn(&mut self,\n-                fk: intravisit::FnKind<'tcx>,\n-                fd: &'tcx hir::FnDecl,\n-                b: hir::BodyId,\n-                s: Span,\n-                fn_id: ast::NodeId) {\n-        // FIXME (@jroesch) change this to be an inference context\n-        let param_env = ParameterEnvironment::for_item(self.tcx, fn_id);\n-        self.tcx.infer_ctxt(None, Some(param_env.clone()),\n-                            Reveal::NotSpecializable).enter(|infcx| {\n+    fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n+        let body = self.tcx.map.body(body_id);\n+        self.tcx.infer_ctxt(body_id, Reveal::NotSpecializable).enter(|infcx| {\n             let mut delegate = RvalueContextDelegate {\n                 tcx: infcx.tcx,\n-                param_env: &param_env\n+                param_env: &infcx.parameter_environment\n             };\n-            let body = infcx.tcx.map.body(b);\n-            let mut euv = euv::ExprUseVisitor::new(&mut delegate, &infcx);\n-            euv.consume_body(body);\n+            euv::ExprUseVisitor::new(&mut delegate, &infcx).consume_body(body);\n         });\n-        intravisit::walk_fn(self, fk, fd, b, s, fn_id)\n+        self.visit_body(body);\n     }\n }\n "}, {"sha": "ef7a1f695ffb4b33c02ee3d47ef997bf72bc54ee", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -392,6 +392,7 @@ struct PrivacyVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     curitem: DefId,\n     in_foreign: bool,\n+    tables: &'a ty::Tables<'tcx>,\n }\n \n impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n@@ -435,6 +436,14 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n         NestedVisitorMap::All(&self.tcx.map)\n     }\n \n+    fn visit_nested_body(&mut self, body: hir::BodyId) {\n+        let old_tables = self.tables;\n+        self.tables = self.tcx.body_tables(body);\n+        let body = self.tcx.map.body(body);\n+        self.visit_body(body);\n+        self.tables = old_tables;\n+    }\n+\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let orig_curitem = replace(&mut self.curitem, self.tcx.map.local_def_id(item.id));\n         intravisit::walk_item(self, item);\n@@ -445,12 +454,12 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                let method = self.tcx.tables().method_map[&method_call];\n+                let method = self.tables.method_map[&method_call];\n                 self.check_method(expr.span, method.def_id);\n             }\n             hir::ExprStruct(ref qpath, ref expr_fields, _) => {\n-                let def = self.tcx.tables().qpath_def(qpath, expr.id);\n-                let adt = self.tcx.tables().expr_ty(expr).ty_adt_def().unwrap();\n+                let def = self.tables.qpath_def(qpath, expr.id);\n+                let adt = self.tables.expr_ty(expr).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(def);\n                 // RFC 736: ensure all unmentioned fields are visible.\n                 // Rather than computing the set of unmentioned fields\n@@ -511,15 +520,15 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n \n         match pattern.node {\n             PatKind::Struct(ref qpath, ref fields, _) => {\n-                let def = self.tcx.tables().qpath_def(qpath, pattern.id);\n-                let adt = self.tcx.tables().pat_ty(pattern).ty_adt_def().unwrap();\n+                let def = self.tables.qpath_def(qpath, pattern.id);\n+                let adt = self.tables.pat_ty(pattern).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(def);\n                 for field in fields {\n                     self.check_field(field.span, adt, variant.field_named(field.node.name));\n                 }\n             }\n             PatKind::TupleStruct(_, ref fields, ddpos) => {\n-                match self.tcx.tables().pat_ty(pattern).sty {\n+                match self.tables.pat_ty(pattern).sty {\n                     // enum fields have no privacy at this time\n                     ty::TyAdt(def, _) if !def.is_enum() => {\n                         let expected_len = def.struct_variant().fields.len();\n@@ -1203,6 +1212,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         curitem: DefId::local(CRATE_DEF_INDEX),\n         in_foreign: false,\n         tcx: tcx,\n+        tables: &ty::Tables::empty(),\n     };\n     intravisit::walk_crate(&mut visitor, krate);\n "}, {"sha": "424017ebd12bb77a33ff8718a592901845e801bf", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -99,7 +99,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         }\n     }\n \n-    fn nest<F>(&mut self, scope_id: NodeId, f: F)\n+    fn nest_scope<F>(&mut self, scope_id: NodeId, f: F)\n         where F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll, D>)\n     {\n         let parent_scope = self.cur_scope;\n@@ -108,6 +108,16 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         self.cur_scope = parent_scope;\n     }\n \n+    fn nest_tables<F>(&mut self, item_id: NodeId, f: F)\n+        where F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll, D>)\n+    {\n+        let old_tables = self.save_ctxt.tables;\n+        let item_def_id = self.tcx.map.local_def_id(item_id);\n+        self.save_ctxt.tables = self.tcx.item_tables(item_def_id);\n+        f(self);\n+        self.save_ctxt.tables = old_tables;\n+    }\n+\n     pub fn dump_crate_info(&mut self, name: &str, krate: &ast::Crate) {\n         let source_file = self.tcx.sess.local_crate_source_file.as_ref();\n         let crate_root = source_file.map(|source_file| {\n@@ -337,7 +347,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             collector.visit_pat(&arg.pat);\n             let span_utils = self.span.clone();\n             for &(id, ref p, ..) in &collector.collected_paths {\n-                let typ = match self.tcx.tables().node_types.get(&id) {\n+                let typ = match self.save_ctxt.tables.node_types.get(&id) {\n                     Some(s) => s.to_string(),\n                     None => continue,\n                 };\n@@ -378,7 +388,9 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n \n             let sig_str = ::make_signature(&sig.decl, &sig.generics);\n             if body.is_some() {\n-                self.process_formals(&sig.decl.inputs, &method_data.qualname);\n+                self.nest_tables(id, |v| {\n+                    v.process_formals(&sig.decl.inputs, &method_data.qualname)\n+                });\n             }\n \n             // If the method is defined in an impl, then try and find the corresponding\n@@ -448,7 +460,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n \n         // walk the fn body\n         if let Some(body) = body {\n-            self.nest(id, |v| v.visit_block(body));\n+            self.nest_tables(id, |v| v.nest_scope(id, |v| v.visit_block(body)));\n         }\n     }\n \n@@ -520,7 +532,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 self.dumper.function(fn_data.clone().lower(self.tcx));\n             }\n \n-            self.process_formals(&decl.inputs, &fn_data.qualname);\n+            self.nest_tables(item.id, |v| v.process_formals(&decl.inputs, &fn_data.qualname));\n             self.process_generic_params(ty_params, item.span, &fn_data.qualname, item.id);\n         }\n \n@@ -532,7 +544,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             self.visit_ty(&ret_ty);\n         }\n \n-        self.nest(item.id, |v| v.visit_block(&body));\n+        self.nest_tables(item.id, |v| v.nest_scope(item.id, |v| v.visit_block(&body)));\n     }\n \n     fn process_static_or_const_item(&mut self,\n@@ -991,7 +1003,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         match p.node {\n             PatKind::Struct(ref path, ref fields, _) => {\n                 visit::walk_path(self, path);\n-                let adt = match self.tcx.tables().node_id_to_type_opt(p.id) {\n+                let adt = match self.save_ctxt.tables.node_id_to_type_opt(p.id) {\n                     Some(ty) => ty.ty_adt_def().unwrap(),\n                     None => {\n                         visit::walk_pat(self, p);\n@@ -1032,7 +1044,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 ast::Mutability::Immutable => value.to_string(),\n                 _ => String::new(),\n             };\n-            let typ = match self.tcx.tables().node_types.get(&id) {\n+            let typ = match self.save_ctxt.tables.node_types.get(&id) {\n                 Some(typ) => {\n                     let typ = typ.to_string();\n                     if !value.is_empty() {\n@@ -1286,7 +1298,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                 self.process_trait(item, generics, trait_refs, methods),\n             Mod(ref m) => {\n                 self.process_mod(item);\n-                self.nest(item.id, |v| visit::walk_mod(v, m));\n+                self.nest_scope(item.id, |v| visit::walk_mod(v, m));\n             }\n             Ty(ref ty, ref ty_params) => {\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n@@ -1349,6 +1361,10 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n \n                 visit::walk_path(self, path);\n             }\n+            ast::TyKind::Array(ref element, ref length) => {\n+                self.visit_ty(element);\n+                self.nest_tables(length.id, |v| v.visit_expr(length));\n+            }\n             _ => visit::walk_ty(self, t),\n         }\n     }\n@@ -1367,7 +1383,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n             }\n             ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n                 let hir_expr = self.save_ctxt.tcx.map.expect_expr(ex.id);\n-                let adt = match self.tcx.tables().expr_ty_opt(&hir_expr) {\n+                let adt = match self.save_ctxt.tables.expr_ty_opt(&hir_expr) {\n                     Some(ty) => ty.ty_adt_def().unwrap(),\n                     None => {\n                         visit::walk_expr(self, ex);\n@@ -1399,7 +1415,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                         return;\n                     }\n                 };\n-                let ty = match self.tcx.tables().expr_ty_adjusted_opt(&hir_node) {\n+                let ty = match self.save_ctxt.tables.expr_ty_adjusted_opt(&hir_node) {\n                     Some(ty) => &ty.sty,\n                     None => {\n                         visit::walk_expr(self, ex);\n@@ -1427,7 +1443,6 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n             ast::ExprKind::Closure(_, ref decl, ref body, _fn_decl_span) => {\n                 let mut id = String::from(\"$\");\n                 id.push_str(&ex.id.to_string());\n-                self.process_formals(&decl.inputs, &id);\n \n                 // walk arg and return types\n                 for arg in &decl.inputs {\n@@ -1439,7 +1454,10 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                 }\n \n                 // walk the body\n-                self.nest(ex.id, |v| v.visit_expr(body));\n+                self.nest_tables(ex.id, |v| {\n+                    v.process_formals(&decl.inputs, &id);\n+                    v.nest_scope(ex.id, |v| v.visit_expr(body))\n+                });\n             }\n             ast::ExprKind::ForLoop(ref pattern, ref subexpression, ref block, _) |\n             ast::ExprKind::WhileLet(ref pattern, ref subexpression, ref block, _) => {\n@@ -1455,6 +1473,10 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                 visit::walk_block(self, block);\n                 opt_else.as_ref().map(|el| visit::walk_expr(self, el));\n             }\n+            ast::ExprKind::Repeat(ref element, ref count) => {\n+                self.visit_expr(element);\n+                self.nest_tables(count.id, |v| v.visit_expr(count));\n+            }\n             _ => {\n                 visit::walk_expr(self, ex)\n             }\n@@ -1492,7 +1514,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                     } else {\n                         \"<mutable>\".to_string()\n                     };\n-                    let typ = self.tcx.tables().node_types\n+                    let typ = self.save_ctxt.tables.node_types\n                                   .get(&id).map(|t| t.to_string()).unwrap_or(String::new());\n                     value.push_str(\": \");\n                     value.push_str(&typ);"}, {"sha": "0fbe29880b9994462e223421154d1ca909359144", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -84,6 +84,7 @@ pub mod recorder {\n \n pub struct SaveContext<'l, 'tcx: 'l> {\n     tcx: TyCtxt<'l, 'tcx, 'tcx>,\n+    tables: &'l ty::Tables<'tcx>,\n     analysis: &'l ty::CrateAnalysis<'tcx>,\n     span_utils: SpanUtils<'tcx>,\n }\n@@ -93,24 +94,6 @@ macro_rules! option_try(\n );\n \n impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n-               analysis: &'l ty::CrateAnalysis<'tcx>)\n-               -> SaveContext<'l, 'tcx> {\n-        let span_utils = SpanUtils::new(&tcx.sess);\n-        SaveContext::from_span_utils(tcx, analysis, span_utils)\n-    }\n-\n-    pub fn from_span_utils(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n-                           analysis: &'l ty::CrateAnalysis<'tcx>,\n-                           span_utils: SpanUtils<'tcx>)\n-                           -> SaveContext<'l, 'tcx> {\n-        SaveContext {\n-            tcx: tcx,\n-            analysis: analysis,\n-            span_utils: span_utils,\n-        }\n-    }\n-\n     // List external crates used by the current crate.\n     pub fn get_external_crates(&self) -> Vec<CrateData> {\n         let mut result = Vec::new();\n@@ -460,7 +443,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     pub fn get_expr_data(&self, expr: &ast::Expr) -> Option<Data> {\n         let hir_node = self.tcx.map.expect_expr(expr.id);\n-        let ty = self.tcx.tables().expr_ty_adjusted_opt(&hir_node);\n+        let ty = self.tables.expr_ty_adjusted_opt(&hir_node);\n         if ty.is_none() || ty.unwrap().sty == ty::TyError {\n             return None;\n         }\n@@ -474,7 +457,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                         return None;\n                     }\n                 };\n-                match self.tcx.tables().expr_ty_adjusted(&hir_node).sty {\n+                match self.tables.expr_ty_adjusted(&hir_node).sty {\n                     ty::TyAdt(def, _) if !def.is_enum() => {\n                         let f = def.struct_variant().field_named(ident.node.name);\n                         let sub_span = self.span_utils.span_for_last_ident(expr.span);\n@@ -493,7 +476,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }\n             }\n             ast::ExprKind::Struct(ref path, ..) => {\n-                match self.tcx.tables().expr_ty_adjusted(&hir_node).sty {\n+                match self.tables.expr_ty_adjusted(&hir_node).sty {\n                     ty::TyAdt(def, _) if !def.is_enum() => {\n                         let sub_span = self.span_utils.span_for_last_ident(path.span);\n                         filter!(self.span_utils, sub_span, path.span, None);\n@@ -514,7 +497,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n             ast::ExprKind::MethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                let method_id = self.tcx.tables().method_map[&method_call].def_id;\n+                let method_id = self.tables.method_map[&method_call].def_id;\n                 let (def_id, decl_id) = match self.tcx.associated_item(method_id).container {\n                     ty::ImplContainer(_) => (Some(method_id), None),\n                     ty::TraitContainer(_) => (None, Some(method_id)),\n@@ -551,7 +534,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             Node::NodePat(&hir::Pat { node: hir::PatKind::Path(ref qpath), .. }) |\n             Node::NodePat(&hir::Pat { node: hir::PatKind::Struct(ref qpath, ..), .. }) |\n             Node::NodePat(&hir::Pat { node: hir::PatKind::TupleStruct(ref qpath, ..), .. }) => {\n-                self.tcx.tables().qpath_def(qpath, id)\n+                self.tables.qpath_def(qpath, id)\n             }\n \n             Node::NodeLocal(&hir::Pat { node: hir::PatKind::Binding(_, def_id, ..), .. }) => {\n@@ -914,7 +897,12 @@ pub fn process_crate<'l, 'tcx>(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n     root_path.pop();\n     let output = &mut output_file;\n \n-    let save_ctxt = SaveContext::new(tcx, analysis);\n+    let save_ctxt = SaveContext {\n+        tcx: tcx,\n+        tables: &ty::Tables::empty(),\n+        analysis: analysis,\n+        span_utils: SpanUtils::new(&tcx.sess),\n+    };\n \n     macro_rules! dump {\n         ($new_dumper: expr) => {{"}, {"sha": "eb6ea8fa94b0ab06a2736c730f662db936865cb5", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -465,7 +465,7 @@ pub fn fulfill_obligation<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n         // Do the initial selection for the obligation. This yields the\n         // shallow result we are looking for -- that is, what specific impl.\n-        tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n+        tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n             let mut selcx = SelectionContext::new(&infcx);\n \n             let obligation_cause = traits::ObligationCause::misc(span,"}, {"sha": "a9c1edfdc66cc600ae6c7d9afffc2ac44ee02cb3", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -95,8 +95,6 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n                 let sym = ccx.symbol_map()\n                              .get(TransItem::Static(id))\n                              .expect(\"Local statics should always be in the SymbolMap\");\n-                // Make sure that this is never executed for something inlined.\n-                assert!(!ccx.tcx().map.is_inlined_node_id(id));\n \n                 let defined_in_current_codegen_unit = ccx.codegen_unit()\n                                                          .items()"}, {"sha": "5efdd129a32b83c330e789f33df119422cfce0d9", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -851,7 +851,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     pub fn layout_of(&self, ty: Ty<'tcx>) -> &'tcx ty::layout::Layout {\n-        self.tcx().infer_ctxt(None, None, traits::Reveal::All).enter(|infcx| {\n+        self.tcx().infer_ctxt((), traits::Reveal::All).enter(|infcx| {\n             ty.layout(&infcx).unwrap_or_else(|e| {\n                 match e {\n                     ty::layout::LayoutError::SizeOverflow(_) =>"}, {"sha": "1473e55b2643cbef4b8f6aef5ccf759fe45d8cd8", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -1738,14 +1738,6 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n \n     let tcx = cx.tcx();\n \n-    // Don't create debuginfo for globals inlined from other crates. The other\n-    // crate should already contain debuginfo for it. More importantly, the\n-    // global might not even exist in un-inlined form anywhere which would lead\n-    // to a linker errors.\n-    if tcx.map.is_inlined_node_id(node_id) {\n-        return;\n-    }\n-\n     let node_def_id = tcx.map.local_def_id(node_id);\n     let (var_scope, span) = get_namespace_and_span_for_item(cx, node_def_id);\n "}, {"sha": "b24f00ee6976d039c14c889d5507976193441709", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -80,7 +80,7 @@ pub fn get_drop_glue_type<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>, t: Ty<'t\n     }\n     match t.sty {\n         ty::TyBox(typ) if !scx.type_needs_drop(typ) && scx.type_is_sized(typ) => {\n-            scx.tcx().infer_ctxt(None, None, traits::Reveal::All).enter(|infcx| {\n+            scx.tcx().infer_ctxt((), traits::Reveal::All).enter(|infcx| {\n                 let layout = t.layout(&infcx).unwrap();\n                 if layout.size(&scx.tcx().data_layout).bytes() == 0 {\n                     // `Box<ZeroSizeType>` does not allocate."}, {"sha": "9ac2bea3b82fbc146495f46a7b6a5ed89db221dd", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -101,7 +101,6 @@ impl<'tcx> Const<'tcx> {\n                 bug!(\"MIR must not use `{:?}` (which refers to a local ID)\", cv)\n             }\n             ConstVal::Char(c) => C_integral(Type::char(ccx), c as u64, false),\n-            ConstVal::Dummy => bug!(),\n         };\n \n         assert!(!ty.has_erasable_regions());"}, {"sha": "bc984949fc69d0438432a85c38151a60c47dfa7b", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -1660,8 +1660,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 self.associated_path_def_to_ty(ast_ty.id, ast_ty.span, ty, def, segment).0\n             }\n             hir::TyArray(ref ty, length) => {\n-                let e = &tcx.map.body(length).value;\n-                if let Ok(length) = eval_length(tcx.global_tcx(), e, \"array length\") {\n+                if let Ok(length) = eval_length(tcx.global_tcx(), length, \"array length\") {\n                     tcx.mk_array(self.ast_ty_to_ty(rscope, &ty), length)\n                 } else {\n                     self.tcx().types.err"}, {"sha": "0551887e2e8a0d41aad7032a82e3e28f27f117f8", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -99,10 +99,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                fn_ty.sig,\n                opt_kind);\n \n-        self.tables.borrow_mut().closure_tys.insert(expr_def_id, fn_ty);\n+        self.tables.borrow_mut().closure_tys.insert(expr.id, fn_ty);\n         match opt_kind {\n             Some(kind) => {\n-                self.tables.borrow_mut().closure_kinds.insert(expr_def_id, kind);\n+                self.tables.borrow_mut().closure_kinds.insert(expr.id, kind);\n             }\n             None => {}\n         }"}, {"sha": "3960dc9edbd2795edecbd0bd8f4fadbfeb0108b3", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -227,7 +227,7 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                                trait_param_env,\n                                                                normalize_cause.clone());\n \n-    tcx.infer_ctxt(None, Some(trait_param_env), Reveal::NotSpecializable).enter(|infcx| {\n+    tcx.infer_ctxt(trait_param_env, Reveal::NotSpecializable).enter(|infcx| {\n         let inh = Inherited::new(ccx, infcx);\n         let infcx = &inh.infcx;\n         let fulfillment_cx = &inh.fulfillment_cx;\n@@ -747,7 +747,7 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\", impl_trait_ref);\n \n     let tcx = ccx.tcx;\n-    tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n+    tcx.infer_ctxt((), Reveal::NotSpecializable).enter(|infcx| {\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n         // The below is for the most part highly similar to the procedure"}, {"sha": "9cd54bd94c8172f8809c4c10d7eaff2a26aa736e", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -81,7 +81,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n     // check that the impl type can be made to match the trait type.\n \n     let impl_param_env = ty::ParameterEnvironment::for_item(tcx, self_type_node_id);\n-    tcx.infer_ctxt(None, Some(impl_param_env), Reveal::NotSpecializable).enter(|infcx| {\n+    tcx.infer_ctxt(impl_param_env, Reveal::NotSpecializable).enter(|infcx| {\n         let tcx = infcx.tcx;\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n "}, {"sha": "f331c561f0c40fcfdb86aa750f50aff366cf2b2d", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -801,13 +801,19 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         // If so, add \"synthetic impls\".\n         let steps = self.steps.clone();\n         for step in steps.iter() {\n-            let closure_def_id = match step.self_ty.sty {\n-                ty::TyClosure(a, _) => a,\n+            let closure_id = match step.self_ty.sty {\n+                ty::TyClosure(def_id, _) => {\n+                    if let Some(id) = self.tcx.map.as_local_node_id(def_id) {\n+                        id\n+                    } else {\n+                        continue;\n+                    }\n+                }\n                 _ => continue,\n             };\n \n             let closure_kinds = &self.tables.borrow().closure_kinds;\n-            let closure_kind = match closure_kinds.get(&closure_def_id) {\n+            let closure_kind = match closure_kinds.get(&closure_id) {\n                 Some(&k) => k,\n                 None => {\n                     return Err(MethodError::ClosureAmbiguity(trait_def_id));"}, {"sha": "ceb97c63d13274f1437d316094c9cbe9166d4b5a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -105,7 +105,7 @@ use lint;\n use util::common::{ErrorReported, indenter};\n use util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap};\n \n-use std::cell::{Cell, Ref, RefCell};\n+use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::mem::replace;\n use std::ops::{self, Deref};\n@@ -483,12 +483,11 @@ pub struct InheritedBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n impl<'a, 'gcx, 'tcx> CrateCtxt<'a, 'gcx> {\n     pub fn inherited(&'a self, id: ast::NodeId)\n                      -> InheritedBuilder<'a, 'gcx, 'tcx> {\n+        let tables = ty::Tables::empty();\n         let param_env = ParameterEnvironment::for_item(self.tcx, id);\n         InheritedBuilder {\n             ccx: self,\n-            infcx: self.tcx.infer_ctxt(Some(ty::Tables::empty()),\n-                                       Some(param_env),\n-                                       Reveal::NotSpecializable)\n+            infcx: self.tcx.infer_ctxt((tables, param_env), Reveal::NotSpecializable)\n         }\n     }\n }\n@@ -612,8 +611,7 @@ pub fn check_item_bodies(ccx: &CrateCtxt) -> CompileResult {\n             let _task = ccx.tcx.dep_graph.in_task(DepNode::TypeckItemBody(def_id));\n \n             let param_env = ParameterEnvironment::for_item(ccx.tcx, item_id);\n-            ccx.tcx.infer_ctxt(None, Some(param_env),\n-                               Reveal::NotSpecializable).enter(|infcx| {\n+            ccx.tcx.infer_ctxt(param_env, Reveal::NotSpecializable).enter(|infcx| {\n                 let mut fulfillment_cx = traits::FulfillmentContext::new();\n                 for obligation in obligations.iter().map(|o| o.to_obligation()) {\n                     fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n@@ -681,7 +679,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         fcx.select_all_obligations_or_error(); // Casts can introduce new obligations.\n \n         fcx.regionck_fn(fn_id, body);\n-        fcx.resolve_type_vars_in_body(body, fn_id);\n+        fcx.resolve_type_vars_in_body(body);\n     });\n }\n \n@@ -1248,7 +1246,7 @@ fn check_const_with_type<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n         fcx.select_all_obligations_or_error();\n \n         fcx.regionck_expr(body);\n-        fcx.resolve_type_vars_in_body(body, id);\n+        fcx.resolve_type_vars_in_body(body);\n     });\n }\n \n@@ -1871,17 +1869,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn item_substs(&self) -> Ref<NodeMap<ty::ItemSubsts<'tcx>>> {\n-        // NOTE: @jroesch this is hack that appears to be fixed on nightly, will monitor if\n-        // it changes when we upgrade the snapshot compiler\n-        fn project_item_susbts<'a, 'tcx>(tables: &'a ty::Tables<'tcx>)\n-                                        -> &'a NodeMap<ty::ItemSubsts<'tcx>> {\n-            &tables.item_substs\n-        }\n-\n-        Ref::map(self.tables.borrow(), project_item_susbts)\n-    }\n-\n     pub fn opt_node_ty_substs<F>(&self,\n                                  id: ast::NodeId,\n                                  f: F) where\n@@ -3872,8 +3859,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             tcx.mk_array(unified, args.len())\n           }\n           hir::ExprRepeat(ref element, count) => {\n-            let count_expr = &tcx.map.body(count).value;\n-            let count = eval_length(self.tcx.global_tcx(), count_expr, \"repeat count\")\n+            let count = eval_length(self.tcx.global_tcx(), count, \"repeat count\")\n                   .unwrap_or(0);\n \n             let uty = match expected {"}, {"sha": "95da5a97f6750588f9d1df52a7f8aa0e711bf585", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -106,8 +106,7 @@ impl<'a, 'gcx, 'tcx> SeedBorrowKind<'a, 'gcx, 'tcx> {\n                      expr: &hir::Expr,\n                      capture_clause: hir::CaptureClause)\n     {\n-        let closure_def_id = self.fcx.tcx.map.local_def_id(expr.id);\n-        if !self.fcx.tables.borrow().closure_kinds.contains_key(&closure_def_id) {\n+        if !self.fcx.tables.borrow().closure_kinds.contains_key(&expr.id) {\n             self.temp_closure_kinds.insert(expr.id, ty::ClosureKind::Fn);\n             debug!(\"check_closure: adding closure {:?} as Fn\", expr.id);\n         }\n@@ -211,8 +210,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         // main table and process any deferred resolutions.\n         let closure_def_id = self.fcx.tcx.map.local_def_id(id);\n         if let Some(&kind) = self.temp_closure_kinds.get(&id) {\n-            self.fcx.tables.borrow_mut().closure_kinds\n-                                        .insert(closure_def_id, kind);\n+            self.fcx.tables.borrow_mut().closure_kinds.insert(id, kind);\n             debug!(\"closure_kind({:?}) = {:?}\", closure_def_id, kind);\n \n             let mut deferred_call_resolutions ="}, {"sha": "02ac7c196b5cb620945be4435ce98d2b04772a80", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -33,10 +33,12 @@ use rustc::hir;\n // Entry point\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn resolve_type_vars_in_body(&self,\n-                                     body: &'gcx hir::Body,\n-                                     item_id: ast::NodeId) {\n+    pub fn resolve_type_vars_in_body(&self, body: &'gcx hir::Body) {\n         assert_eq!(self.writeback_errors.get(), false);\n+\n+        let item_id = self.tcx.map.body_owner(body.id());\n+        let item_def_id = self.tcx.map.local_def_id(item_id);\n+\n         let mut wbcx = WritebackCx::new(self);\n         for arg in &body.arguments {\n             wbcx.visit_node_id(ResolvingPattern(arg.pat.span), arg.id);\n@@ -49,6 +51,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_anon_types();\n         wbcx.visit_deferred_obligations(item_id);\n         wbcx.visit_type_nodes();\n+\n+        let tables = self.tcx.alloc_tables(wbcx.tables);\n+        self.tcx.tables.borrow_mut().insert(item_def_id, tables);\n     }\n }\n \n@@ -63,6 +68,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n struct WritebackCx<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>,\n \n+    tables: ty::Tables<'gcx>,\n+\n     // Mapping from free regions of the function to the\n     // early-bound versions of them, visible from the\n     // outside of the function. This is needed by, and\n@@ -74,6 +81,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     fn new(fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>) -> WritebackCx<'cx, 'gcx, 'tcx> {\n         let mut wbcx = WritebackCx {\n             fcx: fcx,\n+            tables: ty::Tables::empty(),\n             free_to_bound_regions: DefIdMap()\n         };\n \n@@ -113,10 +121,10 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         self.fcx.tcx\n     }\n \n-    fn write_ty_to_tcx(&self, node_id: ast::NodeId, ty: Ty<'gcx>) {\n-        debug!(\"write_ty_to_tcx({}, {:?})\", node_id,  ty);\n+    fn write_ty_to_tables(&mut self, node_id: ast::NodeId, ty: Ty<'gcx>) {\n+        debug!(\"write_ty_to_tables({}, {:?})\", node_id,  ty);\n         assert!(!ty.needs_infer());\n-        self.tcx().tables.borrow_mut().node_types.insert(node_id, ty);\n+        self.tables.node_types.insert(node_id, ty);\n     }\n \n     // Hacky hack: During type-checking, we treat *all* operators\n@@ -228,11 +236,6 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n \n         self.visit_node_id(ResolvingPattern(p.span), p.id);\n \n-        debug!(\"Type for pattern binding {} (id {}) resolved to {:?}\",\n-               self.tcx().map.node_to_pretty_string(p.id),\n-               p.id,\n-               self.tcx().tables().node_id_to_type(p.id));\n-\n         intravisit::walk_pat(self, p);\n     }\n \n@@ -243,13 +246,13 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n \n         let var_ty = self.fcx.local_ty(l.span, l.id);\n         let var_ty = self.resolve(&var_ty, ResolvingLocal(l.span));\n-        self.write_ty_to_tcx(l.id, var_ty);\n+        self.write_ty_to_tables(l.id, var_ty);\n         intravisit::walk_local(self, l);\n     }\n }\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n-    fn visit_upvar_borrow_map(&self) {\n+    fn visit_upvar_borrow_map(&mut self) {\n         if self.fcx.writeback_errors.get() {\n             return;\n         }\n@@ -267,11 +270,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             debug!(\"Upvar capture for {:?} resolved to {:?}\",\n                    upvar_id,\n                    new_upvar_capture);\n-            self.tcx()\n-                .tables\n-                .borrow_mut()\n-                .upvar_capture_map\n-                .insert(*upvar_id, new_upvar_capture);\n+            self.tables.upvar_capture_map.insert(*upvar_id, new_upvar_capture);\n         }\n     }\n \n@@ -280,13 +279,15 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             return\n         }\n \n-        for (def_id, closure_ty) in self.fcx.tables.borrow().closure_tys.iter() {\n-            let closure_ty = self.resolve(closure_ty, ResolvingClosure(*def_id));\n-            self.tcx().tables.borrow_mut().closure_tys.insert(*def_id, closure_ty);\n+        for (&id, closure_ty) in self.fcx.tables.borrow().closure_tys.iter() {\n+            let closure_ty = self.resolve(closure_ty, ResolvingClosure(id));\n+            let def_id = self.tcx().map.local_def_id(id);\n+            self.tcx().closure_tys.borrow_mut().insert(def_id, closure_ty);\n         }\n \n-        for (def_id, &closure_kind) in self.fcx.tables.borrow().closure_kinds.iter() {\n-            self.tcx().tables.borrow_mut().closure_kinds.insert(*def_id, closure_kind);\n+        for (&id, &closure_kind) in self.fcx.tables.borrow().closure_kinds.iter() {\n+            let def_id = self.tcx().map.local_def_id(id);\n+            self.tcx().closure_kinds.borrow_mut().insert(def_id, closure_kind);\n         }\n     }\n \n@@ -339,10 +340,10 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_node_id(&self, reason: ResolveReason, id: ast::NodeId) {\n+    fn visit_node_id(&mut self, reason: ResolveReason, id: ast::NodeId) {\n         // Export associated path extensions.\n         if let Some(def) = self.fcx.tables.borrow_mut().type_relative_path_defs.remove(&id) {\n-            self.tcx().tables.borrow_mut().type_relative_path_defs.insert(id, def);\n+            self.tables.type_relative_path_defs.insert(id, def);\n         }\n \n         // Resolve any borrowings for the node with id `id`\n@@ -351,7 +352,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         // Resolve the type of the node with id `id`\n         let n_ty = self.fcx.node_ty(id);\n         let n_ty = self.resolve(&n_ty, reason);\n-        self.write_ty_to_tcx(id, n_ty);\n+        self.write_ty_to_tables(id, n_ty);\n         debug!(\"Node {} has type {:?}\", id, n_ty);\n \n         // Resolve any substitutions\n@@ -360,12 +361,12 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             if !item_substs.is_noop() {\n                 debug!(\"write_substs_to_tcx({}, {:?})\", id, item_substs);\n                 assert!(!item_substs.substs.needs_infer());\n-                self.tcx().tables.borrow_mut().item_substs.insert(id, item_substs);\n+                self.tables.item_substs.insert(id, item_substs);\n             }\n         });\n     }\n \n-    fn visit_adjustments(&self, reason: ResolveReason, id: ast::NodeId) {\n+    fn visit_adjustments(&mut self, reason: ResolveReason, id: ast::NodeId) {\n         let adjustments = self.fcx.tables.borrow_mut().adjustments.remove(&id);\n         match adjustments {\n             None => {\n@@ -408,13 +409,12 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                     target: self.resolve(&adjustment.target, reason)\n                 };\n                 debug!(\"Adjustments for node {}: {:?}\", id, resolved_adjustment);\n-                self.tcx().tables.borrow_mut().adjustments.insert(\n-                    id, resolved_adjustment);\n+                self.tables.adjustments.insert(id, resolved_adjustment);\n             }\n         }\n     }\n \n-    fn visit_method_map_entry(&self,\n+    fn visit_method_map_entry(&mut self,\n                               reason: ResolveReason,\n                               method_call: MethodCall) {\n         // Resolve any method map entry\n@@ -436,25 +436,25 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n         //NB(jroesch): We need to match twice to avoid a double borrow which would cause an ICE\n         if let Some(method) = new_method {\n-            self.tcx().tables.borrow_mut().method_map.insert(method_call, method);\n+            self.tables.method_map.insert(method_call, method);\n         }\n     }\n \n-    fn visit_liberated_fn_sigs(&self) {\n+    fn visit_liberated_fn_sigs(&mut self) {\n         for (&node_id, fn_sig) in self.fcx.tables.borrow().liberated_fn_sigs.iter() {\n             let fn_sig = self.resolve(fn_sig, ResolvingFnSig(node_id));\n-            self.tcx().tables.borrow_mut().liberated_fn_sigs.insert(node_id, fn_sig.clone());\n+            self.tables.liberated_fn_sigs.insert(node_id, fn_sig.clone());\n         }\n     }\n \n-    fn visit_fru_field_types(&self) {\n+    fn visit_fru_field_types(&mut self) {\n         for (&node_id, ftys) in self.fcx.tables.borrow().fru_field_types.iter() {\n             let ftys = self.resolve(ftys, ResolvingFieldTypes(node_id));\n-            self.tcx().tables.borrow_mut().fru_field_types.insert(node_id, ftys);\n+            self.tables.fru_field_types.insert(node_id, ftys);\n         }\n     }\n \n-    fn visit_deferred_obligations(&self, item_id: ast::NodeId) {\n+    fn visit_deferred_obligations(&mut self, item_id: ast::NodeId) {\n         let deferred_obligations = self.fcx.deferred_obligations.borrow();\n         let obligations: Vec<_> = deferred_obligations.iter().map(|obligation| {\n             let reason = ResolvingDeferredObligation(obligation.cause.span);\n@@ -496,7 +496,7 @@ enum ResolveReason {\n     ResolvingLocal(Span),\n     ResolvingPattern(Span),\n     ResolvingUpvar(ty::UpvarId),\n-    ResolvingClosure(DefId),\n+    ResolvingClosure(ast::NodeId),\n     ResolvingFnSig(ast::NodeId),\n     ResolvingFieldTypes(ast::NodeId),\n     ResolvingAnonTy(DefId),\n@@ -513,12 +513,12 @@ impl<'a, 'gcx, 'tcx> ResolveReason {\n             ResolvingUpvar(upvar_id) => {\n                 tcx.expr_span(upvar_id.closure_expr_id)\n             }\n+            ResolvingClosure(id) |\n             ResolvingFnSig(id) |\n             ResolvingFieldTypes(id) |\n             ResolvingTyNode(id) => {\n                 tcx.map.span(id)\n             }\n-            ResolvingClosure(did) |\n             ResolvingAnonTy(did) => {\n                 tcx.def_span(did)\n             }"}, {"sha": "57df0fb2cee938302af19b6001d80bcc84235eb8", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -205,7 +205,7 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            source,\n            target);\n \n-    tcx.infer_ctxt(None, Some(param_env), Reveal::ExactMatch).enter(|infcx| {\n+    tcx.infer_ctxt(param_env, Reveal::ExactMatch).enter(|infcx| {\n         let cause = ObligationCause::misc(span, impl_node_id);\n         let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n                            mt_b: ty::TypeAndMut<'tcx>,"}, {"sha": "08293c1d874a8d7cb75cd5876ba91a963fc9fb5b", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -87,7 +87,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n \n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n             for &impl2_def_id in &impls[(i + 1)..] {\n-                self.tcx.infer_ctxt(None, None, Reveal::ExactMatch).enter(|infcx| {\n+                self.tcx.infer_ctxt((), Reveal::ExactMatch).enter(|infcx| {\n                     if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n                         self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n                     }"}, {"sha": "f832bf8d86e939bdcd7689d0911e2979ff3ebbf6", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -63,7 +63,7 @@ use constrained_type_params as ctp;\n use middle::lang_items::SizedTraitLangItem;\n use middle::const_val::ConstVal;\n use rustc_const_eval::EvalHint::UncheckedExprHint;\n-use rustc_const_eval::{eval_const_expr_partial, report_const_eval_err};\n+use rustc_const_eval::{ConstContext, report_const_eval_err};\n use rustc::ty::subst::Substs;\n use rustc::ty::{ToPredicate, ImplContainer, AssociatedItemContainer, TraitContainer};\n use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n@@ -1039,8 +1039,9 @@ fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     adt\n }\n \n-    fn evaluate_disr_expr(ccx: &CrateCtxt, repr_ty: attr::IntType, e: &hir::Expr)\n+    fn evaluate_disr_expr(ccx: &CrateCtxt, repr_ty: attr::IntType, body: hir::BodyId)\n                           -> Option<ty::Disr> {\n+        let e = &ccx.tcx.map.body(body).value;\n         debug!(\"disr expr, checking {}\", ccx.tcx.map.node_to_pretty_string(e.id));\n \n         let ty_hint = repr_ty.to_ty(ccx.tcx);\n@@ -1052,9 +1053,9 @@ fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         };\n \n         let hint = UncheckedExprHint(ty_hint);\n-        match eval_const_expr_partial(ccx.tcx, e, hint, None) {\n+        match ConstContext::new(ccx.tcx, body).eval(e, hint) {\n             Ok(ConstVal::Integral(i)) => {\n-                // FIXME: eval_const_expr_partial should return an error if the hint is wrong\n+                // FIXME: eval should return an error if the hint is wrong\n                 match (repr_ty, i) {\n                     (attr::SignedInt(ast::IntTy::I8), ConstInt::I8(_)) |\n                     (attr::SignedInt(ast::IntTy::I16), ConstInt::I16(_)) |\n@@ -1103,7 +1104,6 @@ fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let variants = def.variants.iter().map(|v| {\n         let wrapped_disr = prev_disr.map_or(initial, |d| d.wrap_incr());\n         let disr = if let Some(e) = v.node.disr_expr {\n-            let e = &tcx.map.body(e).value;\n             evaluate_disr_expr(ccx, repr_type, e)\n         } else if let Some(disr) = repr_type.disr_incr(tcx, prev_disr) {\n             Some(disr)"}, {"sha": "6d30a85b582912a7f108a5908588a88333dc564b", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -177,7 +177,7 @@ fn require_same_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 expected: Ty<'tcx>,\n                                 actual: Ty<'tcx>)\n                                 -> bool {\n-    ccx.tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n+    ccx.tcx.infer_ctxt((), Reveal::NotSpecializable).enter(|infcx| {\n         match infcx.eq_types(false, &cause, expected, actual) {\n             Ok(InferOk { obligations, .. }) => {\n                 // FIXME(#32730) propagate obligations"}, {"sha": "93c0bd6d6d836fb646f64c781d02d05949126e29", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -14,7 +14,6 @@ arena = { path = \"../libarena\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n-rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_driver = { path = \"../librustc_driver\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "6a640e7b5ed80a0cccd23c31d6342a2717e70267", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -1692,22 +1692,10 @@ impl Clean<Type> for hir::Ty {\n                 BorrowedRef {lifetime: l.clean(cx), mutability: m.mutbl.clean(cx),\n                              type_: box m.ty.clean(cx)},\n             TySlice(ref ty) => Vector(box ty.clean(cx)),\n-            TyArray(ref ty, e) => {\n-                use rustc_const_math::{ConstInt, ConstUsize};\n-                use rustc_const_eval::eval_const_expr;\n-                use rustc::middle::const_val::ConstVal;\n-\n-                let e = &cx.tcx.map.body(e).value;\n-                let n = match eval_const_expr(cx.tcx, e) {\n-                    ConstVal::Integral(ConstInt::Usize(u)) => match u {\n-                        ConstUsize::Us16(u) => u.to_string(),\n-                        ConstUsize::Us32(u) => u.to_string(),\n-                        ConstUsize::Us64(u) => u.to_string(),\n-                    },\n-                    // after type checking this can't fail\n-                    _ => unreachable!(),\n-                };\n-                FixedVector(box ty.clean(cx), n)\n+            TyArray(ref ty, length) => {\n+                use rustc_const_eval::eval_length;\n+                let n = eval_length(cx.tcx, length, \"array length\").unwrap();\n+                FixedVector(box ty.clean(cx), n.to_string())\n             },\n             TyTup(ref tys) => Tuple(tys.clean(cx)),\n             TyPath(hir::QPath::Resolved(None, ref path)) => {"}, {"sha": "503ef4c3183d2aa2ca543501b3bd6d329d54efa1", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -33,7 +33,6 @@ extern crate getopts;\n extern crate libc;\n extern crate rustc;\n extern crate rustc_const_eval;\n-extern crate rustc_const_math;\n extern crate rustc_data_structures;\n extern crate rustc_trans;\n extern crate rustc_driver;"}, {"sha": "3c688d58fd195d515153d3330228abd07399c8da", "filename": "src/test/compile-fail/const-eval-overflow.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf88730e755d099c854f84dd0f1990490bf0088/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs?ref=cbf88730e755d099c854f84dd0f1990490bf0088", "patch": "@@ -15,6 +15,8 @@\n // change this warn to a deny, then the compiler will exit before\n // those errors are detected.\n \n+#![warn(const_err)]\n+\n use std::fmt;\n use std::{i8, i16, i32, i64, isize};\n use std::{u8, u16, u32, u64, usize};\n@@ -80,7 +82,8 @@ const VALS_I64: (i64, i64, i64, i64) =\n      );\n \n const VALS_U8: (u8, u8, u8, u8) =\n-    (-(u8::MIN as i8) as u8,\n+    ( //~ WARN constant evaluation error: attempt to subtract with overflow.\n+     -(u8::MIN as i8) as u8,\n      u8::MIN - 1,\n      //~^ ERROR constant evaluation error\n      //~| attempt to subtract with overflow\n@@ -93,7 +96,8 @@ const VALS_U8: (u8, u8, u8, u8) =\n      );\n \n const VALS_U16: (u16, u16, u16, u16) =\n-    (-(u16::MIN as i16) as u16,\n+    ( //~ WARN constant evaluation error: attempt to subtract with overflow.\n+     -(u16::MIN as i16) as u16,\n      u16::MIN - 1,\n      //~^ ERROR constant evaluation error\n      //~| attempt to subtract with overflow\n@@ -106,7 +110,8 @@ const VALS_U16: (u16, u16, u16, u16) =\n      );\n \n const VALS_U32: (u32, u32, u32, u32) =\n-    (-(u32::MIN as i32) as u32,\n+    ( //~ WARN constant evaluation error: attempt to subtract with overflow.\n+     -(u32::MIN as i32) as u32,\n      u32::MIN - 1,\n      //~^ ERROR constant evaluation error\n      //~| attempt to subtract with overflow\n@@ -119,7 +124,8 @@ const VALS_U32: (u32, u32, u32, u32) =\n      );\n \n const VALS_U64: (u64, u64, u64, u64) =\n-    (-(u64::MIN as i64) as u64,\n+    ( //~ WARN constant evaluation error: attempt to subtract with overflow.\n+     -(u64::MIN as i64) as u64,\n      u64::MIN - 1,\n      //~^ ERROR constant evaluation error\n      //~| attempt to subtract with overflow"}, {"sha": "0e624a778583d1cc6fe463dadaf6c4ffe9ab9172", "filename": "src/test/run-pass/issue-28189.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7ac9d337dcc544b4b1959997cdd36f1ba0c8d3e1/src%2Ftest%2Frun-pass%2Fissue-28189.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac9d337dcc544b4b1959997cdd36f1ba0c8d3e1/src%2Ftest%2Frun-pass%2Fissue-28189.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-28189.rs?ref=7ac9d337dcc544b4b1959997cdd36f1ba0c8d3e1", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct S<T>(T) where [T; (||{}, 1).1]: Copy;\n-\n-fn main() {\n-\n-}"}]}