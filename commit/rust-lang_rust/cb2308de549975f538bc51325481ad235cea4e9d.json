{"sha": "cb2308de549975f538bc51325481ad235cea4e9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiMjMwOGRlNTQ5OTc1ZjUzOGJjNTEzMjU0ODFhZDIzNWNlYTRlOWQ=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-05-23T13:29:51Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-06-02T13:02:36Z"}, "message": "implement wf checking for constants", "tree": {"sha": "6c3010da2ae6fed380b255eb26c548fce73db3cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c3010da2ae6fed380b255eb26c548fce73db3cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb2308de549975f538bc51325481ad235cea4e9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb2308de549975f538bc51325481ad235cea4e9d", "html_url": "https://github.com/rust-lang/rust/commit/cb2308de549975f538bc51325481ad235cea4e9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb2308de549975f538bc51325481ad235cea4e9d/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3cba254e464303a6495942f3a831c2bbd7f1768", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3cba254e464303a6495942f3a831c2bbd7f1768", "html_url": "https://github.com/rust-lang/rust/commit/d3cba254e464303a6495942f3a831c2bbd7f1768"}], "stats": {"total": 125, "additions": 87, "deletions": 38}, "files": [{"sha": "60a88815214266e8e18dea9965938cc3f689899e", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 87, "deletions": 38, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/cb2308de549975f538bc51325481ad235cea4e9d/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb2308de549975f538bc51325481ad235cea4e9d/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=cb2308de549975f538bc51325481ad235cea4e9d", "patch": "@@ -4,7 +4,7 @@ use crate::traits;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items;\n-use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n use rustc_span::Span;\n use std::rc::Rc;\n@@ -37,14 +37,44 @@ pub fn obligations<'a, 'tcx>(\n     };\n \n     let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![], item: None };\n-    wf.compute(ty);\n+    wf.compute(ty.into());\n     debug!(\"wf::obligations({:?}, body_id={:?}) = {:?}\", ty, body_id, wf.out);\n \n     let result = wf.normalize();\n     debug!(\"wf::obligations({:?}, body_id={:?}) ~~> {:?}\", ty, body_id, result);\n     Some(result)\n }\n \n+/// Returns the set of obligations needed to make the `constant` well-formed.\n+pub fn const_obligations<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    body_id: hir::HirId,\n+    constant: &'tcx ty::Const<'tcx>,\n+    span: Span,\n+) -> Option<Vec<traits::PredicateObligation<'tcx>>> {\n+    let constant = match constant.val {\n+        ty::ConstKind::Infer(infer) => {\n+            let resolved = infcx.shallow_resolve(infer);\n+            if resolved == infer {\n+                // No progress.\n+                return None;\n+            }\n+\n+            infcx.tcx.mk_const(ty::Const { val: ty::ConstKind::Infer(resolved), ..*constant })\n+        }\n+        _ => constant,\n+    };\n+\n+    let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![], item: None };\n+    wf.compute(constant.into());\n+    debug!(\"wf::const obligations({:?}, body_id={:?}) = {:?}\", constant, body_id, wf.out);\n+\n+    let result = wf.normalize();\n+    debug!(\"wf::const obligations({:?}, body_id={:?}) ~~> {:?}\", constant, body_id, result);\n+    Some(result)\n+}\n+\n /// Returns the obligations that make this trait reference\n /// well-formed.  For example, if there is a trait `Set` defined like\n /// `trait Set<K:Eq>`, then the trait reference `Foo: Set<Bar>` is WF\n@@ -78,33 +108,36 @@ pub fn predicate_obligations<'a, 'tcx>(\n         }\n         ty::PredicateKind::RegionOutlives(..) => {}\n         ty::PredicateKind::TypeOutlives(t) => {\n-            wf.compute(t.skip_binder().0);\n+            wf.compute(t.skip_binder().0.into());\n         }\n         ty::PredicateKind::Projection(t) => {\n             let t = t.skip_binder(); // (*)\n             wf.compute_projection(t.projection_ty);\n-            wf.compute(t.ty);\n+            wf.compute(t.ty.into());\n         }\n         &ty::PredicateKind::WellFormed(t) => {\n-            wf.compute(t);\n+            wf.compute(t.into());\n         }\n         ty::PredicateKind::ObjectSafe(_) => {}\n         ty::PredicateKind::ClosureKind(..) => {}\n         ty::PredicateKind::Subtype(data) => {\n-            wf.compute(data.skip_binder().a); // (*)\n-            wf.compute(data.skip_binder().b); // (*)\n+            wf.compute(data.skip_binder().a.into()); // (*)\n+            wf.compute(data.skip_binder().b.into()); // (*)\n         }\n         &ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n             let obligations = wf.nominal_obligations(def_id, substs);\n             wf.out.extend(obligations);\n \n-            for ty in substs.types() {\n-                wf.compute(ty);\n+            for subst in substs.iter().copied() {\n+                wf.compute(subst);\n             }\n         }\n         ty::PredicateKind::ConstEquate(c1, c2) => {\n-            wf.compute(c1.ty);\n-            wf.compute(c2.ty);\n+            wf.compute(c1.ty.into());\n+            wf.compute(c2.ty.into());\n+        }\n+        ty::Predicate::WellFormedConst(constant) => {\n+            wf.compute(constant.into());\n         }\n     }\n \n@@ -213,7 +246,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn cause(&mut self, code: traits::ObligationCauseCode<'tcx>) -> traits::ObligationCause<'tcx> {\n+    fn cause(&self, code: traits::ObligationCauseCode<'tcx>) -> traits::ObligationCause<'tcx> {\n         traits::ObligationCause::new(self.span, self.body_id, code)\n     }\n \n@@ -300,22 +333,6 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         }\n     }\n \n-    /// Pushes the obligations required for an array length to be WF\n-    /// into `self.out`.\n-    fn compute_array_len(&mut self, constant: ty::Const<'tcx>) {\n-        if let ty::ConstKind::Unevaluated(def_id, substs, promoted) = constant.val {\n-            assert!(promoted.is_none());\n-\n-            let obligations = self.nominal_obligations(def_id, substs);\n-            self.out.extend(obligations);\n-\n-            let predicate =\n-                ty::PredicateKind::ConstEvaluatable(def_id, substs).to_predicate(self.tcx());\n-            let cause = self.cause(traits::MiscObligation);\n-            self.out.push(traits::Obligation::new(cause, self.param_env, predicate));\n-        }\n-    }\n-\n     fn require_sized(&mut self, subty: Ty<'tcx>, cause: traits::ObligationCauseCode<'tcx>) {\n         if !subty.has_escaping_bound_vars() {\n             let cause = self.cause(cause);\n@@ -332,8 +349,8 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n     }\n \n     /// Pushes all the predicates needed to validate that `ty` is WF into `out`.\n-    fn compute(&mut self, ty: Ty<'tcx>) {\n-        let mut walker = ty.walk();\n+    fn compute(&mut self, arg: GenericArg<'tcx>) {\n+        let mut walker = arg.walk();\n         let param_env = self.param_env;\n         while let Some(arg) = walker.next() {\n             let ty = match arg.unpack() {\n@@ -343,9 +360,43 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 // obligations are handled by the parent (e.g. `ty::Ref`).\n                 GenericArgKind::Lifetime(_) => continue,\n \n-                // FIXME(eddyb) this is wrong and needs to be replaced\n-                // (see https://github.com/rust-lang/rust/pull/70107).\n-                GenericArgKind::Const(_) => continue,\n+                GenericArgKind::Const(constant) => {\n+                    match constant.val {\n+                        ty::ConstKind::Unevaluated(def_id, substs, promoted) => {\n+                            assert!(promoted.is_none());\n+\n+                            let obligations = self.nominal_obligations(def_id, substs);\n+                            self.out.extend(obligations);\n+\n+                            let predicate = ty::PredicateKind::ConstEvaluatable(def_id, substs).to_predicate(self.tcx());\n+                            let cause = self.cause(traits::MiscObligation);\n+                            self.out.push(traits::Obligation::new(\n+                                cause,\n+                                self.param_env,\n+                                predicate,\n+                            ));\n+                        }\n+                        ty::ConstKind::Infer(infer) => {\n+                            let resolved = self.infcx.shallow_resolve(infer);\n+                            // the `InferConst` changed, meaning that we made progress.\n+                            if resolved != infer {\n+                                let cause = self.cause(traits::MiscObligation);\n+\n+                                let resolved_constant = self.infcx.tcx.mk_const(ty::Const {\n+                                    val: ty::ConstKind::Infer(resolved),\n+                                    ..*constant\n+                                });\n+                                self.out.push(traits::Obligation::new(\n+                                    cause,\n+                                    self.param_env,\n+                                    ty::PredicateKind::WellFormedConst(resolved_constant).to_predicate(self.tcx()),\n+                                ));\n+                            }\n+                        }\n+                        _ => (),\n+                    }\n+                    continue;\n+                }\n             };\n \n             match ty.kind {\n@@ -375,10 +426,8 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     self.require_sized(subty, traits::SliceOrArrayElem);\n                 }\n \n-                ty::Array(subty, len) => {\n+                ty::Array(subty, _) => {\n                     self.require_sized(subty, traits::SliceOrArrayElem);\n-                    // FIXME(eddyb) handle `GenericArgKind::Const` above instead.\n-                    self.compute_array_len(*len);\n                 }\n \n                 ty::Tuple(ref tys) => {\n@@ -467,7 +516,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     walker.skip_current_subtree(); // subtree handled below\n                     for upvar_ty in substs.as_closure().upvar_tys() {\n                         // FIXME(eddyb) add the type to `walker` instead of recursing.\n-                        self.compute(upvar_ty);\n+                        self.compute(upvar_ty.into());\n                     }\n                 }\n \n@@ -540,7 +589,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     } else {\n                         // Yes, resolved, proceed with the result.\n                         // FIXME(eddyb) add the type to `walker` instead of recursing.\n-                        self.compute(ty);\n+                        self.compute(ty.into());\n                     }\n                 }\n             }"}]}