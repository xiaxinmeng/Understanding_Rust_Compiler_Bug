{"sha": "dde9488559514e7d039cec9407e1f8627f665cd0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkZTk0ODg1NTk1MTRlN2QwMzljZWM5NDA3ZTFmODYyN2Y2NjVjZDA=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-09T16:54:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-09T16:54:14Z"}, "message": "Merge #3919\n\n3919: Refactor tokena accessors r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "5ddc0361d4d3538b60cb63a645042cfdcd51f4c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ddc0361d4d3538b60cb63a645042cfdcd51f4c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dde9488559514e7d039cec9407e1f8627f665cd0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJej1M2CRBK7hj4Ov3rIwAAdHIIAKorsteeKEMeXVdYtw5MSrDG\nMkLd0ejO1ZojV3+gFHuGUaPXIc2Z4zCbcv9ilL/VS7t/w2sUNWYCxp8WN/PuhoZW\nJ1Wkuh1rYx6AeYZ6LvlU9IU+q4fLHAvqXcOy+SR2toLBvYPCtLssXrSjR9uyG9SH\n9id+GmXpjvyFJu3r9JcmrN7qT/H/KpakqXhMzOPJ+7djjORKSg451krXAWnhtfMD\nXIzFNIGmkaphme/GdE+hQZGwUZDNfcYWCscxgJOJqtet/Ot74xZ+0Oad4tpjKv7r\nxluRvnYyiZJUIP/i2vvjrxjlR51aQx3LYzwPGpCXihzu2AdrQ3zvsqeGLJ2FMB8=\n=nKsR\n-----END PGP SIGNATURE-----\n", "payload": "tree 5ddc0361d4d3538b60cb63a645042cfdcd51f4c6\nparent 4cea01fdf8dc0a647007bde3010f9fbe607f1e75\nparent 2bfb65db93e48d8f9e8ecac0b2ea837c081a4db5\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1586451254 +0000\ncommitter GitHub <noreply@github.com> 1586451254 +0000\n\nMerge #3919\n\n3919: Refactor tokena accessors r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dde9488559514e7d039cec9407e1f8627f665cd0", "html_url": "https://github.com/rust-lang/rust/commit/dde9488559514e7d039cec9407e1f8627f665cd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dde9488559514e7d039cec9407e1f8627f665cd0/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cea01fdf8dc0a647007bde3010f9fbe607f1e75", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cea01fdf8dc0a647007bde3010f9fbe607f1e75", "html_url": "https://github.com/rust-lang/rust/commit/4cea01fdf8dc0a647007bde3010f9fbe607f1e75"}, {"sha": "2bfb65db93e48d8f9e8ecac0b2ea837c081a4db5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bfb65db93e48d8f9e8ecac0b2ea837c081a4db5", "html_url": "https://github.com/rust-lang/rust/commit/2bfb65db93e48d8f9e8ecac0b2ea837c081a4db5"}], "stats": {"total": 588, "additions": 247, "deletions": 341}, "files": [{"sha": "e7dcfb44e27362e8c0371a3df82a18c0b7fa6f86", "filename": "crates/ra_assists/src/handlers/add_explicit_type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=dde9488559514e7d039cec9407e1f8627f665cd0", "patch": "@@ -1,6 +1,6 @@\n use hir::HirDisplay;\n use ra_syntax::{\n-    ast::{self, AstNode, LetStmt, NameOwner, TypeAscriptionOwner},\n+    ast::{self, AstNode, AstToken, LetStmt, NameOwner, TypeAscriptionOwner},\n     TextRange,\n };\n \n@@ -35,7 +35,7 @@ pub(crate) fn add_explicit_type(ctx: AssistCtx) -> Option<Assist> {\n     let name = pat.name()?;\n     let name_range = name.syntax().text_range();\n     let stmt_range = stmt.syntax().text_range();\n-    let eq_range = stmt.eq_token()?.text_range();\n+    let eq_range = stmt.eq_token()?.syntax().text_range();\n     // Assist should only be applicable if cursor is between 'let' and '='\n     let let_range = TextRange::from_to(stmt_range.start(), eq_range.start());\n     let cursor_in_range = ctx.frange.range.is_subrange(&let_range);"}, {"sha": "26dfed23767990588e152a7267fc9a22627494e7", "filename": "crates/ra_assists/src/handlers/add_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs?ref=dde9488559514e7d039cec9407e1f8627f665cd0", "patch": "@@ -42,7 +42,7 @@ pub(crate) fn add_impl(ctx: AssistCtx) -> Option<Assist> {\n         if let Some(type_params) = type_params {\n             let lifetime_params = type_params\n                 .lifetime_params()\n-                .filter_map(|it| it.lifetime())\n+                .filter_map(|it| it.lifetime_token())\n                 .map(|it| it.text().clone());\n             let type_params =\n                 type_params.type_params().filter_map(|it| it.name()).map(|it| it.text().clone());"}, {"sha": "30360af9421db6b946dccb51072c6d68ae43ded7", "filename": "crates/ra_assists/src/handlers/add_new.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs?ref=dde9488559514e7d039cec9407e1f8627f665cd0", "patch": "@@ -106,7 +106,7 @@ fn generate_impl_text(strukt: &ast::StructDef, code: &str) -> String {\n     if let Some(type_params) = type_params {\n         let lifetime_params = type_params\n             .lifetime_params()\n-            .filter_map(|it| it.lifetime())\n+            .filter_map(|it| it.lifetime_token())\n             .map(|it| it.text().clone());\n         let type_params =\n             type_params.type_params().filter_map(|it| it.name()).map(|it| it.text().clone());"}, {"sha": "b9eb0967652f15ed5747383cdc26c5de6dfa49fc", "filename": "crates/ra_assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=dde9488559514e7d039cec9407e1f8627f665cd0", "patch": "@@ -29,7 +29,7 @@ pub(crate) fn inline_local_variable(ctx: AssistCtx) -> Option<Assist> {\n         ast::Pat::BindPat(pat) => pat,\n         _ => return None,\n     };\n-    if bind_pat.is_mutable() {\n+    if bind_pat.mut_kw_token().is_some() {\n         tested_by!(test_not_inline_mut_variable);\n         return None;\n     }"}, {"sha": "ab6bdf6bbdf88df49aa4c67e7a5e24d9c285dee6", "filename": "crates/ra_assists/src/handlers/introduce_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs?ref=dde9488559514e7d039cec9407e1f8627f665cd0", "patch": "@@ -61,7 +61,7 @@ pub(crate) fn introduce_variable(ctx: AssistCtx) -> Option<Assist> {\n         };\n         if is_full_stmt {\n             tested_by!(test_introduce_var_expr_stmt);\n-            if !full_stmt.unwrap().has_semi() {\n+            if full_stmt.unwrap().semi_token().is_none() {\n                 buf.push_str(\";\");\n             }\n             edit.replace(expr.syntax().text_range(), buf);"}, {"sha": "936d50ab49c28b583031fe146665686248d580ca", "filename": "crates/ra_assists/src/handlers/merge_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs?ref=dde9488559514e7d039cec9407e1f8627f665cd0", "patch": "@@ -82,7 +82,7 @@ fn try_merge_trees(old: &ast::UseTree, new: &ast::UseTree) -> Option<ast::UseTre\n             .filter(|it| it.kind() != T!['{'] && it.kind() != T!['}']),\n     );\n     let use_tree_list = lhs.use_tree_list()?;\n-    let pos = InsertPosition::Before(use_tree_list.r_curly()?.syntax().clone().into());\n+    let pos = InsertPosition::Before(use_tree_list.r_curly_token()?.syntax().clone().into());\n     let use_tree_list = use_tree_list.insert_children(pos, to_insert);\n     Some(lhs.with_use_tree_list(use_tree_list))\n }"}, {"sha": "c4a5ec59cbb258f4ed5176b7b7dd053137cc740e", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=dde9488559514e7d039cec9407e1f8627f665cd0", "patch": "@@ -572,7 +572,10 @@ impl ExprCollector<'_> {\n         let pattern = match &pat {\n             ast::Pat::BindPat(bp) => {\n                 let name = bp.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n-                let annotation = BindingAnnotation::new(bp.is_mutable(), bp.is_ref());\n+                let annotation = BindingAnnotation::new(\n+                    bp.mut_kw_token().is_some(),\n+                    bp.ref_kw_token().is_some(),\n+                );\n                 let subpat = bp.pat().map(|subpat| self.collect_pat(subpat));\n                 if annotation == BindingAnnotation::Unannotated && subpat.is_none() {\n                     // This could also be a single-segment path pattern. To\n@@ -613,7 +616,7 @@ impl ExprCollector<'_> {\n             }\n             ast::Pat::RefPat(p) => {\n                 let pat = self.collect_pat_opt(p.pat());\n-                let mutability = Mutability::from_mutable(p.is_mut());\n+                let mutability = Mutability::from_mutable(p.mut_kw_token().is_some());\n                 Pat::Ref { pat, mutability }\n             }\n             ast::Pat::PathPat(p) => {"}, {"sha": "689bb6c5c2f8afbaaa69418e02fc481bd560e0ba", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=dde9488559514e7d039cec9407e1f8627f665cd0", "patch": "@@ -75,7 +75,7 @@ impl FunctionData {\n             TypeRef::unit()\n         };\n \n-        let ret_type = if src.value.is_async() {\n+        let ret_type = if src.value.async_kw_token().is_some() {\n             let future_impl = desugar_future_path(ret_type);\n             let ty_bound = TypeBound::Path(future_impl);\n             TypeRef::ImplTrait(vec![ty_bound])\n@@ -136,7 +136,7 @@ impl TraitData {\n     pub(crate) fn trait_data_query(db: &dyn DefDatabase, tr: TraitId) -> Arc<TraitData> {\n         let src = tr.lookup(db).source(db);\n         let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n-        let auto = src.value.is_auto();\n+        let auto = src.value.auto_kw_token().is_some();\n         let ast_id_map = db.ast_id_map(src.file_id);\n \n         let container = AssocContainerId::TraitId(tr);\n@@ -213,7 +213,7 @@ impl ImplData {\n \n         let target_trait = src.value.target_trait().map(TypeRef::from_ast);\n         let target_type = TypeRef::from_ast_opt(src.value.target_type());\n-        let is_negative = src.value.is_negative();\n+        let is_negative = src.value.excl_token().is_some();\n         let module_id = impl_loc.container.module(db);\n \n         let mut items = Vec::new();"}, {"sha": "d850244c4a1f512f3b4272bd6a1b9fad6680fc89", "filename": "crates/ra_hir_def/src/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs?ref=dde9488559514e7d039cec9407e1f8627f665cd0", "patch": "@@ -194,7 +194,7 @@ impl GenericParams {\n     }\n \n     fn add_where_predicate_from_bound(&mut self, bound: ast::TypeBound, type_ref: TypeRef) {\n-        if bound.has_question_mark() {\n+        if bound.question_token().is_some() {\n             // FIXME: remove this bound\n             return;\n         }"}, {"sha": "e72ba52cfb37a0144da0809221ac6298947fa96b", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=dde9488559514e7d039cec9407e1f8627f665cd0", "patch": "@@ -287,7 +287,7 @@ impl RawItemsCollector {\n         let visibility = RawVisibility::from_ast_with_hygiene(module.visibility(), &self.hygiene);\n \n         let ast_id = self.source_ast_id_map.ast_id(&module);\n-        if module.has_semi() {\n+        if module.semi_token().is_some() {\n             let item =\n                 self.raw_items.modules.alloc(ModuleData::Declaration { name, visibility, ast_id });\n             self.push_item(current_module, attrs, RawItemKind::Module(item));"}, {"sha": "0f806d6fb500abf04546fc85387465555e7f572a", "filename": "crates/ra_hir_def/src/path/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs?ref=dde9488559514e7d039cec9407e1f8627f665cd0", "patch": "@@ -28,7 +28,7 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n     loop {\n         let segment = path.segment()?;\n \n-        if segment.coloncolon().is_some() {\n+        if segment.coloncolon_token().is_some() {\n             kind = PathKind::Abs;\n         }\n "}, {"sha": "5b6854b0f0038de438ecfb8cd1d9d02ecf2de374", "filename": "crates/ra_hir_def/src/path/lower/lower_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs?ref=dde9488559514e7d039cec9407e1f8627f665cd0", "patch": "@@ -34,7 +34,7 @@ pub(crate) fn lower_use_tree(\n         let alias = tree.alias().map(|a| {\n             a.name().map(|it| it.as_name()).map_or(ImportAlias::Underscore, ImportAlias::Alias)\n         });\n-        let is_glob = tree.star().is_some();\n+        let is_glob = tree.star_token().is_some();\n         if let Some(ast_path) = tree.path() {\n             // Handle self in a path.\n             // E.g. `use something::{self, <...>}`"}, {"sha": "7a8338937429295e0e3081f60b9528b9eb26debe", "filename": "crates/ra_hir_def/src/type_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs?ref=dde9488559514e7d039cec9407e1f8627f665cd0", "patch": "@@ -77,7 +77,7 @@ impl TypeRef {\n             }\n             ast::TypeRef::PointerType(inner) => {\n                 let inner_ty = TypeRef::from_ast_opt(inner.type_ref());\n-                let mutability = Mutability::from_mutable(inner.is_mut());\n+                let mutability = Mutability::from_mutable(inner.mut_kw_token().is_some());\n                 TypeRef::RawPtr(Box::new(inner_ty), mutability)\n             }\n             ast::TypeRef::ArrayType(inner) => {\n@@ -88,7 +88,7 @@ impl TypeRef {\n             }\n             ast::TypeRef::ReferenceType(inner) => {\n                 let inner_ty = TypeRef::from_ast_opt(inner.type_ref());\n-                let mutability = Mutability::from_mutable(inner.is_mut());\n+                let mutability = Mutability::from_mutable(inner.mut_kw_token().is_some());\n                 TypeRef::Reference(Box::new(inner_ty), mutability)\n             }\n             ast::TypeRef::PlaceholderType(_inner) => TypeRef::Placeholder,"}, {"sha": "f97e0bfebc8723b49454d4d57381fad69c7af75a", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=dde9488559514e7d039cec9407e1f8627f665cd0", "patch": "@@ -101,7 +101,7 @@ fn infer_with_mismatches(content: &str, include_mismatches: bool) -> String {\n             let node = src_ptr.value.to_node(&src_ptr.file_syntax(&db));\n \n             let (range, text) = if let Some(self_param) = ast::SelfParam::cast(node.clone()) {\n-                (self_param.self_kw().unwrap().syntax().text_range(), \"self\".to_string())\n+                (self_param.self_kw_token().unwrap().syntax().text_range(), \"self\".to_string())\n             } else {\n                 (src_ptr.value.range(), node.text().to_string().replace(\"\\n\", \" \"))\n             };"}, {"sha": "0e34d85dbd7ea2ef71cf77f8fc68bae3f86cf67d", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=dde9488559514e7d039cec9407e1f8627f665cd0", "patch": "@@ -190,7 +190,10 @@ impl<'a> CompletionContext<'a> {\n         if let Some(name) = find_node_at_offset::<ast::Name>(&file_with_fake_ident, offset) {\n             if let Some(bind_pat) = name.syntax().ancestors().find_map(ast::BindPat::cast) {\n                 self.is_pat_binding_or_const = true;\n-                if bind_pat.has_at() || bind_pat.is_ref() || bind_pat.is_mutable() {\n+                if bind_pat.at_token().is_some()\n+                    || bind_pat.ref_kw_token().is_some()\n+                    || bind_pat.mut_kw_token().is_some()\n+                {\n                     self.is_pat_binding_or_const = false;\n                 }\n                 if bind_pat.syntax().parent().and_then(ast::RecordFieldPatList::cast).is_some() {"}, {"sha": "ad6fd50aa0a50341857c8064452a99f6bd30d690", "filename": "crates/ra_ide/src/references.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=dde9488559514e7d039cec9407e1f8627f665cd0", "patch": "@@ -152,7 +152,7 @@ fn decl_access(def: &Definition, syntax: &SyntaxNode, range: TextRange) -> Optio\n     if stmt.initializer().is_some() {\n         let pat = stmt.pat()?;\n         if let ast::Pat::BindPat(it) = pat {\n-            if it.is_mutable() {\n+            if it.mut_kw_token().is_some() {\n                 return Some(ReferenceAccess::Write);\n             }\n         }"}, {"sha": "71d2bcb045dcbfb7a9584d1fabc81993171e24cc", "filename": "crates/ra_ide/src/typing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_ide%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_ide%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ftyping.rs?ref=dde9488559514e7d039cec9407e1f8627f665cd0", "patch": "@@ -63,7 +63,7 @@ fn on_char_typed_inner(\n fn on_eq_typed(file: &SourceFile, offset: TextUnit) -> Option<SingleFileChange> {\n     assert_eq!(file.syntax().text().char_at(offset), Some('='));\n     let let_stmt: ast::LetStmt = find_node_at_offset(file.syntax(), offset)?;\n-    if let_stmt.has_semi() {\n+    if let_stmt.semi_token().is_some() {\n         return None;\n     }\n     if let Some(expr) = let_stmt.initializer() {"}, {"sha": "15a8279f3dc31d0f2ef232f5cb825a90b93e3cc4", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=dde9488559514e7d039cec9407e1f8627f665cd0", "patch": "@@ -287,7 +287,7 @@ where\n     let pred = predicates.next().unwrap();\n     let mut bounds = pred.type_bound_list().unwrap().bounds();\n \n-    assert_eq!(\"'a\", pred.lifetime().unwrap().text());\n+    assert_eq!(\"'a\", pred.lifetime_token().unwrap().text());\n \n     assert_bound(\"'b\", bounds.next());\n     assert_bound(\"'c\", bounds.next());"}, {"sha": "069c6ee82a15af3c85c588a259c88e23e04f4220", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=dde9488559514e7d039cec9407e1f8627f665cd0", "patch": "@@ -33,9 +33,9 @@ impl ast::FnDef {\n         let mut to_insert: ArrayVec<[SyntaxElement; 2]> = ArrayVec::new();\n         let old_body_or_semi: SyntaxElement = if let Some(old_body) = self.body() {\n             old_body.syntax().clone().into()\n-        } else if let Some(semi) = self.semicolon_token() {\n+        } else if let Some(semi) = self.semi_token() {\n             to_insert.push(make::tokens::single_space().into());\n-            semi.into()\n+            semi.syntax.clone().into()\n         } else {\n             to_insert.push(make::tokens::single_space().into());\n             to_insert.push(body.syntax().clone().into());\n@@ -96,7 +96,7 @@ impl ast::ItemList {\n                 leading_indent(it.syntax()).unwrap_or_default().to_string(),\n                 InsertPosition::After(it.syntax().clone().into()),\n             ),\n-            None => match self.l_curly() {\n+            None => match self.l_curly_token() {\n                 Some(it) => (\n                     \"    \".to_string() + &leading_indent(self.syntax()).unwrap_or_default(),\n                     InsertPosition::After(it.syntax().clone().into()),\n@@ -142,7 +142,7 @@ impl ast::RecordFieldList {\n \n         macro_rules! after_l_curly {\n             () => {{\n-                let anchor = match self.l_curly() {\n+                let anchor = match self.l_curly_token() {\n                     Some(it) => it.syntax().clone().into(),\n                     None => return self.clone(),\n                 };\n@@ -301,7 +301,7 @@ impl ast::UseTree {\n             suffix.clone(),\n             self.use_tree_list(),\n             self.alias(),\n-            self.star().is_some(),\n+            self.star_token().is_some(),\n         );\n         let nested = make::use_tree_list(iter::once(use_tree));\n         return make::use_tree(prefix.clone(), Some(nested), None, false);"}, {"sha": "b50a89864eff4d8dc8bc3a644370ed84ee58f1ec", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 18, "deletions": 123, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=dde9488559514e7d039cec9407e1f8627f665cd0", "patch": "@@ -2,16 +2,14 @@\n //! Extensions for various expressions live in a sibling `expr_extensions` module.\n \n use itertools::Itertools;\n+use ra_parser::SyntaxKind;\n \n use crate::{\n     ast::{\n         self, child_opt, children, support, AstNode, AstToken, AttrInput, NameOwner, SyntaxNode,\n     },\n-    SmolStr, SyntaxElement,\n-    SyntaxKind::*,\n-    SyntaxToken, T,\n+    SmolStr, SyntaxElement, SyntaxToken, T,\n };\n-use ra_parser::SyntaxKind;\n \n impl ast::Name {\n     pub fn text(&self) -> &SmolStr {\n@@ -25,13 +23,11 @@ impl ast::NameRef {\n     }\n \n     pub fn as_tuple_field(&self) -> Option<usize> {\n-        self.syntax().children_with_tokens().find_map(|c| {\n-            if c.kind() == SyntaxKind::INT_NUMBER {\n-                c.as_token().and_then(|tok| tok.text().as_str().parse().ok())\n-            } else {\n-                None\n-            }\n-        })\n+        if let Some(ast::NameRefToken::IntNumber(token)) = self.name_ref_token_token() {\n+            token.text().as_str().parse().ok()\n+        } else {\n+            None\n+        }\n     }\n }\n \n@@ -140,15 +136,6 @@ impl ast::Path {\n     }\n }\n \n-impl ast::Module {\n-    pub fn has_semi(&self) -> bool {\n-        match self.syntax().last_child_or_token() {\n-            None => false,\n-            Some(node) => node.kind() == T![;],\n-        }\n-    }\n-}\n-\n impl ast::UseTreeList {\n     pub fn parent_use_tree(&self) -> ast::UseTree {\n         self.syntax()\n@@ -179,10 +166,6 @@ impl ast::ImplDef {\n         let second = types.next();\n         (first, second)\n     }\n-\n-    pub fn is_negative(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|t| t.kind() == T![!])\n-    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -223,41 +206,6 @@ impl ast::EnumVariant {\n     }\n }\n \n-impl ast::FnDef {\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken> {\n-        self.syntax()\n-            .last_child_or_token()\n-            .and_then(|it| it.into_token())\n-            .filter(|it| it.kind() == T![;])\n-    }\n-\n-    pub fn is_async(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|it| it.kind() == T![async])\n-    }\n-}\n-\n-impl ast::LetStmt {\n-    pub fn has_semi(&self) -> bool {\n-        match self.syntax().last_child_or_token() {\n-            None => false,\n-            Some(node) => node.kind() == T![;],\n-        }\n-    }\n-\n-    pub fn eq_token(&self) -> Option<SyntaxToken> {\n-        self.syntax().children_with_tokens().find(|t| t.kind() == EQ).and_then(|it| it.into_token())\n-    }\n-}\n-\n-impl ast::ExprStmt {\n-    pub fn has_semi(&self) -> bool {\n-        match self.syntax().last_child_or_token() {\n-            None => false,\n-            Some(node) => node.kind() == T![;],\n-        }\n-    }\n-}\n-\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum FieldKind {\n     Name(ast::NameRef),\n@@ -286,25 +234,6 @@ impl ast::FieldExpr {\n     }\n }\n \n-impl ast::RefPat {\n-    pub fn is_mut(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|n| n.kind() == T![mut])\n-    }\n-}\n-\n-impl ast::BindPat {\n-    pub fn is_mutable(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|n| n.kind() == T![mut])\n-    }\n-\n-    pub fn is_ref(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|n| n.kind() == T![ref])\n-    }\n-    pub fn has_at(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|it| it.kind() == T![@])\n-    }\n-}\n-\n pub struct SlicePatComponents {\n     pub prefix: Vec<ast::Pat>,\n     pub slice: Option<ast::Pat>,\n@@ -339,18 +268,6 @@ impl ast::SlicePat {\n     }\n }\n \n-impl ast::PointerType {\n-    pub fn is_mut(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|n| n.kind() == T![mut])\n-    }\n-}\n-\n-impl ast::ReferenceType {\n-    pub fn is_mut(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|n| n.kind() == T![mut])\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum SelfParamKind {\n     /// self\n@@ -363,8 +280,8 @@ pub enum SelfParamKind {\n \n impl ast::SelfParam {\n     pub fn kind(&self) -> SelfParamKind {\n-        if self.amp().is_some() {\n-            if self.amp_mut_kw().is_some() {\n+        if self.amp_token().is_some() {\n+            if self.amp_mut_kw_token().is_some() {\n                 SelfParamKind::MutRef\n             } else {\n                 SelfParamKind::Ref\n@@ -375,7 +292,7 @@ impl ast::SelfParam {\n     }\n \n     /// the \"mut\" in \"mut self\", not the one in \"&mut self\"\n-    pub fn mut_kw(&self) -> Option<ast::MutKw> {\n+    pub fn mut_kw_token(&self) -> Option<ast::MutKw> {\n         self.syntax()\n             .children_with_tokens()\n             .filter_map(|it| it.into_token())\n@@ -384,7 +301,7 @@ impl ast::SelfParam {\n     }\n \n     /// the \"mut\" in \"&mut self\", not the one in \"mut self\"\n-    pub fn amp_mut_kw(&self) -> Option<ast::MutKw> {\n+    pub fn amp_mut_kw_token(&self) -> Option<ast::MutKw> {\n         self.syntax()\n             .children_with_tokens()\n             .filter_map(|it| it.into_token())\n@@ -409,27 +326,23 @@ impl ast::TypeBound {\n             TypeBoundKind::PathType(path_type)\n         } else if let Some(for_type) = children(self).next() {\n             TypeBoundKind::ForType(for_type)\n-        } else if let Some(lifetime) = self.lifetime() {\n+        } else if let Some(lifetime) = self.lifetime_token() {\n             TypeBoundKind::Lifetime(lifetime)\n         } else {\n             unreachable!()\n         }\n     }\n \n-    pub fn has_question_mark(&self) -> bool {\n-        self.question().is_some()\n-    }\n-\n-    pub fn const_question(&self) -> Option<ast::Question> {\n+    pub fn const_question_token(&self) -> Option<ast::Question> {\n         self.syntax()\n             .children_with_tokens()\n             .filter_map(|it| it.into_token())\n             .take_while(|it| it.kind() != T![const])\n             .find_map(ast::Question::cast)\n     }\n \n-    pub fn question(&self) -> Option<ast::Question> {\n-        if self.const_kw().is_some() {\n+    pub fn question_token(&self) -> Option<ast::Question> {\n+        if self.const_kw_token().is_some() {\n             self.syntax()\n                 .children_with_tokens()\n                 .filter_map(|it| it.into_token())\n@@ -441,12 +354,6 @@ impl ast::TypeBound {\n     }\n }\n \n-impl ast::TraitDef {\n-    pub fn is_auto(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|t| t.kind() == T![auto])\n-    }\n-}\n-\n pub enum VisibilityKind {\n     In(ast::Path),\n     PubCrate,\n@@ -459,28 +366,16 @@ impl ast::Visibility {\n     pub fn kind(&self) -> VisibilityKind {\n         if let Some(path) = children(self).next() {\n             VisibilityKind::In(path)\n-        } else if self.is_pub_crate() {\n+        } else if self.crate_kw_token().is_some() {\n             VisibilityKind::PubCrate\n-        } else if self.is_pub_super() {\n+        } else if self.super_kw_token().is_some() {\n             VisibilityKind::PubSuper\n-        } else if self.is_pub_self() {\n+        } else if self.self_kw_token().is_some() {\n             VisibilityKind::PubSuper\n         } else {\n             VisibilityKind::Pub\n         }\n     }\n-\n-    fn is_pub_crate(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|it| it.kind() == T![crate])\n-    }\n-\n-    fn is_pub_super(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|it| it.kind() == T![super])\n-    }\n-\n-    fn is_pub_self(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|it| it.kind() == T![self])\n-    }\n }\n \n impl ast::MacroCall {"}, {"sha": "bcbfd1129df572b089e23f461e9946105321572b", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 191, "deletions": 188, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde9488559514e7d039cec9407e1f8627f665cd0/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=dde9488559514e7d039cec9407e1f8627f665cd0", "patch": "@@ -49,15 +49,15 @@ impl ast::DocCommentsOwner for FnDef {}\n impl ast::AttrsOwner for FnDef {}\n impl FnDef {\n     pub fn abi(&self) -> Option<Abi> { support::child(&self.syntax) }\n-    pub fn const_kw(&self) -> Option<ConstKw> { support::token(&self.syntax) }\n-    pub fn default_kw(&self) -> Option<DefaultKw> { support::token(&self.syntax) }\n-    pub fn async_kw(&self) -> Option<AsyncKw> { support::token(&self.syntax) }\n-    pub fn unsafe_kw(&self) -> Option<UnsafeKw> { support::token(&self.syntax) }\n-    pub fn fn_kw(&self) -> Option<FnKw> { support::token(&self.syntax) }\n+    pub fn const_kw_token(&self) -> Option<ConstKw> { support::token(&self.syntax) }\n+    pub fn default_kw_token(&self) -> Option<DefaultKw> { support::token(&self.syntax) }\n+    pub fn async_kw_token(&self) -> Option<AsyncKw> { support::token(&self.syntax) }\n+    pub fn unsafe_kw_token(&self) -> Option<UnsafeKw> { support::token(&self.syntax) }\n+    pub fn fn_kw_token(&self) -> Option<FnKw> { support::token(&self.syntax) }\n     pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n     pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n     pub fn body(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n-    pub fn semi(&self) -> Option<Semi> { support::token(&self.syntax) }\n+    pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RetType {\n@@ -75,7 +75,7 @@ impl AstNode for RetType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl RetType {\n-    pub fn thin_arrow(&self) -> Option<ThinArrow> { support::token(&self.syntax) }\n+    pub fn thin_arrow_token(&self) -> Option<ThinArrow> { support::token(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -99,9 +99,9 @@ impl ast::TypeParamsOwner for StructDef {}\n impl ast::AttrsOwner for StructDef {}\n impl ast::DocCommentsOwner for StructDef {}\n impl StructDef {\n-    pub fn struct_kw(&self) -> Option<StructKw> { support::token(&self.syntax) }\n+    pub fn struct_kw_token(&self) -> Option<StructKw> { support::token(&self.syntax) }\n     pub fn field_def_list(&self) -> Option<FieldDefList> { support::child(&self.syntax) }\n-    pub fn semi(&self) -> Option<Semi> { support::token(&self.syntax) }\n+    pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UnionDef {\n@@ -124,7 +124,7 @@ impl ast::TypeParamsOwner for UnionDef {}\n impl ast::AttrsOwner for UnionDef {}\n impl ast::DocCommentsOwner for UnionDef {}\n impl UnionDef {\n-    pub fn union_kw(&self) -> Option<UnionKw> { support::token(&self.syntax) }\n+    pub fn union_kw_token(&self) -> Option<UnionKw> { support::token(&self.syntax) }\n     pub fn record_field_def_list(&self) -> Option<RecordFieldDefList> {\n         support::child(&self.syntax)\n     }\n@@ -145,9 +145,9 @@ impl AstNode for RecordFieldDefList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl RecordFieldDefList {\n-    pub fn l_curly(&self) -> Option<LCurly> { support::token(&self.syntax) }\n+    pub fn l_curly_token(&self) -> Option<LCurly> { support::token(&self.syntax) }\n     pub fn fields(&self) -> AstChildren<RecordFieldDef> { support::children(&self.syntax) }\n-    pub fn r_curly(&self) -> Option<RCurly> { support::token(&self.syntax) }\n+    pub fn r_curly_token(&self) -> Option<RCurly> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordFieldDef {\n@@ -186,9 +186,9 @@ impl AstNode for TupleFieldDefList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl TupleFieldDefList {\n-    pub fn l_paren(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n     pub fn fields(&self) -> AstChildren<TupleFieldDef> { support::children(&self.syntax) }\n-    pub fn r_paren(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleFieldDef {\n@@ -231,7 +231,7 @@ impl ast::TypeParamsOwner for EnumDef {}\n impl ast::AttrsOwner for EnumDef {}\n impl ast::DocCommentsOwner for EnumDef {}\n impl EnumDef {\n-    pub fn enum_kw(&self) -> Option<EnumKw> { support::token(&self.syntax) }\n+    pub fn enum_kw_token(&self) -> Option<EnumKw> { support::token(&self.syntax) }\n     pub fn variant_list(&self) -> Option<EnumVariantList> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -250,9 +250,9 @@ impl AstNode for EnumVariantList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl EnumVariantList {\n-    pub fn l_curly(&self) -> Option<LCurly> { support::token(&self.syntax) }\n+    pub fn l_curly_token(&self) -> Option<LCurly> { support::token(&self.syntax) }\n     pub fn variants(&self) -> AstChildren<EnumVariant> { support::children(&self.syntax) }\n-    pub fn r_curly(&self) -> Option<RCurly> { support::token(&self.syntax) }\n+    pub fn r_curly_token(&self) -> Option<RCurly> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct EnumVariant {\n@@ -275,7 +275,7 @@ impl ast::DocCommentsOwner for EnumVariant {}\n impl ast::AttrsOwner for EnumVariant {}\n impl EnumVariant {\n     pub fn field_def_list(&self) -> Option<FieldDefList> { support::child(&self.syntax) }\n-    pub fn eq(&self) -> Option<Eq> { support::token(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -300,9 +300,9 @@ impl ast::DocCommentsOwner for TraitDef {}\n impl ast::TypeParamsOwner for TraitDef {}\n impl ast::TypeBoundsOwner for TraitDef {}\n impl TraitDef {\n-    pub fn unsafe_kw(&self) -> Option<UnsafeKw> { support::token(&self.syntax) }\n-    pub fn auto_kw(&self) -> Option<AutoKw> { support::token(&self.syntax) }\n-    pub fn trait_kw(&self) -> Option<TraitKw> { support::token(&self.syntax) }\n+    pub fn unsafe_kw_token(&self) -> Option<UnsafeKw> { support::token(&self.syntax) }\n+    pub fn auto_kw_token(&self) -> Option<AutoKw> { support::token(&self.syntax) }\n+    pub fn trait_kw_token(&self) -> Option<TraitKw> { support::token(&self.syntax) }\n     pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -325,9 +325,9 @@ impl ast::NameOwner for Module {}\n impl ast::AttrsOwner for Module {}\n impl ast::DocCommentsOwner for Module {}\n impl Module {\n-    pub fn mod_kw(&self) -> Option<ModKw> { support::token(&self.syntax) }\n+    pub fn mod_kw_token(&self) -> Option<ModKw> { support::token(&self.syntax) }\n     pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n-    pub fn semi(&self) -> Option<Semi> { support::token(&self.syntax) }\n+    pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ItemList {\n@@ -347,9 +347,9 @@ impl AstNode for ItemList {\n impl ast::FnDefOwner for ItemList {}\n impl ast::ModuleItemOwner for ItemList {}\n impl ItemList {\n-    pub fn l_curly(&self) -> Option<LCurly> { support::token(&self.syntax) }\n+    pub fn l_curly_token(&self) -> Option<LCurly> { support::token(&self.syntax) }\n     pub fn impl_items(&self) -> AstChildren<ImplItem> { support::children(&self.syntax) }\n-    pub fn r_curly(&self) -> Option<RCurly> { support::token(&self.syntax) }\n+    pub fn r_curly_token(&self) -> Option<RCurly> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ConstDef {\n@@ -373,11 +373,11 @@ impl ast::AttrsOwner for ConstDef {}\n impl ast::DocCommentsOwner for ConstDef {}\n impl ast::TypeAscriptionOwner for ConstDef {}\n impl ConstDef {\n-    pub fn default_kw(&self) -> Option<DefaultKw> { support::token(&self.syntax) }\n-    pub fn const_kw(&self) -> Option<ConstKw> { support::token(&self.syntax) }\n-    pub fn eq(&self) -> Option<Eq> { support::token(&self.syntax) }\n+    pub fn default_kw_token(&self) -> Option<DefaultKw> { support::token(&self.syntax) }\n+    pub fn const_kw_token(&self) -> Option<ConstKw> { support::token(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn semi(&self) -> Option<Semi> { support::token(&self.syntax) }\n+    pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct StaticDef {\n@@ -401,11 +401,11 @@ impl ast::AttrsOwner for StaticDef {}\n impl ast::DocCommentsOwner for StaticDef {}\n impl ast::TypeAscriptionOwner for StaticDef {}\n impl StaticDef {\n-    pub fn static_kw(&self) -> Option<StaticKw> { support::token(&self.syntax) }\n-    pub fn mut_kw(&self) -> Option<MutKw> { support::token(&self.syntax) }\n-    pub fn eq(&self) -> Option<Eq> { support::token(&self.syntax) }\n+    pub fn static_kw_token(&self) -> Option<StaticKw> { support::token(&self.syntax) }\n+    pub fn mut_kw_token(&self) -> Option<MutKw> { support::token(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn semi(&self) -> Option<Semi> { support::token(&self.syntax) }\n+    pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeAliasDef {\n@@ -429,11 +429,11 @@ impl ast::AttrsOwner for TypeAliasDef {}\n impl ast::DocCommentsOwner for TypeAliasDef {}\n impl ast::TypeBoundsOwner for TypeAliasDef {}\n impl TypeAliasDef {\n-    pub fn default_kw(&self) -> Option<DefaultKw> { support::token(&self.syntax) }\n-    pub fn type_kw(&self) -> Option<TypeKw> { support::token(&self.syntax) }\n-    pub fn eq(&self) -> Option<Eq> { support::token(&self.syntax) }\n+    pub fn default_kw_token(&self) -> Option<DefaultKw> { support::token(&self.syntax) }\n+    pub fn type_kw_token(&self) -> Option<TypeKw> { support::token(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n-    pub fn semi(&self) -> Option<Semi> { support::token(&self.syntax) }\n+    pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ImplDef {\n@@ -453,12 +453,12 @@ impl AstNode for ImplDef {\n impl ast::TypeParamsOwner for ImplDef {}\n impl ast::AttrsOwner for ImplDef {}\n impl ImplDef {\n-    pub fn default_kw(&self) -> Option<DefaultKw> { support::token(&self.syntax) }\n-    pub fn const_kw(&self) -> Option<ConstKw> { support::token(&self.syntax) }\n-    pub fn unsafe_kw(&self) -> Option<UnsafeKw> { support::token(&self.syntax) }\n-    pub fn impl_kw(&self) -> Option<ImplKw> { support::token(&self.syntax) }\n-    pub fn excl(&self) -> Option<Excl> { support::token(&self.syntax) }\n-    pub fn for_kw(&self) -> Option<ForKw> { support::token(&self.syntax) }\n+    pub fn default_kw_token(&self) -> Option<DefaultKw> { support::token(&self.syntax) }\n+    pub fn const_kw_token(&self) -> Option<ConstKw> { support::token(&self.syntax) }\n+    pub fn unsafe_kw_token(&self) -> Option<UnsafeKw> { support::token(&self.syntax) }\n+    pub fn impl_kw_token(&self) -> Option<ImplKw> { support::token(&self.syntax) }\n+    pub fn excl_token(&self) -> Option<Excl> { support::token(&self.syntax) }\n+    pub fn for_kw_token(&self) -> Option<ForKw> { support::token(&self.syntax) }\n     pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -477,9 +477,9 @@ impl AstNode for ParenType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ParenType {\n-    pub fn l_paren(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n-    pub fn r_paren(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleType {\n@@ -497,9 +497,9 @@ impl AstNode for TupleType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl TupleType {\n-    pub fn l_paren(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n     pub fn fields(&self) -> AstChildren<TypeRef> { support::children(&self.syntax) }\n-    pub fn r_paren(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct NeverType {\n@@ -517,7 +517,7 @@ impl AstNode for NeverType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl NeverType {\n-    pub fn excl(&self) -> Option<Excl> { support::token(&self.syntax) }\n+    pub fn excl_token(&self) -> Option<Excl> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathType {\n@@ -553,8 +553,9 @@ impl AstNode for PointerType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl PointerType {\n-    pub fn star(&self) -> Option<Star> { support::token(&self.syntax) }\n-    pub fn const_kw(&self) -> Option<ConstKw> { support::token(&self.syntax) }\n+    pub fn star_token(&self) -> Option<Star> { support::token(&self.syntax) }\n+    pub fn const_kw_token(&self) -> Option<ConstKw> { support::token(&self.syntax) }\n+    pub fn mut_kw_token(&self) -> Option<MutKw> { support::token(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -573,11 +574,11 @@ impl AstNode for ArrayType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ArrayType {\n-    pub fn l_brack(&self) -> Option<LBrack> { support::token(&self.syntax) }\n+    pub fn l_brack_token(&self) -> Option<LBrack> { support::token(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n-    pub fn semi(&self) -> Option<Semi> { support::token(&self.syntax) }\n+    pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn r_brack(&self) -> Option<RBrack> { support::token(&self.syntax) }\n+    pub fn r_brack_token(&self) -> Option<RBrack> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SliceType {\n@@ -595,9 +596,9 @@ impl AstNode for SliceType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl SliceType {\n-    pub fn l_brack(&self) -> Option<LBrack> { support::token(&self.syntax) }\n+    pub fn l_brack_token(&self) -> Option<LBrack> { support::token(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n-    pub fn r_brack(&self) -> Option<RBrack> { support::token(&self.syntax) }\n+    pub fn r_brack_token(&self) -> Option<RBrack> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ReferenceType {\n@@ -615,9 +616,9 @@ impl AstNode for ReferenceType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ReferenceType {\n-    pub fn amp(&self) -> Option<Amp> { support::token(&self.syntax) }\n-    pub fn lifetime(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n-    pub fn mut_kw(&self) -> Option<MutKw> { support::token(&self.syntax) }\n+    pub fn amp_token(&self) -> Option<Amp> { support::token(&self.syntax) }\n+    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn mut_kw_token(&self) -> Option<MutKw> { support::token(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -636,7 +637,7 @@ impl AstNode for PlaceholderType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl PlaceholderType {\n-    pub fn underscore(&self) -> Option<Underscore> { support::token(&self.syntax) }\n+    pub fn underscore_token(&self) -> Option<Underscore> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct FnPointerType {\n@@ -655,8 +656,8 @@ impl AstNode for FnPointerType {\n }\n impl FnPointerType {\n     pub fn abi(&self) -> Option<Abi> { support::child(&self.syntax) }\n-    pub fn unsafe_kw(&self) -> Option<UnsafeKw> { support::token(&self.syntax) }\n-    pub fn fn_kw(&self) -> Option<FnKw> { support::token(&self.syntax) }\n+    pub fn unsafe_kw_token(&self) -> Option<UnsafeKw> { support::token(&self.syntax) }\n+    pub fn fn_kw_token(&self) -> Option<FnKw> { support::token(&self.syntax) }\n     pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n     pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n }\n@@ -676,7 +677,7 @@ impl AstNode for ForType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ForType {\n-    pub fn for_kw(&self) -> Option<ForKw> { support::token(&self.syntax) }\n+    pub fn for_kw_token(&self) -> Option<ForKw> { support::token(&self.syntax) }\n     pub fn type_param_list(&self) -> Option<TypeParamList> { support::child(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n@@ -697,7 +698,7 @@ impl AstNode for ImplTraitType {\n }\n impl ast::TypeBoundsOwner for ImplTraitType {}\n impl ImplTraitType {\n-    pub fn impl_kw(&self) -> Option<ImplKw> { support::token(&self.syntax) }\n+    pub fn impl_kw_token(&self) -> Option<ImplKw> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct DynTraitType {\n@@ -716,7 +717,7 @@ impl AstNode for DynTraitType {\n }\n impl ast::TypeBoundsOwner for DynTraitType {}\n impl DynTraitType {\n-    pub fn dyn_kw(&self) -> Option<DynKw> { support::token(&self.syntax) }\n+    pub fn dyn_kw_token(&self) -> Option<DynKw> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleExpr {\n@@ -735,9 +736,9 @@ impl AstNode for TupleExpr {\n }\n impl ast::AttrsOwner for TupleExpr {}\n impl TupleExpr {\n-    pub fn l_paren(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n     pub fn exprs(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n-    pub fn r_paren(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ArrayExpr {\n@@ -756,10 +757,10 @@ impl AstNode for ArrayExpr {\n }\n impl ast::AttrsOwner for ArrayExpr {}\n impl ArrayExpr {\n-    pub fn l_brack(&self) -> Option<LBrack> { support::token(&self.syntax) }\n+    pub fn l_brack_token(&self) -> Option<LBrack> { support::token(&self.syntax) }\n     pub fn exprs(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n-    pub fn semi(&self) -> Option<Semi> { support::token(&self.syntax) }\n-    pub fn r_brack(&self) -> Option<RBrack> { support::token(&self.syntax) }\n+    pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n+    pub fn r_brack_token(&self) -> Option<RBrack> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParenExpr {\n@@ -778,9 +779,9 @@ impl AstNode for ParenExpr {\n }\n impl ast::AttrsOwner for ParenExpr {}\n impl ParenExpr {\n-    pub fn l_paren(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn r_paren(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathExpr {\n@@ -817,9 +818,9 @@ impl AstNode for LambdaExpr {\n }\n impl ast::AttrsOwner for LambdaExpr {}\n impl LambdaExpr {\n-    pub fn static_kw(&self) -> Option<StaticKw> { support::token(&self.syntax) }\n-    pub fn async_kw(&self) -> Option<AsyncKw> { support::token(&self.syntax) }\n-    pub fn move_kw(&self) -> Option<MoveKw> { support::token(&self.syntax) }\n+    pub fn static_kw_token(&self) -> Option<StaticKw> { support::token(&self.syntax) }\n+    pub fn async_kw_token(&self) -> Option<AsyncKw> { support::token(&self.syntax) }\n+    pub fn move_kw_token(&self) -> Option<MoveKw> { support::token(&self.syntax) }\n     pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n     pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n@@ -841,7 +842,7 @@ impl AstNode for IfExpr {\n }\n impl ast::AttrsOwner for IfExpr {}\n impl IfExpr {\n-    pub fn if_kw(&self) -> Option<IfKw> { support::token(&self.syntax) }\n+    pub fn if_kw_token(&self) -> Option<IfKw> { support::token(&self.syntax) }\n     pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -862,7 +863,7 @@ impl AstNode for LoopExpr {\n impl ast::AttrsOwner for LoopExpr {}\n impl ast::LoopBodyOwner for LoopExpr {}\n impl LoopExpr {\n-    pub fn loop_kw(&self) -> Option<LoopKw> { support::token(&self.syntax) }\n+    pub fn loop_kw_token(&self) -> Option<LoopKw> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TryBlockExpr {\n@@ -881,7 +882,7 @@ impl AstNode for TryBlockExpr {\n }\n impl ast::AttrsOwner for TryBlockExpr {}\n impl TryBlockExpr {\n-    pub fn try_kw(&self) -> Option<TryKw> { support::token(&self.syntax) }\n+    pub fn try_kw_token(&self) -> Option<TryKw> { support::token(&self.syntax) }\n     pub fn body(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -902,9 +903,9 @@ impl AstNode for ForExpr {\n impl ast::AttrsOwner for ForExpr {}\n impl ast::LoopBodyOwner for ForExpr {}\n impl ForExpr {\n-    pub fn for_kw(&self) -> Option<ForKw> { support::token(&self.syntax) }\n+    pub fn for_kw_token(&self) -> Option<ForKw> { support::token(&self.syntax) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn in_kw(&self) -> Option<InKw> { support::token(&self.syntax) }\n+    pub fn in_kw_token(&self) -> Option<InKw> { support::token(&self.syntax) }\n     pub fn iterable(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -925,7 +926,7 @@ impl AstNode for WhileExpr {\n impl ast::AttrsOwner for WhileExpr {}\n impl ast::LoopBodyOwner for WhileExpr {}\n impl WhileExpr {\n-    pub fn while_kw(&self) -> Option<WhileKw> { support::token(&self.syntax) }\n+    pub fn while_kw_token(&self) -> Option<WhileKw> { support::token(&self.syntax) }\n     pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -945,8 +946,8 @@ impl AstNode for ContinueExpr {\n }\n impl ast::AttrsOwner for ContinueExpr {}\n impl ContinueExpr {\n-    pub fn continue_kw(&self) -> Option<ContinueKw> { support::token(&self.syntax) }\n-    pub fn lifetime(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn continue_kw_token(&self) -> Option<ContinueKw> { support::token(&self.syntax) }\n+    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BreakExpr {\n@@ -965,8 +966,8 @@ impl AstNode for BreakExpr {\n }\n impl ast::AttrsOwner for BreakExpr {}\n impl BreakExpr {\n-    pub fn break_kw(&self) -> Option<BreakKw> { support::token(&self.syntax) }\n-    pub fn lifetime(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn break_kw_token(&self) -> Option<BreakKw> { support::token(&self.syntax) }\n+    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -985,7 +986,7 @@ impl AstNode for Label {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl Label {\n-    pub fn lifetime(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BlockExpr {\n@@ -1005,7 +1006,7 @@ impl AstNode for BlockExpr {\n impl ast::AttrsOwner for BlockExpr {}\n impl BlockExpr {\n     pub fn label(&self) -> Option<Label> { support::child(&self.syntax) }\n-    pub fn unsafe_kw(&self) -> Option<UnsafeKw> { support::token(&self.syntax) }\n+    pub fn unsafe_kw_token(&self) -> Option<UnsafeKw> { support::token(&self.syntax) }\n     pub fn block(&self) -> Option<Block> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1065,7 +1066,7 @@ impl ast::AttrsOwner for MethodCallExpr {}\n impl ast::ArgListOwner for MethodCallExpr {}\n impl MethodCallExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn dot(&self) -> Option<Dot> { support::token(&self.syntax) }\n+    pub fn dot_token(&self) -> Option<Dot> { support::token(&self.syntax) }\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n     pub fn type_arg_list(&self) -> Option<TypeArgList> { support::child(&self.syntax) }\n }\n@@ -1086,8 +1087,8 @@ impl AstNode for IndexExpr {\n }\n impl ast::AttrsOwner for IndexExpr {}\n impl IndexExpr {\n-    pub fn l_brack(&self) -> Option<LBrack> { support::token(&self.syntax) }\n-    pub fn r_brack(&self) -> Option<RBrack> { support::token(&self.syntax) }\n+    pub fn l_brack_token(&self) -> Option<LBrack> { support::token(&self.syntax) }\n+    pub fn r_brack_token(&self) -> Option<RBrack> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct FieldExpr {\n@@ -1107,7 +1108,7 @@ impl AstNode for FieldExpr {\n impl ast::AttrsOwner for FieldExpr {}\n impl FieldExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn dot(&self) -> Option<Dot> { support::token(&self.syntax) }\n+    pub fn dot_token(&self) -> Option<Dot> { support::token(&self.syntax) }\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1128,8 +1129,8 @@ impl AstNode for AwaitExpr {\n impl ast::AttrsOwner for AwaitExpr {}\n impl AwaitExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn dot(&self) -> Option<Dot> { support::token(&self.syntax) }\n-    pub fn await_kw(&self) -> Option<AwaitKw> { support::token(&self.syntax) }\n+    pub fn dot_token(&self) -> Option<Dot> { support::token(&self.syntax) }\n+    pub fn await_kw_token(&self) -> Option<AwaitKw> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TryExpr {\n@@ -1148,7 +1149,7 @@ impl AstNode for TryExpr {\n }\n impl ast::AttrsOwner for TryExpr {}\n impl TryExpr {\n-    pub fn try_kw(&self) -> Option<TryKw> { support::token(&self.syntax) }\n+    pub fn try_kw_token(&self) -> Option<TryKw> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1169,7 +1170,7 @@ impl AstNode for CastExpr {\n impl ast::AttrsOwner for CastExpr {}\n impl CastExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn as_kw(&self) -> Option<AsKw> { support::token(&self.syntax) }\n+    pub fn as_kw_token(&self) -> Option<AsKw> { support::token(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1189,9 +1190,9 @@ impl AstNode for RefExpr {\n }\n impl ast::AttrsOwner for RefExpr {}\n impl RefExpr {\n-    pub fn amp(&self) -> Option<Amp> { support::token(&self.syntax) }\n-    pub fn raw_kw(&self) -> Option<RawKw> { support::token(&self.syntax) }\n-    pub fn mut_kw(&self) -> Option<MutKw> { support::token(&self.syntax) }\n+    pub fn amp_token(&self) -> Option<Amp> { support::token(&self.syntax) }\n+    pub fn raw_kw_token(&self) -> Option<RawKw> { support::token(&self.syntax) }\n+    pub fn mut_kw_token(&self) -> Option<MutKw> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1211,7 +1212,7 @@ impl AstNode for PrefixExpr {\n }\n impl ast::AttrsOwner for PrefixExpr {}\n impl PrefixExpr {\n-    pub fn prefix_op(&self) -> Option<PrefixOp> { support::token(&self.syntax) }\n+    pub fn prefix_op_token(&self) -> Option<PrefixOp> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1231,7 +1232,7 @@ impl AstNode for BoxExpr {\n }\n impl ast::AttrsOwner for BoxExpr {}\n impl BoxExpr {\n-    pub fn box_kw(&self) -> Option<BoxKw> { support::token(&self.syntax) }\n+    pub fn box_kw_token(&self) -> Option<BoxKw> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1251,7 +1252,7 @@ impl AstNode for RangeExpr {\n }\n impl ast::AttrsOwner for RangeExpr {}\n impl RangeExpr {\n-    pub fn range_op(&self) -> Option<RangeOp> { support::token(&self.syntax) }\n+    pub fn range_op_token(&self) -> Option<RangeOp> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BinExpr {\n@@ -1270,7 +1271,7 @@ impl AstNode for BinExpr {\n }\n impl ast::AttrsOwner for BinExpr {}\n impl BinExpr {\n-    pub fn bin_op(&self) -> Option<BinOp> { support::token(&self.syntax) }\n+    pub fn bin_op_token(&self) -> Option<BinOp> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Literal {\n@@ -1288,7 +1289,7 @@ impl AstNode for Literal {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl Literal {\n-    pub fn literal_token(&self) -> Option<LiteralToken> { support::token(&self.syntax) }\n+    pub fn literal_token_token(&self) -> Option<LiteralToken> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MatchExpr {\n@@ -1307,7 +1308,7 @@ impl AstNode for MatchExpr {\n }\n impl ast::AttrsOwner for MatchExpr {}\n impl MatchExpr {\n-    pub fn match_kw(&self) -> Option<MatchKw> { support::token(&self.syntax) }\n+    pub fn match_kw_token(&self) -> Option<MatchKw> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn match_arm_list(&self) -> Option<MatchArmList> { support::child(&self.syntax) }\n }\n@@ -1328,9 +1329,9 @@ impl AstNode for MatchArmList {\n }\n impl ast::AttrsOwner for MatchArmList {}\n impl MatchArmList {\n-    pub fn l_curly(&self) -> Option<LCurly> { support::token(&self.syntax) }\n+    pub fn l_curly_token(&self) -> Option<LCurly> { support::token(&self.syntax) }\n     pub fn arms(&self) -> AstChildren<MatchArm> { support::children(&self.syntax) }\n-    pub fn r_curly(&self) -> Option<RCurly> { support::token(&self.syntax) }\n+    pub fn r_curly_token(&self) -> Option<RCurly> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MatchArm {\n@@ -1351,7 +1352,7 @@ impl ast::AttrsOwner for MatchArm {}\n impl MatchArm {\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n     pub fn guard(&self) -> Option<MatchGuard> { support::child(&self.syntax) }\n-    pub fn fat_arrow(&self) -> Option<FatArrow> { support::token(&self.syntax) }\n+    pub fn fat_arrow_token(&self) -> Option<FatArrow> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1370,7 +1371,7 @@ impl AstNode for MatchGuard {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl MatchGuard {\n-    pub fn if_kw(&self) -> Option<IfKw> { support::token(&self.syntax) }\n+    pub fn if_kw_token(&self) -> Option<IfKw> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1408,11 +1409,11 @@ impl AstNode for RecordFieldList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl RecordFieldList {\n-    pub fn l_curly(&self) -> Option<LCurly> { support::token(&self.syntax) }\n+    pub fn l_curly_token(&self) -> Option<LCurly> { support::token(&self.syntax) }\n     pub fn fields(&self) -> AstChildren<RecordField> { support::children(&self.syntax) }\n-    pub fn dotdot(&self) -> Option<Dotdot> { support::token(&self.syntax) }\n+    pub fn dotdot_token(&self) -> Option<Dotdot> { support::token(&self.syntax) }\n     pub fn spread(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn r_curly(&self) -> Option<RCurly> { support::token(&self.syntax) }\n+    pub fn r_curly_token(&self) -> Option<RCurly> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordField {\n@@ -1432,7 +1433,7 @@ impl AstNode for RecordField {\n impl ast::AttrsOwner for RecordField {}\n impl RecordField {\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n-    pub fn colon(&self) -> Option<Colon> { support::token(&self.syntax) }\n+    pub fn colon_token(&self) -> Option<Colon> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1469,9 +1470,9 @@ impl AstNode for ParenPat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ParenPat {\n-    pub fn l_paren(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn r_paren(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RefPat {\n@@ -1489,8 +1490,8 @@ impl AstNode for RefPat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl RefPat {\n-    pub fn amp(&self) -> Option<Amp> { support::token(&self.syntax) }\n-    pub fn mut_kw(&self) -> Option<MutKw> { support::token(&self.syntax) }\n+    pub fn amp_token(&self) -> Option<Amp> { support::token(&self.syntax) }\n+    pub fn mut_kw_token(&self) -> Option<MutKw> { support::token(&self.syntax) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1509,7 +1510,7 @@ impl AstNode for BoxPat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl BoxPat {\n-    pub fn box_kw(&self) -> Option<BoxKw> { support::token(&self.syntax) }\n+    pub fn box_kw_token(&self) -> Option<BoxKw> { support::token(&self.syntax) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1530,8 +1531,9 @@ impl AstNode for BindPat {\n impl ast::AttrsOwner for BindPat {}\n impl ast::NameOwner for BindPat {}\n impl BindPat {\n-    pub fn ref_kw(&self) -> Option<RefKw> { support::token(&self.syntax) }\n-    pub fn mut_kw(&self) -> Option<MutKw> { support::token(&self.syntax) }\n+    pub fn ref_kw_token(&self) -> Option<RefKw> { support::token(&self.syntax) }\n+    pub fn mut_kw_token(&self) -> Option<MutKw> { support::token(&self.syntax) }\n+    pub fn at_token(&self) -> Option<At> { support::token(&self.syntax) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1550,7 +1552,7 @@ impl AstNode for PlaceholderPat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl PlaceholderPat {\n-    pub fn underscore(&self) -> Option<Underscore> { support::token(&self.syntax) }\n+    pub fn underscore_token(&self) -> Option<Underscore> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct DotDotPat {\n@@ -1568,7 +1570,7 @@ impl AstNode for DotDotPat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl DotDotPat {\n-    pub fn dotdot(&self) -> Option<Dotdot> { support::token(&self.syntax) }\n+    pub fn dotdot_token(&self) -> Option<Dotdot> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathPat {\n@@ -1604,9 +1606,9 @@ impl AstNode for SlicePat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl SlicePat {\n-    pub fn l_brack(&self) -> Option<LBrack> { support::token(&self.syntax) }\n+    pub fn l_brack_token(&self) -> Option<LBrack> { support::token(&self.syntax) }\n     pub fn args(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n-    pub fn r_brack(&self) -> Option<RBrack> { support::token(&self.syntax) }\n+    pub fn r_brack_token(&self) -> Option<RBrack> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RangePat {\n@@ -1624,7 +1626,7 @@ impl AstNode for RangePat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl RangePat {\n-    pub fn range_separator(&self) -> Option<RangeSeparator> { support::token(&self.syntax) }\n+    pub fn range_separator_token(&self) -> Option<RangeSeparator> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LiteralPat {\n@@ -1699,14 +1701,14 @@ impl AstNode for RecordFieldPatList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl RecordFieldPatList {\n-    pub fn l_curly(&self) -> Option<LCurly> { support::token(&self.syntax) }\n+    pub fn l_curly_token(&self) -> Option<LCurly> { support::token(&self.syntax) }\n     pub fn pats(&self) -> AstChildren<RecordInnerPat> { support::children(&self.syntax) }\n     pub fn record_field_pats(&self) -> AstChildren<RecordFieldPat> {\n         support::children(&self.syntax)\n     }\n     pub fn bind_pats(&self) -> AstChildren<BindPat> { support::children(&self.syntax) }\n-    pub fn dotdot(&self) -> Option<Dotdot> { support::token(&self.syntax) }\n-    pub fn r_curly(&self) -> Option<RCurly> { support::token(&self.syntax) }\n+    pub fn dotdot_token(&self) -> Option<Dotdot> { support::token(&self.syntax) }\n+    pub fn r_curly_token(&self) -> Option<RCurly> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordFieldPat {\n@@ -1726,7 +1728,7 @@ impl AstNode for RecordFieldPat {\n impl ast::AttrsOwner for RecordFieldPat {}\n impl ast::NameOwner for RecordFieldPat {}\n impl RecordFieldPat {\n-    pub fn colon(&self) -> Option<Colon> { support::token(&self.syntax) }\n+    pub fn colon_token(&self) -> Option<Colon> { support::token(&self.syntax) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1746,9 +1748,9 @@ impl AstNode for TupleStructPat {\n }\n impl TupleStructPat {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n-    pub fn l_paren(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n     pub fn args(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n-    pub fn r_paren(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TuplePat {\n@@ -1766,9 +1768,9 @@ impl AstNode for TuplePat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl TuplePat {\n-    pub fn l_paren(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n     pub fn args(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n-    pub fn r_paren(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Visibility {\n@@ -1786,10 +1788,10 @@ impl AstNode for Visibility {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl Visibility {\n-    pub fn pub_kw(&self) -> Option<PubKw> { support::token(&self.syntax) }\n-    pub fn super_kw(&self) -> Option<SuperKw> { support::token(&self.syntax) }\n-    pub fn self_kw(&self) -> Option<SelfKw> { support::token(&self.syntax) }\n-    pub fn crate_kw(&self) -> Option<CrateKw> { support::token(&self.syntax) }\n+    pub fn pub_kw_token(&self) -> Option<PubKw> { support::token(&self.syntax) }\n+    pub fn super_kw_token(&self) -> Option<SuperKw> { support::token(&self.syntax) }\n+    pub fn self_kw_token(&self) -> Option<SelfKw> { support::token(&self.syntax) }\n+    pub fn crate_kw_token(&self) -> Option<CrateKw> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Name {\n@@ -1807,7 +1809,7 @@ impl AstNode for Name {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl Name {\n-    pub fn ident(&self) -> Option<Ident> { support::token(&self.syntax) }\n+    pub fn ident_token(&self) -> Option<Ident> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct NameRef {\n@@ -1825,7 +1827,7 @@ impl AstNode for NameRef {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl NameRef {\n-    pub fn name_ref_token(&self) -> Option<NameRefToken> { support::token(&self.syntax) }\n+    pub fn name_ref_token_token(&self) -> Option<NameRefToken> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroCall {\n@@ -1847,9 +1849,9 @@ impl ast::AttrsOwner for MacroCall {}\n impl ast::DocCommentsOwner for MacroCall {}\n impl MacroCall {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n-    pub fn excl(&self) -> Option<Excl> { support::token(&self.syntax) }\n+    pub fn excl_token(&self) -> Option<Excl> { support::token(&self.syntax) }\n     pub fn token_tree(&self) -> Option<TokenTree> { support::child(&self.syntax) }\n-    pub fn semi(&self) -> Option<Semi> { support::token(&self.syntax) }\n+    pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Attr {\n@@ -1867,13 +1869,13 @@ impl AstNode for Attr {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl Attr {\n-    pub fn pound(&self) -> Option<Pound> { support::token(&self.syntax) }\n-    pub fn excl(&self) -> Option<Excl> { support::token(&self.syntax) }\n-    pub fn l_brack(&self) -> Option<LBrack> { support::token(&self.syntax) }\n+    pub fn pound_token(&self) -> Option<Pound> { support::token(&self.syntax) }\n+    pub fn excl_token(&self) -> Option<Excl> { support::token(&self.syntax) }\n+    pub fn l_brack_token(&self) -> Option<LBrack> { support::token(&self.syntax) }\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n-    pub fn eq(&self) -> Option<Eq> { support::token(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn input(&self) -> Option<AttrInput> { support::child(&self.syntax) }\n-    pub fn r_brack(&self) -> Option<RBrack> { support::token(&self.syntax) }\n+    pub fn r_brack_token(&self) -> Option<RBrack> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TokenTree {\n@@ -1907,12 +1909,12 @@ impl AstNode for TypeParamList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl TypeParamList {\n-    pub fn l_angle(&self) -> Option<LAngle> { support::token(&self.syntax) }\n+    pub fn l_angle_token(&self) -> Option<LAngle> { support::token(&self.syntax) }\n     pub fn generic_params(&self) -> AstChildren<GenericParam> { support::children(&self.syntax) }\n     pub fn type_params(&self) -> AstChildren<TypeParam> { support::children(&self.syntax) }\n     pub fn lifetime_params(&self) -> AstChildren<LifetimeParam> { support::children(&self.syntax) }\n     pub fn const_params(&self) -> AstChildren<ConstParam> { support::children(&self.syntax) }\n-    pub fn r_angle(&self) -> Option<RAngle> { support::token(&self.syntax) }\n+    pub fn r_angle_token(&self) -> Option<RAngle> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeParam {\n@@ -1933,7 +1935,7 @@ impl ast::NameOwner for TypeParam {}\n impl ast::AttrsOwner for TypeParam {}\n impl ast::TypeBoundsOwner for TypeParam {}\n impl TypeParam {\n-    pub fn eq(&self) -> Option<Eq> { support::token(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn default_type(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1955,7 +1957,7 @@ impl ast::NameOwner for ConstParam {}\n impl ast::AttrsOwner for ConstParam {}\n impl ast::TypeAscriptionOwner for ConstParam {}\n impl ConstParam {\n-    pub fn eq(&self) -> Option<Eq> { support::token(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn default_val(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1975,7 +1977,7 @@ impl AstNode for LifetimeParam {\n }\n impl ast::AttrsOwner for LifetimeParam {}\n impl LifetimeParam {\n-    pub fn lifetime(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeBound {\n@@ -1993,8 +1995,8 @@ impl AstNode for TypeBound {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl TypeBound {\n-    pub fn lifetime(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n-    pub fn const_kw(&self) -> Option<ConstKw> { support::token(&self.syntax) }\n+    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn const_kw_token(&self) -> Option<ConstKw> { support::token(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2032,7 +2034,7 @@ impl AstNode for WherePred {\n }\n impl ast::TypeBoundsOwner for WherePred {}\n impl WherePred {\n-    pub fn lifetime(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2051,7 +2053,7 @@ impl AstNode for WhereClause {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl WhereClause {\n-    pub fn where_kw(&self) -> Option<WhereKw> { support::token(&self.syntax) }\n+    pub fn where_kw_token(&self) -> Option<WhereKw> { support::token(&self.syntax) }\n     pub fn predicates(&self) -> AstChildren<WherePred> { support::children(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2070,7 +2072,7 @@ impl AstNode for Abi {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl Abi {\n-    pub fn string(&self) -> Option<String> { support::token(&self.syntax) }\n+    pub fn string_token(&self) -> Option<String> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExprStmt {\n@@ -2090,7 +2092,7 @@ impl AstNode for ExprStmt {\n impl ast::AttrsOwner for ExprStmt {}\n impl ExprStmt {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn semi(&self) -> Option<Semi> { support::token(&self.syntax) }\n+    pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LetStmt {\n@@ -2110,10 +2112,11 @@ impl AstNode for LetStmt {\n impl ast::AttrsOwner for LetStmt {}\n impl ast::TypeAscriptionOwner for LetStmt {}\n impl LetStmt {\n-    pub fn let_kw(&self) -> Option<LetKw> { support::token(&self.syntax) }\n+    pub fn let_kw_token(&self) -> Option<LetKw> { support::token(&self.syntax) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn eq(&self) -> Option<Eq> { support::token(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn initializer(&self) -> Option<Expr> { support::child(&self.syntax) }\n+    pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Condition {\n@@ -2131,9 +2134,9 @@ impl AstNode for Condition {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl Condition {\n-    pub fn let_kw(&self) -> Option<LetKw> { support::token(&self.syntax) }\n+    pub fn let_kw_token(&self) -> Option<LetKw> { support::token(&self.syntax) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn eq(&self) -> Option<Eq> { support::token(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2154,10 +2157,10 @@ impl AstNode for Block {\n impl ast::AttrsOwner for Block {}\n impl ast::ModuleItemOwner for Block {}\n impl Block {\n-    pub fn l_curly(&self) -> Option<LCurly> { support::token(&self.syntax) }\n+    pub fn l_curly_token(&self) -> Option<LCurly> { support::token(&self.syntax) }\n     pub fn statements(&self) -> AstChildren<Stmt> { support::children(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn r_curly(&self) -> Option<RCurly> { support::token(&self.syntax) }\n+    pub fn r_curly_token(&self) -> Option<RCurly> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParamList {\n@@ -2175,10 +2178,10 @@ impl AstNode for ParamList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ParamList {\n-    pub fn l_paren(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n     pub fn self_param(&self) -> Option<SelfParam> { support::child(&self.syntax) }\n     pub fn params(&self) -> AstChildren<Param> { support::children(&self.syntax) }\n-    pub fn r_paren(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SelfParam {\n@@ -2198,9 +2201,9 @@ impl AstNode for SelfParam {\n impl ast::TypeAscriptionOwner for SelfParam {}\n impl ast::AttrsOwner for SelfParam {}\n impl SelfParam {\n-    pub fn amp(&self) -> Option<Amp> { support::token(&self.syntax) }\n-    pub fn lifetime(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n-    pub fn self_kw(&self) -> Option<SelfKw> { support::token(&self.syntax) }\n+    pub fn amp_token(&self) -> Option<Amp> { support::token(&self.syntax) }\n+    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn self_kw_token(&self) -> Option<SelfKw> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Param {\n@@ -2221,7 +2224,7 @@ impl ast::TypeAscriptionOwner for Param {}\n impl ast::AttrsOwner for Param {}\n impl Param {\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn dotdotdot(&self) -> Option<Dotdotdot> { support::token(&self.syntax) }\n+    pub fn dotdotdot_token(&self) -> Option<Dotdotdot> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UseItem {\n@@ -2241,7 +2244,7 @@ impl AstNode for UseItem {\n impl ast::AttrsOwner for UseItem {}\n impl ast::VisibilityOwner for UseItem {}\n impl UseItem {\n-    pub fn use_kw(&self) -> Option<UseKw> { support::token(&self.syntax) }\n+    pub fn use_kw_token(&self) -> Option<UseKw> { support::token(&self.syntax) }\n     pub fn use_tree(&self) -> Option<UseTree> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2261,7 +2264,7 @@ impl AstNode for UseTree {\n }\n impl UseTree {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n-    pub fn star(&self) -> Option<Star> { support::token(&self.syntax) }\n+    pub fn star_token(&self) -> Option<Star> { support::token(&self.syntax) }\n     pub fn use_tree_list(&self) -> Option<UseTreeList> { support::child(&self.syntax) }\n     pub fn alias(&self) -> Option<Alias> { support::child(&self.syntax) }\n }\n@@ -2282,7 +2285,7 @@ impl AstNode for Alias {\n }\n impl ast::NameOwner for Alias {}\n impl Alias {\n-    pub fn as_kw(&self) -> Option<AsKw> { support::token(&self.syntax) }\n+    pub fn as_kw_token(&self) -> Option<AsKw> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UseTreeList {\n@@ -2300,9 +2303,9 @@ impl AstNode for UseTreeList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl UseTreeList {\n-    pub fn l_curly(&self) -> Option<LCurly> { support::token(&self.syntax) }\n+    pub fn l_curly_token(&self) -> Option<LCurly> { support::token(&self.syntax) }\n     pub fn use_trees(&self) -> AstChildren<UseTree> { support::children(&self.syntax) }\n-    pub fn r_curly(&self) -> Option<RCurly> { support::token(&self.syntax) }\n+    pub fn r_curly_token(&self) -> Option<RCurly> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExternCrateItem {\n@@ -2322,8 +2325,8 @@ impl AstNode for ExternCrateItem {\n impl ast::AttrsOwner for ExternCrateItem {}\n impl ast::VisibilityOwner for ExternCrateItem {}\n impl ExternCrateItem {\n-    pub fn extern_kw(&self) -> Option<ExternKw> { support::token(&self.syntax) }\n-    pub fn crate_kw(&self) -> Option<CrateKw> { support::token(&self.syntax) }\n+    pub fn extern_kw_token(&self) -> Option<ExternKw> { support::token(&self.syntax) }\n+    pub fn crate_kw_token(&self) -> Option<CrateKw> { support::token(&self.syntax) }\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n     pub fn alias(&self) -> Option<Alias> { support::child(&self.syntax) }\n }\n@@ -2343,9 +2346,9 @@ impl AstNode for ArgList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ArgList {\n-    pub fn l_paren(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n     pub fn args(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n-    pub fn r_paren(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Path {\n@@ -2382,14 +2385,14 @@ impl AstNode for PathSegment {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl PathSegment {\n-    pub fn coloncolon(&self) -> Option<Coloncolon> { support::token(&self.syntax) }\n-    pub fn l_angle(&self) -> Option<LAngle> { support::token(&self.syntax) }\n+    pub fn coloncolon_token(&self) -> Option<Coloncolon> { support::token(&self.syntax) }\n+    pub fn l_angle_token(&self) -> Option<LAngle> { support::token(&self.syntax) }\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n     pub fn type_arg_list(&self) -> Option<TypeArgList> { support::child(&self.syntax) }\n     pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n     pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n     pub fn path_type(&self) -> Option<PathType> { support::child(&self.syntax) }\n-    pub fn r_angle(&self) -> Option<RAngle> { support::token(&self.syntax) }\n+    pub fn r_angle_token(&self) -> Option<RAngle> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeArgList {\n@@ -2407,14 +2410,14 @@ impl AstNode for TypeArgList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl TypeArgList {\n-    pub fn coloncolon(&self) -> Option<Coloncolon> { support::token(&self.syntax) }\n-    pub fn l_angle(&self) -> Option<LAngle> { support::token(&self.syntax) }\n+    pub fn coloncolon_token(&self) -> Option<Coloncolon> { support::token(&self.syntax) }\n+    pub fn l_angle_token(&self) -> Option<LAngle> { support::token(&self.syntax) }\n     pub fn generic_args(&self) -> AstChildren<GenericArg> { support::children(&self.syntax) }\n     pub fn type_args(&self) -> AstChildren<TypeArg> { support::children(&self.syntax) }\n     pub fn lifetime_args(&self) -> AstChildren<LifetimeArg> { support::children(&self.syntax) }\n     pub fn assoc_type_args(&self) -> AstChildren<AssocTypeArg> { support::children(&self.syntax) }\n     pub fn const_args(&self) -> AstChildren<ConstArg> { support::children(&self.syntax) }\n-    pub fn r_angle(&self) -> Option<RAngle> { support::token(&self.syntax) }\n+    pub fn r_angle_token(&self) -> Option<RAngle> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeArg {\n@@ -2452,7 +2455,7 @@ impl AstNode for AssocTypeArg {\n impl ast::TypeBoundsOwner for AssocTypeArg {}\n impl AssocTypeArg {\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n-    pub fn eq(&self) -> Option<Eq> { support::token(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2471,7 +2474,7 @@ impl AstNode for LifetimeArg {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl LifetimeArg {\n-    pub fn lifetime(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ConstArg {\n@@ -2490,7 +2493,7 @@ impl AstNode for ConstArg {\n }\n impl ConstArg {\n     pub fn literal(&self) -> Option<Literal> { support::child(&self.syntax) }\n-    pub fn eq(&self) -> Option<Eq> { support::token(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn block_expr(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2548,9 +2551,9 @@ impl AstNode for ExternItemList {\n impl ast::FnDefOwner for ExternItemList {}\n impl ast::ModuleItemOwner for ExternItemList {}\n impl ExternItemList {\n-    pub fn l_curly(&self) -> Option<LCurly> { support::token(&self.syntax) }\n+    pub fn l_curly_token(&self) -> Option<LCurly> { support::token(&self.syntax) }\n     pub fn extern_items(&self) -> AstChildren<ExternItem> { support::children(&self.syntax) }\n-    pub fn r_curly(&self) -> Option<RCurly> { support::token(&self.syntax) }\n+    pub fn r_curly_token(&self) -> Option<RCurly> { support::token(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExternBlock {\n@@ -2588,7 +2591,7 @@ impl AstNode for MetaItem {\n }\n impl MetaItem {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n-    pub fn eq(&self) -> Option<Eq> { support::token(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn attr_input(&self) -> Option<AttrInput> { support::child(&self.syntax) }\n     pub fn nested_meta_items(&self) -> AstChildren<MetaItem> { support::children(&self.syntax) }\n }"}, {"sha": "74a87e9009b39274b8edf8dbf24e13da2395c92f", "filename": "xtask/src/ast_src.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dde9488559514e7d039cec9407e1f8627f665cd0/xtask%2Fsrc%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde9488559514e7d039cec9407e1f8627f665cd0/xtask%2Fsrc%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fast_src.rs?ref=dde9488559514e7d039cec9407e1f8627f665cd0", "patch": "@@ -408,7 +408,7 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n         struct TupleType { LParen, fields: [TypeRef], RParen }\n         struct NeverType { Excl }\n         struct PathType { Path }\n-        struct PointerType { Star, ConstKw, TypeRef }\n+        struct PointerType { Star, ConstKw, MutKw, TypeRef }\n         struct ArrayType { LBrack, TypeRef, Semi, Expr, RBrack }\n         struct SliceType { LBrack, TypeRef, RBrack }\n         struct ReferenceType { Amp, Lifetime, MutKw, TypeRef }\n@@ -485,7 +485,7 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n         struct ParenPat { LParen, Pat, RParen }\n         struct RefPat { Amp, MutKw, Pat }\n         struct BoxPat { BoxKw, Pat }\n-        struct BindPat: AttrsOwner, NameOwner { RefKw, MutKw, Pat }\n+        struct BindPat: AttrsOwner, NameOwner { RefKw, MutKw, At, Pat }\n         struct PlaceholderPat { Underscore }\n         struct DotDotPat { Dotdot }\n         struct PathPat { Path }\n@@ -545,6 +545,7 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             Pat,\n             Eq,\n             initializer: Expr,\n+            Semi,\n         }\n         struct Condition { LetKw, Pat, Eq, Expr }\n         struct Block: AttrsOwner, ModuleItemOwner {"}, {"sha": "b5594e3a982e691011b6e28fdb5927bfe7e555dd", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dde9488559514e7d039cec9407e1f8627f665cd0/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde9488559514e7d039cec9407e1f8627f665cd0/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=dde9488559514e7d039cec9407e1f8627f665cd0", "patch": "@@ -208,6 +208,7 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n                 FieldSrc::Optional(_) | FieldSrc::Shorthand => {\n                     let is_token = token_kinds.contains(&ty.to_string());\n                     if is_token {\n+                        let method_name = format_ident!(\"{}_token\", method_name);\n                         quote! {\n                             pub fn #method_name(&self) -> Option<#ty> {\n                                 support::token(&self.syntax)"}]}