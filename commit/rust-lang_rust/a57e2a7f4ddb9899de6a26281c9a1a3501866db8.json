{"sha": "a57e2a7f4ddb9899de6a26281c9a1a3501866db8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1N2UyYTdmNGRkYjk4OTlkZTZhMjYyODFjOWExYTM1MDE4NjZkYjg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-07-18T22:59:54Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-07-18T22:59:54Z"}, "message": "core: Stabliize core::cmp\n\nMark Eq, PartialEq, Ord, PartialOrd as unstable: they will change\nslightly after trait reform. Equiv as experimental: better solutions\nare desired. min/max stable.", "tree": {"sha": "46a086b6800df28b46d4eb97a661fcda56a29eb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46a086b6800df28b46d4eb97a661fcda56a29eb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a57e2a7f4ddb9899de6a26281c9a1a3501866db8", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a57e2a7f4ddb9899de6a26281c9a1a3501866db8", "html_url": "https://github.com/rust-lang/rust/commit/a57e2a7f4ddb9899de6a26281c9a1a3501866db8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a57e2a7f4ddb9899de6a26281c9a1a3501866db8/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7502b4cd6b10693cec6862f5951b1adf0c7657ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/7502b4cd6b10693cec6862f5951b1adf0c7657ab", "html_url": "https://github.com/rust-lang/rust/commit/7502b4cd6b10693cec6862f5951b1adf0c7657ab"}], "stats": {"total": 31, "additions": 31, "deletions": 0}, "files": [{"sha": "8db59bd370e76bcfd292139bca09518ac09a7336", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a57e2a7f4ddb9899de6a26281c9a1a3501866db8/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a57e2a7f4ddb9899de6a26281c9a1a3501866db8/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=a57e2a7f4ddb9899de6a26281c9a1a3501866db8", "patch": "@@ -37,6 +37,8 @@\n //! assert!(SketchyNum {num: 25} != SketchyNum {num: 57});\n //! ```\n \n+#![stable]\n+\n use option::{Option, Some};\n \n /// Trait for values that can be compared for equality and inequality.\n@@ -53,6 +55,7 @@ use option::{Option, Some};\n /// Eventually, this will be implemented by default for types that implement\n /// `Eq`.\n #[lang=\"eq\"]\n+#[unstable = \"Definition may change slightly after trait reform\"]\n pub trait PartialEq {\n     /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n     fn eq(&self, other: &Self) -> bool;\n@@ -71,6 +74,7 @@ pub trait PartialEq {\n /// - reflexive: `a == a`;\n /// - symmetric: `a == b` implies `b == a`; and\n /// - transitive: `a == b` and `b == c` implies `a == c`.\n+#[unstable = \"Definition may change slightly after trait reform\"]\n pub trait Eq: PartialEq {\n     // FIXME #13101: this method is used solely by #[deriving] to\n     // assert that every component of a type implements #[deriving]\n@@ -86,6 +90,7 @@ pub trait Eq: PartialEq {\n \n /// An ordering is, e.g, a result of a comparison between two values.\n #[deriving(Clone, PartialEq, Show)]\n+#[stable]\n pub enum Ordering {\n    /// An ordering where a compared value is less [than another].\n    Less = -1i,\n@@ -104,6 +109,7 @@ pub enum Ordering {\n ///   true; and\n /// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for\n ///   both `==` and `>`.\n+#[unstable = \"Definition may change slightly after trait reform\"]\n pub trait Ord: Eq + PartialOrd {\n     /// This method returns an ordering between `self` and `other` values.\n     ///\n@@ -118,15 +124,18 @@ pub trait Ord: Eq + PartialOrd {\n     fn cmp(&self, other: &Self) -> Ordering;\n }\n \n+#[unstable = \"Trait is unstable.\"]\n impl Eq for Ordering {}\n \n+#[unstable = \"Trait is unstable.\"]\n impl Ord for Ordering {\n     #[inline]\n     fn cmp(&self, other: &Ordering) -> Ordering {\n         (*self as int).cmp(&(*other as int))\n     }\n }\n \n+#[unstable = \"Trait is unstable.\"]\n impl PartialOrd for Ordering {\n     #[inline]\n     fn partial_cmp(&self, other: &Ordering) -> Option<Ordering> {\n@@ -140,6 +149,7 @@ impl PartialOrd for Ordering {\n /// If the first ordering is different, the first ordering is all that must be returned.\n /// If the first ordering is equal, then second ordering is returned.\n #[inline]\n+#[deprecated = \"Just call .cmp() on an Ordering\"]\n pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering {\n     match o1 {\n         Equal => o2,\n@@ -157,6 +167,7 @@ pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering {\n /// `NaN < 0 == false` and `NaN >= 0 == false` (cf. IEEE 754-2008 section\n /// 5.11).\n #[lang=\"ord\"]\n+#[unstable = \"Definition may change slightly after trait reform\"]\n pub trait PartialOrd: PartialEq {\n     /// This method returns an ordering between `self` and `other` values\n     /// if one exists.\n@@ -202,19 +213,22 @@ pub trait PartialOrd: PartialEq {\n /// of different types. The most common use case for this relation is\n /// container types; e.g. it is often desirable to be able to use `&str`\n /// values to look up entries in a container with `String` keys.\n+#[experimental = \"Better solutions may be discovered.\"]\n pub trait Equiv<T> {\n     /// Implement this function to decide equivalent values.\n     fn equiv(&self, other: &T) -> bool;\n }\n \n /// Compare and return the minimum of two values.\n #[inline]\n+#[stable]\n pub fn min<T: Ord>(v1: T, v2: T) -> T {\n     if v1 < v2 { v1 } else { v2 }\n }\n \n /// Compare and return the maximum of two values.\n #[inline]\n+#[stable]\n pub fn max<T: Ord>(v1: T, v2: T) -> T {\n     if v1 > v2 { v1 } else { v2 }\n }\n@@ -227,6 +241,7 @@ mod impls {\n \n     macro_rules! eq_impl(\n         ($($t:ty)*) => ($(\n+            #[unstable = \"Trait is unstable.\"]\n             impl PartialEq for $t {\n                 #[inline]\n                 fn eq(&self, other: &$t) -> bool { (*self) == (*other) }\n@@ -236,6 +251,7 @@ mod impls {\n         )*)\n     )\n \n+    #[unstable = \"Trait is unstable.\"]\n     impl PartialEq for () {\n         #[inline]\n         fn eq(&self, _other: &()) -> bool { true }\n@@ -247,6 +263,7 @@ mod impls {\n \n     macro_rules! totaleq_impl(\n         ($($t:ty)*) => ($(\n+            #[unstable = \"Trait is unstable.\"]\n             impl Eq for $t {}\n         )*)\n     )\n@@ -255,6 +272,7 @@ mod impls {\n \n     macro_rules! ord_impl(\n         ($($t:ty)*) => ($(\n+            #[unstable = \"Trait is unstable.\"]\n             impl PartialOrd for $t {\n                 #[inline]\n                 fn partial_cmp(&self, other: &$t) -> Option<Ordering> {\n@@ -277,13 +295,15 @@ mod impls {\n         )*)\n     )\n \n+    #[unstable = \"Trait is unstable.\"]\n     impl PartialOrd for () {\n         #[inline]\n         fn partial_cmp(&self, _: &()) -> Option<Ordering> {\n             Some(Equal)\n         }\n     }\n \n+    #[unstable = \"Trait is unstable.\"]\n     impl PartialOrd for bool {\n         #[inline]\n         fn partial_cmp(&self, other: &bool) -> Option<Ordering> {\n@@ -295,6 +315,7 @@ mod impls {\n \n     macro_rules! totalord_impl(\n         ($($t:ty)*) => ($(\n+            #[unstable = \"Trait is unstable.\"]\n             impl Ord for $t {\n                 #[inline]\n                 fn cmp(&self, other: &$t) -> Ordering {\n@@ -306,11 +327,13 @@ mod impls {\n         )*)\n     )\n \n+    #[unstable = \"Trait is unstable.\"]\n     impl Ord for () {\n         #[inline]\n         fn cmp(&self, _other: &()) -> Ordering { Equal }\n     }\n \n+    #[unstable = \"Trait is unstable.\"]\n     impl Ord for bool {\n         #[inline]\n         fn cmp(&self, other: &bool) -> Ordering {\n@@ -321,12 +344,14 @@ mod impls {\n     totalord_impl!(char uint u8 u16 u32 u64 int i8 i16 i32 i64)\n \n     // & pointers\n+    #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: PartialEq> PartialEq for &'a T {\n         #[inline]\n         fn eq(&self, other: & &'a T) -> bool { *(*self) == *(*other) }\n         #[inline]\n         fn ne(&self, other: & &'a T) -> bool { *(*self) != *(*other) }\n     }\n+    #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: PartialOrd> PartialOrd for &'a T {\n         #[inline]\n         fn partial_cmp(&self, other: &&'a T) -> Option<Ordering> {\n@@ -341,19 +366,23 @@ mod impls {\n         #[inline]\n         fn gt(&self, other: & &'a T) -> bool { *(*self) > *(*other) }\n     }\n+    #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: Ord> Ord for &'a T {\n         #[inline]\n         fn cmp(&self, other: & &'a T) -> Ordering { (**self).cmp(*other) }\n     }\n+    #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: Eq> Eq for &'a T {}\n \n     // &mut pointers\n+    #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: PartialEq> PartialEq for &'a mut T {\n         #[inline]\n         fn eq(&self, other: &&'a mut T) -> bool { **self == *(*other) }\n         #[inline]\n         fn ne(&self, other: &&'a mut T) -> bool { **self != *(*other) }\n     }\n+    #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: PartialOrd> PartialOrd for &'a mut T {\n         #[inline]\n         fn partial_cmp(&self, other: &&'a mut T) -> Option<Ordering> {\n@@ -368,9 +397,11 @@ mod impls {\n         #[inline]\n         fn gt(&self, other: &&'a mut T) -> bool { **self > **other }\n     }\n+    #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: Ord> Ord for &'a mut T {\n         #[inline]\n         fn cmp(&self, other: &&'a mut T) -> Ordering { (**self).cmp(*other) }\n     }\n+    #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: Eq> Eq for &'a mut T {}\n }"}]}