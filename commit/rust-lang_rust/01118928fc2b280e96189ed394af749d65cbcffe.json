{"sha": "01118928fc2b280e96189ed394af749d65cbcffe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxMTE4OTI4ZmMyYjI4MGU5NjE4OWVkMzk0YWY3NDlkNjVjYmNmZmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-14T18:38:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-14T18:38:23Z"}, "message": "Auto merge of #30587 - oli-obk:eager_const_eval2, r=nikomatsakis\n\ntypestrong const integers\n\n~~It would be great if someone could run crater on this PR, as this has a high danger of breaking valid code~~ Crater ran. Good to go.\n\n----\n\nSo this PR does a few things:\n\n1. ~~const eval array values when const evaluating an array expression~~\n2. ~~const eval repeat value when const evaluating a repeat expression~~\n3. ~~const eval all struct and tuple fields when evaluating a struct/tuple expression~~\n4. remove the `ConstVal::Int` and `ConstVal::Uint` variants and replace them with a single enum (`ConstInt`) which has variants for all integral types\n  * `usize`/`isize` are also enums with variants for 32 and 64 bit. At creation and various usage steps there are assertions in place checking if the target bitwidth matches with the chosen enum variant\n5. enum discriminants (`ty::Disr`) are now `ConstInt`\n6. trans has its own `Disr` type now (newtype around `u64`)\n\nThis obviously can't be done without breaking changes (the ones that are noticable in stable)\nWe could probably write lints that find those situations and error on it for a cycle or two. But then again, those situations are rare and really bugs imo anyway:\n\n```rust\nlet v10 = 10 as i8;\nlet v4 = 4 as isize;\nassert_eq!(v10 << v4 as usize, 160 as i8);\n ```\n\nstops compiling because 160 is not a valid i8\n\n```rust\nstruct S<T, S> {\n    a: T,\n    b: u8,\n    c: S\n}\nlet s = S { a: 0xff_ff_ff_ffu32, b: 1, c: 0xaa_aa_aa_aa as i32 };\n```\n\nstops compiling because `0xaa_aa_aa_aa` is not a valid i32\n\n----\n\ncc @eddyb @pnkfelix\n\nrelated: https://github.com/rust-lang/rfcs/issues/1071", "tree": {"sha": "adbe12b4955b12035e86ca81a1735766a4b1e3b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/adbe12b4955b12035e86ca81a1735766a4b1e3b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01118928fc2b280e96189ed394af749d65cbcffe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01118928fc2b280e96189ed394af749d65cbcffe", "html_url": "https://github.com/rust-lang/rust/commit/01118928fc2b280e96189ed394af749d65cbcffe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01118928fc2b280e96189ed394af749d65cbcffe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d19f1b629918a556709e6b89a1929305db6449dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/d19f1b629918a556709e6b89a1929305db6449dc", "html_url": "https://github.com/rust-lang/rust/commit/d19f1b629918a556709e6b89a1929305db6449dc"}, {"sha": "f665c399a013ce27991fafb2203a5420e75f9cfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/f665c399a013ce27991fafb2203a5420e75f9cfc", "html_url": "https://github.com/rust-lang/rust/commit/f665c399a013ce27991fafb2203a5420e75f9cfc"}], "stats": {"total": 2864, "additions": 1823, "deletions": 1041}, "files": [{"sha": "1c7f141627bb3aabf392c1d07bb86bd6810d9e66", "filename": "mk/crates.mk", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -53,7 +53,7 @@ TARGET_CRATES := libc std term \\\n                  getopts collections test rand \\\n                  core alloc \\\n                  rustc_unicode rustc_bitflags \\\n-\t\t alloc_system alloc_jemalloc\n+\t\t alloc_system alloc_jemalloc rustc_const_eval\n RUSTC_CRATES := rustc rustc_typeck rustc_mir rustc_borrowck rustc_resolve rustc_driver \\\n                 rustc_trans rustc_back rustc_llvm rustc_privacy rustc_lint \\\n                 rustc_data_structures rustc_front rustc_platform_intrinsics \\\n@@ -91,8 +91,11 @@ DEPS_test := std getopts term native:rust_test_helpers\n DEPS_syntax := std term serialize log arena libc rustc_bitflags rustc_unicode\n DEPS_syntax_ext := syntax fmt_macros\n \n+DEPS_rustc_const_eval := std syntax\n+\n DEPS_rustc := syntax fmt_macros flate arena serialize getopts rbml rustc_front\\\n-              log graphviz rustc_llvm rustc_back rustc_data_structures\n+              log graphviz rustc_llvm rustc_back rustc_data_structures\\\n+\t\t  \t  rustc_const_eval\n DEPS_rustc_back := std syntax rustc_llvm rustc_front flate log libc\n DEPS_rustc_borrowck := rustc rustc_front log graphviz syntax\n DEPS_rustc_data_structures := std log serialize\n@@ -103,16 +106,17 @@ DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_bo\n DEPS_rustc_front := std syntax log serialize\n DEPS_rustc_lint := rustc log syntax\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags\n-DEPS_rustc_metadata := rustc rustc_front syntax rbml\n+DEPS_rustc_metadata := rustc rustc_front syntax rbml rustc_const_eval\n DEPS_rustc_passes := syntax rustc core rustc_front\n-DEPS_rustc_mir := rustc rustc_front syntax\n+DEPS_rustc_mir := rustc rustc_front syntax rustc_const_eval\n DEPS_rustc_resolve := arena rustc rustc_front log syntax\n DEPS_rustc_platform_intrinsics := rustc rustc_llvm\n DEPS_rustc_plugin := rustc rustc_metadata syntax rustc_mir\n DEPS_rustc_privacy := rustc rustc_front log syntax\n DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back rustc_mir \\\n-                    log syntax serialize rustc_llvm rustc_front rustc_platform_intrinsics\n-DEPS_rustc_typeck := rustc syntax rustc_front rustc_platform_intrinsics\n+                    log syntax serialize rustc_llvm rustc_front rustc_platform_intrinsics \\\n+\t\t\t\t\trustc_const_eval\n+DEPS_rustc_typeck := rustc syntax rustc_front rustc_platform_intrinsics rustc_const_eval\n \n DEPS_rustdoc := rustc rustc_driver native:hoedown serialize getopts \\\n                 test rustc_lint rustc_front"}, {"sha": "1f000c2af68b880c8310942607cec66b1f07e34d", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -18,6 +18,7 @@ log = { path = \"../liblog\" }\n rbml = { path = \"../librbml\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n+rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_front = { path = \"../librustc_front\" }\n rustc_llvm = { path = \"../librustc_llvm\" }"}, {"sha": "3988545c201e0ad7fd62e18ba2196e7c47186941", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -55,6 +55,7 @@ extern crate rustc_front;\n extern crate rustc_data_structures;\n extern crate serialize;\n extern crate collections;\n+extern crate rustc_const_eval;\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n #[macro_use] #[no_link] extern crate rustc_bitflags;"}, {"sha": "51985be96db53991242b92376d84703522cfe720", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -476,7 +476,7 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n                     Some(Def::AssociatedConst(did)) |\n                     Some(Def::Const(did)) => match lookup_const_by_id(self.tcx, did,\n                                                                     Some(pat.id), None) {\n-                        Some(const_expr) => {\n+                        Some((const_expr, _const_ty)) => {\n                             const_expr_to_pat(self.tcx, const_expr, pat.span).map(|new_pat| {\n \n                                 if let Some(ref mut renaming_map) = self.renaming_map {"}, {"sha": "d97df585edc053e9c3a56fd859ab3b96108b6066", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 394, "deletions": 554, "changes": 948, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -23,10 +23,9 @@ use middle::subst::Subst;\n use middle::def_id::DefId;\n use middle::pat_util::def_to_path;\n use middle::ty::{self, Ty, TyCtxt};\n+use middle::ty::util::IntTypeExt;\n use middle::astconv_util::ast_ty_to_prim_ty;\n-use util::num::ToPrimitive;\n use util::nodemap::NodeMap;\n-use session::Session;\n \n use graphviz::IntoCow;\n use syntax::ast;\n@@ -37,16 +36,27 @@ use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n use syntax::codemap;\n+use syntax::attr::IntType;\n \n use std::borrow::Cow;\n use std::cmp::Ordering;\n use std::collections::hash_map::Entry::Vacant;\n use std::hash;\n use std::mem::transmute;\n-use std::{i8, i16, i32, i64, u8, u16, u32, u64};\n use std::rc::Rc;\n \n-fn lookup_variant_by_id<'a>(tcx: &'a TyCtxt,\n+use rustc_const_eval::*;\n+\n+macro_rules! math {\n+    ($e:expr, $op:expr) => {\n+        match $op {\n+            Ok(val) => val,\n+            Err(e) => signal!($e, Math(e)),\n+        }\n+    }\n+}\n+\n+fn lookup_variant_by_id<'a>(tcx: &'a ty::TyCtxt,\n                             enum_def: DefId,\n                             variant_def: DefId)\n                             -> Option<&'a Expr> {\n@@ -88,13 +98,13 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n                                         def_id: DefId,\n                                         maybe_ref_id: Option<ast::NodeId>,\n                                         param_substs: Option<&'tcx subst::Substs<'tcx>>)\n-                                        -> Option<&'tcx Expr> {\n+                                        -> Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)> {\n     if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n         match tcx.map.find(node_id) {\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n-                hir::ItemConst(_, ref const_expr) => {\n-                    Some(&const_expr)\n+                hir::ItemConst(ref ty, ref const_expr) => {\n+                    Some((&const_expr, ast_ty_to_prim_ty(tcx, ty)))\n                 }\n                 _ => None\n             },\n@@ -113,8 +123,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n                             if let Some(param_substs) = param_substs {\n                                 substs = substs.subst(tcx, param_substs);\n                             }\n-                            resolve_trait_associated_const(tcx, ti, trait_id,\n-                                                           substs)\n+                            resolve_trait_associated_const(tcx, ti, trait_id, substs)\n                         }\n                         // Technically, without knowing anything about the\n                         // expression that generates the obligation, we could\n@@ -128,25 +137,27 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n                 _ => None\n             },\n             Some(ast_map::NodeImplItem(ii)) => match ii.node {\n-                hir::ImplItemKind::Const(_, ref expr) => {\n-                    Some(&expr)\n+                hir::ImplItemKind::Const(ref ty, ref expr) => {\n+                    Some((&expr, ast_ty_to_prim_ty(tcx, ty)))\n                 }\n                 _ => None\n             },\n             Some(_) => None\n         }\n     } else {\n         match tcx.extern_const_statics.borrow().get(&def_id) {\n-            Some(&ast::DUMMY_NODE_ID) => return None,\n-            Some(&expr_id) => {\n-                return Some(tcx.map.expect_expr(expr_id));\n+            Some(&None) => return None,\n+            Some(&Some((expr_id, ty))) => {\n+                return Some((tcx.map.expect_expr(expr_id), ty));\n             }\n             None => {}\n         }\n         let mut used_ref_id = false;\n-        let expr_id = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n+        let expr_ty = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n             cstore::FoundAst::Found(&InlinedItem::Item(ref item)) => match item.node {\n-                hir::ItemConst(_, ref const_expr) => Some(const_expr.id),\n+                hir::ItemConst(ref ty, ref const_expr) => {\n+                    Some((&**const_expr, ast_ty_to_prim_ty(tcx, ty)))\n+                },\n                 _ => None\n             },\n             cstore::FoundAst::Found(&InlinedItem::TraitItem(trait_id, ref ti)) => match ti.node {\n@@ -163,16 +174,17 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n                             if let Some(param_substs) = param_substs {\n                                 substs = substs.subst(tcx, param_substs);\n                             }\n-                            resolve_trait_associated_const(tcx, ti, trait_id,\n-                                                           substs).map(|e| e.id)\n+                            resolve_trait_associated_const(tcx, ti, trait_id, substs)\n                         }\n                         None => None\n                     }\n                 }\n                 _ => None\n             },\n             cstore::FoundAst::Found(&InlinedItem::ImplItem(_, ref ii)) => match ii.node {\n-                hir::ImplItemKind::Const(_, ref expr) => Some(expr.id),\n+                hir::ImplItemKind::Const(ref ty, ref expr) => {\n+                    Some((&**expr, ast_ty_to_prim_ty(tcx, ty)))\n+                },\n                 _ => None\n             },\n             _ => None\n@@ -182,10 +194,10 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n         // lookup with the same def_id may yield a different result.\n         if !used_ref_id {\n             tcx.extern_const_statics\n-               .borrow_mut().insert(def_id,\n-                                    expr_id.unwrap_or(ast::DUMMY_NODE_ID));\n+               .borrow_mut()\n+               .insert(def_id, expr_ty.map(|(e, t)| (e.id, t)));\n         }\n-        expr_id.map(|id| tcx.map.expect_expr(id))\n+        expr_ty\n     }\n }\n \n@@ -248,8 +260,7 @@ pub fn lookup_const_fn_by_id<'tcx>(tcx: &TyCtxt<'tcx>, def_id: DefId)\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum ConstVal {\n     Float(f64),\n-    Int(i64),\n-    Uint(u64),\n+    Integral(ConstInt),\n     Str(InternedString),\n     ByteStr(Rc<Vec<u8>>),\n     Bool(bool),\n@@ -258,14 +269,18 @@ pub enum ConstVal {\n     Function(DefId),\n     Array(ast::NodeId, u64),\n     Repeat(ast::NodeId, u64),\n+    Char(char),\n+    /// A value that only occurs in case `eval_const_expr` reported an error. You should never\n+    /// handle this case. Its sole purpose is to allow more errors to be reported instead of\n+    /// causing a fatal error.\n+    Dummy,\n }\n \n impl hash::Hash for ConstVal {\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {\n         match *self {\n             Float(a) => unsafe { transmute::<_,u64>(a) }.hash(state),\n-            Int(a) => a.hash(state),\n-            Uint(a) => a.hash(state),\n+            Integral(a) => a.hash(state),\n             Str(ref a) => a.hash(state),\n             ByteStr(ref a) => a.hash(state),\n             Bool(a) => a.hash(state),\n@@ -274,6 +289,8 @@ impl hash::Hash for ConstVal {\n             Function(a) => a.hash(state),\n             Array(a, n) => { a.hash(state); n.hash(state) },\n             Repeat(a, n) => { a.hash(state); n.hash(state) },\n+            Char(c) => c.hash(state),\n+            Dummy => ().hash(state),\n         }\n     }\n }\n@@ -286,8 +303,7 @@ impl PartialEq for ConstVal {\n     fn eq(&self, other: &ConstVal) -> bool {\n         match (self, other) {\n             (&Float(a), &Float(b)) => unsafe{transmute::<_,u64>(a) == transmute::<_,u64>(b)},\n-            (&Int(a), &Int(b)) => a == b,\n-            (&Uint(a), &Uint(b)) => a == b,\n+            (&Integral(a), &Integral(b)) => a == b,\n             (&Str(ref a), &Str(ref b)) => a == b,\n             (&ByteStr(ref a), &ByteStr(ref b)) => a == b,\n             (&Bool(a), &Bool(b)) => a == b,\n@@ -296,6 +312,8 @@ impl PartialEq for ConstVal {\n             (&Function(a), &Function(b)) => a == b,\n             (&Array(a, an), &Array(b, bn)) => (a == b) && (an == bn),\n             (&Repeat(a, an), &Repeat(b, bn)) => (a == b) && (an == bn),\n+            (&Char(a), &Char(b)) => a == b,\n+            (&Dummy, &Dummy) => true, // FIXME: should this be false?\n             _ => false,\n         }\n     }\n@@ -307,9 +325,7 @@ impl ConstVal {\n     pub fn description(&self) -> &'static str {\n         match *self {\n             Float(_) => \"float\",\n-            Int(i) if i < 0 => \"negative integer\",\n-            Int(_) => \"positive integer\",\n-            Uint(_) => \"unsigned integer\",\n+            Integral(i) => i.description(),\n             Str(_) => \"string literal\",\n             ByteStr(_) => \"byte string literal\",\n             Bool(_) => \"boolean\",\n@@ -318,6 +334,8 @@ impl ConstVal {\n             Function(_) => \"function definition\",\n             Array(..) => \"array\",\n             Repeat(..) => \"repeat\",\n+            Char(..) => \"char\",\n+            Dummy => \"dummy value\",\n         }\n     }\n }\n@@ -370,7 +388,7 @@ pub fn const_expr_to_pat(tcx: &TyCtxt, expr: &Expr, span: Span) -> P<hir::Pat> {\n                     PatKind::Path(path.clone()),\n                 Some(Def::Const(def_id)) |\n                 Some(Def::AssociatedConst(def_id)) => {\n-                    let expr = lookup_const_by_id(tcx, def_id, Some(expr.id), None).unwrap();\n+                    let (expr, _ty) = lookup_const_by_id(tcx, def_id, Some(expr.id), None).unwrap();\n                     return const_expr_to_pat(tcx, expr, span);\n                 },\n                 _ => unreachable!(),\n@@ -385,7 +403,12 @@ pub fn const_expr_to_pat(tcx: &TyCtxt, expr: &Expr, span: Span) -> P<hir::Pat> {\n pub fn eval_const_expr(tcx: &TyCtxt, e: &Expr) -> ConstVal {\n     match eval_const_expr_partial(tcx, e, ExprTypeChecked, None) {\n         Ok(r) => r,\n-        Err(s) => tcx.sess.span_fatal(s.span, &s.description())\n+        // non-const path still needs to be a fatal error, because enums are funky\n+        Err(ref s) if s.kind == NonConstPath => tcx.sess.span_fatal(s.span, &s.description()),\n+        Err(s) => {\n+            tcx.sess.span_err(s.span, &s.description());\n+            Dummy\n+        },\n     }\n }\n \n@@ -397,12 +420,11 @@ pub struct ConstEvalErr {\n     pub kind: ErrKind,\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, PartialEq)]\n pub enum ErrKind {\n     CannotCast,\n     CannotCastTo(&'static str),\n     InvalidOpForInts(hir::BinOp_),\n-    InvalidOpForUInts(hir::BinOp_),\n     InvalidOpForBools(hir::BinOp_),\n     InvalidOpForFloats(hir::BinOp_),\n     InvalidOpForIntUint(hir::BinOp_),\n@@ -442,6 +464,18 @@ pub enum ErrKind {\n     MiscCatchAll,\n \n     IndexOpFeatureGated,\n+    Math(ConstMathErr),\n+\n+    IntermediateUnsignedNegative,\n+    /// Expected, Got\n+    TypeMismatch(String, ConstInt),\n+    BadType(ConstVal),\n+}\n+\n+impl From<ConstMathErr> for ErrKind {\n+    fn from(err: ConstMathErr) -> ErrKind {\n+        Math(err)\n+    }\n }\n \n impl ConstEvalErr {\n@@ -451,8 +485,7 @@ impl ConstEvalErr {\n         match self.kind {\n             CannotCast => \"can't cast this type\".into_cow(),\n             CannotCastTo(s) => format!(\"can't cast this type to {}\", s).into_cow(),\n-            InvalidOpForInts(_) =>  \"can't do this op on signed integrals\".into_cow(),\n-            InvalidOpForUInts(_) =>  \"can't do this op on unsigned integrals\".into_cow(),\n+            InvalidOpForInts(_) =>  \"can't do this op on integrals\".into_cow(),\n             InvalidOpForBools(_) =>  \"can't do this op on bools\".into_cow(),\n             InvalidOpForFloats(_) => \"can't do this op on floats\".into_cow(),\n             InvalidOpForIntUint(..) => \"can't do this op on an isize and usize\".into_cow(),\n@@ -492,6 +525,17 @@ impl ConstEvalErr {\n             MiscBinaryOp => \"bad operands for binary\".into_cow(),\n             MiscCatchAll => \"unsupported constant expr\".into_cow(),\n             IndexOpFeatureGated => \"the index operation on const values is unstable\".into_cow(),\n+            Math(ref err) => err.description().into_cow(),\n+\n+            IntermediateUnsignedNegative => \"during the computation of an unsigned a negative \\\n+                                             number was encountered. This is most likely a bug in\\\n+                                             the constant evaluator\".into_cow(),\n+\n+            TypeMismatch(ref expected, ref got) => {\n+                format!(\"mismatched types: expected `{}`, found `{}`\",\n+                        expected, got.description()).into_cow()\n+            },\n+            BadType(ref i) => format!(\"value of wrong type: {:?}\", i).into_cow(),\n         }\n     }\n }\n@@ -536,276 +580,12 @@ impl<'tcx> EvalHint<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum IntTy { I8, I16, I32, I64 }\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum UintTy { U8, U16, U32, U64 }\n-\n-impl IntTy {\n-    pub fn from(tcx: &TyCtxt, t: ast::IntTy) -> IntTy {\n-        let t = if let ast::IntTy::Is = t {\n-            tcx.sess.target.int_type\n-        } else {\n-            t\n-        };\n-        match t {\n-            ast::IntTy::Is => unreachable!(),\n-            ast::IntTy::I8  => IntTy::I8,\n-            ast::IntTy::I16 => IntTy::I16,\n-            ast::IntTy::I32 => IntTy::I32,\n-            ast::IntTy::I64 => IntTy::I64,\n-        }\n-    }\n-}\n-\n-impl UintTy {\n-    pub fn from(tcx: &TyCtxt, t: ast::UintTy) -> UintTy {\n-        let t = if let ast::UintTy::Us = t {\n-            tcx.sess.target.uint_type\n-        } else {\n-            t\n-        };\n-        match t {\n-            ast::UintTy::Us => unreachable!(),\n-            ast::UintTy::U8  => UintTy::U8,\n-            ast::UintTy::U16 => UintTy::U16,\n-            ast::UintTy::U32 => UintTy::U32,\n-            ast::UintTy::U64 => UintTy::U64,\n-        }\n-    }\n-}\n-\n macro_rules! signal {\n     ($e:expr, $exn:expr) => {\n         return Err(ConstEvalErr { span: $e.span, kind: $exn })\n     }\n }\n \n-// The const_{int,uint}_checked_{neg,add,sub,mul,div,shl,shr} family\n-// of functions catch and signal overflow errors during constant\n-// evaluation.\n-//\n-// They all take the operator's arguments (`a` and `b` if binary), the\n-// overall expression (`e`) and, if available, whole expression's\n-// concrete type (`opt_ety`).\n-//\n-// If the whole expression's concrete type is None, then this is a\n-// constant evaluation happening before type check (e.g. in the check\n-// to confirm that a pattern range's left-side is not greater than its\n-// right-side). We do not do arithmetic modulo the type's bitwidth in\n-// such a case; we just do 64-bit arithmetic and assume that later\n-// passes will do it again with the type information, and thus do the\n-// overflow checks then.\n-\n-pub fn const_int_checked_neg<'a>(\n-    a: i64, e: &'a Expr, opt_ety: Option<IntTy>) -> EvalResult {\n-\n-    let (min,max) = match opt_ety {\n-        // (-i8::MIN is itself not an i8, etc, but this is an easy way\n-        // to allow literals to pass the check. Of course that does\n-        // not work for i64::MIN.)\n-        Some(IntTy::I8) =>  (-(i8::MAX as i64), -(i8::MIN as i64)),\n-        Some(IntTy::I16) => (-(i16::MAX as i64), -(i16::MIN as i64)),\n-        Some(IntTy::I32) => (-(i32::MAX as i64), -(i32::MIN as i64)),\n-        None | Some(IntTy::I64) => (-i64::MAX, -(i64::MIN+1)),\n-    };\n-\n-    let oflo = a < min || a > max;\n-    if oflo {\n-        signal!(e, NegateWithOverflow(a));\n-    } else {\n-        Ok(Int(-a))\n-    }\n-}\n-\n-pub fn const_uint_checked_neg<'a>(\n-    a: u64, _e: &'a Expr, _opt_ety: Option<UintTy>) -> EvalResult {\n-    // This always succeeds, and by definition, returns `(!a)+1`.\n-    Ok(Uint((!a).wrapping_add(1)))\n-}\n-\n-fn const_uint_not(a: u64, opt_ety: Option<UintTy>) -> ConstVal {\n-    let mask = match opt_ety {\n-        Some(UintTy::U8) => u8::MAX as u64,\n-        Some(UintTy::U16) => u16::MAX as u64,\n-        Some(UintTy::U32) => u32::MAX as u64,\n-        None | Some(UintTy::U64) => u64::MAX,\n-    };\n-    Uint(!a & mask)\n-}\n-\n-macro_rules! overflow_checking_body {\n-    ($a:ident, $b:ident, $ety:ident, $overflowing_op:ident,\n-     lhs: $to_8_lhs:ident $to_16_lhs:ident $to_32_lhs:ident,\n-     rhs: $to_8_rhs:ident $to_16_rhs:ident $to_32_rhs:ident $to_64_rhs:ident,\n-     $EnumTy:ident $T8: ident $T16: ident $T32: ident $T64: ident,\n-     $result_type: ident) => { {\n-        let (a,b,opt_ety) = ($a,$b,$ety);\n-        match opt_ety {\n-            Some($EnumTy::$T8) => match (a.$to_8_lhs(), b.$to_8_rhs()) {\n-                (Some(a), Some(b)) => {\n-                    let (a, oflo) = a.$overflowing_op(b);\n-                    (a as $result_type, oflo)\n-                }\n-                (None, _) | (_, None) => (0, true)\n-            },\n-            Some($EnumTy::$T16) => match (a.$to_16_lhs(), b.$to_16_rhs()) {\n-                (Some(a), Some(b)) => {\n-                    let (a, oflo) = a.$overflowing_op(b);\n-                    (a as $result_type, oflo)\n-                }\n-                (None, _) | (_, None) => (0, true)\n-            },\n-            Some($EnumTy::$T32) => match (a.$to_32_lhs(), b.$to_32_rhs()) {\n-                (Some(a), Some(b)) => {\n-                    let (a, oflo) = a.$overflowing_op(b);\n-                    (a as $result_type, oflo)\n-                }\n-                (None, _) | (_, None) => (0, true)\n-            },\n-            None | Some($EnumTy::$T64) => match b.$to_64_rhs() {\n-                Some(b) => a.$overflowing_op(b),\n-                None => (0, true),\n-            }\n-        }\n-    } }\n-}\n-\n-macro_rules! int_arith_body {\n-    ($a:ident, $b:ident, $ety:ident, $overflowing_op:ident) => {\n-        overflow_checking_body!(\n-            $a, $b, $ety, $overflowing_op,\n-            lhs: to_i8 to_i16 to_i32,\n-            rhs: to_i8 to_i16 to_i32 to_i64, IntTy I8 I16 I32 I64, i64)\n-    }\n-}\n-\n-macro_rules! uint_arith_body {\n-    ($a:ident, $b:ident, $ety:ident, $overflowing_op:ident) => {\n-        overflow_checking_body!(\n-            $a, $b, $ety, $overflowing_op,\n-            lhs: to_u8 to_u16 to_u32,\n-            rhs: to_u8 to_u16 to_u32 to_u64, UintTy U8 U16 U32 U64, u64)\n-    }\n-}\n-\n-macro_rules! int_shift_body {\n-    ($a:ident, $b:ident, $ety:ident, $overflowing_op:ident) => {\n-        overflow_checking_body!(\n-            $a, $b, $ety, $overflowing_op,\n-            lhs: to_i8 to_i16 to_i32,\n-            rhs: to_u32 to_u32 to_u32 to_u32, IntTy I8 I16 I32 I64, i64)\n-    }\n-}\n-\n-macro_rules! uint_shift_body {\n-    ($a:ident, $b:ident, $ety:ident, $overflowing_op:ident) => {\n-        overflow_checking_body!(\n-            $a, $b, $ety, $overflowing_op,\n-            lhs: to_u8 to_u16 to_u32,\n-            rhs: to_u32 to_u32 to_u32 to_u32, UintTy U8 U16 U32 U64, u64)\n-    }\n-}\n-\n-macro_rules! pub_fn_checked_op {\n-    {$fn_name:ident ($a:ident : $a_ty:ty, $b:ident : $b_ty:ty,.. $WhichTy:ident) {\n-        $ret_oflo_body:ident $overflowing_op:ident\n-            $const_ty:ident $signal_exn:expr\n-    }} => {\n-        pub fn $fn_name<'a>($a: $a_ty,\n-                            $b: $b_ty,\n-                            e: &'a Expr,\n-                            opt_ety: Option<$WhichTy>) -> EvalResult {\n-            let (ret, oflo) = $ret_oflo_body!($a, $b, opt_ety, $overflowing_op);\n-            if !oflo { Ok($const_ty(ret)) } else { signal!(e, $signal_exn) }\n-        }\n-    }\n-}\n-\n-pub_fn_checked_op!{ const_int_checked_add(a: i64, b: i64,.. IntTy) {\n-           int_arith_body overflowing_add Int AddiWithOverflow(a, b)\n-}}\n-\n-pub_fn_checked_op!{ const_int_checked_sub(a: i64, b: i64,.. IntTy) {\n-           int_arith_body overflowing_sub Int SubiWithOverflow(a, b)\n-}}\n-\n-pub_fn_checked_op!{ const_int_checked_mul(a: i64, b: i64,.. IntTy) {\n-           int_arith_body overflowing_mul Int MuliWithOverflow(a, b)\n-}}\n-\n-pub fn const_int_checked_div<'a>(\n-    a: i64, b: i64, e: &'a Expr, opt_ety: Option<IntTy>) -> EvalResult {\n-    if b == 0 { signal!(e, DivideByZero); }\n-    let (ret, oflo) = int_arith_body!(a, b, opt_ety, overflowing_div);\n-    if !oflo { Ok(Int(ret)) } else { signal!(e, DivideWithOverflow) }\n-}\n-\n-pub fn const_int_checked_rem<'a>(\n-    a: i64, b: i64, e: &'a Expr, opt_ety: Option<IntTy>) -> EvalResult {\n-    if b == 0 { signal!(e, ModuloByZero); }\n-    let (ret, oflo) = int_arith_body!(a, b, opt_ety, overflowing_rem);\n-    if !oflo { Ok(Int(ret)) } else { signal!(e, ModuloWithOverflow) }\n-}\n-\n-pub_fn_checked_op!{ const_int_checked_shl(a: i64, b: i64,.. IntTy) {\n-           int_shift_body overflowing_shl Int ShiftLeftWithOverflow\n-}}\n-\n-pub_fn_checked_op!{ const_int_checked_shl_via_uint(a: i64, b: u64,.. IntTy) {\n-           int_shift_body overflowing_shl Int ShiftLeftWithOverflow\n-}}\n-\n-pub_fn_checked_op!{ const_int_checked_shr(a: i64, b: i64,.. IntTy) {\n-           int_shift_body overflowing_shr Int ShiftRightWithOverflow\n-}}\n-\n-pub_fn_checked_op!{ const_int_checked_shr_via_uint(a: i64, b: u64,.. IntTy) {\n-           int_shift_body overflowing_shr Int ShiftRightWithOverflow\n-}}\n-\n-pub_fn_checked_op!{ const_uint_checked_add(a: u64, b: u64,.. UintTy) {\n-           uint_arith_body overflowing_add Uint AdduWithOverflow(a, b)\n-}}\n-\n-pub_fn_checked_op!{ const_uint_checked_sub(a: u64, b: u64,.. UintTy) {\n-           uint_arith_body overflowing_sub Uint SubuWithOverflow(a, b)\n-}}\n-\n-pub_fn_checked_op!{ const_uint_checked_mul(a: u64, b: u64,.. UintTy) {\n-           uint_arith_body overflowing_mul Uint MuluWithOverflow(a, b)\n-}}\n-\n-pub fn const_uint_checked_div<'a>(\n-    a: u64, b: u64, e: &'a Expr, opt_ety: Option<UintTy>) -> EvalResult {\n-    if b == 0 { signal!(e, DivideByZero); }\n-    let (ret, oflo) = uint_arith_body!(a, b, opt_ety, overflowing_div);\n-    if !oflo { Ok(Uint(ret)) } else { signal!(e, DivideWithOverflow) }\n-}\n-\n-pub fn const_uint_checked_rem<'a>(\n-    a: u64, b: u64, e: &'a Expr, opt_ety: Option<UintTy>) -> EvalResult {\n-    if b == 0 { signal!(e, ModuloByZero); }\n-    let (ret, oflo) = uint_arith_body!(a, b, opt_ety, overflowing_rem);\n-    if !oflo { Ok(Uint(ret)) } else { signal!(e, ModuloWithOverflow) }\n-}\n-\n-pub_fn_checked_op!{ const_uint_checked_shl(a: u64, b: u64,.. UintTy) {\n-           uint_shift_body overflowing_shl Uint ShiftLeftWithOverflow\n-}}\n-\n-pub_fn_checked_op!{ const_uint_checked_shl_via_int(a: u64, b: i64,.. UintTy) {\n-           uint_shift_body overflowing_shl Uint ShiftLeftWithOverflow\n-}}\n-\n-pub_fn_checked_op!{ const_uint_checked_shr(a: u64, b: u64,.. UintTy) {\n-           uint_shift_body overflowing_shr Uint ShiftRightWithOverflow\n-}}\n-\n-pub_fn_checked_op!{ const_uint_checked_shr_via_int(a: u64, b: i64,.. UintTy) {\n-           uint_shift_body overflowing_shr Uint ShiftRightWithOverflow\n-}}\n-\n /// Evaluate a constant expression in a context where the expression isn't\n /// guaranteed to be evaluatable. `ty_hint` is usually ExprTypeChecked,\n /// but a few places need to evaluate constants during type-checking, like\n@@ -833,34 +613,57 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n             tcx.expr_ty_opt(e)\n         }\n     };\n-\n-    // If type of expression itself is int or uint, normalize in these\n-    // bindings so that isize/usize is mapped to a type with an\n-    // inherently known bitwidth.\n-    let expr_int_type = ety.and_then(|ty| {\n-        if let ty::TyInt(t) = ty.sty {\n-            Some(IntTy::from(tcx, t)) } else { None }\n-    });\n-    let expr_uint_type = ety.and_then(|ty| {\n-        if let ty::TyUint(t) = ty.sty {\n-            Some(UintTy::from(tcx, t)) } else { None }\n-    });\n-\n     let result = match e.node {\n       hir::ExprUnary(hir::UnNeg, ref inner) => {\n+        // unary neg literals already got their sign during creation\n+        if let hir::ExprLit(ref lit) = inner.node {\n+            use syntax::ast::*;\n+            use syntax::ast::LitIntType::*;\n+            const I8_OVERFLOW: u64 = ::std::i8::MAX as u64 + 1;\n+            const I16_OVERFLOW: u64 = ::std::i16::MAX as u64 + 1;\n+            const I32_OVERFLOW: u64 = ::std::i32::MAX as u64 + 1;\n+            const I64_OVERFLOW: u64 = ::std::i64::MAX as u64 + 1;\n+            match (&lit.node, ety.map(|t| &t.sty)) {\n+                (&LitKind::Int(I8_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I8))) |\n+                (&LitKind::Int(I8_OVERFLOW, Signed(IntTy::I8)), _) => {\n+                    return Ok(Integral(I8(::std::i8::MIN)))\n+                },\n+                (&LitKind::Int(I16_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I16))) |\n+                (&LitKind::Int(I16_OVERFLOW, Signed(IntTy::I16)), _) => {\n+                    return Ok(Integral(I16(::std::i16::MIN)))\n+                },\n+                (&LitKind::Int(I32_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I32))) |\n+                (&LitKind::Int(I32_OVERFLOW, Signed(IntTy::I32)), _) => {\n+                    return Ok(Integral(I32(::std::i32::MIN)))\n+                },\n+                (&LitKind::Int(I64_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I64))) |\n+                (&LitKind::Int(I64_OVERFLOW, Signed(IntTy::I64)), _) => {\n+                    return Ok(Integral(I64(::std::i64::MIN)))\n+                },\n+                (&LitKind::Int(n, Unsuffixed), Some(&ty::TyInt(IntTy::Is))) |\n+                (&LitKind::Int(n, Signed(IntTy::Is)), _) => {\n+                    match tcx.sess.target.int_type {\n+                        IntTy::I32 => if n == I32_OVERFLOW {\n+                            return Ok(Integral(Isize(Is32(::std::i32::MIN))));\n+                        },\n+                        IntTy::I64 => if n == I64_OVERFLOW {\n+                            return Ok(Integral(Isize(Is64(::std::i64::MIN))));\n+                        },\n+                        _ => unreachable!(),\n+                    }\n+                },\n+                _ => {},\n+            }\n+        }\n         match try!(eval_const_expr_partial(tcx, &inner, ty_hint, fn_args)) {\n           Float(f) => Float(-f),\n-          Int(n) =>  try!(const_int_checked_neg(n, e, expr_int_type)),\n-          Uint(i) => {\n-              try!(const_uint_checked_neg(i, e, expr_uint_type))\n-          }\n+          Integral(i) => Integral(math!(e, -i)),\n           const_val => signal!(e, NegateOn(const_val)),\n         }\n       }\n       hir::ExprUnary(hir::UnNot, ref inner) => {\n         match try!(eval_const_expr_partial(tcx, &inner, ty_hint, fn_args)) {\n-          Int(i) => Int(!i),\n-          Uint(i) => const_uint_not(i, expr_uint_type),\n+          Integral(i) => Integral(math!(e, !i)),\n           Bool(b) => Bool(!b),\n           const_val => signal!(e, NotOn(const_val)),\n         }\n@@ -870,6 +673,10 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n             hir::BiShl | hir::BiShr => ty_hint.checked_or(tcx.types.usize),\n             _ => ty_hint\n         };\n+        // technically, if we don't have type hints, but integral eval\n+        // gives us a type through a type-suffix, cast or const def type\n+        // we need to re-eval the other value of the BinOp if it was\n+        // not inferred\n         match (try!(eval_const_expr_partial(tcx, &a, ty_hint, fn_args)),\n                try!(eval_const_expr_partial(tcx, &b, b_ty, fn_args))) {\n           (Float(a), Float(b)) => {\n@@ -888,63 +695,28 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n               _ => signal!(e, InvalidOpForFloats(op.node)),\n             }\n           }\n-          (Int(a), Int(b)) => {\n+          (Integral(a), Integral(b)) => {\n+            use std::cmp::Ordering::*;\n             match op.node {\n-              hir::BiAdd => try!(const_int_checked_add(a,b,e,expr_int_type)),\n-              hir::BiSub => try!(const_int_checked_sub(a,b,e,expr_int_type)),\n-              hir::BiMul => try!(const_int_checked_mul(a,b,e,expr_int_type)),\n-              hir::BiDiv => try!(const_int_checked_div(a,b,e,expr_int_type)),\n-              hir::BiRem => try!(const_int_checked_rem(a,b,e,expr_int_type)),\n-              hir::BiBitAnd => Int(a & b),\n-              hir::BiBitOr => Int(a | b),\n-              hir::BiBitXor => Int(a ^ b),\n-              hir::BiShl => try!(const_int_checked_shl(a,b,e,expr_int_type)),\n-              hir::BiShr => try!(const_int_checked_shr(a,b,e,expr_int_type)),\n-              hir::BiEq => Bool(a == b),\n-              hir::BiLt => Bool(a < b),\n-              hir::BiLe => Bool(a <= b),\n-              hir::BiNe => Bool(a != b),\n-              hir::BiGe => Bool(a >= b),\n-              hir::BiGt => Bool(a > b),\n+              hir::BiAdd => Integral(math!(e, a + b)),\n+              hir::BiSub => Integral(math!(e, a - b)),\n+              hir::BiMul => Integral(math!(e, a * b)),\n+              hir::BiDiv => Integral(math!(e, a / b)),\n+              hir::BiRem => Integral(math!(e, a % b)),\n+              hir::BiBitAnd => Integral(math!(e, a & b)),\n+              hir::BiBitOr => Integral(math!(e, a | b)),\n+              hir::BiBitXor => Integral(math!(e, a ^ b)),\n+              hir::BiShl => Integral(math!(e, a << b)),\n+              hir::BiShr => Integral(math!(e, a >> b)),\n+              hir::BiEq => Bool(math!(e, a.try_cmp(b)) == Equal),\n+              hir::BiLt => Bool(math!(e, a.try_cmp(b)) == Less),\n+              hir::BiLe => Bool(math!(e, a.try_cmp(b)) != Greater),\n+              hir::BiNe => Bool(math!(e, a.try_cmp(b)) != Equal),\n+              hir::BiGe => Bool(math!(e, a.try_cmp(b)) != Less),\n+              hir::BiGt => Bool(math!(e, a.try_cmp(b)) == Greater),\n               _ => signal!(e, InvalidOpForInts(op.node)),\n             }\n           }\n-          (Uint(a), Uint(b)) => {\n-            match op.node {\n-              hir::BiAdd => try!(const_uint_checked_add(a,b,e,expr_uint_type)),\n-              hir::BiSub => try!(const_uint_checked_sub(a,b,e,expr_uint_type)),\n-              hir::BiMul => try!(const_uint_checked_mul(a,b,e,expr_uint_type)),\n-              hir::BiDiv => try!(const_uint_checked_div(a,b,e,expr_uint_type)),\n-              hir::BiRem => try!(const_uint_checked_rem(a,b,e,expr_uint_type)),\n-              hir::BiBitAnd => Uint(a & b),\n-              hir::BiBitOr => Uint(a | b),\n-              hir::BiBitXor => Uint(a ^ b),\n-              hir::BiShl => try!(const_uint_checked_shl(a,b,e,expr_uint_type)),\n-              hir::BiShr => try!(const_uint_checked_shr(a,b,e,expr_uint_type)),\n-              hir::BiEq => Bool(a == b),\n-              hir::BiLt => Bool(a < b),\n-              hir::BiLe => Bool(a <= b),\n-              hir::BiNe => Bool(a != b),\n-              hir::BiGe => Bool(a >= b),\n-              hir::BiGt => Bool(a > b),\n-              _ => signal!(e, InvalidOpForUInts(op.node)),\n-            }\n-          }\n-          // shifts can have any integral type as their rhs\n-          (Int(a), Uint(b)) => {\n-            match op.node {\n-              hir::BiShl => try!(const_int_checked_shl_via_uint(a,b,e,expr_int_type)),\n-              hir::BiShr => try!(const_int_checked_shr_via_uint(a,b,e,expr_int_type)),\n-              _ => signal!(e, InvalidOpForIntUint(op.node)),\n-            }\n-          }\n-          (Uint(a), Int(b)) => {\n-            match op.node {\n-              hir::BiShl => try!(const_uint_checked_shl_via_int(a,b,e,expr_uint_type)),\n-              hir::BiShr => try!(const_uint_checked_shr_via_int(a,b,e,expr_uint_type)),\n-              _ => signal!(e, InvalidOpForUintInt(op.node)),\n-            }\n-          }\n           (Bool(a), Bool(b)) => {\n             Bool(match op.node {\n               hir::BiAnd => a && b,\n@@ -962,7 +734,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n         }\n       }\n       hir::ExprCast(ref base, ref target_ty) => {\n-        let ety = ety.or_else(|| ast_ty_to_prim_ty(tcx, &target_ty))\n+        let ety = ast_ty_to_prim_ty(tcx, &target_ty).or_else(|| ety)\n                 .unwrap_or_else(|| {\n                     tcx.sess.span_fatal(target_ty.span,\n                                         \"target type not found for const cast\")\n@@ -971,16 +743,27 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n         let base_hint = if let ExprTypeChecked = ty_hint {\n             ExprTypeChecked\n         } else {\n-            // FIXME (#23833): the type-hint can cause problems,\n-            // e.g. `(i8::MAX + 1_i8) as u32` feeds in `u32` as result\n-            // type to the sum, and thus no overflow is signaled.\n             match tcx.expr_ty_opt(&base) {\n                 Some(t) => UncheckedExprHint(t),\n                 None => ty_hint\n             }\n         };\n \n-        let val = try!(eval_const_expr_partial(tcx, &base, base_hint, fn_args));\n+        let val = match eval_const_expr_partial(tcx, &base, base_hint, fn_args) {\n+            Ok(val) => val,\n+            Err(ConstEvalErr { kind: TypeMismatch(_, val), .. }) => {\n+                // Something like `5i8 as usize` doesn't need a type hint for the base\n+                // instead take the type hint from the inner value\n+                let hint = match val.int_type() {\n+                    Some(IntType::UnsignedInt(ty)) => ty_hint.checked_or(tcx.mk_mach_uint(ty)),\n+                    Some(IntType::SignedInt(ty)) => ty_hint.checked_or(tcx.mk_mach_int(ty)),\n+                    // we had a type hint, so we can't have an unknown type\n+                    None => unreachable!(),\n+                };\n+                try!(eval_const_expr_partial(tcx, &base, hint, fn_args))\n+            },\n+            Err(e) => return Err(e),\n+        };\n         match cast_const(tcx, val, ety) {\n             Ok(val) => val,\n             Err(kind) => return Err(ConstEvalErr { span: e.span, kind: kind }),\n@@ -997,94 +780,49 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n               if def.depth != 0 {\n                   signal!(e, UnresolvedPath);\n               }\n-              Some(def.full_def())\n+              def.full_def()\n           } else {\n-              None\n+              signal!(e, NonConstPath);\n           };\n-          let (const_expr, const_ty) = match opt_def {\n-              Some(Def::Const(def_id)) => {\n-                  if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n-                      match tcx.map.find(node_id) {\n-                          Some(ast_map::NodeItem(it)) => match it.node {\n-                              hir::ItemConst(ref ty, ref expr) => {\n-                                  (Some(&**expr), Some(&**ty))\n-                              }\n-                              _ => (None, None)\n-                          },\n-                          _ => (None, None)\n-                      }\n+          match opt_def {\n+              Def::Const(def_id) |\n+              Def::AssociatedConst(def_id) => {\n+                  let maybe_ref_id = if let ExprTypeChecked = ty_hint {\n+                      Some(e.id)\n                   } else {\n-                      (lookup_const_by_id(tcx, def_id, Some(e.id), None), None)\n+                      None\n+                  };\n+                  if let Some((e, ty)) = lookup_const_by_id(tcx, def_id, maybe_ref_id, None) {\n+                      let item_hint = match ty {\n+                          Some(ty) => ty_hint.checked_or(ty),\n+                          None => ty_hint,\n+                      };\n+                      try!(eval_const_expr_partial(tcx, e, item_hint, None))\n+                  } else {\n+                      signal!(e, NonConstPath);\n                   }\n-              }\n-              Some(Def::AssociatedConst(def_id)) => {\n-                  if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n-                      match impl_or_trait_container(tcx, def_id) {\n-                          ty::TraitContainer(trait_id) => match tcx.map.find(node_id) {\n-                              Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n-                                  hir::ConstTraitItem(ref ty, _) => {\n-                                      if let ExprTypeChecked = ty_hint {\n-                                          let substs = tcx.node_id_item_substs(e.id).substs;\n-                                          (resolve_trait_associated_const(tcx,\n-                                                                          ti,\n-                                                                          trait_id,\n-                                                                          substs),\n-                                           Some(&**ty))\n-                                       } else {\n-                                           (None, None)\n-                                       }\n-                                  }\n-                                  _ => (None, None)\n-                              },\n-                              _ => (None, None)\n-                          },\n-                          ty::ImplContainer(_) => match tcx.map.find(node_id) {\n-                              Some(ast_map::NodeImplItem(ii)) => match ii.node {\n-                                  hir::ImplItemKind::Const(ref ty, ref expr) => {\n-                                      (Some(&**expr), Some(&**ty))\n-                                  }\n-                                  _ => (None, None)\n-                              },\n-                              _ => (None, None)\n-                          },\n-                      }\n+              },\n+              Def::Variant(enum_def, variant_def) => {\n+                  if let Some(const_expr) = lookup_variant_by_id(tcx, enum_def, variant_def) {\n+                      try!(eval_const_expr_partial(tcx, const_expr, ty_hint, None))\n                   } else {\n-                      (lookup_const_by_id(tcx, def_id, Some(e.id), None), None)\n+                      signal!(e, NonConstPath);\n                   }\n               }\n-              Some(Def::Variant(enum_def, variant_def)) => {\n-                  (lookup_variant_by_id(tcx, enum_def, variant_def), None)\n+              Def::Struct(..) => {\n+                  ConstVal::Struct(e.id)\n               }\n-              Some(Def::Struct(..)) => {\n-                  return Ok(ConstVal::Struct(e.id))\n-              }\n-              Some(Def::Local(_, id)) => {\n+              Def::Local(_, id) => {\n                   debug!(\"Def::Local({:?}): {:?}\", id, fn_args);\n                   if let Some(val) = fn_args.and_then(|args| args.get(&id)) {\n-                      return Ok(val.clone());\n+                      val.clone()\n                   } else {\n-                      (None, None)\n+                      signal!(e, NonConstPath);\n                   }\n               },\n-              Some(Def::Method(id)) | Some(Def::Fn(id)) => return Ok(Function(id)),\n-              _ => (None, None)\n-          };\n-          let const_expr = match const_expr {\n-              Some(actual_e) => actual_e,\n-              None => signal!(e, NonConstPath)\n-          };\n-          let item_hint = if let UncheckedExprNoHint = ty_hint {\n-              match const_ty {\n-                  Some(ty) => match ast_ty_to_prim_ty(tcx, ty) {\n-                      Some(ty) => UncheckedExprHint(ty),\n-                      None => UncheckedExprNoHint\n-                  },\n-                  None => UncheckedExprNoHint\n-              }\n-          } else {\n-              ty_hint\n-          };\n-          try!(eval_const_expr_partial(tcx, const_expr, item_hint, fn_args))\n+              Def::Method(id) | Def::Fn(id) => Function(id),\n+              _ => signal!(e, NonConstPath),\n+          }\n       }\n       hir::ExprCall(ref callee, ref args) => {\n           let sub_ty_hint = ty_hint.erase_hint();\n@@ -1103,10 +841,11 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n \n           let mut call_args = NodeMap();\n           for (arg, arg_expr) in decl.inputs.iter().zip(args.iter()) {\n+              let arg_hint = ty_hint.erase_hint();\n               let arg_val = try!(eval_const_expr_partial(\n                   tcx,\n                   arg_expr,\n-                  sub_ty_hint,\n+                  arg_hint,\n                   fn_args\n               ));\n               debug!(\"const call arg: {:?}\", arg);\n@@ -1116,7 +855,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n           debug!(\"const call({:?})\", call_args);\n           try!(eval_const_expr_partial(tcx, &result, ty_hint, Some(&call_args)))\n       },\n-      hir::ExprLit(ref lit) => lit_to_const(tcx.sess, e.span, &lit, ety),\n+      hir::ExprLit(ref lit) => try!(lit_to_const(&lit.node, tcx, ety, lit.span)),\n       hir::ExprBlock(ref block) => {\n         match block.expr {\n             Some(ref expr) => try!(eval_const_expr_partial(tcx, &expr, ty_hint, fn_args)),\n@@ -1134,14 +873,15 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n         let arr = try!(eval_const_expr_partial(tcx, arr, arr_hint, fn_args));\n         let idx_hint = ty_hint.checked_or(tcx.types.usize);\n         let idx = match try!(eval_const_expr_partial(tcx, idx, idx_hint, fn_args)) {\n-            Int(i) if i >= 0 => i as u64,\n-            Int(_) => signal!(idx, IndexNegative),\n-            Uint(i) => i,\n+            Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n+            Integral(_) => unreachable!(),\n             _ => signal!(idx, IndexNotInt),\n         };\n+        assert_eq!(idx as usize as u64, idx);\n         match arr {\n             Array(_, n) if idx >= n => signal!(e, IndexOutOfBounds),\n-            Array(v, _) => if let hir::ExprVec(ref v) = tcx.map.expect_expr(v).node {\n+            Array(v, n) => if let hir::ExprVec(ref v) = tcx.map.expect_expr(v).node {\n+                assert_eq!(n as usize as u64, n);\n                 try!(eval_const_expr_partial(tcx, &v[idx as usize], ty_hint, fn_args))\n             } else {\n                 unreachable!()\n@@ -1155,13 +895,13 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n                 fn_args,\n             )),\n \n-            ByteStr(ref data) if idx as usize >= data.len()\n-                => signal!(e, IndexOutOfBounds),\n-            ByteStr(data) => Uint(data[idx as usize] as u64),\n+            ByteStr(ref data) if idx >= data.len() as u64 => signal!(e, IndexOutOfBounds),\n+            ByteStr(data) => {\n+                Integral(U8(data[idx as usize]))\n+            },\n \n-            Str(ref s) if idx as usize >= s.len()\n-                => signal!(e, IndexOutOfBounds),\n-            Str(_) => unimplemented!(), // there's no const_char type\n+            Str(ref s) if idx as usize >= s.len() => signal!(e, IndexOutOfBounds),\n+            Str(_) => unimplemented!(), // FIXME: return a const char\n             _ => signal!(e, IndexedNonVec),\n         }\n       }\n@@ -1171,9 +911,8 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n           Repeat(\n               e.id,\n               match try!(eval_const_expr_partial(tcx, &n, len_hint, fn_args)) {\n-                  Int(i) if i >= 0 => i as u64,\n-                  Int(_) => signal!(e, RepeatCountNotNatural),\n-                  Uint(i) => i,\n+                  Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n+                  Integral(_) => signal!(e, RepeatCountNotNatural),\n                   _ => signal!(e, RepeatCountNotInt),\n               },\n           )\n@@ -1184,7 +923,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n         if let Tuple(tup_id) = c {\n             if let hir::ExprTup(ref fields) = tcx.map.expect_expr(tup_id).node {\n                 if index.node < fields.len() {\n-                    return eval_const_expr_partial(tcx, &fields[index.node], base_hint, fn_args)\n+                    try!(eval_const_expr_partial(tcx, &fields[index.node], ty_hint, fn_args))\n                 } else {\n                     signal!(e, TupleIndexOutOfBounds);\n                 }\n@@ -1205,7 +944,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n                 // if the idents are compared run-pass/issue-19244 fails\n                 if let Some(f) = fields.iter().find(|f| f.name.node\n                                                      == field_name.node) {\n-                    return eval_const_expr_partial(tcx, &f.expr, base_hint, fn_args)\n+                    try!(eval_const_expr_partial(tcx, &f.expr, ty_hint, fn_args))\n                 } else {\n                     signal!(e, MissingStructField);\n                 }\n@@ -1219,31 +958,89 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n       _ => signal!(e, MiscCatchAll)\n     };\n \n-    Ok(result)\n+    match (ety.map(|t| &t.sty), result) {\n+        (Some(ref ty_hint), Integral(i)) => Ok(Integral(try!(infer(i, tcx, ty_hint, e.span)))),\n+        (_, result) => Ok(result),\n+    }\n }\n \n-fn impl_or_trait_container(tcx: &TyCtxt, def_id: DefId) -> ty::ImplOrTraitItemContainer {\n-    // This is intended to be equivalent to tcx.impl_or_trait_item(def_id).container()\n-    // for local def_id, but it can be called before tcx.impl_or_trait_items is complete.\n-    if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n-        if let Some(ast_map::NodeItem(item)) = tcx.map.find(tcx.map.get_parent_node(node_id)) {\n-            let container_id = tcx.map.local_def_id(item.id);\n-            match item.node {\n-                hir::ItemImpl(..) => return ty::ImplContainer(container_id),\n-                hir::ItemTrait(..) => return ty::TraitContainer(container_id),\n-                _ => ()\n+fn infer<'tcx>(\n+    i: ConstInt,\n+    tcx: &TyCtxt<'tcx>,\n+    ty_hint: &ty::TypeVariants<'tcx>,\n+    span: Span\n+) -> Result<ConstInt, ConstEvalErr> {\n+    use syntax::ast::*;\n+\n+    let err = |e| ConstEvalErr {\n+        span: span,\n+        kind: e,\n+    };\n+\n+    match (ty_hint, i) {\n+        (&ty::TyInt(IntTy::I8), result @ I8(_)) => Ok(result),\n+        (&ty::TyInt(IntTy::I16), result @ I16(_)) => Ok(result),\n+        (&ty::TyInt(IntTy::I32), result @ I32(_)) => Ok(result),\n+        (&ty::TyInt(IntTy::I64), result @ I64(_)) => Ok(result),\n+        (&ty::TyInt(IntTy::Is), result @ Isize(_)) => Ok(result),\n+\n+        (&ty::TyUint(UintTy::U8), result @ U8(_)) => Ok(result),\n+        (&ty::TyUint(UintTy::U16), result @ U16(_)) => Ok(result),\n+        (&ty::TyUint(UintTy::U32), result @ U32(_)) => Ok(result),\n+        (&ty::TyUint(UintTy::U64), result @ U64(_)) => Ok(result),\n+        (&ty::TyUint(UintTy::Us), result @ Usize(_)) => Ok(result),\n+\n+        (&ty::TyInt(IntTy::I8), Infer(i)) => Ok(I8(i as i64 as i8)),\n+        (&ty::TyInt(IntTy::I16), Infer(i)) => Ok(I16(i as i64 as i16)),\n+        (&ty::TyInt(IntTy::I32), Infer(i)) => Ok(I32(i as i64 as i32)),\n+        (&ty::TyInt(IntTy::I64), Infer(i)) => Ok(I64(i as i64)),\n+        (&ty::TyInt(IntTy::Is), Infer(i)) => {\n+            match ConstIsize::new(i as i64, tcx.sess.target.int_type) {\n+                Ok(val) => Ok(Isize(val)),\n+                Err(_) => Ok(Isize(ConstIsize::Is32(i as i64 as i32))),\n             }\n-        }\n-        panic!(\"No impl or trait container for {:?}\", def_id);\n+        },\n+\n+        (&ty::TyInt(IntTy::I8), InferSigned(i)) => Ok(I8(i as i8)),\n+        (&ty::TyInt(IntTy::I16), InferSigned(i)) => Ok(I16(i as i16)),\n+        (&ty::TyInt(IntTy::I32), InferSigned(i)) => Ok(I32(i as i32)),\n+        (&ty::TyInt(IntTy::I64), InferSigned(i)) => Ok(I64(i)),\n+        (&ty::TyInt(IntTy::Is), InferSigned(i)) => {\n+            match ConstIsize::new(i, tcx.sess.target.int_type) {\n+                Ok(val) => Ok(Isize(val)),\n+                Err(_) => Ok(Isize(ConstIsize::Is32(i as i32))),\n+            }\n+        },\n+\n+        (&ty::TyUint(UintTy::U8), Infer(i)) => Ok(U8(i as u8)),\n+        (&ty::TyUint(UintTy::U16), Infer(i)) => Ok(U16(i as u16)),\n+        (&ty::TyUint(UintTy::U32), Infer(i)) => Ok(U32(i as u32)),\n+        (&ty::TyUint(UintTy::U64), Infer(i)) => Ok(U64(i)),\n+        (&ty::TyUint(UintTy::Us), Infer(i)) => {\n+            match ConstUsize::new(i, tcx.sess.target.uint_type) {\n+                Ok(val) => Ok(Usize(val)),\n+                Err(_) => Ok(Usize(ConstUsize::Us32(i as u32))),\n+            }\n+        },\n+        (&ty::TyUint(_), InferSigned(_)) => Err(err(IntermediateUnsignedNegative)),\n+\n+        (&ty::TyInt(ity), i) => Err(err(TypeMismatch(ity.to_string(), i))),\n+        (&ty::TyUint(ity), i) => Err(err(TypeMismatch(ity.to_string(), i))),\n+\n+        (&ty::TyEnum(ref adt, _), i) => {\n+            let hints = tcx.lookup_repr_hints(adt.did);\n+            let int_ty = tcx.enum_repr_type(hints.iter().next());\n+            infer(i, tcx, &int_ty.to_ty(tcx).sty, span)\n+        },\n+        (_, i) => Err(err(BadType(ConstVal::Integral(i)))),\n     }\n-    panic!(\"{:?} is not local\", def_id);\n }\n \n fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n                                                 ti: &'tcx hir::TraitItem,\n                                                 trait_id: DefId,\n                                                 rcvr_substs: subst::Substs<'tcx>)\n-                                                -> Option<&'tcx Expr>\n+                                                -> Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)>\n {\n     let trait_ref = ty::Binder(\n         rcvr_substs.erase_regions().to_trait_ref(tcx, trait_id)\n@@ -1276,7 +1073,9 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n                      .iter().find(|ic| ic.name == ti.name) {\n                 Some(ic) => lookup_const_by_id(tcx, ic.def_id, None, None),\n                 None => match ti.node {\n-                    hir::ConstTraitItem(_, Some(ref expr)) => Some(&*expr),\n+                    hir::ConstTraitItem(ref ty, Some(ref expr)) => {\n+                        Some((&*expr, ast_ty_to_prim_ty(tcx, ty)))\n+                    },\n                     _ => None,\n                 },\n             }\n@@ -1289,100 +1088,141 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n     }\n }\n \n-fn cast_const<'tcx>(tcx: &TyCtxt<'tcx>, val: ConstVal, ty: Ty) -> CastResult {\n-    macro_rules! convert_val {\n-        ($intermediate_ty:ty, $const_type:ident, $target_ty:ty) => {\n-            match val {\n-                Bool(b) => Ok($const_type(b as u64 as $intermediate_ty as $target_ty)),\n-                Uint(u) => Ok($const_type(u as $intermediate_ty as $target_ty)),\n-                Int(i) => Ok($const_type(i as $intermediate_ty as $target_ty)),\n-                Float(f) => Ok($const_type(f as $intermediate_ty as $target_ty)),\n-                _ => Err(ErrKind::CannotCastTo(stringify!($const_type))),\n+fn cast_const_int<'tcx>(tcx: &TyCtxt<'tcx>, val: ConstInt, ty: ty::Ty) -> CastResult {\n+    let v = val.to_u64_unchecked();\n+    match ty.sty {\n+        ty::TyBool if v == 0 => Ok(Bool(false)),\n+        ty::TyBool if v == 1 => Ok(Bool(true)),\n+        ty::TyInt(ast::IntTy::I8) => Ok(Integral(I8(v as i64 as i8))),\n+        ty::TyInt(ast::IntTy::I16) => Ok(Integral(I16(v as i64 as i16))),\n+        ty::TyInt(ast::IntTy::I32) => Ok(Integral(I32(v as i64 as i32))),\n+        ty::TyInt(ast::IntTy::I64) => Ok(Integral(I64(v as i64))),\n+        ty::TyInt(ast::IntTy::Is) => {\n+            match ConstIsize::new(v as i64, tcx.sess.target.int_type) {\n+                Ok(val) => Ok(Integral(Isize(val))),\n+                Err(_) => Ok(Integral(Isize(ConstIsize::Is32(v as i64 as i32)))),\n             }\n-        }\n+        },\n+        ty::TyUint(ast::UintTy::U8) => Ok(Integral(U8(v as u8))),\n+        ty::TyUint(ast::UintTy::U16) => Ok(Integral(U16(v as u16))),\n+        ty::TyUint(ast::UintTy::U32) => Ok(Integral(U32(v as u32))),\n+        ty::TyUint(ast::UintTy::U64) => Ok(Integral(U64(v))),\n+        ty::TyUint(ast::UintTy::Us) => {\n+            match ConstUsize::new(v, tcx.sess.target.uint_type) {\n+                Ok(val) => Ok(Integral(Usize(val))),\n+                Err(_) => Ok(Integral(Usize(ConstUsize::Us32(v as u32)))),\n+            }\n+        },\n+        ty::TyFloat(ast::FloatTy::F64) if val.is_negative() => {\n+            // FIXME: this could probably be prettier\n+            // there's no easy way to turn an `Infer` into a f64\n+            let val = try!((-val).map_err(Math));\n+            let val = val.to_u64().unwrap() as f64;\n+            let val = -val;\n+            Ok(Float(val))\n+        },\n+        ty::TyFloat(ast::FloatTy::F64) => Ok(Float(val.to_u64().unwrap() as f64)),\n+        ty::TyFloat(ast::FloatTy::F32) if val.is_negative() => {\n+            let val = try!((-val).map_err(Math));\n+            let val = val.to_u64().unwrap() as f32;\n+            let val = -val;\n+            Ok(Float(val as f64))\n+        },\n+        ty::TyFloat(ast::FloatTy::F32) => Ok(Float(val.to_u64().unwrap() as f32 as f64)),\n+        _ => Err(CannotCast),\n     }\n+}\n \n-    // Issue #23890: If isize/usize, then dispatch to appropriate target representation type\n-    match (&ty.sty, tcx.sess.target.int_type, tcx.sess.target.uint_type) {\n-        (&ty::TyInt(ast::IntTy::Is), ast::IntTy::I32, _) => return convert_val!(i32, Int, i64),\n-        (&ty::TyInt(ast::IntTy::Is), ast::IntTy::I64, _) => return convert_val!(i64, Int, i64),\n-        (&ty::TyInt(ast::IntTy::Is), _, _) => panic!(\"unexpected target.int_type\"),\n-\n-        (&ty::TyUint(ast::UintTy::Us), _, ast::UintTy::U32) => return convert_val!(u32, Uint, u64),\n-        (&ty::TyUint(ast::UintTy::Us), _, ast::UintTy::U64) => return convert_val!(u64, Uint, u64),\n-        (&ty::TyUint(ast::UintTy::Us), _, _) => panic!(\"unexpected target.uint_type\"),\n-\n-        _ => {}\n+fn cast_const_float<'tcx>(tcx: &TyCtxt<'tcx>, f: f64, ty: ty::Ty) -> CastResult {\n+    match ty.sty {\n+        ty::TyInt(_) if f >= 0.0 => cast_const_int(tcx, Infer(f as u64), ty),\n+        ty::TyInt(_) => cast_const_int(tcx, InferSigned(f as i64), ty),\n+        ty::TyUint(_) if f >= 0.0 => cast_const_int(tcx, Infer(f as u64), ty),\n+        ty::TyFloat(ast::FloatTy::F64) => Ok(Float(f)),\n+        ty::TyFloat(ast::FloatTy::F32) => Ok(Float(f as f32 as f64)),\n+        _ => Err(CannotCast),\n     }\n+}\n \n-    match ty.sty {\n-        ty::TyInt(ast::IntTy::Is) => unreachable!(),\n-        ty::TyUint(ast::UintTy::Us) => unreachable!(),\n-\n-        ty::TyInt(ast::IntTy::I8) => convert_val!(i8, Int, i64),\n-        ty::TyInt(ast::IntTy::I16) => convert_val!(i16, Int, i64),\n-        ty::TyInt(ast::IntTy::I32) => convert_val!(i32, Int, i64),\n-        ty::TyInt(ast::IntTy::I64) => convert_val!(i64, Int, i64),\n-\n-        ty::TyUint(ast::UintTy::U8) => convert_val!(u8, Uint, u64),\n-        ty::TyUint(ast::UintTy::U16) => convert_val!(u16, Uint, u64),\n-        ty::TyUint(ast::UintTy::U32) => convert_val!(u32, Uint, u64),\n-        ty::TyUint(ast::UintTy::U64) => convert_val!(u64, Uint, u64),\n-\n-        ty::TyFloat(ast::FloatTy::F32) => convert_val!(f32, Float, f64),\n-        ty::TyFloat(ast::FloatTy::F64) => convert_val!(f64, Float, f64),\n-        _ => Err(ErrKind::CannotCast),\n+fn cast_const<'tcx>(tcx: &TyCtxt<'tcx>, val: ConstVal, ty: ty::Ty) -> CastResult {\n+    match val {\n+        Integral(i) => cast_const_int(tcx, i, ty),\n+        Bool(b) => cast_const_int(tcx, Infer(b as u64), ty),\n+        Float(f) => cast_const_float(tcx, f, ty),\n+        Char(c) => cast_const_int(tcx, Infer(c as u64), ty),\n+        _ => Err(CannotCast),\n     }\n }\n \n-fn lit_to_const(sess: &Session, span: Span, lit: &ast::Lit, ty_hint: Option<Ty>) -> ConstVal {\n-    match lit.node {\n-        ast::LitKind::Str(ref s, _) => Str((*s).clone()),\n-        ast::LitKind::ByteStr(ref data) => {\n-            ByteStr(data.clone())\n-        }\n-        ast::LitKind::Byte(n) => Uint(n as u64),\n-        ast::LitKind::Char(n) => Uint(n as u64),\n-        ast::LitKind::Int(n, ast::LitIntType::Signed(_)) => Int(n as i64),\n-        ast::LitKind::Int(n, ast::LitIntType::Unsuffixed) => {\n-            match ty_hint.map(|ty| &ty.sty) {\n-                Some(&ty::TyUint(_)) => Uint(n),\n-                _ => Int(n as i64)\n+fn lit_to_const<'tcx>(lit: &ast::LitKind,\n+                      tcx: &TyCtxt<'tcx>,\n+                      ty_hint: Option<Ty<'tcx>>,\n+                      span: Span,\n+                      ) -> Result<ConstVal, ConstEvalErr> {\n+    use syntax::ast::*;\n+    use syntax::ast::LitIntType::*;\n+    match *lit {\n+        LitKind::Str(ref s, _) => Ok(Str((*s).clone())),\n+        LitKind::ByteStr(ref data) => Ok(ByteStr(data.clone())),\n+        LitKind::Byte(n) => Ok(Integral(U8(n))),\n+        LitKind::Int(n, Signed(ity)) => {\n+            infer(InferSigned(n as i64), tcx, &ty::TyInt(ity), span).map(Integral)\n+        },\n+\n+        LitKind::Int(n, Unsuffixed) => {\n+            match ty_hint.map(|t| &t.sty) {\n+                Some(&ty::TyInt(ity)) => {\n+                    infer(InferSigned(n as i64), tcx, &ty::TyInt(ity), span).map(Integral)\n+                },\n+                Some(&ty::TyUint(uty)) => {\n+                    infer(Infer(n), tcx, &ty::TyUint(uty), span).map(Integral)\n+                },\n+                None => Ok(Integral(Infer(n))),\n+                Some(&ty::TyEnum(ref adt, _)) => {\n+                    let hints = tcx.lookup_repr_hints(adt.did);\n+                    let int_ty = tcx.enum_repr_type(hints.iter().next());\n+                    infer(Infer(n), tcx, &int_ty.to_ty(tcx).sty, span).map(Integral)\n+                },\n+                Some(ty_hint) => panic!(\"bad ty_hint: {:?}, {:?}\", ty_hint, lit),\n             }\n-        }\n-        ast::LitKind::Int(n, ast::LitIntType::Unsigned(_)) => Uint(n),\n-        ast::LitKind::Float(ref n, _) |\n-        ast::LitKind::FloatUnsuffixed(ref n) => {\n+        },\n+        LitKind::Int(n, Unsigned(ity)) => {\n+            infer(Infer(n), tcx, &ty::TyUint(ity), span).map(Integral)\n+        },\n+\n+        LitKind::Float(ref n, _) |\n+        LitKind::FloatUnsuffixed(ref n) => {\n             if let Ok(x) = n.parse::<f64>() {\n-                Float(x)\n+                Ok(Float(x))\n             } else {\n                 // FIXME(#31407) this is only necessary because float parsing is buggy\n-                sess.span_bug(span, \"could not evaluate float literal (see issue #31407)\");\n+                tcx.sess.span_bug(span, \"could not evaluate float literal (see issue #31407)\");\n             }\n         }\n-        ast::LitKind::Bool(b) => Bool(b)\n+        LitKind::Bool(b) => Ok(Bool(b)),\n+        LitKind::Char(c) => Ok(Char(c)),\n     }\n }\n \n pub fn compare_const_vals(a: &ConstVal, b: &ConstVal) -> Option<Ordering> {\n-    Some(match (a, b) {\n-        (&Int(a), &Int(b)) => a.cmp(&b),\n-        (&Uint(a), &Uint(b)) => a.cmp(&b),\n+    match (a, b) {\n+        (&Integral(a), &Integral(b)) => a.try_cmp(b).ok(),\n         (&Float(a), &Float(b)) => {\n             // This is pretty bad but it is the existing behavior.\n-            if a == b {\n+            Some(if a == b {\n                 Ordering::Equal\n             } else if a < b {\n                 Ordering::Less\n             } else {\n                 Ordering::Greater\n-            }\n+            })\n         }\n-        (&Str(ref a), &Str(ref b)) => a.cmp(b),\n-        (&Bool(a), &Bool(b)) => a.cmp(&b),\n-        (&ByteStr(ref a), &ByteStr(ref b)) => a.cmp(b),\n-        _ => return None\n-    })\n+        (&Str(ref a), &Str(ref b)) => Some(a.cmp(b)),\n+        (&Bool(a), &Bool(b)) => Some(a.cmp(&b)),\n+        (&ByteStr(ref a), &ByteStr(ref b)) => Some(a.cmp(b)),\n+        (&Char(a), &Char(ref b)) => Some(a.cmp(b)),\n+        _ => None,\n+    }\n }\n \n pub fn compare_lit_exprs<'tcx>(tcx: &TyCtxt<'tcx>,"}, {"sha": "03c13115aea626fc91fc16747cbe1326594619f0", "filename": "src/librustc/middle/ty/context.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -342,8 +342,12 @@ pub struct TyCtxt<'tcx> {\n     /// FIXME(arielb1): why is this separate from populated_external_types?\n     pub populated_external_primitive_impls: RefCell<DefIdSet>,\n \n-    /// These caches are used by const_eval when decoding external constants.\n-    pub extern_const_statics: RefCell<DefIdMap<NodeId>>,\n+    /// Cache used by const_eval when decoding external constants.\n+    /// Contains `None` when the constant has been fetched but doesn't exist.\n+    /// Constains `Some(expr_id, type)` otherwise.\n+    /// `type` is `None` in case it's not a primitive type\n+    pub extern_const_statics: RefCell<DefIdMap<Option<(NodeId, Option<Ty<'tcx>>)>>>,\n+    /// Cache used by const_eval when decoding extern const fns\n     pub extern_const_fns: RefCell<DefIdMap<NodeId>>,\n \n     pub node_lint_levels: RefCell<FnvHashMap<(NodeId, lint::LintId),"}, {"sha": "2491da7f5f317f9c78c3c871902b2727f0404dfa", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -50,6 +50,8 @@ use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::InternedString;\n \n+use rustc_const_eval::ConstInt;\n+\n use rustc_front::hir;\n use rustc_front::hir::{ItemImpl, ItemTrait, PatKind};\n use rustc_front::intravisit::Visitor;\n@@ -100,8 +102,7 @@ mod ivar;\n mod structural_impls;\n mod sty;\n \n-pub type Disr = u64;\n-pub const INITIAL_DISCRIMINANT_VALUE: Disr = 0;\n+pub type Disr = ConstInt;\n \n // Data types\n \n@@ -1580,7 +1581,7 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n     /// Asserts this is a struct and returns the struct's unique\n     /// variant.\n     pub fn struct_variant(&self) -> &VariantDefData<'tcx, 'container> {\n-        assert!(self.adt_kind() == AdtKind::Struct);\n+        assert_eq!(self.adt_kind(), AdtKind::Struct);\n         &self.variants[0]\n     }\n "}, {"sha": "c91441a3f8a4ba6ab21d25b2cce62a40634ca9ac", "filename": "src/librustc/middle/ty/util.rs", "status": "modified", "additions": 54, "deletions": 117, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -21,7 +21,8 @@ use middle::traits;\n use middle::ty::{self, Ty, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n use middle::ty::{Disr, ParameterEnvironment};\n use middle::ty::TypeVariants::*;\n-use util::num::ToPrimitive;\n+\n+use rustc_const_eval::{ConstInt, ConstIsize, ConstUsize};\n \n use std::cmp;\n use std::hash::{Hash, SipHasher, Hasher};\n@@ -34,11 +35,9 @@ use rustc_front::hir;\n \n pub trait IntTypeExt {\n     fn to_ty<'tcx>(&self, cx: &TyCtxt<'tcx>) -> Ty<'tcx>;\n-    fn i64_to_disr(&self, val: i64) -> Option<Disr>;\n-    fn u64_to_disr(&self, val: u64) -> Option<Disr>;\n     fn disr_incr(&self, val: Disr) -> Option<Disr>;\n-    fn disr_string(&self, val: Disr) -> String;\n-    fn disr_wrap_incr(&self, val: Option<Disr>) -> Disr;\n+    fn assert_ty_matches(&self, val: Disr);\n+    fn initial_discriminant(&self, tcx: &TyCtxt) -> Disr;\n }\n \n impl IntTypeExt for attr::IntType {\n@@ -57,98 +56,48 @@ impl IntTypeExt for attr::IntType {\n         }\n     }\n \n-    fn i64_to_disr(&self, val: i64) -> Option<Disr> {\n+    fn initial_discriminant(&self, tcx: &TyCtxt) -> Disr {\n         match *self {\n-            SignedInt(ast::IntTy::I8)    => val.to_i8()  .map(|v| v as Disr),\n-            SignedInt(ast::IntTy::I16)   => val.to_i16() .map(|v| v as Disr),\n-            SignedInt(ast::IntTy::I32)   => val.to_i32() .map(|v| v as Disr),\n-            SignedInt(ast::IntTy::I64)   => val.to_i64() .map(|v| v as Disr),\n-            UnsignedInt(ast::UintTy::U8)  => val.to_u8()  .map(|v| v as Disr),\n-            UnsignedInt(ast::UintTy::U16) => val.to_u16() .map(|v| v as Disr),\n-            UnsignedInt(ast::UintTy::U32) => val.to_u32() .map(|v| v as Disr),\n-            UnsignedInt(ast::UintTy::U64) => val.to_u64() .map(|v| v as Disr),\n-\n-            UnsignedInt(ast::UintTy::Us) |\n-            SignedInt(ast::IntTy::Is) => unreachable!(),\n+            SignedInt(ast::IntTy::I8)    => ConstInt::I8(0),\n+            SignedInt(ast::IntTy::I16)   => ConstInt::I16(0),\n+            SignedInt(ast::IntTy::I32)   => ConstInt::I32(0),\n+            SignedInt(ast::IntTy::I64)   => ConstInt::I64(0),\n+            SignedInt(ast::IntTy::Is) => match tcx.sess.target.int_type {\n+                ast::IntTy::I32 => ConstInt::Isize(ConstIsize::Is32(0)),\n+                ast::IntTy::I64 => ConstInt::Isize(ConstIsize::Is64(0)),\n+                _ => unreachable!(),\n+            },\n+            UnsignedInt(ast::UintTy::U8)  => ConstInt::U8(0),\n+            UnsignedInt(ast::UintTy::U16) => ConstInt::U16(0),\n+            UnsignedInt(ast::UintTy::U32) => ConstInt::U32(0),\n+            UnsignedInt(ast::UintTy::U64) => ConstInt::U64(0),\n+            UnsignedInt(ast::UintTy::Us) => match tcx.sess.target.uint_type {\n+                ast::UintTy::U32 => ConstInt::Usize(ConstUsize::Us32(0)),\n+                ast::UintTy::U64 => ConstInt::Usize(ConstUsize::Us64(0)),\n+                _ => unreachable!(),\n+            },\n         }\n     }\n \n-    fn u64_to_disr(&self, val: u64) -> Option<Disr> {\n-        match *self {\n-            SignedInt(ast::IntTy::I8)    => val.to_i8()  .map(|v| v as Disr),\n-            SignedInt(ast::IntTy::I16)   => val.to_i16() .map(|v| v as Disr),\n-            SignedInt(ast::IntTy::I32)   => val.to_i32() .map(|v| v as Disr),\n-            SignedInt(ast::IntTy::I64)   => val.to_i64() .map(|v| v as Disr),\n-            UnsignedInt(ast::UintTy::U8)  => val.to_u8()  .map(|v| v as Disr),\n-            UnsignedInt(ast::UintTy::U16) => val.to_u16() .map(|v| v as Disr),\n-            UnsignedInt(ast::UintTy::U32) => val.to_u32() .map(|v| v as Disr),\n-            UnsignedInt(ast::UintTy::U64) => val.to_u64() .map(|v| v as Disr),\n-\n-            UnsignedInt(ast::UintTy::Us) |\n-            SignedInt(ast::IntTy::Is) => unreachable!(),\n+    fn assert_ty_matches(&self, val: Disr) {\n+        match (*self, val) {\n+            (SignedInt(ast::IntTy::I8), ConstInt::I8(_)) => {},\n+            (SignedInt(ast::IntTy::I16), ConstInt::I16(_)) => {},\n+            (SignedInt(ast::IntTy::I32), ConstInt::I32(_)) => {},\n+            (SignedInt(ast::IntTy::I64), ConstInt::I64(_)) => {},\n+            (SignedInt(ast::IntTy::Is), ConstInt::Isize(_)) => {},\n+            (UnsignedInt(ast::UintTy::U8), ConstInt::U8(_)) => {},\n+            (UnsignedInt(ast::UintTy::U16), ConstInt::U16(_)) => {},\n+            (UnsignedInt(ast::UintTy::U32), ConstInt::U32(_)) => {},\n+            (UnsignedInt(ast::UintTy::U64), ConstInt::U64(_)) => {},\n+            (UnsignedInt(ast::UintTy::Us), ConstInt::Usize(_)) => {},\n+            _ => panic!(\"disr type mismatch: {:?} vs {:?}\", self, val),\n         }\n     }\n \n     fn disr_incr(&self, val: Disr) -> Option<Disr> {\n-        macro_rules! add1 {\n-            ($e:expr) => { $e.and_then(|v|v.checked_add(1)).map(|v| v as Disr) }\n-        }\n-        match *self {\n-            // SignedInt repr means we *want* to reinterpret the bits\n-            // treating the highest bit of Disr as a sign-bit, so\n-            // cast to i64 before range-checking.\n-            SignedInt(ast::IntTy::I8)    => add1!((val as i64).to_i8()),\n-            SignedInt(ast::IntTy::I16)   => add1!((val as i64).to_i16()),\n-            SignedInt(ast::IntTy::I32)   => add1!((val as i64).to_i32()),\n-            SignedInt(ast::IntTy::I64)   => add1!(Some(val as i64)),\n-\n-            UnsignedInt(ast::UintTy::U8)  => add1!(val.to_u8()),\n-            UnsignedInt(ast::UintTy::U16) => add1!(val.to_u16()),\n-            UnsignedInt(ast::UintTy::U32) => add1!(val.to_u32()),\n-            UnsignedInt(ast::UintTy::U64) => add1!(Some(val)),\n-\n-            UnsignedInt(ast::UintTy::Us) |\n-            SignedInt(ast::IntTy::Is) => unreachable!(),\n-        }\n-    }\n-\n-    // This returns a String because (1.) it is only used for\n-    // rendering an error message and (2.) a string can represent the\n-    // full range from `i64::MIN` through `u64::MAX`.\n-    fn disr_string(&self, val: Disr) -> String {\n-        match *self {\n-            SignedInt(ast::IntTy::I8)    => format!(\"{}\", val as i8 ),\n-            SignedInt(ast::IntTy::I16)   => format!(\"{}\", val as i16),\n-            SignedInt(ast::IntTy::I32)   => format!(\"{}\", val as i32),\n-            SignedInt(ast::IntTy::I64)   => format!(\"{}\", val as i64),\n-            UnsignedInt(ast::UintTy::U8)  => format!(\"{}\", val as u8 ),\n-            UnsignedInt(ast::UintTy::U16) => format!(\"{}\", val as u16),\n-            UnsignedInt(ast::UintTy::U32) => format!(\"{}\", val as u32),\n-            UnsignedInt(ast::UintTy::U64) => format!(\"{}\", val as u64),\n-\n-            UnsignedInt(ast::UintTy::Us) |\n-            SignedInt(ast::IntTy::Is) => unreachable!(),\n-        }\n-    }\n-\n-    fn disr_wrap_incr(&self, val: Option<Disr>) -> Disr {\n-        macro_rules! add1 {\n-            ($e:expr) => { ($e).wrapping_add(1) as Disr }\n-        }\n-        let val = val.unwrap_or(ty::INITIAL_DISCRIMINANT_VALUE);\n-        match *self {\n-            SignedInt(ast::IntTy::I8)    => add1!(val as i8 ),\n-            SignedInt(ast::IntTy::I16)   => add1!(val as i16),\n-            SignedInt(ast::IntTy::I32)   => add1!(val as i32),\n-            SignedInt(ast::IntTy::I64)   => add1!(val as i64),\n-            UnsignedInt(ast::UintTy::U8)  => add1!(val as u8 ),\n-            UnsignedInt(ast::UintTy::U16) => add1!(val as u16),\n-            UnsignedInt(ast::UintTy::U32) => add1!(val as u32),\n-            UnsignedInt(ast::UintTy::U64) => add1!(val as u64),\n-\n-            UnsignedInt(ast::UintTy::Us) |\n-            SignedInt(ast::IntTy::Is) => unreachable!(),\n-        }\n+        self.assert_ty_matches(val);\n+        (val + ConstInt::Infer(1)).ok()\n     }\n }\n \n@@ -266,32 +215,19 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    /// Returns `(normalized_type, ty)`, where `normalized_type` is the\n-    /// IntType representation of one of {i64,i32,i16,i8,u64,u32,u16,u8},\n-    /// and `ty` is the original type (i.e. may include `isize` or\n-    /// `usize`).\n-    pub fn enum_repr_type(&self, opt_hint: Option<&attr::ReprAttr>)\n-                          -> (attr::IntType, Ty<'tcx>) {\n-        let repr_type = match opt_hint {\n+    /// Returns the IntType representation.\n+    /// This used to ensure `int_ty` doesn't contain `usize` and `isize`\n+    /// by converting them to their actual types. That doesn't happen anymore.\n+    pub fn enum_repr_type(&self, opt_hint: Option<&attr::ReprAttr>) -> attr::IntType {\n+        match opt_hint {\n             // Feed in the given type\n             Some(&attr::ReprInt(_, int_t)) => int_t,\n             // ... but provide sensible default if none provided\n             //\n             // NB. Historically `fn enum_variants` generate i64 here, while\n             // rustc_typeck::check would generate isize.\n             _ => SignedInt(ast::IntTy::Is),\n-        };\n-\n-        let repr_type_ty = repr_type.to_ty(self);\n-        let repr_type = match repr_type {\n-            SignedInt(ast::IntTy::Is) =>\n-                SignedInt(self.sess.target.int_type),\n-            UnsignedInt(ast::UintTy::Us) =>\n-                UnsignedInt(self.sess.target.uint_type),\n-            other => other\n-        };\n-\n-        (repr_type, repr_type_ty)\n+        }\n     }\n \n     /// Returns the deeply last field of nested structures, or the same type,\n@@ -335,15 +271,16 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn eval_repeat_count(&self, count_expr: &hir::Expr) -> usize {\n         let hint = UncheckedExprHint(self.types.usize);\n         match const_eval::eval_const_expr_partial(self, count_expr, hint, None) {\n-            Ok(val) => {\n-                let found = match val {\n-                    ConstVal::Uint(count) => return count as usize,\n-                    ConstVal::Int(count) if count >= 0 => return count as usize,\n-                    const_val => const_val.description(),\n-                };\n+            Ok(ConstVal::Integral(ConstInt::Usize(count))) => {\n+                let val = count.as_u64(self.sess.target.uint_type);\n+                assert_eq!(val as usize as u64, val);\n+                val as usize\n+            },\n+            Ok(const_val) => {\n                 span_err!(self.sess, count_expr.span, E0306,\n-                    \"expected positive integer for repeat count, found {}\",\n-                    found);\n+                          \"expected positive integer for repeat count, found {}\",\n+                          const_val.description());\n+                0\n             }\n             Err(err) => {\n                 let err_msg = match count_expr.node {\n@@ -360,9 +297,9 @@ impl<'tcx> TyCtxt<'tcx> {\n                 };\n                 span_err!(self.sess, count_expr.span, E0307,\n                     \"expected constant integer for repeat count, {}\", err_msg);\n+                0\n             }\n         }\n-        0\n     }\n \n     /// Given a set of predicates that apply to an object type, returns"}, {"sha": "11bb381ec33bb756790480e56ac1b55b5319fbe5", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -10,6 +10,7 @@\n \n use graphviz::IntoCow;\n use middle::const_eval::ConstVal;\n+use rustc_const_eval::{ConstUsize, ConstInt};\n use middle::def_id::DefId;\n use middle::subst::Substs;\n use middle::ty::{self, AdtDef, ClosureSubsts, FnOutput, Region, Ty};\n@@ -851,13 +852,12 @@ pub struct Constant<'tcx> {\n pub struct TypedConstVal<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub span: Span,\n-    pub value: ConstVal\n+    pub value: ConstUsize,\n }\n \n impl<'tcx> Debug for TypedConstVal<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n-        try!(write!(fmt, \"const \"));\n-        fmt_const_val(fmt, &self.value)\n+        write!(fmt, \"const {}\", ConstInt::Usize(self.value))\n     }\n }\n \n@@ -897,8 +897,7 @@ fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ConstVal) -> fmt::Result {\n     use middle::const_eval::ConstVal::*;\n     match *const_val {\n         Float(f) => write!(fmt, \"{:?}\", f),\n-        Int(n) => write!(fmt, \"{:?}\", n),\n-        Uint(n) => write!(fmt, \"{:?}\", n),\n+        Integral(n) => write!(fmt, \"{}\", n),\n         Str(ref s) => write!(fmt, \"{:?}\", s),\n         ByteStr(ref bytes) => {\n             let escaped: String = bytes\n@@ -911,6 +910,8 @@ fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ConstVal) -> fmt::Result {\n         Function(def_id) => write!(fmt, \"{}\", item_path_str(def_id)),\n         Struct(node_id) | Tuple(node_id) | Array(node_id, _) | Repeat(node_id, _) =>\n             write!(fmt, \"{}\", node_to_string(node_id)),\n+        Char(c) => write!(fmt, \"{:?}\", c),\n+        Dummy => unreachable!(),\n     }\n }\n "}, {"sha": "b6b2694a7cbe1c2d3d53f4e8f148930a683794c3", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -14,7 +14,6 @@\n  */\n \n use mir::repr::*;\n-use middle::const_eval::ConstVal;\n use middle::subst::{Subst, Substs};\n use middle::ty::{self, AdtDef, Ty, TyCtxt};\n use rustc_front::hir;\n@@ -144,12 +143,10 @@ impl<'tcx> Mir<'tcx> {\n         match *rvalue {\n             Rvalue::Use(ref operand) => Some(self.operand_ty(tcx, operand)),\n             Rvalue::Repeat(ref operand, ref count) => {\n-                if let ConstVal::Uint(u) = count.value {\n-                    let op_ty = self.operand_ty(tcx, operand);\n-                    Some(tcx.mk_array(op_ty, u as usize))\n-                } else {\n-                    None\n-                }\n+                let op_ty = self.operand_ty(tcx, operand);\n+                let count = count.value.as_u64(tcx.sess.target.uint_type);\n+                assert_eq!(count as usize as u64, count);\n+                Some(tcx.mk_array(op_ty, count as usize))\n             }\n             Rvalue::Ref(reg, bk, ref lv) => {\n                 let lv_ty = self.lvalue_ty(tcx, lv).to_ty(tcx);"}, {"sha": "f885e9a94d522397edc8bb69a9a0ff66462391cf", "filename": "src/librustc_const_eval/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_const_eval%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_const_eval%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2FCargo.toml?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_const_eval\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_const_eval\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+log = { path = \"../liblog\" }\n+serialize = { path = \"../libserialize\" }\n+syntax = { path = \"../libsyntax\" }"}, {"sha": "126b3824efec6940c4cd6c0949765bcbdd822a65", "filename": "src/librustc_const_eval/err.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_const_eval%2Ferr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_const_eval%2Ferr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Ferr.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -0,0 +1,85 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::ast;\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum ConstMathErr {\n+    NotInRange,\n+    CmpBetweenUnequalTypes,\n+    UnequalTypes(Op),\n+    Overflow(Op),\n+    ShiftNegative,\n+    DivisionByZero,\n+    RemainderByZero,\n+    UnsignedNegation,\n+    ULitOutOfRange(ast::UintTy),\n+    LitOutOfRange(ast::IntTy),\n+}\n+pub use self::ConstMathErr::*;\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum Op {\n+    Add,\n+    Sub,\n+    Mul,\n+    Div,\n+    Rem,\n+    Shr,\n+    Shl,\n+    Neg,\n+    BitAnd,\n+    BitOr,\n+    BitXor,\n+}\n+\n+impl ConstMathErr {\n+    pub fn description(&self) -> &'static str {\n+        use self::Op::*;\n+        match *self {\n+            NotInRange => \"inferred value out of range\",\n+            CmpBetweenUnequalTypes => \"compared two integrals of different types\",\n+            UnequalTypes(Add) => \"tried to add two integrals of different types\",\n+            UnequalTypes(Sub) => \"tried to subtract two integrals of different types\",\n+            UnequalTypes(Mul) => \"tried to multiply two integrals of different types\",\n+            UnequalTypes(Div) => \"tried to divide two integrals of different types\",\n+            UnequalTypes(Rem) => {\n+                \"tried to calculate the remainder of two integrals of different types\"\n+            },\n+            UnequalTypes(BitAnd) => \"tried to bitand two integrals of different types\",\n+            UnequalTypes(BitOr) => \"tried to bitor two integrals of different types\",\n+            UnequalTypes(BitXor) => \"tried to xor two integrals of different types\",\n+            UnequalTypes(_) => unreachable!(),\n+            Overflow(Add) => \"attempted to add with overflow\",\n+            Overflow(Sub) => \"attempted to subtract with overflow\",\n+            Overflow(Mul) => \"attempted to multiply with overflow\",\n+            Overflow(Div) => \"attempted to divide with overflow\",\n+            Overflow(Rem) => \"attempted to calculate the remainder with overflow\",\n+            Overflow(Neg) => \"attempted to negate with overflow\",\n+            Overflow(Shr) => \"attempted to shift right with overflow\",\n+            Overflow(Shl) => \"attempted to shift left with overflow\",\n+            Overflow(_) => unreachable!(),\n+            ShiftNegative => \"attempted to shift by a negative amount\",\n+            DivisionByZero => \"attempted to divide by zero\",\n+            RemainderByZero => \"attempted to calculate the remainder with a divisor of zero\",\n+            UnsignedNegation => \"unary negation of unsigned integer\",\n+            ULitOutOfRange(ast::UintTy::U8) => \"literal out of range for u8\",\n+            ULitOutOfRange(ast::UintTy::U16) => \"literal out of range for u16\",\n+            ULitOutOfRange(ast::UintTy::U32) => \"literal out of range for u32\",\n+            ULitOutOfRange(ast::UintTy::U64) => \"literal out of range for u64\",\n+            ULitOutOfRange(ast::UintTy::Us) => \"literal out of range for usize\",\n+            LitOutOfRange(ast::IntTy::I8) => \"literal out of range for i8\",\n+            LitOutOfRange(ast::IntTy::I16) => \"literal out of range for i16\",\n+            LitOutOfRange(ast::IntTy::I32) => \"literal out of range for i32\",\n+            LitOutOfRange(ast::IntTy::I64) => \"literal out of range for i64\",\n+            LitOutOfRange(ast::IntTy::Is) => \"literal out of range for isize\",\n+        }\n+    }\n+}"}, {"sha": "15253987bf2b230b2bd1b7276932b60478a41a4d", "filename": "src/librustc_const_eval/int.rs", "status": "added", "additions": 569, "deletions": 0, "changes": 569, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_const_eval%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_const_eval%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fint.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -0,0 +1,569 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cmp::Ordering;\n+use syntax::attr::IntType;\n+use syntax::ast::{IntTy, UintTy};\n+\n+use super::is::*;\n+use super::us::*;\n+use super::err::*;\n+\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, Hash, Eq, PartialEq)]\n+pub enum ConstInt {\n+    I8(i8),\n+    I16(i16),\n+    I32(i32),\n+    I64(i64),\n+    Isize(ConstIsize),\n+    U8(u8),\n+    U16(u16),\n+    U32(u32),\n+    U64(u64),\n+    Usize(ConstUsize),\n+    Infer(u64),\n+    InferSigned(i64),\n+}\n+pub use self::ConstInt::*;\n+\n+\n+macro_rules! bounds {\n+    ($($t:ident $min:ident $max:ident)*) => {\n+        mod as_u64 {\n+            $(\n+                #[allow(dead_code)]\n+                pub const $min: u64 = ::std::$t::MIN as u64;\n+                #[allow(dead_code)]\n+                pub const $max: u64 = ::std::$t::MAX as u64;\n+            )*\n+        }\n+        mod as_i64 {\n+            $(\n+                #[allow(dead_code)]\n+                pub const $min: i64 = ::std::$t::MIN as i64;\n+                #[allow(dead_code)]\n+                pub const $max: i64 = ::std::$t::MAX as i64;\n+            )*\n+        }\n+    }\n+}\n+\n+bounds!{\n+    i8 I8MIN I8MAX i16 I16MIN I16MAX i32 I32MIN I32MAX i64 I64MIN I64MAX isize IMIN IMAX\n+    u8 U8MIN U8MAX u16 U16MIN U16MAX u32 U32MIN U32MAX u64 U64MIN U64MAX usize UMIN UMAX\n+}\n+\n+impl ConstInt {\n+    /// If either value is `Infer` or `InferSigned`, try to turn the value into the type of\n+    /// the other value. If both values have no type, don't do anything\n+    pub fn infer(self, other: Self) -> Result<(Self, Self), ConstMathErr> {\n+        let inferred = match (self, other) {\n+            (InferSigned(_), InferSigned(_))\n+            | (Infer(_), Infer(_)) => self, // no inference possible\n+            // kindof wrong, you could have had values > I64MAX during computation of a\n+            (Infer(a @ 0...as_u64::I64MAX), InferSigned(_)) => InferSigned(a as i64),\n+            (Infer(_), InferSigned(_)) => return Err(ConstMathErr::NotInRange),\n+            (_, InferSigned(_))\n+            | (_, Infer(_)) => return other.infer(self).map(|(b, a)| (a, b)),\n+\n+            (Infer(a @ 0...as_u64::I8MAX), I8(_)) => I8(a as i64 as i8),\n+            (Infer(a @ 0...as_u64::I16MAX), I16(_)) => I16(a as i64 as i16),\n+            (Infer(a @ 0...as_u64::I32MAX), I32(_)) => I32(a as i64 as i32),\n+            (Infer(a @ 0...as_u64::I64MAX), I64(_)) => I64(a as i64),\n+            (Infer(a @ 0...as_u64::I32MAX), Isize(Is32(_))) => Isize(Is32(a as i64 as i32)),\n+            (Infer(a @ 0...as_u64::I64MAX), Isize(Is64(_))) => Isize(Is64(a as i64)),\n+            (Infer(a @ 0...as_u64::U8MAX), U8(_)) => U8(a as u8),\n+            (Infer(a @ 0...as_u64::U16MAX), U16(_)) => U16(a as u16),\n+            (Infer(a @ 0...as_u64::U32MAX), U32(_)) => U32(a as u32),\n+            (Infer(a), U64(_)) => U64(a),\n+            (Infer(a @ 0...as_u64::U32MAX), Usize(Us32(_))) => Usize(Us32(a as u32)),\n+            (Infer(a), Usize(Us64(_))) => Usize(Us64(a)),\n+\n+            (Infer(_), _) => return Err(ConstMathErr::NotInRange),\n+\n+            (InferSigned(a @ as_i64::I8MIN...as_i64::I8MAX), I8(_)) => I8(a as i8),\n+            (InferSigned(a @ as_i64::I16MIN...as_i64::I16MAX), I16(_)) => I16(a as i16),\n+            (InferSigned(a @ as_i64::I32MIN...as_i64::I32MAX), I32(_)) => I32(a as i32),\n+            (InferSigned(a), I64(_)) => I64(a),\n+            (InferSigned(a @ as_i64::I32MIN...as_i64::I32MAX), Isize(Is32(_))) => {\n+                Isize(Is32(a as i32))\n+            },\n+            (InferSigned(a), Isize(Is64(_))) => Isize(Is64(a)),\n+            (InferSigned(a @ 0...as_i64::U8MAX), U8(_)) => U8(a as u8),\n+            (InferSigned(a @ 0...as_i64::U16MAX), U16(_)) => U16(a as u16),\n+            (InferSigned(a @ 0...as_i64::U32MAX), U32(_)) => U32(a as u32),\n+            (InferSigned(a @ 0...as_i64::I64MAX), U64(_)) => U64(a as u64),\n+            (InferSigned(a @ 0...as_i64::U32MAX), Usize(Us32(_))) => Usize(Us32(a as u32)),\n+            (InferSigned(a @ 0...as_i64::I64MAX), Usize(Us64(_))) => Usize(Us64(a as u64)),\n+            (InferSigned(_), _) => return Err(ConstMathErr::NotInRange),\n+            _ => self, // already known types\n+        };\n+        Ok((inferred, other))\n+    }\n+\n+    /// Turn this value into an `Infer` or an `InferSigned`\n+    pub fn erase_type(self) -> Self {\n+        match self {\n+            Infer(i) => Infer(i),\n+            InferSigned(i) if i < 0 => InferSigned(i),\n+            I8(i) if i < 0 => InferSigned(i as i64),\n+            I16(i) if i < 0 => InferSigned(i as i64),\n+            I32(i) if i < 0 => InferSigned(i as i64),\n+            I64(i) if i < 0 => InferSigned(i as i64),\n+            Isize(Is32(i)) if i < 0 => InferSigned(i as i64),\n+            Isize(Is64(i)) if i < 0 => InferSigned(i as i64),\n+            InferSigned(i) => Infer(i as u64),\n+            I8(i) => Infer(i as u64),\n+            I16(i) => Infer(i as u64),\n+            I32(i) => Infer(i as u64),\n+            I64(i) => Infer(i as u64),\n+            Isize(Is32(i)) => Infer(i as u64),\n+            Isize(Is64(i)) => Infer(i as u64),\n+            U8(i) => Infer(i as u64),\n+            U16(i) => Infer(i as u64),\n+            U32(i) => Infer(i as u64),\n+            U64(i) => Infer(i as u64),\n+            Usize(Us32(i)) => Infer(i as u64),\n+            Usize(Us64(i)) => Infer(i),\n+        }\n+    }\n+\n+    /// Description of the type, not the value\n+    pub fn description(&self) -> &'static str {\n+        match *self {\n+            Infer(_) => \"not yet inferred integral\",\n+            InferSigned(_) => \"not yet inferred signed integral\",\n+            I8(_) => \"i8\",\n+            I16(_) => \"i16\",\n+            I32(_) => \"i32\",\n+            I64(_) => \"i64\",\n+            Isize(_) => \"isize\",\n+            U8(_) => \"u8\",\n+            U16(_) => \"u16\",\n+            U32(_) => \"u32\",\n+            U64(_) => \"u64\",\n+            Usize(_) => \"usize\",\n+        }\n+    }\n+\n+    /// Erases the type and returns a u64.\n+    /// This is not the same as `-5i8 as u64` but as `-5i8 as i64 as u64`\n+    pub fn to_u64_unchecked(self) -> u64 {\n+        match self.erase_type() {\n+            ConstInt::Infer(i) => i,\n+            ConstInt::InferSigned(i) => i as u64,\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    /// Converts the value to a `u32` if it's in the range 0...std::u32::MAX\n+    pub fn to_u32(&self) -> Option<u32> {\n+        match *self {\n+            I8(v) if v >= 0 => Some(v as u32),\n+            I16(v) if v >= 0 => Some(v as u32),\n+            I32(v) if v >= 0 => Some(v as u32),\n+            InferSigned(v)\n+            | Isize(Is64(v))\n+            | I64(v) if v >= 0 && v <= ::std::u32::MAX as i64 => Some(v as u32),\n+            Isize(Is32(v)) if v >= 0 => Some(v as u32),\n+            U8(v) => Some(v as u32),\n+            U16(v) => Some(v as u32),\n+            U32(v) => Some(v),\n+            Infer(v)\n+            | Usize(Us64(v))\n+            | U64(v) if v <= ::std::u32::MAX as u64 => Some(v as u32),\n+            Usize(Us32(v)) => Some(v),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Converts the value to a `u64` if it's >= 0\n+    pub fn to_u64(&self) -> Option<u64> {\n+        match *self {\n+            Infer(v) => Some(v),\n+            InferSigned(v) if v >= 0 => Some(v as u64),\n+            I8(v) if v >= 0 => Some(v as u64),\n+            I16(v) if v >= 0 => Some(v as u64),\n+            I32(v) if v >= 0 => Some(v as u64),\n+            I64(v) if v >= 0 => Some(v as u64),\n+            Isize(Is32(v)) if v >= 0 => Some(v as u64),\n+            Isize(Is64(v)) if v >= 0 => Some(v as u64),\n+            U8(v) => Some(v as u64),\n+            U16(v) => Some(v as u64),\n+            U32(v) => Some(v as u64),\n+            U64(v) => Some(v),\n+            Usize(Us32(v)) => Some(v as u64),\n+            Usize(Us64(v)) => Some(v),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn is_negative(&self) -> bool {\n+        match *self {\n+            I8(v) => v < 0,\n+            I16(v) => v < 0,\n+            I32(v) => v < 0,\n+            I64(v) => v < 0,\n+            Isize(Is32(v)) => v < 0,\n+            Isize(Is64(v)) => v < 0,\n+            InferSigned(v) => v < 0,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Compares the values if they are of the same type\n+    pub fn try_cmp(self, rhs: Self) -> Result<::std::cmp::Ordering, ConstMathErr> {\n+        match try!(self.infer(rhs)) {\n+            (I8(a), I8(b)) => Ok(a.cmp(&b)),\n+            (I16(a), I16(b)) => Ok(a.cmp(&b)),\n+            (I32(a), I32(b)) => Ok(a.cmp(&b)),\n+            (I64(a), I64(b)) => Ok(a.cmp(&b)),\n+            (Isize(Is32(a)), Isize(Is32(b))) => Ok(a.cmp(&b)),\n+            (Isize(Is64(a)), Isize(Is64(b))) => Ok(a.cmp(&b)),\n+            (U8(a), U8(b)) => Ok(a.cmp(&b)),\n+            (U16(a), U16(b)) => Ok(a.cmp(&b)),\n+            (U32(a), U32(b)) => Ok(a.cmp(&b)),\n+            (U64(a), U64(b)) => Ok(a.cmp(&b)),\n+            (Usize(Us32(a)), Usize(Us32(b))) => Ok(a.cmp(&b)),\n+            (Usize(Us64(a)), Usize(Us64(b))) => Ok(a.cmp(&b)),\n+            (Infer(a), Infer(b)) => Ok(a.cmp(&b)),\n+            (InferSigned(a), InferSigned(b)) => Ok(a.cmp(&b)),\n+            _ => Err(CmpBetweenUnequalTypes),\n+        }\n+    }\n+\n+    /// Adds 1 to the value and wraps around if the maximum for the type is reached\n+    pub fn wrap_incr(self) -> Self {\n+        macro_rules! add1 {\n+            ($e:expr) => { ($e).wrapping_add(1) }\n+        }\n+        match self {\n+            ConstInt::I8(i) => ConstInt::I8(add1!(i)),\n+            ConstInt::I16(i) => ConstInt::I16(add1!(i)),\n+            ConstInt::I32(i) => ConstInt::I32(add1!(i)),\n+            ConstInt::I64(i) => ConstInt::I64(add1!(i)),\n+            ConstInt::Isize(ConstIsize::Is32(i)) => ConstInt::Isize(ConstIsize::Is32(add1!(i))),\n+            ConstInt::Isize(ConstIsize::Is64(i)) => ConstInt::Isize(ConstIsize::Is64(add1!(i))),\n+            ConstInt::U8(i) => ConstInt::U8(add1!(i)),\n+            ConstInt::U16(i) => ConstInt::U16(add1!(i)),\n+            ConstInt::U32(i) => ConstInt::U32(add1!(i)),\n+            ConstInt::U64(i) => ConstInt::U64(add1!(i)),\n+            ConstInt::Usize(ConstUsize::Us32(i)) => ConstInt::Usize(ConstUsize::Us32(add1!(i))),\n+            ConstInt::Usize(ConstUsize::Us64(i)) => ConstInt::Usize(ConstUsize::Us64(add1!(i))),\n+            ConstInt::Infer(_) | ConstInt::InferSigned(_) => panic!(\"no type info for const int\"),\n+        }\n+    }\n+\n+    pub fn int_type(self) -> Option<IntType> {\n+        match self {\n+            ConstInt::I8(_) => Some(IntType::SignedInt(IntTy::I8)),\n+            ConstInt::I16(_) => Some(IntType::SignedInt(IntTy::I16)),\n+            ConstInt::I32(_) => Some(IntType::SignedInt(IntTy::I32)),\n+            ConstInt::I64(_) => Some(IntType::SignedInt(IntTy::I64)),\n+            ConstInt::Isize(_) => Some(IntType::SignedInt(IntTy::Is)),\n+            ConstInt::U8(_) => Some(IntType::UnsignedInt(UintTy::U8)),\n+            ConstInt::U16(_) => Some(IntType::UnsignedInt(UintTy::U16)),\n+            ConstInt::U32(_) => Some(IntType::UnsignedInt(UintTy::U32)),\n+            ConstInt::U64(_) => Some(IntType::UnsignedInt(UintTy::U64)),\n+            ConstInt::Usize(_) => Some(IntType::UnsignedInt(UintTy::Us)),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+impl ::std::cmp::PartialOrd for ConstInt {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        self.try_cmp(*other).ok()\n+    }\n+}\n+\n+impl ::std::cmp::Ord for ConstInt {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.try_cmp(*other).unwrap()\n+    }\n+}\n+\n+impl ::std::fmt::Display for ConstInt {\n+    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n+        match *self {\n+            Infer(i) => write!(fmt, \"{}\", i),\n+            InferSigned(i) => write!(fmt, \"{}\", i),\n+            I8(i) => write!(fmt, \"{}i8\", i),\n+            I16(i) => write!(fmt, \"{}i16\", i),\n+            I32(i) => write!(fmt, \"{}i32\", i),\n+            I64(i) => write!(fmt, \"{}i64\", i),\n+            Isize(ConstIsize::Is64(i)) => write!(fmt, \"{}isize\", i),\n+            Isize(ConstIsize::Is32(i)) => write!(fmt, \"{}isize\", i),\n+            U8(i) => write!(fmt, \"{}u8\", i),\n+            U16(i) => write!(fmt, \"{}u16\", i),\n+            U32(i) => write!(fmt, \"{}u32\", i),\n+            U64(i) => write!(fmt, \"{}u64\", i),\n+            Usize(ConstUsize::Us64(i)) => write!(fmt, \"{}usize\", i),\n+            Usize(ConstUsize::Us32(i)) => write!(fmt, \"{}usize\", i),\n+        }\n+    }\n+}\n+\n+macro_rules! overflowing {\n+    ($e:expr, $err:expr) => {{\n+        if $e.1 {\n+            return Err(Overflow($err));\n+        } else {\n+            $e.0\n+        }\n+    }}\n+}\n+\n+macro_rules! impl_binop {\n+    ($op:ident, $func:ident, $checked_func:ident) => {\n+        impl ::std::ops::$op for ConstInt {\n+            type Output = Result<Self, ConstMathErr>;\n+            fn $func(self, rhs: Self) -> Result<Self, ConstMathErr> {\n+                match try!(self.infer(rhs)) {\n+                    (I8(a), I8(b)) => a.$checked_func(b).map(I8),\n+                    (I16(a), I16(b)) => a.$checked_func(b).map(I16),\n+                    (I32(a), I32(b)) => a.$checked_func(b).map(I32),\n+                    (I64(a), I64(b)) => a.$checked_func(b).map(I64),\n+                    (Isize(Is32(a)), Isize(Is32(b))) => a.$checked_func(b).map(Is32).map(Isize),\n+                    (Isize(Is64(a)), Isize(Is64(b))) => a.$checked_func(b).map(Is64).map(Isize),\n+                    (U8(a), U8(b)) => a.$checked_func(b).map(U8),\n+                    (U16(a), U16(b)) => a.$checked_func(b).map(U16),\n+                    (U32(a), U32(b)) => a.$checked_func(b).map(U32),\n+                    (U64(a), U64(b)) => a.$checked_func(b).map(U64),\n+                    (Usize(Us32(a)), Usize(Us32(b))) => a.$checked_func(b).map(Us32).map(Usize),\n+                    (Usize(Us64(a)), Usize(Us64(b))) => a.$checked_func(b).map(Us64).map(Usize),\n+                    (Infer(a), Infer(b)) => a.$checked_func(b).map(Infer),\n+                    (InferSigned(a), InferSigned(b)) => a.$checked_func(b).map(InferSigned),\n+                    _ => return Err(UnequalTypes(Op::$op)),\n+                }.ok_or(Overflow(Op::$op))\n+            }\n+        }\n+    }\n+}\n+\n+macro_rules! derive_binop {\n+    ($op:ident, $func:ident) => {\n+        impl ::std::ops::$op for ConstInt {\n+            type Output = Result<Self, ConstMathErr>;\n+            fn $func(self, rhs: Self) -> Result<Self, ConstMathErr> {\n+                match try!(self.infer(rhs)) {\n+                    (I8(a), I8(b)) => Ok(I8(a.$func(b))),\n+                    (I16(a), I16(b)) => Ok(I16(a.$func(b))),\n+                    (I32(a), I32(b)) => Ok(I32(a.$func(b))),\n+                    (I64(a), I64(b)) => Ok(I64(a.$func(b))),\n+                    (Isize(Is32(a)), Isize(Is32(b))) => Ok(Isize(Is32(a.$func(b)))),\n+                    (Isize(Is64(a)), Isize(Is64(b))) => Ok(Isize(Is64(a.$func(b)))),\n+                    (U8(a), U8(b)) => Ok(U8(a.$func(b))),\n+                    (U16(a), U16(b)) => Ok(U16(a.$func(b))),\n+                    (U32(a), U32(b)) => Ok(U32(a.$func(b))),\n+                    (U64(a), U64(b)) => Ok(U64(a.$func(b))),\n+                    (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a.$func(b)))),\n+                    (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a.$func(b)))),\n+                    (Infer(a), Infer(b)) => Ok(Infer(a.$func(b))),\n+                    (InferSigned(a), InferSigned(b)) => Ok(InferSigned(a.$func(b))),\n+                    _ => Err(UnequalTypes(Op::$op)),\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl_binop!(Add, add, checked_add);\n+impl_binop!(Sub, sub, checked_sub);\n+impl_binop!(Mul, mul, checked_mul);\n+derive_binop!(BitAnd, bitand);\n+derive_binop!(BitOr, bitor);\n+derive_binop!(BitXor, bitxor);\n+\n+fn check_division(\n+    lhs: ConstInt,\n+    rhs: ConstInt,\n+    op: Op,\n+    zerr: ConstMathErr,\n+) -> Result<(), ConstMathErr> {\n+    match (lhs, rhs) {\n+        (I8(_), I8(0)) => Err(zerr),\n+        (I16(_), I16(0)) => Err(zerr),\n+        (I32(_), I32(0)) => Err(zerr),\n+        (I64(_), I64(0)) => Err(zerr),\n+        (Isize(_), Isize(Is32(0))) => Err(zerr),\n+        (Isize(_), Isize(Is64(0))) => Err(zerr),\n+        (InferSigned(_), InferSigned(0)) => Err(zerr),\n+\n+        (U8(_), U8(0)) => Err(zerr),\n+        (U16(_), U16(0)) => Err(zerr),\n+        (U32(_), U32(0)) => Err(zerr),\n+        (U64(_), U64(0)) => Err(zerr),\n+        (Usize(_), Usize(Us32(0))) => Err(zerr),\n+        (Usize(_), Usize(Us64(0))) => Err(zerr),\n+        (Infer(_), Infer(0)) => Err(zerr),\n+\n+        (I8(::std::i8::MIN), I8(-1)) => Err(Overflow(op)),\n+        (I16(::std::i16::MIN), I16(-1)) => Err(Overflow(op)),\n+        (I32(::std::i32::MIN), I32(-1)) => Err(Overflow(op)),\n+        (I64(::std::i64::MIN), I64(-1)) => Err(Overflow(op)),\n+        (Isize(Is32(::std::i32::MIN)), Isize(Is32(-1))) => Err(Overflow(op)),\n+        (Isize(Is64(::std::i64::MIN)), Isize(Is64(-1))) => Err(Overflow(op)),\n+        (InferSigned(::std::i64::MIN), InferSigned(-1)) => Err(Overflow(op)),\n+\n+        _ => Ok(()),\n+    }\n+}\n+\n+impl ::std::ops::Div for ConstInt {\n+    type Output = Result<Self, ConstMathErr>;\n+    fn div(self, rhs: Self) -> Result<Self, ConstMathErr> {\n+        let (lhs, rhs) = try!(self.infer(rhs));\n+        try!(check_division(lhs, rhs, Op::Div, DivisionByZero));\n+        match (lhs, rhs) {\n+            (I8(a), I8(b)) => Ok(I8(a/b)),\n+            (I16(a), I16(b)) => Ok(I16(a/b)),\n+            (I32(a), I32(b)) => Ok(I32(a/b)),\n+            (I64(a), I64(b)) => Ok(I64(a/b)),\n+            (Isize(Is32(a)), Isize(Is32(b))) => Ok(Isize(Is32(a/b))),\n+            (Isize(Is64(a)), Isize(Is64(b))) => Ok(Isize(Is64(a/b))),\n+            (InferSigned(a), InferSigned(b)) => Ok(InferSigned(a/b)),\n+\n+            (U8(a), U8(b)) => Ok(U8(a/b)),\n+            (U16(a), U16(b)) => Ok(U16(a/b)),\n+            (U32(a), U32(b)) => Ok(U32(a/b)),\n+            (U64(a), U64(b)) => Ok(U64(a/b)),\n+            (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a/b))),\n+            (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a/b))),\n+            (Infer(a), Infer(b)) => Ok(Infer(a/b)),\n+\n+            _ => Err(UnequalTypes(Op::Div)),\n+        }\n+    }\n+}\n+\n+impl ::std::ops::Rem for ConstInt {\n+    type Output = Result<Self, ConstMathErr>;\n+    fn rem(self, rhs: Self) -> Result<Self, ConstMathErr> {\n+        let (lhs, rhs) = try!(self.infer(rhs));\n+        // should INT_MIN%-1 be zero or an error?\n+        try!(check_division(lhs, rhs, Op::Rem, RemainderByZero));\n+        match (lhs, rhs) {\n+            (I8(a), I8(b)) => Ok(I8(a%b)),\n+            (I16(a), I16(b)) => Ok(I16(a%b)),\n+            (I32(a), I32(b)) => Ok(I32(a%b)),\n+            (I64(a), I64(b)) => Ok(I64(a%b)),\n+            (Isize(Is32(a)), Isize(Is32(b))) => Ok(Isize(Is32(a%b))),\n+            (Isize(Is64(a)), Isize(Is64(b))) => Ok(Isize(Is64(a%b))),\n+            (InferSigned(a), InferSigned(b)) => Ok(InferSigned(a%b)),\n+\n+            (U8(a), U8(b)) => Ok(U8(a%b)),\n+            (U16(a), U16(b)) => Ok(U16(a%b)),\n+            (U32(a), U32(b)) => Ok(U32(a%b)),\n+            (U64(a), U64(b)) => Ok(U64(a%b)),\n+            (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a%b))),\n+            (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a%b))),\n+            (Infer(a), Infer(b)) => Ok(Infer(a%b)),\n+\n+            _ => Err(UnequalTypes(Op::Rem)),\n+        }\n+    }\n+}\n+\n+impl ::std::ops::Shl<ConstInt> for ConstInt {\n+    type Output = Result<Self, ConstMathErr>;\n+    fn shl(self, rhs: Self) -> Result<Self, ConstMathErr> {\n+        let b = try!(rhs.to_u32().ok_or(ShiftNegative));\n+        match self {\n+            I8(a) => Ok(I8(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+            I16(a) => Ok(I16(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+            I32(a) => Ok(I32(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+            I64(a) => Ok(I64(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+            Isize(Is32(a)) => Ok(Isize(Is32(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n+            Isize(Is64(a)) => Ok(Isize(Is64(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n+            U8(a) => Ok(U8(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+            U16(a) => Ok(U16(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+            U32(a) => Ok(U32(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+            U64(a) => Ok(U64(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+            Usize(Us32(a)) => Ok(Usize(Us32(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n+            Usize(Us64(a)) => Ok(Usize(Us64(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n+            Infer(a) => Ok(Infer(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+            InferSigned(a) => Ok(InferSigned(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+        }\n+    }\n+}\n+\n+impl ::std::ops::Shr<ConstInt> for ConstInt {\n+    type Output = Result<Self, ConstMathErr>;\n+    fn shr(self, rhs: Self) -> Result<Self, ConstMathErr> {\n+        let b = try!(rhs.to_u32().ok_or(ShiftNegative));\n+        match self {\n+            I8(a) => Ok(I8(overflowing!(a.overflowing_shr(b), Op::Shr))),\n+            I16(a) => Ok(I16(overflowing!(a.overflowing_shr(b), Op::Shr))),\n+            I32(a) => Ok(I32(overflowing!(a.overflowing_shr(b), Op::Shr))),\n+            I64(a) => Ok(I64(overflowing!(a.overflowing_shr(b), Op::Shl))),\n+            Isize(Is32(a)) => Ok(Isize(Is32(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n+            Isize(Is64(a)) => Ok(Isize(Is64(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n+            U8(a) => Ok(U8(overflowing!(a.overflowing_shr(b), Op::Shr))),\n+            U16(a) => Ok(U16(overflowing!(a.overflowing_shr(b), Op::Shr))),\n+            U32(a) => Ok(U32(overflowing!(a.overflowing_shr(b), Op::Shr))),\n+            U64(a) => Ok(U64(overflowing!(a.overflowing_shr(b), Op::Shr))),\n+            Usize(Us32(a)) => Ok(Usize(Us32(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n+            Usize(Us64(a)) => Ok(Usize(Us64(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n+            Infer(a) => Ok(Infer(overflowing!(a.overflowing_shr(b), Op::Shr))),\n+            InferSigned(a) => Ok(InferSigned(overflowing!(a.overflowing_shr(b), Op::Shr))),\n+        }\n+    }\n+}\n+\n+impl ::std::ops::Neg for ConstInt {\n+    type Output = Result<Self, ConstMathErr>;\n+    fn neg(self) -> Result<Self, ConstMathErr> {\n+        match self {\n+            I8(a) => Ok(I8(overflowing!(a.overflowing_neg(), Op::Neg))),\n+            I16(a) => Ok(I16(overflowing!(a.overflowing_neg(), Op::Neg))),\n+            I32(a) => Ok(I32(overflowing!(a.overflowing_neg(), Op::Neg))),\n+            I64(a) => Ok(I64(overflowing!(a.overflowing_neg(), Op::Neg))),\n+            Isize(Is32(a)) => Ok(Isize(Is32(overflowing!(a.overflowing_neg(), Op::Neg)))),\n+            Isize(Is64(a)) => Ok(Isize(Is64(overflowing!(a.overflowing_neg(), Op::Neg)))),\n+            U8(0) => Ok(U8(0)),\n+            U16(0) => Ok(U16(0)),\n+            U32(0) => Ok(U32(0)),\n+            U64(0) => Ok(U64(0)),\n+            Usize(Us32(0)) => Ok(Usize(Us32(0))),\n+            Usize(Us64(0)) => Ok(Usize(Us64(0))),\n+            U8(_) => Err(UnsignedNegation),\n+            U16(_) => Err(UnsignedNegation),\n+            U32(_) => Err(UnsignedNegation),\n+            U64(_) => Err(UnsignedNegation),\n+            Usize(_) => Err(UnsignedNegation),\n+            Infer(a @ 0...as_u64::I64MAX) => Ok(InferSigned(-(a as i64))),\n+            Infer(_) => Err(Overflow(Op::Neg)),\n+            InferSigned(a) => Ok(InferSigned(overflowing!(a.overflowing_neg(), Op::Neg))),\n+        }\n+    }\n+}\n+\n+impl ::std::ops::Not for ConstInt {\n+    type Output = Result<Self, ConstMathErr>;\n+    fn not(self) -> Result<Self, ConstMathErr> {\n+        match self {\n+            I8(a) => Ok(I8(!a)),\n+            I16(a) => Ok(I16(!a)),\n+            I32(a) => Ok(I32(!a)),\n+            I64(a) => Ok(I64(!a)),\n+            Isize(Is32(a)) => Ok(Isize(Is32(!a))),\n+            Isize(Is64(a)) => Ok(Isize(Is64(!a))),\n+            U8(a) => Ok(U8(!a)),\n+            U16(a) => Ok(U16(!a)),\n+            U32(a) => Ok(U32(!a)),\n+            U64(a) => Ok(U64(!a)),\n+            Usize(Us32(a)) => Ok(Usize(Us32(!a))),\n+            Usize(Us64(a)) => Ok(Usize(Us64(!a))),\n+            Infer(a) => Ok(Infer(!a)),\n+            InferSigned(a) => Ok(InferSigned(!a)),\n+        }\n+    }\n+}"}, {"sha": "082c6510f8bc961308387571b40c2e2c71ffc5ce", "filename": "src/librustc_const_eval/is.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_const_eval%2Fis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_const_eval%2Fis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fis.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::ast;\n+use super::err::*;\n+\n+/// Depending on the target only one variant is ever used in a compilation.\n+/// Anything else is an error. This invariant is checked at several locations\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, Hash, Eq, PartialEq)]\n+pub enum ConstIsize {\n+    Is32(i32),\n+    Is64(i64),\n+}\n+pub use self::ConstIsize::*;\n+\n+impl ConstIsize {\n+    pub fn as_i64(self, target_int_ty: ast::IntTy) -> i64 {\n+        match (self, target_int_ty) {\n+            (Is32(i), ast::IntTy::I32) => i as i64,\n+            (Is64(i), ast::IntTy::I64) => i,\n+            _ => panic!(\"got invalid isize size for target\"),\n+        }\n+    }\n+    pub fn new(i: i64, target_int_ty: ast::IntTy) -> Result<Self, ConstMathErr> {\n+        match target_int_ty {\n+            ast::IntTy::I32 if i as i32 as i64 == i => Ok(Is32(i as i32)),\n+            ast::IntTy::I32 => Err(LitOutOfRange(ast::IntTy::Is)),\n+            ast::IntTy::I64 => Ok(Is64(i)),\n+            _ => unreachable!(),\n+        }\n+    }\n+}"}, {"sha": "e4c702f643b201f9c694ef7c5d7bd26c91db453e", "filename": "src/librustc_const_eval/lib.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Rusty Mathematics\n+//!\n+//! # Note\n+//!\n+//! This API is completely unstable and subject to change.\n+\n+#![crate_name = \"rustc_const_eval\"]\n+#![unstable(feature = \"rustc_private\", issue = \"27812\")]\n+#![crate_type = \"dylib\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+      html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+\n+\n+#![feature(rustc_private)]\n+#![feature(staged_api)]\n+\n+#[macro_use] extern crate log;\n+#[macro_use] extern crate syntax;\n+\n+extern crate serialize as rustc_serialize; // used by deriving\n+\n+mod int;\n+mod us;\n+mod is;\n+mod err;\n+\n+pub use int::*;\n+pub use us::*;\n+pub use is::*;\n+pub use err::ConstMathErr;"}, {"sha": "e5a7086d43663c1ba93b889c5891ee0b8228bac1", "filename": "src/librustc_const_eval/us.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_const_eval%2Fus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_const_eval%2Fus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fus.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::ast;\n+use super::err::*;\n+\n+/// Depending on the target only one variant is ever used in a compilation.\n+/// Anything else is an error. This invariant is checked at several locations\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, Hash, Eq, PartialEq)]\n+pub enum ConstUsize {\n+    Us32(u32),\n+    Us64(u64),\n+}\n+pub use self::ConstUsize::*;\n+\n+impl ConstUsize {\n+    pub fn as_u64(self, target_uint_ty: ast::UintTy) -> u64 {\n+        match (self, target_uint_ty) {\n+            (Us32(i), ast::UintTy::U32) => i as u64,\n+            (Us64(i), ast::UintTy::U64) => i,\n+            _ => panic!(\"got invalid usize size for target\"),\n+        }\n+    }\n+    pub fn new(i: u64, target_uint_ty: ast::UintTy) -> Result<Self, ConstMathErr> {\n+        match target_uint_ty {\n+            ast::UintTy::U32 if i as u32 as u64 == i => Ok(Us32(i as u32)),\n+            ast::UintTy::U32 => Err(ULitOutOfRange(ast::UintTy::Us)),\n+            ast::UintTy::U64 => Ok(Us64(i)),\n+            _ => unreachable!(),\n+        }\n+    }\n+}"}, {"sha": "4d844bbf032b6f2d23b8fde149cad38dbcda9cc1", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -143,8 +143,11 @@ impl LateLintPass for TypeLimits {\n                             else { false }\n                         } else {\n                             match eval_const_expr_partial(cx.tcx, &r, ExprTypeChecked, None) {\n-                                Ok(ConstVal::Int(shift)) => { shift as u64 >= bits },\n-                                Ok(ConstVal::Uint(shift)) => { shift >= bits },\n+                                Ok(ConstVal::Integral(i)) => {\n+                                    i.is_negative() || i.to_u64()\n+                                                        .map(|i| i >= bits)\n+                                                        .unwrap_or(true)\n+                                },\n                                 _ => { false }\n                             }\n                         };"}, {"sha": "e8b5a7efdd96bf68af35bf2402c04e7abcbf47ff", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -15,6 +15,7 @@ rbml = { path = \"../librbml\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n+rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_front = { path = \"../librustc_front\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n serialize = { path = \"../libserialize\" }"}, {"sha": "dfc794dc5b8744a225aaaa89f455243f8cf94e71", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -35,6 +35,8 @@ use middle::subst;\n use middle::ty::{ImplContainer, TraitContainer};\n use middle::ty::{self, Ty, TyCtxt, TypeFoldable, VariantKind};\n \n+use rustc_const_eval::ConstInt;\n+\n use rustc::mir;\n use rustc::mir::visit::MutVisitor;\n \n@@ -198,7 +200,7 @@ fn reexports<'a>(d: rbml::Doc<'a>) -> reader::TaggedDocsIterator<'a> {\n     reader::tagged_docs(d, tag_items_data_item_reexport)\n }\n \n-fn variant_disr_val(d: rbml::Doc) -> Option<ty::Disr> {\n+fn variant_disr_val(d: rbml::Doc) -> Option<u64> {\n     reader::maybe_get_doc(d, tag_disr_val).and_then(|val_doc| {\n         reader::with_doc_data(val_doc, |data| {\n             str::from_utf8(data).ok().and_then(|s| s.parse().ok())\n@@ -396,7 +398,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n                 did: did,\n                 name: item_name(intr, item),\n                 fields: get_variant_fields(intr, cdata, item, tcx),\n-                disr_val: disr,\n+                disr_val: ConstInt::Infer(disr),\n                 kind: expect_variant_kind(item_family(item), tcx),\n             }\n         }).collect()\n@@ -432,7 +434,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n             did: did,\n             name: item_name(intr, doc),\n             fields: get_variant_fields(intr, cdata, doc, tcx),\n-            disr_val: 0,\n+            disr_val: ConstInt::Infer(0),\n             kind: expect_variant_kind(item_family(doc), tcx),\n         }\n     }"}, {"sha": "3dc0e53b254c428dc41c048430e5c94d913e1d76", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -26,6 +26,7 @@ use middle::dependency_format::Linkage;\n use middle::stability;\n use middle::subst;\n use middle::ty::{self, Ty, TyCtxt};\n+use middle::ty::util::IntTypeExt;\n \n use rustc::back::svh::Svh;\n use rustc::front::map::{LinkedPath, PathElem, PathElems};\n@@ -238,7 +239,8 @@ fn encode_symbol(ecx: &EncodeContext,\n fn encode_disr_val(_: &EncodeContext,\n                    rbml_w: &mut Encoder,\n                    disr_val: ty::Disr) {\n-    rbml_w.wr_tagged_str(tag_disr_val, &disr_val.to_string());\n+    // convert to u64 so just the number is printed, without any type info\n+    rbml_w.wr_tagged_str(tag_disr_val, &disr_val.to_u64_unchecked().to_string());\n }\n \n fn encode_parent_item(rbml_w: &mut Encoder, id: DefId) {\n@@ -262,13 +264,14 @@ fn encode_struct_fields(rbml_w: &mut Encoder,\n \n fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                       rbml_w: &mut Encoder,\n-                                      id: NodeId,\n+                                      did: DefId,\n                                       vis: hir::Visibility,\n                                       index: &mut CrateIndex<'tcx>) {\n-    debug!(\"encode_enum_variant_info(id={})\", id);\n-\n-    let mut disr_val = 0;\n-    let def = ecx.tcx.lookup_adt_def(ecx.tcx.map.local_def_id(id));\n+    debug!(\"encode_enum_variant_info(did={:?})\", did);\n+    let repr_hints = ecx.tcx.lookup_repr_hints(did);\n+    let repr_type = ecx.tcx.enum_repr_type(repr_hints.get(0));\n+    let mut disr_val = repr_type.initial_discriminant(&ecx.tcx);\n+    let def = ecx.tcx.lookup_adt_def(did);\n     for variant in &def.variants {\n         let vid = variant.did;\n         let variant_node_id = ecx.local_id(vid);\n@@ -290,7 +293,7 @@ fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             ty::VariantKind::Unit => 'w',\n         });\n         encode_name(rbml_w, variant.name);\n-        encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(id));\n+        encode_parent_item(rbml_w, did);\n         encode_visibility(rbml_w, vis);\n \n         let attrs = ecx.tcx.get_attrs(vid);\n@@ -313,7 +316,7 @@ fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n         ecx.tcx.map.with_path(variant_node_id, |path| encode_path(rbml_w, path));\n         rbml_w.end_tag();\n-        disr_val = disr_val.wrapping_add(1);\n+        disr_val = disr_val.wrap_incr();\n     }\n }\n \n@@ -1035,7 +1038,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n         encode_enum_variant_info(ecx,\n                                  rbml_w,\n-                                 item.id,\n+                                 def_id,\n                                  vis,\n                                  index);\n       }"}, {"sha": "f0f0fb847540a58303657908cdc5e12c76de031b", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -36,6 +36,7 @@ extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_front;\n extern crate rustc_llvm;\n+extern crate rustc_const_eval;\n \n pub use rustc::middle;\n "}, {"sha": "99237c9fa5f47bc1c4feb4ecb3c8cd20abe4229a", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -13,6 +13,7 @@ graphviz = { path = \"../libgraphviz\" }\n log = { path = \"../liblog\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n+rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_front = { path = \"../librustc_front\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "9ecbf748d7c8311f4de4205a64e67e34946232fc", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -269,7 +269,7 @@ enum TestKind<'tcx> {\n \n     // test length of the slice is equal to len\n     Len {\n-        len: usize,\n+        len: u64,\n         op: BinOp,\n     },\n }"}, {"sha": "d42c8ff7bd79fab67f204babfd78e5ac6f8fb703", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -84,7 +84,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 };\n                 Test {\n                     span: match_pair.pattern.span,\n-                    kind: TestKind::Len { len: len, op: op },\n+                    kind: TestKind::Len { len: len as u64, op: op },\n                 }\n             }\n "}, {"sha": "13ab26c358d6a6a9fd6d52637a22e42ff1c24e30", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -46,7 +46,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         Operand::Constant(constant)\n     }\n \n-    pub fn push_usize(&mut self, block: BasicBlock, span: Span, value: usize) -> Lvalue<'tcx> {\n+    pub fn push_usize(&mut self, block: BasicBlock, span: Span, value: u64) -> Lvalue<'tcx> {\n         let usize_ty = self.hir.usize_ty();\n         let temp = self.temp(usize_ty);\n         self.cfg.push_assign_constant("}, {"sha": "6d411b9c07b311dc5394b1bc2cc0c4b946d53f8c", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -94,6 +94,8 @@ use rustc::middle::ty::{self, Ty, TyCtxt};\n use rustc::mir::repr::*;\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::parse::token::intern_and_get_ident;\n+use rustc::middle::const_eval::ConstVal;\n+use rustc_const_eval::ConstInt;\n \n pub struct Scope<'tcx> {\n     extent: CodeExtent,\n@@ -517,7 +519,9 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         }, Constant {\n             span: span,\n             ty: self.hir.tcx().types.u32,\n-            literal: self.hir.usize_literal(span_lines.line)\n+            literal: Literal::Value {\n+                value: ConstVal::Integral(ConstInt::U32(span_lines.line as u32)),\n+            },\n         })\n     }\n "}, {"sha": "1f8a5da9c1b9d598d89e32719cbab9c8a5d9abbc", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -10,12 +10,13 @@\n \n use hair::*;\n use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_const_eval::ConstInt;\n use hair::cx::Cx;\n use hair::cx::block;\n use hair::cx::to_ref::ToRef;\n use rustc::front::map;\n use rustc::middle::def::Def;\n-use rustc::middle::const_eval;\n+use rustc::middle::const_eval::{self, ConstVal};\n use rustc::middle::region::CodeExtent;\n use rustc::middle::pat_util;\n use rustc::middle::ty::{self, VariantDef, Ty};\n@@ -227,28 +228,37 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                 }\n             }\n \n-            hir::ExprUnary(op, ref arg) => {\n+            hir::ExprUnary(hir::UnOp::UnNot, ref arg) => {\n                 if cx.tcx.is_method_call(self.id) {\n                     overloaded_operator(cx, self, ty::MethodCall::expr(self.id),\n                                         PassArgs::ByValue, arg.to_ref(), vec![])\n                 } else {\n-                    // FIXME overflow\n-                    let op = match op {\n-                        hir::UnOp::UnNot => UnOp::Not,\n-                        hir::UnOp::UnNeg => UnOp::Neg,\n-                        hir::UnOp::UnDeref => {\n-                            cx.tcx.sess.span_bug(\n-                                self.span,\n-                                \"UnDeref should have been handled elsewhere\");\n-                        }\n-                    };\n                     ExprKind::Unary {\n-                        op: op,\n+                        op: UnOp::Not,\n                         arg: arg.to_ref(),\n                     }\n                 }\n             }\n \n+            hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n+                if cx.tcx.is_method_call(self.id) {\n+                    overloaded_operator(cx, self, ty::MethodCall::expr(self.id),\n+                                        PassArgs::ByValue, arg.to_ref(), vec![])\n+                } else {\n+                    // FIXME runtime-overflow\n+                    if let hir::ExprLit(_) = arg.node {\n+                        ExprKind::Literal {\n+                            literal: cx.const_eval_literal(self),\n+                        }\n+                    } else {\n+                        ExprKind::Unary {\n+                            op: UnOp::Neg,\n+                            arg: arg.to_ref(),\n+                        }\n+                    }\n+                }\n+            }\n+\n             hir::ExprStruct(_, ref fields, ref base) => {\n                 match expr_ty.sty {\n                     ty::TyStruct(adt, substs) => {\n@@ -338,7 +348,10 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                 count: TypedConstVal {\n                     ty: cx.tcx.expr_ty(c),\n                     span: c.span,\n-                    value: const_eval::eval_const_expr(cx.tcx, c)\n+                    value: match const_eval::eval_const_expr(cx.tcx, c) {\n+                        ConstVal::Integral(ConstInt::Usize(u)) => u,\n+                        other => panic!(\"constant evaluation of repeat count yielded {:?}\", other),\n+                    },\n                 }\n             },\n             hir::ExprRet(ref v) =>"}, {"sha": "fd4cf7c04734a6124966936ea0b463976aa1d5b0", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -24,6 +24,7 @@ use rustc::middle::ty::{self, Ty, TyCtxt};\n use syntax::codemap::Span;\n use syntax::parse::token;\n use rustc_front::hir;\n+use rustc_const_eval::{ConstInt, ConstUsize};\n \n #[derive(Copy, Clone)]\n pub struct Cx<'a, 'tcx: 'a> {\n@@ -50,8 +51,11 @@ impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n         self.tcx.types.usize\n     }\n \n-    pub fn usize_literal(&mut self, value: usize) -> Literal<'tcx> {\n-        Literal::Value { value: ConstVal::Uint(value as u64) }\n+    pub fn usize_literal(&mut self, value: u64) -> Literal<'tcx> {\n+        match ConstUsize::new(value, self.tcx.sess.target.uint_type) {\n+            Ok(val) => Literal::Value { value: ConstVal::Integral(ConstInt::Usize(val))},\n+            Err(_) => panic!(\"usize literal out of range for target\"),\n+        }\n     }\n \n     pub fn bool_ty(&mut self) -> Ty<'tcx> {"}, {"sha": "d1e3f08aff894d01ea538f23b4e943bfba94bace", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -87,7 +87,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                     Def::Const(def_id) | Def::AssociatedConst(def_id) =>\n                         match const_eval::lookup_const_by_id(self.cx.tcx, def_id,\n                                                              Some(pat.id), None) {\n-                            Some(const_expr) => {\n+                            Some((const_expr, _const_ty)) => {\n                                 let pat = const_eval::const_expr_to_pat(self.cx.tcx, const_expr,\n                                                                         pat.span);\n                                 return self.to_pattern(&pat);"}, {"sha": "7c8c8945bbc9109dd2cf4c719ed3525fc00ce9d5", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -31,6 +31,7 @@ extern crate rustc_data_structures;\n extern crate rustc_front;\n extern crate rustc_back;\n extern crate syntax;\n+extern crate rustc_const_eval;\n \n pub mod build;\n pub mod graphviz;"}, {"sha": "a9e03bba7db8e0351967c18771fb545067864696", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -604,7 +604,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 }\n                 Some(Def::Const(did)) |\n                 Some(Def::AssociatedConst(did)) => {\n-                    if let Some(expr) = const_eval::lookup_const_by_id(v.tcx, did,\n+                    if let Some((expr, _ty)) = const_eval::lookup_const_by_id(v.tcx, did,\n                                                                        Some(e.id),\n                                                                        None) {\n                         let inner = v.global_expr(Mode::Const, expr);"}, {"sha": "b7faafeba9aa1b9fd66a940f1af24a48a60a3bcb", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -16,6 +16,7 @@ graphviz = { path = \"../libgraphviz\" }\n log = { path = \"../liblog\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n+rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_front = { path = \"../librustc_front\" }\n rustc_llvm = { path = \"../librustc_llvm\" }"}, {"sha": "d7e79e46720b37749bf14110bc5ba8f8bcd2a38e", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -50,6 +50,7 @@ pub extern crate rustc_llvm as llvm;\n extern crate rustc_mir;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate serialize;\n+extern crate rustc_const_eval;\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "320bb1eab3c63fb66cd64a6a89330b0117d44e13", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -1035,7 +1035,7 @@ fn assert_discr_in_range(ity: IntType, min: Disr, max: Disr, discr: Disr) {\n     match ity {\n         attr::UnsignedInt(_) => {\n             assert!(min <= discr);\n-            assert!(discr <= max)\n+            assert!(discr <= max);\n         },\n         attr::SignedInt(_) => {\n             assert!(min.0 as i64 <= discr.0 as i64);"}, {"sha": "7d37627ad0eea53a7145e286857c7c80f8d2a77a", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 74, "deletions": 72, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -15,15 +15,7 @@ use llvm::{ConstFCmp, ConstICmp, SetLinkage, SetUnnamedAddr};\n use llvm::{InternalLinkage, ValueRef, Bool, True};\n use middle::const_qualif::ConstQualif;\n use middle::cstore::LOCAL_CRATE;\n-use middle::const_eval::{self, ConstVal, ConstEvalErr};\n-use middle::const_eval::{const_int_checked_neg, const_uint_checked_neg};\n-use middle::const_eval::{const_int_checked_add, const_uint_checked_add};\n-use middle::const_eval::{const_int_checked_sub, const_uint_checked_sub};\n-use middle::const_eval::{const_int_checked_mul, const_uint_checked_mul};\n-use middle::const_eval::{const_int_checked_div, const_uint_checked_div};\n-use middle::const_eval::{const_int_checked_rem, const_uint_checked_rem};\n-use middle::const_eval::{const_int_checked_shl, const_uint_checked_shl};\n-use middle::const_eval::{const_int_checked_shr, const_uint_checked_shr};\n+use middle::const_eval::{self, ConstEvalErr};\n use middle::def::Def;\n use middle::def_id::DefId;\n use trans::{adt, closure, debuginfo, expr, inline, machine};\n@@ -42,9 +34,10 @@ use trans::Disr;\n use middle::subst::Substs;\n use middle::ty::adjustment::{AdjustDerefRef, AdjustReifyFnPointer};\n use middle::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, TyCtxt};\n use middle::ty::cast::{CastTy,IntTy};\n use util::nodemap::NodeMap;\n+use rustc_const_eval::{ConstInt, ConstMathErr, ConstUsize, ConstIsize};\n \n use rustc_front::hir;\n \n@@ -234,7 +227,7 @@ pub fn get_const_expr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n \n     match const_eval::lookup_const_by_id(ccx.tcx(), def_id, Some(ref_expr.id), Some(param_substs)) {\n-        Some(ref expr) => expr,\n+        Some((ref expr, _ty)) => expr,\n         None => {\n             ccx.sess().span_bug(ref_expr.span, \"constant item not found\")\n         }\n@@ -469,35 +462,70 @@ fn check_unary_expr_validity(cx: &CrateContext, e: &hir::Expr, t: Ty,\n         // Catch this up front by looking for ExprLit directly,\n         // and just accepting it.\n         if let hir::ExprLit(_) = inner_e.node { return Ok(()); }\n-\n-        let result = match t.sty {\n-            ty::TyInt(int_type) => {\n-                let input = match const_to_opt_int(te) {\n-                    Some(v) => v,\n-                    None => return Ok(()),\n-                };\n-                const_int_checked_neg(\n-                    input, e, Some(const_eval::IntTy::from(cx.tcx(), int_type)))\n-            }\n-            ty::TyUint(uint_type) => {\n-                let input = match const_to_opt_uint(te) {\n-                    Some(v) => v,\n-                    None => return Ok(()),\n-                };\n-                const_uint_checked_neg(\n-                    input, e, Some(const_eval::UintTy::from(cx.tcx(), uint_type)))\n-            }\n-            _ => return Ok(()),\n+        let cval = match to_const_int(te, t, cx.tcx()) {\n+            Some(v) => v,\n+            None => return Ok(()),\n         };\n-        const_err(cx, e, result, trueconst)\n+        match -cval {\n+            Ok(_) => return Ok(()),\n+            Err(err) => const_err(cx, e, Err(err), trueconst),\n+        }\n     } else {\n         Ok(())\n     }\n }\n \n+fn to_const_int(value: ValueRef, t: Ty, tcx: &TyCtxt) -> Option<ConstInt> {\n+    match t.sty {\n+        ty::TyInt(int_type) => const_to_opt_int(value).and_then(|input| match int_type {\n+            ast::IntTy::I8 => {\n+                assert_eq!(input as i8 as i64, input);\n+                Some(ConstInt::I8(input as i8))\n+            },\n+            ast::IntTy::I16 => {\n+                assert_eq!(input as i16 as i64, input);\n+                Some(ConstInt::I16(input as i16))\n+            },\n+            ast::IntTy::I32 => {\n+                assert_eq!(input as i32 as i64, input);\n+                Some(ConstInt::I32(input as i32))\n+            },\n+            ast::IntTy::I64 => {\n+                Some(ConstInt::I64(input))\n+            },\n+            ast::IntTy::Is => {\n+                ConstIsize::new(input, tcx.sess.target.int_type)\n+                    .ok().map(ConstInt::Isize)\n+            },\n+        }),\n+        ty::TyUint(uint_type) => const_to_opt_uint(value).and_then(|input| match uint_type {\n+            ast::UintTy::U8 => {\n+                assert_eq!(input as u8 as u64, input);\n+                Some(ConstInt::U8(input as u8))\n+            },\n+            ast::UintTy::U16 => {\n+                assert_eq!(input as u16 as u64, input);\n+                Some(ConstInt::U16(input as u16))\n+            },\n+            ast::UintTy::U32 => {\n+                assert_eq!(input as u32 as u64, input);\n+                Some(ConstInt::U32(input as u32))\n+            },\n+            ast::UintTy::U64 => {\n+                Some(ConstInt::U64(input))\n+            },\n+            ast::UintTy::Us => {\n+                ConstUsize::new(input, tcx.sess.target.uint_type)\n+                    .ok().map(ConstInt::Usize)\n+            },\n+        }),\n+        _ => None,\n+    }\n+}\n+\n fn const_err(cx: &CrateContext,\n              e: &hir::Expr,\n-             result: Result<ConstVal, ConstEvalErr>,\n+             result: Result<ConstInt, ConstMathErr>,\n              trueconst: TrueConst)\n              -> Result<(), ConstEvalFailure> {\n     match (result, trueconst) {\n@@ -506,10 +534,12 @@ fn const_err(cx: &CrateContext,\n             Ok(())\n         },\n         (Err(err), TrueConst::Yes) => {\n+            let err = ConstEvalErr{ span: e.span, kind: const_eval::ErrKind::Math(err) };\n             cx.tcx().sess.span_err(e.span, &err.description());\n             Err(Compiletime(err))\n         },\n         (Err(err), TrueConst::No) => {\n+            let err = ConstEvalErr{ span: e.span, kind: const_eval::ErrKind::Math(err) };\n             cx.tcx().sess.span_warn(e.span, &err.description());\n             Err(Runtime(err))\n         },\n@@ -520,46 +550,18 @@ fn check_binary_expr_validity(cx: &CrateContext, e: &hir::Expr, t: Ty,\n                               te1: ValueRef, te2: ValueRef,\n                               trueconst: TrueConst) -> Result<(), ConstEvalFailure> {\n     let b = if let hir::ExprBinary(b, _, _) = e.node { b } else { unreachable!() };\n-\n-    let result = match t.sty {\n-        ty::TyInt(int_type) => {\n-            let (lhs, rhs) = match (const_to_opt_int(te1),\n-                                    const_to_opt_int(te2)) {\n-                (Some(v1), Some(v2)) => (v1, v2),\n-                _ => return Ok(()),\n-            };\n-\n-            let opt_ety = Some(const_eval::IntTy::from(cx.tcx(), int_type));\n-            match b.node {\n-                hir::BiAdd => const_int_checked_add(lhs, rhs, e, opt_ety),\n-                hir::BiSub => const_int_checked_sub(lhs, rhs, e, opt_ety),\n-                hir::BiMul => const_int_checked_mul(lhs, rhs, e, opt_ety),\n-                hir::BiDiv => const_int_checked_div(lhs, rhs, e, opt_ety),\n-                hir::BiRem => const_int_checked_rem(lhs, rhs, e, opt_ety),\n-                hir::BiShl => const_int_checked_shl(lhs, rhs, e, opt_ety),\n-                hir::BiShr => const_int_checked_shr(lhs, rhs, e, opt_ety),\n-                _ => return Ok(()),\n-            }\n-        }\n-        ty::TyUint(uint_type) => {\n-            let (lhs, rhs) = match (const_to_opt_uint(te1),\n-                                    const_to_opt_uint(te2)) {\n-                (Some(v1), Some(v2)) => (v1, v2),\n-                _ => return Ok(()),\n-            };\n-\n-            let opt_ety = Some(const_eval::UintTy::from(cx.tcx(), uint_type));\n-            match b.node {\n-                hir::BiAdd => const_uint_checked_add(lhs, rhs, e, opt_ety),\n-                hir::BiSub => const_uint_checked_sub(lhs, rhs, e, opt_ety),\n-                hir::BiMul => const_uint_checked_mul(lhs, rhs, e, opt_ety),\n-                hir::BiDiv => const_uint_checked_div(lhs, rhs, e, opt_ety),\n-                hir::BiRem => const_uint_checked_rem(lhs, rhs, e, opt_ety),\n-                hir::BiShl => const_uint_checked_shl(lhs, rhs, e, opt_ety),\n-                hir::BiShr => const_uint_checked_shr(lhs, rhs, e, opt_ety),\n-                _ => return Ok(()),\n-            }\n-        }\n+    let (lhs, rhs) = match (to_const_int(te1, t, cx.tcx()), to_const_int(te2, t, cx.tcx())) {\n+        (Some(v1), Some(v2)) => (v1, v2),\n+        _ => return Ok(()),\n+    };\n+    let result = match b.node {\n+        hir::BiAdd => lhs + rhs,\n+        hir::BiSub => lhs - rhs,\n+        hir::BiMul => lhs * rhs,\n+        hir::BiDiv => lhs / rhs,\n+        hir::BiRem => lhs % rhs,\n+        hir::BiShl => lhs << rhs,\n+        hir::BiShr => lhs >> rhs,\n         _ => return Ok(()),\n     };\n     const_err(cx, e, result, trueconst)"}, {"sha": "e22d42e9d28da5f7f9faa28a363115cf7226c25b", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -1597,7 +1597,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 llvm::LLVMDIBuilderCreateEnumerator(\n                     DIB(cx),\n                     name.as_ptr(),\n-                    v.disr_val as u64)\n+                    v.disr_val.to_u64_unchecked())\n             }\n         })\n         .collect();"}, {"sha": "d74c1ac50ad74b14ec703ab494c53adb356c0178", "filename": "src/librustc_trans/trans/disr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_trans%2Ftrans%2Fdisr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_trans%2Ftrans%2Fdisr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdisr.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -26,7 +26,7 @@ impl ::std::ops::BitAnd for Disr {\n \n impl From<::middle::ty::Disr> for Disr {\n     fn from(i: ::middle::ty::Disr) -> Disr {\n-        Disr(i)\n+        Disr(i.to_u64_unchecked())\n     }\n }\n "}, {"sha": "c20d8b01eb773ab3e5d7604775822502324b3e6e", "filename": "src/librustc_trans/trans/mir/constant.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -12,13 +12,15 @@ use back::abi;\n use llvm::ValueRef;\n use middle::ty::{Ty, TypeFoldable};\n use rustc::middle::const_eval::{self, ConstVal};\n+use rustc_const_eval::ConstInt::*;\n use rustc::mir::repr as mir;\n use trans::common::{self, BlockAndBuilder, C_bool, C_bytes, C_floating_f64, C_integral,\n                     C_str_slice, C_nil, C_undef};\n use trans::consts;\n use trans::expr;\n use trans::inline;\n use trans::type_of;\n+use trans::type_::Type;\n \n use super::operand::{OperandRef, OperandValue};\n use super::MirContext;\n@@ -63,8 +65,24 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         match *cv {\n             ConstVal::Float(v) => C_floating_f64(v, llty),\n             ConstVal::Bool(v) => C_bool(ccx, v),\n-            ConstVal::Int(v) => C_integral(llty, v as u64, true),\n-            ConstVal::Uint(v) => C_integral(llty, v, false),\n+            ConstVal::Integral(I8(v)) => C_integral(Type::i8(ccx), v as u64, true),\n+            ConstVal::Integral(I16(v)) => C_integral(Type::i16(ccx), v as u64, true),\n+            ConstVal::Integral(I32(v)) => C_integral(Type::i32(ccx), v as u64, true),\n+            ConstVal::Integral(I64(v)) => C_integral(Type::i64(ccx), v as u64, true),\n+            ConstVal::Integral(Isize(v)) => {\n+                let i = v.as_i64(ccx.tcx().sess.target.int_type);\n+                C_integral(Type::int(ccx), i as u64, true)\n+            },\n+            ConstVal::Integral(U8(v)) => C_integral(Type::i8(ccx), v as u64, false),\n+            ConstVal::Integral(U16(v)) => C_integral(Type::i16(ccx), v as u64, false),\n+            ConstVal::Integral(U32(v)) => C_integral(Type::i32(ccx), v as u64, false),\n+            ConstVal::Integral(U64(v)) => C_integral(Type::i64(ccx), v, false),\n+            ConstVal::Integral(Usize(v)) => {\n+                let u = v.as_u64(ccx.tcx().sess.target.uint_type);\n+                C_integral(Type::int(ccx), u, false)\n+            },\n+            ConstVal::Integral(Infer(v)) => C_integral(llty, v as u64, false),\n+            ConstVal::Integral(InferSigned(v)) => C_integral(llty, v as u64, true),\n             ConstVal::Str(ref v) => C_str_slice(ccx, v.clone()),\n             ConstVal::ByteStr(ref v) => consts::addr_of(ccx, C_bytes(ccx, v), 1, \"byte_str\"),\n             ConstVal::Struct(id) | ConstVal::Tuple(id) |\n@@ -74,6 +92,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     expr::trans(bcx, expr).datum.val\n                 })\n             },\n+            ConstVal::Char(c) => C_integral(Type::char(ccx), c as u64, false),\n+            ConstVal::Dummy => unreachable!(),\n             ConstVal::Function(_) => C_nil(ccx)\n         }\n     }\n@@ -99,7 +119,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let substs = bcx.tcx().mk_substs(bcx.monomorphize(&substs));\n                 let def_id = inline::maybe_instantiate_inline(bcx.ccx(), def_id);\n                 let expr = const_eval::lookup_const_by_id(bcx.tcx(), def_id, None, Some(substs))\n-                            .expect(\"def was const, but lookup_const_by_id failed\");\n+                            .expect(\"def was const, but lookup_const_by_id failed\").0;\n                 // FIXME: this is falling back to translating from HIR. This is not easy to fix,\n                 // because we would have somehow adapt const_eval to work on MIR rather than HIR.\n                 let d = bcx.with_block(|bcx| {"}, {"sha": "ea80af14f1f2f18528d3470aca9ddab0d5124d71", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -11,6 +11,8 @@\n use llvm::ValueRef;\n use rustc::middle::ty::{self, Ty};\n use middle::ty::cast::{CastTy, IntTy};\n+use middle::const_eval::ConstVal;\n+use rustc_const_eval::ConstInt;\n use rustc::mir::repr as mir;\n \n use trans::asm;\n@@ -95,7 +97,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n             mir::Rvalue::Repeat(ref elem, ref count) => {\n                 let tr_elem = self.trans_operand(&bcx, elem);\n-                let size = self.trans_constval(&bcx, &count.value, count.ty).immediate();\n+                let count = ConstVal::Integral(ConstInt::Usize(count.value));\n+                let size = self.trans_constval(&bcx, &count, bcx.tcx().types.usize).immediate();\n                 let bcx = bcx.map_block(|block| {\n                     let base = expr::get_dataptr(block, dest.llval);\n                     tvec::iter_vec_raw(block, base, tr_elem.ty, size, |block, llslot, _| {"}, {"sha": "1c907972863b6422878adaad1759ea8aaac0d195", "filename": "src/librustc_typeck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2FCargo.toml?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -15,5 +15,6 @@ arena = { path = \"../libarena\" }\n fmt_macros = { path = \"../libfmt_macros\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n+rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_front = { path = \"../librustc_front\" }\n rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }"}, {"sha": "ba56c5d24ab6e286a431f1cbad2dc4527c719ed5", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -65,6 +65,8 @@ use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::FnvHashSet;\n \n+use rustc_const_eval::ConstInt;\n+\n use syntax::{abi, ast};\n use syntax::codemap::{Span, Pos};\n use syntax::errors::DiagnosticBuilder;\n@@ -1680,22 +1682,16 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n         hir::TyFixedLengthVec(ref ty, ref e) => {\n             let hint = UncheckedExprHint(tcx.types.usize);\n             match const_eval::eval_const_expr_partial(tcx, &e, hint, None) {\n-                Ok(r) => {\n-                    match r {\n-                        ConstVal::Int(i) =>\n-                            tcx.mk_array(ast_ty_to_ty(this, rscope, &ty),\n-                                         i as usize),\n-                        ConstVal::Uint(i) =>\n-                            tcx.mk_array(ast_ty_to_ty(this, rscope, &ty),\n-                                         i as usize),\n-                        _ => {\n-                            span_err!(tcx.sess, ast_ty.span, E0249,\n-                                      \"expected constant integer expression \\\n-                                       for array length\");\n-                            this.tcx().types.err\n-                        }\n-                    }\n-                }\n+                Ok(ConstVal::Integral(ConstInt::Usize(i))) => {\n+                    let i = i.as_u64(tcx.sess.target.uint_type);\n+                    assert_eq!(i as usize as u64, i);\n+                    tcx.mk_array(ast_ty_to_ty(this, rscope, &ty), i as usize)\n+                },\n+                Ok(val) => {\n+                    span_err!(tcx.sess, ast_ty.span, E0249,\n+                              \"expected usize value for array length, got {}\", val.description());\n+                    this.tcx().types.err\n+                },\n                 Err(ref r) => {\n                     let mut err = struct_span_err!(tcx.sess, r.span, E0250,\n                                                    \"array length constant evaluation error: {}\","}, {"sha": "19731407d9e7a302cb03dc92aace2354d9aad701", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 48, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -94,15 +94,15 @@ use middle::pat_util::{self, pat_id_map};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace};\n use middle::traits::{self, report_fulfillment_errors};\n use middle::ty::{GenericPredicates, TypeScheme};\n-use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n+use middle::ty::{ParamTy, ParameterEnvironment};\n use middle::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n use middle::ty::{self, ToPolyTraitRef, Ty, TyCtxt};\n use middle::ty::{MethodCall, MethodCallee};\n use middle::ty::adjustment;\n use middle::ty::error::TypeError;\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n use middle::ty::relate::TypeRelation;\n-use middle::ty::util::Representability;\n+use middle::ty::util::{Representability, IntTypeExt};\n use require_c_abi_if_variadic;\n use rscope::{ElisionFailureInfo, RegionScope};\n use session::{Session, CompileResult};\n@@ -4076,34 +4076,6 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                     sp: Span,\n                                     vs: &'tcx [hir::Variant],\n                                     id: ast::NodeId) {\n-    // disr_in_range should be removed once we have forced type hints for consts\n-    fn disr_in_range(ccx: &CrateCtxt,\n-                     ty: attr::IntType,\n-                     disr: ty::Disr) -> bool {\n-        fn uint_in_range(ccx: &CrateCtxt, ty: ast::UintTy, disr: ty::Disr) -> bool {\n-            match ty {\n-                ast::UintTy::U8 => disr as u8 as Disr == disr,\n-                ast::UintTy::U16 => disr as u16 as Disr == disr,\n-                ast::UintTy::U32 => disr as u32 as Disr == disr,\n-                ast::UintTy::U64 => disr as u64 as Disr == disr,\n-                ast::UintTy::Us => uint_in_range(ccx, ccx.tcx.sess.target.uint_type, disr)\n-            }\n-        }\n-        fn int_in_range(ccx: &CrateCtxt, ty: ast::IntTy, disr: ty::Disr) -> bool {\n-            match ty {\n-                ast::IntTy::I8 => disr as i8 as Disr == disr,\n-                ast::IntTy::I16 => disr as i16 as Disr == disr,\n-                ast::IntTy::I32 => disr as i32 as Disr == disr,\n-                ast::IntTy::I64 => disr as i64 as Disr == disr,\n-                ast::IntTy::Is => int_in_range(ccx, ccx.tcx.sess.target.int_type, disr)\n-            }\n-        }\n-        match ty {\n-            attr::UnsignedInt(ty) => uint_in_range(ccx, ty, disr),\n-            attr::SignedInt(ty) => int_in_range(ccx, ty, disr)\n-        }\n-    }\n-\n     fn do_check<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                           vs: &'tcx [hir::Variant],\n                           id: ast::NodeId,\n@@ -4117,7 +4089,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         let inh = static_inherited_fields(ccx, &tables);\n         let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), id);\n \n-        let (_, repr_type_ty) = ccx.tcx.enum_repr_type(Some(&hint));\n+        let repr_type_ty = ccx.tcx.enum_repr_type(Some(&hint)).to_ty(&ccx.tcx);\n         for v in vs {\n             if let Some(ref e) = v.node.disr_expr {\n                 check_const_with_ty(&fcx, e.span, e, repr_type_ty);\n@@ -4142,23 +4114,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                 }\n                 None => {}\n             }\n-            // Check for unrepresentable discriminant values\n-            match hint {\n-                attr::ReprAny | attr::ReprExtern => {\n-                    disr_vals.push(current_disr_val);\n-                }\n-                attr::ReprInt(sp, ity) => {\n-                    if !disr_in_range(ccx, ity, current_disr_val) {\n-                        let mut err = struct_span_err!(ccx.tcx.sess, v.span, E0082,\n-                            \"discriminant value outside specified type\");\n-                        span_note!(&mut err, sp,\n-                            \"discriminant type specified here\");\n-                        err.emit();\n-                    }\n-                }\n-                // Error reported elsewhere.\n-                attr::ReprSimd | attr::ReprPacked => {}\n-            }\n+            disr_vals.push(current_disr_val);\n         }\n     }\n "}, {"sha": "b97d3f4993a40b9c3d2180b6a3d3cd94f158d648", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 42, "deletions": 29, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -81,6 +81,8 @@ use util::common::{ErrorReported, MemoizationMap};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n use write_ty_to_tcx;\n \n+use rustc_const_eval::ConstInt;\n+\n use std::cell::RefCell;\n use std::collections::HashSet;\n use std::rc::Rc;\n@@ -1012,7 +1014,7 @@ fn convert_struct_def<'tcx>(tcx: &TyCtxt<'tcx>,\n     tcx.intern_adt_def(\n         did,\n         ty::AdtKind::Struct,\n-        vec![convert_struct_variant(tcx, ctor_id, it.name, 0, def)]\n+        vec![convert_struct_variant(tcx, ctor_id, it.name, ConstInt::Infer(0), def)]\n     )\n }\n \n@@ -1021,24 +1023,39 @@ fn convert_enum_def<'tcx>(tcx: &TyCtxt<'tcx>,\n                           def: &hir::EnumDef)\n                           -> ty::AdtDefMaster<'tcx>\n {\n+    fn print_err(tcx: &TyCtxt, span: Span, ty: ty::Ty, cv: ConstVal) {\n+        span_err!(tcx.sess, span, E0079, \"mismatched types: expected `{}` got `{}`\",\n+                  ty, cv.description());\n+    }\n     fn evaluate_disr_expr<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                repr_ty: Ty<'tcx>,\n+                                repr_ty: attr::IntType,\n                                 e: &hir::Expr) -> Option<ty::Disr> {\n         debug!(\"disr expr, checking {}\", pprust::expr_to_string(e));\n \n-        let hint = UncheckedExprHint(repr_ty);\n+        let ty_hint = repr_ty.to_ty(tcx);\n+        let hint = UncheckedExprHint(ty_hint);\n         match const_eval::eval_const_expr_partial(tcx, e, hint, None) {\n-            Ok(ConstVal::Int(val)) => Some(val as ty::Disr),\n-            Ok(ConstVal::Uint(val)) => Some(val as ty::Disr),\n-            Ok(_) => {\n-                let sign_desc = if repr_ty.is_signed() {\n-                    \"signed\"\n-                } else {\n-                    \"unsigned\"\n-                };\n-                span_err!(tcx.sess, e.span, E0079,\n-                          \"expected {} integer constant\",\n-                          sign_desc);\n+            Ok(ConstVal::Integral(i)) => {\n+                // FIXME: eval_const_expr_partial should return an error if the hint is wrong\n+                match (repr_ty, i) {\n+                    (attr::SignedInt(ast::IntTy::I8), ConstInt::I8(_)) => Some(i),\n+                    (attr::SignedInt(ast::IntTy::I16), ConstInt::I16(_)) => Some(i),\n+                    (attr::SignedInt(ast::IntTy::I32), ConstInt::I32(_)) => Some(i),\n+                    (attr::SignedInt(ast::IntTy::I64), ConstInt::I64(_)) => Some(i),\n+                    (attr::SignedInt(ast::IntTy::Is), ConstInt::Isize(_)) => Some(i),\n+                    (attr::UnsignedInt(ast::UintTy::U8), ConstInt::U8(_)) => Some(i),\n+                    (attr::UnsignedInt(ast::UintTy::U16), ConstInt::U16(_)) => Some(i),\n+                    (attr::UnsignedInt(ast::UintTy::U32), ConstInt::U32(_)) => Some(i),\n+                    (attr::UnsignedInt(ast::UintTy::U64), ConstInt::U64(_)) => Some(i),\n+                    (attr::UnsignedInt(ast::UintTy::Us), ConstInt::Usize(_)) => Some(i),\n+                    (_, i) => {\n+                        print_err(tcx, e.span, ty_hint, ConstVal::Integral(i));\n+                        None\n+                    },\n+                }\n+            },\n+            Ok(cv) => {\n+                print_err(tcx, e.span, ty_hint, cv);\n                 None\n             },\n             Err(err) => {\n@@ -1057,16 +1074,11 @@ fn convert_enum_def<'tcx>(tcx: &TyCtxt<'tcx>,\n     fn report_discrim_overflow(tcx: &TyCtxt,\n                                variant_span: Span,\n                                variant_name: &str,\n-                               repr_type: attr::IntType,\n                                prev_val: ty::Disr) {\n-        let computed_value = repr_type.disr_wrap_incr(Some(prev_val));\n-        let computed_value = repr_type.disr_string(computed_value);\n-        let prev_val = repr_type.disr_string(prev_val);\n-        let repr_type = repr_type.to_ty(tcx);\n         span_err!(tcx.sess, variant_span, E0370,\n-                  \"enum discriminant overflowed on value after {}: {}; \\\n+                  \"enum discriminant overflowed on value after {}; \\\n                    set explicitly via {} = {} if that is desired outcome\",\n-                  prev_val, repr_type, variant_name, computed_value);\n+                  prev_val, variant_name, prev_val.wrap_incr());\n     }\n \n     fn next_disr(tcx: &TyCtxt,\n@@ -1076,12 +1088,11 @@ fn convert_enum_def<'tcx>(tcx: &TyCtxt<'tcx>,\n         if let Some(prev_disr_val) = prev_disr_val {\n             let result = repr_type.disr_incr(prev_disr_val);\n             if let None = result {\n-                report_discrim_overflow(tcx, v.span, &v.node.name.as_str(),\n-                                             repr_type, prev_disr_val);\n+                report_discrim_overflow(tcx, v.span, &v.node.name.as_str(), prev_disr_val);\n             }\n             result\n         } else {\n-            Some(ty::INITIAL_DISCRIMINANT_VALUE)\n+            Some(repr_type.initial_discriminant(tcx))\n         }\n     }\n     fn convert_enum_variant<'tcx>(tcx: &TyCtxt<'tcx>,\n@@ -1095,17 +1106,19 @@ fn convert_enum_def<'tcx>(tcx: &TyCtxt<'tcx>,\n     }\n     let did = tcx.map.local_def_id(it.id);\n     let repr_hints = tcx.lookup_repr_hints(did);\n-    let (repr_type, repr_type_ty) = tcx.enum_repr_type(repr_hints.get(0));\n+    let repr_type = tcx.enum_repr_type(repr_hints.get(0));\n     let mut prev_disr = None;\n     let variants = def.variants.iter().map(|v| {\n         let disr = match v.node.disr_expr {\n-            Some(ref e) => evaluate_disr_expr(tcx, repr_type_ty, e),\n+            Some(ref e) => evaluate_disr_expr(tcx, repr_type, e),\n             None => next_disr(tcx, v, repr_type, prev_disr)\n-        }.unwrap_or(repr_type.disr_wrap_incr(prev_disr));\n+        }.unwrap_or_else(|| {\n+            prev_disr.map(ty::Disr::wrap_incr)\n+                     .unwrap_or(repr_type.initial_discriminant(tcx))\n+        });\n \n-        let v = convert_enum_variant(tcx, v, disr);\n         prev_disr = Some(disr);\n-        v\n+        convert_enum_variant(tcx, v, disr)\n     }).collect();\n     tcx.intern_adt_def(tcx.map.local_def_id(it.id), ty::AdtKind::Enum, variants)\n }"}, {"sha": "125c3d426a8036283ee90a0f3271651da917cc4b", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -91,6 +91,7 @@ extern crate rustc;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_front;\n extern crate rustc_back;\n+extern crate rustc_const_eval;\n \n pub use rustc::dep_graph;\n pub use rustc::front;"}, {"sha": "ef54be720376a7a79f96eb40491fa71d6ef2a8a2", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -337,7 +337,7 @@ pub fn build_impl(cx: &DocContext,\n                 let type_scheme = tcx.lookup_item_type(did);\n                 let default = if assoc_const.has_value {\n                     Some(const_eval::lookup_const_by_id(tcx, did, None, None)\n-                         .unwrap().span.to_src(cx))\n+                         .unwrap().0.span.to_src(cx))\n                 } else {\n                     None\n                 };\n@@ -479,15 +479,15 @@ fn build_const(cx: &DocContext, tcx: &TyCtxt,\n     use rustc::middle::const_eval;\n     use rustc_front::print::pprust;\n \n-    let expr = const_eval::lookup_const_by_id(tcx, did, None, None).unwrap_or_else(|| {\n+    let (expr, ty) = const_eval::lookup_const_by_id(tcx, did, None, None).unwrap_or_else(|| {\n         panic!(\"expected lookup_const_by_id to succeed for {:?}\", did);\n     });\n     debug!(\"converting constant expr {:?} to snippet\", expr);\n     let sn = pprust::expr_to_string(expr);\n     debug!(\"got snippet {}\", sn);\n \n     clean::Constant {\n-        type_: tcx.lookup_item_type(did).ty.clean(cx),\n+        type_: ty.map(|t| t.clean(cx)).unwrap_or_else(|| tcx.lookup_item_type(did).ty.clean(cx)),\n         expr: sn\n     }\n }"}, {"sha": "fdfbc98b0078a0bb266cd7e8dd7ee20c574c42a8", "filename": "src/test/auxiliary/dummy_mir_pass.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fauxiliary%2Fdummy_mir_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fauxiliary%2Fdummy_mir_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fdummy_mir_pass.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -16,13 +16,15 @@\n #[macro_use] extern crate rustc;\n extern crate rustc_front;\n extern crate rustc_plugin;\n+extern crate rustc_const_eval;\n extern crate syntax;\n \n use rustc::mir::transform::{self, MirPass};\n use rustc::mir::repr::{Mir, Literal};\n use rustc::mir::visit::MutVisitor;\n use rustc::middle::ty;\n use rustc::middle::const_eval::ConstVal;\n+use rustc_const_eval::ConstInt;\n use rustc_plugin::Registry;\n \n use syntax::ast::NodeId;\n@@ -40,8 +42,10 @@ struct Visitor;\n \n impl<'tcx> MutVisitor<'tcx> for Visitor {\n     fn visit_literal(&mut self, literal: &mut Literal<'tcx>) {\n-        if let Literal::Value { value: ConstVal::Int(ref mut i @ 11) } = *literal {\n-            *i = 42;\n+        if let Literal::Value { ref mut value } = *literal {\n+            if let ConstVal::Integral(ConstInt::I32(ref mut i @ 11)) = *value {\n+                *i = 42;\n+            }\n         }\n     }\n }"}, {"sha": "4d156a49192fd403fb0b894aafb74292c4865eaf", "filename": "src/test/compile-fail/const-err.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -25,9 +25,9 @@ fn main() {\n     //~^ WARN attempted to add with overflow\n     //~^^ WARN attempted to add with overflow\n     let c = 200u8 * 4;\n-    //~^ WARN attempted to mul with overflow\n+    //~^ WARN attempted to multiply with overflow\n     let d = 42u8 - (42u8 + 1);\n-    //~^ WARN attempted to sub with overflow\n+    //~^ WARN attempted to subtract with overflow\n     let _e = BLA;\n     black_box(a);\n     black_box(b);"}, {"sha": "07e27a7dc9a9a412b2eb14155044584b7980c325", "filename": "src/test/compile-fail/const-eval-overflow-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -21,10 +21,11 @@ const NEG_128: i8 = -128;\n const NEG_NEG_128: i8 = -NEG_128;\n //~^ ERROR constant evaluation error: attempted to negate with overflow\n //~| ERROR attempted to negate with overflow\n+//~| ERROR attempted to negate with overflow\n \n fn main() {\n     match -128i8 {\n-        NEG_NEG_128 => println!(\"A\"),\n+        NEG_NEG_128 => println!(\"A\"), //~ NOTE in pattern here\n         _ => println!(\"B\"),\n     }\n }"}, {"sha": "c90ae045f96b4aa0430e2b3c020f47d33caeba1a", "filename": "src/test/compile-fail/const-eval-overflow-3.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-3.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -36,4 +36,3 @@ fn main() {\n fn foo<T:fmt::Debug>(x: T) {\n     println!(\"{:?}\", x);\n }\n-"}, {"sha": "5aa93cf6383fe4c37e2209f3c33cb350e1ed2681", "filename": "src/test/compile-fail/const-eval-overflow-4b.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -21,8 +21,9 @@ use std::{u8, u16, u32, u64, usize};\n \n const A_I8_T\n     : [u32; (i8::MAX as i8 + 1u8) as usize]\n-    //~^ ERROR mismatched types\n-    //~| ERROR the trait `core::ops::Add<u8>` is not implemented for the type `i8`\n+    //~^ ERROR mismatched types:\n+    //~| expected `i8`,\n+    //~| found `u8` [E0250]\n     = [0; (i8::MAX as usize) + 1];\n \n fn main() {"}, {"sha": "3dfcb5bb29a24a68701b48d195f62aca3361240c", "filename": "src/test/compile-fail/const-eval-overflow.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -23,84 +23,84 @@ const VALS_I8: (i8, i8, i8, i8) =\n     (-i8::MIN,\n      //~^ ERROR attempted to negate with overflow\n      i8::MIN - 1,\n-     //~^ ERROR attempted to sub with overflow\n+     //~^ ERROR attempted to subtract with overflow\n      i8::MAX + 1,\n      //~^ ERROR attempted to add with overflow\n      i8::MIN * 2,\n-     //~^ ERROR attempted to mul with overflow\n+     //~^ ERROR attempted to multiply with overflow\n      );\n \n const VALS_I16: (i16, i16, i16, i16) =\n     (-i16::MIN,\n      //~^ ERROR attempted to negate with overflow\n      i16::MIN - 1,\n-     //~^ ERROR attempted to sub with overflow\n+     //~^ ERROR attempted to subtract with overflow\n      i16::MAX + 1,\n      //~^ ERROR attempted to add with overflow\n      i16::MIN * 2,\n-     //~^ ERROR attempted to mul with overflow\n+     //~^ ERROR attempted to multiply with overflow\n      );\n \n const VALS_I32: (i32, i32, i32, i32) =\n     (-i32::MIN,\n      //~^ ERROR attempted to negate with overflow\n      i32::MIN - 1,\n-     //~^ ERROR attempted to sub with overflow\n+     //~^ ERROR attempted to subtract with overflow\n      i32::MAX + 1,\n      //~^ ERROR attempted to add with overflow\n      i32::MIN * 2,\n-     //~^ ERROR attempted to mul with overflow\n+     //~^ ERROR attempted to multiply with overflow\n      );\n \n const VALS_I64: (i64, i64, i64, i64) =\n     (-i64::MIN,\n      //~^ ERROR attempted to negate with overflow\n      i64::MIN - 1,\n-     //~^ ERROR attempted to sub with overflow\n+     //~^ ERROR attempted to subtract with overflow\n      i64::MAX + 1,\n      //~^ ERROR attempted to add with overflow\n      i64::MAX * 2,\n-     //~^ ERROR attempted to mul with overflow\n+     //~^ ERROR attempted to multiply with overflow\n      );\n \n const VALS_U8: (u8, u8, u8, u8) =\n     (-(u8::MIN as i8) as u8,\n      u8::MIN - 1,\n-     //~^ ERROR attempted to sub with overflow\n+     //~^ ERROR attempted to subtract with overflow\n      u8::MAX + 1,\n      //~^ ERROR attempted to add with overflow\n      u8::MAX * 2,\n-     //~^ ERROR attempted to mul with overflow\n+     //~^ ERROR attempted to multiply with overflow\n      );\n \n const VALS_U16: (u16, u16, u16, u16) =\n     (-(u16::MIN as i16) as u16,\n      u16::MIN - 1,\n-     //~^ ERROR attempted to sub with overflow\n+     //~^ ERROR attempted to subtract with overflow\n      u16::MAX + 1,\n      //~^ ERROR attempted to add with overflow\n      u16::MAX * 2,\n-     //~^ ERROR attempted to mul with overflow\n+     //~^ ERROR attempted to multiply with overflow\n      );\n \n const VALS_U32: (u32, u32, u32, u32) =\n     (-(u32::MIN as i32) as u32,\n      u32::MIN - 1,\n-     //~^ ERROR attempted to sub with overflow\n+     //~^ ERROR attempted to subtract with overflow\n      u32::MAX + 1,\n      //~^ ERROR attempted to add with overflow\n      u32::MAX * 2,\n-     //~^ ERROR attempted to mul with overflow\n+     //~^ ERROR attempted to multiply with overflow\n      );\n \n const VALS_U64: (u64, u64, u64, u64) =\n     (-(u64::MIN as i64) as u64,\n      u64::MIN - 1,\n-     //~^ ERROR attempted to sub with overflow\n+     //~^ ERROR attempted to subtract with overflow\n      u64::MAX + 1,\n      //~^ ERROR attempted to add with overflow\n      u64::MAX * 2,\n-     //~^ ERROR attempted to mul with overflow\n+     //~^ ERROR attempted to multiply with overflow\n      );\n \n fn main() {"}, {"sha": "0d6cf3bab453fac0892aca6ff79efa9986f75507", "filename": "src/test/compile-fail/const-integer-bool-ops.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -8,32 +8,30 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-const X: usize = 42 && 39; //~ ERROR: can't do this op on unsigned integrals\n+const X: usize = 42 && 39; //~ ERROR: can't do this op on integrals\n const ARR: [i32; X] = [99; 34]; //~ NOTE: for array length here\n \n-const X1: usize = 42 || 39; //~ ERROR: can't do this op on unsigned integrals\n+const X1: usize = 42 || 39; //~ ERROR: can't do this op on integrals\n const ARR1: [i32; X1] = [99; 47]; //~ NOTE: for array length here\n \n-// FIXME: the error should be `on signed integrals`\n-const X2: usize = -42 || -39; //~ ERROR: can't do this op on unsigned integrals\n+const X2: usize = -42 || -39; //~ ERROR: unary negation of unsigned integer\n const ARR2: [i32; X2] = [99; 18446744073709551607]; //~ NOTE: for array length here\n \n-// FIXME: the error should be `on signed integrals`\n-const X3: usize = -42 && -39; //~ ERROR: can't do this op on unsigned integrals\n+const X3: usize = -42 && -39; //~ ERROR: unary negation of unsigned integer\n const ARR3: [i32; X3] = [99; 6]; //~ NOTE: for array length here\n \n const Y: usize = 42.0 == 42.0;\n-const ARRR: [i32; Y] = [99; 1]; //~ ERROR: expected constant integer expression for array length\n+const ARRR: [i32; Y] = [99; 1]; //~ ERROR: expected usize value for array length\n const Y1: usize = 42.0 >= 42.0;\n-const ARRR1: [i32; Y] = [99; 1]; //~ ERROR: expected constant integer expression for array length\n+const ARRR1: [i32; Y] = [99; 1]; //~ ERROR: expected usize value for array length\n const Y2: usize = 42.0 <= 42.0;\n-const ARRR2: [i32; Y] = [99; 1]; //~ ERROR: expected constant integer expression for array length\n+const ARRR2: [i32; Y] = [99; 1]; //~ ERROR: expected usize value for array length\n const Y3: usize = 42.0 > 42.0;\n-const ARRR3: [i32; Y] = [99; 0]; //~ ERROR: expected constant integer expression for array length\n+const ARRR3: [i32; Y] = [99; 0]; //~ ERROR: expected usize value for array length\n const Y4: usize = 42.0 < 42.0;\n-const ARRR4: [i32; Y] = [99; 0]; //~ ERROR: expected constant integer expression for array length\n+const ARRR4: [i32; Y] = [99; 0]; //~ ERROR: expected usize value for array length\n const Y5: usize = 42.0 != 42.0;\n-const ARRR5: [i32; Y] = [99; 0]; //~ ERROR: expected constant integer expression for array length\n+const ARRR5: [i32; Y] = [99; 0]; //~ ERROR: expected usize value for array length\n \n fn main() {\n     let _ = ARR;"}, {"sha": "9c6b774b99039811fb6482e80d2e98c649f5f6aa", "filename": "src/test/compile-fail/const-len-underflow-separate-spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-separate-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-separate-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-separate-spans.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -15,7 +15,7 @@\n const ONE: usize = 1;\n const TWO: usize = 2;\n const LEN: usize = ONE - TWO;\n-//~^ ERROR array length constant evaluation error: attempted to sub with overflow [E0250]\n+//~^ ERROR array length constant evaluation error: attempted to subtract with overflow [E0250]\n \n fn main() {\n     let a: [i8; LEN] = unimplemented!();"}, {"sha": "d51f31087d0df1494c5cce1005433e6839109a92", "filename": "src/test/compile-fail/const-len-underflow-subspans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-subspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-subspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-subspans.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -16,5 +16,5 @@ const TWO: usize = 2;\n \n fn main() {\n     let a: [i8; ONE - TWO] = unimplemented!();\n-    //~^ ERROR array length constant evaluation error: attempted to sub with overflow [E0250]\n+    //~^ ERROR array length constant evaluation error: attempted to subtract with overflow [E0250]\n }"}, {"sha": "9d3c432d14878de269cf86ba9616dc7cc7c9d7af", "filename": "src/test/compile-fail/const-tup-index-span.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -11,7 +11,7 @@\n // Test spans of errors\n \n const TUP: (usize,) = 5 << 64;\n-//~^ ERROR: attempted left shift with overflow [E0250]\n+//~^ ERROR: attempted to shift left with overflow [E0250]\n const ARR: [i32; TUP.0] = [];\n \n fn main() {"}, {"sha": "0ff740212e8fa46cec39e66a28c8b00de66ce70b", "filename": "src/test/compile-fail/discrim-overflow-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fdiscrim-overflow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fdiscrim-overflow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdiscrim-overflow-2.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -24,7 +24,7 @@ fn f_i8() {\n     enum A {\n         Ok = i8::MAX - 1,\n         Ok2,\n-        OhNo, //~ ERROR enum discriminant overflowed on value after 127: i8; set explicitly via OhNo = -128 if that is desired outcome\n+        OhNo, //~ ERROR enum discriminant overflowed on value after 127i8; set explicitly via OhNo = -128i8 if that is desired outcome\n     }\n }\n \n@@ -33,7 +33,7 @@ fn f_u8() {\n     enum A {\n         Ok = u8::MAX - 1,\n         Ok2,\n-        OhNo, //~ ERROR enum discriminant overflowed on value after 255: u8; set explicitly via OhNo = 0 if that is desired outcome\n+        OhNo, //~ ERROR enum discriminant overflowed on value after 255u8; set explicitly via OhNo = 0u8 if that is desired outcome\n     }\n }\n "}, {"sha": "7316e737b6da8680379b2c617430e54b2703b4ad", "filename": "src/test/compile-fail/discrim-overflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fdiscrim-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fdiscrim-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdiscrim-overflow.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -22,7 +22,7 @@ fn f_i8() {\n     enum A {\n         Ok = i8::MAX - 1,\n         Ok2,\n-        OhNo, //~ ERROR enum discriminant overflowed on value after 127: i8; set explicitly via OhNo = -128 if that is desired outcome\n+        OhNo, //~ ERROR enum discriminant overflowed on value after 127i8; set explicitly via OhNo = -128i8 if that is desired outcome\n     }\n \n     let x = A::Ok;\n@@ -33,7 +33,7 @@ fn f_u8() {\n     enum A {\n         Ok = u8::MAX - 1,\n         Ok2,\n-        OhNo, //~ ERROR enum discriminant overflowed on value after 255: u8; set explicitly via OhNo = 0 if that is desired outcome\n+        OhNo, //~ ERROR enum discriminant overflowed on value after 255u8; set explicitly via OhNo = 0u8 if that is desired outcome\n     }\n \n     let x = A::Ok;"}, {"sha": "d6ba09bb4c5bf072692b9677f3f4883dc99e4951", "filename": "src/test/compile-fail/enum-discrim-too-small.rs", "status": "modified", "additions": 11, "deletions": 25, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -9,46 +9,32 @@\n // except according to those terms.\n \n \n-#[repr(u8)] //~ NOTE discriminant type specified here\n+#[repr(u8)]\n enum Eu8 {\n     Au8 = 23,\n     Bu8 = 223,\n-    Cu8 = -23, //~ ERROR discriminant value outside specified type\n+    Cu8 = -23, //~ ERROR unary negation of unsigned integer\n }\n \n-#[repr(i8)] //~ NOTE discriminant type specified here\n-enum Ei8 {\n-    Ai8 = 23,\n-    Bi8 = -23,\n-    Ci8 = 223, //~ ERROR discriminant value outside specified type\n-}\n-\n-#[repr(u16)] //~ NOTE discriminant type specified here\n+#[repr(u16)]\n enum Eu16 {\n     Au16 = 23,\n     Bu16 = 55555,\n-    Cu16 = -22333, //~ ERROR discriminant value outside specified type\n-}\n-\n-#[repr(i16)] //~ NOTE discriminant type specified here\n-enum Ei16 {\n-    Ai16 = 23,\n-    Bi16 = -22333,\n-    Ci16 = 55555, //~ ERROR discriminant value outside specified type\n+    Cu16 = -22333, //~ ERROR unary negation of unsigned integer\n }\n \n-#[repr(u32)] //~ NOTE discriminant type specified here\n+#[repr(u32)]\n enum Eu32 {\n     Au32 = 23,\n     Bu32 = 3_000_000_000,\n-    Cu32 = -2_000_000_000, //~ ERROR discriminant value outside specified type\n+    Cu32 = -2_000_000_000, //~ ERROR unary negation of unsigned integer\n }\n \n-#[repr(i32)] //~ NOTE discriminant type specified here\n-enum Ei32 {\n-    Ai32 = 23,\n-    Bi32 = -2_000_000_000,\n-    Ci32 = 3_000_000_000, //~ ERROR discriminant value outside specified type\n+#[repr(u64)]\n+enum Eu64 {\n+    Au32 = 23,\n+    Bu32 = 3_000_000_000,\n+    Cu32 = -2_000_000_000, //~ ERROR unary negation of unsigned integer\n }\n \n // u64 currently allows negative numbers, and i64 allows numbers greater than `1<<63`.  This is a"}, {"sha": "d66716c14c3d5ee15b42e1ffb75ebc72fe691219", "filename": "src/test/compile-fail/enum-discrim-too-small2.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small2.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(overflowing_literals)]\n+#![allow(dead_code)]\n+\n+#[repr(i8)]\n+enum Ei8 {\n+    Ai8 = 23,\n+    Bi8 = -23,\n+    Ci8 = 223, //~ ERROR literal out of range for i8\n+}\n+\n+#[repr(i16)]\n+enum Ei16 {\n+    Ai16 = 23,\n+    Bi16 = -22333,\n+    Ci16 = 55555, //~ ERROR literal out of range for i16\n+}\n+\n+#[repr(i32)]\n+enum Ei32 {\n+    Ai32 = 23,\n+    Bi32 = -2_000_000_000,\n+    Ci32 = 3_000_000_000, //~ ERROR literal out of range for i32\n+}\n+\n+#[repr(i64)]\n+enum Ei64 {\n+    Ai64 = 23,\n+    Bi64 = -9223372036854775808,\n+    Ci64 = 9223372036854775809, //~ ERROR literal out of range for i64\n+}\n+\n+// u64 currently allows negative numbers, and i64 allows numbers greater than `1<<63`.  This is a\n+// little counterintuitive, but since the discriminant can store all the bits, and extracting it\n+// with a cast requires specifying the signedness, there is no loss of information in those cases.\n+// This also applies to isize and usize on 64-bit targets.\n+\n+pub fn main() { }"}, {"sha": "7ca274b81e574a5c6cf6962b926ddfb3ceff5b05", "filename": "src/test/compile-fail/eval-enum.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Feval-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Feval-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Feval-enum.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -10,7 +10,8 @@\n \n enum test {\n     div_zero = 1/0, //~ERROR constant evaluation error: attempted to divide by zero\n-    rem_zero = 1%0  //~ERROR constant evaluation error: attempted remainder with a divisor of zero\n+    rem_zero = 1%0,\n+//~^ ERROR constant evaluation error: attempted to calculate the remainder with a divisor of zero\n }\n \n fn main() {}"}, {"sha": "546fc5e3c6063f91ae24b9d1f271697cbb817b76", "filename": "src/test/compile-fail/feature-gate-negate-unsigned.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -21,22 +21,7 @@ const _MAX: usize = -1;\n //~| HELP use a cast or the `!` operator\n \n fn main() {\n-    let a = -1;\n-    //~^ ERROR unary negation of unsigned integer\n-    //~| HELP use a cast or the `!` operator\n-    let _b : u8 = a; // for infering variable a to u8.\n-\n-    -a;\n-    //~^ ERROR unary negation of unsigned integer\n-    //~| HELP use a cast or the `!` operator\n-\n-    let _d = -1u8;\n-    //~^ ERROR unary negation of unsigned integer\n-    //~| HELP use a cast or the `!` operator\n-\n-    for _ in -10..10u8 {}\n-    //~^ ERROR unary negation of unsigned integer\n-    //~| HELP use a cast or the `!` operator\n-\n+    let x = 5u8;\n+    let _y = -x; //~ ERROR unary negation of unsigned integer\n     -S; // should not trigger the gate; issue 26840\n }"}, {"sha": "05b194345d40534692d57eaa4072262d765c46e7", "filename": "src/test/compile-fail/feature-gate-negate-unsigned0.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned0.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that negating unsigned integers doesn't compile\n+\n+struct S;\n+impl std::ops::Neg for S {\n+    type Output = u32;\n+    fn neg(self) -> u32 { 0 }\n+}\n+\n+fn main() {\n+    let a = -1;\n+    //~^ ERROR unary negation of unsigned integer\n+    let _b : u8 = a; // for infering variable a to u8.\n+\n+    let _d = -1u8;\n+    //~^ ERROR unary negation of unsigned integer\n+\n+    for _ in -10..10u8 {}\n+    //~^ ERROR unary negation of unsigned integer\n+\n+    -S; // should not trigger the gate; issue 26840\n+}"}, {"sha": "bdf344dcdfe8da8377ba866e99756a1fb1ad3b39", "filename": "src/test/compile-fail/issue-15524.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fissue-15524.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fissue-15524.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15524.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -12,12 +12,12 @@ const N: isize = 1;\n \n enum Foo {\n     A = 1,\n-    B = 1, //~ ERROR discriminant value `1` already exists\n+    B = 1, //~ ERROR discriminant value `1isize` already exists\n     //~^^ NOTE conflicting\n     C = 0,\n-    D, //~ ERROR discriminant value `1` already exists\n+    D, //~ ERROR discriminant value `1isize` already exists\n     //~^^^^^ NOTE conflicting\n-    E = N, //~ ERROR discriminant value `1` already exists\n+    E = N, //~ ERROR discriminant value `1isize` already exists\n     //~^^^^^^^ NOTE conflicting\n }\n "}, {"sha": "fe51d0b69987a5142775be84bf7f3b54364bcac4", "filename": "src/test/compile-fail/issue-8460-const.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -35,23 +35,23 @@ fn main() {\n     assert!(thread::spawn(move|| { 1i64 / 0; }).join().is_err());\n     //~^ ERROR attempted to divide by zero\n     assert!(thread::spawn(move|| { isize::MIN % -1; }).join().is_err());\n-    //~^ ERROR attempted remainder with overflow\n+    //~^ ERROR attempted to calculate the remainder with overflow\n     assert!(thread::spawn(move|| { i8::MIN % -1; }).join().is_err());\n-    //~^ ERROR attempted remainder with overflow\n+    //~^ ERROR attempted to calculate the remainder with overflow\n     assert!(thread::spawn(move|| { i16::MIN % -1; }).join().is_err());\n-    //~^ ERROR attempted remainder with overflow\n+    //~^ ERROR attempted to calculate the remainder with overflow\n     assert!(thread::spawn(move|| { i32::MIN % -1; }).join().is_err());\n-    //~^ ERROR attempted remainder with overflow\n+    //~^ ERROR attempted to calculate the remainder with overflow\n     assert!(thread::spawn(move|| { i64::MIN % -1; }).join().is_err());\n-    //~^ ERROR attempted remainder with overflow\n+    //~^ ERROR attempted to calculate the remainder with overflow\n     assert!(thread::spawn(move|| { 1isize % 0; }).join().is_err());\n-    //~^ ERROR attempted remainder with a divisor of zero\n+    //~^ ERROR attempted to calculate the remainder with a divisor of zero\n     assert!(thread::spawn(move|| { 1i8 % 0; }).join().is_err());\n-    //~^ ERROR attempted remainder with a divisor of zero\n+    //~^ ERROR attempted to calculate the remainder with a divisor of zero\n     assert!(thread::spawn(move|| { 1i16 % 0; }).join().is_err());\n-    //~^ ERROR attempted remainder with a divisor of zero\n+    //~^ ERROR attempted to calculate the remainder with a divisor of zero\n     assert!(thread::spawn(move|| { 1i32 % 0; }).join().is_err());\n-    //~^ ERROR attempted remainder with a divisor of zero\n+    //~^ ERROR attempted to calculate the remainder with a divisor of zero\n     assert!(thread::spawn(move|| { 1i64 % 0; }).join().is_err());\n-    //~^ ERROR attempted remainder with a divisor of zero\n+    //~^ ERROR attempted to calculate the remainder with a divisor of zero\n }"}, {"sha": "1c98abce0304e149f092ea7e0a4137c0cac303d5", "filename": "src/test/compile-fail/issue-8761.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fissue-8761.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Fissue-8761.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8761.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -10,13 +10,13 @@\n \n enum Foo {\n     A = 1i64,\n-    //~^ ERROR mismatched types\n-    //~| expected `isize`\n-    //~| found `i64`\n+    //~^ ERROR mismatched types:\n+    //~| expected `isize`,\n+    //~| found `i64` [E0080]\n     B = 2u8\n-    //~^ ERROR mismatched types\n-    //~| expected `isize`\n-    //~| found `u8`\n+    //~^ ERROR mismatched types:\n+    //~| expected `isize`,\n+    //~| found `u8` [E0080]\n }\n \n fn main() {}"}, {"sha": "29929c120c30f75784f2e4bd67adce7ad37be3e1", "filename": "src/test/compile-fail/lint-type-limits.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Flint-type-limits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Flint-type-limits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-type-limits.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -24,11 +24,6 @@ fn bar() -> i8 {\n     return 123;\n }\n \n-fn baz() -> bool {\n-    128 > bar() //~ ERROR comparison is useless due to type limits\n-                //~^ WARNING literal out of range for i8\n-}\n-\n fn bleh() {\n     let u = 42u8;\n     let _ = u > 255; //~ ERROR comparison is useless due to type limits\n@@ -40,11 +35,3 @@ fn bleh() {\n     let _ = u >= 0; //~ ERROR comparison is useless due to type limits\n     let _ = 0 <= u; //~ ERROR comparison is useless due to type limits\n }\n-\n-fn qux() {\n-    let mut i = 1i8;\n-    while 200 != i { //~ ERROR comparison is useless due to type limits\n-                     //~^ WARNING literal out of range for i8\n-        i += 1;\n-    }\n-}"}, {"sha": "8fc18d16469e37d3356736bff1cccd097005c0dc", "filename": "src/test/compile-fail/lint-type-limits2.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Flint-type-limits2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Flint-type-limits2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-type-limits2.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+// compile-flags: -D unused-comparisons\n+fn main() { }\n+\n+\n+fn bar() -> i8 {\n+    return 123;\n+}\n+\n+fn baz() -> bool {\n+    128 > bar() //~ ERROR comparison is useless due to type limits\n+                //~| WARN literal out of range for i8\n+}"}, {"sha": "b09dc0acdbf91f41e9f50551a6c7f2c8893d7b15", "filename": "src/test/compile-fail/lint-type-limits3.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Flint-type-limits3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Flint-type-limits3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-type-limits3.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+// compile-flags: -D unused-comparisons\n+fn main() { }\n+\n+fn qux() {\n+    let mut i = 1i8;\n+    while 200 != i { //~ ERROR comparison is useless due to type limits\n+                     //~| WARN literal out of range for i8\n+        i += 1;\n+    }\n+}"}, {"sha": "ce336905c0139e77ea5b6fcd9f47b86e09c7188a", "filename": "src/test/compile-fail/lint-type-overflow.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Flint-type-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Flint-type-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-type-overflow.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -25,7 +25,6 @@ fn main() {\n \n     let x2: i8 = -128; // should be OK\n     let x1: i8 = 128; //~ error: literal out of range for i8\n-    let x2: i8 = --128; //~ error: literal out of range for i8\n \n     let x3: i8 = -129; //~ error: literal out of range for i8\n     let x3: i8 = -(129); //~ error: literal out of range for i8\n@@ -54,9 +53,4 @@ fn main() {\n     let x = 18446744073709551615_i64; //~ error: literal out of range for i64\n     let x: i64 = -9223372036854775809; //~ error: literal out of range for i64\n     let x = -9223372036854775809_i64; //~ error: literal out of range for i64\n-\n-    let x = -3.40282348e+38_f32; //~ error: literal out of range for f32\n-    let x =  3.40282348e+38_f32; //~ error: literal out of range for f32\n-    let x = -1.7976931348623159e+308_f64; //~ error: literal out of range for f64\n-    let x =  1.7976931348623159e+308_f64; //~ error: literal out of range for f64\n }"}, {"sha": "83300f18c3e95b6f401f8f506dbd7503dacbaabc", "filename": "src/test/compile-fail/lint-type-overflow2.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Flint-type-overflow2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Flint-type-overflow2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-type-overflow2.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+\n+#![deny(overflowing_literals)]\n+\n+#[allow(unused_variables)]\n+fn main() {\n+    let x2: i8 = --128; //~ error: literal out of range for i8\n+\n+    let x = -3.40282348e+38_f32; //~ error: literal out of range for f32\n+    let x =  3.40282348e+38_f32; //~ error: literal out of range for f32\n+    let x = -1.7976931348623159e+308_f64; //~ error: literal out of range for f64\n+    let x =  1.7976931348623159e+308_f64; //~ error: literal out of range for f64\n+}"}, {"sha": "10b722946a8a89f847c5af45081ee29e40f9470c", "filename": "src/test/compile-fail/repeat_count.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -43,13 +43,17 @@ fn main() {\n     let f = [0; -4_isize];\n     //~^ ERROR mismatched types\n     //~| expected `usize`\n-    //~| found `isize`\n-    //~| ERROR expected positive integer for repeat count, found negative integer [E0306]\n+    //~| found `isize` [E0308]\n+    //~| ERROR mismatched types:\n+    //~| expected `usize`,\n+    //~| found `isize` [E0307]\n     let f = [0_usize; -1_isize];\n     //~^ ERROR mismatched types\n     //~| expected `usize`\n-    //~| found `isize`\n-    //~| ERROR expected positive integer for repeat count, found negative integer [E0306]\n+    //~| found `isize` [E0308]\n+    //~| ERROR mismatched types\n+    //~| expected `usize`\n+    //~| found `isize` [E0307]\n     struct G {\n         g: (),\n     }"}, {"sha": "562040dc5620ba2fc54dea65eb878d5bc6bebcd5", "filename": "src/test/run-pass/const-fn.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Frun-pass%2Fconst-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Frun-pass%2Fconst-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-fn.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -10,7 +10,7 @@\n \n // A very basic test of const fn functionality.\n \n-#![feature(const_fn)]\n+#![feature(const_fn, const_indexing)]\n \n const fn add(x: u32, y: u32) -> u32 {\n     x + y\n@@ -24,6 +24,14 @@ const unsafe fn div(x: u32, y: u32) -> u32 {\n     x / y\n }\n \n+const fn generic<T>(t: T) -> T {\n+    t\n+}\n+\n+const fn generic_arr<T: Copy>(t: [T; 1]) -> T {\n+    t[0]\n+}\n+\n const SUM: u32 = add(44, 22);\n const DIFF: u32 = sub(44, 22);\n const DIV: u32 = unsafe{div(44, 22)};\n@@ -36,4 +44,6 @@ fn main() {\n     assert_eq!(DIV, 2);\n \n     let _: [&'static str; sub(100, 99) as usize] = [\"hi\"];\n+    let _: [&'static str; generic(1)] = [\"hi\"];\n+    let _: [&'static str; generic_arr([1])] = [\"hi\"];\n }"}, {"sha": "96f4217e4cb8023f6c9b6ac4bc9435484a7cb062", "filename": "src/test/run-pass/const-negation.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Frun-pass%2Fconst-negation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Frun-pass%2Fconst-negation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-negation.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(stmt_expr_attributes)]\n+\n+#[deny(const_err)]\n+\n+fn main() {\n+    #[cfg(target_pointer_width = \"32\")]\n+    const I: isize = -2147483648isize;\n+    #[cfg(target_pointer_width = \"64\")]\n+    const I: isize = -9223372036854775808isize;\n+    assert_eq!(::std::i32::MIN as u64, 0xffffffff80000000);\n+    assert_eq!(-2147483648isize as u64, 0xffffffff80000000);\n+    assert_eq!(::std::i64::MIN as u64, 0x8000000000000000);\n+    #[cfg(target_pointer_width = \"64\")]\n+    assert_eq!(-9223372036854775808isize as u64, 0x8000000000000000);\n+    #[cfg(target_pointer_width = \"32\")]\n+    assert_eq!(-9223372036854775808isize as u64, 0);\n+    const J: usize = ::std::i32::MAX as usize;\n+    const K: usize = -1i32 as u32 as usize;\n+    const L: usize = ::std::i32::MIN as usize;\n+    const M: usize = ::std::i64::MIN as usize;\n+    match 5 {\n+        J => {},\n+        K => {},\n+        L => {},\n+        M => {},\n+        _ => {}\n+    }\n+    match 5 {\n+        I => {},\n+        _ => {}\n+    }\n+}"}, {"sha": "53c44f2bb24b5f16ce3eae5d008182fa2ebaba30", "filename": "src/test/run-pass/enum-discrim-autosizing.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Frun-pass%2Fenum-discrim-autosizing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Frun-pass%2Fenum-discrim-autosizing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-discrim-autosizing.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(stmt_expr_attributes)]\n \n use std::mem::size_of;\n \n@@ -46,18 +47,15 @@ enum Ei64 {\n     Bi64 = 0x8000_0000\n }\n \n-enum Eu64 {\n-    Au64 = 0,\n-    Bu64 = 0x8000_0000_0000_0000\n-}\n-\n pub fn main() {\n     assert_eq!(size_of::<Ei8>(), 1);\n     assert_eq!(size_of::<Eu8>(), 1);\n     assert_eq!(size_of::<Ei16>(), 2);\n     assert_eq!(size_of::<Eu16>(), 2);\n     assert_eq!(size_of::<Ei32>(), 4);\n     assert_eq!(size_of::<Eu32>(), 4);\n+    #[cfg(target_pointer_width = \"64\")]\n     assert_eq!(size_of::<Ei64>(), 8);\n-    assert_eq!(size_of::<Eu64>(), 8);\n+    #[cfg(target_pointer_width = \"32\")]\n+    assert_eq!(size_of::<Ei64>(), 4);\n }"}, {"sha": "7d63c41eb26e1215b00d9206bef0c4d07332b9ec", "filename": "src/test/run-pass/issue-23833.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Frun-pass%2Fissue-23833.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01118928fc2b280e96189ed394af749d65cbcffe/src%2Ftest%2Frun-pass%2Fissue-23833.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23833.rs?ref=01118928fc2b280e96189ed394af749d65cbcffe", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt;\n+use std::{i8, i16, i32, i64, isize};\n+use std::{u8, u16, u32, u64, usize};\n+\n+const A_I8_T\n+    : [u32; (i8::MAX as i8 - 1i8) as usize]\n+    = [0; (i8::MAX as usize) - 1];\n+\n+fn main() {\n+    foo(&A_I8_T[..]);\n+}\n+\n+fn foo<T:fmt::Debug>(x: T) {\n+    println!(\"{:?}\", x);\n+}"}]}