{"sha": "b80cb47889e0ad9400b6708ce2b4c4b364b71982", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4MGNiNDc4ODllMGFkOTQwMGI2NzA4Y2UyYjRjNGIzNjRiNzE5ODI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-18T03:52:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-18T03:52:39Z"}, "message": "Auto merge of #54286 - nnethercote:BitSet, r=pnkfelix\n\nMerge `bitvec.rs` and `indexed_set.rs`\n\nBecause it's not good to have two separate implementations. Also, I will combine the best parts of each to improve NLL memory usage on some benchmarks significantly.", "tree": {"sha": "ca70c0600050ce729db297996e4b4a701c0dcaad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca70c0600050ce729db297996e4b4a701c0dcaad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b80cb47889e0ad9400b6708ce2b4c4b364b71982", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b80cb47889e0ad9400b6708ce2b4c4b364b71982", "html_url": "https://github.com/rust-lang/rust/commit/b80cb47889e0ad9400b6708ce2b4c4b364b71982", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b80cb47889e0ad9400b6708ce2b4c4b364b71982/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2224a42c353636db6ee53cc3f9b1a968e9d9c1f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2224a42c353636db6ee53cc3f9b1a968e9d9c1f6", "html_url": "https://github.com/rust-lang/rust/commit/2224a42c353636db6ee53cc3f9b1a968e9d9c1f6"}, {"sha": "53589b7e4ea36927f2f58c30a23df427f3560f06", "url": "https://api.github.com/repos/rust-lang/rust/commits/53589b7e4ea36927f2f58c30a23df427f3560f06", "html_url": "https://github.com/rust-lang/rust/commit/53589b7e4ea36927f2f58c30a23df427f3560f06"}], "stats": {"total": 2683, "additions": 1279, "deletions": 1404}, "files": [{"sha": "db1bc3e7519c290e1304e77bbef013b48b031a25", "filename": "src/librustc/mir/traversal.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftraversal.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc_data_structures::bitvec::BitArray;\n+use rustc_data_structures::bit_set::BitSet;\n \n use super::*;\n \n@@ -32,7 +32,7 @@ use super::*;\n #[derive(Clone)]\n pub struct Preorder<'a, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n-    visited: BitArray<BasicBlock>,\n+    visited: BitSet<BasicBlock>,\n     worklist: Vec<BasicBlock>,\n }\n \n@@ -42,7 +42,7 @@ impl<'a, 'tcx> Preorder<'a, 'tcx> {\n \n         Preorder {\n             mir,\n-            visited: BitArray::new(mir.basic_blocks().len()),\n+            visited: BitSet::new_empty(mir.basic_blocks().len()),\n             worklist,\n         }\n     }\n@@ -104,15 +104,15 @@ impl<'a, 'tcx> ExactSizeIterator for Preorder<'a, 'tcx> {}\n /// A Postorder traversal of this graph is `D B C A` or `D C B A`\n pub struct Postorder<'a, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n-    visited: BitArray<BasicBlock>,\n+    visited: BitSet<BasicBlock>,\n     visit_stack: Vec<(BasicBlock, Successors<'a>)>\n }\n \n impl<'a, 'tcx> Postorder<'a, 'tcx> {\n     pub fn new(mir: &'a Mir<'tcx>, root: BasicBlock) -> Postorder<'a, 'tcx> {\n         let mut po = Postorder {\n             mir,\n-            visited: BitArray::new(mir.basic_blocks().len()),\n+            visited: BitSet::new_empty(mir.basic_blocks().len()),\n             visit_stack: Vec::new()\n         };\n "}, {"sha": "85e7368bfdd1042f04b5be0e86804920081e1f7c", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -44,8 +44,8 @@ use ty::relate::TypeRelation;\n use middle::lang_items;\n use mir::interpret::{GlobalId};\n \n+use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::sync::Lock;\n-use rustc_data_structures::bitvec::BitArray;\n use std::iter;\n use std::cmp;\n use std::fmt;\n@@ -3069,7 +3069,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 } else {\n                     return Err(Unimplemented);\n                 };\n-                let mut ty_params = BitArray::new(substs_a.types().count());\n+                let mut ty_params = BitSet::new_empty(substs_a.types().count());\n                 let mut found = false;\n                 for ty in field.walk() {\n                     if let ty::Param(p) = ty.sty {"}, {"sha": "79c7e517273fc72c6764ba16303abeda4417beb4", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -49,14 +49,14 @@ use util::nodemap::{DefIdSet, DefIdMap, ItemLocalSet};\n use util::common::{ErrorReported};\n use util::profiling::ProfileCategory::*;\n \n-use rustc_data_structures::indexed_set::IdxSet;\n-use rustc_target::spec::PanicStrategy;\n+use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stable_hasher::StableVec;\n+use rustc_data_structures::sync::Lrc;\n+use rustc_target::spec::PanicStrategy;\n \n use std::ops::Deref;\n-use rustc_data_structures::sync::Lrc;\n use std::sync::Arc;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax_pos::symbol::InternedString;\n@@ -208,7 +208,7 @@ define_queries! { <'tcx>\n         /// Maps DefId's that have an associated Mir to the result\n         /// of the MIR qualify_consts pass. The actual meaning of\n         /// the value isn't known except to the pass itself.\n-        [] fn mir_const_qualif: MirConstQualif(DefId) -> (u8, Lrc<IdxSet<mir::Local>>),\n+        [] fn mir_const_qualif: MirConstQualif(DefId) -> (u8, Lrc<BitSet<mir::Local>>),\n \n         /// Fetch the MIR for a given def-id right after it's built - this includes\n         /// unreachable code."}, {"sha": "0484837a48d7debbdd0641afbdaa9c1c35351dc1", "filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -21,7 +21,7 @@ use libc::c_uint;\n \n use syntax_pos::Pos;\n \n-use rustc_data_structures::bitvec::BitArray;\n+use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n use syntax_pos::BytePos;\n@@ -64,7 +64,7 @@ pub fn create_mir_scopes(\n     };\n \n     // Find all the scopes with variables defined in them.\n-    let mut has_variables = BitArray::new(mir.source_scopes.len());\n+    let mut has_variables = BitSet::new_empty(mir.source_scopes.len());\n     for var in mir.vars_iter() {\n         let decl = &mir.local_decls[var];\n         has_variables.insert(decl.visibility_scope);\n@@ -81,7 +81,7 @@ pub fn create_mir_scopes(\n \n fn make_mir_scope(cx: &CodegenCx<'ll, '_>,\n                   mir: &Mir,\n-                  has_variables: &BitArray<SourceScope>,\n+                  has_variables: &BitSet<SourceScope>,\n                   debug_context: &FunctionDebugContextData<'ll>,\n                   scope: SourceScope,\n                   scopes: &mut IndexVec<SourceScope, MirDebugScope<'ll>>) {"}, {"sha": "c3e3785a724a2a7273f5b0f348f0aa7f7c2d8a4f", "filename": "src/librustc_codegen_llvm/mir/analyze.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -11,7 +11,7 @@\n //! An analysis to determine which locals require allocas and\n //! which do not.\n \n-use rustc_data_structures::bitvec::BitArray;\n+use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::mir::{self, Location, TerminatorKind};\n@@ -22,7 +22,7 @@ use rustc::ty::layout::LayoutOf;\n use type_of::LayoutLlvmExt;\n use super::FunctionCx;\n \n-pub fn non_ssa_locals(fx: &FunctionCx<'a, 'll, 'tcx>) -> BitArray<mir::Local> {\n+pub fn non_ssa_locals(fx: &FunctionCx<'a, 'll, 'tcx>) -> BitSet<mir::Local> {\n     let mir = fx.mir;\n     let mut analyzer = LocalAnalyzer::new(fx);\n \n@@ -54,7 +54,7 @@ pub fn non_ssa_locals(fx: &FunctionCx<'a, 'll, 'tcx>) -> BitArray<mir::Local> {\n struct LocalAnalyzer<'mir, 'a: 'mir, 'll: 'a, 'tcx: 'll> {\n     fx: &'mir FunctionCx<'a, 'll, 'tcx>,\n     dominators: Dominators<mir::BasicBlock>,\n-    non_ssa_locals: BitArray<mir::Local>,\n+    non_ssa_locals: BitSet<mir::Local>,\n     // The location of the first visited direct assignment to each\n     // local, or an invalid location (out of bounds `block` index).\n     first_assignment: IndexVec<mir::Local, Location>\n@@ -67,7 +67,7 @@ impl LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n         let mut analyzer = LocalAnalyzer {\n             fx,\n             dominators: fx.mir.dominators(),\n-            non_ssa_locals: BitArray::new(fx.mir.local_decls.len()),\n+            non_ssa_locals: BitSet::new_empty(fx.mir.local_decls.len()),\n             first_assignment: IndexVec::from_elem(invalid_location, &fx.mir.local_decls)\n         };\n "}, {"sha": "c61a326e7c83937421f335ba169e0236f25d7136", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -31,7 +31,7 @@ use syntax::symbol::keywords;\n \n use std::iter;\n \n-use rustc_data_structures::bitvec::BitArray;\n+use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n \n pub use self::constant::codegen_static_initializer;\n@@ -341,7 +341,7 @@ pub fn codegen_mir(\n     debuginfo::start_emitting_source_locations(&fx.debug_context);\n \n     let rpo = traversal::reverse_postorder(&mir);\n-    let mut visited = BitArray::new(mir.basic_blocks().len());\n+    let mut visited = BitSet::new_empty(mir.basic_blocks().len());\n \n     // Codegen the body of each block using reverse postorder\n     for (bb, _) in rpo {\n@@ -435,7 +435,7 @@ fn arg_local_refs(\n     bx: &Builder<'a, 'll, 'tcx>,\n     fx: &FunctionCx<'a, 'll, 'tcx>,\n     scopes: &IndexVec<mir::SourceScope, debuginfo::MirDebugScope<'ll>>,\n-    memory_locals: &BitArray<mir::Local>,\n+    memory_locals: &BitSet<mir::Local>,\n ) -> Vec<LocalRef<'ll, 'tcx>> {\n     let mir = fx.mir;\n     let tcx = bx.tcx();"}, {"sha": "b1fb475bce9028449c470f5a7284684cdfa961b8", "filename": "src/librustc_data_structures/bit_set.rs", "status": "added", "additions": 1024, "deletions": 0, "changes": 1024, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_data_structures%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_data_structures%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbit_set.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -0,0 +1,1024 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use array_vec::ArrayVec;\n+use indexed_vec::{Idx, IndexVec};\n+use rustc_serialize;\n+use std::fmt;\n+use std::iter;\n+use std::marker::PhantomData;\n+use std::mem;\n+use std::slice;\n+\n+pub type Word = u64;\n+pub const WORD_BYTES: usize = mem::size_of::<Word>();\n+pub const WORD_BITS: usize = WORD_BYTES * 8;\n+\n+/// A fixed-size bitset type with a dense representation. It does not support\n+/// resizing after creation; use `GrowableBitSet` for that.\n+///\n+/// `T` is an index type, typically a newtyped `usize` wrapper, but it can also\n+/// just be `usize`.\n+#[derive(Clone, Eq, PartialEq)]\n+pub struct BitSet<T: Idx> {\n+    words: Vec<Word>,\n+    marker: PhantomData<T>,\n+}\n+\n+impl<T: Idx> BitSet<T> {\n+    #[inline]\n+    pub fn new_empty(domain_size: usize) -> BitSet<T> {\n+        let num_words = num_words(domain_size);\n+        BitSet {\n+            words: vec![0; num_words],\n+            marker: PhantomData,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn new_filled(domain_size: usize) -> BitSet<T> {\n+        let num_words = num_words(domain_size);\n+        let mut result = BitSet {\n+            words: vec![!0; num_words],\n+            marker: PhantomData,\n+        };\n+        result.clear_above(domain_size);\n+        result\n+    }\n+\n+    #[inline]\n+    pub fn clear(&mut self) {\n+        for word in &mut self.words {\n+            *word = 0;\n+        }\n+    }\n+\n+    /// Sets all elements up to and including `size`.\n+    pub fn set_up_to(&mut self, bit: usize) {\n+        for word in &mut self.words {\n+            *word = !0;\n+        }\n+        self.clear_above(bit);\n+    }\n+\n+    /// Clear all elements above `bit`.\n+    fn clear_above(&mut self, bit: usize) {\n+        let first_clear_block = bit / WORD_BITS;\n+\n+        if first_clear_block < self.words.len() {\n+            // Within `first_clear_block`, the `bit % WORD_BITS` LSBs should\n+            // remain.\n+            let mask = (1 << (bit % WORD_BITS)) - 1;\n+            self.words[first_clear_block] &= mask;\n+\n+            // All the blocks above `first_clear_block` are fully cleared.\n+            for word in &mut self.words[first_clear_block + 1..] {\n+                *word = 0;\n+            }\n+        }\n+    }\n+\n+    /// Efficiently overwrite `self` with `other`. Panics if `self` and `other`\n+    /// don't have the same length.\n+    pub fn overwrite(&mut self, other: &BitSet<T>) {\n+        self.words.clone_from_slice(&other.words);\n+    }\n+\n+    /// Count the number of set bits in the set.\n+    pub fn count(&self) -> usize {\n+        self.words.iter().map(|e| e.count_ones() as usize).sum()\n+    }\n+\n+    /// True if `self` contains the bit `bit`.\n+    #[inline]\n+    pub fn contains(&self, bit: T) -> bool {\n+        let (word_index, mask) = word_index_and_mask(bit);\n+        (self.words[word_index] & mask) != 0\n+    }\n+\n+    /// True if `self` is a (non-strict) superset of `other`.\n+    ///\n+    /// The two sets must have the same domain_size.\n+    #[inline]\n+    pub fn superset(&self, other: &BitSet<T>) -> bool {\n+        assert_eq!(self.words.len(), other.words.len());\n+        self.words.iter().zip(&other.words).all(|(a, b)| (a & b) == *b)\n+    }\n+\n+    /// Is the set empty?\n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.words.iter().all(|a| *a == 0)\n+    }\n+\n+    /// Insert a bit. Returns true if the bit has changed.\n+    #[inline]\n+    pub fn insert(&mut self, bit: T) -> bool {\n+        let (word_index, mask) = word_index_and_mask(bit);\n+        let word_ref = &mut self.words[word_index];\n+        let word = *word_ref;\n+        let new_word = word | mask;\n+        *word_ref = new_word;\n+        new_word != word\n+    }\n+\n+    /// Sets all bits to true.\n+    pub fn insert_all(&mut self) {\n+        for word in &mut self.words {\n+            *word = !0;\n+        }\n+    }\n+\n+    /// Returns true if the bit has changed.\n+    #[inline]\n+    pub fn remove(&mut self, bit: T) -> bool {\n+        let (word_index, mask) = word_index_and_mask(bit);\n+        let word_ref = &mut self.words[word_index];\n+        let word = *word_ref;\n+        let new_word = word & !mask;\n+        *word_ref = new_word;\n+        new_word != word\n+    }\n+\n+    /// Set `self = self | other` and return true if `self` changed\n+    /// (i.e., if new bits were added).\n+    pub fn union(&mut self, other: &impl UnionIntoBitSet<T>) -> bool {\n+        other.union_into(self)\n+    }\n+\n+    /// Set `self = self - other` and return true if `self` changed.\n+    /// (i.e., if any bits were removed).\n+    pub fn subtract(&mut self, other: &impl SubtractFromBitSet<T>) -> bool {\n+        other.subtract_from(self)\n+    }\n+\n+    /// Set `self = self & other` and return true if `self` changed.\n+    /// (i.e., if any bits were removed).\n+    pub fn intersect(&mut self, other: &BitSet<T>) -> bool {\n+        bitwise(&mut self.words, &other.words, |a, b| { a & b })\n+    }\n+\n+    /// Get a slice of the underlying words.\n+    pub fn words(&self) -> &[Word] {\n+        &self.words\n+    }\n+\n+    /// Iterates over the indices of set bits in a sorted order.\n+    #[inline]\n+    pub fn iter<'a>(&'a self) -> BitIter<'a, T> {\n+        BitIter {\n+            cur: None,\n+            iter: self.words.iter().enumerate(),\n+            marker: PhantomData,\n+        }\n+    }\n+\n+    /// Duplicates the set as a hybrid set.\n+    pub fn to_hybrid(&self) -> HybridBitSet<T> {\n+        // This domain_size may be slightly larger than the one specified\n+        // upon creation, due to rounding up to a whole word. That's ok.\n+        let domain_size = self.words.len() * WORD_BITS;\n+\n+        // Note: we currently don't bother trying to make a Sparse set.\n+        HybridBitSet::Dense(self.to_owned(), domain_size)\n+    }\n+\n+    pub fn to_string(&self, bits: usize) -> String {\n+        let mut result = String::new();\n+        let mut sep = '[';\n+\n+        // Note: this is a little endian printout of bytes.\n+\n+        // i tracks how many bits we have printed so far.\n+        let mut i = 0;\n+        for word in &self.words {\n+            let mut word = *word;\n+            for _ in 0..WORD_BYTES { // for each byte in `word`:\n+                let remain = bits - i;\n+                // If less than a byte remains, then mask just that many bits.\n+                let mask = if remain <= 8 { (1 << remain) - 1 } else { 0xFF };\n+                assert!(mask <= 0xFF);\n+                let byte = word & mask;\n+\n+                result.push_str(&format!(\"{}{:02x}\", sep, byte));\n+\n+                if remain <= 8 { break; }\n+                word >>= 8;\n+                i += 8;\n+                sep = '-';\n+            }\n+            sep = '|';\n+        }\n+        result.push(']');\n+\n+        result\n+    }\n+}\n+\n+/// This is implemented by all the bitsets so that BitSet::union() can be\n+/// passed any type of bitset.\n+pub trait UnionIntoBitSet<T: Idx> {\n+    // Performs `other = other | self`.\n+    fn union_into(&self, other: &mut BitSet<T>) -> bool;\n+}\n+\n+/// This is implemented by all the bitsets so that BitSet::subtract() can be\n+/// passed any type of bitset.\n+pub trait SubtractFromBitSet<T: Idx> {\n+    // Performs `other = other - self`.\n+    fn subtract_from(&self, other: &mut BitSet<T>) -> bool;\n+}\n+\n+impl<T: Idx> UnionIntoBitSet<T> for BitSet<T> {\n+    fn union_into(&self, other: &mut BitSet<T>) -> bool {\n+        bitwise(&mut other.words, &self.words, |a, b| { a | b })\n+    }\n+}\n+\n+impl<T: Idx> SubtractFromBitSet<T> for BitSet<T> {\n+    fn subtract_from(&self, other: &mut BitSet<T>) -> bool {\n+        bitwise(&mut other.words, &self.words, |a, b| { a & !b })\n+    }\n+}\n+\n+impl<T: Idx> fmt::Debug for BitSet<T> {\n+    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n+        w.debug_list()\n+         .entries(self.iter())\n+         .finish()\n+    }\n+}\n+\n+impl<T: Idx> rustc_serialize::Encodable for BitSet<T> {\n+    fn encode<E: rustc_serialize::Encoder>(&self, encoder: &mut E) -> Result<(), E::Error> {\n+        self.words.encode(encoder)\n+    }\n+}\n+\n+impl<T: Idx> rustc_serialize::Decodable for BitSet<T> {\n+    fn decode<D: rustc_serialize::Decoder>(d: &mut D) -> Result<BitSet<T>, D::Error> {\n+        let words: Vec<Word> = rustc_serialize::Decodable::decode(d)?;\n+        Ok(BitSet {\n+            words,\n+            marker: PhantomData,\n+        })\n+    }\n+}\n+\n+pub struct BitIter<'a, T: Idx> {\n+    cur: Option<(Word, usize)>,\n+    iter: iter::Enumerate<slice::Iter<'a, Word>>,\n+    marker: PhantomData<T>\n+}\n+\n+impl<'a, T: Idx> Iterator for BitIter<'a, T> {\n+    type Item = T;\n+    fn next(&mut self) -> Option<T> {\n+        loop {\n+            if let Some((ref mut word, offset)) = self.cur {\n+                let bit_pos = word.trailing_zeros() as usize;\n+                if bit_pos != WORD_BITS {\n+                    let bit = 1 << bit_pos;\n+                    *word ^= bit;\n+                    return Some(T::new(bit_pos + offset))\n+                }\n+            }\n+\n+            let (i, word) = self.iter.next()?;\n+            self.cur = Some((*word, WORD_BITS * i));\n+        }\n+    }\n+}\n+\n+pub trait BitSetOperator {\n+    /// Combine one bitset into another.\n+    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool;\n+}\n+\n+#[inline]\n+fn bitwise<Op>(out_vec: &mut [Word], in_vec: &[Word], op: Op) -> bool\n+    where Op: Fn(Word, Word) -> Word\n+{\n+    assert_eq!(out_vec.len(), in_vec.len());\n+    let mut changed = false;\n+    for (out_elem, in_elem) in out_vec.iter_mut().zip(in_vec.iter()) {\n+        let old_val = *out_elem;\n+        let new_val = op(old_val, *in_elem);\n+        *out_elem = new_val;\n+        changed |= old_val != new_val;\n+    }\n+    changed\n+}\n+\n+const SPARSE_MAX: usize = 8;\n+\n+/// A fixed-size bitset type with a sparse representation and a maximum of\n+/// SPARSE_MAX elements. The elements are stored as an unsorted vector with no\n+/// duplicates.\n+///\n+/// This type is used by HybridBitSet; do not use directly.\n+#[derive(Clone, Debug)]\n+pub struct SparseBitSet<T: Idx>(ArrayVec<[T; SPARSE_MAX]>);\n+\n+impl<T: Idx> SparseBitSet<T> {\n+    fn new_empty() -> Self {\n+        SparseBitSet(ArrayVec::new())\n+    }\n+\n+    fn len(&self) -> usize {\n+        self.0.len()\n+    }\n+\n+    fn contains(&self, elem: T) -> bool {\n+        self.0.contains(&elem)\n+    }\n+\n+    fn insert(&mut self, elem: T) -> bool {\n+        // Ensure there are no duplicates.\n+        if self.0.contains(&elem) {\n+            false\n+        } else {\n+            self.0.push(elem);\n+            true\n+        }\n+    }\n+\n+    fn remove(&mut self, elem: T) -> bool {\n+        if let Some(i) = self.0.iter().position(|&e| e == elem) {\n+            // Swap the found element to the end, then pop it.\n+            let len = self.0.len();\n+            self.0.swap(i, len - 1);\n+            self.0.pop();\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn to_dense(&self, domain_size: usize) -> BitSet<T> {\n+        let mut dense = BitSet::new_empty(domain_size);\n+        for elem in self.0.iter() {\n+            dense.insert(*elem);\n+        }\n+        dense\n+    }\n+\n+    fn iter(&self) -> slice::Iter<T> {\n+        self.0.iter()\n+    }\n+}\n+\n+impl<T: Idx> UnionIntoBitSet<T> for SparseBitSet<T> {\n+    fn union_into(&self, other: &mut BitSet<T>) -> bool {\n+        let mut changed = false;\n+        for elem in self.iter() {\n+            changed |= other.insert(*elem);\n+        }\n+        changed\n+    }\n+}\n+\n+impl<T: Idx> SubtractFromBitSet<T> for SparseBitSet<T> {\n+    fn subtract_from(&self, other: &mut BitSet<T>) -> bool {\n+        let mut changed = false;\n+        for elem in self.iter() {\n+            changed |= other.remove(*elem);\n+        }\n+        changed\n+    }\n+}\n+\n+/// A fixed-size bitset type with a hybrid representation: sparse when there\n+/// are up to a SPARSE_MAX elements in the set, but dense when there are more\n+/// than SPARSE_MAX.\n+///\n+/// This type is especially efficient for sets that typically have a small\n+/// number of elements, but a large `domain_size`, and are cleared frequently.\n+///\n+/// `T` is an index type, typically a newtyped `usize` wrapper, but it can also\n+/// just be `usize`.\n+#[derive(Clone, Debug)]\n+pub enum HybridBitSet<T: Idx> {\n+    Sparse(SparseBitSet<T>, usize),\n+    Dense(BitSet<T>, usize),\n+}\n+\n+impl<T: Idx> HybridBitSet<T> {\n+    pub fn new_empty(domain_size: usize) -> Self {\n+        HybridBitSet::Sparse(SparseBitSet::new_empty(), domain_size)\n+    }\n+\n+    pub fn clear(&mut self) {\n+        let domain_size = match *self {\n+            HybridBitSet::Sparse(_, size) => size,\n+            HybridBitSet::Dense(_, size) => size,\n+        };\n+        *self = HybridBitSet::new_empty(domain_size);\n+    }\n+\n+    pub fn contains(&self, elem: T) -> bool {\n+        match self {\n+            HybridBitSet::Sparse(sparse, _) => sparse.contains(elem),\n+            HybridBitSet::Dense(dense, _) => dense.contains(elem),\n+        }\n+    }\n+\n+    pub fn insert(&mut self, elem: T) -> bool {\n+        match self {\n+            HybridBitSet::Sparse(sparse, _) if sparse.len() < SPARSE_MAX => {\n+                // The set is sparse and has space for `elem`.\n+                sparse.insert(elem)\n+            }\n+            HybridBitSet::Sparse(sparse, _) if sparse.contains(elem) => {\n+                // The set is sparse and does not have space for `elem`, but\n+                // that doesn't matter because `elem` is already present.\n+                false\n+            }\n+            HybridBitSet::Sparse(_, _) => {\n+                // The set is sparse and full. Convert to a dense set.\n+                //\n+                // FIXME: This code is awful, but I can't work out how else to\n+                //        appease the borrow checker.\n+                let dummy = HybridBitSet::Sparse(SparseBitSet::new_empty(), 0);\n+                match mem::replace(self, dummy) {\n+                    HybridBitSet::Sparse(sparse, domain_size) => {\n+                        let mut dense = sparse.to_dense(domain_size);\n+                        let changed = dense.insert(elem);\n+                        assert!(changed);\n+                        mem::replace(self, HybridBitSet::Dense(dense, domain_size));\n+                        changed\n+                    }\n+                    _ => panic!(\"impossible\"),\n+                }\n+            }\n+\n+            HybridBitSet::Dense(dense, _) => dense.insert(elem),\n+        }\n+    }\n+\n+    pub fn remove(&mut self, elem: T) -> bool {\n+        // Note: we currently don't bother going from Dense back to Sparse.\n+        match self {\n+            HybridBitSet::Sparse(sparse, _) => sparse.remove(elem),\n+            HybridBitSet::Dense(dense, _) => dense.remove(elem),\n+        }\n+    }\n+\n+    /// Converts to a dense set, consuming itself in the process.\n+    pub fn to_dense(self) -> BitSet<T> {\n+        match self {\n+            HybridBitSet::Sparse(sparse, domain_size) => sparse.to_dense(domain_size),\n+            HybridBitSet::Dense(dense, _) => dense,\n+        }\n+    }\n+\n+    /// Iteration order is unspecified.\n+    pub fn iter(&self) -> HybridIter<T> {\n+        match self {\n+            HybridBitSet::Sparse(sparse, _) => HybridIter::Sparse(sparse.iter()),\n+            HybridBitSet::Dense(dense, _) => HybridIter::Dense(dense.iter()),\n+        }\n+    }\n+}\n+\n+impl<T: Idx> UnionIntoBitSet<T> for HybridBitSet<T> {\n+    fn union_into(&self, other: &mut BitSet<T>) -> bool {\n+        match self {\n+            HybridBitSet::Sparse(sparse, _) => sparse.union_into(other),\n+            HybridBitSet::Dense(dense, _) => dense.union_into(other),\n+        }\n+    }\n+}\n+\n+impl<T: Idx> SubtractFromBitSet<T> for HybridBitSet<T> {\n+    fn subtract_from(&self, other: &mut BitSet<T>) -> bool {\n+        match self {\n+            HybridBitSet::Sparse(sparse, _) => sparse.subtract_from(other),\n+            HybridBitSet::Dense(dense, _) => dense.subtract_from(other),\n+        }\n+    }\n+}\n+\n+pub enum HybridIter<'a, T: Idx> {\n+    Sparse(slice::Iter<'a, T>),\n+    Dense(BitIter<'a, T>),\n+}\n+\n+impl<'a, T: Idx> Iterator for HybridIter<'a, T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        match self {\n+            HybridIter::Sparse(sparse) => sparse.next().map(|e| *e),\n+            HybridIter::Dense(dense) => dense.next(),\n+        }\n+    }\n+}\n+\n+/// A resizable bitset type with a dense representation.\n+///\n+/// `T` is an index type, typically a newtyped `usize` wrapper, but it can also\n+/// just be `usize`.\n+#[derive(Clone, Debug, PartialEq)]\n+pub struct GrowableBitSet<T: Idx> {\n+    bit_set: BitSet<T>,\n+}\n+\n+impl<T: Idx> GrowableBitSet<T> {\n+    pub fn grow(&mut self, domain_size: T) {\n+        let num_words = num_words(domain_size);\n+        if self.bit_set.words.len() <= num_words {\n+            self.bit_set.words.resize(num_words + 1, 0)\n+        }\n+    }\n+\n+    pub fn new_empty() -> GrowableBitSet<T> {\n+        GrowableBitSet { bit_set: BitSet::new_empty(0) }\n+    }\n+\n+    pub fn with_capacity(bits: usize) -> GrowableBitSet<T> {\n+        GrowableBitSet { bit_set: BitSet::new_empty(bits) }\n+    }\n+\n+    /// Returns true if the bit has changed.\n+    #[inline]\n+    pub fn insert(&mut self, bit: T) -> bool {\n+        self.grow(bit);\n+        self.bit_set.insert(bit)\n+    }\n+\n+    #[inline]\n+    pub fn contains(&self, bit: T) -> bool {\n+        let (word_index, mask) = word_index_and_mask(bit);\n+        if let Some(word) = self.bit_set.words.get(word_index) {\n+            (word & mask) != 0\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+/// A fixed-size 2D bit matrix type with a dense representation.\n+///\n+/// `R` and `C` are index types used to identify rows and columns respectively;\n+/// typically newtyped `usize` wrappers, but they can also just be `usize`.\n+///\n+#[derive(Clone, Debug)]\n+pub struct BitMatrix<R: Idx, C: Idx> {\n+    columns: usize,\n+    words: Vec<Word>,\n+    marker: PhantomData<(R, C)>,\n+}\n+\n+impl<R: Idx, C: Idx> BitMatrix<R, C> {\n+    /// Create a new `rows x columns` matrix, initially empty.\n+    pub fn new(rows: usize, columns: usize) -> BitMatrix<R, C> {\n+        // For every element, we need one bit for every other\n+        // element. Round up to an even number of words.\n+        let words_per_row = num_words(columns);\n+        BitMatrix {\n+            columns,\n+            words: vec![0; rows * words_per_row],\n+            marker: PhantomData,\n+        }\n+    }\n+\n+    /// The range of bits for a given row.\n+    fn range(&self, row: R) -> (usize, usize) {\n+        let row = row.index();\n+        let words_per_row = num_words(self.columns);\n+        let start = row * words_per_row;\n+        (start, start + words_per_row)\n+    }\n+\n+    /// Sets the cell at `(row, column)` to true. Put another way, insert\n+    /// `column` to the bitset for `row`.\n+    ///\n+    /// Returns true if this changed the matrix, and false otherwise.\n+    pub fn insert(&mut self, row: R, column: R) -> bool {\n+        let (start, _) = self.range(row);\n+        let (word_index, mask) = word_index_and_mask(column);\n+        let words = &mut self.words[..];\n+        let word = words[start + word_index];\n+        let new_word = word | mask;\n+        words[start + word_index] = new_word;\n+        word != new_word\n+    }\n+\n+    /// Do the bits from `row` contain `column`? Put another way, is\n+    /// the matrix cell at `(row, column)` true?  Put yet another way,\n+    /// if the matrix represents (transitive) reachability, can\n+    /// `row` reach `column`?\n+    pub fn contains(&self, row: R, column: R) -> bool {\n+        let (start, _) = self.range(row);\n+        let (word_index, mask) = word_index_and_mask(column);\n+        (self.words[start + word_index] & mask) != 0\n+    }\n+\n+    /// Returns those indices that are true in rows `a` and `b`.  This\n+    /// is an O(n) operation where `n` is the number of elements\n+    /// (somewhat independent from the actual size of the\n+    /// intersection, in particular).\n+    pub fn intersect_rows(&self, a: R, b: R) -> Vec<C> {\n+        let (a_start, a_end) = self.range(a);\n+        let (b_start, b_end) = self.range(b);\n+        let mut result = Vec::with_capacity(self.columns);\n+        for (base, (i, j)) in (a_start..a_end).zip(b_start..b_end).enumerate() {\n+            let mut v = self.words[i] & self.words[j];\n+            for bit in 0..WORD_BITS {\n+                if v == 0 {\n+                    break;\n+                }\n+                if v & 0x1 != 0 {\n+                    result.push(C::new(base * WORD_BITS + bit));\n+                }\n+                v >>= 1;\n+            }\n+        }\n+        result\n+    }\n+\n+    /// Add the bits from row `read` to the bits from row `write`,\n+    /// return true if anything changed.\n+    ///\n+    /// This is used when computing transitive reachability because if\n+    /// you have an edge `write -> read`, because in that case\n+    /// `write` can reach everything that `read` can (and\n+    /// potentially more).\n+    pub fn union_rows(&mut self, read: R, write: R) -> bool {\n+        let (read_start, read_end) = self.range(read);\n+        let (write_start, write_end) = self.range(write);\n+        let words = &mut self.words[..];\n+        let mut changed = false;\n+        for (read_index, write_index) in (read_start..read_end).zip(write_start..write_end) {\n+            let word = words[write_index];\n+            let new_word = word | words[read_index];\n+            words[write_index] = new_word;\n+            changed |= word != new_word;\n+        }\n+        changed\n+    }\n+\n+    /// Iterates through all the columns set to true in a given row of\n+    /// the matrix.\n+    pub fn iter<'a>(&'a self, row: R) -> BitIter<'a, C> {\n+        let (start, end) = self.range(row);\n+        BitIter {\n+            cur: None,\n+            iter: self.words[start..end].iter().enumerate(),\n+            marker: PhantomData,\n+        }\n+    }\n+}\n+\n+/// A fixed-column-size, variable-row-size 2D bit matrix with a moderately\n+/// sparse representation.\n+///\n+/// Initially, every row has no explicit representation. If any bit within a\n+/// row is set, the entire row is instantiated as\n+/// `Some(<full-column-width-BitSet>)`. Furthermore, any previously\n+/// uninstantiated rows prior to it will be instantiated as `None`. Those prior\n+/// rows may themselves become fully instantiated later on if any of their bits\n+/// are set.\n+///\n+/// `R` and `C` are index types used to identify rows and columns respectively;\n+/// typically newtyped `usize` wrappers, but they can also just be `usize`.\n+#[derive(Clone, Debug)]\n+pub struct SparseBitMatrix<R, C>\n+where\n+    R: Idx,\n+    C: Idx,\n+{\n+    num_columns: usize,\n+    rows: IndexVec<R, Option<BitSet<C>>>,\n+}\n+\n+impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n+    /// Create a new empty sparse bit matrix with no rows or columns.\n+    pub fn new(num_columns: usize) -> Self {\n+        Self {\n+            num_columns,\n+            rows: IndexVec::new(),\n+        }\n+    }\n+\n+    fn ensure_row(&mut self, row: R) -> &mut BitSet<C> {\n+        // Instantiate any missing rows up to and including row `row` with an\n+        // empty BitSet.\n+        self.rows.ensure_contains_elem(row, || None);\n+\n+        // Then replace row `row` with a full BitSet if necessary.\n+        let num_columns = self.num_columns;\n+        self.rows[row].get_or_insert_with(|| BitSet::new_empty(num_columns))\n+    }\n+\n+    /// Sets the cell at `(row, column)` to true. Put another way, insert\n+    /// `column` to the bitset for `row`.\n+    ///\n+    /// Returns true if this changed the matrix, and false otherwise.\n+    pub fn insert(&mut self, row: R, column: C) -> bool {\n+        self.ensure_row(row).insert(column)\n+    }\n+\n+    /// Do the bits from `row` contain `column`? Put another way, is\n+    /// the matrix cell at `(row, column)` true?  Put yet another way,\n+    /// if the matrix represents (transitive) reachability, can\n+    /// `row` reach `column`?\n+    pub fn contains(&self, row: R, column: C) -> bool {\n+        self.row(row).map_or(false, |r| r.contains(column))\n+    }\n+\n+    /// Add the bits from row `read` to the bits from row `write`,\n+    /// return true if anything changed.\n+    ///\n+    /// This is used when computing transitive reachability because if\n+    /// you have an edge `write -> read`, because in that case\n+    /// `write` can reach everything that `read` can (and\n+    /// potentially more).\n+    pub fn union_rows(&mut self, read: R, write: R) -> bool {\n+        if read == write || self.row(read).is_none() {\n+            return false;\n+        }\n+\n+        self.ensure_row(write);\n+        if let (Some(read_row), Some(write_row)) = self.rows.pick2_mut(read, write) {\n+            write_row.union(read_row)\n+        } else {\n+            unreachable!()\n+        }\n+    }\n+\n+    /// Merge a row, `from`, into the `into` row.\n+    pub fn union_into_row(&mut self, into: R, from: &BitSet<C>) -> bool {\n+        self.ensure_row(into).union(from)\n+    }\n+\n+    /// Insert all bits in the given row.\n+    pub fn insert_all_into_row(&mut self, row: R) {\n+        self.ensure_row(row).insert_all();\n+    }\n+\n+    pub fn rows(&self) -> impl Iterator<Item = R> {\n+        self.rows.indices()\n+    }\n+\n+    /// Iterates through all the columns set to true in a given row of\n+    /// the matrix.\n+    pub fn iter<'a>(&'a self, row: R) -> impl Iterator<Item = C> + 'a {\n+        self.row(row).into_iter().flat_map(|r| r.iter())\n+    }\n+\n+    pub fn row(&self, row: R) -> Option<&BitSet<C>> {\n+        if let Some(Some(row)) = self.rows.get(row) {\n+            Some(row)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+#[inline]\n+fn num_words<T: Idx>(elements: T) -> usize {\n+    (elements.index() + WORD_BITS - 1) / WORD_BITS\n+}\n+\n+#[inline]\n+fn word_index_and_mask<T: Idx>(index: T) -> (usize, Word) {\n+    let index = index.index();\n+    let word_index = index / WORD_BITS;\n+    let mask = 1 << (index % WORD_BITS);\n+    (word_index, mask)\n+}\n+\n+#[test]\n+fn test_clear_above() {\n+    use std::cmp;\n+\n+    for i in 0..256 {\n+        let mut idx_buf: BitSet<usize> = BitSet::new_filled(128);\n+        idx_buf.clear_above(i);\n+\n+        let elems: Vec<usize> = idx_buf.iter().collect();\n+        let expected: Vec<usize> = (0..cmp::min(i, 128)).collect();\n+        assert_eq!(elems, expected);\n+    }\n+}\n+\n+#[test]\n+fn test_set_up_to() {\n+    for i in 0..128 {\n+        for mut idx_buf in\n+            vec![BitSet::new_empty(128), BitSet::new_filled(128)].into_iter()\n+        {\n+            idx_buf.set_up_to(i);\n+\n+            let elems: Vec<usize> = idx_buf.iter().collect();\n+            let expected: Vec<usize> = (0..i).collect();\n+            assert_eq!(elems, expected);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_new_filled() {\n+    for i in 0..128 {\n+        let idx_buf = BitSet::new_filled(i);\n+        let elems: Vec<usize> = idx_buf.iter().collect();\n+        let expected: Vec<usize> = (0..i).collect();\n+        assert_eq!(elems, expected);\n+    }\n+}\n+\n+#[test]\n+fn bitset_iter_works() {\n+    let mut bitset: BitSet<usize> = BitSet::new_empty(100);\n+    bitset.insert(1);\n+    bitset.insert(10);\n+    bitset.insert(19);\n+    bitset.insert(62);\n+    bitset.insert(63);\n+    bitset.insert(64);\n+    bitset.insert(65);\n+    bitset.insert(66);\n+    bitset.insert(99);\n+    assert_eq!(\n+        bitset.iter().collect::<Vec<_>>(),\n+        [1, 10, 19, 62, 63, 64, 65, 66, 99]\n+    );\n+}\n+\n+#[test]\n+fn bitset_iter_works_2() {\n+    let mut bitset: BitSet<usize> = BitSet::new_empty(319);\n+    bitset.insert(0);\n+    bitset.insert(127);\n+    bitset.insert(191);\n+    bitset.insert(255);\n+    bitset.insert(319);\n+    assert_eq!(bitset.iter().collect::<Vec<_>>(), [0, 127, 191, 255, 319]);\n+}\n+\n+#[test]\n+fn union_two_vecs() {\n+    let mut set1: BitSet<usize> = BitSet::new_empty(65);\n+    let mut set2: BitSet<usize> = BitSet::new_empty(65);\n+    assert!(set1.insert(3));\n+    assert!(!set1.insert(3));\n+    assert!(set2.insert(5));\n+    assert!(set2.insert(64));\n+    assert!(set1.union(&set2));\n+    assert!(!set1.union(&set2));\n+    assert!(set1.contains(3));\n+    assert!(!set1.contains(4));\n+    assert!(set1.contains(5));\n+    assert!(!set1.contains(63));\n+    assert!(set1.contains(64));\n+}\n+\n+#[test]\n+fn grow() {\n+    let mut set: GrowableBitSet<usize> = GrowableBitSet::with_capacity(65);\n+    for index in 0..65 {\n+        assert!(set.insert(index));\n+        assert!(!set.insert(index));\n+    }\n+    set.grow(128);\n+\n+    // Check if the bits set before growing are still set\n+    for index in 0..65 {\n+        assert!(set.contains(index));\n+    }\n+\n+    // Check if the new bits are all un-set\n+    for index in 65..128 {\n+        assert!(!set.contains(index));\n+    }\n+\n+    // Check that we can set all new bits without running out of bounds\n+    for index in 65..128 {\n+        assert!(set.insert(index));\n+        assert!(!set.insert(index));\n+    }\n+}\n+\n+#[test]\n+fn matrix_intersection() {\n+    let mut matrix: BitMatrix<usize, usize> = BitMatrix::new(200, 200);\n+\n+    // (*) Elements reachable from both 2 and 65.\n+\n+    matrix.insert(2, 3);\n+    matrix.insert(2, 6);\n+    matrix.insert(2, 10); // (*)\n+    matrix.insert(2, 64); // (*)\n+    matrix.insert(2, 65);\n+    matrix.insert(2, 130);\n+    matrix.insert(2, 160); // (*)\n+\n+    matrix.insert(64, 133);\n+\n+    matrix.insert(65, 2);\n+    matrix.insert(65, 8);\n+    matrix.insert(65, 10); // (*)\n+    matrix.insert(65, 64); // (*)\n+    matrix.insert(65, 68);\n+    matrix.insert(65, 133);\n+    matrix.insert(65, 160); // (*)\n+\n+    let intersection = matrix.intersect_rows(2, 64);\n+    assert!(intersection.is_empty());\n+\n+    let intersection = matrix.intersect_rows(2, 65);\n+    assert_eq!(intersection, &[10, 64, 160]);\n+}\n+\n+#[test]\n+fn matrix_iter() {\n+    let mut matrix: BitMatrix<usize, usize> = BitMatrix::new(64, 100);\n+    matrix.insert(3, 22);\n+    matrix.insert(3, 75);\n+    matrix.insert(2, 99);\n+    matrix.insert(4, 0);\n+    matrix.union_rows(3, 5);\n+\n+    let expected = [99];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(2) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [22, 75];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(3) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [0];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(4) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [22, 75];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(5) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+}\n+\n+#[test]\n+fn sparse_matrix_iter() {\n+    let mut matrix: SparseBitMatrix<usize, usize> = SparseBitMatrix::new(100);\n+    matrix.insert(3, 22);\n+    matrix.insert(3, 75);\n+    matrix.insert(2, 99);\n+    matrix.insert(4, 0);\n+    matrix.union_rows(3, 5);\n+\n+    let expected = [99];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(2) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [22, 75];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(3) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [0];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(4) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [22, 75];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(5) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+}"}, {"sha": "52cc347f8e771c1dbfe4ecaf4d0554b5552615af", "filename": "src/librustc_data_structures/bitvec.rs", "status": "removed", "additions": 0, "deletions": 781, "changes": 781, "blob_url": "https://github.com/rust-lang/rust/blob/2224a42c353636db6ee53cc3f9b1a968e9d9c1f6/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2224a42c353636db6ee53cc3f9b1a968e9d9c1f6/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=2224a42c353636db6ee53cc3f9b1a968e9d9c1f6", "patch": "@@ -1,781 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use indexed_vec::{Idx, IndexVec};\n-use rustc_serialize;\n-use std::iter;\n-use std::marker::PhantomData;\n-use std::slice;\n-\n-pub type Word = u64;\n-pub const WORD_BYTES: usize = ::std::mem::size_of::<Word>();\n-pub const WORD_BITS: usize = WORD_BYTES * 8;\n-\n-/// A very simple BitArray type.\n-///\n-/// It does not support resizing after creation; use `BitVector` for that.\n-#[derive(Clone, Debug, Eq, PartialEq)]\n-pub struct BitArray<C: Idx> {\n-    data: Vec<Word>,\n-    marker: PhantomData<C>,\n-}\n-\n-impl<C: Idx> BitArray<C> {\n-    // Do not make this method public, instead switch your use case to BitVector.\n-    #[inline]\n-    fn grow(&mut self, num_bits: C) {\n-        let num_words = num_words(num_bits);\n-        if self.data.len() <= num_words {\n-            self.data.resize(num_words + 1, 0)\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn new(num_bits: usize) -> BitArray<C> {\n-        BitArray::new_empty(num_bits)\n-    }\n-\n-    #[inline]\n-    pub fn new_empty(num_bits: usize) -> BitArray<C> {\n-        let num_words = num_words(num_bits);\n-        BitArray {\n-            data: vec![0; num_words],\n-            marker: PhantomData,\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn new_filled(num_bits: usize) -> BitArray<C> {\n-        let num_words = num_words(num_bits);\n-        let mut result = BitArray {\n-            data: vec![!0; num_words],\n-            marker: PhantomData,\n-        };\n-        result.clear_above(num_bits);\n-        result\n-    }\n-\n-    #[inline]\n-    pub fn clear(&mut self) {\n-        for p in &mut self.data {\n-            *p = 0;\n-        }\n-    }\n-\n-    /// Sets all elements up to `num_bits`.\n-    pub fn set_up_to(&mut self, num_bits: usize) {\n-        for p in &mut self.data {\n-            *p = !0;\n-        }\n-        self.clear_above(num_bits);\n-    }\n-\n-    /// Clear all elements above `num_bits`.\n-    fn clear_above(&mut self, num_bits: usize) {\n-        let first_clear_block = num_bits / WORD_BITS;\n-\n-        if first_clear_block < self.data.len() {\n-            // Within `first_clear_block`, the `num_bits % WORD_BITS` LSBs\n-            // should remain.\n-            let mask = (1 << (num_bits % WORD_BITS)) - 1;\n-            self.data[first_clear_block] &= mask;\n-\n-            // All the blocks above `first_clear_block` are fully cleared.\n-            for b in &mut self.data[first_clear_block + 1..] {\n-                *b = 0;\n-            }\n-        }\n-    }\n-\n-    pub fn count(&self) -> usize {\n-        self.data.iter().map(|e| e.count_ones() as usize).sum()\n-    }\n-\n-    /// True if `self` contains the bit `bit`.\n-    #[inline]\n-    pub fn contains(&self, bit: C) -> bool {\n-        let (word, mask) = word_mask(bit);\n-        (self.data[word] & mask) != 0\n-    }\n-\n-    /// True if `self` contains all the bits in `other`.\n-    ///\n-    /// The two vectors must have the same length.\n-    #[inline]\n-    pub fn contains_all(&self, other: &BitArray<C>) -> bool {\n-        assert_eq!(self.data.len(), other.data.len());\n-        self.data.iter().zip(&other.data).all(|(a, b)| (a & b) == *b)\n-    }\n-\n-    #[inline]\n-    pub fn is_empty(&self) -> bool {\n-        self.data.iter().all(|a| *a == 0)\n-    }\n-\n-    /// Returns true if the bit has changed.\n-    #[inline]\n-    pub fn insert(&mut self, bit: C) -> bool {\n-        let (word, mask) = word_mask(bit);\n-        let data = &mut self.data[word];\n-        let value = *data;\n-        let new_value = value | mask;\n-        *data = new_value;\n-        new_value != value\n-    }\n-\n-    /// Sets all bits to true.\n-    pub fn insert_all(&mut self) {\n-        for data in &mut self.data {\n-            *data = !0;\n-        }\n-    }\n-\n-    /// Returns true if the bit has changed.\n-    #[inline]\n-    pub fn remove(&mut self, bit: C) -> bool {\n-        let (word, mask) = word_mask(bit);\n-        let data = &mut self.data[word];\n-        let value = *data;\n-        let new_value = value & !mask;\n-        *data = new_value;\n-        new_value != value\n-    }\n-\n-    #[inline]\n-    pub fn merge(&mut self, all: &BitArray<C>) -> bool {\n-        assert!(self.data.len() == all.data.len());\n-        let mut changed = false;\n-        for (i, j) in self.data.iter_mut().zip(&all.data) {\n-            let value = *i;\n-            *i = value | *j;\n-            if value != *i {\n-                changed = true;\n-            }\n-        }\n-        changed\n-    }\n-\n-    pub fn words(&self) -> &[Word] {\n-        &self.data\n-    }\n-\n-    pub fn words_mut(&mut self) -> &mut [Word] {\n-        &mut self.data\n-    }\n-\n-    /// Iterates over indexes of set bits in a sorted order\n-    #[inline]\n-    pub fn iter<'a>(&'a self) -> BitIter<'a, C> {\n-        BitIter {\n-            cur: None,\n-            iter: self.data.iter().enumerate(),\n-            marker: PhantomData,\n-        }\n-    }\n-}\n-\n-impl<T: Idx> rustc_serialize::Encodable for BitArray<T> {\n-    fn encode<E: rustc_serialize::Encoder>(&self, encoder: &mut E) -> Result<(), E::Error> {\n-        self.data.encode(encoder)\n-    }\n-}\n-\n-impl<T: Idx> rustc_serialize::Decodable for BitArray<T> {\n-    fn decode<D: rustc_serialize::Decoder>(d: &mut D) -> Result<BitArray<T>, D::Error> {\n-        let words: Vec<Word> = rustc_serialize::Decodable::decode(d)?;\n-        Ok(BitArray {\n-            data: words,\n-            marker: PhantomData,\n-        })\n-    }\n-}\n-\n-pub struct BitIter<'a, C: Idx> {\n-    cur: Option<(Word, usize)>,\n-    iter: iter::Enumerate<slice::Iter<'a, Word>>,\n-    marker: PhantomData<C>\n-}\n-\n-impl<'a, C: Idx> Iterator for BitIter<'a, C> {\n-    type Item = C;\n-    fn next(&mut self) -> Option<C> {\n-        loop {\n-            if let Some((ref mut word, offset)) = self.cur {\n-                let bit_pos = word.trailing_zeros() as usize;\n-                if bit_pos != WORD_BITS {\n-                    let bit = 1 << bit_pos;\n-                    *word ^= bit;\n-                    return Some(C::new(bit_pos + offset))\n-                }\n-            }\n-\n-            let (i, word) = self.iter.next()?;\n-            self.cur = Some((*word, WORD_BITS * i));\n-        }\n-    }\n-}\n-\n-pub trait BitwiseOperator {\n-    /// Applies some bit-operation pointwise to each of the bits in the two inputs.\n-    fn join(&self, pred1: Word, pred2: Word) -> Word;\n-}\n-\n-#[inline]\n-pub fn bitwise<Op: BitwiseOperator>(out_vec: &mut [Word], in_vec: &[Word], op: &Op) -> bool\n-{\n-    assert_eq!(out_vec.len(), in_vec.len());\n-    let mut changed = false;\n-    for (out_elem, in_elem) in out_vec.iter_mut().zip(in_vec.iter()) {\n-        let old_val = *out_elem;\n-        let new_val = op.join(old_val, *in_elem);\n-        *out_elem = new_val;\n-        changed |= old_val != new_val;\n-    }\n-    changed\n-}\n-\n-pub struct Intersect;\n-impl BitwiseOperator for Intersect {\n-    #[inline]\n-    fn join(&self, a: Word, b: Word) -> Word { a & b }\n-}\n-\n-pub struct Union;\n-impl BitwiseOperator for Union {\n-    #[inline]\n-    fn join(&self, a: Word, b: Word) -> Word { a | b }\n-}\n-\n-pub struct Subtract;\n-impl BitwiseOperator for Subtract {\n-    #[inline]\n-    fn join(&self, a: Word, b: Word) -> Word { a & !b }\n-}\n-\n-pub fn bits_to_string(words: &[Word], bits: usize) -> String {\n-    let mut result = String::new();\n-    let mut sep = '[';\n-\n-    // Note: this is a little endian printout of bytes.\n-\n-    // i tracks how many bits we have printed so far.\n-    let mut i = 0;\n-    for &word in words.iter() {\n-        let mut v = word;\n-        for _ in 0..WORD_BYTES { // for each byte in `v`:\n-            let remain = bits - i;\n-            // If less than a byte remains, then mask just that many bits.\n-            let mask = if remain <= 8 { (1 << remain) - 1 } else { 0xFF };\n-            assert!(mask <= 0xFF);\n-            let byte = v & mask;\n-\n-            result.push_str(&format!(\"{}{:02x}\", sep, byte));\n-\n-            if remain <= 8 { break; }\n-            v >>= 8;\n-            i += 8;\n-            sep = '-';\n-        }\n-        sep = '|';\n-    }\n-    result.push(']');\n-\n-    result\n-}\n-\n-/// A resizable BitVector type.\n-#[derive(Clone, Debug, PartialEq)]\n-pub struct BitVector<C: Idx> {\n-    data: BitArray<C>,\n-}\n-\n-impl<C: Idx> BitVector<C> {\n-    pub fn grow(&mut self, num_bits: C) {\n-        self.data.grow(num_bits)\n-    }\n-\n-    pub fn new() -> BitVector<C> {\n-        BitVector { data: BitArray::new(0) }\n-    }\n-\n-    pub fn with_capacity(bits: usize) -> BitVector<C> {\n-        BitVector { data: BitArray::new(bits) }\n-    }\n-\n-    /// Returns true if the bit has changed.\n-    #[inline]\n-    pub fn insert(&mut self, bit: C) -> bool {\n-        self.grow(bit);\n-        self.data.insert(bit)\n-    }\n-\n-    #[inline]\n-    pub fn contains(&self, bit: C) -> bool {\n-        let (word, mask) = word_mask(bit);\n-        if let Some(word) = self.data.data.get(word) {\n-            (word & mask) != 0\n-        } else {\n-            false\n-        }\n-    }\n-}\n-\n-/// A \"bit matrix\" is basically a matrix of booleans represented as\n-/// one gigantic bitvector. In other words, it is as if you have\n-/// `rows` bitvectors, each of length `columns`.\n-#[derive(Clone, Debug)]\n-pub struct BitMatrix<R: Idx, C: Idx> {\n-    columns: usize,\n-    vector: Vec<Word>,\n-    phantom: PhantomData<(R, C)>,\n-}\n-\n-impl<R: Idx, C: Idx> BitMatrix<R, C> {\n-    /// Create a new `rows x columns` matrix, initially empty.\n-    pub fn new(rows: usize, columns: usize) -> BitMatrix<R, C> {\n-        // For every element, we need one bit for every other\n-        // element. Round up to an even number of words.\n-        let words_per_row = num_words(columns);\n-        BitMatrix {\n-            columns,\n-            vector: vec![0; rows * words_per_row],\n-            phantom: PhantomData,\n-        }\n-    }\n-\n-    /// The range of bits for a given row.\n-    fn range(&self, row: R) -> (usize, usize) {\n-        let row = row.index();\n-        let words_per_row = num_words(self.columns);\n-        let start = row * words_per_row;\n-        (start, start + words_per_row)\n-    }\n-\n-    /// Sets the cell at `(row, column)` to true. Put another way, add\n-    /// `column` to the bitset for `row`.\n-    ///\n-    /// Returns true if this changed the matrix, and false otherwise.\n-    pub fn add(&mut self, row: R, column: R) -> bool {\n-        let (start, _) = self.range(row);\n-        let (word, mask) = word_mask(column);\n-        let vector = &mut self.vector[..];\n-        let v1 = vector[start + word];\n-        let v2 = v1 | mask;\n-        vector[start + word] = v2;\n-        v1 != v2\n-    }\n-\n-    /// Do the bits from `row` contain `column`? Put another way, is\n-    /// the matrix cell at `(row, column)` true?  Put yet another way,\n-    /// if the matrix represents (transitive) reachability, can\n-    /// `row` reach `column`?\n-    pub fn contains(&self, row: R, column: R) -> bool {\n-        let (start, _) = self.range(row);\n-        let (word, mask) = word_mask(column);\n-        (self.vector[start + word] & mask) != 0\n-    }\n-\n-    /// Returns those indices that are true in rows `a` and `b`.  This\n-    /// is an O(n) operation where `n` is the number of elements\n-    /// (somewhat independent from the actual size of the\n-    /// intersection, in particular).\n-    pub fn intersection(&self, a: R, b: R) -> Vec<C> {\n-        let (a_start, a_end) = self.range(a);\n-        let (b_start, b_end) = self.range(b);\n-        let mut result = Vec::with_capacity(self.columns);\n-        for (base, (i, j)) in (a_start..a_end).zip(b_start..b_end).enumerate() {\n-            let mut v = self.vector[i] & self.vector[j];\n-            for bit in 0..WORD_BITS {\n-                if v == 0 {\n-                    break;\n-                }\n-                if v & 0x1 != 0 {\n-                    result.push(C::new(base * WORD_BITS + bit));\n-                }\n-                v >>= 1;\n-            }\n-        }\n-        result\n-    }\n-\n-    /// Add the bits from row `read` to the bits from row `write`,\n-    /// return true if anything changed.\n-    ///\n-    /// This is used when computing transitive reachability because if\n-    /// you have an edge `write -> read`, because in that case\n-    /// `write` can reach everything that `read` can (and\n-    /// potentially more).\n-    pub fn merge(&mut self, read: R, write: R) -> bool {\n-        let (read_start, read_end) = self.range(read);\n-        let (write_start, write_end) = self.range(write);\n-        let vector = &mut self.vector[..];\n-        let mut changed = false;\n-        for (read_index, write_index) in (read_start..read_end).zip(write_start..write_end) {\n-            let v1 = vector[write_index];\n-            let v2 = v1 | vector[read_index];\n-            vector[write_index] = v2;\n-            changed |= v1 != v2;\n-        }\n-        changed\n-    }\n-\n-    /// Iterates through all the columns set to true in a given row of\n-    /// the matrix.\n-    pub fn iter<'a>(&'a self, row: R) -> BitIter<'a, C> {\n-        let (start, end) = self.range(row);\n-        BitIter {\n-            cur: None,\n-            iter: self.vector[start..end].iter().enumerate(),\n-            marker: PhantomData,\n-        }\n-    }\n-}\n-\n-/// A moderately sparse bit matrix, in which rows are instantiated lazily.\n-///\n-/// Initially, every row has no explicit representation. If any bit within a\n-/// row is set, the entire row is instantiated as\n-/// `Some(<full-column-width-BitArray>)`. Furthermore, any previously\n-/// uninstantiated rows prior to it will be instantiated as `None`. Those prior\n-/// rows may themselves become fully instantiated later on if any of their bits\n-/// are set.\n-#[derive(Clone, Debug)]\n-pub struct SparseBitMatrix<R, C>\n-where\n-    R: Idx,\n-    C: Idx,\n-{\n-    num_columns: usize,\n-    rows: IndexVec<R, Option<BitArray<C>>>,\n-}\n-\n-impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n-    /// Create a new empty sparse bit matrix with no rows or columns.\n-    pub fn new(num_columns: usize) -> Self {\n-        Self {\n-            num_columns,\n-            rows: IndexVec::new(),\n-        }\n-    }\n-\n-    fn ensure_row(&mut self, row: R) -> &mut BitArray<C> {\n-        // Instantiate any missing rows up to and including row `row` with an\n-        // empty BitArray.\n-        self.rows.ensure_contains_elem(row, || None);\n-\n-        // Then replace row `row` with a full BitArray if necessary.\n-        let num_columns = self.num_columns;\n-        self.rows[row].get_or_insert_with(|| BitArray::new(num_columns))\n-    }\n-\n-    /// Sets the cell at `(row, column)` to true. Put another way, insert\n-    /// `column` to the bitset for `row`.\n-    ///\n-    /// Returns true if this changed the matrix, and false otherwise.\n-    pub fn add(&mut self, row: R, column: C) -> bool {\n-        self.ensure_row(row).insert(column)\n-    }\n-\n-    /// Do the bits from `row` contain `column`? Put another way, is\n-    /// the matrix cell at `(row, column)` true?  Put yet another way,\n-    /// if the matrix represents (transitive) reachability, can\n-    /// `row` reach `column`?\n-    pub fn contains(&self, row: R, column: C) -> bool {\n-        self.row(row).map_or(false, |r| r.contains(column))\n-    }\n-\n-    /// Add the bits from row `read` to the bits from row `write`,\n-    /// return true if anything changed.\n-    ///\n-    /// This is used when computing transitive reachability because if\n-    /// you have an edge `write -> read`, because in that case\n-    /// `write` can reach everything that `read` can (and\n-    /// potentially more).\n-    pub fn merge(&mut self, read: R, write: R) -> bool {\n-        if read == write || self.row(read).is_none() {\n-            return false;\n-        }\n-\n-        self.ensure_row(write);\n-        if let (Some(bitvec_read), Some(bitvec_write)) = self.rows.pick2_mut(read, write) {\n-            bitvec_write.merge(bitvec_read)\n-        } else {\n-            unreachable!()\n-        }\n-    }\n-\n-    /// Merge a row, `from`, into the `into` row.\n-    pub fn merge_into(&mut self, into: R, from: &BitArray<C>) -> bool {\n-        self.ensure_row(into).merge(from)\n-    }\n-\n-    /// Add all bits to the given row.\n-    pub fn add_all(&mut self, row: R) {\n-        self.ensure_row(row).insert_all();\n-    }\n-\n-    pub fn rows(&self) -> impl Iterator<Item = R> {\n-        self.rows.indices()\n-    }\n-\n-    /// Iterates through all the columns set to true in a given row of\n-    /// the matrix.\n-    pub fn iter<'a>(&'a self, row: R) -> impl Iterator<Item = C> + 'a {\n-        self.row(row).into_iter().flat_map(|r| r.iter())\n-    }\n-\n-    pub fn row(&self, row: R) -> Option<&BitArray<C>> {\n-        if let Some(Some(row)) = self.rows.get(row) {\n-            Some(row)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-#[inline]\n-fn num_words<C: Idx>(elements: C) -> usize {\n-    (elements.index() + WORD_BITS - 1) / WORD_BITS\n-}\n-\n-#[inline]\n-fn word_mask<C: Idx>(index: C) -> (usize, Word) {\n-    let index = index.index();\n-    let word = index / WORD_BITS;\n-    let mask = 1 << (index % WORD_BITS);\n-    (word, mask)\n-}\n-\n-#[test]\n-fn test_clear_above() {\n-    use std::cmp;\n-\n-    for i in 0..256 {\n-        let mut idx_buf: BitArray<usize> = BitArray::new_filled(128);\n-        idx_buf.clear_above(i);\n-\n-        let elems: Vec<usize> = idx_buf.iter().collect();\n-        let expected: Vec<usize> = (0..cmp::min(i, 128)).collect();\n-        assert_eq!(elems, expected);\n-    }\n-}\n-\n-#[test]\n-fn test_set_up_to() {\n-    for i in 0..128 {\n-        for mut idx_buf in\n-            vec![BitArray::new_empty(128), BitArray::new_filled(128)]\n-            .into_iter()\n-        {\n-            idx_buf.set_up_to(i);\n-\n-            let elems: Vec<usize> = idx_buf.iter().collect();\n-            let expected: Vec<usize> = (0..i).collect();\n-            assert_eq!(elems, expected);\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_new_filled() {\n-    for i in 0..128 {\n-        let idx_buf = BitArray::new_filled(i);\n-        let elems: Vec<usize> = idx_buf.iter().collect();\n-        let expected: Vec<usize> = (0..i).collect();\n-        assert_eq!(elems, expected);\n-    }\n-}\n-\n-#[test]\n-fn bitvec_iter_works() {\n-    let mut bitvec: BitArray<usize> = BitArray::new(100);\n-    bitvec.insert(1);\n-    bitvec.insert(10);\n-    bitvec.insert(19);\n-    bitvec.insert(62);\n-    bitvec.insert(63);\n-    bitvec.insert(64);\n-    bitvec.insert(65);\n-    bitvec.insert(66);\n-    bitvec.insert(99);\n-    assert_eq!(\n-        bitvec.iter().collect::<Vec<_>>(),\n-        [1, 10, 19, 62, 63, 64, 65, 66, 99]\n-    );\n-}\n-\n-#[test]\n-fn bitvec_iter_works_2() {\n-    let mut bitvec: BitArray<usize> = BitArray::new(319);\n-    bitvec.insert(0);\n-    bitvec.insert(127);\n-    bitvec.insert(191);\n-    bitvec.insert(255);\n-    bitvec.insert(319);\n-    assert_eq!(bitvec.iter().collect::<Vec<_>>(), [0, 127, 191, 255, 319]);\n-}\n-\n-#[test]\n-fn union_two_vecs() {\n-    let mut vec1: BitArray<usize> = BitArray::new(65);\n-    let mut vec2: BitArray<usize> = BitArray::new(65);\n-    assert!(vec1.insert(3));\n-    assert!(!vec1.insert(3));\n-    assert!(vec2.insert(5));\n-    assert!(vec2.insert(64));\n-    assert!(vec1.merge(&vec2));\n-    assert!(!vec1.merge(&vec2));\n-    assert!(vec1.contains(3));\n-    assert!(!vec1.contains(4));\n-    assert!(vec1.contains(5));\n-    assert!(!vec1.contains(63));\n-    assert!(vec1.contains(64));\n-}\n-\n-#[test]\n-fn grow() {\n-    let mut vec1: BitVector<usize> = BitVector::with_capacity(65);\n-    for index in 0..65 {\n-        assert!(vec1.insert(index));\n-        assert!(!vec1.insert(index));\n-    }\n-    vec1.grow(128);\n-\n-    // Check if the bits set before growing are still set\n-    for index in 0..65 {\n-        assert!(vec1.contains(index));\n-    }\n-\n-    // Check if the new bits are all un-set\n-    for index in 65..128 {\n-        assert!(!vec1.contains(index));\n-    }\n-\n-    // Check that we can set all new bits without running out of bounds\n-    for index in 65..128 {\n-        assert!(vec1.insert(index));\n-        assert!(!vec1.insert(index));\n-    }\n-}\n-\n-#[test]\n-fn matrix_intersection() {\n-    let mut vec1: BitMatrix<usize, usize> = BitMatrix::new(200, 200);\n-\n-    // (*) Elements reachable from both 2 and 65.\n-\n-    vec1.add(2, 3);\n-    vec1.add(2, 6);\n-    vec1.add(2, 10); // (*)\n-    vec1.add(2, 64); // (*)\n-    vec1.add(2, 65);\n-    vec1.add(2, 130);\n-    vec1.add(2, 160); // (*)\n-\n-    vec1.add(64, 133);\n-\n-    vec1.add(65, 2);\n-    vec1.add(65, 8);\n-    vec1.add(65, 10); // (*)\n-    vec1.add(65, 64); // (*)\n-    vec1.add(65, 68);\n-    vec1.add(65, 133);\n-    vec1.add(65, 160); // (*)\n-\n-    let intersection = vec1.intersection(2, 64);\n-    assert!(intersection.is_empty());\n-\n-    let intersection = vec1.intersection(2, 65);\n-    assert_eq!(intersection, &[10, 64, 160]);\n-}\n-\n-#[test]\n-fn matrix_iter() {\n-    let mut matrix: BitMatrix<usize, usize> = BitMatrix::new(64, 100);\n-    matrix.add(3, 22);\n-    matrix.add(3, 75);\n-    matrix.add(2, 99);\n-    matrix.add(4, 0);\n-    matrix.merge(3, 5);\n-\n-    let expected = [99];\n-    let mut iter = expected.iter();\n-    for i in matrix.iter(2) {\n-        let j = *iter.next().unwrap();\n-        assert_eq!(i, j);\n-    }\n-    assert!(iter.next().is_none());\n-\n-    let expected = [22, 75];\n-    let mut iter = expected.iter();\n-    for i in matrix.iter(3) {\n-        let j = *iter.next().unwrap();\n-        assert_eq!(i, j);\n-    }\n-    assert!(iter.next().is_none());\n-\n-    let expected = [0];\n-    let mut iter = expected.iter();\n-    for i in matrix.iter(4) {\n-        let j = *iter.next().unwrap();\n-        assert_eq!(i, j);\n-    }\n-    assert!(iter.next().is_none());\n-\n-    let expected = [22, 75];\n-    let mut iter = expected.iter();\n-    for i in matrix.iter(5) {\n-        let j = *iter.next().unwrap();\n-        assert_eq!(i, j);\n-    }\n-    assert!(iter.next().is_none());\n-}\n-\n-#[test]\n-fn sparse_matrix_iter() {\n-    let mut matrix: SparseBitMatrix<usize, usize> = SparseBitMatrix::new(100);\n-    matrix.add(3, 22);\n-    matrix.add(3, 75);\n-    matrix.add(2, 99);\n-    matrix.add(4, 0);\n-    matrix.merge(3, 5);\n-\n-    let expected = [99];\n-    let mut iter = expected.iter();\n-    for i in matrix.iter(2) {\n-        let j = *iter.next().unwrap();\n-        assert_eq!(i, j);\n-    }\n-    assert!(iter.next().is_none());\n-\n-    let expected = [22, 75];\n-    let mut iter = expected.iter();\n-    for i in matrix.iter(3) {\n-        let j = *iter.next().unwrap();\n-        assert_eq!(i, j);\n-    }\n-    assert!(iter.next().is_none());\n-\n-    let expected = [0];\n-    let mut iter = expected.iter();\n-    for i in matrix.iter(4) {\n-        let j = *iter.next().unwrap();\n-        assert_eq!(i, j);\n-    }\n-    assert!(iter.next().is_none());\n-\n-    let expected = [22, 75];\n-    let mut iter = expected.iter();\n-    for i in matrix.iter(5) {\n-        let j = *iter.next().unwrap();\n-        assert_eq!(i, j);\n-    }\n-    assert!(iter.next().is_none());\n-}"}, {"sha": "c31321fa374a48cc7d7a678f39797bc2867f3753", "filename": "src/librustc_data_structures/graph/implementation/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -30,7 +30,7 @@\n //! the field `next_edge`). Each of those fields is an array that should\n //! be indexed by the direction (see the type `Direction`).\n \n-use bitvec::BitArray;\n+use bit_set::BitSet;\n use std::fmt::Debug;\n use std::usize;\n use snapshot_vec::{SnapshotVec, SnapshotVecDelegate};\n@@ -266,7 +266,7 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         direction: Direction,\n         entry_node: NodeIndex,\n     ) -> Vec<NodeIndex> {\n-        let mut visited = BitArray::new(self.len_nodes());\n+        let mut visited = BitSet::new_empty(self.len_nodes());\n         let mut stack = vec![];\n         let mut result = Vec::with_capacity(self.len_nodes());\n         let mut push_node = |stack: &mut Vec<_>, node: NodeIndex| {\n@@ -348,7 +348,7 @@ where\n {\n     graph: &'g Graph<N, E>,\n     stack: Vec<NodeIndex>,\n-    visited: BitArray<usize>,\n+    visited: BitSet<usize>,\n     direction: Direction,\n }\n \n@@ -358,7 +358,7 @@ impl<'g, N: Debug, E: Debug> DepthFirstTraversal<'g, N, E> {\n         start_node: NodeIndex,\n         direction: Direction,\n     ) -> Self {\n-        let mut visited = BitArray::new(graph.len_nodes());\n+        let mut visited = BitSet::new_empty(graph.len_nodes());\n         visited.insert(start_node.node_id());\n         DepthFirstTraversal {\n             graph,"}, {"sha": "5ba8c150e1fcb7a30a9793bca5b3b9b1cfd41c53", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "removed", "additions": 0, "deletions": 358, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/2224a42c353636db6ee53cc3f9b1a968e9d9c1f6/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2224a42c353636db6ee53cc3f9b1a968e9d9c1f6/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=2224a42c353636db6ee53cc3f9b1a968e9d9c1f6", "patch": "@@ -1,358 +0,0 @@\n-// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use array_vec::ArrayVec;\n-use std::fmt;\n-use std::mem;\n-use std::slice;\n-use bitvec::{bitwise, BitArray, BitIter, Intersect, Subtract, Union, Word, WORD_BITS};\n-use indexed_vec::Idx;\n-use rustc_serialize;\n-\n-/// This is implemented by all the index sets so that IdxSet::union() can be\n-/// passed any type of index set.\n-pub trait UnionIntoIdxSet<T: Idx> {\n-    // Performs `other = other | self`.\n-    fn union_into(&self, other: &mut IdxSet<T>) -> bool;\n-}\n-\n-/// This is implemented by all the index sets so that IdxSet::subtract() can be\n-/// passed any type of index set.\n-pub trait SubtractFromIdxSet<T: Idx> {\n-    // Performs `other = other - self`.\n-    fn subtract_from(&self, other: &mut IdxSet<T>) -> bool;\n-}\n-\n-/// Represents a set of some element type E, where each E is identified by some\n-/// unique index type `T`.\n-///\n-/// In other words, `T` is the type used to index into the bitvector\n-/// this type uses to represent the set of object it holds.\n-///\n-/// The representation is dense, using one bit per possible element.\n-#[derive(Clone, Eq, PartialEq)]\n-pub struct IdxSet<T: Idx>(BitArray<T>);\n-\n-impl<T: Idx> rustc_serialize::Encodable for IdxSet<T> {\n-    fn encode<E: rustc_serialize::Encoder>(&self, encoder: &mut E) -> Result<(), E::Error> {\n-        self.0.encode(encoder)\n-    }\n-}\n-\n-impl<T: Idx> rustc_serialize::Decodable for IdxSet<T> {\n-    fn decode<D: rustc_serialize::Decoder>(d: &mut D) -> Result<IdxSet<T>, D::Error> {\n-        Ok(IdxSet(rustc_serialize::Decodable::decode(d)?))\n-    }\n-}\n-\n-impl<T: Idx> fmt::Debug for IdxSet<T> {\n-    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n-        w.debug_list()\n-         .entries(self.iter())\n-         .finish()\n-    }\n-}\n-\n-impl<T: Idx> IdxSet<T> {\n-    /// Creates set holding no elements.\n-    pub fn new_empty(domain_size: usize) -> Self {\n-        IdxSet(BitArray::new_empty(domain_size))\n-    }\n-\n-    /// Creates set holding every element whose index falls in range 0..domain_size.\n-    pub fn new_filled(domain_size: usize) -> Self {\n-        IdxSet(BitArray::new_filled(domain_size))\n-    }\n-\n-    /// Duplicates as a hybrid set.\n-    pub fn to_hybrid(&self) -> HybridIdxSet<T> {\n-        // This domain_size may be slightly larger than the one specified\n-        // upon creation, due to rounding up to a whole word. That's ok.\n-        let domain_size = self.words().len() * WORD_BITS;\n-\n-        // Note: we currently don't bother trying to make a Sparse set.\n-        HybridIdxSet::Dense(self.to_owned(), domain_size)\n-    }\n-\n-    /// Removes all elements\n-    pub fn clear(&mut self) {\n-        self.0.clear();\n-    }\n-\n-    /// Sets all elements up to `domain_size`\n-    pub fn set_up_to(&mut self, domain_size: usize) {\n-        self.0.set_up_to(domain_size);\n-    }\n-\n-    /// Removes `elem` from the set `self`; returns true iff this changed `self`.\n-    pub fn remove(&mut self, elem: &T) -> bool {\n-        self.0.remove(*elem)\n-    }\n-\n-    /// Adds `elem` to the set `self`; returns true iff this changed `self`.\n-    pub fn add(&mut self, elem: &T) -> bool {\n-        self.0.insert(*elem)\n-    }\n-\n-    /// Returns true iff set `self` contains `elem`.\n-    pub fn contains(&self, elem: &T) -> bool {\n-        self.0.contains(*elem)\n-    }\n-\n-    pub fn words(&self) -> &[Word] {\n-        self.0.words()\n-    }\n-\n-    pub fn words_mut(&mut self) -> &mut [Word] {\n-        self.0.words_mut()\n-    }\n-\n-    /// Efficiently overwrite `self` with `other`. Panics if `self` and `other`\n-    /// don't have the same length.\n-    pub fn overwrite(&mut self, other: &IdxSet<T>) {\n-        self.words_mut().clone_from_slice(other.words());\n-    }\n-\n-    /// Set `self = self | other` and return true if `self` changed\n-    /// (i.e., if new bits were added).\n-    pub fn union(&mut self, other: &impl UnionIntoIdxSet<T>) -> bool {\n-        other.union_into(self)\n-    }\n-\n-    /// Set `self = self - other` and return true if `self` changed.\n-    /// (i.e., if any bits were removed).\n-    pub fn subtract(&mut self, other: &impl SubtractFromIdxSet<T>) -> bool {\n-        other.subtract_from(self)\n-    }\n-\n-    /// Set `self = self & other` and return true if `self` changed.\n-    /// (i.e., if any bits were removed).\n-    pub fn intersect(&mut self, other: &IdxSet<T>) -> bool {\n-        bitwise(self.words_mut(), other.words(), &Intersect)\n-    }\n-\n-    pub fn iter(&self) -> BitIter<T> {\n-        self.0.iter()\n-    }\n-}\n-\n-impl<T: Idx> UnionIntoIdxSet<T> for IdxSet<T> {\n-    fn union_into(&self, other: &mut IdxSet<T>) -> bool {\n-        bitwise(other.words_mut(), self.words(), &Union)\n-    }\n-}\n-\n-impl<T: Idx> SubtractFromIdxSet<T> for IdxSet<T> {\n-    fn subtract_from(&self, other: &mut IdxSet<T>) -> bool {\n-        bitwise(other.words_mut(), self.words(), &Subtract)\n-    }\n-}\n-\n-const SPARSE_MAX: usize = 8;\n-\n-/// A sparse index set with a maximum of SPARSE_MAX elements. Used by\n-/// HybridIdxSet; do not use directly.\n-///\n-/// The elements are stored as an unsorted vector with no duplicates.\n-#[derive(Clone, Debug)]\n-pub struct SparseIdxSet<T: Idx>(ArrayVec<[T; SPARSE_MAX]>);\n-\n-impl<T: Idx> SparseIdxSet<T> {\n-    fn new() -> Self {\n-        SparseIdxSet(ArrayVec::new())\n-    }\n-\n-    fn len(&self) -> usize {\n-        self.0.len()\n-    }\n-\n-    fn contains(&self, elem: &T) -> bool {\n-        self.0.contains(elem)\n-    }\n-\n-    fn add(&mut self, elem: &T) -> bool {\n-        // Ensure there are no duplicates.\n-        if self.0.contains(elem) {\n-            false\n-        } else {\n-            self.0.push(*elem);\n-            true\n-        }\n-    }\n-\n-    fn remove(&mut self, elem: &T) -> bool {\n-        if let Some(i) = self.0.iter().position(|e| e == elem) {\n-            // Swap the found element to the end, then pop it.\n-            let len = self.0.len();\n-            self.0.swap(i, len - 1);\n-            self.0.pop();\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n-    fn to_dense(&self, domain_size: usize) -> IdxSet<T> {\n-        let mut dense = IdxSet::new_empty(domain_size);\n-        for elem in self.0.iter() {\n-            dense.add(elem);\n-        }\n-        dense\n-    }\n-\n-    fn iter(&self) -> slice::Iter<T> {\n-        self.0.iter()\n-    }\n-}\n-\n-impl<T: Idx> UnionIntoIdxSet<T> for SparseIdxSet<T> {\n-    fn union_into(&self, other: &mut IdxSet<T>) -> bool {\n-        let mut changed = false;\n-        for elem in self.iter() {\n-            changed |= other.add(&elem);\n-        }\n-        changed\n-    }\n-}\n-\n-impl<T: Idx> SubtractFromIdxSet<T> for SparseIdxSet<T> {\n-    fn subtract_from(&self, other: &mut IdxSet<T>) -> bool {\n-        let mut changed = false;\n-        for elem in self.iter() {\n-            changed |= other.remove(&elem);\n-        }\n-        changed\n-    }\n-}\n-\n-/// Like IdxSet, but with a hybrid representation: sparse when there are few\n-/// elements in the set, but dense when there are many. It's especially\n-/// efficient for sets that typically have a small number of elements, but a\n-/// large `domain_size`, and are cleared frequently.\n-#[derive(Clone, Debug)]\n-pub enum HybridIdxSet<T: Idx> {\n-    Sparse(SparseIdxSet<T>, usize),\n-    Dense(IdxSet<T>, usize),\n-}\n-\n-impl<T: Idx> HybridIdxSet<T> {\n-    pub fn new_empty(domain_size: usize) -> Self {\n-        HybridIdxSet::Sparse(SparseIdxSet::new(), domain_size)\n-    }\n-\n-    pub fn clear(&mut self) {\n-        let domain_size = match *self {\n-            HybridIdxSet::Sparse(_, size) => size,\n-            HybridIdxSet::Dense(_, size) => size,\n-        };\n-        *self = HybridIdxSet::new_empty(domain_size);\n-    }\n-\n-    /// Returns true iff set `self` contains `elem`.\n-    pub fn contains(&self, elem: &T) -> bool {\n-        match self {\n-            HybridIdxSet::Sparse(sparse, _) => sparse.contains(elem),\n-            HybridIdxSet::Dense(dense, _) => dense.contains(elem),\n-        }\n-    }\n-\n-    /// Adds `elem` to the set `self`.\n-    pub fn add(&mut self, elem: &T) -> bool {\n-        match self {\n-            HybridIdxSet::Sparse(sparse, _) if sparse.len() < SPARSE_MAX => {\n-                // The set is sparse and has space for `elem`.\n-                sparse.add(elem)\n-            }\n-            HybridIdxSet::Sparse(sparse, _) if sparse.contains(elem) => {\n-                // The set is sparse and does not have space for `elem`, but\n-                // that doesn't matter because `elem` is already present.\n-                false\n-            }\n-            HybridIdxSet::Sparse(_, _) => {\n-                // The set is sparse and full. Convert to a dense set.\n-                //\n-                // FIXME: This code is awful, but I can't work out how else to\n-                //        appease the borrow checker.\n-                let dummy = HybridIdxSet::Sparse(SparseIdxSet::new(), 0);\n-                match mem::replace(self, dummy) {\n-                    HybridIdxSet::Sparse(sparse, domain_size) => {\n-                        let mut dense = sparse.to_dense(domain_size);\n-                        let changed = dense.add(elem);\n-                        assert!(changed);\n-                        mem::replace(self, HybridIdxSet::Dense(dense, domain_size));\n-                        changed\n-                    }\n-                    _ => panic!(\"impossible\"),\n-                }\n-            }\n-\n-            HybridIdxSet::Dense(dense, _) => dense.add(elem),\n-        }\n-    }\n-\n-    /// Removes `elem` from the set `self`.\n-    pub fn remove(&mut self, elem: &T) -> bool {\n-        // Note: we currently don't bother going from Dense back to Sparse.\n-        match self {\n-            HybridIdxSet::Sparse(sparse, _) => sparse.remove(elem),\n-            HybridIdxSet::Dense(dense, _) => dense.remove(elem),\n-        }\n-    }\n-\n-    /// Converts to a dense set, consuming itself in the process.\n-    pub fn to_dense(self) -> IdxSet<T> {\n-        match self {\n-            HybridIdxSet::Sparse(sparse, domain_size) => sparse.to_dense(domain_size),\n-            HybridIdxSet::Dense(dense, _) => dense,\n-        }\n-    }\n-\n-    /// Iteration order is unspecified.\n-    pub fn iter(&self) -> HybridIter<T> {\n-        match self {\n-            HybridIdxSet::Sparse(sparse, _) => HybridIter::Sparse(sparse.iter()),\n-            HybridIdxSet::Dense(dense, _) => HybridIter::Dense(dense.iter()),\n-        }\n-    }\n-}\n-\n-impl<T: Idx> UnionIntoIdxSet<T> for HybridIdxSet<T> {\n-    fn union_into(&self, other: &mut IdxSet<T>) -> bool {\n-        match self {\n-            HybridIdxSet::Sparse(sparse, _) => sparse.union_into(other),\n-            HybridIdxSet::Dense(dense, _) => dense.union_into(other),\n-        }\n-    }\n-}\n-\n-impl<T: Idx> SubtractFromIdxSet<T> for HybridIdxSet<T> {\n-    fn subtract_from(&self, other: &mut IdxSet<T>) -> bool {\n-        match self {\n-            HybridIdxSet::Sparse(sparse, _) => sparse.subtract_from(other),\n-            HybridIdxSet::Dense(dense, _) => dense.subtract_from(other),\n-        }\n-    }\n-}\n-\n-pub enum HybridIter<'a, T: Idx> {\n-    Sparse(slice::Iter<'a, T>),\n-    Dense(BitIter<'a, T>),\n-}\n-\n-impl<'a, T: Idx> Iterator for HybridIter<'a, T> {\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        match self {\n-            HybridIter::Sparse(sparse) => sparse.next().map(|e| *e),\n-            HybridIter::Dense(dense) => dense.next(),\n-        }\n-    }\n-}"}, {"sha": "1d7557953e976a935b79e453a425b0a64360ad90", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -62,12 +62,11 @@ pub use rustc_serialize::hex::ToHex;\n pub mod svh;\n pub mod array_vec;\n pub mod base_n;\n-pub mod bitvec;\n+pub mod bit_set;\n pub mod const_cstr;\n pub mod flock;\n pub mod fx;\n pub mod graph;\n-pub mod indexed_set;\n pub mod indexed_vec;\n pub mod obligation_forest;\n pub mod owning_ref;"}, {"sha": "c85d771a1810671f997ed5487aa0798e8c4c0ff3", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -457,7 +457,7 @@ impl<I: ::indexed_vec::Idx, T, CTX> HashStable<CTX> for ::indexed_vec::IndexVec<\n }\n \n \n-impl<I: ::indexed_vec::Idx, CTX> HashStable<CTX> for ::indexed_set::IdxSet<I>\n+impl<I: ::indexed_vec::Idx, CTX> HashStable<CTX> for ::bit_set::BitSet<I>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           ctx: &mut CTX,"}, {"sha": "1512b30eeadaa932175c7382305f022989ab1ca8", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use bitvec::BitMatrix;\n+use bit_set::BitMatrix;\n use fx::FxHashMap;\n use sync::Lock;\n use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n@@ -279,7 +279,7 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n             //\n             // This same algorithm is used in `parents` below.\n \n-            let mut candidates = closure.intersection(a.0, b.0); // (1)\n+            let mut candidates = closure.intersect_rows(a.0, b.0); // (1)\n             pare_down(&mut candidates, closure); // (2)\n             candidates.reverse(); // (3a)\n             pare_down(&mut candidates, closure); // (3b)\n@@ -321,7 +321,7 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n         // with a slight tweak. In the case where `a R a`, we remove\n         // that from the set of candidates.\n         let ancestors = self.with_closure(|closure| {\n-            let mut ancestors = closure.intersection(a.0, a.0);\n+            let mut ancestors = closure.intersect_rows(a.0, a.0);\n \n             // Remove anything that can reach `a`. If this is a\n             // reflexive relation, this will include `a` itself.\n@@ -366,10 +366,10 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n             changed = false;\n             for edge in &self.edges {\n                 // add an edge from S -> T\n-                changed |= matrix.add(edge.source.0, edge.target.0);\n+                changed |= matrix.insert(edge.source.0, edge.target.0);\n \n                 // add all outgoing edges from T into S\n-                changed |= matrix.merge(edge.target.0, edge.source.0);\n+                changed |= matrix.union_rows(edge.target.0, edge.source.0);\n             }\n         }\n         matrix"}, {"sha": "af9ed9306ebb2f29be1396d21a22a64c9a097db8", "filename": "src/librustc_data_structures/work_queue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_data_structures%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_data_structures%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fwork_queue.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use indexed_set::IdxSet;\n+use bit_set::BitSet;\n use indexed_vec::Idx;\n use std::collections::VecDeque;\n \n@@ -20,7 +20,7 @@ use std::collections::VecDeque;\n /// and also use a bit set to track occupancy.\n pub struct WorkQueue<T: Idx> {\n     deque: VecDeque<T>,\n-    set: IdxSet<T>,\n+    set: BitSet<T>,\n }\n \n impl<T: Idx> WorkQueue<T> {\n@@ -29,7 +29,7 @@ impl<T: Idx> WorkQueue<T> {\n     pub fn with_all(len: usize) -> Self {\n         WorkQueue {\n             deque: (0..len).map(T::new).collect(),\n-            set: IdxSet::new_filled(len),\n+            set: BitSet::new_filled(len),\n         }\n     }\n \n@@ -38,14 +38,14 @@ impl<T: Idx> WorkQueue<T> {\n     pub fn with_none(len: usize) -> Self {\n         WorkQueue {\n             deque: VecDeque::with_capacity(len),\n-            set: IdxSet::new_empty(len),\n+            set: BitSet::new_empty(len),\n         }\n     }\n \n     /// Attempt to enqueue `element` in the work queue. Returns false if it was already present.\n     #[inline]\n     pub fn insert(&mut self, element: T) -> bool {\n-        if self.set.add(&element) {\n+        if self.set.insert(element) {\n             self.deque.push_back(element);\n             true\n         } else {\n@@ -57,7 +57,7 @@ impl<T: Idx> WorkQueue<T> {\n     #[inline]\n     pub fn pop(&mut self) -> Option<T> {\n         if let Some(element) = self.deque.pop_front() {\n-            self.set.remove(&element);\n+            self.set.remove(element);\n             Some(element)\n         } else {\n             None"}, {"sha": "d2285e8cbf1bea5ac1884b1bffdf2453c5023751", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -42,7 +42,7 @@ use syntax::edition::Edition;\n use syntax::parse::source_file_to_stream;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, NO_EXPANSION, FileName};\n-use rustc_data_structures::indexed_set::IdxSet;\n+use rustc_data_structures::bit_set::BitSet;\n use rustc::hir;\n \n macro_rules! provide {\n@@ -141,7 +141,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         mir\n     }\n     mir_const_qualif => {\n-        (cdata.mir_const_qualif(def_id.index), Lrc::new(IdxSet::new_empty(0)))\n+        (cdata.mir_const_qualif(def_id.index), Lrc::new(BitSet::new_empty(0)))\n     }\n     fn_sig => { cdata.fn_sig(def_id.index, tcx) }\n     inherent_impls => { Lrc::new(cdata.get_inherent_implementations_for_type(def_id.index)) }"}, {"sha": "bb70b4b76c27784c0c312c68d6874fc868fb1ce4", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -17,7 +17,7 @@ use rustc::mir::{self, Location, Mir, Place, Local};\n use rustc::ty::{Region, TyCtxt};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc_data_structures::bitvec::BitArray;\n+use rustc_data_structures::bit_set::BitSet;\n use std::fmt;\n use std::hash::Hash;\n use std::ops::Index;\n@@ -102,7 +102,7 @@ impl<'tcx> fmt::Display for BorrowData<'tcx> {\n \n crate enum LocalsStateAtExit {\n     AllAreInvalidated,\n-    SomeAreInvalidated { has_storage_dead_or_moved: BitArray<Local> }\n+    SomeAreInvalidated { has_storage_dead_or_moved: BitSet<Local> }\n }\n \n impl LocalsStateAtExit {\n@@ -111,7 +111,7 @@ impl LocalsStateAtExit {\n         mir: &Mir<'tcx>,\n         move_data: &MoveData<'tcx>\n     ) -> Self {\n-        struct HasStorageDead(BitArray<Local>);\n+        struct HasStorageDead(BitSet<Local>);\n \n         impl<'tcx> Visitor<'tcx> for HasStorageDead {\n             fn visit_local(&mut self, local: &Local, ctx: PlaceContext<'tcx>, _: Location) {\n@@ -124,7 +124,7 @@ impl LocalsStateAtExit {\n         if locals_are_invalidated_at_exit {\n             LocalsStateAtExit::AllAreInvalidated\n         } else {\n-            let mut has_storage_dead = HasStorageDead(BitArray::new(mir.local_decls.len()));\n+            let mut has_storage_dead = HasStorageDead(BitSet::new_empty(mir.local_decls.len()));\n             has_storage_dead.visit_mir(mir);\n             let mut has_storage_dead_or_moved = has_storage_dead.0;\n             for move_out in &move_data.moves {"}, {"sha": "16bb1ef78dc6f85c2000609280aa2f35b8e1e966", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -15,7 +15,7 @@\n \n use rustc::mir::{BasicBlock, Location};\n use rustc::ty::RegionVid;\n-use rustc_data_structures::bitvec::BitIter;\n+use rustc_data_structures::bit_set::BitIter;\n \n use borrow_check::location::LocationIndex;\n "}, {"sha": "521e7ade00ea9efb2edef0dd484ccaeb134cb0c9", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -26,9 +26,9 @@ use rustc::ty::query::Providers;\n use rustc::ty::{self, ParamEnv, TyCtxt, Ty};\n \n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, Level};\n-use rustc_data_structures::graph::dominators::Dominators;\n+use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::indexed_set::IdxSet;\n+use rustc_data_structures::graph::dominators::Dominators;\n use rustc_data_structures::indexed_vec::Idx;\n use smallvec::SmallVec;\n \n@@ -167,7 +167,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         _ => Some(tcx.hir.body_owned_by(id)),\n     };\n \n-    let dead_unwinds = IdxSet::new_empty(mir.basic_blocks().len());\n+    let dead_unwinds = BitSet::new_empty(mir.basic_blocks().len());\n     let mut flow_inits = FlowAtLocation::new(do_dataflow(\n         tcx,\n         mir,\n@@ -1595,7 +1595,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // Check if any of the initializiations of `local` have happened yet:\n         let mpi = self.move_data.rev_lookup.find_local(local);\n         let init_indices = &self.move_data.init_path_map[mpi];\n-        let first_init_index = init_indices.iter().find(|ii| flow_state.ever_inits.contains(ii));\n+        let first_init_index = init_indices.iter().find(|&ii| flow_state.ever_inits.contains(*ii));\n         if let Some(&init_index) = first_init_index {\n             // And, if so, report an error.\n             let init = &self.move_data.inits[init_index];\n@@ -1653,7 +1653,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         debug!(\"check_if_full_path_is_moved place: {:?}\", place_span.0);\n         match self.move_path_closest_to(place_span.0) {\n             Ok(mpi) => {\n-                if maybe_uninits.contains(&mpi) {\n+                if maybe_uninits.contains(mpi) {\n                     self.report_use_of_moved_or_uninitialized(\n                         context,\n                         desired_action,\n@@ -1969,7 +1969,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     // keyword, since the mutation may be a possible reassignment.\n                     let mpi = self.move_data.rev_lookup.find_local(*local);\n                     let ii = &self.move_data.init_path_map[mpi];\n-                    for index in ii {\n+                    for &index in ii {\n                         if flow_state.ever_inits.contains(index) {\n                             self.used_mut.insert(*local);\n                             break;"}, {"sha": "d1713a520a79c7178767ae275c7cb2cd3c081320", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -26,8 +26,8 @@ use rustc::mir::{\n };\n use rustc::ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc::util::common;\n+use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::graph::scc::Sccs;\n-use rustc_data_structures::indexed_set::IdxSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_errors::{DiagnosticBuilder, Diagnostic};\n \n@@ -477,7 +477,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // SCC. For each SCC, we visit its successors and compute\n         // their values, then we union all those values to get our\n         // own.\n-        let visited = &mut IdxSet::new_empty(self.constraint_sccs.num_sccs());\n+        let visited = &mut BitSet::new_empty(self.constraint_sccs.num_sccs());\n         for scc_index in self.constraint_sccs.all_sccs() {\n             self.propagate_constraint_sccs_if_new(scc_index, visited);\n         }\n@@ -487,17 +487,17 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn propagate_constraint_sccs_if_new(\n         &mut self,\n         scc_a: ConstraintSccIndex,\n-        visited: &mut IdxSet<ConstraintSccIndex>,\n+        visited: &mut BitSet<ConstraintSccIndex>,\n     ) {\n-        if visited.add(&scc_a) {\n+        if visited.insert(scc_a) {\n             self.propagate_constraint_sccs_new(scc_a, visited);\n         }\n     }\n \n     fn propagate_constraint_sccs_new(\n         &mut self,\n         scc_a: ConstraintSccIndex,\n-        visited: &mut IdxSet<ConstraintSccIndex>,\n+        visited: &mut BitSet<ConstraintSccIndex>,\n     ) {\n         let constraint_sccs = self.constraint_sccs.clone();\n "}, {"sha": "618bf99c7c0a9a6fd79f938375362ac87eb4a2bb", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::ty::{self, RegionVid};\n-use rustc_data_structures::bitvec::{BitArray, SparseBitMatrix};\n+use rustc_data_structures::bit_set::{BitSet, SparseBitMatrix};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::fmt::Debug;\n@@ -179,19 +179,19 @@ impl<N: Idx> LivenessValues<N> {\n     crate fn add_element(&mut self, row: N, location: Location) -> bool {\n         debug!(\"LivenessValues::add(r={:?}, location={:?})\", row, location);\n         let index = self.elements.point_from_location(location);\n-        self.points.add(row, index)\n+        self.points.insert(row, index)\n     }\n \n     /// Adds all the elements in the given bit array into the given\n     /// region. Returns true if any of them are newly added.\n-    crate fn add_elements(&mut self, row: N, locations: &BitArray<PointIndex>) -> bool {\n+    crate fn add_elements(&mut self, row: N, locations: &BitSet<PointIndex>) -> bool {\n         debug!(\"LivenessValues::add_elements(row={:?}, locations={:?})\", row, locations);\n-        self.points.merge_into(row, locations)\n+        self.points.union_into_row(row, locations)\n     }\n \n     /// Adds all the control-flow points to the values for `r`.\n     crate fn add_all_points(&mut self, row: N) {\n-        self.points.add_all(row);\n+        self.points.insert_all_into_row(row);\n     }\n \n     /// True if the region `r` contains the given element.\n@@ -270,15 +270,15 @@ impl<N: Idx> RegionValues<N> {\n \n     /// Adds all the control-flow points to the values for `r`.\n     crate fn add_all_points(&mut self, r: N) {\n-        self.points.add_all(r);\n+        self.points.insert_all_into_row(r);\n     }\n \n     /// Add all elements in `r_from` to `r_to` (because e.g. `r_to:\n     /// r_from`).\n     crate fn add_region(&mut self, r_to: N, r_from: N) -> bool {\n-        self.points.merge(r_from, r_to)\n-            | self.free_regions.merge(r_from, r_to)\n-            | self.placeholders.merge(r_from, r_to)\n+        self.points.union_rows(r_from, r_to)\n+            | self.free_regions.union_rows(r_from, r_to)\n+            | self.placeholders.union_rows(r_from, r_to)\n     }\n \n     /// True if the region `r` contains the given element.\n@@ -291,7 +291,7 @@ impl<N: Idx> RegionValues<N> {\n     /// the region `to` in `self`.\n     crate fn merge_liveness<M: Idx>(&mut self, to: N, from: M, values: &LivenessValues<M>) {\n         if let Some(set) = values.points.row(from) {\n-            self.points.merge_into(to, set);\n+            self.points.union_into_row(to, set);\n         }\n     }\n \n@@ -300,7 +300,7 @@ impl<N: Idx> RegionValues<N> {\n     crate fn contains_points(&self, sup_region: N, sub_region: N) -> bool {\n         if let Some(sub_row) = self.points.row(sub_region) {\n             if let Some(sup_row) = self.points.row(sup_region) {\n-                sup_row.contains_all(sub_row)\n+                sup_row.superset(sub_row)\n             } else {\n                 // sup row is empty, so sub row must be empty\n                 sub_row.is_empty()\n@@ -378,7 +378,7 @@ crate trait ToElementIndex: Debug + Copy {\n impl ToElementIndex for Location {\n     fn add_to_row<N: Idx>(self, values: &mut RegionValues<N>, row: N) -> bool {\n         let index = values.elements.point_from_location(self);\n-        values.points.add(row, index)\n+        values.points.insert(row, index)\n     }\n \n     fn contained_in_row<N: Idx>(self, values: &RegionValues<N>, row: N) -> bool {\n@@ -389,7 +389,7 @@ impl ToElementIndex for Location {\n \n impl ToElementIndex for RegionVid {\n     fn add_to_row<N: Idx>(self, values: &mut RegionValues<N>, row: N) -> bool {\n-        values.free_regions.add(row, self)\n+        values.free_regions.insert(row, self)\n     }\n \n     fn contained_in_row<N: Idx>(self, values: &RegionValues<N>, row: N) -> bool {\n@@ -400,7 +400,7 @@ impl ToElementIndex for RegionVid {\n impl ToElementIndex for ty::UniverseIndex {\n     fn add_to_row<N: Idx>(self, values: &mut RegionValues<N>, row: N) -> bool {\n         let index = PlaceholderIndex::new(self.as_usize() - 1);\n-        values.placeholders.add(row, index)\n+        values.placeholders.insert(row, index)\n     }\n \n     fn contained_in_row<N: Idx>(self, values: &RegionValues<N>, row: N) -> bool {"}, {"sha": "b6410f7de3d5d7b28395eb199686830f0146883e", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -22,7 +22,7 @@ use rustc::traits::query::dropck_outlives::DropckOutlivesResult;\n use rustc::traits::query::type_op::outlives::DropckOutlives;\n use rustc::traits::query::type_op::TypeOp;\n use rustc::ty::{Ty, TypeFoldable};\n-use rustc_data_structures::bitvec::BitArray;\n+use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::fx::FxHashMap;\n use std::rc::Rc;\n use util::liveness::LiveVariableMap;\n@@ -121,16 +121,16 @@ where\n     cx: LivenessContext<'me, 'typeck, 'flow, 'gcx, 'tcx>,\n \n     /// Set of points that define the current local.\n-    defs: BitArray<PointIndex>,\n+    defs: BitSet<PointIndex>,\n \n     /// Points where the current variable is \"use live\" -- meaning\n     /// that there is a future \"full use\" that may use its value.\n-    use_live_at: BitArray<PointIndex>,\n+    use_live_at: BitSet<PointIndex>,\n \n     /// Points where the current variable is \"drop live\" -- meaning\n     /// that there is no future \"full use\" that may use its value, but\n     /// there is a future drop.\n-    drop_live_at: BitArray<PointIndex>,\n+    drop_live_at: BitSet<PointIndex>,\n \n     /// Locations where drops may occur.\n     drop_locations: Vec<Location>,\n@@ -144,9 +144,9 @@ impl LivenessResults<'me, 'typeck, 'flow, 'gcx, 'tcx> {\n         let num_points = cx.elements.num_points();\n         LivenessResults {\n             cx,\n-            defs: BitArray::new(num_points),\n-            use_live_at: BitArray::new(num_points),\n-            drop_live_at: BitArray::new(num_points),\n+            defs: BitSet::new_empty(num_points),\n+            use_live_at: BitSet::new_empty(num_points),\n+            drop_live_at: BitSet::new_empty(num_points),\n             drop_locations: vec![],\n             stack: vec![],\n         }\n@@ -448,7 +448,7 @@ impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n     fn add_use_live_facts_for(\n         &mut self,\n         value: impl TypeFoldable<'tcx>,\n-        live_at: &BitArray<PointIndex>,\n+        live_at: &BitSet<PointIndex>,\n     ) {\n         debug!(\"add_use_live_facts_for(value={:?})\", value);\n \n@@ -465,7 +465,7 @@ impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n         dropped_local: Local,\n         dropped_ty: Ty<'tcx>,\n         drop_locations: &[Location],\n-        live_at: &BitArray<PointIndex>,\n+        live_at: &BitSet<PointIndex>,\n     ) {\n         debug!(\n             \"add_drop_live_constraint(\\\n@@ -508,7 +508,7 @@ impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n         elements: &RegionValueElements,\n         typeck: &mut TypeChecker<'_, '_, 'tcx>,\n         value: impl TypeFoldable<'tcx>,\n-        live_at: &BitArray<PointIndex>,\n+        live_at: &BitSet<PointIndex>,\n     ) {\n         debug!(\"make_all_regions_live(value={:?})\", value);\n         debug!("}, {"sha": "49c4ed874bbe971c9b775476e035d228a54764f8", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -21,7 +21,7 @@ use hair::*;\n use rustc::hir;\n use rustc::mir::*;\n use rustc::ty::{self, CanonicalTy, Ty};\n-use rustc_data_structures::bitvec::BitArray;\n+use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::fx::FxHashMap;\n use syntax::ast::{Name, NodeId};\n use syntax_pos::Span;\n@@ -635,7 +635,7 @@ enum TestKind<'tcx> {\n     // test the branches of enum\n     Switch {\n         adt_def: &'tcx ty::AdtDef,\n-        variants: BitArray<usize>,\n+        variants: BitSet<usize>,\n     },\n \n     // test the branches of enum"}, {"sha": "caef3ef80dbc2c43ef26420a10f9943faa360656", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -18,8 +18,8 @@\n use build::Builder;\n use build::matches::{Candidate, MatchPair, Test, TestKind};\n use hair::*;\n+use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::bitvec::BitArray;\n use rustc::ty::{self, Ty};\n use rustc::ty::util::IntTypeExt;\n use rustc::mir::*;\n@@ -38,7 +38,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Switch {\n                         adt_def: adt_def.clone(),\n-                        variants: BitArray::new(adt_def.variants.len()),\n+                        variants: BitSet::new_empty(adt_def.variants.len()),\n                     },\n                 }\n             }\n@@ -152,7 +152,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn add_variants_to_switch<'pat>(&mut self,\n                                         test_place: &Place<'tcx>,\n                                         candidate: &Candidate<'pat, 'tcx>,\n-                                        variants: &mut BitArray<usize>)\n+                                        variants: &mut BitSet<usize>)\n                                         -> bool\n     {\n         let match_pair = match candidate.match_pairs.iter().find(|mp| mp.place == *test_place) {"}, {"sha": "d815bfedc3713237ea72d6ae3102a50d940d4b1d", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -12,8 +12,7 @@\n //! locations.\n \n use rustc::mir::{BasicBlock, Location};\n-use rustc_data_structures::bitvec::BitIter;\n-use rustc_data_structures::indexed_set::{HybridIdxSet, IdxSet};\n+use rustc_data_structures::bit_set::{BitIter, BitSet, HybridBitSet};\n \n use dataflow::{BitDenotation, BlockSets, DataflowResults};\n use dataflow::move_paths::{HasMoveData, MovePathIndex};\n@@ -76,9 +75,9 @@ where\n     BD: BitDenotation,\n {\n     base_results: DataflowResults<BD>,\n-    curr_state: IdxSet<BD::Idx>,\n-    stmt_gen: HybridIdxSet<BD::Idx>,\n-    stmt_kill: HybridIdxSet<BD::Idx>,\n+    curr_state: BitSet<BD::Idx>,\n+    stmt_gen: HybridBitSet<BD::Idx>,\n+    stmt_kill: HybridBitSet<BD::Idx>,\n }\n \n impl<BD> FlowAtLocation<BD>\n@@ -105,9 +104,9 @@ where\n \n     pub fn new(results: DataflowResults<BD>) -> Self {\n         let bits_per_block = results.sets().bits_per_block();\n-        let curr_state = IdxSet::new_empty(bits_per_block);\n-        let stmt_gen = HybridIdxSet::new_empty(bits_per_block);\n-        let stmt_kill = HybridIdxSet::new_empty(bits_per_block);\n+        let curr_state = BitSet::new_empty(bits_per_block);\n+        let stmt_gen = HybridBitSet::new_empty(bits_per_block);\n+        let stmt_kill = HybridBitSet::new_empty(bits_per_block);\n         FlowAtLocation {\n             base_results: results,\n             curr_state: curr_state,\n@@ -121,7 +120,7 @@ where\n         self.base_results.operator()\n     }\n \n-    pub fn contains(&self, x: &BD::Idx) -> bool {\n+    pub fn contains(&self, x: BD::Idx) -> bool {\n         self.curr_state.contains(x)\n     }\n \n@@ -224,7 +223,7 @@ where\n         //   siblings);\n         // - ~99% of the time the loop isn't reached, and this code is hot, so\n         //   we don't want to allocate `todo` unnecessarily.\n-        if self.contains(&mpi) {\n+        if self.contains(mpi) {\n             return Some(mpi);\n         }\n         let move_data = self.operator().move_data();\n@@ -236,7 +235,7 @@ where\n         };\n \n         while let Some(mpi) = todo.pop() {\n-            if self.contains(&mpi) {\n+            if self.contains(mpi) {\n                 return Some(mpi);\n             }\n             let move_path = &move_data.move_paths[mpi];"}, {"sha": "45baab844abc35cdcf1e517e6bbe84223f1ee2b3", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -12,7 +12,6 @@\n \n use syntax::ast::NodeId;\n use rustc::mir::{BasicBlock, Mir};\n-use rustc_data_structures::bitvec::bits_to_string;\n \n use dot;\n use dot::IntoCow;\n@@ -223,7 +222,7 @@ where MWF: MirWithFlowState<'tcx>,\n \n         // Entry\n         let set = flow.sets.on_entry_set_for(i);\n-        write!(w, \"<td>{:?}</td>\", dot::escape_html(&bits_to_string(set.words(), bits_per_block)))?;\n+        write!(w, \"<td>{:?}</td>\", dot::escape_html(&set.to_string(bits_per_block)))?;\n \n         // Terminator\n         write!(w, \"<td>\")?;"}, {"sha": "8d186597b142c32517a3ccd680549971c9595780", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -43,7 +43,7 @@ impl<'a, 'tcx> BitDenotation for HaveBeenBorrowedLocals<'a, 'tcx> {\n         self.mir.local_decls.len()\n     }\n \n-    fn start_block_effect(&self, _sets: &mut IdxSet<Local>) {\n+    fn start_block_effect(&self, _sets: &mut BitSet<Local>) {\n         // Nothing is borrowed on function entry\n     }\n \n@@ -58,7 +58,7 @@ impl<'a, 'tcx> BitDenotation for HaveBeenBorrowedLocals<'a, 'tcx> {\n \n         // StorageDead invalidates all borrows and raw pointers to a local\n         match stmt.kind {\n-            StatementKind::StorageDead(l) => sets.kill(&l),\n+            StatementKind::StorageDead(l) => sets.kill(l),\n             _ => (),\n         }\n     }\n@@ -72,18 +72,18 @@ impl<'a, 'tcx> BitDenotation for HaveBeenBorrowedLocals<'a, 'tcx> {\n     }\n \n     fn propagate_call_return(&self,\n-                             _in_out: &mut IdxSet<Local>,\n+                             _in_out: &mut BitSet<Local>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n                              _dest_place: &mir::Place) {\n         // Nothing to do when a call returns successfully\n     }\n }\n \n-impl<'a, 'tcx> BitwiseOperator for HaveBeenBorrowedLocals<'a, 'tcx> {\n+impl<'a, 'tcx> BitSetOperator for HaveBeenBorrowedLocals<'a, 'tcx> {\n     #[inline]\n-    fn join(&self, pred1: Word, pred2: Word) -> Word {\n-        pred1 | pred2 // \"maybe\" means we union effects of both preds\n+    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n+        inout_set.union(in_set) // \"maybe\" means we union effects of both preds\n     }\n }\n \n@@ -118,7 +118,7 @@ impl<'tcx, 'b, 'c> Visitor<'tcx> for BorrowedLocalsVisitor<'b, 'c> {\n                     location: Location) {\n         if let Rvalue::Ref(_, _, ref place) = *rvalue {\n             if let Some(local) = find_local(place) {\n-                self.sets.gen(&local);\n+                self.sets.gen(local);\n             }\n         }\n "}, {"sha": "010ffafc4bd60db7e057529b301a01cf478ec368", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -20,10 +20,9 @@ use rustc::ty::TyCtxt;\n use rustc::ty::{RegionKind, RegionVid};\n use rustc::ty::RegionKind::ReScope;\n \n-use rustc_data_structures::bitvec::{BitwiseOperator, Word};\n+use rustc_data_structures::bit_set::{BitSet, BitSetOperator};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::indexed_set::IdxSet;\n-use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::sync::Lrc;\n \n use dataflow::{BitDenotation, BlockSets, InitialFlow};\n@@ -230,7 +229,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n         self.borrow_set.borrows.len() * 2\n     }\n \n-    fn start_block_effect(&self, _entry_set: &mut IdxSet<BorrowIndex>) {\n+    fn start_block_effect(&self, _entry_set: &mut BitSet<BorrowIndex>) {\n         // no borrows of code region_scopes have been taken prior to\n         // function execution, so this method has no effect on\n         // `_sets`.\n@@ -289,7 +288,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                         debug!(\"Borrows::statement_effect_on_borrows \\\n                                 location: {:?} stmt: {:?} has empty region, killing {:?}\",\n                                location, stmt.kind, index);\n-                        sets.kill(&index);\n+                        sets.kill(*index);\n                         return\n                     } else {\n                         debug!(\"Borrows::statement_effect_on_borrows location: {:?} stmt: {:?}\",\n@@ -299,7 +298,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                     assert!(self.borrow_set.region_map.get(region).unwrap_or_else(|| {\n                         panic!(\"could not find BorrowIndexs for region {:?}\", region);\n                     }).contains(&index));\n-                    sets.gen(&index);\n+                    sets.gen(*index);\n \n                     // Issue #46746: Two-phase borrows handles\n                     // stmts of form `Tmp = &mut Borrow` ...\n@@ -311,7 +310,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                             // e.g. `box (&mut _)`. Current\n                             // conservative solution: force\n                             // immediate activation here.\n-                            sets.gen(&index);\n+                            sets.gen(*index);\n                         }\n                     }\n                 }\n@@ -381,7 +380,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                             if *scope != root_scope &&\n                                 self.scope_tree.is_subscope_of(*scope, root_scope)\n                             {\n-                                sets.kill(&borrow_index);\n+                                sets.kill(borrow_index);\n                             }\n                         }\n                     }\n@@ -402,7 +401,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n     }\n \n     fn propagate_call_return(&self,\n-                             _in_out: &mut IdxSet<BorrowIndex>,\n+                             _in_out: &mut BitSet<BorrowIndex>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n                              _dest_place: &mir::Place) {\n@@ -414,10 +413,10 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitwiseOperator for Borrows<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitSetOperator for Borrows<'a, 'gcx, 'tcx> {\n     #[inline]\n-    fn join(&self, pred1: Word, pred2: Word) -> Word {\n-        pred1 | pred2 // union effects of preds when computing reservations\n+    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n+        inout_set.union(in_set) // \"maybe\" means we union effects of both preds\n     }\n }\n "}, {"sha": "984d1f686d987bfeb645d3ce1e15b8004fe5add2", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -14,8 +14,7 @@\n \n use rustc::ty::TyCtxt;\n use rustc::mir::{self, Mir, Location};\n-use rustc_data_structures::bitvec::{BitwiseOperator, Word};\n-use rustc_data_structures::indexed_set::{IdxSet};\n+use rustc_data_structures::bit_set::{BitSet, BitSetOperator};\n use rustc_data_structures::indexed_vec::Idx;\n \n use super::MoveDataParamEnv;\n@@ -266,8 +265,8 @@ impl<'a, 'gcx, 'tcx> MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n                    state: DropFlagState)\n     {\n         match state {\n-            DropFlagState::Absent => sets.kill(&path),\n-            DropFlagState::Present => sets.gen(&path),\n+            DropFlagState::Absent => sets.kill(path),\n+            DropFlagState::Present => sets.gen(path),\n         }\n     }\n }\n@@ -277,8 +276,8 @@ impl<'a, 'gcx, 'tcx> MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n                    state: DropFlagState)\n     {\n         match state {\n-            DropFlagState::Absent => sets.gen(&path),\n-            DropFlagState::Present => sets.kill(&path),\n+            DropFlagState::Absent => sets.gen(path),\n+            DropFlagState::Present => sets.kill(path),\n         }\n     }\n }\n@@ -288,8 +287,8 @@ impl<'a, 'gcx, 'tcx> DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n                    state: DropFlagState)\n     {\n         match state {\n-            DropFlagState::Absent => sets.kill(&path),\n-            DropFlagState::Present => sets.gen(&path),\n+            DropFlagState::Absent => sets.kill(path),\n+            DropFlagState::Present => sets.gen(path),\n         }\n     }\n }\n@@ -301,12 +300,12 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n         self.move_data().move_paths.len()\n     }\n \n-    fn start_block_effect(&self, entry_set: &mut IdxSet<MovePathIndex>) {\n+    fn start_block_effect(&self, entry_set: &mut BitSet<MovePathIndex>) {\n         drop_flag_effects_for_function_entry(\n             self.tcx, self.mir, self.mdpe,\n             |path, s| {\n                 assert!(s == DropFlagState::Present);\n-                entry_set.add(&path);\n+                entry_set.insert(path);\n             });\n     }\n \n@@ -333,15 +332,15 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n     }\n \n     fn propagate_call_return(&self,\n-                             in_out: &mut IdxSet<MovePathIndex>,\n+                             in_out: &mut BitSet<MovePathIndex>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n                              dest_place: &mir::Place) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_place to 1 (initialized).\n         on_lookup_result_bits(self.tcx, self.mir, self.move_data(),\n                               self.move_data().rev_lookup.find(dest_place),\n-                              |mpi| { in_out.add(&mpi); });\n+                              |mpi| { in_out.insert(mpi); });\n     }\n }\n \n@@ -353,15 +352,15 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MaybeUninitializedPlaces<'a, 'gcx, 'tcx>\n     }\n \n     // sets on_entry bits for Arg places\n-    fn start_block_effect(&self, entry_set: &mut IdxSet<MovePathIndex>) {\n+    fn start_block_effect(&self, entry_set: &mut BitSet<MovePathIndex>) {\n         // set all bits to 1 (uninit) before gathering counterevidence\n         entry_set.set_up_to(self.bits_per_block());\n \n         drop_flag_effects_for_function_entry(\n             self.tcx, self.mir, self.mdpe,\n             |path, s| {\n                 assert!(s == DropFlagState::Present);\n-                entry_set.remove(&path);\n+                entry_set.remove(path);\n             });\n     }\n \n@@ -388,15 +387,15 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MaybeUninitializedPlaces<'a, 'gcx, 'tcx>\n     }\n \n     fn propagate_call_return(&self,\n-                             in_out: &mut IdxSet<MovePathIndex>,\n+                             in_out: &mut BitSet<MovePathIndex>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n                              dest_place: &mir::Place) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_place to 0 (initialized).\n         on_lookup_result_bits(self.tcx, self.mir, self.move_data(),\n                               self.move_data().rev_lookup.find(dest_place),\n-                              |mpi| { in_out.remove(&mpi); });\n+                              |mpi| { in_out.remove(mpi); });\n     }\n }\n \n@@ -408,14 +407,14 @@ impl<'a, 'gcx, 'tcx> BitDenotation for DefinitelyInitializedPlaces<'a, 'gcx, 'tc\n     }\n \n     // sets on_entry bits for Arg places\n-    fn start_block_effect(&self, entry_set: &mut IdxSet<MovePathIndex>) {\n+    fn start_block_effect(&self, entry_set: &mut BitSet<MovePathIndex>) {\n         entry_set.clear();\n \n         drop_flag_effects_for_function_entry(\n             self.tcx, self.mir, self.mdpe,\n             |path, s| {\n                 assert!(s == DropFlagState::Present);\n-                entry_set.add(&path);\n+                entry_set.insert(path);\n             });\n     }\n \n@@ -442,15 +441,15 @@ impl<'a, 'gcx, 'tcx> BitDenotation for DefinitelyInitializedPlaces<'a, 'gcx, 'tc\n     }\n \n     fn propagate_call_return(&self,\n-                             in_out: &mut IdxSet<MovePathIndex>,\n+                             in_out: &mut BitSet<MovePathIndex>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n                              dest_place: &mir::Place) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_place to 1 (initialized).\n         on_lookup_result_bits(self.tcx, self.mir, self.move_data(),\n                               self.move_data().rev_lookup.find(dest_place),\n-                              |mpi| { in_out.add(&mpi); });\n+                              |mpi| { in_out.insert(mpi); });\n     }\n }\n \n@@ -461,9 +460,9 @@ impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n         self.move_data().inits.len()\n     }\n \n-    fn start_block_effect(&self, entry_set: &mut IdxSet<InitIndex>) {\n+    fn start_block_effect(&self, entry_set: &mut BitSet<InitIndex>) {\n         for arg_init in 0..self.mir.arg_count {\n-            entry_set.add(&InitIndex::new(arg_init));\n+            entry_set.insert(InitIndex::new(arg_init));\n         }\n     }\n \n@@ -531,7 +530,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n     }\n \n     fn propagate_call_return(&self,\n-                             in_out: &mut IdxSet<InitIndex>,\n+                             in_out: &mut BitSet<InitIndex>,\n                              call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n                              _dest_place: &mir::Place) {\n@@ -545,36 +544,36 @@ impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n         };\n         for init_index in &init_loc_map[call_loc] {\n             assert!(init_index.index() < bits_per_block);\n-            in_out.add(init_index);\n+            in_out.insert(*init_index);\n         }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitwiseOperator for MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitSetOperator for MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n     #[inline]\n-    fn join(&self, pred1: Word, pred2: Word) -> Word {\n-        pred1 | pred2 // \"maybe\" means we union effects of both preds\n+    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n+        inout_set.union(in_set) // \"maybe\" means we union effects of both preds\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitwiseOperator for MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitSetOperator for MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n     #[inline]\n-    fn join(&self, pred1: Word, pred2: Word) -> Word {\n-        pred1 | pred2 // \"maybe\" means we union effects of both preds\n+    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n+        inout_set.union(in_set) // \"maybe\" means we union effects of both preds\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitwiseOperator for DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitSetOperator for DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n     #[inline]\n-    fn join(&self, pred1: Word, pred2: Word) -> Word {\n-        pred1 & pred2 // \"definitely\" means we intersect effects of both preds\n+    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n+        inout_set.intersect(in_set) // \"definitely\" means we intersect effects of both preds\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitwiseOperator for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitSetOperator for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n     #[inline]\n-    fn join(&self, pred1: Word, pred2: Word) -> Word {\n-        pred1 | pred2 // inits from both preds are in scope\n+    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n+        inout_set.union(in_set) // inits from both preds are in scope\n     }\n }\n "}, {"sha": "ab03ace23d7b4ef635a9c39f6e82bee7da5dc15e", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> BitDenotation for MaybeStorageLive<'a, 'tcx> {\n         self.mir.local_decls.len()\n     }\n \n-    fn start_block_effect(&self, _sets: &mut IdxSet<Local>) {\n+    fn start_block_effect(&self, _sets: &mut BitSet<Local>) {\n         // Nothing is live on function entry\n     }\n \n@@ -46,8 +46,8 @@ impl<'a, 'tcx> BitDenotation for MaybeStorageLive<'a, 'tcx> {\n         let stmt = &self.mir[loc.block].statements[loc.statement_index];\n \n         match stmt.kind {\n-            StatementKind::StorageLive(l) => sets.gen(&l),\n-            StatementKind::StorageDead(l) => sets.kill(&l),\n+            StatementKind::StorageLive(l) => sets.gen(l),\n+            StatementKind::StorageDead(l) => sets.kill(l),\n             _ => (),\n         }\n     }\n@@ -59,18 +59,18 @@ impl<'a, 'tcx> BitDenotation for MaybeStorageLive<'a, 'tcx> {\n     }\n \n     fn propagate_call_return(&self,\n-                             _in_out: &mut IdxSet<Local>,\n+                             _in_out: &mut BitSet<Local>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n                              _dest_place: &mir::Place) {\n         // Nothing to do when a call returns successfully\n     }\n }\n \n-impl<'a, 'tcx> BitwiseOperator for MaybeStorageLive<'a, 'tcx> {\n+impl<'a, 'tcx> BitSetOperator for MaybeStorageLive<'a, 'tcx> {\n     #[inline]\n-    fn join(&self, pred1: Word, pred2: Word) -> Word {\n-        pred1 | pred2 // \"maybe\" means we union effects of both preds\n+    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n+        inout_set.union(in_set) // \"maybe\" means we union effects of both preds\n     }\n }\n "}, {"sha": "1e362e6f0dccfeb55b816d62192216370f1d1589", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 38, "deletions": 41, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -10,8 +10,7 @@\n \n use syntax::ast::{self, MetaItem};\n \n-use rustc_data_structures::bitvec::{bitwise, BitwiseOperator};\n-use rustc_data_structures::indexed_set::{HybridIdxSet, IdxSet};\n+use rustc_data_structures::bit_set::{BitSet, BitSetOperator, HybridBitSet};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::work_queue::WorkQueue;\n \n@@ -125,7 +124,7 @@ pub(crate) fn do_dataflow<'a, 'gcx, 'tcx, BD, P>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                                  mir: &'a Mir<'tcx>,\n                                                  node_id: ast::NodeId,\n                                                  attributes: &[ast::Attribute],\n-                                                 dead_unwinds: &IdxSet<BasicBlock>,\n+                                                 dead_unwinds: &BitSet<BasicBlock>,\n                                                  bd: BD,\n                                                  p: P)\n                                                  -> DataflowResults<BD>\n@@ -182,7 +181,7 @@ struct PropagationContext<'b, 'a: 'b, 'tcx: 'a, O> where O: 'b + BitDenotation\n impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation\n {\n     fn propagate(&mut self) {\n-        let mut temp = IdxSet::new_empty(self.flow_state.sets.bits_per_block);\n+        let mut temp = BitSet::new_empty(self.flow_state.sets.bits_per_block);\n         let mut propcx = PropagationContext {\n             builder: self,\n         };\n@@ -231,7 +230,7 @@ impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation\n \n impl<'b, 'a: 'b, 'tcx: 'a, BD> PropagationContext<'b, 'a, 'tcx, BD> where BD: BitDenotation\n {\n-    fn walk_cfg(&mut self, in_out: &mut IdxSet<BD::Idx>) {\n+    fn walk_cfg(&mut self, in_out: &mut BitSet<BD::Idx>) {\n         let mut dirty_queue: WorkQueue<mir::BasicBlock> =\n             WorkQueue::with_all(self.builder.mir.basic_blocks().len());\n         let mir = self.builder.mir;\n@@ -352,7 +351,7 @@ pub fn state_for_location<'tcx, T: BitDenotation>(loc: Location,\n                                                   analysis: &T,\n                                                   result: &DataflowResults<T>,\n                                                   mir: &Mir<'tcx>)\n-    -> IdxSet<T::Idx> {\n+    -> BitSet<T::Idx> {\n     let mut on_entry = result.sets().on_entry_set_for(loc.block.index()).to_owned();\n     let mut kill_set = on_entry.to_hybrid();\n     let mut gen_set = kill_set.clone();\n@@ -385,7 +384,7 @@ pub fn state_for_location<'tcx, T: BitDenotation>(loc: Location,\n pub struct DataflowAnalysis<'a, 'tcx: 'a, O> where O: BitDenotation\n {\n     flow_state: DataflowState<O>,\n-    dead_unwinds: &'a IdxSet<mir::BasicBlock>,\n+    dead_unwinds: &'a BitSet<mir::BasicBlock>,\n     mir: &'a Mir<'tcx>,\n }\n \n@@ -426,7 +425,7 @@ pub struct DataflowState<O: BitDenotation>\n impl<O: BitDenotation> DataflowState<O> {\n     pub(crate) fn interpret_set<'c, P>(&self,\n                                        o: &'c O,\n-                                       set: &IdxSet<O::Idx>,\n+                                       set: &BitSet<O::Idx>,\n                                        render_idx: &P)\n                                        -> Vec<DebugFormatted>\n         where P: Fn(&O, O::Idx) -> DebugFormatted\n@@ -436,7 +435,7 @@ impl<O: BitDenotation> DataflowState<O> {\n \n     pub(crate) fn interpret_hybrid_set<'c, P>(&self,\n                                               o: &'c O,\n-                                              set: &HybridIdxSet<O::Idx>,\n+                                              set: &HybridBitSet<O::Idx>,\n                                               render_idx: &P)\n                                               -> Vec<DebugFormatted>\n         where P: Fn(&O, O::Idx) -> DebugFormatted\n@@ -451,21 +450,21 @@ pub struct AllSets<E: Idx> {\n     bits_per_block: usize,\n \n     /// For each block, bits valid on entry to the block.\n-    on_entry_sets: Vec<IdxSet<E>>,\n+    on_entry_sets: Vec<BitSet<E>>,\n \n     /// For each block, bits generated by executing the statements +\n     /// terminator in the block -- with one caveat. In particular, for\n     /// *call terminators*, the effect of storing the destination is\n     /// not included, since that only takes effect on the **success**\n     /// edge (and not the unwind edge).\n-    gen_sets: Vec<HybridIdxSet<E>>,\n+    gen_sets: Vec<HybridBitSet<E>>,\n \n     /// For each block, bits killed by executing the statements +\n     /// terminator in the block -- with one caveat. In particular, for\n     /// *call terminators*, the effect of storing the destination is\n     /// not included, since that only takes effect on the **success**\n     /// edge (and not the unwind edge).\n-    kill_sets: Vec<HybridIdxSet<E>>,\n+    kill_sets: Vec<HybridBitSet<E>>,\n }\n \n /// Triple of sets associated with a given block.\n@@ -485,42 +484,42 @@ pub struct AllSets<E: Idx> {\n #[derive(Debug)]\n pub struct BlockSets<'a, E: Idx> {\n     /// Dataflow state immediately before control flow enters the given block.\n-    pub(crate) on_entry: &'a mut IdxSet<E>,\n+    pub(crate) on_entry: &'a mut BitSet<E>,\n \n     /// Bits that are set to 1 by the time we exit the given block. Hybrid\n     /// because it usually contains only 0 or 1 elements.\n-    pub(crate) gen_set: &'a mut HybridIdxSet<E>,\n+    pub(crate) gen_set: &'a mut HybridBitSet<E>,\n \n     /// Bits that are set to 0 by the time we exit the given block. Hybrid\n     /// because it usually contains only 0 or 1 elements.\n-    pub(crate) kill_set: &'a mut HybridIdxSet<E>,\n+    pub(crate) kill_set: &'a mut HybridBitSet<E>,\n }\n \n impl<'a, E:Idx> BlockSets<'a, E> {\n-    fn gen(&mut self, e: &E) {\n-        self.gen_set.add(e);\n+    fn gen(&mut self, e: E) {\n+        self.gen_set.insert(e);\n         self.kill_set.remove(e);\n     }\n     fn gen_all<I>(&mut self, i: I)\n         where I: IntoIterator,\n               I::Item: Borrow<E>\n     {\n         for j in i {\n-            self.gen(j.borrow());\n+            self.gen(*j.borrow());\n         }\n     }\n \n-    fn kill(&mut self, e: &E) {\n+    fn kill(&mut self, e: E) {\n         self.gen_set.remove(e);\n-        self.kill_set.add(e);\n+        self.kill_set.insert(e);\n     }\n \n     fn kill_all<I>(&mut self, i: I)\n         where I: IntoIterator,\n               I::Item: Borrow<E>\n     {\n         for j in i {\n-            self.kill(j.borrow());\n+            self.kill(*j.borrow());\n         }\n     }\n \n@@ -540,13 +539,13 @@ impl<E:Idx> AllSets<E> {\n         }\n     }\n \n-    pub fn on_entry_set_for(&self, block_idx: usize) -> &IdxSet<E> {\n+    pub fn on_entry_set_for(&self, block_idx: usize) -> &BitSet<E> {\n         &self.on_entry_sets[block_idx]\n     }\n-    pub fn gen_set_for(&self, block_idx: usize) -> &HybridIdxSet<E> {\n+    pub fn gen_set_for(&self, block_idx: usize) -> &HybridBitSet<E> {\n         &self.gen_sets[block_idx]\n     }\n-    pub fn kill_set_for(&self, block_idx: usize) -> &HybridIdxSet<E> {\n+    pub fn kill_set_for(&self, block_idx: usize) -> &HybridBitSet<E> {\n         &self.kill_sets[block_idx]\n     }\n }\n@@ -562,7 +561,7 @@ pub trait InitialFlow {\n     fn bottom_value() -> bool;\n }\n \n-pub trait BitDenotation: BitwiseOperator {\n+pub trait BitDenotation: BitSetOperator {\n     /// Specifies what index type is used to access the bitvector.\n     type Idx: Idx;\n \n@@ -609,7 +608,7 @@ pub trait BitDenotation: BitwiseOperator {\n     /// these won't be accounted for correctly.\n     ///\n     /// (For example, establishing the call arguments.)\n-    fn start_block_effect(&self, entry_set: &mut IdxSet<Self::Idx>);\n+    fn start_block_effect(&self, entry_set: &mut BitSet<Self::Idx>);\n \n     /// Similar to `statement_effect`, except it applies\n     /// *just before* the statement rather than *just after* it.\n@@ -689,7 +688,7 @@ pub trait BitDenotation: BitwiseOperator {\n     /// kill-sets associated with each edge coming out of the basic\n     /// block.\n     fn propagate_call_return(&self,\n-                             in_out: &mut IdxSet<Self::Idx>,\n+                             in_out: &mut BitSet<Self::Idx>,\n                              call_bb: mir::BasicBlock,\n                              dest_bb: mir::BasicBlock,\n                              dest_place: &mir::Place);\n@@ -698,17 +697,17 @@ pub trait BitDenotation: BitwiseOperator {\n impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n {\n     pub fn new(mir: &'a Mir<'tcx>,\n-               dead_unwinds: &'a IdxSet<mir::BasicBlock>,\n+               dead_unwinds: &'a BitSet<mir::BasicBlock>,\n                denotation: D) -> Self where D: InitialFlow {\n         let bits_per_block = denotation.bits_per_block();\n         let num_blocks = mir.basic_blocks().len();\n \n         let on_entry_sets = if D::bottom_value() {\n-            vec![IdxSet::new_filled(bits_per_block); num_blocks]\n+            vec![BitSet::new_filled(bits_per_block); num_blocks]\n         } else {\n-            vec![IdxSet::new_empty(bits_per_block); num_blocks]\n+            vec![BitSet::new_empty(bits_per_block); num_blocks]\n         };\n-        let gen_sets = vec![HybridIdxSet::new_empty(bits_per_block); num_blocks];\n+        let gen_sets = vec![HybridBitSet::new_empty(bits_per_block); num_blocks];\n         let kill_sets = gen_sets.clone();\n \n         DataflowAnalysis {\n@@ -727,7 +726,7 @@ impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n     }\n \n     pub fn new_from_sets(mir: &'a Mir<'tcx>,\n-                         dead_unwinds: &'a IdxSet<mir::BasicBlock>,\n+                         dead_unwinds: &'a BitSet<mir::BasicBlock>,\n                          sets: AllSets<D::Idx>,\n                          denotation: D) -> Self {\n         DataflowAnalysis {\n@@ -758,7 +757,7 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n     /// unwind target).\n     fn propagate_bits_into_graph_successors_of(\n         &mut self,\n-        in_out: &mut IdxSet<D::Idx>,\n+        in_out: &mut BitSet<D::Idx>,\n         (bb, bb_data): (mir::BasicBlock, &mir::BasicBlockData),\n         dirty_list: &mut WorkQueue<mir::BasicBlock>)\n     {\n@@ -787,7 +786,7 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n                 target, value: _, location: _, unwind: Some(unwind)\n             } => {\n                 self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n-                if !self.dead_unwinds.contains(&bb) {\n+                if !self.dead_unwinds.contains(bb) {\n                     self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n                 }\n             }\n@@ -798,7 +797,7 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n             }\n             mir::TerminatorKind::Call { cleanup, ref destination, func: _, args: _ } => {\n                 if let Some(unwind) = cleanup {\n-                    if !self.dead_unwinds.contains(&bb) {\n+                    if !self.dead_unwinds.contains(bb) {\n                         self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n                     }\n                 }\n@@ -819,7 +818,7 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n             mir::TerminatorKind::FalseUnwind { real_target, unwind } => {\n                 self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n                 if let Some(unwind) = unwind {\n-                    if !self.dead_unwinds.contains(&bb) {\n+                    if !self.dead_unwinds.contains(bb) {\n                         self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n                     }\n                 }\n@@ -828,13 +827,11 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n     }\n \n     fn propagate_bits_into_entry_set_for(&mut self,\n-                                         in_out: &IdxSet<D::Idx>,\n+                                         in_out: &BitSet<D::Idx>,\n                                          bb: mir::BasicBlock,\n                                          dirty_queue: &mut WorkQueue<mir::BasicBlock>) {\n-        let entry_set = self.flow_state.sets.for_block(bb.index()).on_entry;\n-        let set_changed = bitwise(entry_set.words_mut(),\n-                                  in_out.words(),\n-                                  &self.flow_state.operator);\n+        let entry_set = &mut self.flow_state.sets.for_block(bb.index()).on_entry;\n+        let set_changed = self.flow_state.operator.join(entry_set, &in_out);\n         if set_changed {\n             dirty_queue.insert(bb);\n         }"}, {"sha": "d50ef2242faeeada6492a3c11f8e11d161e10e39", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -210,7 +210,7 @@ use rustc::util::common::time;\n \n use monomorphize::item::{MonoItemExt, DefPathBasedNames, InstantiationMode};\n \n-use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::bit_set::GrowableBitSet;\n use rustc_data_structures::sync::{MTRef, MTLock, ParallelIterator, par_iter};\n \n #[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n@@ -231,7 +231,7 @@ pub struct InliningMap<'tcx> {\n \n     // Contains one bit per mono item in the `targets` field. That bit\n     // is true if that mono item needs to be inlined into every CGU.\n-    inlines: BitVector<usize>,\n+    inlines: GrowableBitSet<usize>,\n }\n \n impl<'tcx> InliningMap<'tcx> {\n@@ -240,7 +240,7 @@ impl<'tcx> InliningMap<'tcx> {\n         InliningMap {\n             index: FxHashMap(),\n             targets: Vec::new(),\n-            inlines: BitVector::with_capacity(1024),\n+            inlines: GrowableBitSet::with_capacity(1024),\n         }\n     }\n "}, {"sha": "92b6af8b51f7f0e32e0d8c98d5fdefdb90c5a4e7", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -18,15 +18,14 @@ use dataflow::{self, do_dataflow, DebugFormatted};\n use rustc::ty::{self, TyCtxt};\n use rustc::mir::*;\n use rustc::util::nodemap::FxHashMap;\n-use rustc_data_structures::indexed_set::IdxSet;\n+use rustc_data_structures::bit_set::BitSet;\n+use std::fmt;\n+use syntax::ast;\n+use syntax_pos::Span;\n use transform::{MirPass, MirSource};\n use util::patch::MirPatch;\n use util::elaborate_drops::{DropFlagState, Unwind, elaborate_drop};\n use util::elaborate_drops::{DropElaborator, DropStyle, DropFlagMode};\n-use syntax::ast;\n-use syntax_pos::Span;\n-\n-use std::fmt;\n \n pub struct ElaborateDrops;\n \n@@ -92,12 +91,12 @@ fn find_dead_unwinds<'a, 'tcx>(\n     mir: &Mir<'tcx>,\n     id: ast::NodeId,\n     env: &MoveDataParamEnv<'tcx, 'tcx>)\n-    -> IdxSet<BasicBlock>\n+    -> BitSet<BasicBlock>\n {\n     debug!(\"find_dead_unwinds({:?})\", mir.span);\n     // We only need to do this pass once, because unwind edges can only\n     // reach cleanup blocks, which can't have unwind edges themselves.\n-    let mut dead_unwinds = IdxSet::new_empty(mir.basic_blocks().len());\n+    let mut dead_unwinds = BitSet::new_empty(mir.basic_blocks().len());\n     let flow_inits =\n         do_dataflow(tcx, mir, id, &[], &dead_unwinds,\n                     MaybeInitializedPlaces::new(tcx, mir, &env),\n@@ -111,7 +110,7 @@ fn find_dead_unwinds<'a, 'tcx>(\n \n         let mut init_data = InitializationData {\n             live: flow_inits.sets().on_entry_set_for(bb.index()).to_owned(),\n-            dead: IdxSet::new_empty(env.move_data.move_paths.len()),\n+            dead: BitSet::new_empty(env.move_data.move_paths.len()),\n         };\n         debug!(\"find_dead_unwinds @ {:?}: {:?}; init_data={:?}\",\n                bb, bb_data, init_data.live);\n@@ -138,16 +137,16 @@ fn find_dead_unwinds<'a, 'tcx>(\n \n         debug!(\"find_dead_unwinds @ {:?}: maybe_live={}\", bb, maybe_live);\n         if !maybe_live {\n-            dead_unwinds.add(&bb);\n+            dead_unwinds.insert(bb);\n         }\n     }\n \n     dead_unwinds\n }\n \n struct InitializationData {\n-    live: IdxSet<MovePathIndex>,\n-    dead: IdxSet<MovePathIndex>\n+    live: BitSet<MovePathIndex>,\n+    dead: BitSet<MovePathIndex>\n }\n \n impl InitializationData {\n@@ -162,19 +161,19 @@ impl InitializationData {\n                    loc, path, df);\n             match df {\n                 DropFlagState::Present => {\n-                    self.live.add(&path);\n-                    self.dead.remove(&path);\n+                    self.live.insert(path);\n+                    self.dead.remove(path);\n                 }\n                 DropFlagState::Absent => {\n-                    self.dead.add(&path);\n-                    self.live.remove(&path);\n+                    self.dead.insert(path);\n+                    self.live.remove(path);\n                 }\n             }\n         });\n     }\n \n     fn state(&self, path: MovePathIndex) -> (bool, bool) {\n-        (self.live.contains(&path), self.dead.contains(&path))\n+        (self.live.contains(path), self.dead.contains(path))\n     }\n }\n "}, {"sha": "96111519550f6ff18f6f387e5d2cc35f115190a7", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -69,7 +69,7 @@ use util::dump_mir;\n use util::liveness::{self, IdentityMap};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc_data_structures::indexed_set::IdxSet;\n+use rustc_data_structures::bit_set::BitSet;\n use std::borrow::Cow;\n use std::iter::once;\n use std::mem;\n@@ -331,7 +331,7 @@ impl<'tcx> Visitor<'tcx> for StorageIgnored {\n                        _location: Location) {\n         match statement.kind {\n             StatementKind::StorageLive(l) |\n-            StatementKind::StorageDead(l) => { self.0.remove(&l); }\n+            StatementKind::StorageDead(l) => { self.0.remove(l); }\n             _ => (),\n         }\n     }\n@@ -341,7 +341,7 @@ struct BorrowedLocals(liveness::LiveVarSet<Local>);\n \n fn mark_as_borrowed<'tcx>(place: &Place<'tcx>, locals: &mut BorrowedLocals) {\n     match *place {\n-        Place::Local(l) => { locals.0.add(&l); },\n+        Place::Local(l) => { locals.0.insert(l); },\n         Place::Promoted(_) |\n         Place::Static(..) => (),\n         Place::Projection(ref proj) => {\n@@ -376,7 +376,7 @@ fn locals_live_across_suspend_points(\n     liveness::LiveVarSet<Local>,\n     FxHashMap<BasicBlock, liveness::LiveVarSet<Local>>,\n ) {\n-    let dead_unwinds = IdxSet::new_empty(mir.basic_blocks().len());\n+    let dead_unwinds = BitSet::new_empty(mir.basic_blocks().len());\n     let node_id = tcx.hir.as_local_node_id(source.def_id).unwrap();\n \n     // Calculate when MIR locals have live storage. This gives us an upper bound of their\n@@ -388,7 +388,7 @@ fn locals_live_across_suspend_points(\n \n     // Find the MIR locals which do not use StorageLive/StorageDead statements.\n     // The storage of these locals are always live.\n-    let mut ignored = StorageIgnored(IdxSet::new_filled(mir.local_decls.len()));\n+    let mut ignored = StorageIgnored(BitSet::new_filled(mir.local_decls.len()));\n     ignored.visit_mir(mir);\n \n     // Calculate the MIR locals which have been previously\n@@ -472,7 +472,7 @@ fn locals_live_across_suspend_points(\n     }\n \n     // The generator argument is ignored\n-    set.remove(&self_arg());\n+    set.remove(self_arg());\n \n     (set, storage_liveness_map)\n }\n@@ -502,7 +502,7 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     for (local, decl) in mir.local_decls.iter_enumerated() {\n         // Ignore locals which are internal or not live\n-        if !live_locals.contains(&local) || decl.internal {\n+        if !live_locals.contains(local) || decl.internal {\n             continue;\n         }\n \n@@ -823,7 +823,7 @@ fn create_cases<'a, 'tcx, F>(mir: &mut Mir<'tcx>,\n             // Create StorageLive instructions for locals with live storage\n             for i in 0..(mir.local_decls.len()) {\n                 let l = Local::new(i);\n-                if point.storage_liveness.contains(&l) && !transform.remap.contains_key(&l) {\n+                if point.storage_liveness.contains(l) && !transform.remap.contains_key(&l) {\n                     statements.push(Statement {\n                         source_info,\n                         kind: StatementKind::StorageLive(l),"}, {"sha": "8689fde3ee640b81bbe894e2e02fe028aa83aa3e", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -14,7 +14,7 @@ use rustc::hir;\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def_id::DefId;\n \n-use rustc_data_structures::bitvec::BitArray;\n+use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n use rustc::mir::*;\n@@ -271,7 +271,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         // Traverse the MIR manually so we can account for the effects of\n         // inlining on the CFG.\n         let mut work_list = vec![START_BLOCK];\n-        let mut visited = BitArray::new(callee_mir.basic_blocks().len());\n+        let mut visited = BitSet::new_empty(callee_mir.basic_blocks().len());\n         while let Some(bb) = work_list.pop() {\n             if !visited.insert(bb.index()) { continue; }\n             let blk = &callee_mir.basic_blocks()[bb];"}, {"sha": "bc9cc7274d5e78797581750ce89230f5475e5ba0", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -14,8 +14,7 @@\n //! The Qualif flags below can be used to also provide better\n //! diagnostics as to why a constant rvalue wasn't promoted.\n \n-use rustc_data_structures::bitvec::BitArray;\n-use rustc_data_structures::indexed_set::IdxSet;\n+use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashSet;\n use rustc::hir;\n@@ -116,7 +115,7 @@ struct Qualifier<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     param_env: ty::ParamEnv<'tcx>,\n     local_qualif: IndexVec<Local, Option<Qualif>>,\n     qualif: Qualif,\n-    const_fn_arg_vars: BitArray<Local>,\n+    const_fn_arg_vars: BitSet<Local>,\n     temp_promotion_state: IndexVec<Local, TempState>,\n     promotion_candidates: Vec<Candidate>\n }\n@@ -151,7 +150,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             param_env,\n             local_qualif,\n             qualif: Qualif::empty(),\n-            const_fn_arg_vars: BitArray::new(mir.local_decls.len()),\n+            const_fn_arg_vars: BitSet::new_empty(mir.local_decls.len()),\n             temp_promotion_state: temps,\n             promotion_candidates: vec![]\n         }\n@@ -280,12 +279,12 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n     }\n \n     /// Qualify a whole const, static initializer or const fn.\n-    fn qualify_const(&mut self) -> (Qualif, Lrc<IdxSet<Local>>) {\n+    fn qualify_const(&mut self) -> (Qualif, Lrc<BitSet<Local>>) {\n         debug!(\"qualifying {} {:?}\", self.mode, self.def_id);\n \n         let mir = self.mir;\n \n-        let mut seen_blocks = BitArray::new(mir.basic_blocks().len());\n+        let mut seen_blocks = BitSet::new_empty(mir.basic_blocks().len());\n         let mut bb = START_BLOCK;\n         loop {\n             seen_blocks.insert(bb.index());\n@@ -383,14 +382,14 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n \n \n         // Collect all the temps we need to promote.\n-        let mut promoted_temps = IdxSet::new_empty(self.temp_promotion_state.len());\n+        let mut promoted_temps = BitSet::new_empty(self.temp_promotion_state.len());\n \n         for candidate in &self.promotion_candidates {\n             match *candidate {\n                 Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {\n                     match self.mir[bb].statements[stmt_idx].kind {\n                         StatementKind::Assign(_, Rvalue::Ref(_, _, Place::Local(index))) => {\n-                            promoted_temps.add(&index);\n+                            promoted_temps.insert(index);\n                         }\n                         _ => {}\n                     }\n@@ -1121,7 +1120,7 @@ pub fn provide(providers: &mut Providers) {\n \n fn mir_const_qualif<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               def_id: DefId)\n-                              -> (u8, Lrc<IdxSet<Local>>) {\n+                              -> (u8, Lrc<BitSet<Local>>) {\n     // NB: This `borrow()` is guaranteed to be valid (i.e., the value\n     // cannot yet be stolen), because `mir_validated()`, which steals\n     // from `mir_const(), forces this query to execute before\n@@ -1130,7 +1129,7 @@ fn mir_const_qualif<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     if mir.return_ty().references_error() {\n         tcx.sess.delay_span_bug(mir.span, \"mir_const_qualif: Mir had errors\");\n-        return (Qualif::NOT_CONST.bits(), Lrc::new(IdxSet::new_empty(0)));\n+        return (Qualif::NOT_CONST.bits(), Lrc::new(BitSet::new_empty(0)));\n     }\n \n     let mut qualifier = Qualifier::new(tcx, def_id, mir, Mode::Const);\n@@ -1220,15 +1219,15 @@ impl MirPass for QualifyAndPromoteConstants {\n                 block.statements.retain(|statement| {\n                     match statement.kind {\n                         StatementKind::StorageDead(index) => {\n-                            !promoted_temps.contains(&index)\n+                            !promoted_temps.contains(index)\n                         }\n                         _ => true\n                     }\n                 });\n                 let terminator = block.terminator_mut();\n                 match terminator.kind {\n                     TerminatorKind::Drop { location: Place::Local(index), target, .. } => {\n-                        if promoted_temps.contains(&index) {\n+                        if promoted_temps.contains(index) {\n                             terminator.kind = TerminatorKind::Goto {\n                                 target,\n                             };"}, {"sha": "9cdd94a7be7f168e1a7552f81d46b5c06ee812b5", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n-use rustc_data_structures::bitvec::BitArray;\n+use rustc_data_structures::bit_set::BitSet;\n use transform::{MirPass, MirSource};\n use util::patch::MirPatch;\n \n@@ -45,7 +45,7 @@ impl RemoveNoopLandingPads {\n         &self,\n         bb: BasicBlock,\n         mir: &Mir,\n-        nop_landing_pads: &BitArray<BasicBlock>,\n+        nop_landing_pads: &BitSet<BasicBlock>,\n     ) -> bool {\n         for stmt in &mir[bb].statements {\n             match stmt.kind {\n@@ -111,7 +111,7 @@ impl RemoveNoopLandingPads {\n \n         let mut jumps_folded = 0;\n         let mut landing_pads_removed = 0;\n-        let mut nop_landing_pads = BitArray::new(mir.basic_blocks().len());\n+        let mut nop_landing_pads = BitSet::new_empty(mir.basic_blocks().len());\n \n         // This is a post-order traversal, so that if A post-dominates B\n         // then A will be visited before B."}, {"sha": "3c898eedebcc49582b980eda60be6d01e9a4df6f", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -14,7 +14,7 @@ use syntax_pos::Span;\n \n use rustc::ty::{self, TyCtxt};\n use rustc::mir::{self, Mir, Location};\n-use rustc_data_structures::indexed_set::IdxSet;\n+use rustc_data_structures::bit_set::BitSet;\n use transform::{MirPass, MirSource};\n \n use dataflow::{do_dataflow, DebugFormatted};\n@@ -46,7 +46,7 @@ impl MirPass for SanityCheck {\n         let param_env = tcx.param_env(def_id);\n         let move_data = MoveData::gather_moves(mir, tcx).unwrap();\n         let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n-        let dead_unwinds = IdxSet::new_empty(mir.basic_blocks().len());\n+        let dead_unwinds = BitSet::new_empty(mir.basic_blocks().len());\n         let flow_inits =\n             do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n                         MaybeInitializedPlaces::new(tcx, mir, &mdpe),\n@@ -175,7 +175,7 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 // Okay, our search is over.\n                 match move_data.rev_lookup.find(peeking_at_place) {\n                     LookupResult::Exact(peek_mpi) => {\n-                        let bit_state = sets.on_entry.contains(&peek_mpi);\n+                        let bit_state = sets.on_entry.contains(peek_mpi);\n                         debug!(\"rustc_peek({:?} = &{:?}) bit_state: {}\",\n                                place, peeking_at_place, bit_state);\n                         if !bit_state {"}, {"sha": "a6e0932bf0acec6860272ad15ba50c5c7ab71e8c", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -37,7 +37,7 @@\n //! naively generate still contains the `_a = ()` write in the unreachable block \"after\" the\n //! return.\n \n-use rustc_data_structures::bitvec::BitArray;\n+use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n@@ -249,7 +249,7 @@ impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n }\n \n pub fn remove_dead_blocks(mir: &mut Mir) {\n-    let mut seen = BitArray::new(mir.basic_blocks().len());\n+    let mut seen = BitSet::new_empty(mir.basic_blocks().len());\n     for (bb, _) in traversal::preorder(mir) {\n         seen.insert(bb.index());\n     }\n@@ -285,7 +285,7 @@ impl MirPass for SimplifyLocals {\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _: MirSource,\n                           mir: &mut Mir<'tcx>) {\n-        let mut marker = DeclMarker { locals: BitArray::new(mir.local_decls.len()) };\n+        let mut marker = DeclMarker { locals: BitSet::new_empty(mir.local_decls.len()) };\n         marker.visit_mir(mir);\n         // Return pointer and arguments are always live\n         marker.locals.insert(RETURN_PLACE);\n@@ -310,7 +310,7 @@ impl MirPass for SimplifyLocals {\n /// Construct the mapping while swapping out unused stuff out from the `vec`.\n fn make_local_map<'tcx, V>(\n     vec: &mut IndexVec<Local, V>,\n-    mask: BitArray<Local>,\n+    mask: BitSet<Local>,\n ) -> IndexVec<Local, Option<Local>> {\n     let mut map: IndexVec<Local, Option<Local>> = IndexVec::from_elem(None, &*vec);\n     let mut used = Local::new(0);\n@@ -326,7 +326,7 @@ fn make_local_map<'tcx, V>(\n }\n \n struct DeclMarker {\n-    pub locals: BitArray<Local>,\n+    pub locals: BitSet<Local>,\n }\n \n impl<'tcx> Visitor<'tcx> for DeclMarker {"}, {"sha": "420ca4efde37d8d6c72e48650c1a021e8e3d68ae", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -37,7 +37,7 @@ use rustc::mir::visit::{PlaceContext, Visitor};\n use rustc::mir::Local;\n use rustc::mir::*;\n use rustc::ty::{item_path, TyCtxt};\n-use rustc_data_structures::indexed_set::IdxSet;\n+use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::work_queue::WorkQueue;\n use std::fs;\n@@ -46,7 +46,7 @@ use std::path::{Path, PathBuf};\n use transform::MirSource;\n use util::pretty::{dump_enabled, write_basic_block, write_mir_intro};\n \n-pub type LiveVarSet<V> = IdxSet<V>;\n+pub type LiveVarSet<V> = BitSet<V>;\n \n /// This gives the result of the liveness analysis at the boundary of\n /// basic blocks.\n@@ -243,8 +243,8 @@ impl<V: Idx> DefsUses<V> {\n         //     X = 5\n         //     // Defs = {}, Uses = {X}\n         //     use(X)\n-        self.uses.remove(&index);\n-        self.defs.add(&index);\n+        self.uses.remove(index);\n+        self.defs.insert(index);\n     }\n \n     fn add_use(&mut self, index: V) {\n@@ -258,8 +258,8 @@ impl<V: Idx> DefsUses<V> {\n         //     X = 5\n         //     // Defs = {}, Uses = {X}\n         //     use(X)\n-        self.defs.remove(&index);\n-        self.uses.add(&index);\n+        self.defs.remove(index);\n+        self.uses.insert(index);\n     }\n }\n "}, {"sha": "68b468417182a0bef98e6e699e195b2215f3d10f", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80cb47889e0ad9400b6708ce2b4c4b364b71982/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=b80cb47889e0ad9400b6708ce2b4c4b364b71982", "patch": "@@ -46,7 +46,7 @@ extern crate smallvec;\n extern crate serialize as rustc_serialize; // used by deriving\n \n use rustc_data_structures::sync::Lock;\n-use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::bit_set::GrowableBitSet;\n pub use rustc_data_structures::small_vec::OneVector;\n pub use rustc_data_structures::thin_vec::ThinVec;\n use ast::AttrId;\n@@ -82,8 +82,8 @@ macro_rules! unwrap_or {\n }\n \n pub struct Globals {\n-    used_attrs: Lock<BitVector<AttrId>>,\n-    known_attrs: Lock<BitVector<AttrId>>,\n+    used_attrs: Lock<GrowableBitSet<AttrId>>,\n+    known_attrs: Lock<GrowableBitSet<AttrId>>,\n     syntax_pos_globals: syntax_pos::Globals,\n }\n \n@@ -92,8 +92,8 @@ impl Globals {\n         Globals {\n             // We have no idea how many attributes their will be, so just\n             // initiate the vectors with 0 bits. We'll grow them as necessary.\n-            used_attrs: Lock::new(BitVector::new()),\n-            known_attrs: Lock::new(BitVector::new()),\n+            used_attrs: Lock::new(GrowableBitSet::new_empty()),\n+            known_attrs: Lock::new(GrowableBitSet::new_empty()),\n             syntax_pos_globals: syntax_pos::Globals::new(),\n         }\n     }"}]}