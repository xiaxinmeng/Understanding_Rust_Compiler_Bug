{"sha": "fbea3e57f34c7d30f6c18b435a37db70df49fc9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiZWEzZTU3ZjM0YzdkMzBmNmMxOGI0MzVhMzdkYjcwZGY0OWZjOWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-15T10:41:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-15T10:41:13Z"}, "message": "Auto merge of #1330 - RalfJung:retag-return-place, r=RalfJung\n\nretag return place\n\n@eddyb suggested that return places should be treated like unique references for Stacked Borrows. That is implemented by this patch, but it is unfortunately quite the hack because otherwise we are retagging *references*, not places.\n\n@eddyb does this roughly correspond to what you had in mind? (Except for whatever it is you think should happen with argument passing, which is a much bigger issue.) Also, do you think there is any way we can *test* this?\n\nNeeds https://github.com/rust-lang/rust/pull/71100 to land.", "tree": {"sha": "24ded36a9a9ec7b9e4b3d81b3e0b33eee6dc1496", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24ded36a9a9ec7b9e4b3d81b3e0b33eee6dc1496"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbea3e57f34c7d30f6c18b435a37db70df49fc9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbea3e57f34c7d30f6c18b435a37db70df49fc9e", "html_url": "https://github.com/rust-lang/rust/commit/fbea3e57f34c7d30f6c18b435a37db70df49fc9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbea3e57f34c7d30f6c18b435a37db70df49fc9e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "669191bca995d01db9eb75e3d906cfc07e28d7dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/669191bca995d01db9eb75e3d906cfc07e28d7dd", "html_url": "https://github.com/rust-lang/rust/commit/669191bca995d01db9eb75e3d906cfc07e28d7dd"}, {"sha": "3548dcf8cc3021dcfe425df90d7feb14c0bdda61", "url": "https://api.github.com/repos/rust-lang/rust/commits/3548dcf8cc3021dcfe425df90d7feb14c0bdda61", "html_url": "https://github.com/rust-lang/rust/commit/3548dcf8cc3021dcfe425df90d7feb14c0bdda61"}], "stats": {"total": 75, "additions": 60, "deletions": 15}, "files": [{"sha": "937073ef4fcc3166ebbde27ba2acbf31ace8843e", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbea3e57f34c7d30f6c18b435a37db70df49fc9e/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/fbea3e57f34c7d30f6c18b435a37db70df49fc9e/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=fbea3e57f34c7d30f6c18b435a37db70df49fc9e", "patch": "@@ -1 +1 @@\n-47f49695dfb4fe9e584239fdc59c771887148a57\n+df768c5c8fcb361c4dc94b4c776d6a78c12862e1"}, {"sha": "94603c3dfb4d67f86f2e490f83d951702c3baae0", "filename": "src/machine.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fbea3e57f34c7d30f6c18b435a37db70df49fc9e/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbea3e57f34c7d30f6c18b435a37db70df49fc9e/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=fbea3e57f34c7d30f6c18b435a37db70df49fc9e", "patch": "@@ -481,30 +481,42 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         kind: mir::RetagKind,\n         place: PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n-        if ecx.memory.extra.stacked_borrows.is_none() {\n-            // No tracking.\n-            Ok(())\n-        } else {\n+        if ecx.memory.extra.stacked_borrows.is_some() {\n             ecx.retag(kind, place)\n+        } else {\n+            Ok(())\n         }\n     }\n \n     #[inline(always)]\n-    fn stack_push(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx, FrameData<'tcx>> {\n+    fn init_frame_extra(\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        frame: Frame<'mir, 'tcx, Tag>,\n+    ) -> InterpResult<'tcx, Frame<'mir, 'tcx, Tag, FrameData<'tcx>>> {\n         let stacked_borrows = ecx.memory.extra.stacked_borrows.as_ref();\n         let call_id = stacked_borrows.map_or(NonZeroU64::new(1).unwrap(), |stacked_borrows| {\n             stacked_borrows.borrow_mut().new_call()\n         });\n-        Ok(FrameData { call_id, catch_unwind: None })\n+        let extra = FrameData { call_id, catch_unwind: None };\n+        Ok(frame.with_extra(extra))\n+    }\n+\n+    #[inline(always)]\n+    fn after_stack_push(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+        if ecx.memory.extra.stacked_borrows.is_some() {\n+            ecx.retag_return_place()\n+        } else {\n+            Ok(())\n+        }\n     }\n \n     #[inline(always)]\n-    fn stack_pop(\n+    fn after_stack_pop(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        extra: FrameData<'tcx>,\n+        frame: Frame<'mir, 'tcx, Tag, FrameData<'tcx>>,\n         unwinding: bool,\n     ) -> InterpResult<'tcx, StackPopJump> {\n-        ecx.handle_stack_pop(extra, unwinding)\n+        ecx.handle_stack_pop(frame.extra, unwinding)\n     }\n \n     #[inline(always)]"}, {"sha": "a69948002c1269e5a6c469a87cea70b7235a847d", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fbea3e57f34c7d30f6c18b435a37db70df49fc9e/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbea3e57f34c7d30f6c18b435a37db70df49fc9e/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=fbea3e57f34c7d30f6c18b435a37db70df49fc9e", "patch": "@@ -11,7 +11,7 @@ use log::trace;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_middle::mir::RetagKind;\n use rustc_middle::ty;\n-use rustc_target::abi::Size;\n+use rustc_target::abi::{LayoutOf, Size};\n use rustc_hir::Mutability;\n \n use crate::*;\n@@ -569,7 +569,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         val: ImmTy<'tcx, Tag>,\n         kind: RefKind,\n         protect: bool,\n-    ) -> InterpResult<'tcx, Immediate<Tag>> {\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, Tag>> {\n         let this = self.eval_context_mut();\n         // We want a place for where the ptr *points to*, so we get one.\n         let place = this.ref_to_mplace(val)?;\n@@ -582,7 +582,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let place = this.mplace_access_checked(place)?;\n         if size == Size::ZERO {\n             // Nothing to do for ZSTs.\n-            return Ok(*val);\n+            return Ok(val);\n         }\n \n         // Compute new borrow.\n@@ -603,7 +603,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let new_place = place.replace_tag(new_tag);\n \n         // Return new pointer.\n-        Ok(new_place.to_ref())\n+        Ok(ImmTy::from_immediate(new_place.to_ref(), val.layout))\n     }\n }\n \n@@ -640,9 +640,42 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Fast path.\n             let val = this.read_immediate(this.place_to_op(place)?)?;\n             let val = this.retag_reference(val, mutbl, protector)?;\n-            this.write_immediate(val, place)?;\n+            this.write_immediate(*val, place)?;\n         }\n \n         Ok(())\n     }\n+\n+    /// After a stack frame got pushed, retag the return place so that we are sure\n+    /// it does not alias with anything.\n+    /// \n+    /// This is a HACK because there is nothing in MIR that would make the retag\n+    /// explicit. Also see https://github.com/rust-lang/rust/issues/71117.\n+    fn retag_return_place(&mut self) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let return_place = if let Some(return_place) = this.frame_mut().return_place {\n+            return_place\n+        } else {\n+            // No return place, nothing to do.\n+            return Ok(());\n+        };\n+        if return_place.layout.is_zst() {\n+            // There may not be any memory here, nothing to do.\n+            return Ok(());\n+        }\n+        // We need this to be in-memory to use tagged pointers.\n+        let return_place = this.force_allocation(return_place)?;\n+\n+        // We have to turn the place into a pointer to use the existing code.\n+        // (The pointer type does not matter, so we use a raw pointer.)\n+        let ptr_layout = this.layout_of(this.tcx.mk_mut_ptr(return_place.layout.ty))?;\n+        let val = ImmTy::from_immediate(return_place.to_ref(), ptr_layout);\n+        // Reborrow it.\n+        let val = this.retag_reference(val, RefKind::Unique { two_phase: false }, /*protector*/ true)?;\n+        // And use reborrowed pointer for return place.\n+        let return_place = this.ref_to_mplace(val)?;\n+        this.frame_mut().return_place = Some(return_place.into());\n+\n+        Ok(())\n+    }\n }"}]}