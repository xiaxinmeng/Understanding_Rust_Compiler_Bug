{"sha": "53ae6d2eb5352cc20f2e9b92847d92e935639f3c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzYWU2ZDJlYjUzNTJjYzIwZjJlOWI5Mjg0N2Q5MmU5MzU2MzlmM2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-25T02:17:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-25T02:17:05Z"}, "message": "Auto merge of #61572 - Aaron1011:fix/generator-ref, r=varkor\n\nFix HIR visit order\n\nFixes #61442\n\nWhen rustc::middle::region::ScopeTree computes its yield_in_scope\nfield, it relies on the HIR visitor order to properly compute which\ntypes must be live across yield points. In order for the computed scopes\nto agree with the generated MIR, we must ensure that expressions\nevaluated before a yield point are visited before the 'yield'\nexpression.\n\nHowever, the visitor order for ExprKind::AssignOp\nwas incorrect. The left-hand side of a compund assignment expression is\nevaluated before the right-hand side, but the right-hand expression was\nbeing visited before the left-hand expression. If the left-hand\nexpression caused a new type to be introduced (e.g. through a\nderef-coercion), the new type would be incorrectly seen as occuring\n*after* the yield point, instead of before. This leads to a mismatch\nbetween the computed generator types and the MIR, since the MIR will\ncorrectly see the type as being live across the yield point.\n\nTo fix this, we correct the visitor order for ExprKind::AssignOp\nto reflect the actual evaulation order.", "tree": {"sha": "d19d826f7c3921ca6f3de654e33039c0e6b26a95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d19d826f7c3921ca6f3de654e33039c0e6b26a95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53ae6d2eb5352cc20f2e9b92847d92e935639f3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53ae6d2eb5352cc20f2e9b92847d92e935639f3c", "html_url": "https://github.com/rust-lang/rust/commit/53ae6d2eb5352cc20f2e9b92847d92e935639f3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53ae6d2eb5352cc20f2e9b92847d92e935639f3c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5b17298f2d1c5994c73e540ce7c44830af0d4dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5b17298f2d1c5994c73e540ce7c44830af0d4dc", "html_url": "https://github.com/rust-lang/rust/commit/a5b17298f2d1c5994c73e540ce7c44830af0d4dc"}, {"sha": "770655a47f9577b15e499a76f87b903bbde93c3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/770655a47f9577b15e499a76f87b903bbde93c3b", "html_url": "https://github.com/rust-lang/rust/commit/770655a47f9577b15e499a76f87b903bbde93c3b"}], "stats": {"total": 148, "additions": 146, "deletions": 2}, "files": [{"sha": "9c05f18762df1894130c8bbc63102c3eaf954d9f", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53ae6d2eb5352cc20f2e9b92847d92e935639f3c/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ae6d2eb5352cc20f2e9b92847d92e935639f3c/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=53ae6d2eb5352cc20f2e9b92847d92e935639f3c", "patch": "@@ -1056,7 +1056,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         }\n         ExprKind::AssignOp(_, ref left_expression, ref right_expression) => {\n             visitor.visit_expr(right_expression);\n-            visitor.visit_expr(left_expression)\n+            visitor.visit_expr(left_expression);\n         }\n         ExprKind::Field(ref subexpression, ident) => {\n             visitor.visit_expr(subexpression);"}, {"sha": "114684b15240279badb11c6241fe448c607016e8", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 107, "deletions": 1, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/53ae6d2eb5352cc20f2e9b92847d92e935639f3c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ae6d2eb5352cc20f2e9b92847d92e935639f3c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=53ae6d2eb5352cc20f2e9b92847d92e935639f3c", "patch": "@@ -371,7 +371,12 @@ struct RegionResolutionVisitor<'tcx> {\n \n     // The number of expressions and patterns visited in the current body\n     expr_and_pat_count: usize,\n-\n+    // When this is `true`, we record the `Scopes` we encounter\n+    // when processing a Yield expression. This allows us to fix\n+    // up their indices.\n+    pessimistic_yield: bool,\n+    // Stores scopes when pessimistic_yield is true.\n+    fixup_scopes: Vec<Scope>,\n     // Generated scope tree:\n     scope_tree: ScopeTree,\n \n@@ -947,12 +952,107 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n         }\n     }\n \n+    let prev_pessimistic = visitor.pessimistic_yield;\n+\n+    // Ordinarily, we can rely on the visit order of HIR intravisit\n+    // to correspond to the actual execution order of statements.\n+    // However, there's a weird corner case with compund assignment\n+    // operators (e.g. `a += b`). The evaluation order depends on whether\n+    // or not the operator is overloaded (e.g. whether or not a trait\n+    // like AddAssign is implemented).\n+\n+    // For primitive types (which, despite having a trait impl, don't actually\n+    // end up calling it), the evluation order is right-to-left. For example,\n+    // the following code snippet:\n+    //\n+    //    let y = &mut 0;\n+    //    *{println!(\"LHS!\"); y} += {println!(\"RHS!\"); 1};\n+    //\n+    // will print:\n+    //\n+    // RHS!\n+    // LHS!\n+    //\n+    // However, if the operator is used on a non-primitive type,\n+    // the evaluation order will be left-to-right, since the operator\n+    // actually get desugared to a method call. For example, this\n+    // nearly identical code snippet:\n+    //\n+    //     let y = &mut String::new();\n+    //    *{println!(\"LHS String\"); y} += {println!(\"RHS String\"); \"hi\"};\n+    //\n+    // will print:\n+    // LHS String\n+    // RHS String\n+    //\n+    // To determine the actual execution order, we need to perform\n+    // trait resolution. Unfortunately, we need to be able to compute\n+    // yield_in_scope before type checking is even done, as it gets\n+    // used by AST borrowcheck.\n+    //\n+    // Fortunately, we don't need to know the actual execution order.\n+    // It suffices to know the 'worst case' order with respect to yields.\n+    // Specifically, we need to know the highest 'expr_and_pat_count'\n+    // that we could assign to the yield expression. To do this,\n+    // we pick the greater of the two values from the left-hand\n+    // and right-hand expressions. This makes us overly conservative\n+    // about what types could possibly live across yield points,\n+    // but we will never fail to detect that a type does actually\n+    // live across a yield point. The latter part is critical -\n+    // we're already overly conservative about what types will live\n+    // across yield points, as the generated MIR will determine\n+    // when things are actually live. However, for typecheck to work\n+    // properly, we can't miss any types.\n+\n+\n     match expr.node {\n         // Manually recurse over closures, because they are the only\n         // case of nested bodies that share the parent environment.\n         hir::ExprKind::Closure(.., body, _, _) => {\n             let body = visitor.tcx.hir().body(body);\n             visitor.visit_body(body);\n+        },\n+        hir::ExprKind::AssignOp(_, ref left_expr, ref right_expr) => {\n+            debug!(\"resolve_expr - enabling pessimistic_yield, was previously {}\",\n+                   prev_pessimistic);\n+\n+            let start_point = visitor.fixup_scopes.len();\n+            visitor.pessimistic_yield = true;\n+\n+            // If the actual execution order turns out to be right-to-left,\n+            // then we're fine. However, if the actual execution order is left-to-right,\n+            // then we'll assign too low a count to any `yield` expressions\n+            // we encounter in 'right_expression' - they should really occur after all of the\n+            // expressions in 'left_expression'.\n+            visitor.visit_expr(&right_expr);\n+            visitor.pessimistic_yield = prev_pessimistic;\n+\n+            debug!(\"resolve_expr - restoring pessimistic_yield to {}\", prev_pessimistic);\n+            visitor.visit_expr(&left_expr);\n+            debug!(\"resolve_expr - fixing up counts to {}\", visitor.expr_and_pat_count);\n+\n+            // Remove and process any scopes pushed by the visitor\n+            let target_scopes = visitor.fixup_scopes.drain(start_point..);\n+\n+            for scope in target_scopes {\n+                let mut yield_data = visitor.scope_tree.yield_in_scope.get_mut(&scope).unwrap();\n+                let count = yield_data.expr_and_pat_count;\n+                let span = yield_data.span;\n+\n+                // expr_and_pat_count never decreases. Since we recorded counts in yield_in_scope\n+                // before walking the left-hand side, it should be impossible for the recorded\n+                // count to be greater than the left-hand side count.\n+                if count > visitor.expr_and_pat_count {\n+                    bug!(\"Encountered greater count {} at span {:?} - expected no greater than {}\",\n+                         count, span, visitor.expr_and_pat_count);\n+                }\n+                let new_count = visitor.expr_and_pat_count;\n+                debug!(\"resolve_expr - increasing count for scope {:?} from {} to {} at span {:?}\",\n+                       scope, count, new_count, span);\n+\n+                yield_data.expr_and_pat_count = new_count;\n+            }\n+\n         }\n \n         _ => intravisit::walk_expr(visitor, expr)\n@@ -972,6 +1072,10 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n                 source: *source,\n             };\n             visitor.scope_tree.yield_in_scope.insert(scope, data);\n+            if visitor.pessimistic_yield {\n+                debug!(\"resolve_expr in pessimistic_yield - marking scope {:?} for fixup\", scope);\n+                visitor.fixup_scopes.push(scope);\n+            }\n \n             // Keep traversing up while we can.\n             match visitor.scope_tree.parent_map.get(&scope) {\n@@ -1360,6 +1464,8 @@ fn region_scope_tree<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ScopeTree\n                 var_parent: None,\n             },\n             terminating_scopes: Default::default(),\n+            pessimistic_yield: false,\n+            fixup_scopes: vec![],\n         };\n \n         let body = tcx.hir().body(body_id);"}, {"sha": "0bd078dace410bc6823b92d55614efe1bc374f49", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53ae6d2eb5352cc20f2e9b92847d92e935639f3c/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ae6d2eb5352cc20f2e9b92847d92e935639f3c/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=53ae6d2eb5352cc20f2e9b92847d92e935639f3c", "patch": "@@ -28,6 +28,10 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n               source_span: Span) {\n         use syntax_pos::DUMMY_SP;\n \n+        debug!(\"generator_interior: attempting to record type {:?} {:?} {:?} {:?}\",\n+               ty, scope, expr, source_span);\n+\n+\n         let live_across_yield = scope.map(|s| {\n             self.region_scope_tree.yield_in_scope(s).and_then(|yield_data| {\n                 // If we are recording an expression that is the last yield"}, {"sha": "6a417936384b9e6e88c360fda762e916417d4a53", "filename": "src/test/run-pass/generator/addassign-yield.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/53ae6d2eb5352cc20f2e9b92847d92e935639f3c/src%2Ftest%2Frun-pass%2Fgenerator%2Faddassign-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ae6d2eb5352cc20f2e9b92847d92e935639f3c/src%2Ftest%2Frun-pass%2Fgenerator%2Faddassign-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Faddassign-yield.rs?ref=53ae6d2eb5352cc20f2e9b92847d92e935639f3c", "patch": "@@ -0,0 +1,34 @@\n+// Regression test for broken MIR error (#61442)\n+// Due to the two possible evaluation orders for\n+// a '+=' expression (depending on whether or not the 'AddAssign' trait\n+// is being used), we were failing to account for all types that might\n+// possibly be live across a yield point.\n+\n+#![feature(generators)]\n+\n+fn foo() {\n+    let _x = static || {\n+        let mut s = String::new();\n+        s += { yield; \"\" };\n+    };\n+\n+    let _y = static || {\n+        let x = &mut 0;\n+        *{ yield; x } += match String::new() { _ => 0 };\n+    };\n+\n+    // Please don't ever actually write something like this\n+    let _z = static || {\n+        let x = &mut 0;\n+        *{\n+            let inner = &mut 1;\n+            *{ yield (); inner } += match String::new() { _ => 1};\n+            yield;\n+            x\n+        } += match String::new() { _ => 2 };\n+    };\n+}\n+\n+fn main() {\n+    foo()\n+}"}]}