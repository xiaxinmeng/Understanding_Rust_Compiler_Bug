{"sha": "b707da40a5d0369201f80d2fed5847caeb781094", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3MDdkYTQwYTVkMDM2OTIwMWY4MGQyZmVkNTg0N2NhZWI3ODEwOTQ=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-08-13T14:26:30Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-08-13T14:26:30Z"}, "message": "Change todo map to set of alloc id's in constant.rs", "tree": {"sha": "dfcaaee769a0ba02c6fbf1e057436d812a8fccfb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfcaaee769a0ba02c6fbf1e057436d812a8fccfb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b707da40a5d0369201f80d2fed5847caeb781094", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b707da40a5d0369201f80d2fed5847caeb781094", "html_url": "https://github.com/rust-lang/rust/commit/b707da40a5d0369201f80d2fed5847caeb781094", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b707da40a5d0369201f80d2fed5847caeb781094/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49d24a6333c1f30cd92048206016a006430b7a42", "url": "https://api.github.com/repos/rust-lang/rust/commits/49d24a6333c1f30cd92048206016a006430b7a42", "html_url": "https://github.com/rust-lang/rust/commit/49d24a6333c1f30cd92048206016a006430b7a42"}], "stats": {"total": 36, "additions": 19, "deletions": 17}, "files": [{"sha": "c518ccb8950006e120f91fac081c70d989b81354", "filename": "src/constant.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b707da40a5d0369201f80d2fed5847caeb781094/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b707da40a5d0369201f80d2fed5847caeb781094/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=b707da40a5d0369201f80d2fed5847caeb781094", "patch": "@@ -12,21 +12,23 @@ pub struct ConstantCx {\n \n impl ConstantCx {\n     pub fn finalize<B: Backend>(mut self, module: &mut Module<B>) {\n+        println!(\"constants {:?}\", self.constants);\n+        println!(\"done {:?}\", self.done);\n         for data_id in self.done.drain() {\n             module.finalize_data(data_id);\n         }\n     }\n }\n \n-pub fn codegen_static<'a, 'tcx: 'a, B: Backend>(_cx: &mut CodegenCx<'a, 'tcx, B>, def_id: DefId) {\n-    unimpl!(\"Unimplemented static mono item {:?}\", def_id);\n+pub fn codegen_static<'a, 'tcx: 'a, B: Backend>(cx: &mut CodegenCx<'a, 'tcx, B>, def_id: DefId) {\n+    unimpl!(\"static mono item {:?}\", def_id);\n }\n \n pub fn codegen_static_ref<'a, 'tcx: 'a>(\n-    _fx: &mut FunctionCx<'a, 'tcx>,\n+    fx: &mut FunctionCx<'a, 'tcx>,\n     static_: &Static<'tcx>,\n ) -> CPlace<'tcx> {\n-    unimpl!(\"Unimplemented static mono item {:?}\", static_.def_id);\n+    unimpl!(\"static place {:?} ty {:?}\", static_.def_id, static_.ty);\n }\n \n pub fn trans_promoted<'a, 'tcx: 'a>(\n@@ -125,21 +127,21 @@ fn define_global_for_alloc_id<'a, 'tcx: 'a, B: Backend>(\n     module: &mut Module<B>,\n     cx: &mut ConstantCx,\n     alloc_id: AllocId,\n-    todo: &mut HashMap<AllocId, DataId>,\n+    todo: &mut HashSet<AllocId>,\n ) -> DataId {\n     *cx.constants.entry(alloc_id).or_insert_with(|| {\n         let data_id = module\n             .declare_data(&alloc_id.0.to_string(), Linkage::Local, false)\n             .unwrap();\n-        todo.insert(alloc_id, data_id);\n+        todo.insert(alloc_id);\n         data_id\n     })\n }\n \n fn get_global_for_alloc_id<'a, 'tcx: 'a, B: Backend + 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     module: &mut Module<B>,\n-    cx: &mut ConstantCx,//<'a, 'tcx>,\n+    cx: &mut ConstantCx,\n     alloc_id: AllocId,\n ) -> DataId {\n     if let Some(data_id) = cx.constants.get(&alloc_id) {\n@@ -148,23 +150,23 @@ fn get_global_for_alloc_id<'a, 'tcx: 'a, B: Backend + 'a>(\n \n     let memory = Memory::<CompileTimeEvaluator>::new(tcx.at(DUMMY_SP), ());\n \n-    let mut todo = HashMap::new();\n-    define_global_for_alloc_id(module, cx, alloc_id, &mut todo);\n+    let mut todo = HashSet::new();\n+    todo.insert(alloc_id);\n \n     loop {\n-        let (alloc_id, data_id) = {\n-            if let Some(alloc_id) = todo.keys().next().map(|alloc_id| *alloc_id) {\n-                let data_id = todo.remove(&alloc_id).unwrap();\n-                (alloc_id, data_id)\n+        let alloc_id = {\n+            if let Some(alloc_id) = todo.iter().next().map(|alloc_id| *alloc_id) {\n+                todo.remove(&alloc_id);\n+                alloc_id\n             } else {\n                 break;\n             }\n         };\n \n-        println!(\n-            \"cur: {:?}:{:?} todo: {:?} done: {:?}\",\n-            alloc_id, data_id, todo, cx.done\n-        );\n+        let data_id = define_global_for_alloc_id(module, cx, alloc_id, &mut todo);\n+        if cx.done.contains(&data_id) {\n+            continue;\n+        }\n \n         let alloc = memory.get(alloc_id).unwrap();\n         //let alloc = tcx.alloc_map.lock().get(alloc_id).unwrap();"}]}