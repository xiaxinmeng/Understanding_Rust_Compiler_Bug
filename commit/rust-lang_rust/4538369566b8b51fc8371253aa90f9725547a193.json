{"sha": "4538369566b8b51fc8371253aa90f9725547a193", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1MzgzNjk1NjZiOGI1MWZjODM3MTI1M2FhOTBmOTcyNTU0N2ExOTM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-13T01:30:41Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-24T22:42:00Z"}, "message": "std: Expose that LocalIo may not always be available\n\nIt is not the case that all programs will always be able to acquire an instance\nof the LocalIo borrow, so this commit exposes this limitation by returning\nOption<LocalIo> from LocalIo::borrow().\n\nAt the same time, a helper method LocalIo::maybe_raise() has been added in order\nto encapsulate the functionality of raising on io_error if there is on local I/O\navailable.", "tree": {"sha": "dd3390d2083e2a6d5c494dec6760bdf4590a8b86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd3390d2083e2a6d5c494dec6760bdf4590a8b86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4538369566b8b51fc8371253aa90f9725547a193", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4538369566b8b51fc8371253aa90f9725547a193", "html_url": "https://github.com/rust-lang/rust/commit/4538369566b8b51fc8371253aa90f9725547a193", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4538369566b8b51fc8371253aa90f9725547a193/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a55c57284d8341ee5b22c5372e77ac0af9479dc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a55c57284d8341ee5b22c5372e77ac0af9479dc5", "html_url": "https://github.com/rust-lang/rust/commit/a55c57284d8341ee5b22c5372e77ac0af9479dc5"}], "stats": {"total": 294, "additions": 118, "deletions": 176}, "files": [{"sha": "ded1d254f3f5a746c5cf8c7ef15f6895daf8456b", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 29, "deletions": 37, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/4538369566b8b51fc8371253aa90f9725547a193/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4538369566b8b51fc8371253aa90f9725547a193/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=4538369566b8b51fc8371253aa90f9725547a193", "patch": "@@ -54,7 +54,7 @@ use super::{SeekStyle, Read, Write, Open, IoError, Truncate,\n use rt::rtio::{RtioFileStream, IoFactory, LocalIo};\n use io;\n use option::{Some, None, Option};\n-use result::{Ok, Err, Result};\n+use result::{Ok, Err};\n use path;\n use path::{Path, GenericPath};\n use vec::{OwnedVector, ImmutableVector};\n@@ -75,17 +75,6 @@ pub struct File {\n     priv last_nread: int,\n }\n \n-fn io_raise<T>(f: |io: &mut IoFactory| -> Result<T, IoError>) -> Option<T> {\n-    let mut io = LocalIo::borrow();\n-    match f(io.get()) {\n-        Ok(t) => Some(t),\n-        Err(ioerr) => {\n-            io_error::cond.raise(ioerr);\n-            None\n-        }\n-    }\n-}\n-\n impl File {\n     /// Open a file at `path` in the mode specified by the `mode` and `access`\n     /// arguments\n@@ -131,18 +120,15 @@ impl File {\n     pub fn open_mode(path: &Path,\n                      mode: FileMode,\n                      access: FileAccess) -> Option<File> {\n-        let mut io = LocalIo::borrow();\n-        match io.get().fs_open(&path.to_c_str(), mode, access) {\n-            Ok(fd) => Some(File {\n-                path: path.clone(),\n-                fd: fd,\n-                last_nread: -1\n-            }),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+        LocalIo::maybe_raise(|io| {\n+            io.fs_open(&path.to_c_str(), mode, access).map(|fd| {\n+                File {\n+                    path: path.clone(),\n+                    fd: fd,\n+                    last_nread: -1\n+                }\n+            })\n+        })\n     }\n \n     /// Attempts to open a file in read-only mode. This function is equivalent to\n@@ -242,7 +228,7 @@ impl File {\n /// directory, the user lacks permissions to remove the file, or if some\n /// other filesystem-level error occurs.\n pub fn unlink(path: &Path) {\n-    io_raise(|io| io.fs_unlink(&path.to_c_str()));\n+    LocalIo::maybe_raise(|io| io.fs_unlink(&path.to_c_str()));\n }\n \n /// Given a path, query the file system to get information about a file,\n@@ -270,7 +256,9 @@ pub fn unlink(path: &Path) {\n /// requisite permissions to perform a `stat` call on the given path or if\n /// there is no entry in the filesystem at the provided path.\n pub fn stat(path: &Path) -> FileStat {\n-    io_raise(|io| io.fs_stat(&path.to_c_str())).unwrap_or_else(dummystat)\n+    LocalIo::maybe_raise(|io| {\n+        io.fs_stat(&path.to_c_str())\n+    }).unwrap_or_else(dummystat)\n }\n \n fn dummystat() -> FileStat {\n@@ -306,7 +294,9 @@ fn dummystat() -> FileStat {\n ///\n /// See `stat`\n pub fn lstat(path: &Path) -> FileStat {\n-    io_raise(|io| io.fs_lstat(&path.to_c_str())).unwrap_or_else(dummystat)\n+    LocalIo::maybe_raise(|io| {\n+        io.fs_lstat(&path.to_c_str())\n+    }).unwrap_or_else(dummystat)\n }\n \n /// Rename a file or directory to a new name.\n@@ -324,7 +314,7 @@ pub fn lstat(path: &Path) -> FileStat {\n /// the process lacks permissions to view the contents, or if some other\n /// intermittent I/O error occurs.\n pub fn rename(from: &Path, to: &Path) {\n-    io_raise(|io| io.fs_rename(&from.to_c_str(), &to.to_c_str()));\n+    LocalIo::maybe_raise(|io| io.fs_rename(&from.to_c_str(), &to.to_c_str()));\n }\n \n /// Copies the contents of one file to another. This function will also\n@@ -395,7 +385,7 @@ pub fn copy(from: &Path, to: &Path) {\n /// condition. Some possible error situations are not having the permission to\n /// change the attributes of a file or the file not existing.\n pub fn chmod(path: &Path, mode: io::FilePermission) {\n-    io_raise(|io| io.fs_chmod(&path.to_c_str(), mode));\n+    LocalIo::maybe_raise(|io| io.fs_chmod(&path.to_c_str(), mode));\n }\n \n /// Change the user and group owners of a file at the specified path.\n@@ -404,7 +394,7 @@ pub fn chmod(path: &Path, mode: io::FilePermission) {\n ///\n /// This function will raise on the `io_error` condition on failure.\n pub fn chown(path: &Path, uid: int, gid: int) {\n-    io_raise(|io| io.fs_chown(&path.to_c_str(), uid, gid));\n+    LocalIo::maybe_raise(|io| io.fs_chown(&path.to_c_str(), uid, gid));\n }\n \n /// Creates a new hard link on the filesystem. The `dst` path will be a\n@@ -415,7 +405,7 @@ pub fn chown(path: &Path, uid: int, gid: int) {\n ///\n /// This function will raise on the `io_error` condition on failure.\n pub fn link(src: &Path, dst: &Path) {\n-    io_raise(|io| io.fs_link(&src.to_c_str(), &dst.to_c_str()));\n+    LocalIo::maybe_raise(|io| io.fs_link(&src.to_c_str(), &dst.to_c_str()));\n }\n \n /// Creates a new symbolic link on the filesystem. The `dst` path will be a\n@@ -425,7 +415,7 @@ pub fn link(src: &Path, dst: &Path) {\n ///\n /// This function will raise on the `io_error` condition on failure.\n pub fn symlink(src: &Path, dst: &Path) {\n-    io_raise(|io| io.fs_symlink(&src.to_c_str(), &dst.to_c_str()));\n+    LocalIo::maybe_raise(|io| io.fs_symlink(&src.to_c_str(), &dst.to_c_str()));\n }\n \n /// Reads a symlink, returning the file that the symlink points to.\n@@ -436,7 +426,7 @@ pub fn symlink(src: &Path, dst: &Path) {\n /// conditions include reading a file that does not exist or reading a file\n /// which is not a symlink.\n pub fn readlink(path: &Path) -> Option<Path> {\n-    io_raise(|io| io.fs_readlink(&path.to_c_str()))\n+    LocalIo::maybe_raise(|io| io.fs_readlink(&path.to_c_str()))\n }\n \n /// Create a new, empty directory at the provided path\n@@ -456,7 +446,7 @@ pub fn readlink(path: &Path) -> Option<Path> {\n /// to make a new directory at the provided path, or if the directory already\n /// exists.\n pub fn mkdir(path: &Path, mode: FilePermission) {\n-    io_raise(|io| io.fs_mkdir(&path.to_c_str(), mode));\n+    LocalIo::maybe_raise(|io| io.fs_mkdir(&path.to_c_str(), mode));\n }\n \n /// Remove an existing, empty directory\n@@ -475,7 +465,7 @@ pub fn mkdir(path: &Path, mode: FilePermission) {\n /// to remove the directory at the provided path, or if the directory isn't\n /// empty.\n pub fn rmdir(path: &Path) {\n-    io_raise(|io| io.fs_rmdir(&path.to_c_str()));\n+    LocalIo::maybe_raise(|io| io.fs_rmdir(&path.to_c_str()));\n }\n \n /// Retrieve a vector containing all entries within a provided directory\n@@ -502,7 +492,9 @@ pub fn rmdir(path: &Path) {\n /// the process lacks permissions to view the contents or if the `path` points\n /// at a non-directory file\n pub fn readdir(path: &Path) -> ~[Path] {\n-    io_raise(|io| io.fs_readdir(&path.to_c_str(), 0)).unwrap_or_else(|| ~[])\n+    LocalIo::maybe_raise(|io| {\n+        io.fs_readdir(&path.to_c_str(), 0)\n+    }).unwrap_or_else(|| ~[])\n }\n \n /// Returns an iterator which will recursively walk the directory structure\n@@ -583,7 +575,7 @@ pub fn rmdir_recursive(path: &Path) {\n /// happens.\n // FIXME(#10301) these arguments should not be u64\n pub fn change_file_times(path: &Path, atime: u64, mtime: u64) {\n-    io_raise(|io| io.fs_utime(&path.to_c_str(), atime, mtime));\n+    LocalIo::maybe_raise(|io| io.fs_utime(&path.to_c_str(), atime, mtime));\n }\n \n impl Reader for File {"}, {"sha": "6d968de209ca85f07f3a128bfd8b27b7b6eeec4b", "filename": "src/libstd/io/net/addrinfo.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4538369566b8b51fc8371253aa90f9725547a193/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4538369566b8b51fc8371253aa90f9725547a193/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=4538369566b8b51fc8371253aa90f9725547a193", "patch": "@@ -18,8 +18,6 @@ getaddrinfo()\n */\n \n use option::{Option, Some, None};\n-use result::{Ok, Err};\n-use io::{io_error};\n use io::net::ip::{SocketAddr, IpAddr};\n use rt::rtio::{IoFactory, LocalIo};\n use vec::ImmutableVector;\n@@ -97,14 +95,7 @@ pub fn get_host_addresses(host: &str) -> Option<~[IpAddr]> {\n ///      consumption just yet.\n fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)\n           -> Option<~[Info]> {\n-    let mut io = LocalIo::borrow();\n-    match io.get().get_host_addresses(hostname, servname, hint) {\n-        Ok(i) => Some(i),\n-        Err(ioerr) => {\n-            io_error::cond.raise(ioerr);\n-            None\n-        }\n-    }\n+    LocalIo::maybe_raise(|io| io.get_host_addresses(hostname, servname, hint))\n }\n \n #[cfg(test)]"}, {"sha": "bd7d8bacb386d8f98cc1a41d74598a7b03775c65", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4538369566b8b51fc8371253aa90f9725547a193/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4538369566b8b51fc8371253aa90f9725547a193/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=4538369566b8b51fc8371253aa90f9725547a193", "patch": "@@ -26,17 +26,9 @@ impl TcpStream {\n     }\n \n     pub fn connect(addr: SocketAddr) -> Option<TcpStream> {\n-        let result = {\n-            let mut io = LocalIo::borrow();\n-            io.get().tcp_connect(addr)\n-        };\n-        match result {\n-            Ok(s) => Some(TcpStream::new(s)),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+        LocalIo::maybe_raise(|io| {\n+            io.tcp_connect(addr).map(TcpStream::new)\n+        })\n     }\n \n     pub fn peer_name(&mut self) -> Option<SocketAddr> {\n@@ -94,14 +86,9 @@ pub struct TcpListener {\n \n impl TcpListener {\n     pub fn bind(addr: SocketAddr) -> Option<TcpListener> {\n-        let mut io = LocalIo::borrow();\n-        match io.get().tcp_bind(addr) {\n-            Ok(l) => Some(TcpListener { obj: l }),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+        LocalIo::maybe_raise(|io| {\n+            io.tcp_bind(addr).map(|l| TcpListener { obj: l })\n+        })\n     }\n \n     pub fn socket_name(&mut self) -> Option<SocketAddr> {"}, {"sha": "159823ba2b533b86e8bfa06eea6c3c86c018b00d", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4538369566b8b51fc8371253aa90f9725547a193/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4538369566b8b51fc8371253aa90f9725547a193/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=4538369566b8b51fc8371253aa90f9725547a193", "patch": "@@ -21,14 +21,9 @@ pub struct UdpSocket {\n \n impl UdpSocket {\n     pub fn bind(addr: SocketAddr) -> Option<UdpSocket> {\n-        let mut io = LocalIo::borrow();\n-        match io.get().udp_bind(addr) {\n-            Ok(s) => Some(UdpSocket { obj: s }),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+        LocalIo::maybe_raise(|io| {\n+            io.udp_bind(addr).map(|s| UdpSocket { obj: s })\n+        })\n     }\n \n     pub fn recvfrom(&mut self, buf: &mut [u8]) -> Option<(uint, SocketAddr)> {"}, {"sha": "8fd256a22f982f1576b145822ada3a3572195491", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4538369566b8b51fc8371253aa90f9725547a193/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4538369566b8b51fc8371253aa90f9725547a193/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=4538369566b8b51fc8371253aa90f9725547a193", "patch": "@@ -59,14 +59,9 @@ impl UnixStream {\n     ///     stream.write([1, 2, 3]);\n     ///\n     pub fn connect<P: ToCStr>(path: &P) -> Option<UnixStream> {\n-        let mut io = LocalIo::borrow();\n-        match io.get().unix_connect(&path.to_c_str()) {\n-            Ok(s) => Some(UnixStream::new(s)),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+        LocalIo::maybe_raise(|io| {\n+            io.unix_connect(&path.to_c_str()).map(UnixStream::new)\n+        })\n     }\n }\n \n@@ -107,14 +102,9 @@ impl UnixListener {\n     ///     }\n     ///\n     pub fn bind<P: ToCStr>(path: &P) -> Option<UnixListener> {\n-        let mut io = LocalIo::borrow();\n-        match io.get().unix_bind(&path.to_c_str()) {\n-            Ok(s) => Some(UnixListener{ obj: s }),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+        LocalIo::maybe_raise(|io| {\n+            io.unix_bind(&path.to_c_str()).map(|s| UnixListener { obj: s })\n+        })\n     }\n }\n "}, {"sha": "2349c64a84b272e791849b46dd384d4d4069a795", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4538369566b8b51fc8371253aa90f9725547a193/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4538369566b8b51fc8371253aa90f9725547a193/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=4538369566b8b51fc8371253aa90f9725547a193", "patch": "@@ -14,10 +14,9 @@\n //! enough so that pipes can be created to child processes.\n \n use prelude::*;\n-use super::{Reader, Writer};\n use io::{io_error, EndOfFile};\n-use io::native::file;\n-use rt::rtio::{LocalIo, RtioPipe};\n+use libc;\n+use rt::rtio::{RtioPipe, LocalIo};\n \n pub struct PipeStream {\n     priv obj: ~RtioPipe,\n@@ -43,15 +42,10 @@ impl PipeStream {\n     ///\n     /// If the pipe cannot be created, an error will be raised on the\n     /// `io_error` condition.\n-    pub fn open(fd: file::fd_t) -> Option<PipeStream> {\n-        let mut io = LocalIo::borrow();\n-        match io.get().pipe_open(fd) {\n-            Ok(obj) => Some(PipeStream { obj: obj }),\n-            Err(e) => {\n-                io_error::cond.raise(e);\n-                None\n-            }\n-        }\n+    pub fn open(fd: libc::c_int) -> Option<PipeStream> {\n+        LocalIo::maybe_raise(|io| {\n+            io.pipe_open(fd).map(|obj| PipeStream { obj: obj })\n+        })\n     }\n \n     pub fn new(inner: ~RtioPipe) -> PipeStream {"}, {"sha": "bbb2a7ef3984df2fec2406cc4b9738659e4dfcde", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4538369566b8b51fc8371253aa90f9725547a193/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4538369566b8b51fc8371253aa90f9725547a193/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=4538369566b8b51fc8371253aa90f9725547a193", "patch": "@@ -119,19 +119,17 @@ impl Process {\n     /// Creates a new pipe initialized, but not bound to any particular\n     /// source/destination\n     pub fn new(config: ProcessConfig) -> Option<Process> {\n-        let mut io = LocalIo::borrow();\n-        match io.get().spawn(config) {\n-            Ok((p, io)) => Some(Process{\n-                handle: p,\n-                io: io.move_iter().map(|p|\n-                    p.map(|p| io::PipeStream::new(p))\n-                ).collect()\n-            }),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+        let mut config = Some(config);\n+        LocalIo::maybe_raise(|io| {\n+            io.spawn(config.take_unwrap()).map(|(p, io)| {\n+                Process {\n+                    handle: p,\n+                    io: io.move_iter().map(|p| {\n+                        p.map(|p| io::PipeStream::new(p))\n+                    }).collect()\n+                }\n+            })\n+        })\n     }\n \n     /// Returns the process id of this child process"}, {"sha": "4cde35796a642e8abb821718e6a0bff951594d76", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4538369566b8b51fc8371253aa90f9725547a193/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4538369566b8b51fc8371253aa90f9725547a193/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=4538369566b8b51fc8371253aa90f9725547a193", "patch": "@@ -23,8 +23,7 @@ use clone::Clone;\n use comm::{Port, SharedChan};\n use container::{Map, MutableMap};\n use hashmap;\n-use io::io_error;\n-use result::{Err, Ok};\n+use option::{Some, None};\n use rt::rtio::{IoFactory, LocalIo, RtioSignal};\n \n #[repr(int)]\n@@ -122,16 +121,14 @@ impl Listener {\n         if self.handles.contains_key(&signum) {\n             return true; // self is already listening to signum, so succeed\n         }\n-        let mut io = LocalIo::borrow();\n-        match io.get().signal(signum, self.chan.clone()) {\n-            Ok(w) => {\n-                self.handles.insert(signum, w);\n+        match LocalIo::maybe_raise(|io| {\n+            io.signal(signum, self.chan.clone())\n+        }) {\n+            Some(handle) => {\n+                self.handles.insert(signum, handle);\n                 true\n-            },\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                false\n             }\n+            None => false\n         }\n     }\n "}, {"sha": "0adb83d2015354ce84f62c8699051f9fc8539a6c", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4538369566b8b51fc8371253aa90f9725547a193/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4538369566b8b51fc8371253aa90f9725547a193/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=4538369566b8b51fc8371253aa90f9725547a193", "patch": "@@ -27,13 +27,14 @@ out.write(bytes!(\"Hello, world!\"));\n */\n \n use fmt;\n+use io::buffered::LineBufferedWriter;\n+use io::{Reader, Writer, io_error, IoError, OtherIoError,\n+         standard_error, EndOfFile};\n use libc;\n use option::{Option, Some, None};\n use result::{Ok, Err};\n-use io::buffered::LineBufferedWriter;\n use rt::rtio::{DontClose, IoFactory, LocalIo, RtioFileStream, RtioTTY};\n-use super::{Reader, Writer, io_error, IoError, OtherIoError,\n-            standard_error, EndOfFile};\n+use vec;\n \n // And so begins the tale of acquiring a uv handle to a stdio stream on all\n // platforms in all situations. Our story begins by splitting the world into two\n@@ -69,19 +70,12 @@ enum StdSource {\n }\n \n fn src<T>(fd: libc::c_int, readable: bool, f: |StdSource| -> T) -> T {\n-    let mut io = LocalIo::borrow();\n-    match io.get().tty_open(fd, readable) {\n-        Ok(tty) => f(TTY(tty)),\n-        Err(_) => {\n-            // It's not really that desirable if these handles are closed\n-            // synchronously, and because they're squirreled away in a task\n-            // structure the destructors will be run when the task is\n-            // attempted to get destroyed. This means that if we run a\n-            // synchronous destructor we'll attempt to do some scheduling\n-            // operations which will just result in sadness.\n-            f(File(io.get().fs_from_raw_fd(fd, DontClose)))\n-        }\n-    }\n+    LocalIo::maybe_raise(|io| {\n+        Ok(match io.tty_open(fd, readable) {\n+            Ok(tty) => f(TTY(tty)),\n+            Err(_) => f(File(io.fs_from_raw_fd(fd, DontClose))),\n+        })\n+    }).unwrap()\n }\n \n /// Creates a new non-blocking handle to the stdin of the current process."}, {"sha": "7c9aa28bfe9a8008aa3fa6c6472248911498ddc4", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4538369566b8b51fc8371253aa90f9725547a193/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4538369566b8b51fc8371253aa90f9725547a193/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=4538369566b8b51fc8371253aa90f9725547a193", "patch": "@@ -39,9 +39,7 @@ loop {\n */\n \n use comm::Port;\n-use option::{Option, Some, None};\n-use result::{Ok, Err};\n-use io::io_error;\n+use option::Option;\n use rt::rtio::{IoFactory, LocalIo, RtioTimer};\n \n pub struct Timer {\n@@ -60,15 +58,7 @@ impl Timer {\n     /// for a number of milliseconds, or to possibly create channels which will\n     /// get notified after an amount of time has passed.\n     pub fn new() -> Option<Timer> {\n-        let mut io = LocalIo::borrow();\n-        match io.get().timer_init() {\n-            Ok(t) => Some(Timer { obj: t }),\n-            Err(ioerr) => {\n-                debug!(\"Timer::init: failed to init: {:?}\", ioerr);\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+        LocalIo::maybe_raise(|io| io.timer_init().map(|t| Timer { obj: t }))\n     }\n \n     /// Blocks the current task for `msecs` milliseconds."}, {"sha": "7207c1a813435e523af24ba7ead6c3467789a005", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 37, "deletions": 23, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4538369566b8b51fc8371253aa90f9725547a193/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4538369566b8b51fc8371253aa90f9725547a193/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=4538369566b8b51fc8371253aa90f9725547a193", "patch": "@@ -93,36 +93,50 @@ impl<'a> Drop for LocalIo<'a> {\n impl<'a> LocalIo<'a> {\n     /// Returns the local I/O: either the local scheduler's I/O services or\n     /// the native I/O services.\n-    pub fn borrow() -> LocalIo {\n-        use rt::sched::Scheduler;\n-        use rt::local::Local;\n+    pub fn borrow() -> Option<LocalIo> {\n+        // XXX: This is currently very unsafely implemented. We don't actually\n+        //      *take* the local I/O so there's a very real possibility that we\n+        //      can have two borrows at once. Currently there is not a clear way\n+        //      to actually borrow the local I/O factory safely because even if\n+        //      ownership were transferred down to the functions that the I/O\n+        //      factory implements it's just too much of a pain to know when to\n+        //      relinquish ownership back into the local task (but that would be\n+        //      the safe way of implementing this function).\n+        //\n+        // In order to get around this, we just transmute a copy out of the task\n+        // in order to have what is likely a static lifetime (bad).\n+        let mut t: ~Task = Local::take();\n+        let ret = t.local_io().map(|t| {\n+            unsafe { cast::transmute_copy(&t) }\n+        });\n+        Local::put(t);\n+        return ret;\n+    }\n \n-        unsafe {\n-            // First, attempt to use the local scheduler's I/O services\n-            let sched: Option<*mut Scheduler> = Local::try_unsafe_borrow();\n-            match sched {\n-                Some(sched) => {\n-                    match (*sched).event_loop.io() {\n-                        Some(factory) => {\n-                            return LocalIo {\n-                                factory: factory,\n-                            }\n-                        }\n-                        None => {}\n+    pub fn maybe_raise<T>(f: |io: &mut IoFactory| -> Result<T, IoError>)\n+        -> Option<T>\n+    {\n+        match LocalIo::borrow() {\n+            None => {\n+                io::io_error::cond.raise(io::standard_error(io::IoUnavailable));\n+                None\n+            }\n+            Some(mut io) => {\n+                match f(io.get()) {\n+                    Ok(t) => Some(t),\n+                    Err(ioerr) => {\n+                        io::io_error::cond.raise(ioerr);\n+                        None\n                     }\n                 }\n-                None => {}\n-            }\n-            // If we don't have a scheduler or the scheduler doesn't have I/O\n-            // services, then fall back to the native I/O services.\n-            let native_io: &'static mut native::IoFactory =\n-                &mut NATIVE_IO_FACTORY;\n-            LocalIo {\n-                factory: native_io as &mut IoFactory:'static\n             }\n         }\n     }\n \n+    pub fn new<'a>(io: &'a mut IoFactory) -> LocalIo<'a> {\n+        LocalIo { factory: io }\n+    }\n+\n     /// Returns the underlying I/O factory as a trait reference.\n     #[inline]\n     pub fn get<'a>(&'a mut self) -> &'a mut IoFactory {"}]}