{"sha": "c57a932c3f1235d93076a3925b226b9bdb9108fc", "node_id": "C_kwDOAAsO6NoAKGM1N2E5MzJjM2YxMjM1ZDkzMDc2YTM5MjViMjI2YjliZGI5MTA4ZmM", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-08-30T11:26:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-30T11:26:09Z"}, "message": "Rollup merge of #100653 - cuviper:fptoint_sat, r=michaelwoerister,antoyo\n\nMove the cast_float_to_int fallback code to GCC\n\nNow that we require at least LLVM 13, that codegen backend is always\nusing its intrinsic `fptosi.sat` and `fptoui.sat` conversions, so it\ndoesn't need the manual implementation. However, the GCC backend still\nneeds it, so we can move all of that code down there.", "tree": {"sha": "95e7eddae0fed6364be846cc415486d4c7d884b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95e7eddae0fed6364be846cc415486d4c7d884b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c57a932c3f1235d93076a3925b226b9bdb9108fc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjDfPRCRBK7hj4Ov3rIwAA/5kIAGryawLXB7Zql4ELSjJQT+xb\nrYWiCzP4gueD0gB0xGP6nsirztL7Ui6EZTIdJ529ufxYzOEFGWY4Lfo+rzW+4I5O\nn0kCiAyaie7kvEPuKkKw8wvkCHsGl3biN3zTJE4AtEYlPeSWfYItYtfdDjNjDnFh\nfJJfPZAAO/ws5+XTlrZ2W+Q4EmD7qS11OthGw/zjSeEB7zAgb+hS828d2zy4xMol\nWhCbXLdLGLUidRg7Hdxjss8bbeSMFHYqBYTpR7qOxRx+syL7DZYg7wte2Zm9J2Hg\nrhWCR+JswrpgxJBOwoVjq35nLiJuabcUD7MYw07lL3iGv3ainHWiLGepRXYk2QM=\n=OE//\n-----END PGP SIGNATURE-----\n", "payload": "tree 95e7eddae0fed6364be846cc415486d4c7d884b9\nparent 15e2e5185a22207b18d2cbc47a48b39e63e84cd0\nparent 147032a61896db76e97bfde9fa0e711fd5e62b08\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1661858769 +0530\ncommitter GitHub <noreply@github.com> 1661858769 +0530\n\nRollup merge of #100653 - cuviper:fptoint_sat, r=michaelwoerister,antoyo\n\nMove the cast_float_to_int fallback code to GCC\n\nNow that we require at least LLVM 13, that codegen backend is always\nusing its intrinsic `fptosi.sat` and `fptoui.sat` conversions, so it\ndoesn't need the manual implementation. However, the GCC backend still\nneeds it, so we can move all of that code down there.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c57a932c3f1235d93076a3925b226b9bdb9108fc", "html_url": "https://github.com/rust-lang/rust/commit/c57a932c3f1235d93076a3925b226b9bdb9108fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c57a932c3f1235d93076a3925b226b9bdb9108fc/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15e2e5185a22207b18d2cbc47a48b39e63e84cd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/15e2e5185a22207b18d2cbc47a48b39e63e84cd0", "html_url": "https://github.com/rust-lang/rust/commit/15e2e5185a22207b18d2cbc47a48b39e63e84cd0"}, {"sha": "147032a61896db76e97bfde9fa0e711fd5e62b08", "url": "https://api.github.com/repos/rust-lang/rust/commits/147032a61896db76e97bfde9fa0e711fd5e62b08", "html_url": "https://github.com/rust-lang/rust/commit/147032a61896db76e97bfde9fa0e711fd5e62b08"}], "stats": {"total": 347, "additions": 177, "deletions": 170}, "files": [{"sha": "820ec06f678ae84fc3e0ad707a9113f2981f7bf4", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c57a932c3f1235d93076a3925b226b9bdb9108fc/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c57a932c3f1235d93076a3925b226b9bdb9108fc/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=c57a932c3f1235d93076a3925b226b9bdb9108fc", "patch": "@@ -3369,7 +3369,6 @@ dependencies = [\n  \"object 0.29.0\",\n  \"pathdiff\",\n  \"regex\",\n- \"rustc_apfloat\",\n  \"rustc_arena\",\n  \"rustc_ast\",\n  \"rustc_attr\","}, {"sha": "6994eeb00c3e2e6de92639e6039d5e00e8d0c63a", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 169, "deletions": 5, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/c57a932c3f1235d93076a3925b226b9bdb9108fc/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c57a932c3f1235d93076a3925b226b9bdb9108fc/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=c57a932c3f1235d93076a3925b226b9bdb9108fc", "patch": "@@ -15,8 +15,11 @@ use gccjit::{\n     Type,\n     UnaryOp,\n };\n+use rustc_apfloat::{ieee, Float, Round, Status};\n use rustc_codegen_ssa::MemFlags;\n-use rustc_codegen_ssa::common::{AtomicOrdering, AtomicRmwBinOp, IntPredicate, RealPredicate, SynchronizationScope};\n+use rustc_codegen_ssa::common::{\n+    AtomicOrdering, AtomicRmwBinOp, IntPredicate, RealPredicate, SynchronizationScope, TypeKind,\n+};\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{\n@@ -31,6 +34,7 @@ use rustc_codegen_ssa::traits::{\n     StaticBuilderMethods,\n };\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_middle::bug;\n use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n use rustc_middle::ty::layout::{FnAbiError, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, LayoutOfHelpers, TyAndLayout};\n use rustc_span::Span;\n@@ -1271,12 +1275,12 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         val\n     }\n \n-    fn fptoui_sat(&mut self, _val: RValue<'gcc>, _dest_ty: Type<'gcc>) -> Option<RValue<'gcc>> {\n-        None\n+    fn fptoui_sat(&mut self, val: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        self.fptoint_sat(false, val, dest_ty)\n     }\n \n-    fn fptosi_sat(&mut self, _val: RValue<'gcc>, _dest_ty: Type<'gcc>) -> Option<RValue<'gcc>> {\n-        None\n+    fn fptosi_sat(&mut self, val: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        self.fptoint_sat(true, val, dest_ty)\n     }\n \n     fn instrprof_increment(&mut self, _fn_name: RValue<'gcc>, _hash: RValue<'gcc>, _num_counters: RValue<'gcc>, _index: RValue<'gcc>) {\n@@ -1285,6 +1289,166 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n }\n \n impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n+    fn fptoint_sat(&mut self, signed: bool, val: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        let src_ty = self.cx.val_ty(val);\n+        let (float_ty, int_ty) = if self.cx.type_kind(src_ty) == TypeKind::Vector {\n+            assert_eq!(self.cx.vector_length(src_ty), self.cx.vector_length(dest_ty));\n+            (self.cx.element_type(src_ty), self.cx.element_type(dest_ty))\n+        } else {\n+            (src_ty, dest_ty)\n+        };\n+\n+        // FIXME(jistone): the following was originally the fallback SSA implementation, before LLVM 13\n+        // added native `fptosi.sat` and `fptoui.sat` conversions, but it was used by GCC as well.\n+        // Now that LLVM always relies on its own, the code has been moved to GCC, but the comments are\n+        // still LLVM-specific. This should be updated, and use better GCC specifics if possible.\n+\n+        let int_width = self.cx.int_width(int_ty);\n+        let float_width = self.cx.float_width(float_ty);\n+        // LLVM's fpto[su]i returns undef when the input val is infinite, NaN, or does not fit into the\n+        // destination integer type after rounding towards zero. This `undef` value can cause UB in\n+        // safe code (see issue #10184), so we implement a saturating conversion on top of it:\n+        // Semantically, the mathematical value of the input is rounded towards zero to the next\n+        // mathematical integer, and then the result is clamped into the range of the destination\n+        // integer type. Positive and negative infinity are mapped to the maximum and minimum value of\n+        // the destination integer type. NaN is mapped to 0.\n+        //\n+        // Define f_min and f_max as the largest and smallest (finite) floats that are exactly equal to\n+        // a value representable in int_ty.\n+        // They are exactly equal to int_ty::{MIN,MAX} if float_ty has enough significand bits.\n+        // Otherwise, int_ty::MAX must be rounded towards zero, as it is one less than a power of two.\n+        // int_ty::MIN, however, is either zero or a negative power of two and is thus exactly\n+        // representable. Note that this only works if float_ty's exponent range is sufficiently large.\n+        // f16 or 256 bit integers would break this property. Right now the smallest float type is f32\n+        // with exponents ranging up to 127, which is barely enough for i128::MIN = -2^127.\n+        // On the other hand, f_max works even if int_ty::MAX is greater than float_ty::MAX. Because\n+        // we're rounding towards zero, we just get float_ty::MAX (which is always an integer).\n+        // This already happens today with u128::MAX = 2^128 - 1 > f32::MAX.\n+        let int_max = |signed: bool, int_width: u64| -> u128 {\n+            let shift_amount = 128 - int_width;\n+            if signed { i128::MAX as u128 >> shift_amount } else { u128::MAX >> shift_amount }\n+        };\n+        let int_min = |signed: bool, int_width: u64| -> i128 {\n+            if signed { i128::MIN >> (128 - int_width) } else { 0 }\n+        };\n+\n+        let compute_clamp_bounds_single = |signed: bool, int_width: u64| -> (u128, u128) {\n+            let rounded_min =\n+                ieee::Single::from_i128_r(int_min(signed, int_width), Round::TowardZero);\n+            assert_eq!(rounded_min.status, Status::OK);\n+            let rounded_max =\n+                ieee::Single::from_u128_r(int_max(signed, int_width), Round::TowardZero);\n+            assert!(rounded_max.value.is_finite());\n+            (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n+        };\n+        let compute_clamp_bounds_double = |signed: bool, int_width: u64| -> (u128, u128) {\n+            let rounded_min =\n+                ieee::Double::from_i128_r(int_min(signed, int_width), Round::TowardZero);\n+            assert_eq!(rounded_min.status, Status::OK);\n+            let rounded_max =\n+                ieee::Double::from_u128_r(int_max(signed, int_width), Round::TowardZero);\n+            assert!(rounded_max.value.is_finite());\n+            (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n+        };\n+        // To implement saturation, we perform the following steps:\n+        //\n+        // 1. Cast val to an integer with fpto[su]i. This may result in undef.\n+        // 2. Compare val to f_min and f_max, and use the comparison results to select:\n+        //  a) int_ty::MIN if val < f_min or val is NaN\n+        //  b) int_ty::MAX if val > f_max\n+        //  c) the result of fpto[su]i otherwise\n+        // 3. If val is NaN, return 0.0, otherwise return the result of step 2.\n+        //\n+        // This avoids resulting undef because values in range [f_min, f_max] by definition fit into the\n+        // destination type. It creates an undef temporary, but *producing* undef is not UB. Our use of\n+        // undef does not introduce any non-determinism either.\n+        // More importantly, the above procedure correctly implements saturating conversion.\n+        // Proof (sketch):\n+        // If val is NaN, 0 is returned by definition.\n+        // Otherwise, val is finite or infinite and thus can be compared with f_min and f_max.\n+        // This yields three cases to consider:\n+        // (1) if val in [f_min, f_max], the result of fpto[su]i is returned, which agrees with\n+        //     saturating conversion for inputs in that range.\n+        // (2) if val > f_max, then val is larger than int_ty::MAX. This holds even if f_max is rounded\n+        //     (i.e., if f_max < int_ty::MAX) because in those cases, nextUp(f_max) is already larger\n+        //     than int_ty::MAX. Because val is larger than int_ty::MAX, the return value of int_ty::MAX\n+        //     is correct.\n+        // (3) if val < f_min, then val is smaller than int_ty::MIN. As shown earlier, f_min exactly equals\n+        //     int_ty::MIN and therefore the return value of int_ty::MIN is correct.\n+        // QED.\n+\n+        let float_bits_to_llval = |bx: &mut Self, bits| {\n+            let bits_llval = match float_width {\n+                32 => bx.cx().const_u32(bits as u32),\n+                64 => bx.cx().const_u64(bits as u64),\n+                n => bug!(\"unsupported float width {}\", n),\n+            };\n+            bx.bitcast(bits_llval, float_ty)\n+        };\n+        let (f_min, f_max) = match float_width {\n+            32 => compute_clamp_bounds_single(signed, int_width),\n+            64 => compute_clamp_bounds_double(signed, int_width),\n+            n => bug!(\"unsupported float width {}\", n),\n+        };\n+        let f_min = float_bits_to_llval(self, f_min);\n+        let f_max = float_bits_to_llval(self, f_max);\n+        let int_max = self.cx.const_uint_big(int_ty, int_max(signed, int_width));\n+        let int_min = self.cx.const_uint_big(int_ty, int_min(signed, int_width) as u128);\n+        let zero = self.cx.const_uint(int_ty, 0);\n+\n+        // If we're working with vectors, constants must be \"splatted\": the constant is duplicated\n+        // into each lane of the vector.  The algorithm stays the same, we are just using the\n+        // same constant across all lanes.\n+        let maybe_splat = |bx: &mut Self, val| {\n+            if bx.cx().type_kind(dest_ty) == TypeKind::Vector {\n+                bx.vector_splat(bx.vector_length(dest_ty), val)\n+            } else {\n+                val\n+            }\n+        };\n+        let f_min = maybe_splat(self, f_min);\n+        let f_max = maybe_splat(self, f_max);\n+        let int_max = maybe_splat(self, int_max);\n+        let int_min = maybe_splat(self, int_min);\n+        let zero = maybe_splat(self, zero);\n+\n+        // Step 1 ...\n+        let fptosui_result = if signed { self.fptosi(val, dest_ty) } else { self.fptoui(val, dest_ty) };\n+        let less_or_nan = self.fcmp(RealPredicate::RealULT, val, f_min);\n+        let greater = self.fcmp(RealPredicate::RealOGT, val, f_max);\n+\n+        // Step 2: We use two comparisons and two selects, with %s1 being the\n+        // result:\n+        //     %less_or_nan = fcmp ult %val, %f_min\n+        //     %greater = fcmp olt %val, %f_max\n+        //     %s0 = select %less_or_nan, int_ty::MIN, %fptosi_result\n+        //     %s1 = select %greater, int_ty::MAX, %s0\n+        // Note that %less_or_nan uses an *unordered* comparison. This\n+        // comparison is true if the operands are not comparable (i.e., if val is\n+        // NaN). The unordered comparison ensures that s1 becomes int_ty::MIN if\n+        // val is NaN.\n+        //\n+        // Performance note: Unordered comparison can be lowered to a \"flipped\"\n+        // comparison and a negation, and the negation can be merged into the\n+        // select. Therefore, it not necessarily any more expensive than an\n+        // ordered (\"normal\") comparison. Whether these optimizations will be\n+        // performed is ultimately up to the backend, but at least x86 does\n+        // perform them.\n+        let s0 = self.select(less_or_nan, int_min, fptosui_result);\n+        let s1 = self.select(greater, int_max, s0);\n+\n+        // Step 3: NaN replacement.\n+        // For unsigned types, the above step already yielded int_ty::MIN == 0 if val is NaN.\n+        // Therefore we only need to execute this step for signed integer types.\n+        if signed {\n+            // LLVM has no isNaN predicate, so we use (val == val) instead\n+            let cmp = self.fcmp(RealPredicate::RealOEQ, val, val);\n+            self.select(cmp, s1, zero)\n+        } else {\n+            s1\n+        }\n+    }\n+\n     #[cfg(feature=\"master\")]\n     pub fn shuffle_vector(&mut self, v1: RValue<'gcc>, v2: RValue<'gcc>, mask: RValue<'gcc>) -> RValue<'gcc> {\n         let struct_type = mask.get_type().is_struct().expect(\"mask of struct type\");"}, {"sha": "223466fb9b51f26533243aa178b051483b563473", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c57a932c3f1235d93076a3925b226b9bdb9108fc/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c57a932c3f1235d93076a3925b226b9bdb9108fc/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=c57a932c3f1235d93076a3925b226b9bdb9108fc", "patch": "@@ -19,6 +19,7 @@\n #![warn(rust_2018_idioms)]\n #![warn(unused_lifetimes)]\n \n+extern crate rustc_apfloat;\n extern crate rustc_ast;\n extern crate rustc_codegen_ssa;\n extern crate rustc_data_structures;"}, {"sha": "e7e373bf45d11043f9e3ba32bd18d09f10313322", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c57a932c3f1235d93076a3925b226b9bdb9108fc/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c57a932c3f1235d93076a3925b226b9bdb9108fc/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=c57a932c3f1235d93076a3925b226b9bdb9108fc", "patch": "@@ -725,11 +725,11 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         unsafe { llvm::LLVMBuildSExt(self.llbuilder, val, dest_ty, UNNAMED) }\n     }\n \n-    fn fptoui_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> Option<&'ll Value> {\n+    fn fptoui_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.fptoint_sat(false, val, dest_ty)\n     }\n \n-    fn fptosi_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> Option<&'ll Value> {\n+    fn fptosi_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.fptoint_sat(true, val, dest_ty)\n     }\n \n@@ -1429,12 +1429,7 @@ impl<'a, 'll, 'tcx> Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn fptoint_sat(\n-        &mut self,\n-        signed: bool,\n-        val: &'ll Value,\n-        dest_ty: &'ll Type,\n-    ) -> Option<&'ll Value> {\n+    fn fptoint_sat(&mut self, signed: bool, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         let src_ty = self.cx.val_ty(val);\n         let (float_ty, int_ty, vector_length) = if self.cx.type_kind(src_ty) == TypeKind::Vector {\n             assert_eq!(self.cx.vector_length(src_ty), self.cx.vector_length(dest_ty));\n@@ -1459,7 +1454,7 @@ impl<'a, 'll, 'tcx> Builder<'a, 'll, 'tcx> {\n             format!(\"llvm.{}.sat.i{}.f{}\", instr, int_width, float_width)\n         };\n         let f = self.declare_cfn(&name, llvm::UnnamedAddr::No, self.type_func(&[src_ty], dest_ty));\n-        Some(self.call(self.type_func(&[src_ty], dest_ty), f, &[val], None))\n+        self.call(self.type_func(&[src_ty], dest_ty), f, &[val], None)\n     }\n \n     pub(crate) fn landing_pad("}, {"sha": "d868e3d56ba6b33d240fe92b65b7e003ebe45726", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c57a932c3f1235d93076a3925b226b9bdb9108fc/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c57a932c3f1235d93076a3925b226b9bdb9108fc/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=c57a932c3f1235d93076a3925b226b9bdb9108fc", "patch": "@@ -26,7 +26,6 @@ rustc_arena = { path = \"../rustc_arena\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_middle = { path = \"../rustc_middle\" }\n-rustc_apfloat = { path = \"../rustc_apfloat\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_symbol_mangling = { path = \"../rustc_symbol_mangling\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }"}, {"sha": "10cf8948b5a54fc55c73e100fc988f7752d7b607", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 3, "deletions": 154, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/c57a932c3f1235d93076a3925b226b9bdb9108fc/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c57a932c3f1235d93076a3925b226b9bdb9108fc/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=c57a932c3f1235d93076a3925b226b9bdb9108fc", "patch": "@@ -1,6 +1,5 @@\n use super::abi::AbiBuilderMethods;\n use super::asm::AsmBuilderMethods;\n-use super::consts::ConstMethods;\n use super::coverageinfo::CoverageInfoBuilderMethods;\n use super::debuginfo::DebugInfoBuilderMethods;\n use super::intrinsic::IntrinsicCallMethods;\n@@ -15,7 +14,6 @@ use crate::mir::operand::OperandRef;\n use crate::mir::place::PlaceRef;\n use crate::MemFlags;\n \n-use rustc_apfloat::{ieee, Float, Round, Status};\n use rustc_middle::ty::layout::{HasParamEnv, TyAndLayout};\n use rustc_middle::ty::Ty;\n use rustc_span::Span;\n@@ -188,8 +186,8 @@ pub trait BuilderMethods<'a, 'tcx>:\n \n     fn trunc(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn sext(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n-    fn fptoui_sat(&mut self, val: Self::Value, dest_ty: Self::Type) -> Option<Self::Value>;\n-    fn fptosi_sat(&mut self, val: Self::Value, dest_ty: Self::Type) -> Option<Self::Value>;\n+    fn fptoui_sat(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n+    fn fptosi_sat(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn fptoui(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn fptosi(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn uitofp(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n@@ -223,156 +221,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n             return if signed { self.fptosi(x, dest_ty) } else { self.fptoui(x, dest_ty) };\n         }\n \n-        let try_sat_result =\n-            if signed { self.fptosi_sat(x, dest_ty) } else { self.fptoui_sat(x, dest_ty) };\n-        if let Some(try_sat_result) = try_sat_result {\n-            return try_sat_result;\n-        }\n-\n-        let int_width = self.cx().int_width(int_ty);\n-        let float_width = self.cx().float_width(float_ty);\n-        // LLVM's fpto[su]i returns undef when the input x is infinite, NaN, or does not fit into the\n-        // destination integer type after rounding towards zero. This `undef` value can cause UB in\n-        // safe code (see issue #10184), so we implement a saturating conversion on top of it:\n-        // Semantically, the mathematical value of the input is rounded towards zero to the next\n-        // mathematical integer, and then the result is clamped into the range of the destination\n-        // integer type. Positive and negative infinity are mapped to the maximum and minimum value of\n-        // the destination integer type. NaN is mapped to 0.\n-        //\n-        // Define f_min and f_max as the largest and smallest (finite) floats that are exactly equal to\n-        // a value representable in int_ty.\n-        // They are exactly equal to int_ty::{MIN,MAX} if float_ty has enough significand bits.\n-        // Otherwise, int_ty::MAX must be rounded towards zero, as it is one less than a power of two.\n-        // int_ty::MIN, however, is either zero or a negative power of two and is thus exactly\n-        // representable. Note that this only works if float_ty's exponent range is sufficiently large.\n-        // f16 or 256 bit integers would break this property. Right now the smallest float type is f32\n-        // with exponents ranging up to 127, which is barely enough for i128::MIN = -2^127.\n-        // On the other hand, f_max works even if int_ty::MAX is greater than float_ty::MAX. Because\n-        // we're rounding towards zero, we just get float_ty::MAX (which is always an integer).\n-        // This already happens today with u128::MAX = 2^128 - 1 > f32::MAX.\n-        let int_max = |signed: bool, int_width: u64| -> u128 {\n-            let shift_amount = 128 - int_width;\n-            if signed { i128::MAX as u128 >> shift_amount } else { u128::MAX >> shift_amount }\n-        };\n-        let int_min = |signed: bool, int_width: u64| -> i128 {\n-            if signed { i128::MIN >> (128 - int_width) } else { 0 }\n-        };\n-\n-        let compute_clamp_bounds_single = |signed: bool, int_width: u64| -> (u128, u128) {\n-            let rounded_min =\n-                ieee::Single::from_i128_r(int_min(signed, int_width), Round::TowardZero);\n-            assert_eq!(rounded_min.status, Status::OK);\n-            let rounded_max =\n-                ieee::Single::from_u128_r(int_max(signed, int_width), Round::TowardZero);\n-            assert!(rounded_max.value.is_finite());\n-            (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n-        };\n-        let compute_clamp_bounds_double = |signed: bool, int_width: u64| -> (u128, u128) {\n-            let rounded_min =\n-                ieee::Double::from_i128_r(int_min(signed, int_width), Round::TowardZero);\n-            assert_eq!(rounded_min.status, Status::OK);\n-            let rounded_max =\n-                ieee::Double::from_u128_r(int_max(signed, int_width), Round::TowardZero);\n-            assert!(rounded_max.value.is_finite());\n-            (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n-        };\n-        // To implement saturation, we perform the following steps:\n-        //\n-        // 1. Cast x to an integer with fpto[su]i. This may result in undef.\n-        // 2. Compare x to f_min and f_max, and use the comparison results to select:\n-        //  a) int_ty::MIN if x < f_min or x is NaN\n-        //  b) int_ty::MAX if x > f_max\n-        //  c) the result of fpto[su]i otherwise\n-        // 3. If x is NaN, return 0.0, otherwise return the result of step 2.\n-        //\n-        // This avoids resulting undef because values in range [f_min, f_max] by definition fit into the\n-        // destination type. It creates an undef temporary, but *producing* undef is not UB. Our use of\n-        // undef does not introduce any non-determinism either.\n-        // More importantly, the above procedure correctly implements saturating conversion.\n-        // Proof (sketch):\n-        // If x is NaN, 0 is returned by definition.\n-        // Otherwise, x is finite or infinite and thus can be compared with f_min and f_max.\n-        // This yields three cases to consider:\n-        // (1) if x in [f_min, f_max], the result of fpto[su]i is returned, which agrees with\n-        //     saturating conversion for inputs in that range.\n-        // (2) if x > f_max, then x is larger than int_ty::MAX. This holds even if f_max is rounded\n-        //     (i.e., if f_max < int_ty::MAX) because in those cases, nextUp(f_max) is already larger\n-        //     than int_ty::MAX. Because x is larger than int_ty::MAX, the return value of int_ty::MAX\n-        //     is correct.\n-        // (3) if x < f_min, then x is smaller than int_ty::MIN. As shown earlier, f_min exactly equals\n-        //     int_ty::MIN and therefore the return value of int_ty::MIN is correct.\n-        // QED.\n-\n-        let float_bits_to_llval = |bx: &mut Self, bits| {\n-            let bits_llval = match float_width {\n-                32 => bx.cx().const_u32(bits as u32),\n-                64 => bx.cx().const_u64(bits as u64),\n-                n => bug!(\"unsupported float width {}\", n),\n-            };\n-            bx.bitcast(bits_llval, float_ty)\n-        };\n-        let (f_min, f_max) = match float_width {\n-            32 => compute_clamp_bounds_single(signed, int_width),\n-            64 => compute_clamp_bounds_double(signed, int_width),\n-            n => bug!(\"unsupported float width {}\", n),\n-        };\n-        let f_min = float_bits_to_llval(self, f_min);\n-        let f_max = float_bits_to_llval(self, f_max);\n-        let int_max = self.cx().const_uint_big(int_ty, int_max(signed, int_width));\n-        let int_min = self.cx().const_uint_big(int_ty, int_min(signed, int_width) as u128);\n-        let zero = self.cx().const_uint(int_ty, 0);\n-\n-        // If we're working with vectors, constants must be \"splatted\": the constant is duplicated\n-        // into each lane of the vector.  The algorithm stays the same, we are just using the\n-        // same constant across all lanes.\n-        let maybe_splat = |bx: &mut Self, val| {\n-            if bx.cx().type_kind(dest_ty) == TypeKind::Vector {\n-                bx.vector_splat(bx.vector_length(dest_ty), val)\n-            } else {\n-                val\n-            }\n-        };\n-        let f_min = maybe_splat(self, f_min);\n-        let f_max = maybe_splat(self, f_max);\n-        let int_max = maybe_splat(self, int_max);\n-        let int_min = maybe_splat(self, int_min);\n-        let zero = maybe_splat(self, zero);\n-\n-        // Step 1 ...\n-        let fptosui_result = if signed { self.fptosi(x, dest_ty) } else { self.fptoui(x, dest_ty) };\n-        let less_or_nan = self.fcmp(RealPredicate::RealULT, x, f_min);\n-        let greater = self.fcmp(RealPredicate::RealOGT, x, f_max);\n-\n-        // Step 2: We use two comparisons and two selects, with %s1 being the\n-        // result:\n-        //     %less_or_nan = fcmp ult %x, %f_min\n-        //     %greater = fcmp olt %x, %f_max\n-        //     %s0 = select %less_or_nan, int_ty::MIN, %fptosi_result\n-        //     %s1 = select %greater, int_ty::MAX, %s0\n-        // Note that %less_or_nan uses an *unordered* comparison. This\n-        // comparison is true if the operands are not comparable (i.e., if x is\n-        // NaN). The unordered comparison ensures that s1 becomes int_ty::MIN if\n-        // x is NaN.\n-        //\n-        // Performance note: Unordered comparison can be lowered to a \"flipped\"\n-        // comparison and a negation, and the negation can be merged into the\n-        // select. Therefore, it not necessarily any more expensive than an\n-        // ordered (\"normal\") comparison. Whether these optimizations will be\n-        // performed is ultimately up to the backend, but at least x86 does\n-        // perform them.\n-        let s0 = self.select(less_or_nan, int_min, fptosui_result);\n-        let s1 = self.select(greater, int_max, s0);\n-\n-        // Step 3: NaN replacement.\n-        // For unsigned types, the above step already yielded int_ty::MIN == 0 if x is NaN.\n-        // Therefore we only need to execute this step for signed integer types.\n-        if signed {\n-            // LLVM has no isNaN predicate, so we use (x == x) instead\n-            let cmp = self.fcmp(RealPredicate::RealOEQ, x, x);\n-            self.select(cmp, s1, zero)\n-        } else {\n-            s1\n-        }\n+        if signed { self.fptosi_sat(x, dest_ty) } else { self.fptoui_sat(x, dest_ty) }\n     }\n \n     fn icmp(&mut self, op: IntPredicate, lhs: Self::Value, rhs: Self::Value) -> Self::Value;"}]}