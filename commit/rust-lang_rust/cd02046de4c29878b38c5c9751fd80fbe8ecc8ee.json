{"sha": "cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkMDIwNDZkZTRjMjk4NzhiMzhjNWM5NzUxZmQ4MGZiZThlY2M4ZWU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-06-07T05:30:52Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-06-07T05:30:52Z"}, "message": "merge", "tree": {"sha": "0ab09bf5331761b8132e7a61ed8f646eaad70005", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ab09bf5331761b8132e7a61ed8f646eaad70005"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "html_url": "https://github.com/rust-lang/rust/commit/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3685d53a61355e141e65dbd4075180eade3ace2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3685d53a61355e141e65dbd4075180eade3ace2c", "html_url": "https://github.com/rust-lang/rust/commit/3685d53a61355e141e65dbd4075180eade3ace2c"}, {"sha": "0327dc0b188ee536eb6865cf202f03c88864f4fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/0327dc0b188ee536eb6865cf202f03c88864f4fb", "html_url": "https://github.com/rust-lang/rust/commit/0327dc0b188ee536eb6865cf202f03c88864f4fb"}], "stats": {"total": 1321, "additions": 748, "deletions": 573}, "files": [{"sha": "df9cb78ef8f17c5998d95f4cadffb6c4ace2b182", "filename": "Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -421,9 +421,9 @@ else\n TSREQS :=\t\t\t\t\t\t\t\t\t\t\t\\\n \t$(foreach target,$(CFG_TARGET_TRIPLES),\t\t\t\\\n \t\t$(SREQ3_T_$(target)_H_$(CFG_HOST_TRIPLE)))\n-FUZZ := $(HBIN3_H_$(CFG_HOST_TRIPLE))/fuzzer$(X)\n-CARGO := $(HBIN3_H_$(CFG_HOST_TRIPLE))/cargo$(X)\n-RUSTDOC := $(HBIN3_H_$(CFG_HOST_TRIPLE))/rustdoc$(X)\n+FUZZ := $(HBIN2_H_$(CFG_HOST_TRIPLE))/fuzzer$(X)\n+CARGO := $(HBIN2_H_$(CFG_HOST_TRIPLE))/cargo$(X)\n+RUSTDOC := $(HBIN2_H_$(CFG_HOST_TRIPLE))/rustdoc$(X)\n \n all: rustc $(GENERATED) docs $(FUZZ) $(CARGO) $(RUSTDOC)\n "}, {"sha": "ff099f3d007ac673263d3d17e3b8b44860b50958", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -332,7 +332,7 @@ fn try_parse_sources(filename: str, sources: map::hashmap<str, source>) {\n     }\n }\n \n-fn load_one_source_package(&src: source, p: map::hashmap<str, json::json>) {\n+fn load_one_source_package(&&src: source, p: map::hashmap<str, json::json>) {\n     let name = alt p.find(\"name\") {\n         some(json::string(_n)) { _n }\n         _ {\n@@ -404,8 +404,8 @@ fn load_one_source_package(&src: source, p: map::hashmap<str, json::json>) {\n     log(debug, \"  loaded package: \" + src.name + \"/\" + name);\n }\n \n-fn load_source_packages(&c: cargo, &src: source) {\n-    log(debug, \"loading source: \" + src.name);\n+fn load_source_packages(&&c: cargo, &&src: source) {\n+    log(debug, \"Loading source: \" + src.name);\n     let dir = path::connect(c.sourcedir, src.name);\n     let pkgfile = path::connect(dir, \"packages.json\");\n     if !os::path_exists(pkgfile) { ret; }"}, {"sha": "aea97cf1649f539042a10d9a72c622e15a3ce158", "filename": "src/libcore/cmp.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -0,0 +1,10 @@\n+#[doc=\"Interfaces used for comparison.\"]\n+\n+iface ord {\n+    fn lt(&&other: self) -> bool;\n+}\n+\n+iface eq {\n+    fn eq(&&other: self) -> bool;\n+}\n+"}, {"sha": "efcd424024a1c5db946cb3eb9af9bc9554c6d9d3", "filename": "src/libcore/core.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -44,6 +44,7 @@ export extfmt;\n export tuple;\n export to_str;\n export dvec, dvec_iter;\n+export cmp;\n \n // NDM seems to be necessary for resolve to work\n export option_iter;\n@@ -152,6 +153,7 @@ mod tuple;\n \n // Ubiquitous-utility-type modules\n \n+mod cmp;\n mod either;\n mod iter;\n mod logging;"}, {"sha": "ccaab58553f792470272cb9fbc635f77022919ff", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -57,6 +57,11 @@ fn dvec<A>() -> dvec<A> {\n     {mut data: [mut]}\n }\n \n+#[doc = \"Creates a new dvec with a single element\"]\n+fn from_elt<A>(+e: A) -> dvec<A> {\n+    {mut data: [mut e]}\n+}\n+\n #[doc = \"Creates a new dvec with the contents of a vector\"]\n fn from_vec<A>(+v: [mut A]) -> dvec<A> {\n     {mut data: v}\n@@ -234,12 +239,19 @@ impl extensions<A:copy> for dvec<A> {\n         self.data[idx] = a;\n     }\n \n-    #[doc = \"Overwrites the contents of the element at `idx` with `a`\"]\n+    #[doc = \"Overwrites the contents of the element at `idx` with `a`,\n+    growing the vector if necessary.  New elements will be initialized\n+    with `initval`\"]\n     fn grow_set_elt(idx: uint, initval: A, val: A) {\n         self.swap { |v|\n             let mut v <- v;\n             vec::grow_set(v, idx, initval, val);\n             v\n         }\n     }\n+\n+    #[doc = \"Returns the last element, failing if the vector is empty\"]\n+    fn last() -> A {\n+        self.get_elt(self.len() - 1u)\n+    }\n }\n\\ No newline at end of file"}, {"sha": "6152b83536a87e73aa89a1c9b99b9be0a66f65d4", "filename": "src/libcore/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -108,7 +108,7 @@ fn get<A:copy>(future: future<A>) -> A {\n fn with<A,B>(future: future<A>, blk: fn(A) -> B) -> B {\n     #[doc = \"Work with the value without copying it\"];\n \n-    let v = alt future.v {\n+    let v = alt copy future.v {\n       either::left(v) { v }\n       either::right(f) {\n         let v = @f();"}, {"sha": "4011ac1a18a7d23e4511fda14bcd828664f05e0f", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -1,4 +1,5 @@\n import T = inst::T;\n+import cmp::{eq, ord};\n \n export min_value, max_value;\n export min, max;\n@@ -10,6 +11,7 @@ export range;\n export compl;\n export abs;\n export parse_buf, from_str, to_str, to_str_bytes, str;\n+export ord, eq;\n \n const min_value: T = -1 as T << (inst::bits - 1 as T);\n const max_value: T = min_value - 1 as T;\n@@ -108,6 +110,18 @@ fn to_str_bytes<U>(n: T, radix: uint, f: fn([u8]/&) -> U) -> U {\n #[doc = \"Convert to a string\"]\n fn str(i: T) -> str { ret to_str(i, 10u); }\n \n+impl ord of ord for T {\n+    fn lt(&&other: T) -> bool {\n+        ret self < other;\n+    }\n+}\n+\n+impl eq of eq for T {\n+    fn eq(&&other: T) -> bool {\n+        ret self == other;\n+    }\n+}\n+\n \n // FIXME: Has alignment issues on windows and 32-bit linux\n #[test]"}, {"sha": "b18be417019b61fe1ad6260f913d5cf9a633263c", "filename": "src/libcore/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -613,7 +613,7 @@ impl of writer for mem_buffer {\n         // FIXME #2004--use memcpy here?\n         let mut pos = self.pos, vpos = 0u;\n         while vpos < vlen && pos < buf_len {\n-            self.buf.set_elt(pos, v[vpos]);\n+            self.buf.set_elt(pos, copy v[vpos]);\n             pos += 1u;\n             vpos += 1u;\n         }"}, {"sha": "71bd1025d1db50bd918d19e9549ef3def4edce7e", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -218,7 +218,7 @@ impl extensions for rng {\n     }\n \n     #[doc = \"Shuffle a mutable vec in place\"]\n-    fn shuffle_mut<T>(&values: [mut T]) {\n+    fn shuffle_mut<T>(&&values: [mut T]) {\n         let mut i = values.len();\n         while i >= 2u {\n             // invariant: elements with index >= i have been locked in place."}, {"sha": "6c24b65698845b65052dc1bad19903d54d7ee626", "filename": "src/libcore/str.rs", "status": "modified", "additions": 118, "deletions": 97, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -122,7 +122,7 @@ Convert a vector of bytes to a UTF-8 string\n \n Fails if invalid UTF-8\n \"]\n-fn from_bytes(vv: [u8]) -> str unsafe {\n+pure fn from_bytes(vv: [u8]) -> str unsafe {\n    assert is_utf8(vv);\n    ret unsafe::from_bytes(vv);\n }\n@@ -134,7 +134,7 @@ Convert a byte to a UTF-8 string\n \n Fails if invalid UTF-8\n \"]\n-fn from_byte(b: u8) -> str unsafe {\n+pure fn from_byte(b: u8) -> str unsafe {\n     assert b < 128u8;\n     let mut v = [b, 0u8];\n     let s: str = ::unsafe::reinterpret_cast(v);\n@@ -217,22 +217,24 @@ fn push_char(&s: str, ch: char) unsafe {\n }\n \n #[doc = \"Convert a char to a string\"]\n-fn from_char(ch: char) -> str {\n+pure fn from_char(ch: char) -> str {\n     let mut buf = \"\";\n-    push_char(buf, ch);\n+    unchecked { push_char(buf, ch); }\n     ret buf;\n }\n \n #[doc = \"Convert a vector of chars to a string\"]\n-fn from_chars(chs: [char]) -> str {\n+pure fn from_chars(chs: [char]) -> str {\n     let mut buf = \"\";\n-    reserve(buf, chs.len());\n-    for vec::each(chs) {|ch| push_char(buf, ch); }\n+    unchecked {\n+        reserve(buf, chs.len());\n+        for vec::each(chs) {|ch| push_char(buf, ch); }\n+    }\n     ret buf;\n }\n \n #[doc = \"Concatenate a vector of strings\"]\n-fn concat(v: [str]) -> str {\n+pure fn concat(v: [str]) -> str {\n     let mut s: str = \"\";\n     for vec::each(v) {|ss| s += ss; }\n     ret s;\n@@ -241,7 +243,7 @@ fn concat(v: [str]) -> str {\n #[doc = \"\n Concatenate a vector of strings, placing a given separator between each\n \"]\n-fn connect(v: [str], sep: str) -> str {\n+pure fn connect(v: [str], sep: str) -> str {\n     let mut s = \"\", first = true;\n     for vec::each(v) {|ss|\n         if first { first = false; } else { s += sep; }\n@@ -286,7 +288,7 @@ fn shift_char(&s: str) -> char unsafe {\n fn unshift_char(&s: str, ch: char) { s = from_char(ch) + s; }\n \n #[doc = \"Returns a string with leading whitespace removed\"]\n-fn trim_left(+s: str) -> str {\n+pure fn trim_left(+s: str) -> str {\n     alt find(s, {|c| !char::is_whitespace(c)}) {\n       none { \"\" }\n       some(first) {\n@@ -297,7 +299,7 @@ fn trim_left(+s: str) -> str {\n }\n \n #[doc = \"Returns a string with trailing whitespace removed\"]\n-fn trim_right(+s: str) -> str {\n+pure fn trim_right(+s: str) -> str {\n     alt rfind(s, {|c| !char::is_whitespace(c)}) {\n       none { \"\" }\n       some(last) {\n@@ -309,7 +311,7 @@ fn trim_right(+s: str) -> str {\n }\n \n #[doc = \"Returns a string with leading and trailing whitespace removed\"]\n-fn trim(+s: str) -> str { trim_left(trim_right(s)) }\n+pure fn trim(+s: str) -> str { trim_left(trim_right(s)) }\n \n /*\n Section: Transforming strings\n@@ -320,7 +322,7 @@ Converts a string to a vector of bytes\n \n The result vector is not null-terminated.\n \"]\n-fn bytes(s: str) -> [u8] unsafe {\n+pure fn bytes(s: str) -> [u8] unsafe {\n     let mut s_copy = s;\n     let mut v: [u8] = ::unsafe::reinterpret_cast(s_copy);\n     ::unsafe::forget(s_copy);\n@@ -332,14 +334,14 @@ fn bytes(s: str) -> [u8] unsafe {\n Work with the string as a byte slice, not including trailing null.\n \"]\n #[inline(always)]\n-fn byte_slice<T>(s: str/&, f: fn([u8]/&) -> T) -> T unsafe {\n+pure fn byte_slice<T>(s: str/&, f: fn([u8]/&) -> T) -> T unsafe {\n     unpack_slice(s) {|p,n|\n         vec::unsafe::form_slice(p, n-1u, f)\n     }\n }\n \n #[doc = \"Convert a string to a vector of characters\"]\n-fn chars(s: str) -> [char] {\n+pure fn chars(s: str) -> [char] {\n     let mut buf = [], i = 0u;\n     let len = len(s);\n     while i < len {\n@@ -356,7 +358,7 @@ Take a substring of another.\n Returns a string containing `n` characters starting at byte offset\n `begin`.\n \"]\n-fn substr(s: str, begin: uint, n: uint) -> str {\n+pure fn substr(s: str, begin: uint, n: uint) -> str {\n     slice(s, begin, begin + count_bytes(s, begin, n))\n }\n \n@@ -366,7 +368,7 @@ Returns a slice of the given string from the byte range [`begin`..`end`)\n Fails when `begin` and `end` do not point to valid characters or\n beyond the last character of the string\n \"]\n-fn slice(s: str, begin: uint, end: uint) -> str unsafe {\n+pure fn slice(s: str, begin: uint, end: uint) -> str unsafe {\n     assert is_char_boundary(s, begin);\n     assert is_char_boundary(s, end);\n     unsafe::slice_bytes(s, begin, end)\n@@ -375,7 +377,7 @@ fn slice(s: str, begin: uint, end: uint) -> str unsafe {\n #[doc = \"\n Splits a string into substrings at each occurrence of a given character\n \"]\n-fn split_char(s: str, sep: char) -> [str] {\n+pure fn split_char(s: str, sep: char) -> [str] {\n     split_char_inner(s, sep, len(s), true)\n }\n \n@@ -385,18 +387,18 @@ character up to 'count' times\n \n The byte must be a valid UTF-8/ASCII byte\n \"]\n-fn splitn_char(s: str, sep: char, count: uint) -> [str] {\n+pure fn splitn_char(s: str, sep: char, count: uint) -> [str] {\n     split_char_inner(s, sep, count, true)\n }\n \n #[doc = \"\n Like `split_char`, but omits empty strings from the returned vector\n \"]\n-fn split_char_nonempty(s: str, sep: char) -> [str] {\n+pure fn split_char_nonempty(s: str, sep: char) -> [str] {\n     split_char_inner(s, sep, len(s), false)\n }\n \n-fn split_char_inner(s: str, sep: char, count: uint, allow_empty: bool)\n+pure fn split_char_inner(s: str, sep: char, count: uint, allow_empty: bool)\n     -> [str] unsafe {\n     if sep < 128u as char {\n         let b = sep as u8, l = len(s);\n@@ -423,24 +425,24 @@ fn split_char_inner(s: str, sep: char, count: uint, allow_empty: bool)\n \n \n #[doc = \"Splits a string into substrings using a character function\"]\n-fn split(s: str, sepfn: fn(char) -> bool) -> [str] {\n+pure fn split(s: str, sepfn: fn(char) -> bool) -> [str] {\n     split_inner(s, sepfn, len(s), true)\n }\n \n #[doc = \"\n Splits a string into substrings using a character function, cutting at\n most `count` times.\n \"]\n-fn splitn(s: str, sepfn: fn(char) -> bool, count: uint) -> [str] {\n+pure fn splitn(s: str, sepfn: fn(char) -> bool, count: uint) -> [str] {\n     split_inner(s, sepfn, count, true)\n }\n \n #[doc = \"Like `split`, but omits empty strings from the returned vector\"]\n-fn split_nonempty(s: str, sepfn: fn(char) -> bool) -> [str] {\n+pure fn split_nonempty(s: str, sepfn: fn(char) -> bool) -> [str] {\n     split_inner(s, sepfn, len(s), false)\n }\n \n-fn split_inner(s: str, sepfn: fn(cc: char) -> bool, count: uint,\n+pure fn split_inner(s: str, sepfn: fn(cc: char) -> bool, count: uint,\n                allow_empty: bool) -> [str] unsafe {\n     let l = len(s);\n     let mut result = [], i = 0u, start = 0u, done = 0u;\n@@ -462,7 +464,7 @@ fn split_inner(s: str, sepfn: fn(cc: char) -> bool, count: uint,\n }\n \n // See Issue #1932 for why this is a naive search\n-fn iter_matches(s: str, sep: str, f: fn(uint, uint)) {\n+pure fn iter_matches(s: str, sep: str, f: fn(uint, uint)) {\n     let sep_len = len(sep), l = len(s);\n     assert sep_len > 0u;\n     let mut i = 0u, match_start = 0u, match_i = 0u;\n@@ -489,7 +491,7 @@ fn iter_matches(s: str, sep: str, f: fn(uint, uint)) {\n     }\n }\n \n-fn iter_between_matches(s: str, sep: str, f: fn(uint, uint)) {\n+pure fn iter_between_matches(s: str, sep: str, f: fn(uint, uint)) {\n     let mut last_end = 0u;\n     iter_matches(s, sep) {|from, to|\n         f(last_end, from);\n@@ -507,15 +509,15 @@ Splits a string into a vector of the substrings separated by a given string\n assert [\\\"\\\", \\\"XXX\\\", \\\"YYY\\\", \\\"\\\"] == split_str(\\\".XXX.YYY.\\\", \\\".\\\")\n ~~~\n \"]\n-fn split_str(s: str, sep: str) -> [str] {\n+pure fn split_str(s: str, sep: str) -> [str] {\n     let mut result = [];\n     iter_between_matches(s, sep) {|from, to|\n         unsafe { result += [unsafe::slice_bytes(s, from, to)]; }\n     }\n     result\n }\n \n-fn split_str_nonempty(s: str, sep: str) -> [str] {\n+pure fn split_str_nonempty(s: str, sep: str) -> [str] {\n     let mut result = [];\n     iter_between_matches(s, sep) {|from, to|\n         if to > from {\n@@ -528,13 +530,13 @@ fn split_str_nonempty(s: str, sep: str) -> [str] {\n #[doc = \"\n Splits a string into a vector of the substrings separated by LF ('\\\\n')\n \"]\n-fn lines(s: str) -> [str] { split_char(s, '\\n') }\n+pure fn lines(s: str) -> [str] { split_char(s, '\\n') }\n \n #[doc = \"\n Splits a string into a vector of the substrings separated by LF ('\\\\n')\n and/or CR LF ('\\\\r\\\\n')\n \"]\n-fn lines_any(s: str) -> [str] {\n+pure fn lines_any(s: str) -> [str] {\n     vec::map(lines(s), {|s|\n         let l = len(s);\n         let mut cp = s;\n@@ -548,18 +550,22 @@ fn lines_any(s: str) -> [str] {\n #[doc = \"\n Splits a string into a vector of the substrings separated by whitespace\n \"]\n-fn words(s: str) -> [str] {\n+pure fn words(s: str) -> [str] {\n     split_nonempty(s, {|c| char::is_whitespace(c)})\n }\n \n #[doc = \"Convert a string to lowercase. ASCII only\"]\n-fn to_lower(s: str) -> str {\n-    map(s, {|c| (libc::tolower(c as libc::c_char)) as char})\n+pure fn to_lower(s: str) -> str {\n+    map(s, {|c|\n+        unchecked{(libc::tolower(c as libc::c_char)) as char}\n+    })\n }\n \n #[doc = \"Convert a string to uppercase. ASCII only\"]\n-fn to_upper(s: str) -> str {\n-    map(s, {|c| (libc::toupper(c as libc::c_char)) as char})\n+pure fn to_upper(s: str) -> str {\n+    map(s, {|c|\n+        unchecked{(libc::toupper(c as libc::c_char)) as char}\n+    })\n }\n \n #[doc = \"\n@@ -575,7 +581,7 @@ Replace all occurances of one string with another\n \n The original string with all occurances of `from` replaced with `to`\n \"]\n-fn replace(s: str, from: str, to: str) -> str unsafe {\n+pure fn replace(s: str, from: str, to: str) -> str unsafe {\n     let mut result = \"\", first = true;\n     iter_between_matches(s, from) {|start, end|\n         if first { first = false; } else { result += to; }\n@@ -595,7 +601,7 @@ pure fn eq(&&a: str, &&b: str) -> bool { a == b }\n pure fn le(&&a: str, &&b: str) -> bool { a <= b }\n \n #[doc = \"String hash function\"]\n-fn hash(&&s: str) -> uint {\n+pure fn hash(&&s: str) -> uint {\n     // djb hash.\n     // FIXME: replace with murmur. (see #859 and #1616)\n     let mut u: uint = 5381u;\n@@ -611,28 +617,32 @@ Section: Iterating through strings\n Return true if a predicate matches all characters or if the string\n contains no characters\n \"]\n-fn all(s: str, it: fn(char) -> bool) -> bool {\n+pure fn all(s: str, it: fn(char) -> bool) -> bool {\n     all_between(s, 0u, len(s), it)\n }\n \n #[doc = \"\n Return true if a predicate matches any character (and false if it\n matches none or there are no characters)\n \"]\n-fn any(ss: str, pred: fn(char) -> bool) -> bool {\n+pure fn any(ss: str, pred: fn(char) -> bool) -> bool {\n     !all(ss, {|cc| !pred(cc)})\n }\n \n #[doc = \"Apply a function to each character\"]\n-fn map(ss: str, ff: fn(char) -> char) -> str {\n+pure fn map(ss: str, ff: fn(char) -> char) -> str {\n     let mut result = \"\";\n-    reserve(result, len(ss));\n-    chars_iter(ss) {|cc| str::push_char(result, ff(cc));}\n+    unchecked {\n+        reserve(result, len(ss));\n+        chars_iter(ss) {|cc|\n+            str::push_char(result, ff(cc));\n+        }\n+    }\n     result\n }\n \n #[doc = \"Iterate over the bytes in a string\"]\n-fn bytes_iter(ss: str, it: fn(u8)) {\n+pure fn bytes_iter(ss: str, it: fn(u8)) {\n     let mut pos = 0u;\n     let len = len(ss);\n \n@@ -644,7 +654,7 @@ fn bytes_iter(ss: str, it: fn(u8)) {\n \n #[doc = \"Iterate over the bytes in a string\"]\n #[inline(always)]\n-fn each(s: str, it: fn(u8) -> bool) {\n+pure fn each(s: str, it: fn(u8) -> bool) {\n     let mut i = 0u, l = len(s);\n     while (i < l) {\n         if !it(s[i]) { break; }\n@@ -654,7 +664,7 @@ fn each(s: str, it: fn(u8) -> bool) {\n \n #[doc = \"Iterates over the chars in a string\"]\n #[inline(always)]\n-fn each_char(s: str, it: fn(char) -> bool) {\n+pure fn each_char(s: str, it: fn(char) -> bool) {\n     let mut pos = 0u;\n     let len = len(s);\n     while pos < len {\n@@ -665,7 +675,7 @@ fn each_char(s: str, it: fn(char) -> bool) {\n }\n \n #[doc = \"Iterate over the characters in a string\"]\n-fn chars_iter(s: str, it: fn(char)) {\n+pure fn chars_iter(s: str, it: fn(char)) {\n     let mut pos = 0u;\n     let len = len(s);\n     while (pos < len) {\n@@ -678,25 +688,26 @@ fn chars_iter(s: str, it: fn(char)) {\n #[doc = \"\n Apply a function to each substring after splitting by character\n \"]\n-fn split_char_iter(ss: str, cc: char, ff: fn(&&str)) {\n+pure fn split_char_iter(ss: str, cc: char, ff: fn(&&str)) {\n    vec::iter(split_char(ss, cc), ff)\n }\n \n #[doc = \"\n Apply a function to each substring after splitting by character, up to\n `count` times\n \"]\n-fn splitn_char_iter(ss: str, sep: char, count: uint, ff: fn(&&str)) unsafe {\n+pure fn splitn_char_iter(ss: str, sep: char, count: uint,\n+                         ff: fn(&&str)) unsafe {\n    vec::iter(splitn_char(ss, sep, count), ff)\n }\n \n #[doc = \"Apply a function to each word\"]\n-fn words_iter(ss: str, ff: fn(&&str)) {\n+pure fn words_iter(ss: str, ff: fn(&&str)) {\n     vec::iter(words(ss), ff)\n }\n \n #[doc = \"Apply a function to each line (by '\\\\n')\"]\n-fn lines_iter(ss: str, ff: fn(&&str)) {\n+pure fn lines_iter(ss: str, ff: fn(&&str)) {\n     vec::iter(lines(ss), ff)\n }\n \n@@ -717,7 +728,7 @@ Returns the byte index of the first matching character\n An `option` containing the byte index of the first matching character\n or `none` if there is no match\n \"]\n-fn find_char(s: str, c: char) -> option<uint> {\n+pure fn find_char(s: str, c: char) -> option<uint> {\n     find_char_between(s, c, 0u, len(s))\n }\n \n@@ -741,7 +752,7 @@ or `none` if there is no match\n `start` must be less than or equal to `len(s)`. `start` must be the\n index of a character boundary, as defined by `is_char_boundary`.\n \"]\n-fn find_char_from(s: str, c: char, start: uint) -> option<uint> {\n+pure fn find_char_from(s: str, c: char, start: uint) -> option<uint> {\n     find_char_between(s, c, start, len(s))\n }\n \n@@ -766,7 +777,7 @@ or `none` if there is no match\n or equal to `len(s)`. `start` must be the index of a character boundary,\n as defined by `is_char_boundary`.\n \"]\n-fn find_char_between(s: str, c: char, start: uint, end: uint)\n+pure fn find_char_between(s: str, c: char, start: uint, end: uint)\n     -> option<uint> {\n     if c < 128u as char {\n         assert start <= end;\n@@ -796,7 +807,7 @@ Returns the byte index of the last matching character\n An `option` containing the byte index of the last matching character\n or `none` if there is no match\n \"]\n-fn rfind_char(s: str, c: char) -> option<uint> {\n+pure fn rfind_char(s: str, c: char) -> option<uint> {\n     rfind_char_between(s, c, len(s), 0u)\n }\n \n@@ -820,7 +831,7 @@ or `none` if there is no match\n `start` must be less than or equal to `len(s)`. `start` must be\n the index of a character boundary, as defined by `is_char_boundary`.\n \"]\n-fn rfind_char_from(s: str, c: char, start: uint) -> option<uint> {\n+pure fn rfind_char_from(s: str, c: char, start: uint) -> option<uint> {\n     rfind_char_between(s, c, start, 0u)\n }\n \n@@ -845,7 +856,7 @@ or `none` if there is no match\n or equal to `len(s)`. `start` must be the index of a character boundary,\n as defined by `is_char_boundary`.\n \"]\n-fn rfind_char_between(s: str, c: char, start: uint, end: uint)\n+pure fn rfind_char_between(s: str, c: char, start: uint, end: uint)\n     -> option<uint> {\n     if c < 128u as char {\n         assert start >= end;\n@@ -876,7 +887,7 @@ the given predicate\n An `option` containing the byte index of the first matching character\n or `none` if there is no match\n \"]\n-fn find(s: str, f: fn(char) -> bool) -> option<uint> {\n+pure fn find(s: str, f: fn(char) -> bool) -> option<uint> {\n     find_between(s, 0u, len(s), f)\n }\n \n@@ -900,7 +911,7 @@ or `none` if there is no match\n `start` must be less than or equal to `len(s)`. `start` must be the\n index of a character boundary, as defined by `is_char_boundary`.\n \"]\n-fn find_from(s: str, start: uint, f: fn(char) -> bool) -> option<uint> {\n+pure fn find_from(s: str, start: uint, f: fn(char) -> bool) -> option<uint> {\n     find_between(s, start, len(s), f)\n }\n \n@@ -926,7 +937,7 @@ or `none` if there is no match\n or equal to `len(s)`. `start` must be the index of a character\n boundary, as defined by `is_char_boundary`.\n \"]\n-fn find_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n+pure fn find_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n     -> option<uint> {\n     assert start <= end;\n     assert end <= len(s);\n@@ -954,7 +965,7 @@ the given predicate\n An option containing the byte index of the last matching character\n or `none` if there is no match\n \"]\n-fn rfind(s: str, f: fn(char) -> bool) -> option<uint> {\n+pure fn rfind(s: str, f: fn(char) -> bool) -> option<uint> {\n     rfind_between(s, len(s), 0u, f)\n }\n \n@@ -978,7 +989,7 @@ or `none` if there is no match\n `start` must be less than or equal to `len(s)', `start` must be the\n index of a character boundary, as defined by `is_char_boundary`\n \"]\n-fn rfind_from(s: str, start: uint, f: fn(char) -> bool) -> option<uint> {\n+pure fn rfind_from(s: str, start: uint, f: fn(char) -> bool) -> option<uint> {\n     rfind_between(s, start, 0u, f)\n }\n \n@@ -1004,7 +1015,7 @@ or `none` if there is no match\n than or equal to `len(s)`. `start` must be the index of a character\n boundary, as defined by `is_char_boundary`\n \"]\n-fn rfind_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n+pure fn rfind_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n     -> option<uint> {\n     assert start >= end;\n     assert start <= len(s);\n@@ -1019,7 +1030,7 @@ fn rfind_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n }\n \n // Utility used by various searching functions\n-fn match_at(haystack: str, needle: str, at: uint) -> bool {\n+pure fn match_at(haystack: str, needle: str, at: uint) -> bool {\n     let mut i = at;\n     for each(needle) {|c| if haystack[i] != c { ret false; } i += 1u; }\n     ret true;\n@@ -1038,7 +1049,7 @@ Returns the byte index of the first matching substring\n An `option` containing the byte index of the first matching substring\n or `none` if there is no match\n \"]\n-fn find_str(haystack: str, needle: str) -> option<uint> {\n+pure fn find_str(haystack: str, needle: str) -> option<uint> {\n     find_str_between(haystack, needle, 0u, len(haystack))\n }\n \n@@ -1061,7 +1072,7 @@ or `none` if there is no match\n \n `start` must be less than or equal to `len(s)`\n \"]\n-fn find_str_from(haystack: str, needle: str, start: uint)\n+pure fn find_str_from(haystack: str, needle: str, start: uint)\n   -> option<uint> {\n     find_str_between(haystack, needle, start, len(haystack))\n }\n@@ -1086,7 +1097,7 @@ or `none` if there is no match\n `start` must be less than or equal to `end` and `end` must be less than\n or equal to `len(s)`.\n \"]\n-fn find_str_between(haystack: str, needle: str, start: uint, end:uint)\n+pure fn find_str_between(haystack: str, needle: str, start: uint, end:uint)\n   -> option<uint> {\n     // See Issue #1932 for why this is a naive search\n     assert end <= len(haystack);\n@@ -1111,7 +1122,7 @@ Returns true if one string contains another\n * haystack - The string to look in\n * needle - The string to look for\n \"]\n-fn contains(haystack: str, needle: str) -> bool {\n+pure fn contains(haystack: str, needle: str) -> bool {\n     option::is_some(find_str(haystack, needle))\n }\n \n@@ -1123,7 +1134,7 @@ Returns true if one string starts with another\n * haystack - The string to look in\n * needle - The string to look for\n \"]\n-fn starts_with(haystack: str, needle: str) -> bool unsafe {\n+pure fn starts_with(haystack: str, needle: str) -> bool unsafe {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n@@ -1138,7 +1149,7 @@ Returns true if one string ends with another\n * haystack - The string to look in\n * needle - The string to look for\n \"]\n-fn ends_with(haystack: str, needle: str) -> bool {\n+pure fn ends_with(haystack: str, needle: str) -> bool {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n@@ -1150,7 +1161,7 @@ Section: String properties\n */\n \n #[doc = \"Determines if a string contains only ASCII characters\"]\n-fn is_ascii(s: str) -> bool {\n+pure fn is_ascii(s: str) -> bool {\n     let mut i: uint = len(s);\n     while i > 0u { i -= 1u; if !u8::is_ascii(s[i]) { ret false; } }\n     ret true;\n@@ -1167,7 +1178,7 @@ Returns true if the string contains only whitespace\n \n Whitespace characters are determined by `char::is_whitespace`\n \"]\n-fn is_whitespace(s: str) -> bool {\n+pure fn is_whitespace(s: str) -> bool {\n     ret all(s, char::is_whitespace);\n }\n \n@@ -1189,14 +1200,14 @@ pure fn len(s: str) -> uint unsafe {\n }\n \n #[doc = \"Returns the number of characters that a string holds\"]\n-fn char_len(s: str) -> uint { count_chars(s, 0u, len(s)) }\n+pure fn char_len(s: str) -> uint { count_chars(s, 0u, len(s)) }\n \n /*\n Section: Misc\n */\n \n #[doc = \"Determines if a vector of bytes contains valid UTF-8\"]\n-fn is_utf8(v: [const u8]) -> bool {\n+pure fn is_utf8(v: [const u8]) -> bool {\n     let mut i = 0u;\n     let total = vec::len::<u8>(v);\n     while i < total {\n@@ -1214,7 +1225,7 @@ fn is_utf8(v: [const u8]) -> bool {\n }\n \n #[doc = \"Determines if a vector of `u16` contains valid UTF-16\"]\n-fn is_utf16(v: [const u16]) -> bool {\n+pure fn is_utf16(v: [const u16]) -> bool {\n     let len = vec::len(v);\n     let mut i = 0u;\n     while (i < len) {\n@@ -1235,7 +1246,7 @@ fn is_utf16(v: [const u16]) -> bool {\n }\n \n #[doc = \"Converts to a vector of `u16` encoded as UTF-16\"]\n-fn to_utf16(s: str) -> [u16] {\n+pure fn to_utf16(s: str) -> [u16] {\n     let mut u = [];\n     chars_iter(s) {|cch|\n         // Arithmetic with u32 literals is easier on the eyes than chars.\n@@ -1257,7 +1268,7 @@ fn to_utf16(s: str) -> [u16] {\n     ret u;\n }\n \n-fn utf16_chars(v: [const u16], f: fn(char)) {\n+pure fn utf16_chars(v: [const u16], f: fn(char)) {\n     let len = vec::len(v);\n     let mut i = 0u;\n     while (i < len && v[i] != 0u16) {\n@@ -1282,10 +1293,12 @@ fn utf16_chars(v: [const u16], f: fn(char)) {\n }\n \n \n-fn from_utf16(v: [const u16]) -> str {\n+pure fn from_utf16(v: [const u16]) -> str {\n     let mut buf = \"\";\n-    reserve(buf, vec::len(v));\n-    utf16_chars(v) {|ch| push_char(buf, ch); }\n+    unchecked {\n+        reserve(buf, vec::len(v));\n+        utf16_chars(v) {|ch| push_char(buf, ch); }\n+    }\n     ret buf;\n }\n \n@@ -1303,7 +1316,7 @@ As char_len but for a slice of a string\n \n The number of Unicode characters in `s` between the given indices.\n \"]\n-fn count_chars(s: str, start: uint, end: uint) -> uint {\n+pure fn count_chars(s: str, start: uint, end: uint) -> uint {\n     assert is_char_boundary(s, start);\n     assert is_char_boundary(s, end);\n     let mut i = start, len = 0u;\n@@ -1318,7 +1331,7 @@ fn count_chars(s: str, start: uint, end: uint) -> uint {\n #[doc = \"\n Counts the number of bytes taken by the `n` in `s` starting from `start`.\n \"]\n-fn count_bytes(s: str, start: uint, n: uint) -> uint {\n+pure fn count_bytes(s: str, start: uint, n: uint) -> uint {\n     assert is_char_boundary(s, start);\n     let mut end = start, cnt = n;\n     let l = len(s);\n@@ -1403,7 +1416,7 @@ index of the next unicode character.\n If `i` is greater than or equal to the length of the string.\n If `i` is not the index of the beginning of a valid UTF-8 character.\n \"]\n-fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n+pure fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n     let b0 = s[i];\n     let w = utf8_char_width(b0);\n     assert (w != 0u);\n@@ -1426,14 +1439,16 @@ fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n }\n \n #[doc = \"Pluck a character out of a string\"]\n-fn char_at(s: str, i: uint) -> char { ret char_range_at(s, i).ch; }\n+pure fn char_at(s: str, i: uint) -> char { ret char_range_at(s, i).ch; }\n \n #[doc = \"\n Given a byte position and a str, return the previous char and its position\n \n This function can be used to iterate over a unicode string in reverse.\n \"]\n-fn char_range_at_reverse(ss: str, start: uint) -> {ch: char, prev: uint} {\n+pure fn char_range_at_reverse(ss: str, start: uint)\n+    -> {ch: char, prev: uint} {\n+\n     let mut prev = start;\n \n     // while there is a previous byte == 10......\n@@ -1470,7 +1485,8 @@ Loop through a substring, char by char\n `true` If execution proceeded correctly, `false` if it was interrupted,\n that is if `it` returned `false` at any point.\n \"]\n-fn all_between(s: str, start: uint, end: uint, it: fn(char) -> bool) -> bool {\n+pure fn all_between(s: str, start: uint, end: uint,\n+                    it: fn(char) -> bool) -> bool {\n     assert is_char_boundary(s, start);\n     let mut i = start;\n     while i < end {\n@@ -1502,7 +1518,8 @@ Loop through a substring, char by char\n \n `true` if `it` returns `true` for any character\n \"]\n-fn any_between(s: str, start: uint, end: uint, it: fn(char) -> bool) -> bool {\n+pure fn any_between(s: str, start: uint, end: uint,\n+                    it: fn(char) -> bool) -> bool {\n     !all_between(s, start, end, {|c| !it(c)})\n }\n \n@@ -1533,7 +1550,7 @@ interop.\n let i = str::as_bytes(\\\"Hello World\\\") { |bytes| vec::len(bytes) };\n ~~~\n \"]\n-fn as_bytes<T>(s: str, f: fn([u8]) -> T) -> T unsafe {\n+pure fn as_bytes<T>(s: str, f: fn([u8]) -> T) -> T unsafe {\n     let v: *[u8] = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n     f(*v)\n }\n@@ -1544,7 +1561,7 @@ Work with the byte buffer of a string.\n Allows for unsafe manipulation of strings, which is useful for native\n interop.\n \"]\n-fn as_buf<T>(s: str, f: fn(*u8) -> T) -> T unsafe {\n+pure fn as_buf<T>(s: str, f: fn(*u8) -> T) -> T unsafe {\n     as_bytes(s) { |v| vec::as_buf(v, f) }\n }\n \n@@ -1560,7 +1577,7 @@ interop, without copying the original string.\n let s = str::as_buf(\\\"PATH\\\", { |path_buf| libc::getenv(path_buf) });\n ~~~\n \"]\n-fn as_c_str<T>(s: str, f: fn(*libc::c_char) -> T) -> T unsafe {\n+pure fn as_c_str<T>(s: str, f: fn(*libc::c_char) -> T) -> T unsafe {\n     as_buf(s) {|buf| f(buf as *libc::c_char) }\n }\n \n@@ -1574,7 +1591,7 @@ indexable area for a null byte, as is the case in slices pointing\n to full strings, or suffixes of them.\n \"]\n #[inline(always)]\n-fn unpack_slice<T>(s: str/&, f: fn(*u8, uint) -> T) -> T unsafe {\n+pure fn unpack_slice<T>(s: str/&, f: fn(*u8, uint) -> T) -> T unsafe {\n     let v : *(*u8,uint) = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n     let (buf,len) = *v;\n     f(buf, len)\n@@ -1639,18 +1656,22 @@ pure fn capacity(&&s: str) -> uint unsafe {\n }\n \n #[doc = \"Escape each char in `s` with char::escape_default.\"]\n-fn escape_default(s: str) -> str {\n+pure fn escape_default(s: str) -> str {\n     let mut out: str = \"\";\n-    reserve_at_least(out, str::len(s));\n-    chars_iter(s) {|c| out += char::escape_default(c); }\n+    unchecked {\n+        reserve_at_least(out, str::len(s));\n+        chars_iter(s) {|c| out += char::escape_default(c); }\n+    }\n     ret out;\n }\n \n #[doc = \"Escape each char in `s` with char::escape_unicode.\"]\n-fn escape_unicode(s: str) -> str {\n+pure fn escape_unicode(s: str) -> str {\n     let mut out: str = \"\";\n-    reserve_at_least(out, str::len(s));\n-    chars_iter(s) {|c| out += char::escape_unicode(c); }\n+    unchecked {\n+        reserve_at_least(out, str::len(s));\n+        chars_iter(s) {|c| out += char::escape_unicode(c); }\n+    }\n     ret out;\n }\n "}, {"sha": "e0fd21f6c4a1d9a40ea2f6bec51c4ba1728d3246", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -17,9 +17,9 @@ enum type_desc = {\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n-    fn refcount(t: *()) -> libc::intptr_t;\n+    pure fn refcount(t: *()) -> libc::intptr_t;\n     fn unsupervise();\n-    fn shape_log_str(t: *sys::type_desc, data: *()) -> str;\n+    pure fn shape_log_str(t: *sys::type_desc, data: *()) -> str;\n }\n \n #[abi = \"rust-intrinsic\"]\n@@ -36,13 +36,13 @@ Returns a pointer to a type descriptor.\n Useful for calling certain function in the Rust runtime or otherwise\n performing dark magick.\n \"]\n-fn get_type_desc<T>() -> *type_desc {\n-    rusti::get_tydesc::<T>() as *type_desc\n+pure fn get_type_desc<T>() -> *type_desc {\n+    unchecked { rusti::get_tydesc::<T>() as *type_desc }\n }\n \n #[doc = \"Returns the size of a type\"]\n-fn size_of<T>() -> uint unsafe {\n-    rusti::size_of::<T>()\n+pure fn size_of<T>() -> uint unsafe {\n+    unchecked { rusti::size_of::<T>() }\n }\n \n #[doc = \"\n@@ -51,23 +51,23 @@ Returns the ABI-required minimum alignment of a type\n This is the alignment used for struct fields. It may be smaller\n than the preferred alignment.\n \"]\n-fn min_align_of<T>() -> uint unsafe {\n-    rusti::min_align_of::<T>()\n+pure fn min_align_of<T>() -> uint unsafe {\n+    unchecked { rusti::min_align_of::<T>() }\n }\n \n #[doc = \"Returns the preferred alignment of a type\"]\n-fn pref_align_of<T>() -> uint unsafe {\n-    rusti::pref_align_of::<T>()\n+pure fn pref_align_of<T>() -> uint unsafe {\n+    unchecked { rusti::pref_align_of::<T>() }\n }\n \n #[doc = \"Returns the refcount of a shared box\"]\n-fn refcount<T>(t: @T) -> uint {\n+pure fn refcount<T>(t: @T) -> uint {\n     unsafe {\n         ret rustrt::refcount(unsafe::reinterpret_cast(t)) as uint;\n     }\n }\n \n-fn log_str<T>(t: T) -> str {\n+pure fn log_str<T>(t: T) -> str {\n     unsafe {\n         let data_ptr: *() = unsafe::reinterpret_cast(ptr::addr_of(t));\n         rustrt::shape_log_str(get_type_desc::<T>(), data_ptr)"}, {"sha": "7126fb3d007d335f57ae7b124052eec47c6cbb10", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -1,4 +1,5 @@\n import T = inst::T;\n+import cmp::{eq, ord};\n \n export min_value, max_value;\n export min, max;\n@@ -10,6 +11,7 @@ export range;\n export compl;\n export to_str, to_str_bytes;\n export from_str, from_str_radix, str, parse_buf;\n+export ord, eq;\n \n const min_value: T = 0 as T;\n const max_value: T = 0 as T - 1 as T;\n@@ -49,6 +51,18 @@ pure fn compl(i: T) -> T {\n     max_value ^ i\n }\n \n+impl ord of ord for T {\n+    fn lt(&&other: T) -> bool {\n+        ret self < other;\n+    }\n+}\n+\n+impl eq of eq for T {\n+    fn eq(&&other: T) -> bool {\n+        ret self == other;\n+    }\n+}\n+\n #[doc = \"\n Parse a buffer of bytes\n "}, {"sha": "4cfcd6b7517e90a7e0dc5e46e127754108fe441b", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -211,18 +211,18 @@ fn from_mut<T>(+v: [mut T]) -> [T] unsafe {\n pure fn head<T: copy>(v: [const T]/&) -> T { v[0] }\n \n #[doc = \"Returns a vector containing all but the first element of a slice\"]\n-fn tail<T: copy>(v: [const T]/&) -> [T] {\n+pure fn tail<T: copy>(v: [const T]/&) -> [T] {\n     ret slice(v, 1u, len(v));\n }\n \n #[doc = \"Returns a vector containing all but the first `n` \\\n          elements of a slice\"]\n-fn tailn<T: copy>(v: [const T]/&, n: uint) -> [T] {\n+pure fn tailn<T: copy>(v: [const T]/&, n: uint) -> [T] {\n     slice(v, n, len(v))\n }\n \n #[doc = \"Returns a vector containing all but the last element of a slice\"]\n-fn init<T: copy>(v: [const T]/&) -> [T] {\n+pure fn init<T: copy>(v: [const T]/&) -> [T] {\n     assert len(v) != 0u;\n     slice(v, 0u, len(v) - 1u)\n }\n@@ -798,7 +798,7 @@ Swaps two elements in a vector\n * a - The index of the first element\n * b - The index of the second element\n \"]\n-fn swap<T>(v: [mut T], a: uint, b: uint) {\n+fn swap<T>(&&v: [mut T], a: uint, b: uint) {\n     v[a] <-> v[b];\n }\n \n@@ -1033,10 +1033,10 @@ pure fn unpack_mut_slice<T,U>(s: [mut T]/&,\n impl extensions/&<T> for [const T]/& {\n     #[doc = \"Returns true if a vector contains no elements\"]\n     #[inline]\n-    fn is_empty() -> bool { is_empty(self) }\n+    pure fn is_empty() -> bool { is_empty(self) }\n     #[doc = \"Returns true if a vector contains some elements\"]\n     #[inline]\n-    fn is_not_empty() -> bool { is_not_empty(self) }\n+    pure fn is_not_empty() -> bool { is_not_empty(self) }\n     #[doc = \"Returns the length of a vector\"]\n     #[inline]\n     pure fn len() -> uint { len(self) }\n@@ -1046,44 +1046,44 @@ impl extensions/&<T> for [const T]/& {\n impl extensions/&<T: copy> for [const T]/& {\n     #[doc = \"Returns the first element of a vector\"]\n     #[inline]\n-    fn head() -> T { head(self) }\n+    pure fn head() -> T { head(self) }\n     #[doc = \"Returns all but the last elemnt of a vector\"]\n     #[inline]\n-    fn init() -> [T] { init(self) }\n+    pure fn init() -> [T] { init(self) }\n     #[doc = \"\n     Returns the last element of a `v`, failing if the vector is empty.\n     \"]\n     #[inline]\n-    fn last() -> T { last(self) }\n+    pure fn last() -> T { last(self) }\n     #[doc = \"Returns a copy of the elements from [`start`..`end`) from `v`.\"]\n     #[inline]\n-    fn slice(start: uint, end: uint) -> [T] { slice(self, start, end) }\n+    pure fn slice(start: uint, end: uint) -> [T] { slice(self, start, end) }\n     #[doc = \"Returns all but the first element of a vector\"]\n     #[inline]\n-    fn tail() -> [T] { tail(self) }\n+    pure fn tail() -> [T] { tail(self) }\n }\n \n #[doc = \"Extension methods for vectors\"]\n impl extensions/&<T> for [T]/& {\n     #[doc = \"Reduce a vector from right to left\"]\n     #[inline]\n-    fn foldr<U: copy>(z: U, p: fn(T, U) -> U) -> U { foldr(self, z, p) }\n+    pure fn foldr<U: copy>(z: U, p: fn(T, U) -> U) -> U { foldr(self, z, p) }\n     #[doc = \"\n     Iterates over a vector\n \n     Iterates over vector `v` and, for each element, calls function `f` with\n     the element's value.\n     \"]\n     #[inline]\n-    fn iter(f: fn(T)) { iter(self, f) }\n+    pure fn iter(f: fn(T)) { iter(self, f) }\n     #[doc = \"\n     Iterates over a vector's elements and indexes\n \n     Iterates over vector `v` and, for each element, calls function `f` with\n     the element's value and index.\n     \"]\n     #[inline]\n-    fn iteri(f: fn(uint, T)) { iteri(self, f) }\n+    pure fn iteri(f: fn(uint, T)) { iteri(self, f) }\n     #[doc = \"\n     Find the first index matching some predicate\n \n@@ -1092,26 +1092,26 @@ impl extensions/&<T> for [T]/& {\n     elements then none is returned.\n     \"]\n     #[inline]\n-    fn position(f: fn(T) -> bool) -> option<uint> { position(self, f) }\n+    pure fn position(f: fn(T) -> bool) -> option<uint> { position(self, f) }\n     #[doc = \"Find the first index containing a matching value\"]\n     #[inline]\n-    fn position_elem(x: T) -> option<uint> { position_elem(self, x) }\n+    pure fn position_elem(x: T) -> option<uint> { position_elem(self, x) }\n     #[doc = \"\n     Iterates over a vector in reverse\n \n     Iterates over vector `v` and, for each element, calls function `f` with\n     the element's value.\n     \"]\n     #[inline]\n-    fn riter(f: fn(T)) { riter(self, f) }\n+    pure fn riter(f: fn(T)) { riter(self, f) }\n     #[doc =\"\n     Iterates over a vector's elements and indexes in reverse\n \n     Iterates over vector `v` and, for each element, calls function `f` with\n     the element's value and index.\n     \"]\n     #[inline]\n-    fn riteri(f: fn(uint, T)) { riteri(self, f) }\n+    pure fn riteri(f: fn(uint, T)) { riteri(self, f) }\n     #[doc = \"\n     Find the last index matching some predicate\n \n@@ -1120,20 +1120,20 @@ impl extensions/&<T> for [T]/& {\n     matches no elements then none is returned.\n     \"]\n     #[inline]\n-    fn rposition(f: fn(T) -> bool) -> option<uint> { rposition(self, f) }\n+    pure fn rposition(f: fn(T) -> bool) -> option<uint> { rposition(self, f) }\n     #[doc = \"Find the last index containing a matching value\"]\n     #[inline]\n-    fn rposition_elem(x: T) -> option<uint> { rposition_elem(self, x) }\n+    pure fn rposition_elem(x: T) -> option<uint> { rposition_elem(self, x) }\n     #[doc = \"\n     Apply a function to each element of a vector and return the results\n     \"]\n     #[inline]\n-    fn map<U>(f: fn(T) -> U) -> [U] { map(self, f) }\n+    pure fn map<U>(f: fn(T) -> U) -> [U] { map(self, f) }\n     #[doc = \"\n     Apply a function to the index and value of each element in the vector\n     and return the results\n     \"]\n-    fn mapi<U>(f: fn(uint, T) -> U) -> [U] {\n+    pure fn mapi<U>(f: fn(uint, T) -> U) -> [U] {\n         mapi(self, f)\n     }\n     #[doc = \"Returns true if the function returns true for all elements.\n@@ -1147,15 +1147,15 @@ impl extensions/&<T> for [T]/& {\n     of each result vector\n     \"]\n     #[inline]\n-    fn flat_map<U>(f: fn(T) -> [U]) -> [U] { flat_map(self, f) }\n+    pure fn flat_map<U>(f: fn(T) -> [U]) -> [U] { flat_map(self, f) }\n     #[doc = \"\n     Apply a function to each element of a vector and return the results\n \n     If function `f` returns `none` then that element is excluded from\n     the resulting vector.\n     \"]\n     #[inline]\n-    fn filter_map<U: copy>(f: fn(T) -> option<U>) -> [U] {\n+    pure fn filter_map<U: copy>(f: fn(T) -> option<U>) -> [U] {\n         filter_map(self, f)\n     }\n }\n@@ -1170,7 +1170,7 @@ impl extensions/&<T: copy> for [T]/& {\n     only those elements for which `f` returned true.\n     \"]\n     #[inline]\n-    fn filter(f: fn(T) -> bool) -> [T] { filter(self, f) }\n+    pure fn filter(f: fn(T) -> bool) -> [T] { filter(self, f) }\n     #[doc = \"\n     Search for the first element that matches a given predicate\n \n@@ -1179,7 +1179,7 @@ impl extensions/&<T: copy> for [T]/& {\n     is returned. If `f` matches no elements then none is returned.\n     \"]\n     #[inline]\n-    fn find(f: fn(T) -> bool) -> option<T> { find(self, f) }\n+    pure fn find(f: fn(T) -> bool) -> option<T> { find(self, f) }\n     #[doc = \"\n     Search for the last element that matches a given predicate\n \n@@ -1188,7 +1188,7 @@ impl extensions/&<T: copy> for [T]/& {\n     matches no elements then none is returned.\n     \"]\n     #[inline]\n-    fn rfind(f: fn(T) -> bool) -> option<T> { rfind(self, f) }\n+    pure fn rfind(f: fn(T) -> bool) -> option<T> { rfind(self, f) }\n }\n \n #[doc = \"Unsafe operations\"]\n@@ -1221,12 +1221,12 @@ mod unsafe {\n     #[doc = \"\n     Sets the length of a vector\n \n-    This well explicitly set the size of the vector, without actually\n+    This will explicitly set the size of the vector, without actually\n     modifing its buffers, so it is up to the caller to ensure that\n     the vector is actually the specified size.\n     \"]\n     #[inline(always)]\n-    unsafe fn set_len<T>(&v: [const T], new_len: uint) {\n+    unsafe fn set_len<T>(&&v: [const T], new_len: uint) {\n         let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n         (**repr).fill = new_len * sys::size_of::<T>();\n     }"}, {"sha": "3445d7399afa8cadd23e3a476567505b70245dd2", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -24,9 +24,7 @@ type arc_data<T: const> = {\n resource arc_destruct<T: const>(data: *libc::c_void) {\n     unsafe {\n         let data: ~arc_data<T> = unsafe::reinterpret_cast(data);\n-        let ref_ptr = &mut data.count;\n-\n-        let new_count = rustrt::rust_atomic_decrement(ref_ptr);\n+        let new_count = rustrt::rust_atomic_decrement(&mut data.count);\n         assert new_count >= 0;\n         if new_count == 0 {\n             // drop glue takes over."}, {"sha": "4cef3245661840bc7fc8c7bba165d5e9fdf8636a", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -1,6 +1,7 @@\n #[doc = \"A deque. Untested as of yet. Likely buggy\"];\n \n import option::{some, none};\n+import dvec::{dvec, extensions};\n \n iface t<T> {\n     fn size() -> uint;\n@@ -23,7 +24,7 @@ fn create<T: copy>() -> t<T> {\n       * Grow is only called on full elts, so nelts is also len(elts), unlike\n       * elsewhere.\n       */\n-    fn grow<T: copy>(nelts: uint, lo: uint, elts: [mut cell<T>]) ->\n+    fn grow<T: copy>(nelts: uint, lo: uint, -elts: [mut cell<T>]) ->\n        [mut cell<T>] {\n         assert (nelts == vec::len(elts));\n         let mut rv = [mut];\n@@ -39,38 +40,38 @@ fn create<T: copy>() -> t<T> {\n \n         ret rv;\n     }\n-    fn get<T: copy>(elts: [mut cell<T>], i: uint) -> T {\n-        ret alt elts[i] { some(t) { t } _ { fail } };\n+    fn get<T: copy>(elts: dvec<cell<T>>, i: uint) -> T {\n+        alt elts.get_elt(i) { some(t) { t } _ { fail } }\n     }\n \n     type repr<T> = {mut nelts: uint,\n                     mut lo: uint,\n                     mut hi: uint,\n-                    mut elts: [mut cell<T>]};\n+                    elts: dvec<cell<T>>};\n \n     impl <T: copy> of t<T> for repr<T> {\n         fn size() -> uint { ret self.nelts; }\n         fn add_front(t: T) {\n             let oldlo: uint = self.lo;\n             if self.lo == 0u {\n-                self.lo = vec::len(self.elts) - 1u;\n+                self.lo = self.elts.len() - 1u;\n             } else { self.lo -= 1u; }\n             if self.lo == self.hi {\n-                self.elts = grow(self.nelts, oldlo, self.elts);\n-                self.lo = vec::len(self.elts) - 1u;\n+                self.elts.swap({ |v| grow(self.nelts, oldlo, v) });\n+                self.lo = self.elts.len() - 1u;\n                 self.hi = self.nelts;\n             }\n-            self.elts[self.lo] = some(t);\n+            self.elts.set_elt(self.lo, some(t));\n             self.nelts += 1u;\n         }\n         fn add_back(t: T) {\n             if self.lo == self.hi && self.nelts != 0u {\n-                self.elts = grow(self.nelts, self.lo, self.elts);\n+                self.elts.swap({ |v| grow(self.nelts, self.lo, v) });\n                 self.lo = 0u;\n                 self.hi = self.nelts;\n             }\n-            self.elts[self.hi] = some(t);\n-            self.hi = (self.hi + 1u) % vec::len(self.elts);\n+            self.elts.set_elt(self.hi, some(t));\n+            self.hi = (self.hi + 1u) % self.elts.len();\n             self.nelts += 1u;\n         }\n         /**\n@@ -79,24 +80,24 @@ fn create<T: copy>() -> t<T> {\n          */\n         fn pop_front() -> T {\n             let t: T = get(self.elts, self.lo);\n-            self.elts[self.lo] = none;\n-            self.lo = (self.lo + 1u) % vec::len(self.elts);\n+            self.elts.set_elt(self.lo, none);\n+            self.lo = (self.lo + 1u) % self.elts.len();\n             self.nelts -= 1u;\n             ret t;\n         }\n         fn pop_back() -> T {\n             if self.hi == 0u {\n-                self.hi = vec::len(self.elts) - 1u;\n+                self.hi = self.elts.len() - 1u;\n             } else { self.hi -= 1u; }\n             let t: T = get(self.elts, self.hi);\n-            self.elts[self.hi] = none;\n+            self.elts.set_elt(self.hi, none);\n             self.nelts -= 1u;\n             ret t;\n         }\n         fn peek_front() -> T { ret get(self.elts, self.lo); }\n         fn peek_back() -> T { ret get(self.elts, self.hi - 1u); }\n         fn get(i: int) -> T {\n-            let idx = (self.lo + (i as uint)) % vec::len(self.elts);\n+            let idx = (self.lo + (i as uint)) % self.elts.len();\n             ret get(self.elts, idx);\n         }\n     }\n@@ -105,7 +106,10 @@ fn create<T: copy>() -> t<T> {\n         mut nelts: 0u,\n         mut lo: 0u,\n         mut hi: 0u,\n-        mut elts: vec::to_mut(vec::from_elem(initial_capacity, none))\n+        elts:\n+            dvec::from_vec(\n+                vec::to_mut(\n+                    vec::from_elem(initial_capacity, none)))\n     };\n     repr as t::<T>\n }"}, {"sha": "76c71d7ed2aa24d3b144b988dc637c4928332b65", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -1,5 +1,6 @@\n #[doc = \"Sorting methods\"];\n import vec::len;\n+import int::{eq, ord};\n \n export le;\n export merge_sort;\n@@ -141,7 +142,6 @@ fn qsort3<T: copy>(compare_func_lt: le<T>, compare_func_eq: le<T>,\n     qsort3::<T>(compare_func_lt, compare_func_eq, arr, i, right);\n }\n \n-// FIXME: This should take lt and eq types (#2348)\n #[doc = \"\n Fancy quicksort. Sorts a mut vector in place.\n \n@@ -152,22 +152,17 @@ According to these slides this is the algorithm of choice for\n \n This is an unstable sort.\n \"]\n-fn quick_sort3<T: copy>(compare_func_lt: le<T>, compare_func_eq: le<T>,\n-                       arr: [mut T]) {\n+fn quick_sort3<T: copy ord eq>(arr: [mut T]) {\n     if len::<T>(arr) == 0u { ret; }\n-    qsort3::<T>(compare_func_lt, compare_func_eq, arr, 0,\n+    qsort3::<T>({ |x, y| x.lt(y) }, { |x, y| x.eq(y) }, arr, 0,\n                 (len::<T>(arr) as int) - 1);\n }\n \n #[cfg(test)]\n mod test_qsort3 {\n     fn check_sort(v1: [mut int], v2: [mut int]) {\n         let len = vec::len::<int>(v1);\n-        fn lt(&&a: int, &&b: int) -> bool { ret a < b; }\n-        fn equal(&&a: int, &&b: int) -> bool { ret a == b; }\n-        let f1 = lt;\n-        let f2 = equal;\n-        quick_sort3::<int>(f1, f2, v1);\n+        quick_sort3::<int>(v1);\n         let mut i = 0u;\n         while i < len {\n             log(debug, v2[i]);"}, {"sha": "ab458931b0c0686b12a43c3edbd1387d6ff344bc", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -313,7 +313,7 @@ enum expr_ {\n     expr_fn(proto, fn_decl, blk, capture_clause),\n     expr_fn_block(fn_decl, blk, capture_clause),\n     // Inner expr is always an expr_fn_block. We need the wrapping node to\n-    // sanely type this (a function returning nil on the inside but bool on\n+    // easily type this (a function returning nil on the inside but bool on\n     // the outside).\n     expr_loop_body(@expr),\n     expr_block(blk),"}, {"sha": "cc4593d4af864528b14a34134a4d5e3113a9b830", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -21,17 +21,17 @@ pure fn mk_sp(lo: uint, hi: uint) -> span {\n // make this a const, once the compiler supports it\n pure fn dummy_sp() -> span { ret mk_sp(0u, 0u); }\n \n-fn path_name(p: @path) -> str { path_name_i(p.idents) }\n+pure fn path_name(p: @path) -> str { path_name_i(p.idents) }\n \n-fn path_name_i(idents: [ident]) -> str { str::connect(idents, \"::\") }\n+pure fn path_name_i(idents: [ident]) -> str { str::connect(idents, \"::\") }\n \n-fn path_to_ident(p: @path) -> ident { vec::last(p.idents) }\n+pure fn path_to_ident(p: @path) -> ident { vec::last(p.idents) }\n \n-fn local_def(id: node_id) -> def_id { {crate: local_crate, node: id} }\n+pure fn local_def(id: node_id) -> def_id { {crate: local_crate, node: id} }\n \n pure fn is_local(did: ast::def_id) -> bool { did.crate == local_crate }\n \n-fn stmt_id(s: stmt) -> node_id {\n+pure fn stmt_id(s: stmt) -> node_id {\n     alt s.node {\n       stmt_decl(_, id) { id }\n       stmt_expr(_, id) { id }\n@@ -45,7 +45,7 @@ fn variant_def_ids(d: def) -> {enm: def_id, var: def_id} {\n         _ { fail \"non-variant in variant_def_ids\"; } }\n }\n \n-fn def_id_of_def(d: def) -> def_id {\n+pure fn def_id_of_def(d: def) -> def_id {\n     alt d {\n       def_fn(id, _) | def_mod(id) |\n       def_native_mod(id) | def_const(id) |\n@@ -60,7 +60,7 @@ fn def_id_of_def(d: def) -> def_id {\n     }\n }\n \n-fn binop_to_str(op: binop) -> str {\n+pure fn binop_to_str(op: binop) -> str {\n     alt op {\n       add { ret \"+\"; }\n       subtract { ret \"-\"; }\n@@ -95,7 +95,7 @@ pure fn is_shift_binop(b: binop) -> bool {\n     }\n }\n \n-fn unop_to_str(op: unop) -> str {\n+pure fn unop_to_str(op: unop) -> str {\n     alt op {\n       box(mt) { if mt == m_mutbl { ret \"@mut \"; } ret \"@\"; }\n       uniq(mt) { if mt == m_mutbl { ret \"~mut \"; } ret \"~\"; }\n@@ -105,19 +105,19 @@ fn unop_to_str(op: unop) -> str {\n     }\n }\n \n-fn is_path(e: @expr) -> bool {\n+pure fn is_path(e: @expr) -> bool {\n     ret alt e.node { expr_path(_) { true } _ { false } };\n }\n \n-fn int_ty_to_str(t: int_ty) -> str {\n+pure fn int_ty_to_str(t: int_ty) -> str {\n     alt t {\n       ty_char { \"u8\" } // ???\n       ty_i { \"\" } ty_i8 { \"i8\" } ty_i16 { \"i16\" }\n       ty_i32 { \"i32\" } ty_i64 { \"i64\" }\n     }\n }\n \n-fn int_ty_max(t: int_ty) -> u64 {\n+pure fn int_ty_max(t: int_ty) -> u64 {\n     alt t {\n       ty_i8 { 0x80u64 }\n       ty_i16 { 0x8000u64 }\n@@ -126,14 +126,14 @@ fn int_ty_max(t: int_ty) -> u64 {\n     }\n }\n \n-fn uint_ty_to_str(t: uint_ty) -> str {\n+pure fn uint_ty_to_str(t: uint_ty) -> str {\n     alt t {\n       ty_u { \"u\" } ty_u8 { \"u8\" } ty_u16 { \"u16\" }\n       ty_u32 { \"u32\" } ty_u64 { \"u64\" }\n     }\n }\n \n-fn uint_ty_max(t: uint_ty) -> u64 {\n+pure fn uint_ty_max(t: uint_ty) -> u64 {\n     alt t {\n       ty_u8 { 0xffu64 }\n       ty_u16 { 0xffffu64 }\n@@ -142,7 +142,7 @@ fn uint_ty_max(t: uint_ty) -> u64 {\n     }\n }\n \n-fn float_ty_to_str(t: float_ty) -> str {\n+pure fn float_ty_to_str(t: float_ty) -> str {\n     alt t { ty_f { \"\" } ty_f32 { \"f32\" } ty_f64 { \"f64\" } }\n }\n "}, {"sha": "0fa419cd4a96a6db60adac99ee9825b9141d604b", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -77,7 +77,7 @@ fn next_line(file: filemap, chpos: uint, byte_pos: uint) {\n     file.lines += [{ch: chpos, byte: byte_pos + file.start_pos.byte}];\n }\n \n-type lookup_fn = fn@(file_pos) -> uint;\n+type lookup_fn = pure fn(file_pos) -> uint;\n \n fn lookup_line(map: codemap, pos: uint, lookup: lookup_fn)\n     -> {fm: filemap, line: uint}\n@@ -108,12 +108,12 @@ fn lookup_pos(map: codemap, pos: uint, lookup: lookup_fn) -> loc {\n }\n \n fn lookup_char_pos(map: codemap, pos: uint) -> loc {\n-    fn lookup(pos: file_pos) -> uint { ret pos.ch; }\n+    pure fn lookup(pos: file_pos) -> uint { ret pos.ch; }\n     ret lookup_pos(map, pos, lookup);\n }\n \n fn lookup_byte_pos(map: codemap, pos: uint) -> loc {\n-    fn lookup(pos: file_pos) -> uint { ret pos.byte; }\n+    pure fn lookup(pos: file_pos) -> uint { ret pos.byte; }\n     ret lookup_pos(map, pos, lookup);\n }\n \n@@ -139,7 +139,7 @@ fn lookup_char_pos_adj(map: codemap, pos: uint)\n }\n \n fn adjust_span(map: codemap, sp: span) -> span {\n-    fn lookup(pos: file_pos) -> uint { ret pos.ch; }\n+    pure fn lookup(pos: file_pos) -> uint { ret pos.ch; }\n     let line = lookup_line(map, sp.lo, lookup);\n     alt (line.fm.substr) {\n       fss_none {sp}\n@@ -198,7 +198,8 @@ fn get_line(fm: filemap, line: int) -> str unsafe {\n \n fn lookup_byte_offset(cm: codemap::codemap, chpos: uint)\n     -> {fm: filemap, pos: uint} {\n-    let {fm, line} = lookup_line(cm, chpos, {|pos| pos.ch});\n+    pure fn lookup(pos: file_pos) -> uint { ret pos.ch; }\n+    let {fm, line} = lookup_line(cm, chpos, lookup);\n     let line_offset = fm.lines[line].byte - fm.start_pos.byte;\n     let col = chpos - fm.lines[line].ch;\n     let col_offset = str::count_bytes(*fm.src, line_offset, col);"}, {"sha": "f58333c5599be338335a687e592651775bc39a4a", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -86,11 +86,14 @@ impl codemap_handler of handler for handler_t {\n     }\n     fn has_errors() -> bool { self.err_count > 0u }\n     fn abort_if_errors() {\n-        if self.err_count > 0u {\n-            let s = #fmt[\"aborting due to %u previous errors\",\n-                         self.err_count];\n-            self.fatal(s);\n+        let s;\n+        alt self.err_count {\n+          0u { ret; }\n+          1u { s = \"aborting due to previous error\"; }\n+          _  { s = #fmt[\"aborting due to %u previous errors\",\n+                        self.err_count]; }\n         }\n+        self.fatal(s);\n     }\n     fn warn(msg: str) {\n         self.emit(none, msg, warning);"}, {"sha": "1a7ae69e79df4c314e1b5fa09e9fe11a875a2502", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -212,7 +212,7 @@ fn finish<T: qq_helper>\n             state = skip(str::char_len(repl));\n             str2 += repl;\n         }\n-        alt state {\n+        alt copy state {\n           active {str::push_char(str2, ch);}\n           skip(1u) {state = blank;}\n           skip(sk) {state = skip (sk-1u);}"}, {"sha": "764c484c8e39bd243978999e55deef2d8b4cf4eb", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -1,5 +1,6 @@\n import codemap::span;\n import std::map::{hashmap, str_hash};\n+import dvec::{dvec, extensions};\n \n import base::*;\n \n@@ -134,7 +135,7 @@ fn compose_sels(s1: selector, s2: selector) -> selector {\n \n type binders =\n     {real_binders: hashmap<ident, selector>,\n-     mut literal_ast_matchers: [selector]};\n+     literal_ast_matchers: dvec<selector>};\n type bindings = hashmap<ident, arb_depth<matchable>>;\n \n fn acumm_bindings(_cx: ext_ctxt, _b_dest: bindings, _b_src: bindings) { }\n@@ -146,7 +147,7 @@ fn acumm_bindings(_cx: ext_ctxt, _b_dest: bindings, _b_src: bindings) { }\n fn pattern_to_selectors(cx: ext_ctxt, e: @expr) -> binders {\n     let res: binders =\n         {real_binders: str_hash::<selector>(),\n-         mut literal_ast_matchers: []};\n+         literal_ast_matchers: dvec()};\n     //this oughta return binders instead, but macro args are a sequence of\n     //expressions, rather than a single expression\n     fn trivial_selector(m: matchable) -> match_result { ret some(leaf(m)); }\n@@ -474,7 +475,7 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n                       _ { cx.bug(\"broken traversal in p_t_s_r\") }\n                     }\n             }\n-            b.literal_ast_matchers += [bind select(cx, _, e)];\n+            b.literal_ast_matchers.push(bind select(cx, _, e));\n           }\n         }\n       }\n@@ -640,8 +641,8 @@ fn p_t_s_r_length(cx: ext_ctxt, len: uint, at_least: bool, s: selector,\n               _ { none }\n             }\n     }\n-    b.literal_ast_matchers +=\n-        [compose_sels(s, bind len_select(cx, _, at_least, len))];\n+    b.literal_ast_matchers.push(\n+        compose_sels(s, bind len_select(cx, _, at_least, len)));\n }\n \n fn p_t_s_r_actual_vector(cx: ext_ctxt, elts: [@expr], _repeat_after: bool,"}, {"sha": "35afb79ce63f0aaebb0af9c14b74108d8ee58562", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -18,7 +18,7 @@ fn seq_sep_none() -> seq_sep {\n }\n \n \n-fn token_to_str(reader: reader, token: token::token) -> str {\n+fn token_to_str(reader: reader, ++token: token::token) -> str {\n     token::to_str(*reader.interner, token)\n }\n \n@@ -27,8 +27,9 @@ fn token_to_str(reader: reader, token: token::token) -> str {\n impl parser_common for parser {\n \n     fn unexpected_last(t: token::token) -> ! {\n-        self.span_fatal(self.last_span, \"unexpected token: '\"\n-                        + token_to_str(self.reader, t) + \"'\");\n+        self.span_fatal(\n+            copy self.last_span,\n+            \"unexpected token: '\" + token_to_str(self.reader, t) + \"'\");\n     }\n \n     fn unexpected() -> ! {\n@@ -49,7 +50,7 @@ impl parser_common for parser {\n     }\n \n     fn parse_ident() -> ast::ident {\n-        alt self.token {\n+        alt copy self.token {\n           token::IDENT(i, _) { self.bump(); ret self.get_str(i); }\n           _ { self.fatal(\"expecting ident, found \"\n                       + token_to_str(self.reader, self.token)); }\n@@ -79,7 +80,7 @@ impl parser_common for parser {\n         }\n     }\n \n-    fn token_is_keyword(word: str, tok: token::token) -> bool {\n+    fn token_is_keyword(word: str, ++tok: token::token) -> bool {\n         self.require_keyword(word);\n         alt tok {\n           token::IDENT(sid, false) { str::eq(word, self.get_str(sid)) }\n@@ -93,8 +94,11 @@ impl parser_common for parser {\n \n     fn eat_keyword(word: str) -> bool {\n         self.require_keyword(word);\n-        alt self.token {\n-          token::IDENT(sid, false) {\n+\n+        // FIXME: this gratuitous use of @ is to\n+        // workaround LLVM bug #13042\n+        alt @self.token {\n+          @token::IDENT(sid, false) {\n             if str::eq(word, self.get_str(sid)) {\n                 self.bump();\n                 ret true;"}, {"sha": "33e7d082bfb0b4f66dbec338e5342b73b7759dfd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -121,16 +121,16 @@ class parser {\n         ret self.buffer[distance - 1u].tok;\n     }\n     fn fatal(m: str) -> ! {\n-        self.sess.span_diagnostic.span_fatal(self.span, m)\n+        self.sess.span_diagnostic.span_fatal(copy self.span, m)\n     }\n     fn span_fatal(sp: span, m: str) -> ! {\n         self.sess.span_diagnostic.span_fatal(sp, m)\n     }\n     fn bug(m: str) -> ! {\n-        self.sess.span_diagnostic.span_bug(self.span, m)\n+        self.sess.span_diagnostic.span_bug(copy self.span, m)\n     }\n     fn warn(m: str) {\n-        self.sess.span_diagnostic.span_warn(self.span, m)\n+        self.sess.span_diagnostic.span_warn(copy self.span, m)\n     }\n     fn get_str(i: token::str_num) -> str {\n         interner::get(*self.reader.interner, i)\n@@ -307,7 +307,7 @@ class parser {\n     // Parses something like \"&x\"\n     fn parse_region() -> @region {\n         self.expect(token::BINOP(token::AND));\n-        alt self.token {\n+        alt copy self.token {\n           token::IDENT(sid, _) {\n             self.bump();\n             let n = self.get_str(sid);\n@@ -322,7 +322,7 @@ class parser {\n     // Parses something like \"&x.\" (note the trailing dot)\n     fn parse_region_dot() -> @region {\n         let name =\n-            alt self.token {\n+            alt copy self.token {\n               token::IDENT(sid, _) if self.look_ahead(1u) == token::DOT {\n                 self.bump(); self.bump();\n                 some(self.get_str(sid))\n@@ -483,11 +483,11 @@ class parser {\n     }\n \n     fn maybe_parse_dollar_mac() -> option<mac_> {\n-        alt self.token {\n+        alt copy self.token {\n           token::DOLLAR {\n             let lo = self.span.lo;\n             self.bump();\n-            alt self.token {\n+            alt copy self.token {\n               token::LIT_INT(num, ty_i) {\n                 self.bump();\n                 some(mac_var(num as uint))\n@@ -511,7 +511,7 @@ class parser {\n     fn maybe_parse_vstore() -> option<vstore> {\n         if self.token == token::BINOP(token::SLASH) {\n             self.bump();\n-            alt self.token {\n+            alt copy self.token {\n               token::AT {\n                 self.bump(); some(vstore_box)\n               }\n@@ -968,7 +968,7 @@ class parser {\n         loop {\n             // expr.f\n             if self.eat(token::DOT) {\n-                alt self.token {\n+                alt copy self.token {\n                   token::IDENT(i, _) {\n                     hi = self.span.hi;\n                     self.bump();\n@@ -986,7 +986,7 @@ class parser {\n                 cont;\n             }\n             if self.expr_is_complete(e) { break; }\n-            alt self.token {\n+            alt copy self.token {\n               // expr(...)\n               token::LPAREN if self.permits_call() {\n                 let es_opt = self.parse_seq(token::LPAREN, token::RPAREN,\n@@ -1042,7 +1042,7 @@ class parser {\n         let mut hi;\n \n         let mut ex;\n-        alt self.token {\n+        alt copy self.token {\n           token::NOT {\n             self.bump();\n             let e = self.to_expr(self.parse_prefix_expr());\n@@ -1134,7 +1134,7 @@ class parser {\n     fn parse_assign_expr() -> @expr {\n         let lo = self.span.lo;\n         let lhs = self.parse_binops();\n-        alt self.token {\n+        alt copy self.token {\n           token::EQ {\n             self.bump();\n             let rhs = self.parse_expr();\n@@ -1831,7 +1831,7 @@ class parser {\n     }\n \n     fn parse_method_name() -> ident {\n-        alt self.token {\n+        alt copy self.token {\n           token::BINOP(op) { self.bump(); token::binop_to_str(op) }\n           token::NOT { self.bump(); \"!\" }\n           token::LBRACKET { self.bump(); self.expect(token::RBRACKET); \"[]\" }\n@@ -2375,7 +2375,7 @@ class parser {\n             while self.token == token::MOD_SEP {\n                 self.bump();\n \n-                alt self.token {\n+                alt copy self.token {\n \n                   token::IDENT(i, _) {\n                     self.bump();\n@@ -2477,7 +2477,7 @@ class parser {\n     }\n \n     fn parse_str() -> str {\n-        alt self.token {\n+        alt copy self.token {\n           token::LIT_STR(s) { self.bump(); self.get_str(s) }\n           _ {\n             self.fatal(\"expected string literal\")"}, {"sha": "bbbd09632ef86f86e2f379a3316f00edfb4f3008", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -184,16 +184,16 @@ fn is_lit(t: token::token) -> bool {\n         }\n }\n \n-fn is_ident(t: token::token) -> bool {\n+pure fn is_ident(t: token::token) -> bool {\n     alt t { token::IDENT(_, _) { ret true; } _ { } }\n     ret false;\n }\n \n-fn is_plain_ident(t: token::token) -> bool {\n+pure fn is_plain_ident(t: token::token) -> bool {\n     ret alt t { token::IDENT(_, false) { true } _ { false } };\n }\n \n-fn is_bar(t: token::token) -> bool {\n+pure fn is_bar(t: token::token) -> bool {\n     alt t { token::BINOP(token::OR) | token::OROR { true } _ { false } }\n }\n "}, {"sha": "329dff0c4c1b14fe99e601c9ff4dc266265b9275", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -59,11 +59,11 @@ type break_t = {offset: int, blank_space: int};\n \n type begin_t = {offset: int, breaks: breaks};\n \n-enum token { STRING(str, int), BREAK(break_t), BEGIN(begin_t), END, EOF, }\n+enum token { STRING(@str, int), BREAK(break_t), BEGIN(begin_t), END, EOF, }\n \n-fn tok_str(t: token) -> str {\n+fn tok_str(++t: token) -> str {\n     alt t {\n-      STRING(s, len) { ret #fmt[\"STR(%s,%d)\", s, len]; }\n+      STRING(s, len) { ret #fmt[\"STR(%s,%d)\", *s, len]; }\n       BREAK(_) { ret \"BREAK\"; }\n       BEGIN(_) { ret \"BEGIN\"; }\n       END { ret \"END\"; }\n@@ -109,8 +109,8 @@ fn mk_printer(out: io::writer, linewidth: uint) -> printer {\n       mut space: linewidth as int,\n       mut left: 0u,\n       mut right: 0u,\n-      mut token: token,\n-      mut size: size,\n+      token: token,\n+      size: size,\n       mut left_total: 0,\n       mut right_total: 0,\n       mut scan_stack: scan_stack,\n@@ -206,8 +206,8 @@ type printer = @{\n     mut space: int, // number of spaces left on line\n     mut left: uint, // index of left side of input stream\n     mut right: uint, // index of right side of input stream\n-    mut token: [mut token], // ring-buffr stream goes through\n-    mut size: [mut int], // ring-buffer of calculated sizes\n+    token: [mut token], // ring-buffr stream goes through\n+    size: [mut int], // ring-buffer of calculated sizes\n     mut left_total: int, // running size of stream \"...left\"\n     mut right_total: int, // running size of stream \"...right\"\n     // pseudo-stack, really a ring too. Holds the\n@@ -346,7 +346,7 @@ impl printer for printer {\n         self.right %= self.buf_len;\n         assert (self.right != self.left);\n     }\n-    fn advance_left(x: token, L: int) {\n+    fn advance_left(++x: token, L: int) {\n         #debug(\"advnce_left [%u,%u], sizeof(%u)=%d\", self.left, self.right,\n                self.left, L);\n         if L >= 0 {\n@@ -367,7 +367,7 @@ impl printer for printer {\n     fn check_stack(k: int) {\n         if !self.scan_stack_empty {\n             let x = self.scan_top();\n-            alt self.token[x] {\n+            alt copy self.token[x] {\n               BEGIN(b) {\n                 if k > 0 {\n                     self.size[self.scan_pop()] = self.size[x] +\n@@ -465,7 +465,7 @@ impl printer for printer {\n             assert (L == len);\n             // assert L <= space;\n             self.space -= len;\n-            self.write_str(s);\n+            self.write_str(*s);\n           }\n           EOF {\n             // EOF should never get here.\n@@ -493,14 +493,14 @@ fn end(p: printer) { p.pretty_print(END); }\n fn eof(p: printer) { p.pretty_print(EOF); }\n \n fn word(p: printer, wrd: str) {\n-    p.pretty_print(STRING(wrd, str::len(wrd) as int));\n+    p.pretty_print(STRING(@wrd, str::len(wrd) as int));\n }\n \n fn huge_word(p: printer, wrd: str) {\n-    p.pretty_print(STRING(wrd, size_infinity));\n+    p.pretty_print(STRING(@wrd, size_infinity));\n }\n \n-fn zero_word(p: printer, wrd: str) { p.pretty_print(STRING(wrd, 0)); }\n+fn zero_word(p: printer, wrd: str) { p.pretty_print(STRING(@wrd, 0)); }\n \n fn spaces(p: printer, n: uint) { break_offset(p, n, 0); }\n "}, {"sha": "d4e66137d675826980ef3ed72116161d090c49c6", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -539,6 +539,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n           print_block(s, ctor.node.body);\n           option::iter(m_dtor) {|dtor|\n             hardbreak_if_not_bol(s);\n+            maybe_print_comment(s, dtor.span.lo);\n             head(s, \"drop\");\n             print_block(s, dtor.node.body);\n           }\n@@ -1703,7 +1704,7 @@ fn print_comment(s: ps, cmnt: comments::cmnt) {\n         // We need to do at least one, possibly two hardbreaks.\n         let is_semi =\n             alt s.s.last_token() {\n-              pp::STRING(s, _) { s == \";\" }\n+              pp::STRING(s, _) { *s == \";\" }\n               _ { false }\n             };\n         if is_semi || is_begin(s) || is_end(s) { hardbreak(s.s); }"}, {"sha": "c3e1b4da77276455ac01b4a74ad8d7051cedc499", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -637,6 +637,11 @@ fn link_binary(sess: session,\n     // and binutils 2.22+ won't add them automatically\n     if sess.targ_cfg.os == session::os_linux {\n         cc_args += [\"-lrt\", \"-ldl\"];\n+\n+        // LLVM implements the `frem` instruction as a call to `fmod`,\n+        // which lives in libm. Similar to above, on some linuxes we\n+        // have to be explicit about linking to it. See #2510\n+        cc_args += [\"-lm\"];\n     }\n \n     if sess.targ_cfg.os == session::os_freebsd {"}, {"sha": "e769455376a5788f1617fb4e9ec5a58d0a57e721", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -194,7 +194,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n          bind middle::check_loop::check_crate(ty_cx, crate));\n     time(time_passes, \"alt checking\",\n          bind middle::check_alt::check_crate(ty_cx, crate));\n-    let (last_use_map, spill_map) =\n+    let last_use_map =\n         time(time_passes, \"liveness checking\",\n              bind middle::liveness::check_crate(ty_cx, method_map, crate));\n     time(time_passes, \"typestate checking\",\n@@ -216,7 +216,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n     let maps = {mutbl_map: mutbl_map, root_map: root_map,\n                 copy_map: copy_map, last_use_map: last_use_map,\n                 impl_map: impl_map, method_map: method_map,\n-                vtable_map: vtable_map, spill_map: spill_map};\n+                vtable_map: vtable_map};\n \n     let (llmod, link_meta) =\n         time(time_passes, \"translation\","}, {"sha": "5e88df1de5ecfd2c043d9233b82693bafe33af94", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -15,7 +15,8 @@ import std::map::hashmap;\n import getopts::{opt_present};\n import rustc::driver::driver::*;\n import syntax::codemap;\n-import rustc::driver::{diagnostic, session};\n+import syntax::diagnostic;\n+import rustc::driver::session;\n import rustc::middle::lint;\n import io::reader_util;\n "}, {"sha": "2cb144a60b5cd7b0517bcb405dea2eff131504af", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -9,6 +9,7 @@ import syntax::codemap::span;\n import driver::session;\n import session::session;\n import syntax::attr;\n+import dvec::{dvec, extensions};\n \n export modify_for_testing;\n \n@@ -20,7 +21,7 @@ type test_ctxt =\n     @{sess: session::session,\n       crate: @ast::crate,\n       mut path: [ast::ident],\n-      mut testfns: [test]};\n+      testfns: dvec<test>};\n \n // Traverse the crate, collecting all the test functions, eliding any\n // existing main functions, and synthesizing a main test harness\n@@ -40,7 +41,7 @@ fn generate_test_harness(sess: session::session,\n         @{sess: sess,\n           crate: crate,\n           mut path: [],\n-          mut testfns: []};\n+          testfns: dvec()};\n \n     let precursor =\n         @{fold_crate: fold::wrap(bind fold_crate(cx, _, _)),\n@@ -110,8 +111,8 @@ fn fold_item(cx: test_ctxt, &&i: @ast::item, fld: fold::ast_fold) ->\n             let test = {span: i.span,\n                         path: cx.path, ignore: is_ignored(cx, i),\n                         should_fail: should_fail(i)};\n-            cx.testfns += [test];\n-            #debug(\"have %u test functions\", vec::len(cx.testfns));\n+            cx.testfns.push(test);\n+            #debug(\"have %u test functions\", cx.testfns.len());\n           }\n         }\n     }\n@@ -269,11 +270,10 @@ fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::ty {\n }\n \n fn mk_test_desc_vec(cx: test_ctxt) -> @ast::expr {\n-    #debug(\"building test vector from %u tests\", vec::len(cx.testfns));\n+    #debug(\"building test vector from %u tests\", cx.testfns.len());\n     let mut descs = [];\n     for cx.testfns.each {|test|\n-        let test_ = test; // Satisfy alias analysis\n-        descs += [mk_test_desc_rec(cx, test_)];\n+        descs += [mk_test_desc_rec(cx, test)];\n     }\n \n     ret @{id: cx.sess.next_node_id(),"}, {"sha": "3356e8cdd65245c5affe6238eff7f5af09eb6b38", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -13,6 +13,7 @@ import std::map::{hashmap, int_hash};\n import syntax::print::pprust;\n import filesearch::filesearch;\n import common::*;\n+import dvec::{dvec, extensions};\n \n export read_crates;\n \n@@ -26,7 +27,7 @@ fn read_crates(diag: span_handler, crate: ast::crate,\n               cstore: cstore,\n               os: os,\n               static: static,\n-              mut crate_cache: [],\n+              crate_cache: dvec(),\n               mut next_crate_num: 1};\n     let v =\n         visit::mk_simple_visitor(@{visit_view_item:\n@@ -35,7 +36,7 @@ fn read_crates(diag: span_handler, crate: ast::crate,\n                                       with *visit::default_simple_visitor()});\n     visit::visit_crate(crate, (), v);\n     dump_crates(e.crate_cache);\n-    warn_if_multiple_versions(diag, copy e.crate_cache);\n+    warn_if_multiple_versions(diag, e.crate_cache.get());\n }\n \n type cache_entry = {\n@@ -45,7 +46,7 @@ type cache_entry = {\n     metas: @[@ast::meta_item]\n };\n \n-fn dump_crates(crate_cache: [cache_entry]) {\n+fn dump_crates(crate_cache: dvec<cache_entry>) {\n     #debug(\"resolved crates:\");\n     for crate_cache.each {|entry|\n         #debug(\"cnum: %?\", entry.cnum);\n@@ -64,10 +65,10 @@ fn warn_if_multiple_versions(diag: span_handler,\n                              crate_cache: [cache_entry]) {\n     import either::*;\n \n-    if crate_cache.is_not_empty() {\n+    if crate_cache.len() != 0u {\n         let name = loader::crate_name_from_metas(*crate_cache.last().metas);\n         let {lefts: matches, rights: non_matches} =\n-            partition(crate_cache.map {|entry|\n+            partition(crate_cache.map_to_vec {|entry|\n                 let othername = loader::crate_name_from_metas(*entry.metas);\n                 if name == othername {\n                     left(entry)\n@@ -99,7 +100,7 @@ type env = @{diag: span_handler,\n              cstore: cstore::cstore,\n              os: loader::os,\n              static: bool,\n-             mut crate_cache: [cache_entry],\n+             crate_cache: dvec<cache_entry>,\n              mut next_crate_num: ast::crate_num};\n \n fn visit_view_item(e: env, i: @ast::view_item) {\n@@ -176,12 +177,14 @@ fn metas_with_ident(ident: ast::ident,\n \n fn existing_match(e: env, metas: [@ast::meta_item], hash: str) ->\n     option<int> {\n-    let maybe_entry = e.crate_cache.find {|c|\n-        loader::metadata_matches(*c.metas, metas) &&\n-            (hash.is_empty() || c.hash == hash)\n-    };\n \n-    maybe_entry.map {|c| c.cnum }\n+    for e.crate_cache.each {|c|\n+        if loader::metadata_matches(*c.metas, metas)\n+            && (hash.is_empty() || c.hash == hash) {\n+            ret some(c.cnum);\n+        }\n+    }\n+    ret none;\n }\n \n fn resolve_crate(e: env, ident: ast::ident, metas: [@ast::meta_item],\n@@ -211,8 +214,8 @@ fn resolve_crate(e: env, ident: ast::ident, metas: [@ast::meta_item],\n \n         // Claim this crate number and cache it\n         let cnum = e.next_crate_num;\n-        e.crate_cache += [{cnum: cnum, span: span,\n-                           hash: hash, metas: @linkage_metas}];\n+        e.crate_cache.push({cnum: cnum, span: span,\n+                            hash: hash, metas: @linkage_metas});\n         e.next_crate_num += 1;\n \n         // Now resolve the crates referenced by this crate"}, {"sha": "0bbbeafdb54a0cf9a131d1ddce651bab3da28a2c", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -63,7 +63,9 @@ type cstore_private =\n type use_crate_map = map::hashmap<ast::node_id, ast::crate_num>;\n \n // Internal method to retrieve the data from the cstore\n-fn p(cstore: cstore) -> cstore_private { alt cstore { private(p) { p } } }\n+pure fn p(cstore: cstore) -> cstore_private {\n+    alt cstore { private(p) { p } }\n+}\n \n fn mk_cstore() -> cstore {\n     let meta_cache = map::int_hash::<crate_metadata>();"}, {"sha": "4df45033a77c3d953756a2693c45ec09eeeb54d9", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -7,14 +7,14 @@ import syntax::{ast, ast_util};\n import syntax::attr;\n import middle::ty;\n import syntax::ast_map;\n-import common::*;\n import tydecode::{parse_ty_data, parse_def_id, parse_bounds_data,\n         parse_ident};\n import syntax::print::pprust;\n import cmd=cstore::crate_metadata;\n import util::ppaux::ty_to_str;\n import ebml::deserializer;\n import syntax::diagnostic::span_handler;\n+import common::*;\n \n export class_dtor;\n export get_class_fields;"}, {"sha": "6ebf0ed9ec65fae068ce3e45a06b4d664f078a5f", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -57,7 +57,6 @@ type maps = {\n     impl_map: middle::resolve::impl_map,\n     method_map: middle::typeck::method_map,\n     vtable_map: middle::typeck::vtable_map,\n-    spill_map: middle::liveness::spill_map\n };\n \n type decode_ctxt = @{\n@@ -839,12 +838,6 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    option::iter(maps.spill_map.find(id)) {|_m|\n-        ebml_w.tag(c::tag_table_spill) {||\n-            ebml_w.id(id);\n-        }\n-    }\n-\n     option::iter(maps.last_use_map.find(id)) {|m|\n         ebml_w.tag(c::tag_table_last_use) {||\n             ebml_w.id(id);\n@@ -953,8 +946,6 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n             dcx.maps.mutbl_map.insert(id, ());\n         } else if tag == (c::tag_table_copy as uint) {\n             dcx.maps.copy_map.insert(id, ());\n-        } else if tag == (c::tag_table_spill as uint) {\n-            dcx.maps.spill_map.insert(id, ());\n         } else {\n             let val_doc = entry_doc[c::tag_table_val];\n             let val_dsr = ebml::ebml_deserializer(val_doc);"}, {"sha": "d106c2b23d86edf36767ecf40923f5a68a5c4068", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -164,6 +164,7 @@ import util::common::indenter;\n import ast_util::op_expr_callee_id;\n import ty::to_str;\n import driver::session::session;\n+import dvec::{dvec, extensions};\n \n export check_crate, root_map, mutbl_map;\n \n@@ -298,7 +299,7 @@ type loan = {lp: @loan_path, cmt: cmt, mutbl: ast::mutability};\n \n // maps computed by `gather_loans` that are then used by `check_loans`\n type req_maps = {\n-    req_loan_map: hashmap<ast::node_id, @mut [@const [loan]]>,\n+    req_loan_map: hashmap<ast::node_id, @dvec<@dvec<loan>>>,\n     pure_map: hashmap<ast::node_id, bckerr>\n };\n "}, {"sha": "ff9d51196c91bd47a5f6ef04b9a18be05a9dd140", "filename": "src/rustc/middle/borrowck/categorization.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -7,7 +7,15 @@ determine what kind of memory is used in evaluating it (for example,\n where dereferences occur and what kind of pointer is dereferenced;\n whether the memory is mutable; etc)\n \n-\n+Categorization effectively transforms all of our expressions into\n+expressions of the following forms (the actual enum has many more\n+possibilities, naturally, but they are all variants of these base\n+forms):\n+\n+    E = rvalue    // some computed rvalue\n+      | x         // address of a local variable, arg, or upvar\n+      | *E        // deref of a ptr\n+      | E.comp    // access to an interior component\n \n Imagine a routine ToAddr(Expr) that evaluates an expression and returns an\n address where the result is to be found.  If Expr is an lvalue, then this"}, {"sha": "04a37d327cda8fe8e17a03a51fcc2ca5f766c7f5", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -7,6 +7,7 @@\n // 3. assignments do not affect things loaned out as immutable\n // 4. moves to dnot affect things loaned out in any way\n \n+import dvec::{dvec, extensions};\n import categorization::public_methods;\n \n export check_loans;\n@@ -22,7 +23,7 @@ enum check_loan_ctxt = @{\n     // we are in a ctor, we track the self id\n     mut in_ctor: bool,\n     mut declared_purity: ast::purity,\n-    mut fn_args: [ast::node_id]\n+    mut fn_args: @[ast::node_id]\n };\n \n // if we are enforcing purity, why are we doing so?\n@@ -44,7 +45,7 @@ fn check_loans(bccx: borrowck_ctxt,\n                                  reported: int_hash(),\n                                  mut in_ctor: false,\n                                  mut declared_purity: ast::impure_fn,\n-                                 mut fn_args: []});\n+                                 mut fn_args: @[]});\n     let vt = visit::mk_vt(@{visit_expr: check_loans_in_expr,\n                             visit_block: check_loans_in_block,\n                             visit_fn: check_loans_in_fn\n@@ -179,7 +180,7 @@ impl methods for check_loan_ctxt {\n                 let did = ast_util::def_id_of_def(def);\n                 let is_fn_arg =\n                     did.crate == ast::local_crate &&\n-                    self.fn_args.contains(did.node);\n+                    (*self.fn_args).contains(did.node);\n                 if is_fn_arg { ret; } // case (a) above\n               }\n               ast::expr_fn_block(*) | ast::expr_fn(*) |\n@@ -225,7 +226,8 @@ impl methods for check_loan_ctxt {\n           ast::expr_path(_) {\n             let def = self.tcx().def_map.get(expr.id);\n             let did = ast_util::def_id_of_def(def);\n-            did.crate == ast::local_crate && self.fn_args.contains(did.node)\n+            did.crate == ast::local_crate &&\n+                (*self.fn_args).contains(did.node)\n           }\n           ast::expr_fn_block(*) | ast::expr_fn(*) {\n             self.is_stack_closure(expr.id)\n@@ -484,7 +486,7 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                      sp: span, id: ast::node_id, &&self: check_loan_ctxt,\n                      visitor: visit::vt<check_loan_ctxt>) {\n \n-    #debug[\"purity on entry=%?\", self.declared_purity];\n+    #debug[\"purity on entry=%?\", copy self.declared_purity];\n     save_and_restore(self.in_ctor) {||\n         save_and_restore(self.declared_purity) {||\n             save_and_restore(self.fn_args) {||\n@@ -500,7 +502,7 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                   visit::fk_ctor(*) {\n                     self.in_ctor = true;\n                     self.declared_purity = decl.purity;\n-                    self.fn_args = decl.inputs.map({|i| i.id});\n+                    self.fn_args = @decl.inputs.map({|i| i.id});\n                   }\n                   visit::fk_anon(*) |\n                   visit::fk_fn_block(*) if is_stack_closure {\n@@ -512,15 +514,15 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                   visit::fk_res(*) | visit::fk_dtor(*) {\n                     self.in_ctor = false;\n                     self.declared_purity = decl.purity;\n-                    self.fn_args = decl.inputs.map({|i| i.id});\n+                    self.fn_args = @decl.inputs.map({|i| i.id});\n                   }\n                 }\n \n                 visit::visit_fn(fk, decl, body, sp, id, self, visitor);\n             }\n         }\n     }\n-    #debug[\"purity on exit=%?\", self.declared_purity];\n+    #debug[\"purity on exit=%?\", copy self.declared_purity];\n }\n \n fn check_loans_in_expr(expr: @ast::expr,"}, {"sha": "fe59d771042feb33a0e0f24cdefdd5f7fc2701ba", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -84,15 +84,24 @@ fn req_loans_in_expr(ex: @ast::expr,\n                 // the pointer to be borrowed as immutable even if it\n                 // is mutable in the caller's frame, thus effectively\n                 // passing the buck onto us to enforce this)\n+                //\n+                // FIXME---this handling is not really adequate.  For\n+                // example, if there is a type like, {f: [int]}, we\n+                // will ignore it, but we ought to be requiring it to\n+                // be immutable (whereas something like {f:int} would\n+                // be fine).\n \n                 alt opt_deref_kind(arg_ty.ty) {\n-                  some(deref_ptr(region_ptr)) {\n+                  some(deref_ptr(region_ptr)) |\n+                  some(deref_ptr(unsafe_ptr)) {\n                     /* region pointers are (by induction) guaranteed */\n+                    /* unsafe pointers are the user's problem */\n                   }\n+                  some(deref_comp(_)) |\n                   none {\n                     /* not a pointer, no worries */\n                   }\n-                  some(_) {\n+                  some(deref_ptr(_)) {\n                     let arg_cmt = self.bccx.cat_borrow_of_expr(arg);\n                     self.guarantee_valid(arg_cmt, m_const, scope_r);\n                   }\n@@ -264,13 +273,14 @@ impl methods for gather_loan_ctxt {\n         }\n     }\n \n-    fn add_loans(scope_id: ast::node_id, loans: @const [loan]) {\n+    fn add_loans(scope_id: ast::node_id, loans: @dvec<loan>) {\n         alt self.req_maps.req_loan_map.find(scope_id) {\n           some(l) {\n-            *l += [loans];\n+            (*l).push(loans);\n           }\n           none {\n-            self.req_maps.req_loan_map.insert(scope_id, @mut [loans]);\n+            self.req_maps.req_loan_map.insert(\n+                scope_id, @dvec::from_vec([mut loans]));\n           }\n         }\n     }"}, {"sha": "c0e6f4accf707330ae10dda009654db438ba4a2e", "filename": "src/rustc/middle/borrowck/loan.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -5,16 +5,16 @@\n export public_methods;\n \n impl public_methods for borrowck_ctxt {\n-    fn loan(cmt: cmt, mutbl: ast::mutability) -> @const [loan] {\n-        let lc = @{bccx: self, loans: @mut []};\n+    fn loan(cmt: cmt, mutbl: ast::mutability) -> @dvec<loan> {\n+        let lc = @{bccx: self, loans: @dvec()};\n         lc.loan(cmt, mutbl);\n         ret lc.loans;\n     }\n }\n \n type loan_ctxt = @{\n     bccx: borrowck_ctxt,\n-    loans: @mut [loan]\n+    loans: @dvec<loan>\n };\n \n impl loan_methods for loan_ctxt {\n@@ -23,9 +23,9 @@ impl loan_methods for loan_ctxt {\n         // Note: all cmt's that we deal with will have a non-none lp, because\n         // the entry point into this routine, `borrowck_ctxt::loan()`, rejects\n         // any cmt with a none-lp.\n-        *self.loans += [{lp:option::get(cmt.lp),\n-                         cmt:cmt,\n-                         mutbl:mutbl}];\n+        (*self.loans).push({lp:option::get(cmt.lp),\n+                            cmt:cmt,\n+                            mutbl:mutbl});\n     }\n \n     fn loan(cmt: cmt, req_mutbl: ast::mutability) {"}, {"sha": "6c2032c9c34d383a5f66743fc149fd2165b3d661", "filename": "src/rustc/middle/check_const.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_const.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -2,6 +2,7 @@ import syntax::ast::*;\n import syntax::{visit, ast_util, ast_map};\n import driver::session::session;\n import std::map::hashmap;\n+import dvec::{dvec, extensions};\n \n fn check_crate(sess: session, crate: @crate, ast_map: ast_map::map,\n                def_map: resolve::def_map,\n@@ -130,15 +131,15 @@ fn check_item_recursion(sess: session, ast_map: ast_map::map,\n         sess: session,\n         ast_map: ast_map::map,\n         def_map: resolve::def_map,\n-        idstack: @mut [node_id],\n+        idstack: @dvec<node_id>,\n     };\n \n     let env = {\n         root_it: it,\n         sess: sess,\n         ast_map: ast_map,\n         def_map: def_map,\n-        idstack: @mut []\n+        idstack: @dvec()\n     };\n \n     let visitor = visit::mk_vt(@{\n@@ -152,9 +153,9 @@ fn check_item_recursion(sess: session, ast_map: ast_map::map,\n         if (*env.idstack).contains(it.id) {\n             env.sess.span_fatal(env.root_it.span, \"recursive constant\");\n         }\n-        vec::push(*env.idstack, it.id);\n+        (*env.idstack).push(it.id);\n         visit::visit_item(it, env, v);\n-        vec::pop(*env.idstack);\n+        (*env.idstack).pop();\n     }\n \n     fn visit_expr(e: @expr, &&env: env, v: visit::vt<env>) {"}, {"sha": "0f1edb0c4158ac5442f1ad26d254ddbe64006dfd", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 16, "deletions": 59, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -57,7 +57,6 @@ import capture::{cap_move, cap_drop, cap_copy, cap_ref};\n \n export check_crate;\n export last_use_map;\n-export spill_map;\n \n // Maps from an expr id to a list of variable ids for which this expr\n // is the last use.  Typically, the expr is a path and the node id is\n@@ -66,13 +65,6 @@ export spill_map;\n // list of closed over variables that can be moved into the closure.\n type last_use_map = hashmap<node_id, @dvec<node_id>>;\n \n-// A set of variable ids which must be spilled (stored on the stack).\n-// We add in any variables or arguments where:\n-// (1) the variables are moved;\n-// (2) the address of the variable/argument is taken;\n-// or (3) we find a last use (as they may be moved).\n-type spill_map = hashmap<node_id, ()>;\n-\n enum variable = uint;\n enum live_node = uint;\n \n@@ -85,7 +77,7 @@ enum live_node_kind {\n \n fn check_crate(tcx: ty::ctxt,\n                method_map: typeck::method_map,\n-               crate: @crate) -> (last_use_map, spill_map) {\n+               crate: @crate) -> last_use_map {\n     let visitor = visit::mk_vt(@{\n         visit_fn: visit_fn,\n         visit_local: visit_local,\n@@ -94,12 +86,11 @@ fn check_crate(tcx: ty::ctxt,\n     });\n \n     let last_use_map = int_hash();\n-    let spill_map = int_hash();\n     let initial_maps = @ir_maps(tcx, method_map,\n-                                last_use_map, spill_map);\n+                                last_use_map);\n     visit::visit_crate(*crate, initial_maps, visitor);\n     tcx.sess.abort_if_errors();\n-    ret (last_use_map, spill_map);\n+    ret last_use_map;\n }\n \n impl of to_str::to_str for live_node {\n@@ -133,7 +124,7 @@ impl of to_str::to_str for variable {\n // assignment.  And so forth.\n \n impl methods for live_node {\n-    fn is_valid() -> bool { *self != uint::max_value }\n+    pure fn is_valid() -> bool { *self != uint::max_value }\n }\n \n fn invalid_node() -> live_node { live_node(uint::max_value) }\n@@ -162,7 +153,6 @@ class ir_maps {\n     let tcx: ty::ctxt;\n     let method_map: typeck::method_map;\n     let last_use_map: last_use_map;\n-    let spill_map: spill_map;\n \n     let mut num_live_nodes: uint;\n     let mut num_vars: uint;\n@@ -174,11 +164,10 @@ class ir_maps {\n     let mut lnks: [live_node_kind];\n \n     new(tcx: ty::ctxt, method_map: typeck::method_map,\n-        last_use_map: last_use_map, spill_map: spill_map) {\n+        last_use_map: last_use_map) {\n         self.tcx = tcx;\n         self.method_map = method_map;\n         self.last_use_map = last_use_map;\n-        self.spill_map = spill_map;\n \n         self.num_live_nodes = 0u;\n         self.num_vars = 0u;\n@@ -264,17 +253,6 @@ class ir_maps {\n         self.lnks[*ln]\n     }\n \n-    fn add_spill(var: variable) {\n-        let vk = self.var_kinds[*var];\n-        alt vk {\n-          vk_local(id, _) | vk_arg(id, _, by_val) {\n-            #debug[\"adding spill for %?\", vk];\n-            self.spill_map.insert(id, ());\n-          }\n-          vk_arg(*) | vk_field(_) | vk_self | vk_implicit_ret {}\n-        }\n-    }\n-\n     fn add_last_use(expr_id: node_id, var: variable) {\n         let vk = self.var_kinds[*var];\n         #debug[\"Node %d is a last use of variable %?\", expr_id, vk];\n@@ -308,7 +286,7 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n \n     // swap in a new set of IR maps for this function body:\n     let fn_maps = @ir_maps(self.tcx, self.method_map,\n-                           self.last_use_map, self.spill_map);\n+                           self.last_use_map);\n \n     #debug[\"creating fn_maps: %x\", ptr::addr_of(*fn_maps) as uint];\n \n@@ -571,7 +549,7 @@ class liveness {\n     fn live_on_exit(ln: live_node, var: variable)\n         -> option<live_node_kind> {\n \n-        self.live_on_entry(self.successors[*ln], var)\n+        self.live_on_entry(copy self.successors[*ln], var)\n     }\n \n     fn used_on_entry(ln: live_node, var: variable) -> bool {\n@@ -590,7 +568,7 @@ class liveness {\n     fn assigned_on_exit(ln: live_node, var: variable)\n         -> option<live_node_kind> {\n \n-        self.assigned_on_entry(self.successors[*ln], var)\n+        self.assigned_on_entry(copy self.successors[*ln], var)\n     }\n \n     fn indices(ln: live_node, op: fn(uint)) {\n@@ -627,14 +605,14 @@ class liveness {\n             wr.write_str(\"[ln(\");\n             wr.write_uint(*ln);\n             wr.write_str(\") of kind \");\n-            wr.write_str(#fmt[\"%?\", self.ir.lnks[*ln]]);\n+            wr.write_str(#fmt[\"%?\", copy self.ir.lnks[*ln]]);\n             wr.write_str(\" reads\");\n             self.write_vars(wr, ln, {|idx| self.users[idx].reader});\n             wr.write_str(\"  writes\");\n             self.write_vars(wr, ln, {|idx| self.users[idx].writer});\n             wr.write_str(\" \");\n             wr.write_str(\" precedes \");\n-            wr.write_str(self.successors[*ln].to_str());\n+            wr.write_str((copy self.successors[*ln]).to_str());\n             wr.write_str(\"]\");\n         }\n     }\n@@ -668,9 +646,9 @@ class liveness {\n \n         let mut changed = false;\n         self.indices2(ln, succ_ln) { |idx, succ_idx|\n-            changed |= copy_if_invalid(self.users[succ_idx].reader,\n+            changed |= copy_if_invalid(copy self.users[succ_idx].reader,\n                                        self.users[idx].reader);\n-            changed |= copy_if_invalid(self.users[succ_idx].writer,\n+            changed |= copy_if_invalid(copy self.users[succ_idx].writer,\n                                        self.users[idx].writer);\n             if self.users[succ_idx].used && !self.users[idx].used {\n                 self.users[idx].used = true;\n@@ -1407,11 +1385,7 @@ fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n         vt.visit_expr(f, self, vt);\n         vec::iter2(args, targs) { |arg_expr, arg_ty|\n             alt ty::resolved_mode(self.tcx, arg_ty.mode) {\n-              by_val | by_copy {\n-                vt.visit_expr(arg_expr, self, vt);\n-              }\n-              by_ref | by_mutbl_ref {\n-                self.spill_expr(arg_expr);\n+              by_val | by_copy | by_ref | by_mutbl_ref{\n                 vt.visit_expr(arg_expr, self, vt);\n               }\n               by_move {\n@@ -1421,10 +1395,6 @@ fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n         }\n       }\n \n-      expr_addr_of(_, arg_expr) {\n-        self.spill_expr(arg_expr);\n-      }\n-\n       // no correctness conditions related to liveness\n       expr_if_check(*) | expr_if(*) | expr_alt(*) |\n       expr_while(*) | expr_loop(*) |\n@@ -1434,7 +1404,7 @@ fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n       expr_assert(*) | expr_check(*) | expr_copy(*) |\n       expr_loop_body(*) | expr_cast(*) | expr_unary(*) | expr_fail(*) |\n       expr_ret(*) | expr_break | expr_cont | expr_lit(_) |\n-      expr_block(*) | expr_swap(*) | expr_mac(*) {\n+      expr_block(*) | expr_swap(*) | expr_mac(*) | expr_addr_of(*) {\n         visit::visit_expr(expr, self, vt);\n       }\n     }\n@@ -1501,10 +1471,7 @@ impl check_methods for @liveness {\n                ln.to_str(), var.to_str()];\n \n         alt (*self).live_on_exit(ln, var) {\n-          none {\n-            // update spill map to include this variable, as it is moved:\n-            (*self.ir).add_spill(var);\n-          }\n+          none { }\n           some(lnk) {\n             self.report_illegal_move(span, lnk, var);\n           }\n@@ -1516,20 +1483,10 @@ impl check_methods for @liveness {\n           some(_) {}\n           none {\n             (*self.ir).add_last_use(expr.id, var);\n-\n-            // update spill map to include this variable, as it may be moved:\n-            (*self.ir).add_spill(var);\n           }\n        }\n     }\n \n-    fn spill_expr(expr: @expr) {\n-        alt (*self).variable_from_path(expr) {\n-          some(var) {(*self.ir).add_spill(var)}\n-          none {}\n-        }\n-    }\n-\n     fn check_move_from_expr(expr: @expr, vt: vt<@liveness>) {\n         #debug[\"check_move_from_expr(node %d: %s)\",\n                expr.id, expr_to_str(expr)];\n@@ -1775,4 +1732,4 @@ impl check_methods for @liveness {\n             }\n         }\n     }\n- }\n\\ No newline at end of file\n+ }"}, {"sha": "6c75e470c0a839ccac0a12ca4a997c94d1699909", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -100,7 +100,7 @@ type glob_imp_def = {def: def, path: @ast::view_path};\n type indexed_mod = {\n     m: option<ast::_mod>,\n     index: mod_index,\n-    mut glob_imports: [glob_imp_def],\n+    glob_imports: dvec<glob_imp_def>,\n     mut globbed_exports: [ident],\n     glob_imported_names: hashmap<str, glob_import_state>,\n     path: str\n@@ -123,7 +123,7 @@ type env =\n      def_map: def_map,\n      ast_map: ast_map::map,\n      imports: hashmap<node_id, import_state>,\n-     mut exp_map: exp_map,\n+     exp_map: exp_map,\n      mod_map: hashmap<node_id, @indexed_mod>,\n      block_map: hashmap<node_id, [glob_imp_def]>,\n      ext_map: ext_map,\n@@ -132,7 +132,7 @@ type env =\n      ext_cache: ext_hash,\n      used_imports: {mut track: bool,\n                     mut data: [node_id]},\n-     mut reported: [{ident: str, sc: scope}],\n+     reported: dvec<{ident: str, sc: scope}>,\n      mut ignored_imports: [node_id],\n      mut current_tp: option<uint>,\n      mut resolve_unexported: bool,\n@@ -174,15 +174,15 @@ fn create_env(sess: session, amap: ast_map::map) -> @env {\n       def_map: int_hash(),\n       ast_map: amap,\n       imports: int_hash(),\n-      mut exp_map: int_hash(),\n+      exp_map: int_hash(),\n       mod_map: int_hash(),\n       block_map: int_hash(),\n       ext_map: new_def_hash(),\n       impl_map: int_hash(),\n       impl_cache: new_def_hash(),\n       ext_cache: new_ext_hash(),\n       used_imports: {mut track: false, mut data:  []},\n-      mut reported: [],\n+      reported: dvec(),\n       mut ignored_imports: [],\n       mut current_tp: none,\n       mut resolve_unexported: false,\n@@ -270,7 +270,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n             e.mod_map.insert(i.id,\n                              @{m: some(md),\n                                index: index_mod(md),\n-                               mut glob_imports: [],\n+                               glob_imports: dvec(),\n                                mut globbed_exports: [],\n                                glob_imported_names: str_hash(),\n                                path: path_from_scope(sc, i.ident)});\n@@ -279,7 +279,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n             e.mod_map.insert(i.id,\n                              @{m: none::<ast::_mod>,\n                                index: index_nmod(nmd),\n-                               mut glob_imports: [],\n+                               glob_imports: dvec(),\n                                mut globbed_exports: [],\n                                glob_imported_names: str_hash(),\n                                path: path_from_scope(sc, i.ident)});\n@@ -301,7 +301,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n                     let glob = {def: imp, path: vp};\n                     alt list::head(sc) {\n                       scope_item(i) {\n-                        e.mod_map.get(i.id).glob_imports += [glob];\n+                        e.mod_map.get(i.id).glob_imports.push(glob);\n                       }\n                       scope_block(b, _, _) {\n                         let globs = alt e.block_map.find(b.node.id) {\n@@ -311,8 +311,8 @@ fn map_crate(e: @env, c: @ast::crate) {\n                         e.block_map.insert(b.node.id, globs);\n                       }\n                       scope_crate {\n-                        e.mod_map.get(ast::crate_node_id).glob_imports\n-                            += [glob];\n+                        e.mod_map.get(ast::crate_node_id).\n+                            glob_imports.push(glob);\n                       }\n                       _ { e.sess.span_bug(vi.span, \"unexpected scope in a \\\n                                                     glob import\"); }\n@@ -338,7 +338,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n     e.mod_map.insert(ast::crate_node_id,\n                      @{m: some(c.node.module),\n                        index: index_mod(c.node.module),\n-                       mut glob_imports: [],\n+                       glob_imports: dvec(),\n                        mut globbed_exports: [],\n                        glob_imported_names: str_hash(),\n                        path: \"\"});\n@@ -899,7 +899,7 @@ fn unresolved_err(e: env, cx: ctxt, sp: span, name: ident, kind: str) {\n             for e.reported.each {|rs|\n                 if str::eq(rs.ident, name) && err_scope == rs.sc { ret; }\n             }\n-            e.reported += [{ident: name, sc: err_scope}];\n+            e.reported.push({ident: name, sc: err_scope});\n           }\n           _ {}\n         }\n@@ -1536,7 +1536,7 @@ fn lookup_glob_in_mod(e: env, info: @indexed_mod, sp: span, id: ident,\n     // absence takes the place of todo()\n     if !info.glob_imported_names.contains_key(id) {\n         info.glob_imported_names.insert(id, glob_resolving(sp));\n-        let globs = info.glob_imports;\n+        let globs = info.glob_imports.get();\n         let val = lookup_in_globs(e, globs, sp, id, ns_val, dr);\n         let typ = lookup_in_globs(e, globs, sp, id, ns_type, dr);\n         let md = lookup_in_globs(e, globs, sp, id, ns_module, dr);"}, {"sha": "c1d05bf39da1f0f7a2c2339fba8e4994e1d3ff8b", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 45, "deletions": 79, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -62,6 +62,12 @@ enum dest {\n     ignore,\n }\n \n+// Heap selectors. Indicate which heap something should go on.\n+enum heap {\n+    heap_shared,\n+    heap_exchange,\n+}\n+\n fn dest_str(ccx: @crate_ctxt, d: dest) -> str {\n     alt d {\n       by_val(v) { #fmt[\"by_val(%s)\", val_str(ccx.tn, *v)] }\n@@ -341,75 +347,61 @@ fn opaque_box_body(bcx: block,\n     PointerCast(bcx, bodyptr, T_ptr(type_of(ccx, body_t)))\n }\n \n-// trans_malloc_boxed_raw: expects an unboxed type and returns a pointer to\n+// malloc_raw: expects an unboxed type and returns a pointer to\n // enough space for a box of that type.  This includes a rust_opaque_box\n // header.\n-fn malloc_boxed_raw(bcx: block, t: ty::t,\n-                    &static_ti: option<@tydesc_info>) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"trans_malloc_boxed_raw\");\n+fn malloc_raw(bcx: block, t: ty::t, heap: heap) -> ValueRef {\n+    let _icx = bcx.insn_ctxt(\"malloc_raw\");\n     let ccx = bcx.ccx();\n \n-    // Grab the TypeRef type of box_ptr, because that's what trans_raw_malloc\n-    // wants.\n-    let box_ptr = ty::mk_imm_box(ccx.tcx, t);\n-    let llty = type_of(ccx, box_ptr);\n+    let (mk_fn, upcall) = alt heap {\n+      heap_shared { (ty::mk_imm_box, ccx.upcalls.malloc) }\n+      heap_exchange {\n+        (ty::mk_imm_uniq, ccx.upcalls.exchange_malloc )\n+      }\n+    };\n+\n+    // Grab the TypeRef type of box_ptr_ty.\n+    let box_ptr_ty = mk_fn(bcx.tcx(), t);\n+    let llty = type_of(ccx, box_ptr_ty);\n \n     // Get the tydesc for the body:\n+    let mut static_ti = none;\n     let lltydesc = get_tydesc(ccx, t, static_ti);\n     lazily_emit_all_tydesc_glue(ccx, copy static_ti);\n \n     // Allocate space:\n-    let rval = Call(bcx, ccx.upcalls.malloc, [lltydesc]);\n+    let rval = Call(bcx, upcall, [lltydesc]);\n     ret PointerCast(bcx, rval, llty);\n }\n \n-// trans_malloc_boxed: usefully wraps trans_malloc_box_raw; allocates a box,\n-// initializes the reference count to 1, and pulls out the body and rc\n-fn malloc_boxed(bcx: block, t: ty::t) -> {box: ValueRef, body: ValueRef} {\n-    let _icx = bcx.insn_ctxt(\"trans_malloc_boxed\");\n-    let mut ti = none;\n-    let box = malloc_boxed_raw(bcx, t, ti);\n-    let box_no_addrspace = non_gc_box_cast(\n-        bcx, box, ty::mk_imm_box(bcx.tcx(), t));\n-    let body = GEPi(bcx, box_no_addrspace, [0u, abi::box_field_body]);\n+// malloc_general: usefully wraps malloc_raw; allocates a box,\n+// and pulls out the body\n+fn malloc_general(bcx: block, t: ty::t, heap: heap) ->\n+    {box: ValueRef, body: ValueRef} {\n+    let _icx = bcx.insn_ctxt(\"malloc_general\");\n+    let mk_ty = alt heap { heap_shared { ty::mk_imm_box }\n+                           heap_exchange { ty::mk_imm_uniq } };\n+    let box = malloc_raw(bcx, t, heap);\n+    let non_gc_box = non_gc_box_cast(bcx, box, mk_ty(bcx.tcx(), t));\n+    let body = GEPi(bcx, non_gc_box, [0u, abi::box_field_body]);\n     ret {box: box, body: body};\n }\n \n-fn malloc_unique_raw(bcx: block, t: ty::t) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"malloc_unique_box_raw\");\n-    let ccx = bcx.ccx();\n-\n-    // Grab the TypeRef type of box_ptr, because that's what trans_raw_malloc\n-    // wants.\n-    let box_ptr = ty::mk_imm_uniq(ccx.tcx, t);\n-    let llty = type_of(ccx, box_ptr);\n-\n-    // Get the tydesc for the body:\n-    let mut static_ti = none;\n-    let lltydesc = get_tydesc(ccx, t, static_ti);\n-    lazily_emit_all_tydesc_glue(ccx, static_ti);\n-\n-    // Allocate space:\n-    let rval = Call(bcx, ccx.upcalls.exchange_malloc, [lltydesc]);\n-    ret PointerCast(bcx, rval, llty);\n+fn malloc_boxed(bcx: block, t: ty::t) -> {box: ValueRef, body: ValueRef} {\n+    malloc_general(bcx, t, heap_shared)\n }\n-\n fn malloc_unique(bcx: block, t: ty::t) -> {box: ValueRef, body: ValueRef} {\n-    let _icx = bcx.insn_ctxt(\"malloc_unique_box\");\n-    let box = malloc_unique_raw(bcx, t);\n-    let non_gc_box = non_gc_box_cast(bcx, box, ty::mk_imm_uniq(bcx.tcx(), t));\n-    let body = GEPi(bcx, non_gc_box, [0u, abi::box_field_body]);\n-    ret {box: box, body: body};\n+    malloc_general(bcx, t, heap_exchange)\n }\n \n fn malloc_unique_dyn_raw(bcx: block, t: ty::t, size: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"malloc_unique_box_raw\");\n+    let _icx = bcx.insn_ctxt(\"malloc_unique_dyn_raw\");\n     let ccx = bcx.ccx();\n \n-    // Grab the TypeRef type of box_ptr, because that's what trans_raw_malloc\n-    // wants.\n-    let box_ptr = ty::mk_imm_uniq(ccx.tcx, t);\n-    let llty = type_of(ccx, box_ptr);\n+    // Grab the TypeRef type of box_ptr_ty.\n+    let box_ptr_ty = ty::mk_imm_uniq(ccx.tcx, t);\n+    let llty = type_of(ccx, box_ptr_ty);\n \n     // Get the tydesc for the body:\n     let mut static_ti = none;\n@@ -423,7 +415,7 @@ fn malloc_unique_dyn_raw(bcx: block, t: ty::t, size: ValueRef) -> ValueRef {\n \n fn malloc_unique_dyn(bcx: block, t: ty::t, size: ValueRef\n                     ) -> {box: ValueRef, body: ValueRef} {\n-    let _icx = bcx.insn_ctxt(\"malloc_unique_box\");\n+    let _icx = bcx.insn_ctxt(\"malloc_unique_dyn\");\n     let box = malloc_unique_dyn_raw(bcx, t, size);\n     let body = GEPi(bcx, box, [0u, abi::box_field_body]);\n     ret {box: box, body: body};\n@@ -1194,7 +1186,7 @@ fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n               }\n             }\n         } else if field == abi::tydesc_field_visit_glue {\n-            alt ti.free_glue {\n+            alt ti.visit_glue {\n               some(_) { }\n               none {\n                 #debug(\"+++ lazily_emit_tydesc_glue VISIT %s\",\n@@ -1230,6 +1222,8 @@ fn call_tydesc_glue_full(cx: block, v: ValueRef, tydesc: ValueRef,\n             static_glue_fn = sti.drop_glue;\n         } else if field == abi::tydesc_field_free_glue {\n             static_glue_fn = sti.free_glue;\n+        } else if field == abi::tydesc_field_visit_glue {\n+            static_glue_fn = sti.visit_glue;\n         }\n       }\n     }\n@@ -3749,6 +3743,8 @@ fn lval_to_dps(bcx: block, e: @ast::expr, dest: dest) -> block {\n     let ty = expr_ty(bcx, e);\n     let lv = trans_lval(bcx, e);\n     let last_use = (lv.kind == owned && last_use_map.contains_key(e.id));\n+    #debug[\"is last use (%s) = %b, %d\", expr_to_str(e), last_use,\n+           lv.kind as int];\n     lval_result_to_dps(lv, ty, last_use, dest)\n }\n \n@@ -4039,29 +4035,10 @@ fn init_local(bcx: block, local: @ast::local) -> block {\n     let ty = node_id_type(bcx, local.node.id);\n     let llptr = alt bcx.fcx.lllocals.find(local.node.id) {\n       some(local_mem(v)) { v }\n-      some(_) { bcx.tcx().sess.span_bug(local.span,\n+      _ { bcx.tcx().sess.span_bug(local.span,\n                         \"init_local: Someone forgot to document why it's\\\n                          safe to assume local.node.init must be local_mem!\");\n-      }\n-      // This is a local that is kept immediate\n-      none {\n-        let initexpr = alt local.node.init {\n-                some({expr, _}) { expr }\n-                none { bcx.tcx().sess.span_bug(local.span,\n-                        \"init_local: late-initialized var appears to \\\n-                 be an immediate -- possibly init_local was called \\\n-                 without calling alloc_local\"); }\n-            };\n-        let mut {bcx, val, kind} = trans_temp_lval(bcx, initexpr);\n-        if kind != temporary {\n-            if kind == owned { val = Load(bcx, val); }\n-            let rs = take_ty_immediate(bcx, val, ty);\n-            bcx = rs.bcx; val = rs.val;\n-            add_clean_temp(bcx, val, ty);\n         }\n-        bcx.fcx.lllocals.insert(local.node.pat.id, local_imm(val));\n-        ret bcx;\n-      }\n     };\n \n     let mut bcx = bcx;\n@@ -4341,17 +4318,6 @@ fn alloc_local(cx: block, local: @ast::local) -> block {\n       ast::pat_ident(pth, none) { some(path_to_ident(pth)) }\n       _ { none }\n     };\n-    // Do not allocate space for locals that can be kept immediate.\n-    let ccx = cx.ccx();\n-    if option::is_some(simple_name) &&\n-       !ccx.maps.mutbl_map.contains_key(local.node.pat.id) &&\n-       !ccx.maps.spill_map.contains_key(local.node.pat.id) &&\n-       ty::type_is_immediate(t) {\n-        alt local.node.init {\n-          some({op: ast::init_assign, _}) { ret cx; }\n-          _ {}\n-        }\n-    }\n     let val = alloc_ty(cx, t);\n     if cx.sess().opts.debuginfo {\n         option::iter(simple_name) {|name|"}, {"sha": "88cd126b1e4d375669adf0946ff9176ac3149791", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -175,11 +175,12 @@ fn allocate_cbox(bcx: block,\n     let mut temp_cleanups = [];\n     let (bcx, box) = alt ck {\n       ty::ck_box {\n-        let box = malloc_boxed_raw(bcx, cdata_ty, ti);\n+        get_tydesc(ccx, cdata_ty, ti);\n+        let box = malloc_raw(bcx, cdata_ty, heap_shared);\n         (bcx, box)\n       }\n       ty::ck_uniq {\n-        let box = malloc_unique_raw(bcx, cdata_ty);\n+        let box = malloc_raw(bcx, cdata_ty, heap_exchange);\n         (bcx, box)\n       }\n       ty::ck_block {"}, {"sha": "09c5ebbf96aaac54cc79545132297a7f8f6b2053", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -24,29 +24,30 @@ fn visit_ty_steps(bcx: block, t: ty::t,\n       ty::ty_bool { step(bcx, \"visit_bool\", []) }\n       ty::ty_int(ast::ty_i) { step(bcx, \"visit_int\", []) }\n       ty::ty_int(ast::ty_char) { step(bcx, \"visit_char\", []) }\n-          ty::ty_int(ast::ty_i8) { step(bcx, \"visit_i8\", []) }\n-          ty::ty_int(ast::ty_i16) { step(bcx, \"visit_i16\", []) }\n-          ty::ty_int(ast::ty_i32) { step(bcx, \"visit_i32\", []) }\n-          ty::ty_int(ast::ty_i64) { step(bcx, \"visit_i64\", []) }\n-          ty::ty_uint(ast::ty_u) { step(bcx, \"visit_uint\", []) }\n-          ty::ty_uint(ast::ty_u8) { step(bcx, \"visit_u8\", []) }\n-          ty::ty_uint(ast::ty_u16) { step(bcx, \"visit_u16\", []) }\n-          ty::ty_uint(ast::ty_u32) { step(bcx, \"visit_u32\", []) }\n-          ty::ty_uint(ast::ty_u64) { step(bcx, \"visit_u64\", []) }\n-          ty::ty_float(ast::ty_f) { step(bcx, \"visit_float\", []) }\n-          ty::ty_float(ast::ty_f32) { step(bcx, \"visit_f32\", []) }\n-          ty::ty_float(ast::ty_f64) { step(bcx, \"visit_f64\", []) }\n-          ty::ty_str { step(bcx, \"visit_str\", []) }\n+      ty::ty_int(ast::ty_i8) { step(bcx, \"visit_i8\", []) }\n+      ty::ty_int(ast::ty_i16) { step(bcx, \"visit_i16\", []) }\n+      ty::ty_int(ast::ty_i32) { step(bcx, \"visit_i32\", []) }\n+      ty::ty_int(ast::ty_i64) { step(bcx, \"visit_i64\", []) }\n+      ty::ty_uint(ast::ty_u) { step(bcx, \"visit_uint\", []) }\n+      ty::ty_uint(ast::ty_u8) { step(bcx, \"visit_u8\", []) }\n+      ty::ty_uint(ast::ty_u16) { step(bcx, \"visit_u16\", []) }\n+      ty::ty_uint(ast::ty_u32) { step(bcx, \"visit_u32\", []) }\n+      ty::ty_uint(ast::ty_u64) { step(bcx, \"visit_u64\", []) }\n+      ty::ty_float(ast::ty_f) { step(bcx, \"visit_float\", []) }\n+      ty::ty_float(ast::ty_f32) { step(bcx, \"visit_f32\", []) }\n+      ty::ty_float(ast::ty_f64) { step(bcx, \"visit_f64\", []) }\n+      ty::ty_str { step(bcx, \"visit_str\", []) }\n \n-          ty::ty_vec(mt) {\n-            let bcx = step(bcx, \"visit_vec_of\",\n-                           [C_uint(ccx, mt.mutbl as uint)]);\n-            sub(bcx, mt.ty)\n-          }\n+      ty::ty_vec(mt) {\n+        let bcx = step(bcx, \"visit_vec_of\",\n+                       [C_uint(ccx, mt.mutbl as uint)]);\n+        sub(bcx, mt.ty)\n+      }\n \n       _ {\n-        bcx.sess().unimpl(\"trans::reflect::visit_ty_args on \"\n-                          + ty_to_str(bcx.ccx().tcx, t));\n+        // Ideally this would be an unimpl, but sadly we have\n+        // to pretend we can visit everything at this point.\n+        step(bcx, \"visit_bot\", [])\n       }\n     }\n }"}, {"sha": "6d6848336d49ca5a4fcfec154c02299a6c3c865a", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -13,9 +13,9 @@ import tstate::ann::{pre_and_post, pre_and_post_state, empty_ann, prestate,\n                      set_postcondition, ts_ann,\n                      clear_in_postcond,\n                      clear_in_poststate_};\n-import tritv::*;\n-import bitvectors::promises_;\n import driver::session::session;\n+import dvec::{dvec, extensions};\n+import tritv::{dont_care, tfalse, tritv_get, ttrue};\n \n import syntax::print::pprust::{constr_args_to_str, lit_to_str};\n \n@@ -197,7 +197,7 @@ type constraint = {\n     path: @path,\n     // FIXME: really only want it to be mut during collect_locals.\n     // freeze it after that.\n-    descs: @mut [pred_args]\n+    descs: @dvec<pred_args>\n };\n \n type tsconstr = {\n@@ -473,8 +473,7 @@ fn node_id_to_def(ccx: crate_ctxt, id: node_id) -> option<def> {\n \n fn norm_a_constraint(id: def_id, c: constraint) -> [norm_constraint] {\n     let mut rslt: [norm_constraint] = [];\n-    let descs = *c.descs;\n-    for vec::each(descs) {|pd|\n+    for (*c.descs).each {|pd|\n         rslt +=\n             [{bit_num: pd.node.bit_num,\n               c: respan(pd.span, {path: c.path,\n@@ -498,11 +497,11 @@ fn constraints(fcx: fn_ctxt) -> [norm_constraint] {\n // FIXME\n // Would rather take an immutable vec as an argument,\n // should freeze it at some earlier point.\n-fn match_args(fcx: fn_ctxt, occs: @mut [pred_args],\n+fn match_args(fcx: fn_ctxt, occs: @dvec<pred_args>,\n               occ: [@constr_arg_use]) -> uint {\n     #debug(\"match_args: looking at %s\",\n            constr_args_to_str(fn@(i: inst) -> str { ret i.ident; }, occ));\n-    for vec::each(*occs) {|pd|\n+    for (*occs).each {|pd|\n         log(debug,\n                  \"match_args: candidate \" + pred_args_to_str(pd));\n         fn eq(p: inst, q: inst) -> bool { ret p.node == q.node; }\n@@ -613,7 +612,8 @@ fn substitute_arg(cx: ty::ctxt, actuals: [@expr], a: @constr_arg) ->\n     }\n }\n \n-fn pred_args_matches(pattern: [constr_arg_general_<inst>], desc: pred_args) ->\n+fn pred_args_matches(pattern: [constr_arg_general_<inst>],\n+                     desc: pred_args) ->\n    bool {\n     let mut i = 0u;\n     for desc.node.args.each {|c|\n@@ -638,7 +638,8 @@ fn pred_args_matches(pattern: [constr_arg_general_<inst>], desc: pred_args) ->\n     ret true;\n }\n \n-fn find_instance_(pattern: [constr_arg_general_<inst>], descs: [pred_args]) ->\n+fn find_instance_(pattern: [constr_arg_general_<inst>],\n+                  descs: [pred_args]) ->\n    option<uint> {\n     for descs.each {|d|\n         if pred_args_matches(pattern, d) { ret some(d.node.bit_num); }\n@@ -660,15 +661,19 @@ fn find_instances(_fcx: fn_ctxt, subst: subst,\n \n     if vec::len(subst) == 0u { ret []; }\n     let mut res = [];\n-    for (*c.descs).each { |d|\n-        if args_mention(d.node.args, find_in_subst_bool, subst) {\n-            let old_bit_num = d.node.bit_num;\n-            let newv = replace(subst, d);\n-            alt find_instance_(newv, *c.descs) {\n-              some(d1) {res += [{from: old_bit_num, to: d1}]}\n-              _ {}\n-            }\n-        } else {}\n+    (*c.descs).swap { |v|\n+        let v <- vec::from_mut(v);\n+        for v.each { |d|\n+            if args_mention(d.node.args, find_in_subst_bool, subst) {\n+                let old_bit_num = d.node.bit_num;\n+                let newv = replace(subst, d);\n+                alt find_instance_(newv, v) {\n+                  some(d1) {res += [{from: old_bit_num, to: d1}]}\n+                  _ {}\n+                }\n+            } else {}\n+        }\n+        vec::to_mut(v)\n     }\n     ret res;\n }\n@@ -811,7 +816,7 @@ fn copy_in_poststate_two(fcx: fn_ctxt, src_post: poststate,\n         // dest def_id\n         let insts = find_instances(fcx, subst, val);\n         for insts.each {|p|\n-            if promises_(p.from, src_post) {\n+            if bitvectors::promises_(p.from, src_post) {\n                 set_in_poststate_(p.to, target_post);\n             }\n         }\n@@ -897,12 +902,6 @@ fn args_mention<T>(args: [@constr_arg_use],\n \n fn use_var(fcx: fn_ctxt, v: node_id) { *fcx.enclosing.used_vars += [v]; }\n \n-// FIXME: This should be a function in vec::.\n-fn vec_contains(v: @mut [node_id], i: node_id) -> bool {\n-    for vec::each(*v) {|d| if d == i { ret true; } }\n-    ret false;\n-}\n-\n fn op_to_oper_ty(io: init_op) -> oper_type {\n     alt io { init_move { oper_move } _ { oper_assign } }\n }"}, {"sha": "0d3ab5321df3d6ba575dc966caf00d76ab7356bf", "filename": "src/rustc/middle/tstate/collect_locals.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -8,6 +8,7 @@ import syntax::ast_util::respan;\n import driver::session::session;\n import aux::*;\n import std::map::hashmap;\n+import dvec::{dvec, extensions};\n \n type ctxt = {cs: @mut [sp_constr], tcx: ty::ctxt};\n \n@@ -57,12 +58,11 @@ fn add_constraint(tcx: ty::ctxt, c: sp_constr, next: uint, tbl: constr_map) ->\n     let {path: p, def_id: d_id, args: args} = c.node;\n     alt tbl.find(d_id) {\n       some(ct) {\n-        let {path: _, descs: pds} = ct;\n-        *pds += [respan(c.span, {args: args, bit_num: next})];\n+        (*ct.descs).push(respan(c.span, {args: args, bit_num: next}));\n       }\n       none {\n-        let rslt: @mut [pred_args] =\n-            @mut [respan(c.span, {args: args, bit_num: next})];\n+        let rslt = @dvec();\n+        (*rslt).push(respan(c.span, {args: args, bit_num: next}));\n         tbl.insert(d_id, {path:p, descs:rslt});\n       }\n     }"}, {"sha": "ca70c7d70a62dbbdf696d69e8acb714b9cab0ae7", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -4,19 +4,19 @@ import std::map::hashmap;\n import driver::session;\n import session::session;\n import syntax::{ast, ast_map};\n-import syntax::ast::*;\n import syntax::ast_util;\n import syntax::ast_util::{is_local, local_def, split_class_items,\n                           new_def_hash};\n import syntax::codemap::span;\n import metadata::csearch;\n-import util::common::*;\n import util::ppaux::region_to_str;\n import util::ppaux::vstore_to_str;\n import util::ppaux::{ty_to_str, tys_to_str, ty_constr_to_str};\n-import syntax::print::pprust::*;\n import middle::lint::{get_warning_level, vecs_not_implicitly_copyable,\n                       ignore};\n+import syntax::ast::*;\n+import syntax::print::pprust::*;\n+\n export ty_vid, region_vid, vid;\n export br_hashmap;\n export is_instantiable;\n@@ -63,7 +63,6 @@ export mt;\n export node_type_table;\n export pat_ty;\n export sequence_element_type;\n-export sort_methods;\n export stmt_node_id;\n export sty;\n export subst, subst_tps, substs_is_noop, substs_to_str, substs;\n@@ -2311,13 +2310,6 @@ fn method_idx(id: ast::ident, meths: [method]) -> option<uint> {\n     ret none;\n }\n \n-fn sort_methods(meths: [method]) -> [method] {\n-    fn method_lteq(a: method, b: method) -> bool {\n-        ret str::le(a.ident, b.ident);\n-    }\n-    ret std::sort::merge_sort(bind method_lteq(_, _), meths);\n-}\n-\n fn occurs_check(tcx: ctxt, sp: span, vid: ty_vid, rt: t) {\n     // Fast path\n     if !type_needs_infer(rt) { ret; }"}, {"sha": "476ef9d3ba55143dc723fa73330183c37f5db3c8", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -45,7 +45,8 @@ an rptr (`&r.T`) use the region `r` that appears in the rptr.\n \"];\n \n import check::fn_ctxt;\n-import rscope::*;\n+import rscope::{anon_rscope, binding_rscope, empty_rscope, in_anon_rscope};\n+import rscope::{in_binding_rscope, region_scope, type_rscope};\n \n iface ast_conv {\n     fn tcx() -> ty::ctxt;"}, {"sha": "b3f7c5a938856ad2e6ef9fb8048929c7ffb8e456", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -71,7 +71,8 @@ import collect::{methods}; // ccx.to_ty()\n import method::{methods};  // methods for method::lookup\n import middle::ty::tys_in_fn_ty;\n import regionmanip::{replace_bound_regions_in_fn_ty, region_of};\n-import rscope::*;\n+import rscope::{anon_rscope, binding_rscope, empty_rscope, in_anon_rscope};\n+import rscope::{in_binding_rscope, region_scope, type_rscope};\n \n type fn_ctxt =\n     // var_bindings, locals and next_var_id are shared\n@@ -386,6 +387,12 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n           };\n           // typecheck the members\n           for members.each {|m| check_class_member(class_ccx, class_t, m); }\n+          // Check that there's at least one field\n+          let (fields,_) = split_class_items(members);\n+          if fields.len() < 1u {\n+              ccx.tcx.sess.span_err(it.span, \"A class must have at least one \\\n+                field\");\n+          }\n           // Check that the class is instantiable\n           check_instantiable(ccx.tcx, it.span, it.id);\n       }"}, {"sha": "e81bd9d35478076ae98764e273397441bb3d40ac", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -369,31 +369,23 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n         let t_ctor =\n             ty::mk_fn(\n                 tcx,\n-                ty_of_fn_decl(ccx,\n-                                       empty_rscope,\n-                                       ast::proto_any,\n-                                       ctor.node.dec,\n-                                       none));\n+                ty_of_fn_decl(ccx, type_rscope(rp), ast::proto_any,\n+                              ctor.node.dec, none));\n         write_ty_to_tcx(tcx, ctor.node.id, t_ctor);\n         tcx.tcache.insert(local_def(ctor.node.id),\n                           {bounds: tpt.bounds,\n-                           rp: ast::rp_none,\n+                           rp: rp,\n                            ty: t_ctor});\n         option::iter(m_dtor) {|dtor|\n             // Write the dtor type\n             let t_dtor = ty::mk_fn(\n                 tcx,\n-                // not sure about empty_rscope\n-                // FIXME\n-                ty_of_fn_decl(ccx,\n-                                       empty_rscope,\n-                                       ast::proto_any,\n-                                       ast_util::dtor_dec(),\n-                                       none));\n+                ty_of_fn_decl(ccx, type_rscope(rp), ast::proto_any,\n+                              ast_util::dtor_dec(), none));\n             write_ty_to_tcx(tcx, dtor.node.id, t_dtor);\n             tcx.tcache.insert(local_def(dtor.node.id),\n                               {bounds: tpt.bounds,\n-                               rp: ast::rp_none,\n+                               rp: rp,\n                                ty: t_dtor});\n         };\n         ensure_iface_methods(ccx, it.id);"}, {"sha": "c5c445702d517f1074550f478c0fb4ab85d18a75", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -1,6 +1,14 @@\n import std::map::hashmap;\n import middle::ty;\n-import middle::ty::*;\n+import middle::ty::{arg, bound_region, br_anon, br_named, canon_mode};\n+import middle::ty::{ck_block, ck_box, ck_uniq, constr, ctxt, field, method};\n+import middle::ty::{mt, re_bound, re_free, re_scope, re_var, region, t};\n+import middle::ty::{ty_bool, ty_bot, ty_box, ty_class, ty_constr, ty_enum};\n+import middle::ty::{ty_estr, ty_evec, ty_float, ty_fn, ty_iface, ty_int};\n+import middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n+import middle::ty::{ty_ptr, ty_rec, ty_res, ty_rptr, ty_self, ty_str, ty_tup};\n+import middle::ty::{ty_type, ty_uniq, ty_uint, ty_var, ty_var_integral};\n+import middle::ty::{ty_vec, vid};\n import metadata::encoder;\n import syntax::codemap;\n import syntax::print::pprust;"}, {"sha": "7b6938e6133e53deb202176fdcb9ed64077c691c", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -6,6 +6,14 @@ S 2012-06-06 db31969\n   macos-x86_64 bd99c6745ae0b41b2ac749fdc58fe76a3ccb50a6\n   macos-i386 cba5620bbfe9195917799dd02fac5b9e2be997cd\n \n+S 2012-06-05 fec3b91\n+  winnt-i386 36348a2b016f25d9e3b7e1a8814a352c18123839\n+  linux-x86_64 7308f0eb3d6a9985c14dfbbde7e1f9eb901cc966\n+  linux-i386 d4c1e1733fd30945f96ae67dbc10289f2a9ec380\n+  freebsd-x86_64 d0ee6054d7d8320d64aa4dbb9b041537fa2665d5\n+  macos-x86_64 652501172b4fee6631f595c90538fd95914ef444\n+  macos-i386 5c54b5ecf54cc2631fdd48caa326ab44b5a2e494\n+\n S 2012-06-04 7213274\n   winnt-i386 94b9414433fd83c086b349ded3159f0541aace16\n   linux-x86_64 eb9cf0de4cc09e8b8bfcf741eff4b20510e13a5b"}, {"sha": "87ab9bbcfea33cc10609cad938ee3437c0317902", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -1,29 +1,29 @@\n-type alist<A,B> = { eq_fn: fn@(A,A) -> bool, mut data: [(A,B)] };\n+import dvec::{dvec,extensions};\n+\n+type entry<A,B> = {key: A, value: B};\n+type alist<A,B> = { eq_fn: fn@(A,A) -> bool, data: dvec<entry<A,B>> };\n \n fn alist_add<A: copy, B: copy>(lst: alist<A,B>, k: A, v: B) {\n-    lst.data += [(k, v)];\n+    lst.data.push({key:k, value:v});\n }\n \n fn alist_get<A: copy, B: copy>(lst: alist<A,B>, k: A) -> B {\n     let eq_fn = lst.eq_fn;\n-    for lst.data.each {|pair|\n-        let (ki, vi) = pair; // copy req'd for alias analysis\n-        if eq_fn(k, ki) { ret vi; }\n+    for lst.data.each {|entry|\n+        if eq_fn(entry.key, k) { ret entry.value; }\n     }\n     fail;\n }\n \n #[inline]\n fn new_int_alist<B: copy>() -> alist<int, B> {\n     fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n-    ret {eq_fn: eq_int,\n-         mut data: []};\n+    ret {eq_fn: eq_int, data: dvec()};\n }\n \n #[inline]\n fn new_int_alist_2<B: copy>() -> alist<int, B> {\n     #[inline]\n     fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n-    ret {eq_fn: eq_int,\n-         mut data: []};\n+    ret {eq_fn: eq_int, data: dvec()};\n }\n\\ No newline at end of file"}, {"sha": "a1438c5318762172df93368e1b14e44c7192105c", "filename": "src/test/compile-fail/issue-2487-b.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Fcompile-fail%2Fissue-2487-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Fcompile-fail%2Fissue-2487-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2487-b.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -0,0 +1,19 @@\n+class socket {\n+    let sock: int;\n+\n+    new() { self.sock = 1; }\n+\n+    drop { }\n+\n+    fn set_identity()  {\n+      closure { ||\n+        setsockopt_bytes(self.sock) //! ERROR copying a noncopyable value\n+      } \n+    }\n+}\n+\n+fn closure(f: fn@()) { f() }\n+\n+fn setsockopt_bytes(+_sock: int) { }\n+\n+fn main() {}"}, {"sha": "a500d249c07a8aa0071d35868d01090e788f32cb", "filename": "src/test/compile-fail/issue-2509-a.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Fcompile-fail%2Fissue-2509-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Fcompile-fail%2Fissue-2509-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2509-a.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -0,0 +1,9 @@\n+class c { //! ERROR A class must have at least one field\n+    new() { }\n+}\n+\n+fn main() {\n+    let a = c();\n+    let x = [a];\n+    let _y = x[0];\n+}"}, {"sha": "40d25a375668094e1bc95d18b6cad4054c716943", "filename": "src/test/compile-fail/issue-511.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-511.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -8,4 +8,8 @@ fn f<T>(&o: option<T>) {\n fn main() {\n     f::<int>(option::none);\n     //!^ ERROR taking mut reference to static item\n+\n+    // Additional errors reported by borrowck:\n+    //^^ ERROR illegal borrow unless pure: creating mutable alias to aliasable, immutable memory\n+    //^^^ NOTE impure due to access to impure function\n }\n\\ No newline at end of file"}, {"sha": "736fee0f66cb9e2ef575fe09974b9e0706f787de", "filename": "src/test/compile-fail/noncopyable-class.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -3,14 +3,15 @@\n // Test that a class with a non-copyable field can't be\n // copied\n class bar {\n-  new() {}\n+  let x: int;\n+  new(x:int) {self.x = x;}\n   drop {}\n }\n \n class foo {\n   let i: int;\n   let j: bar;\n-  new(i:int) { self.i = i; self.j = bar(); }\n+  new(i:int) { self.i = i; self.j = bar(5); }\n }\n \n fn main() { let x <- foo(10); let y = x; log(error, x); }"}, {"sha": "c62db9b8fff2a123eca35dd352134f50dc3e1648", "filename": "src/test/compile-fail/regions-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -4,7 +4,7 @@\n \n enum an_enum/& { }\n iface an_iface/& { }\n-class a_class/& { new() { } }\n+class a_class/& { let x:int; new(x:int) { self.x = x; } }\n \n fn a_fn1(e: an_enum/&a) -> an_enum/&b {\n     ret e; //! ERROR mismatched types: expected `an_enum/&b` but found `an_enum/&a`"}, {"sha": "f6388b19798393e114e1ae9bcb5fdb33fcf41883", "filename": "src/test/compile-fail/vec-res-add.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -1,7 +1,8 @@\n // error-pattern: copying a noncopyable value\n \n class r {\n-  new(_i:int) {}\n+  let i:int;\n+  new(i:int) {self.i = i;}\n   drop {}\n }\n "}, {"sha": "215fd53ce5edddbdd905c3a792d68ec82fc7d90c", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-2.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -0,0 +1,17 @@\n+// xfail-test\n+// error-pattern:bounds check\n+\n+fn main() {\n+    let x = [1u,2u,3u];\n+\n+    // This should cause a bounds-check failure, but may not if we do our\n+    // bounds checking by comparing a scaled index value to the vector's\n+    // length (in bytes), because the scaling of the index will cause it to\n+    // wrap around to a small number.\n+\n+    let idx = uint::max_value & !(uint::max_value >> 1u);\n+    #error(\"ov2 idx = 0x%x\", idx);\n+\n+    // This should fail.\n+    #error(\"ov2 0x%x\",  x[idx]);\n+}\n\\ No newline at end of file"}, {"sha": "26737f8a9fab81032f4b13f235da952ee070784e", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow-3.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-3.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -0,0 +1,28 @@\n+// xfail-test\n+// error-pattern:bounds check\n+\n+#[cfg(target_arch=\"x86\")]\n+fn main() {\n+    let x = [1u,2u,3u];\n+\n+    // This should cause a bounds-check failure, but may not if we do our\n+    // bounds checking by truncating the index value to the size of the\n+    // machine word, losing relevant bits of the index value.\n+\n+    // This test is only meaningful on 32-bit hosts.\n+\n+    let idx = u64::max_value & !(u64::max_value >> 1u);\n+    #error(\"ov3 idx = 0x%8.8x%8.8x\",\n+           (idx >> 32) as uint,\n+           idx as uint);\n+\n+    // This should fail.\n+    #error(\"ov3 0x%x\",  x[idx]);\n+}\n+\n+#[cfg(target_arch=\"x86_64\")]\n+fn main() {\n+    // This version just fails anyways, for symmetry on 64-bit hosts.\n+    let x = [1u,2u,3u];\n+    #error(\"ov3 0x%x\",  x[200]);\n+}"}, {"sha": "84bd9ab5c76eeed25723afb5d5dfac8c9f7a1760", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -0,0 +1,24 @@\n+// error-pattern:bounds check\n+\n+fn main() {\n+\n+    // This should cause a bounds-check failure, but may not if we do our\n+    // bounds checking by comparing the scaled index to the vector's\n+    // address-bounds, since we've scaled the index to wrap around to the\n+    // address of the 0th cell in the array (even though the index is\n+    // huge).\n+\n+    let x = [1u,2u,3u];\n+    vec::unpack_slice(x) {|p, _len|\n+        let base = p as uint;                     // base = 0x1230 say\n+        let idx = base / sys::size_of::<uint>();  // idx  = 0x0246 say\n+        #error(\"ov1 base = 0x%x\", base);\n+        #error(\"ov1 idx = 0x%x\", idx);\n+        #error(\"ov1 sizeof::<uint>() = 0x%x\", sys::size_of::<uint>());\n+        #error(\"ov1 idx * sizeof::<uint>() = 0x%x\",\n+               idx * sys::size_of::<uint>());\n+\n+        // This should fail.\n+        #error(\"ov1 0x%x\",  x[idx]);\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "d68e9c49789563c7107cfd541fc969ffba23a875", "filename": "src/test/run-fail/morestack2.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-fail%2Fmorestack2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-fail%2Fmorestack2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmorestack2.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -21,7 +21,8 @@ fn getbig_call_c_and_fail(i: int) {\n }\n \n class and_then_get_big_again {\n-  new() {}\n+  let x:int;\n+  new(x:int) {self.x = x;}\n   drop {\n     fn getbig(i: int) {\n         if i != 0 {\n@@ -34,7 +35,7 @@ class and_then_get_big_again {\n \n fn main() {\n     task::spawn {||\n-        let r = and_then_get_big_again();\n+        let r = and_then_get_big_again(4);\n         getbig_call_c_and_fail(10000);\n     };\n }\n\\ No newline at end of file"}, {"sha": "0f0aea5ccd122a2d606929bfd26d3ddd0f1defcb", "filename": "src/test/run-fail/morestack3.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-fail%2Fmorestack3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-fail%2Fmorestack3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmorestack3.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -5,7 +5,7 @@\n use std;\n \n fn getbig_and_fail(&&i: int) {\n-    let _r = and_then_get_big_again();\n+    let _r = and_then_get_big_again(5);\n     if i != 0 {\n         getbig_and_fail(i - 1);\n     } else {\n@@ -14,7 +14,8 @@ fn getbig_and_fail(&&i: int) {\n }\n \n class and_then_get_big_again {\n-  new() {}\n+  let x:int;\n+  new(x:int) {self.x = x;}\n   drop {\n     fn getbig(i: int) {\n         if i != 0 {"}, {"sha": "b1c86d5110a9a260abf6f4630d5a433c4126bbe1", "filename": "src/test/run-fail/morestack4.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-fail%2Fmorestack4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-fail%2Fmorestack4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmorestack4.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -5,7 +5,7 @@\n use std;\n \n fn getbig_and_fail(&&i: int) {\n-    let r = and_then_get_big_again();\n+    let r = and_then_get_big_again(5);\n     if i != 0 {\n         getbig_and_fail(i - 1);\n     } else {\n@@ -14,7 +14,8 @@ fn getbig_and_fail(&&i: int) {\n }\n \n class and_then_get_big_again {\n-  new() {}\n+  let x:int;\n+  new(x:int) {self.x = x;}\n   drop {}\n }\n "}, {"sha": "2c2665446cdf4f7f362be0c118c98063fcb7c0a0", "filename": "src/test/run-fail/rt-set-exit-status-fail2.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-fail%2Frt-set-exit-status-fail2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-fail%2Frt-set-exit-status-fail2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status-fail2.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -1,19 +1,20 @@\n // error-pattern:whatever\n \n class r {\n+  let x:int;\n             // Setting the exit status after the runtime has already\n             // failed has no effect and the process exits with the\n             // runtime's exit code\n   drop {\n     os::set_exit_status(50);\n   }\n-  new() {}\n+  new(x:int) {self.x = x;}\n }\n \n fn main() {\n     log(error, \"whatever\");\n     task::spawn {||\n-      let i = r();\n+      let i = r(5);\n     };\n     fail;\n }\n\\ No newline at end of file"}, {"sha": "0af65bd18270f5e6fda2a8c9da5a85fc0b9b188e", "filename": "src/test/run-pass/alt-pattern-drop.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -25,8 +25,10 @@ fn foo(s: @int) {\n fn main() {\n     let s: @int = @0; // ref up\n \n+    let count = dbg::refcount(s);\n+\n     foo(s); // ref up then down\n \n     log(debug, dbg::refcount(s));\n-    assert (dbg::refcount(s) == 1u);\n+    assert (dbg::refcount(s) == count);\n }"}, {"sha": "1a8f777767205d84d9b5f16f6de9637788ce0544", "filename": "src/test/run-pass/class-implements-multiple-ifaces.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-ifaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-ifaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-ifaces.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -1,6 +1,7 @@\n use std;\n import std::map::*;\n import vec::*;\n+import dvec::{dvec, extensions};\n \n enum furniture { chair, couch, bed }\n enum body_part { finger, toe, nose, ear }\n@@ -26,7 +27,7 @@ fn vec_includes<T>(xs: [T], x: T) -> bool {\n class cat implements noisy, scratchy, bitey {\n   priv {\n     let meows : @mut uint;\n-    let scratched : @mut [furniture];\n+    let scratched : dvec<furniture>;\n     let bite_counts : hashmap<body_part, uint>;\n \n     fn meow() -> uint {\n@@ -44,7 +45,7 @@ class cat implements noisy, scratchy, bitey {\n \n   new(in_x : uint, in_y : int, in_name: str)\n     { self.meows = @mut in_x; self.how_hungry = @mut in_y;\n-      self.name = in_name; self.scratched = @mut [];\n+      self.name = in_name; self.scratched = dvec();\n       let hsher: hashfn<body_part> =\n         fn@(p: body_part) -> uint { int::hash(p as int) };\n       let eqer : eqfn<body_part> =\n@@ -61,10 +62,10 @@ class cat implements noisy, scratchy, bitey {\n   fn meow_count() -> uint { *self.meows }\n   fn scratch() -> option<furniture> {\n     let all = [chair, couch, bed];\n-    log(error, *(self.scratched));\n+    log(error, self.scratched);\n     let mut rslt = none;\n-    for each(all) {|thing| if !vec_includes(*(self.scratched), thing) {\n-          *self.scratched += [thing];\n+    for each(all) {|thing| if !self.scratched.contains(thing) {\n+          self.scratched.push(thing);\n           ret some(thing); }}\n     rslt\n   }"}, {"sha": "2b64840d8301f4ac20350fe5445ebb62c1efcfac", "filename": "src/test/run-pass/conditional-compile.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-pass%2Fconditional-compile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-pass%2Fconditional-compile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconditional-compile.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -26,11 +26,13 @@ enum tg { bar, }\n \n #[cfg(bogus)]\n class r {\n-  new(i:int) {}\n+  let i: int;\n+  new(i:int) { self.i = i; }\n }\n \n class r {\n-  new(i:int) {}\n+  let i: int;\n+  new(i:int) { self.i = i; }\n }\n \n #[cfg(bogus)]"}, {"sha": "1377bb2a279010dc933f5436fd36b21bbd492d3d", "filename": "src/test/run-pass/iface-cast.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-pass%2Fiface-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-pass%2Fiface-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiface-cast.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -26,10 +26,9 @@ impl of to_str for int {\n \n impl of to_str for Tree {\n     fn to_str() -> str {\n-        #fmt[\"[%s, %s, %s]\",\n-             self.val.to_str(),\n-             self.left.to_str(),\n-             self.right.to_str()]\n+        let l = self.left, r = self.right;\n+        #fmt[\"[%s, %s, %s]\", self.val.to_str(),\n+             l.to_str(), r.to_str()]\n     }\n }\n "}, {"sha": "ab1d9ccb3bea77c9956ced49da45bef2c9e66f5b", "filename": "src/test/run-pass/issue-2487-a.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-pass%2Fissue-2487-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-pass%2Fissue-2487-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2487-a.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -0,0 +1,19 @@\n+class socket {\n+    let sock: int;\n+\n+    new() { self.sock = 1; }\n+\n+    drop { }\n+\n+    fn set_identity()  {\n+        closure { ||\n+            setsockopt_bytes(copy self.sock)\n+        }\n+    }\n+}\n+\n+fn closure(f: fn()) { f() }\n+\n+fn setsockopt_bytes(_sock: int) { }\n+\n+fn main() {}"}, {"sha": "6aa35169dd5c861ab5e57e0ca97de29012baede9", "filename": "src/test/run-pass/issue-2502.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-pass%2Fissue-2502.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-pass%2Fissue-2502.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2502.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -0,0 +1,13 @@\n+class font/& {\n+    let fontbuf: &self.[u8];\n+\n+    new(fontbuf: &self.[u8]) {\n+        self.fontbuf = fontbuf;\n+    }\n+\n+    fn buf() -> &self.[u8] {\n+        self.fontbuf\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "4f305ff837880fba854294d463425517404c952b", "filename": "src/test/run-pass/maybe-mutable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n fn len(v: [const int]) -> uint {\n     let mut i = 0u;\n-    for v.each {|x| i += 1u; }\n+    while i < vec::len(v) { i += 1u; }\n     ret i;\n }\n "}, {"sha": "4b92e518b2e49ddc0a1d8296b22c212e97c8989d", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd02046de4c29878b38c5c9751fd80fbe8ecc8ee/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=cd02046de4c29878b38c5c9751fd80fbe8ecc8ee", "patch": "@@ -1,7 +1,3 @@\n-// xfail-test\n-//\n-// This doesn't work quite yet in check-fast mode. Not sure why. Crashes.\n-\n enum my_visitor = @{ mut types: [str] };\n \n impl of intrinsic::ty_visitor for my_visitor {"}]}