{"sha": "0459aca41a31213f18471aeafe246cd20cc846e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0NTlhY2E0MWEzMTIxM2YxODQ3MWFlYWZlMjQ2Y2QyMGNjODQ2ZTk=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-11-21T04:50:13Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-11-21T15:18:56Z"}, "message": "Get rid of some doctree items\n\nThey can be derived directly from the `hir::Item`, there's no special\nlogic.\n\n- TypeDef\n- OpaqueTy\n- Constant\n- Static\n- TraitAlias\n- Enum\n- Union\n- Struct", "tree": {"sha": "9b583dd6a2cda317f9fef3e18ae4e87ff428a3be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b583dd6a2cda317f9fef3e18ae4e87ff428a3be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0459aca41a31213f18471aeafe246cd20cc846e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0459aca41a31213f18471aeafe246cd20cc846e9", "html_url": "https://github.com/rust-lang/rust/commit/0459aca41a31213f18471aeafe246cd20cc846e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0459aca41a31213f18471aeafe246cd20cc846e9/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "593fe977a77ad5a7aec23c6cb0f86a3470221670", "url": "https://api.github.com/repos/rust-lang/rust/commits/593fe977a77ad5a7aec23c6cb0f86a3470221670", "html_url": "https://github.com/rust-lang/rust/commit/593fe977a77ad5a7aec23c6cb0f86a3470221670"}], "stats": {"total": 352, "additions": 71, "deletions": 281}, "files": [{"sha": "5bc30357f62a5a6c772597452b5fd3ee312f9deb", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 60, "deletions": 121, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/0459aca41a31213f18471aeafe246cd20cc846e9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459aca41a31213f18471aeafe246cd20cc846e9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0459aca41a31213f18471aeafe246cd20cc846e9", "patch": "@@ -231,21 +231,14 @@ impl Clean<Item> for doctree::Module<'_> {\n         let mut items: Vec<Item> = vec![];\n         items.extend(self.extern_crates.iter().flat_map(|x| x.clean(cx)));\n         items.extend(self.imports.iter().flat_map(|x| x.clean(cx)));\n-        items.extend(self.structs.iter().map(|x| x.clean(cx)));\n-        items.extend(self.unions.iter().map(|x| x.clean(cx)));\n-        items.extend(self.enums.iter().map(|x| x.clean(cx)));\n         items.extend(self.fns.iter().map(|x| x.clean(cx)));\n         items.extend(self.foreigns.iter().map(|x| x.clean(cx)));\n         items.extend(self.mods.iter().map(|x| x.clean(cx)));\n-        items.extend(self.typedefs.iter().map(|x| x.clean(cx)));\n-        items.extend(self.opaque_tys.iter().map(|x| x.clean(cx)));\n-        items.extend(self.statics.iter().map(|x| x.clean(cx)));\n-        items.extend(self.constants.iter().map(|x| x.clean(cx)));\n+        items.extend(self.items.iter().map(|x| x.clean(cx)));\n         items.extend(self.traits.iter().map(|x| x.clean(cx)));\n         items.extend(self.impls.iter().flat_map(|x| x.clean(cx)));\n         items.extend(self.macros.iter().map(|x| x.clean(cx)));\n         items.extend(self.proc_macros.iter().map(|x| x.clean(cx)));\n-        items.extend(self.trait_aliases.iter().map(|x| x.clean(cx)));\n \n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n@@ -1020,20 +1013,6 @@ impl Clean<Item> for doctree::Trait<'_> {\n     }\n }\n \n-impl Clean<Item> for doctree::TraitAlias<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item::from_hir_id_and_parts(\n-            self.id,\n-            Some(self.name),\n-            TraitAliasItem(TraitAlias {\n-                generics: self.generics.clean(cx),\n-                bounds: self.bounds.clean(cx),\n-            }),\n-            cx,\n-        )\n-    }\n-}\n-\n impl Clean<bool> for hir::IsAuto {\n     fn clean(&self, _: &DocContext<'_>) -> bool {\n         match *self {\n@@ -1777,38 +1756,6 @@ impl Clean<Visibility> for ty::Visibility {\n     }\n }\n \n-impl Clean<Item> for doctree::Struct<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item::from_hir_id_and_parts(\n-            self.id,\n-            Some(self.name),\n-            StructItem(Struct {\n-                struct_type: self.struct_type,\n-                generics: self.generics.clean(cx),\n-                fields: self.fields.clean(cx),\n-                fields_stripped: false,\n-            }),\n-            cx,\n-        )\n-    }\n-}\n-\n-impl Clean<Item> for doctree::Union<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item::from_hir_id_and_parts(\n-            self.id,\n-            Some(self.name),\n-            UnionItem(Union {\n-                struct_type: self.struct_type,\n-                generics: self.generics.clean(cx),\n-                fields: self.fields.clean(cx),\n-                fields_stripped: false,\n-            }),\n-            cx,\n-        )\n-    }\n-}\n-\n impl Clean<VariantStruct> for rustc_hir::VariantData<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> VariantStruct {\n         VariantStruct {\n@@ -1819,21 +1766,6 @@ impl Clean<VariantStruct> for rustc_hir::VariantData<'_> {\n     }\n }\n \n-impl Clean<Item> for doctree::Enum<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item::from_hir_id_and_parts(\n-            self.id,\n-            Some(self.name),\n-            EnumItem(Enum {\n-                variants: self.variants.iter().map(|v| v.clean(cx)).collect(),\n-                generics: self.generics.clean(cx),\n-                variants_stripped: false,\n-            }),\n-            cx,\n-        )\n-    }\n-}\n-\n impl Clean<Item> for doctree::Variant<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let what_rustc_thinks = Item::from_hir_id_and_parts(\n@@ -1981,33 +1913,6 @@ impl Clean<String> for Symbol {\n     }\n }\n \n-impl Clean<Item> for doctree::Typedef<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let type_ = self.ty.clean(cx);\n-        let item_type = type_.def_id().and_then(|did| inline::build_ty(cx, did));\n-        Item::from_hir_id_and_parts(\n-            self.id,\n-            Some(self.name),\n-            TypedefItem(Typedef { type_, generics: self.gen.clean(cx), item_type }, false),\n-            cx,\n-        )\n-    }\n-}\n-\n-impl Clean<Item> for doctree::OpaqueTy<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item::from_hir_id_and_parts(\n-            self.id,\n-            Some(self.name),\n-            OpaqueTyItem(OpaqueTy {\n-                bounds: self.opaque_ty.bounds.clean(cx),\n-                generics: self.opaque_ty.generics.clean(cx),\n-            }),\n-            cx,\n-        )\n-    }\n-}\n-\n impl Clean<BareFunctionDecl> for hir::BareFnTy<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> BareFunctionDecl {\n         let (generic_params, decl) = enter_impl_trait(cx, || {\n@@ -2017,37 +1922,71 @@ impl Clean<BareFunctionDecl> for hir::BareFnTy<'_> {\n     }\n }\n \n-impl Clean<Item> for doctree::Static<'_> {\n+impl Clean<Item> for hir::Item<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        debug!(\"cleaning static {}: {:?}\", self.name.clean(cx), self);\n-        Item::from_hir_id_and_parts(\n-            self.id,\n-            Some(self.name),\n-            StaticItem(Static {\n-                type_: self.type_.clean(cx),\n-                mutability: self.mutability,\n-                expr: print_const_expr(cx, self.expr),\n+        use hir::ItemKind;\n+\n+        let def_id = cx.tcx.hir().local_def_id(self.hir_id).to_def_id();\n+        let name = cx.tcx.hir().name(self.hir_id);\n+        let kind = match self.kind {\n+            ItemKind::Static(ty, mutability, body_id) => StaticItem(Static {\n+                type_: ty.clean(cx),\n+                mutability,\n+                expr: print_const_expr(cx, body_id),\n             }),\n-            cx,\n-        )\n+            ItemKind::Const(ty, body_id) => ConstantItem(Constant {\n+                type_: ty.clean(cx),\n+                expr: print_const_expr(cx, body_id),\n+                value: print_evaluated_const(cx, def_id),\n+                is_literal: is_literal_expr(cx, body_id.hir_id),\n+            }),\n+            ItemKind::OpaqueTy(ref ty) => OpaqueTyItem(OpaqueTy {\n+                bounds: ty.bounds.clean(cx),\n+                generics: ty.generics.clean(cx),\n+            }),\n+            ItemKind::TyAlias(ty, ref generics) => {\n+                let rustdoc_ty = ty.clean(cx);\n+                let item_type = rustdoc_ty.def_id().and_then(|did| inline::build_ty(cx, did));\n+                TypedefItem(\n+                    Typedef { type_: rustdoc_ty, generics: generics.clean(cx), item_type },\n+                    false,\n+                )\n+            }\n+            ItemKind::Enum(ref def, ref generics) => EnumItem(Enum {\n+                variants: def.variants.iter().map(|v| v.clean(cx)).collect(),\n+                generics: generics.clean(cx),\n+                variants_stripped: false,\n+            }),\n+            ItemKind::TraitAlias(ref generics, bounds) => TraitAliasItem(TraitAlias {\n+                generics: generics.clean(cx),\n+                bounds: bounds.clean(cx),\n+            }),\n+            ItemKind::Union(ref variant_data, ref generics) => UnionItem(Union {\n+                struct_type: doctree::struct_type_from_def(&variant_data),\n+                generics: generics.clean(cx),\n+                fields: variant_data.fields().clean(cx),\n+                fields_stripped: false,\n+            }),\n+            ItemKind::Struct(ref variant_data, ref generics) => StructItem(Struct {\n+                struct_type: doctree::struct_type_from_def(&variant_data),\n+                generics: generics.clean(cx),\n+                fields: variant_data.fields().clean(cx),\n+                fields_stripped: false,\n+            }),\n+            _ => unreachable!(\"not yet converted\"),\n+        };\n+\n+        Item::from_def_id_and_parts(def_id, Some(name), kind, cx)\n     }\n }\n \n-impl Clean<Item> for doctree::Constant<'_> {\n+impl Clean<Item> for hir::Variant<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let def_id = cx.tcx.hir().local_def_id(self.id).to_def_id();\n-\n-        Item::from_def_id_and_parts(\n-            def_id,\n-            Some(self.name),\n-            ConstantItem(Constant {\n-                type_: self.type_.clean(cx),\n-                expr: print_const_expr(cx, self.expr),\n-                value: print_evaluated_const(cx, def_id),\n-                is_literal: is_literal_expr(cx, self.expr.hir_id),\n-            }),\n-            cx,\n-        )\n+        let kind = VariantItem(Variant { kind: self.data.clean(cx) });\n+        let what_rustc_thinks =\n+            Item::from_hir_id_and_parts(self.id, Some(self.ident.name), kind, cx);\n+        // don't show `pub` for variants, which are always public\n+        Item { visibility: Inherited, ..what_rustc_thinks }\n     }\n }\n "}, {"sha": "69baffcc6131be1e2a2b95ac5697e3d820c9ef92", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 2, "deletions": 78, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/0459aca41a31213f18471aeafe246cd20cc846e9/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459aca41a31213f18471aeafe246cd20cc846e9/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=0459aca41a31213f18471aeafe246cd20cc846e9", "patch": "@@ -17,22 +17,15 @@ crate struct Module<'hir> {\n     crate where_inner: Span,\n     crate extern_crates: Vec<ExternCrate<'hir>>,\n     crate imports: Vec<Import<'hir>>,\n-    crate structs: Vec<Struct<'hir>>,\n-    crate unions: Vec<Union<'hir>>,\n-    crate enums: Vec<Enum<'hir>>,\n     crate fns: Vec<Function<'hir>>,\n     crate mods: Vec<Module<'hir>>,\n     crate id: hir::HirId,\n-    crate typedefs: Vec<Typedef<'hir>>,\n-    crate opaque_tys: Vec<OpaqueTy<'hir>>,\n-    crate statics: Vec<Static<'hir>>,\n-    crate constants: Vec<Constant<'hir>>,\n+    crate items: Vec<&'hir hir::Item<'hir>>,\n     crate traits: Vec<Trait<'hir>>,\n     crate impls: Vec<Impl<'hir>>,\n     crate foreigns: Vec<ForeignItem<'hir>>,\n     crate macros: Vec<Macro>,\n     crate proc_macros: Vec<ProcMacro>,\n-    crate trait_aliases: Vec<TraitAlias<'hir>>,\n     crate is_crate: bool,\n }\n \n@@ -46,21 +39,14 @@ impl Module<'hir> {\n             attrs,\n             extern_crates: Vec::new(),\n             imports: Vec::new(),\n-            structs: Vec::new(),\n-            unions: Vec::new(),\n-            enums: Vec::new(),\n             fns: Vec::new(),\n             mods: Vec::new(),\n-            typedefs: Vec::new(),\n-            opaque_tys: Vec::new(),\n-            statics: Vec::new(),\n-            constants: Vec::new(),\n+            items: Vec::new(),\n             traits: Vec::new(),\n             impls: Vec::new(),\n             foreigns: Vec::new(),\n             macros: Vec::new(),\n             proc_macros: Vec::new(),\n-            trait_aliases: Vec::new(),\n             is_crate: false,\n         }\n     }\n@@ -76,29 +62,6 @@ crate enum StructType {\n     Unit,\n }\n \n-crate struct Struct<'hir> {\n-    crate id: hir::HirId,\n-    crate struct_type: StructType,\n-    crate name: Symbol,\n-    crate generics: &'hir hir::Generics<'hir>,\n-    crate fields: &'hir [hir::StructField<'hir>],\n-}\n-\n-crate struct Union<'hir> {\n-    crate id: hir::HirId,\n-    crate struct_type: StructType,\n-    crate name: Symbol,\n-    crate generics: &'hir hir::Generics<'hir>,\n-    crate fields: &'hir [hir::StructField<'hir>],\n-}\n-\n-crate struct Enum<'hir> {\n-    crate variants: Vec<Variant<'hir>>,\n-    crate generics: &'hir hir::Generics<'hir>,\n-    crate id: hir::HirId,\n-    crate name: Symbol,\n-}\n-\n crate struct Variant<'hir> {\n     crate name: Symbol,\n     crate id: hir::HirId,\n@@ -114,38 +77,6 @@ crate struct Function<'hir> {\n     crate body: hir::BodyId,\n }\n \n-crate struct Typedef<'hir> {\n-    crate ty: &'hir hir::Ty<'hir>,\n-    crate gen: &'hir hir::Generics<'hir>,\n-    crate name: Symbol,\n-    crate id: hir::HirId,\n-}\n-\n-crate struct OpaqueTy<'hir> {\n-    crate opaque_ty: &'hir hir::OpaqueTy<'hir>,\n-    crate name: Symbol,\n-    crate id: hir::HirId,\n-}\n-\n-#[derive(Debug)]\n-crate struct Static<'hir> {\n-    crate type_: &'hir hir::Ty<'hir>,\n-    crate mutability: hir::Mutability,\n-    crate expr: hir::BodyId,\n-    crate name: Symbol,\n-    crate attrs: &'hir [ast::Attribute],\n-    crate vis: &'hir hir::Visibility<'hir>,\n-    crate id: hir::HirId,\n-    crate span: Span,\n-}\n-\n-crate struct Constant<'hir> {\n-    crate type_: &'hir hir::Ty<'hir>,\n-    crate expr: hir::BodyId,\n-    crate name: Symbol,\n-    crate id: hir::HirId,\n-}\n-\n crate struct Trait<'hir> {\n     crate is_auto: hir::IsAuto,\n     crate unsafety: hir::Unsafety,\n@@ -157,13 +88,6 @@ crate struct Trait<'hir> {\n     crate id: hir::HirId,\n }\n \n-crate struct TraitAlias<'hir> {\n-    crate name: Symbol,\n-    crate generics: &'hir hir::Generics<'hir>,\n-    crate bounds: &'hir [hir::GenericBound<'hir>],\n-    crate id: hir::HirId,\n-}\n-\n #[derive(Debug)]\n crate struct Impl<'hir> {\n     crate unsafety: hir::Unsafety,"}, {"sha": "fc42ef79dcc9e627cd3cceb7d3a72eef24f13eb4", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 9, "deletions": 82, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/0459aca41a31213f18471aeafe246cd20cc846e9/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459aca41a31213f18471aeafe246cd20cc846e9/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=0459aca41a31213f18471aeafe246cd20cc846e9", "patch": "@@ -82,50 +82,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         module\n     }\n \n-    fn visit_variant_data(\n-        &mut self,\n-        item: &'tcx hir::Item<'_>,\n-        name: Symbol,\n-        sd: &'tcx hir::VariantData<'_>,\n-        generics: &'tcx hir::Generics<'_>,\n-    ) -> Struct<'tcx> {\n-        debug!(\"visiting struct\");\n-        let struct_type = struct_type_from_def(&*sd);\n-        Struct { id: item.hir_id, struct_type, name, generics, fields: sd.fields() }\n-    }\n-\n-    fn visit_union_data(\n-        &mut self,\n-        item: &'tcx hir::Item<'_>,\n-        name: Symbol,\n-        sd: &'tcx hir::VariantData<'_>,\n-        generics: &'tcx hir::Generics<'_>,\n-    ) -> Union<'tcx> {\n-        debug!(\"visiting union\");\n-        let struct_type = struct_type_from_def(&*sd);\n-        Union { id: item.hir_id, struct_type, name, generics, fields: sd.fields() }\n-    }\n-\n-    fn visit_enum_def(\n-        &mut self,\n-        it: &'tcx hir::Item<'_>,\n-        name: Symbol,\n-        def: &'tcx hir::EnumDef<'_>,\n-        generics: &'tcx hir::Generics<'_>,\n-    ) -> Enum<'tcx> {\n-        debug!(\"visiting enum\");\n-        Enum {\n-            name,\n-            variants: def\n-                .variants\n-                .iter()\n-                .map(|v| Variant { name: v.ident.name, id: v.id, def: &v.data })\n-                .collect(),\n-            generics,\n-            id: it.hir_id,\n-        }\n-    }\n-\n     fn visit_fn(\n         &mut self,\n         om: &mut Module<'tcx>,\n@@ -414,45 +370,21 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     Some(ident.name),\n                 ));\n             }\n-            hir::ItemKind::Enum(ref ed, ref gen) => {\n-                om.enums.push(self.visit_enum_def(item, ident.name, ed, gen))\n-            }\n-            hir::ItemKind::Struct(ref sd, ref gen) => {\n-                om.structs.push(self.visit_variant_data(item, ident.name, sd, gen))\n-            }\n-            hir::ItemKind::Union(ref sd, ref gen) => {\n-                om.unions.push(self.visit_union_data(item, ident.name, sd, gen))\n-            }\n+            hir::ItemKind::Enum(..) => om.items.push(item),\n+            hir::ItemKind::Struct(..) => om.items.push(item),\n+            hir::ItemKind::Union(..) => om.items.push(item),\n             hir::ItemKind::Fn(ref sig, ref gen, body) => {\n                 self.visit_fn(om, item, ident.name, &sig.decl, sig.header, gen, body)\n             }\n-            hir::ItemKind::TyAlias(ty, ref gen) => {\n-                let t = Typedef { ty, gen, name: ident.name, id: item.hir_id };\n-                om.typedefs.push(t);\n-            }\n-            hir::ItemKind::OpaqueTy(ref opaque_ty) => {\n-                let t = OpaqueTy { opaque_ty, name: ident.name, id: item.hir_id };\n-                om.opaque_tys.push(t);\n-            }\n-            hir::ItemKind::Static(type_, mutability, expr) => {\n-                let s = Static {\n-                    type_,\n-                    mutability,\n-                    expr,\n-                    id: item.hir_id,\n-                    name: ident.name,\n-                    attrs: &item.attrs,\n-                    span: item.span,\n-                    vis: &item.vis,\n-                };\n-                om.statics.push(s);\n-            }\n-            hir::ItemKind::Const(type_, expr) => {\n+            hir::ItemKind::TyAlias(..)\n+            | hir::ItemKind::OpaqueTy(..)\n+            | hir::ItemKind::Static(..)\n+            | hir::ItemKind::TraitAlias(..) => om.items.push(item),\n+            hir::ItemKind::Const(..) => {\n                 // Underscore constants do not correspond to a nameable item and\n                 // so are never useful in documentation.\n                 if ident.name != kw::Underscore {\n-                    let s = Constant { type_, expr, id: item.hir_id, name: ident.name };\n-                    om.constants.push(s);\n+                    om.items.push(item);\n                 }\n             }\n             hir::ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref item_ids) => {\n@@ -469,11 +401,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 };\n                 om.traits.push(t);\n             }\n-            hir::ItemKind::TraitAlias(ref generics, ref bounds) => {\n-                let t = TraitAlias { name: ident.name, generics, bounds, id: item.hir_id };\n-                om.trait_aliases.push(t);\n-            }\n-\n             hir::ItemKind::Impl {\n                 unsafety,\n                 polarity,"}]}