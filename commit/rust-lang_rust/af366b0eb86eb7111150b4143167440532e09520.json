{"sha": "af366b0eb86eb7111150b4143167440532e09520", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmMzY2YjBlYjg2ZWI3MTExMTUwYjQxNDMxNjc0NDA1MzJlMDk1MjA=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-06-22T22:52:56Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-16T19:09:05Z"}, "message": "Refactor condition", "tree": {"sha": "c85a8f7ec529eb2179982f5818a3a0d2fc7c7963", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c85a8f7ec529eb2179982f5818a3a0d2fc7c7963"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af366b0eb86eb7111150b4143167440532e09520", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af366b0eb86eb7111150b4143167440532e09520", "html_url": "https://github.com/rust-lang/rust/commit/af366b0eb86eb7111150b4143167440532e09520", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af366b0eb86eb7111150b4143167440532e09520/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25ba9118ff3d3f6b8d05efb7995c4d53a55841b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/25ba9118ff3d3f6b8d05efb7995c4d53a55841b8", "html_url": "https://github.com/rust-lang/rust/commit/25ba9118ff3d3f6b8d05efb7995c4d53a55841b8"}], "stats": {"total": 58, "additions": 27, "deletions": 31}, "files": [{"sha": "60a8c89995a00b5b473746ef024af79b1659d7b3", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/af366b0eb86eb7111150b4143167440532e09520/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af366b0eb86eb7111150b4143167440532e09520/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=af366b0eb86eb7111150b4143167440532e09520", "patch": "@@ -35,6 +35,7 @@ use arena::TypedArena;\n use std::cmp::{self, Ordering};\n use std::fmt;\n use std::iter::{FromIterator, IntoIterator};\n+use std::ops::RangeInclusive;\n \n pub fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pattern<'tcx>)\n                                 -> &'a Pattern<'tcx>\n@@ -274,7 +275,7 @@ impl<'tcx> Constructor<'tcx> {\n     }\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub enum Usefulness<'tcx> {\n     Useful,\n     UsefulWithWitness(Vec<Witness<'tcx>>),\n@@ -290,7 +291,7 @@ impl<'tcx> Usefulness<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub enum WitnessPreference {\n     ConstructWitness,\n     LeaveOutWitness\n@@ -303,7 +304,7 @@ struct PatternContext<'tcx> {\n }\n \n /// A stack of patterns in reverse order of construction\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct Witness<'tcx>(Vec<Pattern<'tcx>>);\n \n impl<'tcx> Witness<'tcx> {\n@@ -418,10 +419,6 @@ impl<'tcx> Witness<'tcx> {\n /// but is instead bounded by the maximum fixed length of slice patterns in\n /// the column of patterns being analyzed.\n ///\n-/// This intentionally does not list ConstantValue specializations for\n-/// non-booleans, because we currently assume that there is always a\n-/// \"non-standard constant\" that matches. See issue #12483.\n-///\n /// We make sure to omit constructors that are statically impossible. eg for\n /// Option<!> we do not include Some(_) in the returned list of constructors.\n fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n@@ -530,7 +527,7 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n     //     `[true, ..]`\n     //     `[.., false]`\n     // Then any slice of length \u22651 that matches one of these two\n-    // patterns can be  be trivially turned to a slice of any\n+    // patterns can be trivially turned to a slice of any\n     // other length \u22651 that matches them and vice-versa - for\n     // but the slice from length 2 `[false, true]` that matches neither\n     // of these patterns can't be turned to a slice from length 1 that\n@@ -823,33 +820,32 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         // as patterns in the `match` expression, but did not.\n         let mut missing_ctors = vec![];\n         for req_ctor in &all_ctors {\n-            if consider_value_constructors {\n-                let mut refined_ctors = vec![req_ctor.clone()];\n-                for used_ctor in &used_ctors {\n-                    // Refine the required constructors for the type by subtracting\n-                    // the range defined by the current constructor pattern.\n-                    refined_ctors = match IntRange::from_ctor(cx.tcx, used_ctor) {\n-                        Some(interval) => interval.subtract_from(cx.tcx, refined_ctors),\n-                        None => refined_ctors,\n-                    };\n-                    // If the constructor patterns that have been considered so far\n-                    // already cover the entire range of values, then we the\n-                    // constructor is not missing, and we can move on to the next one.\n-                    if refined_ctors.is_empty() {\n-                        break;\n+            let mut refined_ctors = vec![req_ctor.clone()];\n+            for used_ctor in &used_ctors {\n+                if used_ctor == req_ctor {\n+                    // If a constructor appears in a `match` arm, we can\n+                    // eliminate it straight away.\n+                    refined_ctors = vec![]\n+                } else if exhaustive_integer_patterns {\n+                    if let Some(interval) = IntRange::from_ctor(cx.tcx, used_ctor) {\n+                        // Refine the required constructors for the type by subtracting\n+                        // the range defined by the current constructor pattern.\n+                        refined_ctors = interval.subtract_from(cx.tcx, refined_ctors);\n                     }\n                 }\n-                // If a constructor has not been matched, then it is missing.\n-                // We add `refined_ctors` instead of `req_ctor`, because then we can\n-                // provide more detailed error information about precisely which\n-                // ranges have been omitted.\n-                missing_ctors.extend(refined_ctors);\n-            } else {\n-                // A constructor is missing if it never appears in a `match` arm.\n-                if !used_ctors.iter().any(|used_ctor| used_ctor == req_ctor) {\n-                    missing_ctors.push(req_ctor.clone());\n+\n+                // If the constructor patterns that have been considered so far\n+                // already cover the entire range of values, then we the\n+                // constructor is not missing, and we can move on to the next one.\n+                if refined_ctors.is_empty() {\n+                    break;\n                 }\n             }\n+            // If a constructor has not been matched, then it is missing.\n+            // We add `refined_ctors` instead of `req_ctor`, because then we can\n+            // provide more detailed error information about precisely which\n+            // ranges have been omitted.\n+            missing_ctors.extend(refined_ctors);\n         }\n \n         // `missing_ctors` is the set of constructors from the same type as the"}]}