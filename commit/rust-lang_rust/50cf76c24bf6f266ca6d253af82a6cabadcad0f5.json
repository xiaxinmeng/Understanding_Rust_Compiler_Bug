{"sha": "50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "node_id": "C_kwDOAAsO6NoAKDUwY2Y3NmMyNGJmNmYyNjZjYTZkMjUzYWY4MmE2Y2FiYWRjYWQwZjU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-05T16:59:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-05T16:59:54Z"}, "message": "Auto merge of #96734 - matthiaskrgr:rollup-hng33tb, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #95359 (Update `int_roundings` methods from feedback)\n - #95843 (Improve Rc::new_cyclic and Arc::new_cyclic documentation)\n - #96507 (Suggest calling `Self::associated_function()`)\n - #96635 (Use \"strict\" mode in JS scripts)\n - #96673 (Report that opaque types are not allowed in impls even in the presence of other errors)\n - #96682 (Show invisible delimeters (within comments) when pretty printing.)\n - #96714 (interpret/validity: debug-check ScalarPair layout information)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "173d0a1e452b82d603c76cc1e74a803466f94df9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/173d0a1e452b82d603c76cc1e74a803466f94df9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "html_url": "https://github.com/rust-lang/rust/commit/50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7d6768e3b60209d4195c822ea3247482909b604", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7d6768e3b60209d4195c822ea3247482909b604", "html_url": "https://github.com/rust-lang/rust/commit/a7d6768e3b60209d4195c822ea3247482909b604"}, {"sha": "68048199c9d58e907c308620aeb0e5133d5aba7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/68048199c9d58e907c308620aeb0e5133d5aba7b", "html_url": "https://github.com/rust-lang/rust/commit/68048199c9d58e907c308620aeb0e5133d5aba7b"}], "stats": {"total": 780, "additions": 522, "deletions": 258}, "files": [{"sha": "35eca23a116258535a7b167cd03ae8ed34348d87", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -50,11 +50,12 @@ pub enum Delimiter {\n     Brace,\n     /// `[ ... ]`\n     Bracket,\n-    /// `\u00d8 ... \u00d8`\n+    /// `/*\u00ab*/ ... /*\u00bb*/`\n     /// An invisible delimiter, that may, for example, appear around tokens coming from a\n     /// \"macro variable\" `$var`. It is important to preserve operator priorities in cases like\n     /// `$var * 3` where `$var` is `1 + 2`.\n-    /// Invisible delimiters might not survive roundtrip of a token stream through a string.\n+    /// Invisible delimiters are not directly writable in normal Rust code except as comments.\n+    /// Therefore, they might not survive a roundtrip of a token stream through a string.\n     Invisible,\n }\n "}, {"sha": "c02cdc295610fc1fc852874a213f6d1d7d940ad7", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -590,15 +590,29 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                     self.nbsp();\n                 }\n                 self.word(\"{\");\n-                if !tts.is_empty() {\n+                let empty = tts.is_empty();\n+                if !empty {\n                     self.space();\n                 }\n                 self.ibox(0);\n                 self.print_tts(tts, convert_dollar_crate);\n                 self.end();\n-                let empty = tts.is_empty();\n                 self.bclose(span, empty);\n             }\n+            Some(Delimiter::Invisible) => {\n+                self.word(\"/*\u00ab*/\");\n+                let empty = tts.is_empty();\n+                if !empty {\n+                    self.space();\n+                }\n+                self.ibox(0);\n+                self.print_tts(tts, convert_dollar_crate);\n+                self.end();\n+                if !empty {\n+                    self.space();\n+                }\n+                self.word(\"/*\u00bb*/\");\n+            }\n             Some(delim) => {\n                 let token_str = self.token_kind_to_string(&token::OpenDelim(delim));\n                 self.word(token_str);\n@@ -772,9 +786,8 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n             token::CloseDelim(Delimiter::Bracket) => \"]\".into(),\n             token::OpenDelim(Delimiter::Brace) => \"{\".into(),\n             token::CloseDelim(Delimiter::Brace) => \"}\".into(),\n-            token::OpenDelim(Delimiter::Invisible) | token::CloseDelim(Delimiter::Invisible) => {\n-                \"\".into()\n-            }\n+            token::OpenDelim(Delimiter::Invisible) => \"/*\u00ab*/\".into(),\n+            token::CloseDelim(Delimiter::Invisible) => \"/*\u00bb*/\".into(),\n             token::Pound => \"#\".into(),\n             token::Dollar => \"$\".into(),\n             token::Question => \"?\".into(),"}, {"sha": "a8a5ac2f9d95d4b6aae2cf0d801890322edd7c42", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 55, "deletions": 29, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -84,14 +84,18 @@ impl<'tcx, Tag: Provenance> Immediate<Tag> {\n     }\n \n     #[inline]\n-    pub fn to_scalar_pair(self) -> InterpResult<'tcx, (Scalar<Tag>, Scalar<Tag>)> {\n+    pub fn to_scalar_or_uninit_pair(self) -> (ScalarMaybeUninit<Tag>, ScalarMaybeUninit<Tag>) {\n         match self {\n-            Immediate::ScalarPair(val1, val2) => Ok((val1.check_init()?, val2.check_init()?)),\n-            Immediate::Scalar(..) => {\n-                bug!(\"Got a scalar where a scalar pair was expected\")\n-            }\n+            Immediate::ScalarPair(val1, val2) => (val1, val2),\n+            Immediate::Scalar(..) => bug!(\"Got a scalar where a scalar pair was expected\"),\n         }\n     }\n+\n+    #[inline]\n+    pub fn to_scalar_pair(self) -> InterpResult<'tcx, (Scalar<Tag>, Scalar<Tag>)> {\n+        let (val1, val2) = self.to_scalar_or_uninit_pair();\n+        Ok((val1.check_init()?, val2.check_init()?))\n+    }\n }\n \n // ScalarPair needs a type to interpret, so we often have an immediate and a type together\n@@ -248,9 +252,12 @@ impl<'tcx, Tag: Provenance> ImmTy<'tcx, Tag> {\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Try reading an immediate in memory; this is interesting particularly for `ScalarPair`.\n     /// Returns `None` if the layout does not permit loading this as a value.\n-    fn try_read_immediate_from_mplace(\n+    ///\n+    /// This is an internal function; call `read_immediate` instead.\n+    fn read_immediate_from_mplace_raw(\n         &self,\n         mplace: &MPlaceTy<'tcx, M::PointerTag>,\n+        force: bool,\n     ) -> InterpResult<'tcx, Option<ImmTy<'tcx, M::PointerTag>>> {\n         if mplace.layout.is_unsized() {\n             // Don't touch unsized\n@@ -271,42 +278,61 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // case where some of the bytes are initialized and others are not. So, we need an extra\n         // check that walks over the type of `mplace` to make sure it is truly correct to treat this\n         // like a `Scalar` (or `ScalarPair`).\n-        match mplace.layout.abi {\n-            Abi::Scalar(abi::Scalar::Initialized { .. }) => {\n-                let scalar = alloc.read_scalar(alloc_range(Size::ZERO, mplace.layout.size))?;\n-                Ok(Some(ImmTy { imm: scalar.into(), layout: mplace.layout }))\n-            }\n+        let scalar_layout = match mplace.layout.abi {\n+            // `if` does not work nested inside patterns, making this a bit awkward to express.\n+            Abi::Scalar(abi::Scalar::Initialized { value: s, .. }) => Some(s),\n+            Abi::Scalar(s) if force => Some(s.primitive()),\n+            _ => None,\n+        };\n+        if let Some(_) = scalar_layout {\n+            let scalar = alloc.read_scalar(alloc_range(Size::ZERO, mplace.layout.size))?;\n+            return Ok(Some(ImmTy { imm: scalar.into(), layout: mplace.layout }));\n+        }\n+        let scalar_pair_layout = match mplace.layout.abi {\n             Abi::ScalarPair(\n                 abi::Scalar::Initialized { value: a, .. },\n                 abi::Scalar::Initialized { value: b, .. },\n-            ) => {\n-                // We checked `ptr_align` above, so all fields will have the alignment they need.\n-                // We would anyway check against `ptr_align.restrict_for_offset(b_offset)`,\n-                // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n-                let (a_size, b_size) = (a.size(self), b.size(self));\n-                let b_offset = a_size.align_to(b.align(self).abi);\n-                assert!(b_offset.bytes() > 0); // we later use the offset to tell apart the fields\n-                let a_val = alloc.read_scalar(alloc_range(Size::ZERO, a_size))?;\n-                let b_val = alloc.read_scalar(alloc_range(b_offset, b_size))?;\n-                Ok(Some(ImmTy { imm: Immediate::ScalarPair(a_val, b_val), layout: mplace.layout }))\n-            }\n-            _ => Ok(None),\n+            ) => Some((a, b)),\n+            Abi::ScalarPair(a, b) if force => Some((a.primitive(), b.primitive())),\n+            _ => None,\n+        };\n+        if let Some((a, b)) = scalar_pair_layout {\n+            // We checked `ptr_align` above, so all fields will have the alignment they need.\n+            // We would anyway check against `ptr_align.restrict_for_offset(b_offset)`,\n+            // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n+            let (a_size, b_size) = (a.size(self), b.size(self));\n+            let b_offset = a_size.align_to(b.align(self).abi);\n+            assert!(b_offset.bytes() > 0); // we later use the offset to tell apart the fields\n+            let a_val = alloc.read_scalar(alloc_range(Size::ZERO, a_size))?;\n+            let b_val = alloc.read_scalar(alloc_range(b_offset, b_size))?;\n+            return Ok(Some(ImmTy {\n+                imm: Immediate::ScalarPair(a_val, b_val),\n+                layout: mplace.layout,\n+            }));\n         }\n+        // Neither a scalar nor scalar pair.\n+        return Ok(None);\n     }\n \n-    /// Try returning an immediate for the operand.\n-    /// If the layout does not permit loading this as an immediate, return where in memory\n-    /// we can find the data.\n+    /// Try returning an immediate for the operand. If the layout does not permit loading this as an\n+    /// immediate, return where in memory we can find the data.\n     /// Note that for a given layout, this operation will either always fail or always\n     /// succeed!  Whether it succeeds depends on whether the layout can be represented\n     /// in an `Immediate`, not on which data is stored there currently.\n-    pub fn try_read_immediate(\n+    ///\n+    /// If `force` is `true`, then even scalars with fields that can be ununit will be\n+    /// read. This means the load is lossy and should not be written back!\n+    /// This flag exists only for validity checking.\n+    ///\n+    /// This is an internal function that should not usually be used; call `read_immediate` instead.\n+    pub fn read_immediate_raw(\n         &self,\n         src: &OpTy<'tcx, M::PointerTag>,\n+        force: bool,\n     ) -> InterpResult<'tcx, Result<ImmTy<'tcx, M::PointerTag>, MPlaceTy<'tcx, M::PointerTag>>> {\n         Ok(match src.try_as_mplace() {\n             Ok(ref mplace) => {\n-                if let Some(val) = self.try_read_immediate_from_mplace(mplace)? {\n+                if let Some(val) = self.read_immediate_from_mplace_raw(mplace, force)? {\n                     Ok(val)\n                 } else {\n                     Err(*mplace)\n@@ -322,7 +348,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         op: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n-        if let Ok(imm) = self.try_read_immediate(op)? {\n+        if let Ok(imm) = self.read_immediate_raw(op, /*force*/ false)? {\n             Ok(imm)\n         } else {\n             span_bug!(self.cur_span(), \"primitive read failed for type: {:?}\", op.layout.ty);"}, {"sha": "df6e05bb13cde81b839894c3f2496d1a71c03123", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -720,7 +720,7 @@ where\n         }\n         trace!(\"write_immediate: {:?} <- {:?}: {}\", *dest, src, dest.layout.ty);\n \n-        // See if we can avoid an allocation. This is the counterpart to `try_read_immediate`,\n+        // See if we can avoid an allocation. This is the counterpart to `read_immediate_raw`,\n         // but not factored as a separate function.\n         let mplace = match dest.place {\n             Place::Local { frame, local } => {\n@@ -879,7 +879,7 @@ where\n         }\n \n         // Let us see if the layout is simple so we take a shortcut, avoid force_allocation.\n-        let src = match self.try_read_immediate(src)? {\n+        let src = match self.read_immediate_raw(src, /*force*/ false)? {\n             Ok(src_val) => {\n                 assert!(!src.layout.is_unsized(), \"cannot have unsized immediates\");\n                 // Yay, we got a value that we can write directly."}, {"sha": "92e3ac04dc41813522fd6266356d9611f85876f2", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 38, "deletions": 18, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -20,8 +20,8 @@ use rustc_target::abi::{Abi, Scalar as ScalarAbi, Size, VariantIdx, Variants, Wr\n use std::hash::Hash;\n \n use super::{\n-    alloc_range, CheckInAllocMsg, GlobalAlloc, InterpCx, InterpResult, MPlaceTy, Machine,\n-    MemPlaceMeta, OpTy, Scalar, ScalarMaybeUninit, ValueVisitor,\n+    alloc_range, CheckInAllocMsg, GlobalAlloc, Immediate, InterpCx, InterpResult, MPlaceTy,\n+    Machine, MemPlaceMeta, OpTy, Scalar, ScalarMaybeUninit, ValueVisitor,\n };\n \n macro_rules! throw_validation_failure {\n@@ -487,6 +487,17 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         ))\n     }\n \n+    fn read_immediate_forced(\n+        &self,\n+        op: &OpTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, Immediate<M::PointerTag>> {\n+        Ok(*try_validation!(\n+            self.ecx.read_immediate_raw(op, /*force*/ true),\n+            self.path,\n+            err_unsup!(ReadPointerAsBytes) => { \"(potentially part of) a pointer\" } expected { \"plain (non-pointer) bytes\" },\n+        ).unwrap())\n+    }\n+\n     /// Check if this is a value of primitive type, and if yes check the validity of the value\n     /// at that type.  Return `true` if the type is indeed primitive.\n     fn try_visit_primitive(\n@@ -626,18 +637,19 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n \n     fn visit_scalar(\n         &mut self,\n-        op: &OpTy<'tcx, M::PointerTag>,\n+        scalar: ScalarMaybeUninit<M::PointerTag>,\n         scalar_layout: ScalarAbi,\n     ) -> InterpResult<'tcx> {\n         // We check `is_full_range` in a slightly complicated way because *if* we are checking\n         // number validity, then we want to ensure that `Scalar::Initialized` is indeed initialized,\n         // i.e. that we go over the `check_init` below.\n+        let size = scalar_layout.size(self.ecx);\n         let is_full_range = match scalar_layout {\n             ScalarAbi::Initialized { valid_range, .. } => {\n                 if M::enforce_number_validity(self.ecx) {\n                     false // not \"full\" since uninit is not accepted\n                 } else {\n-                    valid_range.is_full_for(op.layout.size)\n+                    valid_range.is_full_for(size)\n                 }\n             }\n             ScalarAbi::Union { .. } => true,\n@@ -646,21 +658,19 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             // Nothing to check\n             return Ok(());\n         }\n-        // We have something to check.\n+        // We have something to check: it must at least be initialized.\n         let valid_range = scalar_layout.valid_range(self.ecx);\n         let WrappingRange { start, end } = valid_range;\n-        let max_value = op.layout.size.unsigned_int_max();\n+        let max_value = size.unsigned_int_max();\n         assert!(end <= max_value);\n-        // Determine the allowed range\n-        let value = self.read_scalar(op)?;\n         let value = try_validation!(\n-            value.check_init(),\n+            scalar.check_init(),\n             self.path,\n-            err_ub!(InvalidUninitBytes(None)) => { \"{:x}\", value }\n+            err_ub!(InvalidUninitBytes(None)) => { \"{:x}\", scalar }\n                 expected { \"something {}\", wrapping_range_format(valid_range, max_value) },\n         );\n         let bits = match value.try_to_int() {\n-            Ok(int) => int.assert_bits(op.layout.size),\n+            Ok(int) => int.assert_bits(size),\n             Err(_) => {\n                 // So this is a pointer then, and casting to an int failed.\n                 // Can only happen during CTFE.\n@@ -678,7 +688,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     } else {\n                         return Ok(());\n                     }\n-                } else if scalar_layout.valid_range(self.ecx).is_full_for(op.layout.size) {\n+                } else if scalar_layout.valid_range(self.ecx).is_full_for(size) {\n                     // Easy. (This is reachable if `enforce_number_validity` is set.)\n                     return Ok(());\n                 } else {\n@@ -817,13 +827,23 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 );\n             }\n             Abi::Scalar(scalar_layout) => {\n-                self.visit_scalar(op, scalar_layout)?;\n+                let scalar = self.read_immediate_forced(op)?.to_scalar_or_uninit();\n+                self.visit_scalar(scalar, scalar_layout)?;\n+            }\n+            Abi::ScalarPair(a_layout, b_layout) => {\n+                // We would validate these things as we descend into the fields,\n+                // but that can miss bugs in layout computation. Layout computation\n+                // is subtle due to enums having ScalarPair layout, where one field\n+                // is the discriminant.\n+                if cfg!(debug_assertions) {\n+                    let (a, b) = self.read_immediate_forced(op)?.to_scalar_or_uninit_pair();\n+                    self.visit_scalar(a, a_layout)?;\n+                    self.visit_scalar(b, b_layout)?;\n+                }\n             }\n-            Abi::ScalarPair { .. } | Abi::Vector { .. } => {\n-                // These have fields that we already visited above, so we already checked\n-                // all their scalar-level restrictions.\n-                // There is also no equivalent to `rustc_layout_scalar_valid_range_start`\n-                // that would make skipping them here an issue.\n+            Abi::Vector { .. } => {\n+                // No checks here, we assume layout computation gets this right.\n+                // (This is harder to check since Miri does not represent these as `Immediate`.)\n             }\n             Abi::Aggregate { .. } => {\n                 // Nothing to do."}, {"sha": "f7535d338da40dd05caa6e7a8e037498d2e94257", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -415,7 +415,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n         // Try to read the local as an immediate so that if it is representable as a scalar, we can\n         // handle it as such, but otherwise, just return the value as is.\n-        Some(match self.ecx.try_read_immediate(&op) {\n+        Some(match self.ecx.read_immediate_raw(&op, /*force*/ false) {\n             Ok(Ok(imm)) => imm.into(),\n             _ => op,\n         })\n@@ -709,8 +709,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             return;\n         }\n \n-        // FIXME> figure out what to do when try_read_immediate fails\n-        let imm = self.use_ecx(|this| this.ecx.try_read_immediate(value));\n+        // FIXME> figure out what to do when read_immediate_raw fails\n+        let imm = self.use_ecx(|this| this.ecx.read_immediate_raw(value, /*force*/ false));\n \n         if let Some(Ok(imm)) = imm {\n             match *imm {"}, {"sha": "aa898cfd3ba5ef3e5f14529e1cb3973599378348", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -412,7 +412,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n         // Try to read the local as an immediate so that if it is representable as a scalar, we can\n         // handle it as such, but otherwise, just return the value as is.\n-        Some(match self.ecx.try_read_immediate(&op) {\n+        Some(match self.ecx.read_immediate_raw(&op, /*force*/ false) {\n             Ok(Ok(imm)) => imm.into(),\n             _ => op,\n         })"}, {"sha": "df6733ac45f9b2f46252d53a0692dc31851a07bc", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -486,6 +486,9 @@ struct DiagnosticMetadata<'ast> {\n     current_where_predicate: Option<&'ast WherePredicate>,\n \n     current_type_path: Option<&'ast Ty>,\n+\n+    /// The current impl items (used to suggest).\n+    current_impl_items: Option<&'ast [P<AssocItem>]>,\n }\n \n struct LateResolutionVisitor<'a, 'b, 'ast> {\n@@ -1637,7 +1640,9 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 items: ref impl_items,\n                 ..\n             }) => {\n+                self.diagnostic_metadata.current_impl_items = Some(impl_items);\n                 self.resolve_implementation(generics, of_trait, &self_ty, item.id, impl_items);\n+                self.diagnostic_metadata.current_impl_items = None;\n             }\n \n             ItemKind::Trait(box Trait { ref generics, ref bounds, ref items, .. }) => {"}, {"sha": "4f07d0076f140452226a08dd73d22d4a7a8d4c5c", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 75, "deletions": 34, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -6,7 +6,7 @@ use crate::path_names_to_string;\n use crate::{Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{PathResult, PathSource, Segment};\n \n-use rustc_ast::visit::FnKind;\n+use rustc_ast::visit::{FnCtxt, FnKind};\n use rustc_ast::{\n     self as ast, AssocItemKind, Expr, ExprKind, GenericParam, GenericParamKind, Item, ItemKind,\n     NodeId, Path, Ty, TyKind,\n@@ -144,15 +144,22 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         let is_enum_variant = &|res| matches!(res, Res::Def(DefKind::Variant, _));\n \n         // Make the base error.\n+        struct BaseError<'a> {\n+            msg: String,\n+            fallback_label: String,\n+            span: Span,\n+            could_be_expr: bool,\n+            suggestion: Option<(Span, &'a str, String)>,\n+        }\n         let mut expected = source.descr_expected();\n         let path_str = Segment::names_to_string(path);\n         let item_str = path.last().unwrap().ident;\n-        let (base_msg, fallback_label, base_span, could_be_expr) = if let Some(res) = res {\n-            (\n-                format!(\"expected {}, found {} `{}`\", expected, res.descr(), path_str),\n-                format!(\"not a {}\", expected),\n+        let base_error = if let Some(res) = res {\n+            BaseError {\n+                msg: format!(\"expected {}, found {} `{}`\", expected, res.descr(), path_str),\n+                fallback_label: format!(\"not a {expected}\"),\n                 span,\n-                match res {\n+                could_be_expr: match res {\n                     Res::Def(DefKind::Fn, _) => {\n                         // Verify whether this is a fn call or an Fn used as a type.\n                         self.r\n@@ -171,45 +178,78 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                     | Res::Local(_) => true,\n                     _ => false,\n                 },\n-            )\n+                suggestion: None,\n+            }\n         } else {\n             let item_span = path.last().unwrap().ident.span;\n-            let (mod_prefix, mod_str) = if path.len() == 1 {\n-                (String::new(), \"this scope\".to_string())\n+            let (mod_prefix, mod_str, suggestion) = if path.len() == 1 {\n+                debug!(?self.diagnostic_metadata.current_impl_items);\n+                debug!(?self.diagnostic_metadata.current_function);\n+                let suggestion = if let Some(items) = self.diagnostic_metadata.current_impl_items\n+                    && let Some((fn_kind, _)) = self.diagnostic_metadata.current_function\n+                    && self.current_trait_ref.is_none()\n+                    && let Some(FnCtxt::Assoc(_)) = fn_kind.ctxt()\n+                    && let Some(item) = items.iter().find(|i| {\n+                        if let AssocItemKind::Fn(fn_) = &i.kind\n+                            && !fn_.sig.decl.has_self()\n+                            && i.ident.name == item_str.name\n+                        {\n+                            debug!(?item_str.name);\n+                            debug!(?fn_.sig.decl.inputs);\n+                            return true\n+                        }\n+                        false\n+                    })\n+                {\n+                    Some((\n+                        item_span,\n+                        \"consider using the associated function\",\n+                        format!(\"Self::{}\", item.ident)\n+                    ))\n+                } else {\n+                    None\n+                };\n+                (String::new(), \"this scope\".to_string(), suggestion)\n             } else if path.len() == 2 && path[0].ident.name == kw::PathRoot {\n                 if self.r.session.edition() > Edition::Edition2015 {\n                     // In edition 2018 onwards, the `::foo` syntax may only pull from the extern prelude\n                     // which overrides all other expectations of item type\n                     expected = \"crate\";\n-                    (String::new(), \"the list of imported crates\".to_string())\n+                    (String::new(), \"the list of imported crates\".to_string(), None)\n                 } else {\n-                    (String::new(), \"the crate root\".to_string())\n+                    (String::new(), \"the crate root\".to_string(), None)\n                 }\n             } else if path.len() == 2 && path[0].ident.name == kw::Crate {\n-                (String::new(), \"the crate root\".to_string())\n+                (String::new(), \"the crate root\".to_string(), None)\n             } else {\n                 let mod_path = &path[..path.len() - 1];\n                 let mod_prefix = match self.resolve_path(mod_path, Some(TypeNS), None) {\n                     PathResult::Module(ModuleOrUniformRoot::Module(module)) => module.res(),\n                     _ => None,\n                 }\n                 .map_or_else(String::new, |res| format!(\"{} \", res.descr()));\n-                (mod_prefix, format!(\"`{}`\", Segment::names_to_string(mod_path)))\n+                (mod_prefix, format!(\"`{}`\", Segment::names_to_string(mod_path)), None)\n             };\n-            (\n-                format!(\"cannot find {} `{}` in {}{}\", expected, item_str, mod_prefix, mod_str),\n-                if path_str == \"async\" && expected.starts_with(\"struct\") {\n+            BaseError {\n+                msg: format!(\"cannot find {expected} `{item_str}` in {mod_prefix}{mod_str}\"),\n+                fallback_label: if path_str == \"async\" && expected.starts_with(\"struct\") {\n                     \"`async` blocks are only allowed in Rust 2018 or later\".to_string()\n                 } else {\n-                    format!(\"not found in {}\", mod_str)\n+                    format!(\"not found in {mod_str}\")\n                 },\n-                item_span,\n-                false,\n-            )\n+                span: item_span,\n+                could_be_expr: false,\n+                suggestion,\n+            }\n         };\n \n         let code = source.error_code(res.is_some());\n-        let mut err = self.r.session.struct_span_err_with_code(base_span, &base_msg, code);\n+        let mut err =\n+            self.r.session.struct_span_err_with_code(base_error.span, &base_error.msg, code);\n+\n+        if let Some(sugg) = base_error.suggestion {\n+            err.span_suggestion_verbose(sugg.0, sugg.1, sugg.2, Applicability::MaybeIncorrect);\n+        }\n \n         if let Some(span) = self.diagnostic_metadata.current_block_could_be_bare_struct_literal {\n             err.multipart_suggestion(\n@@ -269,7 +309,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             }\n         }\n \n-        self.detect_assoct_type_constraint_meant_as_path(base_span, &mut err);\n+        self.detect_assoct_type_constraint_meant_as_path(base_error.span, &mut err);\n \n         // Emit special messages for unresolved `Self` and `self`.\n         if is_self_type(path, ns) {\n@@ -471,16 +511,17 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 source,\n                 res,\n                 &path_str,\n-                &fallback_label,\n+                &base_error.fallback_label,\n             ) {\n                 // We do this to avoid losing a secondary span when we override the main error span.\n                 self.r.add_typo_suggestion(&mut err, typo_sugg, ident_span);\n                 return (err, candidates);\n             }\n         }\n \n-        let is_macro = base_span.from_expansion() && base_span.desugaring_kind().is_none();\n-        if !self.type_ascription_suggestion(&mut err, base_span) {\n+        let is_macro =\n+            base_error.span.from_expansion() && base_error.span.desugaring_kind().is_none();\n+        if !self.type_ascription_suggestion(&mut err, base_error.span) {\n             let mut fallback = false;\n             if let (\n                 PathSource::Trait(AliasPossibility::Maybe),\n@@ -493,7 +534,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                     let spans: Vec<Span> = bounds\n                         .iter()\n                         .map(|bound| bound.span())\n-                        .filter(|&sp| sp != base_span)\n+                        .filter(|&sp| sp != base_error.span)\n                         .collect();\n \n                     let start_span = bounds.iter().map(|bound| bound.span()).next().unwrap();\n@@ -515,7 +556,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                         multi_span.push_span_label(sp, msg);\n                     }\n                     multi_span.push_span_label(\n-                        base_span,\n+                        base_error.span,\n                         \"expected this type to be a trait...\".to_string(),\n                     );\n                     err.span_help(\n@@ -525,14 +566,14 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                     );\n                     if bounds.iter().all(|bound| match bound {\n                         ast::GenericBound::Outlives(_) => true,\n-                        ast::GenericBound::Trait(tr, _) => tr.span == base_span,\n+                        ast::GenericBound::Trait(tr, _) => tr.span == base_error.span,\n                     }) {\n                         let mut sugg = vec![];\n-                        if base_span != start_span {\n-                            sugg.push((start_span.until(base_span), String::new()));\n+                        if base_error.span != start_span {\n+                            sugg.push((start_span.until(base_error.span), String::new()));\n                         }\n-                        if base_span != end_span {\n-                            sugg.push((base_span.shrink_to_hi().to(end_span), String::new()));\n+                        if base_error.span != end_span {\n+                            sugg.push((base_error.span.shrink_to_hi().to(end_span), String::new()));\n                         }\n \n                         err.multipart_suggestion(\n@@ -550,7 +591,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 fallback = true;\n                 match self.diagnostic_metadata.current_let_binding {\n                     Some((pat_sp, Some(ty_sp), None))\n-                        if ty_sp.contains(base_span) && could_be_expr =>\n+                        if ty_sp.contains(base_error.span) && base_error.could_be_expr =>\n                     {\n                         err.span_suggestion_short(\n                             pat_sp.between(ty_sp),\n@@ -568,7 +609,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             }\n             if fallback {\n                 // Fallback label.\n-                err.span_label(base_span, fallback_label);\n+                err.span_label(base_error.span, base_error.fallback_label);\n             }\n         }\n         if let Some(err_code) = &err.code {"}, {"sha": "f57986a985cdea63face6a3d361ba95a0abd0663", "filename": "compiler/rustc_typeck/src/coherence/orphan.rs", "status": "modified", "additions": 53, "deletions": 52, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -44,6 +44,59 @@ fn orphan_check_impl(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Result<(), ErrorGua\n     };\n     let sp = tcx.sess.source_map().guess_head_span(item.span);\n     let tr = impl_.of_trait.as_ref().unwrap();\n+\n+    // Ensure no opaque types are present in this impl header. See issues #76202 and #86411 for examples,\n+    // and #84660 where it would otherwise allow unsoundness.\n+    if trait_ref.has_opaque_types() {\n+        trace!(\"{:#?}\", item);\n+        // First we find the opaque type in question.\n+        for ty in trait_ref.substs {\n+            for ty in ty.walk() {\n+                let ty::subst::GenericArgKind::Type(ty) = ty.unpack() else { continue };\n+                let ty::Opaque(def_id, _) = *ty.kind() else { continue };\n+                trace!(?def_id);\n+\n+                // Then we search for mentions of the opaque type's type alias in the HIR\n+                struct SpanFinder<'tcx> {\n+                    sp: Span,\n+                    def_id: DefId,\n+                    tcx: TyCtxt<'tcx>,\n+                }\n+                impl<'v, 'tcx> hir::intravisit::Visitor<'v> for SpanFinder<'tcx> {\n+                    #[instrument(level = \"trace\", skip(self, _id))]\n+                    fn visit_path(&mut self, path: &'v hir::Path<'v>, _id: hir::HirId) {\n+                        // You can't mention an opaque type directly, so we look for type aliases\n+                        if let hir::def::Res::Def(hir::def::DefKind::TyAlias, def_id) = path.res {\n+                            // And check if that type alias's type contains the opaque type we're looking for\n+                            for arg in self.tcx.type_of(def_id).walk() {\n+                                if let GenericArgKind::Type(ty) = arg.unpack() {\n+                                    if let ty::Opaque(def_id, _) = *ty.kind() {\n+                                        if def_id == self.def_id {\n+                                            // Finally we update the span to the mention of the type alias\n+                                            self.sp = path.span;\n+                                            return;\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                        }\n+                        hir::intravisit::walk_path(self, path)\n+                    }\n+                }\n+\n+                let mut visitor = SpanFinder { sp, def_id, tcx };\n+                hir::intravisit::walk_item(&mut visitor, item);\n+                let reported = tcx\n+                    .sess\n+                    .struct_span_err(visitor.sp, \"cannot implement trait on type alias impl trait\")\n+                    .span_note(tcx.def_span(def_id), \"type alias impl trait defined here\")\n+                    .emit();\n+                return Err(reported);\n+            }\n+        }\n+        span_bug!(sp, \"opaque type not found, but `has_opaque_types` is set\")\n+    }\n+\n     match traits::orphan_check(tcx, item.def_id.to_def_id()) {\n         Ok(()) => {}\n         Err(err) => emit_orphan_check_error(\n@@ -143,58 +196,6 @@ fn orphan_check_impl(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Result<(), ErrorGua\n         }\n     }\n \n-    // Ensure no opaque types are present in this impl header. See issues #76202 and #86411 for examples,\n-    // and #84660 where it would otherwise allow unsoundness.\n-    if trait_ref.has_opaque_types() {\n-        trace!(\"{:#?}\", item);\n-        // First we find the opaque type in question.\n-        for ty in trait_ref.substs {\n-            for ty in ty.walk() {\n-                let ty::subst::GenericArgKind::Type(ty) = ty.unpack() else { continue };\n-                let ty::Opaque(def_id, _) = *ty.kind() else { continue };\n-                trace!(?def_id);\n-\n-                // Then we search for mentions of the opaque type's type alias in the HIR\n-                struct SpanFinder<'tcx> {\n-                    sp: Span,\n-                    def_id: DefId,\n-                    tcx: TyCtxt<'tcx>,\n-                }\n-                impl<'v, 'tcx> hir::intravisit::Visitor<'v> for SpanFinder<'tcx> {\n-                    #[instrument(level = \"trace\", skip(self, _id))]\n-                    fn visit_path(&mut self, path: &'v hir::Path<'v>, _id: hir::HirId) {\n-                        // You can't mention an opaque type directly, so we look for type aliases\n-                        if let hir::def::Res::Def(hir::def::DefKind::TyAlias, def_id) = path.res {\n-                            // And check if that type alias's type contains the opaque type we're looking for\n-                            for arg in self.tcx.type_of(def_id).walk() {\n-                                if let GenericArgKind::Type(ty) = arg.unpack() {\n-                                    if let ty::Opaque(def_id, _) = *ty.kind() {\n-                                        if def_id == self.def_id {\n-                                            // Finally we update the span to the mention of the type alias\n-                                            self.sp = path.span;\n-                                            return;\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                        }\n-                        hir::intravisit::walk_path(self, path)\n-                    }\n-                }\n-\n-                let mut visitor = SpanFinder { sp, def_id, tcx };\n-                hir::intravisit::walk_item(&mut visitor, item);\n-                let reported = tcx\n-                    .sess\n-                    .struct_span_err(visitor.sp, \"cannot implement trait on type alias impl trait\")\n-                    .span_note(tcx.def_span(def_id), \"type alias impl trait defined here\")\n-                    .emit();\n-                return Err(reported);\n-            }\n-        }\n-        span_bug!(sp, \"opaque type not found, but `has_opaque_types` is set\")\n-    }\n-\n     Ok(())\n }\n "}, {"sha": "6f764a952c02274041fa4ce12a26b3e65f843084", "filename": "compiler/rustc_typeck/src/constrained_generic_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -59,7 +59,7 @@ struct ParameterCollector {\n impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         match *t.kind() {\n-            ty::Projection(..) | ty::Opaque(..) if !self.include_nonconstraining => {\n+            ty::Projection(..) if !self.include_nonconstraining => {\n                 // projections are not injective\n                 return ControlFlow::CONTINUE;\n             }"}, {"sha": "52957456473650f0fdf26fe067a479145d83899a", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -374,19 +374,26 @@ impl<T> Rc<T> {\n         }\n     }\n \n-    /// Constructs a new `Rc<T>` using a closure `data_fn` that has access to a\n-    /// weak reference to the constructing `Rc<T>`.\n+    /// Constructs a new `Rc<T>` while giving you a `Weak<T>` to the allocation,\n+    /// to allow you to construct a `T` which holds a weak pointer to itself.\n     ///\n     /// Generally, a structure circularly referencing itself, either directly or\n-    /// indirectly, should not hold a strong reference to prevent a memory leak.\n-    /// In `data_fn`, initialization of `T` can make use of the weak reference\n-    /// by cloning and storing it inside `T` for use at a later time.\n+    /// indirectly, should not hold a strong reference to itself to prevent a memory leak.\n+    /// Using this function, you get access to the weak pointer during the\n+    /// initialization of `T`, before the `Rc<T>` is created, such that you can\n+    /// clone and store it inside the `T`.\n+    ///\n+    /// `new_cyclic` first allocates the managed allocation for the `Rc<T>`,\n+    /// then calls your closure, giving it a `Weak<T>` to this allocation,\n+    /// and only afterwards completes the construction of the `Rc<T>` by placing\n+    /// the `T` returned from your closure into the allocation.\n     ///\n     /// Since the new `Rc<T>` is not fully-constructed until `Rc<T>::new_cyclic`\n-    /// returns, calling [`upgrade`] on the weak reference inside `data_fn` will\n+    /// returns, calling [`upgrade`] on the weak reference inside your closure will\n     /// fail and result in a `None` value.\n     ///\n     /// # Panics\n+    ///\n     /// If `data_fn` panics, the panic is propagated to the caller, and the\n     /// temporary [`Weak<T>`] is dropped normally.\n     ///\n@@ -403,7 +410,12 @@ impl<T> Rc<T> {\n     /// impl Gadget {\n     ///     /// Construct a reference counted Gadget.\n     ///     fn new() -> Rc<Self> {\n-    ///         Rc::new_cyclic(|me| Gadget { me: me.clone() })\n+    ///         // `me` is a `Weak<Gadget>` pointing at the new allocation of the\n+    ///         // `Rc` we're constructing.\n+    ///         Rc::new_cyclic(|me| {\n+    ///             // Create the actual struct here.\n+    ///             Gadget { me: me.clone() }\n+    ///         })\n     ///     }\n     ///\n     ///     /// Return a reference counted pointer to Self."}, {"sha": "2bd8f418ee90ce809a1c23346c00f045b5486a4c", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -351,23 +351,31 @@ impl<T> Arc<T> {\n         unsafe { Self::from_inner(Box::leak(x).into()) }\n     }\n \n-    /// Constructs a new `Arc<T>` using a closure `data_fn` that has access to\n-    /// a weak reference to the constructing `Arc<T>`.\n+    /// Constructs a new `Arc<T>` while giving you a `Weak<T>` to the allocation,\n+    /// to allow you to construct a `T` which holds a weak pointer to itself.\n     ///\n     /// Generally, a structure circularly referencing itself, either directly or\n-    /// indirectly, should not hold a strong reference to prevent a memory leak.\n-    /// In `data_fn`, initialization of `T` can make use of the weak reference\n-    /// by cloning and storing it inside `T` for use at a later time.\n+    /// indirectly, should not hold a strong reference to itself to prevent a memory leak.\n+    /// Using this function, you get access to the weak pointer during the\n+    /// initialization of `T`, before the `Arc<T>` is created, such that you can\n+    /// clone and store it inside the `T`.\n     ///\n-    /// Since the new `Arc<T>` is not fully-constructed until\n-    /// `Arc<T>::new_cyclic` returns, calling [`upgrade`] on the weak\n-    /// reference inside `data_fn` will fail and result in a `None` value.\n+    /// `new_cyclic` first allocates the managed allocation for the `Arc<T>`,\n+    /// then calls your closure, giving it a `Weak<T>` to this allocation,\n+    /// and only afterwards completes the construction of the `Arc<T>` by placing\n+    /// the `T` returned from your closure into the allocation.\n+    ///\n+    /// Since the new `Arc<T>` is not fully-constructed until `Arc<T>::new_cyclic`\n+    /// returns, calling [`upgrade`] on the weak reference inside your closure will\n+    /// fail and result in a `None` value.\n     ///\n     /// # Panics\n+    ///\n     /// If `data_fn` panics, the panic is propagated to the caller, and the\n     /// temporary [`Weak<T>`] is dropped normally.\n     ///\n     /// # Example\n+    ///\n     /// ```\n     /// # #![allow(dead_code)]\n     /// use std::sync::{Arc, Weak};\n@@ -379,7 +387,12 @@ impl<T> Arc<T> {\n     /// impl Gadget {\n     ///     /// Construct a reference counted Gadget.\n     ///     fn new() -> Arc<Self> {\n-    ///         Arc::new_cyclic(|me| Gadget { me: me.clone() })\n+    ///         // `me` is a `Weak<Gadget>` pointing at the new allocation of the\n+    ///         // `Arc` we're constructing.\n+    ///         Arc::new_cyclic(|me| {\n+    ///             // Create the actual struct here.\n+    ///             Gadget { me: me.clone() }\n+    ///         })\n     ///     }\n     ///\n     ///     /// Return a reference counted pointer to Self."}, {"sha": "b5c7982a5a871170a21dcdb1395fc827313a2bc0", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -2015,7 +2015,12 @@ macro_rules! int_impl {\n         ///\n         /// # Panics\n         ///\n-        /// This function will panic if `rhs` is 0 or the division results in overflow.\n+        /// This function will panic if `rhs` is zero.\n+        ///\n+        /// ## Overflow behavior\n+        ///\n+        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n+        /// mode) and wrap if overflow checks are disabled (default in release mode).\n         ///\n         /// # Examples\n         ///\n@@ -2050,7 +2055,12 @@ macro_rules! int_impl {\n         ///\n         /// # Panics\n         ///\n-        /// This function will panic if `rhs` is 0 or the division results in overflow.\n+        /// This function will panic if `rhs` is zero.\n+        ///\n+        /// ## Overflow behavior\n+        ///\n+        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n+        /// mode) and wrap if overflow checks are disabled (default in release mode).\n         ///\n         /// # Examples\n         ///\n@@ -2088,7 +2098,12 @@ macro_rules! int_impl {\n         ///\n         /// # Panics\n         ///\n-        /// This function will panic if `rhs` is 0 or the operation results in overflow.\n+        /// This function will panic if `rhs` is zero.\n+        ///\n+        /// ## Overflow behavior\n+        ///\n+        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n+        /// mode) and wrap if overflow checks are disabled (default in release mode).\n         ///\n         /// # Examples\n         ///\n@@ -2157,7 +2172,6 @@ macro_rules! int_impl {\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n-        #[rustc_inherit_overflow_checks]\n         pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n             // This would otherwise fail when calculating `r` when self == T::MIN.\n             if rhs == -1 {"}, {"sha": "048d6bafcdecd018dae127660878b36dfe565023", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -2020,7 +2020,7 @@ macro_rules! uint_impl {\n         ///\n         /// # Panics\n         ///\n-        /// This function will panic if `rhs` is 0.\n+        /// This function will panic if `rhs` is zero.\n         ///\n         /// # Examples\n         ///\n@@ -2034,7 +2034,6 @@ macro_rules! uint_impl {\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline(always)]\n-        #[rustc_inherit_overflow_checks]\n         pub const fn div_floor(self, rhs: Self) -> Self {\n             self / rhs\n         }\n@@ -2043,7 +2042,12 @@ macro_rules! uint_impl {\n         ///\n         /// # Panics\n         ///\n-        /// This function will panic if `rhs` is 0.\n+        /// This function will panic if `rhs` is zero.\n+        ///\n+        /// ## Overflow behavior\n+        ///\n+        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n+        /// mode) and wrap if overflow checks are disabled (default in release mode).\n         ///\n         /// # Examples\n         ///\n@@ -2073,7 +2077,12 @@ macro_rules! uint_impl {\n         ///\n         /// # Panics\n         ///\n-        /// This function will panic if `rhs` is 0 or the operation results in overflow.\n+        /// This function will panic if `rhs` is zero.\n+        ///\n+        /// ## Overflow behavior\n+        ///\n+        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n+        /// mode) and wrap if overflow checks are disabled (default in release mode).\n         ///\n         /// # Examples\n         ///\n@@ -2097,7 +2106,7 @@ macro_rules! uint_impl {\n         }\n \n         /// Calculates the smallest value greater than or equal to `self` that\n-        /// is a multiple of `rhs`. Returns `None` is `rhs` is zero or the\n+        /// is a multiple of `rhs`. Returns `None` if `rhs` is zero or the\n         /// operation would result in overflow.\n         ///\n         /// # Examples\n@@ -2115,7 +2124,6 @@ macro_rules! uint_impl {\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n-        #[rustc_inherit_overflow_checks]\n         pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n             match try_opt!(self.checked_rem(rhs)) {\n                 0 => Some(self),"}, {"sha": "1ddd20f33d0b17cec89d08e393422cbb0dd0b5ce", "filename": "library/core/tests/num/i128.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Ftests%2Fnum%2Fi128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Ftests%2Fnum%2Fi128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fi128.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -1 +1 @@\n-int_module!(i128, i128);\n+int_module!(i128);"}, {"sha": "c7aa9fff964ede3deee081616195518c3e9e1232", "filename": "library/core/tests/num/i16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Ftests%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Ftests%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fi16.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -1 +1 @@\n-int_module!(i16, i16);\n+int_module!(i16);"}, {"sha": "efd5b1596a80d25e09d605e8f088ec8c34c94509", "filename": "library/core/tests/num/i32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Ftests%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Ftests%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fi32.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -1,4 +1,4 @@\n-int_module!(i32, i32);\n+int_module!(i32);\n \n #[test]\n fn test_arith_operation() {"}, {"sha": "93d23c10adf7e7fb3c5672a7addb81d39c02ed56", "filename": "library/core/tests/num/i64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Ftests%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Ftests%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fi64.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -1 +1 @@\n-int_module!(i64, i64);\n+int_module!(i64);"}, {"sha": "887d4f17d25ffd204d1e15ab5da12f2440b82ff9", "filename": "library/core/tests/num/i8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Ftests%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Ftests%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fi8.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -1 +1 @@\n-int_module!(i8, i8);\n+int_module!(i8);"}, {"sha": "8b84a78e6be08823a33a1abb9ad07f7724778d73", "filename": "library/core/tests/num/int_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Ftests%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Ftests%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fint_macros.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -1,9 +1,9 @@\n macro_rules! int_module {\n-    ($T:ident, $T_i:ident) => {\n+    ($T:ident) => {\n         #[cfg(test)]\n         mod tests {\n             use core::ops::{BitAnd, BitOr, BitXor, Not, Shl, Shr};\n-            use core::$T_i::*;\n+            use core::$T::*;\n \n             use crate::num;\n "}, {"sha": "a7b0f9effefb97f0431350b1bec9ca3875f7abd1", "filename": "library/core/tests/num/u128.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Ftests%2Fnum%2Fu128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Ftests%2Fnum%2Fu128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fu128.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -1 +1 @@\n-uint_module!(u128, u128);\n+uint_module!(u128);"}, {"sha": "010596a34a56cbce1ffe2f96ec065d073289e75c", "filename": "library/core/tests/num/u16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Ftests%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Ftests%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fu16.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -1 +1 @@\n-uint_module!(u16, u16);\n+uint_module!(u16);"}, {"sha": "687d3bbaa907ffe7e9da11e7edda52eee8447fda", "filename": "library/core/tests/num/u32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Ftests%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Ftests%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fu32.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -1 +1 @@\n-uint_module!(u32, u32);\n+uint_module!(u32);"}, {"sha": "ee55071e949960142d374cfd21b24a01f2201cdb", "filename": "library/core/tests/num/u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Ftests%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Ftests%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fu64.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -1 +1 @@\n-uint_module!(u64, u64);\n+uint_module!(u64);"}, {"sha": "12b038ce0f75cab97dceafa4f534eff2b4c06b20", "filename": "library/core/tests/num/u8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Ftests%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Ftests%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fu8.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -1 +1 @@\n-uint_module!(u8, u8);\n+uint_module!(u8);"}, {"sha": "93ae620c23302413da250988dd8b0592d8c19d8a", "filename": "library/core/tests/num/uint_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Ftests%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fcore%2Ftests%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fuint_macros.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -1,9 +1,9 @@\n macro_rules! uint_module {\n-    ($T:ident, $T_i:ident) => {\n+    ($T:ident) => {\n         #[cfg(test)]\n         mod tests {\n             use core::ops::{BitAnd, BitOr, BitXor, Not, Shl, Shr};\n-            use core::$T_i::*;\n+            use core::$T::*;\n             use std::str::FromStr;\n \n             use crate::num;"}, {"sha": "6f7c6305afc14ec91e1be195cd68c6f4dc3a1735", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -703,11 +703,12 @@ pub enum Delimiter {\n     /// `[ ... ]`\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     Bracket,\n-    /// `\u00d8 ... \u00d8`\n+    /// `/*\u00ab*/ ... /*\u00bb*/`\n     /// An invisible delimiter, that may, for example, appear around tokens coming from a\n     /// \"macro variable\" `$var`. It is important to preserve operator priorities in cases like\n     /// `$var * 3` where `$var` is `1 + 2`.\n-    /// Invisible delimiters might not survive roundtrip of a token stream through a string.\n+    /// Invisible delimiters are not directly writable in normal Rust code except as comments.\n+    /// Therefore, they might not survive a roundtrip of a token stream through a string.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     None,\n }"}, {"sha": "667f89c07e212b0a094bc33534ede07c83bc0d6b", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -7,6 +7,8 @@\n /* global onEach, onEachLazy, removeClass */\n /* global switchTheme, useSystemTheme */\n \n+\"use strict\";\n+\n if (!String.prototype.startsWith) {\n     String.prototype.startsWith = function(searchString, position) {\n         position = position || 0;\n@@ -292,15 +294,12 @@ function loadCss(cssFileName) {\n }\n \n (function() {\n-    \"use strict\";\n-\n     function loadScript(url) {\n         const script = document.createElement('script');\n         script.src = url;\n         document.head.append(script);\n     }\n \n-\n     getSettingsButton().onclick = event => {\n         event.preventDefault();\n         loadScript(window.settingsJS);"}, {"sha": "70fcef522129eabc7b03d71ab5939759b3bab302", "filename": "src/librustdoc/html/static/js/scrape-examples.js", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fscrape-examples.js", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fscrape-examples.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fscrape-examples.js?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -4,6 +4,8 @@\n /* eslint prefer-arrow-callback: \"error\" */\n /* global addClass, hasClass, removeClass, onEachLazy */\n \n+\"use strict\";\n+\n (function () {\n     // Number of lines shown when code viewer is not expanded\n     const MAX_LINES = 10;"}, {"sha": "54ce2508c468d7132958031d1beb0be7392e87c4", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -5,7 +5,9 @@\n /* global addClass, getNakedUrl, getSettingValue, hasOwnPropertyRustdoc, initSearch, onEach */\n /* global onEachLazy, removeClass, searchState, browserSupportsHistoryApi */\n \n-(function () {\n+\"use strict\";\n+\n+(function() {\n // This mapping table should match the discriminants of\n // `rustdoc::formats::item_type::ItemType` type in Rust.\n const itemTypes = ["}, {"sha": "119d4b07665a4ea416c6bfb8ddff9c41222d91c5", "filename": "src/librustdoc/html/static/js/settings.js", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -7,6 +7,8 @@\n /* global addClass, removeClass, onEach, onEachLazy, NOT_DISPLAYED_ID */\n /* global MAIN_ID, getVar, getSettingsButton, switchDisplayedElement, getNotDisplayedElem */\n \n+\"use strict\";\n+\n (function () {\n     const isSettingsPage = window.location.pathname.endsWith(\"/settings.html\");\n "}, {"sha": "f788d41d2ded4a1290f89302e465d895536d76e1", "filename": "src/librustdoc/html/static/js/source-script.js", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsource-script.js", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsource-script.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsource-script.js?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -9,7 +9,10 @@\n // Local js definitions:\n /* global addClass, getCurrentValue, hasClass, onEachLazy, removeClass, browserSupportsHistoryApi */\n /* global updateLocalStorage */\n-(function () {\n+\n+\"use strict\";\n+\n+(function() {\n \n function getCurrentFilePath() {\n     const parts = window.location.pathname.split(\"/\");"}, {"sha": "052731e99aed28c452e8b18e8750543e64c1bcc3", "filename": "src/librustdoc/html/static/js/storage.js", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fstorage.js", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fstorage.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fstorage.js?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -3,6 +3,8 @@\n /* eslint prefer-const: \"error\" */\n /* eslint prefer-arrow-callback: \"error\" */\n \n+\"use strict\";\n+\n const darkThemes = [\"dark\", \"ayu\"];\n window.currentTheme = document.getElementById(\"themeStyle\");\n window.mainTheme = document.getElementById(\"mainThemeStyle\");"}, {"sha": "a2e30e2e93b5a63f009dccf6280be1cc887cdd34", "filename": "src/test/ui/proc-macro/auxiliary/expand-expr.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fexpand-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fexpand-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fexpand-expr.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -12,6 +12,15 @@ use std::str::FromStr;\n \n #[proc_macro]\n pub fn expand_expr_is(input: TokenStream) -> TokenStream {\n+    expand_expr_is_inner(input, false)\n+}\n+\n+#[proc_macro]\n+pub fn expand_expr_is_trim(input: TokenStream) -> TokenStream {\n+    expand_expr_is_inner(input, true)\n+}\n+\n+fn expand_expr_is_inner(input: TokenStream, trim_invisible: bool) -> TokenStream {\n     let mut iter = input.into_iter();\n     let mut expected_tts = Vec::new();\n     loop {\n@@ -22,14 +31,18 @@ pub fn expand_expr_is(input: TokenStream) -> TokenStream {\n         }\n     }\n \n-    let expected = expected_tts.into_iter().collect::<TokenStream>();\n-    let expanded = iter.collect::<TokenStream>().expand_expr().expect(\"expand_expr failed\");\n-    assert!(\n-        expected.to_string() == expanded.to_string(),\n-        \"assert failed\\nexpected: `{}`\\nexpanded: `{}`\",\n-        expected.to_string(),\n-        expanded.to_string()\n-    );\n+    // If requested, trim the \"invisible\" delimiters at the start and end.\n+    let expected = expected_tts.into_iter().collect::<TokenStream>().to_string();\n+    let expected = if trim_invisible {\n+        let len1 = \"/*\u00ab*/ \".len();\n+        let len2 = \" /*\u00bb*/\".len();\n+        &expected[len1..expected.len() - len2]\n+    } else {\n+        &expected[..]\n+    };\n+    let expanded = iter.collect::<TokenStream>().expand_expr().unwrap().to_string();\n+\n+    assert_eq!(expected, expanded);\n \n     TokenStream::new()\n }"}, {"sha": "3d0e7eaff00d853f5356582cf0bbb7152163f839", "filename": "src/test/ui/proc-macro/capture-macro-rules-invoke.stdout", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fcapture-macro-rules-invoke.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fcapture-macro-rules-invoke.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fcapture-macro-rules-invoke.stdout?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -1,4 +1,5 @@\n PRINT-BANG INPUT (DISPLAY): self\n+PRINT-BANG RE-COLLECTED (DISPLAY): /*\u00ab*/ self /*\u00bb*/\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Group {\n         delimiter: None,\n@@ -13,8 +14,10 @@ PRINT-BANG INPUT (DEBUG): TokenStream [\n ]\n PRINT-BANG INPUT (DISPLAY): 1 + 1, { \"a\" }, let a = 1;, String, my_name, 'a, my_val = 30,\n std::option::Option, pub(in some::path) , [a b c], -30\n-PRINT-BANG RE-COLLECTED (DISPLAY): 1 + 1, { \"a\" }, let a = 1, String, my_name, 'a, my_val = 30,\n-std :: option :: Option, pub(in some :: path), [a b c], - 30\n+PRINT-BANG RE-COLLECTED (DISPLAY): /*\u00ab*/ 1 + 1 /*\u00bb*/, /*\u00ab*/ { \"a\" } /*\u00bb*/, /*\u00ab*/ let a = 1 /*\u00bb*/, /*\u00ab*/\n+String /*\u00bb*/, my_name, /*\u00ab*/ 'a /*\u00bb*/, /*\u00ab*/ my_val = 30 /*\u00bb*/, /*\u00ab*/\n+std :: option :: Option /*\u00bb*/, /*\u00ab*/ pub(in some :: path) /*\u00bb*/, [a b c],\n+/*\u00ab*/ - 30 /*\u00bb*/\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Group {\n         delimiter: None,\n@@ -295,6 +298,7 @@ PRINT-BANG INPUT (DEBUG): TokenStream [\n     },\n ]\n PRINT-BANG INPUT (DISPLAY): (a, b)\n+PRINT-BANG RE-COLLECTED (DISPLAY): /*\u00ab*/ (a, b) /*\u00bb*/\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Group {\n         delimiter: None,"}, {"sha": "5fe6ff72b4544a93276baf6f8054cd9f6892b822", "filename": "src/test/ui/proc-macro/capture-unglued-token.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fcapture-unglued-token.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fcapture-unglued-token.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fcapture-unglued-token.stdout?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -1,5 +1,5 @@\n PRINT-BANG INPUT (DISPLAY): Vec<u8>\n-PRINT-BANG RE-COLLECTED (DISPLAY): Vec < u8 >\n+PRINT-BANG RE-COLLECTED (DISPLAY): /*\u00ab*/ Vec < u8 > /*\u00bb*/\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Group {\n         delimiter: None,"}, {"sha": "edcb30f892cdf0b359018eccd74bee28a87643f5", "filename": "src/test/ui/proc-macro/expand-expr.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-expr.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -2,9 +2,9 @@\n \n extern crate expand_expr;\n \n-use expand_expr::{\n-    check_expand_expr_file, echo_pm, expand_expr_fail, expand_expr_is, recursive_expand,\n-};\n+use expand_expr::{check_expand_expr_file, echo_pm, expand_expr_fail, expand_expr_is};\n+use expand_expr::{expand_expr_is_trim, recursive_expand};\n+\n \n // Check builtin macros can be expanded.\n \n@@ -47,21 +47,21 @@ macro_rules! echo_expr {\n \n macro_rules! simple_lit {\n     ($l:literal) => {\n-        expand_expr_is!($l, $l);\n-        expand_expr_is!($l, echo_lit!($l));\n-        expand_expr_is!($l, echo_expr!($l));\n-        expand_expr_is!($l, echo_tts!($l));\n-        expand_expr_is!($l, echo_pm!($l));\n+        expand_expr_is_trim!($l, $l);\n+        expand_expr_is_trim!($l, echo_lit!($l));\n+        expand_expr_is_trim!($l, echo_expr!($l));\n+        expand_expr_is_trim!($l, echo_tts!($l));\n+        expand_expr_is_trim!($l, echo_pm!($l));\n         const _: () = {\n             macro_rules! mac {\n                 () => {\n                     $l\n                 };\n             }\n-            expand_expr_is!($l, mac!());\n-            expand_expr_is!($l, echo_expr!(mac!()));\n-            expand_expr_is!($l, echo_tts!(mac!()));\n-            expand_expr_is!($l, echo_pm!(mac!()));\n+            expand_expr_is_trim!($l, mac!());\n+            expand_expr_is_trim!($l, echo_expr!(mac!()));\n+            expand_expr_is_trim!($l, echo_tts!(mac!()));\n+            expand_expr_is_trim!($l, echo_pm!(mac!()));\n         };\n     };\n }"}, {"sha": "04b516fd254243550031cc841af0047137c05c87", "filename": "src/test/ui/proc-macro/expr-stmt-nonterminal-tokens.stdout", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fexpr-stmt-nonterminal-tokens.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fexpr-stmt-nonterminal-tokens.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fexpr-stmt-nonterminal-tokens.stdout?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -1,5 +1,6 @@\n PRINT-DERIVE INPUT (DISPLAY): enum E { V = { let _ = #[allow(warnings)] 0 ; 0 }, }\n-PRINT-DERIVE DEEP-RE-COLLECTED (DISPLAY): enum E { V = { let _ = #[allow(warnings)] #[allow(warnings)] 0 ; 0 }, }\n+PRINT-DERIVE DEEP-RE-COLLECTED (DISPLAY): enum E\n+{ V = { let _ = /*\u00ab*/ #[allow(warnings)] #[allow(warnings)] 0 /*\u00bb*/ ; 0 }, }\n PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"enum\",\n@@ -123,7 +124,7 @@ PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     },\n ]\n PRINT-DERIVE INPUT (DISPLAY): enum E { V = { let _ = { 0; } ; 0 }, }\n-PRINT-DERIVE DEEP-RE-COLLECTED (DISPLAY): enum E { V = { let _ = { 0 } ; 0 }, }\n+PRINT-DERIVE DEEP-RE-COLLECTED (DISPLAY): enum E { V = { let _ = { /*\u00ab*/ 0 /*\u00bb*/ } ; 0 }, }\n PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"enum\",\n@@ -203,6 +204,7 @@ PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     },\n ]\n PRINT-DERIVE INPUT (DISPLAY): enum E { V = { let _ = { {} } ; 0 }, }\n+PRINT-DERIVE DEEP-RE-COLLECTED (DISPLAY): enum E { V = { let _ = { /*\u00ab*/ {} /*\u00bb*/ } ; 0 }, }\n PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"enum\",\n@@ -281,7 +283,7 @@ PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     },\n ]\n PRINT-DERIVE INPUT (DISPLAY): enum E { V = { let _ = { PATH; } ; 0 }, }\n-PRINT-DERIVE DEEP-RE-COLLECTED (DISPLAY): enum E { V = { let _ = { PATH } ; 0 }, }\n+PRINT-DERIVE DEEP-RE-COLLECTED (DISPLAY): enum E { V = { let _ = { /*\u00ab*/ PATH /*\u00bb*/ } ; 0 }, }\n PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"enum\",\n@@ -359,7 +361,7 @@ PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     },\n ]\n PRINT-DERIVE INPUT (DISPLAY): enum E { V = { let _ = { 0 + 1; } ; 0 }, }\n-PRINT-DERIVE DEEP-RE-COLLECTED (DISPLAY): enum E { V = { let _ = { 0 + 1 } ; 0 }, }\n+PRINT-DERIVE DEEP-RE-COLLECTED (DISPLAY): enum E { V = { let _ = { /*\u00ab*/ 0 + 1 /*\u00bb*/ } ; 0 }, }\n PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"enum\",\n@@ -450,7 +452,7 @@ PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     },\n ]\n PRINT-DERIVE INPUT (DISPLAY): enum E { V = { let _ = { PATH + 1; } ; 0 }, }\n-PRINT-DERIVE DEEP-RE-COLLECTED (DISPLAY): enum E { V = { let _ = { PATH + 1 } ; 0 }, }\n+PRINT-DERIVE DEEP-RE-COLLECTED (DISPLAY): enum E { V = { let _ = { /*\u00ab*/ PATH + 1 /*\u00bb*/ } ; 0 }, }\n PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"enum\","}, {"sha": "55818969c71781c5829b4f67fac0e49d858bed54", "filename": "src/test/ui/proc-macro/issue-75734-pp-paren.stdout", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fissue-75734-pp-paren.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fissue-75734-pp-paren.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-75734-pp-paren.stdout?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -96,6 +96,7 @@ PRINT-ATTR INPUT (DEBUG): TokenStream [\n     },\n ]\n PRINT-BANG INPUT (DISPLAY): 1 + 1 * 2\n+PRINT-BANG RE-COLLECTED (DISPLAY): /*\u00ab*/ 1 + 1 /*\u00bb*/ * 2\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Group {\n         delimiter: None,"}, {"sha": "6cf8043c34f81fd95307d67482e54782877994af", "filename": "src/test/ui/proc-macro/issue-78675-captured-inner-attrs.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fissue-78675-captured-inner-attrs.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fissue-78675-captured-inner-attrs.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-78675-captured-inner-attrs.stdout?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -1,7 +1,7 @@\n PRINT-BANG INPUT (DISPLAY): foo! { #[fake_attr] mod bar {\n     #![doc = r\" Foo\"]\n } }\n-PRINT-BANG DEEP-RE-COLLECTED (DISPLAY): foo! { #[fake_attr] mod bar { #! [doc = r\" Foo\"] } }\n+PRINT-BANG DEEP-RE-COLLECTED (DISPLAY): foo! { #[fake_attr] /*\u00ab*/ mod bar { #! [doc = r\" Foo\"] } /*\u00bb*/ }\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"foo\","}, {"sha": "adbd653ead4b7e5ddc1b35c455a4bd0caa8ebf66", "filename": "src/test/ui/proc-macro/issue-80760-empty-stmt.stdout", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fissue-80760-empty-stmt.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fissue-80760-empty-stmt.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-80760-empty-stmt.stdout?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -1,4 +1,5 @@\n PRINT-BANG INPUT (DISPLAY): ;\n+PRINT-BANG RE-COLLECTED (DISPLAY): /*\u00ab*/ ; /*\u00bb*/\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Group {\n         delimiter: None,"}, {"sha": "b912e426d5d993869e647655e92a68158af3a0da", "filename": "src/test/ui/proc-macro/nested-nonterminal-tokens.stdout", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fnested-nonterminal-tokens.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fnested-nonterminal-tokens.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnested-nonterminal-tokens.stdout?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -1,4 +1,6 @@\n PRINT-BANG INPUT (DISPLAY): 0 + 1 + 2 + 3\n+PRINT-BANG RE-COLLECTED (DISPLAY): /*\u00ab*/ 0 + 1 + 2 /*\u00bb*/ + 3\n+PRINT-BANG DEEP-RE-COLLECTED (DISPLAY): /*\u00ab*/ /*\u00ab*/ /*\u00ab*/ 0 /*\u00bb*/ + 1 /*\u00bb*/ + 2 /*\u00bb*/ + 3\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Group {\n         delimiter: None,"}, {"sha": "0d2f33b41750d1401c43e0d76dbd7c98d1e58ca8", "filename": "src/test/ui/proc-macro/nodelim-groups.stdout", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fnodelim-groups.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fnodelim-groups.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnodelim-groups.stdout?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -1,4 +1,5 @@\n PRINT-BANG INPUT (DISPLAY): \"hi\" 1 + (25) + 1 (1 + 1)\n+PRINT-BANG RE-COLLECTED (DISPLAY): \"hi\" /*\u00ab*/ 1 + (25) + 1 /*\u00bb*/ (1 + 1)\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Literal {\n         kind: Str,\n@@ -71,6 +72,9 @@ PRINT-BANG INPUT (DEBUG): TokenStream [\n     },\n ]\n PRINT-BANG INPUT (DISPLAY): \"hi\" \"hello\".len() + \"world\".len() (1 + 1)\n+PRINT-BANG RE-COLLECTED (DISPLAY): \"hi\" /*\u00ab*/ \"hello\".len() + \"world\".len() /*\u00bb*/ (1 + 1)\n+PRINT-BANG DEEP-RE-COLLECTED (DISPLAY): \"hi\" /*\u00ab*/ /*\u00ab*/ \"hello\".len() /*\u00bb*/ + /*\u00ab*/ \"world\".len() /*\u00bb*/ /*\u00bb*/\n+(1 + 1)\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Literal {\n         kind: Str,"}, {"sha": "32981e7011d970a7182718fe542bb120067c1247", "filename": "src/test/ui/proc-macro/nonterminal-expansion.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-expansion.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-expansion.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-expansion.stdout?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -1,5 +1,5 @@\n PRINT-ATTR_ARGS INPUT (DISPLAY): a, line!(), b\n-PRINT-ATTR_ARGS RE-COLLECTED (DISPLAY): a, line! (), b\n+PRINT-ATTR_ARGS RE-COLLECTED (DISPLAY): a, /*\u00ab*/ line! () /*\u00bb*/, b\n PRINT-ATTR_ARGS INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"a\","}, {"sha": "ba18ca75d7fe4dc2743da1d8cfda7d9390f7b377", "filename": "src/test/ui/proc-macro/nonterminal-token-hygiene.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-token-hygiene.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-token-hygiene.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-token-hygiene.stdout?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -1,5 +1,5 @@\n PRINT-BANG INPUT (DISPLAY): struct S;\n-PRINT-BANG RE-COLLECTED (DISPLAY): struct S ;\n+PRINT-BANG RE-COLLECTED (DISPLAY): /*\u00ab*/ struct S ; /*\u00bb*/\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Group {\n         delimiter: None,"}, {"sha": "71e5065a87a8888c63c19e433bc597cb38c55cc9", "filename": "src/test/ui/proc-macro/parent-source-spans.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fparent-source-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fparent-source-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fparent-source-spans.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -8,16 +8,16 @@ use parent_source_spans::parent_source_spans;\n \n macro one($a:expr, $b:expr) {\n     two!($a, $b);\n-    //~^ ERROR first parent: \"hello\"\n-    //~| ERROR second parent: \"world\"\n+    //~^ ERROR first parent: /*\u00ab*/ \"hello\" /*\u00bb*/\n+    //~| ERROR second parent: /*\u00ab*/ \"world\" /*\u00bb*/\n }\n \n macro two($a:expr, $b:expr) {\n     three!($a, $b);\n-    //~^ ERROR first final: \"hello\"\n-    //~| ERROR second final: \"world\"\n-    //~| ERROR first final: \"yay\"\n-    //~| ERROR second final: \"rust\"\n+    //~^ ERROR first final: /*\u00ab*/ \"hello\" /*\u00bb*/\n+    //~| ERROR second final: /*\u00ab*/ \"world\" /*\u00bb*/\n+    //~| ERROR first final: /*\u00ab*/ \"yay\" /*\u00bb*/\n+    //~| ERROR second final: /*\u00ab*/ \"rust\" /*\u00bb*/\n }\n \n // forwarding tokens directly doesn't create a new source chain\n@@ -34,16 +34,16 @@ macro four($($tokens:tt)*) {\n \n fn main() {\n     one!(\"hello\", \"world\");\n-    //~^ ERROR first grandparent: \"hello\"\n-    //~| ERROR second grandparent: \"world\"\n-    //~| ERROR first source: \"hello\"\n-    //~| ERROR second source: \"world\"\n+    //~^ ERROR first grandparent: /*\u00ab*/ \"hello\" /*\u00bb*/\n+    //~| ERROR second grandparent: /*\u00ab*/ \"world\" /*\u00bb*/\n+    //~| ERROR first source: /*\u00ab*/ \"hello\" /*\u00bb*/\n+    //~| ERROR second source: /*\u00ab*/ \"world\" /*\u00bb*/\n \n     two!(\"yay\", \"rust\");\n-    //~^ ERROR first parent: \"yay\"\n-    //~| ERROR second parent: \"rust\"\n-    //~| ERROR first source: \"yay\"\n-    //~| ERROR second source: \"rust\"\n+    //~^ ERROR first parent: /*\u00ab*/ \"yay\" /*\u00bb*/\n+    //~| ERROR second parent: /*\u00ab*/ \"rust\" /*\u00bb*/\n+    //~| ERROR first source: /*\u00ab*/ \"yay\" /*\u00bb*/\n+    //~| ERROR second source: /*\u00ab*/ \"rust\" /*\u00bb*/\n \n     three!(\"hip\", \"hop\");\n     //~^ ERROR first final: \"hip\""}, {"sha": "e42218ea70117b3ed05144b789e5bcf044618870", "filename": "src/test/ui/proc-macro/parent-source-spans.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fparent-source-spans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fproc-macro%2Fparent-source-spans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fparent-source-spans.stderr?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -1,4 +1,4 @@\n-error: first final: \"hello\"\n+error: first final: /*\u00ab*/ \"hello\" /*\u00bb*/\n   --> $DIR/parent-source-spans.rs:16:12\n    |\n LL |     three!($a, $b);\n@@ -9,7 +9,7 @@ LL |     one!(\"hello\", \"world\");\n    |\n    = note: this error originates in the macro `two` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: second final: \"world\"\n+error: second final: /*\u00ab*/ \"world\" /*\u00bb*/\n   --> $DIR/parent-source-spans.rs:16:16\n    |\n LL |     three!($a, $b);\n@@ -20,7 +20,7 @@ LL |     one!(\"hello\", \"world\");\n    |\n    = note: this error originates in the macro `two` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: first parent: \"hello\"\n+error: first parent: /*\u00ab*/ \"hello\" /*\u00bb*/\n   --> $DIR/parent-source-spans.rs:10:5\n    |\n LL |     two!($a, $b);\n@@ -31,7 +31,7 @@ LL |     one!(\"hello\", \"world\");\n    |\n    = note: this error originates in the macro `one` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: second parent: \"world\"\n+error: second parent: /*\u00ab*/ \"world\" /*\u00bb*/\n   --> $DIR/parent-source-spans.rs:10:5\n    |\n LL |     two!($a, $b);\n@@ -42,31 +42,31 @@ LL |     one!(\"hello\", \"world\");\n    |\n    = note: this error originates in the macro `one` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: first grandparent: \"hello\"\n+error: first grandparent: /*\u00ab*/ \"hello\" /*\u00bb*/\n   --> $DIR/parent-source-spans.rs:36:5\n    |\n LL |     one!(\"hello\", \"world\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: second grandparent: \"world\"\n+error: second grandparent: /*\u00ab*/ \"world\" /*\u00bb*/\n   --> $DIR/parent-source-spans.rs:36:5\n    |\n LL |     one!(\"hello\", \"world\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: first source: \"hello\"\n+error: first source: /*\u00ab*/ \"hello\" /*\u00bb*/\n   --> $DIR/parent-source-spans.rs:36:5\n    |\n LL |     one!(\"hello\", \"world\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: second source: \"world\"\n+error: second source: /*\u00ab*/ \"world\" /*\u00bb*/\n   --> $DIR/parent-source-spans.rs:36:5\n    |\n LL |     one!(\"hello\", \"world\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: first final: \"yay\"\n+error: first final: /*\u00ab*/ \"yay\" /*\u00bb*/\n   --> $DIR/parent-source-spans.rs:16:12\n    |\n LL |     three!($a, $b);\n@@ -77,7 +77,7 @@ LL |     two!(\"yay\", \"rust\");\n    |\n    = note: this error originates in the macro `two` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: second final: \"rust\"\n+error: second final: /*\u00ab*/ \"rust\" /*\u00bb*/\n   --> $DIR/parent-source-spans.rs:16:16\n    |\n LL |     three!($a, $b);\n@@ -88,25 +88,25 @@ LL |     two!(\"yay\", \"rust\");\n    |\n    = note: this error originates in the macro `two` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: first parent: \"yay\"\n+error: first parent: /*\u00ab*/ \"yay\" /*\u00bb*/\n   --> $DIR/parent-source-spans.rs:42:5\n    |\n LL |     two!(\"yay\", \"rust\");\n    |     ^^^^^^^^^^^^^^^^^^^\n \n-error: second parent: \"rust\"\n+error: second parent: /*\u00ab*/ \"rust\" /*\u00bb*/\n   --> $DIR/parent-source-spans.rs:42:5\n    |\n LL |     two!(\"yay\", \"rust\");\n    |     ^^^^^^^^^^^^^^^^^^^\n \n-error: first source: \"yay\"\n+error: first source: /*\u00ab*/ \"yay\" /*\u00bb*/\n   --> $DIR/parent-source-spans.rs:42:5\n    |\n LL |     two!(\"yay\", \"rust\");\n    |     ^^^^^^^^^^^^^^^^^^^\n \n-error: second source: \"rust\"\n+error: second source: /*\u00ab*/ \"rust\" /*\u00bb*/\n   --> $DIR/parent-source-spans.rs:42:5\n    |\n LL |     two!(\"yay\", \"rust\");"}, {"sha": "b8d528efc15909eaf42223a3153e7c4cf8205898", "filename": "src/test/ui/resolve/issue-2356.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fresolve%2Fissue-2356.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fresolve%2Fissue-2356.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-2356.stderr?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -48,6 +48,11 @@ error[E0425]: cannot find function `static_method` in this scope\n    |\n LL |         static_method();\n    |         ^^^^^^^^^^^^^ not found in this scope\n+   |\n+help: consider using the associated function\n+   |\n+LL |         Self::static_method();\n+   |         ~~~~~~~~~~~~~~~~~~~\n \n error[E0425]: cannot find function `purr` in this scope\n   --> $DIR/issue-2356.rs:54:9\n@@ -85,6 +90,11 @@ error[E0425]: cannot find function `grow_older` in this scope\n    |\n LL |     grow_older();\n    |     ^^^^^^^^^^ not found in this scope\n+   |\n+help: consider using the associated function\n+   |\n+LL |     Self::grow_older();\n+   |     ~~~~~~~~~~~~~~~~\n \n error[E0425]: cannot find function `shave` in this scope\n   --> $DIR/issue-2356.rs:74:5"}, {"sha": "778d9847773f35633b4db608c914835434c1ae11", "filename": "src/test/ui/suggestions/assoc_fn_without_self.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fsuggestions%2Fassoc_fn_without_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fsuggestions%2Fassoc_fn_without_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fassoc_fn_without_self.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -0,0 +1,20 @@\n+fn main() {}\n+\n+struct S;\n+\n+impl S {\n+    fn foo() {}\n+\n+    fn bar(&self) {}\n+\n+    fn baz(a: u8, b: u8) {}\n+\n+    fn b() {\n+        fn c() {\n+            foo(); //~ ERROR cannot find function `foo` in this scope\n+        }\n+        foo(); //~ ERROR cannot find function `foo` in this scope\n+        bar(); //~ ERROR cannot find function `bar` in this scope\n+        baz(2, 3); //~ ERROR cannot find function `baz` in this scope\n+    }\n+}"}, {"sha": "4a0e62e73093b564c7c70a612e271dcc5d78c1ee", "filename": "src/test/ui/suggestions/assoc_fn_without_self.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fsuggestions%2Fassoc_fn_without_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Fsuggestions%2Fassoc_fn_without_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fassoc_fn_without_self.stderr?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -0,0 +1,37 @@\n+error[E0425]: cannot find function `foo` in this scope\n+  --> $DIR/assoc_fn_without_self.rs:14:13\n+   |\n+LL |             foo();\n+   |             ^^^ not found in this scope\n+\n+error[E0425]: cannot find function `foo` in this scope\n+  --> $DIR/assoc_fn_without_self.rs:16:9\n+   |\n+LL |         foo();\n+   |         ^^^ not found in this scope\n+   |\n+help: consider using the associated function\n+   |\n+LL |         Self::foo();\n+   |         ~~~~~~~~~\n+\n+error[E0425]: cannot find function `bar` in this scope\n+  --> $DIR/assoc_fn_without_self.rs:17:9\n+   |\n+LL |         bar();\n+   |         ^^^ not found in this scope\n+\n+error[E0425]: cannot find function `baz` in this scope\n+  --> $DIR/assoc_fn_without_self.rs:18:9\n+   |\n+LL |         baz(2, 3);\n+   |         ^^^ not found in this scope\n+   |\n+help: consider using the associated function\n+   |\n+LL |         Self::baz(2, 3);\n+   |         ~~~~~~~~~\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "98ac215ad6cc53f6b7a280eb71df97f57e35cffd", "filename": "src/test/ui/type-alias-impl-trait/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.rs?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -12,6 +12,6 @@ fn use_alias<T>(val: T) -> AliasOfForeignType<T> {\n }\n \n impl<T> foreign_crate::ForeignTrait for AliasOfForeignType<T> {}\n-//~^ ERROR the type parameter `T` is not constrained by the impl trait, self type, or predicates\n+//~^ ERROR cannot implement trait on type alias impl trait\n \n fn main() {}"}, {"sha": "3ce25d94f6e124b832d7d0e97a697f083b351831", "filename": "src/test/ui/type-alias-impl-trait/coherence.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50cf76c24bf6f266ca6d253af82a6cabadcad0f5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr?ref=50cf76c24bf6f266ca6d253af82a6cabadcad0f5", "patch": "@@ -1,9 +1,14 @@\n-error[E0207]: the type parameter `T` is not constrained by the impl trait, self type, or predicates\n-  --> $DIR/coherence.rs:14:6\n+error: cannot implement trait on type alias impl trait\n+  --> $DIR/coherence.rs:14:41\n    |\n LL | impl<T> foreign_crate::ForeignTrait for AliasOfForeignType<T> {}\n-   |      ^ unconstrained type parameter\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: type alias impl trait defined here\n+  --> $DIR/coherence.rs:9:30\n+   |\n+LL | type AliasOfForeignType<T> = impl LocalTrait;\n+   |                              ^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0207`."}]}